{"task_id": "CPP/1", "prompt": {"en": "#include <bits/stdc++.h>\nusing namespace std;\n// Return \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"\nstring f_1()", "sq": "#include <bits/stdc++.h>\nusing namespace std;\n// Kthen \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"\nstring f_1()", "hy": "#include <bits/stdc++.h>\nusing namespace std;\n// Վերադարձնել \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"\nstring f_1()", "bn": "#include <bits/stdc++.h>\nusing namespace std;\n// \"Hello, Mass-McEval: massively scaled multilingual code evaluation\" ফেরত দিন\nstring f_1()", "bg": "#include <bits/stdc++.h>\nusing namespace std;\n// Връща \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"\nstring f_1()", "zh": "#include <bits/stdc++.h>\nusing namespace std;\n// 返回 \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"\nstring f_1()", "fr": "#include <bits/stdc++.h>\nusing namespace std;\n// Retourne \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"\nstring f_1()", "de": "#include <bits/stdc++.h>\nusing namespace std;\n// Gibt \"Hello, Mass-McEval: massively scaled multilingual code evaluation\" zurück\nstring f_1()", "ha": "#include <bits/stdc++.h>\nusing namespace std;\n// Mayar da \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"\nstring f_1()", "hi": "#include <bits/stdc++.h>\nusing namespace std;\n// \"Hello, Mass-McEval: massively scaled multilingual code evaluation\" लौटाएं\nstring f_1()", "hu": "#include <bits/stdc++.h>\nusing namespace std;\n// Adja vissza a \"Hello, Mass-McEval: massively scaled multilingual code evaluation\" szöveget\nstring f_1()", "es": "#include <bits/stdc++.h>\nusing namespace std;\n// Devuelve \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"\nstring f_1()", "arb": "#include <bits/stdc++.h>\nusing namespace std;\n// إرجاع \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"\nstring f_1()", "sw": "#include <bits/stdc++.h>\nusing namespace std;\n// Rudisha \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"\nstring f_1()", "tr": "#include <bits/stdc++.h>\nusing namespace std;\n// \"Hello, Mass-McEval: massively scaled multilingual code evaluation\" döndür\nstring f_1()", "vi": "#include <bits/stdc++.h>\nusing namespace std;\n// Trả về \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"\nstring f_1()", "id": "#include <bits/stdc++.h>\nusing namespace std;\n// Mengembalikan \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"\nstring f_1()", "ja": "#include <bits/stdc++.h>\nusing namespace std;\n// \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"を返す\nstring f_1()", "ko": "#include <bits/stdc++.h>\nusing namespace std;\n// \"Hello, Mass-McEval: massively scaled multilingual code evaluation\" 반환\nstring f_1()\n", "ml": "#include <bits/stdc++.h>\nusing namespace std;\n// \"Hello, Mass-McEval: massively scaled multilingual code evaluation\" എന്നത് തിരികെ നൽകുക\nstring f_1()", "fa": "#include <bits/stdc++.h>\nusing namespace std;\n// بازگرداندن \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"\nstring f_1()"}, "canonical_solution": "{\n    return \"Hello, Mass-McEval: massively scaled multilingual code evaluation\";\n}", "instruction": {"en": "string f_1()\n{\n    return \"Hello, Mass-McEval: massively scaled multilingual code evaluation\";\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.", "sq": "string f_1()\n{\n    return \"Hello, Mass-McEval: massively scaled multilingual code evaluation\";\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit CPP në shqip duke përdorur maksimumi 500 karaktere.", "hy": "string f_1()\n{\n    return \"Hello, Mass-McEval: massively scaled multilingual code evaluation\";\n}\n\nՏվեք CPP կոդի համառոտ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "string f_1()\n{\n    return \"Hello, Mass-McEval: massively scaled multilingual code evaluation\";\n}\n\nসিপিপি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।", "bg": "string f_1()\n{\n    return \"Hello, Mass-McEval: massively scaled multilingual code evaluation\";\n}\n\nПредоставете кратко описание на CPP кода на естествен език (docstring) на български, използвайки най-много 500 знака.", "zh": "string f_1()\n{\n    return \"Hello, Mass-McEval: massively scaled multilingual code evaluation\";\n}\n\n请用最多500个字符的中文对该CPP代码提供简洁的自然语言描述（文档字符串）。", "fr": "string f_1()\n{\n    return \"Hello, Mass-McEval: massively scaled multilingual code evaluation\";\n}\n\nFournissez une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.", "de": "string f_1()\n{\n    return \"Hello, Mass-McEval: massively scaled multilingual code evaluation\";\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen.", "ha": "string f_1()\n{\n    return \"Hello, Mass-McEval: massively scaled multilingual code evaluation\";\n}\n\nBa da taƙaitaccen bayani a cikin yaren halitta (docstring) na lambar CPP a cikin Hausa ta amfani da haruffa 500 kawai.", "hi": "string f_1()\n{\n    return \"Hello, Mass-McEval: massively scaled multilingual code evaluation\";\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।", "hu": "string f_1()\n{\n    return \"Hello, Mass-McEval: massively scaled multilingual code evaluation\";\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a CPP kódról magyarul, legfeljebb 500 karakterben.", "es": "string f_1()\n{\n    return \"Hello, Mass-McEval: massively scaled multilingual code evaluation\";\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando como máximo 500 caracteres.", "arb": "string f_1()\n{\n    return \"Hello, Mass-McEval: massively scaled multilingual code evaluation\";\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C++ باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "string f_1()\n{\n    return \"Hello, Mass-McEval: massively scaled multilingual code evaluation\";\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "string f_1()\n{\n    return \"Hello, Mass-McEval: massively scaled multilingual code evaluation\";\n}\n\nAşağıdaki CPP kodunun Türkçe olarak en fazla 500 karakter kullanarak özlü bir doğal dil açıklamasını (docstring) sağlayın.", "vi": "string f_1()\n{\n    return \"Hello, Mass-McEval: massively scaled multilingual code evaluation\";\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự.", "id": "string f_1()\n{\n    return \"Hello, Mass-McEval: massively scaled multilingual code evaluation\";\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode CPP dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "string f_1()\n{\n    return \"Hello, Mass-McEval: massively scaled multilingual code evaluation\";\n}\n\n以下のCPPコードの自然言語による簡潔な説明（ドックストリング）を日本語で500文字以内で提供してください。", "ko": "string f_1()\n{\n    return \"Hello, Mass-McEval: massively scaled multilingual code evaluation\";\n}\n\n다음 CPP 코드의 동작을 설명하는 간결한 자연어 설명(docstring)을 최대 500자 이내로 한국어로 제공하세요.", "ml": "string f_1()\n{\n    return \"Hello, Mass-McEval: massively scaled multilingual code evaluation\";\n}\n\nCPP കോഡ് ഉപയോഗിച്ച് 500 അക്ഷരങ്ങളിൽ കൂടുതൽ അല്ലാത്ത ഒരു സംക്ഷിപ്ത സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) മലയാളത്തിൽ നൽകുക.", "fa": "string f_1()\n{\n    return \"Hello, Mass-McEval: massively scaled multilingual code evaluation\";\n}\n\nتوضیح مختصر و طبیعی (docstring) از کد CPP را به زبان فارسی با حداکثر ۵۰۰ کاراکتر ارائه دهید."}, "level": "", "test": "int main()\n{\n    assert(f_1() ==  \"Hello, Mass-McEval: massively scaled multilingual code evaluation\");\n    return 0;\n}", "entry_point": "f_1", "signature": "string f_1()", "docstring": {"en": "Return \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "sq": "Kthe \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "hy": "Վերադարձնում է \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "bn": "Return \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "bg": "Върни \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "zh": "返回 \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "fr": "Retourne \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "de": "Zurückgeben \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "ha": "Return \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "hi": "\"Hello, Mass-McEval: massively scaled multilingual code evaluation\" लौटाएँ", "hu": "Adja vissza a \"Hello, Mass-McEval: massively scaled multilingual code evaluation\" szöveget.", "es": "Devuelve \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "arb": "إرجاع \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "sw": "Rudisha \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "tr": " \"Hello, Mass-McEval: massively scaled multilingual code evaluation\" döndür", "vi": "Trả về \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "id": "Return \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "ja": "\"Hello, Mass-McEval: massively scaled multilingual code evaluation\"を返します。", "ko": "Return \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "ml": "Return \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "fa": "بازگرداندن \"Hello, Mass-McEval: massively scaled multilingual code evaluation\""}}
{"task_id": "CPP/2", "prompt": {"en": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Calculate the area of a triangle given its three sides.\n *\n * @param a (double): Length of side 'a'.\n * @param b (double): Length of side 'b'.\n * @param c (double): Length of side 'c'.\n *\n * @return (double): If the provided sides form a triangle, return the\n *                   calculated area rounded to 2 decimal places.\n *                   Otherwise, return -1 as an indicator.\n *\n * Example usage:\n *     double area = f_2(3, 5, 4);\n *     assert(fabs(area - 6.00) < 1e-6); // Area should be approximately 6\n */\ndouble f_2(double a, double b, double c)", "sq": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Llogarit sipërfaqen e një trekëndëshi duke pasur parasysh tre anët e tij.\n *\n * @param a (double): Gjatësia e anës 'a'.\n * @param b (double): Gjatësia e anës 'b'.\n * @param c (double): Gjatësia e anës 'c'.\n *\n * @return (double): Nëse anët e dhëna formojnë një trekëndësh, kthen\n *                   sipërfaqen e llogaritur të rrumbullakosur në 2 vende dhjetore.\n *                   Përndryshe, kthen -1 si një tregues.\n *\n * Shembull përdorimi:\n *     double area = f_2(3, 5, 4);\n *     assert(fabs(area - 6.00) < 1e-6); // Sipërfaqja duhet të jetë afërsisht 6\n */\ndouble f_2(double a, double b, double c)", "hy": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Հաշվարկել եռանկյան մակերեսը՝ տրված նրա երեք կողմերը:\n *\n * @param a (double): Կողմ 'a'-ի երկարությունը:\n * @param b (double): Կողմ 'b'-ի երկարությունը:\n * @param c (double): Կողմ 'c'-ի երկարությունը:\n *\n * @return (double): Եթե տրված կողմերը կազմում են եռանկյուն, վերադարձնել\n *                   հաշվարկված մակերեսը՝ կլորացված մինչև 2 տասնորդական:\n *                   Հակառակ դեպքում վերադարձնել -1 որպես ցուցիչ:\n *\n * Օգտագործման օրինակ:\n *     double area = f_2(3, 5, 4);\n *     assert(fabs(area - 6.00) < 1e-6); // Մակերեսը պետք է մոտ լինի 6-ի\n */\ndouble f_2(double a, double b, double c)", "bn": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * একটি ত্রিভুজের তিনটি বাহু দেওয়া থাকলে তার ক্ষেত্রফল গণনা করুন।\n *\n * @param a (double): বাহু 'a' এর দৈর্ঘ্য।\n * @param b (double): বাহু 'b' এর দৈর্ঘ্য।\n * @param c (double): বাহু 'c' এর দৈর্ঘ্য।\n *\n * @return (double): যদি প্রদত্ত বাহুগুলি একটি ত্রিভুজ গঠন করে, তবে\n *                   গণনা করা ক্ষেত্রফল 2 দশমিক স্থান পর্যন্ত\n *                   রাউন্ড করে ফেরত দিন। অন্যথায়, সূচক হিসাবে -1 ফেরত দিন।\n *\n * উদাহরণ ব্যবহার:\n *     double area = f_2(3, 5, 4);\n *     assert(fabs(area - 6.00) < 1e-6); // ক্ষেত্রফল প্রায় 6 হওয়া উচিত\n */\ndouble f_2(double a, double b, double c)", "bg": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Изчисляване на лицето на триъгълник, дадени неговите три страни.\n *\n * @param a (double): Дължина на страна 'a'.\n * @param b (double): Дължина на страна 'b'.\n * @param c (double): Дължина на страна 'c'.\n *\n * @return (double): Ако предоставените страни образуват триъгълник, връща\n *                   изчисленото лице, закръглено до 2 знака след десетичната запетая.\n *                   В противен случай връща -1 като индикатор.\n *\n * Пример за използване:\n *     double area = f_2(3, 5, 4);\n *     assert(fabs(area - 6.00) < 1e-6); // Лицето трябва да бъде приблизително 6\n */\ndouble f_2(double a, double b, double c)", "zh": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * 计算给定三边的三角形面积。\n *\n * @param a (double): 边 'a' 的长度。\n * @param b (double): 边 'b' 的长度。\n * @param c (double): 边 'c' 的长度。\n *\n * @return (double): 如果提供的边能构成三角形，返回计算出的面积，保留两位小数。\n *                   否则，返回 -1 作为指示。\n *\n * 示例用法:\n *     double area = f_2(3, 5, 4);\n *     assert(fabs(area - 6.00) < 1e-6); // 面积应约为 6\n */\ndouble f_2(double a, double b, double c)", "fr": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Calculer l'aire d'un triangle donné ses trois côtés.\n *\n * @param a (double): Longueur du côté 'a'.\n * @param b (double): Longueur du côté 'b'.\n * @param c (double): Longueur du côté 'c'.\n *\n * @return (double): Si les côtés fournis forment un triangle, retourne l'aire\n *                   calculée arrondie à 2 décimales.\n *                   Sinon, retourne -1 comme indicateur.\n *\n * Exemple d'utilisation :\n *     double area = f_2(3, 5, 4);\n *     assert(fabs(area - 6.00) < 1e-6); // L'aire devrait être approximativement 6\n */\ndouble f_2(double a, double b, double c)", "de": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Berechne die Fläche eines Dreiecks, gegeben durch seine drei Seiten.\n *\n * @param a (double): Länge der Seite 'a'.\n * @param b (double): Länge der Seite 'b'.\n * @param c (double): Länge der Seite 'c'.\n *\n * @return (double): Wenn die angegebenen Seiten ein Dreieck bilden, gib die\n *                   berechnete Fläche gerundet auf 2 Dezimalstellen zurück.\n *                   Andernfalls gib -1 als Indikator zurück.\n *\n * Beispielverwendung:\n *     double area = f_2(3, 5, 4);\n *     assert(fabs(area - 6.00) < 1e-6); // Fläche sollte ungefähr 6 sein\n */\ndouble f_2(double a, double b, double c)", "ha": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Lissafi yanki na alwatika idan aka ba da gefensa uku.\n *\n * @param a (double): Tsawon gefen 'a'.\n * @param b (double): Tsawon gefen 'b'.\n * @param c (double): Tsawon gefen 'c'.\n *\n * @return (double): Idan gefen da aka bayar sun kafa alwatika, dawo da\n *                   yankin da aka lissafa wanda aka zagaye zuwa wurare 2 na goma.\n *                   In ba haka ba, dawo da -1 a matsayin alama.\n *\n * Misalin amfani:\n *     double area = f_2(3, 5, 4);\n *     assert(fabs(area - 6.00) < 1e-6); // Yankin yakamata ya zama kusan 6\n */\ndouble f_2(double a, double b, double c)", "hi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * दिए गए तीन भुजाओं के आधार पर त्रिभुज का क्षेत्रफल गणना करें।\n *\n * @param a (double): भुजा 'a' की लंबाई।\n * @param b (double): भुजा 'b' की लंबाई।\n * @param c (double): भुजा 'c' की लंबाई।\n *\n * @return (double): यदि दी गई भुजाएं एक त्रिभुज बनाती हैं, तो\n *                   गणना किया गया क्षेत्रफल 2 दशमलव स्थानों तक\n *                   गोलाई करके लौटाएं। अन्यथा, संकेतक के रूप में -1 लौटाएं।\n *\n * उदाहरण उपयोग:\n *     double area = f_2(3, 5, 4);\n *     assert(fabs(area - 6.00) < 1e-6); // क्षेत्रफल लगभग 6 होना चाहिए\n */\ndouble f_2(double a, double b, double c)", "hu": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Számítsa ki egy háromszög területét a három oldalának ismeretében.\n *\n * @param a (double): Az 'a' oldal hossza.\n * @param b (double): A 'b' oldal hossza.\n * @param c (double): A 'c' oldal hossza.\n *\n * @return (double): Ha a megadott oldalak háromszöget alkotnak, térjen vissza a\n *                   kiszámított területtel, amely 2 tizedesjegyre van kerekítve.\n *                   Ellenkező esetben térjen vissza -1 értékkel, mint jelző.\n *\n * Példa használat:\n *     double area = f_2(3, 5, 4);\n *     assert(fabs(area - 6.00) < 1e-6); // A területnek körülbelül 6-nak kell lennie\n */\ndouble f_2(double a, double b, double c)", "es": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Calcular el área de un triángulo dados sus tres lados.\n *\n * @param a (double): Longitud del lado 'a'.\n * @param b (double): Longitud del lado 'b'.\n * @param c (double): Longitud del lado 'c'.\n *\n * @return (double): Si los lados proporcionados forman un triángulo, devuelve el\n *                   área calculada redondeada a 2 decimales.\n *                   De lo contrario, devuelve -1 como indicador.\n *\n * Ejemplo de uso:\n *     double area = f_2(3, 5, 4);\n *     assert(fabs(area - 6.00) < 1e-6); // El área debería ser aproximadamente 6\n */\ndouble f_2(double a, double b, double c)", "arb": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * حساب مساحة مثلث معطى أضلاعه الثلاثة.\n *\n * @param a (double): طول الضلع 'a'.\n * @param b (double): طول الضلع 'b'.\n * @param c (double): طول الضلع 'c'.\n *\n * @return (double): إذا كانت الأضلاع المعطاة تشكل مثلثًا، يتم إرجاع\n *                   المساحة المحسوبة مقربة إلى منزلتين عشريتين.\n *                   خلاف ذلك، يتم إرجاع -1 كمؤشر.\n *\n * مثال على الاستخدام:\n *     double area = f_2(3, 5, 4);\n *     assert(fabs(area - 6.00) < 1e-6); // يجب أن تكون المساحة تقريبًا 6\n */\ndouble f_2(double a, double b, double c)", "sw": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Hesabu eneo la pembetatu ukipewa pande zake tatu.\n *\n * @param a (double): Urefu wa upande 'a'.\n * @param b (double): Urefu wa upande 'b'.\n * @param c (double): Urefu wa upande 'c'.\n *\n * @return (double): Ikiwa pande zilizotolewa zinaunda pembetatu, rudisha\n *                   eneo lililohesabiwa na kulizungusha hadi sehemu 2 za desimali.\n *                   Vinginevyo, rudisha -1 kama kiashiria.\n *\n * Mfano wa matumizi:\n *     double area = f_2(3, 5, 4);\n *     assert(fabs(area - 6.00) < 1e-6); // Eneo linapaswa kuwa takriban 6\n */\ndouble f_2(double a, double b, double c)", "tr": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Üç kenarı verilen bir üçgenin alanını hesaplayın.\n *\n * @param a (double): 'a' kenarının uzunluğu.\n * @param b (double): 'b' kenarının uzunluğu.\n * @param c (double): 'c' kenarının uzunluğu.\n *\n * @return (double): Verilen kenarlar bir üçgen oluşturuyorsa,\n *                   hesaplanan alanı 2 ondalık basamağa yuvarlanmış\n *                   olarak döndürün. Aksi takdirde, bir gösterge\n *                   olarak -1 döndürün.\n *\n * Örnek kullanım:\n *     double area = f_2(3, 5, 4);\n *     assert(fabs(area - 6.00) < 1e-6); // Alan yaklaşık olarak 6 olmalıdır\n */\ndouble f_2(double a, double b, double c)", "vi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Tính diện tích của một tam giác khi biết ba cạnh của nó.\n *\n * @param a (double): Chiều dài của cạnh 'a'.\n * @param b (double): Chiều dài của cạnh 'b'.\n * @param c (double): Chiều dài của cạnh 'c'.\n *\n * @return (double): Nếu các cạnh được cung cấp tạo thành một tam giác, trả về\n *                   diện tích đã tính toán được làm tròn đến 2 chữ số thập phân.\n *                   Nếu không, trả về -1 như một chỉ báo.\n *\n * Ví dụ sử dụng:\n *     double area = f_2(3, 5, 4);\n *     assert(fabs(area - 6.00) < 1e-6); // Diện tích nên xấp xỉ 6\n */\ndouble f_2(double a, double b, double c)", "id": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Hitung luas segitiga yang diberikan tiga sisinya.\n *\n * @param a (double): Panjang sisi 'a'.\n * @param b (double): Panjang sisi 'b'.\n * @param c (double): Panjang sisi 'c'.\n *\n * @return (double): Jika sisi yang diberikan membentuk segitiga, kembalikan\n *                   luas yang dihitung dibulatkan ke 2 tempat desimal.\n *                   Jika tidak, kembalikan -1 sebagai indikator.\n *\n * Contoh penggunaan:\n *     double area = f_2(3, 5, 4);\n *     assert(fabs(area - 6.00) < 1e-6); // Luas seharusnya sekitar 6\n */\ndouble f_2(double a, double b, double c)", "ja": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * 三辺が与えられた三角形の面積を計算します。\n *\n * @param a (double): 辺 'a' の長さ。\n * @param b (double): 辺 'b' の長さ。\n * @param c (double): 辺 'c' の長さ。\n *\n * @return (double): 提供された辺が三角形を形成する場合、\n *                   計算された面積を小数点以下2桁に丸めて返します。\n *                   そうでない場合、指標として -1 を返します。\n *\n * 使用例:\n *     double area = f_2(3, 5, 4);\n *     assert(fabs(area - 6.00) < 1e-6); // 面積は約6であるべき\n */\ndouble f_2(double a, double b, double c)", "ko": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * 주어진 세 변의 길이를 통해 삼각형의 면적을 계산합니다.\n *\n * @param a (double): 변 'a'의 길이.\n * @param b (double): 변 'b'의 길이.\n * @param c (double): 변 'c'의 길이.\n *\n * @return (double): 제공된 변들이 삼각형을 형성하면,\n *                   계산된 면적을 소수점 두 자리로 반올림하여 반환합니다.\n *                   그렇지 않으면, -1을 지표로 반환합니다.\n *\n * 사용 예:\n *     double area = f_2(3, 5, 4);\n *     assert(fabs(area - 6.00) < 1e-6); // 면적은 대략 6이어야 합니다\n */\ndouble f_2(double a, double b, double c)", "ml": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * ഒരു ത്രികോണത്തിന്റെ മൂന്നു വശങ്ങൾ നൽകിയാൽ അതിന്റെ വിസ്തീർണം കണക്കാക്കുക.\n *\n * @param a (double): 'a' എന്ന വശത്തിന്റെ നീളം.\n * @param b (double): 'b' എന്ന വശത്തിന്റെ നീളം.\n * @param c (double): 'c' എന്ന വശത്തിന്റെ നീളം.\n *\n * @return (double): നൽകിയ വശങ്ങൾ ഒരു ത്രികോണം രൂപീകരിക്കുന്നുവെങ്കിൽ,\n *                   കണക്കാക്കിയ വിസ്തീർണം 2 ദശാംശസ്ഥാനം വരെയായി\n *                   റൗണ്ട് ചെയ്തതായിരിക്കും മടക്കിനൽകുക.\n *                   അല്ലെങ്കിൽ, സൂചനയായി -1 മടക്കിനൽകുക.\n *\n * ഉദാഹരണ ഉപയോഗം:\n *     double area = f_2(3, 5, 4);\n *     assert(fabs(area - 6.00) < 1e-6); // വിസ്തീർണം ഏകദേശം 6 ആയിരിക്കണം\n */\ndouble f_2(double a, double b, double c)", "fa": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * محاسبه مساحت یک مثلث با توجه به سه ضلع آن.\n *\n * @param a (double): طول ضلع 'a'.\n * @param b (double): طول ضلع 'b'.\n * @param c (double): طول ضلع 'c'.\n *\n * @return (double): اگر اضلاع داده شده یک مثلث تشکیل دهند، مساحت محاسبه شده\n *                   را با گرد کردن به 2 رقم اعشار برمی‌گرداند.\n *                   در غیر این صورت، -1 را به عنوان نشانگر برمی‌گرداند.\n *\n * مثال استفاده:\n *     double area = f_2(3, 5, 4);\n *     assert(fabs(area - 6.00) < 1e-6); // مساحت باید تقریباً 6 باشد\n */\ndouble f_2(double a, double b, double c)"}, "canonical_solution": "{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        return -1; // Special value to indicate it's not a triangle\n    }\n}", "instruction": {"en": "double f_2(double a, double b, double c)\n{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        return -1; // Special value to indicate it's not a triangle\n    }\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.", "sq": "double f_2(double a, double b, double c)\n{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        return -1; // Special value to indicate it's not a triangle\n    }\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit CPP në shqip duke përdorur maksimumi 500 karaktere.", "hy": "double f_2(double a, double b, double c)\n{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        return -1; // Special value to indicate it's not a triangle\n    }\n}\n\nՏվեք CPP կոդի համառոտ բնութագիրը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։", "bn": "double f_2(double a, double b, double c)\n{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        return -1; // Special value to indicate it's not a triangle\n    }\n}\n\nনিচের CPP কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।", "bg": "double f_2(double a, double b, double c)\n{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        return -1; // Special value to indicate it's not a triangle\n    }\n}\n\nПредоставете кратко описание на CPP кода на български език, като използвате не повече от 500 знака.", "zh": "double f_2(double a, double b, double c)\n{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        return -1; // Special value to indicate it's not a triangle\n    }\n}\n\n请用最多500个字符的中文对该CPP代码提供简洁的自然语言描述（文档字符串）。", "fr": "double f_2(double a, double b, double c)\n{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        return -1; // Special value to indicate it's not a triangle\n    }\n}\n\nFournissez une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.", "de": "double f_2(double a, double b, double c)\n{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        return -1; // Special value to indicate it's not a triangle\n    }\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "double f_2(double a, double b, double c)\n{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        return -1; // Special value to indicate it's not a triangle\n    }\n}\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar CPP cikin Hausa ta amfani da haruffa 500 kacal.", "hi": "double f_2(double a, double b, double c)\n{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        return -1; // Special value to indicate it's not a triangle\n    }\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "double f_2(double a, double b, double c)\n{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        return -1; // Special value to indicate it's not a triangle\n    }\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a CPP kódról magyarul, legfeljebb 500 karakterben.", "es": "double f_2(double a, double b, double c)\n{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        return -1; // Special value to indicate it's not a triangle\n    }\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando como máximo 500 caracteres.", "arb": "double f_2(double a, double b, double c)\n{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        return -1; // Special value to indicate it's not a triangle\n    }\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لشفرة CPP باللغة العربية الفصحى باستخدام 500 حرف على الأكثر.", "sw": "double f_2(double a, double b, double c)\n{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        return -1; // Special value to indicate it's not a triangle\n    }\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "double f_2(double a, double b, double c)\n{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        return -1; // Special value to indicate it's not a triangle\n    }\n}\n\nAşağıdaki CPP kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda, özlü bir doğal dil açıklaması (docstring) sağlayın.", "vi": "double f_2(double a, double b, double c)\n{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        return -1; // Special value to indicate it's not a triangle\n    }\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự.", "id": "double f_2(double a, double b, double c)\n{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        return -1; // Special value to indicate it's not a triangle\n    }\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode CPP dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "double f_2(double a, double b, double c)\n{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        return -1; // Special value to indicate it's not a triangle\n    }\n}\n\n以下のCPPコードに対して、500文字以内で簡潔な自然言語の説明（ドックストリング）を日本語で提供してください。", "ko": "double f_2(double a, double b, double c)\n{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        return -1; // Special value to indicate it's not a triangle\n    }\n}\n\n다음 CPP 코드에 대한 간결한 자연어 설명(도크스트링)을 한국어로 최대 500자 이내로 제공하세요.", "ml": "double f_2(double a, double b, double c)\n{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        return -1; // Special value to indicate it's not a triangle\n    }\n}\n\nസിപിപി കോഡിന്റെ സംക്ഷിപ്തമായ സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) മലയാളത്തിൽ 500 അക്ഷരങ്ങളിൽ കൂടാതെയായി നൽകുക.", "fa": "double f_2(double a, double b, double c)\n{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        return -1; // Special value to indicate it's not a triangle\n    }\n}\n\nتوضیح مختصر و طبیعی (docstring) از کد CPP به زبان فارسی با حداکثر ۵۰۰ کاراکتر ارائه دهید."}, "level": "", "test": "int main() {\n    // Test cases for the f_2 function\n    assert(fabs(f_2(3, 5, 4) - 6.00) < 1e-6); // Expected area is 6\n    assert(f_2(1, 1, 4) == -1);  // Not a triangle, should return -1\n    assert(fabs(f_2(7, 24, 25) - 84.00) < 1e-6); // Expected area is 84\n    assert(fabs(f_2(10.5, 6.2, 7.3) - 22.15) < 1e-2); // Expected area is approx 22.15\n\n    // All tests passed\n    \n    return 0;\n}", "entry_point": "f_2", "signature": "double f_2(double a, double b, double c)", "docstring": {"en": "Calculate the area of a triangle given its three sides.\n\n@param a (double): Length of side 'a'.\n@param b (double): Length of side 'b'.\n@param c (double): Length of side 'c'.\n\n@return (double): If the provided sides form a triangle, return the calculated area rounded to 2 decimal places. Otherwise, return -1 as an indicator.\n\nExample usage:\n    double area = f_2(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // Area should be approximately 6", "sq": "Llogarit sipërfaqen e një trekëndëshi duke pasur parasysh tre anët e tij.\n\n@param a (double): Gjatësia e anës 'a'.\n@param b (double): Gjatësia e anës 'b'.\n@param c (double): Gjatësia e anës 'c'.\n\n@return (double): Nëse anët e dhëna formojnë një trekëndësh, kthen sipërfaqen e llogaritur të rrumbullakosur në 2 shifra dhjetore. Përndryshe, kthen -1 si një tregues.\n\nShembull përdorimi:\n    double area = f_2(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // Sipërfaqja duhet të jetë afërsisht 6", "hy": "Հաշվել եռանկյան մակերեսը՝ հաշվի առնելով նրա երեք կողմերը։\n\n@param a (double): Կողմ 'a'-ի երկարությունը։\n@param b (double): Կողմ 'b'-ի երկարությունը։\n@param c (double): Կողմ 'c'-ի երկարությունը։\n\n@return (double): Եթե տրված կողմերը կազմում են եռանկյուն, վերադարձնել հաշվարկված մակերեսը՝ կլորացված մինչև 2 տասնորդական։ Հակառակ դեպքում, վերադարձնել -1 որպես ցուցիչ։\n\nՕրինակ օգտագործում:\n    double area = f_2(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // Մակերեսը պետք է մոտավորապես լինի 6", "bn": "একটি ত্রিভুজের তিনটি বাহু দেওয়া থাকলে তার ক্ষেত্রফল গণনা করুন।\n\n@param a (double): বাহু 'a' এর দৈর্ঘ্য।\n@param b (double): বাহু 'b' এর দৈর্ঘ্য।\n@param c (double): বাহু 'c' এর দৈর্ঘ্য।\n\n@return (double): যদি প্রদত্ত বাহুগুলি একটি ত্রিভুজ গঠন করে, তবে 2 দশমিক স্থান পর্যন্ত গোলাকার গণনা করা ক্ষেত্রফল প্রদান করুন। অন্যথায়, সূচক হিসাবে -1 প্রদান করুন।\n\nব্যবহারের উদাহরণ:\n    double area = f_2(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // ক্ষেত্রফল আনুমানিক 6 হওয়া উচিত", "bg": "Изчислява площта на триъгълник, дадени неговите три страни.\n\n@param a (double): Дължина на страна 'a'.\n@param b (double): Дължина на страна 'b'.\n@param c (double): Дължина на страна 'c'.\n\n@return (double): Ако предоставените страни образуват триъгълник, връща изчислената площ, закръглена до 2 знака след десетичната запетая. В противен случай връща -1 като индикатор.\n\nПример за използване:\n    double area = f_2(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // Площта трябва да бъде приблизително 6", "zh": "计算给定三边的三角形面积。\n\n@param a (double): 边 'a' 的长度。\n@param b (double): 边 'b' 的长度。\n@param c (double): 边 'c' 的长度。\n\n@return (double): 如果提供的边长可以构成一个三角形，返回计算出的面积并四舍五入到小数点后两位。否则，返回 -1 作为指示。\n\n示例用法:\n    double area = f_2(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // 面积应大约为 6", "fr": "Calculer l'aire d'un triangle donné ses trois côtés.\n\n@param a (double): Longueur du côté 'a'.\n@param b (double): Longueur du côté 'b'.\n@param c (double): Longueur du côté 'c'.\n\n@return (double): Si les côtés fournis forment un triangle, retourner l'aire calculée arrondie à 2 décimales. Sinon, retourner -1 comme indicateur.\n\nExemple d'utilisation :\n    double area = f_2(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // L'aire devrait être approximativement 6", "de": "Berechnen Sie die Fläche eines Dreiecks, gegeben durch seine drei Seiten.\n\n@param a (double): Länge der Seite 'a'.\n@param b (double): Länge der Seite 'b'.\n@param c (double): Länge der Seite 'c'.\n\n@return (double): Wenn die angegebenen Seiten ein Dreieck bilden, geben Sie die berechnete Fläche auf 2 Dezimalstellen gerundet zurück. Andernfalls geben Sie -1 als Indikator zurück.\n\nBeispielverwendung:\n    double area = f_2(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // Die Fläche sollte ungefähr 6 betragen", "ha": "Lissafin yankin wani kusurwar kusurwa idan aka ba shi bangarorinsa guda uku.\n\n@param a (double): Tsawon gefen 'a'.\n@param b (double): Tsawon gefen 'b'.\n@param c (double): Tsawon gefen 'c'.\n\n@return (double): Idan gefen da aka bayar sun ƙirƙiri alwatika, dawo da yankin da aka lissafa wanda aka zagaye zuwa wurare 2 na adadi. In ba haka ba, dawo da -1 a matsayin alamar.\n\nExample usage:\n    double area = f_2(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // Ya kamata yankin ya kasance kusan 6", "hi": "त्रिभुज के तीन भुजाओं के आधार पर उसका क्षेत्रफल गणना करें।\n\n@param a (double): भुजा 'a' की लंबाई।\n@param b (double): भुजा 'b' की लंबाई।\n@param c (double): भुजा 'c' की लंबाई।\n\n@return (double): यदि दी गई भुजाएँ एक त्रिभुज बनाती हैं, तो गणना किया गया क्षेत्रफल 2 दशमलव स्थानों तक गोल कर लौटाएं। अन्यथा, संकेतक के रूप में -1 लौटाएं।\n\nउदाहरण उपयोग:\n    double area = f_2(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // क्षेत्रफल लगभग 6 होना चाहिए", "hu": "Számítsa ki egy háromszög területét a három oldalának ismeretében.\n\n@param a (double): Az 'a' oldal hossza.\n@param b (double): A 'b' oldal hossza.\n@param c (double): A 'c' oldal hossza.\n\n@return (double): Ha a megadott oldalak háromszöget alkotnak, adja vissza a kiszámított területet 2 tizedesjegyre kerekítve. Ellenkező esetben adja vissza a -1 értéket jelzésként.\n\nPélda használat:\n    double area = f_2(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // A területnek körülbelül 6-nak kell lennie", "es": "Calcular el área de un triángulo dados sus tres lados.\n\n@param a (double): Longitud del lado 'a'.\n@param b (double): Longitud del lado 'b'.\n@param c (double): Longitud del lado 'c'.\n\n@return (double): Si los lados proporcionados forman un triángulo, devuelve el área calculada redondeada a 2 decimales. De lo contrario, devuelve -1 como indicador.\n\nEjemplo de uso:\n    double area = f_2(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // El área debería ser aproximadamente 6", "arb": "حساب مساحة مثلث معطى أطوال أضلاعه الثلاثة.\n\n@param a (double): طول الضلع 'a'.\n@param b (double): طول الضلع 'b'.\n@param c (double): طول الضلع 'c'.\n\n@return (double): إذا كانت الأضلاع المعطاة تشكل مثلثًا، يتم إرجاع المساحة المحسوبة مقربة إلى منزلتين عشريتين. خلاف ذلك، يتم إرجاع -1 كمؤشر.\n\nمثال على الاستخدام:\n    double area = f_2(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // يجب أن تكون المساحة تقريبًا 6", "sw": "Hesabu eneo la pembetatu ukitumia pande zake tatu.\n\n@param a (double): Urefu wa upande 'a'.\n@param b (double): Urefu wa upande 'b'.\n@param c (double): Urefu wa upande 'c'.\n\n@return (double): Ikiwa pande zilizotolewa zinaunda pembetatu, rudisha eneo lililohesabiwa likiwa limezungushwa hadi sehemu 2 za desimali. Vinginevyo, rudisha -1 kama kiashiria.\n\nMfano wa matumizi:\n    double area = f_2(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // Eneo linapaswa kuwa takriban 6", "tr": "Bir üçgenin üç kenarı verildiğinde alanını hesaplayın.\n\n@param a (double): 'a' kenarının uzunluğu.\n@param b (double): 'b' kenarının uzunluğu.\n@param c (double): 'c' kenarının uzunluğu.\n\n@return (double): Verilen kenarlar bir üçgen oluşturuyorsa, hesaplanan alanı 2 ondalık basamağa yuvarlanmış olarak döndürür. Aksi takdirde, bir gösterge olarak -1 döndürür.\n\nÖrnek kullanım:\n    double area = f_2(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // Alan yaklaşık olarak 6 olmalıdır.", "vi": "Tính diện tích của một tam giác khi biết ba cạnh của nó.\n\n@param a (double): Chiều dài của cạnh 'a'.\n@param b (double): Chiều dài của cạnh 'b'.\n@param c (double): Chiều dài của cạnh 'c'.\n\n@return (double): Nếu các cạnh được cung cấp tạo thành một tam giác, trả về diện tích đã tính toán được làm tròn đến 2 chữ số thập phân. Nếu không, trả về -1 như là một chỉ báo.\n\nVí dụ sử dụng:\n    double area = f_2(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // Diện tích nên xấp xỉ 6", "id": "Hitung luas segitiga berdasarkan tiga sisinya.\n\n@param a (double): Panjang sisi 'a'.\n@param b (double): Panjang sisi 'b'.\n@param c (double): Panjang sisi 'c'.\n\n@return (double): Jika sisi yang diberikan membentuk segitiga, kembalikan luas yang dihitung dibulatkan ke 2 tempat desimal. Jika tidak, kembalikan -1 sebagai indikator.\n\nContoh penggunaan:\n    double area = f_2(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // Luas seharusnya sekitar 6", "ja": "三辺の長さが与えられたときの三角形の面積を計算します。\n\n@param a (double): 辺 'a' の長さ。\n@param b (double): 辺 'b' の長さ。\n@param c (double): 辺 'c' の長さ。\n\n@return (double): 提供された辺が三角形を形成する場合、計算された面積を小数点以下2桁に丸めて返します。それ以外の場合は、指標として -1 を返します。\n\n使用例:\n    double area = f_2(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // 面積はおおよそ6であるべきです。", "ko": "삼각형의 세 변이 주어졌을 때, 삼각형의 면적을 계산합니다.\n\n@param a (double): 변 'a'의 길이.\n@param b (double): 변 'b'의 길이.\n@param c (double): 변 'c'의 길이.\n\n@return (double): 제공된 변들이 삼각형을 형성하면, 계산된 면적을 소수점 두 자리로 반올림하여 반환합니다. 그렇지 않으면, -1을 지표로 반환합니다.\n\n사용 예:\n    double area = f_2(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // 면적은 대략 6이어야 합니다.", "ml": "ത്രികോണത്തിന്റെ മൂന്നു വശങ്ങൾ നൽകിയാൽ അതിന്റെ വിസ്തീർണ്ണം കണക്കാക്കുക.\n\n@param a (double): വശം 'a'യുടെ നീളം.\n@param b (double): വശം 'b'യുടെ നീളം.\n@param c (double): വശം 'c'യുടെ നീളം.\n\n@return (double): നൽകിയ വശങ്ങൾ ത്രികോണം രൂപീകരിക്കുന്നുവെങ്കിൽ, കണക്കാക്കിയ വിസ്തീർണ്ണം 2 ദശാംശങ്ങളിൽ ചുരുക്കി മടക്കുക. അല്ലെങ്കിൽ, സൂചകമായി -1 മടക്കുക.\n\nഉദാഹരണ ഉപയോഗം:\n    double area = f_2(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // വിസ്തീർണ്ണം ഏകദേശം 6 ആയിരിക്കണം", "fa": "محاسبه مساحت یک مثلث با توجه به سه ضلع آن.\n\n@param a (double): طول ضلع 'a'.\n@param b (double): طول ضلع 'b'.\n@param c (double): طول ضلع 'c'.\n\n@return (double): اگر اضلاع داده شده یک مثلث تشکیل دهند، مساحت محاسبه شده را با گرد کردن به 2 رقم اعشار برگردانید. در غیر این صورت، -1 را به عنوان نشانگر برگردانید.\n\nمثال استفاده:\n    double area = f_2(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // مساحت باید تقریباً 6 باشد"}}
{"task_id": "CPP/3", "prompt": {"en": "#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <string>\n/**\n * Calculate the value of the function for a given input.\n * Parameters:\n * - x (int): Input value for the function.\n * Returns:\n * - std::string: If x is not in the defined domain, returns \"Not define\".\n *   Otherwise, returns the calculated function value rounded to 5 decimal places.\n *\n * Function Definitions:\n * - For 0 <= x < 10: y = cos(x + 3.0)\n * - For 10 <= x < 20: y = (cos(x + 7.5))^2\n * - For 20 <= x < 30: y = (cos(x + 4.0))^4\n * Example:\n *   f_3(40) returns \"Not define\"\n */\nstd::string f_3(int x)", "sq": "#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <string>\n/**\n * Llogarit vlerën e funksionit për një hyrje të dhënë.\n * Parametrat:\n * - x (int): Vlera e hyrjes për funksionin.\n * Kthen:\n * - std::string: Nëse x nuk është në domenin e përcaktuar, kthen \"Not define\".\n *   Përndryshe, kthen vlerën e llogaritur të funksionit të rrumbullakosur në 5 shifra dhjetore.\n *\n * Përkufizimet e funksionit:\n * - Për 0 <= x < 10: y = cos(x + 3.0)\n * - Për 10 <= x < 20: y = (cos(x + 7.5))^2\n * - Për 20 <= x < 30: y = (cos(x + 4.0))^4\n * Shembull:\n *   f_3(40) kthen \"Not define\"\n */\nstd::string f_3(int x)", "hy": "#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <string>\n/**\n * Հաշվարկել ֆունկցիայի արժեքը տրված մուտքագրման համար:\n * Պարամետրեր:\n * - x (int): Ֆունկցիայի մուտքագրման արժեքը:\n * Վերադարձնում է:\n * - std::string: Եթե x-ը սահմանված տիրույթում չէ, վերադարձնում է \"Not define\":\n *   Հակառակ դեպքում, վերադարձնում է հաշվարկված ֆունկցիայի արժեքը կլորացված մինչև 5 տասնորդական թվանշան:\n *\n * Ֆունկցիայի սահմանումներ:\n * - 0 <= x < 10: y = cos(x + 3.0)\n * - 10 <= x < 20: y = (cos(x + 7.5))^2\n * - 20 <= x < 30: y = (cos(x + 4.0))^4\n * Օրինակ:\n *   f_3(40) վերադարձնում է \"Not define\"\n */\nstd::string f_3(int x)", "bn": "#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <string>\n/**\n * প্রদত্ত ইনপুটের জন্য ফাংশনের মান গণনা করুন।\n * প্যারামিটার:\n * - x (int): ফাংশনের জন্য ইনপুট মান।\n * রিটার্নস:\n * - std::string: যদি x সংজ্ঞায়িত ডোমেইনে না থাকে, \"Not define\" রিটার্ন করে।\n *   অন্যথায়, গণনা করা ফাংশনের মান 5 দশমিক স্থানে রাউন্ড করে রিটার্ন করে।\n *\n * ফাংশন সংজ্ঞা:\n * - 0 <= x < 10 এর জন্য: y = cos(x + 3.0)\n * - 10 <= x < 20 এর জন্য: y = (cos(x + 7.5))^2\n * - 20 <= x < 30 এর জন্য: y = (cos(x + 4.0))^4\n * উদাহরণ:\n *   f_3(40) \"Not define\" রিটার্ন করে\n */\nstd::string f_3(int x)", "bg": "#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <string>\n/**\n * Изчислява стойността на функцията за даден вход.\n * Параметри:\n * - x (int): Входна стойност за функцията.\n * Връща:\n * - std::string: Ако x не е в определения домейн, връща \"Not define\".\n *   В противен случай, връща изчислената стойност на функцията, закръглена до 5 десетични знака.\n *\n * Дефиниции на функцията:\n * - За 0 <= x < 10: y = cos(x + 3.0)\n * - За 10 <= x < 20: y = (cos(x + 7.5))^2\n * - За 20 <= x < 30: y = (cos(x + 4.0))^4\n * Пример:\n *   f_3(40) връща \"Not define\"\n */\nstd::string f_3(int x)", "zh": "#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <string>\n/**\n * 计算给定输入的函数值。\n * 参数：\n * - x (int): 函数的输入值。\n * 返回：\n * - std::string: 如果 x 不在定义域内，返回 \"Not define\"。\n *   否则，返回计算后的函数值，四舍五入到小数点后5位。\n *\n * 函数定义：\n * - 对于 0 <= x < 10: y = cos(x + 3.0)\n * - 对于 10 <= x < 20: y = (cos(x + 7.5))^2\n * - 对于 20 <= x < 30: y = (cos(x + 4.0))^4\n * 示例：\n *   f_3(40) 返回 \"Not define\"\n */\nstd::string f_3(int x)", "fr": "#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <string>\n/**\n * Calculer la valeur de la fonction pour une entrée donnée.\n * Paramètres :\n * - x (int) : Valeur d'entrée pour la fonction.\n * Renvoie :\n * - std::string : Si x n'est pas dans le domaine défini, renvoie \"Not define\".\n *   Sinon, renvoie la valeur calculée de la fonction arrondie à 5 décimales.\n *\n * Définitions de la fonction :\n * - Pour 0 <= x < 10 : y = cos(x + 3.0)\n * - Pour 10 <= x < 20 : y = (cos(x + 7.5))^2\n * - Pour 20 <= x < 30 : y = (cos(x + 4.0))^4\n * Exemple :\n *   f_3(40) returns \"Not define\"\n */\nstd::string f_3(int x)", "de": "#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <string>\n/**\n * Berechnet den Wert der Funktion für eine gegebene Eingabe.\n * Parameter:\n * - x (int): Eingabewert für die Funktion.\n * Rückgabe:\n * - std::string: Wenn x nicht im definierten Bereich liegt, wird \"Not define\" zurückgegeben.\n *   Andernfalls wird der berechnete Funktionswert auf 5 Dezimalstellen gerundet zurückgegeben.\n *\n * Funktionsdefinitionen:\n * - Für 0 <= x < 10: y = cos(x + 3.0)\n * - Für 10 <= x < 20: y = (cos(x + 7.5))^2\n * - Für 20 <= x < 30: y = (cos(x + 4.0))^4\n * Beispiel:\n *   f_3(40) gibt \"Not define\" zurück\n */\nstd::string f_3(int x)", "ha": "#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <string>\n/**\n * Lissafa ƙimar aikin don wani shigarwa da aka bayar.\n * Sigogi:\n * - x (int): Ƙimar shigarwa don aikin.\n * Komawa:\n * - std::string: Idan x ba ya cikin yankin da aka ayyana, yana mayar da \"Not define\".\n *   In ba haka ba, yana mayar da ƙimar aikin da aka lissafa an zagaye zuwa wurare 5 na ɗigo.\n *\n * Ma'anar Aiki:\n * - Don 0 <= x < 10: y = cos(x + 3.0)\n * - Don 10 <= x < 20: y = (cos(x + 7.5))^2\n * - Don 20 <= x < 30: y = (cos(x + 4.0))^4\n * Misali:\n *   f_3(40) yana mayar da \"Not define\"\n */\nstd::string f_3(int x)", "hi": "#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <string>\n/**\n * दिए गए इनपुट के लिए फ़ंक्शन का मान गणना करें।\n * पैरामीटर्स:\n * - x (int): फ़ंक्शन के लिए इनपुट मान।\n * रिटर्न:\n * - std::string: यदि x परिभाषित डोमेन में नहीं है, तो \"Not define\" लौटाता है।\n *   अन्यथा, गणना किए गए फ़ंक्शन मान को 5 दशमलव स्थानों तक राउंड करके लौटाता है।\n *\n * फ़ंक्शन परिभाषाएँ:\n * - 0 <= x < 10 के लिए: y = cos(x + 3.0)\n * - 10 <= x < 20 के लिए: y = (cos(x + 7.5))^2\n * - 20 <= x < 30 के लिए: y = (cos(x + 4.0))^4\n * उदाहरण:\n *   f_3(40) \"Not define\" लौटाता है\n */\nstd::string f_3(int x)", "hu": "#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <string>\n/**\n * Számítsa ki a függvény értékét egy adott bemenetre.\n * Paraméterek:\n * - x (int): A függvény bemeneti értéke.\n * Visszatérési érték:\n * - std::string: Ha x nincs a meghatározott tartományban, \"Not define\" értéket ad vissza.\n *   Egyébként a kiszámított függvényértéket adja vissza 5 tizedesjegyre kerekítve.\n *\n * Függvény definíciók:\n * - Ha 0 <= x < 10: y = cos(x + 3.0)\n * - Ha 10 <= x < 20: y = (cos(x + 7.5))^2\n * - Ha 20 <= x < 30: y = (cos(x + 4.0))^4\n * Példa:\n *   f_3(40) visszaadja \"Not define\"\n */\nstd::string f_3(int x)", "es": "#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <string>\n/**\n * Calcula el valor de la función para una entrada dada.\n * Parámetros:\n * - x (int): Valor de entrada para la función.\n * Retorna:\n * - std::string: Si x no está en el dominio definido, retorna \"Not define\".\n *   De lo contrario, retorna el valor calculado de la función redondeado a 5 decimales.\n *\n * Definiciones de la función:\n * - Para 0 <= x < 10: y = cos(x + 3.0)\n * - Para 10 <= x < 20: y = (cos(x + 7.5))^2\n * - Para 20 <= x < 30: y = (cos(x + 4.0))^4\n * Ejemplo:\n *   f_3(40) retorna \"Not define\"\n */\nstd::string f_3(int x)", "arb": "#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <string>\n/**\n * حساب قيمة الدالة لمدخل معين.\n * المعطيات:\n * - x (int): قيمة المدخل للدالة.\n * يعيد:\n * - std::string: إذا لم يكن x في النطاق المحدد، يعيد \"Not define\".\n *   خلاف ذلك، يعيد قيمة الدالة المحسوبة مقربة إلى 5 منازل عشرية.\n *\n * تعريفات الدالة:\n * - لـ 0 <= x < 10: y = cos(x + 3.0)\n * - لـ 10 <= x < 20: y = (cos(x + 7.5))^2\n * - لـ 20 <= x < 30: y = (cos(x + 4.0))^4\n * مثال:\n *   f_3(40) يعيد \"Not define\"\n */\nstd::string f_3(int x)", "sw": "#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <string>\n/**\n * Hesabu thamani ya kazi kwa pembejeo iliyotolewa.\n * Vigezo:\n * - x (int): Thamani ya pembejeo kwa kazi.\n * Inarudisha:\n * - std::string: Ikiwa x haipo katika kikoa kilichobainishwa, inarudisha \"Not define\".\n *   Vinginevyo, inarudisha thamani ya kazi iliyohesabiwa iliyokatwa hadi sehemu 5 za desimali.\n *\n * Ufafanuzi wa Kazi:\n * - Kwa 0 <= x < 10: y = cos(x + 3.0)\n * - Kwa 10 <= x < 20: y = (cos(x + 7.5))^2\n * - Kwa 20 <= x < 30: y = (cos(x + 4.0))^4\n * Mfano:\n *   f_3(40) inarudisha \"Not define\"\n */\nstd::string f_3(int x)", "tr": "#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <string>\n/**\n * Belirli bir giriş için fonksiyonun değerini hesapla.\n * Parametreler:\n * - x (int): Fonksiyon için giriş değeri.\n * Döndürür:\n * - std::string: Eğer x tanımlı alanda değilse, \"Not define\" döndürür.\n *   Aksi takdirde, hesaplanan fonksiyon değerini 5 ondalık basamağa yuvarlanmış olarak döndürür.\n *\n * Fonksiyon Tanımları:\n * - 0 <= x < 10 için: y = cos(x + 3.0)\n * - 10 <= x < 20 için: y = (cos(x + 7.5))^2\n * - 20 <= x < 30 için: y = (cos(x + 4.0))^4\n * Örnek:\n *   f_3(40) \"Not define\" döndürür\n */\nstd::string f_3(int x)", "vi": "#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <string>\n/**\n * Tính giá trị của hàm cho một đầu vào nhất định.\n * Tham số:\n * - x (int): Giá trị đầu vào cho hàm.\n * Trả về:\n * - std::string: Nếu x không nằm trong miền xác định, trả về \"Not define\".\n *   Ngược lại, trả về giá trị hàm đã tính được làm tròn đến 5 chữ số thập phân.\n *\n * Định nghĩa hàm:\n * - Với 0 <= x < 10: y = cos(x + 3.0)\n * - Với 10 <= x < 20: y = (cos(x + 7.5))^2\n * - Với 20 <= x < 30: y = (cos(x + 4.0))^4\n * Ví dụ:\n *   f_3(40) trả về \"Not define\"\n */\nstd::string f_3(int x)", "id": "#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <string>\n/**\n * Menghitung nilai fungsi untuk input yang diberikan.\n * Parameter:\n * - x (int): Nilai input untuk fungsi.\n * Mengembalikan:\n * - std::string: Jika x tidak dalam domain yang ditentukan, mengembalikan \"Not define\".\n *   Jika tidak, mengembalikan nilai fungsi yang dihitung dibulatkan hingga 5 tempat desimal.\n *\n * Definisi Fungsi:\n * - Untuk 0 <= x < 10: y = cos(x + 3.0)\n * - Untuk 10 <= x < 20: y = (cos(x + 7.5))^2\n * - Untuk 20 <= x < 30: y = (cos(x + 4.0))^4\n * Contoh:\n *   f_3(40) mengembalikan \"Not define\"\n */\nstd::string f_3(int x)", "ja": "#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <string>\n/**\n * 指定された入力に対する関数の値を計算します。\n * パラメータ:\n * - x (int): 関数の入力値。\n * 戻り値:\n * - std::string: x が定義域にない場合は \"Not define\" を返します。\n *   それ以外の場合は、計算された関数の値を小数点以下5桁に丸めて返します。\n *\n * 関数定義:\n * - 0 <= x < 10 の場合: y = cos(x + 3.0)\n * - 10 <= x < 20 の場合: y = (cos(x + 7.5))^2\n * - 20 <= x < 30 の場合: y = (cos(x + 4.0))^4\n * 例:\n *   f_3(40) は \"Not define\" を返します\n */\nstd::string f_3(int x)", "ko": "#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <string>\n/**\n * 주어진 입력에 대한 함수의 값을 계산합니다.\n * 매개변수:\n * - x (int): 함수에 대한 입력 값.\n * 반환:\n * - std::string: x가 정의된 도메인에 없으면 \"Not define\"을 반환합니다.\n *   그렇지 않으면 계산된 함수 값을 소수점 5자리로 반올림하여 반환합니다.\n *\n * 함수 정의:\n * - 0 <= x < 10: y = cos(x + 3.0)\n * - 10 <= x < 20: y = (cos(x + 7.5))^2\n * - 20 <= x < 30: y = (cos(x + 4.0))^4\n * 예시:\n *   f_3(40) returns \"Not define\"\n */\nstd::string f_3(int x)", "ml": "#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <string>\n/**\n * നൽകിയ ഇൻപുട്ടിനായി ഫംഗ്ഷന്റെ മൂല്യം കണക്കാക്കുക.\n * പാരാമീറ്ററുകൾ:\n * - x (int): ഫംഗ്ഷനുള്ള ഇൻപുട്ട് മൂല്യം.\n * റിട്ടേൺസ്:\n * - std::string: x നിർവ്വചിച്ച ഡൊമെയിനിൽ ഇല്ലെങ്കിൽ, \"Not define\" റിട്ടേൺ ചെയ്യുന്നു.\n *   അല്ലെങ്കിൽ, കണക്കാക്കിയ ഫംഗ്ഷൻ മൂല്യം 5 ദശാംശ സ്ഥാനങ്ങളിൽ വട്ടമിടുന്നു.\n *\n * ഫംഗ്ഷൻ നിർവ്വചനങ്ങൾ:\n * - 0 <= x < 10: y = cos(x + 3.0)\n * - 10 <= x < 20: y = (cos(x + 7.5))^2\n * - 20 <= x < 30: y = (cos(x + 4.0))^4\n * ഉദാഹരണം:\n *   f_3(40) \"Not define\" റിട്ടേൺ ചെയ്യുന്നു\n */\nstd::string f_3(int x)", "fa": "#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <string>\n/**\n * محاسبه مقدار تابع برای یک ورودی داده شده.\n * پارامترها:\n * - x (int): مقدار ورودی برای تابع.\n * بازگشت:\n * - std::string: اگر x در دامنه تعریف شده نباشد، \"Not define\" را برمی‌گرداند.\n *   در غیر این صورت، مقدار محاسبه شده تابع را با گرد کردن به 5 رقم اعشار برمی‌گرداند.\n *\n * تعاریف تابع:\n * - برای 0 <= x < 10: y = cos(x + 3.0)\n * - برای 10 <= x < 20: y = (cos(x + 7.5))^2\n * - برای 20 <= x < 30: y = (cos(x + 4.0))^4\n * مثال:\n *   f_3(40) returns \"Not define\"\n */\nstd::string f_3(int x)"}, "canonical_solution": "{\n    char output[50]; // Buffer to hold the output string.\n\n    if (0 <= x && x < 10) {\n        snprintf(output, sizeof(output), \"%.5f\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return std::string(output);\n}", "instruction": {"en": "std::string f_3(int x)\n{\n    char output[50]; // Buffer to hold the output string.\n\n    if (0 <= x && x < 10) {\n        snprintf(output, sizeof(output), \"%.5f\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return std::string(output);\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.", "sq": "std::string f_3(int x)\n{\n    char output[50]; // Buffer to hold the output string.\n\n    if (0 <= x && x < 10) {\n        snprintf(output, sizeof(output), \"%.5f\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return std::string(output);\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit CPP në shqip duke përdorur maksimumi 500 karaktere.", "hy": "std::string f_3(int x)\n{\n    char output[50]; // Buffer to hold the output string.\n\n    if (0 <= x && x < 10) {\n        snprintf(output, sizeof(output), \"%.5f\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return std::string(output);\n}\n\nՏվեք CPP կոդի համառոտ բնական լեզվով նկարագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "std::string f_3(int x)\n{\n    char output[50]; // Buffer to hold the output string.\n\n    if (0 <= x && x < 10) {\n        snprintf(output, sizeof(output), \"%.5f\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return std::string(output);\n}\n\nসিপিপি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলা ভাষায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।", "bg": "std::string f_3(int x)\n{\n    char output[50]; // Buffer to hold the output string.\n\n    if (0 <= x && x < 10) {\n        snprintf(output, sizeof(output), \"%.5f\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return std::string(output);\n}\n\nПредоставете кратко описание на CPP кода на български език, използвайки не повече от 500 знака.", "zh": "std::string f_3(int x)\n{\n    char output[50]; // Buffer to hold the output string.\n\n    if (0 <= x && x < 10) {\n        snprintf(output, sizeof(output), \"%.5f\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return std::string(output);\n}\n\n请用最多500个字符的中文对该CPP代码提供简洁的自然语言描述（文档字符串）。", "fr": "std::string f_3(int x)\n{\n    char output[50]; // Buffer to hold the output string.\n\n    if (0 <= x && x < 10) {\n        snprintf(output, sizeof(output), \"%.5f\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return std::string(output);\n}\n\nFournissez une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.", "de": "std::string f_3(int x)\n{\n    char output[50]; // Buffer to hold the output string.\n\n    if (0 <= x && x < 10) {\n        snprintf(output, sizeof(output), \"%.5f\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return std::string(output);\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen.", "ha": "std::string f_3(int x)\n{\n    char output[50]; // Buffer to hold the output string.\n\n    if (0 <= x && x < 10) {\n        snprintf(output, sizeof(output), \"%.5f\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return std::string(output);\n}\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar CPP a cikin Hausa ta amfani da haruffa 500 kacal.", "hi": "std::string f_3(int x)\n{\n    char output[50]; // Buffer to hold the output string.\n\n    if (0 <= x && x < 10) {\n        snprintf(output, sizeof(output), \"%.5f\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return std::string(output);\n}\n\nसीपीपी कोड का संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में अधिकतम 500 वर्णों में प्रदान करें।", "hu": "std::string f_3(int x)\n{\n    char output[50]; // Buffer to hold the output string.\n\n    if (0 <= x && x < 10) {\n        snprintf(output, sizeof(output), \"%.5f\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return std::string(output);\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a CPP kódról magyarul, legfeljebb 500 karakterben.", "es": "std::string f_3(int x)\n{\n    char output[50]; // Buffer to hold the output string.\n\n    if (0 <= x && x < 10) {\n        snprintf(output, sizeof(output), \"%.5f\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return std::string(output);\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando como máximo 500 caracteres.", "arb": "std::string f_3(int x)\n{\n    char output[50]; // Buffer to hold the output string.\n\n    if (0 <= x && x < 10) {\n        snprintf(output, sizeof(output), \"%.5f\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return std::string(output);\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) للكود المكتوب بلغة C++ باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.", "sw": "std::string f_3(int x)\n{\n    char output[50]; // Buffer to hold the output string.\n\n    if (0 <= x && x < 10) {\n        snprintf(output, sizeof(output), \"%.5f\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return std::string(output);\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "std::string f_3(int x)\n{\n    char output[50]; // Buffer to hold the output string.\n\n    if (0 <= x && x < 10) {\n        snprintf(output, sizeof(output), \"%.5f\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return std::string(output);\n}\n\nAşağıdaki CPP kodunun Türkçe'de en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.", "vi": "std::string f_3(int x)\n{\n    char output[50]; // Buffer to hold the output string.\n\n    if (0 <= x && x < 10) {\n        snprintf(output, sizeof(output), \"%.5f\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return std::string(output);\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự.", "id": "std::string f_3(int x)\n{\n    char output[50]; // Buffer to hold the output string.\n\n    if (0 <= x && x < 10) {\n        snprintf(output, sizeof(output), \"%.5f\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return std::string(output);\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode CPP dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "std::string f_3(int x)\n{\n    char output[50]; // Buffer to hold the output string.\n\n    if (0 <= x && x < 10) {\n        snprintf(output, sizeof(output), \"%.5f\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return std::string(output);\n}\n\n以下のCPPコードに対して、500文字以内で簡潔な自然言語の説明（ドックストリング）を日本語で提供してください。", "ko": "std::string f_3(int x)\n{\n    char output[50]; // Buffer to hold the output string.\n\n    if (0 <= x && x < 10) {\n        snprintf(output, sizeof(output), \"%.5f\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return std::string(output);\n}\n\n다음 CPP 코드의 기능을 설명하는 간결한 자연어 설명(도크스트링)을 한국어로 작성하세요. 500자 이내로 작성해야 합니다.", "ml": "std::string f_3(int x)\n{\n    char output[50]; // Buffer to hold the output string.\n\n    if (0 <= x && x < 10) {\n        snprintf(output, sizeof(output), \"%.5f\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return std::string(output);\n}\n\nസിപിപി കോഡിന് 500 അക്ഷരത്തിൽ കൂടുതൽ അല്ലാത്ത മലയാളത്തിൽ സംക്ഷിപ്തമായ സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) നൽകുക.", "fa": "std::string f_3(int x)\n{\n    char output[50]; // Buffer to hold the output string.\n\n    if (0 <= x && x < 10) {\n        snprintf(output, sizeof(output), \"%.5f\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return std::string(output);\n}\n\nتوضیح مختصر و طبیعی (docstring) از کد CPP به زبان فارسی ارائه دهید که حداکثر ۵۰۰ کاراکتر باشد."}, "level": "", "test": "int main() {\n    assert(f_3(40) == \"Not define\");\n\n    // Additional test cases based on provided function definitions\n    assert(f_3(5) == \"-0.14550\");\n    assert(f_3(15) == \"0.76266\");\n    assert(f_3(25) == \"0.31314\");\n    assert(f_3(-1) == \"Not define\");\n\n    // std::cout << \"All tests passed successfully.\" << std::endl;\n\n    return 0;\n}", "entry_point": "f_3", "signature": "std::string f_3(int x)", "docstring": {"en": "Calculate the value of the function for a given input. Parameters: - x (int): Input value for the function. Returns: - std::string: If x is not in the defined domain, returns \"Not define\". Otherwise, returns the calculated function value rounded to 5 decimal places. Function Definitions: - For 0 <= x < 10: y = cos(x + 3.0) - For 10 <= x < 20: y = (cos(x + 7.5))^2 - For 20 <= x < 30: y = (cos(x + 4.0))^4 Example: f_3(40) returns \"Not define\"", "sq": "Llogarit vlerën e funksionit për një hyrje të dhënë.\n\nParametrat: - x (int): Vlera e hyrjes për funksionin.\n\nKthen:\n- std::string: Nëse x nuk është në domenin e përcaktuar, kthen \"Not define\". Përndryshe, kthen vlerën e llogaritur të funksionit të rrumbullakosur në 5 vende dhjetore.\n\nPërcaktimet e Funksionit:\n- Për 0 <= x < 10: y = cos(x + 3.0)\n- Për 10 <= x < 20: y = (cos(x + 7.5))^2\n- Për 20 <= x < 30: y = (cos(x + 4.0))^4\n\nShembull:\nf_3(40) kthen \"Not define\"", "hy": "Հաշվարկել ֆունկցիայի արժեքը տրված մուտքագրվածի համար։ Պարամետրեր՝ - x (int): Մուտքագրված արժեք ֆունկցիայի համար։ Վերադարձնում է՝ - std::string: Եթե x-ը սահմանված տիրույթում չէ, վերադարձնում է \"Not define\"։ Հակառակ դեպքում, վերադարձնում է հաշվարկված ֆունկցիայի արժեքը կլորացված մինչև 5 տասնորդական։ Ֆունկցիայի սահմանումներ՝ - 0 <= x < 10: y = cos(x + 3.0) - 10 <= x < 20: y = (cos(x + 7.5))^2 - 20 <= x < 30: y = (cos(x + 4.0))^4 Օրինակ՝ f_3(40) վերադարձնում է \"Not define\"", "bn": "প্রদত্ত ইনপুটের জন্য ফাংশনের মান গণনা করুন।\n\nParameters: - x (int): ফাংশনের জন্য ইনপুট মান।\n\nReturns:\n- std::string: যদি x সংজ্ঞায়িত ডোমেইনে না থাকে, তাহলে \"Not define\" রিটার্ন করে। অন্যথায়, গণনা করা ফাংশনের মান 5 দশমিক স্থানে রাউন্ড করে রিটার্ন করে।\n\nFunction Definitions:\n- For 0 <= x < 10: y = cos(x + 3.0)\n- For 10 <= x < 20: y = (cos(x + 7.5))^2\n- For 20 <= x < 30: y = (cos(x + 4.0))^4\n\nExample:\nf_3(40) returns \"Not define\"", "bg": "Изчислява стойността на функцията за даден вход. \n\nПараметри: - x (int): Входна стойност за функцията.\n\nВръща:\n- std::string: Ако x не е в определения домейн, връща \"Not define\". В противен случай, връща изчислената стойност на функцията, закръглена до 5 знака след десетичната запетая.\n\nОпределения на функцията:\n- За 0 <= x < 10: y = cos(x + 3.0)\n- За 10 <= x < 20: y = (cos(x + 7.5))^2\n- За 20 <= x < 30: y = (cos(x + 4.0))^4\n\nПример:\nf_3(40) връща \"Not define\"", "zh": "计算给定输入的函数值。\n\n参数: - x (int): 函数的输入值。\n\n返回:\n- std::string: 如果 x 不在定义域内，返回 \"Not define\"。否则，返回计算后的函数值，保留小数点后 5 位。\n\n函数定义:\n- 对于 0 <= x < 10: y = cos(x + 3.0)\n- 对于 10 <= x < 20: y = (cos(x + 7.5))^2\n- 对于 20 <= x < 30: y = (cos(x + 4.0))^4\n\n示例:\nf_3(40) 返回 \"Not define\"", "fr": "Calculer la valeur de la fonction pour une entrée donnée. \n\nParamètres: - x (int): Valeur d'entrée pour la fonction. \n\nRenvoie: \n- std::string: Si x n'est pas dans le domaine défini, renvoie \"Not define\". Sinon, renvoie la valeur calculée de la fonction arrondie à 5 décimales. \n\nDéfinitions de fonction: \n- Pour 0 <= x < 10: y = cos(x + 3.0) \n- Pour 10 <= x < 20: y = (cos(x + 7.5))^2 \n- Pour 20 <= x < 30: y = (cos(x + 4.0))^4 \n\nExemple: f_3(40) renvoie \"Not define\"", "de": "Berechne den Wert der Funktion für eine gegebene Eingabe.\n\nParameter: - x (int): Eingabewert für die Funktion.\n\nRückgabewerte:\n- std::string: Wenn x nicht im definierten Bereich liegt, wird \"Not define\" zurückgegeben. Andernfalls wird der berechnete Funktionswert auf 5 Dezimalstellen gerundet zurückgegeben.\n\nFunktionsdefinitionen:\n- Für 0 <= x < 10: y = cos(x + 3.0)\n- Für 10 <= x < 20: y = (cos(x + 7.5))^2\n- Für 20 <= x < 30: y = (cos(x + 4.0))^4\n\nBeispiel:\nf_3(40) gibt \"Not define\" zurück.", "ha": "Lissafa ƙimar aikin don wani shigarwa da aka bayar.\n\nSigogi: - x (int): Ƙimar shigarwa don aikin.\n\nReturns:\n    - std::string: Idan x ba ya cikin yankin da aka ayyana, yana dawowa \"Not define\". In ba haka ba, yana dawowa da ƙimar aikin da aka lissafa tare da zagaye zuwa wurare 5 na ƙidaya.\n\nFunction Definitions:\n    - Don 0 <= x < 10: y = cos(x + 3.0)\n    - Don 10 <= x < 20: y = (cos(x + 7.5))^2\n    - Don 20 <= x < 30: y = (cos(x + 4.0))^4\n\nExample:\n    f_3(40) returns \"Not define\"", "hi": "दिए गए इनपुट के लिए फ़ंक्शन का मान गणना करें।\n\nपैरामीटर्स: - x (int): फ़ंक्शन के लिए इनपुट मान।\n\nReturns:\n- std::string: यदि x परिभाषित डोमेन में नहीं है, तो \"Not define\" लौटाता है। अन्यथा, गणना किए गए फ़ंक्शन मान को 5 दशमलव स्थानों तक राउंड करके लौटाता है।\n\nFunction Definitions:\n- For 0 <= x < 10: y = cos(x + 3.0)\n- For 10 <= x < 20: y = (cos(x + 7.5))^2\n- For 20 <= x < 30: y = (cos(x + 4.0))^4\n\nExample:\nf_3(40) returns \"Not define\"", "hu": "Számítsa ki a függvény értékét egy adott bemenethez. Paraméterek: - x (int): A függvény bemeneti értéke. Visszatér: - std::string: Ha x nincs a meghatározott tartományban, \"Not define\" értéket ad vissza. Ellenkező esetben a kiszámított függvényértéket adja vissza, 5 tizedesjegyre kerekítve. Függvénydefiníciók: - Ha 0 <= x < 10: y = cos(x + 3.0) - Ha 10 <= x < 20: y = (cos(x + 7.5))^2 - Ha 20 <= x < 30: y = (cos(x + 4.0))^4 Példa: f_3(40) visszatér \"Not define\"", "es": "Calcular el valor de la función para una entrada dada. Parámetros: - x (int): Valor de entrada para la función. Devuelve: - std::string: Si x no está en el dominio definido, devuelve \"Not define\". De lo contrario, devuelve el valor calculado de la función redondeado a 5 decimales. Definiciones de Función: - Para 0 <= x < 10: y = cos(x + 3.0) - Para 10 <= x < 20: y = (cos(x + 7.5))^2 - Para 20 <= x < 30: y = (cos(x + 4.0))^4 Ejemplo: f_3(40) devuelve \"Not define\"", "arb": "احسب قيمة الدالة لإدخال معين.  \nالمعلمات:  \n- x (int): قيمة الإدخال للدالة.  \nالقيم المعادة:  \n- std::string: إذا لم يكن x في النطاق المحدد، يعيد \"غير معرف\". خلاف ذلك، يعيد قيمة الدالة المحسوبة مقربة إلى 5 منازل عشرية.  \nتعريفات الدالة:  \n- لـ 0 <= x < 10: y = cos(x + 3.0)  \n- لـ 10 <= x < 20: y = (cos(x + 7.5))^2  \n- لـ 20 <= x < 30: y = (cos(x + 4.0))^4  \nمثال:  \nf_3(40) يعيد \"غير معرف\"", "sw": "Hesabu thamani ya kazi kwa pembejeo iliyotolewa.\n\nVigezo:\n- x (int): Thamani ya pembejeo kwa kazi.\n\nInarejesha:\n- std::string: Ikiwa x haipo katika kikoa kilichobainishwa, inarejesha \"Not define\". Vinginevyo, inarejesha thamani ya kazi iliyohesabiwa iliyozungushwa hadi sehemu tano za desimali.\n\nUfafanuzi wa Kazi:\n- Kwa 0 <= x < 10: y = cos(x + 3.0)\n- Kwa 10 <= x < 20: y = (cos(x + 7.5))^2\n- Kwa 20 <= x < 30: y = (cos(x + 4.0))^4\n\nMfano:\nf_3(40) inarejesha \"Not define\"", "tr": "Belirli bir giriş için fonksiyonun değerini hesapla.\n\nParametreler:\n- x (int): Fonksiyon için giriş değeri.\n\nDöndürülenler:\n- std::string: Eğer x tanımlı alanda değilse, \"Not define\" döner. Aksi takdirde, hesaplanan fonksiyon değerini 5 ondalık basamağa yuvarlanmış olarak döner.\n\nFonksiyon Tanımları:\n- 0 <= x < 10 için: y = cos(x + 3.0)\n- 10 <= x < 20 için: y = (cos(x + 7.5))^2\n- 20 <= x < 30 için: y = (cos(x + 4.0))^4\n\nÖrnek:\nf_3(40) returns \"Not define\"", "vi": "Tính giá trị của hàm cho một đầu vào nhất định.\n\nTham số:\n- x (int): Giá trị đầu vào cho hàm.\n\nTrả về:\n- std::string: Nếu x không nằm trong miền xác định, trả về \"Not define\". Ngược lại, trả về giá trị hàm đã tính toán được làm tròn đến 5 chữ số thập phân.\n\nĐịnh nghĩa hàm:\n- Đối với 0 <= x < 10: y = cos(x + 3.0)\n- Đối với 10 <= x < 20: y = (cos(x + 7.5))^2\n- Đối với 20 <= x < 30: y = (cos(x + 4.0))^4\n\nVí dụ:\nf_3(40) trả về \"Not define\"", "id": "Hitung nilai fungsi untuk input yang diberikan.  \nParameter:  \n- x (int): Nilai input untuk fungsi.  \n\nMengembalikan:  \n- std::string: Jika x tidak dalam domain yang ditentukan, mengembalikan \"Not define\". Jika tidak, mengembalikan nilai fungsi yang dihitung dibulatkan ke 5 tempat desimal.  \n\nDefinisi Fungsi:  \n- Untuk 0 <= x < 10: y = cos(x + 3.0)  \n- Untuk 10 <= x < 20: y = (cos(x + 7.5))^2  \n- Untuk 20 <= x < 30: y = (cos(x + 4.0))^4  \n\nContoh:  \nf_3(40) mengembalikan \"Not define\"  ", "ja": "関数の値を指定された入力に対して計算します。\n\nパラメータ:\n- x (int): 関数の入力値。\n\n戻り値:\n- std::string: x が定義された範囲にない場合は \"Not define\" を返します。それ以外の場合は、計算された関数の値を小数点以下5桁に丸めて返します。\n\n関数定義:\n- 0 <= x < 10 の場合: y = cos(x + 3.0)\n- 10 <= x < 20 の場合: y = (cos(x + 7.5))^2\n- 20 <= x < 30 の場合: y = (cos(x + 4.0))^4\n\n例:\nf_3(40) は \"Not define\" を返します。", "ko": "주어진 입력에 대한 함수의 값을 계산합니다. \n\n매개변수:\n- x (int): 함수에 대한 입력 값입니다.\n\n반환:\n- std::string: x가 정의된 도메인에 없으면 \"Not define\"을 반환합니다. 그렇지 않으면 계산된 함수 값을 소수점 5자리로 반올림하여 반환합니다.\n\n함수 정의:\n- 0 <= x < 10: y = cos(x + 3.0)\n- 10 <= x < 20: y = (cos(x + 7.5))^2\n- 20 <= x < 30: y = (cos(x + 4.0))^4\n\n예제:\nf_3(40) returns \"Not define\"", "ml": "നൽകിയ ഇൻപുട്ടിനായി ഫംഗ്ഷന്റെ മൂല്യം കണക്കാക്കുക.\n\nParameters:\n- x (int): ഫംഗ്ഷനു വേണ്ടി നൽകുന്ന ഇൻപുട്ട് മൂല്യം.\n\nReturns:\n- std::string: x നിർവ്വചിച്ചിരിക്കുന്ന ഡൊമൈനിൽ ഇല്ലെങ്കിൽ, \"Not define\" എന്നത് തിരികെ നൽകുന്നു. അല്ലെങ്കിൽ, കൃത്യമായ 5 ദശാംശ സ്ഥാനങ്ങൾ വരെയുള്ള ഫംഗ്ഷൻ മൂല്യം തിരികെ നൽകുന്നു.\n\nFunction Definitions:\n- 0 <= x < 10: y = cos(x + 3.0)\n- 10 <= x < 20: y = (cos(x + 7.5))^2\n- 20 <= x < 30: y = (cos(x + 4.0))^4\n\nExample:\nf_3(40) returns \"Not define\"", "fa": "محاسبه مقدار تابع برای یک ورودی داده شده.\n\nپارامترها:\n- x (int): مقدار ورودی برای تابع.\n\nبازگشت:\n- std::string: اگر x در دامنه تعریف شده نباشد، \"Not define\" را برمی‌گرداند. در غیر این صورت، مقدار محاسبه شده تابع را با گرد کردن به 5 رقم اعشار برمی‌گرداند.\n\nتعاریف تابع:\n- برای 0 <= x < 10: y = cos(x + 3.0)\n- برای 10 <= x < 20: y = (cos(x + 7.5))^2\n- برای 20 <= x < 30: y = (cos(x + 4.0))^4\n\nمثال:\nf_3(40) returns \"Not define\""}}
{"task_id": "CPP/4", "prompt": {"en": "#include <cassert>\n#include <cstdio>\n/*\nFind the maximum and minimum of three distinct integers.\nParameters:\na (int): The first integer.\nb (int): The second integer.\nc (int): The third integer.\n\nReturns:\nTuple[int, int]: A tuple is not a concept in C; instead, we will return by reference.\n\n>>> Example call: \nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid f_4(int a, int b, int c, int *max, int *min)", "sq": "#include <cassert>\n#include <cstdio>\n/*\nGjeni maksimumin dhe minimumin e tre numrave të plotë të ndryshëm.\nParametrat:\na (int): Numri i parë i plotë.\nb (int): Numri i dytë i plotë.\nc (int): Numri i tretë i plotë.\n\nKthen:\nTuple[int, int]: Një tuple nuk është një koncept në C; në vend të kësaj, ne do të kthejmë me referencë.\n\n>>> Shembull thirrjeje: \nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid f_4(int a, int b, int c, int *max, int *min)", "hy": "#include <cassert>\n#include <cstdio>\n/*\nԳտնել երեք տարբեր ամբողջ թվերի առավելագույնը և նվազագույնը։\nՊարամետրեր:\na (int): Առաջին ամբողջ թիվը։\nb (int): Երկրորդ ամբողջ թիվը։\nc (int): Երրորդ ամբողջ թիվը։\n\nՎերադարձնում է:\nTuple[int, int]: Tuple-ը հասկացություն չէ C-ում; փոխարենը մենք կվերադարձնենք հղումով։\n\n>>> Օրինակ զանգ:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid f_4(int a, int b, int c, int *max, int *min)", "bn": "#include <cassert>\n#include <cstdio>\n/*\nতিনটি ভিন্ন পূর্ণসংখ্যার মধ্যে সর্বাধিক এবং সর্বনিম্ন খুঁজে বের করুন।\nপ্যারামিটারসমূহ:\na (int): প্রথম পূর্ণসংখ্যা।\nb (int): দ্বিতীয় পূর্ণসংখ্যা।\nc (int): তৃতীয় পূর্ণসংখ্যা।\n\nফেরত দেয়:\nTuple[int, int]: C তে একটি টিউপল ধারণা নয়; পরিবর্তে, আমরা রেফারেন্স দ্বারা ফেরত দেব।\n\n>>> উদাহরণ কল:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid f_4(int a, int b, int c, int *max, int *min)", "bg": "#include <cassert>\n#include <cstdio>\n/*\nНамерете максимума и минимума на три различни цели числа.\nПараметри:\na (int): Първото цяло число.\nb (int): Второто цяло число.\nc (int): Третото цяло число.\n\nВръща:\nTuple[int, int]: Кортеж не е концепция в C; вместо това ще върнем чрез препратка.\n\n>>> Примерно извикване: \nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid f_4(int a, int b, int c, int *max, int *min)", "zh": "#include <cassert>\n#include <cstdio>\n/*\n寻找三个不同整数的最大值和最小值。\n参数：\na (int): 第一个整数。\nb (int): 第二个整数。\nc (int): 第三个整数。\n\n返回：\nTuple[int, int]: 在C语言中没有元组的概念，我们将通过引用返回。\n\n>>> 示例调用: \nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid f_4(int a, int b, int c, int *max, int *min)", "fr": "#include <cassert>\n#include <cstdio>\n/*\nTrouver le maximum et le minimum de trois entiers distincts.\nParamètres :\na (int) : Le premier entier.\nb (int) : Le deuxième entier.\nc (int) : Le troisième entier.\n\nRenvoie :\nTuple[int, int] : Un tuple n'est pas un concept en C ; à la place, nous allons retourner par référence.\n\n>>> Exemple d'appel : \nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid f_4(int a, int b, int c, int *max, int *min)", "de": "#include <cassert>\n#include <cstdio>\n/*\nFinde das Maximum und Minimum von drei verschiedenen ganzen Zahlen.\nParameter:\na (int): Die erste ganze Zahl.\nb (int): Die zweite ganze Zahl.\nc (int): Die dritte ganze Zahl.\n\nRückgabewert:\nTuple[int, int]: Ein Tupel ist kein Konzept in C; stattdessen werden wir durch Referenz zurückgeben.\n\n>>> Beispielaufruf: \nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid f_4(int a, int b, int c, int *max, int *min)", "ha": "#include <cassert>\n#include <cstdio>\n/*\nNemo mafi girma da mafi ƙanƙanta daga cikin lambobi guda uku masu bambanci.\nSigogi:\na (int): Lamba ta farko.\nb (int): Lamba ta biyu.\nc (int): Lamba ta uku.\n\nDawowa:\nTuple[int, int]: Ba a amfani da ra'ayin tuple a cikin C; maimakon haka, za mu dawo ta hanyar nuni.\n\n>>> Misalin kira: \nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid f_4(int a, int b, int c, int *max, int *min)", "hi": "#include <cassert>\n#include <cstdio>\n/*\nतीन भिन्न पूर्णांकों का अधिकतम और न्यूनतम मान खोजें।\nपैरामीटर्स:\na (int): पहला पूर्णांक।\nb (int): दूसरा पूर्णांक।\nc (int): तीसरा पूर्णांक।\n\nवापसी मान:\nTuple[int, int]: C में एक ट्यूपल की अवधारणा नहीं है; इसके बजाय, हम संदर्भ द्वारा लौटाएंगे।\n\n>>> उदाहरण कॉल:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid f_4(int a, int b, int c, int *max, int *min)", "hu": "#include <cassert>\n#include <cstdio>\n/*\nKeresse meg három különböző egész szám maximumát és minimumát.\nParaméterek:\na (int): Az első egész szám.\nb (int): A második egész szám.\nc (int): A harmadik egész szám.\n\nVisszatérési érték:\nTuple[int, int]: A tuple nem egy fogalom a C nyelvben; helyette referencia szerint fogunk visszatérni.\n\n>>> Példa hívás: \nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid f_4(int a, int b, int c, int *max, int *min)", "es": "#include <cassert>\n#include <cstdio>\n/*\nEncuentra el máximo y el mínimo de tres enteros distintos.\nParámetros:\na (int): El primer entero.\nb (int): El segundo entero.\nc (int): El tercer entero.\n\nDevuelve:\nTuple[int, int]: Una tupla no es un concepto en C; en su lugar, devolveremos por referencia.\n\n>>> Llamada de ejemplo: \nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid f_4(int a, int b, int c, int *max, int *min)", "arb": "#include <cassert>\n#include <cstdio>\n/*\nالعثور على الحد الأقصى والأدنى من ثلاثة أعداد صحيحة مميزة.\nالمعلمات:\na (int): العدد الصحيح الأول.\nb (int): العدد الصحيح الثاني.\nc (int): العدد الصحيح الثالث.\n\nالإرجاع:\nTuple[int, int]: الزوج المرتب ليس مفهومًا في C؛ بدلاً من ذلك، سنعيده بالإشارة.\n\n>>> مثال على الاستدعاء: \nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid f_4(int a, int b, int c, int *max, int *min)", "sw": "#include <cassert>\n#include <cstdio>\n/*\nPata kubwa na ndogo kati ya nambari tatu tofauti.\nVigezo:\na (int): Nambari ya kwanza.\nb (int): Nambari ya pili.\nc (int): Nambari ya tatu.\n\nInarejesha:\nTuple[int, int]: Tuple si dhana katika C; badala yake, tutarejesha kwa marejeleo.\n\n>>> Mfano wa kupiga:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid f_4(int a, int b, int c, int *max, int *min)", "tr": "#include <cassert>\n#include <cstdio>\n/*\nÜç farklı tam sayının maksimum ve minimumunu bulun.\nParametreler:\na (int): Birinci tam sayı.\nb (int): İkinci tam sayı.\nc (int): Üçüncü tam sayı.\n\nDöndürür:\nTuple[int, int]: C'de tuple bir kavram değildir; bunun yerine referansla döneceğiz.\n\n>>> Örnek çağrı: \nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid f_4(int a, int b, int c, int *max, int *min)", "vi": "#include <cassert>\n#include <cstdio>\n/*\nTìm giá trị lớn nhất và nhỏ nhất của ba số nguyên khác nhau.\nTham số:\na (int): Số nguyên thứ nhất.\nb (int): Số nguyên thứ hai.\nc (int): Số nguyên thứ ba.\n\nTrả về:\nTuple[int, int]: Một tuple không phải là khái niệm trong C; thay vào đó, chúng ta sẽ trả về bằng tham chiếu.\n\n>>> Ví dụ gọi:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid f_4(int a, int b, int c, int *max, int *min)", "id": "#include <cassert>\n#include <cstdio>\n/*\nTemukan nilai maksimum dan minimum dari tiga bilangan bulat yang berbeda.\nParameter:\na (int): Bilangan bulat pertama.\nb (int): Bilangan bulat kedua.\nc (int): Bilangan bulat ketiga.\n\nMengembalikan:\nTuple[int, int]: Tuple bukanlah konsep dalam C; sebagai gantinya, kita akan mengembalikan melalui referensi.\n\n>>> Contoh panggilan: \nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid f_4(int a, int b, int c, int *max, int *min)", "ja": "#include <cassert>\n#include <cstdio>\n/*\n3つの異なる整数の最大値と最小値を見つけます。\nパラメータ:\na (int): 最初の整数。\nb (int): 2番目の整数。\nc (int): 3番目の整数。\n\n戻り値:\nTuple[int, int]: Cではタプルという概念はないため、参照によって返します。\n\n>>> 例の呼び出し: \nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid f_4(int a, int b, int c, int *max, int *min)", "ko": "#include <cassert>\n#include <cstdio>\n/*\n세 개의 서로 다른 정수의 최대값과 최소값을 찾습니다.\n매개변수:\na (int): 첫 번째 정수.\nb (int): 두 번째 정수.\nc (int): 세 번째 정수.\n\n반환값:\nTuple[int, int]: 튜플은 C에서 개념이 아니므로, 참조로 반환합니다.\n\n>>> 예시 호출: \nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid f_4(int a, int b, int c, int *max, int *min)", "ml": "#include <cassert>\n#include <cstdio>\n/*\nമൂന്ന് വ്യത്യസ്തമായ പൂർണ്ണസംഖ്യകളുടെ പരമാവധി, കുറഞ്ഞത് കണ്ടെത്തുക.\nപാരാമീറ്ററുകൾ:\na (int): ആദ്യത്തെ പൂർണ്ണസംഖ്യ.\nb (int): രണ്ടാം പൂർണ്ണസംഖ്യ.\nc (int): മൂന്നാം പൂർണ്ണസംഖ്യ.\n\nമടക്കുക:\nTuple[int, int]: C-യിൽ ട്യൂപ്പിൾ എന്ന ആശയം ഇല്ല; പകരം, നാം റഫറൻസിലൂടെ മടക്കും.\n\n>>> ഉദാഹരണ കോൾ:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid f_4(int a, int b, int c, int *max, int *min)", "fa": "#include <cassert>\n#include <cstdio>\n/*\nبیشینه و کمینه سه عدد صحیح متمایز را پیدا کنید.\nپارامترها:\na (int): عدد صحیح اول.\nb (int): عدد صحیح دوم.\nc (int): عدد صحیح سوم.\n\nبازگشت:\nTuple[int, int]: تاپل یک مفهوم در C نیست؛ در عوض، ما با ارجاع برمی‌گردیم.\n\n>>> مثال فراخوانی: \nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid f_4(int a, int b, int c, int *max, int *min)"}, "canonical_solution": "{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else if (b > c) {\n        *max = b;\n        *min = (a < c) ? a : c;\n    } else {\n        *max = c;\n        *min = a;\n    }\n}", "instruction": {"en": "void f_4(int a, int b, int c, int *max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else if (b > c) {\n        *max = b;\n        *min = (a < c) ? a : c;\n    } else {\n        *max = c;\n        *min = a;\n    }\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.", "sq": "void f_4(int a, int b, int c, int *max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else if (b > c) {\n        *max = b;\n        *min = (a < c) ? a : c;\n    } else {\n        *max = c;\n        *min = a;\n    }\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit CPP në shqip duke përdorur maksimumi 500 karaktere.", "hy": "void f_4(int a, int b, int c, int *max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else if (b > c) {\n        *max = b;\n        *min = (a < c) ? a : c;\n    } else {\n        *max = c;\n        *min = a;\n    }\n}\n\nՏվեք CPP կոդի հակիրճ բնութագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "void f_4(int a, int b, int c, int *max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else if (b > c) {\n        *max = b;\n        *min = (a < c) ? a : c;\n    } else {\n        *max = c;\n        *min = a;\n    }\n}\n\nসিপিপি কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।", "bg": "void f_4(int a, int b, int c, int *max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else if (b > c) {\n        *max = b;\n        *min = (a < c) ? a : c;\n    } else {\n        *max = c;\n        *min = a;\n    }\n}\n\nПредоставете кратко описание на CPP кода на естествен език (docstring) на български, използвайки най-много 500 знака.", "zh": "void f_4(int a, int b, int c, int *max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else if (b > c) {\n        *max = b;\n        *min = (a < c) ? a : c;\n    } else {\n        *max = c;\n        *min = a;\n    }\n}\n\n请用最多500个字符的中文对该CPP代码提供简洁的自然语言描述（文档字符串）。", "fr": "void f_4(int a, int b, int c, int *max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else if (b > c) {\n        *max = b;\n        *min = (a < c) ? a : c;\n    } else {\n        *max = c;\n        *min = a;\n    }\n}\n\nFournir une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.", "de": "void f_4(int a, int b, int c, int *max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else if (b > c) {\n        *max = b;\n        *min = (a < c) ? a : c;\n    } else {\n        *max = c;\n        *min = a;\n    }\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen.", "ha": "void f_4(int a, int b, int c, int *max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else if (b > c) {\n        *max = b;\n        *min = (a < c) ? a : c;\n    } else {\n        *max = c;\n        *min = a;\n    }\n}\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar CPP cikin Hausa ta amfani da haruffa 500 kacal.", "hi": "void f_4(int a, int b, int c, int *max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else if (b > c) {\n        *max = b;\n        *min = (a < c) ? a : c;\n    } else {\n        *max = c;\n        *min = a;\n    }\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 अक्षरों में हो।", "hu": "void f_4(int a, int b, int c, int *max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else if (b > c) {\n        *max = b;\n        *min = (a < c) ? a : c;\n    } else {\n        *max = c;\n        *min = a;\n    }\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a CPP kódról magyarul, legfeljebb 500 karakterben.", "es": "void f_4(int a, int b, int c, int *max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else if (b > c) {\n        *max = b;\n        *min = (a < c) ? a : c;\n    } else {\n        *max = c;\n        *min = a;\n    }\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando como máximo 500 caracteres.", "arb": "void f_4(int a, int b, int c, int *max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else if (b > c) {\n        *max = b;\n        *min = (a < c) ? a : c;\n    } else {\n        *max = c;\n        *min = a;\n    }\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية بلغة C++ باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "void f_4(int a, int b, int c, int *max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else if (b > c) {\n        *max = b;\n        *min = (a < c) ? a : c;\n    } else {\n        *max = c;\n        *min = a;\n    }\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "void f_4(int a, int b, int c, int *max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else if (b > c) {\n        *max = b;\n        *min = (a < c) ? a : c;\n    } else {\n        *max = c;\n        *min = a;\n    }\n}\n\nAşağıdaki CPP kodunun Türkçe olarak en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.", "vi": "void f_4(int a, int b, int c, int *max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else if (b > c) {\n        *max = b;\n        *min = (a < c) ? a : c;\n    } else {\n        *max = c;\n        *min = a;\n    }\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự.", "id": "void f_4(int a, int b, int c, int *max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else if (b > c) {\n        *max = b;\n        *min = (a < c) ? a : c;\n    } else {\n        *max = c;\n        *min = a;\n    }\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode CPP dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "void f_4(int a, int b, int c, int *max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else if (b > c) {\n        *max = b;\n        *min = (a < c) ? a : c;\n    } else {\n        *max = c;\n        *min = a;\n    }\n}\n\n以下のCPPコードの簡潔な自然言語による説明（ドックストリング）を日本語で500文字以内で提供してください。", "ko": "void f_4(int a, int b, int c, int *max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else if (b > c) {\n        *max = b;\n        *min = (a < c) ? a : c;\n    } else {\n        *max = c;\n        *min = a;\n    }\n}\n\n다음 CPP 코드에 대한 간결한 자연어 설명(도크스트링)을 한국어로 최대 500자 이내로 제공하세요.", "ml": "void f_4(int a, int b, int c, int *max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else if (b > c) {\n        *max = b;\n        *min = (a < c) ? a : c;\n    } else {\n        *max = c;\n        *min = a;\n    }\n}\n\nCPP കോഡ് മലയാളത്തിൽ പരമാവധി 500 അക്ഷരങ്ങളിൽ ഒരു സംക്ഷിപ്ത സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) നൽകുക.", "fa": "void f_4(int a, int b, int c, int *max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else if (b > c) {\n        *max = b;\n        *min = (a < c) ? a : c;\n    } else {\n        *max = c;\n        *min = a;\n    }\n}\n\nتوضیح مختصر و طبیعی (docstring) از کد CPP به زبان فارسی ارائه دهید که حداکثر ۵۰۰ کاراکتر باشد."}, "level": "", "test": "int main() {\n    int max, min;\n\n    // Test with a set of values\n    f_4(1, 2, 3, &max, &min);\n    assert(max == 3 && min == 1);\n\n    // Additional tests\n    f_4(5, 3, 4, &max, &min);\n    assert(max == 5 && min == 3);\n\n    f_4(10, -2, 7, &max, &min);\n    assert(max == 10 && min == -2);\n\n    f_4(-1, -3, -2, &max, &min);\n    assert(max == -1 && min == -3);\n\n    return 0;\n}", "entry_point": "f_4", "signature": "void f_4(int a, int b, int c, int *max, int *min)", "docstring": {"en": "Find the maximum and minimum of three distinct integers.\nParameters:\na (int): The first integer.\nb (int): The second integer.\nc (int): The third integer.\n\nReturns:\nTuple[int, int]: A tuple is not a concept in C; instead, we will return by reference.\n\n>>> Example call:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n", "sq": "Gjeni maksimumin dhe minimumin e tre numrave të plotë të dallueshëm.\nParametrat:\na (int): Numri i parë i plotë.\nb (int): Numri i dytë i plotë.\nc (int): Numri i tretë i plotë.\n\nKthen:\nTuple[int, int]: Një tuple nuk është një koncept në C; në vend të kësaj, ne do të kthejmë me referencë.\n\n>>> Thirrje shembull:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "hy": "Երեք տարբեր ամբողջ թվերի առավելագույնը և նվազագույնը գտնել:\nՊարամետրեր:\na (int): Առաջին ամբողջ թիվը:\nb (int): Երկրորդ ամբողջ թիվը:\nc (int): Երրորդ ամբողջ թիվը:\n\nՎերադարձնում է:\nTuple[int, int]: Կապ չի հանդիսանում C-ում հասկացություն; փոխարենը մենք կվերադարձնենք հղումով:\n\n>>> Օրինակ կանչ:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "bn": "তিনটি ভিন্ন পূর্ণসংখ্যার সর্বাধিক এবং সর্বনিম্ন মান খুঁজে বের করুন।\nParameters:\na (int): প্রথম পূর্ণসংখ্যা।\nb (int): দ্বিতীয় পূর্ণসংখ্যা।\nc (int): তৃতীয় পূর্ণসংখ্যা।\n\nReturns:\nTuple[int, int]: একটি টিউপল C তে একটি ধারণা নয়; পরিবর্তে, আমরা রেফারেন্স দ্বারা ফেরত দেব।\n\n>>> উদাহরণ কল:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "bg": "Намерете максимума и минимума на три различни цели числа.\nПараметри:\na (int): Първото цяло число.\nb (int): Второто цяло число.\nc (int): Третото цяло число.\n\nВръща:\nTuple[int, int]: Кортежът не е концепция в C; вместо това ще върнем чрез референция.\n\n>>> Примерно извикване:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "zh": "找出三个不同整数的最大值和最小值。\n参数：\na (int): 第一个整数。\nb (int): 第二个整数。\nc (int): 第三个整数。\n\n返回：\nTuple[int, int]: 在C语言中没有元组的概念，因此我们将通过引用返回。\n\n>>> 示例调用：\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "fr": "Trouver le maximum et le minimum de trois entiers distincts.  \nParamètres :  \na (int) : Le premier entier.  \nb (int) : Le deuxième entier.  \nc (int) : Le troisième entier.  \n\nRenvoie :  \nTuple[int, int] : Un tuple n'est pas un concept en C ; à la place, nous renverrons par référence.  \n\n>>> Exemple d'appel :  \nint max, min;  \nf_4(1,2,3, &max, &min);  \nassert(max == 3 && min == 1);  ", "de": "Finde das Maximum und Minimum von drei verschiedenen ganzen Zahlen.\nParameter:\na (int): Die erste ganze Zahl.\nb (int): Die zweite ganze Zahl.\nc (int): Die dritte ganze Zahl.\n\nRückgabewerte:\nTuple[int, int]: Ein Tupel ist kein Konzept in C; stattdessen werden wir durch Referenz zurückgeben.\n\n>>> Beispielaufruf:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "ha": "Nemo mafi girma da mafi ƙanƙanta daga cikin lambobi guda uku masu bambanta.  \nSigogi:  \na (int): Lamba ta farko.  \nb (int): Lamba ta biyu.  \nc (int): Lamba ta uku.  \n\nDawowa:  \nTuple[int, int]: Tuple ba wani abu bane a cikin C; maimakon haka, za mu dawo ta hanyar tunani.  \n\n>>> Misalin kira:  \nint max, min;  \nf_4(1,2,3, &max, &min);  \nassert(max == 3 && min == 1);  ", "hi": "तीन भिन्न पूर्णांकों का अधिकतम और न्यूनतम मान खोजें।\nमापदंड:\na (int): पहला पूर्णांक।\nb (int): दूसरा पूर्णांक।\nc (int): तीसरा पूर्णांक।\n\nवापसी:\nTuple[int, int]: एक ट्यूपल C में एक अवधारणा नहीं है; इसके बजाय, हम संदर्भ द्वारा वापस करेंगे।\n\n>>> उदाहरण कॉल:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "hu": "Keresse meg három különböző egész szám maximumát és minimumát.  \nParaméterek:  \na (int): Az első egész szám.  \nb (int): A második egész szám.  \nc (int): A harmadik egész szám.  \n\nVisszatér:  \nTuple[int, int]: A tuple nem egy fogalom a C nyelvben; ehelyett referencia alapján térünk vissza.  \n\n>>> Példa hívás:  \nint max, min;  \nf_4(1,2,3, &max, &min);  \nassert(max == 3 && min == 1);  ", "es": "Encuentra el máximo y el mínimo de tres enteros distintos.\nParámetros:\na (int): El primer entero.\nb (int): El segundo entero.\nc (int): El tercer entero.\n\nDevuelve:\nTuple[int, int]: Una tupla no es un concepto en C; en su lugar, devolveremos por referencia.\n\n>>> Llamada de ejemplo:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "arb": "إيجاد القيمة القصوى والدنيا لثلاثة أعداد صحيحة مميزة.\nالمعلمات:\na (int): العدد الصحيح الأول.\nb (int): العدد الصحيح الثاني.\nc (int): العدد الصحيح الثالث.\n\nالقيم المعادة:\nTuple[int, int]: الترتيب ليس مفهومًا في C؛ بدلاً من ذلك، سنعيد بالقيمة المرجعية.\n\n>>> مثال على الاستدعاء:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "sw": "Pata kiwango cha juu na cha chini cha nambari tatu tofauti za mzima.\n\nVigezo:\na (int): Nambari ya kwanza ya mzima.\nb (int): Nambari ya pili ya mzima.\nc (int): Nambari ya tatu ya mzima.\n\nInarejesha:\nTuple[int, int]: Tuple si dhana katika C; badala yake, tutarejesha kwa marejeleo.\n\n>>> Mfano wa kupiga:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "tr": "Üç farklı tamsayının maksimum ve minimumunu bulun.  \nParametreler:  \na (int): Birinci tamsayı.  \nb (int): İkinci tamsayı.  \nc (int): Üçüncü tamsayı.  \n\nDöndürülenler:  \nTuple[int, int]: C'de bir kavram olarak tuple yoktur; bunun yerine referansla döneceğiz.\n\n>>> Örnek çağrı:  \nint max, min;  \nf_4(1,2,3, &max, &min);  \nassert(max == 3 && min == 1);  ", "vi": "Tìm giá trị lớn nhất và nhỏ nhất của ba số nguyên khác nhau.  \nTham số:  \na (int): Số nguyên thứ nhất.  \nb (int): Số nguyên thứ hai.  \nc (int): Số nguyên thứ ba.  \n\nTrả về:  \nTuple[int, int]: Một tuple không phải là khái niệm trong C; thay vào đó, chúng ta sẽ trả về bằng tham chiếu.  \n\n>>> Ví dụ gọi:  \nint max, min;  \nf_4(1,2,3, &max, &min);  \nassert(max == 3 && min == 1);  ", "id": "Temukan nilai maksimum dan minimum dari tiga bilangan bulat yang berbeda.\nParameter:\na (int): Bilangan bulat pertama.\nb (int): Bilangan bulat kedua.\nc (int): Bilangan bulat ketiga.\n\nMengembalikan:\nTuple[int, int]: Tuple bukanlah konsep dalam C; sebagai gantinya, kita akan mengembalikan melalui referensi.\n\n>>> Contoh panggilan:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "ja": "3つの異なる整数の最大値と最小値を見つけます。\n引数:\na (int): 最初の整数。\nb (int): 2番目の整数。\nc (int): 3番目の整数。\n\n戻り値:\nTuple[int, int]: タプルはCの概念ではないため、参照によって返します。\n\n>>> 呼び出し例:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "ko": "세 개의 서로 다른 정수의 최대값과 최소값을 찾습니다.\n매개변수:\na (int): 첫 번째 정수.\nb (int): 두 번째 정수.\nc (int): 세 번째 정수.\n\n반환값:\nTuple[int, int]: 튜플은 C에서 개념이 아니므로, 참조에 의해 반환합니다.\n\n>>> 예제 호출:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "ml": "മൂന്ന് വ്യത്യസ്തമായ പൂർണ്ണസംഖ്യകളിൽ ഏറ്റവും വലിയതും ഏറ്റവും ചെറിയതുമായത് കണ്ടെത്തുക.  \nപാരാമീറ്ററുകൾ:  \na (int): ആദ്യത്തെ പൂർണ്ണസംഖ്യ.  \nb (int): രണ്ടാം പൂർണ്ണസംഖ്യ.  \nc (int): മൂന്നാമത്തെ പൂർണ്ണസംഖ്യ.  \n\nമടങ്ങിവരവ്:  \nTuple[int, int]: ട്യൂപ്പിൾ എന്നത് C-യിൽ ഒരു ആശയം അല്ല; പകരം, നമുക്ക് റഫറൻസിലൂടെ മടങ്ങിവരാം.  \n\n>>> ഉദാഹരണ കോൾ:  \nint max, min;  \nf_4(1,2,3, &max, &min);  \nassert(max == 3 && min == 1);  ", "fa": "حداکثر و حداقل سه عدد صحیح متمایز را پیدا کنید.\nپارامترها:\na (int): اولین عدد صحیح.\nb (int): دومین عدد صحیح.\nc (int): سومین عدد صحیح.\n\nبازگشت:\nTuple[int, int]: تاپل یک مفهوم در C نیست؛ در عوض، ما با ارجاع بازخواهیم گشت.\n\n>>> فراخوانی نمونه:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);"}}
{"task_id": "CPP/5", "prompt": {"en": "#include <cassert>\n#include <cmath>\n#include <cstring>\n/**\n * Calculate the distance between two points A (xa, ya) and B (xb, yb).\n * \n * Parameters:\n * - xa (double): x-coordinate of point A.\n * - ya (double): y-coordinate of point A.\n * - xb (double): x-coordinate of point B.\n * - yb (double): y-coordinate of point B.\n * \n * Returns:\n * double: The distance between points A and B.\n * \n * Examples:\n * f_5(0, 0, 3, 4) returns 5\n */\ndouble f_5(double xa, double ya, double xb, double yb)", "sq": "#include <cassert>\n#include <cmath>\n#include <cstring>\n/**\n * Llogarit distancën midis dy pikave A (xa, ya) dhe B (xb, yb).\n * \n * Parametrat:\n * - xa (double): koordinata x e pikës A.\n * - ya (double): koordinata y e pikës A.\n * - xb (double): koordinata x e pikës B.\n * - yb (double): koordinata y e pikës B.\n * \n * Kthen:\n * double: Distanca midis pikave A dhe B.\n * \n * Shembuj:\n * f_5(0, 0, 3, 4) kthen 5\n */\ndouble f_5(double xa, double ya, double xb, double yb)", "hy": "#include <cassert>\n#include <cmath>\n#include <cstring>\n/**\n * Հաշվել հեռավորությունը երկու կետերի A (xa, ya) և B (xb, yb) միջև։\n * \n * Պարամետրեր:\n * - xa (double): A կետի x-կոորդինատը։\n * - ya (double): A կետի y-կոորդինատը։\n * - xb (double): B կետի x-կոորդինատը։\n * - yb (double): B կետի y-կոորդինատը։\n * \n * Վերադարձնում է:\n * double: Հեռավորությունը A և B կետերի միջև։\n * \n * Օրինակներ:\n * f_5(0, 0, 3, 4) վերադարձնում է 5\n */\ndouble f_5(double xa, double ya, double xb, double yb)", "bn": "#include <cassert>\n#include <cmath>\n#include <cstring>\n/**\n * দুটি বিন্দু A (xa, ya) এবং B (xb, yb) এর মধ্যে দূরত্ব গণনা করুন।\n * \n * প্যারামিটারসমূহ:\n * - xa (double): বিন্দু A এর x-সমন্বয়।\n * - ya (double): বিন্দু A এর y-সমন্বয়।\n * - xb (double): বিন্দু B এর x-সমন্বয়।\n * - yb (double): বিন্দু B এর y-সমন্বয়।\n * \n * রিটার্নস:\n * double: বিন্দু A এবং B এর মধ্যে দূরত্ব।\n * \n * উদাহরণ:\n * f_5(0, 0, 3, 4) 5 রিটার্ন করে\n */\ndouble f_5(double xa, double ya, double xb, double yb)", "bg": "#include <cassert>\n#include <cmath>\n#include <cstring>\n/**\n * Изчислява разстоянието между две точки A (xa, ya) и B (xb, yb).\n * \n * Параметри:\n * - xa (double): x-координата на точка A.\n * - ya (double): y-координата на точка A.\n * - xb (double): x-координата на точка B.\n * - yb (double): y-координата на точка B.\n * \n * Връща:\n * double: Разстоянието между точките A и B.\n * \n * Примери:\n * f_5(0, 0, 3, 4) връща 5\n */\ndouble f_5(double xa, double ya, double xb, double yb)", "zh": "#include <cassert>\n#include <cmath>\n#include <cstring>\n/**\n * 计算两个点 A (xa, ya) 和 B (xb, yb) 之间的距离。\n * \n * 参数:\n * - xa (double): 点 A 的 x 坐标。\n * - ya (double): 点 A 的 y 坐标。\n * - xb (double): 点 B 的 x 坐标。\n * - yb (double): 点 B 的 y 坐标。\n * \n * 返回:\n * double: 点 A 和 B 之间的距离。\n * \n * 示例:\n * f_5(0, 0, 3, 4) 返回 5\n */\ndouble f_5(double xa, double ya, double xb, double yb)", "fr": "#include <cassert>\n#include <cmath>\n#include <cstring>\n/**\n * Calculer la distance entre deux points A (xa, ya) et B (xb, yb).\n * \n * Paramètres :\n * - xa (double) : coordonnée x du point A.\n * - ya (double) : coordonnée y du point A.\n * - xb (double) : coordonnée x du point B.\n * - yb (double) : coordonnée y du point B.\n * \n * Renvoie :\n * double : La distance entre les points A et B.\n * \n * Exemples :\n * f_5(0, 0, 3, 4) returns 5\n */\ndouble f_5(double xa, double ya, double xb, double yb)", "de": "#include <cassert>\n#include <cmath>\n#include <cstring>\n/**\n * Berechne die Entfernung zwischen zwei Punkten A (xa, ya) und B (xb, yb).\n * \n * Parameter:\n * - xa (double): x-Koordinate des Punktes A.\n * - ya (double): y-Koordinate des Punktes A.\n * - xb (double): x-Koordinate des Punktes B.\n * - yb (double): y-Koordinate des Punktes B.\n * \n * Rückgabewert:\n * double: Die Entfernung zwischen den Punkten A und B.\n * \n * Beispiele:\n * f_5(0, 0, 3, 4) gibt 5 zurück\n */\ndouble f_5(double xa, double ya, double xb, double yb)", "ha": "#include <cassert>\n#include <cmath>\n#include <cstring>\n/**\n * Lissafin nisan tsakanin maki biyu A (xa, ya) da B (xb, yb).\n * \n * Sigogi:\n * - xa (double): x-daftarin maki A.\n * - ya (double): y-daftarin maki A.\n * - xb (double): x-daftarin maki B.\n * - yb (double): y-daftarin maki B.\n * \n * Komawa:\n * double: Nisan tsakanin maki A da B.\n * \n * Misalai:\n * f_5(0, 0, 3, 4) yana dawowa 5\n */\ndouble f_5(double xa, double ya, double xb, double yb)", "hi": "#include <cassert>\n#include <cmath>\n#include <cstring>\n/**\n * दो बिंदुओं A (xa, ya) और B (xb, yb) के बीच की दूरी की गणना करें।\n * \n * पैरामीटर्स:\n * - xa (double): बिंदु A का x-निर्देशांक।\n * - ya (double): बिंदु A का y-निर्देशांक।\n * - xb (double): बिंदु B का x-निर्देशांक।\n * - yb (double): बिंदु B का y-निर्देशांक।\n * \n * रिटर्न करता है:\n * double: बिंदुओं A और B के बीच की दूरी।\n * \n * उदाहरण:\n * f_5(0, 0, 3, 4) 5 लौटाता है\n */\ndouble f_5(double xa, double ya, double xb, double yb)", "hu": "#include <cassert>\n#include <cmath>\n#include <cstring>\n/**\n * Számítsa ki a távolságot két pont, A (xa, ya) és B (xb, yb) között.\n * \n * Paraméterek:\n * - xa (double): A pont x-koordinátája.\n * - ya (double): A pont y-koordinátája.\n * - xb (double): B pont x-koordinátája.\n * - yb (double): B pont y-koordinátája.\n * \n * Visszatérési érték:\n * double: Az A és B pontok közötti távolság.\n * \n * Példák:\n * f_5(0, 0, 3, 4) visszaadja 5\n */\ndouble f_5(double xa, double ya, double xb, double yb)", "es": "#include <cassert>\n#include <cmath>\n#include <cstring>\n/**\n * Calcular la distancia entre dos puntos A (xa, ya) y B (xb, yb).\n * \n * Parámetros:\n * - xa (double): coordenada x del punto A.\n * - ya (double): coordenada y del punto A.\n * - xb (double): coordenada x del punto B.\n * - yb (double): coordenada y del punto B.\n * \n * Devuelve:\n * double: La distancia entre los puntos A y B.\n * \n * Ejemplos:\n * f_5(0, 0, 3, 4) returns 5\n */\ndouble f_5(double xa, double ya, double xb, double yb)", "arb": "#include <cassert>\n#include <cmath>\n#include <cstring>\n/**\n * احسب المسافة بين نقطتين A (xa, ya) و B (xb, yb).\n * \n * المعلمات:\n * - xa (double): الإحداثي السيني للنقطة A.\n * - ya (double): الإحداثي الصادي للنقطة A.\n * - xb (double): الإحداثي السيني للنقطة B.\n * - yb (double): الإحداثي الصادي للنقطة B.\n * \n * يعيد:\n * double: المسافة بين النقطتين A و B.\n * \n * أمثلة:\n * f_5(0, 0, 3, 4) returns 5\n */\ndouble f_5(double xa, double ya, double xb, double yb)", "sw": "#include <cassert>\n#include <cmath>\n#include <cstring>\n/**\n * Hesabu umbali kati ya pointi mbili A (xa, ya) na B (xb, yb).\n * \n * Vigezo:\n * - xa (double): x-kiwango cha pointi A.\n * - ya (double): y-kiwango cha pointi A.\n * - xb (double): x-kiwango cha pointi B.\n * - yb (double): y-kiwango cha pointi B.\n * \n * Inarudisha:\n * double: Umbali kati ya pointi A na B.\n * \n * Mifano:\n * f_5(0, 0, 3, 4) inarudisha 5\n */\ndouble f_5(double xa, double ya, double xb, double yb)", "tr": "#include <cassert>\n#include <cmath>\n#include <cstring>\n/**\n * İki nokta A (xa, ya) ve B (xb, yb) arasındaki mesafeyi hesapla.\n * \n * Parametreler:\n * - xa (double): A noktasının x-koordinatı.\n * - ya (double): A noktasının y-koordinatı.\n * - xb (double): B noktasının x-koordinatı.\n * - yb (double): B noktasının y-koordinatı.\n * \n * Döndürür:\n * double: A ve B noktaları arasındaki mesafe.\n * \n * Örnekler:\n * f_5(0, 0, 3, 4) 5 döndürür\n */\ndouble f_5(double xa, double ya, double xb, double yb)", "vi": "#include <cassert>\n#include <cmath>\n#include <cstring>\n/**\n * Tính khoảng cách giữa hai điểm A (xa, ya) và B (xb, yb).\n * \n * Tham số:\n * - xa (double): tọa độ x của điểm A.\n * - ya (double): tọa độ y của điểm A.\n * - xb (double): tọa độ x của điểm B.\n * - yb (double): tọa độ y của điểm B.\n * \n * Trả về:\n * double: Khoảng cách giữa điểm A và B.\n * \n * Ví dụ:\n * f_5(0, 0, 3, 4) trả về 5\n */\ndouble f_5(double xa, double ya, double xb, double yb)", "id": "#include <cassert>\n#include <cmath>\n#include <cstring>\n/**\n * Hitung jarak antara dua titik A (xa, ya) dan B (xb, yb).\n * \n * Parameter:\n * - xa (double): koordinat x dari titik A.\n * - ya (double): koordinat y dari titik A.\n * - xb (double): koordinat x dari titik B.\n * - yb (double): koordinat y dari titik B.\n * \n * Mengembalikan:\n * double: Jarak antara titik A dan B.\n * \n * Contoh:\n * f_5(0, 0, 3, 4) mengembalikan 5\n */\ndouble f_5(double xa, double ya, double xb, double yb)", "ja": "#include <cassert>\n#include <cmath>\n#include <cstring>\n/**\n * 2点A (xa, ya) とB (xb, yb) の間の距離を計算します。\n * \n * パラメータ:\n * - xa (double): 点Aのx座標。\n * - ya (double): 点Aのy座標。\n * - xb (double): 点Bのx座標。\n * - yb (double): 点Bのy座標。\n * \n * 戻り値:\n * double: 点AとBの間の距離。\n * \n * 例:\n * f_5(0, 0, 3, 4) は5を返します\n */\ndouble f_5(double xa, double ya, double xb, double yb)", "ko": "#include <cassert>\n#include <cmath>\n#include <cstring>\n/**\n * 두 점 A (xa, ya)와 B (xb, yb) 사이의 거리를 계산합니다.\n * \n * 매개변수:\n * - xa (double): 점 A의 x-좌표.\n * - ya (double): 점 A의 y-좌표.\n * - xb (double): 점 B의 x-좌표.\n * - yb (double): 점 B의 y-좌표.\n * \n * 반환값:\n * double: 점 A와 B 사이의 거리.\n * \n * 예시:\n * f_5(0, 0, 3, 4) returns 5\n */\ndouble f_5(double xa, double ya, double xb, double yb)", "ml": "#include <cassert>\n#include <cmath>\n#include <cstring>\n/**\n * A (xa, ya) എന്ന രണ്ട് ബിന്ദുക്കളും B (xb, yb) എന്ന ബിന്ദുക്കളും തമ്മിലുള്ള ദൂരം കണക്കാക്കുക.\n * \n * പാരാമീറ്ററുകൾ:\n * - xa (double): A ബിന്ദുവിന്റെ x-കോഓർഡിനേറ്റ്.\n * - ya (double): A ബിന്ദുവിന്റെ y-കോഓർഡിനേറ്റ്.\n * - xb (double): B ബിന്ദുവിന്റെ x-കോഓർഡിനേറ്റ്.\n * - yb (double): B ബിന്ദുവിന്റെ y-കോഓർഡിനേറ്റ്.\n * \n * മടക്കുന്നു:\n * double: A, B ബിന്ദുക്കളും തമ്മിലുള്ള ദൂരം.\n * \n * ഉദാഹരണങ്ങൾ:\n * f_5(0, 0, 3, 4) 5 മടക്കുന്നു\n */\ndouble f_5(double xa, double ya, double xb, double yb)", "fa": "#include <cassert>\n#include <cmath>\n#include <cstring>\n/**\n * محاسبه فاصله بین دو نقطه A (xa, ya) و B (xb, yb).\n * \n * پارامترها:\n * - xa (double): مختصات x نقطه A.\n * - ya (double): مختصات y نقطه A.\n * - xb (double): مختصات x نقطه B.\n * - yb (double): مختصات y نقطه B.\n * \n * بازگشت:\n * double: فاصله بین نقاط A و B.\n * \n * مثال‌ها:\n * f_5(0, 0, 3, 4) returns 5\n */\ndouble f_5(double xa, double ya, double xb, double yb)"}, "canonical_solution": "{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}", "instruction": {"en": "double f_5(double xa, double ya, double xb, double yb)\n{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.", "sq": "double f_5(double xa, double ya, double xb, double yb)\n{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) për kodin CPP në gjuhën shqipe duke përdorur maksimumi 500 karaktere.", "hy": "double f_5(double xa, double ya, double xb, double yb)\n{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}\n\nՏվեք համառոտ բնական լեզվով նկարագրություն (docstring) այս CPP կոդի համար՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "double f_5(double xa, double ya, double xb, double yb)\n{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}\n\nসিপিপি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।", "bg": "double f_5(double xa, double ya, double xb, double yb)\n{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}\n\nПредоставете кратко описание на CPP кода на естествен език на български, използвайки не повече от 500 знака.", "zh": "double f_5(double xa, double ya, double xb, double yb)\n{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}\n\n请用最多500个字符的中文对该CPP代码提供简洁的自然语言描述（文档字符串）。", "fr": "double f_5(double xa, double ya, double xb, double yb)\n{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}\n\nFournissez une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.", "de": "double f_5(double xa, double ya, double xb, double yb)\n{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "double f_5(double xa, double ya, double xb, double yb)\n{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}\n\nBa da takaitaccen bayani a cikin yaren halitta (docstring) na lambar CPP a cikin Hausa ta amfani da haruffa 500 kacal.", "hi": "double f_5(double xa, double ya, double xb, double yb)\n{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 अक्षरों का हो।", "hu": "double f_5(double xa, double ya, double xb, double yb)\n{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a CPP kódról magyarul, legfeljebb 500 karakterben.", "es": "double f_5(double xa, double ya, double xb, double yb)\n{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando un máximo de 500 caracteres.", "arb": "double f_5(double xa, double ya, double xb, double yb)\n{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C++ باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "double f_5(double xa, double ya, double xb, double yb)\n{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "double f_5(double xa, double ya, double xb, double yb)\n{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}\n\nAşağıdaki CPP kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda özlü bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalıdır.", "vi": "double f_5(double xa, double ya, double xb, double yb)\n{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự.", "id": "double f_5(double xa, double ya, double xb, double yb)\n{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode CPP dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "double f_5(double xa, double ya, double xb, double yb)\n{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}\n\n以下のCPPコードの簡潔な自然言語による説明（ドックストリング）を日本語で500文字以内で提供してください。", "ko": "double f_5(double xa, double ya, double xb, double yb)\n{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}\n\n다음 CPP 코드의 동작을 500자 이내의 한국어로 간결하게 설명하는 자연어 설명(도크스트링)을 제공하세요.", "ml": "double f_5(double xa, double ya, double xb, double yb)\n{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}\n\nസിപിപി കോഡിന്റെ സംക്ഷിപ്തമായ സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) പരമാവധി 500 അക്ഷരങ്ങളിൽ മലയാളത്തിൽ നൽകുക.", "fa": "double f_5(double xa, double ya, double xb, double yb)\n{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}\n\nتوضیح مختصر و طبیعی (docstring) از کد CPP را به زبان فارسی با حداکثر ۵۰۰ کاراکتر ارائه دهید."}, "level": "", "test": "int main() \n{\n    assert(fabs(f_5(0, 0, 3, 4) - 5) < 1e-6);\n    assert(fabs(f_5(0, 0, 0, 0) - 0) < 1e-6);\n    assert(fabs(f_5(-1, -1, 2, 2) - 4.242640687) < 1e-6);\n    assert(fabs(f_5(1.5, 3.9, 4.2, -1.1) - 5.68243) < 1e-6);\n    //std::cout << \"All test cases passed!\\n\"; // printf can be replaced with std::cout\n    return 0;\n}", "entry_point": "f_5", "signature": "double f_5(double xa, double ya, double xb, double yb)", "docstring": {"en": "Calculate the distance between two points A (xa, ya) and B (xb, yb).\n\nParameters:\n- xa (double): x-coordinate of point A.\n- ya (double): y-coordinate of point A.\n- xb (double): x-coordinate of point B.\n- yb (double): y-coordinate of point B.\n\nReturns:\ndouble: The distance between points A and B.\n\nExamples:\nf_5(0, 0, 3, 4) returns 5", "sq": "Llogarit distancën midis dy pikave A (xa, ya) dhe B (xb, yb).\n\nParametrat:\n- xa (double): koordinata x e pikës A.\n- ya (double): koordinata y e pikës A.\n- xb (double): koordinata x e pikës B.\n- yb (double): koordinata y e pikës B.\n\nKthen:\ndouble: Distanca midis pikave A dhe B.\n\nShembuj:\nf_5(0, 0, 3, 4) kthen 5", "hy": "Հաշվարկել հեռավորությունը երկու կետերի A (xa, ya) և B (xb, yb) միջև։\n\nՊարամետրեր՝\n- xa (double): A կետի x-կոորդինատը։\n- ya (double): A կետի y-կոորդինատը։\n- xb (double): B կետի x-կոորդինատը։\n- yb (double): B կետի y-կոորդինատը։\n\nՎերադարձնում է՝\ndouble: Հեռավորությունը A և B կետերի միջև։\n\nՕրինակներ՝\nf_5(0, 0, 3, 4) վերադարձնում է 5", "bn": "দুটি বিন্দু A (xa, ya) এবং B (xb, yb) এর মধ্যে দূরত্ব গণনা করুন।\n\nপ্যারামিটারসমূহ:\n- xa (double): বিন্দু A এর x-সমন্বয়।\n- ya (double): বিন্দু A এর y-সমন্বয়।\n- xb (double): বিন্দু B এর x-সমন্বয়।\n- yb (double): বিন্দু B এর y-সমন্বয়।\n\nরিটার্নস:\ndouble: বিন্দু A এবং B এর মধ্যে দূরত্ব।\n\nউদাহরণ:\nf_5(0, 0, 3, 4) returns 5", "bg": "Изчислява разстоянието между две точки A (xa, ya) и B (xb, yb).\n\nПараметри:\n- xa (double): x-координата на точка A.\n- ya (double): y-координата на точка A.\n- xb (double): x-координата на точка B.\n- yb (double): y-координата на точка B.\n\nВръща:\ndouble: Разстоянието между точките A и B.\n\nПримери:\nf_5(0, 0, 3, 4) връща 5", "zh": "计算两点 A (xa, ya) 和 B (xb, yb) 之间的距离。\n\n参数：\n- xa (double): 点 A 的 x 坐标。\n- ya (double): 点 A 的 y 坐标。\n- xb (double): 点 B 的 x 坐标。\n- yb (double): 点 B 的 y 坐标。\n\n返回：\ndouble: 点 A 和 B 之间的距离。\n\n示例：\nf_5(0, 0, 3, 4) 返回 5", "fr": "Calculer la distance entre deux points A (xa, ya) et B (xb, yb).\n\nParamètres :\n- xa (double) : coordonnée x du point A.\n- ya (double) : coordonnée y du point A.\n- xb (double) : coordonnée x du point B.\n- yb (double) : coordonnée y du point B.\n\nRenvoie :\ndouble : La distance entre les points A et B.\n\nExemples :\nf_5(0, 0, 3, 4) renvoie 5", "de": "Berechnen Sie die Entfernung zwischen zwei Punkten A (xa, ya) und B (xb, yb).\n\nParameter:\n- xa (double): x-Koordinate des Punktes A.\n- ya (double): y-Koordinate des Punktes A.\n- xb (double): x-Koordinate des Punktes B.\n- yb (double): y-Koordinate des Punktes B.\n\nRückgabewert:\ndouble: Die Entfernung zwischen den Punkten A und B.\n\nBeispiele:\nf_5(0, 0, 3, 4) gibt 5 zurück", "ha": "Lissafi nisan tsakanin maki biyu A (xa, ya) da B (xb, yb).\n\nSigogi:\n- xa (double): x-kwatance na aya A.\n- ya (double): y-kwatance na aya A.\n- xb (double): x-kwatance na aya B.\n- yb (double): y-kwatance na aya B.\n\nDawowa:\ndouble: Nisan tsakanin wurare A da B.\n\nMisalai:\nf_5(0, 0, 3, 4) returns 5", "hi": "दो बिंदुओं A (xa, ya) और B (xb, yb) के बीच की दूरी की गणना करें।\n\nपैरामीटर्स:\n- xa (double): बिंदु A का x-निर्देशांक।\n- ya (double): बिंदु A का y-निर्देशांक।\n- xb (double): बिंदु B का x-निर्देशांक।\n- yb (double): बिंदु B का y-निर्देशांक।\n\nवापसी:\ndouble: बिंदु A और B के बीच की दूरी।\n\nउदाहरण:\nf_5(0, 0, 3, 4) 5 लौटाता है।", "hu": "Számítsa ki a távolságot két pont, A (xa, ya) és B (xb, yb) között.\n\nParaméterek:\n- xa (double): A pont x-koordinátája.\n- ya (double): A pont y-koordinátája.\n- xb (double): B pont x-koordinátája.\n- yb (double): B pont y-koordinátája.\n\nVisszatérési érték:\ndouble: A távolság A és B pontok között.\n\nPéldák:\nf_5(0, 0, 3, 4) visszaadja 5", "es": "Calcular la distancia entre dos puntos A (xa, ya) y B (xb, yb).\n\nParámetros:\n- xa (double): coordenada x del punto A.\n- ya (double): coordenada y del punto A.\n- xb (double): coordenada x del punto B.\n- yb (double): coordenada y del punto B.\n\nDevuelve:\ndouble: La distancia entre los puntos A y B.\n\nEjemplos:\nf_5(0, 0, 3, 4) devuelve 5", "arb": "احسب المسافة بين نقطتين A (xa, ya) و B (xb, yb).\n\nالمعلمات:\n- xa (double): الإحداثي السيني للنقطة A.\n- ya (double): الإحداثي الصادي للنقطة A.\n- xb (double): الإحداثي السيني للنقطة B.\n- yb (double): الإحداثي الصادي للنقطة B.\n\nالقيم المعادة:\ndouble: المسافة بين النقطتين A و B.\n\nأمثلة:\nf_5(0, 0, 3, 4) يعيد 5", "sw": "Hesabu umbali kati ya pointi mbili A (xa, ya) na B (xb, yb).\n\nVigezo:\n- xa (double): x-kipeo cha pointi A.\n- ya (double): y-kipeo cha pointi A.\n- xb (double): x-kipeo cha pointi B.\n- yb (double): y-kipeo cha pointi B.\n\nRudisha:\ndouble: Umbali kati ya pointi A na B.\n\nMifano:\nf_5(0, 0, 3, 4) inarudisha 5", "tr": "İki nokta A (xa, ya) ve B (xb, yb) arasındaki mesafeyi hesaplayın.\n\nParametreler:\n- xa (double): A noktasının x-koordinatı.\n- ya (double): A noktasının y-koordinatı.\n- xb (double): B noktasının x-koordinatı.\n- yb (double): B noktasının y-koordinatı.\n\nDöndürülenler:\ndouble: A ve B noktaları arasındaki mesafe.\n\nÖrnekler:\nf_5(0, 0, 3, 4) 5 döndürür", "vi": "Tính khoảng cách giữa hai điểm A (xa, ya) và B (xb, yb).\n\nTham số:\n- xa (double): tọa độ x của điểm A.\n- ya (double): tọa độ y của điểm A.\n- xb (double): tọa độ x của điểm B.\n- yb (double): tọa độ y của điểm B.\n\nTrả về:\ndouble: Khoảng cách giữa các điểm A và B.\n\nVí dụ:\nf_5(0, 0, 3, 4) trả về 5", "id": "Hitung jarak antara dua titik A (xa, ya) dan B (xb, yb).\n\nParameter:\n- xa (double): koordinat x dari titik A.\n- ya (double): koordinat y dari titik A.\n- xb (double): koordinat x dari titik B.\n- yb (double): koordinat y dari titik B.\n\nMengembalikan:\ndouble: Jarak antara titik A dan B.\n\nContoh:\nf_5(0, 0, 3, 4) mengembalikan 5", "ja": "2点A (xa, ya) とB (xb, yb) の間の距離を計算します。\n\nパラメータ:\n- xa (double): 点Aのx座標。\n- ya (double): 点Aのy座標。\n- xb (double): 点Bのx座標。\n- yb (double): 点Bのy座標。\n\n戻り値:\ndouble: 点AとBの間の距離。\n\n例:\nf_5(0, 0, 3, 4) は5を返します。", "ko": "두 점 A (xa, ya)와 B (xb, yb) 사이의 거리를 계산합니다.\n\n매개변수:\n- xa (double): 점 A의 x-좌표.\n- ya (double): 점 A의 y-좌표.\n- xb (double): 점 B의 x-좌표.\n- yb (double): 점 B의 y-좌표.\n\n반환값:\ndouble: 점 A와 B 사이의 거리.\n\n예제:\nf_5(0, 0, 3, 4) returns 5", "ml": "A (xa, ya) എന്ന രണ്ട് ബിന്ദുക്കളും B (xb, yb) എന്ന ബിന്ദുക്കളും തമ്മിലുള്ള ദൂരം കണക്കാക്കുക.\n\nപാരാമീറ്ററുകൾ:\n- xa (double): A ബിന്ദുവിന്റെ x-കോഓർഡിനേറ്റ്.\n- ya (double): A ബിന്ദുവിന്റെ y-കോഓർഡിനേറ്റ്.\n- xb (double): B ബിന്ദുവിന്റെ x-കോഓർഡിനേറ്റ്.\n- yb (double): B ബിന്ദുവിന്റെ y-കോഓർഡിനേറ്റ്.\n\nമടക്കുന്നു:\ndouble: A, B ബിന്ദുക്കളുടെ ഇടയിലെ ദൂരമാനം.\n\nഉദാഹരണങ്ങൾ:\nf_5(0, 0, 3, 4) 5 മടക്കുന്നു", "fa": "محاسبه فاصله بین دو نقطه A (xa, ya) و B (xb, yb).\n\nپارامترها:\n- xa (double): مختصات x نقطه A.\n- ya (double): مختصات y نقطه A.\n- xb (double): مختصات x نقطه B.\n- yb (double): مختصات y نقطه B.\n\nبازگشت:\ndouble: فاصله بین نقاط A و B.\n\nمثال‌ها:\nf_5(0, 0, 3, 4) بازمی‌گرداند 5"}}
{"task_id": "CPP/6", "prompt": {"en": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Calculates the factorial of N modulo 10007.\n * \n * Parameters:\n * - N (int): An integer representing the input value (N <= 10000).\n * \n * Returns:\n * int: The result after calculating the factorial of N and\n * taking the modulo 10007.\n * \n * Examples:\n * >>> f_6(1)\n * 1\n * >>> f_6(10)\n * 6266\n */\nint f_6(int n)", "sq": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Llogarit faktorialin e N modulo 10007.\n * \n * Parametrat:\n * - N (int): Një numër i plotë që përfaqëson vlerën hyrëse (N <= 10000).\n * \n * Kthen:\n * int: Rezultati pas llogaritjes së faktorialit të N dhe\n * marrjes së modulo 10007.\n * \n * Shembuj:\n * >>> f_6(1)\n * 1\n * >>> f_6(10)\n * 6266\n */\nint f_6(int n)", "hy": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Հաշվում է N-ի ֆակտորիալը 10007 մոդուլով։\n * \n * Պարամետրեր:\n * - N (int): Ամբողջ թիվ, որը ներկայացնում է մուտքային արժեքը (N <= 10000)։\n * \n * Վերադարձնում է:\n * int: Արդյունքը N-ի ֆակտորիալը հաշվելուց և 10007 մոդուլ վերցնելուց հետո։\n * \n * Օրինակներ:\n * >>> f_6(1)\n * 1\n * >>> f_6(10)\n * 6266\n */\nint f_6(int n)", "bn": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * N এর ফ্যাক্টোরিয়াল 10007 দ্বারা মডুলো হিসাব করে।\n * \n * প্যারামিটার:\n * - N (int): একটি পূর্ণসংখ্যা যা ইনপুট মানকে উপস্থাপন করে (N <= 10000)।\n * \n * রিটার্নস:\n * int: N এর ফ্যাক্টোরিয়াল হিসাব করার পর এবং\n * 10007 দ্বারা মডুলো নেওয়ার পর ফলাফল।\n * \n * উদাহরণ:\n * >>> f_6(1)\n * 1\n * >>> f_6(10)\n * 6266\n */\nint f_6(int n)", "bg": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Изчислява факториела на N модуло 10007.\n * \n * Параметри:\n * - N (int): Цяло число, представляващо входната стойност (N <= 10000).\n * \n * Връща:\n * int: Резултатът след изчисляване на факториела на N и\n * вземане на модуло 10007.\n * \n * Примери:\n * >>> f_6(1)\n * 1\n * >>> f_6(10)\n * 6266\n */\nint f_6(int n)", "zh": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * 计算 N 的阶乘模 10007。\n * \n * 参数:\n * - N (int): 表示输入值的整数 (N <= 10000)。\n * \n * 返回:\n * int: 计算 N 的阶乘并取模 10007 后的结果。\n * \n * 示例:\n * >>> f_6(1)\n * 1\n * >>> f_6(10)\n * 6266\n */\nint f_6(int n)", "fr": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Calcule le factoriel de N modulo 10007.\n * \n * Paramètres :\n * - N (int) : Un entier représentant la valeur d'entrée (N <= 10000).\n * \n * Renvoie :\n * int : Le résultat après avoir calculé le factoriel de N et\n * pris le modulo 10007.\n * \n * Exemples :\n * >>> f_6(1)\n * 1\n * >>> f_6(10)\n * 6266\n */\nint f_6(int n)", "de": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Berechnet die Fakultät von N modulo 10007.\n * \n * Parameter:\n * - N (int): Eine Ganzzahl, die den Eingabewert darstellt (N <= 10000).\n * \n * Rückgabewert:\n * int: Das Ergebnis nach der Berechnung der Fakultät von N und\n * der Modulo-Operation mit 10007.\n * \n * Beispiele:\n * >>> f_6(1)\n * 1\n * >>> f_6(10)\n * 6266\n */\nint f_6(int n)", "ha": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Lissafi na factorial na N modulo 10007.\n * \n * Sigogi:\n * - N (int): Wani cikakken lamba da ke wakiltar ƙimar shigarwa (N <= 10000).\n * \n * Komawa:\n * int: Sakamakon bayan lissafin factorial na N da\n * ɗaukar modulo 10007.\n * \n * Misalai:\n * >>> f_6(1)\n * 1\n * >>> f_6(10)\n * 6266\n */\nint f_6(int n)", "hi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * N का फैक्टरियल 10007 से मॉड्यूलो के साथ गणना करता है।\n * \n * पैरामीटर्स:\n * - N (int): एक पूर्णांक जो इनपुट मान का प्रतिनिधित्व करता है (N <= 10000)।\n * \n * रिटर्न्स:\n * int: N का फैक्टरियल गणना करने के बाद और\n * 10007 से मॉड्यूलो लेने के बाद का परिणाम।\n * \n * उदाहरण:\n * >>> f_6(1)\n * 1\n * >>> f_6(10)\n * 6266\n */\nint f_6(int n)", "hu": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Kiszámítja N faktoriálisát modulo 10007.\n * \n * Paraméterek:\n * - N (int): Egy egész szám, amely az input értéket jelöli (N <= 10000).\n * \n * Visszatérési érték:\n * int: Az eredmény, miután kiszámította N faktoriálisát és\n * elvégezte a modulo 10007 műveletet.\n * \n * Példák:\n * >>> f_6(1)\n * 1\n * >>> f_6(10)\n * 6266\n */\nint f_6(int n)", "es": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Calcula el factorial de N módulo 10007.\n * \n * Parámetros:\n * - N (int): Un entero que representa el valor de entrada (N <= 10000).\n * \n * Retorna:\n * int: El resultado después de calcular el factorial de N y\n * tomar el módulo 10007.\n * \n * Ejemplos:\n * >>> f_6(1)\n * 1\n * >>> f_6(10)\n * 6266\n */\nint f_6(int n)", "arb": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * يحسب مضروب N موديولو 10007.\n * \n * المعاملات:\n * - N (int): عدد صحيح يمثل قيمة الإدخال (N <= 10000).\n * \n * يعيد:\n * int: النتيجة بعد حساب مضروب N وأخذ الموديولو 10007.\n * \n * أمثلة:\n * >>> f_6(1)\n * 1\n * >>> f_6(10)\n * 6266\n */\nint f_6(int n)", "sw": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Inahesabu faktoria ya N modulo 10007.\n * \n * Vigezo:\n * - N (int): Nambari nzima inayowakilisha thamani ya pembejeo (N <= 10000).\n * \n * Inarudisha:\n * int: Matokeo baada ya kuhesabu faktoria ya N na\n * kuchukua modulo 10007.\n * \n * Mifano:\n * >>> f_6(1)\n * 1\n * >>> f_6(10)\n * 6266\n */\nint f_6(int n)", "tr": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * N faktöriyelinin 10007 ile modülünü hesaplar.\n * \n * Parametreler:\n * - N (int): Girdi değerini temsil eden bir tamsayı (N <= 10000).\n * \n * Döndürür:\n * int: N faktöriyelini hesapladıktan sonra 10007 ile modülünü aldıktan sonraki sonuç.\n * \n * Örnekler:\n * >>> f_6(1)\n * 1\n * >>> f_6(10)\n * 6266\n */\nint f_6(int n)", "vi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Tính giai thừa của N modulo 10007.\n * \n * Tham số:\n * - N (int): Một số nguyên đại diện cho giá trị đầu vào (N <= 10000).\n * \n * Trả về:\n * int: Kết quả sau khi tính giai thừa của N và\n * lấy modulo 10007.\n * \n * Ví dụ:\n * >>> f_6(1)\n * 1\n * >>> f_6(10)\n * 6266\n */\nint f_6(int n)", "id": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Menghitung faktorial dari N modulo 10007.\n * \n * Parameter:\n * - N (int): Sebuah bilangan bulat yang mewakili nilai masukan (N <= 10000).\n * \n * Mengembalikan:\n * int: Hasil setelah menghitung faktorial dari N dan\n * mengambil modulo 10007.\n * \n * Contoh:\n * >>> f_6(1)\n * 1\n * >>> f_6(10)\n * 6266\n */\nint f_6(int n)", "ja": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Nの階乗を10007で割った余りを計算します。\n * \n * パラメータ:\n * - N (int): 入力値を表す整数 (N <= 10000)。\n * \n * 戻り値:\n * int: Nの階乗を計算し、10007で割った余りの結果。\n * \n * 例:\n * >>> f_6(1)\n * 1\n * >>> f_6(10)\n * 6266\n */\nint f_6(int n)", "ko": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * N의 팩토리얼을 10007로 나눈 나머지를 계산합니다.\n * \n * 매개변수:\n * - N (int): 입력 값을 나타내는 정수 (N <= 10000).\n * \n * 반환값:\n * int: N의 팩토리얼을 계산한 후 10007로 나눈 나머지 결과.\n * \n * 예시:\n * >>> f_6(1)\n * 1\n * >>> f_6(10)\n * 6266\n */\nint f_6(int n)", "ml": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * N ന്റെ ഫാക്ടോറിയൽ 10007 ന്റെ മോഡുലോ ആയി കണക്കാക്കുന്നു.\n * \n * പാരാമീറ്ററുകൾ:\n * - N (int): ഇൻപുട്ട് മൂല്യം പ്രതിനിധീകരിക്കുന്ന ഒരു പൂർണ്ണസംഖ്യ (N <= 10000).\n * \n * മടക്കുന്നു:\n * int: N ന്റെ ഫാക്ടോറിയൽ കണക്കാക്കി 10007 ന്റെ മോഡുലോ എടുക്കുന്നതിന് ശേഷമുള്ള ഫലം.\n * \n * ഉദാഹരണങ്ങൾ:\n * >>> f_6(1)\n * 1\n * >>> f_6(10)\n * 6266\n */\nint f_6(int n)", "fa": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * محاسبه فاکتوریل N به پیمانه 10007.\n * \n * پارامترها:\n * - N (int): یک عدد صحیح که مقدار ورودی را نشان می‌دهد (N <= 10000).\n * \n * بازگشت:\n * int: نتیجه پس از محاسبه فاکتوریل N و گرفتن پیمانه 10007.\n * \n * مثال‌ها:\n * >>> f_6(1)\n * 1\n * >>> f_6(10)\n * 6266\n */\nint f_6(int n)"}, "canonical_solution": "{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for (register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i - 1] * i) % 10007;\n    }\n    return a[n];\n}", "instruction": {"en": "int f_6(int n)\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for (register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i - 1] * i) % 10007;\n    }\n    return a[n];\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.", "sq": "int f_6(int n)\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for (register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i - 1] * i) % 10007;\n    }\n    return a[n];\n}\n\nSiguroni një përshkrim të shkurtër në gjuhën natyrore (docstring) të kodit CPP në gjuhën shqipe duke përdorur maksimumi 500 karaktere.", "hy": "int f_6(int n)\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for (register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i - 1] * i) % 10007;\n    }\n    return a[n];\n}\n\nՏվեք CPP կոդի համառոտ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "int f_6(int n)\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for (register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i - 1] * i) % 10007;\n    }\n    return a[n];\n}\n\nসিপিপি কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।", "bg": "int f_6(int n)\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for (register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i - 1] * i) % 10007;\n    }\n    return a[n];\n}\n\nПредоставете кратко описание на CPP кода на естествен език на български, използвайки не повече от 500 знака.", "zh": "int f_6(int n)\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for (register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i - 1] * i) % 10007;\n    }\n    return a[n];\n}\n\n将以下 CPP 代码的自然语言描述（文档字符串）用中文简明扼要地提供，字数不超过500个字符。", "fr": "int f_6(int n)\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for (register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i - 1] * i) % 10007;\n    }\n    return a[n];\n}\n\nFournir une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.", "de": "int f_6(int n)\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for (register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i - 1] * i) % 10007;\n    }\n    return a[n];\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "int f_6(int n)\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for (register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i - 1] * i) % 10007;\n    }\n    return a[n];\n}\n\nBa da takaitaccen bayanin yare na halitta (docstring) na lambar CPP a cikin Hausa ta amfani da haruffa 500 kawai.", "hi": "int f_6(int n)\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for (register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i - 1] * i) % 10007;\n    }\n    return a[n];\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "int f_6(int n)\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for (register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i - 1] * i) % 10007;\n    }\n    return a[n];\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a CPP kódról magyarul, legfeljebb 500 karakterben.", "es": "int f_6(int n)\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for (register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i - 1] * i) % 10007;\n    }\n    return a[n];\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando como máximo 500 caracteres.", "arb": "int f_6(int n)\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for (register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i - 1] * i) % 10007;\n    }\n    return a[n];\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة CPP باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "int f_6(int n)\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for (register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i - 1] * i) % 10007;\n    }\n    return a[n];\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "int f_6(int n)\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for (register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i - 1] * i) % 10007;\n    }\n    return a[n];\n}\n\nAşağıdaki CPP kodunun Türkçe olarak en fazla 500 karakterle doğal dilde kısa bir açıklamasını (docstring) sağlayın.", "vi": "int f_6(int n)\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for (register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i - 1] * i) % 10007;\n    }\n    return a[n];\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự.", "id": "int f_6(int n)\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for (register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i - 1] * i) % 10007;\n    }\n    return a[n];\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode CPP dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "int f_6(int n)\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for (register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i - 1] * i) % 10007;\n    }\n    return a[n];\n}\n\n以下のCPPコードの簡潔な自然言語による説明（ドックストリング）を日本語で500文字以内で提供してください。", "ko": "int f_6(int n)\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for (register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i - 1] * i) % 10007;\n    }\n    return a[n];\n}\n\n다음 CPP 코드에 대한 간결한 자연어 설명(도크스트링)을 최대 500자 이내로 한국어로 제공하세요.", "ml": "int f_6(int n)\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for (register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i - 1] * i) % 10007;\n    }\n    return a[n];\n}\n\nCPP കോഡിന്റെ സംഗ്രഹമായ സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) മലയാളത്തിൽ 500 അക്ഷരങ്ങളിൽ കവിയാതെയായി നൽകുക.", "fa": "int f_6(int n)\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for (register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i - 1] * i) % 10007;\n    }\n    return a[n];\n}\n\nتوضیح مختصر و طبیعی (docstring) از کد CPP را به زبان فارسی ارائه دهید که حداکثر ۵۰۰ کاراکتر باشد."}, "level": "", "test": "int main()\n{\n    assert(f_6(0) == 1); // Added test for boundary condition\n    assert(f_6(1) == 1);\n    assert(f_6(2) == 2);\n    assert(f_6(3) == 6);\n    assert(f_6(4) == 24);\n    assert(f_6(10) == 6266); // 10! % 10007 = 3628800 % 10007 = 6266\n    assert(f_6(10000) == 6991); // Added a test for upper boundary condition\n    // printf(\"All tests passed.\\n\");\n    return 0;\n}", "entry_point": "f_6", "signature": "int f_6(int n)", "docstring": {"en": "Calculates the factorial of N modulo 10007.\n\nParameters:\n- N (int): An integer representing the input value (N <= 10000).\n\nReturns:\nint: The result after calculating the factorial of N and\ntaking the modulo 10007.\n\nExamples:\n>>> f_6(1)\n1\n>>> f_6(10)\n6266", "sq": "Llogarit faktorielin e N modulo 10007.\n\nParametrat:\n- N (int): Një numër i plotë që përfaqëson vlerën hyrëse (N <= 10000).\n\nKthen:\nint: Rezultati pas llogaritjes së faktorielit të N dhe\nmarrjes së modulo 10007.\n\nShembuj:\n>>> f_6(1)\n1\n>>> f_6(10)\n6266", "hy": "Հաշվում է N-ի ֆակտորիալը մոդուլո 10007-ով։\n\nՊարամետրեր՝\n- N (int): Ընդհանուր թիվ, որը ներկայացնում է մուտքային արժեքը (N <= 10000)։\n\nՎերադարձնում է՝\nint: Արդյունքը՝ N-ի ֆակտորիալը հաշվելուց հետո և\nմոդուլո 10007 վերցնելուց հետո։\n\nՕրինակներ՝\n>>> f_6(1)\n1\n>>> f_6(10)\n6266", "bn": "N এর ফ্যাক্টোরিয়াল 10007 দ্বারা মডুলো হিসাব করে।\n\nপ্যারামিটার:\n- N (int): একটি পূর্ণসংখ্যা যা ইনপুট মানকে উপস্থাপন করে (N <= 10000)।\n\nফেরত দেয়:\nint: N এর ফ্যাক্টোরিয়াল গণনা করার পর এবং 10007 দ্বারা মডুলো নেওয়ার পর ফলাফল।\n\nউদাহরণ:\n>>> f_6(1)\n1\n>>> f_6(10)\n6266", "bg": "Изчислява факториела на N по модул 10007.\n\nПараметри:\n- N (int): Цяло число, представляващо входната стойност (N <= 10000).\n\nВръща:\nint: Резултатът след изчисляване на факториела на N и\nвземане на модул 10007.\n\nПримери:\n>>> f_6(1)\n1\n>>> f_6(10)\n6266", "zh": "计算 N 的阶乘并取模 10007。\n\n参数：\n- N (int): 表示输入值的整数 (N <= 10000)。\n\n返回：\nint: 计算 N 的阶乘并取模 10007 后的结果。\n\n示例：\n>>> f_6(1)\n1\n>>> f_6(10)\n6266", "fr": "Calcule la factorielle de N modulo 10007.\n\nParamètres:\n- N (int): Un entier représentant la valeur d'entrée (N <= 10000).\n\nRenvoie:\nint: Le résultat après avoir calculé la factorielle de N et\nappliqué le modulo 10007.\n\nExemples:\n>>> f_6(1)\n1\n>>> f_6(10)\n6266", "de": "Berechnet die Fakultät von N modulo 10007.\n\nParameter:\n- N (int): Eine ganze Zahl, die den Eingabewert darstellt (N <= 10000).\n\nRückgabewerte:\nint: Das Ergebnis nach der Berechnung der Fakultät von N und\nder Modulo-Operation mit 10007.\n\nBeispiele:\n>>> f_6(1)\n1\n>>> f_6(10)\n6266", "ha": "Lissafi na factorial na N modulo 10007.\n\nSigogi:\n- N (int): Wani cikakken lamba wanda ke wakiltar darajar shigarwa (N <= 10000).\n\nDawowa:\nint: Sakamakon bayan lissafin factorial na N da\ndaukar modulo 10007.\n\nMisalai:\n>>> f_6(1)\n1\n>>> f_6(10)\n6266", "hi": "N का फैक्टोरियल 10007 से मॉड्यूलो निकालता है।\n\nपैरामीटर्स:\n- N (int): एक पूर्णांक जो इनपुट मान का प्रतिनिधित्व करता है (N <= 10000)।\n\nवापसी:\nint: N का फैक्टोरियल निकालने और 10007 से मॉड्यूलो लेने के बाद का परिणाम।\n\nउदाहरण:\n>>> f_6(1)\n1\n>>> f_6(10)\n6266", "hu": "Kiszámítja N faktoriálisát modulo 10007.\n\nParaméterek:\n- N (int): Egy egész szám, amely az input értéket jelöli (N <= 10000).\n\nVisszatérési érték:\nint: Az eredmény, miután kiszámítottuk N faktoriálisát és\nvettük a modulo 10007-et.\n\nPéldák:\n>>> f_6(1)\n1\n>>> f_6(10)\n6266", "es": "Calcula el factorial de N módulo 10007.\n\nParámetros:\n- N (int): Un entero que representa el valor de entrada (N <= 10000).\n\nDevuelve:\nint: El resultado después de calcular el factorial de N y\ntomar el módulo 10007.\n\nEjemplos:\n>>> f_6(1)\n1\n>>> f_6(10)\n6266", "arb": "يحسب مضروب N موديولو 10007.\n\nالمعلمات:\n- N (int): عدد صحيح يمثل قيمة الإدخال (N <= 10000).\n\nالقيم المعادة:\nint: النتيجة بعد حساب مضروب N وأخذ الموديولو 10007.\n\nأمثلة:\n>>> f_6(1)\n1\n>>> f_6(10)\n6266", "sw": "Hesabu faktoria ya N modulo 10007.\n\nVigezo:\n- N (int): Nambari nzima inayowakilisha thamani ya ingizo (N <= 10000).\n\nInarejesha:\nint: Matokeo baada ya kuhesabu faktoria ya N na\nkuchukua modulo 10007.\n\nMifano:\n>>> f_6(1)\n1\n>>> f_6(10)\n6266", "tr": "N'nin faktöriyelini 10007 modunda hesaplar.\n\nParametreler:\n- N (int): Girdi değerini temsil eden bir tamsayı (N <= 10000).\n\nDöndürülenler:\nint: N'nin faktöriyelini hesapladıktan sonra\n10007 modunu alarak elde edilen sonuç.\n\nÖrnekler:\n>>> f_6(1)\n1\n>>> f_6(10)\n6266", "vi": "Tính giai thừa của N theo modulo 10007.\n\nTham số:\n- N (int): Một số nguyên đại diện cho giá trị đầu vào (N <= 10000).\n\nTrả về:\nint: Kết quả sau khi tính giai thừa của N và\nlấy modulo 10007.\n\nVí dụ:\n>>> f_6(1)\n1\n>>> f_6(10)\n6266", "id": "Menghitung faktorial dari N modulo 10007.\n\nParameter:\n- N (int): Sebuah bilangan bulat yang mewakili nilai input (N <= 10000).\n\nMengembalikan:\nint: Hasil setelah menghitung faktorial dari N dan\nmengambil modulo 10007.\n\nContoh:\n>>> f_6(1)\n1\n>>> f_6(10)\n6266", "ja": "Nの階乗を10007で割った余りを計算します。\n\n引数:\n- N (int): 入力値を表す整数 (N <= 10000)。\n\n戻り値:\nint: Nの階乗を計算し、10007で割った余りの結果。\n\n例:\n>>> f_6(1)\n1\n>>> f_6(10)\n6266", "ko": "N의 팩토리얼을 10007로 나눈 나머지를 계산합니다.\n\n매개변수:\n- N (int): 입력 값(N <= 10000)을 나타내는 정수.\n\n반환값:\nint: N의 팩토리얼을 계산하고 10007로 나눈 나머지의 결과.\n\n예제:\n>>> f_6(1)\n1\n>>> f_6(10)\n6266", "ml": "N ന്റെ ഫാക്ടോറിയൽ 10007 ന്റെ മോഡുലോ ആയി കണക്കാക്കുന്നു.\n\nപാരാമീറ്ററുകൾ:\n- N (int): ഇൻപുട്ട് മൂല്യം പ്രതിനിധീകരിക്കുന്ന ഒരു പൂർണ്ണസംഖ്യ (N <= 10000).\n\nമടക്കുക:\nint: N ന്റെ ഫാക്ടോറിയൽ കണക്കാക്കി 10007 ന്റെ മോഡുലോ എടുത്ത ശേഷം ലഭിക്കുന്ന ഫലം.\n\nഉദാഹരണങ്ങൾ:\n>>> f_6(1)\n1\n>>> f_6(10)\n6266", "fa": "محاسبه فاکتوریل N به پیمانه 10007.\n\nپارامترها:\n- N (int): یک عدد صحیح که نمایانگر مقدار ورودی است (N <= 10000).\n\nبازگشت:\nint: نتیجه پس از محاسبه فاکتوریل N و گرفتن پیمانه 10007.\n\nمثال‌ها:\n>>> f_6(1)\n1\n>>> f_6(10)\n6266"}}
{"task_id": "CPP/7", "prompt": {"en": "#include <bits/stdc++.h>\n/*\nCalculate the area of a triangle given its base and height.\n​    Parameters:\n- base (int): The base length of the triangle.\n- height (int): The height of the triangle.\n​    Returns:\n​    float: The calculated area of the triangle, rounded to one decimal place.\n\t>>> f_7(1,2)\n\t1.0\n*/\nfloat f_7(int base, int height)", "sq": "#include <bits/stdc++.h>\n/*\nLlogarit sipërfaqen e një trekëndëshi duke dhënë bazën dhe lartësinë e tij.\n​    Parametrat:\n- base (int): Gjatësia e bazës së trekëndëshit.\n- height (int): Lartësia e trekëndëshit.\n​    Kthen:\n​    float: Sipërfaqja e llogaritur e trekëndëshit, e rrumbullakosur në një vend dhjetor.\n\t>>> f_7(1,2)\n\t1.0\n*/\nfloat f_7(int base, int height)", "hy": "#include <bits/stdc++.h>\n/*\nՀաշվարկել եռանկյան մակերեսը, տրված նրա հիմքը և բարձրությունը։\n​    Պարամետրեր:\n- base (int): Եռանկյան հիմքի երկարությունը։\n- height (int): Եռանկյան բարձրությունը։\n​    Վերադարձնում է:\n​    float: Եռանկյան հաշվարկված մակերեսը, կլորացված մինչև մեկ տասնորդական։\n\t>>> f_7(1,2)\n\t1.0\n*/\nfloat f_7(int base, int height)", "bn": "#include <bits/stdc++.h>\n/*\nএকটি ত্রিভুজের ভিত্তি এবং উচ্চতা দেওয়া থাকলে তার ক্ষেত্রফল গণনা করুন।\n​    প্যারামিটার:\n- base (int): ত্রিভুজের ভিত্তির দৈর্ঘ্য।\n- height (int): ত্রিভুজের উচ্চতা।\n​    রিটার্নস:\n​    float: ত্রিভুজের গণনা করা ক্ষেত্রফল, এক দশমিক স্থানে রাউন্ড করা।\n\t>>> f_7(1,2)\n\t1.0\n*/\nfloat f_7(int base, int height)", "bg": "#include <bits/stdc++.h>\n/*\nИзчислете площта на триъгълник, като се даде неговата основа и височина.\n​    Параметри:\n- base (int): Дължината на основата на триъгълника.\n- height (int): Височината на триъгълника.\n​    Връща:\n​    float: Изчислената площ на триъгълника, закръглена до един десетичен знак.\n\t>>> f_7(1,2)\n\t1.0\n*/\nfloat f_7(int base, int height)", "zh": "#include <bits/stdc++.h>\n/*\n计算给定底边和高的三角形面积。\n    参数:\n- base (int): 三角形的底边长度。\n- height (int): 三角形的高度。\n    返回:\n    float: 计算出的三角形面积，保留一位小数。\n\t>>> f_7(1,2)\n\t1.0\n*/\nfloat f_7(int base, int height)", "fr": "#include <bits/stdc++.h>\n/*\nCalculer l'aire d'un triangle donné sa base et sa hauteur.\n​    Paramètres :\n- base (int) : La longueur de la base du triangle.\n- height (int) : La hauteur du triangle.\n​    Renvoie :\n​    float : L'aire calculée du triangle, arrondie à un chiffre après la virgule.\n\t>>> f_7(1,2)\n\t1.0\n*/\nfloat f_7(int base, int height)", "de": "#include <bits/stdc++.h>\n/*\nBerechne die Fläche eines Dreiecks, gegeben durch seine Basis und Höhe.\n    Parameter:\n- base (int): Die Basislänge des Dreiecks.\n- height (int): Die Höhe des Dreiecks.\n    Rückgabe:\n    float: Die berechnete Fläche des Dreiecks, auf eine Dezimalstelle gerundet.\n\t>>> f_7(1,2)\n\t1.0\n*/\nfloat f_7(int base, int height)", "ha": "#include <bits/stdc++.h>\n/*\nƘididdige yanki na alwatika la'akari da ginshiƙi da tsawo.\n​    Sigogi:\n- base (int): Tsawon ginshiƙin alwatika.\n- height (int): Tsawon alwatika.\n​    Komawa:\n​    float: Yankin da aka ƙididdige na alwatika, an zagaye zuwa wuri ɗaya na ɗabi'u.\n\t>>> f_7(1,2)\n\t1.0\n*/\nfloat f_7(int base, int height)", "hi": "#include <bits/stdc++.h>\n/*\nत्रिभुज का क्षेत्रफल इसकी आधार और ऊँचाई के आधार पर गणना करें।\n    पैरामीटर्स:\n- base (int): त्रिभुज की आधार लंबाई।\n- height (int): त्रिभुज की ऊँचाई।\n    रिटर्न करता है:\n    float: त्रिभुज का गणना किया गया क्षेत्रफल, एक दशमलव स्थान तक गोल किया गया।\n\t>>> f_7(1,2)\n\t1.0\n*/\nfloat f_7(int base, int height)", "hu": "#include <bits/stdc++.h>\n/*\nSzámítsa ki egy háromszög területét az alapja és magassága alapján.\n​    Paraméterek:\n- base (int): A háromszög alapjának hossza.\n- height (int): A háromszög magassága.\n​    Visszatér:\n​    float: A háromszög kiszámított területe, egy tizedesjegyre kerekítve.\n\t>>> f_7(1,2)\n\t1.0\n*/\nfloat f_7(int base, int height)", "es": "#include <bits/stdc++.h>\n/*\nCalcular el área de un triángulo dado su base y altura.\n    Parámetros:\n- base (int): La longitud de la base del triángulo.\n- height (int): La altura del triángulo.\n    Devuelve:\n    float: El área calculada del triángulo, redondeada a un decimal.\n\t>>> f_7(1,2)\n\t1.0\n*/\nfloat f_7(int base, int height)", "arb": "#include <bits/stdc++.h>\n/*\nحساب مساحة المثلث المعطى قاعدته وارتفاعه.\n​    المعاملات:\n- base (int): طول قاعدة المثلث.\n- height (int): ارتفاع المثلث.\n​    يعيد:\n​    float: المساحة المحسوبة للمثلث، مقربة إلى مكان عشري واحد.\n\t>>> f_7(1,2)\n\t1.0\n*/\nfloat f_7(int base, int height)", "sw": "#include <bits/stdc++.h>\n/*\nHesabu eneo la pembetatu ukizingatia msingi wake na urefu.\n​    Vigezo:\n- base (int): Urefu wa msingi wa pembetatu.\n- height (int): Urefu wa pembetatu.\n​    Inarejesha:\n​    float: Eneo lililohesabiwa la pembetatu, limezungushwa hadi sehemu moja ya desimali.\n\t>>> f_7(1,2)\n\t1.0\n*/\nfloat f_7(int base, int height)", "tr": "#include <bits/stdc++.h>\n/*\nBir üçgenin alanını, tabanı ve yüksekliği verildiğinde hesaplayın.\n​    Parametreler:\n- base (int): Üçgenin taban uzunluğu.\n- height (int): Üçgenin yüksekliği.\n​    Döndürür:\n​    float: Hesaplanan üçgenin alanı, bir ondalık basamağa yuvarlanmış.\n\t>>> f_7(1,2)\n\t1.0\n*/\nfloat f_7(int base, int height)", "vi": "#include <bits/stdc++.h>\n/*\nTính diện tích của một tam giác khi biết đáy và chiều cao của nó.\n    Tham số:\n- base (int): Chiều dài đáy của tam giác.\n- height (int): Chiều cao của tam giác.\n    Trả về:\n    float: Diện tích đã tính của tam giác, làm tròn đến một chữ số thập phân.\n\t>>> f_7(1,2)\n\t1.0\n*/\nfloat f_7(int base, int height)", "id": "#include <bits/stdc++.h>\n/*\nMenghitung luas segitiga berdasarkan alas dan tingginya.\n    Parameter:\n- base (int): Panjang alas segitiga.\n- height (int): Tinggi segitiga.\n    Mengembalikan:\n    float: Luas segitiga yang dihitung, dibulatkan ke satu tempat desimal.\n\t>>> f_7(1,2)\n\t1.0\n*/\nfloat f_7(int base, int height)", "ja": "#include <bits/stdc++.h>\n/*\n三角形の面積を、その底辺と高さを与えて計算します。\n​    パラメータ:\n- base (int): 三角形の底辺の長さ。\n- height (int): 三角形の高さ。\n​    戻り値:\n​    float: 計算された三角形の面積、小数点以下1桁に丸められます。\n\t>>> f_7(1,2)\n\t1.0\n*/\nfloat f_7(int base, int height)", "ko": "#include <bits/stdc++.h>\n/*\n삼각형의 밑변과 높이가 주어졌을 때 삼각형의 면적을 계산합니다.\n​    매개변수:\n- base (int): 삼각형의 밑변 길이.\n- height (int): 삼각형의 높이.\n​    반환값:\n​    float: 소수점 첫째 자리까지 반올림된 삼각형의 계산된 면적.\n\t>>> f_7(1,2)\n\t1.0\n*/\nfloat f_7(int base, int height)", "ml": "#include <bits/stdc++.h>\n/*\nത്രികോണത്തിന്റെ അടിയും ഉയരവും നൽകിയാൽ അതിന്റെ വിസ്തീർണം കണക്കാക്കുക.\n    പാരാമീറ്ററുകൾ:\n- base (int): ത്രികോണത്തിന്റെ അടിയുടെ നീളം.\n- height (int): ത്രികോണത്തിന്റെ ഉയരം.\n    റിട്ടേൺസ്:\n    float: ഒരു ദശാംശസ്ഥാനം വരെയായി വട്ടമിട്ട് കണക്കാക്കിയ ത്രികോണത്തിന്റെ വിസ്തീർണം.\n\t>>> f_7(1,2)\n\t1.0\n*/\nfloat f_7(int base, int height)", "fa": "#include <bits/stdc++.h>\n/*\nمساحت یک مثلث را با توجه به قاعده و ارتفاع آن محاسبه کنید.\n​    پارامترها:\n- base (int): طول قاعده مثلث.\n- height (int): ارتفاع مثلث.\n​    بازگشت:\n​    float: مساحت محاسبه شده مثلث، گرد شده به یک رقم اعشار.\n\t>>> f_7(1,2)\n\t1.0\n*/\nfloat f_7(int base, int height)"}, "canonical_solution": "{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}", "instruction": {"en": "float f_7(int base, int height)\n{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.", "sq": "float f_7(int base, int height)\n{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit CPP në shqip duke përdorur maksimumi 500 karaktere.", "hy": "float f_7(int base, int height)\n{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}\n\nՏվեք CPP կոդի համառոտ բնական լեզվով նկարագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։", "bn": "float f_7(int base, int height)\n{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}\n\nসিপিপি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।", "bg": "float f_7(int base, int height)\n{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}\n\nПредоставете кратко описание на CPP кода на естествен език (docstring) на български, използвайки най-много 500 знака.", "zh": "float f_7(int base, int height)\n{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}\n\n请用最多500个字符的中文对该CPP代码提供简洁的自然语言描述（文档字符串）。", "fr": "float f_7(int base, int height)\n{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}\n\nFournissez une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.", "de": "float f_7(int base, int height)\n{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen.", "ha": "float f_7(int base, int height)\n{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar CPP a cikin Hausa ta amfani da haruffa 500 ko kasa da haka.", "hi": "float f_7(int base, int height)\n{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "float f_7(int base, int height)\n{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a CPP kódról magyar nyelven, legfeljebb 500 karakterben.", "es": "float f_7(int base, int height)\n{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando un máximo de 500 caracteres.", "arb": "float f_7(int base, int height)\n{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة CPP باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "float f_7(int base, int height)\n{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "float f_7(int base, int height)\n{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}\n\nAşağıdaki CPP kodunun Türkçe olarak en fazla 500 karakter kullanarak özlü bir doğal dil açıklamasını (docstring) sağlayın.", "vi": "float f_7(int base, int height)\n{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự.", "id": "float f_7(int base, int height)\n{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode CPP dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "float f_7(int base, int height)\n{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}\n\n以下のCPPコードの簡潔な自然言語による説明（ドックストリング）を日本語で500文字以内で提供してください。", "ko": "float f_7(int base, int height)\n{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}\n\n최대 500자를 사용하여 영어로 CPP 코드에 대한 간결한 자연어 설명(docstring)을 제공하세요.", "ml": "float f_7(int base, int height)\n{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}\n\nCPP കോഡ് ഉപയോഗിച്ച് 500 അക്ഷരങ്ങളിൽ കൂടുതൽ അല്ലാത്ത ഒരു സംക്ഷിപ്ത സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) മലയാളത്തിൽ നൽകുക.", "fa": "float f_7(int base, int height)\n{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}\n\nیک توضیح مختصر به زبان طبیعی (docstring) از کد CPP به زبان فارسی ارائه دهید که حداکثر ۵۰۰ کاراکتر باشد."}, "level": "", "test": "int main()\n{\n    // Adding more comprehensive test cases and correcting the expected values\n    assert(fabs(f_7(1, 2) - 1.0) < 1e-6); // Should assert true with close approximate comparison\n    assert(fabs(f_7(3, 4) - 6.0) < 1e-6); // Should assert true with close approximate comparison\n    assert(fabs(f_7(5, 8) - 20.0) < 1e-6); // Additional test case\n    assert(fabs(f_7(7, 3) - 10.5) < 1e-6); // Additional test case\n    assert(fabs(f_7(10, 10) - 50.0) < 1e-6); // Additional test case\n\n    // printf(\"All tests passed.\\n\");\n    return 0;\n}", "entry_point": "f_7", "signature": "float f_7(int base, int height)", "docstring": {"en": "Calculate the area of a triangle given its base and height.\n    Parameters:\n- base (int): The base length of the triangle.\n- height (int): The height of the triangle.\n​    Returns:\n​    float: The calculated area of the triangle, rounded to one decimal place.\n    >>> f_7(1,2)\n    1.0\n", "sq": "Llogarit sipërfaqen e një trekëndëshi duke pasur bazën dhe lartësinë e tij.\n    Parametra:\n- base (int): Gjatësia e bazës së trekëndëshit.\n- height (int): Lartësia e trekëndëshit.\n​    Kthen:\n​    float: Sipërfaqja e llogaritur e trekëndëshit, e rrumbullakosur në një vend dhjetor.\n    >>> f_7(1,2)\n    1.0", "hy": "Հաշվարկել եռանկյան մակերեսը՝ տրված դրա հիմքը և բարձրությունը։\n    Պարամետրեր:\n- base (int): Եռանկյան հիմքի երկարությունը։\n- height (int): Եռանկյան բարձրությունը։\n    Վերադարձնում է:\n    float: Եռանկյան հաշվարկված մակերեսը՝ կլորացված մինչև մեկ տասնորդական։\n    >>> f_7(1,2)\n    1.0", "bn": "ত্রিভুজের ভিত্তি এবং উচ্চতা প্রদত্ত হলে এর ক্ষেত্রফল গণনা করুন।\n    Parameters:\n- base (int): ত্রিভুজের ভিত্তির দৈর্ঘ্য।\n- height (int): ত্রিভুজের উচ্চতা।\n    Returns:\n    float: ত্রিভুজের গণিত ক্ষেত্রফল, এক দশমিক স্থান পর্যন্ত গোলাকার।\n    >>> f_7(1,2)\n    1.0", "bg": "Изчисляване на лицето на триъгълник, като се дадат неговата основа и височина.\n    Параметри:\n- base (int): Дължината на основата на триъгълника.\n- height (int): Височината на триъгълника.\n​    Връща:\n​    float: Изчисленото лице на триъгълника, закръглено до един десетичен знак.\n    >>> f_7(1,2)\n    1.0", "zh": "计算给定底边和高的三角形面积。\n    参数:\n- base (int): 三角形的底边长度。\n- height (int): 三角形的高度。\n    返回:\n    float: 计算得到的三角形面积，四舍五入到小数点后一位。\n    >>> f_7(1,2)\n    1.0", "fr": "Calculer l'aire d'un triangle donné sa base et sa hauteur.\n    Paramètres:\n- base (int): La longueur de la base du triangle.\n- height (int): La hauteur du triangle.\n    Renvoie:\n    float: L'aire calculée du triangle, arrondie à un chiffre après la virgule.\n    >>> f_7(1,2)\n    1.0", "de": "Berechne die Fläche eines Dreiecks, gegeben durch seine Basis und Höhe.\n    Parameter:\n- base (int): Die Basislänge des Dreiecks.\n- height (int): Die Höhe des Dreiecks.\n    Rückgabewert:\n    float: Die berechnete Fläche des Dreiecks, gerundet auf eine Dezimalstelle.\n    >>> f_7(1,2)\n    1.0", "ha": "Ƙididdige yanki na alwatika la'akari da tushenta da tsayinta.\n    Sigogi:\n- base (int): Tsawon tushe na alwatika.\n- height (int): Tsawon tsayi na alwatika.\n​    Mayarwa:\n​    float: Yankin da aka ƙididdige na alwatika, an zagaye zuwa wuri ɗaya na ɗigon goma.\n    >>> f_7(1,2)\n    1.0", "hi": "त्रिभुज का क्षेत्रफल उसकी आधार और ऊँचाई के आधार पर गणना करें।\n    पैरामीटर्स:\n- base (int): त्रिभुज की आधार लंबाई।\n- height (int): त्रिभुज की ऊँचाई।\n    रिटर्न्स:\n    float: त्रिभुज का गणना किया गया क्षेत्रफल, एक दशमलव स्थान तक गोल किया गया।\n    >>> f_7(1,2)\n    1.0", "hu": "Számítsa ki egy háromszög területét az alapja és magassága alapján.\n    Paraméterek:\n- base (int): A háromszög alapjának hossza.\n- height (int): A háromszög magassága.\n    Visszatér:\n    float: A háromszög kiszámított területe, egy tizedesjegyre kerekítve.\n    >>> f_7(1,2)\n    1.0", "es": "Calcular el área de un triángulo dada su base y altura.\n    Parámetros:\n- base (int): La longitud de la base del triángulo.\n- height (int): La altura del triángulo.\n​    Devuelve:\n​    float: El área calculada del triángulo, redondeada a un decimal.\n    >>> f_7(1,2)\n    1.0", "arb": "احسب مساحة المثلث بناءً على قاعدته وارتفاعه.\n    المعلمات:\n- base (int): طول قاعدة المثلث.\n- height (int): ارتفاع المثلث.\n    يعيد:\n    float: المساحة المحسوبة للمثلث، مقربة إلى منزلة عشرية واحدة.\n    >>> f_7(1,2)\n    1.0", "sw": "Hesabu eneo la pembetatu ukitumia msingi wake na urefu.\n\n    Vigezo:\n    - base (int): Urefu wa msingi wa pembetatu.\n    - height (int): Urefu wa pembetatu.\n\n    Inarejesha:\n    float: Eneo lililohesabiwa la pembetatu, limezungushwa hadi sehemu moja ya desimali.\n\n    >>> f_7(1,2)\n    1.0", "tr": "Üçgenin tabanı ve yüksekliği verildiğinde alanını hesaplayın.\n    Parametreler:\n- base (int): Üçgenin taban uzunluğu.\n- height (int): Üçgenin yüksekliği.\n​    Döndürür:\n​    float: Üçgenin hesaplanan alanı, bir ondalık basamağa yuvarlanmış.\n    >>> f_7(1,2)\n    1.0", "vi": "Tính diện tích của một tam giác khi biết đáy và chiều cao của nó.\n    Tham số:\n- base (int): Độ dài đáy của tam giác.\n- height (int): Chiều cao của tam giác.\n    Trả về:\n    float: Diện tích được tính của tam giác, làm tròn đến một chữ số thập phân.\n    >>> f_7(1,2)\n    1.0", "id": "Hitung luas segitiga berdasarkan alas dan tingginya.\n    Parameter:\n- base (int): Panjang alas segitiga.\n- height (int): Tinggi segitiga.\n    Mengembalikan:\n    float: Luas segitiga yang dihitung, dibulatkan ke satu tempat desimal.\n    >>> f_7(1,2)\n    1.0", "ja": "三角形の面積を、その底辺と高さを与えて計算します。\n    パラメータ:\n- base (int): 三角形の底辺の長さ。\n- height (int): 三角形の高さ。\n​    戻り値:\n​    float: 計算された三角形の面積、小数点以下1桁に丸められます。\n    >>> f_7(1,2)\n    1.0", "ko": "삼각형의 밑변과 높이가 주어졌을 때, 삼각형의 면적을 계산합니다.\n    매개변수:\n- base (int): 삼각형의 밑변 길이.\n- height (int): 삼각형의 높이.\n    반환:\n    float: 소수점 첫째 자리까지 반올림된 삼각형의 계산된 면적.\n    >>> f_7(1,2)\n    1.0", "ml": "ത്രികോണമിതിയുടെ അടിയും ഉയരവും നൽകിയാൽ അതിന്റെ വിസ്തീർണ്ണം കണക്കാക്കുക.\n    പാരാമീറ്ററുകൾ:\n- base (int): ത്രികോണമിതിയുടെ അടിയുടെ നീളം.\n- height (int): ത്രികോണമിതിയുടെ ഉയരം.\n    മടക്കങ്ങൾ:\n    float: ഒരു ദശാംശ സ്ഥാനത്തേക്ക് വട്ടമിട്ട ത്രികോണമിതിയുടെ കണക്കാക്കിയ വിസ്തീർണ്ണം.\n    >>> f_7(1,2)\n    1.0", "fa": "محاسبه مساحت یک مثلث با توجه به قاعده و ارتفاع آن.\n    پارامترها:\n- base (int): طول قاعده مثلث.\n- height (int): ارتفاع مثلث.\n    بازگشت:\n    float: مساحت محاسبه شده مثلث، گرد شده به یک رقم اعشار.\n    >>> f_7(1,2)\n    1.0"}}
{"task_id": "CPP/8", "prompt": {"en": "#include <bits/stdc++.h>\n/*\nCalculate the Hamming distance between two integers in binary representation.\n​    Parameters:\n- x (int): The first positive integer (x <= 1,000,000,000).\n- y (int): The second positive integer (y <= 1,000,000,000).\n​    Returns:\n​    int: The Hamming distance between x and y, i.e., the number of bits that need to be flipped\n​         to transform x into y in binary.\n\t>>> f_8(1,2)\n\t2\n*/\nint f_8(int x, int y)", "sq": "#include <bits/stdc++.h>\n/*\nLlogarit distancën Hamming midis dy numrave të plotë në përfaqësimin binar.\n​    Parametrat:\n- x (int): Numri i parë pozitiv (x <= 1,000,000,000).\n- y (int): Numri i dytë pozitiv (y <= 1,000,000,000).\n​    Kthen:\n​    int: Distanca Hamming midis x dhe y, dmth, numri i biteve që duhet të ndryshohen\n​         për të transformuar x në y në binar.\n\t>>> f_8(1,2)\n\t2\n*/\nint f_8(int x, int y)", "hy": "#include <bits/stdc++.h>\n/*\nՀաշվել Հեմինգի հեռավորությունը երկու ամբողջ թվերի միջև բինար ներկայացման մեջ:\n​    Պարամետրեր:\n- x (int): Առաջին դրական ամբողջ թիվը (x <= 1,000,000,000):\n- y (int): Երկրորդ դրական ամբողջ թիվը (y <= 1,000,000,000):\n​    Վերադարձնում է:\n​    int: Հեմինգի հեռավորությունը x և y միջև, այսինքն՝ բիթերի քանակը, որոնք պետք է փոխվեն\n​         x-ը y-ի վերածելու համար բինար տեսքով:\n\t>>> f_8(1,2)\n\t2\n*/\nint f_8(int x, int y)", "bn": "#include <bits/stdc++.h>\n/*\nদুটি পূর্ণসংখ্যার বাইনারি উপস্থাপনার মধ্যে হ্যামিং দূরত্ব গণনা করুন।\n​    প্যারামিটার:\n- x (int): প্রথম ধনাত্মক পূর্ণসংখ্যা (x <= 1,000,000,000)।\n- y (int): দ্বিতীয় ধনাত্মক পূর্ণসংখ্যা (y <= 1,000,000,000)।\n​    রিটার্নস:\n​    int: x এবং y এর মধ্যে হ্যামিং দূরত্ব, অর্থাৎ x কে বাইনারিতে y তে রূপান্তর করতে যে সংখ্যক বিট পরিবর্তন করতে হবে\n\t>>> f_8(1,2)\n\t2\n*/\nint f_8(int x, int y)", "bg": "#include <bits/stdc++.h>\n/*\nИзчислете разстоянието на Хаминг между две цели числа в двоична форма.\n​    Параметри:\n- x (int): Първото положително цяло число (x <= 1,000,000,000).\n- y (int): Второто положително цяло число (y <= 1,000,000,000).\n​    Връща:\n​    int: Разстоянието на Хаминг между x и y, т.е. броят на битовете, които трябва да бъдат обърнати,\n​         за да се преобразува x в y в двоична форма.\n\t>>> f_8(1,2)\n\t2\n*/\nint f_8(int x, int y)", "zh": "#include <bits/stdc++.h>\n/*\n计算两个整数在二进制表示中的汉明距离。\n    参数:\n- x (int): 第一个正整数 (x <= 1,000,000,000)。\n- y (int): 第二个正整数 (y <= 1,000,000,000)。\n    返回:\n    int: x 和 y 之间的汉明距离，即需要翻转的位数以将 x 转换为二进制中的 y。\n\t>>> f_8(1,2)\n\t2\n*/\nint f_8(int x, int y)", "fr": "#include <bits/stdc++.h>\n/*\nCalculer la distance de Hamming entre deux entiers en représentation binaire.\n​    Paramètres:\n- x (int): Le premier entier positif (x <= 1,000,000,000).\n- y (int): Le second entier positif (y <= 1,000,000,000).\n​    Renvoie:\n​    int: La distance de Hamming entre x et y, c'est-à-dire le nombre de bits qui doivent être inversés\n​         pour transformer x en y en binaire.\n\t>>> f_8(1,2)\n\t2\n*/\nint f_8(int x, int y)", "de": "#include <bits/stdc++.h>\n/*\nBerechne die Hamming-Distanz zwischen zwei ganzen Zahlen in binärer Darstellung.\n    Parameter:\n- x (int): Die erste positive ganze Zahl (x <= 1.000.000.000).\n- y (int): Die zweite positive ganze Zahl (y <= 1.000.000.000).\n    Rückgabe:\n    int: Die Hamming-Distanz zwischen x und y, d.h., die Anzahl der Bits, die umgekehrt werden müssen,\n         um x in y in binärer Form zu transformieren.\n\t>>> f_8(1,2)\n\t2\n*/\nint f_8(int x, int y)", "ha": "#include <bits/stdc++.h>\n/*\nƘididdige nisan Hamming tsakanin lambobi biyu a cikin wakilcin binary.\n​    Sigogi:\n- x (int): Lamba ta farko mai kyau (x <= 1,000,000,000).\n- y (int): Lamba ta biyu mai kyau (y <= 1,000,000,000).\n​    Komawa:\n​    int: Nisan Hamming tsakanin x da y, wato, adadin bits da ake buƙatar juyawa\n​         don canza x zuwa y a cikin binary.\n\t>>> f_8(1,2)\n\t2\n*/\nint f_8(int x, int y)", "hi": "#include <bits/stdc++.h>\n/*\nदो पूर्णांकों के बीच द्विआधारी अभ्यRepresentation में हैमिंग दूरी की गणना करें।\n    पैरामीटर्स:\n- x (int): पहला धनात्मक पूर्णांक (x <= 1,000,000,000)।\n- y (int): दूसरा धनात्मक पूर्णांक (y <= 1,000,000,000)।\n    रिटर्न करता है:\n    int: x और y के बीच हैमिंग दूरी, अर्थात्, x को द्विआधारी में y में बदलने के लिए कितने बिट्स को फ्लिप करने की आवश्यकता है।\n\t>>> f_8(1,2)\n\t2\n*/\nint f_8(int x, int y)", "hu": "#include <bits/stdc++.h>\n/*\nSzámítsa ki a Hamming-távolságot két egész szám bináris ábrázolása között.\n    Paraméterek:\n- x (int): Az első pozitív egész szám (x <= 1,000,000,000).\n- y (int): A második pozitív egész szám (y <= 1,000,000,000).\n    Visszatérési érték:\n    int: A Hamming-távolság x és y között, azaz a bitek száma, amelyeket meg kell változtatni\n         ahhoz, hogy x-ből y-t alakítsunk binárisan.\n\t>>> f_8(1,2)\n\t2\n*/\nint f_8(int x, int y)", "es": "#include <bits/stdc++.h>\n/*\nCalcular la distancia de Hamming entre dos enteros en representación binaria.\n    Parámetros:\n- x (int): El primer entero positivo (x <= 1,000,000,000).\n- y (int): El segundo entero positivo (y <= 1,000,000,000).\n    Devuelve:\n    int: La distancia de Hamming entre x e y, es decir, el número de bits que deben cambiarse\n         para transformar x en y en binario.\n\t>>> f_8(1,2)\n\t2\n*/\nint f_8(int x, int y)", "arb": "#include <bits/stdc++.h>\n/*\nاحسب مسافة هامنج بين عددين صحيحين في التمثيل الثنائي.\n​    المعاملات:\n- x (int): العدد الصحيح الأول الموجب (x <= 1,000,000,000).\n- y (int): العدد الصحيح الثاني الموجب (y <= 1,000,000,000).\n​    يعيد:\n​    int: مسافة هامنج بين x و y، أي عدد البتات التي تحتاج إلى قلب\n​         لتحويل x إلى y في النظام الثنائي.\n\t>>> f_8(1,2)\n\t2\n*/\nint f_8(int x, int y)", "sw": "#include <bits/stdc++.h>\n/*\nHesabu umbali wa Hamming kati ya nambari mbili katika uwakilishi wa binary.\n​    Vigezo:\n- x (int): Nambari ya kwanza chanya (x <= 1,000,000,000).\n- y (int): Nambari ya pili chanya (y <= 1,000,000,000).\n​    Inarudisha:\n​    int: Umbali wa Hamming kati ya x na y, yaani, idadi ya biti zinazohitajika kubadilishwa\n​         ili kubadilisha x kuwa y katika binary.\n\t>>> f_8(1,2)\n\t2\n*/\nint f_8(int x, int y)", "tr": "#include <bits/stdc++.h>\n/*\nİki tamsayı arasındaki Hamming mesafesini ikili gösterimde hesaplayın.\n​    Parametreler:\n- x (int): İlk pozitif tamsayı (x <= 1,000,000,000).\n- y (int): İkinci pozitif tamsayı (y <= 1,000,000,000).\n​    Döndürür:\n​    int: x ve y arasındaki Hamming mesafesi, yani x'i ikili olarak y'ye dönüştürmek için\n​         çevrilmesi gereken bit sayısı.\n\t>>> f_8(1,2)\n\t2\n*/\nint f_8(int x, int y)", "vi": "#include <bits/stdc++.h>\n/*\nTính khoảng cách Hamming giữa hai số nguyên trong biểu diễn nhị phân.\n​    Tham số:\n- x (int): Số nguyên dương thứ nhất (x <= 1,000,000,000).\n- y (int): Số nguyên dương thứ hai (y <= 1,000,000,000).\n​    Trả về:\n​    int: Khoảng cách Hamming giữa x và y, tức là số bit cần phải thay đổi\n​         để biến đổi x thành y trong nhị phân.\n\t>>> f_8(1,2)\n\t2\n*/\nint f_8(int x, int y)", "id": "#include <bits/stdc++.h>\n/*\nHitung jarak Hamming antara dua bilangan bulat dalam representasi biner.\n​    Parameter:\n- x (int): Bilangan bulat positif pertama (x <= 1,000,000,000).\n- y (int): Bilangan bulat positif kedua (y <= 1,000,000,000).\n​    Mengembalikan:\n​    int: Jarak Hamming antara x dan y, yaitu jumlah bit yang perlu dibalik\n​         untuk mengubah x menjadi y dalam biner.\n\t>>> f_8(1,2)\n\t2\n*/\nint f_8(int x, int y)", "ja": "#include <bits/stdc++.h>\n/*\n2つの整数の2進数表現におけるハミング距離を計算します。\n​    パラメータ:\n- x (int): 最初の正の整数 (x <= 1,000,000,000)。\n- y (int): 2番目の正の整数 (y <= 1,000,000,000)。\n​    戻り値:\n​    int: xとyの間のハミング距離、すなわち、xを2進数でyに変換するために反転する必要があるビットの数。\n\t>>> f_8(1,2)\n\t2\n*/\nint f_8(int x, int y)", "ko": "#include <bits/stdc++.h>\n/*\n두 정수를 이진수 표현으로 변환했을 때의 해밍 거리 계산.\n​    매개변수:\n- x (int): 첫 번째 양의 정수 (x <= 1,000,000,000).\n- y (int): 두 번째 양의 정수 (y <= 1,000,000,000).\n​    반환값:\n​    int: x와 y 사이의 해밍 거리, 즉 x를 이진수로 y로 변환하기 위해 뒤집어야 하는 비트의 수.\n\t>>> f_8(1,2)\n\t2\n*/\nint f_8(int x, int y)", "ml": "#include <bits/stdc++.h>\n/*\nരണ്ടു പൂർണ്ണസംഖ്യകളുടെ ബൈനറി പ്രതിനിധാനത്തിൽ ഹാമ്മിംഗ് ദൂരമനക്കുക.\n​    പാരാമീറ്ററുകൾ:\n- x (int): ആദ്യത്തെ പോസിറ്റീവ് പൂർണ്ണസംഖ്യ (x <= 1,000,000,000).\n- y (int): രണ്ടാം പോസിറ്റീവ് പൂർണ്ണസംഖ്യ (y <= 1,000,000,000).\n​    മടക്കുന്നു:\n​    int: x നും y നും ഇടയിൽ ഹാമ്മിംഗ് ദൂരം, അഥവാ ബൈനറിയിൽ x നെ y ആക്കാൻ മാറ്റേണ്ട ബിറ്റുകളുടെ എണ്ണം.\n\t>>> f_8(1,2)\n\t2\n*/\nint f_8(int x, int y)", "fa": "#include <bits/stdc++.h>\n/*\nمحاسبه فاصله همینگ بین دو عدد صحیح در نمایش باینری.\n​    پارامترها:\n- x (int): اولین عدد صحیح مثبت (x <= 1,000,000,000).\n- y (int): دومین عدد صحیح مثبت (y <= 1,000,000,000).\n​    بازگشت:\n​    int: فاصله همینگ بین x و y، یعنی تعداد بیت‌هایی که باید تغییر کنند\n​         تا x به y در باینری تبدیل شود.\n\t>>> f_8(1,2)\n\t2\n*/\nint f_8(int x, int y)"}, "canonical_solution": "{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}", "instruction": {"en": "int f_8(int x, int y)\n{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.", "sq": "int f_8(int x, int y)\n{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit CPP në gjuhën shqipe duke përdorur maksimumi 500 karaktere.", "hy": "int f_8(int x, int y)\n{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}\n\nՏվեք CPP կոդի հակիրճ բնութագրումը (docstring) հայերեն լեզվով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "int f_8(int x, int y)\n{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}\n\nসিপিপি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।", "bg": "int f_8(int x, int y)\n{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}\n\nПредоставете кратко описание на CPP кода на български език, използвайки не повече от 500 символа.", "zh": "int f_8(int x, int y)\n{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}\n\n将以下 CPP 代码的功能简洁地用中文自然语言描述（文档字符串），不超过 500 个字符。", "fr": "int f_8(int x, int y)\n{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}\n\nFournissez une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.", "de": "int f_8(int x, int y)\n{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "int f_8(int x, int y)\n{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}\n\nBa da takaitaccen bayanin yanayi na halitta (docstring) na lambar CPP cikin Hausa ta amfani da haruffa 500 ko kasa da haka.", "hi": "int f_8(int x, int y)\n{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "int f_8(int x, int y)\n{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a CPP kódról magyarul, legfeljebb 500 karakterben.", "es": "int f_8(int x, int y)\n{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando como máximo 500 caracteres.", "arb": "int f_8(int x, int y)\n{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة CPP باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.", "sw": "int f_8(int x, int y)\n{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "int f_8(int x, int y)\n{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}\n\nAşağıdaki CPP kodunun Türkçe olarak en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.", "vi": "int f_8(int x, int y)\n{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự.", "id": "int f_8(int x, int y)\n{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode CPP dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "int f_8(int x, int y)\n{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}\n\n以下のCPPコードの簡潔な自然言語による説明（ドックストリング）を日本語で500文字以内で提供してください。", "ko": "int f_8(int x, int y)\n{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}\n\n다음 CPP 코드에 대한 간결한 자연어 설명(도크스트링)을 한국어로 최대 500자 이내로 제공하세요.", "ml": "int f_8(int x, int y)\n{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}\n\nസിപിപി കോഡിന്റെ സംക്ഷിപ്തമായ സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) മലയാളത്തിൽ 500 അക്ഷരങ്ങളിൽ കവിയാതെ നൽകുക.", "fa": "int f_8(int x, int y)\n{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}\n\nتوضیح مختصر و طبیعی (docstring) از کد CPP را به زبان فارسی با حداکثر ۵۰۰ کاراکتر ارائه دهید."}, "level": "", "test": "int main() {\n    assert(f_8(1, 2) == 2); // 01 and 10 have 2 different bits\n    assert(f_8(4, 7) == 2); // 100 and 111 have 2 different bits\n    assert(f_8(25, 30) == 3); // Additional test: 11001 and 11110 have 3 different bits\n    assert(f_8(0, 0) == 0); // Additional test: Same numbers have 0 different bits\n    assert(f_8(0xFFFFFFF, 0x0000000) == 28); // Additional test: Max unsigned int and 0 have 32 different bits\n    return 0;\n}", "entry_point": "f_8", "signature": "int f_8(int x, int y)", "docstring": {"en": "Calculate the Hamming distance between two integers in binary representation.\n    Parameters:\n- x (int): The first positive integer (x <= 1,000,000,000).\n- y (int): The second positive integer (y <= 1,000,000,000).\n    Returns:\n    int: The Hamming distance between x and y, i.e., the number of bits that need to be flipped to transform x into y in binary.\n    >>> f_8(1,2)\n    2\n", "sq": "Llogarit distancën Hamming midis dy numrave të plotë në përfaqësimin binar.\n    Parametrat:\n- x (int): Numri i parë pozitiv (x <= 1,000,000,000).\n- y (int): Numri i dytë pozitiv (y <= 1,000,000,000).\n    Kthen:\n    int: Distanca Hamming midis x dhe y, dmth numri i biteve që duhet të ndryshohen për të transformuar x në y në binar.\n    >>> f_8(1,2)\n    2", "hy": "Հաշվարկել Հեմինգի հեռավորությունը երկու ամբողջ թվերի միջև երկուական ներկայացմամբ։ \n    Պարամետրեր:\n- x (int): Առաջին դրական ամբողջ թիվը (x <= 1,000,000,000)։\n- y (int): Երկրորդ դրական ամբողջ թիվը (y <= 1,000,000,000)։\n    Վերադարձնում է:\n    int: Հեմինգի հեռավորությունը x-ի և y-ի միջև, այսինքն՝ բիթերի քանակը, որոնք անհրաժեշտ է փոխել, որպեսզի x-ը վերածվի y-ի երկուականում։\n    >>> f_8(1,2)\n    2", "bn": "দুটি পূর্ণসংখ্যার বাইনারি উপস্থাপনার মধ্যে হ্যামিং দূরত্ব গণনা করুন।\n    Parameters:\n- x (int): প্রথম ধনাত্মক পূর্ণসংখ্যা (x <= 1,000,000,000)।\n- y (int): দ্বিতীয় ধনাত্মক পূর্ণসংখ্যা (y <= 1,000,000,000)।\n    Returns:\n    int: x এবং y এর মধ্যে হ্যামিং দূরত্ব, অর্থাৎ x কে y তে রূপান্তর করতে যে সংখ্যক বিট পরিবর্তন করতে হবে।\n    >>> f_8(1,2)\n    2", "bg": "Изчисляване на разстоянието на Хаминг между две цели числа в двоична форма.\n    Параметри:\n- x (int): Първото положително цяло число (x <= 1,000,000,000).\n- y (int): Второто положително цяло число (y <= 1,000,000,000).\n    Връща:\n    int: Разстоянието на Хаминг между x и y, т.е. броят на битовете, които трябва да бъдат обърнати, за да се преобразува x в y в двоична форма.\n    >>> f_8(1,2)\n    2", "zh": "计算两个整数在二进制表示中的汉明距离。\n    参数:\n- x (int): 第一个正整数 (x <= 1,000,000,000)。\n- y (int): 第二个正整数 (y <= 1,000,000,000)。\n    返回:\n    int: x 和 y 之间的汉明距离，即需要翻转多少个位才能将 x 转换为 y。\n    >>> f_8(1,2)\n    2", "fr": "Calculer la distance de Hamming entre deux entiers en représentation binaire.\n    Paramètres:\n- x (int): Le premier entier positif (x <= 1,000,000,000).\n- y (int): Le deuxième entier positif (y <= 1,000,000,000).\n    Renvoie:\n    int: La distance de Hamming entre x et y, c'est-à-dire le nombre de bits qui doivent être inversés pour transformer x en y en binaire.\n    >>> f_8(1,2)\n    2", "de": "Berechne die Hamming-Distanz zwischen zwei ganzen Zahlen in binärer Darstellung.\n    Parameter:\n- x (int): Die erste positive ganze Zahl (x <= 1.000.000.000).\n- y (int): Die zweite positive ganze Zahl (y <= 1.000.000.000).\n    Rückgabewert:\n    int: Die Hamming-Distanz zwischen x und y, d.h., die Anzahl der Bits, die umgekehrt werden müssen, um x in y in binär zu transformieren.\n    >>> f_8(1,2)\n    2", "ha": "Ƙididdige nisan Hamming tsakanin lambobi biyu a cikin wakilcin binary.\n    Sigogi:\n- x (int): Lamba ta farko mai kyau (x <= 1,000,000,000).\n- y (int): Lamba ta biyu mai kyau (y <= 1,000,000,000).\n    Dawowa:\n    int: Nisan Hamming tsakanin x da y, wato, adadin bits da ake buƙatar juyawa don canza x zuwa y a cikin binary.\n    >>> f_8(1,2)\n    2", "hi": "दो पूर्णांकों के बीच बाइनरी प्रतिनिधित्व में हैमिंग दूरी की गणना करें।\n    पैरामीटर्स:\n- x (int): पहला धनात्मक पूर्णांक (x <= 1,000,000,000)।\n- y (int): दूसरा धनात्मक पूर्णांक (y <= 1,000,000,000)।\n    रिटर्न्स:\n    int: x और y के बीच हैमिंग दूरी, अर्थात्, x को बाइनरी में y में बदलने के लिए जितने बिट्स को उलटना आवश्यक है।\n    >>> f_8(1,2)\n    2", "hu": "Számítsa ki a Hamming-távolságot két egész szám bináris ábrázolása között.\n    Paraméterek:\n- x (int): Az első pozitív egész szám (x <= 1,000,000,000).\n- y (int): A második pozitív egész szám (y <= 1,000,000,000).\n    Visszatérési érték:\n    int: A Hamming-távolság x és y között, azaz a bitek száma, amelyeket meg kell változtatni ahhoz, hogy x-et y-ra alakítsuk binárisan.\n    >>> f_8(1,2)\n    2", "es": "Calcular la distancia de Hamming entre dos enteros en representación binaria.\n    Parámetros:\n- x (int): El primer entero positivo (x <= 1,000,000,000).\n- y (int): El segundo entero positivo (y <= 1,000,000,000).\n    Devuelve:\n    int: La distancia de Hamming entre x e y, es decir, el número de bits que deben ser cambiados para transformar x en y en binario.\n    >>> f_8(1,2)\n    2", "arb": "احسب مسافة هامنج بين عددين صحيحين في التمثيل الثنائي.\n    المعاملات:\n- x (int): العدد الصحيح الأول الموجب (x <= 1,000,000,000).\n- y (int): العدد الصحيح الثاني الموجب (y <= 1,000,000,000).\n    يعيد:\n    int: مسافة هامنج بين x و y، أي عدد البتات التي تحتاج إلى قلب لتحويل x إلى y في النظام الثنائي.\n    >>> f_8(1,2)\n    2", "sw": "Hesabu umbali wa Hamming kati ya nambari mbili katika uwakilishi wa binary.\n    Vigezo:\n- x (int): Nambari ya kwanza chanya (x <= 1,000,000,000).\n- y (int): Nambari ya pili chanya (y <= 1,000,000,000).\n    Inarejesha:\n    int: Umbali wa Hamming kati ya x na y, yaani, idadi ya biti zinazohitaji kubadilishwa ili kubadilisha x kuwa y katika binary.\n    >>> f_8(1,2)\n    2", "tr": "İkili gösterimde iki tamsayı arasındaki Hamming mesafesini hesaplayın.\n    Parametreler:\n- x (int): İlk pozitif tamsayı (x <= 1,000,000,000).\n- y (int): İkinci pozitif tamsayı (y <= 1,000,000,000).\n    Döndürür:\n    int: x ve y arasındaki Hamming mesafesi, yani x'i ikili olarak y'ye dönüştürmek için çevrilmesi gereken bit sayısı.\n    >>> f_8(1,2)\n    2", "vi": "Tính khoảng cách Hamming giữa hai số nguyên trong biểu diễn nhị phân.\n    Tham số:\n- x (int): Số nguyên dương thứ nhất (x <= 1,000,000,000).\n- y (int): Số nguyên dương thứ hai (y <= 1,000,000,000).\n    Trả về:\n    int: Khoảng cách Hamming giữa x và y, tức là số bit cần phải lật để biến đổi x thành y trong nhị phân.\n    >>> f_8(1,2)\n    2", "id": "Hitung jarak Hamming antara dua bilangan bulat dalam representasi biner.\n    Parameter:\n- x (int): Bilangan bulat positif pertama (x <= 1,000,000,000).\n- y (int): Bilangan bulat positif kedua (y <= 1,000,000,000).\n    Mengembalikan:\n    int: Jarak Hamming antara x dan y, yaitu jumlah bit yang perlu dibalik untuk mengubah x menjadi y dalam biner.\n    >>> f_8(1,2)\n    2", "ja": "2つの整数の2進数表現におけるハミング距離を計算します。\n    パラメータ:\n- x (int): 最初の正の整数 (x <= 1,000,000,000)。\n- y (int): 2番目の正の整数 (y <= 1,000,000,000)。\n    戻り値:\n    int: xとyのハミング距離、つまりxを2進数でyに変換するために反転する必要があるビットの数。\n    >>> f_8(1,2)\n    2", "ko": "이진 표현에서 두 정수 사이의 해밍 거리 계산.\n\n    매개변수:\n    - x (int): 첫 번째 양의 정수 (x <= 1,000,000,000).\n    - y (int): 두 번째 양의 정수 (y <= 1,000,000,000).\n\n    반환:\n    int: x와 y 사이의 해밍 거리, 즉 이진수에서 x를 y로 변환하기 위해 뒤집어야 하는 비트의 수.\n\n    >>> f_8(1,2)\n    2", "ml": "രണ്ടു പൂർണ്ണസംഖ്യകളുടെ ബൈനറി പ്രതിനിധാനത്തിൽ ഹാമ്മിംഗ് ദൂരമനക്കുക.\n    പാരാമീറ്ററുകൾ:\n- x (int): ആദ്യത്തെ പോസിറ്റീവ് പൂർണ്ണസംഖ്യ (x <= 1,000,000,000).\n- y (int): രണ്ടാമത്തെ പോസിറ്റീവ് പൂർണ്ണസംഖ്യ (y <= 1,000,000,000).\n    തിരികെ നൽകുന്നത്:\n    int: x നും y നും ഇടയിലെ ഹാമിംഗ് ദൂരം, അതായത്, ബൈനറിയിൽ x നെ y ആക്കാൻ മാറ്റേണ്ട ബിറ്റുകളുടെ എണ്ണം.\n    >>> f_8(1,2)\n    2", "fa": "محاسبه فاصله همینگ بین دو عدد صحیح در نمایش باینری.\n    پارامترها:\n- x (int): عدد صحیح اول (x <= 1,000,000,000).\n- y (int): عدد صحیح دوم (y <= 1,000,000,000).\n    بازگشت:\n    int: فاصله همینگ بین x و y، یعنی تعداد بیت‌هایی که باید تغییر کنند تا x به y در باینری تبدیل شود.\n    >>> f_8(1,2)\n    2"}}
{"task_id": "CPP/9", "prompt": {"en": "#include <assert.h>\n#include <stdarg.h>\n\n/**\n * Count the number of odd integers in a given list of numbers.\n * Parameters:\n * - count (int): The number of integers to evaluate.\n * - ... (int): A sequence of integers.\n * Returns:\n *   int: The count of odd numbers in the input list.\n * Usage:\n *   f_9(5, 1, 4, 3, 2, 5) should return 3\n */\nint f_9(int count, ...)", "sq": "#include <assert.h>\n#include <stdarg.h>\n\n/**\n * Numëron numrin e numrave tek në një listë të dhënë numrash.\n * Parametrat:\n * - count (int): Numri i tërësishëm për t'u vlerësuar.\n * - ... (int): Një sekuencë tërësish.\n * Kthen:\n *   int: Numri i numrave tek në listën e dhënë.\n * Përdorimi:\n *   f_9(5, 1, 4, 3, 2, 5) duhet të kthejë 3\n */\nint f_9(int count, ...)", "hy": "#include <assert.h>\n#include <stdarg.h>\n\n/**\n * Հաշվել տրված թվերի ցանկում կենտ ամբողջ թվերի քանակը։\n * Պարամետրեր:\n * - count (int): Արժևորելու ենթակա ամբողջ թվերի քանակը։\n * - ... (int): Ամբողջ թվերի հաջորդականություն։\n * Վերադարձնում է:\n *   int: Կենտ թվերի քանակը մուտքային ցանկում։\n * Օգտագործում:\n *   f_9(5, 1, 4, 3, 2, 5) պետք է վերադարձնի 3\n */\nint f_9(int count, ...)", "bn": "#include <assert.h>\n#include <stdarg.h>\n\n/**\n * প্রদত্ত সংখ্যার তালিকায় বিজোড় পূর্ণসংখ্যার সংখ্যা গণনা করুন।\n * প্যারামিটার:\n * - count (int): মূল্যায়ন করার জন্য পূর্ণসংখ্যার সংখ্যা।\n * - ... (int): পূর্ণসংখ্যার একটি ক্রম।\n * রিটার্নস:\n *   int: ইনপুট তালিকায় বিজোড় সংখ্যার সংখ্যা।\n * ব্যবহার:\n *   f_9(5, 1, 4, 3, 2, 5) 3 রিটার্ন করা উচিত\n */\nint f_9(int count, ...)", "bg": "#include <assert.h>\n#include <stdarg.h>\n\n/**\n * Брой на нечетните цели числа в даден списък от числа.\n * Параметри:\n * - count (int): Броят на целите числа за оценка.\n * - ... (int): Последователност от цели числа.\n * Връща:\n *   int: Броят на нечетните числа в входния списък.\n * Употреба:\n *   f_9(5, 1, 4, 3, 2, 5) трябва да върне 3\n */\nint f_9(int count, ...)", "zh": "#include <assert.h>\n#include <stdarg.h>\n\n/**\n * 计算给定数字列表中奇数的数量。\n * 参数:\n * - count (int): 要评估的整数数量。\n * - ... (int): 一系列整数。\n * 返回:\n *   int: 输入列表中奇数的数量。\n * 用法:\n *   f_9(5, 1, 4, 3, 2, 5) 应返回 3\n */\nint f_9(int count, ...)", "fr": "#include <assert.h>\n#include <stdarg.h>\n\n/**\n * Compter le nombre d'entiers impairs dans une liste donnée de nombres.\n * Paramètres:\n * - count (int): Le nombre d'entiers à évaluer.\n * - ... (int): Une séquence d'entiers.\n * Retourne:\n *   int: Le nombre d'entiers impairs dans la liste d'entrée.\n * Utilisation:\n *   f_9(5, 1, 4, 3, 2, 5) devrait retourner 3\n */\nint f_9(int count, ...)", "de": "#include <assert.h>\n#include <stdarg.h>\n\n/**\n * Zählt die Anzahl der ungeraden Ganzzahlen in einer gegebenen Liste von Zahlen.\n * Parameter:\n * - count (int): Die Anzahl der zu bewertenden Ganzzahlen.\n * - ... (int): Eine Sequenz von Ganzzahlen.\n * Rückgabe:\n *   int: Die Anzahl der ungeraden Zahlen in der Eingabeliste.\n * Verwendung:\n *   f_9(5, 1, 4, 3, 2, 5) sollte 3 zurückgeben\n */\nint f_9(int count, ...)", "ha": "#include <assert.h>\n#include <stdarg.h>\n\n/**\n * Ƙirga adadin lambobin da ba su daidai ba a cikin jerin lambobi da aka bayar.\n * Sigogi:\n * - count (int): Yawan lambobin da za a tantance.\n * - ... (int): Jerin lambobi.\n * Komawa:\n *   int: Adadin lambobin da ba su daidai ba a cikin jerin shigarwa.\n * Amfani:\n *   f_9(5, 1, 4, 3, 2, 5) ya kamata ya dawo da 3\n */\nint f_9(int count, ...)", "hi": "#include <assert.h>\n#include <stdarg.h>\n\n/**\n * दिए गए संख्याओं की सूची में विषम पूर्णांकों की संख्या गिनें।\n * पैरामीटर्स:\n * - count (int): मूल्यांकन करने के लिए पूर्णांकों की संख्या।\n * - ... (int): पूर्णांकों का अनुक्रम।\n * रिटर्न करता है:\n *   int: इनपुट सूची में विषम संख्याओं की गिनती।\n * उपयोग:\n *   f_9(5, 1, 4, 3, 2, 5) को 3 लौटाना चाहिए\n */\nint f_9(int count, ...)", "hu": "#include <assert.h>\n#include <stdarg.h>\n\n/**\n * Számolja meg a páratlan egész számok számát egy adott számok listájában.\n * Paraméterek:\n * - count (int): Az értékelendő egész számok száma.\n * - ... (int): Egy egész számok sorozata.\n * Visszatér:\n *   int: A bemeneti listában lévő páratlan számok száma.\n * Használat:\n *   f_9(5, 1, 4, 3, 2, 5) vissza kell adja a 3-at\n */\nint f_9(int count, ...)", "es": "#include <assert.h>\n#include <stdarg.h>\n\n/**\n * Cuenta el número de enteros impares en una lista dada de números.\n * Parámetros:\n * - count (int): El número de enteros a evaluar.\n * - ... (int): Una secuencia de enteros.\n * Retorna:\n *   int: La cuenta de números impares en la lista de entrada.\n * Uso:\n *   f_9(5, 1, 4, 3, 2, 5) debería retornar 3\n */\nint f_9(int count, ...)", "arb": "#include <assert.h>\n#include <stdarg.h>\n\n/**\n * عد عدد الأعداد الفردية في قائمة معينة من الأرقام.\n * المعلمات:\n * - count (int): عدد الأعداد لتقييمها.\n * - ... (int): تسلسل من الأعداد.\n * يعيد:\n *   int: عدد الأعداد الفردية في قائمة الإدخال.\n * الاستخدام:\n *   f_9(5, 1, 4, 3, 2, 5) يجب أن تعيد 3\n */\nint f_9(int count, ...)", "sw": "#include <assert.h>\n#include <stdarg.h>\n\n/**\n * Hesabu idadi ya namba zisizo za kawaida katika orodha iliyotolewa ya namba.\n * Vigezo:\n * - count (int): Idadi ya namba za kutathmini.\n * - ... (int): Mlolongo wa namba.\n * Inarudisha:\n *   int: Idadi ya namba zisizo za kawaida katika orodha ya ingizo.\n * Matumizi:\n *   f_9(5, 1, 4, 3, 2, 5) inapaswa kurudisha 3\n */\nint f_9(int count, ...)", "tr": "#include <assert.h>\n#include <stdarg.h>\n\n/**\n * Verilen bir sayı listesindeki tek sayıların sayısını hesaplayın.\n * Parametreler:\n * - count (int): Değerlendirilecek sayıların sayısı.\n * - ... (int): Bir dizi tamsayı.\n * Döndürür:\n *   int: Girdi listesindeki tek sayıların sayısı.\n * Kullanım:\n *   f_9(5, 1, 4, 3, 2, 5) 3 döndürmelidir\n */\nint f_9(int count, ...)", "vi": "#include <assert.h>\n#include <stdarg.h>\n\n/**\n * Đếm số lượng số nguyên lẻ trong một danh sách số đã cho.\n * Tham số:\n * - count (int): Số lượng số nguyên cần đánh giá.\n * - ... (int): Một dãy số nguyên.\n * Trả về:\n *   int: Số lượng số lẻ trong danh sách đầu vào.\n * Sử dụng:\n *   f_9(5, 1, 4, 3, 2, 5) sẽ trả về 3\n */\nint f_9(int count, ...)", "id": "#include <assert.h>\n#include <stdarg.h>\n\n/**\n * Hitung jumlah bilangan ganjil dalam daftar bilangan yang diberikan.\n * Parameter:\n * - count (int): Jumlah bilangan bulat yang akan dievaluasi.\n * - ... (int): Urutan bilangan bulat.\n * Mengembalikan:\n *   int: Jumlah bilangan ganjil dalam daftar input.\n * Penggunaan:\n *   f_9(5, 1, 4, 3, 2, 5) seharusnya mengembalikan 3\n */\nint f_9(int count, ...)", "ja": "#include <assert.h>\n#include <stdarg.h>\n\n/**\n * 指定された数のリスト内の奇数の数をカウントします。\n * パラメータ:\n * - count (int): 評価する整数の数。\n * - ... (int): 整数のシーケンス。\n * 戻り値:\n *   int: 入力リスト内の奇数の数。\n * 使用例:\n *   f_9(5, 1, 4, 3, 2, 5) は 3 を返すべきです\n */\nint f_9(int count, ...)", "ko": "#include <assert.h>\n#include <stdarg.h>\n\n/**\n * 주어진 숫자 목록에서 홀수 정수의 개수를 센다.\n * 매개변수:\n * - count (int): 평가할 정수의 수.\n * - ... (int): 정수의 시퀀스.\n * 반환값:\n *   int: 입력 목록에서 홀수의 개수.\n * 사용법:\n *   f_9(5, 1, 4, 3, 2, 5) 는 3을 반환해야 한다\n */\nint f_9(int count, ...)", "ml": "#include <assert.h>\n#include <stdarg.h>\n\n/**\n * നൽകിയ ഒരു സംഖ്യാവിഹിതത്തിലുള്ള ബിസമ സംഖ്യകളുടെ എണ്ണം എണ്ണുക.\n * പാരാമീറ്ററുകൾ:\n * - count (int): വിലയിരുത്തേണ്ട സംഖ്യകളുടെ എണ്ണം.\n * - ... (int): ഒരു സംഖ്യാവിഹിതം.\n * മടക്കുന്നു:\n *   int: ഇൻപുട്ട് ലിസ്റ്റിലുള്ള ബിസമ സംഖ്യകളുടെ എണ്ണം.\n * ഉപയോഗം:\n *   f_9(5, 1, 4, 3, 2, 5) 3 മടക്കണം\n */\nint f_9(int count, ...)", "fa": "#include <assert.h>\n#include <stdarg.h>\n\n/**\n * تعداد اعداد فرد در یک لیست از اعداد داده شده را بشمارید.\n * پارامترها:\n * - count (int): تعداد اعدادی که باید ارزیابی شوند.\n * - ... (int): دنباله‌ای از اعداد صحیح.\n * بازگشت:\n *   int: تعداد اعداد فرد در لیست ورودی.\n * استفاده:\n *   f_9(5, 1, 4, 3, 2, 5) باید 3 را برگرداند\n */\nint f_9(int count, ...)"}, "canonical_solution": "{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1) {\n            ans++;\n        }\n    }\n    va_end(args);\n    return ans;\n}", "instruction": {"en": "int f_9(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1) {\n            ans++;\n        }\n    }\n    va_end(args);\n    return ans;\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.", "sq": "int f_9(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1) {\n            ans++;\n        }\n    }\n    va_end(args);\n    return ans;\n}\n\nJepni një përshkrim të shkurtër në gjuhën natyrore (docstring) të kodit CPP në shqip duke përdorur maksimumi 500 karaktere.", "hy": "int f_9(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1) {\n            ans++;\n        }\n    }\n    va_end(args);\n    return ans;\n}\n\nՏվեք CPP կոդի հակիրճ բնութագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "int f_9(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1) {\n            ans++;\n        }\n    }\n    va_end(args);\n    return ans;\n}\n\nসিপিপি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।", "bg": "int f_9(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1) {\n            ans++;\n        }\n    }\n    va_end(args);\n    return ans;\n}\n\nПредоставете кратко описание на CPP кода на български език, използвайки не повече от 500 знака.", "zh": "int f_9(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1) {\n            ans++;\n        }\n    }\n    va_end(args);\n    return ans;\n}\n\n请用最多500个字符的中文对该CPP代码提供简洁的自然语言描述（文档字符串）。", "fr": "int f_9(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1) {\n            ans++;\n        }\n    }\n    va_end(args);\n    return ans;\n}\n\nFournissez une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.", "de": "int f_9(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1) {\n            ans++;\n        }\n    }\n    va_end(args);\n    return ans;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen.", "ha": "int f_9(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1) {\n            ans++;\n        }\n    }\n    va_end(args);\n    return ans;\n}\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar CPP a cikin Hausa ta amfani da haruffa 500 kacal.", "hi": "int f_9(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1) {\n            ans++;\n        }\n    }\n    va_end(args);\n    return ans;\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।", "hu": "int f_9(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1) {\n            ans++;\n        }\n    }\n    va_end(args);\n    return ans;\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a CPP kódról magyarul, legfeljebb 500 karakterben.", "es": "int f_9(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1) {\n            ans++;\n        }\n    }\n    va_end(args);\n    return ans;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando como máximo 500 caracteres.", "arb": "int f_9(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1) {\n            ans++;\n        }\n    }\n    va_end(args);\n    return ans;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية المكتوبة بلغة CPP باللغة العربية الفصحى، على ألا يتجاوز 500 حرف.", "sw": "int f_9(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1) {\n            ans++;\n        }\n    }\n    va_end(args);\n    return ans;\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "int f_9(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1) {\n            ans++;\n        }\n    }\n    va_end(args);\n    return ans;\n}\n\nAşağıdaki CPP kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda bir doğal dil açıklaması (docstring) sağlayın.", "vi": "int f_9(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1) {\n            ans++;\n        }\n    }\n    va_end(args);\n    return ans;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự.", "id": "int f_9(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1) {\n            ans++;\n        }\n    }\n    va_end(args);\n    return ans;\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode CPP dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "int f_9(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1) {\n            ans++;\n        }\n    }\n    va_end(args);\n    return ans;\n}\n\n以下のCPPコードの簡潔な自然言語による説明（ドックストリング）を日本語で500文字以内で提供してください。", "ko": "int f_9(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1) {\n            ans++;\n        }\n    }\n    va_end(args);\n    return ans;\n}\n\n다음 CPP 코드에 대한 간결한 자연어 설명(도크스트링)을 한국어로 500자 이내로 제공하세요.", "ml": "int f_9(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1) {\n            ans++;\n        }\n    }\n    va_end(args);\n    return ans;\n}\n\nCPP കോഡ് ഉപയോഗിച്ച് ഒരു സംക്ഷിപ്തമായ സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) മലയാളത്തിൽ 500 അക്ഷരങ്ങൾക്കുള്ളിൽ നൽകുക.", "fa": "int f_9(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1) {\n            ans++;\n        }\n    }\n    va_end(args);\n    return ans;\n}\n\nتوضیح مختصر و طبیعی (docstring) از کد CPP را به زبان فارسی با حداکثر ۵۰۰ کاراکتر ارائه دهید."}, "level": "", "test": "int main() {\n    assert(f_9(5, 1, 4, 3, 2, 5) == 3);\n    assert(f_9(4, 2, 2, 0, 0) == 0);\n    assert(f_9(6, 7, 7, 8, 1, 9, 10) == 4); // Additional Test Sample\n    // Uncomment the following line to print a success message\n    // std::printf(\"All tests passed!\\n\");\n    return 0;\n}", "entry_point": "f_9", "signature": "int f_9(int count, ...)", "docstring": {"en": "Count the number of odd integers in a given list of numbers.\nParameters:\n- count (int): The number of integers to evaluate.\n- ... (int): A sequence of integers.\nReturns:\n  int: The count of odd numbers in the input list.\nUsage:\n  f_9(5, 1, 4, 3, 2, 5) should return 3", "sq": "Numëroni numrin e numrave tek në një listë të dhënë numrash.  \nParametrat:  \n- count (int): Numri i numrave për të vlerësuar.  \n- ... (int): Një sekuencë numrash të plotë.  \nKthen:  \n  int: Numri i numrave tek në listën e dhënë.  \nPërdorimi:  \n  f_9(5, 1, 4, 3, 2, 5) duhet të kthejë 3  ", "hy": "Հաշվել տրված թվերի ցուցակում կենտ ամբողջ թվերի քանակը։\nՊարամետրեր՝\n- count (int): Ամբողջ թվերի քանակը գնահատելու համար։\n- ... (int): Ամբողջ թվերի հաջորդականություն։\nՎերադարձնում է՝\n  int: Կենտ թվերի քանակը մուտքագրված ցուցակում։\nՕգտագործում՝\n  f_9(5, 1, 4, 3, 2, 5) պետք է վերադարձնի 3", "bn": "দেওয়া সংখ্যার তালিকায় বিজোড় পূর্ণসংখ্যার সংখ্যা গণনা করুন।\nপ্যারামিটারসমূহ:\n- count (int): মূল্যায়ন করার পূর্ণসংখ্যার সংখ্যা।\n- ... (int): পূর্ণসংখ্যার একটি ক্রম।\nফেরত দেয়:\n  int: ইনপুট তালিকায় বিজোড় সংখ্যার সংখ্যা।\nব্যবহার:\n  f_9(5, 1, 4, 3, 2, 5) 3 ফেরত দেবে।", "bg": "Бройте броя на нечетните цели числа в даден списък от числа.\nПараметри:\n- count (int): Броят на целите числа за оценка.\n- ... (int): Последователност от цели числа.\nВръща:\n  int: Броят на нечетните числа в входния списък.\nИзползване:\n  f_9(5, 1, 4, 3, 2, 5) трябва да върне 3", "zh": "计算给定数字列表中奇数的数量。\n参数：\n- count (int): 要评估的整数数量。\n- ... (int): 一系列整数。\n返回：\n  int: 输入列表中奇数的数量。\n用法：\n  f_9(5, 1, 4, 3, 2, 5) 应返回 3", "fr": "Compter le nombre d'entiers impairs dans une liste donnée de nombres.\nParamètres:\n- count (int): Le nombre d'entiers à évaluer.\n- ... (int): Une séquence d'entiers.\nRenvoie:\n  int: Le nombre d'entiers impairs dans la liste d'entrée.\nUtilisation:\n  f_9(5, 1, 4, 3, 2, 5) devrait renvoyer 3", "de": "Zähle die Anzahl der ungeraden Ganzzahlen in einer gegebenen Liste von Zahlen.\nParameter:\n- count (int): Die Anzahl der zu bewertenden Ganzzahlen.\n- ... (int): Eine Sequenz von Ganzzahlen.\nRückgabe:\n  int: Die Anzahl der ungeraden Zahlen in der Eingabeliste.\nVerwendung:\n  f_9(5, 1, 4, 3, 2, 5) sollte 3 zurückgeben.", "ha": "Ƙirga adadin lambobin da ba su da ma'aurata a cikin jerin lambobi da aka bayar.\nParameters:  \n- count (int): Yawan lambobin da za a tantance.  \n- ... (int): Jerin lambobi.  \nReturns:  \n  int: Yawan lambobin da ba su da ma'ana a cikin jerin shigarwa.  \nUsage:  \n  f_9(5, 1, 4, 3, 2, 5) ya kamata ya dawo da 3", "hi": "दिए गए संख्याओं की सूची में विषम पूर्णांकों की संख्या गिनें।  \nपैरामीटर्स:  \n- count (int): मूल्यांकन करने के लिए पूर्णांकों की संख्या।  \n- ... (int): पूर्णांकों का अनुक्रम।  \nरिटर्न्स:  \n  int: इनपुट सूची में विषम संख्याओं की गिनती।  \nउपयोग:  \n  f_9(5, 1, 4, 3, 2, 5) को 3 लौटाना चाहिए।", "hu": "Számolja meg a páratlan egész számok számát egy adott számok listájában.\nParaméterek:\n- count (int): Az értékelendő egész számok száma.\n- ... (int): Egy egész számok sorozata.\nVisszatér:\n  int: A páratlan számok száma a bemeneti listában.\nHasználat:\n  f_9(5, 1, 4, 3, 2, 5) esetén az eredmény 3 kell legyen.", "es": "Cuenta el número de enteros impares en una lista dada de números.\nParámetros:\n- count (int): La cantidad de enteros a evaluar.\n- ... (int): Una secuencia de enteros.\nDevuelve:\n  int: La cantidad de números impares en la lista de entrada.\nUso:\n  f_9(5, 1, 4, 3, 2, 5) debería devolver 3", "arb": "احسب عدد الأعداد الفردية في قائمة معينة من الأرقام.\nالمعلمات:\n- count (int): عدد الأعداد التي سيتم تقييمها.\n- ... (int): سلسلة من الأعداد الصحيحة.\nالقيم المعادة:\n  int: عدد الأعداد الفردية في قائمة الإدخال.\nالاستخدام:\n  f_9(5, 1, 4, 3, 2, 5) يجب أن تعيد 3", "sw": "Hesabu idadi ya nambari zisizo za kawaida katika orodha iliyotolewa ya nambari.  \nVigezo:  \n- count (int): Idadi ya nambari za kutathmini.  \n- ... (int): Mfululizo wa nambari.  \nRudisha:  \n  int: Idadi ya nambari zisizo za kawaida katika orodha ya ingizo.  \nMatumizi:  \n  f_9(5, 1, 4, 3, 2, 5) inapaswa kurudisha 3  ", "tr": "Verilen bir sayı listesinde tek sayıların sayısını sayın.\nParametreler:\n- count (int): Değerlendirilecek tamsayıların sayısı.\n- ... (int): Bir dizi tamsayı.\nDöndürür:\n  int: Girdi listesindeki tek sayıların sayısı.\nKullanım:\n  f_9(5, 1, 4, 3, 2, 5) 3 döndürmelidir.", "vi": "Đếm số lượng số nguyên lẻ trong một danh sách số đã cho.\nTham số:\n- count (int): Số lượng số nguyên cần đánh giá.\n- ... (int): Một dãy số nguyên.\nTrả về:\n  int: Số lượng số lẻ trong danh sách đầu vào.\nSử dụng:\n  f_9(5, 1, 4, 3, 2, 5) nên trả về 3", "id": "Hitung jumlah bilangan bulat ganjil dalam daftar angka yang diberikan.\nParameter:\n- count (int): Jumlah bilangan bulat yang akan dievaluasi.\n- ... (int): Urutan bilangan bulat.\nMengembalikan:\n  int: Jumlah bilangan ganjil dalam daftar input.\nPenggunaan:\n  f_9(5, 1, 4, 3, 2, 5) seharusnya mengembalikan 3", "ja": "奇数の整数の数を、指定された数値のリスト内で数えます。\n引数:\n- count (int): 評価する整数の数。\n- ... (int): 整数のシーケンス。\n戻り値:\n  int: 入力リスト内の奇数の数。\n使用例:\n  f_9(5, 1, 4, 3, 2, 5) は 3 を返すべきです。", "ko": "주어진 숫자 목록에서 홀수 정수의 개수를 계산합니다.\n매개변수:\n- count (int): 평가할 정수의 개수.\n- ... (int): 정수의 시퀀스.\n반환:\n  int: 입력 목록에서 홀수의 개수.\n사용 예:\n  f_9(5, 1, 4, 3, 2, 5)는 3을 반환해야 합니다.", "ml": "ഒരു നൽകിയ ലിസ്റ്റിലുള്ള বিজാതീയ സംഖ്യകളുടെ എണ്ണം എണ്ണുക. \nഅവലംബങ്ങൾ:\n- count (int): വിലയിരുത്താനുള്ള സംഖ്യകളുടെ എണ്ണം.\n- ... (int): ഒരു സംഖ്യകളുടെ ശ്രേണി.\nമടക്കൽ:\n  int: ഇൻപുട്ട് ലിസ്റ്റിലെ বিজാതീയ സംഖ്യകളുടെ എണ്ണം.\nഉപയോഗം:\n  f_9(5, 1, 4, 3, 2, 5) 3 മടക്കണം.", "fa": "تعداد اعداد فرد را در یک لیست داده شده از اعداد بشمارید.\nپارامترها:\n- count (int): تعداد اعدادی که باید ارزیابی شوند.\n- ... (int): یک دنباله از اعداد صحیح.\nبازگشت:\n  int: تعداد اعداد فرد در لیست ورودی.\nاستفاده:\n  f_9(5, 1, 4, 3, 2, 5) باید 3 را برگرداند."}}
{"task_id": "CPP/10", "prompt": {"en": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Calculate the sum of even numbers in a given array.\n * \n * Parameters:\n * - numbers (vector<int>): A vector of integers.\n * - size (int): The size of the array.\n * \n * Returns:\n * int: The sum of even numbers in the input array.\n * \n * Examples:\n * >>> f_10({1,4,3,2,5}, 5)\n * 6\n */\nint f_10(const std::vector<int>& numbers)", "sq": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Llogarit shumën e numrave çift në një varg të dhënë.\n * \n * Parametrat:\n * - numbers (vector<int>): Një vektor i numrave të plotë.\n * - size (int): Madhësia e vargut.\n * \n * Kthen:\n * int: Shuma e numrave çift në vargun hyrës.\n * \n * Shembuj:\n * >>> f_10({1,4,3,2,5}, 5)\n * 6\n */\nint f_10(const std::vector<int>& numbers)", "hy": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Հաշվել տրված զանգվածի զույգ թվերի գումարը։\n * \n * Պարամետրեր:\n * - numbers (vector<int>): Թվերի վեկտոր։\n * - size (int): Զանգվածի չափը։\n * \n * Վերադարձնում է:\n * int: Մուտքային զանգվածի զույգ թվերի գումարը։\n * \n * Օրինակներ:\n * >>> f_10({1,4,3,2,5}, 5)\n * 6\n */\nint f_10(const std::vector<int>& numbers)", "bn": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * প্রদত্ত অ্যারের মধ্যে জোড় সংখ্যাগুলির যোগফল গণনা করুন।\n * \n * প্যারামিটার:\n * - numbers (vector<int>): পূর্ণসংখ্যার একটি ভেক্টর।\n * - size (int): অ্যারের আকার।\n * \n * রিটার্নস:\n * int: ইনপুট অ্যারের জোড় সংখ্যাগুলির যোগফল।\n * \n * উদাহরণ:\n * >>> f_10({1,4,3,2,5}, 5)\n * 6\n */\nint f_10(const std::vector<int>& numbers)", "bg": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Изчислява сумата на четните числа в даден масив.\n * \n * Параметри:\n * - numbers (vector<int>): Вектор от цели числа.\n * - size (int): Размерът на масива.\n * \n * Връща:\n * int: Сумата на четните числа в входния масив.\n * \n * Примери:\n * >>> f_10({1,4,3,2,5}, 5)\n * 6\n */\nint f_10(const std::vector<int>& numbers)", "zh": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * 计算给定数组中偶数的和。\n * \n * 参数:\n * - numbers (vector<int>): 整数向量。\n * - size (int): 数组的大小。\n * \n * 返回:\n * int: 输入数组中偶数的和。\n * \n * 示例:\n * >>> f_10({1,4,3,2,5}, 5)\n * 6\n */\nint f_10(const std::vector<int>& numbers)", "fr": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Calculer la somme des nombres pairs dans un tableau donné.\n * \n * Paramètres:\n * - numbers (vector<int>): Un vecteur d'entiers.\n * - size (int): La taille du tableau.\n * \n * Renvoie:\n * int: La somme des nombres pairs dans le tableau d'entrée.\n * \n * Exemples:\n * >>> f_10({1,4,3,2,5}, 5)\n * 6\n */\nint f_10(const std::vector<int>& numbers)", "de": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Berechne die Summe der geraden Zahlen in einem gegebenen Array.\n * \n * Parameter:\n * - numbers (vector<int>): Ein Vektor von ganzen Zahlen.\n * - size (int): Die Größe des Arrays.\n * \n * Rückgabewert:\n * int: Die Summe der geraden Zahlen im Eingabearray.\n * \n * Beispiele:\n * >>> f_10({1,4,3,2,5}, 5)\n * 6\n */\nint f_10(const std::vector<int>& numbers)", "ha": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Lissafi jimillar lambobin da suka kasance ma'aurata a cikin wani jeri.\n * \n * Sigogi:\n * - numbers (vector<int>): Wani vector na lambobi.\n * - size (int): Girman jerin.\n * \n * Komawa:\n * int: Jimillar lambobin da suka kasance ma'aurata a cikin jerin shigarwa.\n * \n * Misalai:\n * >>> f_10({1,4,3,2,5}, 5)\n * 6\n */\nint f_10(const std::vector<int>& numbers)", "hi": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * दिए गए array में सम संख्याओं का योग गणना करें।\n * \n * पैरामीटर्स:\n * - numbers (vector<int>): पूर्णांकों का एक वेक्टर।\n * - size (int): array का आकार।\n * \n * रिटर्न करता है:\n * int: इनपुट array में सम संख्याओं का योग।\n * \n * उदाहरण:\n * >>> f_10({1,4,3,2,5}, 5)\n * 6\n */\nint f_10(const std::vector<int>& numbers)", "hu": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Számítsa ki a páros számok összegét egy adott tömbben.\n * \n * Paraméterek:\n * - numbers (vector<int>): Egész számok vektora.\n * - size (int): A tömb mérete.\n * \n * Visszatérési érték:\n * int: A bemeneti tömbben lévő páros számok összege.\n * \n * Példák:\n * >>> f_10({1,4,3,2,5}, 5)\n * 6\n */\nint f_10(const std::vector<int>& numbers)", "es": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Calcular la suma de números pares en un arreglo dado.\n * \n * Parámetros:\n * - numbers (vector<int>): Un vector de enteros.\n * - size (int): El tamaño del arreglo.\n * \n * Devuelve:\n * int: La suma de los números pares en el arreglo de entrada.\n * \n * Ejemplos:\n * >>> f_10({1,4,3,2,5}, 5)\n * 6\n */\nint f_10(const std::vector<int>& numbers)", "arb": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * حساب مجموع الأعداد الزوجية في مصفوفة معينة.\n * \n * المعاملات:\n * - numbers (vector<int>): متجه من الأعداد الصحيحة.\n * - size (int): حجم المصفوفة.\n * \n * يعيد:\n * int: مجموع الأعداد الزوجية في المصفوفة المدخلة.\n * \n * أمثلة:\n * >>> f_10({1,4,3,2,5}, 5)\n * 6\n */\nint f_10(const std::vector<int>& numbers)", "sw": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Hesabu jumla ya namba shufwa katika safu iliyotolewa.\n * \n * Vigezo:\n * - numbers (vector<int>): Vector ya namba nzima.\n * - size (int): Ukubwa wa safu.\n * \n * Inarudisha:\n * int: Jumla ya namba shufwa katika safu ya ingizo.\n * \n * Mifano:\n * >>> f_10({1,4,3,2,5}, 5)\n * 6\n */\nint f_10(const std::vector<int>& numbers)", "tr": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Verilen bir dizideki çift sayıların toplamını hesapla.\n * \n * Parametreler:\n * - numbers (vector<int>): Bir tamsayı vektörü.\n * - size (int): Dizinin boyutu.\n * \n * Döndürür:\n * int: Girdi dizisindeki çift sayıların toplamı.\n * \n * Örnekler:\n * >>> f_10({1,4,3,2,5}, 5)\n * 6\n */\nint f_10(const std::vector<int>& numbers)", "vi": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Tính tổng các số chẵn trong một mảng cho trước.\n * \n * Tham số:\n * - numbers (vector<int>): Một vector các số nguyên.\n * - size (int): Kích thước của mảng.\n * \n * Trả về:\n * int: Tổng các số chẵn trong mảng đầu vào.\n * \n * Ví dụ:\n * >>> f_10({1,4,3,2,5}, 5)\n * 6\n */\nint f_10(const std::vector<int>& numbers)", "id": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Hitung jumlah bilangan genap dalam array yang diberikan.\n * \n * Parameter:\n * - numbers (vector<int>): Sebuah vektor dari bilangan bulat.\n * - size (int): Ukuran dari array.\n * \n * Mengembalikan:\n * int: Jumlah bilangan genap dalam array masukan.\n * \n * Contoh:\n * >>> f_10({1,4,3,2,5}, 5)\n * 6\n */\nint f_10(const std::vector<int>& numbers)", "ja": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * 指定された配列内の偶数の合計を計算します。\n * \n * パラメータ:\n * - numbers (vector<int>): 整数のベクター。\n * - size (int): 配列のサイズ。\n * \n * 戻り値:\n * int: 入力配列内の偶数の合計。\n * \n * 例:\n * >>> f_10({1,4,3,2,5}, 5)\n * 6\n */\nint f_10(const std::vector<int>& numbers)", "ko": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * 주어진 배열에서 짝수의 합을 계산합니다.\n * \n * 매개변수:\n * - numbers (vector<int>): 정수의 벡터.\n * - size (int): 배열의 크기.\n * \n * 반환값:\n * int: 입력 배열에서 짝수의 합.\n * \n * 예시:\n * >>> f_10({1,4,3,2,5}, 5)\n * 6\n */\nint f_10(const std::vector<int>& numbers)", "ml": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * നൽകിയിരിക്കുന്ന അറേയിലുള്ള സമവായ സംഖ്യകളുടെ മൊത്തം കണക്കാക്കുക.\n * \n * പാരാമീറ്ററുകൾ:\n * - numbers (vector<int>): പൂർണ്ണസംഖ്യകളുടെ ഒരു വെക്ടർ.\n * - size (int): അറേയുടെ വലുപ്പം.\n * \n * മടക്കുന്നു:\n * int: ഇൻപുട്ട് അറേയിലുള്ള സമവായ സംഖ്യകളുടെ മൊത്തം.\n * \n * ഉദാഹരണങ്ങൾ:\n * >>> f_10({1,4,3,2,5}, 5)\n * 6\n */\nint f_10(const std::vector<int>& numbers)", "fa": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * محاسبه مجموع اعداد زوج در یک آرایه داده شده.\n * \n * پارامترها:\n * - numbers (vector<int>): یک وکتور از اعداد صحیح.\n * - size (int): اندازه آرایه.\n * \n * برمی‌گرداند:\n * int: مجموع اعداد زوج در آرایه ورودی.\n * \n * مثال‌ها:\n * >>> f_10({1,4,3,2,5}, 5)\n * 6\n */\nint f_10(const std::vector<int>& numbers)"}, "canonical_solution": "{\n    int ans = 0;\n    for (auto num : numbers) {\n        if ((num & 1) == 0) { // Only sum the even numbers\n            ans += num;\n        }\n    }\n    return ans;\n}", "instruction": {"en": "int f_10(const std::vector<int>& numbers)\n{\n    int ans = 0;\n    for (auto num : numbers) {\n        if ((num & 1) == 0) { // Only sum the even numbers\n            ans += num;\n        }\n    }\n    return ans;\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.", "sq": "int f_10(const std::vector<int>& numbers)\n{\n    int ans = 0;\n    for (auto num : numbers) {\n        if ((num & 1) == 0) { // Only sum the even numbers\n            ans += num;\n        }\n    }\n    return ans;\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit CPP në gjuhën shqipe duke përdorur maksimumi 500 karaktere.", "hy": "int f_10(const std::vector<int>& numbers)\n{\n    int ans = 0;\n    for (auto num : numbers) {\n        if ((num & 1) == 0) { // Only sum the even numbers\n            ans += num;\n        }\n    }\n    return ans;\n}\n\nՏվեք CPP կոդի համառոտ բնութագրումը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։", "bn": "int f_10(const std::vector<int>& numbers)\n{\n    int ans = 0;\n    for (auto num : numbers) {\n        if ((num & 1) == 0) { // Only sum the even numbers\n            ans += num;\n        }\n    }\n    return ans;\n}\n\nনিচের CPP কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।", "bg": "int f_10(const std::vector<int>& numbers)\n{\n    int ans = 0;\n    for (auto num : numbers) {\n        if ((num & 1) == 0) { // Only sum the even numbers\n            ans += num;\n        }\n    }\n    return ans;\n}\n\nПредоставете кратко описание на CPP кода на български език, използвайки не повече от 500 знака.", "zh": "int f_10(const std::vector<int>& numbers)\n{\n    int ans = 0;\n    for (auto num : numbers) {\n        if ((num & 1) == 0) { // Only sum the even numbers\n            ans += num;\n        }\n    }\n    return ans;\n}\n\n请为以下 CPP 代码提供简洁的自然语言描述（文档字符串），使用中文且不超过 500 个字符。", "fr": "int f_10(const std::vector<int>& numbers)\n{\n    int ans = 0;\n    for (auto num : numbers) {\n        if ((num & 1) == 0) { // Only sum the even numbers\n            ans += num;\n        }\n    }\n    return ans;\n}\n\nFournir une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.", "de": "int f_10(const std::vector<int>& numbers)\n{\n    int ans = 0;\n    for (auto num : numbers) {\n        if ((num & 1) == 0) { // Only sum the even numbers\n            ans += num;\n        }\n    }\n    return ans;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen.", "ha": "int f_10(const std::vector<int>& numbers)\n{\n    int ans = 0;\n    for (auto num : numbers) {\n        if ((num & 1) == 0) { // Only sum the even numbers\n            ans += num;\n        }\n    }\n    return ans;\n}\n\nBa da taƙaitaccen bayani a cikin yaren halitta (docstring) na lambar CPP a cikin Hausa ta amfani da haruffa 500 kawai.", "hi": "int f_10(const std::vector<int>& numbers)\n{\n    int ans = 0;\n    for (auto num : numbers) {\n        if ((num & 1) == 0) { // Only sum the even numbers\n            ans += num;\n        }\n    }\n    return ans;\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रींग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "int f_10(const std::vector<int>& numbers)\n{\n    int ans = 0;\n    for (auto num : numbers) {\n        if ((num & 1) == 0) { // Only sum the even numbers\n            ans += num;\n        }\n    }\n    return ans;\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a CPP kódról magyarul, legfeljebb 500 karakterben.", "es": "int f_10(const std::vector<int>& numbers)\n{\n    int ans = 0;\n    for (auto num : numbers) {\n        if ((num & 1) == 0) { // Only sum the even numbers\n            ans += num;\n        }\n    }\n    return ans;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando como máximo 500 caracteres.", "arb": "int f_10(const std::vector<int>& numbers)\n{\n    int ans = 0;\n    for (auto num : numbers) {\n        if ((num & 1) == 0) { // Only sum the even numbers\n            ans += num;\n        }\n    }\n    return ans;\n}\n\nتقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C++ باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.", "sw": "int f_10(const std::vector<int>& numbers)\n{\n    int ans = 0;\n    for (auto num : numbers) {\n        if ((num & 1) == 0) { // Only sum the even numbers\n            ans += num;\n        }\n    }\n    return ans;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "int f_10(const std::vector<int>& numbers)\n{\n    int ans = 0;\n    for (auto num : numbers) {\n        if ((num & 1) == 0) { // Only sum the even numbers\n            ans += num;\n        }\n    }\n    return ans;\n}\n\nAşağıdaki CPP kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda, özlü bir doğal dil açıklaması (docstring) sağlayın.", "vi": "int f_10(const std::vector<int>& numbers)\n{\n    int ans = 0;\n    for (auto num : numbers) {\n        if ((num & 1) == 0) { // Only sum the even numbers\n            ans += num;\n        }\n    }\n    return ans;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự.", "id": "int f_10(const std::vector<int>& numbers)\n{\n    int ans = 0;\n    for (auto num : numbers) {\n        if ((num & 1) == 0) { // Only sum the even numbers\n            ans += num;\n        }\n    }\n    return ans;\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode CPP dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "int f_10(const std::vector<int>& numbers)\n{\n    int ans = 0;\n    for (auto num : numbers) {\n        if ((num & 1) == 0) { // Only sum the even numbers\n            ans += num;\n        }\n    }\n    return ans;\n}\n\n次のCPPコードの自然言語による簡潔な説明（ドックストリング）を日本語で500文字以内で提供してください。", "ko": "int f_10(const std::vector<int>& numbers)\n{\n    int ans = 0;\n    for (auto num : numbers) {\n        if ((num & 1) == 0) { // Only sum the even numbers\n            ans += num;\n        }\n    }\n    return ans;\n}\n\n다음 CPP 코드의 동작을 최대 500자 이내의 간결한 자연어 설명(도크스트링)으로 한국어로 제공하세요.", "ml": "int f_10(const std::vector<int>& numbers)\n{\n    int ans = 0;\n    for (auto num : numbers) {\n        if ((num & 1) == 0) { // Only sum the even numbers\n            ans += num;\n        }\n    }\n    return ans;\n}\n\nCPP കോഡിന്റെ സംഗ്രഹമായ പ്രകൃതിദത്ത ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) പരമാവധി 500 അക്ഷരങ്ങൾ ഉപയോഗിച്ച് മലയാളത്തിൽ നൽകുക.", "fa": "int f_10(const std::vector<int>& numbers)\n{\n    int ans = 0;\n    for (auto num : numbers) {\n        if ((num & 1) == 0) { // Only sum the even numbers\n            ans += num;\n        }\n    }\n    return ans;\n}\n\nیک توضیح مختصر به زبان طبیعی (docstring) از کد CPP به زبان فارسی ارائه دهید که حداکثر ۵۰۰ کاراکتر باشد."}, "level": "", "test": "int main() {\n    std::vector<int> sample1 = {1, 4, 3, 2, 5};\n    std::vector<int> sample2 = {2, 2, 0, 0};\n    std::vector<int> sample3 = {7, 11, 19}; // Additional test with no even numbers\n    std::vector<int> sample4 = {12, 14, 16, 18, 20}; // Additional test with all even numbers\n\n    assert(f_10(sample1) == 6);\n    assert(f_10(sample2) == 4);\n    assert(f_10(sample3) == 0); // Should return 0 because there are no even numbers\n    assert(f_10(sample4) == 12 + 14 + 16 + 18 + 20);\n\n    // std::cout << \"All tests passed successfully.\\n\";\n\n    return 0;\n}", "entry_point": "f_10", "signature": "int f_10(const std::vector<int>& numbers)", "docstring": {"en": "Calculate the sum of even numbers in a given array.\n\nParameters:\n- numbers (vector<int>): A vector of integers.\n\nReturns:\nint: The sum of even numbers in the input array.\n\nExamples:\n>>> f_10({1,4,3,2,5}, 5)\n6\n", "sq": "Llogarit shumën e numrave çift në një varg të dhënë.\n\nParametrat:\n- numbers (vector<int>): Një vektor i numrave të plotë.\n\nKthen:\nint: Shuma e numrave çift në vargun hyrës.\n\nShembuj:\n>>> f_10({1,4,3,2,5}, 5)\n6", "hy": "Հաշվել տրված զանգվածում զույգ թվերի գումարը։\n\nՊարամետրեր:\n- numbers (vector<int>): Ամբողջ թվերի վեկտոր։\n\nՎերադարձնում է:\nint: Մուտքագրված զանգվածի զույգ թվերի գումարը։\n\nՕրինակներ:\n>>> f_10({1,4,3,2,5}, 5)\n6", "bn": "দেওয়া অ্যারেতে জোড় সংখ্যাগুলোর যোগফল গণনা করুন।\n\nপ্যারামিটারসমূহ:\n- numbers (vector<int>): পূর্ণসংখ্যার একটি ভেক্টর।\n\nফেরত দেয়:\nint: ইনপুট অ্যারেতে জোড় সংখ্যাগুলোর যোগফল।\n\nউদাহরণ:\n>>> f_10({1,4,3,2,5}, 5)\n6", "bg": "Изчисляване на сумата от четни числа в даден масив.\n\nПараметри:\n- numbers (vector<int>): Вектор от цели числа.\n\nВръща:\nint: Сумата от четните числа в входния масив.\n\nПримери:\n>>> f_10({1,4,3,2,5}, 5)\n6", "zh": "计算给定数组中偶数的和。\n\n参数：\n- numbers (vector<int>): 一个整数向量。\n\n返回：\nint: 输入数组中偶数的和。\n\n示例：\n>>> f_10({1,4,3,2,5}, 5)\n6", "fr": "Calculer la somme des nombres pairs dans un tableau donné.\n\nParamètres:\n- numbers (vector<int>): Un vecteur d'entiers.\n\nRenvoie:\nint: La somme des nombres pairs dans le tableau d'entrée.\n\nExemples:\n>>> f_10({1,4,3,2,5}, 5)\n6", "de": "Berechnen Sie die Summe der geraden Zahlen in einem gegebenen Array.\n\nParameter:\n- numbers (vector<int>): Ein Vektor von ganzen Zahlen.\n\nRückgabewert:\nint: Die Summe der geraden Zahlen im Eingabearray.\n\nBeispiele:\n>>> f_10({1,4,3,2,5}, 5)\n6", "ha": "Lissafa jimillar lambobin da suka zama lamba biyu a cikin jerin da aka bayar.\n\nMa'auni:\n- numbers (vector<int>): Wata vector na lambobi.\n\nDawowa:\nint: Jimillar lambobin da suka kasance ma'aurata a cikin jerin lambobin shigarwa.\n\nMisalai:\n>>> f_10({1,4,3,2,5}, 5)\n6", "hi": "दिए गए ऐरे में सम संख्या का योग गणना करें।\n\nपैरामीटर्स:\n- numbers (vector<int>): पूर्णांकों का एक वेक्टर।\n\nरिटर्न्स:\nint: इनपुट ऐरे में सम संख्याओं का योग।\n\nउदाहरण:\n>>> f_10({1,4,3,2,5}, 5)\n6", "hu": "Számítsa ki a páros számok összegét egy adott tömbben.\n\nParaméterek:\n- numbers (vector<int>): Egész számok vektora.\n\nVisszatérési érték:\nint: A bemeneti tömbben lévő páros számok összege.\n\nPéldák:\n>>> f_10({1,4,3,2,5}, 5)\n6", "es": "Calcular la suma de números pares en un arreglo dado.\n\nParámetros:\n- numbers (vector<int>): Un vector de enteros.\n\nDevuelve:\nint: La suma de los números pares en el arreglo de entrada.\n\nEjemplos:\n>>> f_10({1,4,3,2,5}, 5)\n6", "arb": "حساب مجموع الأعداد الزوجية في مصفوفة معينة.\n\nالمعطيات:\n- numbers (vector<int>): متجه من الأعداد الصحيحة.\n\nالقيم المعادة:\nint: مجموع الأعداد الزوجية في المصفوفة المدخلة.\n\nأمثلة:\n>>> f_10({1,4,3,2,5}, 5)\n6", "sw": "Hesabu jumla ya nambari za jozi katika safu iliyotolewa.\n\nVigezo:\n- numbers (vector<int>): Kundi la nambari za mzima.\n\nRudisha:\nint: Jumla ya nambari za jozi katika safu ya ingizo.\n\nMifano:\n>>> f_10({1,4,3,2,5}, 5)\n6", "tr": "Verilen bir dizideki çift sayıların toplamını hesaplayın.\n\nParametreler:\n- numbers (vector<int>): Bir tamsayı vektörü.\n\nDöndürülenler:\nint: Girdi dizisindeki çift sayıların toplamı.\n\nÖrnekler:\n>>> f_10({1,4,3,2,5}, 5)\n6", "vi": "Tính tổng các số chẵn trong một mảng cho trước.\n\nTham số:\n- numbers (vector<int>): Một vector các số nguyên.\n\nTrả về:\nint: Tổng các số chẵn trong mảng đầu vào.\n\nVí dụ:\n>>> f_10({1,4,3,2,5}, 5)\n6", "id": "Hitung jumlah bilangan genap dalam array yang diberikan.\n\nParameter:\n- numbers (vector<int>): Sebuah vektor dari bilangan bulat.\n\nMengembalikan:\nint: Jumlah dari bilangan genap dalam array masukan.\n\nContoh:\n>>> f_10({1,4,3,2,5}, 5)\n6", "ja": "与えられた配列内の偶数の合計を計算します。\n\n引数:\n- numbers (vector<int>): 整数のベクター。\n\n戻り値:\nint: 入力配列内の偶数の合計。\n\n例:\n>>> f_10({1,4,3,2,5}, 5)\n6", "ko": "주어진 배열에서 짝수의 합을 계산합니다.\n\n매개변수:\n- numbers (vector<int>): 정수 벡터.\n\n반환값:\nint: 입력 배열에서 짝수의 합.\n\n예제:\n>>> f_10({1,4,3,2,5}, 5)\n6", "ml": "നൽകിയിരിക്കുന്ന നിരയിലെ സമനിലകളുടെ മൊത്തം കണക്കുകൂട്ടുക.\n\nപാരാമീറ്ററുകൾ:\n- numbers (vector<int>): പൂർണ്ണസംഖ്യകളുടെ ഒരു വെക്റ്റർ.\n\nമടക്കം:\nint: ഇൻപുട്ട് അറേയിലുള്ള സമനിലകളുടെ മൊത്തം.\n\nഉദാഹരണങ്ങൾ:\n>>> f_10({1,4,3,2,5}, 5)\n6", "fa": "محاسبه مجموع اعداد زوج در یک آرایه داده شده.\n\nپارامترها:\n- numbers (vector<int>): یک وکتور از اعداد صحیح.\n\nبازگشت:\nint: مجموع اعداد زوج در آرایه ورودی.\n\nمثال‌ها:\n>>> f_10({1,4,3,2,5}, 5)\n6"}}
{"task_id": "CPP/11", "prompt": {"en": "#include <cassert>\n#include <cstdio>\n/**\n * Determines if two closed intervals intersect.\n *\n * @param a The lower bound of the first closed interval [a,b].\n * @param b The upper bound of the first closed interval [a,b].\n * @param c The lower bound of the second closed interval [c,d].\n * @param d The upper bound of the second closed interval [c,d].\n *\n * @return 1 if the intervals intersect, 0 otherwise.\n *\n * Examples:\n * f_11(1, 1, 1, 2) returns 1\n * f_11(3, 5, 2, 6) returns 1\n * f_11(3, 5, 4, 7) returns 1\n * f_11(3, 5, 6, 7) returns 0\n */\nint f_11(int a, int b, int c, int d)", "sq": "#include <cassert>\n#include <cstdio>\n/**\n * Përcakton nëse dy intervale të mbyllura ndërpriten.\n *\n * @param a Kufiri i poshtëm i intervalit të parë të mbyllur [a,b].\n * @param b Kufiri i sipërm i intervalit të parë të mbyllur [a,b].\n * @param c Kufiri i poshtëm i intervalit të dytë të mbyllur [c,d].\n * @param d Kufiri i sipërm i intervalit të dytë të mbyllur [c,d].\n *\n * @return 1 nëse intervalet ndërpriten, 0 përndryshe.\n *\n * Shembuj:\n * f_11(1, 1, 1, 2) returns 1\n * f_11(3, 5, 2, 6) returns 1\n * f_11(3, 5, 4, 7) returns 1\n * f_11(3, 5, 6, 7) returns 0\n */\nint f_11(int a, int b, int c, int d)", "hy": "#include <cassert>\n#include <cstdio>\n/**\n * Որոշում է՝ արդյոք երկու փակ միջակայքեր հատվում են։\n *\n * @param a Առաջին փակ միջակայքի [a,b] ստորին սահմանը։\n * @param b Առաջին փակ միջակայքի [a,b] վերին սահմանը։\n * @param c Երկրորդ փակ միջակայքի [c,d] ստորին սահմանը։\n * @param d Երկրորդ փակ միջակայքի [c,d] վերին սահմանը։\n *\n * @return 1 եթե միջակայքերը հատվում են, 0՝ հակառակ դեպքում։\n *\n * Օրինակներ:\n * f_11(1, 1, 1, 2) վերադարձնում է 1\n * f_11(3, 5, 2, 6) վերադարձնում է 1\n * f_11(3, 5, 4, 7) վերադարձնում է 1\n * f_11(3, 5, 6, 7) վերադարձնում է 0\n */\nint f_11(int a, int b, int c, int d)", "bn": "#include <cassert>\n#include <cstdio>\n/**\n * দুটি বন্ধ অন্তরাল একে অপরকে অতিক্রম করে কিনা তা নির্ধারণ করে।\n *\n * @param a প্রথম বন্ধ অন্তরাল [a,b] এর নিম্ন সীমা।\n * @param b প্রথম বন্ধ অন্তরাল [a,b] এর উপরের সীমা।\n * @param c দ্বিতীয় বন্ধ অন্তরাল [c,d] এর নিম্ন সীমা।\n * @param d দ্বিতীয় বন্ধ অন্তরাল [c,d] এর উপরের সীমা।\n *\n * @return অন্তরালগুলি অতিক্রম করলে 1, অন্যথায় 0।\n *\n * উদাহরণ:\n * f_11(1, 1, 1, 2) 1 প্রদান করে\n * f_11(3, 5, 2, 6) 1 প্রদান করে\n * f_11(3, 5, 4, 7) 1 প্রদান করে\n * f_11(3, 5, 6, 7) 0 প্রদান করে\n */\nint f_11(int a, int b, int c, int d)", "bg": "#include <cassert>\n#include <cstdio>\n/**\n * Определя дали два затворени интервала се пресичат.\n *\n * @param a Долна граница на първия затворен интервал [a,b].\n * @param b Горна граница на първия затворен интервал [a,b].\n * @param c Долна граница на втория затворен интервал [c,d].\n * @param d Горна граница на втория затворен интервал [c,d].\n *\n * @return 1 ако интервалите се пресичат, 0 в противен случай.\n *\n * Примери:\n * f_11(1, 1, 1, 2) връща 1\n * f_11(3, 5, 2, 6) връща 1\n * f_11(3, 5, 4, 7) връща 1\n * f_11(3, 5, 6, 7) връща 0\n */\nint f_11(int a, int b, int c, int d)", "zh": "#include <cassert>\n#include <cstdio>\n/**\n * 判断两个闭区间是否相交。\n *\n * @param a 第一个闭区间 [a,b] 的下界。\n * @param b 第一个闭区间 [a,b] 的上界。\n * @param c 第二个闭区间 [c,d] 的下界。\n * @param d 第二个闭区间 [c,d] 的上界。\n *\n * @return 如果区间相交返回 1，否则返回 0。\n *\n * 示例:\n * f_11(1, 1, 1, 2) returns 1\n * f_11(3, 5, 2, 6) returns 1\n * f_11(3, 5, 4, 7) returns 1\n * f_11(3, 5, 6, 7) returns 0\n */\nint f_11(int a, int b, int c, int d)", "fr": "#include <cassert>\n#include <cstdio>\n/**\n * Détermine si deux intervalles fermés s'intersectent.\n *\n * @param a La borne inférieure du premier intervalle fermé [a,b].\n * @param b La borne supérieure du premier intervalle fermé [a,b].\n * @param c La borne inférieure du second intervalle fermé [c,d].\n * @param d La borne supérieure du second intervalle fermé [c,d].\n *\n * @return 1 si les intervalles s'intersectent, 0 sinon.\n *\n * Exemples :\n * f_11(1, 1, 1, 2) returns 1\n * f_11(3, 5, 2, 6) returns 1\n * f_11(3, 5, 4, 7) returns 1\n * f_11(3, 5, 6, 7) returns 0\n */\nint f_11(int a, int b, int c, int d)", "de": "#include <cassert>\n#include <cstdio>\n/**\n * Bestimmt, ob zwei abgeschlossene Intervalle sich überschneiden.\n *\n * @param a Die untere Grenze des ersten abgeschlossenen Intervalls [a,b].\n * @param b Die obere Grenze des ersten abgeschlossenen Intervalls [a,b].\n * @param c Die untere Grenze des zweiten abgeschlossenen Intervalls [c,d].\n * @param d Die obere Grenze des zweiten abgeschlossenen Intervalls [c,d].\n *\n * @return 1, wenn die Intervalle sich überschneiden, 0 andernfalls.\n *\n * Beispiele:\n * f_11(1, 1, 1, 2) gibt 1 zurück\n * f_11(3, 5, 2, 6) gibt 1 zurück\n * f_11(3, 5, 4, 7) gibt 1 zurück\n * f_11(3, 5, 6, 7) gibt 0 zurück\n */\nint f_11(int a, int b, int c, int d)", "ha": "#include <cassert>\n#include <cstdio>\n/**\n * Yana tantance ko wasu zangon rufe guda biyu suna haduwa.\n *\n * @param a Ƙananan iyaka na zangon rufe na farko [a,b].\n * @param b Babban iyaka na zangon rufe na farko [a,b].\n * @param c Ƙananan iyaka na zangon rufe na biyu [c,d].\n * @param d Babban iyaka na zangon rufe na biyu [c,d].\n *\n * @return 1 idan zangon suna haduwa, 0 in ba haka ba.\n *\n * Misalai:\n * f_11(1, 1, 1, 2) returns 1\n * f_11(3, 5, 2, 6) returns 1\n * f_11(3, 5, 4, 7) returns 1\n * f_11(3, 5, 6, 7) returns 0\n */\nint f_11(int a, int b, int c, int d)", "hi": "#include <cassert>\n#include <cstdio>\n/**\n * यह निर्धारित करता है कि दो बंद अंतराल एक-दूसरे को काटते हैं या नहीं।\n *\n * @param a पहले बंद अंतराल [a,b] की निचली सीमा।\n * @param b पहले बंद अंतराल [a,b] की ऊपरी सीमा।\n * @param c दूसरे बंद अंतराल [c,d] की निचली सीमा।\n * @param d दूसरे बंद अंतराल [c,d] की ऊपरी सीमा।\n *\n * @return 1 यदि अंतराल एक-दूसरे को काटते हैं, अन्यथा 0।\n *\n * उदाहरण:\n * f_11(1, 1, 1, 2) returns 1\n * f_11(3, 5, 2, 6) returns 1\n * f_11(3, 5, 4, 7) returns 1\n * f_11(3, 5, 6, 7) returns 0\n */\nint f_11(int a, int b, int c, int d)", "hu": "#include <cassert>\n#include <cstdio>\n/**\n * Meghatározza, hogy két zárt intervallum metszi-e egymást.\n *\n * @param a Az első zárt intervallum alsó határa [a,b].\n * @param b Az első zárt intervallum felső határa [a,b].\n * @param c A második zárt intervallum alsó határa [c,d].\n * @param d A második zárt intervallum felső határa [c,d].\n *\n * @return 1, ha az intervallumok metszik egymást, különben 0.\n *\n * Példák:\n * f_11(1, 1, 1, 2) visszaadja 1\n * f_11(3, 5, 2, 6) visszaadja 1\n * f_11(3, 5, 4, 7) visszaadja 1\n * f_11(3, 5, 6, 7) visszaadja 0\n */\nint f_11(int a, int b, int c, int d)", "es": "#include <cassert>\n#include <cstdio>\n/**\n * Determina si dos intervalos cerrados se intersectan.\n *\n * @param a El límite inferior del primer intervalo cerrado [a,b].\n * @param b El límite superior del primer intervalo cerrado [a,b].\n * @param c El límite inferior del segundo intervalo cerrado [c,d].\n * @param d El límite superior del segundo intervalo cerrado [c,d].\n *\n * @return 1 si los intervalos se intersectan, 0 en caso contrario.\n *\n * Ejemplos:\n * f_11(1, 1, 1, 2) returns 1\n * f_11(3, 5, 2, 6) returns 1\n * f_11(3, 5, 4, 7) returns 1\n * f_11(3, 5, 6, 7) returns 0\n */\nint f_11(int a, int b, int c, int d)", "arb": "#include <cassert>\n#include <cstdio>\n/**\n * يحدد ما إذا كان هناك تقاطع بين فترتين مغلقتين.\n *\n * @param a الحد الأدنى للفترة المغلقة الأولى [a,b].\n * @param b الحد الأعلى للفترة المغلقة الأولى [a,b].\n * @param c الحد الأدنى للفترة المغلقة الثانية [c,d].\n * @param d الحد الأعلى للفترة المغلقة الثانية [c,d].\n *\n * @return 1 إذا كانت الفترات تتقاطع، 0 خلاف ذلك.\n *\n * أمثلة:\n * f_11(1, 1, 1, 2) returns 1\n * f_11(3, 5, 2, 6) returns 1\n * f_11(3, 5, 4, 7) returns 1\n * f_11(3, 5, 6, 7) returns 0\n */\nint f_11(int a, int b, int c, int d)", "sw": "#include <cassert>\n#include <cstdio>\n/**\n * Huamua kama vipindi viwili vilivyofungwa vinaingiliana.\n *\n * @param a Kikomo cha chini cha kipindi cha kwanza kilichofungwa [a,b].\n * @param b Kikomo cha juu cha kipindi cha kwanza kilichofungwa [a,b].\n * @param c Kikomo cha chini cha kipindi cha pili kilichofungwa [c,d].\n * @param d Kikomo cha juu cha kipindi cha pili kilichofungwa [c,d].\n *\n * @return 1 ikiwa vipindi vinaingiliana, 0 vinginevyo.\n *\n * Mifano:\n * f_11(1, 1, 1, 2) inarudisha 1\n * f_11(3, 5, 2, 6) inarudisha 1\n * f_11(3, 5, 4, 7) inarudisha 1\n * f_11(3, 5, 6, 7) inarudisha 0\n */\nint f_11(int a, int b, int c, int d)", "tr": "#include <cassert>\n#include <cstdio>\n/**\n * İki kapalı aralığın kesişip kesişmediğini belirler.\n *\n * @param a İlk kapalı aralığın alt sınırı [a,b].\n * @param b İlk kapalı aralığın üst sınırı [a,b].\n * @param c İkinci kapalı aralığın alt sınırı [c,d].\n * @param d İkinci kapalı aralığın üst sınırı [c,d].\n *\n * @return Aralıklar kesişiyorsa 1, aksi takdirde 0.\n *\n * Örnekler:\n * f_11(1, 1, 1, 2) 1 döndürür\n * f_11(3, 5, 2, 6) 1 döndürür\n * f_11(3, 5, 4, 7) 1 döndürür\n * f_11(3, 5, 6, 7) 0 döndürür\n */\nint f_11(int a, int b, int c, int d)", "vi": "#include <cassert>\n#include <cstdio>\n/**\n * Xác định xem hai khoảng đóng có giao nhau hay không.\n *\n * @param a Giới hạn dưới của khoảng đóng thứ nhất [a,b].\n * @param b Giới hạn trên của khoảng đóng thứ nhất [a,b].\n * @param c Giới hạn dưới của khoảng đóng thứ hai [c,d].\n * @param d Giới hạn trên của khoảng đóng thứ hai [c,d].\n *\n * @return 1 nếu các khoảng giao nhau, 0 nếu không.\n *\n * Ví dụ:\n * f_11(1, 1, 1, 2) trả về 1\n * f_11(3, 5, 2, 6) trả về 1\n * f_11(3, 5, 4, 7) trả về 1\n * f_11(3, 5, 6, 7) trả về 0\n */\nint f_11(int a, int b, int c, int d)", "id": "#include <cassert>\n#include <cstdio>\n/**\n * Menentukan apakah dua interval tertutup saling berpotongan.\n *\n * @param a Batas bawah dari interval tertutup pertama [a,b].\n * @param b Batas atas dari interval tertutup pertama [a,b].\n * @param c Batas bawah dari interval tertutup kedua [c,d].\n * @param d Batas atas dari interval tertutup kedua [c,d].\n *\n * @return 1 jika interval berpotongan, 0 jika tidak.\n *\n * Contoh:\n * f_11(1, 1, 1, 2) mengembalikan 1\n * f_11(3, 5, 2, 6) mengembalikan 1\n * f_11(3, 5, 4, 7) mengembalikan 1\n * f_11(3, 5, 6, 7) mengembalikan 0\n */\nint f_11(int a, int b, int c, int d)", "ja": "#include <cassert>\n#include <cstdio>\n/**\n * 2つの閉区間が交差するかどうかを判断します。\n *\n * @param a 最初の閉区間 [a,b] の下限。\n * @param b 最初の閉区間 [a,b] の上限。\n * @param c 2番目の閉区間 [c,d] の下限。\n * @param d 2番目の閉区間 [c,d] の上限。\n *\n * @return 区間が交差する場合は1、そうでない場合は0を返します。\n *\n * 例:\n * f_11(1, 1, 1, 2) は1を返します\n * f_11(3, 5, 2, 6) は1を返します\n * f_11(3, 5, 4, 7) は1を返します\n * f_11(3, 5, 6, 7) は0を返します\n */\nint f_11(int a, int b, int c, int d)", "ko": "#include <cassert>\n#include <cstdio>\n/**\n * 두 닫힌 구간이 교차하는지 여부를 결정합니다.\n *\n * @param a 첫 번째 닫힌 구간 [a,b]의 하한.\n * @param b 첫 번째 닫힌 구간 [a,b]의 상한.\n * @param c 두 번째 닫힌 구간 [c,d]의 하한.\n * @param d 두 번째 닫힌 구간 [c,d]의 상한.\n *\n * @return 구간이 교차하면 1을 반환하고, 그렇지 않으면 0을 반환합니다.\n *\n * 예시:\n * f_11(1, 1, 1, 2) returns 1\n * f_11(3, 5, 2, 6) returns 1\n * f_11(3, 5, 4, 7) returns 1\n * f_11(3, 5, 6, 7) returns 0\n */\nint f_11(int a, int b, int c, int d)", "ml": "#include <cassert>\n#include <cstdio>\n/**\n * രണ്ട് അടച്ച ഇടവേളകൾ തമ്മിൽ മുറിച്ചുകടക്കുന്നതാണോ എന്ന് നിർണ്ണയിക്കുന്നു.\n *\n * @param a ആദ്യത്തെ അടച്ച ഇടവേളയുടെ താഴത്തെ പരിധി [a,b].\n * @param b ആദ്യത്തെ അടച്ച ഇടവേളയുടെ മുകളിലെ പരിധി [a,b].\n * @param c രണ്ടാമത്തെ അടച്ച ഇടവേളയുടെ താഴത്തെ പരിധി [c,d].\n * @param d രണ്ടാമത്തെ അടച്ച ഇടവേളയുടെ മുകളിലെ പരിധി [c,d].\n *\n * @return ഇടവേളകൾ മുറിച്ചുകടക്കുകയാണെങ്കിൽ 1, അല്ലെങ്കിൽ 0.\n *\n * ഉദാഹരണങ്ങൾ:\n * f_11(1, 1, 1, 2) 1 തിരികെ നൽകുന്നു\n * f_11(3, 5, 2, 6) 1 തിരികെ നൽകുന്നു\n * f_11(3, 5, 4, 7) 1 തിരികെ നൽകുന്നു\n * f_11(3, 5, 6, 7) 0 തിരികെ നൽകുന്നു\n */\nint f_11(int a, int b, int c, int d)", "fa": "#include <cassert>\n#include <cstdio>\n/**\n * تعیین می‌کند که آیا دو بازه بسته با هم تلاقی دارند یا خیر.\n *\n * @param a حد پایین اولین بازه بسته [a,b].\n * @param b حد بالای اولین بازه بسته [a,b].\n * @param c حد پایین دومین بازه بسته [c,d].\n * @param d حد بالای دومین بازه بسته [c,d].\n *\n * @return 1 اگر بازه‌ها تلاقی دارند، در غیر این صورت 0.\n *\n * مثال‌ها:\n * f_11(1, 1, 1, 2) returns 1\n * f_11(3, 5, 2, 6) returns 1\n * f_11(3, 5, 4, 7) returns 1\n * f_11(3, 5, 6, 7) returns 0\n */\nint f_11(int a, int b, int c, int d)"}, "canonical_solution": "{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}", "instruction": {"en": "int f_11(int a, int b, int c, int d)\n{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.", "sq": "int f_11(int a, int b, int c, int d)\n{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit CPP në shqip duke përdorur maksimumi 500 karaktere.", "hy": "int f_11(int a, int b, int c, int d)\n{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}\n\nՏվյալ CPP կոդի համար տրամադրեք հակիրճ բնութագիր (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "int f_11(int a, int b, int c, int d)\n{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}\n\nসিপিপি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।", "bg": "int f_11(int a, int b, int c, int d)\n{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}\n\nПредоставете кратко описание на CPP кода на естествен език (docstring) на български, използвайки най-много 500 знака.", "zh": "int f_11(int a, int b, int c, int d)\n{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}\n\n将以下CPP代码的自然语言描述（文档字符串）翻译成中文，限制在500个字符以内。", "fr": "int f_11(int a, int b, int c, int d)\n{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}\n\nFournissez une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.", "de": "int f_11(int a, int b, int c, int d)\n{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "int f_11(int a, int b, int c, int d)\n{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}\n\nBa da takaitaccen bayanin yanayi (docstring) na lambar CPP a cikin Hausa ta amfani da haruffa 500 kacal.", "hi": "int f_11(int a, int b, int c, int d)\n{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}\n\nसीपीपी कोड का संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रींग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "int f_11(int a, int b, int c, int d)\n{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a CPP kódhoz magyarul, legfeljebb 500 karakterben.", "es": "int f_11(int a, int b, int c, int d)\n{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando como máximo 500 caracteres.", "arb": "int f_11(int a, int b, int c, int d)\n{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة CPP باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "int f_11(int a, int b, int c, int d)\n{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "int f_11(int a, int b, int c, int d)\n{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}\n\nAşağıdaki CPP kodunun işlevini açıklayan en fazla 500 karakterlik özlü bir doğal dil açıklaması (docstring) sağlayın.", "vi": "int f_11(int a, int b, int c, int d)\n{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự.", "id": "int f_11(int a, int b, int c, int d)\n{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode CPP dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "int f_11(int a, int b, int c, int d)\n{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}\n\n以下のCPPコードの自然言語による簡潔な説明（ドックストリング）を日本語で500文字以内で提供してください。", "ko": "int f_11(int a, int b, int c, int d)\n{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}\n\n다음 CPP 코드의 동작을 간결하게 설명하는 자연어 설명(docstring)을 최대 500자 이내로 한국어로 제공하세요.", "ml": "int f_11(int a, int b, int c, int d)\n{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}\n\nCPP കോഡ് സംബന്ധിച്ച സംക്ഷിപ്തമായ ഒരു സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) പരമാവധി 500 അക്ഷരങ്ങൾ ഉപയോഗിച്ച് മലയാളത്തിൽ നൽകുക.", "fa": "int f_11(int a, int b, int c, int d)\n{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}\n\nتوضیح مختصر و طبیعی (docstring) از کد CPP به زبان فارسی ارائه دهید که حداکثر ۵۰۰ کاراکتر باشد."}, "level": "", "test": "int main() {\n    assert(f_11(1, 1, 1, 2) == 1);\n    assert(f_11(3, 5, 2, 6) == 1);\n    assert(f_11(3, 5, 4, 7) == 1);\n    assert(f_11(3, 5, 6, 7) == 0);\n    // Additional test cases\n    assert(f_11(0, 0, 0, 0) == 1);\n    assert(f_11(1, 3, 2, 4) == 1);\n    assert(f_11(1, 3, 4, 6) == 0);\n    assert(f_11(10, 20, 20, 30) == 1);\n    assert(f_11(10, 20, 21, 30) == 0);\n    \n    // printf(\"All tests passed.\\n\");\n    return 0;\n}", "entry_point": "f_11", "signature": "int f_11(int a, int b, int c, int d)", "docstring": {"en": "Determines if two closed intervals intersect.\n\n@param a The lower bound of the first closed interval [a,b].\n@param b The upper bound of the first closed interval [a,b].\n@param c The lower bound of the second closed interval [c,d].\n@param d The upper bound of the second closed interval [c,d].\n\n@return 1 if the intervals intersect, 0 otherwise.\n\nExamples:\nf_11(1, 1, 1, 2) returns 1\nf_11(3, 5, 2, 6) returns 1\nf_11(3, 5, 4, 7) returns 1\nf_11(3, 5, 6, 7) returns 0\n", "sq": "Determinon nëse dy intervale të mbyllura ndërpriten.\n\n@param a Kufiri i poshtëm i intervalit të parë të mbyllur [a,b].\n@param b Kufiri i sipërm i intervalit të parë të mbyllur [a,b].\n@param c Kufiri i poshtëm i intervalit të dytë të mbyllur [c,d].\n@param d Kufiri i sipërm i intervalit të dytë të mbyllur [c,d].\n\n@return 1 nëse intervalet ndërpriten, 0 përndryshe.\n\nShembuj:\nf_11(1, 1, 1, 2) kthen 1\nf_11(3, 5, 2, 6) kthen 1\nf_11(3, 5, 4, 7) kthen 1\nf_11(3, 5, 6, 7) kthen 0", "hy": "Որոշում է՝ արդյոք երկու փակ միջակայքերը հատվում են։\n\n@param a Առաջին փակ միջակայքի ստորին սահմանը [a,b]։\n@param b Առաջին փակ միջակայքի վերին սահմանը [a,b]։\n@param c Երկրորդ փակ միջակայքի ստորին սահմանը [c,d]։\n@param d Երկրորդ փակ միջակայքի վերին սահմանը [c,d]։\n\n@return 1՝ եթե միջակայքերը հատվում են, 0՝ հակառակ դեպքում։\n\nՕրինակներ:\nf_11(1, 1, 1, 2) վերադարձնում է 1\nf_11(3, 5, 2, 6) վերադարձնում է 1\nf_11(3, 5, 4, 7) վերադարձնում է 1\nf_11(3, 5, 6, 7) վերադարձնում է 0", "bn": "দুটি বন্ধ ইন্টারভাল পরস্পরকে অতিক্রম করে কিনা তা নির্ধারণ করে।\n\n@param a প্রথম বন্ধ ইন্টারভালের [a,b] নিম্ন সীমা।\n@param b প্রথম বন্ধ ইন্টারভালের [a,b] উপরের সীমা।\n@param c দ্বিতীয় বন্ধ ইন্টারভালের [c,d] নিম্ন সীমা।\n@param d দ্বিতীয় বন্ধ ইন্টারভালের [c,d] উপরের সীমা।\n\n@return 1 যদি ইন্টারভালগুলি ছেদ করে, অন্যথায় 0।\n\nউদাহরণ:\nf_11(1, 1, 1, 2) returns 1\nf_11(3, 5, 2, 6) returns 1\nf_11(3, 5, 4, 7) returns 1\nf_11(3, 5, 6, 7) returns 0", "bg": "Определя дали два затворени интервала се пресичат.\n\n@param a Долна граница на първия затворен интервал [a,b].\n@param b Горна граница на първия затворен интервал [a,b].\n@param c Долна граница на втория затворен интервал [c,d].\n@param d Горна граница на втория затворен интервал [c,d].\n\n@return 1 ако интервалите се пресичат, 0 в противен случай.\n\nПримери:\nf_11(1, 1, 1, 2) връща 1\nf_11(3, 5, 2, 6) връща 1\nf_11(3, 5, 4, 7) връща 1\nf_11(3, 5, 6, 7) връща 0", "zh": "确定两个闭区间是否相交。\n\n@param a 第一个闭区间 [a,b] 的下界。\n@param b 第一个闭区间 [a,b] 的上界。\n@param c 第二个闭区间 [c,d] 的下界。\n@param d 第二个闭区间 [c,d] 的上界。\n\n@return 如果区间相交返回 1，否则返回 0。\n\n示例：\nf_11(1, 1, 1, 2) 返回 1\nf_11(3, 5, 2, 6) 返回 1\nf_11(3, 5, 4, 7) 返回 1\nf_11(3, 5, 6, 7) 返回 0", "fr": "Détermine si deux intervalles fermés s'intersectent.\n\n@param a La borne inférieure du premier intervalle fermé [a,b].\n@param b La borne supérieure du premier intervalle fermé [a,b].\n@param c La borne inférieure du second intervalle fermé [c,d].\n@param d La borne supérieure du second intervalle fermé [c,d].\n\n@return 1 si les intervalles s'intersectent, 0 sinon.\n\nExemples:\nf_11(1, 1, 1, 2) retourne 1\nf_11(3, 5, 2, 6) retourne 1\nf_11(3, 5, 4, 7) retourne 1\nf_11(3, 5, 6, 7) retourne 0", "de": "Bestimmt, ob zwei abgeschlossene Intervalle sich überschneiden.\n\n@param a Die untere Grenze des ersten abgeschlossenen Intervalls [a,b].\n@param b Die obere Grenze des ersten abgeschlossenen Intervalls [a,b].\n@param c Die untere Grenze des zweiten abgeschlossenen Intervalls [c,d].\n@param d Die obere Grenze des zweiten abgeschlossenen Intervalls [c,d].\n\n@return 1, wenn sich die Intervalle überschneiden, 0 andernfalls.\n\nBeispiele:\nf_11(1, 1, 1, 2) gibt 1 zurück\nf_11(3, 5, 2, 6) gibt 1 zurück\nf_11(3, 5, 4, 7) gibt 1 zurück\nf_11(3, 5, 6, 7) gibt 0 zurück", "ha": "Yana tantance idan tazara biyu masu rufe suna hade.\n\n@param a Ƙananan iyaka na farkon rufaffiyar tazara [a,b].\n@param b Babban iyaka na farkon rufaffiyar tazara [a,b].\n@param c Ƙananan iyaka na na biyun rufaffiyar tazara [c,d].\n@param d Babban iyaka na na biyun rufaffiyar tazara [c,d].\n\n@return 1 idan tazarorin sun haɗu, 0 in ba haka ba.\n\nMisalai:\nf_11(1, 1, 1, 2) returns 1\nf_11(3, 5, 2, 6) returns 1\nf_11(3, 5, 4, 7) returns 1\nf_11(3, 5, 6, 7) returns 0", "hi": "दो बंद अंतरालों के प्रतिच्छेदन की जाँच करता है।\n\n@param a पहले बंद अंतराल [a,b] की निचली सीमा।\n@param b पहले बंद अंतराल [a,b] की ऊपरी सीमा।\n@param c दूसरे बंद अंतराल [c,d] की निचली सीमा।\n@param d दूसरे बंद अंतराल [c,d] की ऊपरी सीमा।\n\n@return 1 यदि अंतराल प्रतिच्छेदित होते हैं, अन्यथा 0।\n\nउदाहरण:\nf_11(1, 1, 1, 2) returns 1\nf_11(3, 5, 2, 6) returns 1\nf_11(3, 5, 4, 7) returns 1\nf_11(3, 5, 6, 7) returns 0", "hu": "Meghatározza, hogy két zárt intervallum metszi-e egymást.\n\n@param a Az első zárt intervallum [a,b] alsó határa.\n@param b Az első zárt intervallum [a,b] felső határa.\n@param c A második zárt intervallum [c,d] alsó határa.\n@param d A második zárt intervallum [c,d] felső határa.\n\n@return 1, ha az intervallumok metszik egymást, különben 0.\n\nPéldák:\nf_11(1, 1, 1, 2) visszaadja 1\nf_11(3, 5, 2, 6) visszaadja 1\nf_11(3, 5, 4, 7) visszaadja 1\nf_11(3, 5, 6, 7) visszaadja 0", "es": "Determina si dos intervalos cerrados se intersectan.\n\n@param a El límite inferior del primer intervalo cerrado [a,b].\n@param b El límite superior del primer intervalo cerrado [a,b].\n@param c El límite inferior del segundo intervalo cerrado [c,d].\n@param d El límite superior del segundo intervalo cerrado [c,d].\n\n@return 1 si los intervalos se intersectan, 0 en caso contrario.\n\nEjemplos:\nf_11(1, 1, 1, 2) returns 1\nf_11(3, 5, 2, 6) returns 1\nf_11(3, 5, 4, 7) returns 1\nf_11(3, 5, 6, 7) returns 0", "arb": "يحدد ما إذا كان هناك تقاطع بين فترتين مغلقتين.\n\n@param a الحد الأدنى للفاصل المغلق الأول [a,b].\n@param b الحد الأقصى للفاصل المغلق الأول [a,b].\n@param c الحد الأدنى للفاصل المغلق الثاني [c,d].\n@param d الحد الأقصى للفاصل المغلق الثاني [c,d].\n\n@return 1 إذا كانت الفواصل تتقاطع، 0 خلاف ذلك.\n\nأمثلة:\nf_11(1, 1, 1, 2) returns 1\nf_11(3, 5, 2, 6) returns 1\nf_11(3, 5, 4, 7) returns 1\nf_11(3, 5, 6, 7) returns 0", "sw": "Huamua kama vipindi viwili vilivyofungwa vinaingiliana.\n\n@param a Chini ya kikomo cha kwanza kilichofungwa [a,b].\n@param b Juu ya kikomo cha kwanza kilichofungwa [a,b].\n@param c Chini ya kikomo cha pili kilichofungwa [c,d].\n@param d Juu ya kikomo cha pili kilichofungwa [c,d].\n\n@return 1 ikiwa vipindi vinaingiliana, 0 vinginevyo.\n\nExamples:\nf_11(1, 1, 1, 2) returns 1\nf_11(3, 5, 2, 6) returns 1\nf_11(3, 5, 4, 7) returns 1\nf_11(3, 5, 6, 7) returns 0", "tr": "İki kapalı aralığın kesişip kesişmediğini belirler.\n\n@param a İlk kapalı aralığın [a,b] alt sınırı.\n@param b İlk kapalı aralığın [a,b] üst sınırı.\n@param c İkinci kapalı aralığın [c,d] alt sınırı.\n@param d İkinci kapalı aralığın [c,d] üst sınırı.\n\n@return Aralıklar kesişiyorsa 1, aksi takdirde 0.\n\nÖrnekler:\nf_11(1, 1, 1, 2) 1 döndürür\nf_11(3, 5, 2, 6) 1 döndürür\nf_11(3, 5, 4, 7) 1 döndürür\nf_11(3, 5, 6, 7) 0 döndürür", "vi": "Xác định xem hai khoảng đóng có giao nhau hay không.\n\n@param a Giới hạn dưới của khoảng đóng đầu tiên [a,b].\n@param b Giới hạn trên của khoảng đóng đầu tiên [a,b].\n@param c Giới hạn dưới của khoảng đóng thứ hai [c,d].\n@param d Giới hạn trên của khoảng đóng thứ hai [c,d].\n\n@return 1 nếu các khoảng giao nhau, 0 nếu không.\n\nVí dụ:\nf_11(1, 1, 1, 2) trả về 1\nf_11(3, 5, 2, 6) trả về 1\nf_11(3, 5, 4, 7) trả về 1\nf_11(3, 5, 6, 7) trả về 0", "id": "Menentukan apakah dua interval tertutup saling berpotongan.\n\n@param a Batas bawah dari interval tertutup pertama [a,b].\n@param b Batas atas dari interval tertutup pertama [a,b].\n@param c Batas bawah dari interval tertutup kedua [c,d].\n@param d Batas atas dari interval tertutup kedua [c,d].\n\n@return 1 jika interval berpotongan, 0 jika tidak.\n\nContoh:\nf_11(1, 1, 1, 2) mengembalikan 1\nf_11(3, 5, 2, 6) mengembalikan 1\nf_11(3, 5, 4, 7) mengembalikan 1\nf_11(3, 5, 6, 7) mengembalikan 0", "ja": "2つの閉区間が交差するかどうかを判断します。\n\n@param a 最初の閉区間 [a,b] の下限。\n@param b 最初の閉区間 [a,b] の上限。\n@param c 2番目の閉区間 [c,d] の下限。\n@param d 2番目の閉区間 [c,d] の上限。\n\n@return 区間が交差する場合は1、そうでない場合は0。\n\n例:\nf_11(1, 1, 1, 2) は1を返します\nf_11(3, 5, 2, 6) は1を返します\nf_11(3, 5, 4, 7) は1を返します\nf_11(3, 5, 6, 7) は0を返します", "ko": "두 닫힌 구간이 교차하는지 여부를 결정합니다.\n\n@param a 첫 번째 닫힌 구간 [a,b]의 하한.\n@param b 첫 번째 닫힌 구간 [a,b]의 상한.\n@param c 두 번째 닫힌 구간 [c,d]의 하한.\n@param d 두 번째 닫힌 구간 [c,d]의 상한.\n\n@return 구간이 교차하면 1, 그렇지 않으면 0.\n\n예시:\nf_11(1, 1, 1, 2) returns 1\nf_11(3, 5, 2, 6) returns 1\nf_11(3, 5, 4, 7) returns 1\nf_11(3, 5, 6, 7) returns 0", "ml": "രണ്ട് അടച്ച ഇടവേളകൾ തമ്മിൽ മുറിച്ചുകടക്കുന്നതാണോ എന്ന് നിർണ്ണയിക്കുന്നു.\n\n@param a ആദ്യ അടച്ച ഇടവേളയുടെ താഴത്തെ പരിധി [a,b].\n@param b ആദ്യ അടച്ച ഇടവേളയുടെ മുകളിലെ പരിധി [a,b].\n@param c രണ്ടാം അടച്ച ഇടവേളയുടെ താഴത്തെ പരിധി [c,d].\n@param d രണ്ടാം അടച്ച ഇടവേളയുടെ മുകളിലെ പരിധി [c,d].\n\n@return ഇടവേളകൾ തമ്മിൽ മുട്ടുകയാണെങ്കിൽ 1, അല്ലെങ്കിൽ 0.\n\nഉദാഹരണങ്ങൾ:\nf_11(1, 1, 1, 2) 1 തിരികെ നൽകുന്നു\nf_11(3, 5, 2, 6) 1 തിരികെ നൽകുന്നു\nf_11(3, 5, 4, 7) 1 തിരികെ നൽകുന്നു\nf_11(3, 5, 6, 7) 0 തിരികെ നൽകുന്നു", "fa": "تعیین می‌کند که آیا دو بازه بسته با هم تلاقی دارند یا خیر.\n\n@param a کران پایین بازه بسته اول [a,b].\n@param b کران بالا بازه بسته اول [a,b].\n@param c کران پایین بازه بسته دوم [c,d].\n@param d کران بالا بازه بسته دوم [c,d].\n\n@return 1 اگر بازه‌ها تداخل داشته باشند، در غیر این صورت 0.\n\nExamples:\nf_11(1, 1, 1, 2) returns 1\nf_11(3, 5, 2, 6) returns 1\nf_11(3, 5, 4, 7) returns 1\nf_11(3, 5, 6, 7) returns 0"}}
{"task_id": "CPP/12", "prompt": {"en": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n/**\n * You are given three integers a, b, c, where two of them are equal, and the\n * third is different from the other two. Your task is to find the value that\n * occurs exactly once.\n *\n * Examples:\n *   f_12(0, 0, 1) returns 1\n *   f_12(4, 3, 4) returns 3\n */\nint f_12(int a, int b, int c)", "sq": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n/**\n * Ju jepen tre numra të plotë a, b, c, ku dy prej tyre janë të barabartë, dhe i\n * treti është i ndryshëm nga dy të tjerët. Detyra juaj është të gjeni vlerën që\n * ndodh saktësisht një herë.\n *\n * Shembuj:\n *   f_12(0, 0, 1) kthen 1\n *   f_12(4, 3, 4) kthen 3\n */\nint f_12(int a, int b, int c)", "hy": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n/**\n * Ձեզ տրված են երեք ամբողջ թվեր a, b, c, որտեղ երկուսը հավասար են, և\n * երրորդը տարբերվում է մյուս երկուսից։ Ձեր խնդիրը գտնել այն արժեքը,\n * որը հանդիպում է միայն մեկ անգամ։\n *\n * Օրինակներ:\n *   f_12(0, 0, 1) վերադարձնում է 1\n *   f_12(4, 3, 4) վերադարձնում է 3\n */\nint f_12(int a, int b, int c)", "bn": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n/**\n * আপনাকে তিনটি পূর্ণসংখ্যা দেওয়া হয়েছে a, b, c, যেখানে এদের মধ্যে দুটি সমান, এবং\n * তৃতীয়টি অন্য দুটি থেকে আলাদা। আপনার কাজ হল সেই মানটি খুঁজে বের করা যা\n * ঠিক একবার ঘটে।\n *\n * উদাহরণ:\n *   f_12(0, 0, 1) 1 ফেরত দেয়\n *   f_12(4, 3, 4) 3 ফেরত দেয়\n */\nint f_12(int a, int b, int c)", "bg": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n/**\n * Дадени са ви три цели числа a, b, c, където две от тях са равни, а\n * третото е различно от другите две. Вашата задача е да намерите стойността,\n * която се среща точно веднъж.\n *\n * Примери:\n *   f_12(0, 0, 1) връща 1\n *   f_12(4, 3, 4) връща 3\n */\nint f_12(int a, int b, int c)", "zh": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n/**\n * 给定三个整数 a, b, c，其中两个相等，第三个与其他两个不同。\n * 你的任务是找到只出现一次的值。\n *\n * 示例:\n *   f_12(0, 0, 1) 返回 1\n *   f_12(4, 3, 4) 返回 3\n */\nint f_12(int a, int b, int c)", "fr": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n/**\n * On vous donne trois entiers a, b, c, où deux d'entre eux sont égaux, et le\n * troisième est différent des deux autres. Votre tâche est de trouver la valeur qui\n * apparaît exactement une fois.\n *\n * Exemples :\n *   f_12(0, 0, 1) returns 1\n *   f_12(4, 3, 4) returns 3\n */\nint f_12(int a, int b, int c)", "de": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n/**\n * Sie haben drei ganze Zahlen a, b, c, wobei zwei von ihnen gleich sind und die\n * dritte sich von den anderen beiden unterscheidet. Ihre Aufgabe ist es, den Wert zu finden,\n * der genau einmal vorkommt.\n *\n * Beispiele:\n *   f_12(0, 0, 1) gibt 1 zurück\n *   f_12(4, 3, 4) gibt 3 zurück\n */\nint f_12(int a, int b, int c)", "ha": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n/**\n * An ba ku lambobi guda uku a, b, c, inda biyu daga cikinsu suna daidai, \n * kuma na uku ya bambanta da sauran biyun. Aikin ku shine nemo ƙimar da \n * ta bayyana sau ɗaya kawai.\n *\n * Misalai:\n *   f_12(0, 0, 1) returns 1\n *   f_12(4, 3, 4) returns 3\n */\nint f_12(int a, int b, int c)", "hi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n/**\n * आपको तीन पूर्णांक a, b, c दिए गए हैं, जहाँ इनमें से दो समान हैं, और\n * तीसरा अन्य दो से भिन्न है। आपका कार्य उस मान को खोजना है जो\n * केवल एक बार आता है।\n *\n * उदाहरण:\n *   f_12(0, 0, 1) 1 लौटाता है\n *   f_12(4, 3, 4) 3 लौटाता है\n */\nint f_12(int a, int b, int c)", "hu": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n/**\n * Három egész számot kap, a, b, c, ahol kettő közülük egyenlő, és a\n * harmadik különbözik a másik kettőtől. Az Ön feladata megtalálni azt az értéket,\n * amely pontosan egyszer fordul elő.\n *\n * Példák:\n *   f_12(0, 0, 1) visszaadja 1\n *   f_12(4, 3, 4) visszaadja 3\n */\nint f_12(int a, int b, int c)", "es": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n/**\n * Se te dan tres enteros a, b, c, donde dos de ellos son iguales, y el\n * tercero es diferente de los otros dos. Tu tarea es encontrar el valor que\n * ocurre exactamente una vez.\n *\n * Ejemplos:\n *   f_12(0, 0, 1) returns 1\n *   f_12(4, 3, 4) returns 3\n */\nint f_12(int a, int b, int c)", "arb": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n/**\n * لديك ثلاثة أعداد صحيحة a, b, c، حيث أن اثنين منهما متساويان،\n * والثالث مختلف عن الآخرين. مهمتك هي إيجاد القيمة التي تظهر مرة واحدة فقط.\n *\n * أمثلة:\n *   f_12(0, 0, 1) returns 1\n *   f_12(4, 3, 4) returns 3\n */\nint f_12(int a, int b, int c)", "sw": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n/**\n * Umepewa nambari tatu za mzima a, b, c, ambapo mbili kati yao ni sawa, na\n * ya tatu ni tofauti na zile mbili nyingine. Kazi yako ni kupata thamani ambayo\n * inatokea mara moja tu.\n *\n * Mifano:\n *   f_12(0, 0, 1) inarudisha 1\n *   f_12(4, 3, 4) inarudisha 3\n */\nint f_12(int a, int b, int c)", "tr": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n/**\n * Üç tamsayı a, b, c verilir, bunlardan ikisi eşittir ve\n * üçüncüsü diğer ikisinden farklıdır. Göreviniz, tam olarak bir kez\n * geçen değeri bulmaktır.\n *\n * Örnekler:\n *   f_12(0, 0, 1) 1 döndürür\n *   f_12(4, 3, 4) 3 döndürür\n */\nint f_12(int a, int b, int c)", "vi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n/**\n * Bạn được cung cấp ba số nguyên a, b, c, trong đó hai số bằng nhau, và\n * số thứ ba khác với hai số còn lại. Nhiệm vụ của bạn là tìm giá trị xuất hiện\n * chính xác một lần.\n *\n * Ví dụ:\n *   f_12(0, 0, 1) trả về 1\n *   f_12(4, 3, 4) trả về 3\n */\nint f_12(int a, int b, int c)", "id": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n/**\n * Anda diberikan tiga bilangan bulat a, b, c, di mana dua di antaranya sama, dan\n * yang ketiga berbeda dari dua lainnya. Tugas Anda adalah menemukan nilai yang\n * muncul tepat sekali.\n *\n * Contoh:\n *   f_12(0, 0, 1) mengembalikan 1\n *   f_12(4, 3, 4) mengembalikan 3\n */\nint f_12(int a, int b, int c)", "ja": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n/**\n * あなたは3つの整数 a, b, c を与えられます。そのうち2つは等しく、残りの1つは他の2つと異なります。\n * あなたのタスクは、ちょうど1回だけ出現する値を見つけることです。\n *\n * 例:\n *   f_12(0, 0, 1) は 1 を返します\n *   f_12(4, 3, 4) は 3 を返します\n */\nint f_12(int a, int b, int c)", "ko": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n/**\n * 세 정수 a, b, c가 주어졌을 때, 그 중 두 개는 같고,\n * 나머지 하나는 다른 두 개와 다릅니다. 당신의 작업은\n * 정확히 한 번만 나타나는 값을 찾는 것입니다.\n *\n * 예시:\n *   f_12(0, 0, 1) returns 1\n *   f_12(4, 3, 4) returns 3\n */\nint f_12(int a, int b, int c)", "ml": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n/**\n * നിങ്ങൾക്ക് മൂന്നു പൂർണ്ണസംഖ്യകൾ a, b, c ലഭ്യമാണ്, ഇവയിൽ രണ്ടെണ്ണം തുല്യമാണ്, \n * മൂന്നാമത്തേത് മറ്റുള്ള രണ്ടെണ്ണത്തേക്കാൾ വ്യത്യസ്തമാണ്. \n * ഒരിക്കൽ മാത്രം സംഭവിക്കുന്ന മൂല്യം കണ്ടെത്തുക എന്നതാണ് നിങ്ങളുടെ ജോലി.\n *\n * ഉദാഹരണങ്ങൾ:\n *   f_12(0, 0, 1) 1 തിരിച്ചുനൽകുന്നു\n *   f_12(4, 3, 4) 3 തിരിച്ചുനൽകുന്നു\n */\nint f_12(int a, int b, int c)", "fa": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n/**\n * به شما سه عدد صحیح a، b، c داده شده است که دو تا از آنها برابر هستند و\n * سومی با دو تای دیگر متفاوت است. وظیفه شما این است که مقداری را پیدا کنید که\n * دقیقا یک بار ظاهر می‌شود.\n *\n * مثال‌ها:\n *   f_12(0, 0, 1) مقدار 1 را برمی‌گرداند\n *   f_12(4, 3, 4) مقدار 3 را برمی‌گرداند\n */\nint f_12(int a, int b, int c)"}, "canonical_solution": "{\n    if (a == b) {\n        return c;\n    } else if (a == c) {\n        return b;\n    } else {\n        return a;\n    }\n}", "instruction": {"en": "int f_12(int a, int b, int c)\n{\n    if (a == b) {\n        return c;\n    } else if (a == c) {\n        return b;\n    } else {\n        return a;\n    }\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.", "sq": "int f_12(int a, int b, int c)\n{\n    if (a == b) {\n        return c;\n    } else if (a == c) {\n        return b;\n    } else {\n        return a;\n    }\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit CPP në shqip duke përdorur maksimumi 500 karaktere.", "hy": "int f_12(int a, int b, int c)\n{\n    if (a == b) {\n        return c;\n    } else if (a == c) {\n        return b;\n    } else {\n        return a;\n    }\n}\n\nՏվեք CPP կոդի համառոտ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "int f_12(int a, int b, int c)\n{\n    if (a == b) {\n        return c;\n    } else if (a == c) {\n        return b;\n    } else {\n        return a;\n    }\n}\n\nসিপিপি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।", "bg": "int f_12(int a, int b, int c)\n{\n    if (a == b) {\n        return c;\n    } else if (a == c) {\n        return b;\n    } else {\n        return a;\n    }\n}\n\nПредоставете кратко описание на CPP кода на естествен език (docstring) на български, използвайки най-много 500 знака.", "zh": "int f_12(int a, int b, int c)\n{\n    if (a == b) {\n        return c;\n    } else if (a == c) {\n        return b;\n    } else {\n        return a;\n    }\n}\n\n请用不超过500个字符的中文，为以下CPP代码提供简明的自然语言描述（文档字符串）。", "fr": "int f_12(int a, int b, int c)\n{\n    if (a == b) {\n        return c;\n    } else if (a == c) {\n        return b;\n    } else {\n        return a;\n    }\n}\n\nFournissez une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.", "de": "int f_12(int a, int b, int c)\n{\n    if (a == b) {\n        return c;\n    } else if (a == c) {\n        return b;\n    } else {\n        return a;\n    }\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "int f_12(int a, int b, int c)\n{\n    if (a == b) {\n        return c;\n    } else if (a == c) {\n        return b;\n    } else {\n        return a;\n    }\n}\n\nBa da taƙaitaccen bayani a cikin harshen halitta (docstring) na lambar CPP a cikin Hausa ta amfani da haruffa 500 ko ƙasa da haka.", "hi": "int f_12(int a, int b, int c)\n{\n    if (a == b) {\n        return c;\n    } else if (a == c) {\n        return b;\n    } else {\n        return a;\n    }\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "int f_12(int a, int b, int c)\n{\n    if (a == b) {\n        return c;\n    } else if (a == c) {\n        return b;\n    } else {\n        return a;\n    }\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a CPP kódról magyarul, legfeljebb 500 karakterben.", "es": "int f_12(int a, int b, int c)\n{\n    if (a == b) {\n        return c;\n    } else if (a == c) {\n        return b;\n    } else {\n        return a;\n    }\n}\n\nProporciona una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando un máximo de 500 caracteres.", "arb": "int f_12(int a, int b, int c)\n{\n    if (a == b) {\n        return c;\n    } else if (a == c) {\n        return b;\n    } else {\n        return a;\n    }\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لشيفرة CPP باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.", "sw": "int f_12(int a, int b, int c)\n{\n    if (a == b) {\n        return c;\n    } else if (a == c) {\n        return b;\n    } else {\n        return a;\n    }\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "int f_12(int a, int b, int c)\n{\n    if (a == b) {\n        return c;\n    } else if (a == c) {\n        return b;\n    } else {\n        return a;\n    }\n}\n\nAşağıdaki CPP kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda Türkçe bir doğal dil açıklaması (docstring) sağlayın.", "vi": "int f_12(int a, int b, int c)\n{\n    if (a == b) {\n        return c;\n    } else if (a == c) {\n        return b;\n    } else {\n        return a;\n    }\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự.", "id": "int f_12(int a, int b, int c)\n{\n    if (a == b) {\n        return c;\n    } else if (a == c) {\n        return b;\n    } else {\n        return a;\n    }\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode CPP dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "int f_12(int a, int b, int c)\n{\n    if (a == b) {\n        return c;\n    } else if (a == c) {\n        return b;\n    } else {\n        return a;\n    }\n}\n\n以下のCPPコードの自然言語による簡潔な説明（ドックストリング）を日本語で500文字以内で提供してください。", "ko": "int f_12(int a, int b, int c)\n{\n    if (a == b) {\n        return c;\n    } else if (a == c) {\n        return b;\n    } else {\n        return a;\n    }\n}\n\n다음 CPP 코드에 대한 간결한 자연어 설명(도크스트링)을 최대 500자 이내로 한국어로 제공하세요.", "ml": "int f_12(int a, int b, int c)\n{\n    if (a == b) {\n        return c;\n    } else if (a == c) {\n        return b;\n    } else {\n        return a;\n    }\n}\n\nCPP കോഡ് ഉപയോഗിച്ച് 500 അക്ഷരങ്ങളിൽ കൂടുതൽ അല്ലാത്ത പ്രകൃതിദത്ത ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) മലയാളത്തിൽ നൽകുക.", "fa": "int f_12(int a, int b, int c)\n{\n    if (a == b) {\n        return c;\n    } else if (a == c) {\n        return b;\n    } else {\n        return a;\n    }\n}\n\nتوضیح مختصر و طبیعی (docstring) از کد CPP به زبان فارسی ارائه دهید که حداکثر ۵۰۰ کاراکتر باشد."}, "level": "", "test": "int main() {\n    assert(f_12(2, 7, 2) == 7);\n    assert(f_12(3, 2, 2) == 3);\n    assert(f_12(5, 5, 1) == 1);\n    assert(f_12(500000000, 3, 500000000) == 3);\n    assert(f_12(500000000, 500000000, 3) == 3);\n\n    \n    return 0;\n}", "entry_point": "f_12", "signature": "int f_12(int a, int b, int c)", "docstring": {"en": "You are given three integers a, b, c, where two of them are equal, and the third is different from the other two. Your task is to find the value that occurs exactly once.\n\nExamples:\n  f_12(0, 0, 1) returns 1\n  f_12(4, 3, 4) returns 3\n", "sq": "Ju jepen tre numra të plotë a, b, c, ku dy prej tyre janë të barabartë, dhe i treti është i ndryshëm nga dy të tjerët. Detyra juaj është të gjeni vlerën që ndodh saktësisht një herë.\n\nShembuj:\n  f_12(0, 0, 1) kthen 1\n  f_12(4, 3, 4) kthen 3", "hy": "Դուք տրված եք երեք ամբողջ թվերով՝ a, b, c, որտեղ երկուսը հավասար են, և երրորդը տարբերվում է մյուս երկուսից։ Ձեր խնդիրն է գտնել այն արժեքը, որը հանդիպում է ճիշտ մեկ անգամ։\n\nՕրինակներ:\n  f_12(0, 0, 1) վերադարձնում է 1\n  f_12(4, 3, 4) վերադարձնում է 3", "bn": "আপনাকে তিনটি পূর্ণসংখ্যা দেওয়া হয়েছে a, b, c, যেখানে তাদের মধ্যে দুটি সমান এবং তৃতীয়টি অন্য দুটি থেকে আলাদা। আপনার কাজ হল সেই মানটি খুঁজে বের করা যা ঠিক একবার ঘটে।\n\nউদাহরণ:\n  f_12(0, 0, 1) 1 ফেরত দেয়\n  f_12(4, 3, 4) 3 ফেরত দেয়", "bg": "Дадени са ви три цели числа a, b, c, където две от тях са равни, а третото е различно от другите две. Вашата задача е да намерите стойността, която се среща точно веднъж.\n\nПримери:\n  f_12(0, 0, 1) връща 1\n  f_12(4, 3, 4) връща 3", "zh": "你有三个整数 a, b, c，其中两个是相等的，第三个与其他两个不同。你的任务是找到那个只出现一次的值。\n\n示例：\n  f_12(0, 0, 1) 返回 1\n  f_12(4, 3, 4) 返回 3", "fr": "Vous disposez de trois entiers a, b, c, dont deux sont égaux, et le troisième est différent des deux autres. Votre tâche est de trouver la valeur qui apparaît exactement une fois.\n\nExemples :\n  f_12(0, 0, 1) renvoie 1\n  f_12(4, 3, 4) renvoie 3", "de": "Du hast drei ganze Zahlen a, b, c, wobei zwei von ihnen gleich sind und die dritte sich von den anderen beiden unterscheidet. Deine Aufgabe ist es, den Wert zu finden, der genau einmal vorkommt.\n\nBeispiele:\n  f_12(0, 0, 1) gibt 1 zurück\n  f_12(4, 3, 4) gibt 3 zurück", "ha": "An ba ku lambobi guda uku a, b, c, inda biyu daga cikinsu suna daidai, kuma na uku ya bambanta da sauran biyun. Aikin ku shi ne gano darajar da ta bayyana sau daya kawai.\n\nMisalai:\n  f_12(0, 0, 1) yana dawowa 1\n  f_12(4, 3, 4) yana dawowa 3", "hi": "आपको तीन पूर्णांक a, b, c दिए गए हैं, जिनमें से दो समान हैं, और तीसरा अन्य दो से भिन्न है। आपका कार्य उस मान को खोजना है जो केवल एक बार आता है।\n\nउदाहरण:\n  f_12(0, 0, 1) 1 लौटाता है\n  f_12(4, 3, 4) 3 लौटाता है", "hu": "Három egész számot kap, a, b, c, ahol kettő közülük egyenlő, és a harmadik különbözik a másik kettőtől. Az Ön feladata megtalálni azt az értéket, amely pontosan egyszer fordul elő.\n\nPéldák:\n  f_12(0, 0, 1) visszatér 1\n  f_12(4, 3, 4) visszatér 3", "es": "Se te dan tres enteros a, b, c, donde dos de ellos son iguales y el tercero es diferente de los otros dos. Tu tarea es encontrar el valor que ocurre exactamente una vez.\n\nEjemplos:\n  f_12(0, 0, 1) devuelve 1\n  f_12(4, 3, 4) devuelve 3", "arb": "أنت مُعطى ثلاثة أعداد صحيحة a، b، c، حيث يكون اثنان منها متساويين، والثالث مختلف عن الآخرين. مهمتك هي إيجاد القيمة التي تظهر مرة واحدة فقط.\n\nأمثلة:\n  f_12(0, 0, 1) returns 1\n  f_12(4, 3, 4) returns 3", "sw": "Unapewa nambari tatu za integer a, b, c, ambapo mbili kati ya hizo ni sawa, na ya tatu ni tofauti na hizo mbili. Kazi yako ni kupata thamani inayotokea mara moja tu.\n\nMifano:\n  f_12(0, 0, 1) inarejesha 1\n  f_12(4, 3, 4) inarejesha 3", "tr": "Üç tamsayı a, b, c verilir; bunlardan ikisi eşittir ve üçüncüsü diğer ikisinden farklıdır. Göreviniz, tam olarak bir kez geçen değeri bulmaktır.\n\nÖrnekler:\n  f_12(0, 0, 1) 1 döndürür\n  f_12(4, 3, 4) 3 döndürür", "vi": "Bạn được cung cấp ba số nguyên a, b, c, trong đó hai số bằng nhau, và số thứ ba khác với hai số còn lại. Nhiệm vụ của bạn là tìm giá trị xuất hiện đúng một lần.\n\nVí dụ:\n  f_12(0, 0, 1) trả về 1\n  f_12(4, 3, 4) trả về 3", "id": "Anda diberikan tiga bilangan bulat a, b, c, di mana dua di antaranya sama, dan yang ketiga berbeda dari dua lainnya. Tugas Anda adalah menemukan nilai yang muncul tepat sekali.\n\nContoh:\n  f_12(0, 0, 1) mengembalikan 1\n  f_12(4, 3, 4) mengembalikan 3", "ja": "3つの整数a、b、cが与えられています。このうち2つは等しく、残りの1つは他の2つと異なります。あなたのタスクは、ちょうど1回だけ現れる値を見つけることです。\n\n例:\n  f_12(0, 0, 1) は 1 を返します\n  f_12(4, 3, 4) は 3 を返します", "ko": "세 개의 정수 a, b, c가 주어졌으며, 그 중 두 개는 같고 나머지 하나는 다른 두 개와 다릅니다. 당신의 작업은 정확히 한 번만 나타나는 값을 찾는 것입니다.\n\n예시:\n  f_12(0, 0, 1) returns 1\n  f_12(4, 3, 4) returns 3", "ml": "നിങ്ങൾക്ക് മൂന്ന് പൂർണ്ണസംഖ്യകൾ a, b, c ലഭ്യമാണ്, അവയിൽ രണ്ടെണ്ണം തുല്യമാണ്, മൂന്നാമത്തേത് മറ്റുള്ള രണ്ടിനും വ്യത്യസ്തമാണ്. ഒരിക്കൽ മാത്രം സംഭവിക്കുന്ന മൂല്യം കണ്ടെത്തുക എന്നതാണ് നിങ്ങളുടെ പണി.\n\nഉദാഹരണങ്ങൾ:\n  f_12(0, 0, 1) 1 മടക്കുന്നു\n  f_12(4, 3, 4) 3 മടക്കുന്നു", "fa": "شما سه عدد صحیح a، b، c دارید که دو تای آنها برابر هستند و سومی با دو تای دیگر متفاوت است. وظیفه شما این است که مقداری را پیدا کنید که دقیقاً یک بار ظاهر می‌شود.\n\nمثال‌ها:\n  f_12(0, 0, 1) مقدار 1 را برمی‌گرداند\n  f_12(4, 3, 4) مقدار 3 را برمی‌گرداند"}}
{"task_id": "CPP/13", "prompt": {"en": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Calculate the total score for a student based on the scores in different subjects.\n *\n * Parameters:\n * - subject_scores (list): A list containing the scores for each subject.\n *\n * Returns:\n *   int: The total score obtained by summing up the scores in all subjects.\n *\n * Examples:\n *   >>> f_13(100,100,100,100,100)\n *   500\n */\nint f_13(int score1, int score2, int score3, int score4, int score5)", "sq": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Llogarit totalin e pikëve për një student bazuar në pikët në lëndë të ndryshme.\n *\n * Parametrat:\n * - subject_scores (listë): Një listë që përmban pikët për secilën lëndë.\n *\n * Kthen:\n *   int: Totali i pikëve të marra duke mbledhur pikët në të gjitha lëndët.\n *\n * Shembuj:\n *   >>> f_13(100,100,100,100,100)\n *   500\n */\nint f_13(int score1, int score2, int score3, int score4, int score5)", "hy": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Հաշվել ուսանողի ընդհանուր միավորը տարբեր առարկաներում ստացած միավորների հիման վրա:\n *\n * Պարամետրեր:\n * - subject_scores (list): Ցանկ, որը պարունակում է յուրաքանչյուր առարկայի միավորները:\n *\n * Վերադարձնում է:\n *   int: Ընդհանուր միավորը, որը ստացվում է բոլոր առարկաների միավորների գումարով:\n *\n * Օրինակներ:\n *   >>> f_13(100,100,100,100,100)\n *   500\n */\nint f_13(int score1, int score2, int score3, int score4, int score5)", "bn": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * বিভিন্ন বিষয়ে স্কোরের উপর ভিত্তি করে একজন শিক্ষার্থীর মোট স্কোর গণনা করুন।\n *\n * প্যারামিটার:\n * - subject_scores (list): প্রতিটি বিষয়ের স্কোর ধারণকারী একটি তালিকা।\n *\n * রিটার্নস:\n *   int: সমস্ত বিষয়ে স্কোর যোগ করে প্রাপ্ত মোট স্কোর।\n *\n * উদাহরণ:\n *   >>> f_13(100,100,100,100,100)\n *   500\n */\nint f_13(int score1, int score2, int score3, int score4, int score5)", "bg": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Изчислява общия резултат за ученик въз основа на резултатите по различни предмети.\n *\n * Параметри:\n * - subject_scores (list): Списък, съдържащ резултатите за всеки предмет.\n *\n * Връща:\n *   int: Общият резултат, получен чрез събиране на резултатите по всички предмети.\n *\n * Примери:\n *   >>> f_13(100,100,100,100,100)\n *   500\n */\nint f_13(int score1, int score2, int score3, int score4, int score5)", "zh": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * 计算学生在不同科目中的总分。\n *\n * 参数:\n * - subject_scores (list): 包含每个科目分数的列表。\n *\n * 返回:\n *   int: 通过将所有科目的分数相加获得的总分。\n *\n * 示例:\n *   >>> f_13(100,100,100,100,100)\n *   500\n */\nint f_13(int score1, int score2, int score3, int score4, int score5)", "fr": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Calculer le score total pour un étudiant basé sur les scores dans différentes matières.\n *\n * Paramètres:\n * - subject_scores (list): Une liste contenant les scores pour chaque matière.\n *\n * Renvoie:\n *   int: Le score total obtenu en additionnant les scores de toutes les matières.\n *\n * Exemples:\n *   >>> f_13(100,100,100,100,100)\n *   500\n */\nint f_13(int score1, int score2, int score3, int score4, int score5)", "de": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Berechnet die Gesamtpunktzahl für einen Schüler basierend auf den Punkten in verschiedenen Fächern.\n *\n * Parameter:\n * - subject_scores (list): Eine Liste, die die Punkte für jedes Fach enthält.\n *\n * Rückgabewert:\n *   int: Die Gesamtpunktzahl, die durch das Summieren der Punkte in allen Fächern erzielt wird.\n *\n * Beispiele:\n *   >>> f_13(100,100,100,100,100)\n *   500\n */\nint f_13(int score1, int score2, int score3, int score4, int score5)", "ha": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Lissafa jimillar maki ga ɗalibi bisa ga maki a fannoni daban-daban.\n *\n * Sigogi:\n * - subject_scores (list): Jerin da ke ɗauke da maki na kowane fanni.\n *\n * Komawa:\n *   int: Jimillar maki da aka samu ta hanyar tara maki a dukkan fannoni.\n *\n * Misalai:\n *   >>> f_13(100,100,100,100,100)\n *   500\n */\nint f_13(int score1, int score2, int score3, int score4, int score5)", "hi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * विभिन्न विषयों में अंकों के आधार पर एक छात्र के लिए कुल अंक की गणना करें।\n *\n * पैरामीटर:\n * - subject_scores (list): प्रत्येक विषय के लिए अंक वाली एक सूची।\n *\n * रिटर्न करता है:\n *   int: सभी विषयों में अंकों को जोड़कर प्राप्त कुल अंक।\n *\n * उदाहरण:\n *   >>> f_13(100,100,100,100,100)\n *   500\n */\nint f_13(int score1, int score2, int score3, int score4, int score5)", "hu": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Számítsa ki a diák összpontszámát a különböző tantárgyakban elért pontszámok alapján.\n *\n * Paraméterek:\n * - subject_scores (list): Egy lista, amely az egyes tantárgyak pontszámait tartalmazza.\n *\n * Visszatér:\n *   int: Az összpontszám, amelyet az összes tantárgy pontszámainak összeadásával kapunk.\n *\n * Példák:\n *   >>> f_13(100,100,100,100,100)\n *   500\n */\nint f_13(int score1, int score2, int score3, int score4, int score5)", "es": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Calcular la puntuación total de un estudiante basada en las puntuaciones en diferentes materias.\n *\n * Parámetros:\n * - subject_scores (list): Una lista que contiene las puntuaciones para cada materia.\n *\n * Devuelve:\n *   int: La puntuación total obtenida al sumar las puntuaciones en todas las materias.\n *\n * Ejemplos:\n *   >>> f_13(100,100,100,100,100)\n *   500\n */\nint f_13(int score1, int score2, int score3, int score4, int score5)", "arb": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * حساب المجموع الكلي للدرجات لطالب بناءً على الدرجات في مواد مختلفة.\n *\n * المعلمات:\n * - subject_scores (list): قائمة تحتوي على الدرجات لكل مادة.\n *\n * يعيد:\n *   int: المجموع الكلي الذي يتم الحصول عليه بجمع الدرجات في جميع المواد.\n *\n * أمثلة:\n *   >>> f_13(100,100,100,100,100)\n *   500\n */\nint f_13(int score1, int score2, int score3, int score4, int score5)", "sw": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Hesabu jumla ya alama kwa mwanafunzi kulingana na alama katika masomo tofauti.\n *\n * Vigezo:\n * - subject_scores (list): Orodha inayoonyesha alama za kila somo.\n *\n * Inarudisha:\n *   int: Jumla ya alama zilizopatikana kwa kujumlisha alama katika masomo yote.\n *\n * Mifano:\n *   >>> f_13(100,100,100,100,100)\n *   500\n */\nint f_13(int score1, int score2, int score3, int score4, int score5)", "tr": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Farklı derslerdeki puanlara göre bir öğrencinin toplam puanını hesaplayın.\n *\n * Parametreler:\n * - subject_scores (list): Her ders için puanları içeren bir liste.\n *\n * Döndürür:\n *   int: Tüm derslerdeki puanların toplanmasıyla elde edilen toplam puan.\n *\n * Örnekler:\n *   >>> f_13(100,100,100,100,100)\n *   500\n */\nint f_13(int score1, int score2, int score3, int score4, int score5)", "vi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Tính tổng điểm cho một học sinh dựa trên điểm số ở các môn học khác nhau.\n *\n * Tham số:\n * - subject_scores (list): Một danh sách chứa điểm số cho mỗi môn học.\n *\n * Trả về:\n *   int: Tổng điểm đạt được bằng cách cộng điểm số của tất cả các môn học.\n *\n * Ví dụ:\n *   >>> f_13(100,100,100,100,100)\n *   500\n */\nint f_13(int score1, int score2, int score3, int score4, int score5)", "id": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Menghitung total skor untuk seorang siswa berdasarkan skor dalam berbagai mata pelajaran.\n *\n * Parameter:\n * - subject_scores (list): Daftar yang berisi skor untuk setiap mata pelajaran.\n *\n * Mengembalikan:\n *   int: Total skor yang diperoleh dengan menjumlahkan skor di semua mata pelajaran.\n *\n * Contoh:\n *   >>> f_13(100,100,100,100,100)\n *   500\n */\nint f_13(int score1, int score2, int score3, int score4, int score5)", "ja": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * 異なる科目のスコアに基づいて学生の合計スコアを計算します。\n *\n * パラメータ:\n * - subject_scores (list): 各科目のスコアを含むリスト。\n *\n * 戻り値:\n *   int: すべての科目のスコアを合計して得られる合計スコア。\n *\n * 例:\n *   >>> f_13(100,100,100,100,100)\n *   500\n */\nint f_13(int score1, int score2, int score3, int score4, int score5)", "ko": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * 학생의 다양한 과목 점수를 기반으로 총 점수를 계산합니다.\n *\n * 매개변수:\n * - subject_scores (list): 각 과목의 점수를 포함하는 리스트입니다.\n *\n * 반환값:\n *   int: 모든 과목의 점수를 합산하여 얻은 총 점수입니다.\n *\n * 예시:\n *   >>> f_13(100,100,100,100,100)\n *   500\n */\nint f_13(int score1, int score2, int score3, int score4, int score5)", "ml": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * വിവിധ വിഷയങ്ങളിലെ സ്കോറുകൾ അടിസ്ഥാനമാക്കി ഒരു വിദ്യാർത്ഥിയുടെ മൊത്തം സ്കോർ കണക്കാക്കുക.\n *\n * പാരാമീറ്ററുകൾ:\n * - subject_scores (list): ഓരോ വിഷയത്തിന്റെയും സ്കോറുകൾ അടങ്ങിയ ഒരു പട്ടിക.\n *\n * റിട്ടേൺസ്:\n *   int: എല്ലാ വിഷയങ്ങളിലെയും സ്കോറുകൾ കൂട്ടിച്ചേർത്തു ലഭിക്കുന്ന മൊത്തം സ്കോർ.\n *\n * ഉദാഹരണങ്ങൾ:\n *   >>> f_13(100,100,100,100,100)\n *   500\n */\nint f_13(int score1, int score2, int score3, int score4, int score5)", "fa": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * محاسبه امتیاز کل برای یک دانش‌آموز بر اساس امتیازات در موضوعات مختلف.\n *\n * پارامترها:\n * - subject_scores (list): لیستی که امتیازات هر موضوع را شامل می‌شود.\n *\n * بازگشت:\n *   int: امتیاز کل که با جمع کردن امتیازات در همه موضوعات به دست می‌آید.\n *\n * مثال‌ها:\n *   >>> f_13(100,100,100,100,100)\n *   500\n */\nint f_13(int score1, int score2, int score3, int score4, int score5)"}, "canonical_solution": "{\n    return score1 + score2 + score3 + score4 + score5;\n}", "instruction": {"en": "int f_13(int score1, int score2, int score3, int score4, int score5)\n{\n    return score1 + score2 + score3 + score4 + score5;\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.", "sq": "int f_13(int score1, int score2, int score3, int score4, int score5)\n{\n    return score1 + score2 + score3 + score4 + score5;\n}\n\nSiguroni një përshkrim të shkurtër në gjuhën natyrore (docstring) të kodit CPP në shqip duke përdorur maksimumi 500 karaktere.", "hy": "int f_13(int score1, int score2, int score3, int score4, int score5)\n{\n    return score1 + score2 + score3 + score4 + score5;\n}\n\nՏվեք CPP կոդի համառոտ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "int f_13(int score1, int score2, int score3, int score4, int score5)\n{\n    return score1 + score2 + score3 + score4 + score5;\n}\n\nসিপিপি কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।", "bg": "int f_13(int score1, int score2, int score3, int score4, int score5)\n{\n    return score1 + score2 + score3 + score4 + score5;\n}\n\nПредоставете кратко описание на CPP кода на естествен език на български, използвайки не повече от 500 знака.", "zh": "int f_13(int score1, int score2, int score3, int score4, int score5)\n{\n    return score1 + score2 + score3 + score4 + score5;\n}\n\n将以下 CPP 代码的功能描述为简洁的自然语言（文档字符串），并使用不超过 500 个字符的中文。", "fr": "int f_13(int score1, int score2, int score3, int score4, int score5)\n{\n    return score1 + score2 + score3 + score4 + score5;\n}\n\nFournissez une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.", "de": "int f_13(int score1, int score2, int score3, int score4, int score5)\n{\n    return score1 + score2 + score3 + score4 + score5;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen.", "ha": "int f_13(int score1, int score2, int score3, int score4, int score5)\n{\n    return score1 + score2 + score3 + score4 + score5;\n}\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar CPP cikin Hausa ta amfani da haruffa 500 ko kasa da haka.", "hi": "int f_13(int score1, int score2, int score3, int score4, int score5)\n{\n    return score1 + score2 + score3 + score4 + score5;\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "int f_13(int score1, int score2, int score3, int score4, int score5)\n{\n    return score1 + score2 + score3 + score4 + score5;\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a CPP kódról magyar nyelven, legfeljebb 500 karakterben.", "es": "int f_13(int score1, int score2, int score3, int score4, int score5)\n{\n    return score1 + score2 + score3 + score4 + score5;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando como máximo 500 caracteres.", "arb": "int f_13(int score1, int score2, int score3, int score4, int score5)\n{\n    return score1 + score2 + score3 + score4 + score5;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشيفرة المكتوبة بلغة CPP باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "int f_13(int score1, int score2, int score3, int score4, int score5)\n{\n    return score1 + score2 + score3 + score4 + score5;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "int f_13(int score1, int score2, int score3, int score4, int score5)\n{\n    return score1 + score2 + score3 + score4 + score5;\n}\n\nAşağıdaki CPP kodunun Türkçe olarak en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.", "vi": "int f_13(int score1, int score2, int score3, int score4, int score5)\n{\n    return score1 + score2 + score3 + score4 + score5;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt, không quá 500 ký tự.", "id": "int f_13(int score1, int score2, int score3, int score4, int score5)\n{\n    return score1 + score2 + score3 + score4 + score5;\n}\n\nBerikan deskripsi bahasa alami (docstring) yang ringkas tentang kode CPP dalam bahasa Inggris menggunakan maksimal 500 karakter.", "ja": "int f_13(int score1, int score2, int score3, int score4, int score5)\n{\n    return score1 + score2 + score3 + score4 + score5;\n}\n\n以下のCPPコードの簡潔な自然言語による説明（ドキュメンテーションコメント）を、日本語で500文字以内で提供してください。", "ko": "int f_13(int score1, int score2, int score3, int score4, int score5)\n{\n    return score1 + score2 + score3 + score4 + score5;\n}\n\n다음 CPP 코드에 대한 간결한 자연어 설명(도크스트링)을 최대 500자 이내로 한국어로 제공하세요.", "ml": "int f_13(int score1, int score2, int score3, int score4, int score5)\n{\n    return score1 + score2 + score3 + score4 + score5;\n}\n\nസിപിപി കോഡിന് 500 അക്ഷരങ്ങളിൽ കൂടുതൽ അല്ലാത്ത ഒരു സംക്ഷിപ്ത സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) മലയാളത്തിൽ നൽകുക.", "fa": "int f_13(int score1, int score2, int score3, int score4, int score5)\n{\n    return score1 + score2 + score3 + score4 + score5;\n}\n\nتوضیح مختصر و طبیعی از کد CPP به زبان فارسی با حداکثر ۵۰۰ کاراکتر ارائه دهید."}, "level": "", "test": "int main() {\n    assert(f_13(100,100,100,100,100) == 500);\n    assert(f_13(0,0,0,0,0) == 0);\n    assert(f_13(20, 30, 40, 10, 50) == 150);\n    assert(f_13(23, 45, 67, 89, 12) == 236);\n    assert(f_13(5, 5, 5, 5, 5) == 25);\n    return 0;\n}", "entry_point": "f_13", "signature": "int f_13(int score1, int score2, int score3, int score4, int score5)", "docstring": {"en": "Calculate the total score for a student based on the scores in different subjects.\n\nParameters:\n- score1 (int): The score for the first subject.\n- score2 (int): The score for the second subject.\n- score3 (int): The score for the third subject.\n- score4 (int): The score for the fourth subject.\n- score5 (int): The score for the fifth subject.\n\nReturns:\n  int: The total score obtained by summing up the scores in all subjects.\n\nExamples:\n  >>> f_13(100,100,100,100,100)\n  500\n", "sq": "Llogaritni rezultatin total për një student bazuar në rezultatet në lëndë të ndryshme.\n\nParametrat:\n- score1 (int): Rezultati për lëndën e parë.\n- score2 (int): Rezultati për lëndën e dytë.\n- score3 (int): Rezultati për lëndën e tretë.\n- score4 (int): Rezultati për lëndën e katërt.\n- score5 (int): Rezultati për lëndën e pestë.\n\nKthen:\n  int: Rezultati total i marrë duke mbledhur rezultatet në të gjitha lëndët.\n\nShembuj:\n  >>> f_13(100,100,100,100,100)\n  500", "hy": "Հաշվարկել ուսանողի ընդհանուր միավորը տարբեր առարկաներում ստացված միավորների հիման վրա:\n\nՊարամետրեր:\n- score1 (int): Առաջին առարկայի միավորը:\n- score2 (int): Երկրորդ առարկայի միավորը:\n- score3 (int): Երրորդ առարկայի միավորը:\n- score4 (int): Չորրորդ առարկայի միավորը:\n- score5 (int): Հինգերորդ առարկայի միավորը:\n\nՎերադարձնում է:\n  int: Ընդհանուր միավորը, որը ստացվում է բոլոր առարկաների միավորների գումարով:\n\nՕրինակներ:\n  >>> f_13(100,100,100,100,100)\n  500", "bn": "একজন শিক্ষার্থীর বিভিন্ন বিষয়ে প্রাপ্ত নম্বরের ভিত্তিতে মোট স্কোর গণনা করুন।\n\nপ্যারামিটারসমূহ:\n- score1 (int): প্রথম বিষয়ের নম্বর।\n- score2 (int): দ্বিতীয় বিষয়ের নম্বর।\n- score3 (int): তৃতীয় বিষয়ের নম্বর।\n- score4 (int): চতুর্থ বিষয়ের নম্বর।\n- score5 (int): পঞ্চম বিষয়ের নম্বর।\n\nফেরত দেয়:\n  int: সব বিষয়ের নম্বর যোগ করে প্রাপ্ত মোট স্কোর।\n\nউদাহরণ:\n  >>> f_13(100,100,100,100,100)\n  500", "bg": "Изчислява общия резултат за студент въз основа на резултатите по различни предмети.\n\nПараметри:\n- score1 (int): Резултатът за първия предмет.\n- score2 (int): Резултатът за втория предмет.\n- score3 (int): Резултатът за третия предмет.\n- score4 (int): Резултатът за четвъртия предмет.\n- score5 (int): Резултатът за петия предмет.\n\nВръща:\n  int: Общият резултат, получен чрез сумиране на резултатите по всички предмети.\n\nПримери:\n  >>> f_13(100,100,100,100,100)\n  500", "zh": "计算学生在不同科目中的总分。\n\n参数：\n- score1 (int): 第一科目的分数。\n- score2 (int): 第二科目的分数。\n- score3 (int): 第三科目的分数。\n- score4 (int): 第四科目的分数。\n- score5 (int): 第五科目的分数。\n\n返回：\n  int: 通过将所有科目的分数相加得到的总分。\n\n示例：\n  >>> f_13(100,100,100,100,100)\n  500", "fr": "Calculer le score total pour un étudiant basé sur les scores dans différentes matières.\n\nParamètres:\n- score1 (int): Le score pour la première matière.\n- score2 (int): Le score pour la deuxième matière.\n- score3 (int): Le score pour la troisième matière.\n- score4 (int): Le score pour la quatrième matière.\n- score5 (int): Le score pour la cinquième matière.\n\nRenvoie:\n  int: Le score total obtenu en additionnant les scores dans toutes les matières.\n\nExemples:\n  >>> f_13(100,100,100,100,100)\n  500", "de": "Berechnen Sie die Gesamtpunktzahl für einen Schüler basierend auf den Punkten in verschiedenen Fächern.\n\nParameter:\n- score1 (int): Die Punktzahl für das erste Fach.\n- score2 (int): Die Punktzahl für das zweite Fach.\n- score3 (int): Die Punktzahl für das dritte Fach.\n- score4 (int): Die Punktzahl für das vierte Fach.\n- score5 (int): Die Punktzahl für das fünfte Fach.\n\nRückgabewert:\n  int: Die Gesamtpunktzahl, die durch das Aufsummieren der Punkte in allen Fächern erzielt wird.\n\nBeispiele:\n  >>> f_13(100,100,100,100,100)\n  500", "ha": "Ƙididdige jimillar maki ga ɗalibi bisa ga maki a fannoni daban-daban.\n\nSigogi:\n- score1 (int): Makin fanni na farko.\n- score2 (int): Makin fanni na biyu.\n- score3 (int): Makin fanni na uku.\n- score4 (int): Makin fanni na huɗu.\n- score5 (int): Makin fanni na biyar.\n\nDawowa:\n  int: Jimillar maki da aka samu ta hanyar tara maki a duk fannoni.\n\nMisalai:\n  >>> f_13(100,100,100,100,100)\n  500", "hi": "विभिन्न विषयों में अंकों के आधार पर एक छात्र के लिए कुल स्कोर की गणना करें।\n\nमापदंड:\n- score1 (int): पहले विषय के लिए अंक।\n- score2 (int): दूसरे विषय के लिए अंक।\n- score3 (int): तीसरे विषय के लिए अंक।\n- score4 (int): चौथे विषय के लिए अंक।\n- score5 (int): पांचवें विषय के लिए अंक।\n\nवापसी:\n  int: सभी विषयों में अंकों को जोड़कर प्राप्त कुल अंक।\n\nउदाहरण:\n  >>> f_13(100,100,100,100,100)\n  500", "hu": "Számítsa ki a diák összpontszámát a különböző tantárgyakban elért pontszámok alapján.\n\nParaméterek:\n- score1 (int): Az első tantárgy pontszáma.\n- score2 (int): A második tantárgy pontszáma.\n- score3 (int): A harmadik tantárgy pontszáma.\n- score4 (int): A negyedik tantárgy pontszáma.\n- score5 (int): Az ötödik tantárgy pontszáma.\n\nVisszatér:\n  int: Az összpontszám, amelyet az összes tantárgy pontszámának összeadásával kapunk.\n\nPéldák:\n  >>> f_13(100,100,100,100,100)\n  500", "es": "Calcular la puntuación total para un estudiante basado en las puntuaciones en diferentes materias.\n\nParámetros:\n- score1 (int): La puntuación para la primera materia.\n- score2 (int): La puntuación para la segunda materia.\n- score3 (int): La puntuación para la tercera materia.\n- score4 (int): La puntuación para la cuarta materia.\n- score5 (int): La puntuación para la quinta materia.\n\nDevuelve:\n  int: La puntuación total obtenida al sumar las puntuaciones en todas las materias.\n\nEjemplos:\n  >>> f_13(100,100,100,100,100)\n  500", "arb": "احسب المجموع الكلي للدرجات لطالب بناءً على الدرجات في مواد مختلفة.\n\nالمعلمات:\n- score1 (int): الدرجة للمادة الأولى.\n- score2 (int): الدرجة للمادة الثانية.\n- score3 (int): الدرجة للمادة الثالثة.\n- score4 (int): الدرجة للمادة الرابعة.\n- score5 (int): الدرجة للمادة الخامسة.\n\nالقيم المعادة:\n  int: المجموع الكلي للدرجات المحصل عليه بجمع الدرجات في جميع المواد.\n\nأمثلة:\n  >>> f_13(100,100,100,100,100)\n  500", "sw": "Hesabu jumla ya alama kwa mwanafunzi kulingana na alama katika masomo tofauti.\n\nVigezo:\n- score1 (int): Alama ya somo la kwanza.\n- score2 (int): Alama ya somo la pili.\n- score3 (int): Alama ya somo la tatu.\n- score4 (int): Alama ya somo la nne.\n- score5 (int): Alama ya somo la tano.\n\nInarejesha:\n  int: Jumla ya alama iliyopatikana kwa kujumlisha alama katika masomo yote.\n\nMifano:\n  >>> f_13(100,100,100,100,100)\n  500", "tr": "Bir öğrencinin farklı derslerdeki puanlarına dayanarak toplam puanını hesaplayın.\n\nParametreler:\n- score1 (int): Birinci dersin puanı.\n- score2 (int): İkinci dersin puanı.\n- score3 (int): Üçüncü dersin puanı.\n- score4 (int): Dördüncü dersin puanı.\n- score5 (int): Beşinci dersin puanı.\n\nDöndürülenler:\n  int: Tüm derslerdeki puanların toplanmasıyla elde edilen toplam puan.\n\nÖrnekler:\n  >>> f_13(100,100,100,100,100)\n  500", "vi": "Tính tổng điểm cho một học sinh dựa trên điểm số ở các môn học khác nhau.\n\nTham số:\n- score1 (int): Điểm số cho môn học thứ nhất.\n- score2 (int): Điểm số cho môn học thứ hai.\n- score3 (int): Điểm số cho môn học thứ ba.\n- score4 (int): Điểm số cho môn học thứ tư.\n- score5 (int): Điểm số cho môn học thứ năm.\n\nTrả về:\n  int: Tổng điểm đạt được bằng cách cộng điểm số ở tất cả các môn học.\n\nVí dụ:\n  >>> f_13(100,100,100,100,100)\n  500", "id": "Hitung total skor untuk seorang siswa berdasarkan skor dalam berbagai mata pelajaran.\n\nParameter:\n- score1 (int): Skor untuk mata pelajaran pertama.\n- score2 (int): Skor untuk mata pelajaran kedua.\n- score3 (int): Skor untuk mata pelajaran ketiga.\n- score4 (int): Skor untuk mata pelajaran keempat.\n- score5 (int): Skor untuk mata pelajaran kelima.\n\nMengembalikan:\n  int: Total skor yang diperoleh dengan menjumlahkan skor dalam semua mata pelajaran.\n\nContoh:\n  >>> f_13(100,100,100,100,100)\n  500", "ja": "学生の異なる科目のスコアに基づいて、総合スコアを計算します。\n\n引数:\n- score1 (int): 最初の科目のスコア。\n- score2 (int): 2番目の科目のスコア。\n- score3 (int): 3番目の科目のスコア。\n- score4 (int): 4番目の科目のスコア。\n- score5 (int): 5番目の科目のスコア。\n\n戻り値:\n  int: すべての科目のスコアを合計して得られる総合スコア。\n\n例:\n  >>> f_13(100,100,100,100,100)\n  500", "ko": "학생의 다양한 과목 점수를 기반으로 총점을 계산합니다.\n\n매개변수:\n- score1 (int): 첫 번째 과목의 점수.\n- score2 (int): 두 번째 과목의 점수.\n- score3 (int): 세 번째 과목의 점수.\n- score4 (int): 네 번째 과목의 점수.\n- score5 (int): 다섯 번째 과목의 점수.\n\n반환값:\n  int: 모든 과목의 점수를 합산하여 얻은 총점.\n\n예제:\n  >>> f_13(100,100,100,100,100)\n  500", "ml": "വിവിധ വിഷയങ്ങളിലെ സ്കോറുകൾ അടിസ്ഥാനമാക്കി ഒരു വിദ്യാർത്ഥിയുടെ മൊത്തം സ്കോർ കണക്കാക്കുക.\n\nപാരാമീറ്ററുകൾ:\n- score1 (int): ആദ്യ വിഷയത്തിനുള്ള സ്കോർ.\n- score2 (int): രണ്ടാം വിഷയത്തിനുള്ള സ്കോർ.\n- score3 (int): മൂന്നാം വിഷയത്തിനുള്ള സ്കോർ.\n- score4 (int): നാലാം വിഷയത്തിനുള്ള സ്കോർ.\n- score5 (int): അഞ്ചാം വിഷയത്തിനുള്ള സ്കോർ.\n\nമടക്കം:\n  int: എല്ലാ വിഷയങ്ങളിലെയും സ്കോറുകൾ കൂട്ടിച്ചേർത്തു ലഭിക്കുന്ന മൊത്തം സ്കോർ.\n\nഉദാഹരണങ്ങൾ:\n  >>> f_13(100,100,100,100,100)\n  500", "fa": "محاسبه امتیاز کل برای یک دانش‌آموز بر اساس امتیازات در موضوعات مختلف.\n\nپارامترها:\n- score1 (int): امتیاز برای موضوع اول.\n- score2 (int): امتیاز برای موضوع دوم.\n- score3 (int): امتیاز برای موضوع سوم.\n- score4 (int): امتیاز برای موضوع چهارم.\n- score5 (int): امتیاز برای موضوع پنجم.\n\nبازگشت:\n  int: امتیاز کل به‌دست‌آمده با جمع کردن امتیازات در همه موضوعات.\n\nمثال‌ها:\n  >>> f_13(100,100,100,100,100)\n  500"}}
{"task_id": "CPP/14", "prompt": {"en": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/*\nDecode a series of numbers to reveal the pattern and understand the actual values \neach digit represents.\n\nEquations provided for reference:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParameters:\n- data_str: A constant character array (C-style string) representing a series of numbers. Length does not exceed 100.\n\nReturns:\nint: The result of each data string corresponding to the right-hand side of the equation.\n\nExample usage:\nassert(f_14(\"0000\") == 4);\n*/\nint f_14(const char* data_str)", "sq": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/*\nDekodo një seri numrash për të zbuluar modelin dhe për të kuptuar vlerat aktuale \nqë përfaqëson secila shifër.\n\nEkuacionet e dhëna për referencë:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParametrat:\n- data_str: Një varg karakteresh konstant (string në stilin C) që përfaqëson një seri numrash. Gjatësia nuk e kalon 100.\n\nKthen:\nint: Rezultati i secilës varg të dhënash që korrespondon me anën e djathtë të ekuacionit.\n\nShembull përdorimi:\nassert(f_14(\"0000\") == 4);\n*/\nint f_14(const char* data_str)", "hy": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/*\nՎերծանել թվերի շարք՝ բացահայտելու օրինաչափությունը և հասկանալու իրական արժեքները,\nորոնք ներկայացնում է յուրաքանչյուր թվանշան:\n\nՀաշվարկային հավասարումները տրված են հղման համար.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nՊարամետրեր:\n- data_str: Հաստատուն սիմվոլների զանգված (C-ոճի տող), որը ներկայացնում է թվերի շարք։ Երկարությունը չի գերազանցում 100-ը։\n\nՎերադարձնում է:\nint: Յուրաքանչյուր տվյալ տողի արդյունքը, որը համապատասխանում է հավասարման աջ կողմին։\n\nՕրինակ օգտագործում:\nassert(f_14(\"0000\") == 4);\n*/\nint f_14(const char* data_str)", "bn": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/*\nসংখ্যার একটি সিরিজ ডিকোড করুন যাতে প্যাটার্নটি প্রকাশ পায় এবং প্রতিটি অঙ্ক আসলে কোন মানটি উপস্থাপন করে তা বোঝা যায়।\n\nতুলনার জন্য প্রদত্ত সমীকরণ:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nপ্যারামিটার:\n- data_str: একটি ধ্রুবক চরিত্রের অ্যারে (সি-স্টাইল স্ট্রিং) যা সংখ্যার একটি সিরিজ উপস্থাপন করে। দৈর্ঘ্য 100 অতিক্রম করে না।\n\nরিটার্নস:\nint: প্রতিটি ডেটা স্ট্রিং এর ফলাফল যা সমীকরণের ডান দিকের সাথে মিলে যায়।\n\nউদাহরণ ব্যবহার:\nassert(f_14(\"0000\") == 4);\n*/\nint f_14(const char* data_str)", "bg": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/*\nДекодирайте поредица от числа, за да разкриете модела и да разберете действителните стойности,\nкоито всяка цифра представлява.\n\nПредоставени уравнения за справка:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nПараметри:\n- data_str: Константен масив от символи (низ в стил C), представляващ поредица от числа. Дължината не надвишава 100.\n\nВръща:\nint: Резултатът от всеки низ от данни, съответстващ на дясната страна на уравнението.\n\nПример за използване:\nassert(f_14(\"0000\") == 4);\n*/\nint f_14(const char* data_str)", "zh": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/*\n解码一系列数字以揭示模式并理解每个数字代表的实际值。\n\n提供的方程用于参考：\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\n参数：\n- data_str: 一个常量字符数组（C风格字符串），表示一系列数字。长度不超过100。\n\n返回：\nint: 每个数据字符串对应方程右侧的结果。\n\n示例用法：\nassert(f_14(\"0000\") == 4);\n*/\nint f_14(const char* data_str)", "fr": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/*\nDécoder une série de chiffres pour révéler le motif et comprendre les valeurs réelles \nque chaque chiffre représente.\n\nÉquations fournies à titre de référence :\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParamètres :\n- data_str : Un tableau de caractères constant (chaîne de style C) représentant une série de chiffres. La longueur ne dépasse pas 100.\n\nRenvoie :\nint : Le résultat de chaque chaîne de données correspondant au côté droit de l'équation.\n\nExemple d'utilisation :\nassert(f_14(\"0000\") == 4);\n*/\nint f_14(const char* data_str)", "de": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/*\nDekodiere eine Reihe von Zahlen, um das Muster zu erkennen und die tatsächlichen Werte zu verstehen, \ndie jede Ziffer darstellt.\n\nGleichungen zur Referenz:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParameter:\n- data_str: Ein konstantes Zeichenarray (C-Style-String), das eine Reihe von Zahlen darstellt. Die Länge überschreitet nicht 100.\n\nRückgabewert:\nint: Das Ergebnis jeder Datenzeichenfolge, das der rechten Seite der Gleichung entspricht.\n\nBeispielverwendung:\nassert(f_14(\"0000\") == 4);\n*/\nint f_14(const char* data_str)", "ha": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/*\nFassara jerin lambobi don bayyana tsarin kuma fahimtar ainihin ƙimar da kowace lamba ke wakilta.\n\nAn bayar da ƙa'idodi don tunani:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nSigogi:\n- data_str: Tsayayyen jerin haruffa (salo na C) wanda ke wakiltar jerin lambobi. Tsawon ba ya wuce 100.\n\nDawowa:\nint: Sakamakon kowanne jerin bayanai da ya dace da gefen dama na ƙa'idar.\n\nMisalin amfani:\nassert(f_14(\"0000\") == 4);\n*/\nint f_14(const char* data_str)", "hi": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/*\nसंख्याओं की एक श्रृंखला को डिकोड करें ताकि पैटर्न का पता चल सके और समझ सकें कि प्रत्येक अंक का वास्तविक मूल्य क्या है।\n\nसंदर्भ के लिए समीकरण प्रदान किए गए हैं:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nपैरामीटर्स:\n- data_str: एक स्थिर कैरेक्टर ऐरे (C-शैली की स्ट्रिंग) जो संख्याओं की एक श्रृंखला का प्रतिनिधित्व करता है। लंबाई 100 से अधिक नहीं होती।\n\nवापसी:\nint: प्रत्येक डेटा स्ट्रिंग का परिणाम जो समीकरण के दाहिने हाथ की ओर संबंधित होता है।\n\nउदाहरण उपयोग:\nassert(f_14(\"0000\") == 4);\n*/\nint f_14(const char* data_str)", "hu": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/*\nDekódolj egy számsorozatot, hogy felfedd a mintát és megértsd, hogy az egyes számjegyek valójában milyen értékeket képviselnek.\n\nAz egyenletek referenciaként:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParaméterek:\n- data_str: Egy konstans karaktertömb (C-stílusú string), amely egy számsorozatot képvisel. Hossza nem haladja meg a 100-at.\n\nVisszatérési érték:\nint: Az egyes adatstringek eredménye, amely megfelel az egyenlet jobb oldalának.\n\nPélda használat:\nassert(f_14(\"0000\") == 4);\n*/\nint f_14(const char* data_str)", "es": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/*\nDecodificar una serie de números para revelar el patrón y entender los valores reales \nque cada dígito representa.\n\nEcuaciones proporcionadas como referencia:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParámetros:\n- data_str: Una matriz de caracteres constante (cadena estilo C) que representa una serie de números. La longitud no excede 100.\n\nDevuelve:\nint: El resultado de cada cadena de datos correspondiente al lado derecho de la ecuación.\n\nEjemplo de uso:\nassert(f_14(\"0000\") == 4);\n*/\nint f_14(const char* data_str)", "arb": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/*\nفك سلسلة من الأرقام للكشف عن النمط وفهم القيم الفعلية التي يمثلها كل رقم.\n\nالمعادلات المقدمة للمرجع:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nالمعلمات:\n- data_str: مصفوفة حرفية ثابتة (سلسلة نمط C) تمثل سلسلة من الأرقام. الطول لا يتجاوز 100.\n\nالإرجاع:\nint: نتيجة كل سلسلة بيانات مطابقة للجانب الأيمن من المعادلة.\n\nمثال على الاستخدام:\nassert(f_14(\"0000\") == 4);\n*/\nint f_14(const char* data_str)", "sw": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/*\nFasiri mfululizo wa nambari ili kufichua muundo na kuelewa thamani halisi \nambayo kila tarakimu inawakilisha.\n\nMlinganyo uliotolewa kwa marejeleo:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nVigezo:\n- data_str: Mfululizo wa herufi wa tabia za kudumu (mfululizo wa C-style) unaowakilisha mfululizo wa nambari. Urefu hauzidi 100.\n\nInarudisha:\nint: Matokeo ya kila mfululizo wa data yanayolingana na upande wa kulia wa mlinganyo.\n\nMfano wa matumizi:\nassert(f_14(\"0000\") == 4);\n*/\nint f_14(const char* data_str)", "tr": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/*\nBir dizi sayıyı çözerek deseni ortaya çıkarın ve her bir rakamın temsil ettiği gerçek değerleri anlayın.\n\nReferans için sağlanan denklemler:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParametreler:\n- data_str: Bir dizi sayıyı temsil eden sabit karakter dizisi (C tarzı dize). Uzunluğu 100'ü geçmez.\n\nDöndürür:\nint: Her veri dizisinin denklemin sağ tarafına karşılık gelen sonucu.\n\nÖrnek kullanım:\nassert(f_14(\"0000\") == 4);\n*/\nint f_14(const char* data_str)", "vi": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/*\nGiải mã một chuỗi số để tiết lộ mẫu và hiểu các giá trị thực tế mà mỗi chữ số đại diện.\n\nCác phương trình được cung cấp để tham khảo:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nTham số:\n- data_str: Một mảng ký tự hằng số (chuỗi kiểu C) đại diện cho một chuỗi số. Độ dài không vượt quá 100.\n\nTrả về:\nint: Kết quả của mỗi chuỗi dữ liệu tương ứng với vế phải của phương trình.\n\nVí dụ sử dụng:\nassert(f_14(\"0000\") == 4);\n*/\nint f_14(const char* data_str)", "id": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/*\nDekode serangkaian angka untuk mengungkap pola dan memahami nilai sebenarnya \nyang diwakili setiap digit.\n\nPersamaan yang disediakan untuk referensi:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParameter:\n- data_str: Sebuah array karakter konstan (string gaya C) yang mewakili serangkaian angka. Panjang tidak melebihi 100.\n\nMengembalikan:\nint: Hasil dari setiap string data yang sesuai dengan sisi kanan persamaan.\n\nContoh penggunaan:\nassert(f_14(\"0000\") == 4);\n*/\nint f_14(const char* data_str)", "ja": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/*\n一連の数字をデコードしてパターンを明らかにし、各桁が表す実際の値を理解します。\n\n参照用に提供された方程式:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nパラメータ:\n- data_str: 一連の数字を表す定数文字配列（Cスタイルの文字列）。長さは100を超えません。\n\n戻り値:\nint: 方程式の右辺に対応する各データ文字列の結果。\n\n使用例:\nassert(f_14(\"0000\") == 4);\n*/\nint f_14(const char* data_str)", "ko": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/*\n숫자 시리즈를 해독하여 패턴을 밝히고 각 자릿수가 나타내는 실제 값을 이해합니다.\n\n참조를 위한 방정식:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\n매개변수:\n- data_str: 숫자 시리즈를 나타내는 상수 문자 배열(C 스타일 문자열). 길이는 100을 초과하지 않습니다.\n\n반환:\nint: 방정식의 오른쪽에 해당하는 각 데이터 문자열의 결과.\n\n사용 예:\nassert(f_14(\"0000\") == 4);\n*/\nint f_14(const char* data_str)", "ml": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/*\nസംഖ്യകളുടെ ഒരു പരമ്പര ഡികോഡ് ചെയ്ത് ഓരോ അക്കവും പ്രതിനിധാനം ചെയ്യുന്ന യഥാർത്ഥ മൂല്യങ്ങൾ മനസ്സിലാക്കുക.\n\nഉദാഹരണത്തിന് നൽകിയ സമവാക്യങ്ങൾ:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nപാരാമീറ്ററുകൾ:\n- data_str: സംഖ്യകളുടെ ഒരു പരമ്പര പ്രതിനിധീകരിക്കുന്ന സ്ഥിരമായ പ്രതീക അണിയറ (സി-ശൈലി സ്ട്രിംഗ്). നീളം 100-നെ കവിയില്ല.\n\nമടക്കാൻ:\nint: സമവാക്യത്തിന്റെ വലതുവശത്ത് അനുബന്ധിക്കുന്ന ഓരോ ഡാറ്റാ സ്ട്രിംഗിന്റെയും ഫലം.\n\nഉദാഹരണ ഉപയോഗം:\nassert(f_14(\"0000\") == 4);\n*/\nint f_14(const char* data_str)", "fa": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/*\nیک سری از اعداد را رمزگشایی کنید تا الگو را آشکار کرده و مقادیر واقعی که هر رقم نشان می‌دهد را بفهمید.\n\nمعادلات برای مرجع ارائه شده‌اند:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nپارامترها:\n- data_str: یک آرایه کاراکتری ثابت (رشته به سبک C) که نمایانگر یک سری از اعداد است. طول آن از 100 تجاوز نمی‌کند.\n\nبازگشت:\nint: نتیجه هر رشته داده که با سمت راست معادله مطابقت دارد.\n\nمثال استفاده:\nassert(f_14(\"0000\") == 4);\n*/\nint f_14(const char* data_str)"}, "canonical_solution": "{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < std::strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}", "instruction": {"en": "int f_14(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < std::strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.", "sq": "int f_14(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < std::strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit CPP në shqip duke përdorur maksimumi 500 karaktere.", "hy": "int f_14(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < std::strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}\n\nՏվեք CPP կոդի համառոտ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "int f_14(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < std::strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}\n\nসিপিপি কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।", "bg": "int f_14(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < std::strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}\n\nПредоставете кратко описание на CPP кода на естествен език (docstring) на български, използвайки най-много 500 знака.", "zh": "int f_14(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < std::strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}\n\n请用中文为以下CPP代码提供一个简洁的自然语言描述（文档字符串），字数不超过500个字符。", "fr": "int f_14(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < std::strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}\n\nFournissez une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.", "de": "int f_14(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < std::strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "int f_14(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < std::strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar CPP a cikin Hausa ta amfani da haruffa 500 kacal.", "hi": "int f_14(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < std::strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।", "hu": "int f_14(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < std::strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a CPP kódról magyarul, legfeljebb 500 karakterben.", "es": "int f_14(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < std::strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}\n\nProporciona una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando como máximo 500 caracteres.", "arb": "int f_14(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < std::strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية بلغة C++ باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "int f_14(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < std::strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "int f_14(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < std::strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}\n\nAşağıdaki CPP kodunun Türkçe'de en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.", "vi": "int f_14(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < std::strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt, không quá 500 ký tự.", "id": "int f_14(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < std::strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode CPP dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "int f_14(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < std::strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}\n\n以下のCPPコードの自然言語による簡潔な説明（ドックストリング）を日本語で500文字以内で提供してください。", "ko": "int f_14(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < std::strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}\n\n다음 CPP 코드의 동작을 설명하는 간결한 자연어 설명(도크스트링)을 한국어로 작성하세요. 최대 500자 이내로 작성하십시오.", "ml": "int f_14(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < std::strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}\n\nCPP കോഡ് ഉപയോഗിച്ച് 500 അക്ഷരങ്ങളിൽ കൂടുതൽ അല്ലാത്ത ഒരു സംക്ഷിപ്ത സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) മലയാളത്തിൽ നൽകുക.", "fa": "int f_14(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < std::strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}\n\nتوضیح مختصری به زبان طبیعی (docstring) از کد CPP به زبان فارسی ارائه دهید که حداکثر ۵۰۰ کاراکتر باشد."}, "level": "", "test": "int main() {\n    // Assert basic provided test cases\n    assert(f_14(\"0000\") == 4);\n    assert(f_14(\"8888\") == 8);\n    assert(f_14(\"1234\") == 1);\n    assert(f_14(\"5678\") == 3);\n    assert(f_14(\"9012\") == 2);\n    assert(f_14(\"1357\") == 0);\n    assert(f_14(\"2468\") == 4);\n\n    // Assert additional test cases\n    assert(f_14(\"9999\") == 4);\n    assert(f_14(\"1111\") == 0);\n    assert(f_14(\"2222\") == 0);\n    assert(f_14(\"3333\") == 0);\n    assert(f_14(\"4444\") == 4);\n    assert(f_14(\"5555\") == 0);\n    assert(f_14(\"6666\") == 4);\n    assert(f_14(\"7777\") == 0);\n    assert(f_14(\"0001\") == 3);\n    assert(f_14(\"2301\") == 1);\n\n    // Indicate that all tests passed\n    // std::cout << \"All tests passed successfully!\" << std::endl;\n\n    return 0;\n}", "entry_point": "f_14", "signature": "int f_14(const char* data_str)", "docstring": {"en": "Decode a series of numbers to reveal the pattern and understand the actual values each digit represents.\n\nEquations provided for reference:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParameters:\n- data_str: A constant character array (C-style string) representing a series of numbers. Length does not exceed 100.\n\nReturns:\nint: The result of each data string corresponding to the right-hand side of the equation.\n\nExample usage:\nassert(f_14(\"0000\") == 4);", "sq": "Dekodoni një seri numrash për të zbuluar modelin dhe për të kuptuar vlerat aktuale që përfaqëson secila shifër.\n\nEkuacionet e dhëna për referencë:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParametrat:\n- data_str: Një varg karakteresh konstant (string në stilin C) që përfaqëson një seri numrash. Gjatësia nuk tejkalon 100.\n\nKthen:\nint: Rezultati i secilit varg të dhënash që korrespondon me anën e djathtë të ekuacionit.\n\nShembull përdorimi:\nassert(f_14(\"0000\") == 4);", "hy": "Թվերի շարք ապակոդավորել՝ բացահայտելու օրինաչափությունը և հասկանալու, թե իրականում ինչ արժեքներ են ներկայացնում յուրաքանչյուր թվանշան։\n\nՀաշվարկները տրված են հղման համար.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nՊարամետրեր:\n- data_str: Հաստատուն սիմվոլների զանգված (C ոճի տող), որը ներկայացնում է թվերի շարք։ Երկարությունը չի գերազանցում 100-ը։\n\nՎերադարձնում է:\nint: Յուրաքանչյուր տվյալների տողի արդյունքը, որը համապատասխանում է հավասարման աջ կողմին։\n\nՕրինակ օգտագործում:\nassert(f_14(\"0000\") == 4);", "bn": "সংখ্যার একটি সিরিজ ডিকোড করুন প্যাটার্নটি প্রকাশ করতে এবং প্রতিটি অঙ্কের প্রকৃত মানগুলি বোঝার জন্য।\n\nতুলনার জন্য প্রদত্ত সমীকরণ:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nপ্যারামিটারসমূহ:\n- data_str: একটি ধ্রুব চরিত্রের অ্যারে (সি-স্টাইল স্ট্রিং) যা সংখ্যার একটি সিরিজ উপস্থাপন করে। দৈর্ঘ্য 100 অতিক্রম করে না।\n\nফেরত দেয়:\nint: প্রতিটি ডেটা স্ট্রিংয়ের ফলাফল যা সমীকরণের ডানপাশের সাথে মিলে যায়।\n\nব্যবহারের উদাহরণ:\nassert(f_14(\"0000\") == 4);", "bg": "Декодирайте серия от числа, за да разкриете модела и да разберете действителните стойности, които всяка цифра представлява.\n\nУравнения, предоставени за справка:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nПараметри:\n- data_str: Константен масив от символи (стринг в стил C), представляващ серия от числа. Дължината не надвишава 100.\n\nВръща:\nint: Резултатът от всеки низ от данни, съответстващ на дясната страна на уравнението.\n\nПример за използване:\nassert(f_14(\"0000\") == 4);", "zh": "解码一系列数字以揭示模式并理解每个数字代表的实际值。\n\n提供的方程用于参考：\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\n参数：\n- data_str: 一个常量字符数组（C风格字符串），表示一系列数字。长度不超过100。\n\n返回：\nint: 每个数据字符串对应方程右侧的结果。\n\n示例用法：\nassert(f_14(\"0000\") == 4);", "fr": "Décoder une série de chiffres pour révéler le motif et comprendre les valeurs réelles que chaque chiffre représente.\n\nÉquations fournies à titre de référence :\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParamètres :\n- data_str : Un tableau de caractères constant (chaîne de style C) représentant une série de chiffres. La longueur ne dépasse pas 100.\n\nRenvoie :\nint : Le résultat de chaque chaîne de données correspondant au côté droit de l'équation.\n\nExemple d'utilisation :\nassert(f_14(\"0000\") == 4);", "de": "Dekodiere eine Serie von Zahlen, um das Muster zu erkennen und die tatsächlichen Werte zu verstehen, die jede Ziffer darstellt.\n\nGleichungen zur Referenz:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParameter:\n- data_str: Ein konstantes Zeichenarray (C-Style-String), das eine Serie von Zahlen darstellt. Die Länge überschreitet nicht 100.\n\nRückgabewert:\nint: Das Ergebnis jeder Datenzeichenkette, das der rechten Seite der Gleichung entspricht.\n\nBeispielverwendung:\nassert(f_14(\"0000\") == 4);", "ha": "Fassara jerin lambobi don bayyana tsarin kuma fahimtar ainihin ƙimar da kowace lamba ke wakilta.\n\nLissafin da aka bayar don tunani:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nSigogi:\n- data_str: Wata madaidaiciyar jerin haruffa (C-style string) da ke wakiltar jerin lambobi. Tsawon ba ya wuce 100.\n\nAbubuwan da ake dawowa da su:\nint: Sakamakon kowanne jerin bayanai da ya dace da gefen dama na lissafin.\n\nMisalin amfani:\nassert(f_14(\"0000\") == 4);", "hi": "संख्याओं की एक श्रृंखला को डिकोड करें ताकि पैटर्न का पता चल सके और समझ सकें कि प्रत्येक अंक का वास्तविक मूल्य क्या है।\n\nसंदर्भ के लिए समीकरण दिए गए हैं:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nपैरामीटर्स:\n- data_str: एक स्थिर वर्ण सरणी (C-शैली स्ट्रिंग) जो संख्याओं की एक श्रृंखला का प्रतिनिधित्व करती है। लंबाई 100 से अधिक नहीं है।\n\nवापसी:\nint: प्रत्येक डेटा स्ट्रिंग का परिणाम जो समीकरण के दाहिने हिस्से से मेल खाता है।\n\nउदाहरण उपयोग:\nassert(f_14(\"0000\") == 4);", "hu": "Dekódoljon egy számok sorozatát, hogy felfedje a mintát, és megértse, hogy az egyes számjegyek valójában milyen értékeket képviselnek.\n\nAz egyenletek referenciaként szolgálnak:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParaméterek:\n- data_str: Egy állandó karaktertömb (C-stílusú string), amely számok sorozatát képviseli. Hossza nem haladja meg a 100-at.\n\nVisszatérési érték:\nint: Az egyes adat stringek eredménye, amely megfelel az egyenlet jobb oldalának.\n\nPélda használat:\nassert(f_14(\"0000\") == 4);", "es": "Decodificar una serie de números para revelar el patrón y entender los valores reales que representa cada dígito.\n\nEcuaciones proporcionadas como referencia:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParámetros:\n- data_str: Una matriz de caracteres constante (cadena de estilo C) que representa una serie de números. La longitud no excede de 100.\n\nDevuelve:\nint: El resultado de cada cadena de datos correspondiente al lado derecho de la ecuación.\n\nEjemplo de uso:\nassert(f_14(\"0000\") == 4);", "arb": "فك سلسلة من الأرقام للكشف عن النمط وفهم القيم الفعلية التي يمثلها كل رقم.\n\nالمعادلات المقدمة للرجوع إليها:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nالمعلمات:\n- data_str: مصفوفة ثابتة من الأحرف (سلسلة نمط C) تمثل سلسلة من الأرقام. الطول لا يتجاوز 100.\n\nالقيم المعادة:\nint: نتيجة كل سلسلة بيانات تتوافق مع الجانب الأيمن من المعادلة.\n\nمثال على الاستخدام:\nassert(f_14(\"0000\") == 4);", "sw": "Fasiri mfululizo wa nambari ili kufichua muundo na kuelewa thamani halisi ambayo kila tarakimu inawakilisha.\n\nMlinganyo uliotolewa kwa marejeleo:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nVigezo:\n- data_str: Safu ya tabia ya kudumu (mfululizo wa herufi za mtindo wa C) inayowakilisha mfululizo wa nambari. Urefu hauzidi 100.\n\nInarejesha:\nint: Matokeo ya kila mfululizo wa data yanayolingana na upande wa kulia wa mlinganyo.\n\nMfano wa matumizi:\nassert(f_14(\"0000\") == 4);", "tr": "Decode bir dizi numarayı, deseni ortaya çıkarmak ve her bir rakamın temsil ettiği gerçek değerleri anlamak için çöz.\n\nReferans için sağlanan denklemler:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParametreler:\n- data_str: Bir dizi numarayı temsil eden sabit bir karakter dizisi (C tarzı string). Uzunluk 100'ü geçmez.\n\nDöndürülenler:\nint: Her bir veri dizisinin denklemin sağ tarafına karşılık gelen sonucu.\n\nÖrnek kullanım:\nassert(f_14(\"0000\") == 4);", "vi": "Giải mã một chuỗi số để tiết lộ mô hình và hiểu các giá trị thực mà mỗi chữ số đại diện.\n\nCác phương trình được cung cấp để tham khảo:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nTham số:\n- data_str: Một mảng ký tự hằng số (chuỗi kiểu C) đại diện cho một chuỗi số. Độ dài không vượt quá 100.\n\nTrả về:\nint: Kết quả của mỗi chuỗi dữ liệu tương ứng với phía bên phải của phương trình.\n\nVí dụ sử dụng:\nassert(f_14(\"0000\") == 4);", "id": "Menguraikan serangkaian angka untuk mengungkap pola dan memahami nilai sebenarnya yang diwakili setiap digit.\n\nPersamaan yang disediakan untuk referensi:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParameter:\n- data_str: Sebuah array karakter konstan (string gaya C) yang mewakili serangkaian angka. Panjangnya tidak melebihi 100.\n\nMengembalikan:\nint: Hasil dari setiap string data yang sesuai dengan sisi kanan persamaan.\n\nContoh penggunaan:\nassert(f_14(\"0000\") == 4);", "ja": "数字の一連のパターンをデコードして、各桁が表す実際の値を理解します。\n\n参考用の方程式:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nパラメータ:\n- data_str: 一連の数字を表す定数文字配列（Cスタイルの文字列）。長さは100を超えません。\n\n戻り値:\nint: 方程式の右辺に対応する各データ文字列の結果。\n\n使用例:\nassert(f_14(\"0000\") == 4);", "ko": "숫자 시리즈를 해독하여 패턴을 밝히고 각 숫자가 나타내는 실제 값을 이해합니다.\n\n참조용으로 제공된 방정식:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\n매개변수:\n- data_str: 숫자 시리즈를 나타내는 상수 문자 배열(C 스타일 문자열). 길이는 100을 초과하지 않습니다.\n\n반환:\nint: 방정식의 오른쪽에 해당하는 각 데이터 문자열의 결과입니다.\n\n사용 예:\nassert(f_14(\"0000\") == 4);", "ml": "സംഖ്യകളുടെ ഒരു പരമ്പര ഡികോഡ് ചെയ്ത് ഓരോ അക്കവും പ്രതിനിധാനം ചെയ്യുന്ന യഥാർത്ഥ മൂല്യങ്ങൾ മനസ്സിലാക്കുക.\n\nസൂചികകൾക്കായി നൽകിയിരിക്കുന്ന സമവാക്യങ്ങൾ:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nപാരാമീറ്ററുകൾ:\n- data_str: അക്കങ്ങളുടെ ഒരു നിരയെ പ്രതിനിധീകരിക്കുന്ന ഒരു സ്ഥിരമായ കാരക്ടർ നിര (സി-ശൈലി സ്ട്രിംഗ്). നീളം 100-നെ മിച്ചം ചെയ്യില്ല.\n\nമടക്കം:\nint: സമവാക്യത്തിന്റെ വലതുഭാഗത്തോട് അനുബന്ധിക്കുന്ന ഓരോ ഡാറ്റ സ്ട്രിംഗിന്റെയും ഫലം.\n\nഉദാഹരണ ഉപയോഗം:\nassert(f_14(\"0000\") == 4);", "fa": "یک سری از اعداد را رمزگشایی کنید تا الگو را آشکار کرده و مقادیر واقعی که هر رقم نشان می‌دهد را بفهمید.\n\nمعادلات ارائه شده برای مرجع:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nپارامترها:\n- data_str: یک آرایه کاراکتری ثابت (رشته به سبک C) که یک سری از اعداد را نشان می‌دهد. طول آن از 100 تجاوز نمی‌کند.\n\nبازگشت:\nint: نتیجه هر رشته داده که به سمت راست معادله مربوط می‌شود.\n\nمثال استفاده:\nassert(f_14(\"0000\") == 4);"}}
{"task_id": "CPP/15", "prompt": {"en": "#include <cassert>\n#include <iostream>\n/**\n * Counts the number of different coloring methods for n squares with m colors,\n * considering the requirement that adjacent squares and the first/last squares\n * must have different colors.\n * \n * @param n The number of squares.\n * @param m The number of colors.\n * @return The count of different coloring methods satisfying the specified conditions.\n *         The result is modulo 1000003.\n *\n * Examples:\n * f_15(1,1) returns 1\n * f_15(2,2) returns 2\n */\nint f_15(int n, int m)", "sq": "#include <cassert>\n#include <iostream>\n/**\n * Numëron numrin e metodave të ndryshme të ngjyrosjes për n katrorë me m ngjyra,\n * duke marrë parasysh kërkesën që katrorët ngjitur dhe katrorët e parë/fundit\n * duhet të kenë ngjyra të ndryshme.\n * \n * @param n Numri i katrorëve.\n * @param m Numri i ngjyrave.\n * @return Numri i metodave të ndryshme të ngjyrosjes që plotësojnë kushtet e specifikuara.\n *         Rezultati është modulo 1000003.\n *\n * Shembuj:\n * f_15(1,1) kthen 1\n * f_15(2,2) kthen 2\n */\nint f_15(int n, int m)", "hy": "#include <cassert>\n#include <iostream>\n/**\n * Հաշվում է քառակուսիների n քանակի տարբեր գունավորման մեթոդների քանակը m գույներով,\n * հաշվի առնելով այն պահանջը, որ հարակից քառակուսիները և առաջին/վերջին քառակուսիները\n * պետք է ունենան տարբեր գույներ։\n * \n * @param n Քառակուսիների քանակը։\n * @param m Գույների քանակը։\n * @return Տարբեր գունավորման մեթոդների քանակը, որը բավարարում է նշված պայմաններին։\n *         Արդյունքը մոդուլո 1000003։\n *\n * Օրինակներ:\n * f_15(1,1) վերադարձնում է 1\n * f_15(2,2) վերադարձնում է 2\n */\nint f_15(int n, int m)", "bn": "#include <cassert>\n#include <iostream>\n/**\n * nটি বর্গক্ষেত্রের জন্য mটি রঙের বিভিন্ন রঙ করার পদ্ধতির সংখ্যা গণনা করে,\n * শর্তটি বিবেচনা করে যে সংলগ্ন বর্গক্ষেত্র এবং প্রথম/শেষ বর্গক্ষেত্রের রঙ ভিন্ন হতে হবে।\n * \n * @param n বর্গক্ষেত্রের সংখ্যা।\n * @param m রঙের সংখ্যা।\n * @return নির্দিষ্ট শর্তগুলি পূরণ করে এমন বিভিন্ন রঙ করার পদ্ধতির সংখ্যা।\n *         ফলাফলটি 1000003 দ্বারা মডুলো।\n *\n * উদাহরণ:\n * f_15(1,1) 1 রিটার্ন করে\n * f_15(2,2) 2 রিটার্ন করে\n */\nint f_15(int n, int m)", "bg": "#include <cassert>\n#include <iostream>\n/**\n * Брои броя на различните методи за оцветяване на n квадрата с m цвята,\n * като се има предвид изискването съседните квадрати и първият/последният квадрат\n * да имат различни цветове.\n * \n * @param n Броят на квадратите.\n * @param m Броят на цветовете.\n * @return Броят на различните методи за оцветяване, които удовлетворяват посочените условия.\n *         Резултатът е модуло 1000003.\n *\n * Примери:\n * f_15(1,1) връща 1\n * f_15(2,2) връща 2\n */\nint f_15(int n, int m)", "zh": "#include <cassert>\n#include <iostream>\n/**\n * 计算使用 m 种颜色为 n 个方块着色的不同方法数，\n * 考虑到相邻方块以及第一个/最后一个方块必须有不同的颜色。\n * \n * @param n 方块的数量。\n * @param m 颜色的数量。\n * @return 满足指定条件的不同着色方法的数量。\n *         结果对 1000003 取模。\n *\n * 例子:\n * f_15(1,1) 返回 1\n * f_15(2,2) 返回 2\n */\nint f_15(int n, int m)", "fr": "#include <cassert>\n#include <iostream>\n/**\n * Compte le nombre de méthodes de coloration différentes pour n carrés avec m couleurs,\n * en considérant l'exigence que les carrés adjacents et les premiers/derniers carrés\n * doivent avoir des couleurs différentes.\n * \n * @param n Le nombre de carrés.\n * @param m Le nombre de couleurs.\n * @return Le compte des différentes méthodes de coloration satisfaisant les conditions spécifiées.\n *         Le résultat est modulo 1000003.\n *\n * Exemples:\n * f_15(1,1) returns 1\n * f_15(2,2) returns 2\n */\nint f_15(int n, int m)", "de": "#include <cassert>\n#include <iostream>\n/**\n * Zählt die Anzahl der verschiedenen Färbemethoden für n Quadrate mit m Farben,\n * unter Berücksichtigung der Anforderung, dass benachbarte Quadrate und die ersten/letzten Quadrate\n * unterschiedliche Farben haben müssen.\n * \n * @param n Die Anzahl der Quadrate.\n * @param m Die Anzahl der Farben.\n * @return Die Anzahl der verschiedenen Färbemethoden, die die angegebenen Bedingungen erfüllen.\n *         Das Ergebnis ist modulo 1000003.\n *\n * Beispiele:\n * f_15(1,1) gibt 1 zurück\n * f_15(2,2) gibt 2 zurück\n */\nint f_15(int n, int m)", "ha": "#include <cassert>\n#include <iostream>\n/**\n * Yana ƙididdige adadin hanyoyin launi daban-daban don murabba'i n tare da launuka m,\n * la'akari da buƙatar cewa murabba'i masu makwabtaka da murabba'i na farko/na ƙarshe\n * dole ne su sami launuka daban-daban.\n * \n * @param n Adadin murabba'ai.\n * @param m Adadin launuka.\n * @return Adadin hanyoyin launi daban-daban da suka cika sharuɗɗan da aka fayyace.\n *         Sakamakon yana cikin modulo 1000003.\n *\n * Misalai:\n * f_15(1,1) yana dawowa 1\n * f_15(2,2) yana dawowa 2\n */\nint f_15(int n, int m)", "hi": "#include <cassert>\n#include <iostream>\n/**\n * n वर्गों के लिए m रंगों के विभिन्न रंगने के तरीकों की संख्या गिनता है,\n * इस आवश्यकता को ध्यान में रखते हुए कि आसन्न वर्ग और पहले/अंतिम वर्ग\n * के रंग अलग-अलग होने चाहिए।\n * \n * @param n वर्गों की संख्या।\n * @param m रंगों की संख्या।\n * @return निर्दिष्ट शर्तों को संतुष्ट करने वाले विभिन्न रंगने के तरीकों की संख्या।\n *         परिणाम 1000003 के मापांक में है।\n *\n * उदाहरण:\n * f_15(1,1) 1 लौटाता है\n * f_15(2,2) 2 लौटाता है\n */\nint f_15(int n, int m)", "hu": "#include <cassert>\n#include <iostream>\n/**\n * Megszámolja az n négyzet m színnel történő különböző színezési módszereit,\n * figyelembe véve azt a követelményt, hogy a szomszédos négyzetek és az első/utolsó négyzetek\n * különböző színűek legyenek.\n * \n * @param n A négyzetek száma.\n * @param m A színek száma.\n * @return A különböző színezési módszerek száma, amelyek megfelelnek a megadott feltételeknek.\n *         Az eredmény modulo 1000003.\n *\n * Példák:\n * f_15(1,1) visszaadja 1\n * f_15(2,2) visszaadja 2\n */\nint f_15(int n, int m)", "es": "#include <cassert>\n#include <iostream>\n/**\n * Cuenta el número de diferentes métodos de coloreado para n cuadrados con m colores,\n * considerando el requisito de que los cuadrados adyacentes y los primeros/últimos cuadrados\n * deben tener colores diferentes.\n * \n * @param n El número de cuadrados.\n * @param m El número de colores.\n * @return El conteo de diferentes métodos de coloreado que satisfacen las condiciones especificadas.\n *         El resultado es módulo 1000003.\n *\n * Ejemplos:\n * f_15(1,1) returns 1\n * f_15(2,2) returns 2\n */\nint f_15(int n, int m)", "arb": "#include <cassert>\n#include <iostream>\n/**\n * يحسب عدد طرق التلوين المختلفة لـ n من المربعات باستخدام m من الألوان،\n * مع مراعاة الشرط بأن المربعات المتجاورة والمربعات الأولى/الأخيرة\n * يجب أن تكون بألوان مختلفة.\n * \n * @param n عدد المربعات.\n * @param m عدد الألوان.\n * @return عدد طرق التلوين المختلفة التي تلبي الشروط المحددة.\n *         النتيجة تكون مخرجة بنسبة 1000003.\n *\n * أمثلة:\n * f_15(1,1) returns 1\n * f_15(2,2) returns 2\n */\nint f_15(int n, int m)", "sw": "#include <cassert>\n#include <iostream>\n/**\n * Inahesabu idadi ya mbinu tofauti za kupaka rangi miraba n kwa rangi m,\n * kwa kuzingatia hitaji kwamba miraba iliyo karibu na miraba ya kwanza/mwisho\n * lazima iwe na rangi tofauti.\n * \n * @param n Idadi ya miraba.\n * @param m Idadi ya rangi.\n * @return Idadi ya mbinu tofauti za kupaka rangi zinazokidhi masharti yaliyobainishwa.\n *         Matokeo ni modulo 1000003.\n *\n * Mifano:\n * f_15(1,1) inarudisha 1\n * f_15(2,2) inarudisha 2\n */\nint f_15(int n, int m)", "tr": "#include <cassert>\n#include <iostream>\n/**\n * n kare için m renk ile farklı boyama yöntemlerinin sayısını sayar,\n * bitişik karelerin ve ilk/son karelerin farklı renklere sahip olması\n * gerektiği şartını göz önünde bulundurur.\n * \n * @param n Karelerin sayısı.\n * @param m Renklerin sayısı.\n * @return Belirtilen koşulları karşılayan farklı boyama yöntemlerinin sayısı.\n *         Sonuç 1000003 ile mod alınır.\n *\n * Örnekler:\n * f_15(1,1) 1 döndürür\n * f_15(2,2) 2 döndürür\n */\nint f_15(int n, int m)", "vi": "#include <cassert>\n#include <iostream>\n/**\n * Đếm số lượng phương pháp tô màu khác nhau cho n ô vuông với m màu,\n * với điều kiện rằng các ô liền kề và ô đầu/cuối phải có màu khác nhau.\n * \n * @param n Số lượng ô vuông.\n * @param m Số lượng màu.\n * @return Số lượng phương pháp tô màu khác nhau thỏa mãn các điều kiện đã chỉ định.\n *         Kết quả được lấy modulo 1000003.\n *\n * Ví dụ:\n * f_15(1,1) trả về 1\n * f_15(2,2) trả về 2\n */\nint f_15(int n, int m)", "id": "#include <cassert>\n#include <iostream>\n/**\n * Menghitung jumlah metode pewarnaan yang berbeda untuk n kotak dengan m warna,\n * dengan mempertimbangkan persyaratan bahwa kotak yang bersebelahan dan kotak pertama/terakhir\n * harus memiliki warna yang berbeda.\n * \n * @param n Jumlah kotak.\n * @param m Jumlah warna.\n * @return Jumlah metode pewarnaan yang berbeda yang memenuhi kondisi yang ditentukan.\n *         Hasilnya adalah modulo 1000003.\n *\n * Contoh:\n * f_15(1,1) mengembalikan 1\n * f_15(2,2) mengembalikan 2\n */\nint f_15(int n, int m)", "ja": "#include <cassert>\n#include <iostream>\n/**\n * n個の正方形をm色で塗り分ける方法の数を数えます。\n * 隣接する正方形および最初と最後の正方形が異なる色である必要があります。\n * \n * @param n 正方形の数。\n * @param m 色の数。\n * @return 指定された条件を満たす異なる塗り分け方法の数。\n *         結果は1000003での剰余です。\n *\n * 例:\n * f_15(1,1) は1を返します\n * f_15(2,2) は2を返します\n */\nint f_15(int n, int m)", "ko": "#include <cassert>\n#include <iostream>\n/**\n * n개의 사각형을 m개의 색상으로 칠하는 서로 다른 방법의 수를 계산합니다.\n * 인접한 사각형과 첫 번째/마지막 사각형은 다른 색상이어야 한다는 요구 사항을 고려합니다.\n * \n * @param n 사각형의 수.\n * @param m 색상의 수.\n * @return 지정된 조건을 만족하는 서로 다른 색칠 방법의 수를 반환합니다.\n *         결과는 1000003으로 나눈 나머지입니다.\n *\n * 예시:\n * f_15(1,1) returns 1\n * f_15(2,2) returns 2\n */\nint f_15(int n, int m)", "ml": "#include <cassert>\n#include <iostream>\n/**\n * n ചതുരങ്ങൾ m നിറങ്ങളാൽ നിറയ്ക്കാനുള്ള വ്യത്യസ്തമായ നിറപ്പെടുത്തൽ\n * രീതികളുടെ എണ്ണം എണ്ണുന്നു, ചേർന്നിരിക്കുന്ന ചതുരങ്ങൾക്കും ആദ്യ/അവസാന\n * ചതുരങ്ങൾക്കും വ്യത്യസ്ത നിറങ്ങൾ വേണമെന്ന ആവശ്യകത പരിഗണിക്കുന്നു.\n * \n * @param n ചതുരങ്ങളുടെ എണ്ണം.\n * @param m നിറങ്ങളുടെ എണ്ണം.\n * @return നിർദ്ദിഷ്ട വ്യവസ്ഥകൾ പാലിക്കുന്ന വ്യത്യസ്ത നിറപ്പെടുത്തൽ\n *         രീതികളുടെ എണ്ണം. ഫലം 1000003 ന്റെ മോഡുലോ ആണ്.\n *\n * ഉദാഹരണങ്ങൾ:\n * f_15(1,1) 1 മടക്കുന്നു\n * f_15(2,2) 2 മടക്കുന്നു\n */\nint f_15(int n, int m)", "fa": "#include <cassert>\n#include <iostream>\n/**\n * تعداد روش‌های مختلف رنگ‌آمیزی برای n مربع با m رنگ را محاسبه می‌کند،\n * با در نظر گرفتن این شرط که مربع‌های مجاور و مربع‌های اول/آخر باید رنگ‌های متفاوتی داشته باشند.\n * \n * @param n تعداد مربع‌ها.\n * @param m تعداد رنگ‌ها.\n * @return تعداد روش‌های مختلف رنگ‌آمیزی که شرایط مشخص شده را برآورده می‌کند.\n *         نتیجه به صورت مدولوی 1000003 است.\n *\n * Examples:\n * f_15(1,1) returns 1\n * f_15(2,2) returns 2\n */\nint f_15(int n, int m)"}, "canonical_solution": "{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return static_cast<long long>(m) * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = static_cast<long long>(m) * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = static_cast<long long>(f[2]) * (m - 2) % 1000003;\n    for(int i = 4; i <= n; ++i) {\n        f[i] = (static_cast<long long>(f[i - 1]) * (m - 2) % 1000003 +\n                static_cast<long long>(f[i - 2]) * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}", "instruction": {"en": "int f_15(int n, int m)\n{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return static_cast<long long>(m) * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = static_cast<long long>(m) * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = static_cast<long long>(f[2]) * (m - 2) % 1000003;\n    for(int i = 4; i <= n; ++i) {\n        f[i] = (static_cast<long long>(f[i - 1]) * (m - 2) % 1000003 +\n                static_cast<long long>(f[i - 2]) * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.", "sq": "int f_15(int n, int m)\n{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return static_cast<long long>(m) * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = static_cast<long long>(m) * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = static_cast<long long>(f[2]) * (m - 2) % 1000003;\n    for(int i = 4; i <= n; ++i) {\n        f[i] = (static_cast<long long>(f[i - 1]) * (m - 2) % 1000003 +\n                static_cast<long long>(f[i - 2]) * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit CPP në shqip duke përdorur maksimumi 500 karaktere.", "hy": "int f_15(int n, int m)\n{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return static_cast<long long>(m) * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = static_cast<long long>(m) * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = static_cast<long long>(f[2]) * (m - 2) % 1000003;\n    for(int i = 4; i <= n; ++i) {\n        f[i] = (static_cast<long long>(f[i - 1]) * (m - 2) % 1000003 +\n                static_cast<long long>(f[i - 2]) * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}\n\nՏվեք կարճ բնութագիր (docstring) CPP կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "int f_15(int n, int m)\n{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return static_cast<long long>(m) * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = static_cast<long long>(m) * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = static_cast<long long>(f[2]) * (m - 2) % 1000003;\n    for(int i = 4; i <= n; ++i) {\n        f[i] = (static_cast<long long>(f[i - 1]) * (m - 2) % 1000003 +\n                static_cast<long long>(f[i - 2]) * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}\n\nসিপিপি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।", "bg": "int f_15(int n, int m)\n{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return static_cast<long long>(m) * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = static_cast<long long>(m) * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = static_cast<long long>(f[2]) * (m - 2) % 1000003;\n    for(int i = 4; i <= n; ++i) {\n        f[i] = (static_cast<long long>(f[i - 1]) * (m - 2) % 1000003 +\n                static_cast<long long>(f[i - 2]) * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}\n\nПредоставете кратко описание на CPP кода на български език, използвайки не повече от 500 знака.", "zh": "int f_15(int n, int m)\n{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return static_cast<long long>(m) * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = static_cast<long long>(m) * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = static_cast<long long>(f[2]) * (m - 2) % 1000003;\n    for(int i = 4; i <= n; ++i) {\n        f[i] = (static_cast<long long>(f[i - 1]) * (m - 2) % 1000003 +\n                static_cast<long long>(f[i - 2]) * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}\n\n请用不超过500个字符的中文为以下CPP代码提供简洁的自然语言描述（文档字符串）。", "fr": "int f_15(int n, int m)\n{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return static_cast<long long>(m) * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = static_cast<long long>(m) * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = static_cast<long long>(f[2]) * (m - 2) % 1000003;\n    for(int i = 4; i <= n; ++i) {\n        f[i] = (static_cast<long long>(f[i - 1]) * (m - 2) % 1000003 +\n                static_cast<long long>(f[i - 2]) * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}\n\nFournissez une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.", "de": "int f_15(int n, int m)\n{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return static_cast<long long>(m) * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = static_cast<long long>(m) * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = static_cast<long long>(f[2]) * (m - 2) % 1000003;\n    for(int i = 4; i <= n; ++i) {\n        f[i] = (static_cast<long long>(f[i - 1]) * (m - 2) % 1000003 +\n                static_cast<long long>(f[i - 2]) * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen.", "ha": "int f_15(int n, int m)\n{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return static_cast<long long>(m) * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = static_cast<long long>(m) * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = static_cast<long long>(f[2]) * (m - 2) % 1000003;\n    for(int i = 4; i <= n; ++i) {\n        f[i] = (static_cast<long long>(f[i - 1]) * (m - 2) % 1000003 +\n                static_cast<long long>(f[i - 2]) * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar CPP cikin Hausa ta amfani da haruffa 500 kacal.", "hi": "int f_15(int n, int m)\n{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return static_cast<long long>(m) * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = static_cast<long long>(m) * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = static_cast<long long>(f[2]) * (m - 2) % 1000003;\n    for(int i = 4; i <= n; ++i) {\n        f[i] = (static_cast<long long>(f[i - 1]) * (m - 2) % 1000003 +\n                static_cast<long long>(f[i - 2]) * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।", "hu": "int f_15(int n, int m)\n{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return static_cast<long long>(m) * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = static_cast<long long>(m) * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = static_cast<long long>(f[2]) * (m - 2) % 1000003;\n    for(int i = 4; i <= n; ++i) {\n        f[i] = (static_cast<long long>(f[i - 1]) * (m - 2) % 1000003 +\n                static_cast<long long>(f[i - 2]) * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a CPP kódról magyarul, legfeljebb 500 karakterben.", "es": "int f_15(int n, int m)\n{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return static_cast<long long>(m) * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = static_cast<long long>(m) * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = static_cast<long long>(f[2]) * (m - 2) % 1000003;\n    for(int i = 4; i <= n; ++i) {\n        f[i] = (static_cast<long long>(f[i - 1]) * (m - 2) % 1000003 +\n                static_cast<long long>(f[i - 2]) * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando como máximo 500 caracteres.", "arb": "int f_15(int n, int m)\n{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return static_cast<long long>(m) * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = static_cast<long long>(m) * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = static_cast<long long>(f[2]) * (m - 2) % 1000003;\n    for(int i = 4; i <= n; ++i) {\n        f[i] = (static_cast<long long>(f[i - 1]) * (m - 2) % 1000003 +\n                static_cast<long long>(f[i - 2]) * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة CPP باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.", "sw": "int f_15(int n, int m)\n{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return static_cast<long long>(m) * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = static_cast<long long>(m) * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = static_cast<long long>(f[2]) * (m - 2) % 1000003;\n    for(int i = 4; i <= n; ++i) {\n        f[i] = (static_cast<long long>(f[i - 1]) * (m - 2) % 1000003 +\n                static_cast<long long>(f[i - 2]) * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "int f_15(int n, int m)\n{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return static_cast<long long>(m) * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = static_cast<long long>(m) * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = static_cast<long long>(f[2]) * (m - 2) % 1000003;\n    for(int i = 4; i <= n; ++i) {\n        f[i] = (static_cast<long long>(f[i - 1]) * (m - 2) % 1000003 +\n                static_cast<long long>(f[i - 2]) * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}\n\nAşağıdaki CPP kodunun Türkçe olarak en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.", "vi": "int f_15(int n, int m)\n{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return static_cast<long long>(m) * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = static_cast<long long>(m) * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = static_cast<long long>(f[2]) * (m - 2) % 1000003;\n    for(int i = 4; i <= n; ++i) {\n        f[i] = (static_cast<long long>(f[i - 1]) * (m - 2) % 1000003 +\n                static_cast<long long>(f[i - 2]) * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự.", "id": "int f_15(int n, int m)\n{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return static_cast<long long>(m) * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = static_cast<long long>(m) * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = static_cast<long long>(f[2]) * (m - 2) % 1000003;\n    for(int i = 4; i <= n; ++i) {\n        f[i] = (static_cast<long long>(f[i - 1]) * (m - 2) % 1000003 +\n                static_cast<long long>(f[i - 2]) * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode CPP dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "int f_15(int n, int m)\n{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return static_cast<long long>(m) * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = static_cast<long long>(m) * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = static_cast<long long>(f[2]) * (m - 2) % 1000003;\n    for(int i = 4; i <= n; ++i) {\n        f[i] = (static_cast<long long>(f[i - 1]) * (m - 2) % 1000003 +\n                static_cast<long long>(f[i - 2]) * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}\n\n以下のCPPコードの簡潔な自然言語による説明（ドックストリング）を日本語で500文字以内で提供してください。", "ko": "int f_15(int n, int m)\n{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return static_cast<long long>(m) * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = static_cast<long long>(m) * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = static_cast<long long>(f[2]) * (m - 2) % 1000003;\n    for(int i = 4; i <= n; ++i) {\n        f[i] = (static_cast<long long>(f[i - 1]) * (m - 2) % 1000003 +\n                static_cast<long long>(f[i - 2]) * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}\n\n다음 CPP 코드의 기능을 설명하는 간결한 자연어 설명(docstring)을 최대 500자 이내로 한국어로 제공하세요.", "ml": "int f_15(int n, int m)\n{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return static_cast<long long>(m) * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = static_cast<long long>(m) * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = static_cast<long long>(f[2]) * (m - 2) % 1000003;\n    for(int i = 4; i <= n; ++i) {\n        f[i] = (static_cast<long long>(f[i - 1]) * (m - 2) % 1000003 +\n                static_cast<long long>(f[i - 2]) * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}\n\nCPP കോഡ് മലയാളത്തിൽ 500 അക്ഷരങ്ങളിൽ കവിയാതെയുള്ള സംക്ഷിപ്തമായ ഒരു സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) നൽകുക.", "fa": "int f_15(int n, int m)\n{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return static_cast<long long>(m) * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = static_cast<long long>(m) * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = static_cast<long long>(f[2]) * (m - 2) % 1000003;\n    for(int i = 4; i <= n; ++i) {\n        f[i] = (static_cast<long long>(f[i - 1]) * (m - 2) % 1000003 +\n                static_cast<long long>(f[i - 2]) * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}\n\nتوضیح مختصر و طبیعی (docstring) از کد CPP را به زبان فارسی با حداکثر ۵۰۰ کاراکتر ارائه دهید."}, "level": "", "test": "int main() {\n    assert(f_15(1, 1) == 1);\n    assert(f_15(2, 2) == 2);\n    assert(f_15(3, 3) == 6);\n    assert(f_15(4, 2) == 2);\n    assert(f_15(1000, 10) == 566585); // We don't have the expected result for this case\n\n    // Additional test cases\n    assert(f_15(2, 3) == 6);\n    assert(f_15(1000, 1000) == 67911);\n    assert(f_15(999, 66) == 501817);\n    assert(f_15(5, 3) == 30); // Example of an expected output\n\n    // std::cout << \"All tests passed!\\n\";\n    return 0;\n}", "entry_point": "f_15", "signature": "int f_15(int n, int m)", "docstring": {"en": "Counts the number of different coloring methods for n squares with m colors, considering the requirement that adjacent squares and the first/last squares must have different colors.\n\n@param n The number of squares.\n@param m The number of colors.\n@return The count of different coloring methods satisfying the specified conditions. The result is modulo 1000003.\n\nExamples:\nf_15(1,1) returns 1\nf_15(2,2) returns 2\n", "sq": "Numëron numrin e metodave të ndryshme të ngjyrosjes për n katrorë me m ngjyra, duke marrë parasysh kërkesën që katrorët ngjitur dhe katrorët e parë/fundit duhet të kenë ngjyra të ndryshme.\n\n@param n Numri i katrorëve.\n@param m Numri i ngjyrave.\n@return Numri i metodave të ndryshme të ngjyrosjes që plotësojnë kushtet e specifikuara. Rezultati është modulo 1000003.\n\nShembuj:\nf_15(1,1) kthen 1\nf_15(2,2) kthen 2", "hy": "Հաշվում է n քառակուսիների տարբեր գունավորման մեթոդների քանակը m գույներով՝ հաշվի առնելով, որ հարակից քառակուսիները և առաջին/վերջին քառակուսիները պետք է ունենան տարբեր գույներ:\n\n@param n Քառակուսիների քանակը։\n@param m Գույների քանակը։\n@return Տարբեր գունավորման մեթոդների քանակը, որոնք բավարարում են նշված պայմանները։ Արդյունքը մոդուլո 1000003 է։\n\nՕրինակներ:\nf_15(1,1) վերադարձնում է 1\nf_15(2,2) վերադարձնում է 2", "bn": "nটি বর্গক্ষেত্রের জন্য mটি রঙের বিভিন্ন রঙ করার পদ্ধতির সংখ্যা গণনা করে, যেখানে শর্ত হল যে সংলগ্ন বর্গক্ষেত্র এবং প্রথম/শেষ বর্গক্ষেত্রের রঙ ভিন্ন হতে হবে।\n\n@param n বর্গক্ষেত্রের সংখ্যা।\n@param m রঙের সংখ্যা।\n@return নির্দিষ্ট শর্তগুলি পূরণকারী বিভিন্ন রঙ করার পদ্ধতির সংখ্যা। ফলাফলটি 1000003 দ্বারা মডুলো।\n\nউদাহরণসমূহ:\nf_15(1,1) 1 ফেরত দেয়\nf_15(2,2) 2 ফেরত দেয়", "bg": "Брои броя на различните методи за оцветяване за n квадрата с m цвята, като се има предвид изискването съседните квадрати и първият/последният квадрат да са с различни цветове.\n\n@param n Броят на квадратите.\n@param m Броят на цветовете.\n@return Броят на различните методи за оцветяване, които удовлетворяват посочените условия. Резултатът е модуло 1000003.\n\nПримери:\nf_15(1,1) връща 1\nf_15(2,2) връща 2", "zh": "计算使用 m 种颜色对 n 个方块进行不同着色的方法数，考虑到相邻方块以及首尾方块必须具有不同颜色的要求。\n\n@param n 方块的数量。\n@param m 颜色的数量。\n@return 满足指定条件的不同着色方法的计数。结果取模 1000003。\n\n示例:\nf_15(1,1) 返回 1\nf_15(2,2) 返回 2", "fr": "Compte le nombre de méthodes de coloration différentes pour n carrés avec m couleurs, en tenant compte de l'exigence selon laquelle les carrés adjacents et les premiers/derniers carrés doivent avoir des couleurs différentes.\n\n@param n Le nombre de carrés.\n@param m Le nombre de couleurs.\n@return Le compte des différentes méthodes de coloration satisfaisant les conditions spécifiées. Le résultat est modulo 1000003.\n\nExemples :\nf_15(1,1) renvoie 1\nf_15(2,2) renvoie 2", "de": "Zählt die Anzahl der verschiedenen Färbemethoden für n Quadrate mit m Farben, unter Berücksichtigung der Anforderung, dass benachbarte Quadrate und die ersten/letzten Quadrate unterschiedliche Farben haben müssen.\n\n@param n Die Anzahl der Quadrate.\n@param m Die Anzahl der Farben.\n@return Die Anzahl der verschiedenen Färbemethoden, die die angegebenen Bedingungen erfüllen. Das Ergebnis ist modulo 1000003.\n\nBeispiele:\nf_15(1,1) gibt 1 zurück\nf_15(2,2) gibt 2 zurück", "ha": "Yana ƙididdige adadin hanyoyin canza launi daban-daban don murabba'i n tare da launuka m, la'akari da buƙatar cewa murabba'i masu makwabtaka da murabba'i na farko/na ƙarshe dole ne su sami launuka daban.\n\n@param n Yawan murabba'ai.\n@param m Yawan launuka.\n@return Adadin hanyoyin canza launi daban-daban da suka cika yanayin da aka fayyace. Sakamakon yana cikin modulo 1000003.\n\nMisalai:\nf_15(1,1) returns 1\nf_15(2,2) returns 2", "hi": "n वर्गों के लिए m रंगों के साथ विभिन्न रंगाई विधियों की संख्या की गणना करता है, इस आवश्यकता को ध्यान में रखते हुए कि आसन्न वर्गों और पहले/अंतिम वर्गों के रंग अलग-अलग होने चाहिए।\n\n@param n वर्गों की संख्या।\n@param m रंगों की संख्या।\n@return निर्दिष्ट शर्तों को संतुष्ट करने वाली विभिन्न रंगाई विधियों की गणना। परिणाम 1000003 के माड्यूलो में है।\n\nउदाहरण:\nf_15(1,1) 1 लौटाता है\nf_15(2,2) 2 लौटाता है", "hu": "Számolja meg az n négyzet különböző színezési módszereinek számát m színnel, figyelembe véve azt a követelményt, hogy a szomszédos négyzetek és az első/utolsó négyzetek különböző színűek legyenek.\n\n@param n A négyzetek száma.\n@param m A színek száma.\n@return A különböző színezési módszerek száma, amelyek megfelelnek a megadott feltételeknek. Az eredmény modulo 1000003.\n\nPéldák:\nf_15(1,1) visszaadja 1\nf_15(2,2) visszaadja 2", "es": "Cuenta el número de diferentes métodos de coloreo para n cuadrados con m colores, considerando el requisito de que los cuadrados adyacentes y los primeros/últimos cuadrados deben tener colores diferentes.\n\n@param n El número de cuadrados.\n@param m El número de colores.\n@return El conteo de diferentes métodos de coloreo que satisfacen las condiciones especificadas. El resultado es módulo 1000003.\n\nEjemplos:\nf_15(1,1) devuelve 1\nf_15(2,2) devuelve 2", "arb": "يحسب عدد طرق التلوين المختلفة لـ n من المربعات باستخدام m من الألوان، مع مراعاة الشرط الذي يتطلب أن تكون المربعات المتجاورة والمربعات الأولى/الأخيرة بألوان مختلفة.\n\n@param n عدد المربعات.\n@param m عدد الألوان.\n@return عدد طرق التلوين المختلفة التي تفي بالشروط المحددة. النتيجة هي باقي القسمة على 1000003.\n\nأمثلة:\nf_15(1,1) returns 1\nf_15(2,2) returns 2", "sw": "Hesabu idadi ya mbinu tofauti za kupaka rangi kwa miraba n yenye rangi m, ukizingatia hitaji kwamba miraba iliyo karibu na miraba ya kwanza/ya mwisho lazima iwe na rangi tofauti.\n\n@param n Idadi ya miraba.\n@param m Idadi ya rangi.\n@return Hesabu ya mbinu tofauti za kupaka rangi zinazokidhi masharti yaliyotajwa. Matokeo ni modulo 1000003.\n\nMifano:\nf_15(1,1) inarudisha 1\nf_15(2,2) inarudisha 2", "tr": "Farklı renklendirme yöntemlerinin sayısını, n kare ve m renk ile, bitişik karelerin ve ilk/son karelerin farklı renklere sahip olması gerekliliğini göz önünde bulundurarak sayar.\n\n@param n Kare sayısı.\n@param m Renk sayısı.\n@return Belirtilen koşulları karşılayan farklı renklendirme yöntemlerinin sayısı. Sonuç 1000003 ile mod alınır.\n\nÖrnekler:\nf_15(1,1) 1 döndürür\nf_15(2,2) 2 döndürür", "vi": "Đếm số lượng phương pháp tô màu khác nhau cho n ô vuông với m màu, xem xét yêu cầu rằng các ô vuông liền kề và ô đầu/ô cuối phải có màu khác nhau.\n\n@param n Số lượng ô vuông.\n@param m Số lượng màu sắc.\n@return Số lượng phương pháp tô màu khác nhau thỏa mãn các điều kiện đã chỉ định. Kết quả được lấy theo modulo 1000003.\n\nVí dụ:\nf_15(1,1) trả về 1\nf_15(2,2) trả về 2", "id": "Menghitung jumlah metode pewarnaan berbeda untuk n kotak dengan m warna, dengan mempertimbangkan persyaratan bahwa kotak yang bersebelahan dan kotak pertama/terakhir harus memiliki warna yang berbeda.\n\n@param n Jumlah kotak.\n@param m Jumlah warna.\n@return Jumlah metode pewarnaan berbeda yang memenuhi kondisi yang ditentukan. Hasilnya adalah modulo 1000003.\n\nContoh:\nf_15(1,1) mengembalikan 1\nf_15(2,2) mengembalikan 2", "ja": "n 個の正方形を m 色で塗り分ける方法の数を数えます。ただし、隣接する正方形および最初と最後の正方形は異なる色でなければならないという条件を考慮します。\n\n@param n 正方形の数。\n@param m 色の数。\n@return 指定された条件を満たす異なる塗り分け方法の数。結果は 1000003 での剰余です。\n\n例:\nf_15(1,1) は 1 を返します\nf_15(2,2) は 2 を返します", "ko": "n개의 정사각형을 m개의 색상으로 칠하는 방법의 수를 계산합니다. 인접한 정사각형과 첫 번째/마지막 정사각형이 다른 색상이어야 한다는 요구 사항을 고려합니다.\n\n@param n 정사각형의 수.\n@param m 색상의 수.\n@return 지정된 조건을 만족하는 서로 다른 색칠 방법의 수. 결과는 1000003으로 나눈 나머지입니다.\n\n예시:\nf_15(1,1) returns 1\nf_15(2,2) returns 2", "ml": "n ചതുരങ്ങൾ m നിറങ്ങളുമായി നിറയ്ക്കാനുള്ള വ്യത്യസ്തമായ നിറയ്ക്കൽ രീതികളുടെ എണ്ണം എണ്ണുന്നു, ചേർന്നിരിക്കുന്ന ചതുരങ്ങൾക്കും ആദ്യ/അവസാന ചതുരങ്ങൾക്കും വ്യത്യസ്ത നിറങ്ങൾ വേണമെന്ന് ആവശ്യമായ സാഹചര്യത്തിൽ.\n\n@param n ചതുരങ്ങളുടെ എണ്ണം.\n@param m നിറങ്ങളുടെ എണ്ണം.\n@return നിർദ്ദിഷ്ട സാഹചര്യങ്ങൾ പാലിക്കുന്ന വ്യത്യസ്ത നിറയ്ക്കൽ രീതികളുടെ എണ്ണം. ഫലം 1000003-ൽ മോഡുലോ ആണ്.\n\nഉദാഹരണങ്ങൾ:\nf_15(1,1) 1 മടക്കുന്നു\nf_15(2,2) 2 മടക്കുന്നു", "fa": "تعداد روش‌های مختلف رنگ‌آمیزی برای n مربع با m رنگ را محاسبه می‌کند، با در نظر گرفتن این شرط که مربع‌های مجاور و مربع‌های اول/آخر باید رنگ‌های متفاوتی داشته باشند.\n\n@param n تعداد مربع‌ها.\n@param m تعداد رنگ‌ها.\n@return تعداد روش‌های مختلف رنگ‌آمیزی که شرایط مشخص شده را برآورده می‌کنند. نتیجه به صورت مدولوی 1000003 است.\n\nمثال‌ها:\nf_15(1,1) مقدار 1 را برمی‌گرداند\nf_15(2,2) مقدار 2 را برمی‌گرداند"}}
{"task_id": "CPP/16", "prompt": {"en": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Count the number of valid coin toss sequences with no consecutive heads in n tosses.\n *\n * Parameters:\n * - n (int): The number of coin tosses.\n *\n * Returns:\n * - unsigned long long: The count of valid sequences.\n *\n * Examples:\n *   f_16(1) returns 2\n *   f_16(2) returns 3\n */\nunsigned long long f_16(int n)", "sq": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Numëron numrin e sekuencave të vlefshme të hedhjeve të monedhës pa koka të njëpasnjëshme në n hedhje.\n *\n * Parametrat:\n * - n (int): Numri i hedhjeve të monedhës.\n *\n * Kthen:\n * - unsigned long long: Numri i sekuencave të vlefshme.\n *\n * Shembuj:\n *   f_16(1) kthen 2\n *   f_16(2) kthen 3\n */\nunsigned long long f_16(int n)", "hy": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Հաշվել վավեր մետաղադրամի նետումների հաջորդականությունների քանակը, որտեղ n նետումների մեջ չկան հաջորդական գլուխներ:\n *\n * Պարամետրեր:\n * - n (int): Մետաղադրամի նետումների քանակը:\n *\n * Վերադարձնում է:\n * - unsigned long long: Վավեր հաջորդականությունների քանակը:\n *\n * Օրինակներ:\n *   f_16(1) վերադարձնում է 2\n *   f_16(2) վերադարձնում է 3\n */\nunsigned long long f_16(int n)", "bn": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * n টি ছোঁড়ায় কোন পরপর হেড না থাকা বৈধ কয়েন টস সিকোয়েন্সের সংখ্যা গণনা করুন।\n *\n * প্যারামিটার:\n * - n (int): কয়েন টসের সংখ্যা।\n *\n * রিটার্নস:\n * - unsigned long long: বৈধ সিকোয়েন্সের সংখ্যা।\n *\n * উদাহরণ:\n *   f_16(1) রিটার্ন করে 2\n *   f_16(2) রিটার্ন করে 3\n */\nunsigned long long f_16(int n)", "bg": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Брои броя на валидните последователности от хвърляния на монета без последователни ези в n хвърляния.\n *\n * Параметри:\n * - n (int): Броят на хвърлянията на монетата.\n *\n * Връща:\n * - unsigned long long: Броят на валидните последователности.\n *\n * Примери:\n *   f_16(1) връща 2\n *   f_16(2) връща 3\n */\nunsigned long long f_16(int n)", "zh": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * 计算在n次投掷中没有连续正面的有效投掷序列的数量。\n *\n * 参数:\n * - n (int): 投掷硬币的次数。\n *\n * 返回:\n * - unsigned long long: 有效序列的数量。\n *\n * 示例:\n *   f_16(1) 返回 2\n *   f_16(2) 返回 3\n */\nunsigned long long f_16(int n)", "fr": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Compter le nombre de séquences de lancers de pièces valides sans faces consécutives dans n lancers.\n *\n * Paramètres:\n * - n (int): Le nombre de lancers de pièces.\n *\n * Renvoie:\n * - unsigned long long: Le nombre de séquences valides.\n *\n * Exemples:\n *   f_16(1) returns 2\n *   f_16(2) returns 3\n */\nunsigned long long f_16(int n)", "de": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Zählt die Anzahl der gültigen Münzwurfsequenzen ohne aufeinanderfolgende Köpfe in n Würfen.\n *\n * Parameter:\n * - n (int): Die Anzahl der Münzwürfe.\n *\n * Rückgabe:\n * - unsigned long long: Die Anzahl der gültigen Sequenzen.\n *\n * Beispiele:\n *   f_16(1) gibt 2 zurück\n *   f_16(2) gibt 3 zurück\n */\nunsigned long long f_16(int n)", "ha": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Ƙididdige adadin sahihan jeri na jefa tsabar kudi ba tare da kai biyu a jere ba a cikin jefa n.\n *\n * Sigogi:\n * - n (int): Adadin jefa tsabar kudi.\n *\n * Komawa:\n * - unsigned long long: Adadin jerin sahihan.\n *\n * Misalai:\n *   f_16(1) returns 2\n *   f_16(2) returns 3\n */\nunsigned long long f_16(int n)", "hi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * n उछालों में कोई लगातार हेड्स नहीं होने वाले वैध सिक्का उछाल अनुक्रमों की संख्या गिनें।\n *\n * पैरामीटर्स:\n * - n (int): सिक्का उछालों की संख्या।\n *\n * रिटर्न्स:\n * - unsigned long long: वैध अनुक्रमों की गिनती।\n *\n * उदाहरण:\n *   f_16(1) returns 2\n *   f_16(2) returns 3\n */\nunsigned long long f_16(int n)", "hu": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Számolja meg az érvényes pénzfeldobás sorozatok számát, ahol nincs két egymást követő fej n dobás esetén.\n *\n * Paraméterek:\n * - n (int): A pénzfeldobások száma.\n *\n * Visszatérési érték:\n * - unsigned long long: Az érvényes sorozatok száma.\n *\n * Példák:\n *   f_16(1) visszaadja 2\n *   f_16(2) visszaadja 3\n */\nunsigned long long f_16(int n)", "es": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Cuenta el número de secuencias válidas de lanzamientos de moneda sin caras consecutivas en n lanzamientos.\n *\n * Parámetros:\n * - n (int): El número de lanzamientos de moneda.\n *\n * Devuelve:\n * - unsigned long long: El conteo de secuencias válidas.\n *\n * Ejemplos:\n *   f_16(1) returns 2\n *   f_16(2) returns 3\n */\nunsigned long long f_16(int n)", "arb": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * احسب عدد تسلسلات رمي العملة الصحيحة بدون رؤوس متتالية في n رميات.\n *\n * المعلمات:\n * - n (int): عدد رميات العملة.\n *\n * يعيد:\n * - unsigned long long: عدد التسلسلات الصحيحة.\n *\n * أمثلة:\n *   f_16(1) returns 2\n *   f_16(2) returns 3\n */\nunsigned long long f_16(int n)", "sw": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Hesabu idadi ya mlolongo sahihi wa kurusha sarafu bila vichwa mfululizo katika kurusha mara n.\n *\n * Vigezo:\n * - n (int): Idadi ya kurusha sarafu.\n *\n * Inarudisha:\n * - unsigned long long: Hesabu ya milolongo sahihi.\n *\n * Mifano:\n *   f_16(1) inarudisha 2\n *   f_16(2) inarudisha 3\n */\nunsigned long long f_16(int n)", "tr": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Ardışık yazı gelmeyen geçerli para atışı dizilerinin sayısını n atışta sayar.\n *\n * Parametreler:\n * - n (int): Para atışlarının sayısı.\n *\n * Döndürür:\n * - unsigned long long: Geçerli dizilerin sayısı.\n *\n * Örnekler:\n *   f_16(1) 2 döndürür\n *   f_16(2) 3 döndürür\n */\nunsigned long long f_16(int n)", "vi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Đếm số lượng dãy tung đồng xu hợp lệ mà không có hai mặt ngửa liên tiếp trong n lần tung.\n *\n * Tham số:\n * - n (int): Số lần tung đồng xu.\n *\n * Trả về:\n * - unsigned long long: Số lượng dãy hợp lệ.\n *\n * Ví dụ:\n *   f_16(1) trả về 2\n *   f_16(2) trả về 3\n */\nunsigned long long f_16(int n)", "id": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Hitung jumlah urutan lemparan koin yang valid tanpa kepala berturut-turut dalam n lemparan.\n *\n * Parameter:\n * - n (int): Jumlah lemparan koin.\n *\n * Mengembalikan:\n * - unsigned long long: Jumlah urutan yang valid.\n *\n * Contoh:\n *   f_16(1) mengembalikan 2\n *   f_16(2) mengembalikan 3\n */\nunsigned long long f_16(int n)", "ja": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * n回のコイントスで連続する表がない有効なコイントスシーケンスの数を数えます。\n *\n * パラメータ:\n * - n (int): コイントスの回数。\n *\n * 戻り値:\n * - unsigned long long: 有効なシーケンスの数。\n *\n * 例:\n *   f_16(1) は 2 を返します\n *   f_16(2) は 3 を返します\n */\nunsigned long long f_16(int n)", "ko": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * 연속된 앞면이 없는 유효한 동전 던지기 시퀀스의 수를 n번 던졌을 때 계산합니다.\n *\n * 매개변수:\n * - n (int): 동전 던지기의 횟수.\n *\n * 반환값:\n * - unsigned long long: 유효한 시퀀스의 수.\n *\n * 예시:\n *   f_16(1) returns 2\n *   f_16(2) returns 3\n */\nunsigned long long f_16(int n)", "ml": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * n തവണ എറിയുമ്പോൾ തുടർച്ചയായ തലകൾ ഇല്ലാത്ത സാധുവായ നാണയ എറിയൽ ക്രമങ്ങളുടെ എണ്ണം എണ്ണുക.\n *\n * പാരാമീറ്ററുകൾ:\n * - n (int): നാണയം എറിയുന്ന തവണകൾ.\n *\n * തിരിച്ചറിയുന്നു:\n * - unsigned long long: സാധുവായ ക്രമങ്ങളുടെ എണ്ണം.\n *\n * ഉദാഹരണങ്ങൾ:\n *   f_16(1) 2 തിരിച്ചറിയുന്നു\n *   f_16(2) 3 തിരിച്ചറിയുന്നു\n */\nunsigned long long f_16(int n)", "fa": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * تعداد دنباله‌های معتبر پرتاب سکه بدون شیرهای متوالی در n پرتاب را بشمارید.\n *\n * پارامترها:\n * - n (int): تعداد پرتاب‌های سکه.\n *\n * برمی‌گرداند:\n * - unsigned long long: تعداد دنباله‌های معتبر.\n *\n * مثال‌ها:\n *   f_16(1) برمی‌گرداند 2\n *   f_16(2) برمی‌گرداند 3\n */\nunsigned long long f_16(int n)"}, "canonical_solution": "{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n\n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n\n    return a[n][0] + a[n][1];\n}", "instruction": {"en": "unsigned long long f_16(int n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n\n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n\n    return a[n][0] + a[n][1];\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.", "sq": "unsigned long long f_16(int n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n\n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n\n    return a[n][0] + a[n][1];\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit CPP në shqip duke përdorur maksimumi 500 karaktere.", "hy": "unsigned long long f_16(int n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n\n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n\n    return a[n][0] + a[n][1];\n}\n\nՏվեք կարճ բնական լեզվով նկարագրություն (docstring) այս CPP կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "unsigned long long f_16(int n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n\n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n\n    return a[n][0] + a[n][1];\n}\n\nসিপিপি কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।", "bg": "unsigned long long f_16(int n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n\n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n\n    return a[n][0] + a[n][1];\n}\n\nПредоставете кратко описание на CPP кода на естествен език на български, като използвате не повече от 500 знака.", "zh": "unsigned long long f_16(int n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n\n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n\n    return a[n][0] + a[n][1];\n}\n\n将以下 CPP 代码的功能描述为简洁的自然语言（文档字符串），使用不超过 500 个字符的中文。", "fr": "unsigned long long f_16(int n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n\n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n\n    return a[n][0] + a[n][1];\n}\n\nFournissez une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.", "de": "unsigned long long f_16(int n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n\n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n\n    return a[n][0] + a[n][1];\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "unsigned long long f_16(int n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n\n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n\n    return a[n][0] + a[n][1];\n}\n\nBa da takaitaccen bayani a cikin yare na halitta (docstring) na lambar CPP a cikin Hausa, ba tare da wucewa haruffa 500 ba.", "hi": "unsigned long long f_16(int n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n\n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n\n    return a[n][0] + a[n][1];\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।", "hu": "unsigned long long f_16(int n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n\n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n\n    return a[n][0] + a[n][1];\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a CPP kódról magyarul, legfeljebb 500 karakterben.", "es": "unsigned long long f_16(int n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n\n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n\n    return a[n][0] + a[n][1];\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando como máximo 500 caracteres.", "arb": "unsigned long long f_16(int n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n\n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n\n    return a[n][0] + a[n][1];\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية بلغة C++ باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "unsigned long long f_16(int n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n\n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n\n    return a[n][0] + a[n][1];\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "unsigned long long f_16(int n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n\n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n\n    return a[n][0] + a[n][1];\n}\n\nAşağıdaki CPP kodunun Türkçe'de en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.", "vi": "unsigned long long f_16(int n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n\n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n\n    return a[n][0] + a[n][1];\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự.", "id": "unsigned long long f_16(int n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n\n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n\n    return a[n][0] + a[n][1];\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode CPP dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "unsigned long long f_16(int n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n\n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n\n    return a[n][0] + a[n][1];\n}\n\n以下のCPPコードの自然言語による簡潔な説明（ドックストリング）を日本語で500文字以内で提供してください。", "ko": "unsigned long long f_16(int n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n\n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n\n    return a[n][0] + a[n][1];\n}\n\n최대 500자를 사용하여 영어로 CPP 코드에 대한 간결한 자연어 설명(docstring)을 제공하세요.", "ml": "unsigned long long f_16(int n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n\n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n\n    return a[n][0] + a[n][1];\n}\n\nCPP കോഡ് മലയാളത്തിൽ പരമാവധി 500 അക്ഷരങ്ങളിൽ സംക്ഷിപ്തമായ സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) നൽകുക.", "fa": "unsigned long long f_16(int n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n\n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n\n    return a[n][0] + a[n][1];\n}\n\nتوضیح مختصر و طبیعی (docstring) از کد CPP به زبان فارسی با حداکثر ۵۰۰ کاراکتر ارائه دهید."}, "level": "", "test": "int main() {\n    assert(f_16(1) == 2);\n    assert(f_16(2) == 3);\n    assert(f_16(3) == 5);\n    assert(f_16(4) == 8); // Additional test\n    assert(f_16(5) == 13); // Additional test\n    // Feel free to add more tests here\n    assert(f_16(40) == 267914296ULL); // Additional test\n    assert(f_16(39) == 165580141ULL);\n    assert(f_16(38) == 102334155ULL);\n    // printf(\"All tests passed!\\n\");\n    return 0;\n}", "entry_point": "f_16", "signature": "unsigned long long f_16(int n)", "docstring": {"en": "Count the number of valid coin toss sequences with no consecutive heads in n tosses.\n\nParameters:\n- n (int): The number of coin tosses.\n\nReturns:\n- unsigned long long: The count of valid sequences.\n\nExamples:\n  f_16(1) returns 2\n  f_16(2) returns 3\n", "sq": "Numëroni numrin e sekuencave të vlefshme të hedhjeve të monedhës pa koka të njëpasnjëshme në n hedhje.\n\nParametrat:\n- n (int): Numri i hedhjeve të monedhës.\n\nKthen:\n- unsigned long long: Numri i sekuencave të vlefshme.\n\nShembuj:\n  f_16(1) kthen 2\n  f_16(2) kthen 3", "hy": "Հաշվել վավեր մետաղադրամի նետման հաջորդականությունների քանակը՝ առանց հաջորդական գլուխների n նետման դեպքում:\n\nՊարամետրեր:\n- n (int): Նետումների քանակը:\n\nՎերադարձնում է:\n- unsigned long long: Վավեր հաջորդականությունների քանակը:\n\nՕրինակներ:\n  f_16(1) վերադարձնում է 2\n  f_16(2) վերադարձնում է 3", "bn": "n টসের মধ্যে কোন পরপর হেড না থাকা বৈধ কয়েন টস সিকোয়েন্সের সংখ্যা গণনা করুন।\n\nপ্যারামিটারসমূহ:\n- n (int): কয়েন টসের সংখ্যা।\n\nফেরত দেয়:\n- unsigned long long: বৈধ সিকোয়েন্সের সংখ্যা।\n\nউদাহরণসমূহ:\n  f_16(1) ফেরত দেয় 2\n  f_16(2) ফেরত দেয় 3", "bg": "Бройте броя на валидните последователности от хвърляния на монета без последователни ези в n хвърляния.\n\nПараметри:\n- n (int): Броят на хвърлянията на монетата.\n\nВръща:\n- unsigned long long: Броят на валидните последователности.\n\nПримери:\n  f_16(1) връща 2\n  f_16(2) връща 3", "zh": "计算在 n 次投掷中没有连续正面的有效硬币投掷序列的数量。\n\n参数：\n- n (int): 硬币投掷的次数。\n\n返回：\n- unsigned long long: 有效序列的数量。\n\n示例：\n  f_16(1) returns 2\n  f_16(2) returns 3", "fr": "Compter le nombre de séquences de lancers de pièce valides sans faces consécutives dans n lancers.\n\nParamètres :\n- n (int) : Le nombre de lancers de pièce.\n\nRenvoie :\n- unsigned long long : Le compte des séquences valides.\n\nExemples :\n  f_16(1) renvoie 2\n  f_16(2) renvoie 3", "de": "Zähle die Anzahl der gültigen Münzwurfsequenzen ohne aufeinanderfolgende Köpfe bei n Würfen.\n\nParameter:\n- n (int): Die Anzahl der Münzwürfe.\n\nGibt zurück:\n- unsigned long long: Die Anzahl der gültigen Sequenzen.\n\nBeispiele:\n  f_16(1) gibt 2 zurück\n  f_16(2) gibt 3 zurück", "ha": "Ƙirga adadin jerin jefa tsabar kudi masu inganci tare da babu kawunan da ke jere a cikin jefa tsabar kudi n.\n\nSigogi:\n- n (int): Yawan jefa tsabar kudi.\n\nDawowa:\n- unsigned long long: Adadin sahihan jerin.\n\nMisalai:\n  f_16(1) returns 2\n  f_16(2) returns 3", "hi": "n उछालों में बिना लगातार हेड्स के वैध सिक्का उछाल अनुक्रमों की संख्या गिनें।\n\nपैरामीटर्स:\n- n (int): सिक्का उछालों की संख्या।\n\nवापसी:\n- unsigned long long: वैध अनुक्रमों की गिनती।\n\nउदाहरण:\n  f_16(1) returns 2\n  f_16(2) returns 3", "hu": "Számolja meg az érvényes pénzfeldobási sorozatok számát, ahol nincs egymást követő fej n dobás esetén.\n\nParaméterek:\n- n (int): A pénzfeldobások száma.\n\nVisszatér:\n- unsigned long long: Az érvényes sorozatok száma.\n\nPéldák:\n  f_16(1) visszaadja 2\n  f_16(2) visszaadja 3", "es": "Cuenta el número de secuencias válidas de lanzamientos de moneda sin caras consecutivas en n lanzamientos.\n\nParámetros:\n- n (int): El número de lanzamientos de moneda.\n\nDevuelve:\n- unsigned long long: La cuenta de secuencias válidas.\n\nEjemplos:\n  f_16(1) devuelve 2\n  f_16(2) devuelve 3", "arb": "احسب عدد تسلسلات رمي العملة الصحيحة بدون رؤوس متتالية في n من الرميات.\n\nالمعلمات:\n- n (int): عدد رميات العملة.\n\nالقيم المعادة:\n- unsigned long long: عدد التسلسلات الصحيحة.\n\nأمثلة:\n  f_16(1) returns 2\n  f_16(2) returns 3", "sw": "Hesabu idadi ya mfuatano halali wa kurusha sarafu bila vichwa vinavyofuatana katika kurusha sarafu n.\n\nVigezo:\n- n (int): Idadi ya kurusha sarafu.\n\nInarejesha:\n- unsigned long long: Idadi ya mfuatano halali.\n\nMifano:\n  f_16(1) inarejesha 2\n  f_16(2) inarejesha 3", "tr": "n atışında ardışık yazı gelmeyen geçerli madeni para atış dizilerinin sayısını sayın.\n\nParametreler:\n- n (int): Madeni para atışlarının sayısı.\n\nDöndürür:\n- unsigned long long: Geçerli dizilerin sayısı.\n\nÖrnekler:\n  f_16(1) 2 döndürür\n  f_16(2) 3 döndürür", "vi": "Đếm số lượng dãy tung đồng xu hợp lệ mà không có hai mặt ngửa liên tiếp trong n lần tung.\n\nTham số:\n- n (int): Số lần tung đồng xu.\n\nTrả về:\n- unsigned long long: Số lượng dãy hợp lệ.\n\nVí dụ:\n  f_16(1) trả về 2\n  f_16(2) trả về 3", "id": "Hitung jumlah urutan lemparan koin yang valid tanpa kepala berturut-turut dalam n lemparan.\n\nParameter:\n- n (int): Jumlah lemparan koin.\n\nMengembalikan:\n- unsigned long long: Jumlah urutan yang valid.\n\nContoh:\n  f_16(1) mengembalikan 2\n  f_16(2) mengembalikan 3", "ja": "n回のコイントスで連続する表がない有効なコイントスシーケンスの数を数えます。\n\nパラメータ:\n- n (int): コイントスの回数。\n\n戻り値:\n- unsigned long long: 有効なシーケンスの数。\n\n例:\n  f_16(1) は 2 を返します\n  f_16(2) は 3 を返します", "ko": "n번의 던지기에서 연속된 앞면이 없는 유효한 동전 던지기 시퀀스의 수를 계산합니다.\n\n매개변수:\n- n (int): 동전 던지기 횟수.\n\n반환:\n- unsigned long long: 유효한 시퀀스의 수.\n\n예시:\n  f_16(1) returns 2\n  f_16(2) returns 3", "ml": "n തവണ നാണയം എറിയുമ്പോൾ തുടർച്ചയായ തലകളില്ലാത്ത സാധുവായ നാണയ എറിയൽ ക്രമങ്ങളുടെ എണ്ണം എണ്ണുക.\n\nപാരാമീറ്ററുകൾ:\n- n (int): നാണയം എറിയുന്ന എണ്ണം.\n\nമടക്കങ്ങൾ:\n- unsigned long long: സാധുവായ ക്രമങ്ങളുടെ എണ്ണം.\n\nഉദാഹരണങ്ങൾ:\n  f_16(1) മടക്കുന്നു 2\n  f_16(2) മടക്കുന്നു 3", "fa": "تعداد دنباله‌های معتبر پرتاب سکه را که در آن‌ها هیچ شیر متوالی وجود ندارد در n پرتاب محاسبه کنید.\n\nپارامترها:\n- n (int): تعداد پرتاب‌های سکه.\n\nبازگشت:\n- unsigned long long: تعداد دنباله‌های معتبر.\n\nمثال‌ها:\n  f_16(1) returns 2\n  f_16(2) returns 3"}}
{"task_id": "CPP/17", "prompt": {"en": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Find the length of the longest consecutive sequence of 1s in the binary \n * representation of a non-negative integer.\n *\n * Parameters:\n * - n (unsigned long long): A non-negative integer (0 ≤ n ≤ 2^64 - 1).\n *\n * Returns:\n * - int: The length of the longest consecutive sequence of 1s in the binary \n *        representation of the given integer.\n *\n * Examples:\n *   >>> f_17(7)\n *   3\n */\nint f_17(unsigned long long n)", "sq": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Gjeni gjatësinë e sekuencës më të gjatë të njëshave radhazi në paraqitjen \n * binare të një numri të plotë jo-negativ.\n *\n * Parametrat:\n * - n (unsigned long long): Një numër i plotë jo-negativ (0 ≤ n ≤ 2^64 - 1).\n *\n * Kthen:\n * - int: Gjatësia e sekuencës më të gjatë të njëshave radhazi në paraqitjen \n *        binare të numrit të dhënë.\n *\n * Shembuj:\n *   >>> f_17(7)\n *   3\n */\nint f_17(unsigned long long n)", "hy": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Գտնել ամենաերկար հաջորդական 1-երի հաջորդականության երկարությունը ոչ բացասական ամբողջ թվի \n * երկբայական ներկայացման մեջ:\n *\n * Պարամետրեր:\n * - n (unsigned long long): Ոչ բացասական ամբողջ թիվ (0 ≤ n ≤ 2^64 - 1):\n *\n * Վերադարձնում է:\n * - int: Տրված ամբողջ թվի երկբայական ներկայացման մեջ ամենաերկար հաջորդական 1-երի \n *        հաջորդականության երկարությունը:\n *\n * Օրինակներ:\n *   >>> f_17(7)\n *   3\n */\nint f_17(unsigned long long n)", "bn": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * একটি অ-ঋণাত্মক পূর্ণসংখ্যার বাইনারি উপস্থাপনায় 1 এর দীর্ঘতম ধারাবাহিক ক্রমের দৈর্ঘ্য খুঁজুন।\n *\n * প্যারামিটার:\n * - n (unsigned long long): একটি অ-ঋণাত্মক পূর্ণসংখ্যা (0 ≤ n ≤ 2^64 - 1)।\n *\n * রিটার্ন করে:\n * - int: প্রদত্ত পূর্ণসংখ্যার বাইনারি উপস্থাপনায় 1 এর দীর্ঘতম ধারাবাহিক ক্রমের দৈর্ঘ্য।\n *\n * উদাহরণ:\n *   >>> f_17(7)\n *   3\n */\nint f_17(unsigned long long n)", "bg": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Намерете дължината на най-дългата последователна поредица от 1-ци в двоичното \n * представяне на неотрицателно цяло число.\n *\n * Параметри:\n * - n (unsigned long long): Неотрицателно цяло число (0 ≤ n ≤ 2^64 - 1).\n *\n * Връща:\n * - int: Дължината на най-дългата последователна поредица от 1-ци в двоичното \n *        представяне на даденото число.\n *\n * Примери:\n *   >>> f_17(7)\n *   3\n */\nint f_17(unsigned long long n)", "zh": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * 找到非负整数的二进制表示中最长连续1序列的长度。\n *\n * 参数：\n * - n (unsigned long long): 一个非负整数 (0 ≤ n ≤ 2^64 - 1)。\n *\n * 返回：\n * - int: 给定整数的二进制表示中最长连续1序列的长度。\n *\n * 示例：\n *   >>> f_17(7)\n *   3\n */\nint f_17(unsigned long long n)", "fr": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Trouver la longueur de la plus longue séquence consécutive de 1 dans la \n * représentation binaire d'un entier non négatif.\n *\n * Paramètres :\n * - n (unsigned long long) : Un entier non négatif (0 ≤ n ≤ 2^64 - 1).\n *\n * Renvoie :\n * - int : La longueur de la plus longue séquence consécutive de 1 dans la \n *         représentation binaire de l'entier donné.\n *\n * Exemples :\n *   >>> f_17(7)\n *   3\n */\nint f_17(unsigned long long n)", "de": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Finde die Länge der längsten aufeinanderfolgenden Sequenz von 1en in der \n * Binärdarstellung einer nicht-negativen ganzen Zahl.\n *\n * Parameter:\n * - n (unsigned long long): Eine nicht-negative ganze Zahl (0 ≤ n ≤ 2^64 - 1).\n *\n * Rückgabewerte:\n * - int: Die Länge der längsten aufeinanderfolgenden Sequenz von 1en in der \n *        Binärdarstellung der gegebenen Zahl.\n *\n * Beispiele:\n *   >>> f_17(7)\n *   3\n */\nint f_17(unsigned long long n)", "ha": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Nemo tsawon mafi tsawo jere na 1s a cikin wakilcin binary \n * na lamba mara kyau.\n *\n * Sigogi:\n * - n (unsigned long long): Lamba mara kyau (0 ≤ n ≤ 2^64 - 1).\n *\n * Komawa:\n * - int: Tsawon mafi tsawo jere na 1s a cikin wakilcin binary \n *        na lambar da aka bayar.\n *\n * Misalai:\n *   >>> f_17(7)\n *   3\n */\nint f_17(unsigned long long n)", "hi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * एक गैर-ऋणात्मक पूर्णांक के बाइनरी प्रतिनिधित्व में लगातार 1s के सबसे लंबे अनुक्रम की लंबाई खोजें।\n *\n * पैरामीटर:\n * - n (unsigned long long): एक गैर-ऋणात्मक पूर्णांक (0 ≤ n ≤ 2^64 - 1)।\n *\n * लौटाता है:\n * - int: दिए गए पूर्णांक के बाइनरी प्रतिनिधित्व में लगातार 1s के सबसे लंबे अनुक्रम की लंबाई।\n *\n * उदाहरण:\n *   >>> f_17(7)\n *   3\n */\nint f_17(unsigned long long n)", "hu": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Keresse meg a leghosszabb egymást követő 1-esek sorozatának hosszát egy nem negatív egész szám bináris \n * ábrázolásában.\n *\n * Paraméterek:\n * - n (unsigned long long): Egy nem negatív egész szám (0 ≤ n ≤ 2^64 - 1).\n *\n * Visszatérési érték:\n * - int: A leghosszabb egymást követő 1-esek sorozatának hossza a megadott egész szám bináris \n *        ábrázolásában.\n *\n * Példák:\n *   >>> f_17(7)\n *   3\n */\nint f_17(unsigned long long n)", "es": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Encuentra la longitud de la secuencia consecutiva más larga de 1s en la \n * representación binaria de un entero no negativo.\n *\n * Parámetros:\n * - n (unsigned long long): Un entero no negativo (0 ≤ n ≤ 2^64 - 1).\n *\n * Retorna:\n * - int: La longitud de la secuencia consecutiva más larga de 1s en la \n *        representación binaria del entero dado.\n *\n * Ejemplos:\n *   >>> f_17(7)\n *   3\n */\nint f_17(unsigned long long n)", "arb": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * إيجاد طول أطول تسلسل متتابع من الأرقام 1 في التمثيل الثنائي لعدد صحيح غير سالب.\n *\n * المعاملات:\n * - n (unsigned long long): عدد صحيح غير سالب (0 ≤ n ≤ 2^64 - 1).\n *\n * يعيد:\n * - int: طول أطول تسلسل متتابع من الأرقام 1 في التمثيل الثنائي للعدد المعطى.\n *\n * أمثلة:\n *   >>> f_17(7)\n *   3\n */\nint f_17(unsigned long long n)", "sw": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Tafuta urefu wa mfululizo mrefu zaidi wa 1s katika uwakilishi wa \n * nambari ya binary ya nambari isiyo na alama.\n *\n * Vigezo:\n * - n (unsigned long long): Nambari isiyo na alama (0 ≤ n ≤ 2^64 - 1).\n *\n * Inarudisha:\n * - int: Urefu wa mfululizo mrefu zaidi wa 1s katika uwakilishi wa \n *        nambari ya binary ya nambari iliyotolewa.\n *\n * Mifano:\n *   >>> f_17(7)\n *   3\n */\nint f_17(unsigned long long n)", "tr": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Bir negatif olmayan tamsayının ikili gösterimindeki en uzun ardışık 1 \n * dizisinin uzunluğunu bulun.\n *\n * Parametreler:\n * - n (unsigned long long): Negatif olmayan bir tamsayı (0 ≤ n ≤ 2^64 - 1).\n *\n * Döndürür:\n * - int: Verilen tamsayının ikili gösterimindeki en uzun ardışık 1 dizisinin \n *        uzunluğu.\n *\n * Örnekler:\n *   >>> f_17(7)\n *   3\n */\nint f_17(unsigned long long n)", "vi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Tìm độ dài của dãy liên tiếp dài nhất của các số 1 trong biểu diễn nhị phân \n * của một số nguyên không âm.\n *\n * Tham số:\n * - n (unsigned long long): Một số nguyên không âm (0 ≤ n ≤ 2^64 - 1).\n *\n * Trả về:\n * - int: Độ dài của dãy liên tiếp dài nhất của các số 1 trong biểu diễn nhị phân \n *        của số nguyên đã cho.\n *\n * Ví dụ:\n *   >>> f_17(7)\n *   3\n */\nint f_17(unsigned long long n)", "id": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Temukan panjang urutan terpanjang dari 1s secara berurutan dalam representasi \n * biner dari bilangan bulat non-negatif.\n *\n * Parameter:\n * - n (unsigned long long): Sebuah bilangan bulat non-negatif (0 ≤ n ≤ 2^64 - 1).\n *\n * Mengembalikan:\n * - int: Panjang urutan terpanjang dari 1s secara berurutan dalam representasi \n *        biner dari bilangan bulat yang diberikan.\n *\n * Contoh:\n *   >>> f_17(7)\n *   3\n */\nint f_17(unsigned long long n)\n", "ja": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * 非負整数の2進数表現における1の連続する最長シーケンスの長さを見つける。\n *\n * パラメータ:\n * - n (unsigned long long): 非負整数 (0 ≤ n ≤ 2^64 - 1)。\n *\n * 戻り値:\n * - int: 与えられた整数の2進数表現における1の連続する最長シーケンスの長さ。\n *\n * 例:\n *   >>> f_17(7)\n *   3\n */\nint f_17(unsigned long long n)", "ko": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * 이진 표현에서 1의 가장 긴 연속 시퀀스의 길이를 찾습니다.\n *\n * 매개변수:\n * - n (unsigned long long): 음이 아닌 정수 (0 ≤ n ≤ 2^64 - 1).\n *\n * 반환:\n * - int: 주어진 정수의 이진 표현에서 1의 가장 긴 연속 시퀀스의 길이.\n *\n * 예시:\n *   >>> f_17(7)\n *   3\n */\nint f_17(unsigned long long n)", "ml": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * ഒരു അസാധാരണമായ പൂർണ്ണസംഖ്യയുടെ ബൈനറി പ്രതിനിധാനത്തിൽ \n * തുടർച്ചയായ 1 കളുടെ ഏറ്റവും നീളമുള്ള അനുക്രമത്തിന്റെ നീളം കണ്ടെത്തുക.\n *\n * പാരാമീറ്ററുകൾ:\n * - n (unsigned long long): ഒരു അസാധാരണമായ പൂർണ്ണസംഖ്യ (0 ≤ n ≤ 2^64 - 1).\n *\n * മടക്കുന്നു:\n * - int: നൽകിയിരിക്കുന്ന പൂർണ്ണസംഖ്യയുടെ ബൈനറി പ്രതിനിധാനത്തിൽ \n *        തുടർച്ചയായ 1 കളുടെ ഏറ്റവും നീളമുള്ള അനുക്രമത്തിന്റെ നീളം.\n *\n * ഉദാഹരണങ്ങൾ:\n *   >>> f_17(7)\n *   3\n */\nint f_17(unsigned long long n)", "fa": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * طول بلندترین دنباله متوالی از 1ها را در نمایش باینری یک عدد صحیح غیرمنفی پیدا کنید.\n *\n * پارامترها:\n * - n (unsigned long long): یک عدد صحیح غیرمنفی (0 ≤ n ≤ 2^64 - 1).\n *\n * بازگشت:\n * - int: طول بلندترین دنباله متوالی از 1ها در نمایش باینری عدد داده شده.\n *\n * مثال‌ها:\n *   >>> f_17(7)\n *   3\n */\nint f_17(unsigned long long n)"}, "canonical_solution": "{\n    int max_length = 0;\n    int current_length = 0;\n    while (n) {\n        if (n & 1) {\n            current_length++;\n        } else {\n            if (current_length > max_length) {\n                max_length = current_length;\n            }\n            current_length = 0;\n        }\n        n >>= 1;\n    }\n    if (current_length > max_length) {\n        max_length = current_length;\n    }\n    return max_length;\n}", "instruction": {"en": "int f_17(unsigned long long n)\n{\n    int max_length = 0;\n    int current_length = 0;\n    while (n) {\n        if (n & 1) {\n            current_length++;\n        } else {\n            if (current_length > max_length) {\n                max_length = current_length;\n            }\n            current_length = 0;\n        }\n        n >>= 1;\n    }\n    if (current_length > max_length) {\n        max_length = current_length;\n    }\n    return max_length;\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.", "sq": "int f_17(unsigned long long n)\n{\n    int max_length = 0;\n    int current_length = 0;\n    while (n) {\n        if (n & 1) {\n            current_length++;\n        } else {\n            if (current_length > max_length) {\n                max_length = current_length;\n            }\n            current_length = 0;\n        }\n        n >>= 1;\n    }\n    if (current_length > max_length) {\n        max_length = current_length;\n    }\n    return max_length;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit CPP në shqip duke përdorur maksimumi 500 karaktere.", "hy": "int f_17(unsigned long long n)\n{\n    int max_length = 0;\n    int current_length = 0;\n    while (n) {\n        if (n & 1) {\n            current_length++;\n        } else {\n            if (current_length > max_length) {\n                max_length = current_length;\n            }\n            current_length = 0;\n        }\n        n >>= 1;\n    }\n    if (current_length > max_length) {\n        max_length = current_length;\n    }\n    return max_length;\n}\n\nՏվեք CPP կոդի հակիրճ նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "int f_17(unsigned long long n)\n{\n    int max_length = 0;\n    int current_length = 0;\n    while (n) {\n        if (n & 1) {\n            current_length++;\n        } else {\n            if (current_length > max_length) {\n                max_length = current_length;\n            }\n            current_length = 0;\n        }\n        n >>= 1;\n    }\n    if (current_length > max_length) {\n        max_length = current_length;\n    }\n    return max_length;\n}\n\nসিপিপি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।", "bg": "int f_17(unsigned long long n)\n{\n    int max_length = 0;\n    int current_length = 0;\n    while (n) {\n        if (n & 1) {\n            current_length++;\n        } else {\n            if (current_length > max_length) {\n                max_length = current_length;\n            }\n            current_length = 0;\n        }\n        n >>= 1;\n    }\n    if (current_length > max_length) {\n        max_length = current_length;\n    }\n    return max_length;\n}\n\nПредоставете кратко описание на CPP кода на естествен език (docstring) на български, използвайки най-много 500 знака.", "zh": "int f_17(unsigned long long n)\n{\n    int max_length = 0;\n    int current_length = 0;\n    while (n) {\n        if (n & 1) {\n            current_length++;\n        } else {\n            if (current_length > max_length) {\n                max_length = current_length;\n            }\n            current_length = 0;\n        }\n        n >>= 1;\n    }\n    if (current_length > max_length) {\n        max_length = current_length;\n    }\n    return max_length;\n}\n\n请用最多500个字符的中文对该CPP代码提供简洁的自然语言描述（文档字符串）。", "fr": "int f_17(unsigned long long n)\n{\n    int max_length = 0;\n    int current_length = 0;\n    while (n) {\n        if (n & 1) {\n            current_length++;\n        } else {\n            if (current_length > max_length) {\n                max_length = current_length;\n            }\n            current_length = 0;\n        }\n        n >>= 1;\n    }\n    if (current_length > max_length) {\n        max_length = current_length;\n    }\n    return max_length;\n}\n\nFournissez une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.", "de": "int f_17(unsigned long long n)\n{\n    int max_length = 0;\n    int current_length = 0;\n    while (n) {\n        if (n & 1) {\n            current_length++;\n        } else {\n            if (current_length > max_length) {\n                max_length = current_length;\n            }\n            current_length = 0;\n        }\n        n >>= 1;\n    }\n    if (current_length > max_length) {\n        max_length = current_length;\n    }\n    return max_length;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen.", "ha": "int f_17(unsigned long long n)\n{\n    int max_length = 0;\n    int current_length = 0;\n    while (n) {\n        if (n & 1) {\n            current_length++;\n        } else {\n            if (current_length > max_length) {\n                max_length = current_length;\n            }\n            current_length = 0;\n        }\n        n >>= 1;\n    }\n    if (current_length > max_length) {\n        max_length = current_length;\n    }\n    return max_length;\n}\n\nBa da takaitaccen bayani a cikin yare na halitta (docstring) na lambar CPP cikin Hausa ta amfani da haruffa 500 kacal.", "hi": "int f_17(unsigned long long n)\n{\n    int max_length = 0;\n    int current_length = 0;\n    while (n) {\n        if (n & 1) {\n            current_length++;\n        } else {\n            if (current_length > max_length) {\n                max_length = current_length;\n            }\n            current_length = 0;\n        }\n        n >>= 1;\n    }\n    if (current_length > max_length) {\n        max_length = current_length;\n    }\n    return max_length;\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।", "hu": "int f_17(unsigned long long n)\n{\n    int max_length = 0;\n    int current_length = 0;\n    while (n) {\n        if (n & 1) {\n            current_length++;\n        } else {\n            if (current_length > max_length) {\n                max_length = current_length;\n            }\n            current_length = 0;\n        }\n        n >>= 1;\n    }\n    if (current_length > max_length) {\n        max_length = current_length;\n    }\n    return max_length;\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (dokumentációs kommentet) a CPP kódról magyarul, legfeljebb 500 karakterben.", "es": "int f_17(unsigned long long n)\n{\n    int max_length = 0;\n    int current_length = 0;\n    while (n) {\n        if (n & 1) {\n            current_length++;\n        } else {\n            if (current_length > max_length) {\n                max_length = current_length;\n            }\n            current_length = 0;\n        }\n        n >>= 1;\n    }\n    if (current_length > max_length) {\n        max_length = current_length;\n    }\n    return max_length;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando como máximo 500 caracteres.", "arb": "int f_17(unsigned long long n)\n{\n    int max_length = 0;\n    int current_length = 0;\n    while (n) {\n        if (n & 1) {\n            current_length++;\n        } else {\n            if (current_length > max_length) {\n                max_length = current_length;\n            }\n            current_length = 0;\n        }\n        n >>= 1;\n    }\n    if (current_length > max_length) {\n        max_length = current_length;\n    }\n    return max_length;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة CPP باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "int f_17(unsigned long long n)\n{\n    int max_length = 0;\n    int current_length = 0;\n    while (n) {\n        if (n & 1) {\n            current_length++;\n        } else {\n            if (current_length > max_length) {\n                max_length = current_length;\n            }\n            current_length = 0;\n        }\n        n >>= 1;\n    }\n    if (current_length > max_length) {\n        max_length = current_length;\n    }\n    return max_length;\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "int f_17(unsigned long long n)\n{\n    int max_length = 0;\n    int current_length = 0;\n    while (n) {\n        if (n & 1) {\n            current_length++;\n        } else {\n            if (current_length > max_length) {\n                max_length = current_length;\n            }\n            current_length = 0;\n        }\n        n >>= 1;\n    }\n    if (current_length > max_length) {\n        max_length = current_length;\n    }\n    return max_length;\n}\n\nAşağıdaki CPP kodunun Türkçe olarak en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.", "vi": "int f_17(unsigned long long n)\n{\n    int max_length = 0;\n    int current_length = 0;\n    while (n) {\n        if (n & 1) {\n            current_length++;\n        } else {\n            if (current_length > max_length) {\n                max_length = current_length;\n            }\n            current_length = 0;\n        }\n        n >>= 1;\n    }\n    if (current_length > max_length) {\n        max_length = current_length;\n    }\n    return max_length;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự.", "id": "int f_17(unsigned long long n)\n{\n    int max_length = 0;\n    int current_length = 0;\n    while (n) {\n        if (n & 1) {\n            current_length++;\n        } else {\n            if (current_length > max_length) {\n                max_length = current_length;\n            }\n            current_length = 0;\n        }\n        n >>= 1;\n    }\n    if (current_length > max_length) {\n        max_length = current_length;\n    }\n    return max_length;\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode CPP dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "int f_17(unsigned long long n)\n{\n    int max_length = 0;\n    int current_length = 0;\n    while (n) {\n        if (n & 1) {\n            current_length++;\n        } else {\n            if (current_length > max_length) {\n                max_length = current_length;\n            }\n            current_length = 0;\n        }\n        n >>= 1;\n    }\n    if (current_length > max_length) {\n        max_length = current_length;\n    }\n    return max_length;\n}\n\n以下のCPPコードの簡潔な自然言語による説明（ドックストリング）を日本語で500文字以内で提供してください。", "ko": "int f_17(unsigned long long n)\n{\n    int max_length = 0;\n    int current_length = 0;\n    while (n) {\n        if (n & 1) {\n            current_length++;\n        } else {\n            if (current_length > max_length) {\n                max_length = current_length;\n            }\n            current_length = 0;\n        }\n        n >>= 1;\n    }\n    if (current_length > max_length) {\n        max_length = current_length;\n    }\n    return max_length;\n}\n\n다음 CPP 코드의 동작을 최대 500자 이내의 한국어로 간결하게 설명하는 문서 문자열(docstring)을 제공하세요.", "ml": "int f_17(unsigned long long n)\n{\n    int max_length = 0;\n    int current_length = 0;\n    while (n) {\n        if (n & 1) {\n            current_length++;\n        } else {\n            if (current_length > max_length) {\n                max_length = current_length;\n            }\n            current_length = 0;\n        }\n        n >>= 1;\n    }\n    if (current_length > max_length) {\n        max_length = current_length;\n    }\n    return max_length;\n}\n\nസിപിപി കോഡിന്റെ മലയാളത്തിലുള്ള സംക്ഷിപ്ത സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) 500 അക്ഷരങ്ങളിൽ കവിയാതെയായി നൽകുക.", "fa": "int f_17(unsigned long long n)\n{\n    int max_length = 0;\n    int current_length = 0;\n    while (n) {\n        if (n & 1) {\n            current_length++;\n        } else {\n            if (current_length > max_length) {\n                max_length = current_length;\n            }\n            current_length = 0;\n        }\n        n >>= 1;\n    }\n    if (current_length > max_length) {\n        max_length = current_length;\n    }\n    return max_length;\n}\n\nتوضیح مختصر و طبیعی از کد CPP به زبان فارسی ارائه دهید که حداکثر ۵۰۰ کاراکتر باشد."}, "level": "", "test": "int main()\n{\n    assert(f_17(7) == 3);\n    assert(f_17(13) == 2);\n    assert(f_17(12345) == 3); // New test sample\n    assert(f_17(0b11011101111) == 4); // New test sample using binary literal for clarity\n    assert(f_17(0xFFFFFFFF) == 32); // New test sample: all ones for a 32-bit number\n    assert(f_17(0) == 0); // New test sample: no ones in a zero\n\n    // printf(\"All tests passed!\\n\"); // In C++, you might use std::cout, but it is commented out as per the original code.\n    return 0;\n}", "entry_point": "f_17", "signature": "int f_17(unsigned long long n)", "docstring": {"en": "Find the length of the longest consecutive sequence of 1s in the binary representation of a non-negative integer.\n\nParameters:\n- n (unsigned long long): A non-negative integer (0 ≤ n ≤ 2^64 - 1).\n\nReturns:\n- int: The length of the longest consecutive sequence of 1s in the binary representation of the given integer.\n\nExamples:\n  >>> f_17(7)\n  3\n", "sq": "Gjeni gjatësinë e sekuencës më të gjatë të njëshave radhazi në përfaqësimin binar të një numri të plotë jo-negativ.\n\nParametrat:\n- n (unsigned long long): Një numër i plotë jo-negativ (0 ≤ n ≤ 2^64 - 1).\n\nKthen:\n- int: Gjatësia e sekuencës më të gjatë të njëshave radhazi në përfaqësimin binar të numrit të dhënë.\n\nShembuj:\n  >>> f_17(7)\n  3", "hy": "Բացահայտեք 1-երի ամենաերկար հաջորդական հաջորդականության երկարությունը ոչ բացասական ամբողջ թվի երկբայնի ներկայացման մեջ:\n\nՊարամետրեր:\n- n (unsigned long long): Ոչ բացասական ամբողջ թիվ (0 ≤ n ≤ 2^64 - 1):\n\nՎերադարձնում է:\n- int: Տրված ամբողջ թվի երկբայնի ներկայացման մեջ 1-երի ամենաերկար հաջորդական հաջորդականության երկարությունը:\n\nՕրինակներ:\n  >>> f_17(7)\n  3", "bn": "একটি অ-ঋণাত্মক পূর্ণসংখ্যার বাইনারি উপস্থাপনার মধ্যে 1s এর দীর্ঘতম ক্রমাগত অনুক্রমের দৈর্ঘ্য খুঁজে বের করুন।\n\nপ্যারামিটারসমূহ:\n- n (unsigned long long): একটি অ-ঋণাত্মক পূর্ণসংখ্যা (0 ≤ n ≤ 2^64 - 1)।\n\nফেরত দেয়:\n- int: প্রদত্ত পূর্ণসংখ্যার বাইনারি উপস্থাপনায় 1-এর দীর্ঘতম ধারাবাহিক ক্রমের দৈর্ঘ্য।\n\nউদাহরণসমূহ:\n  >>> f_17(7)\n  3", "bg": "Намерете дължината на най-дългата последователна поредица от 1 в двоичното представяне на неотрицателно цяло число.\n\nПараметри:\n- n (unsigned long long): Неотрицателно цяло число (0 ≤ n ≤ 2^64 - 1).\n\nВръща:\n- int: Дължината на най-дългата последователна поредица от 1 в двоичното представяне на даденото число.\n\nПримери:\n  >>> f_17(7)\n  3", "zh": "找到非负整数的二进制表示中最长连续1序列的长度。\n\n参数:\n- n (unsigned long long): 一个非负整数 (0 ≤ n ≤ 2^64 - 1)。\n\n返回:\n- int: 给定整数的二进制表示中最长连续1序列的长度。\n\n示例:\n  >>> f_17(7)\n  3", "fr": "Trouver la longueur de la plus longue séquence consécutive de 1 dans la représentation binaire d'un entier non négatif.\n\nParamètres :\n- n (unsigned long long) : Un entier non négatif (0 ≤ n ≤ 2^64 - 1).\n\nRenvoie :\n- int : La longueur de la plus longue séquence consécutive de 1 dans la représentation binaire de l'entier donné.\n\nExemples :\n  >>> f_17(7)\n  3\n", "de": "Finden Sie die Länge der längsten aufeinanderfolgenden Sequenz von 1en in der Binärdarstellung einer nicht-negativen ganzen Zahl.\n\nParameter:\n- n (unsigned long long): Eine nicht-negative ganze Zahl (0 ≤ n ≤ 2^64 - 1).\n\nRückgabewert:\n- int: Die Länge der längsten aufeinanderfolgenden Sequenz von 1en in der Binärdarstellung der gegebenen ganzen Zahl.\n\nBeispiele:\n  >>> f_17(7)\n  3\n", "ha": "Nemo tsawon jerin jere mafi tsawo na 1s a cikin wakilcin binary na lamba mara kyau.\n\nSigogi:\n- n (unsigned long long): Wani lamba mara kyau (0 ≤ n ≤ 2^64 - 1).\n\nDawowa:\n- int: Tsawon mafi tsawo jere na 1s a cikin wakilcin binary na lambar da aka bayar.\n\nMisalai:\n  >>> f_17(7)\n  3", "hi": "एक गैर-ऋणात्मक पूर्णांक के द्विआधारी प्रतिनिधित्व में 1s के सबसे लंबे अनुक्रम की लंबाई खोजें।\n\nपैरामीटर्स:\n- n (unsigned long long): एक गैर-ऋणात्मक पूर्णांक (0 ≤ n ≤ 2^64 - 1)।\n\nवापसी:\n- int: दिए गए पूर्णांक के द्विआधारी प्रतिनिधित्व में 1s के सबसे लंबे अनुक्रम की लंबाई।\n\nउदाहरण:\n  >>> f_17(7)\n  3", "hu": "Keresse meg a leghosszabb egymást követő 1-esek sorozatának hosszát egy nem negatív egész szám bináris ábrázolásában.\n\nParaméterek:\n- n (unsigned long long): Egy nem negatív egész szám (0 ≤ n ≤ 2^64 - 1).\n\nVisszatérési érték:\n- int: A leghosszabb egymást követő 1-esek sorozatának hossza a megadott egész szám bináris ábrázolásában.\n\nPéldák:\n  >>> f_17(7)\n  3", "es": "Encuentra la longitud de la secuencia consecutiva más larga de 1s en la representación binaria de un número entero no negativo.\n\nParámetros:\n- n (unsigned long long): Un número entero no negativo (0 ≤ n ≤ 2^64 - 1).\n\nDevuelve:\n- int: La longitud de la secuencia consecutiva más larga de 1s en la representación binaria del número entero dado.\n\nEjemplos:\n  >>> f_17(7)\n  3", "arb": "إيجاد طول أطول تسلسل متتالي من الأرقام 1 في التمثيل الثنائي لعدد صحيح غير سالب.\n\nالمعلمات:\n- n (unsigned long long): عدد صحيح غير سالب (0 ≤ n ≤ 2^64 - 1).\n\nالقيم المعادة:\n- int: طول أطول تسلسل متتالي من الأرقام 1 في التمثيل الثنائي للعدد المعطى.\n\nأمثلة:\n  >>> f_17(7)\n  3", "sw": "Tafuta urefu wa mlolongo mrefu zaidi wa 1 mfululizo katika uwakilishi wa binary wa nambari isiyo hasi.\n\nVigezo:\n- n (unsigned long long): Nambari isiyo hasi (0 ≤ n ≤ 2^64 - 1).\n\nInarejesha:\n- int: Urefu wa mlolongo mrefu zaidi wa 1 mfululizo katika uwakilishi wa binary wa nambari iliyotolewa.\n\nMifano:\n  >>> f_17(7)\n  3", "tr": "Bir negatif olmayan tamsayının ikili gösterimindeki en uzun ardışık 1 dizisinin uzunluğunu bulun.\n\nParametreler:\n- n (unsigned long long): Negatif olmayan bir tam sayı (0 ≤ n ≤ 2^64 - 1).\n\nDöndürülenler:\n- int: Verilen tam sayının ikili gösterimindeki en uzun ardışık 1 dizisinin uzunluğu.\n\nÖrnekler:\n  >>> f_17(7)\n  3", "vi": "Tìm độ dài của dãy liên tiếp dài nhất của các số 1 trong biểu diễn nhị phân của một số nguyên không âm.\n\nTham số:\n- n (unsigned long long): Một số nguyên không âm (0 ≤ n ≤ 2^64 - 1).\n\nTrả về:\n- int: Độ dài của dãy liên tiếp dài nhất của các số 1 trong biểu diễn nhị phân của số nguyên đã cho.\n\nVí dụ:\n  >>> f_17(7)\n  3", "id": "Temukan panjang urutan 1 berurutan terpanjang dalam representasi biner dari bilangan bulat non-negatif.\n\nParameter:\n- n (unsigned long long): Sebuah bilangan bulat non-negatif (0 ≤ n ≤ 2^64 - 1).\n\nMengembalikan:\n- int: Panjang urutan 1 berurutan terpanjang dalam representasi biner dari bilangan bulat yang diberikan.\n\nContoh:\n  >>> f_17(7)\n  3", "ja": "非負整数の2進数表現における1の連続する最長シーケンスの長さを見つける。\n\nパラメータ:\n- n (unsigned long long): 非負の整数 (0 ≤ n ≤ 2^64 - 1)。\n\n戻り値:\n- int: 与えられた整数の2進数表現における1の最長連続シーケンスの長さ。\n\n例:\n  >>> f_17(7)\n  3", "ko": "이진 표현에서 1의 가장 긴 연속 시퀀스의 길이를 찾습니다.\n\n매개변수:\n- n (unsigned long long): 음이 아닌 정수 (0 ≤ n ≤ 2^64 - 1).\n\n반환:\n- int: 주어진 정수의 이진 표현에서 1이 연속으로 나오는 가장 긴 길이.\n\n예제:\n  >>> f_17(7)\n  3", "ml": "ഒരു അസാധാരണമായ പൂർണ്ണസംഖ്യയുടെ ബൈനറി പ്രതിനിധാനത്തിൽ. \n\nപാരാമീറ്ററുകൾ:\n- n (unsigned long long): ഒരു നെഗറ്റീവ് അല്ലാത്ത പൂർണ്ണസംഖ്യ (0 ≤ n ≤ 2^64 - 1).\n\nമടക്കം:\n- int: നൽകിയ പൂർണ്ണസംഖ്യയുടെ ബൈനറി പ്രതിനിധാനത്തിലെ ഏറ്റവും നീളമുള്ള അനന്തരമായ 1 കളുടെ ശ്രേണിയുടെ നീളം.\n\nഉദാഹരണങ്ങൾ:\n  >>> f_17(7)\n  3", "fa": "طول طولانی‌ترین دنباله متوالی از 1ها در نمایش باینری یک عدد صحیح غیرمنفی را پیدا کنید.\n\nپارامترها:\n- n (unsigned long long): یک عدد صحیح غیرمنفی (0 ≤ n ≤ 2^64 - 1).\n\nبازگشت:\n- int: طول طولانی‌ترین دنباله متوالی از 1ها در نمایش باینری عدد داده شده.\n\nمثال‌ها:\n  >>> f_17(7)\n  3"}}
{"task_id": "CPP/18", "prompt": {"en": "#include <iostream>\n#include <string>\n#include <cassert>\n/**\n * Generates a unique identifier by interweaving two words in a specified pattern.\n * @param word1 The first word to be used in the ID creation process.\n * @param word2 The second word to be used in the ID creation process.\n * @return A unique identifier formed by alternating characters from the second word,\n *         reversed, with characters from the first word.\n * Example Usage:\n * \n * f_18(\"fish\", \"cat\") returns \"ftiasch\"\n * f_18(\"icpc\", \"acm\") returns \"imccpac\"\n * \n */\nstd::string f_18(const std::string& word1, const std::string& word2)", "sq": "#include <iostream>\n#include <string>\n#include <cassert>\n/**\n * Gjeneron një identifikues unik duke ndërthurur dy fjalë në një model të specifikuar.\n * @param word1 Fjala e parë që do të përdoret në procesin e krijimit të ID-së.\n * @param word2 Fjala e dytë që do të përdoret në procesin e krijimit të ID-së.\n * @return Një identifikues unik i formuar duke alternuar karakteret nga fjala e dytë,\n *         e kthyer mbrapsht, me karakteret nga fjala e parë.\n * Shembull Përdorimi:\n * \n * f_18(\"fish\", \"cat\") returns \"ftiasch\"\n * f_18(\"icpc\", \"acm\") returns \"imccpac\"\n * \n */\nstd::string f_18(const std::string& word1, const std::string& word2)", "hy": "#include <iostream>\n#include <string>\n#include <cassert>\n/**\n * Ստեղծում է եզակի նույնացուցիչ՝ երկու բառերը որոշակի ձևով միահյուսելով:\n * @param word1 Առաջին բառը, որը կօգտագործվի ID ստեղծման գործընթացում:\n * @param word2 Երկրորդ բառը, որը կօգտագործվի ID ստեղծման գործընթացում:\n * @return Եզակի նույնացուցիչ, որը ձևավորվում է երկրորդ բառի նիշերը, հակառակ հերթականությամբ,\n *         առաջին բառի նիշերի հետ փոխարինելով:\n * Օրինակ օգտագործում:\n * \n * f_18(\"fish\", \"cat\") վերադարձնում է \"ftiasch\"\n * f_18(\"icpc\", \"acm\") վերադարձնում է \"imccpac\"\n * \n */\nstd::string f_18(const std::string& word1, const std::string& word2)", "bn": "#include <iostream>\n#include <string>\n#include <cassert>\n/**\n * একটি অনন্য শনাক্তকারী তৈরি করে দুটি শব্দকে একটি নির্দিষ্ট প্যাটার্নে আন্তঃবিন্যাস করে।\n * @param word1 শনাক্তকারী তৈরির প্রক্রিয়ায় ব্যবহৃত প্রথম শব্দ।\n * @param word2 শনাক্তকারী তৈরির প্রক্রিয়ায় ব্যবহৃত দ্বিতীয় শব্দ।\n * @return একটি অনন্য শনাক্তকারী যা দ্বিতীয় শব্দের অক্ষরগুলি, উল্টানো অবস্থায়,\n *         প্রথম শব্দের অক্ষরগুলির সাথে পর্যায়ক্রমে বিন্যাস করে গঠিত।\n * উদাহরণ ব্যবহার:\n * \n * f_18(\"fish\", \"cat\") returns \"ftiasch\"\n * f_18(\"icpc\", \"acm\") returns \"imccpac\"\n * \n */\nstd::string f_18(const std::string& word1, const std::string& word2)", "bg": "#include <iostream>\n#include <string>\n#include <cassert>\n/**\n * Генерира уникален идентификатор чрез преплитане на две думи в определен модел.\n * @param word1 Първата дума, която ще се използва в процеса на създаване на ID.\n * @param word2 Втората дума, която ще се използва в процеса на създаване на ID.\n * @return Уникален идентификатор, образуван чрез редуване на символи от втората дума,\n *         обърната, със символи от първата дума.\n * Пример за използване:\n * \n * f_18(\"fish\", \"cat\") връща \"ftiasch\"\n * f_18(\"icpc\", \"acm\") връща \"imccpac\"\n * \n */\nstd::string f_18(const std::string& word1, const std::string& word2)", "zh": "#include <iostream>\n#include <string>\n#include <cassert>\n/**\n * 通过以指定模式交错两个单词来生成唯一标识符。\n * @param word1 在ID创建过程中使用的第一个单词。\n * @param word2 在ID创建过程中使用的第二个单词。\n * @return 一个唯一标识符，由第二个单词的字符反转后与第一个单词的字符交替形成。\n * 示例用法:\n * \n * f_18(\"fish\", \"cat\") 返回 \"ftiasch\"\n * f_18(\"icpc\", \"acm\") 返回 \"imccpac\"\n * \n */\nstd::string f_18(const std::string& word1, const std::string& word2)", "fr": "#include <iostream>\n#include <string>\n#include <cassert>\n/**\n * Génère un identifiant unique en entrelaçant deux mots selon un schéma spécifié.\n * @param word1 Le premier mot à utiliser dans le processus de création de l'ID.\n * @param word2 Le deuxième mot à utiliser dans le processus de création de l'ID.\n * @return Un identifiant unique formé en alternant des caractères du deuxième mot,\n *         inversé, avec des caractères du premier mot.\n * Exemple d'utilisation :\n * \n * f_18(\"fish\", \"cat\") returns \"ftiasch\"\n * f_18(\"icpc\", \"acm\") returns \"imccpac\"\n * \n */\nstd::string f_18(const std::string& word1, const std::string& word2)", "de": "#include <iostream>\n#include <string>\n#include <cassert>\n/**\n * Generiert eine eindeutige Kennung, indem zwei Wörter in einem bestimmten Muster verflochten werden.\n * @param word1 Das erste Wort, das im ID-Erstellungsprozess verwendet wird.\n * @param word2 Das zweite Wort, das im ID-Erstellungsprozess verwendet wird.\n * @return Eine eindeutige Kennung, die durch abwechselnde Zeichen des zweiten Wortes,\n *         umgekehrt, mit Zeichen des ersten Wortes gebildet wird.\n * Beispielverwendung:\n * \n * f_18(\"fish\", \"cat\") gibt \"ftiasch\" zurück\n * f_18(\"icpc\", \"acm\") gibt \"imccpac\" zurück\n * \n */\nstd::string f_18(const std::string& word1, const std::string& word2)", "ha": "#include <iostream>\n#include <string>\n#include <cassert>\n/**\n * Yana samar da mai ganowa na musamman ta hanyar haɗa kalmomi biyu a cikin tsarin da aka fayyace.\n * @param word1 Kalma ta farko da za a yi amfani da ita a cikin tsarin ƙirƙirar ID.\n * @param word2 Kalma ta biyu da za a yi amfani da ita a cikin tsarin ƙirƙirar ID.\n * @return Mai ganowa na musamman da aka samar ta hanyar musanya haruffa daga kalma ta biyu,\n *         a juye, tare da haruffa daga kalma ta farko.\n * Misalin Amfani:\n * \n * f_18(\"fish\", \"cat\") returns \"ftiasch\"\n * f_18(\"icpc\", \"acm\") returns \"imccpac\"\n * \n */\nstd::string f_18(const std::string& word1, const std::string& word2)", "hi": "#include <iostream>\n#include <string>\n#include <cassert>\n/**\n * दो शब्दों को एक निर्दिष्ट पैटर्न में मिलाकर एक अद्वितीय पहचानकर्ता उत्पन्न करता है।\n * @param word1 पहचानकर्ता निर्माण प्रक्रिया में उपयोग के लिए पहला शब्द।\n * @param word2 पहचानकर्ता निर्माण प्रक्रिया में उपयोग के लिए दूसरा शब्द।\n * @return एक अद्वितीय पहचानकर्ता जो दूसरे शब्द के वर्णों को उल्टा करके,\n *         पहले शब्द के वर्णों के साथ बारी-बारी से बनता है।\n * उदाहरण उपयोग:\n * \n * f_18(\"fish\", \"cat\") returns \"ftiasch\"\n * f_18(\"icpc\", \"acm\") returns \"imccpac\"\n * \n */\nstd::string f_18(const std::string& word1, const std::string& word2)", "hu": "#include <iostream>\n#include <string>\n#include <cassert>\n/**\n * Egyedi azonosítót generál két szó összefonásával egy meghatározott mintában.\n * @param word1 Az első szó, amelyet az azonosító létrehozásához használunk.\n * @param word2 A második szó, amelyet az azonosító létrehozásához használunk.\n * @return Egy egyedi azonosító, amely a második szó karaktereinek váltakozásával,\n *         fordítva, az első szó karaktereivel van kialakítva.\n * Példa használat:\n * \n * f_18(\"fish\", \"cat\") visszatér \"ftiasch\"\n * f_18(\"icpc\", \"acm\") visszatér \"imccpac\"\n * \n */\nstd::string f_18(const std::string& word1, const std::string& word2)", "es": "#include <iostream>\n#include <string>\n#include <cassert>\n/**\n * Genera un identificador único entrelazando dos palabras en un patrón especificado.\n * @param word1 La primera palabra que se utilizará en el proceso de creación del ID.\n * @param word2 La segunda palabra que se utilizará en el proceso de creación del ID.\n * @return Un identificador único formado alternando caracteres de la segunda palabra,\n *         invertida, con caracteres de la primera palabra.\n * Ejemplo de uso:\n * \n * f_18(\"fish\", \"cat\") returns \"ftiasch\"\n * f_18(\"icpc\", \"acm\") returns \"imccpac\"\n * \n */\nstd::string f_18(const std::string& word1, const std::string& word2)", "arb": "#include <iostream>\n#include <string>\n#include <cassert>\n/**\n * ينشئ معرفًا فريدًا عن طريق تشابك كلمتين بنمط محدد.\n * @param word1 الكلمة الأولى التي سيتم استخدامها في عملية إنشاء المعرف.\n * @param word2 الكلمة الثانية التي سيتم استخدامها في عملية إنشاء المعرف.\n * @return معرف فريد يتكون من تبديل الأحرف من الكلمة الثانية،\n *         معكوسة، مع الأحرف من الكلمة الأولى.\n * مثال على الاستخدام:\n * \n * f_18(\"fish\", \"cat\") returns \"ftiasch\"\n * f_18(\"icpc\", \"acm\") returns \"imccpac\"\n * \n */\nstd::string f_18(const std::string& word1, const std::string& word2)", "sw": "#include <iostream>\n#include <string>\n#include <cassert>\n/**\n * Hutengeneza kitambulisho cha kipekee kwa kuchanganya maneno mawili kwa mtindo maalum.\n * @param word1 Neno la kwanza litakalotumika katika mchakato wa kuunda kitambulisho.\n * @param word2 Neno la pili litakalotumika katika mchakato wa kuunda kitambulisho.\n * @return Kitambulisho cha kipekee kinachoundwa kwa kubadilisha herufi kutoka neno la pili,\n *         lililogeuzwa, na herufi kutoka neno la kwanza.\n * Mfano wa Matumizi:\n * \n * f_18(\"fish\", \"cat\") returns \"ftiasch\"\n * f_18(\"icpc\", \"acm\") returns \"imccpac\"\n * \n */\nstd::string f_18(const std::string& word1, const std::string& word2)", "tr": "#include <iostream>\n#include <string>\n#include <cassert>\n/**\n * Belirli bir desende iki kelimeyi iç içe geçirerek benzersiz bir kimlik oluşturur.\n * @param word1 Kimlik oluşturma sürecinde kullanılacak ilk kelime.\n * @param word2 Kimlik oluşturma sürecinde kullanılacak ikinci kelime.\n * @return İkinci kelimenin karakterlerinin ters çevrilmiş haliyle, \n *         birinci kelimenin karakterlerinin dönüşümlü olarak kullanılmasıyla oluşturulan benzersiz bir kimlik.\n * Örnek Kullanım:\n * \n * f_18(\"fish\", \"cat\") returns \"ftiasch\"\n * f_18(\"icpc\", \"acm\") returns \"imccpac\"\n * \n */\nstd::string f_18(const std::string& word1, const std::string& word2)", "vi": "#include <iostream>\n#include <string>\n#include <cassert>\n/**\n * Tạo một định danh duy nhất bằng cách xen kẽ hai từ theo một mẫu được chỉ định.\n * @param word1 Từ đầu tiên được sử dụng trong quá trình tạo ID.\n * @param word2 Từ thứ hai được sử dụng trong quá trình tạo ID.\n * @return Một định danh duy nhất được tạo bằng cách xen kẽ các ký tự từ từ thứ hai,\n *         đảo ngược, với các ký tự từ từ đầu tiên.\n * Ví dụ Sử dụng:\n * \n * f_18(\"fish\", \"cat\") trả về \"ftiasch\"\n * f_18(\"icpc\", \"acm\") trả về \"imccpac\"\n * \n */\nstd::string f_18(const std::string& word1, const std::string& word2)", "id": "#include <iostream>\n#include <string>\n#include <cassert>\n/**\n * Menghasilkan pengenal unik dengan menyisipkan dua kata dalam pola tertentu.\n * @param word1 Kata pertama yang akan digunakan dalam proses pembuatan ID.\n * @param word2 Kata kedua yang akan digunakan dalam proses pembuatan ID.\n * @return Pengenal unik yang dibentuk dengan mengganti-ganti karakter dari kata kedua,\n *         dibalik, dengan karakter dari kata pertama.\n * Contoh Penggunaan:\n * \n * f_18(\"fish\", \"cat\") mengembalikan \"ftiasch\"\n * f_18(\"icpc\", \"acm\") mengembalikan \"imccpac\"\n * \n */\nstd::string f_18(const std::string& word1, const std::string& word2)", "ja": "#include <iostream>\n#include <string>\n#include <cassert>\n/**\n * 2つの単語を指定されたパターンで交互に組み合わせてユニークな識別子を生成します。\n * @param word1 ID作成プロセスで使用する最初の単語。\n * @param word2 ID作成プロセスで使用する2番目の単語。\n * @return 2番目の単語を逆にして、最初の単語と交互に文字を組み合わせて形成されたユニークな識別子。\n * 使用例:\n * \n * f_18(\"fish\", \"cat\") returns \"ftiasch\"\n * f_18(\"icpc\", \"acm\") returns \"imccpac\"\n * \n */\nstd::string f_18(const std::string& word1, const std::string& word2)", "ko": "#include <iostream>\n#include <string>\n#include <cassert>\n/**\n * 두 단어를 지정된 패턴으로 엮어 고유 식별자를 생성합니다.\n * @param word1 ID 생성 과정에서 사용될 첫 번째 단어입니다.\n * @param word2 ID 생성 과정에서 사용될 두 번째 단어입니다.\n * @return 두 번째 단어의 문자를 첫 번째 단어의 문자와 교대로 사용하여\n *         뒤집힌 형태로 형성된 고유 식별자를 반환합니다.\n * 사용 예:\n * \n * f_18(\"fish\", \"cat\") returns \"ftiasch\"\n * f_18(\"icpc\", \"acm\") returns \"imccpac\"\n * \n */\nstd::string f_18(const std::string& word1, const std::string& word2)", "ml": "#include <iostream>\n#include <string>\n#include <cassert>\n/**\n * രണ്ട് വാക്കുകൾ ഒരു നിർദ്ദിഷ്ട മാതൃകയിൽ ഇണചേർത്ത് ഒരു അനന്യമായ ഐഡന്റിഫയർ സൃഷ്ടിക്കുന്നു.\n * @param word1 ഐഡി സൃഷ്ടിക്കൽ പ്രക്രിയയിൽ ഉപയോഗിക്കേണ്ട ആദ്യത്തെ വാക്ക്.\n * @param word2 ഐഡി സൃഷ്ടിക്കൽ പ്രക്രിയയിൽ ഉപയോഗിക്കേണ്ട രണ്ടാമത്തെ വാക്ക്.\n * @return രണ്ടാമത്തെ വാക്കിലെ പ്രത്യയങ്ങൾ, മറിച്ചുള്ളവ, ആദ്യത്തെ വാക്കിലെ പ്രത്യയങ്ങളുമായി മാറി, രൂപീകരിച്ച ഒരു അനന്യമായ ഐഡന്റിഫയർ.\n * ഉദാഹരണ ഉപയോഗം:\n * \n * f_18(\"fish\", \"cat\") returns \"ftiasch\"\n * f_18(\"icpc\", \"acm\") returns \"imccpac\"\n * \n */\nstd::string f_18(const std::string& word1, const std::string& word2)", "fa": "#include <iostream>\n#include <string>\n#include <cassert>\n/**\n * تولید یک شناسه منحصر به فرد با در هم آمیختن دو کلمه در یک الگوی مشخص.\n * @param word1 اولین کلمه‌ای که در فرآیند ایجاد شناسه استفاده می‌شود.\n * @param word2 دومین کلمه‌ای که در فرآیند ایجاد شناسه استفاده می‌شود.\n * @return یک شناسه منحصر به فرد که با جایگزینی کاراکترهای کلمه دوم،\n *         به صورت معکوس، با کاراکترهای کلمه اول تشکیل می‌شود.\n * مثال استفاده:\n * \n * f_18(\"fish\", \"cat\") returns \"ftiasch\"\n * f_18(\"icpc\", \"acm\") returns \"imccpac\"\n * \n */\nstd::string f_18(const std::string& word1, const std::string& word2)"}, "canonical_solution": "{\n    std::string id;\n    int j = 0, k = word2.length() - 1;\n    for (int i = 0; i < word1.length() + word2.length(); ++i) {\n        if (i % 2 == 0) {\n            id += word1[j++]; // Take character from word1\n        } else {\n            id += word2[k--]; // Take character from word2 in reverse\n        }\n    }\n    return id;\n}", "instruction": {"en": "std::string f_18(const std::string& word1, const std::string& word2)\n{\n    std::string id;\n    int j = 0, k = word2.length() - 1;\n    for (int i = 0; i < word1.length() + word2.length(); ++i) {\n        if (i % 2 == 0) {\n            id += word1[j++]; // Take character from word1\n        } else {\n            id += word2[k--]; // Take character from word2 in reverse\n        }\n    }\n    return id;\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.", "sq": "std::string f_18(const std::string& word1, const std::string& word2)\n{\n    std::string id;\n    int j = 0, k = word2.length() - 1;\n    for (int i = 0; i < word1.length() + word2.length(); ++i) {\n        if (i % 2 == 0) {\n            id += word1[j++]; // Take character from word1\n        } else {\n            id += word2[k--]; // Take character from word2 in reverse\n        }\n    }\n    return id;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrale (docstring) të kodit CPP në shqip duke përdorur maksimumi 500 karaktere.", "hy": "std::string f_18(const std::string& word1, const std::string& word2)\n{\n    std::string id;\n    int j = 0, k = word2.length() - 1;\n    for (int i = 0; i < word1.length() + word2.length(); ++i) {\n        if (i % 2 == 0) {\n            id += word1[j++]; // Take character from word1\n        } else {\n            id += word2[k--]; // Take character from word2 in reverse\n        }\n    }\n    return id;\n}\n\nՏվյալ CPP կոդի համար տրամադրեք հակիրճ բնութագիր (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "std::string f_18(const std::string& word1, const std::string& word2)\n{\n    std::string id;\n    int j = 0, k = word2.length() - 1;\n    for (int i = 0; i < word1.length() + word2.length(); ++i) {\n        if (i % 2 == 0) {\n            id += word1[j++]; // Take character from word1\n        } else {\n            id += word2[k--]; // Take character from word2 in reverse\n        }\n    }\n    return id;\n}\n\nসিপিপি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।", "bg": "std::string f_18(const std::string& word1, const std::string& word2)\n{\n    std::string id;\n    int j = 0, k = word2.length() - 1;\n    for (int i = 0; i < word1.length() + word2.length(); ++i) {\n        if (i % 2 == 0) {\n            id += word1[j++]; // Take character from word1\n        } else {\n            id += word2[k--]; // Take character from word2 in reverse\n        }\n    }\n    return id;\n}\n\nПредоставете кратко описание на CPP кода на естествен език (docstring) на български, използвайки най-много 500 знака.", "zh": "std::string f_18(const std::string& word1, const std::string& word2)\n{\n    std::string id;\n    int j = 0, k = word2.length() - 1;\n    for (int i = 0; i < word1.length() + word2.length(); ++i) {\n        if (i % 2 == 0) {\n            id += word1[j++]; // Take character from word1\n        } else {\n            id += word2[k--]; // Take character from word2 in reverse\n        }\n    }\n    return id;\n}\n\n请用不超过500个字符的中文，为以下CPP代码提供简洁的自然语言描述（文档字符串）。", "fr": "std::string f_18(const std::string& word1, const std::string& word2)\n{\n    std::string id;\n    int j = 0, k = word2.length() - 1;\n    for (int i = 0; i < word1.length() + word2.length(); ++i) {\n        if (i % 2 == 0) {\n            id += word1[j++]; // Take character from word1\n        } else {\n            id += word2[k--]; // Take character from word2 in reverse\n        }\n    }\n    return id;\n}\n\nFournissez une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.", "de": "std::string f_18(const std::string& word1, const std::string& word2)\n{\n    std::string id;\n    int j = 0, k = word2.length() - 1;\n    for (int i = 0; i < word1.length() + word2.length(); ++i) {\n        if (i % 2 == 0) {\n            id += word1[j++]; // Take character from word1\n        } else {\n            id += word2[k--]; // Take character from word2 in reverse\n        }\n    }\n    return id;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen.", "ha": "std::string f_18(const std::string& word1, const std::string& word2)\n{\n    std::string id;\n    int j = 0, k = word2.length() - 1;\n    for (int i = 0; i < word1.length() + word2.length(); ++i) {\n        if (i % 2 == 0) {\n            id += word1[j++]; // Take character from word1\n        } else {\n            id += word2[k--]; // Take character from word2 in reverse\n        }\n    }\n    return id;\n}\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar CPP a cikin Hausa ta amfani da haruffa 500 kawai.", "hi": "std::string f_18(const std::string& word1, const std::string& word2)\n{\n    std::string id;\n    int j = 0, k = word2.length() - 1;\n    for (int i = 0; i < word1.length() + word2.length(); ++i) {\n        if (i % 2 == 0) {\n            id += word1[j++]; // Take character from word1\n        } else {\n            id += word2[k--]; // Take character from word2 in reverse\n        }\n    }\n    return id;\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "std::string f_18(const std::string& word1, const std::string& word2)\n{\n    std::string id;\n    int j = 0, k = word2.length() - 1;\n    for (int i = 0; i < word1.length() + word2.length(); ++i) {\n        if (i % 2 == 0) {\n            id += word1[j++]; // Take character from word1\n        } else {\n            id += word2[k--]; // Take character from word2 in reverse\n        }\n    }\n    return id;\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a CPP kódról magyar nyelven, legfeljebb 500 karakterben.", "es": "std::string f_18(const std::string& word1, const std::string& word2)\n{\n    std::string id;\n    int j = 0, k = word2.length() - 1;\n    for (int i = 0; i < word1.length() + word2.length(); ++i) {\n        if (i % 2 == 0) {\n            id += word1[j++]; // Take character from word1\n        } else {\n            id += word2[k--]; // Take character from word2 in reverse\n        }\n    }\n    return id;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando como máximo 500 caracteres.", "arb": "std::string f_18(const std::string& word1, const std::string& word2)\n{\n    std::string id;\n    int j = 0, k = word2.length() - 1;\n    for (int i = 0; i < word1.length() + word2.length(); ++i) {\n        if (i % 2 == 0) {\n            id += word1[j++]; // Take character from word1\n        } else {\n            id += word2[k--]; // Take character from word2 in reverse\n        }\n    }\n    return id;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C++ باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "std::string f_18(const std::string& word1, const std::string& word2)\n{\n    std::string id;\n    int j = 0, k = word2.length() - 1;\n    for (int i = 0; i < word1.length() + word2.length(); ++i) {\n        if (i % 2 == 0) {\n            id += word1[j++]; // Take character from word1\n        } else {\n            id += word2[k--]; // Take character from word2 in reverse\n        }\n    }\n    return id;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "std::string f_18(const std::string& word1, const std::string& word2)\n{\n    std::string id;\n    int j = 0, k = word2.length() - 1;\n    for (int i = 0; i < word1.length() + word2.length(); ++i) {\n        if (i % 2 == 0) {\n            id += word1[j++]; // Take character from word1\n        } else {\n            id += word2[k--]; // Take character from word2 in reverse\n        }\n    }\n    return id;\n}\n\nAşağıdaki CPP kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda özlü bir doğal dil açıklaması (docstring) sağlayın.", "vi": "std::string f_18(const std::string& word1, const std::string& word2)\n{\n    std::string id;\n    int j = 0, k = word2.length() - 1;\n    for (int i = 0; i < word1.length() + word2.length(); ++i) {\n        if (i % 2 == 0) {\n            id += word1[j++]; // Take character from word1\n        } else {\n            id += word2[k--]; // Take character from word2 in reverse\n        }\n    }\n    return id;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự.", "id": "std::string f_18(const std::string& word1, const std::string& word2)\n{\n    std::string id;\n    int j = 0, k = word2.length() - 1;\n    for (int i = 0; i < word1.length() + word2.length(); ++i) {\n        if (i % 2 == 0) {\n            id += word1[j++]; // Take character from word1\n        } else {\n            id += word2[k--]; // Take character from word2 in reverse\n        }\n    }\n    return id;\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode CPP dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "std::string f_18(const std::string& word1, const std::string& word2)\n{\n    std::string id;\n    int j = 0, k = word2.length() - 1;\n    for (int i = 0; i < word1.length() + word2.length(); ++i) {\n        if (i % 2 == 0) {\n            id += word1[j++]; // Take character from word1\n        } else {\n            id += word2[k--]; // Take character from word2 in reverse\n        }\n    }\n    return id;\n}\n\n以下のCPPコードの簡潔な自然言語による説明（ドックストリング）を日本語で500文字以内で提供してください。", "ko": "std::string f_18(const std::string& word1, const std::string& word2)\n{\n    std::string id;\n    int j = 0, k = word2.length() - 1;\n    for (int i = 0; i < word1.length() + word2.length(); ++i) {\n        if (i % 2 == 0) {\n            id += word1[j++]; // Take character from word1\n        } else {\n            id += word2[k--]; // Take character from word2 in reverse\n        }\n    }\n    return id;\n}\n\n다음 CPP 코드의 동작을 최대 500자 이내의 자연어로 간결하게 설명하는 문서 문자열(docstring)을 한국어로 제공하세요.", "ml": "std::string f_18(const std::string& word1, const std::string& word2)\n{\n    std::string id;\n    int j = 0, k = word2.length() - 1;\n    for (int i = 0; i < word1.length() + word2.length(); ++i) {\n        if (i % 2 == 0) {\n            id += word1[j++]; // Take character from word1\n        } else {\n            id += word2[k--]; // Take character from word2 in reverse\n        }\n    }\n    return id;\n}\n\nCPP കോഡ് varten 500 അക്ഷരങ്ങളിൽ കൂടാത്ത ഒരു സംക്ഷിപ്തമായ സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) മലയാളത്തിൽ നൽകുക.", "fa": "std::string f_18(const std::string& word1, const std::string& word2)\n{\n    std::string id;\n    int j = 0, k = word2.length() - 1;\n    for (int i = 0; i < word1.length() + word2.length(); ++i) {\n        if (i % 2 == 0) {\n            id += word1[j++]; // Take character from word1\n        } else {\n            id += word2[k--]; // Take character from word2 in reverse\n        }\n    }\n    return id;\n}\n\nتوضیح مختصر و طبیعی (docstring) از کد CPP به زبان فارسی ارائه دهید که حداکثر ۵۰۰ کاراکتر باشد."}, "level": "", "test": "int main() {\n    std::string id; // To hold the results from f_18\n\n    id = f_18(\"fish\", \"cat\");\n    assert(id.compare(\"ftiasch\") == 0);\n\n    id = f_18(\"icpc\", \"acm\");\n    assert(id.compare(\"imccpac\") == 0);\n\n    id = f_18(\"oo\", \"w\");\n    assert(id.compare(\"owo\") == 0);\n\n    // Add more test samples\n    id = f_18(\"hello\", \"world\");\n    assert(id.compare(\"hdellrloow\") == 0);\n\n    id = f_18(\"abc\", \"def\");\n    assert(id.compare(\"afbecd\") == 0);\n\n    id = f_18(\"buaanb\", \"nbbuaa\");\n    assert(id.compare(\"bauaauabnbbn\") == 0);\n\n    id = f_18(\"xtuisgood\", \"ilovextu\");\n    assert(id.compare(\"xuttuxiesvgooloid\") == 0);\n\n    // std::cout << \"All tests passed!\" << std::endl;\n\n    return 0;\n}", "entry_point": "f_18", "signature": "std::string f_18(const std::string& word1, const std::string& word2)", "docstring": {"en": "Generates a unique identifier by interweaving two words in a specified pattern.\n@param word1 The first word to be used in the ID creation process.\n@param word2 The second word to be used in the ID creation process.\n@return A unique identifier formed by alternating characters from the second word, reversed, with characters from the first word.\nExample Usage:\n\nf_18(\"fish\", \"cat\") returns \"ftiasch\"\nf_18(\"icpc\", \"acm\") returns \"imccpac\"\n\n", "sq": "Gjeneron një identifikues unik duke ndërthurur dy fjalë sipas një modeli të specifikuar.\n@param word1 Fjala e parë që do të përdoret në procesin e krijimit të ID-së.\n@param word2 Fjala e dytë që do të përdoret në procesin e krijimit të ID-së.\n@return Një identifikues unik i formuar duke alternuar karakteret nga fjala e dytë, e kthyer mbrapsht, me karakteret nga fjala e parë.\nShembull i Përdorimit:\n\nf_18(\"fish\", \"cat\") kthen \"ftiasch\"\nf_18(\"icpc\", \"acm\") kthen \"imccpac\"", "hy": "Ստեղծում է եզակի նույնացուցիչ՝ երկու բառերը որոշակի նախշով միահյուսելով:\n@param word1 Առաջին բառը, որը կօգտագործվի ID ստեղծման գործընթացում:\n@param word2 Երկրորդ բառը, որը կօգտագործվի ID ստեղծման գործընթացում:\n@return Եզակի նույնացուցիչ, որը ձևավորվում է երկրորդ բառի, հակադարձված, և առաջին բառի տառերը հերթագայելով:\nՕրինակ օգտագործում:\n\nf_18(\"fish\", \"cat\") վերադարձնում է \"ftiasch\"\nf_18(\"icpc\", \"acm\") վերադարձնում է \"imccpac\"", "bn": "একটি নির্দিষ্ট প্যাটার্নে দুটি শব্দ একত্রিত করে একটি অনন্য শনাক্তকারী তৈরি করে।\n@param word1 আইডি তৈরির প্রক্রিয়ায় ব্যবহৃত প্রথম শব্দ।\n@param word2 আইডি তৈরির প্রক্রিয়ায় ব্যবহৃত দ্বিতীয় শব্দ।\n@return দ্বিতীয় শব্দের অক্ষরগুলি, উল্টো করে, প্রথম শব্দের অক্ষরগুলির সাথে পর্যায়ক্রমে মিলিয়ে গঠিত একটি অনন্য শনাক্তকারী।\nব্যবহারের উদাহরণ:\n\nf_18(\"fish\", \"cat\") returns \"ftiasch\"\nf_18(\"icpc\", \"acm\") returns \"imccpac\"", "bg": "Генерира уникален идентификатор чрез преплитане на две думи в определен модел.\n@param word1 Първата дума, която ще се използва в процеса на създаване на идентификатора.\n@param word2 Втората дума, която ще се използва в процеса на създаване на идентификатора.\n@return Уникален идентификатор, образуван чрез редуване на символи от втората дума, обърната, със символи от първата дума.\nПример за използване:\n\nf_18(\"fish\", \"cat\") връща \"ftiasch\"\nf_18(\"icpc\", \"acm\") връща \"imccpac\"", "zh": "生成一个唯一标识符，通过以指定模式交织两个单词来实现。\n@param word1 用于创建ID的第一个单词。\n@param word2 用于创建ID的第二个单词。\n@return 一个唯一标识符，通过从第二个单词反向交替字符与第一个单词的字符形成。\n示例用法：\n\nf_18(\"fish\", \"cat\") 返回 \"ftiasch\"\nf_18(\"icpc\", \"acm\") 返回 \"imccpac\"", "fr": "Génère un identifiant unique en entrelaçant deux mots selon un modèle spécifié.\n@param word1 Le premier mot à utiliser dans le processus de création de l'ID.\n@param word2 Le deuxième mot à utiliser dans le processus de création de l'ID.\n@return Un identifiant unique formé en alternant des caractères du deuxième mot, inversé, avec des caractères du premier mot.\nExemple d'utilisation :\n\nf_18(\"fish\", \"cat\") retourne \"ftiasch\"\nf_18(\"icpc\", \"acm\") retourne \"imccpac\"", "de": "Erzeugt einen eindeutigen Bezeichner, indem zwei Wörter in einem bestimmten Muster miteinander verflochten werden.\n@param word1 Das erste Wort, das im ID-Erstellungsprozess verwendet wird.\n@param word2 Das zweite Wort, das im ID-Erstellungsprozess verwendet wird.\n@return Ein eindeutiger Bezeichner, der durch abwechselnde Zeichen aus dem zweiten Wort, umgekehrt, mit Zeichen aus dem ersten Wort gebildet wird.\nBeispielverwendung:\n\nf_18(\"fish\", \"cat\") gibt \"ftiasch\" zurück\nf_18(\"icpc\", \"acm\") gibt \"imccpac\" zurück", "ha": "Yana haifar da mai gano na musamman ta hanyar haɗa kalmomi biyu a cikin tsari da aka fayyace.\n@param word1 Kalma ta farko da za a yi amfani da ita a cikin tsarin ƙirƙirar ID.\n@param word2 Kalma ta biyu da za a yi amfani da ita a cikin tsarin ƙirƙirar ID.\n@return Mai gano na musamman da aka samar ta hanyar madadin haruffa daga kalma ta biyu, da aka juya, tare da haruffa daga kalma ta farko.\nMisalin Amfani:\n\nf_18(\"fish\", \"cat\") returns \"ftiasch\"\nf_18(\"icpc\", \"acm\") returns \"imccpac\"", "hi": "दो शब्दों को एक निर्दिष्ट पैटर्न में मिलाकर एक अद्वितीय पहचानकर्ता उत्पन्न करता है।\n@param word1 आईडी निर्माण प्रक्रिया में उपयोग किए जाने वाला पहला शब्द।\n@param word2 आईडी निर्माण प्रक्रिया में उपयोग किए जाने वाला दूसरा शब्द।\n@return एक अद्वितीय पहचानकर्ता जो दूसरे शब्द के अक्षरों को उलट कर, पहले शब्द के अक्षरों के साथ बारी-बारी से बनता है।\nउदाहरण उपयोग:\n\nf_18(\"fish\", \"cat\") returns \"ftiasch\"\nf_18(\"icpc\", \"acm\") returns \"imccpac\"", "hu": "Egyedi azonosítót generál két szó meghatározott mintázat szerinti összefonásával.\n@param word1 Az első szó, amelyet az azonosító létrehozási folyamatában használunk.\n@param word2 A második szó, amelyet az azonosító létrehozási folyamatában használunk.\n@return Egyedi azonosító, amelyet a második szó visszafelé vett karaktereinek és az első szó karaktereinek váltakozásával hozunk létre.\nPélda használat:\n\nf_18(\"fish\", \"cat\") visszaadja \"ftiasch\"\nf_18(\"icpc\", \"acm\") visszaadja \"imccpac\"", "es": "Genera un identificador único entrelazando dos palabras en un patrón especificado.\n@param word1 La primera palabra que se utilizará en el proceso de creación del ID.\n@param word2 La segunda palabra que se utilizará en el proceso de creación del ID.\n@return Un identificador único formado alternando caracteres de la segunda palabra, invertida, con caracteres de la primera palabra.\nEjemplo de uso:\n\nf_18(\"fish\", \"cat\") devuelve \"ftiasch\"\nf_18(\"icpc\", \"acm\") devuelve \"imccpac\"", "arb": "ينشئ معرفًا فريدًا عن طريق تشابك كلمتين بنمط محدد.\n@param word1 الكلمة الأولى التي سيتم استخدامها في عملية إنشاء المعرف.\n@param word2 الكلمة الثانية التي سيتم استخدامها في عملية إنشاء المعرف.\n@return معرف فريد يتكون من تبديل الأحرف من الكلمة الثانية، معكوسة، مع الأحرف من الكلمة الأولى.\nمثال على الاستخدام:\n\nf_18(\"fish\", \"cat\") returns \"ftiasch\"\nf_18(\"icpc\", \"acm\") returns \"imccpac\"", "sw": "Hutengeneza kitambulisho cha kipekee kwa kuchanganya maneno mawili kwa mtindo maalum.\n@param word1 Neno la kwanza litakalotumika katika mchakato wa kuunda kitambulisho.\n@param word2 Neno la pili litakalotumika katika mchakato wa kuunda kitambulisho.\n@return Kitambulisho cha kipekee kinachoundwa kwa kubadilishana herufi kutoka neno la pili, lililogeuzwa, na herufi kutoka neno la kwanza.\nMfano wa Matumizi:\n\nf_18(\"fish\", \"cat\") inarudisha \"ftiasch\"\nf_18(\"icpc\", \"acm\") inarudisha \"imccpac\"", "tr": "Belirtilen bir desende iki kelimeyi iç içe geçirerek benzersiz bir tanımlayıcı oluşturur.\n@param word1 ID oluşturma sürecinde kullanılacak ilk kelime.\n@param word2 ID oluşturma sürecinde kullanılacak ikinci kelime.\n@return İkinci kelimenin karakterlerinin ters çevrilmiş hali ile birinci kelimenin karakterlerinin dönüşümlü olarak kullanılmasıyla oluşturulmuş benzersiz bir tanımlayıcı.\nÖrnek Kullanım:\n\nf_18(\"fish\", \"cat\") returns \"ftiasch\"\nf_18(\"icpc\", \"acm\") returns \"imccpac\"", "vi": "Tạo một định danh duy nhất bằng cách xen kẽ hai từ theo một mẫu được chỉ định.\n@param word1 Từ đầu tiên được sử dụng trong quá trình tạo ID.\n@param word2 Từ thứ hai được sử dụng trong quá trình tạo ID.\n@return Một định danh duy nhất được tạo ra bằng cách xen kẽ các ký tự từ từ thứ hai, đảo ngược, với các ký tự từ từ thứ nhất.\nVí dụ Sử dụng:\n\nf_18(\"fish\", \"cat\") trả về \"ftiasch\"\nf_18(\"icpc\", \"acm\") trả về \"imccpac\"", "id": "Menghasilkan pengenal unik dengan menyisipkan dua kata dalam pola yang ditentukan.\n@param word1 Kata pertama yang akan digunakan dalam proses pembuatan ID.\n@param word2 Kata kedua yang akan digunakan dalam proses pembuatan ID.\n@return Pengenal unik yang dibentuk dengan karakter bergantian dari kata kedua, dibalik, dengan karakter dari kata pertama.\nContoh Penggunaan:\n\nf_18(\"fish\", \"cat\") mengembalikan \"ftiasch\"\nf_18(\"icpc\", \"acm\") mengembalikan \"imccpac\"", "ja": "2つの単語を指定されたパターンで交互に組み合わせてユニークな識別子を生成します。\n@param word1 ID作成プロセスで使用される最初の単語。\n@param word2 ID作成プロセスで使用される2番目の単語。\n@return 2番目の単語を逆順にした文字と1番目の単語の文字を交互に組み合わせて形成されたユニークな識別子。\n使用例:\n\nf_18(\"fish\", \"cat\") は \"ftiasch\" を返します\nf_18(\"icpc\", \"acm\") は \"imccpac\" を返します", "ko": "두 단어를 지정된 패턴으로 엮어 고유 식별자를 생성합니다.\n@param word1 ID 생성 과정에서 사용될 첫 번째 단어입니다.\n@param word2 ID 생성 과정에서 사용될 두 번째 단어입니다.\n@return 두 번째 단어의 문자를 뒤집어 첫 번째 단어의 문자와 번갈아 가며 형성된 고유 식별자입니다.\n사용 예:\n\nf_18(\"fish\", \"cat\") returns \"ftiasch\"\nf_18(\"icpc\", \"acm\") returns \"imccpac\"", "ml": "രണ്ട് വാക്കുകൾ ഒരു നിർദ്ദിഷ്ട മാതൃകയിൽ ഇണചേർത്ത് ഒരു അനന്യമായ ഐഡന്റിഫയർ സൃഷ്ടിക്കുന്നു.\n@param word1 ID സൃഷ്ടിക്കുന്ന പ്രക്രിയയിൽ ഉപയോഗിക്കുന്ന ആദ്യ വാക്ക്.\n@param word2 ID സൃഷ്ടിക്കുന്ന പ്രക്രിയയിൽ ഉപയോഗിക്കുന്ന രണ്ടാം വാക്ക്.\n@return രണ്ടാം വാക്കിലെ പ്രത്യയങ്ങൾ, മറിച്ചുള്ള, ആദ്യ വാക്കിലെ പ്രത്യയങ്ങളുമായി മാറി മാറി ചേർത്ത് രൂപപ്പെടുത്തിയ ഒരു സവിശേഷ ഐഡന്റിഫയർ.\nഉദാഹരണ ഉപയോഗം:\n\nf_18(\"fish\", \"cat\") returns \"ftiasch\"\nf_18(\"icpc\", \"acm\") returns \"imccpac\"", "fa": "یک شناسه منحصربه‌فرد با درهم‌آمیختن دو کلمه در یک الگوی مشخص تولید می‌کند.\n@param word1 اولین کلمه‌ای که در فرآیند ایجاد شناسه استفاده می‌شود.\n@param word2 دومین کلمه‌ای که در فرآیند ایجاد شناسه استفاده می‌شود.\n@return یک شناسه منحصربه‌فرد که با جایگزینی کاراکترهای کلمه دوم، به صورت معکوس، با کاراکترهای کلمه اول تشکیل شده است.\nمثال استفاده:\n\nf_18(\"fish\", \"cat\") بازمی‌گرداند \"ftiasch\"\nf_18(\"icpc\", \"acm\") بازمی‌گرداند \"imccpac\""}}
{"task_id": "CPP/19", "prompt": {"en": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Count the number of different permutation schemes for a binary string of length n,\n * where the number of '1's is m and the number of '0's is n - m.\n * \n * Parameters:\n * - n (int): Length of the binary string.\n * - m (int): Number of '1's in the binary string.\n * \n * Returns:\n * - int: The total number of different permutation schemes.\n */\nint f_19(int n, int m)", "sq": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Numëron numrin e skemave të ndryshme të permutimit për një varg binar me gjatësi n,\n * ku numri i '1'-ve është m dhe numri i '0'-ve është n - m.\n * \n * Parametrat:\n * - n (int): Gjatësia e vargut binar.\n * - m (int): Numri i '1'-ve në vargun binar.\n * \n * Kthen:\n * - int: Numri total i skemave të ndryshme të permutimit.\n */\nint f_19(int n, int m)", "hy": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Հաշվել տարբեր փոխատեղման սխեմաների քանակը երկբայական տողի համար, որի երկարությունը n է,\n * որտեղ '1'-երի քանակը m է և '0'-երի քանակը n - m է։\n * \n * Պարամետրեր:\n * - n (int): Երկբայական տողի երկարությունը։\n * - m (int): '1'-երի քանակը երկբայական տողի մեջ։\n * \n * Վերադարձնում է:\n * - int: Տարբեր փոխատեղման սխեմաների ընդհանուր քանակը։\n */\nint f_19(int n, int m)", "bn": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * একটি বাইনারি স্ট্রিংয়ের জন্য বিভিন্ন বিন্যাস স্কিমের সংখ্যা গণনা করুন যার দৈর্ঘ্য n,\n * যেখানে '1' এর সংখ্যা m এবং '0' এর সংখ্যা n - m।\n * \n * প্যারামিটার:\n * - n (int): বাইনারি স্ট্রিংয়ের দৈর্ঘ্য।\n * - m (int): বাইনারি স্ট্রিংয়ে '1' এর সংখ্যা।\n * \n * রিটার্নস:\n * - int: বিভিন্ন বিন্যাস স্কিমের মোট সংখ্যা।\n */\nint f_19(int n, int m)", "bg": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Пребройте броя на различните схеми на пермутации за двоична низ с дължина n,\n * където броят на '1'-ците е m и броят на '0'-ите е n - m.\n * \n * Параметри:\n * - n (int): Дължина на двоичната низ.\n * - m (int): Брой на '1'-ците в двоичната низ.\n * \n * Връща:\n * - int: Общият брой на различните схеми на пермутации.\n */\nint f_19(int n, int m)", "zh": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * 计算长度为 n 的二进制字符串的不同排列方案数量，\n * 其中 '1' 的数量为 m，'0' 的数量为 n - m。\n * \n * 参数:\n * - n (int): 二进制字符串的长度。\n * - m (int): 二进制字符串中 '1' 的数量。\n * \n * 返回:\n * - int: 不同排列方案的总数量。\n */\nint f_19(int n, int m)", "fr": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Compter le nombre de différents schémas de permutation pour une chaîne binaire de longueur n,\n * où le nombre de '1' est m et le nombre de '0' est n - m.\n * \n * Paramètres :\n * - n (int) : Longueur de la chaîne binaire.\n * - m (int) : Nombre de '1' dans la chaîne binaire.\n * \n * Renvoie :\n * - int : Le nombre total de différents schémas de permutation.\n */\nint f_19(int n, int m)", "de": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Zählt die Anzahl der verschiedenen Permutationsschemata für einen Binärstring der Länge n,\n * wobei die Anzahl der '1's m ist und die Anzahl der '0's n - m ist.\n * \n * Parameter:\n * - n (int): Länge des Binärstrings.\n * - m (int): Anzahl der '1's im Binärstring.\n * \n * Rückgabewert:\n * - int: Die Gesamtanzahl der verschiedenen Permutationsschemata.\n */\nint f_19(int n, int m)", "ha": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Ƙirga yawan tsarin permutation daban-daban don kirtani na binary mai tsawon n,\n * inda adadin '1's shine m kuma adadin '0's shine n - m.\n * \n * Sigogi:\n * - n (int): Tsawon kirtani na binary.\n * - m (int): Adadin '1's a cikin kirtani na binary.\n * \n * Komawa:\n * - int: Jimillar yawan tsarin permutation daban-daban.\n */\nint f_19(int n, int m)", "hi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * एक बाइनरी स्ट्रिंग की विभिन्न क्रमचय योजनाओं की संख्या गिनें जिसकी लंबाई n है,\n * जहाँ '1's की संख्या m है और '0's की संख्या n - m है।\n * \n * पैरामीटर्स:\n * - n (int): बाइनरी स्ट्रिंग की लंबाई।\n * - m (int): बाइनरी स्ट्रिंग में '1's की संख्या।\n * \n * रिटर्न करता है:\n * - int: विभिन्न क्रमचय योजनाओं की कुल संख्या।\n */\nint f_19(int n, int m)", "hu": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Számolja meg a különböző permutációs sémák számát egy n hosszúságú bináris karakterlánc esetén,\n * ahol az '1'-ek száma m és a '0'-k száma n - m.\n * \n * Paraméterek:\n * - n (int): A bináris karakterlánc hossza.\n * - m (int): Az '1'-ek száma a bináris karakterláncban.\n * \n * Visszatérési érték:\n * - int: A különböző permutációs sémák összes száma.\n */\nint f_19(int n, int m)", "es": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Cuenta el número de diferentes esquemas de permutación para una cadena binaria de longitud n,\n * donde el número de '1's es m y el número de '0's es n - m.\n * \n * Parámetros:\n * - n (int): Longitud de la cadena binaria.\n * - m (int): Número de '1's en la cadena binaria.\n * \n * Devuelve:\n * - int: El número total de diferentes esquemas de permutación.\n */\nint f_19(int n, int m)", "arb": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * احسب عدد مخططات التبديل المختلفة لسلسلة ثنائية بطول n،\n * حيث يكون عدد '1's هو m وعدد '0's هو n - m.\n * \n * المعلمات:\n * - n (int): طول السلسلة الثنائية.\n * - m (int): عدد '1's في السلسلة الثنائية.\n * \n * يعيد:\n * - int: العدد الإجمالي لمخططات التبديل المختلفة.\n */\nint f_19(int n, int m)", "sw": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Hesabu idadi ya mipango tofauti ya mpangilio kwa kamba ya binary ya urefu n,\n * ambapo idadi ya '1's ni m na idadi ya '0's ni n - m.\n * \n * Vigezo:\n * - n (int): Urefu wa kamba ya binary.\n * - m (int): Idadi ya '1's katika kamba ya binary.\n * \n * Inarudisha:\n * - int: Jumla ya idadi ya mipango tofauti ya mpangilio.\n */\nint f_19(int n, int m)", "tr": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Uzunluğu n olan bir ikili dizgenin, '1'lerin sayısının m ve '0'ların sayısının n - m olduğu\n * farklı permütasyon şemalarının sayısını sayar.\n * \n * Parametreler:\n * - n (int): İkili dizgenin uzunluğu.\n * - m (int): İkili dizgedeki '1'lerin sayısı.\n * \n * Döndürür:\n * - int: Farklı permütasyon şemalarının toplam sayısı.\n */\nint f_19(int n, int m)", "vi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Đếm số lượng các sơ đồ hoán vị khác nhau cho một chuỗi nhị phân có độ dài n,\n * trong đó số lượng '1's là m và số lượng '0's là n - m.\n * \n * Tham số:\n * - n (int): Độ dài của chuỗi nhị phân.\n * - m (int): Số lượng '1's trong chuỗi nhị phân.\n * \n * Trả về:\n * - int: Tổng số lượng các sơ đồ hoán vị khác nhau.\n */\nint f_19(int n, int m)", "id": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Hitung jumlah skema permutasi berbeda untuk string biner dengan panjang n,\n * di mana jumlah '1' adalah m dan jumlah '0' adalah n - m.\n * \n * Parameter:\n * - n (int): Panjang string biner.\n * - m (int): Jumlah '1' dalam string biner.\n * \n * Mengembalikan:\n * - int: Total jumlah skema permutasi berbeda.\n */\nint f_19(int n, int m)", "ja": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * 長さ n のバイナリ文字列に対する異なる順列スキームの数を数えます。\n * ここで、'1' の数は m であり、'0' の数は n - m です。\n * \n * パラメータ:\n * - n (int): バイナリ文字列の長さ。\n * - m (int): バイナリ文字列内の '1' の数。\n * \n * 戻り値:\n * - int: 異なる順列スキームの総数。\n */\nint f_19(int n, int m)", "ko": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * 길이가 n인 이진 문자열에 대해, '1'의 개수가 m이고 '0'의 개수가 n - m인 경우의 서로 다른 순열 수를 계산합니다.\n * \n * 매개변수:\n * - n (int): 이진 문자열의 길이.\n * - m (int): 이진 문자열에서 '1'의 개수.\n * \n * 반환값:\n * - int: 서로 다른 순열의 총 수.\n */\nint f_19(int n, int m)", "ml": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * n നീളമുള്ള ബൈനറി സ്ട്രിംഗിനായുള്ള വ്യത്യസ്തമായ പെർമ്യൂട്ടേഷൻ പദ്ധതികളുടെ എണ്ണം എണ്ണുക,\n * '1' കളുടെ എണ്ണം m ആണെങ്കിൽ, '0' കളുടെ എണ്ണം n - m ആണ്.\n * \n * പാരാമീറ്ററുകൾ:\n * - n (int): ബൈനറി സ്ട്രിംഗിന്റെ നീളം.\n * - m (int): ബൈനറി സ്ട്രിംഗിലെ '1' കളുടെ എണ്ണം.\n * \n * മടക്കുന്നു:\n * - int: വ്യത്യസ്തമായ പെർമ്യൂട്ടേഷൻ പദ്ധതികളുടെ മൊത്തം എണ്ണം.\n */\nint f_19(int n, int m)", "fa": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * تعداد طرح‌های مختلف جایگشت برای یک رشته باینری به طول n را بشمارید،\n * که تعداد '1'ها برابر با m و تعداد '0'ها برابر با n - m است.\n * \n * پارامترها:\n * - n (int): طول رشته باینری.\n * - m (int): تعداد '1'ها در رشته باینری.\n * \n * بازگشت:\n * - int: تعداد کل طرح‌های مختلف جایگشت.\n */\nint f_19(int n, int m)"}, "canonical_solution": "{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // Calculating the number of permutations using the factorial values\n        return static_cast<int>(numerator / denominator1 / denominator2 + 0.5);\n    }\n}", "instruction": {"en": "int f_19(int n, int m)\n{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // Calculating the number of permutations using the factorial values\n        return static_cast<int>(numerator / denominator1 / denominator2 + 0.5);\n    }\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.", "sq": "int f_19(int n, int m)\n{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // Calculating the number of permutations using the factorial values\n        return static_cast<int>(numerator / denominator1 / denominator2 + 0.5);\n    }\n}\n\nSiguroni një përshkrim të shkurtër në gjuhën natyrore (docstring) të kodit CPP në shqip duke përdorur maksimumi 500 karaktere.", "hy": "int f_19(int n, int m)\n{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // Calculating the number of permutations using the factorial values\n        return static_cast<int>(numerator / denominator1 / denominator2 + 0.5);\n    }\n}\n\nՏվեք CPP կոդի հակիրճ բնական լեզվով նկարագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։", "bn": "int f_19(int n, int m)\n{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // Calculating the number of permutations using the factorial values\n        return static_cast<int>(numerator / denominator1 / denominator2 + 0.5);\n    }\n}\n\nসিপিপি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।", "bg": "int f_19(int n, int m)\n{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // Calculating the number of permutations using the factorial values\n        return static_cast<int>(numerator / denominator1 / denominator2 + 0.5);\n    }\n}\n\nПредоставете кратко описание на CPP кода на естествен език на български, използвайки не повече от 500 знака.", "zh": "int f_19(int n, int m)\n{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // Calculating the number of permutations using the factorial values\n        return static_cast<int>(numerator / denominator1 / denominator2 + 0.5);\n    }\n}\n\n请用中文为以下CPP代码提供简洁的自然语言描述（文档字符串），字数不超过500个字符。", "fr": "int f_19(int n, int m)\n{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // Calculating the number of permutations using the factorial values\n        return static_cast<int>(numerator / denominator1 / denominator2 + 0.5);\n    }\n}\n\nFournissez une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.", "de": "int f_19(int n, int m)\n{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // Calculating the number of permutations using the factorial values\n        return static_cast<int>(numerator / denominator1 / denominator2 + 0.5);\n    }\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen.", "ha": "int f_19(int n, int m)\n{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // Calculating the number of permutations using the factorial values\n        return static_cast<int>(numerator / denominator1 / denominator2 + 0.5);\n    }\n}\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar CPP cikin Hausa ta amfani da haruffa 500 kacal.", "hi": "int f_19(int n, int m)\n{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // Calculating the number of permutations using the factorial values\n        return static_cast<int>(numerator / denominator1 / denominator2 + 0.5);\n    }\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "int f_19(int n, int m)\n{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // Calculating the number of permutations using the factorial values\n        return static_cast<int>(numerator / denominator1 / denominator2 + 0.5);\n    }\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a CPP kódhoz magyarul, legfeljebb 500 karakterben.", "es": "int f_19(int n, int m)\n{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // Calculating the number of permutations using the factorial values\n        return static_cast<int>(numerator / denominator1 / denominator2 + 0.5);\n    }\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando como máximo 500 caracteres.", "arb": "int f_19(int n, int m)\n{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // Calculating the number of permutations using the factorial values\n        return static_cast<int>(numerator / denominator1 / denominator2 + 0.5);\n    }\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C++ باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "int f_19(int n, int m)\n{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // Calculating the number of permutations using the factorial values\n        return static_cast<int>(numerator / denominator1 / denominator2 + 0.5);\n    }\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "int f_19(int n, int m)\n{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // Calculating the number of permutations using the factorial values\n        return static_cast<int>(numerator / denominator1 / denominator2 + 0.5);\n    }\n}\n\nAşağıdaki CPP kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda, kısa ve öz bir doğal dil açıklaması (docstring) sağlayın.", "vi": "int f_19(int n, int m)\n{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // Calculating the number of permutations using the factorial values\n        return static_cast<int>(numerator / denominator1 / denominator2 + 0.5);\n    }\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự.", "id": "int f_19(int n, int m)\n{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // Calculating the number of permutations using the factorial values\n        return static_cast<int>(numerator / denominator1 / denominator2 + 0.5);\n    }\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode CPP dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "int f_19(int n, int m)\n{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // Calculating the number of permutations using the factorial values\n        return static_cast<int>(numerator / denominator1 / denominator2 + 0.5);\n    }\n}\n\n以下のCPPコードの簡潔な自然言語による説明（ドックストリング）を日本語で500文字以内で提供してください。", "ko": "int f_19(int n, int m)\n{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // Calculating the number of permutations using the factorial values\n        return static_cast<int>(numerator / denominator1 / denominator2 + 0.5);\n    }\n}\n\n다음 CPP 코드의 기능을 설명하는 간결한 자연어 설명(docstring)을 한국어로 작성하되, 최대 500자 이내로 작성하세요.", "ml": "int f_19(int n, int m)\n{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // Calculating the number of permutations using the factorial values\n        return static_cast<int>(numerator / denominator1 / denominator2 + 0.5);\n    }\n}\n\nCPP കോഡ് ഉപയോഗിച്ച് 500 അക്ഷരങ്ങളിൽ കവിയാതെ മലയാളത്തിൽ സംക്ഷിപ്തമായ ഒരു സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) നൽകുക.", "fa": "int f_19(int n, int m)\n{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // Calculating the number of permutations using the factorial values\n        return static_cast<int>(numerator / denominator1 / denominator2 + 0.5);\n    }\n}\n\nتوضیح مختصر و طبیعی (docstring) از کد CPP به زبان فارسی ارائه دهید که حداکثر ۵۰۰ کاراکتر باشد."}, "level": "", "test": "int main() {\n    assert(f_19(2, 0) == 2);\n    assert(f_19(2, 1) == 0);\n    assert(f_19(3, 0) == 0);\n    assert(f_19(3, 1) == 3);\n    assert(f_19(3, 2) == 0);\n    assert(f_19(30, 2) == 145422675);\n    assert(f_19(4, 2) == 4);\n    assert(f_19(5, 5) == 1);\n    assert(f_19(33, 17) == 13884156);\n    assert(f_19(1000, 1000) == 1);\n    // Add more test cases if necessary\n    return 0;\n}", "entry_point": "f_19", "signature": "int f_19(int n, int m)", "docstring": {"en": "Count the number of different permutation schemes for a binary string of length n, where the number of '1's is m and the number of '0's is n - m.\n\nParameters:\n- n (int): Length of the binary string.\n- m (int): Number of '1's in the binary string.\n\nReturns:\n- int: The total number of different permutation schemes.", "sq": "Numëroni numrin e skemave të ndryshme të permutimit për një varg binar me gjatësi n, ku numri i '1'-ve është m dhe numri i '0'-ve është n - m.\n\nParametrat:\n- n (int): Gjatësia e vargut binar.\n- m (int): Numri i '1'-ve në vargun binar.\n\nKthen:\n- int: Numri total i skemave të ndryshme të permutimit.", "hy": "Հաշվել տարբեր փոխարկման սխեմաների քանակը երկբայական տողի համար, որի երկարությունը n է, որտեղ '1'-երի քանակը m է, իսկ '0'-երի քանակը n - m է։\n\nՊարամետրեր:\n- n (int): Երկբայական տողի երկարությունը։\n- m (int): '1'-երի քանակը երկբայական տողի մեջ։\n\nՎերադարձնում է:\n- int: Տարբեր փոխարկման սխեմաների ընդհանուր քանակը։", "bn": "বাইনারি স্ট্রিংয়ের দৈর্ঘ্য n এর জন্য বিভিন্ন বিন্যাস প্রকল্পের সংখ্যা গণনা করুন, যেখানে '1' এর সংখ্যা m এবং '0' এর সংখ্যা n - m।\n\nপ্যারামিটারসমূহ:\n- n (int): বাইনারি স্ট্রিংয়ের দৈর্ঘ্য।\n- m (int): বাইনারি স্ট্রিংয়ে '1' এর সংখ্যা।\n\nরিটার্নস:\n- int: বিভিন্ন বিন্যাস প্রকল্পের মোট সংখ্যা।", "bg": "Бройте броя на различните схеми на пермутации за двоична низ с дължина n, където броят на '1'-ците е m и броят на '0'-ците е n - m.\n\nПараметри:\n- n (int): Дължина на двоичната низ.\n- m (int): Брой '1'-ци в двоичната низ.\n\nВръща:\n- int: Общият брой на различните схеми на пермутации.", "zh": "计算长度为 n 的二进制字符串的不同排列方案数量，其中 '1' 的数量为 m，'0' 的数量为 n - m。\n\n参数:\n- n (int): 二进制字符串的长度。\n- m (int): 二进制字符串中 '1' 的数量。\n\n返回:\n- int: 不同排列方案的总数量。", "fr": "Comptez le nombre de différents schémas de permutation pour une chaîne binaire de longueur n, où le nombre de '1' est m et le nombre de '0' est n - m.\n\nParamètres :\n- n (int) : Longueur de la chaîne binaire.\n- m (int) : Nombre de '1' dans la chaîne binaire.\n\nRetourne :\n- int : Le nombre total de différents schémas de permutation.", "de": "Zähle die Anzahl der verschiedenen Permutationsschemata für einen Binärstring der Länge n, wobei die Anzahl der '1's m ist und die Anzahl der '0's n - m ist.\n\nParameter:\n- n (int): Länge des Binärstrings.\n- m (int): Anzahl der '1's im Binärstring.\n\nRückgabewert:\n- int: Die Gesamtanzahl der verschiedenen Permutationsschemata.", "ha": "Ƙididdige adadin tsarin juyawa daban-daban don igiyar binary mai tsawon n, inda adadin '1's yake m kuma adadin '0's yake n - m.\n\nSigogi:\n- n (int): Tsawon igiyar binary.\n- m (int): Adadin '1's a cikin igiyar binary.\n\nDawowa:\n- int: Jimlar adadin tsarin juyawa daban-daban.", "hi": "बाइनरी स्ट्रिंग की लंबाई n के लिए विभिन्न क्रमपरिवर्तन योजनाओं की संख्या गिनें, जहाँ '1' की संख्या m है और '0' की संख्या n - m है।\n\nपैरामीटर्स:\n- n (int): बाइनरी स्ट्रिंग की लंबाई।\n- m (int): बाइनरी स्ट्रिंग में '1' की संख्या।\n\nवापसी:\n- int: विभिन्न क्रमपरिवर्तन योजनाओं की कुल संख्या।", "hu": "Számolja meg a különböző permutációs sémák számát egy n hosszúságú bináris karakterlánc esetén, ahol az '1'-ek száma m, és a '0'-k száma n - m.\n\nParaméterek:\n- n (int): A bináris karakterlánc hossza.\n- m (int): Az '1'-ek száma a bináris karakterláncban.\n\nVisszatér:\n- int: A különböző permutációs sémák teljes száma.", "es": "Cuenta el número de diferentes esquemas de permutación para una cadena binaria de longitud n, donde el número de '1's es m y el número de '0's es n - m.\n\nParámetros:\n- n (int): Longitud de la cadena binaria.\n- m (int): Número de '1's en la cadena binaria.\n\nDevuelve:\n- int: El número total de diferentes esquemas de permutación.", "arb": "احسب عدد مخططات التبديل المختلفة لسلسلة ثنائية بطول n، حيث يكون عدد '1's هو m وعدد '0's هو n - m.\n\nالمعلمات:\n- n (int): طول السلسلة الثنائية.\n- m (int): عدد '1's في السلسلة الثنائية.\n\nالقيم المعادة:\n- int: العدد الإجمالي لمخططات التبديل المختلفة.", "sw": "Hesabu idadi ya mipango tofauti ya mpangilio kwa kamba ya binary yenye urefu n, ambapo idadi ya '1' ni m na idadi ya '0' ni n - m.\n\nVigezo:\n- n (int): Urefu wa kamba ya binary.\n- m (int): Idadi ya '1' katika kamba ya binary.\n\nRudisha:\n- int: Jumla ya idadi ya mipango tofauti ya mpangilio.", "tr": "İkili bir dizinin uzunluğu n olan ve '1'lerin sayısı m, '0'ların sayısı n - m olan farklı permütasyon şemalarının sayısını hesaplayın.\n\nParametreler:\n- n (int): İkili dizinin uzunluğu.\n- m (int): İkili dizideki '1'lerin sayısı.\n\nDöndürür:\n- int: Farklı permütasyon şemalarının toplam sayısı.", "vi": "Đếm số lượng các sơ đồ hoán vị khác nhau cho một chuỗi nhị phân có độ dài n, trong đó số lượng '1' là m và số lượng '0' là n - m.\n\nTham số:\n- n (int): Độ dài của chuỗi nhị phân.\n- m (int): Số lượng '1' trong chuỗi nhị phân.\n\nTrả về:\n- int: Tổng số lượng các sơ đồ hoán vị khác nhau.", "id": "Hitung jumlah skema permutasi berbeda untuk string biner dengan panjang n, di mana jumlah '1' adalah m dan jumlah '0' adalah n - m.\n\nParameter:\n- n (int): Panjang dari string biner.\n- m (int): Jumlah '1' dalam string biner.\n\nMengembalikan:\n- int: Jumlah total skema permutasi berbeda.", "ja": "バイナリ文字列の長さ n に対する異なる順列スキームの数を数えます。ここで、'1' の数は m で、'0' の数は n - m です。\n\n引数:\n- n (int): バイナリ文字列の長さ。\n- m (int): バイナリ文字列内の '1' の数。\n\n戻り値:\n- int: 異なる順列スキームの総数。", "ko": "이진 문자열의 길이가 n이고 '1'의 개수가 m, '0'의 개수가 n - m인 경우의 서로 다른 순열 방식을 세십시오.\n\n매개변수:\n- n (int): 이진 문자열의 길이.\n- m (int): 이진 문자열에서 '1'의 개수.\n\n반환:\n- int: 서로 다른 순열 방식의 총 개수.", "ml": "n നീളമുള്ള ബൈനറി സ്ട്രിംഗിനായുള്ള വ്യത്യസ്തമായ പെർമ്യൂട്ടേഷൻ പദ്ധതികളുടെ എണ്ണം എണ്ണുക,\n * '1' കളുടെ എണ്ണം m ആണെങ്കിൽ, '0' കളുടെ എണ്ണം n - m ആണ്.\n\nപാരാമീറ്ററുകൾ:\n- n (int): ബൈനറി സ്ട്രിംഗിന്റെ നീളം.\n- m (int): ബൈനറി സ്ട്രിംഗിലെ '1' കളുടെ എണ്ണം.\n\nമടക്കുന്നു:\n- int: വ്യത്യസ്ത പെർമ്യൂട്ടേഷൻ സ്കീമുകളുടെ മൊത്തം എണ്ണം.", "fa": "تعداد طرح‌های مختلف جایگشت برای یک رشته باینری با طول n را بشمارید، جایی که تعداد '1'ها برابر با m و تعداد '0'ها برابر با n - m است.\n\nپارامترها:\n- n (int): طول رشته باینری.\n- m (int): تعداد '1'ها در رشته باینری.\n\nبازگشت:\n- int: تعداد کل طرح‌های مختلف جایگشت."}}
{"task_id": "CPP/20", "prompt": {"en": "#include <cassert>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n/**\n *  Answer a series of questions by providing choices A, B, C, or D for each question.\n *  \n *  Question 1:\n *  Constants like 1e6 belong to which data type?\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n *  \n *  Question 2:\n *  Given 21! = 51,090,942,171,709,440,000, which data type can be used to store this value?\n *      A. int\n *      B. long long\n *      C. double\n *      D. None of the above\n *  \n *  Question 3:\n *  Which statement about left values in expressions is incorrect?\n *      A. Variable name expressions are left values.\n *      B. Increment operation requires the operand to be a left value.\n *      C. Pointer dereference expressions are left values.\n *      D. Prefix increment operation expressions are left values.\n *  \n *  Question 4:\n *  Which statement about functions is incorrect?\n *      A. Formal parameters of a function are local variables.\n *      B. Local variables are allocated space in the stack.\n *      C. The function type is the same as the return value type.\n *      D. A function can call itself from within its body.\n *  \n *  Question 5:\n *  Which statement about pointers is incorrect?\n *      A. Subtracting two pointers equals the difference in their address values.\n *      B. Pointer dereference involves resolving based on the pointer's type.\n *      C. int *p[4], p is an array of int pointers.\n *      D. Function names can be assigned to function pointers.\n *  \n *  You're supposed to only return strings similar to \"AAAAA\", which stand for the choices of the question.\n */\nconst char* f_20()", "sq": "#include <cassert>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n/**\n *  Përgjigju një serie pyetjesh duke dhënë zgjedhjet A, B, C, ose D për secilën pyetje.\n *  \n *  Pyetja 1:\n *  Konstantet si 1e6 i përkasin cilit lloj të dhënash?\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n *  \n *  Pyetja 2:\n *  Duke dhënë 21! = 51,090,942,171,709,440,000, cili lloj i të dhënave mund të përdoret për të ruajtur këtë vlerë?\n *      A. int\n *      B. long long\n *      C. double\n *      D. Asnjë nga të mësipërmet\n *  \n *  Pyetja 3:\n *  Cila deklaratë për vlerat e majta në shprehje është e pasaktë?\n *      A. Shprehjet e emrave të variablave janë vlera të majta.\n *      B. Operacioni i inkrementimit kërkon që operandi të jetë një vlerë e majtë.\n *      C. Shprehjet e dereferencimit të treguesve janë vlera të majta.\n *      D. Shprehjet e operacionit të inkrementimit prefiks janë vlera të majta.\n *  \n *  Pyetja 4:\n *  Cila deklaratë për funksionet është e pasaktë?\n *      A. Parametrat formalë të një funksioni janë variabla lokale.\n *      B. Variablat lokale alokohen hapësirë në stack.\n *      C. Lloji i funksionit është i njëjtë me llojin e vlerës së kthimit.\n *      D. Një funksion mund të thërrasë vetveten nga brenda trupit të tij.\n *  \n *  Pyetja 5:\n *  Cila deklaratë për treguesit është e pasaktë?\n *      A. Zbritja e dy treguesve është e barabartë me diferencën në vlerat e adresave të tyre.\n *      B. Dereferencimi i treguesit përfshin zgjidhjen bazuar në llojin e treguesit.\n *      C. int *p[4], p është një varg treguesish int.\n *      D. Emrat e funksioneve mund të caktohen te treguesit e funksioneve.\n *  \n *  Supozohet të ktheni vetëm vargje të ngjashme me \"AAAAA\", të cilat përfaqësojnë zgjedhjet e pyetjeve.\n */\nconst char* f_20()", "hy": "#include <cassert>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n/**\n *  Պատասխանեք մի շարք հարցերի՝ յուրաքանչյուր հարցի համար տրամադրելով A, B, C կամ D ընտրանքները:\n *  \n *  Հարց 1:\n *  Նման հաստատունները, ինչպիսիք են 1e6-ը, որ տվյալների տիպին են պատկանում?\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n *  \n *  Հարց 2:\n *  Տրված է 21! = 51,090,942,171,709,440,000, որ տվյալների տիպը կարող է պահել այս արժեքը?\n *      A. int\n *      B. long long\n *      C. double\n *      D. Վերը նշվածներից ոչ մեկը\n *  \n *  Հարց 3:\n *  Որ հայտարարությունը ձախ արժեքների մասին արտահայտություններում սխալ է?\n *      A. Փոփոխականի անվան արտահայտությունները ձախ արժեքներ են:\n *      B. Ինքրեմենտի գործողությունը պահանջում է, որ օպերանդը լինի ձախ արժեք:\n *      C. Ցուցիչի ապահանել արտահայտությունները ձախ արժեքներ են:\n *      D. Նախածանց ինքրեմենտի գործողության արտահայտությունները ձախ արժեքներ են:\n *  \n *  Հարց 4:\n *  Որ հայտարարությունը ֆունկցիաների մասին սխալ է?\n *      A. Ֆունկցիայի ֆորմալ պարամետրերը տեղական փոփոխականներ են:\n *      B. Տեղական փոփոխականները հատկացվում են ստեկում:\n *      C. Ֆունկցիայի տիպը նույնն է, ինչ վերադարձվող արժեքի տիպը:\n *      D. Ֆունկցիան կարող է ինքն իրեն կանչել իր մարմնի ներսից:\n *  \n *  Հարց 5:\n *  Որ հայտարարությունը ցուցիչների մասին սխալ է?\n *      A. Երկու ցուցիչների հանումը հավասար է նրանց հասցեների արժեքների տարբերությանը:\n *      B. Ցուցիչի ապահանումը ներառում է լուծում ցուցիչի տիպի հիման վրա:\n *      C. int *p[4], p-ն int ցուցիչների զանգված է:\n *      D. Ֆունկցիաների անունները կարող են վերագրվել ֆունկցիայի ցուցիչներին:\n *  \n *  Դուք պետք է վերադարձնեք միայն նմանատիպ տողեր \"AAAAA\", որոնք ներկայացնում են հարցերի ընտրանքները:\n */\nconst char* f_20()", "bn": "#include <cassert>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n/**\n *  প্রতিটি প্রশ্নের জন্য পছন্দ A, B, C, বা D প্রদান করে প্রশ্নগুলির উত্তর দিন।\n *  \n *  প্রশ্ন ১:\n *  1e6 এর মতো ধ্রুবক কোন ডেটা টাইপের অন্তর্গত?\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n *  \n *  প্রশ্ন ২:\n *  21! = 51,090,942,171,709,440,000 দেওয়া হয়েছে, কোন ডেটা টাইপ এই মানটি সংরক্ষণ করতে ব্যবহার করা যেতে পারে?\n *      A. int\n *      B. long long\n *      C. double\n *      D. উপরের কোনোটিই নয়\n *  \n *  প্রশ্ন ৩:\n *  এক্সপ্রেশনে বাম মান সম্পর্কে কোন বিবৃতিটি ভুল?\n *      A. ভেরিয়েবল নাম এক্সপ্রেশনগুলি বাম মান।\n *      B. ইনক্রিমেন্ট অপারেশনটির জন্য অপারেন্ডটি একটি বাম মান হতে হবে।\n *      C. পয়েন্টার ডিরেফারেন্স এক্সপ্রেশনগুলি বাম মান।\n *      D. প্রিফিক্স ইনক্রিমেন্ট অপারেশন এক্সপ্রেশনগুলি বাম মান।\n *  \n *  প্রশ্ন ৪:\n *  ফাংশন সম্পর্কে কোন বিবৃতিটি ভুল?\n *      A. একটি ফাংশনের আনুষ্ঠানিক প্যারামিটারগুলি স্থানীয় ভেরিয়েবল।\n *      B. স্থানীয় ভেরিয়েবলগুলি স্ট্যাকে স্থান বরাদ্দ করে।\n *      C. ফাংশনের টাইপ এবং রিটার্ন ভ্যালু টাইপ একই।\n *      D. একটি ফাংশন তার দেহের ভিতরে নিজেকে কল করতে পারে।\n *  \n *  প্রশ্ন ৫:\n *  পয়েন্টার সম্পর্কে কোন বিবৃতিটি ভুল?\n *      A. দুটি পয়েন্টার বিয়োগ করার মানে তাদের ঠিকানা মানের পার্থক্য।\n *      B. পয়েন্টার ডিরেফারেন্স পয়েন্টারের টাইপের উপর ভিত্তি করে সমাধান করা হয়।\n *      C. int *p[4], p হল int পয়েন্টারগুলির একটি অ্যারে।\n *      D. ফাংশনের নামগুলি ফাংশন পয়েন্টারগুলিতে বরাদ্দ করা যেতে পারে।\n *  \n *  আপনি শুধুমাত্র \"AAAAA\" এর মতো স্ট্রিং ফেরত দেওয়ার কথা, যা প্রশ্নের পছন্দগুলির জন্য দাঁড়ায়।\n */\nconst char* f_20()", "bg": "#include <cassert>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n/**\n *  Отговорете на серия от въпроси, като предоставите избори A, B, C или D за всеки въпрос.\n *  \n *  Въпрос 1:\n *  Константи като 1e6 принадлежат към кой тип данни?\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n *  \n *  Въпрос 2:\n *  Дадено е 21! = 51,090,942,171,709,440,000, кой тип данни може да се използва за съхранение на тази стойност?\n *      A. int\n *      B. long long\n *      C. double\n *      D. Нито едно от горните\n *  \n *  Въпрос 3:\n *  Кое твърдение за левите стойности в изразите е неправилно?\n *      A. Изразите с имена на променливи са леви стойности.\n *      B. Операцията на инкрементиране изисква операндът да е лява стойност.\n *      C. Изразите с разименуване на указатели са леви стойности.\n *      D. Изразите с префиксно инкрементиране са леви стойности.\n *  \n *  Въпрос 4:\n *  Кое твърдение за функциите е неправилно?\n *      A. Формалните параметри на функцията са локални променливи.\n *      B. Локалните променливи се разпределят в стека.\n *      C. Типът на функцията е същият като типа на връщаната стойност.\n *      D. Функцията може да извика сама себе си от тялото си.\n *  \n *  Въпрос 5:\n *  Кое твърдение за указателите е неправилно?\n *      A. Изваждането на два указателя е равно на разликата в стойностите на техните адреси.\n *      B. Разименуването на указател включва разрешаване на базата на типа на указателя.\n *      C. int *p[4], p е масив от указатели към int.\n *      D. Имената на функциите могат да бъдат присвоени на указатели към функции.\n *  \n *  Трябва да върнете само низове, подобни на \"AAAAA\", които представляват изборите на въпросите.\n */\nconst char* f_20()", "zh": "#include <cassert>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n/**\n *  通过为每个问题提供选择A、B、C或D来回答一系列问题。\n *  \n *  问题 1:\n *  常量如1e6属于哪种数据类型？\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n *  \n *  问题 2:\n *  给定21! = 51,090,942,171,709,440,000，哪种数据类型可以用来存储这个值？\n *      A. int\n *      B. long long\n *      C. double\n *      D. 以上都不是\n *  \n *  问题 3:\n *  关于表达式中的左值，哪个说法是不正确的？\n *      A. 变量名表达式是左值。\n *      B. 增量操作要求操作数是左值。\n *      C. 指针解引用表达式是左值。\n *      D. 前缀增量操作表达式是左值。\n *  \n *  问题 4:\n *  关于函数，哪个说法是不正确的？\n *      A. 函数的形式参数是局部变量。\n *      B. 局部变量在栈中分配空间。\n *      C. 函数类型与返回值类型相同。\n *      D. 函数可以在其体内调用自身。\n *  \n *  问题 5:\n *  关于指针，哪个说法是不正确的？\n *      A. 两个指针相减等于它们地址值的差。\n *      B. 指针解引用涉及根据指针的类型进行解析。\n *      C. int *p[4], p是一个int指针数组。\n *      D. 函数名可以赋值给函数指针。\n *  \n *  你应该只返回类似于\"AAAAA\"的字符串，代表问题的选择。\n */\nconst char* f_20()", "fr": "#include <cassert>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n/**\n *  Répondez à une série de questions en fournissant les choix A, B, C ou D pour chaque question.\n *  \n *  Question 1 :\n *  Les constantes comme 1e6 appartiennent à quel type de données ?\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n *  \n *  Question 2 :\n *  Étant donné 21! = 51,090,942,171,709,440,000, quel type de données peut être utilisé pour stocker cette valeur ?\n *      A. int\n *      B. long long\n *      C. double\n *      D. Aucun des précédents\n *  \n *  Question 3 :\n *  Quelle affirmation concernant les valeurs à gauche dans les expressions est incorrecte ?\n *      A. Les expressions de nom de variable sont des valeurs à gauche.\n *      B. L'opération d'incrémentation nécessite que l'opérande soit une valeur à gauche.\n *      C. Les expressions de déréférencement de pointeur sont des valeurs à gauche.\n *      D. Les expressions d'opération d'incrémentation préfixée sont des valeurs à gauche.\n *  \n *  Question 4 :\n *  Quelle affirmation concernant les fonctions est incorrecte ?\n *      A. Les paramètres formels d'une fonction sont des variables locales.\n *      B. Les variables locales sont allouées dans la pile.\n *      C. Le type de la fonction est le même que le type de la valeur de retour.\n *      D. Une fonction peut s'appeler elle-même depuis son corps.\n *  \n *  Question 5 :\n *  Quelle affirmation concernant les pointeurs est incorrecte ?\n *      A. Soustraire deux pointeurs équivaut à la différence de leurs valeurs d'adresse.\n *      B. Le déréférencement de pointeur implique une résolution basée sur le type du pointeur.\n *      C. int *p[4], p est un tableau de pointeurs int.\n *      D. Les noms de fonctions peuvent être assignés à des pointeurs de fonction.\n *  \n *  Vous êtes censé ne retourner que des chaînes similaires à \"AAAAA\", qui représentent les choix de la question.\n */\nconst char* f_20()", "de": "#include <cassert>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n/**\n *  Beantworten Sie eine Reihe von Fragen, indem Sie für jede Frage die Auswahlmöglichkeiten A, B, C oder D angeben.\n *  \n *  Frage 1:\n *  Konstanten wie 1e6 gehören zu welchem Datentyp?\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n *  \n *  Frage 2:\n *  Gegeben 21! = 51,090,942,171,709,440,000, welcher Datentyp kann verwendet werden, um diesen Wert zu speichern?\n *      A. int\n *      B. long long\n *      C. double\n *      D. Keine der oben genannten\n *  \n *  Frage 3:\n *  Welche Aussage über linke Werte in Ausdrücken ist falsch?\n *      A. Variablennamen-Ausdrücke sind linke Werte.\n *      B. Der Inkrementierungsoperator erfordert, dass der Operand ein linker Wert ist.\n *      C. Zeiger-Dereferenz-Ausdrücke sind linke Werte.\n *      D. Präfix-Inkrement-Ausdrücke sind linke Werte.\n *  \n *  Frage 4:\n *  Welche Aussage über Funktionen ist falsch?\n *      A. Formale Parameter einer Funktion sind lokale Variablen.\n *      B. Lokale Variablen werden im Stack Speicherplatz zugewiesen.\n *      C. Der Funktionstyp ist derselbe wie der Rückgabewerttyp.\n *      D. Eine Funktion kann sich selbst innerhalb ihres Körpers aufrufen.\n *  \n *  Frage 5:\n *  Welche Aussage über Zeiger ist falsch?\n *      A. Das Subtrahieren von zwei Zeigern entspricht der Differenz ihrer Adresswerte.\n *      B. Die Zeiger-Dereferenzierung erfolgt basierend auf dem Typ des Zeigers.\n *      C. int *p[4], p ist ein Array von int-Zeigern.\n *      D. Funktionsnamen können Funktionszeigern zugewiesen werden.\n *  \n *  Sie sollen nur Zeichenfolgen ähnlich wie \"AAAAA\" zurückgeben, die für die Auswahlmöglichkeiten der Frage stehen.\n */\nconst char* f_20()", "ha": "#include <cassert>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n/**\n *  Amsa jerin tambayoyi ta hanyar bayar da zaɓuɓɓuka A, B, C, ko D ga kowace tambaya.\n *  \n *  Tambaya ta 1:\n *  Constants kamar 1e6 suna cikin wane nau'in bayanai?\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n *  \n *  Tambaya ta 2:\n *  An bayar da 21! = 51,090,942,171,709,440,000, wane nau'in bayanai za a iya amfani da shi don adana wannan ƙima?\n *      A. int\n *      B. long long\n *      C. double\n *      D. Babu ɗaya daga cikin waɗanda ke sama\n *  \n *  Tambaya ta 3:\n *  Wane bayani game da ƙimar hagu a cikin maganganu ba daidai ba ne?\n *      A. Maganganun sunayen canji ƙimar hagu ne.\n *      B. Aiki na ƙara yana buƙatar operand ya zama ƙimar hagu.\n *      C. Maganganun cirewa mai nuna alama ƙimar hagu ne.\n *      D. Maganganun aiki na ƙara na farko ƙimar hagu ne.\n *  \n *  Tambaya ta 4:\n *  Wane bayani game da ayyuka ba daidai ba ne?\n *      A. Sigogin tsari na aiki canje-canje na gida ne.\n *      B. Canje-canje na gida suna da sarari a cikin tsari.\n *      C. Nau'in aiki iri ɗaya ne da nau'in ƙimar dawowa.\n *      D. Aiki na iya kiran kansa daga cikin jikinsa.\n *  \n *  Tambaya ta 5:\n *  Wane bayani game da masu nuna alama ba daidai ba ne?\n *      A. Rage masu nuna alama biyu yana daidai da bambanci a cikin ƙimar adireshinsu.\n *      B. Cire mai nuna alama yana buƙatar warwarewa bisa nau'in mai nuna alama.\n *      C. int *p[4], p jerin masu nuna alama ne na int.\n *      D. Ana iya sanya sunayen ayyuka ga masu nuna alama na aiki.\n *  \n *  Ana tsammanin ka dawo da kirtani makamancin \"AAAAA\", wanda ke wakiltar zaɓuɓɓukan tambayoyin.\n */\nconst char* f_20()", "hi": "#include <cassert>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n/**\n *  प्रत्येक प्रश्न के लिए विकल्प A, B, C, या D प्रदान करके प्रश्नों की एक श्रृंखला का उत्तर दें।\n *  \n *  प्रश्न 1:\n *  1e6 जैसी स्थिरांक किस डेटा प्रकार से संबंधित हैं?\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n *  \n *  प्रश्न 2:\n *  दिए गए 21! = 51,090,942,171,709,440,000, इस मान को संग्रहीत करने के लिए कौन सा डेटा प्रकार उपयोग किया जा सकता है?\n *      A. int\n *      B. long long\n *      C. double\n *      D. उपरोक्त में से कोई नहीं\n *  \n *  प्रश्न 3:\n *  अभिव्यक्तियों में बाएँ मानों के बारे में कौन सा कथन गलत है?\n *      A. वेरिएबल नाम अभिव्यक्तियाँ बाएँ मान हैं।\n *      B. वृद्धि ऑपरेशन के लिए ऑपरेन्ड का बाएँ मान होना आवश्यक है।\n *      C. पॉइंटर डिरेफरेंस अभिव्यक्तियाँ बाएँ मान हैं।\n *      D. उपसर्ग वृद्धि ऑपरेशन अभिव्यक्तियाँ बाएँ मान हैं।\n *  \n *  प्रश्न 4:\n *  कार्यों के बारे में कौन सा कथन गलत है?\n *      A. एक फ़ंक्शन के औपचारिक पैरामीटर स्थानीय वेरिएबल होते हैं।\n *      B. स्थानीय वेरिएबल स्टैक में स्थान आवंटित करते हैं।\n *      C. फ़ंक्शन प्रकार वही है जो रिटर्न मान प्रकार है।\n *      D. एक फ़ंक्शन अपने शरीर के भीतर से स्वयं को कॉल कर सकता है।\n *  \n *  प्रश्न 5:\n *  पॉइंटर्स के बारे में कौन सा कथन गलत है?\n *      A. दो पॉइंटर्स को घटाने से उनके पते के मूल्यों में अंतर होता है।\n *      B. पॉइंटर डिरेफरेंस में पॉइंटर के प्रकार के आधार पर समाधान शामिल होता है।\n *      C. int *p[4], p एक int पॉइंटर्स की सरणी है।\n *      D. फ़ंक्शन नामों को फ़ंक्शन पॉइंटर्स को सौंपा जा सकता है।\n *  \n *  आपको केवल \"AAAAA\" जैसे स्ट्रिंग्स लौटाने हैं, जो प्रश्न के विकल्पों के लिए खड़े हैं।\n */\nconst char* f_20()", "hu": "#include <cassert>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n/**\n *  Válaszolj egy sor kérdésre az A, B, C vagy D választási lehetőségek megadásával minden kérdésre.\n *  \n *  1. kérdés:\n *  Az olyan konstansok, mint az 1e6, melyik adattípushoz tartoznak?\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n *  \n *  2. kérdés:\n *  Adott 21! = 51,090,942,171,709,440,000, melyik adattípus használható ennek az értéknek a tárolására?\n *      A. int\n *      B. long long\n *      C. double\n *      D. Egyik sem a fentiek közül\n *  \n *  3. kérdés:\n *  Melyik állítás helytelen a balértékekről kifejezésekben?\n *      A. A változónév kifejezések balértékek.\n *      B. Az inkrementáló művelet megköveteli, hogy az operandus balérték legyen.\n *      C. A pointer dereferálás kifejezések balértékek.\n *      D. A prefix inkrementáló művelet kifejezések balértékek.\n *  \n *  4. kérdés:\n *  Melyik állítás helytelen a függvényekről?\n *      A. A függvény formális paraméterei lokális változók.\n *      B. A lokális változók a veremben kapnak helyet.\n *      C. A függvény típusa megegyezik a visszatérési érték típusával.\n *      D. Egy függvény meghívhatja önmagát a saját törzsén belül.\n *  \n *  5. kérdés:\n *  Melyik állítás helytelen a pointerekről?\n *      A. Két pointer kivonása az címértékeik különbségével egyenlő.\n *      B. A pointer dereferálás a pointer típusának megfelelően történik.\n *      C. int *p[4], p egy int pointerek tömbje.\n *      D. A függvénynevek hozzárendelhetők függvénypointerekhez.\n *  \n *  Csak olyan karakterláncokat kell visszaadnod, mint például \"AAAAA\", amelyek a kérdés választásait jelölik.\n */\nconst char* f_20()", "es": "#include <cassert>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n/**\n *  Responder a una serie de preguntas proporcionando opciones A, B, C o D para cada pregunta.\n *  \n *  Pregunta 1:\n *  ¿A qué tipo de datos pertenecen constantes como 1e6?\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n *  \n *  Pregunta 2:\n *  Dado 21! = 51,090,942,171,709,440,000, ¿qué tipo de datos se puede usar para almacenar este valor?\n *      A. int\n *      B. long long\n *      C. double\n *      D. Ninguna de las anteriores\n *  \n *  Pregunta 3:\n *  ¿Cuál afirmación sobre los valores a la izquierda en expresiones es incorrecta?\n *      A. Las expresiones de nombres de variables son valores a la izquierda.\n *      B. La operación de incremento requiere que el operando sea un valor a la izquierda.\n *      C. Las expresiones de desreferencia de punteros son valores a la izquierda.\n *      D. Las expresiones de operación de incremento prefijo son valores a la izquierda.\n *  \n *  Pregunta 4:\n *  ¿Cuál afirmación sobre las funciones es incorrecta?\n *      A. Los parámetros formales de una función son variables locales.\n *      B. Las variables locales se asignan espacio en la pila.\n *      C. El tipo de la función es el mismo que el tipo de valor de retorno.\n *      D. Una función puede llamarse a sí misma desde dentro de su cuerpo.\n *  \n *  Pregunta 5:\n *  ¿Cuál afirmación sobre los punteros es incorrecta?\n *      A. Restar dos punteros equivale a la diferencia en sus valores de dirección.\n *      B. La desreferencia de punteros implica resolver basado en el tipo del puntero.\n *      C. int *p[4], p es un arreglo de punteros a int.\n *      D. Los nombres de funciones pueden asignarse a punteros de funciones.\n *  \n *  Se supone que debes devolver solo cadenas similares a \"AAAAA\", que representan las opciones de la pregunta.\n */\nconst char* f_20()", "arb": "#include <cassert>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n/**\n *  أجب عن سلسلة من الأسئلة بتقديم الخيارات A، B، C، أو D لكل سؤال.\n *  \n *  السؤال 1:\n *  الثوابت مثل 1e6 تنتمي إلى أي نوع من البيانات؟\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n *  \n *  السؤال 2:\n *  بالنظر إلى 21! = 51,090,942,171,709,440,000، أي نوع من البيانات يمكن استخدامه لتخزين هذه القيمة؟\n *      A. int\n *      B. long long\n *      C. double\n *      D. لا شيء مما سبق\n *  \n *  السؤال 3:\n *  أي عبارة عن القيم اليسارية في التعبيرات غير صحيحة؟\n *      A. تعبيرات أسماء المتغيرات هي قيم يسارية.\n *      B. عملية الزيادة تتطلب أن يكون المعامل قيمة يسارية.\n *      C. تعبيرات إلغاء المؤشر هي قيم يسارية.\n *      D. تعبيرات عملية الزيادة المسبقة هي قيم يسارية.\n *  \n *  السؤال 4:\n *  أي عبارة عن الدوال غير صحيحة؟\n *      A. المعاملات الشكلية للدالة هي متغيرات محلية.\n *      B. يتم تخصيص مساحة للمتغيرات المحلية في المكدس.\n *      C. نوع الدالة هو نفسه نوع قيمة الإرجاع.\n *      D. يمكن للدالة أن تستدعي نفسها من داخل جسمها.\n *  \n *  السؤال 5:\n *  أي عبارة عن المؤشرات غير صحيحة؟\n *      A. طرح مؤشرين يساوي الفرق في قيم عناوينهما.\n *      B. إلغاء المؤشر يتضمن الحل بناءً على نوع المؤشر.\n *      C. int *p[4]، p هو مصفوفة من مؤشرات int.\n *      D. يمكن تعيين أسماء الدوال إلى مؤشرات الدوال.\n *  \n *  من المفترض أن تعيد فقط سلاسل مشابهة لـ \"AAAAA\"، والتي تمثل خيارات السؤال.\n */\nconst char* f_20()", "sw": "#include <cassert>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n/**\n *  Jibu mfululizo wa maswali kwa kutoa chaguo A, B, C, au D kwa kila swali.\n *  \n *  Swali la 1:\n *  Vigezo kama 1e6 vinahusiana na aina gani ya data?\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n *  \n *  Swali la 2:\n *  Ikitolewa 21! = 51,090,942,171,709,440,000, aina gani ya data inaweza kutumika kuhifadhi thamani hii?\n *      A. int\n *      B. long long\n *      C. double\n *      D. Hakuna kati ya haya\n *  \n *  Swali la 3:\n *  Ni kauli gani kuhusu thamani za kushoto katika maonyesho si sahihi?\n *      A. Maonyesho ya majina ya vigezo ni thamani za kushoto.\n *      B. Operesheni ya kuongeza inahitaji operand kuwa thamani ya kushoto.\n *      C. Maonyesho ya kufuta pointer ni thamani za kushoto.\n *      D. Maonyesho ya operesheni ya kuongeza awali ni thamani za kushoto.\n *  \n *  Swali la 4:\n *  Ni kauli gani kuhusu kazi si sahihi?\n *      A. Vigezo rasmi vya kazi ni vigezo vya ndani.\n *      B. Vigezo vya ndani vinatengewa nafasi kwenye stack.\n *      C. Aina ya kazi ni sawa na aina ya thamani ya kurudi.\n *      D. Kazi inaweza kujita kutoka ndani ya mwili wake.\n *  \n *  Swali la 5:\n *  Ni kauli gani kuhusu pointers si sahihi?\n *      A. Kutoa pointers mbili ni sawa na tofauti katika thamani za anwani zao.\n *      B. Kufuta pointer kunahusisha kutatua kulingana na aina ya pointer.\n *      C. int *p[4], p ni safu ya pointers za int.\n *      D. Majina ya kazi yanaweza kupewa pointers za kazi.\n *  \n *  Unatakiwa kurudisha tu misururu kama \"AAAAA\", ambayo inasimama kwa chaguo za swali.\n */\nconst char* f_20()", "tr": "#include <cassert>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n/**\n *  Her bir soru için A, B, C veya D seçeneklerini sağlayarak bir dizi soruya cevap verin.\n *  \n *  Soru 1:\n *  1e6 gibi sabitler hangi veri tipine aittir?\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n *  \n *  Soru 2:\n *  21! = 51,090,942,171,709,440,000 verildiğinde, bu değeri saklamak için hangi veri tipi kullanılabilir?\n *      A. int\n *      B. long long\n *      C. double\n *      D. Yukarıdakilerin hiçbiri\n *  \n *  Soru 3:\n *  İfadelerdeki sol değerler hakkında hangi ifade yanlıştır?\n *      A. Değişken adı ifadeleri sol değerlerdir.\n *      B. Artırma işlemi, operandın bir sol değer olmasını gerektirir.\n *      C. Gösterici çözme ifadeleri sol değerlerdir.\n *      D. Ön ek artırma işlemi ifadeleri sol değerlerdir.\n *  \n *  Soru 4:\n *  Fonksiyonlar hakkında hangi ifade yanlıştır?\n *      A. Bir fonksiyonun resmi parametreleri yerel değişkenlerdir.\n *      B. Yerel değişkenler yığında alan tahsis edilir.\n *      C. Fonksiyon türü, dönüş değeri türü ile aynıdır.\n *      D. Bir fonksiyon, gövdesi içinden kendini çağırabilir.\n *  \n *  Soru 5:\n *  Göstericiler hakkında hangi ifade yanlıştır?\n *      A. İki göstericinin çıkarılması, adres değerlerindeki farkı eşittir.\n *      B. Gösterici çözme, göstericinin türüne göre çözümlemeyi içerir.\n *      C. int *p[4], p bir dizi int göstericisidir.\n *      D. Fonksiyon isimleri, fonksiyon göstericilerine atanabilir.\n *  \n *  Sadece soruların seçeneklerini temsil eden \"AAAAA\" gibi dizeler döndürmeniz gerekiyor.\n */\nconst char* f_20()", "vi": "#include <cassert>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n/**\n *  Trả lời một loạt câu hỏi bằng cách cung cấp lựa chọn A, B, C, hoặc D cho mỗi câu hỏi.\n *  \n *  Câu hỏi 1:\n *  Hằng số như 1e6 thuộc kiểu dữ liệu nào?\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n *  \n *  Câu hỏi 2:\n *  Cho 21! = 51,090,942,171,709,440,000, kiểu dữ liệu nào có thể được sử dụng để lưu trữ giá trị này?\n *      A. int\n *      B. long long\n *      C. double\n *      D. Không có kiểu nào ở trên\n *  \n *  Câu hỏi 3:\n *  Câu nào về giá trị bên trái trong biểu thức là không đúng?\n *      A. Biểu thức tên biến là giá trị bên trái.\n *      B. Phép toán tăng yêu cầu toán hạng phải là giá trị bên trái.\n *      C. Biểu thức giải tham chiếu con trỏ là giá trị bên trái.\n *      D. Biểu thức phép toán tăng tiền tố là giá trị bên trái.\n *  \n *  Câu hỏi 4:\n *  Câu nào về hàm là không đúng?\n *      A. Tham số hình thức của một hàm là biến cục bộ.\n *      B. Biến cục bộ được cấp phát không gian trong ngăn xếp.\n *      C. Kiểu của hàm giống với kiểu giá trị trả về.\n *      D. Một hàm có thể gọi chính nó từ bên trong thân hàm.\n *  \n *  Câu hỏi 5:\n *  Câu nào về con trỏ là không đúng?\n *      A. Trừ hai con trỏ bằng với sự khác biệt trong giá trị địa chỉ của chúng.\n *      B. Giải tham chiếu con trỏ liên quan đến việc giải quyết dựa trên kiểu của con trỏ.\n *      C. int *p[4], p là một mảng các con trỏ int.\n *      D. Tên hàm có thể được gán cho con trỏ hàm.\n *  \n *  Bạn cần chỉ trả về chuỗi tương tự như \"AAAAA\", đại diện cho lựa chọn của câu hỏi.\n */\nconst char* f_20()", "id": "#include <cassert>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n/**\n *  Jawab serangkaian pertanyaan dengan memberikan pilihan A, B, C, atau D untuk setiap pertanyaan.\n *  \n *  Pertanyaan 1:\n *  Konstanta seperti 1e6 termasuk dalam tipe data apa?\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n *  \n *  Pertanyaan 2:\n *  Diberikan 21! = 51,090,942,171,709,440,000, tipe data mana yang dapat digunakan untuk menyimpan nilai ini?\n *      A. int\n *      B. long long\n *      C. double\n *      D. Tidak ada dari yang di atas\n *  \n *  Pertanyaan 3:\n *  Pernyataan mana tentang nilai kiri dalam ekspresi yang tidak benar?\n *      A. Ekspresi nama variabel adalah nilai kiri.\n *      B. Operasi inkremen memerlukan operan menjadi nilai kiri.\n *      C. Ekspresi dereferensi pointer adalah nilai kiri.\n *      D. Ekspresi operasi inkremen prefix adalah nilai kiri.\n *  \n *  Pertanyaan 4:\n *  Pernyataan mana tentang fungsi yang tidak benar?\n *      A. Parameter formal dari sebuah fungsi adalah variabel lokal.\n *      B. Variabel lokal dialokasikan ruang di stack.\n *      C. Tipe fungsi sama dengan tipe nilai kembalian.\n *      D. Sebuah fungsi dapat memanggil dirinya sendiri dari dalam tubuhnya.\n *  \n *  Pertanyaan 5:\n *  Pernyataan mana tentang pointer yang tidak benar?\n *      A. Mengurangi dua pointer sama dengan perbedaan dalam nilai alamat mereka.\n *      B. Dereferensi pointer melibatkan penyelesaian berdasarkan tipe pointer.\n *      C. int *p[4], p adalah array dari pointer int.\n *      D. Nama fungsi dapat ditugaskan ke pointer fungsi.\n *  \n *  Anda seharusnya hanya mengembalikan string seperti \"AAAAA\", yang mewakili pilihan dari pertanyaan.\n */\nconst char* f_20()\n", "ja": "#include <cassert>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n/**\n *  各質問に対して選択肢 A、B、C、または D を提供して一連の質問に答えてください。\n *  \n *  質問 1:\n *  1e6 のような定数はどのデータ型に属しますか？\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n *  \n *  質問 2:\n *  21! = 51,090,942,171,709,440,000 の場合、この値を格納するために使用できるデータ型はどれですか？\n *      A. int\n *      B. long long\n *      C. double\n *      D. 上記のいずれでもない\n *  \n *  質問 3:\n *  式の左辺値についての記述で誤っているものはどれですか？\n *      A. 変数名の式は左辺値です。\n *      B. インクリメント操作にはオペランドが左辺値であることが必要です。\n *      C. ポインタのデリファレンス式は左辺値です。\n *      D. プレフィックスインクリメント操作の式は左辺値です。\n *  \n *  質問 4:\n *  関数についての記述で誤っているものはどれですか？\n *      A. 関数の形式パラメータはローカル変数です。\n *      B. ローカル変数はスタックにスペースが割り当てられます。\n *      C. 関数の型は戻り値の型と同じです。\n *      D. 関数はその本体内から自身を呼び出すことができます。\n *  \n *  質問 5:\n *  ポインタについての記述で誤っているものはどれですか？\n *      A. 2 つのポインタを引くと、それらのアドレス値の差になります。\n *      B. ポインタのデリファレンスにはポインタの型に基づく解決が含まれます。\n *      C. int *p[4], p は int ポインタの配列です。\n *      D. 関数名は関数ポインタに代入できます。\n *  \n *  質問の選択肢を表す \"AAAAA\" のような文字列のみを返すことになっています。\n */\nconst char* f_20()", "ko": "#include <cassert>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n/**\n *  각 질문에 대해 선택지 A, B, C 또는 D를 제공하여 일련의 질문에 답하십시오.\n *  \n *  질문 1:\n *  1e6과 같은 상수는 어떤 데이터 유형에 속합니까?\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n *  \n *  질문 2:\n *  21! = 51,090,942,171,709,440,000인 경우, 이 값을 저장할 수 있는 데이터 유형은 무엇입니까?\n *      A. int\n *      B. long long\n *      C. double\n *      D. 위의 것들 중 어느 것도 아님\n *  \n *  질문 3:\n *  표현식에서 왼쪽 값에 대한 설명 중 틀린 것은 무엇입니까?\n *      A. 변수 이름 표현식은 왼쪽 값입니다.\n *      B. 증가 연산은 피연산자가 왼쪽 값이어야 합니다.\n *      C. 포인터 역참조 표현식은 왼쪽 값입니다.\n *      D. 전위 증가 연산 표현식은 왼쪽 값입니다.\n *  \n *  질문 4:\n *  함수에 대한 설명 중 틀린 것은 무엇입니까?\n *      A. 함수의 형식 매개변수는 지역 변수입니다.\n *      B. 지역 변수는 스택에 공간이 할당됩니다.\n *      C. 함수 유형은 반환 값 유형과 동일합니다.\n *      D. 함수는 본문 내에서 자신을 호출할 수 있습니다.\n *  \n *  질문 5:\n *  포인터에 대한 설명 중 틀린 것은 무엇입니까?\n *      A. 두 포인터를 빼면 주소 값의 차이와 같습니다.\n *      B. 포인터 역참조는 포인터의 유형을 기반으로 해석됩니다.\n *      C. int *p[4], p는 int 포인터 배열입니다.\n *      D. 함수 이름은 함수 포인터에 할당할 수 있습니다.\n *  \n *  당신은 질문의 선택지를 나타내는 \"AAAAA\"와 유사한 문자열만 반환해야 합니다.\n */\nconst char* f_20()\n", "ml": "#include <cassert>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n/**\n *  ഓരോ ചോദ്യത്തിനും A, B, C, അല്ലെങ്കിൽ D എന്ന ചോയ്‌സുകൾ നൽകിക്കൊണ്ട് ചോദ്യങ്ങൾക്ക് ഉത്തരം നൽകുക.\n *  \n *  ചോദ്യം 1:\n *  1e6 പോലുള്ള സ്ഥിരാങ്കങ്ങൾ ഏത് ഡാറ്റാ ടൈപ്പിൽ പെടുന്നു?\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n *  \n *  ചോദ്യം 2:\n *  21! = 51,090,942,171,709,440,000 എന്നതിനെ സൂക്ഷിക്കാൻ ഏത് ഡാറ്റാ ടൈപ്പ് ഉപയോഗിക്കാം?\n *      A. int\n *      B. long long\n *      C. double\n *      D. മുകളിലെവയും അല്ല\n *  \n *  ചോദ്യം 3:\n *  എക്‌സ്‌പ്രഷനിലെ ഇടത് മൂല്യങ്ങളെക്കുറിച്ചുള്ള ഏത് പ്രസ്താവന തെറ്റാണ്?\n *      A. വേരിയബിൾ നെയിം എക്‌സ്‌പ്രഷനുകൾ ഇടത് മൂല്യങ്ങളാണ്.\n *      B. വർദ്ധന ഓപ്പറേഷൻ നടത്താൻ ഓപ്പറാൻഡ് ഇടത് മൂല്യമായിരിക്കണം.\n *      C. പോയിന്റർ ഡീരിഫറൻസ് എക്‌സ്‌പ്രഷനുകൾ ഇടത് മൂല്യങ്ങളാണ്.\n *      D. പ്രിഫിക്സ് ഇൻക്രീമെന്റ് ഓപ്പറേഷൻ എക്‌സ്‌പ്രഷനുകൾ ഇടത് മൂല്യങ്ങളാണ്.\n *  \n *  ചോദ്യം 4:\n *  ഫംഗ്ഷനുകളെക്കുറിച്ചുള്ള ഏത് പ്രസ്താവന തെറ്റാണ്?\n *      A. ഒരു ഫംഗ്ഷന്റെ ഔപചാരിക പാരാമീറ്ററുകൾ ലോക്കൽ വേരിയബിൾസ് ആണ്.\n *      B. ലോക്കൽ വേരിയബിൾസ് സ്റ്റാക്കിൽ സ്ഥലം അനുവദിക്കുന്നു.\n *      C. ഫംഗ്ഷൻ തരം റിട്ടേൺ മൂല്യത്തിന്റെ തരം തന്നെയാണ്.\n *      D. ഒരു ഫംഗ്ഷൻ അതിന്റെ ബോഡിയിൽ നിന്ന് തന്നെ വിളിക്കാം.\n *  \n *  ചോദ്യം 5:\n *  പോയിന്ററുകളെക്കുറിച്ചുള്ള ഏത് പ്രസ്താവന തെറ്റാണ്?\n *      A. രണ്ട് പോയിന്ററുകൾ കുറയ്ക്കുന്നത് അവരുടെ അഡ്രസ് മൂല്യങ്ങളുടെ വ്യത്യാസം ആണ്.\n *      B. പോയിന്റർ ഡീരിഫറൻസ് ചെയ്യുന്നത് പോയിന്ററിന്റെ തരം അടിസ്ഥാനമാക്കി പരിഹരിക്കുന്നു.\n *      C. int *p[4], p ഒരു int പോയിന്ററുകളുടെ അറേ ആണ്.\n *      D. ഫംഗ്ഷൻ നാമങ്ങൾ ഫംഗ്ഷൻ പോയിന്ററുകൾക്ക് നിയോഗിക്കാം.\n *  \n *  നിങ്ങൾ \"AAAAA\" പോലുള്ള സ്ട്രിംഗുകൾ മാത്രമേ തിരികെ നൽകേണ്ടതുള്ളൂ, ഇത് ചോദ്യത്തിന്റെ ചോയ്‌സുകൾക്ക് നിൽക്കുന്നു.\n */\nconst char* f_20()", "fa": "#include <cassert>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n/**\n *  به یک سری سوال با ارائه گزینه‌های A، B، C یا D برای هر سوال پاسخ دهید.\n *  \n *  سوال 1:\n *  ثوابت مانند 1e6 به کدام نوع داده‌ای تعلق دارند؟\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n *  \n *  سوال 2:\n *  با توجه به 21! = 51,090,942,171,709,440,000، از کدام نوع داده‌ای می‌توان برای ذخیره این مقدار استفاده کرد؟\n *      A. int\n *      B. long long\n *      C. double\n *      D. هیچ‌کدام از موارد فوق\n *  \n *  سوال 3:\n *  کدام عبارت درباره مقادیر چپ در عبارات نادرست است؟\n *      A. عبارات نام متغیر مقادیر چپ هستند.\n *      B. عملیات افزایش نیاز دارد که عملوند یک مقدار چپ باشد.\n *      C. عبارات اشاره‌گر مقادیر چپ هستند.\n *      D. عبارات عملیات افزایش پیشوندی مقادیر چپ هستند.\n *  \n *  سوال 4:\n *  کدام عبارت درباره توابع نادرست است؟\n *      A. پارامترهای رسمی یک تابع متغیرهای محلی هستند.\n *      B. متغیرهای محلی در پشته فضا تخصیص داده می‌شوند.\n *      C. نوع تابع همانند نوع مقدار بازگشتی است.\n *      D. یک تابع می‌تواند خود را از درون بدنه‌اش فراخوانی کند.\n *  \n *  سوال 5:\n *  کدام عبارت درباره اشاره‌گرها نادرست است؟\n *      A. تفریق دو اشاره‌گر برابر با تفاوت در مقادیر آدرس آن‌ها است.\n *      B. اشاره‌گرها بر اساس نوع اشاره‌گر حل می‌شوند.\n *      C. int *p[4]، p یک آرایه از اشاره‌گرهای int است.\n *      D. نام‌های تابع می‌توانند به اشاره‌گرهای تابع اختصاص داده شوند.\n *  \n *  شما باید تنها رشته‌هایی مشابه \"AAAAA\" برگردانید که نشان‌دهنده انتخاب‌های سوال هستند.\n */\nconst char* f_20()"}, "canonical_solution": "{\n    return \"DDDBA\";\n}", "instruction": {"en": "const char* f_20()\n{\n    return \"DDDBA\";\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.", "sq": "const char* f_20()\n{\n    return \"DDDBA\";\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit CPP në shqip duke përdorur maksimumi 500 karaktere.", "hy": "const char* f_20()\n{\n    return \"DDDBA\";\n}\n\nՏվեք CPP կոդի հակիրճ բնութագիրը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։", "bn": "const char* f_20()\n{\n    return \"DDDBA\";\n}\n\nসিপিপি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।", "bg": "const char* f_20()\n{\n    return \"DDDBA\";\n}\n\nПредоставете кратко описание на CPP кода на естествен език на български, използвайки не повече от 500 знака.", "zh": "const char* f_20()\n{\n    return \"DDDBA\";\n}\n\n请用中文为以下CPP代码提供一个简明的自然语言描述（文档字符串），字数不超过500个字符。", "fr": "const char* f_20()\n{\n    return \"DDDBA\";\n}\n\nFournissez une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.", "de": "const char* f_20()\n{\n    return \"DDDBA\";\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen.", "ha": "const char* f_20()\n{\n    return \"DDDBA\";\n}\n\nBa da takaitaccen bayanin yanayi na halitta (docstring) na lambar CPP cikin Hausa ta amfani da haruffa 500 kawai.", "hi": "const char* f_20()\n{\n    return \"DDDBA\";\n}\n\nसीपीपी कोड के लिए अधिकतम 500 वर्णों में एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें।", "hu": "const char* f_20()\n{\n    return \"DDDBA\";\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a CPP kódról magyarul, legfeljebb 500 karakterben.", "es": "const char* f_20()\n{\n    return \"DDDBA\";\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando como máximo 500 caracteres.", "arb": "const char* f_20()\n{\n    return \"DDDBA\";\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C++ باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "const char* f_20()\n{\n    return \"DDDBA\";\n}\n\nToa maelezo mafupi kwa lugha ya asili (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "const char* f_20()\n{\n    return \"DDDBA\";\n}\n\nAşağıdaki CPP kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda bir doğal dil açıklaması (docstring) sağlayın.", "vi": "const char* f_20()\n{\n    return \"DDDBA\";\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự.", "id": "const char* f_20()\n{\n    return \"DDDBA\";\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode CPP dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "const char* f_20()\n{\n    return \"DDDBA\";\n}\n\n以下のCPPコードの簡潔な自然言語による説明（ドックストリング）を日本語で500文字以内で提供してください。", "ko": "const char* f_20()\n{\n    return \"DDDBA\";\n}\n\n다음 CPP 코드의 동작을 간결하게 설명하는 자연어 설명(도크스트링)을 한국어로 작성하세요. 최대 500자까지 가능합니다.", "ml": "const char* f_20()\n{\n    return \"DDDBA\";\n}\n\nസിപിപി കോഡിന്റെ മലയാളത്തിലുള്ള വിവരണം (ഡോക്സ്ട്രിംഗ്) 500 അക്ഷരങ്ങളിൽ കവിയാതെയായി നൽകുക.", "fa": "const char* f_20()\n{\n    return \"DDDBA\";\n}\n\nتوضیح مختصر و طبیعی (docstring) از کد CPP به زبان فارسی ارائه دهید که حداکثر ۵۰۰ کاراکتر باشد."}, "level": "", "test": "int main() {\n    // The assert should compare strings, not literals or enums, using strcmp\n    const char* expected_answers = \"DDDBA\";\n    assert(strcmp(f_20(), expected_answers) == 0);\n    \n    return 0;\n}", "entry_point": "f_20", "signature": "const char* f_20()", "docstring": {"en": "Answer a series of questions by providing choices A, B, C, or D for each question.\n\nQuestion 1:\nConstants like 1e6 belong to which data type?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nQuestion 2:\nGiven 21! = 51,090,942,171,709,440,000, which data type can be used to store this value?\n    A. int\n    B. long long\n    C. double\n    D. None of the above\n\nQuestion 3:\nWhich statement about left values in expressions is incorrect?\n    A. Variable name expressions are left values.\n    B. Increment operation requires the operand to be a left value.\n    C. Pointer dereference expressions are left values.\n    D. Prefix increment operation expressions are left values.\n\nQuestion 4:\nWhich statement about functions is incorrect?\n    A. Formal parameters of a function are local variables.\n    B. Local variables are allocated space in the stack.\n    C. The function type is the same as the return value type.\n    D. A function can call itself from within its body.\n\nQuestion 5:\nWhich statement about pointers is incorrect?\n    A. Subtracting two pointers equals the difference in their address values.\n    B. Pointer dereference involves resolving based on the pointer's type.\n    C. int *p[4], p is an array of int pointers.\n    D. Function names can be assigned to function pointers.\n\nYou're supposed to only return strings similar to \"AAAAA\", which stand for the choices of the question.", "sq": "Përgjigjuni një serie pyetjesh duke dhënë zgjedhjet A, B, C, ose D për secilën pyetje.\n\nPyetja 1:\nKonstantet si 1e6 i përkasin cilit tip të dhënash?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nPyetja 2:\nDuke dhënë 21! = 51,090,942,171,709,440,000, cili tip i të dhënave mund të përdoret për të ruajtur këtë vlerë?\n    A. int\n    B. long long\n    C. double\n    D. Asnjë nga më sipër\n\nPyetja 3:\nCila deklaratë për vlerat e majta në shprehje është e pasaktë?\n    A. Shprehjet e emrave të variablave janë vlera të majta.\n    B. Operacioni i inkrementimit kërkon që operandi të jetë një vlerë e majtë.\n    C. Shprehjet e dereferencimit të treguesve janë vlera të majta.\n    D. Shprehjet e operacionit të inkrementimit prefiks janë vlera të majta.\n\nPyetja 4:\nCila deklaratë për funksionet është e pasaktë?\n    A. Parametrat formalë të një funksioni janë variabla lokale.\n    B. Variablat lokale kanë hapësirë të alokuar në stack.\n    C. Tipi i funksionit është i njëjtë me tipin e vlerës së kthimit.\n    D. Një funksion mund të thërrasë vetveten brenda trupit të tij.\n\nPyetja 5:\nCila deklaratë për treguesit është e pasaktë?\n    A. Zbritja e dy treguesve është e barabartë me diferencën në vlerat e adresave të tyre.\n    B. Dereferencimi i treguesit përfshin zgjidhjen bazuar në tipin e treguesit.\n    C. int *p[4], p është një varg treguesish int.\n    D. Emrat e funksioneve mund të caktohen te treguesit e funksioneve.\n\nJu supozohet të ktheni vetëm vargje të ngjashme me \"AAAAA\", të cilat përfaqësojnë zgjedhjet e pyetjeve.", "hy": "Պատասխանել մի շարք հարցերի՝ յուրաքանչյուր հարցի համար տրամադրելով ընտրանքներ A, B, C կամ D:\n\nՀարց 1:\nՆման 1e6 հաստատունները որ տվյալների տիպին են պատկանում?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nՀարց 2:\nԵթե 21! = 51,090,942,171,709,440,000, ապա որ տվյալների տիպը կարող է պահել այս արժեքը?\n    A. int\n    B. long long\n    C. double\n    D. Վերը նշվածներից ոչ մեկը\n\nՀարց 3:\nՈր հայտարարությունը ձախ արժեքների մասին արտահայտություններում սխալ է?\n    A. Փոփոխականի անվան արտահայտությունները ձախ արժեքներ են:\n    B. Ինկրեմենտ գործողությունը պահանջում է, որ օպերանդը լինի ձախ արժեք:\n    C. Ցուցիչի դե-ռեֆերենս արտահայտությունները ձախ արժեքներ են:\n    D. Նախածանց ինկրեմենտ գործողության արտահայտությունները ձախ արժեքներ են:\n\nՀարց 4:\nՈր հայտարարությունը ֆունկցիաների մասին սխալ է?\n    A. Ֆունկցիայի ֆորմալ պարամետրերը տեղական փոփոխականներ են:\n    B. Տեղական փոփոխականները տեղադրվում են ստեկում:\n    C. Ֆունկցիայի տիպը նույնն է, ինչ վերադարձվող արժեքի տիպը:\n    D. Ֆունկցիան կարող է ինքն իրեն կանչել իր մարմնից:\n\nՀարց 5:\nՈր հայտարարությունը ցուցիչների մասին սխալ է?\n    A. Երկու ցուցիչների հանումը հավասար է նրանց հասցեների արժեքների տարբերությանը:\n    B. Ցուցիչի դե-ռեֆերենսը ներառում է լուծում՝ հիմնված ցուցիչի տիպի վրա:\n    C. int *p[4], p-ն int ցուցիչների զանգված է:\n    D. Ֆունկցիայի անունները կարող են վերագրվել ֆունկցիայի ցուցիչներին:\n\nԴուք պետք է վերադարձնեք միայն \"AAAAA\" նման տողեր, որոնք ներկայացնում են հարցի ընտրանքները:", "bn": "একটি প্রশ্নের সিরিজের উত্তর দিন প্রতিটি প্রশ্নের জন্য A, B, C, বা D পছন্দ প্রদান করে।\n\nপ্রশ্ন ১:\n1e6 এর মতো ধ্রুবক কোন ডেটা টাইপের অন্তর্গত?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nপ্রশ্ন ২:\nযদি 21! = 51,090,942,171,709,440,000 হয়, তবে কোন ডেটা টাইপ এই মানটি সংরক্ষণ করতে ব্যবহার করা যেতে পারে?\n    A. int\n    B. long long\n    C. double\n    D. উপরের কোনোটিই নয়\n\nপ্রশ্ন ৩:\nএক্সপ্রেশনে বাম মান সম্পর্কে কোন বিবৃতি ভুল?\n    A. ভেরিয়েবল নাম এক্সপ্রেশনগুলি বাম মান।\n    B. ইনক্রিমেন্ট অপারেশনটির জন্য অপারেন্ডটি একটি বাম মান হতে হবে।\n    C. পয়েন্টার ডেরেফারেন্স এক্সপ্রেশনগুলি বাম মান।\n    D. প্রিফিক্স ইনক্রিমেন্ট অপারেশন এক্সপ্রেশনগুলি বাম মান।\n\nপ্রশ্ন ৪:\nফাংশন সম্পর্কে কোন বিবৃতি ভুল?\n    A. একটি ফাংশনের আনুষ্ঠানিক প্যারামিটারগুলি স্থানীয় ভেরিয়েবল।\n    B. স্থানীয় ভেরিয়েবলগুলি স্ট্যাকে স্থান বরাদ্দ করা হয়।\n    C. ফাংশন টাইপটি রিটার্ন ভ্যালু টাইপের মতোই।\n    D. একটি ফাংশন তার দেহের ভিতর থেকে নিজেকে কল করতে পারে।\n\nপ্রশ্ন ৫:\nপয়েন্টার সম্পর্কে কোন বিবৃতি ভুল?\n    A. দুটি পয়েন্টার বিয়োগ করলে তাদের ঠিকানা মানের পার্থক্য সমান হয়।\n    B. পয়েন্টার ডেরেফারেন্স পয়েন্টারের টাইপের উপর ভিত্তি করে সমাধান করে।\n    C. int *p[4], p একটি int পয়েন্টারের অ্যারে।\n    D. ফাংশন নামগুলি ফাংশন পয়েন্টারগুলিতে বরাদ্দ করা যেতে পারে।\n\nআপনাকে প্রশ্নের পছন্দের জন্য \"AAAAA\" এর মতো স্ট্রিংগুলি ফেরত দিতে হবে।", "bg": "Отговорете на серия от въпроси, като предоставите избори A, B, C или D за всеки въпрос.\n\nВъпрос 1:\nКонстанти като 1e6 принадлежат към кой тип данни?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nВъпрос 2:\nДадено е 21! = 51,090,942,171,709,440,000, кой тип данни може да се използва за съхранение на тази стойност?\n    A. int\n    B. long long\n    C. double\n    D. Нито едно от горепосочените\n\nВъпрос 3:\nКое твърдение за левите стойности в изразите е неправилно?\n    A. Изразите с имена на променливи са леви стойности.\n    B. Операцията за инкрементиране изисква операндът да е лява стойност.\n    C. Изразите за разименуване на указатели са леви стойности.\n    D. Изразите за префиксно инкрементиране са леви стойности.\n\nВъпрос 4:\nКое твърдение за функциите е неправилно?\n    A. Формалните параметри на функцията са локални променливи.\n    B. Локалните променливи са разпределени в стека.\n    C. Типът на функцията е същият като типа на връщаната стойност.\n    D. Функцията може да извика себе си от тялото си.\n\nВъпрос 5:\nКое твърдение за указателите е неправилно?\n    A. Изваждането на два указателя е равно на разликата в техните адресни стойности.\n    B. Разименуването на указател включва разрешаване на базата на типа на указателя.\n    C. int *p[4], p е масив от указатели към int.\n    D. Имената на функциите могат да бъдат присвоени на указатели към функции.\n\nТрябва да върнете само низове, подобни на \"AAAAA\", които представляват изборите на въпроса.", "zh": "回答一系列问题，为每个问题提供选择A、B、C或D。\n\n问题1：\n像1e6这样的常量属于哪种数据类型？\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\n问题2：\n给定21! = 51,090,942,171,709,440,000，哪种数据类型可以用来存储这个值？\n    A. int\n    B. long long\n    C. double\n    D. 以上都不是\n\n问题3：\n关于表达式中的左值，哪种说法是不正确的？\n    A. 变量名表达式是左值。\n    B. 增量操作要求操作数是左值。\n    C. 指针解引用表达式是左值。\n    D. 前缀增量操作表达式是左值。\n\n问题4：\n关于函数，哪种说法是不正确的？\n    A. 函数的形式参数是局部变量。\n    B. 局部变量在栈中分配空间。\n    C. 函数类型与返回值类型相同。\n    D. 函数可以在其主体内调用自身。\n\n问题5：\n关于指针，哪种说法是不正确的？\n    A. 两个指针相减等于它们地址值的差。\n    B. 指针解引用涉及基于指针类型的解析。\n    C. int *p[4]，p是一个int指针数组。\n    D. 函数名可以赋值给函数指针。\n\n你应该只返回类似于\"AAAAA\"的字符串，代表问题的选择。", "fr": "Répondez à une série de questions en fournissant les choix A, B, C ou D pour chaque question.\n\nQuestion 1 :\nLes constantes comme 1e6 appartiennent à quel type de données ?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nQuestion 2 :\nÉtant donné 21! = 51,090,942,171,709,440,000, quel type de données peut être utilisé pour stocker cette valeur ?\n    A. int\n    B. long long\n    C. double\n    D. Aucun des précédents\n\nQuestion 3 :\nQuelle affirmation concernant les valeurs à gauche dans les expressions est incorrecte ?\n    A. Les expressions de nom de variable sont des valeurs à gauche.\n    B. L'opération d'incrément nécessite que l'opérande soit une valeur à gauche.\n    C. Les expressions de déréférencement de pointeur sont des valeurs à gauche.\n    D. Les expressions d'opération d'incrémentation préfixe sont des valeurs à gauche.\n\nQuestion 4 :\nQuelle affirmation concernant les fonctions est incorrecte ?\n    A. Les paramètres formels d'une fonction sont des variables locales.\n    B. Les variables locales sont allouées dans la pile.\n    C. Le type de la fonction est le même que le type de la valeur de retour.\n    D. Une fonction peut s'appeler elle-même depuis son corps.\n\nQuestion 5 :\nQuelle affirmation concernant les pointeurs est incorrecte ?\n    A. Soustraire deux pointeurs équivaut à la différence de leurs valeurs d'adresse.\n    B. Le déréférencement de pointeur implique une résolution basée sur le type du pointeur.\n    C. int *p[4], p est un tableau de pointeurs int.\n    D. Les noms de fonctions peuvent être assignés à des pointeurs de fonction.\n\nVous êtes censé ne retourner que des chaînes similaires à \"AAAAA\", qui représentent les choix de la question.", "de": "Beantworten Sie eine Reihe von Fragen, indem Sie für jede Frage die Auswahlmöglichkeiten A, B, C oder D angeben.\n\nFrage 1:\nKonstanten wie 1e6 gehören zu welchem Datentyp?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nFrage 2:\nGegeben 21! = 51,090,942,171,709,440,000, welcher Datentyp kann verwendet werden, um diesen Wert zu speichern?\n    A. int\n    B. long long\n    C. double\n    D. Keine der oben genannten\n\nFrage 3:\nWelche Aussage über linke Werte in Ausdrücken ist falsch?\n    A. Variablennamenausdrücke sind linke Werte.\n    B. Die Inkrementoperation erfordert, dass der Operand ein linker Wert ist.\n    C. Zeiger-Dereferenzierungsausdrücke sind linke Werte.\n    D. Präfix-Inkrementoperation-Ausdrücke sind linke Werte.\n\nFrage 4:\nWelche Aussage über Funktionen ist falsch?\n    A. Formale Parameter einer Funktion sind lokale Variablen.\n    B. Lokale Variablen werden im Stapel Speicherplatz zugewiesen.\n    C. Der Funktionstyp ist derselbe wie der Rückgabewerttyp.\n    D. Eine Funktion kann sich selbst innerhalb ihres Körpers aufrufen.\n\nFrage 5:\nWelche Aussage über Zeiger ist falsch?\n    A. Das Subtrahieren von zwei Zeigern entspricht der Differenz ihrer Adresswerte.\n    B. Die Zeiger-Dereferenzierung beinhaltet die Auflösung basierend auf dem Typ des Zeigers.\n    C. int *p[4], p ist ein Array von int-Zeigern.\n    D. Funktionsnamen können Funktionszeigern zugewiesen werden.\n\nSie sollen nur Zeichenfolgen wie \"AAAAA\" zurückgeben, die für die Auswahlmöglichkeiten der Frage stehen.", "ha": "Amsa jerin tambayoyi ta hanyar bayar da zaɓuɓɓuka A, B, C, ko D don kowace tambaya.\n\nTambaya ta 1:\nDindindin kamar 1e6 suna cikin wane nau'in bayanai?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nTambaya ta 2:\nAn ba da 21! = 51,090,942,171,709,440,000, wane nau'in bayanai za a iya amfani da shi don adana wannan ƙima?\n    A. int\n    B. long long\n    C. double\n    D. Babu ɗaya daga cikin waɗanda ke sama\n\nTambaya ta 3:\nWane bayani game da ƙimar hagu a cikin bayyana ba daidai ba ne?\n    A. Bayanan sunan canji suna ƙimar hagu.\n    B. Aiki na ƙaruwa yana buƙatar mai aiki ya zama ƙimar hagu.\n    C. Bayanan cirewa mai nuna suna ƙimar hagu.\n    D. Bayanan aiki na ƙaruwa na farko suna ƙimar hagu.\n\nTambaya ta 4:\nWane bayani game da ayyuka ba daidai ba ne?\n    A. Sigogi na zahiri na aiki suna da canje-canje na gida.\n    B. Canje-canje na gida suna samun sarari a cikin faifai.\n    C. Nau'in aiki yana daidai da nau'in ƙimar dawowa.\n    D. Aiki na iya kiran kansa daga cikin jikinsa.\n\nTambaya ta 5:\nWane bayani game da masu nuna ba daidai ba ne?\n    A. Cirewa masu nuna biyu yana daidai da bambanci a cikin ƙimar adireshinsu.\n    B. Cirewa mai nuna yana haɗawa da warwarewa bisa nau'in mai nuna.\n    C. int *p[4], p tsari ne na masu nuna int.\n    D. Ana iya sanya sunayen ayyuka zuwa masu nuna ayyuka.\n\nAna tsammanin ka dawo da igiyoyi makamancin \"AAAAA\", wanda ke wakiltar zaɓuɓɓukan tambayar.", "hi": "प्रश्नों की एक श्रृंखला का उत्तर देकर प्रत्येक प्रश्न के लिए विकल्प A, B, C, या D प्रदान करें।\n\nप्रश्न 1:\n1e6 जैसी स्थिरांक किस डेटा प्रकार से संबंधित हैं?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nप्रश्न 2:\n21! = 51,090,942,171,709,440,000 दिया गया है, इस मान को संग्रहीत करने के लिए कौन सा डेटा प्रकार उपयोग किया जा सकता है?\n    A. int\n    B. long long\n    C. double\n    D. उपरोक्त में से कोई नहीं\n\nप्रश्न 3:\nअभिव्यक्तियों में बाएं मानों के बारे में कौन सा कथन गलत है?\n    A. चर नाम अभिव्यक्तियाँ बाएं मान हैं।\n    B. वृद्धि ऑपरेशन के लिए ऑपरेन्ड का बाएं मान होना आवश्यक है।\n    C. पॉइंटर डिरेफरेंस अभिव्यक्तियाँ बाएं मान हैं।\n    D. उपसर्ग वृद्धि ऑपरेशन अभिव्यक्तियाँ बाएं मान हैं।\n\nप्रश्न 4:\nकार्य के बारे में कौन सा कथन गलत है?\n    A. किसी कार्य के औपचारिक पैरामीटर स्थानीय चर हैं।\n    B. स्थानीय चर स्टैक में स्थान आवंटित करते हैं।\n    C. कार्य प्रकार वही है जो वापसी मूल्य प्रकार है।\n    D. एक कार्य अपने शरीर के भीतर से खुद को कॉल कर सकता है।\n\nप्रश्न 5:\nपॉइंटर्स के बारे में कौन सा कथन गलत है?\n    A. दो पॉइंटर्स को घटाने से उनके पते के मानों में अंतर होता है।\n    B. पॉइंटर डिरेफरेंस में पॉइंटर के प्रकार के आधार पर समाधान शामिल होता है।\n    C. int *p[4], p एक int पॉइंटर्स की सरणी है।\n    D. कार्य नामों को कार्य पॉइंटर्स को सौंपा जा सकता है।\n\nआपको केवल \"AAAAA\" जैसे स्ट्रिंग्स लौटाने हैं, जो प्रश्न के विकल्पों के लिए खड़े हैं।", "hu": "Válaszolj egy sor kérdésre azáltal, hogy választ adsz A, B, C vagy D lehetőségek közül minden kérdésre.\n\n1. kérdés:\nAz olyan konstansok, mint az 1e6, melyik adattípushoz tartoznak?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\n2. kérdés:\nAdott a 21! = 51,090,942,171,709,440,000, melyik adattípus használható ennek az értéknek a tárolására?\n    A. int\n    B. long long\n    C. double\n    D. Egyik sem\n\n3. kérdés:\nMelyik állítás helytelen a balértékekkel kapcsolatban a kifejezésekben?\n    A. A változónév kifejezések balértékek.\n    B. Az inkrementáló művelet megköveteli, hogy az operandus balérték legyen.\n    C. A pointer dereferencia kifejezések balértékek.\n    D. A prefix inkrementáló művelet kifejezések balértékek.\n\n4. kérdés:\nMelyik állítás helytelen a függvényekkel kapcsolatban?\n    A. A függvény formális paraméterei lokális változók.\n    B. A lokális változók a veremben kapnak helyet.\n    C. A függvény típusa megegyezik a visszatérési érték típusával.\n    D. Egy függvény meghívhatja önmagát a törzsén belül.\n\n5. kérdés:\nMelyik állítás helytelen a pointerekkel kapcsolatban?\n    A. Két pointer kivonása egyenlő a címértékeik különbségével.\n    B. A pointer dereferencia a pointer típusának alapján történik.\n    C. int *p[4], p egy int pointerek tömbje.\n    D. A függvénynevek hozzárendelhetők függvénypointerekhez.\n\nCsak olyan karakterláncokat kell visszaadnod, mint \"AAAAA\", amelyek a kérdések választásait jelölik.", "es": "Responde a una serie de preguntas proporcionando opciones A, B, C o D para cada pregunta.\n\nPregunta 1:\n¿A qué tipo de datos pertenecen constantes como 1e6?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nPregunta 2:\nDado 21! = 51,090,942,171,709,440,000, ¿qué tipo de datos se puede usar para almacenar este valor?\n    A. int\n    B. long long\n    C. double\n    D. Ninguna de las anteriores\n\nPregunta 3:\n¿Cuál afirmación sobre los valores a la izquierda en las expresiones es incorrecta?\n    A. Las expresiones de nombres de variables son valores a la izquierda.\n    B. La operación de incremento requiere que el operando sea un valor a la izquierda.\n    C. Las expresiones de desreferenciación de punteros son valores a la izquierda.\n    D. Las expresiones de operación de incremento prefijo son valores a la izquierda.\n\nPregunta 4:\n¿Cuál afirmación sobre las funciones es incorrecta?\n    A. Los parámetros formales de una función son variables locales.\n    B. Las variables locales se asignan espacio en la pila.\n    C. El tipo de la función es el mismo que el tipo del valor de retorno.\n    D. Una función puede llamarse a sí misma desde dentro de su cuerpo.\n\nPregunta 5:\n¿Cuál afirmación sobre los punteros es incorrecta?\n    A. Restar dos punteros equivale a la diferencia en sus valores de dirección.\n    B. La desreferenciación de punteros implica resolver en función del tipo del puntero.\n    C. int *p[4], p es un arreglo de punteros a int.\n    D. Los nombres de funciones pueden asignarse a punteros de funciones.\n\nSe supone que solo debes devolver cadenas similares a \"AAAAA\", que representan las opciones de la pregunta.", "arb": "الإجابة على سلسلة من الأسئلة عن طريق تقديم الخيارات A، B، C، أو D لكل سؤال.\n\nالسؤال 1:\nالثوابت مثل 1e6 تنتمي إلى أي نوع من البيانات؟\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nالسؤال 2:\nبالنظر إلى 21! = 51,090,942,171,709,440,000، أي نوع من البيانات يمكن استخدامه لتخزين هذه القيمة؟\n    A. int\n    B. long long\n    C. double\n    D. لا شيء مما سبق\n\nالسؤال 3:\nأي عبارة عن القيم اليسرى في التعبيرات غير صحيحة؟\n    A. تعبيرات أسماء المتغيرات هي قيم يسرى.\n    B. عملية الزيادة تتطلب أن يكون المعامل قيمة يسرى.\n    C. تعبيرات إلغاء الإشارة للمؤشر هي قيم يسرى.\n    D. تعبيرات عملية الزيادة السابقة هي قيم يسرى.\n\nالسؤال 4:\nأي عبارة عن الدوال غير صحيحة؟\n    A. المعاملات الرسمية للدالة هي متغيرات محلية.\n    B. يتم تخصيص مساحة للمتغيرات المحلية في المكدس.\n    C. نوع الدالة هو نفسه نوع قيمة الإرجاع.\n    D. يمكن للدالة أن تستدعي نفسها من داخل جسمها.\n\nالسؤال 5:\nأي عبارة عن المؤشرات غير صحيحة؟\n    A. طرح مؤشرين يساوي الفرق في قيم عناوينهما.\n    B. إلغاء الإشارة للمؤشر يتضمن الحل بناءً على نوع المؤشر.\n    C. int *p[4]، p هو مصفوفة من مؤشرات int.\n    D. يمكن تعيين أسماء الدوال لمؤشرات الدوال.\n\nمن المفترض أن تعيد فقط سلاسل مشابهة لـ \"AAAAA\"، والتي تمثل اختيارات السؤال.", "sw": "Jibu maswali kadhaa kwa kutoa chaguo A, B, C, au D kwa kila swali.\n\nSwali la 1:\nKonstant kama 1e6 ni ya aina gani ya data?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nSwali la 2:\nKwa kuzingatia 21! = 51,090,942,171,709,440,000, aina gani ya data inaweza kutumika kuhifadhi thamani hii?\n    A. int\n    B. long long\n    C. double\n    D. Hakuna kati ya haya\n\nSwali la 3:\nNi tamko gani kuhusu thamani za kushoto katika maonyesho ambalo si sahihi?\n    A. Maonyesho ya majina ya vigezo ni thamani za kushoto.\n    B. Operesheni ya kuongeza inahitaji operand kuwa thamani ya kushoto.\n    C. Maonyesho ya kufuta pointer ni thamani za kushoto.\n    D. Maonyesho ya operesheni ya kuongeza awali ni thamani za kushoto.\n\nSwali la 4:\nNi tamko gani kuhusu kazi ambalo si sahihi?\n    A. Vigezo rasmi vya kazi ni vigezo vya ndani.\n    B. Vigezo vya ndani vinatengewa nafasi kwenye stack.\n    C. Aina ya kazi ni sawa na aina ya thamani inayorejeshwa.\n    D. Kazi inaweza kujita kutoka ndani ya mwili wake.\n\nSwali la 5:\nNi tamko gani kuhusu pointer ambalo si sahihi?\n    A. Kutoa pointer mbili ni sawa na tofauti katika thamani za anuani zao.\n    B. Kufuta pointer kunahusisha kutatua kulingana na aina ya pointer.\n    C. int *p[4], p ni safu ya pointer za int.\n    D. Majina ya kazi yanaweza kupewa pointer za kazi.\n\nUnatakiwa kurudisha tu mistari kama \"AAAAA\", ambayo inawakilisha chaguo za swali.", "tr": "Bir dizi soruya, her soru için A, B, C veya D seçeneklerini sağlayarak cevap verin.\n\nSoru 1:\n1e6 gibi sabitler hangi veri türüne aittir?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nSoru 2:\n21! = 51,090,942,171,709,440,000 verildiğinde, bu değeri saklamak için hangi veri türü kullanılabilir?\n    A. int\n    B. long long\n    C. double\n    D. Yukarıdakilerin hiçbiri\n\nSoru 3:\nİfadelerdeki sol değerler hakkında hangi ifade yanlıştır?\n    A. Değişken adı ifadeleri sol değerlerdir.\n    B. Artırma işlemi, operandın bir sol değer olmasını gerektirir.\n    C. Gösterici çözme ifadeleri sol değerlerdir.\n    D. Ön ek artırma işlemi ifadeleri sol değerlerdir.\n\nSoru 4:\nFonksiyonlar hakkında hangi ifade yanlıştır?\n    A. Bir fonksiyonun resmi parametreleri yerel değişkenlerdir.\n    B. Yerel değişkenler yığında yer kaplar.\n    C. Fonksiyon türü, dönüş değeri türü ile aynıdır.\n    D. Bir fonksiyon, kendi gövdesinden kendisini çağırabilir.\n\nSoru 5:\nGöstericiler hakkında hangi ifade yanlıştır?\n    A. İki göstericinin çıkarılması, adres değerlerindeki farkı eşittir.\n    B. Gösterici çözme, göstericinin türüne göre çözümlemeyi içerir.\n    C. int *p[4], p bir int gösterici dizisidir.\n    D. Fonksiyon adları, fonksiyon göstericilerine atanabilir.\n\nSoruların seçeneklerini temsil eden \"AAAAA\" gibi dizeleri döndürmeniz bekleniyor.", "vi": "Trả lời một loạt câu hỏi bằng cách cung cấp lựa chọn A, B, C, hoặc D cho mỗi câu hỏi.\n\nCâu hỏi 1:\nHằng số như 1e6 thuộc kiểu dữ liệu nào?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nCâu hỏi 2:\nCho 21! = 51,090,942,171,709,440,000, kiểu dữ liệu nào có thể được sử dụng để lưu trữ giá trị này?\n    A. int\n    B. long long\n    C. double\n    D. Không có kiểu nào ở trên\n\nCâu hỏi 3:\nCâu nào về giá trị bên trái trong biểu thức là không đúng?\n    A. Biểu thức tên biến là giá trị bên trái.\n    B. Phép toán tăng yêu cầu toán hạng là giá trị bên trái.\n    C. Biểu thức giải tham chiếu con trỏ là giá trị bên trái.\n    D. Biểu thức phép toán tăng trước là giá trị bên trái.\n\nCâu hỏi 4:\nCâu nào về hàm là không đúng?\n    A. Tham số hình thức của một hàm là biến cục bộ.\n    B. Biến cục bộ được cấp phát không gian trong ngăn xếp.\n    C. Kiểu hàm giống với kiểu giá trị trả về.\n    D. Một hàm có thể gọi chính nó từ trong thân hàm.\n\nCâu hỏi 5:\nCâu nào về con trỏ là không đúng?\n    A. Trừ hai con trỏ bằng với sự khác biệt trong giá trị địa chỉ của chúng.\n    B. Giải tham chiếu con trỏ liên quan đến việc giải quyết dựa trên kiểu của con trỏ.\n    C. int *p[4], p là một mảng của các con trỏ int.\n    D. Tên hàm có thể được gán cho con trỏ hàm.\n\nBạn được yêu cầu chỉ trả về chuỗi tương tự như \"AAAAA\", đại diện cho các lựa chọn của câu hỏi.", "id": "Jawab serangkaian pertanyaan dengan memberikan pilihan A, B, C, atau D untuk setiap pertanyaan.\n\nPertanyaan 1:\nKonstanta seperti 1e6 termasuk dalam tipe data apa?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nPertanyaan 2:\nDiberikan 21! = 51,090,942,171,709,440,000, tipe data mana yang dapat digunakan untuk menyimpan nilai ini?\n    A. int\n    B. long long\n    C. double\n    D. Tidak ada dari yang di atas\n\nPertanyaan 3:\nPernyataan mana tentang nilai kiri dalam ekspresi yang salah?\n    A. Ekspresi nama variabel adalah nilai kiri.\n    B. Operasi peningkatan memerlukan operan menjadi nilai kiri.\n    C. Ekspresi dereferensi pointer adalah nilai kiri.\n    D. Ekspresi operasi peningkatan prefiks adalah nilai kiri.\n\nPertanyaan 4:\nPernyataan mana tentang fungsi yang salah?\n    A. Parameter formal dari suatu fungsi adalah variabel lokal.\n    B. Variabel lokal dialokasikan ruang di stack.\n    C. Tipe fungsi sama dengan tipe nilai kembalian.\n    D. Sebuah fungsi dapat memanggil dirinya sendiri dari dalam tubuhnya.\n\nPertanyaan 5:\nPernyataan mana tentang pointer yang salah?\n    A. Mengurangi dua pointer sama dengan perbedaan dalam nilai alamat mereka.\n    B. Dereferensi pointer melibatkan penyelesaian berdasarkan tipe pointer.\n    C. int *p[4], p adalah array dari pointer int.\n    D. Nama fungsi dapat ditugaskan ke pointer fungsi.\n\nAnda seharusnya hanya mengembalikan string seperti \"AAAAA\", yang mewakili pilihan dari pertanyaan.", "ja": "一連の質問に対して、各質問に対する選択肢 A、B、C、または D を提供してください。\n\n質問 1:\n1e6 のような定数はどのデータ型に属しますか？\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\n質問 2:\n21! = 51,090,942,171,709,440,000 の場合、この値を格納するために使用できるデータ型はどれですか？\n    A. int\n    B. long long\n    C. double\n    D. 上記のいずれでもない\n\n質問 3:\n式における左辺値に関する記述のうち、誤っているものはどれですか？\n    A. 変数名の式は左辺値である。\n    B. インクリメント操作には被演算子が左辺値であることが必要である。\n    C. ポインタのデリファレンス式は左辺値である。\n    D. プレフィックスインクリメント操作の式は左辺値である。\n\n質問 4:\n関数に関する記述のうち、誤っているものはどれですか？\n    A. 関数の仮引数はローカル変数である。\n    B. ローカル変数はスタックにスペースが割り当てられる。\n    C. 関数の型は戻り値の型と同じである。\n    D. 関数はその本体から自身を呼び出すことができる。\n\n質問 5:\nポインタに関する記述のうち、誤っているものはどれですか？\n    A. 2つのポインタを引くと、それらのアドレス値の差になる。\n    B. ポインタのデリファレンスはポインタの型に基づいて解決される。\n    C. int *p[4]、p は int ポインタの配列である。\n    D. 関数名は関数ポインタに代入できる。\n\nあなたは質問の選択肢を表す \"AAAAA\" のような文字列のみを返すことになっています。", "ko": "질문에 대한 답변을 A, B, C 또는 D로 제공하십시오.\n\n질문 1:\n1e6과 같은 상수는 어떤 데이터 유형에 속합니까?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\n질문 2:\n21! = 51,090,942,171,709,440,000이 주어졌을 때, 이 값을 저장할 수 있는 데이터 유형은 무엇입니까?\n    A. int\n    B. long long\n    C. double\n    D. 위의 어느 것도 아님\n\n질문 3:\n식에서 왼쪽 값에 대한 설명 중 틀린 것은 무엇입니까?\n    A. 변수 이름 표현식은 왼쪽 값입니다.\n    B. 증가 연산은 피연산자가 왼쪽 값이어야 합니다.\n    C. 포인터 역참조 표현식은 왼쪽 값입니다.\n    D. 접두사 증가 연산 표현식은 왼쪽 값입니다.\n\n질문 4:\n함수에 대한 설명 중 틀린 것은 무엇입니까?\n    A. 함수의 형식 매개변수는 지역 변수입니다.\n    B. 지역 변수는 스택에 공간이 할당됩니다.\n    C. 함수 유형은 반환 값 유형과 동일합니다.\n    D. 함수는 본문 내에서 자신을 호출할 수 있습니다.\n\n질문 5:\n포인터에 대한 설명 중 틀린 것은 무엇입니까?\n    A. 두 포인터를 빼면 주소 값의 차이가 됩니다.\n    B. 포인터 역참조는 포인터의 유형에 따라 해석됩니다.\n    C. int *p[4], p는 int 포인터의 배열입니다.\n    D. 함수 이름은 함수 포인터에 할당될 수 있습니다.\n\n당신은 질문의 선택지를 나타내는 \"AAAAA\"와 유사한 문자열만 반환해야 합니다.", "ml": "ഒരു ചോദ്യത്തിന് A, B, C, അല്ലെങ്കിൽ D എന്നിങ്ങനെ തിരഞ്ഞെടുക്കലുകൾ നൽകിക്കൊണ്ട് ചോദ്യങ്ങൾക്ക് ഉത്തരം നൽകുക.\n\nചോദ്യം 1:\n1e6 പോലുള്ള സ്ഥിരാങ്കങ്ങൾ ഏത് ഡാറ്റാ തരം ഉൾപ്പെടുന്നു?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nചോദ്യം 2:\n21! = 51,090,942,171,709,440,000 എന്നത് നൽകിയാൽ, ഈ മൂല്യം സംഭരിക്കാൻ ഏത് ഡാറ്റാ തരം ഉപയോഗിക്കാം?\n    A. int\n    B. long long\n    C. double\n    D. മുകളിൽ പറയാത്തവ\n\nചോദ്യം 3:\nവ്യക്തീകരണങ്ങളിലെ ഇടത് മൂല്യങ്ങളെക്കുറിച്ചുള്ള ഏത് പ്രസ്താവന തെറ്റാണ്?\n    A. വേരിയബിൾ നെയിം വ്യക്തീകരണങ്ങൾ ഇടത് മൂല്യങ്ങളാണ്.\n    B. വർദ്ധന ഓപ്പറേഷൻ നടത്താൻ ഓപ്പറാൻഡ് ഒരു ഇടത് മൂല്യം ആയിരിക്കണം.\n    C. പോയിന്റർ ഡീറഫറൻസ് വ്യക്തീകരണങ്ങൾ ഇടത് മൂല്യങ്ങളാണ്.\n    D. പ്രിഫിക്സ് വർദ്ധന ഓപ്പറേഷൻ വ്യക്തീകരണങ്ങൾ ഇടത് മൂല്യങ്ങളാണ്.\n\nചോദ്യം 4:\nഫംഗ്ഷനുകളെക്കുറിച്ചുള്ള ഏത് പ്രസ്താവന തെറ്റാണ്?\n    A. ഒരു ഫംഗ്ഷന്റെ ഔപചാരിക പാരാമീറ്ററുകൾ പ്രാദേശിക വേരിയബിൾസ് ആണ്.\n    B. പ്രാദേശിക വേരിയബിൾസ് സ്റ്റാക്കിൽ സ്ഥലം അനുവദിക്കുന്നു.\n    C. ഫംഗ്ഷൻ തരം മടക്ക മൂല്യ തരം പോലെയാണ്.\n    D. ഒരു ഫംഗ്ഷൻ അതിന്റെ ശരീരത്തിൽ നിന്ന് തന്നെ വിളിക്കാം.\n\nചോദ്യം 5:\nപോയിന്ററുകളെക്കുറിച്ചുള്ള ഏത് പ്രസ്താവന തെറ്റാണ്?\n    A. രണ്ട് പോയിന്ററുകൾ കുറയ്ക്കുന്നത് അവരുടെ വിലാസ മൂല്യങ്ങളിലെ വ്യത്യാസം ആണ്.\n    B. പോയിന്റർ ഡീറഫറൻസ്, പോയിന്ററിന്റെ തരം അടിസ്ഥാനമാക്കി പരിഹരിക്കുന്നു.\n    C. int *p[4], p ഒരു int പോയിന്ററുകളുടെ നിരയാണ്.\n    D. ഫംഗ്ഷൻ നാമങ്ങൾ ഫംഗ്ഷൻ പോയിന്ററുകൾക്ക് നിയോഗിക്കാം.\n\nനിങ്ങൾ \"AAAAA\" പോലുള്ള സ്ട്രിംഗുകൾ മാത്രം മടക്കേണ്ടതാണ്, ഇത് ചോദ്യത്തിന്റെ തിരഞ്ഞെടുക്കലുകൾക്കായി നിൽക്കുന്നു.", "fa": "پاسخ به یک سری سوال با ارائه گزینه‌های A، B، C یا D برای هر سوال.\n\nسوال 1:\nثابت‌هایی مانند 1e6 به کدام نوع داده تعلق دارند؟\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nسوال 2:\nبا توجه به 21! = 51,090,942,171,709,440,000، از کدام نوع داده می‌توان برای ذخیره این مقدار استفاده کرد؟\n    A. int\n    B. long long\n    C. double\n    D. هیچ‌کدام از موارد فوق\n\nسوال 3:\nکدام عبارت درباره مقادیر چپ در عبارات نادرست است؟\n    A. عبارات نام متغیر مقادیر چپ هستند.\n    B. عملیات افزایش نیاز دارد که عملوند یک مقدار چپ باشد.\n    C. عبارات اشاره‌گر به مقدار مقادیر چپ هستند.\n    D. عبارات عملیات افزایش پیشوندی مقادیر چپ هستند.\n\nسوال 4:\nکدام عبارت درباره توابع نادرست است؟\n    A. پارامترهای رسمی یک تابع متغیرهای محلی هستند.\n    B. متغیرهای محلی در پشته فضا تخصیص می‌دهند.\n    C. نوع تابع همان نوع مقدار بازگشتی است.\n    D. یک تابع می‌تواند خود را از درون بدنه‌اش فراخوانی کند.\n\nسوال 5:\nکدام عبارت درباره اشاره‌گرها نادرست است؟\n    A. تفریق دو اشاره‌گر برابر با تفاوت در مقادیر آدرس آن‌ها است.\n    B. اشاره‌گر به مقدار شامل حل بر اساس نوع اشاره‌گر است.\n    C. int *p[4]، p یک آرایه از اشاره‌گرهای int است.\n    D. نام‌های تابع می‌توانند به اشاره‌گرهای تابع اختصاص داده شوند.\n\nشما باید فقط رشته‌هایی مشابه \"AAAAA\" را که نشان‌دهنده انتخاب‌های سوال هستند، بازگردانید."}}
{"task_id": "CPP/21", "prompt": {"en": "#include <cassert>\n#include <cmath>\n#include <vector>\n/**\n * Determines if it is possible to assemble the wooden squares from n buckets\n * into a single larger square, where each bucket contains squares with a side length of 1.\n * \n * Input: vector of numbers\n * Example:\n *    >>> f_21({9})\n *    true\n * \n * @param squares Vector containing the count of squares in each bucket.\n * @return True if it is possible to form a larger square, False otherwise.\n */\nbool f_21(std::vector<int> squares)", "sq": "#include <cassert>\n#include <cmath>\n#include <vector>\n/**\n * Përcakton nëse është e mundur të montohen katrorët prej druri nga n kovë\n * në një katror më të madh, ku secila kovë përmban katrorë me një gjatësi anësore prej 1.\n * \n * Hyrja: vektor numrash\n * Shembull:\n *    >>> f_21({9})\n *    true\n * \n * @param squares Vektor që përmban numrin e katrorëve në secilën kovë.\n * @return True nëse është e mundur të formohet një katror më i madh, False përndryshe.\n */\nbool f_21(std::vector<int> squares)", "hy": "#include <cassert>\n#include <cmath>\n#include <vector>\n/**\n * Որոշում է՝ արդյոք հնարավոր է հավաքել փայտե քառակուսիները n դույլերից\n * մեկ մեծ քառակուսի մեջ, որտեղ յուրաքանչյուր դույլ պարունակում է 1 կողմի երկարությամբ քառակուսիներ:\n * \n * Մուտք: թվերի վեկտոր\n * Օրինակ:\n *    >>> f_21({9})\n *    true\n * \n * @param squares Վեկտոր, որը պարունակում է յուրաքանչյուր դույլում քառակուսիների քանակը:\n * @return Ճիշտ է, եթե հնարավոր է կազմել մեծ քառակուսի, Հակառակ դեպքում՝ Սխալ:\n */\nbool f_21(std::vector<int> squares)", "bn": "#include <cassert>\n#include <cmath>\n#include <vector>\n/**\n * নির্ধারণ করে যে n বালতি থেকে কাঠের বর্গক্ষেত্রগুলি একত্রিত করে একটি বড় বর্গক্ষেত্র তৈরি করা সম্ভব কিনা,\n * যেখানে প্রতিটি বালতিতে 1 পার্শ্ব দৈর্ঘ্যের বর্গক্ষেত্র রয়েছে।\n * \n * ইনপুট: সংখ্যার ভেক্টর\n * উদাহরণ:\n *    >>> f_21({9})\n *    true\n * \n * @param squares প্রতিটি বালতিতে থাকা বর্গক্ষেত্রের সংখ্যা ধারণকারী ভেক্টর।\n * @return যদি একটি বড় বর্গক্ষেত্র তৈরি করা সম্ভব হয় তবে True, অন্যথায় False।\n */\nbool f_21(std::vector<int> squares)", "bg": "#include <cassert>\n#include <cmath>\n#include <vector>\n/**\n * Определя дали е възможно да се сглобят дървените квадрати от n кофи\n * в един по-голям квадрат, където всяка кофа съдържа квадрати със страна 1.\n * \n * Вход: вектор от числа\n * Пример:\n *    >>> f_21({9})\n *    true\n * \n * @param squares Вектор, съдържащ броя на квадратите във всяка кофа.\n * @return True ако е възможно да се формира по-голям квадрат, False в противен случай.\n */\nbool f_21(std::vector<int> squares)", "zh": "#include <cassert>\n#include <cmath>\n#include <vector>\n/**\n * 确定是否可以将 n 个桶中的木块组装成一个更大的正方形，其中每个桶包含边长为 1 的正方形。\n * \n * 输入: 数字向量\n * 示例:\n *    >>> f_21({9})\n *    true\n * \n * @param squares 向量，包含每个桶中正方形的数量。\n * @return 如果可以形成更大的正方形则返回 True，否则返回 False。\n */\nbool f_21(std::vector<int> squares)", "fr": "#include <cassert>\n#include <cmath>\n#include <vector>\n/**\n * Détermine s'il est possible d'assembler les carrés en bois à partir de n seaux\n * en un seul carré plus grand, où chaque seau contient des carrés avec une longueur de côté de 1.\n * \n * Entrée : vecteur de nombres\n * Exemple :\n *    >>> f_21({9})\n *    true\n * \n * @param squares Vecteur contenant le nombre de carrés dans chaque seau.\n * @return True s'il est possible de former un carré plus grand, False sinon.\n */\nbool f_21(std::vector<int> squares)", "de": "#include <cassert>\n#include <cmath>\n#include <vector>\n/**\n * Bestimmt, ob es möglich ist, die Holzquadrate aus n Eimern zu einem einzigen größeren Quadrat zusammenzusetzen,\n * wobei jeder Eimer Quadrate mit einer Seitenlänge von 1 enthält.\n * \n * Eingabe: Vektor von Zahlen\n * Beispiel:\n *    >>> f_21({9})\n *    true\n * \n * @param squares Vektor, der die Anzahl der Quadrate in jedem Eimer enthält.\n * @return True, wenn es möglich ist, ein größeres Quadrat zu bilden, False andernfalls.\n */\nbool f_21(std::vector<int> squares)", "ha": "#include <cassert>\n#include <cmath>\n#include <vector>\n/**\n * Yana tantancewa idan yana yiwuwa a tara murabba'ai na katako daga guga n\n * zuwa murabba'i guda mafi girma, inda kowanne guga ya ƙunshi murabba'ai da ke da tsawon gefe 1.\n * \n * Shigarwa: vector na lambobi\n * Misali:\n *    >>> f_21({9})\n *    true\n * \n * @param squares Vector da ke ƙunshe da adadin murabba'ai a kowanne guga.\n * @return True idan yana yiwuwa a samar da murabba'i mafi girma, False in ba haka ba.\n */\nbool f_21(std::vector<int> squares)", "hi": "#include <cassert>\n#include <cmath>\n#include <vector>\n/**\n * यह निर्धारित करता है कि क्या n बाल्टियों से लकड़ी के वर्गों को एक बड़े वर्ग में इकट्ठा करना संभव है,\n * जहाँ प्रत्येक बाल्टी में 1 की भुजा लंबाई वाले वर्ग होते हैं।\n * \n * इनपुट: संख्याओं का वेक्टर\n * उदाहरण:\n *    >>> f_21({9})\n *    true\n * \n * @param squares प्रत्येक बाल्टी में वर्गों की गिनती वाला वेक्टर।\n * @return True यदि एक बड़ा वर्ग बनाना संभव है, अन्यथा False।\n */\nbool f_21(std::vector<int> squares)", "hu": "#include <cassert>\n#include <cmath>\n#include <vector>\n/**\n * Meghatározza, hogy lehetséges-e a fából készült négyzeteket n vödörből\n * egyetlen nagyobb négyzetté összeállítani, ahol minden vödör 1 oldalhosszúságú négyzeteket tartalmaz.\n * \n * Bemenet: számokat tartalmazó vektor\n * Példa:\n *    >>> f_21({9})\n *    true\n * \n * @param squares Vektor, amely minden vödörben található négyzetek számát tartalmazza.\n * @return Igaz, ha lehetséges egy nagyobb négyzetet kialakítani, Hamis egyébként.\n */\nbool f_21(std::vector<int> squares)", "es": "#include <cassert>\n#include <cmath>\n#include <vector>\n/**\n * Determina si es posible ensamblar los cuadrados de madera de n cubetas\n * en un cuadrado más grande, donde cada cubeta contiene cuadrados con un lado de longitud 1.\n * \n * Entrada: vector de números\n * Ejemplo:\n *    >>> f_21({9})\n *    true\n * \n * @param squares Vector que contiene la cantidad de cuadrados en cada cubeta.\n * @return True si es posible formar un cuadrado más grande, False en caso contrario.\n */\nbool f_21(std::vector<int> squares)", "arb": "#include <cassert>\n#include <cmath>\n#include <vector>\n/**\n * يحدد ما إذا كان من الممكن تجميع المربعات الخشبية من n دلاء\n * في مربع أكبر واحد، حيث يحتوي كل دلو على مربعات بطول ضلع 1.\n * \n * المدخل: متجه من الأرقام\n * مثال:\n *    >>> f_21({9})\n *    true\n * \n * @param squares متجه يحتوي على عدد المربعات في كل دلو.\n * @return صحيح إذا كان من الممكن تشكيل مربع أكبر، خطأ خلاف ذلك.\n */\nbool f_21(std::vector<int> squares)", "sw": "#include <cassert>\n#include <cmath>\n#include <vector>\n/**\n * Huamua ikiwa inawezekana kuunganisha miraba ya mbao kutoka kwenye n ndoo\n * kuwa mraba mmoja mkubwa, ambapo kila ndoo ina miraba yenye urefu wa upande wa 1.\n * \n * Ingizo: vector ya namba\n * Mfano:\n *    >>> f_21({9})\n *    true\n * \n * @param squares Vector inayoshikilia idadi ya miraba katika kila ndoo.\n * @return True ikiwa inawezekana kuunda mraba mkubwa, False vinginevyo.\n */\nbool f_21(std::vector<int> squares)", "tr": "#include <cassert>\n#include <cmath>\n#include <vector>\n/**\n * n kovadan ahşap kareleri, her kovada kenar uzunluğu 1 olan kareler bulunan tek bir büyük kareye monte etmenin mümkün olup olmadığını belirler.\n * \n * Girdi: sayıların vektörü\n * Örnek:\n *    >>> f_21({9})\n *    true\n * \n * @param squares Her kovadaki karelerin sayısını içeren vektör.\n * @return Daha büyük bir kare oluşturmak mümkünse True, aksi takdirde False döner.\n */\nbool f_21(std::vector<int> squares)", "vi": "#include <cassert>\n#include <cmath>\n#include <vector>\n/**\n * Xác định xem có thể lắp ráp các hình vuông gỗ từ n xô\n * thành một hình vuông lớn hơn duy nhất hay không, trong đó mỗi xô chứa các hình vuông có độ dài cạnh là 1.\n * \n * Đầu vào: vector các số\n * Ví dụ:\n *    >>> f_21({9})\n *    true\n * \n * @param squares Vector chứa số lượng hình vuông trong mỗi xô.\n * @return True nếu có thể tạo thành một hình vuông lớn hơn, False nếu không thể.\n */\nbool f_21(std::vector<int> squares)", "id": "#include <cassert>\n#include <cmath>\n#include <vector>\n/**\n * Menentukan apakah mungkin untuk merakit kotak kayu dari n ember\n * menjadi satu kotak yang lebih besar, di mana setiap ember berisi kotak dengan panjang sisi 1.\n * \n * Input: vektor angka\n * Contoh:\n *    >>> f_21({9})\n *    true\n * \n * @param squares Vektor yang berisi jumlah kotak di setiap ember.\n * @return True jika mungkin untuk membentuk kotak yang lebih besar, False jika tidak.\n */\nbool f_21(std::vector<int> squares)", "ja": "#include <cassert>\n#include <cmath>\n#include <vector>\n/**\n * n個のバケツから木製の正方形を1つの大きな正方形に組み立てることが可能かどうかを判断します。\n * 各バケツには1辺の長さが1の正方形が含まれています。\n * \n * 入力: 数字のベクトル\n * 例:\n *    >>> f_21({9})\n *    true\n * \n * @param squares 各バケツに含まれる正方形の数を含むベクトル。\n * @return 大きな正方形を形成することが可能であればTrue、そうでなければFalse。\n */\nbool f_21(std::vector<int> squares)", "ko": "#include <cassert>\n#include <cmath>\n#include <vector>\n/**\n * n개의 버킷에서 나무 정사각형을 하나의 더 큰 정사각형으로 조립할 수 있는지 여부를 결정합니다.\n * 각 버킷에는 한 변의 길이가 1인 정사각형이 들어 있습니다.\n * \n * 입력: 숫자의 벡터\n * 예:\n *    >>> f_21({9})\n *    true\n * \n * @param squares 각 버킷에 있는 정사각형의 개수를 포함하는 벡터입니다.\n * @return 더 큰 정사각형을 형성할 수 있으면 True, 그렇지 않으면 False를 반환합니다.\n */\nbool f_21(std::vector<int> squares)", "ml": "#include <cassert>\n#include <cmath>\n#include <vector>\n/**\n * n ബക്കറ്റുകളിൽ നിന്ന് മരം ചതുരങ്ങൾ ഒരു വലിയ ചതുരത്തിൽ ചേർക്കാൻ കഴിയുമോ എന്ന് നിർണയിക്കുന്നു,\n * ഓരോ ബക്കറ്റിലും 1 വശം നീളമുള്ള ചതുരങ്ങൾ അടങ്ങിയിരിക്കുന്നു.\n * \n * ഇൻപുട്ട്: നംബറുകളുടെ വെക്റ്റർ\n * ഉദാഹരണം:\n *    >>> f_21({9})\n *    true\n * \n * @param squares ഓരോ ബക്കറ്റിലും ഉള്ള ചതുരങ്ങളുടെ എണ്ണമുള്ള വെക്റ്റർ.\n * @return വലിയൊരു ചതുരം രൂപീകരിക്കാൻ കഴിയുമെങ്കിൽ True, അല്ലെങ്കിൽ False.\n */\nbool f_21(std::vector<int> squares)", "fa": "#include <cassert>\n#include <cmath>\n#include <vector>\n/**\n * تعیین می‌کند که آیا ممکن است مربع‌های چوبی را از n سطل به یک مربع بزرگ‌تر مونتاژ کرد،\n * جایی که هر سطل شامل مربع‌هایی با طول ضلع 1 است.\n * \n * ورودی: بردار اعداد\n * مثال:\n *    >>> f_21({9})\n *    true\n * \n * @param squares برداری که تعداد مربع‌ها در هر سطل را شامل می‌شود.\n * @return True اگر امکان تشکیل یک مربع بزرگ‌تر وجود دارد، False در غیر این صورت.\n */\nbool f_21(std::vector<int> squares)"}, "canonical_solution": "{\n    long long sum = 0;\n    for (int square : squares) {\n        sum += square; // Sum the squares\n    }\n    int root = static_cast<int>(std::sqrt(sum));\n    return root * root == sum; // Check if the sum is a perfect square\n}", "instruction": {"en": "bool f_21(std::vector<int> squares)\n{\n    long long sum = 0;\n    for (int square : squares) {\n        sum += square; // Sum the squares\n    }\n    int root = static_cast<int>(std::sqrt(sum));\n    return root * root == sum; // Check if the sum is a perfect square\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.", "sq": "bool f_21(std::vector<int> squares)\n{\n    long long sum = 0;\n    for (int square : squares) {\n        sum += square; // Sum the squares\n    }\n    int root = static_cast<int>(std::sqrt(sum));\n    return root * root == sum; // Check if the sum is a perfect square\n}\n\nJepni një përshkrim të shkurtër në gjuhën natyrore (docstring) të kodit CPP në shqip duke përdorur maksimumi 500 karaktere.", "hy": "bool f_21(std::vector<int> squares)\n{\n    long long sum = 0;\n    for (int square : squares) {\n        sum += square; // Sum the squares\n    }\n    int root = static_cast<int>(std::sqrt(sum));\n    return root * root == sum; // Check if the sum is a perfect square\n}\n\nՏրամադրել հակիրճ բնական լեզվով նկարագրություն (docstring) այս CPP կոդի համար՝ օգտագործելով առավելագույնը 500 նիշ։", "bn": "bool f_21(std::vector<int> squares)\n{\n    long long sum = 0;\n    for (int square : squares) {\n        sum += square; // Sum the squares\n    }\n    int root = static_cast<int>(std::sqrt(sum));\n    return root * root == sum; // Check if the sum is a perfect square\n}\n\nসিপিপি কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলা ভাষায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হতে হবে।", "bg": "bool f_21(std::vector<int> squares)\n{\n    long long sum = 0;\n    for (int square : squares) {\n        sum += square; // Sum the squares\n    }\n    int root = static_cast<int>(std::sqrt(sum));\n    return root * root == sum; // Check if the sum is a perfect square\n}\n\nПредоставете кратко описание на CPP кода на естествен език (docstring) на български, използвайки най-много 500 знака.", "zh": "bool f_21(std::vector<int> squares)\n{\n    long long sum = 0;\n    for (int square : squares) {\n        sum += square; // Sum the squares\n    }\n    int root = static_cast<int>(std::sqrt(sum));\n    return root * root == sum; // Check if the sum is a perfect square\n}\n\n请用不超过500个字符的中文，为以下CPP代码提供简洁的自然语言描述（文档字符串）。", "fr": "bool f_21(std::vector<int> squares)\n{\n    long long sum = 0;\n    for (int square : squares) {\n        sum += square; // Sum the squares\n    }\n    int root = static_cast<int>(std::sqrt(sum));\n    return root * root == sum; // Check if the sum is a perfect square\n}\n\nFournissez une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.", "de": "bool f_21(std::vector<int> squares)\n{\n    long long sum = 0;\n    for (int square : squares) {\n        sum += square; // Sum the squares\n    }\n    int root = static_cast<int>(std::sqrt(sum));\n    return root * root == sum; // Check if the sum is a perfect square\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "bool f_21(std::vector<int> squares)\n{\n    long long sum = 0;\n    for (int square : squares) {\n        sum += square; // Sum the squares\n    }\n    int root = static_cast<int>(std::sqrt(sum));\n    return root * root == sum; // Check if the sum is a perfect square\n}\n\nBa da taƙaitaccen bayanin harshen halitta (docstring) na lambar CPP a cikin Hausa ta amfani da haruffa 500 ko ƙasa da haka.", "hi": "bool f_21(std::vector<int> squares)\n{\n    long long sum = 0;\n    for (int square : squares) {\n        sum += square; // Sum the squares\n    }\n    int root = static_cast<int>(std::sqrt(sum));\n    return root * root == sum; // Check if the sum is a perfect square\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "bool f_21(std::vector<int> squares)\n{\n    long long sum = 0;\n    for (int square : squares) {\n        sum += square; // Sum the squares\n    }\n    int root = static_cast<int>(std::sqrt(sum));\n    return root * root == sum; // Check if the sum is a perfect square\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a CPP kódról magyarul, legfeljebb 500 karakterben.", "es": "bool f_21(std::vector<int> squares)\n{\n    long long sum = 0;\n    for (int square : squares) {\n        sum += square; // Sum the squares\n    }\n    int root = static_cast<int>(std::sqrt(sum));\n    return root * root == sum; // Check if the sum is a perfect square\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando como máximo 500 caracteres.", "arb": "bool f_21(std::vector<int> squares)\n{\n    long long sum = 0;\n    for (int square : squares) {\n        sum += square; // Sum the squares\n    }\n    int root = static_cast<int>(std::sqrt(sum));\n    return root * root == sum; // Check if the sum is a perfect square\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C++ باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "bool f_21(std::vector<int> squares)\n{\n    long long sum = 0;\n    for (int square : squares) {\n        sum += square; // Sum the squares\n    }\n    int root = static_cast<int>(std::sqrt(sum));\n    return root * root == sum; // Check if the sum is a perfect square\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "bool f_21(std::vector<int> squares)\n{\n    long long sum = 0;\n    for (int square : squares) {\n        sum += square; // Sum the squares\n    }\n    int root = static_cast<int>(std::sqrt(sum));\n    return root * root == sum; // Check if the sum is a perfect square\n}\n\nAşağıdaki CPP kodunun Türkçe'de en fazla 500 karakter kullanarak özlü bir doğal dil açıklamasını (docstring) sağlayın.", "vi": "bool f_21(std::vector<int> squares)\n{\n    long long sum = 0;\n    for (int square : squares) {\n        sum += square; // Sum the squares\n    }\n    int root = static_cast<int>(std::sqrt(sum));\n    return root * root == sum; // Check if the sum is a perfect square\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự.", "id": "bool f_21(std::vector<int> squares)\n{\n    long long sum = 0;\n    for (int square : squares) {\n        sum += square; // Sum the squares\n    }\n    int root = static_cast<int>(std::sqrt(sum));\n    return root * root == sum; // Check if the sum is a perfect square\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode CPP dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "bool f_21(std::vector<int> squares)\n{\n    long long sum = 0;\n    for (int square : squares) {\n        sum += square; // Sum the squares\n    }\n    int root = static_cast<int>(std::sqrt(sum));\n    return root * root == sum; // Check if the sum is a perfect square\n}\n\n以下のCPPコードの自然言語による簡潔な説明（ドックストリング）を日本語で500文字以内で提供してください。", "ko": "bool f_21(std::vector<int> squares)\n{\n    long long sum = 0;\n    for (int square : squares) {\n        sum += square; // Sum the squares\n    }\n    int root = static_cast<int>(std::sqrt(sum));\n    return root * root == sum; // Check if the sum is a perfect square\n}\n\n다음 CPP 코드에 대한 간결한 자연어 설명(도크스트링)을 한국어로 최대 500자 이내로 제공하세요.", "ml": "bool f_21(std::vector<int> squares)\n{\n    long long sum = 0;\n    for (int square : squares) {\n        sum += square; // Sum the squares\n    }\n    int root = static_cast<int>(std::sqrt(sum));\n    return root * root == sum; // Check if the sum is a perfect square\n}\n\nCPP കോഡ് ഉപയോഗിച്ച് 500 അക്ഷരങ്ങളിൽ കൂടുതൽ അല്ലാത്ത രീതിയിൽ മലയാളത്തിൽ സംക്ഷിപ്തമായ ഒരു സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) നൽകുക.", "fa": "bool f_21(std::vector<int> squares)\n{\n    long long sum = 0;\n    for (int square : squares) {\n        sum += square; // Sum the squares\n    }\n    int root = static_cast<int>(std::sqrt(sum));\n    return root * root == sum; // Check if the sum is a perfect square\n}\n\nتوضیح مختصر و طبیعی (docstring) از کد CPP به زبان فارسی ارائه دهید که حداکثر ۵۰۰ کاراکتر باشد."}, "level": "", "test": "int main() {\n    assert(f_21({9}) == true);\n    assert(f_21({14, 2}) == true);\n    assert(f_21({7, 7}) == false);\n    assert(f_21({1, 2, 3, 4, 5, 6, 7}) == false);\n    assert(f_21({1, 3, 5, 7, 9, 11}) == true);\n    assert(f_21({2, 2, 2, 2}) == false);\n\n    // Additional test cases\n    assert(f_21({4, 5, 6}) == false);\n    assert(f_21({16, 9, 4, 1}) == false);\n    assert(f_21({1, 1, 1, 1, 1}) == false);\n    assert(f_21({25, 25}) == false);\n    assert(f_21({10, 10, 5}) == true);\n\n    // All tests passed\n    return 0;\n}", "entry_point": "f_21", "signature": "bool f_21(std::vector<int> squares)", "docstring": {"en": "Determines if it is possible to assemble the wooden squares from n buckets\ninto a single larger square, where each bucket contains squares with a side length of 1.\n\nInput: vector of numbers\nExample:\n   >>> f_21({9})\n   true\n\n@param squares Vector containing the count of squares in each bucket.\n@return True if it is possible to form a larger square, False otherwise.\n", "sq": "Përcakton nëse është e mundur të montohet një katror i madh prej druri nga n kovë\nnë një katror të vetëm më të madh, ku çdo kovë përmban katrorë me një gjatësi anësore prej 1.\n\nHyrja: vektor numrash\nShembull:\n   >>> f_21({9})\n   true\n\n@param squares Vektor që përmban numrin e katrorëve në secilën kovë.\n@return E vërtetë nëse është e mundur të formohet një katror më i madh, e rreme përndryshe.", "hy": "Վճռում է՝ արդյոք հնարավոր է հավաքել փայտե քառակուսիները n դույլերից մեկ մեծ քառակուսիի մեջ, որտեղ յուրաքանչյուր դույլ պարունակում է կողքի երկարությամբ 1 քառակուսիներ։\n\nՄուտք: թվերի վեկտոր  \nՕրինակ:  \n   >>> f_21({9})  \n   true  \n\n@param squares Վեկտոր, որը պարունակում է յուրաքանչյուր դույլում քառակուսիների քանակը։  \n@return True, եթե հնարավոր է կազմել մեծ քառակուսի, False՝ հակառակ դեպքում։  ", "bn": "বুঝায় যে এটি সম্ভব কিনা n বালতি থেকে কাঠের বর্গক্ষেত্রগুলি একত্রিত করে একটি বড় বর্গক্ষেত্র তৈরি করা, যেখানে প্রতিটি বালতিতে 1 পার্শ্ব দৈর্ঘ্যের বর্গক্ষেত্র রয়েছে।\n\nইনপুট: সংখ্যার ভেক্টর\nউদাহরণ:\n   >>> f_21({9})\n   true\n\n@param squares প্রতিটি বালতিতে বর্গক্ষেত্রের সংখ্যা ধারণকারী ভেক্টর।\n@return যদি একটি বড় বর্গক্ষেত্র তৈরি করা সম্ভব হয় তবে True, অন্যথায় False।", "bg": "Определя дали е възможно да се сглобят дървените квадрати от n кофи в един по-голям квадрат, където всяка кофа съдържа квадрати с дължина на страната 1.\n\nВход: вектор от числа\nПример:\n   >>> f_21({9})\n   true\n\n@param squares Вектор, съдържащ броя на квадратите във всяка кофа.\n@return True, ако е възможно да се образува по-голям квадрат, False в противен случай.", "zh": "确定是否可以将 n 个桶中的木方块组装成一个更大的正方形，其中每个桶包含边长为 1 的正方形。\n\n输入：数字向量\n示例：\n   >>> f_21({9})\n   true\n\n@param squares 向量，包含每个桶中正方形的数量。\n@return 如果可以形成一个更大的正方形，则返回 True，否则返回 False。", "fr": "Détermine s'il est possible d'assembler les carrés en bois de n seaux en un seul carré plus grand, où chaque seau contient des carrés avec une longueur de côté de 1.\n\nEntrée : vecteur de nombres\nExemple :\n   >>> f_21({9})\n   true\n\n@param squares Vecteur contenant le nombre de carrés dans chaque seau.\n@return True s'il est possible de former un carré plus grand, False sinon.", "de": "Bestimmt, ob es möglich ist, die Holzquadrate aus n Eimern zu einem einzigen größeren Quadrat zusammenzusetzen, wobei jeder Eimer Quadrate mit einer Seitenlänge von 1 enthält.\n\nEingabe: Vektor von Zahlen\nBeispiel:\n   >>> f_21({9})\n   true\n\n@param squares Vektor, der die Anzahl der Quadrate in jedem Eimer enthält.\n@return True, wenn es möglich ist, ein größeres Quadrat zu bilden, False andernfalls.", "ha": "Yana tantance ko zai yiwu a tara murabba'ai na katako daga guga n cikin guga guda ɗaya mafi girma, inda kowanne guga yana ɗauke da murabba'ai tare da tsawon gefe na 1.\n\nShigarwa: vector na lambobi\nMisali:\n   >>> f_21({9})\n   true\n\n@param squares Vector mai ɗauke da adadin murabba'ai a kowane guga.\n@return Gaskiya idan zai yiwu a samar da murabba'i mafi girma, Karya in ba haka ba.", "hi": "यह निर्धारित करता है कि क्या n बाल्टियों से लकड़ी के वर्गों को एक बड़े वर्ग में इकट्ठा करना संभव है, जहाँ प्रत्येक बाल्टी में 1 की भुजा लंबाई वाले वर्ग होते हैं।\n\nइनपुट: संख्याओं का वेक्टर  \nउदाहरण:  \n   >>> f_21({9})  \n   true\n\n@param squares प्रत्येक बाल्टी में वर्गों की संख्या वाला वेक्टर।  \n@return यदि एक बड़ा वर्ग बनाना संभव है तो True, अन्यथा False।", "hu": "Meghatározza, hogy lehetséges-e a fa négyzeteket n vödörből egyetlen nagyobb négyzetté összeállítani, ahol minden vödör 1 oldalhosszúságú négyzeteket tartalmaz.\n\nBemenet: számok vektora\nPélda:\n   >>> f_21({9})\n   true\n\n@param squares Vektor, amely az egyes vödrökben lévő négyzetek számát tartalmazza.\n@return Igaz, ha lehetséges egy nagyobb négyzetet kialakítani, különben Hamis.", "es": "Determina si es posible ensamblar los cuadrados de madera de n cubetas en un solo cuadrado más grande, donde cada cubeta contiene cuadrados con un lado de longitud 1.\n\nEntrada: vector de números\nEjemplo:\n   >>> f_21({9})\n   true\n\n@param squares Vector que contiene la cantidad de cuadrados en cada cubeta.\n@return True si es posible formar un cuadrado más grande, False en caso contrario.", "arb": "يحدد ما إذا كان من الممكن تجميع المربعات الخشبية من n دلاء في مربع أكبر واحد، حيث يحتوي كل دلو على مربعات بطول ضلع 1.\n\nالمدخلات: متجه من الأرقام\nمثال:\n   >>> f_21({9})\n   true\n\n@param squares متجه يحتوي على عدد المربعات في كل دلو.\n@return صحيح إذا كان من الممكن تشكيل مربع أكبر، خطأ خلاف ذلك.", "sw": "Inabainisha kama inawezekana kuunganisha miraba ya mbao kutoka kwenye ndoo n kuwa mraba mmoja mkubwa zaidi, ambapo kila ndoo ina miraba yenye urefu wa upande wa 1.\n\nIngizo: vector ya namba\nMfano:\n   >>> f_21({9})\n   true\n\n@param squares Vector inayojumuisha idadi ya miraba katika kila ndoo.\n@return Kweli ikiwa inawezekana kuunda mraba mkubwa zaidi, Si kweli vinginevyo.", "tr": "Ahşap kareleri n kovasından tek bir büyük kareye monte etmenin mümkün olup olmadığını belirler, burada her kova kenar uzunluğu 1 olan kareler içerir.\n\nGirdi: sayıların vektörü\nÖrnek:\n   >>> f_21({9})\n   true\n\n@param squares Her kovadaki karelerin sayısını içeren vektör.\n@return Daha büyük bir kare oluşturmak mümkünse True, aksi takdirde False.", "vi": "Xác định xem có thể lắp ráp các hình vuông gỗ từ n thùng thành một hình vuông lớn hơn hay không, trong đó mỗi thùng chứa các hình vuông có độ dài cạnh là 1.\n\nĐầu vào: vector của các số\nVí dụ:\n   >>> f_21({9})\n   true\n\n@param squares Vector chứa số lượng hình vuông trong mỗi thùng.\n@return True nếu có thể tạo thành một hình vuông lớn hơn, False nếu không.", "id": "Menentukan apakah mungkin untuk merakit kotak kayu dari n ember menjadi satu kotak yang lebih besar, di mana setiap ember berisi kotak dengan panjang sisi 1.\n\nInput: vektor angka\nContoh:\n   >>> f_21({9})\n   true\n\n@param squares Vektor yang berisi jumlah kotak di setiap ember.\n@return True jika mungkin untuk membentuk kotak yang lebih besar, False jika tidak.", "ja": "木製の正方形をn個のバケツから1つの大きな正方形に組み立てることが可能かどうかを判断します。各バケツには、辺の長さが1の正方形が含まれています。\n\n入力: 数字のベクトル\n例:\n   >>> f_21({9})\n   true\n\n@param squares 各バケツに含まれる正方形の数を含むベクトル。\n@return 大きな正方形を形成することが可能であればTrue、そうでなければFalseを返します。", "ko": "n개의 버킷에서 나무 정사각형을 하나의 더 큰 정사각형으로 조립할 수 있는지 여부를 결정합니다.\n * 각 버킷에는 한 변의 길이가 1인 정사각형이 들어 있습니다.\n\n입력: 숫자의 벡터\n예제:\n   >>> f_21({9})\n   true\n\n@param squares 각 버킷에 있는 정사각형의 개수를 포함하는 벡터.\n@return 더 큰 정사각형을 형성할 수 있으면 True, 그렇지 않으면 False.", "ml": "n ബക്കറ്റുകളിൽ നിന്ന് മരം ചതുരങ്ങൾ ഒരു വലിയ ചതുരത്തിൽ ചേർക്കാൻ കഴിയുമോ എന്ന് നിർണയിക്കുന്നു,\n * ഓരോ ബക്കറ്റിലും 1 വശം നീളമുള്ള ചതുരങ്ങൾ അടങ്ങിയിരിക്കുന്നു.\n\nവിവരണം: സംഖ്യകളുടെ ഒരു വെക്ടർ\nഉദാഹരണം:\n   >>> f_21({9})\n   true\n\n@param squares ഓരോ ബക്കറ്റിലും ചതുരങ്ങളുടെ എണ്ണം അടങ്ങിയ വെക്ടർ.\n@return വലിയൊരു ചതുരം രൂപീകരിക്കാൻ കഴിയുമെങ്കിൽ True, അല്ലെങ്കിൽ False.", "fa": "تعیین می‌کند که آیا امکان دارد مربع‌های چوبی را از n سطل به یک مربع بزرگ‌تر مونتاژ کرد، جایی که هر سطل حاوی مربع‌هایی با طول ضلع 1 است.\n\nورودی: بردار اعداد\nمثال:\n   >>> f_21({9})\n   true\n\n@param squares برداری که تعداد مربع‌ها در هر سطل را شامل می‌شود.\n@return True اگر امکان تشکیل یک مربع بزرگ‌تر وجود داشته باشد، False در غیر این صورت."}}
{"task_id": "CPP/22", "prompt": {"en": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Given integers c and d, where a + b = c and a * b = d, this function\n * finds the possible value of a with the condition a <= b. When multiple \n * pairs (a, b) are possible, it returns the pair with the smallest a.\n * If no valid pair exists, it returns -1.\n *\n * Parameters:\n *  - c (int): The sum of a and b.\n *  - d (int): The product of a and b.\n *\n * Returns:\n *  - int: A possible value of a or -1 if no valid values exist.\n *\n * Examples:\n *  f_22(7, 11) returns -1\n *  f_22(5, 6) returns 2\n */\nint f_22(int c, int d)", "sq": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Duke pasur parasysh numrat e plotë c dhe d, ku a + b = c dhe a * b = d, kjo funksion\n * gjen vlerën e mundshme të a me kushtin a <= b. Kur janë të mundshme disa \n * çifte (a, b), kthen çiftin me a më të vogël.\n * Nëse nuk ekziston asnjë çift i vlefshëm, kthen -1.\n *\n * Parametrat:\n *  - c (int): Shuma e a dhe b.\n *  - d (int): Produkti i a dhe b.\n *\n * Kthen:\n *  - int: Një vlerë e mundshme e a ose -1 nëse nuk ekzistojnë vlera të vlefshme.\n *\n * Shembuj:\n *  f_22(7, 11) kthen -1\n *  f_22(5, 6) kthen 2\n */\nint f_22(int c, int d)", "hy": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Տրված են ամբողջ թվեր c և d, որտեղ a + b = c և a * b = d, այս ֆունկցիան\n * գտնում է a-ի հնարավոր արժեքը պայմանով, որ a <= b։ Երբ հնարավոր են բազմաթիվ \n * զույգեր (a, b), այն վերադարձնում է զույգը ամենափոքր a-ով։\n * Եթե ոչ մի վավեր զույգ չի գոյություն ունենում, այն վերադարձնում է -1։\n *\n * Պարամետրեր:\n *  - c (int): a և b-ի գումարը։\n *  - d (int): a և b-ի արտադրյալը։\n *\n * Վերադարձնում է:\n *  - int: a-ի հնարավոր արժեք կամ -1, եթե վավեր արժեքներ չկան։\n *\n * Օրինակներ:\n *  f_22(7, 11) վերադարձնում է -1\n *  f_22(5, 6) վերադարձնում է 2\n */\nint f_22(int c, int d)", "bn": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * প্রদত্ত পূর্ণসংখ্যা c এবং d, যেখানে a + b = c এবং a * b = d, এই ফাংশনটি\n * a এর সম্ভাব্য মান খুঁজে বের করে শর্ত সাপেক্ষে a <= b। যখন একাধিক \n * জোড়া (a, b) সম্ভব, এটি সেই জোড়াটি ফেরত দেয় যেখানে a সবচেয়ে ছোট।\n * যদি কোন বৈধ জোড়া না থাকে, এটি -1 ফেরত দেয়।\n *\n * প্যারামিটার:\n *  - c (int): a এবং b এর যোগফল।\n *  - d (int): a এবং b এর গুণফল।\n *\n * রিটার্নস:\n *  - int: a এর সম্ভাব্য মান অথবা যদি কোন বৈধ মান না থাকে তবে -1।\n *\n * উদাহরণ:\n *  f_22(7, 11) returns -1\n *  f_22(5, 6) returns 2\n */\nint f_22(int c, int d)", "bg": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Дадени са цели числа c и d, където a + b = c и a * b = d, тази функция\n * намира възможната стойност на a с условието a <= b. Когато са възможни \n * множество двойки (a, b), тя връща двойката с най-малко a.\n * Ако не съществува валидна двойка, връща -1.\n *\n * Параметри:\n *  - c (int): Сумата на a и b.\n *  - d (int): Произведението на a и b.\n *\n * Връща:\n *  - int: Възможна стойност на a или -1, ако не съществуват валидни стойности.\n *\n * Примери:\n *  f_22(7, 11) връща -1\n *  f_22(5, 6) връща 2\n */\nint f_22(int c, int d)", "zh": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * 给定整数 c 和 d，其中 a + b = c 且 a * b = d，此函数\n * 找出满足条件 a <= b 的可能值 a。当存在多个\n * (a, b) 对时，返回 a 最小的对。\n * 如果不存在有效对，则返回 -1。\n *\n * 参数:\n *  - c (int): a 和 b 的和。\n *  - d (int): a 和 b 的积。\n *\n * 返回:\n *  - int: a 的可能值，或如果不存在有效值则返回 -1。\n *\n * 示例:\n *  f_22(7, 11) 返回 -1\n *  f_22(5, 6) 返回 2\n */\nint f_22(int c, int d)", "fr": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Étant donné les entiers c et d, où a + b = c et a * b = d, cette fonction\n * trouve la valeur possible de a avec la condition a <= b. Lorsque plusieurs \n * paires (a, b) sont possibles, elle retourne la paire avec le plus petit a.\n * Si aucune paire valide n'existe, elle retourne -1.\n *\n * Paramètres:\n *  - c (int): La somme de a et b.\n *  - d (int): Le produit de a et b.\n *\n * Renvoie:\n *  - int: Une valeur possible de a ou -1 si aucune valeur valide n'existe.\n *\n * Exemples:\n *  f_22(7, 11) returns -1\n *  f_22(5, 6) returns 2\n */\nint f_22(int c, int d)", "de": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Gegeben sind die ganzen Zahlen c und d, wobei a + b = c und a * b = d. Diese Funktion\n * findet den möglichen Wert von a mit der Bedingung a <= b. Wenn mehrere \n * Paare (a, b) möglich sind, gibt sie das Paar mit dem kleinsten a zurück.\n * Wenn kein gültiges Paar existiert, gibt sie -1 zurück.\n *\n * Parameter:\n *  - c (int): Die Summe von a und b.\n *  - d (int): Das Produkt von a und b.\n *\n * Rückgabewerte:\n *  - int: Ein möglicher Wert von a oder -1, wenn keine gültigen Werte existieren.\n *\n * Beispiele:\n *  f_22(7, 11) gibt -1 zurück\n *  f_22(5, 6) gibt 2 zurück\n */\nint f_22(int c, int d)", "ha": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * An ba da lambobin c da d, inda a + b = c kuma a * b = d, wannan aikin\n * yana nemo yuwuwar ƙimar a tare da yanayin a <= b. Idan an samu \n * ma'aurata (a, b) da dama, yana mayar da ma'aurata tare da ƙaramin a.\n * Idan babu ma'aurata masu inganci, yana mayar da -1.\n *\n * Sigogi:\n *  - c (int): Jimillar a da b.\n *  - d (int): Samfurin a da b.\n *\n * Yana Mayarwa:\n *  - int: Yuwuwar ƙimar a ko -1 idan babu ƙimar da ta dace.\n *\n * Misalai:\n *  f_22(7, 11) returns -1\n *  f_22(5, 6) returns 2\n */\nint f_22(int c, int d)", "hi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * दिए गए पूर्णांक c और d, जहाँ a + b = c और a * b = d, यह फ़ंक्शन\n * a के संभावित मान को खोजता है इस शर्त के साथ कि a <= b। जब कई \n * जोड़े (a, b) संभव होते हैं, तो यह सबसे छोटे a वाले जोड़े को लौटाता है।\n * यदि कोई मान्य जोड़ा मौजूद नहीं है, तो यह -1 लौटाता है।\n *\n * पैरामीटर्स:\n *  - c (int): a और b का योग।\n *  - d (int): a और b का गुणनफल।\n *\n * रिटर्न्स:\n *  - int: a का एक संभावित मान या -1 यदि कोई मान्य मान मौजूद नहीं है।\n *\n * उदाहरण:\n *  f_22(7, 11) -1 लौटाता है\n *  f_22(5, 6) 2 लौटाता है\n */\nint f_22(int c, int d)", "hu": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Adott két egész szám, c és d, ahol a + b = c és a * b = d, ez a függvény\n * megkeresi a lehetséges a értékét azzal a feltétellel, hogy a <= b. Ha több \n * (a, b) pár lehetséges, akkor a legkisebb a értékű párt adja vissza.\n * Ha nem létezik érvényes pár, akkor -1-et ad vissza.\n *\n * Paraméterek:\n *  - c (int): Az a és b összege.\n *  - d (int): Az a és b szorzata.\n *\n * Visszatérési érték:\n *  - int: Az a lehetséges értéke vagy -1, ha nem léteznek érvényes értékek.\n *\n * Példák:\n *  f_22(7, 11) visszaadja -1\n *  f_22(5, 6) visszaadja 2\n */\nint f_22(int c, int d)", "es": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Dados los enteros c y d, donde a + b = c y a * b = d, esta función\n * encuentra el valor posible de a con la condición a <= b. Cuando múltiples \n * pares (a, b) son posibles, devuelve el par con el menor a.\n * Si no existe un par válido, devuelve -1.\n *\n * Parámetros:\n *  - c (int): La suma de a y b.\n *  - d (int): El producto de a y b.\n *\n * Devuelve:\n *  - int: Un valor posible de a o -1 si no existen valores válidos.\n *\n * Ejemplos:\n *  f_22(7, 11) returns -1\n *  f_22(5, 6) returns 2\n */\nint f_22(int c, int d)", "arb": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * بالنظر إلى الأعداد الصحيحة c و d، حيث a + b = c و a * b = d، هذه الدالة\n * تجد القيمة الممكنة لـ a بشرط a <= b. عندما تكون هناك أزواج متعددة (a, b) ممكنة، \n * فإنها تعيد الزوج الذي يحتوي على أصغر a.\n * إذا لم يوجد زوج صالح، فإنها تعيد -1.\n *\n * المعاملات:\n *  - c (int): مجموع a و b.\n *  - d (int): حاصل ضرب a و b.\n *\n * تعيد:\n *  - int: قيمة ممكنة لـ a أو -1 إذا لم توجد قيم صالحة.\n *\n * أمثلة:\n *  f_22(7, 11) returns -1\n *  f_22(5, 6) returns 2\n */\nint f_22(int c, int d)", "sw": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Ukipewa nambari nzima c na d, ambapo a + b = c na a * b = d, kazi hii\n * inapata thamani inayowezekana ya a kwa sharti a <= b. Wakati jozi nyingi \n * (a, b) zinawezekana, inarudisha jozi yenye a ndogo zaidi.\n * Ikiwa hakuna jozi halali ipo, inarudisha -1.\n *\n * Vigezo:\n *  - c (int): Jumla ya a na b.\n *  - d (int): Bidhaa ya a na b.\n *\n * Inarudisha:\n *  - int: Thamani inayowezekana ya a au -1 ikiwa hakuna thamani halali ipo.\n *\n * Mifano:\n *  f_22(7, 11) inarudisha -1\n *  f_22(5, 6) inarudisha 2\n */\nint f_22(int c, int d)", "tr": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * a + b = c ve a * b = d olan tamsayılar c ve d verildiğinde, bu fonksiyon\n * a <= b koşuluyla a'nın olası değerini bulur. Birden fazla (a, b) çifti mümkün olduğunda,\n * en küçük a'ya sahip çifti döndürür. Geçerli bir çift yoksa, -1 döndürür.\n *\n * Parametreler:\n *  - c (int): a ve b'nin toplamı.\n *  - d (int): a ve b'nin çarpımı.\n *\n * Döndürür:\n *  - int: a'nın olası bir değeri veya geçerli değer yoksa -1.\n *\n * Örnekler:\n *  f_22(7, 11) -1 döndürür\n *  f_22(5, 6) 2 döndürür\n */\nint f_22(int c, int d)", "vi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Cho các số nguyên c và d, trong đó a + b = c và a * b = d, hàm này\n * tìm giá trị có thể của a với điều kiện a <= b. Khi có nhiều cặp \n * (a, b) có thể, nó trả về cặp với a nhỏ nhất.\n * Nếu không tồn tại cặp hợp lệ nào, nó trả về -1.\n *\n * Tham số:\n *  - c (int): Tổng của a và b.\n *  - d (int): Tích của a và b.\n *\n * Trả về:\n *  - int: Một giá trị có thể của a hoặc -1 nếu không tồn tại giá trị hợp lệ nào.\n *\n * Ví dụ:\n *  f_22(7, 11) trả về -1\n *  f_22(5, 6) trả về 2\n */\nint f_22(int c, int d)", "id": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Diberikan bilangan bulat c dan d, di mana a + b = c dan a * b = d, fungsi ini\n * menemukan nilai a yang mungkin dengan kondisi a <= b. Ketika beberapa \n * pasangan (a, b) mungkin, fungsi ini mengembalikan pasangan dengan a terkecil.\n * Jika tidak ada pasangan yang valid, fungsi ini mengembalikan -1.\n *\n * Parameter:\n *  - c (int): Jumlah dari a dan b.\n *  - d (int): Hasil kali dari a dan b.\n *\n * Mengembalikan:\n *  - int: Nilai a yang mungkin atau -1 jika tidak ada nilai yang valid.\n *\n * Contoh:\n *  f_22(7, 11) mengembalikan -1\n *  f_22(5, 6) mengembalikan 2\n */\nint f_22(int c, int d)", "ja": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * 整数 c と d が与えられたとき、a + b = c かつ a * b = d であるような\n * a の可能な値を見つける関数です。条件として a <= b を満たす必要があります。\n * 複数のペア (a, b) が可能な場合、最小の a を持つペアを返します。\n * 有効なペアが存在しない場合は -1 を返します。\n *\n * パラメータ:\n *  - c (int): a と b の和。\n *  - d (int): a と b の積。\n *\n * 戻り値:\n *  - int: a の可能な値、または有効な値が存在しない場合は -1。\n *\n * 例:\n *  f_22(7, 11) は -1 を返します\n *  f_22(5, 6) は 2 を返します\n */\nint f_22(int c, int d)", "ko": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * 정수 c와 d가 주어졌을 때, 여기서 a + b = c이고 a * b = d인 경우\n * a <= b 조건을 만족하는 a의 가능한 값을 찾습니다. 여러 쌍 (a, b)이\n * 가능한 경우, 가장 작은 a를 가진 쌍을 반환합니다.\n * 유효한 쌍이 없으면 -1을 반환합니다.\n *\n * 매개변수:\n *  - c (int): a와 b의 합.\n *  - d (int): a와 b의 곱.\n *\n * 반환값:\n *  - int: a의 가능한 값 또는 유효한 값이 없을 경우 -1.\n *\n * 예시:\n *  f_22(7, 11) returns -1\n *  f_22(5, 6) returns 2\n */\nint f_22(int c, int d)\n", "ml": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * നൽകിയിരിക്കുന്ന പൂർണ്ണസംഖ്യകൾ c, d എന്നിവയിൽ, a + b = c, a * b = d എന്നിടത്ത് \n * a <= b എന്ന വ്യവസ്ഥയോടെ a യുടെ സാധ്യമായ മൂല്യം കണ്ടെത്തുന്നു. \n * ഒന്നിലധികം (a, b) ജോഡികൾ സാധ്യമാണെങ്കിൽ, ഏറ്റവും ചെറിയ a ഉള്ള ജോഡി തിരികെ നൽകുന്നു.\n * യാതൊരു സാധുവായ ജോഡിയും നിലനിൽക്കാത്ത പക്ഷം, -1 തിരികെ നൽകുന്നു.\n *\n * പാരാമീറ്ററുകൾ:\n *  - c (int): a, b എന്നിവയുടെ ആകെ.\n *  - d (int): a, b എന്നിവയുടെ ഗുണനം.\n *\n * തിരികെ നൽകുന്നു:\n *  - int: a യുടെ ഒരു സാധ്യമായ മൂല്യം അല്ലെങ്കിൽ യാതൊരു സാധുവായ മൂല്യങ്ങളും നിലനിൽക്കാത്ത പക്ഷം -1.\n *\n * ഉദാഹരണങ്ങൾ:\n *  f_22(7, 11) -1 തിരികെ നൽകുന്നു\n *  f_22(5, 6) 2 തിരികെ നൽകുന്നു\n */\nint f_22(int c, int d)", "fa": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * با توجه به اعداد صحیح c و d، که در آن a + b = c و a * b = d، این تابع\n * مقدار ممکن a را با شرط a <= b پیدا می‌کند. زمانی که چندین جفت (a, b) ممکن است،\n * جفتی را با کوچکترین a برمی‌گرداند. اگر هیچ جفت معتبری وجود نداشته باشد، -1 را برمی‌گرداند.\n *\n * پارامترها:\n *  - c (int): مجموع a و b.\n *  - d (int): حاصل‌ضرب a و b.\n *\n * بازگشت:\n *  - int: یک مقدار ممکن از a یا -1 اگر هیچ مقدار معتبری وجود نداشته باشد.\n *\n * مثال‌ها:\n *  f_22(7, 11) returns -1\n *  f_22(5, 6) returns 2\n */\nint f_22(int c, int d)\n"}, "canonical_solution": "{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i; // Return the value of a where a <= b and both conditions are satisfied\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}", "instruction": {"en": "int f_22(int c, int d)\n{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i; // Return the value of a where a <= b and both conditions are satisfied\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.", "sq": "int f_22(int c, int d)\n{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i; // Return the value of a where a <= b and both conditions are satisfied\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit CPP në shqip duke përdorur maksimumi 500 karaktere.", "hy": "int f_22(int c, int d)\n{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i; // Return the value of a where a <= b and both conditions are satisfied\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}\n\nՏվեք CPP կոդի հակիրճ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "int f_22(int c, int d)\n{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i; // Return the value of a where a <= b and both conditions are satisfied\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}\n\nসিপিপি কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।", "bg": "int f_22(int c, int d)\n{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i; // Return the value of a where a <= b and both conditions are satisfied\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}\n\nПредоставете кратко описание на C++ кода на естествен език (docstring) на български, използвайки не повече от 500 знака.", "zh": "int f_22(int c, int d)\n{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i; // Return the value of a where a <= b and both conditions are satisfied\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}\n\n请用最多500个字符的中文对该CPP代码提供简洁的自然语言描述（文档字符串）。", "fr": "int f_22(int c, int d)\n{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i; // Return the value of a where a <= b and both conditions are satisfied\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}\n\nFournir une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.", "de": "int f_22(int c, int d)\n{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i; // Return the value of a where a <= b and both conditions are satisfied\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "int f_22(int c, int d)\n{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i; // Return the value of a where a <= b and both conditions are satisfied\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}\n\nBa da takaitaccen bayanin yare na halitta (docstring) na lambar CPP a cikin Hausa ta amfani da haruffa 500 ko ƙasa da haka.", "hi": "int f_22(int c, int d)\n{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i; // Return the value of a where a <= b and both conditions are satisfied\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}\n\nसीपीपी कोड का संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "int f_22(int c, int d)\n{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i; // Return the value of a where a <= b and both conditions are satisfied\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a CPP kódról magyarul, legfeljebb 500 karakterben.", "es": "int f_22(int c, int d)\n{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i; // Return the value of a where a <= b and both conditions are satisfied\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando como máximo 500 caracteres.", "arb": "int f_22(int c, int d)\n{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i; // Return the value of a where a <= b and both conditions are satisfied\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C++ باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "int f_22(int c, int d)\n{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i; // Return the value of a where a <= b and both conditions are satisfied\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "int f_22(int c, int d)\n{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i; // Return the value of a where a <= b and both conditions are satisfied\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}\n\nAşağıdaki CPP kodunun Türkçe olarak en fazla 500 karakter kullanarak doğal dilde kısa bir açıklamasını (docstring) sağlayın.", "vi": "int f_22(int c, int d)\n{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i; // Return the value of a where a <= b and both conditions are satisfied\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự.", "id": "int f_22(int c, int d)\n{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i; // Return the value of a where a <= b and both conditions are satisfied\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode CPP dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "int f_22(int c, int d)\n{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i; // Return the value of a where a <= b and both conditions are satisfied\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}\n\n以下のCPPコードの簡潔な自然言語による説明（ドックストリング）を日本語で500文字以内で提供してください。", "ko": "int f_22(int c, int d)\n{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i; // Return the value of a where a <= b and both conditions are satisfied\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}\n\n다음 CPP 코드에 대한 간결한 자연어 설명(도크스트링)을 한국어로 최대 500자 이내로 제공하세요.", "ml": "int f_22(int c, int d)\n{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i; // Return the value of a where a <= b and both conditions are satisfied\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}\n\nCPP കോഡിന്റെ സംക്ഷിപ്തമായ ഒരു സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) പരമാവധി 500 അക്ഷരങ്ങൾ ഉപയോഗിച്ച് മലയാളത്തിൽ നൽകുക.", "fa": "int f_22(int c, int d)\n{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i; // Return the value of a where a <= b and both conditions are satisfied\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}\n\nتوضیح مختصر به زبان طبیعی (docstring) از کد CPP را به زبان فارسی با حداکثر ۵۰۰ کاراکتر ارائه دهید."}, "level": "", "test": "int main() {\n    assert(f_22(5, 6) == 2);\n    assert(f_22(6, 9) == 3);\n    assert(f_22(7, 12) == 3);\n    assert(f_22(7, 11) == -1);\n    assert(f_22(9, 8) == 1);\n    assert(f_22(10, 25) == 5);\n    assert(f_22(10000, 8765) == -1);\n\n    return 0;\n}", "entry_point": "f_22", "signature": "int f_22(int c, int d)", "docstring": {"en": "Given integers c and d, where a + b = c and a * b = d, this function\nfinds the possible value of a with the condition a <= b. When multiple\npairs (a, b) are possible, it returns the pair with the smallest a.\nIf no valid pair exists, it returns -1.\n\nParameters:\n- c (int): The sum of a and b.\n- d (int): The product of a and b.\n\nReturns:\n- int: A possible value of a or -1 if no valid values exist.\n\nExamples:\nf_22(7, 11) returns -1\nf_22(5, 6) returns 2\n", "sq": "Duke pasur parasysh numrat e plotë c dhe d, ku a + b = c dhe a * b = d, kjo funksion\ngjen vlerën e mundshme të a me kushtin a <= b. Kur janë të mundshme shumë\nçifte (a, b), ajo kthen çiftin me a më të vogël.\nNëse nuk ekziston asnjë çift i vlefshëm, ajo kthen -1.\n\nParametrat:\n- c (int): Shuma e a dhe b.\n- d (int): Produkti i a dhe b.\n\nKthen:\n- int: Një vlerë e mundshme e a ose -1 nëse nuk ekzistojnë vlera të vlefshme.\n\nShembuj:\nf_22(7, 11) kthen -1\nf_22(5, 6) kthen 2", "hy": "Տրված են ամբողջ թվեր c և d, որտեղ a + b = c և a * b = d, այս ֆունկցիան\nգտնում է a-ի հնարավոր արժեքը պայմանով a <= b։ Երբ հնարավոր են մի քանի\nզույգեր (a, b), այն վերադարձնում է զույգը ամենափոքր a-ով։\nԵթե վավեր զույգ գոյություն չունի, այն վերադարձնում է -1։\n\nՊարամետրեր:\n- c (int): a և b-ի գումարը։\n- d (int): a և b-ի արտադրյալը։\n\nՎերադարձնում է:\n- int: a-ի հնարավոր արժեքը կամ -1, եթե վավեր արժեքներ չկան։\n\nՕրինակներ:\nf_22(7, 11) վերադարձնում է -1\nf_22(5, 6) վերադարձնում է 2", "bn": "দেওয়া পূর্ণসংখ্যা c এবং d এর জন্য, যেখানে a + b = c এবং a * b = d, এই ফাংশনটি a এর সম্ভাব্য মান খুঁজে বের করে শর্ত সহ a <= b। যখন একাধিক জোড়া (a, b) সম্ভব হয়, এটি সবচেয়ে ছোট a সহ জোড়াটি ফেরত দেয়। যদি কোনো বৈধ জোড়া না থাকে, এটি -1 ফেরত দেয়।\n\nপ্যারামিটারসমূহ:\n- c (int): a এবং b এর যোগফল।\n- d (int): a এবং b এর গুণফল।\n\nফেরত:\n- int: a এর একটি সম্ভাব্য মান অথবা যদি কোনো বৈধ মান না থাকে তবে -1।\n\nউদাহরণ:\nf_22(7, 11) returns -1\nf_22(5, 6) returns 2", "bg": "Дадени са цели числа c и d, където a + b = c и a * b = d, тази функция\nнамира възможната стойност на a с условието a <= b. Когато са възможни множество\nдвойки (a, b), тя връща двойката с най-малко a.\nАко не съществува валидна двойка, тя връща -1.\n\nПараметри:\n- c (int): Сумата на a и b.\n- d (int): Произведението на a и b.\n\nВръща:\n- int: Възможна стойност на a или -1, ако не съществуват валидни стойности.\n\nПримери:\nf_22(7, 11) връща -1\nf_22(5, 6) връща 2", "zh": "给定整数 c 和 d，其中 a + b = c 且 a * b = d，此函数在 a <= b 的条件下找到 a 的可能值。当存在多个 (a, b) 对时，返回具有最小 a 的对。如果不存在有效对，则返回 -1。\n\n参数:\n- c (int): a 和 b 的和。\n- d (int): a 和 b 的积。\n\n返回:\n- int: a 的可能值，如果不存在有效值则返回 -1。\n\n示例:\nf_22(7, 11) 返回 -1\nf_22(5, 6) 返回 2", "fr": "Étant donné des entiers c et d, où a + b = c et a * b = d, cette fonction\ntrouve la valeur possible de a avec la condition a <= b. Lorsqu'il existe plusieurs\npaires (a, b) possibles, elle renvoie la paire avec le plus petit a.\nSi aucune paire valide n'existe, elle renvoie -1.\n\nParamètres:\n- c (int): La somme de a et b.\n- d (int): Le produit de a et b.\n\nRenvoie:\n- int: Une valeur possible de a ou -1 si aucune valeur valide n'existe.\n\nExemples:\nf_22(7, 11) renvoie -1\nf_22(5, 6) renvoie 2", "de": "Gegeben ganze Zahlen c und d, wobei a + b = c und a * b = d, findet diese Funktion den möglichen Wert von a mit der Bedingung a <= b. Wenn mehrere Paare (a, b) möglich sind, gibt sie das Paar mit dem kleinsten a zurück. Wenn kein gültiges Paar existiert, gibt sie -1 zurück.\n\nParameter:\n- c (int): Die Summe von a und b.\n- d (int): Das Produkt von a und b.\n\nRückgabewert:\n- int: Ein möglicher Wert von a oder -1, wenn keine gültigen Werte existieren.\n\nBeispiele:\nf_22(7, 11) gibt -1 zurück\nf_22(5, 6) gibt 2 zurück", "ha": "An ba da lambobin c da d, inda a + b = c kuma a * b = d, wannan aikin yana nemo yiwuwar ƙimar a tare da yanayin a <= b. Lokacin da dama-dama (a, b) suna yiwuwa, yana dawo da ma'aurata tare da ƙaramin a. Idan babu ma'aurata masu inganci, yana dawo da -1.\n\nParameters:\n- c (int): Jimillar a da b.\n- d (int): Samfurin a da b.\n\nReturns:\n- int: Yiwuwar ƙimar a ko -1 idan babu ƙimar da ta dace.\n\nExamples:\nf_22(7, 11) returns -1\nf_22(5, 6) returns 2", "hi": "दिए गए पूर्णांक c और d के लिए, जहाँ a + b = c और a * b = d, यह फ़ंक्शन a के संभावित मान को ढूंढता है जिसमें शर्त a <= b होती है। जब कई जोड़े (a, b) संभव होते हैं, तो यह सबसे छोटे a वाले जोड़े को लौटाता है। यदि कोई वैध जोड़ा मौजूद नहीं है, तो यह -1 लौटाता है।\n\nपैरामीटर्स:\n- c (int): a और b का योग।\n- d (int): a और b का गुणनफल।\n\nवापसी:\n- int: a का एक संभावित मान या -1 यदि कोई वैध मान मौजूद नहीं है।\n\nउदाहरण:\nf_22(7, 11) -1 लौटाता है\nf_22(5, 6) 2 लौटाता है", "hu": "Adott c és d egész számok, ahol a + b = c és a * b = d, ez a függvény\nmegtalálja a lehetséges a értékét azzal a feltétellel, hogy a <= b. Ha több\n(a, b) pár lehetséges, akkor a legkisebb a értékű párt adja vissza.\nHa nem létezik érvényes pár, akkor -1-et ad vissza.\n\nParaméterek:\n- c (int): Az a és b összege.\n- d (int): Az a és b szorzata.\n\nVisszatérési érték:\n- int: Egy lehetséges a érték vagy -1, ha nem léteznek érvényes értékek.\n\nPéldák:\nf_22(7, 11) visszaadja -1\nf_22(5, 6) visszaadja 2", "es": "Dado los enteros c y d, donde a + b = c y a * b = d, esta función\nencuentra el valor posible de a con la condición a <= b. Cuando múltiples\npares (a, b) son posibles, devuelve el par con el a más pequeño.\nSi no existe un par válido, devuelve -1.\n\nParámetros:\n- c (int): La suma de a y b.\n- d (int): El producto de a y b.\n\nDevuelve:\n- int: Un valor posible de a o -1 si no existen valores válidos.\n\nEjemplos:\nf_22(7, 11) devuelve -1\nf_22(5, 6) devuelve 2", "arb": "المعطى عددان صحيحان c و d، حيث a + b = c و a * b = d، هذه الدالة\nتجد القيمة الممكنة لـ a بشرط أن a <= b. عندما تكون هناك أزواج متعددة (a, b) ممكنة، فإنها تعيد الزوج الذي يحتوي على أصغر قيمة لـ a.\nإذا لم يكن هناك زوج صالح، فإنها تعيد -1.\n\nالمعطيات:\n- c (int): مجموع a و b.\n- d (int): حاصل ضرب a و b.\n\nالقيم المعادة:\n- int: قيمة ممكنة لـ a أو -1 إذا لم تكن هناك قيم صالحة.\n\nأمثلة:\nf_22(7, 11) يعيد -1\nf_22(5, 6) يعيد 2", "sw": "Ukipewa nambari nzima c na d, ambapo a + b = c na a * b = d, kazi hii\ninapata thamani inayowezekana ya a kwa sharti a <= b. Wakati jozi nyingi\n(a, b) zinawezekana, inarudisha jozi yenye a ndogo zaidi.\nIkiwa hakuna jozi halali ipo, inarudisha -1.\n\nVigezo:\n- c (int): Jumla ya a na b.\n- d (int): Bidhaa ya a na b.\n\nInarejesha:\n- int: Thamani inayowezekana ya a au -1 ikiwa hakuna thamani halali.\n\nMifano:\nf_22(7, 11) inarejesha -1\nf_22(5, 6) inarejesha 2", "tr": "Verilen c ve d tam sayıları için, burada a + b = c ve a * b = d, bu fonksiyon a <= b koşuluyla a'nın olası değerini bulur. Birden fazla (a, b) çifti mümkün olduğunda, en küçük a'ya sahip çifti döndürür. Geçerli bir çift yoksa, -1 döndürür.\n\nParametreler:\n- c (int): a ve b'nin toplamı.\n- d (int): a ve b'nin çarpımı.\n\nDöndürülen:\n- int: a'nın olası bir değeri veya geçerli bir değer yoksa -1.\n\nÖrnekler:\nf_22(7, 11) -1 döndürür\nf_22(5, 6) 2 döndürür", "vi": "Cho các số nguyên c và d, trong đó a + b = c và a * b = d, hàm này tìm giá trị có thể có của a với điều kiện a <= b. Khi có nhiều cặp (a, b) có thể, nó trả về cặp với a nhỏ nhất. Nếu không tồn tại cặp hợp lệ, nó trả về -1.\n\nTham số:\n- c (int): Tổng của a và b.\n- d (int): Tích của a và b.\n\nTrả về:\n- int: Một giá trị có thể có của a hoặc -1 nếu không tồn tại giá trị hợp lệ.\n\nVí dụ:\nf_22(7, 11) trả về -1\nf_22(5, 6) trả về 2", "id": "Diberikan bilangan bulat c dan d, di mana a + b = c dan a * b = d, fungsi ini\nmenemukan nilai a yang mungkin dengan kondisi a <= b. Ketika beberapa\npasangan (a, b) mungkin, fungsi ini mengembalikan pasangan dengan a terkecil.\nJika tidak ada pasangan yang valid, fungsi ini mengembalikan -1.\n\nParameter:\n- c (int): Jumlah dari a dan b.\n- d (int): Hasil kali dari a dan b.\n\nMengembalikan:\n- int: Nilai a yang mungkin atau -1 jika tidak ada nilai yang valid.\n\nContoh:\nf_22(7, 11) mengembalikan -1\nf_22(5, 6) mengembalikan 2", "ja": "与えられた整数 c と d に対して、a + b = c かつ a * b = d であるとき、この関数は a <= b の条件を満たす a の可能な値を見つけます。複数のペア (a, b) が可能な場合、最も小さい a を持つペアを返します。有効なペアが存在しない場合は、-1 を返します。\n\n引数:\n- c (int): a と b の和。\n- d (int): a と b の積。\n\n返り値:\n- int: a の可能な値、または有効な値が存在しない場合は -1。\n\n例:\nf_22(7, 11) は -1 を返します\nf_22(5, 6) は 2 を返します", "ko": "주어진 정수 c와 d에 대해, 여기서 a + b = c 그리고 a * b = d일 때, 이 함수는 a <= b 조건을 만족하는 a의 가능한 값을 찾습니다. 여러 쌍 (a, b)이 가능한 경우, 가장 작은 a를 갖는 쌍을 반환합니다. 유효한 쌍이 존재하지 않으면 -1을 반환합니다.\n\n매개변수:\n- c (int): a와 b의 합.\n- d (int): a와 b의 곱.\n\n반환값:\n- int: 가능한 a의 값 또는 유효한 값이 존재하지 않으면 -1.\n\n예제:\nf_22(7, 11) returns -1\nf_22(5, 6) returns 2", "ml": "നൽകിയിരിക്കുന്ന പൂർണ്ണസംഖ്യകൾ c, d എന്നിവയിൽ, a + b = c, a * b = d എന്നിടത്ത് \n * a <= b എന്ന വ്യവസ്ഥയോടെ a യുടെ സാധ്യമായ മൂല്യം കണ്ടെത്തുന്നു. \n * ഒന്നിലധികം (a, b) ജോഡികൾ സാധ്യമാണെങ്കിൽ, ഏറ്റവും ചെറിയ a ഉള്ള ജോഡി തിരികെ നൽകുന്നു.\n * യാതൊരു സാധുവായ ജോഡിയും നിലനിൽക്കാത്ത പക്ഷം, -1 തിരികെ നൽകുന്നു.\n\nപാരാമീറ്ററുകൾ:\n- c (int): a + b എന്നതിന്റെ ആകെ ഫലം.\n- d (int): a * b എന്നതിന്റെ ഗുണഫലം.\n\nമടക്കം:\n- int: a എന്നതിനുള്ള ഒരു സാധ്യമായ മൂല്യം അല്ലെങ്കിൽ സാധുവായ മൂല്യങ്ങൾ ഇല്ലെങ്കിൽ -1.\n\nഉദാഹരണങ്ങൾ:\nf_22(7, 11) -1 മടക്കുന്നു\nf_22(5, 6) 2 മടക്കുന്നു", "fa": "ارقام صحیح c و d داده شده‌اند، که در آن a + b = c و a * b = d، این تابع\nمقدار ممکن a را با شرط a <= b پیدا می‌کند. وقتی چندین جفت (a, b) ممکن باشد، جفتی را با کوچکترین a برمی‌گرداند.\nاگر هیچ جفت معتبری وجود نداشته باشد، -1 را برمی‌گرداند.\n\nپارامترها:\n- c (int): مجموع a و b.\n- d (int): حاصل‌ضرب a و b.\n\nبازگشتی:\n- int: یک مقدار ممکن از a یا -1 اگر هیچ مقدار معتبری وجود نداشته باشد.\n\nمثال‌ها:\nf_22(7, 11) returns -1\nf_22(5, 6) returns 2"}}
{"task_id": "CPP/23", "prompt": {"en": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\n/**\nCount the number of acute-angled triangles that can be formed by selecting any 3 edges out of\na given set of edges.\n  \nArgs:\n- edges_count: The number of edges passed.\n- An arbitrary number of integer arguments representing the lengths of the edges.\n  \nReturns:\nint: The count of distinct acute-angled triangles that can be formed.\n  \nExamples:\n>>> f_23(4, 1, 1, 1, 1)\n4\n**/\nint f_23(int edges_count, ...)", "sq": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\n/**\nNumëroni numrin e trekëndëshave me kënd të mprehtë që mund të formohen duke zgjedhur çdo 3 brinjë nga\nnjë grup i dhënë i brinjëve.\n  \nArgumentet:\n- edges_count: Numri i brinjëve të dhëna.\n- Një numër arbitrar i argumenteve të plotë që përfaqësojnë gjatësitë e brinjëve.\n  \nKthen:\nint: Numri i trekëndëshave të dallueshëm me kënd të mprehtë që mund të formohen.\n  \nShembuj:\n>>> f_23(4, 1, 1, 1, 1)\n4\n**/\nint f_23(int edges_count, ...)", "hy": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\n/**\nՀաշվել սուր անկյուն ունեցող եռանկյունիների քանակը, որոնք կարող են կազմվել ընտրելով ցանկացած 3 կողերից\nտրված կողերի բազմությունից:\n  \nԱրգումենտներ:\n- edges_count: Փոխանցված կողերի քանակը:\n- Կողերի երկարությունները ներկայացնող ամբողջ թվերի կամայական քանակի արգումենտներ:\n  \nՎերադարձնում է:\nint: Տարբեր սուր անկյուն ունեցող եռանկյունիների քանակը, որոնք կարող են կազմվել:\n  \nՕրինակներ:\n>>> f_23(4, 1, 1, 1, 1)\n4\n**/\nint f_23(int edges_count, ...)", "bn": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\n/**\nপ্রদত্ত প্রান্তগুলির একটি সেট থেকে যেকোনো 3 প্রান্ত নির্বাচন করে গঠিত তীক্ষ্ণ-কোণযুক্ত ত্রিভুজের সংখ্যা গণনা করুন।\n\nআর্গুমেন্টসমূহ:\n- edges_count: প্রেরিত প্রান্তের সংখ্যা।\n- প্রান্তগুলির দৈর্ঘ্য উপস্থাপনকারী একটি ইচ্ছামত সংখ্যক পূর্ণসংখ্যার আর্গুমেন্ট।\n\nফেরত দেয়:\nint: গঠিত হতে পারে এমন স্বতন্ত্র তীক্ষ্ণ-কোণযুক্ত ত্রিভুজের সংখ্যা।\n\nউদাহরণ:\n>>> f_23(4, 1, 1, 1, 1)\n4\n**/\nint f_23(int edges_count, ...)", "bg": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\n/**\nБройте броя на остроъгълните триъгълници, които могат да бъдат образувани чрез избиране на произволни 3 ръба от\nдадена група ръбове.\n  \nАргументи:\n- edges_count: Броят на предадените ръбове.\n- Произволен брой цели числа, представляващи дължините на ръбовете.\n  \nВръща:\nint: Броят на различните остроъгълни триъгълници, които могат да бъдат образувани.\n  \nПримери:\n>>> f_23(4, 1, 1, 1, 1)\n4\n**/\nint f_23(int edges_count, ...)", "zh": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\n/**\n计算可以通过从给定的一组边中选择任意3条边形成的锐角三角形的数量。\n\n参数：\n- edges_count: 传递的边的数量。\n- 任意数量的整数参数，表示边的长度。\n\n返回：\nint: 可以形成的不同锐角三角形的数量。\n\n示例：\n>>> f_23(4, 1, 1, 1, 1)\n4\n**/\nint f_23(int edges_count, ...)", "fr": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\n/**\nCompter le nombre de triangles aigus qui peuvent être formés en sélectionnant 3 arêtes parmi\nun ensemble donné d'arêtes.\n  \nArguments:\n- edges_count: Le nombre d'arêtes passées.\n- Un nombre arbitraire d'arguments entiers représentant les longueurs des arêtes.\n  \nRenvoie:\nint: Le nombre de triangles aigus distincts qui peuvent être formés.\n  \nExemples:\n>>> f_23(4, 1, 1, 1, 1)\n4\n**/\nint f_23(int edges_count, ...)", "de": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\n/**\nZählt die Anzahl der spitzwinkligen Dreiecke, die gebildet werden können, indem beliebige 3 Kanten aus\neinem gegebenen Satz von Kanten ausgewählt werden.\n  \nArgumente:\n- edges_count: Die Anzahl der übergebenen Kanten.\n- Eine beliebige Anzahl von ganzzahligen Argumenten, die die Längen der Kanten darstellen.\n  \nRückgabewert:\nint: Die Anzahl der verschiedenen spitzwinkligen Dreiecke, die gebildet werden können.\n  \nBeispiele:\n>>> f_23(4, 1, 1, 1, 1)\n4\n**/\nint f_23(int edges_count, ...)", "ha": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\n/**\nƘididdige adadin kusurwoyi masu kaifi waɗanda za a iya samarwa ta zaɓar kowane 3 gefuna daga\nwani saitin gefuna da aka bayar.\n  \nArgs:\n- edges_count: Adadin gefuna da aka wuce.\n- Yawan hujjojin lamba na duk wani tsawon gefuna.\n  \nReturns:\nint: Adadin kusurwoyi masu kaifi na daban-daban waɗanda za a iya samarwa.\n  \nMisalai:\n>>> f_23(4, 1, 1, 1, 1)\n4\n**/\nint f_23(int edges_count, ...)", "hi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\n/**\nदिए गए किनारों के सेट में से किसी भी 3 किनारों का चयन करके बनने वाले तीव्र कोणीय त्रिभुजों की संख्या गिनें।\n\nआर्ग्स:\n- edges_count: पास की गई किनारों की संख्या।\n- किनारों की लंबाई का प्रतिनिधित्व करने वाले कई पूर्णांक तर्क।\n\nवापसी:\nint: बनने वाले विशिष्ट तीव्र कोणीय त्रिभुजों की संख्या।\n\nउदाहरण:\n>>> f_23(4, 1, 1, 1, 1)\n4\n**/\nint f_23(int edges_count, ...)", "hu": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\n/**\nSzámolja meg a hegyesszögű háromszögek számát, amelyek a megadott élek halmazából bármely 3 él kiválasztásával képezhetők.\n  \nArgumentumok:\n- edges_count: A megadott élek száma.\n- Tetszőleges számú egész szám argumentum, amelyek az élek hosszát képviselik.\n  \nVisszatér:\nint: A különböző hegyesszögű háromszögek száma, amelyek képezhetők.\n  \nPéldák:\n>>> f_23(4, 1, 1, 1, 1)\n4\n**/\nint f_23(int edges_count, ...)", "es": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\n/**\nCuenta el número de triángulos acutángulos que se pueden formar seleccionando cualquier 3 lados de un conjunto dado de lados.\n  \nArgs:\n- edges_count: El número de lados pasados.\n- Un número arbitrario de argumentos enteros que representan las longitudes de los lados.\n  \nReturns:\nint: La cantidad de triángulos acutángulos distintos que se pueden formar.\n  \nExamples:\n>>> f_23(4, 1, 1, 1, 1)\n4\n**/\nint f_23(int edges_count, ...)", "arb": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\n/**\nاحسب عدد المثلثات الحادة الزاوية التي يمكن تشكيلها عن طريق اختيار أي 3 حواف من مجموعة معينة من الحواف.\n\nالمعطيات:\n- edges_count: عدد الحواف الممررة.\n- عدد تعسفي من الوسيطات الصحيحة التي تمثل أطوال الحواف.\n\nالإرجاع:\nint: عدد المثلثات الحادة الزاوية المميزة التي يمكن تشكيلها.\n\nأمثلة:\n>>> f_23(4, 1, 1, 1, 1)\n4\n**/\nint f_23(int edges_count, ...)", "sw": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\n/**\nHesabu idadi ya pembetatu zenye pembe kali ambazo zinaweza kuundwa kwa kuchagua pande 3 yoyote kutoka kwenye seti ya pande zilizotolewa.\n\nArgs:\n- edges_count: Idadi ya pande zilizopitishwa.\n- Idadi isiyo ya kawaida ya hoja za nambari nzima zinazowakilisha urefu wa pande.\n\nReturns:\nint: Idadi ya pembetatu tofauti zenye pembe kali ambazo zinaweza kuundwa.\n\nExamples:\n>>> f_23(4, 1, 1, 1, 1)\n4\n**/\nint f_23(int edges_count, ...)", "tr": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\n/**\nVerilen bir kenar kümesinden herhangi 3 kenar seçilerek oluşturulabilecek keskin açılı üçgenlerin sayısını sayar.\n  \nArgümanlar:\n- edges_count: Geçilen kenarların sayısı.\n- Kenar uzunluklarını temsil eden rastgele sayıda tamsayı argümanı.\n  \nDöndürür:\nint: Oluşturulabilecek farklı keskin açılı üçgenlerin sayısı.\n  \nÖrnekler:\n>>> f_23(4, 1, 1, 1, 1)\n4\n**/\nint f_23(int edges_count, ...)", "vi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\n/**\nĐếm số lượng tam giác nhọn có thể được tạo thành bằng cách chọn bất kỳ 3 cạnh nào từ\nmột tập hợp các cạnh cho trước.\n  \nTham số:\n- edges_count: Số lượng cạnh được truyền vào.\n- Một số lượng tùy ý các đối số nguyên đại diện cho độ dài của các cạnh.\n  \nTrả về:\nint: Số lượng tam giác nhọn khác biệt có thể được tạo thành.\n  \nVí dụ:\n>>> f_23(4, 1, 1, 1, 1)\n4\n**/\nint f_23(int edges_count, ...)", "id": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\n/**\nMenghitung jumlah segitiga lancip yang dapat dibentuk dengan memilih 3 sisi dari\nsekumpulan sisi yang diberikan.\n  \nArgumen:\n- edges_count: Jumlah sisi yang diberikan.\n- Sejumlah argumen bilangan bulat yang mewakili panjang sisi-sisi.\n  \nMengembalikan:\nint: Jumlah segitiga lancip yang berbeda yang dapat dibentuk.\n  \nContoh:\n>>> f_23(4, 1, 1, 1, 1)\n4\n**/\nint f_23(int edges_count, ...)", "ja": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\n/**\n与えられたエッジの集合から任意の3つのエッジを選択することによって形成できる鋭角三角形の数を数えます。\n  \n引数:\n- edges_count: 渡されたエッジの数。\n- エッジの長さを表す任意の数の整数引数。\n  \n戻り値:\nint: 形成できる異なる鋭角三角形の数。\n  \n例:\n>>> f_23(4, 1, 1, 1, 1)\n4\n**/\nint f_23(int edges_count, ...)", "ko": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\n/**\n주어진 변 집합에서 임의의 3개의 변을 선택하여 만들 수 있는 예각 삼각형의 수를 계산합니다.\n  \n매개변수:\n- edges_count: 전달된 변의 수.\n- 변의 길이를 나타내는 임의의 개수의 정수 인수.\n  \n반환:\nint: 만들 수 있는 서로 다른 예각 삼각형의 수.\n  \n예시:\n>>> f_23(4, 1, 1, 1, 1)\n4\n**/\nint f_23(int edges_count, ...)\n", "ml": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\n/**\nഒരു നൽകിയ എഡ്ജുകളുടെ സമുച്ചയത്തിൽ നിന്ന് ഏതെങ്കിലും 3 എഡ്ജുകൾ തിരഞ്ഞെടുക്കുന്നതിലൂടെ രൂപീകരിക്കാവുന്ന acute-angled ത്രികോണങ്ങളുടെ എണ്ണം എണ്ണുക.\n\nആർഗ്യുമെന്റുകൾ:\n- edges_count: പാസ്സാക്കിയ എഡ്ജുകളുടെ എണ്ണം.\n- എഡ്ജുകളുടെ നീളങ്ങളെ പ്രതിനിധീകരിക്കുന്ന ഏത് സംഖ്യയിലും ഇന്റിജർ ആർഗ്യുമെന്റുകൾ.\n\nമടക്കുന്നു:\nint: രൂപീകരിക്കാവുന്ന വ്യത്യസ്തമായ acute-angled ത്രികോണങ്ങളുടെ എണ്ണം.\n\nഉദാഹരണങ്ങൾ:\n>>> f_23(4, 1, 1, 1, 1)\n4\n**/\nint f_23(int edges_count, ...)", "fa": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\n/**\nتعداد مثلث‌های تیزگوشه‌ای را که می‌توان با انتخاب هر ۳ ضلع از مجموعه‌ای از اضلاع تشکیل داد، بشمارید.\n\nآرگومان‌ها:\n- edges_count: تعداد اضلاع داده شده.\n- تعداد دلخواهی از آرگومان‌های صحیح که طول اضلاع را نشان می‌دهند.\n\nبازگشت:\nint: تعداد مثلث‌های تیزگوشه متمایزی که می‌توان تشکیل داد.\n\nمثال‌ها:\n>>> f_23(4, 1, 1, 1, 1)\n4\n**/\nint f_23(int edges_count, ...)\n"}, "canonical_solution": "{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = (int*) malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    // qsort(edges, edges_count, sizeof(int), [](const void * a, const void * b) -> int {\n    //     return *(int*)a - *(int*)b;\n    // });\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}", "instruction": {"en": "int f_23(int edges_count, ...)\n{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = (int*) malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    // qsort(edges, edges_count, sizeof(int), [](const void * a, const void * b) -> int {\n    //     return *(int*)a - *(int*)b;\n    // });\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.", "sq": "int f_23(int edges_count, ...)\n{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = (int*) malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    // qsort(edges, edges_count, sizeof(int), [](const void * a, const void * b) -> int {\n    //     return *(int*)a - *(int*)b;\n    // });\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrale (docstring) për kodin CPP në gjuhën shqipe duke përdorur maksimumi 500 karaktere.", "hy": "int f_23(int edges_count, ...)\n{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = (int*) malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    // qsort(edges, edges_count, sizeof(int), [](const void * a, const void * b) -> int {\n    //     return *(int*)a - *(int*)b;\n    // });\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}\n\nՏվեք CPP կոդի հակիրճ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "int f_23(int edges_count, ...)\n{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = (int*) malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    // qsort(edges, edges_count, sizeof(int), [](const void * a, const void * b) -> int {\n    //     return *(int*)a - *(int*)b;\n    // });\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}\n\nনিচের CPP কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।", "bg": "int f_23(int edges_count, ...)\n{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = (int*) malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    // qsort(edges, edges_count, sizeof(int), [](const void * a, const void * b) -> int {\n    //     return *(int*)a - *(int*)b;\n    // });\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}\n\nПредоставете кратко описание на кода на CPP на естествен език на български, като използвате не повече от 500 знака.", "zh": "int f_23(int edges_count, ...)\n{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = (int*) malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    // qsort(edges, edges_count, sizeof(int), [](const void * a, const void * b) -> int {\n    //     return *(int*)a - *(int*)b;\n    // });\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}\n\n请用最多500个字符的中文对该CPP代码提供简洁的自然语言描述（文档字符串）。", "fr": "int f_23(int edges_count, ...)\n{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = (int*) malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    // qsort(edges, edges_count, sizeof(int), [](const void * a, const void * b) -> int {\n    //     return *(int*)a - *(int*)b;\n    // });\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}\n\nFournissez une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.", "de": "int f_23(int edges_count, ...)\n{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = (int*) malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    // qsort(edges, edges_count, sizeof(int), [](const void * a, const void * b) -> int {\n    //     return *(int*)a - *(int*)b;\n    // });\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen.", "ha": "int f_23(int edges_count, ...)\n{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = (int*) malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    // qsort(edges, edges_count, sizeof(int), [](const void * a, const void * b) -> int {\n    //     return *(int*)a - *(int*)b;\n    // });\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}\n\nBa da takaitaccen bayani a cikin yaren halitta (docstring) na lambar CPP cikin Hausa ta amfani da haruffa 500 kacal.", "hi": "int f_23(int edges_count, ...)\n{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = (int*) malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    // qsort(edges, edges_count, sizeof(int), [](const void * a, const void * b) -> int {\n    //     return *(int*)a - *(int*)b;\n    // });\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "int f_23(int edges_count, ...)\n{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = (int*) malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    // qsort(edges, edges_count, sizeof(int), [](const void * a, const void * b) -> int {\n    //     return *(int*)a - *(int*)b;\n    // });\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a CPP kódról magyarul, legfeljebb 500 karakterben.", "es": "int f_23(int edges_count, ...)\n{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = (int*) malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    // qsort(edges, edges_count, sizeof(int), [](const void * a, const void * b) -> int {\n    //     return *(int*)a - *(int*)b;\n    // });\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando como máximo 500 caracteres.", "arb": "int f_23(int edges_count, ...)\n{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = (int*) malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    // qsort(edges, edges_count, sizeof(int), [](const void * a, const void * b) -> int {\n    //     return *(int*)a - *(int*)b;\n    // });\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة CPP باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.", "sw": "int f_23(int edges_count, ...)\n{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = (int*) malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    // qsort(edges, edges_count, sizeof(int), [](const void * a, const void * b) -> int {\n    //     return *(int*)a - *(int*)b;\n    // });\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "int f_23(int edges_count, ...)\n{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = (int*) malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    // qsort(edges, edges_count, sizeof(int), [](const void * a, const void * b) -> int {\n    //     return *(int*)a - *(int*)b;\n    // });\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}\n\nAşağıdaki CPP kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalıdır.", "vi": "int f_23(int edges_count, ...)\n{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = (int*) malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    // qsort(edges, edges_count, sizeof(int), [](const void * a, const void * b) -> int {\n    //     return *(int*)a - *(int*)b;\n    // });\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự.", "id": "int f_23(int edges_count, ...)\n{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = (int*) malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    // qsort(edges, edges_count, sizeof(int), [](const void * a, const void * b) -> int {\n    //     return *(int*)a - *(int*)b;\n    // });\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode CPP dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "int f_23(int edges_count, ...)\n{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = (int*) malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    // qsort(edges, edges_count, sizeof(int), [](const void * a, const void * b) -> int {\n    //     return *(int*)a - *(int*)b;\n    // });\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}\n\n以下のCPPコードの簡潔な自然言語による説明（ドックストリング）を日本語で500文字以内で提供してください。", "ko": "int f_23(int edges_count, ...)\n{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = (int*) malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    // qsort(edges, edges_count, sizeof(int), [](const void * a, const void * b) -> int {\n    //     return *(int*)a - *(int*)b;\n    // });\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}\n\n다음 CPP 코드의 동작을 간결하게 설명하는 자연어 설명(docstring)을 한국어로 500자 이내로 작성하세요.", "ml": "int f_23(int edges_count, ...)\n{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = (int*) malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    // qsort(edges, edges_count, sizeof(int), [](const void * a, const void * b) -> int {\n    //     return *(int*)a - *(int*)b;\n    // });\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}\n\nCPP കോഡ് സംബന്ധിച്ച സംക്ഷിപ്തമായ ഒരു പ്രകൃതിദത്ത ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) പരമാവധി 500 അക്ഷരങ്ങൾ ഉപയോഗിച്ച് മലയാളത്തിൽ നൽകുക.", "fa": "int f_23(int edges_count, ...)\n{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = (int*) malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    // qsort(edges, edges_count, sizeof(int), [](const void * a, const void * b) -> int {\n    //     return *(int*)a - *(int*)b;\n    // });\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}\n\nیک توضیح مختصر به زبان طبیعی (docstring) از کد CPP به زبان فارسی ارائه دهید که حداکثر ۵۰۰ کاراکتر باشد."}, "level": "", "test": "int main() {\n    assert(f_23(4, 1, 1, 1, 1) == 4);\n    assert(f_23(3, 1, 2, 3) == 0);\n    // Additional tests to ensure correctness\n    assert(f_23(5, 3, 4, 5, 7, 10) == 0);\n    assert(f_23(6, 6, 8, 10, 5, 5, 5) == 4);\n    return 0;\n}", "entry_point": "f_23", "signature": "int f_23(int edges_count, ...)", "docstring": {"en": "Count the number of acute-angled triangles that can be formed by selecting any 3 edges out of a given set of edges.\n\nArgs:\n- edges_count: The number of edges passed.\n- An arbitrary number of integer arguments representing the lengths of the edges.\n\nReturns:\nint: The count of distinct acute-angled triangles that can be formed.\n\nExamples:\n>>> f_23(4, 1, 1, 1, 1)\n4\n", "sq": "Numëroni numrin e trekëndëshave me kënd të mprehtë që mund të formohen duke zgjedhur çdo 3 brinjë nga një grup i dhënë brinjësh.\n\nArgumentet:\n- edges_count: Numri i brinjëve të dhëna.\n- Një numër i pacaktuar argumentesh të tipit integer që përfaqësojnë gjatësitë e brinjëve.\n\nKthen:\nint: Numri i trekëndëshave të dallueshëm me kënd të mprehtë që mund të formohen.\n\nShembuj:\n>>> f_23(4, 1, 1, 1, 1)\n4", "hy": "Հաշվել սուրանկյուն եռանկյունիների քանակը, որոնք կարող են ձևավորվել տրված կողերի հավաքածուից ցանկացած 3 կող ընտրելով:\n\nԱրգումենտներ:\n- edges_count: Անցկացված կողերի քանակը:\n- Անհայտ քանակի ամբողջ թվային արգումենտներ, որոնք ներկայացնում են կողերի երկարությունները:\n\nՎերադարձնում է:\nint: Տարբեր սուրանկյուն եռանկյունիների քանակը, որոնք կարող են ձևավորվել:\n\nՕրինակներ:\n>>> f_23(4, 1, 1, 1, 1)\n4", "bn": "তীক্ষ্ণ-কোণী ত্রিভুজের সংখ্যা গণনা করুন যা একটি প্রদত্ত প্রান্তের সেট থেকে যেকোনো 3 প্রান্ত নির্বাচন করে তৈরি করা যেতে পারে।\n\nআর্গুমেন্টসমূহ:\n- edges_count: প্রান্তের সংখ্যা যা প্রদান করা হয়েছে।\n- প্রান্তের দৈর্ঘ্য উপস্থাপনকারী একটি ইচ্ছামত সংখ্যক পূর্ণসংখ্যার আর্গুমেন্ট।\n\nফেরত দেয়:\nint: পৃথক তীক্ষ্ণ-কোণী ত্রিভুজের সংখ্যা যা তৈরি করা যেতে পারে।\n\nউদাহরণ:\n>>> f_23(4, 1, 1, 1, 1)\n4", "bg": "Бройте броя на острите триъгълници, които могат да бъдат образувани чрез избиране на произволни 3 ръба от даден набор от ръбове.\n\nАргументи:\n- edges_count: Броят на подадените ръбове.\n- Произволен брой цели аргументи, представляващи дължините на ръбовете.\n\nВръща:\nint: Броят на различните остри триъгълници, които могат да бъдат образувани.\n\nПримери:\n>>> f_23(4, 1, 1, 1, 1)\n4", "zh": "计算可以通过从给定的边集中选择任意3条边形成的锐角三角形的数量。\n\n参数：\n- edges_count: 传递的边的数量。\n- 任意数量的整数参数，表示边的长度。\n\n返回：\nint: 可以形成的不同锐角三角形的数量。\n\n示例：\n>>> f_23(4, 1, 1, 1, 1)\n4", "fr": "Compter le nombre de triangles acutangles qui peuvent être formés en sélectionnant 3 arêtes quelconques parmi un ensemble donné d'arêtes.\n\nArgs:\n- edges_count: Le nombre d'arêtes passées.\n- Un nombre arbitraire d'arguments entiers représentant les longueurs des arêtes.\n\nReturns:\nint: Le nombre de triangles acutangles distincts qui peuvent être formés.\n\nExamples:\n>>> f_23(4, 1, 1, 1, 1)\n4\n", "de": "Zähle die Anzahl der spitzwinkligen Dreiecke, die gebildet werden können, indem beliebige 3 Kanten aus einer gegebenen Menge von Kanten ausgewählt werden.\n\nArgs:\n- edges_count: Die Anzahl der übergebenen Kanten.\n- Eine beliebige Anzahl von ganzzahligen Argumenten, die die Längen der Kanten darstellen.\n\nReturns:\nint: Die Anzahl der unterschiedlichen spitzwinkligen Dreiecke, die gebildet werden können.\n\nExamples:\n>>> f_23(4, 1, 1, 1, 1)\n4", "ha": "Kirga adadin kusurwoyi masu kaifi waɗanda za a iya samarwa ta zaɓar kowane 3 gefuna daga cikin wani saiti na gefuna.\n\nArgs:\n- edges_count: Adadin gefuna da aka bayar.\n- Yawan hujjojin lamba masu zaman kansu da ke wakiltar tsawon gefuna.\n\nReturns:\nint: Adadin kusurwoyi masu kaifi na daban-daban da za a iya samarwa.\n\nMisalai:\n>>> f_23(4, 1, 1, 1, 1)\n4", "hi": "तीव्र कोण वाले त्रिभुजों की संख्या गिनें जो कि दिए गए किनारों के सेट में से किसी भी 3 किनारों का चयन करके बनाए जा सकते हैं।\n\nआर्ग्स:\n- edges_count: पास किए गए किनारों की संख्या।\n- किनारों की लंबाई का प्रतिनिधित्व करने वाले पूर्णांक तर्कों की एक मनमानी संख्या।\n\nरिटर्न्स:\nint: विशिष्ट तीव्र कोण वाले त्रिभुजों की संख्या जो बनाई जा सकती है।\n\nउदाहरण:\n>>> f_23(4, 1, 1, 1, 1)\n4", "hu": "Számolja meg a hegyesszögű háromszögek számát, amelyek úgy alakíthatók ki, hogy kiválasztunk bármely 3 élt egy adott élsorozatból.\n\nArgs:\n- edges_count: Az átadott élek száma.\n- Tetszőleges számú egész szám argumentum, amelyek az élek hosszát képviselik.\n\nReturns:\nint: Az alakítható különböző hegyesszögű háromszögek száma.\n\nExamples:\n>>> f_23(4, 1, 1, 1, 1)\n4", "es": "Cuenta el número de triángulos acutángulos que se pueden formar seleccionando cualquier 3 aristas de un conjunto dado de aristas.\n\nArgs:\n- edges_count: El número de aristas pasadas.\n- Un número arbitrario de argumentos enteros que representan las longitudes de las aristas.\n\nReturns:\nint: La cuenta de triángulos acutángulos distintos que se pueden formar.\n\nExamples:\n>>> f_23(4, 1, 1, 1, 1)\n4", "arb": "عد عدد المثلثات الحادة الزاوية التي يمكن تشكيلها عن طريق اختيار أي 3 حواف من مجموعة الحواف المعطاة.\n\nArgs:\n- edges_count: عدد الحواف الممررة.\n- عدد تعسفي من الوسيطات الصحيحة التي تمثل أطوال الحواف.\n\nReturns:\nint: عدد المثلثات الحادة الزاوية المميزة التي يمكن تشكيلها.\n\nExamples:\n>>> f_23(4, 1, 1, 1, 1)\n4", "sw": "Hesabu idadi ya pembetatu zenye pembe kali ambazo zinaweza kuundwa kwa kuchagua kingo 3 kutoka kwenye seti iliyotolewa ya kingo.\n\nArgs:\n- edges_count: Idadi ya kingo zilizopitishwa.\n- Idadi yoyote ya hoja za nambari nzima zinazowakilisha urefu wa kingo.\n\nReturns:\nint: Idadi ya pembetatu tofauti zenye pembe kali ambazo zinaweza kuundwa.\n\nExamples:\n>>> f_23(4, 1, 1, 1, 1)\n4", "tr": "Verilen bir dizi kenardan herhangi 3 kenar seçilerek oluşturulabilecek keskin açılı üçgenlerin sayısını sayın.\n\nArgs:\n- edges_count: Geçilen kenarların sayısı.\n- Kenarların uzunluklarını temsil eden rastgele sayıda tamsayı argümanı.\n\nReturns:\nint: Oluşturulabilecek farklı keskin açılı üçgenlerin sayısı.\n\nExamples:\n>>> f_23(4, 1, 1, 1, 1)\n4", "vi": "Đếm số lượng tam giác nhọn có thể được tạo thành bằng cách chọn bất kỳ 3 cạnh nào từ một tập hợp các cạnh đã cho.\n\nTham số:\n- edges_count: Số lượng cạnh được truyền vào.\n- Một số lượng tùy ý các đối số kiểu số nguyên đại diện cho độ dài của các cạnh.\n\nTrả về:\nint: Số lượng tam giác nhọn khác nhau có thể được tạo thành.\n\nVí dụ:\n>>> f_23(4, 1, 1, 1, 1)\n4", "id": "Hitung jumlah segitiga lancip yang dapat dibentuk dengan memilih sembarang 3 sisi dari sekumpulan sisi yang diberikan.\n\nArgs:\n- edges_count: Jumlah sisi yang diberikan.\n- Sejumlah argumen bilangan bulat yang mewakili panjang sisi-sisi.\n\nReturns:\nint: Jumlah segitiga lancip yang berbeda yang dapat dibentuk.\n\nExamples:\n>>> f_23(4, 1, 1, 1, 1)\n4", "ja": "与えられたエッジのセットから任意の3つのエッジを選択することによって形成できる鋭角三角形の数を数えます。\n\n引数:\n- edges_count: 渡されたエッジの数。\n- エッジの長さを表す任意の数の整数引数。\n\n戻り値:\nint: 形成できる異なる鋭角三角形の数。\n\n例:\n>>> f_23(4, 1, 1, 1, 1)\n4", "ko": "주어진 모서리 집합에서 임의의 3개의 모서리를 선택하여 형성할 수 있는 예각 삼각형의 수를 계산합니다.\n\n인수:\n- edges_count: 전달된 모서리의 수.\n- 모서리의 길이를 나타내는 임의의 개수의 정수 인수.\n\n반환:\nint: 형성할 수 있는 고유한 예각 삼각형의 수.\n\n예제:\n>>> f_23(4, 1, 1, 1, 1)\n4", "ml": "തരിച്ചിരിക്കുന്ന എഡ്ജുകളുടെ ഒരു സെറ്റിൽ നിന്ന് ഏതെങ്കിലും 3 എഡ്ജുകൾ തിരഞ്ഞെടുക്കുന്നതിലൂടെ രൂപീകരിക്കാവുന്ന മൂർച്ചയുള്ള കോണുകളുള്ള ത്രികോണങ്ങളുടെ എണ്ണം എണ്ണുക.\n\nആർഗുകൾ:\n- edges_count: പാസ്സായ എഡ്ജുകളുടെ എണ്ണം.\n- എഡ്ജുകളുടെ നീളങ്ങളെ പ്രതിനിധീകരിക്കുന്ന ഒരു എണ്പതേയും സംഖ്യാരൂപത്തിലുള്ള ആർഗുമെന്റുകൾ.\n\nമടക്കം:\nint: രൂപീകരിക്കാവുന്ന വ്യത്യസ്തമായ മൂർച്ചയുള്ള കോണങ്ങളുള്ള ത്രികോണങ്ങളുടെ എണ്ണം.\n\nഉദാഹരണങ്ങൾ:\n>>> f_23(4, 1, 1, 1, 1)\n4", "fa": "تعداد مثلث‌های تیزگوشه‌ای که می‌توان با انتخاب هر ۳ ضلع از مجموعه‌ای از اضلاع تشکیل داد را بشمارید.\n\nآرگومان‌ها:\n- edges_count: تعداد اضلاعی که داده شده است.\n- تعداد دلخواهی از آرگومان‌های صحیح که طول اضلاع را نشان می‌دهند.\n\nبازگشت:\nint: تعداد مثلث‌های تیزگوشه متمایزی که می‌توان تشکیل داد.\n\nمثال‌ها:\n>>> f_23(4, 1, 1, 1, 1)\n4"}}
{"task_id": "CPP/24", "prompt": {"en": "#include <bits/stdc++.h>\n/**\n * Reads an integer and a character, then returns them as a formatted string separated by a comma.\n * \n * Parameters:\n * - integer_value (int): The input integer.\n * - char_value (char): The input character.\n * \n * Returns:\n * - char*: A string containing the integer and character separated by a comma.\n * \n * Example:\n * f_24(234, 'H') returns \"234,H\"\n */\nchar* f_24(int integer_value, char char_value)", "sq": "#include <bits/stdc++.h>\n/**\n * Lexon një numër të plotë dhe një karakter, pastaj i kthen ato si një varg i formatuar i ndarë me presje.\n * \n * Parametrat:\n * - integer_value (int): Numri i plotë i futur.\n * - char_value (char): Karakteri i futur.\n * \n * Kthen:\n * - char*: Një varg që përmban numrin e plotë dhe karakterin e ndarë me presje.\n * \n * Shembull:\n * f_24(234, 'H') kthen \"234,H\"\n */\nchar* f_24(int integer_value, char char_value)", "hy": "#include <bits/stdc++.h>\n/**\n * Կարդում է ամբողջ թիվ և սիմվոլ, ապա վերադարձնում է դրանք որպես ձևաչափված տող, որը բաժանված է ստորակետով:\n * \n * Պարամետրեր:\n * - integer_value (int): Մուտքային ամբողջ թիվը:\n * - char_value (char): Մուտքային սիմվոլը:\n * \n * Վերադարձնում է:\n * - char*: Տող, որը պարունակում է ամբողջ թիվը և սիմվոլը, որոնք բաժանված են ստորակետով:\n * \n * Օրինակ:\n * f_24(234, 'H') վերադարձնում է \"234,H\"\n */\nchar* f_24(int integer_value, char char_value)", "bn": "#include <bits/stdc++.h>\n/**\n * একটি পূর্ণসংখ্যা এবং একটি অক্ষর পড়ে, তারপর সেগুলিকে কমা দ্বারা পৃথক একটি ফরম্যাট করা স্ট্রিং হিসাবে ফেরত দেয়।\n * \n * প্যারামিটার:\n * - integer_value (int): ইনপুট পূর্ণসংখ্যা।\n * - char_value (char): ইনপুট অক্ষর।\n * \n * ফেরত দেয়:\n * - char*: একটি স্ট্রিং যা পূর্ণসংখ্যা এবং অক্ষরকে কমা দ্বারা পৃথক করে ধারণ করে।\n * \n * উদাহরণ:\n * f_24(234, 'H') \"234,H\" ফেরত দেয়\n */\nchar* f_24(int integer_value, char char_value)", "bg": "#include <bits/stdc++.h>\n/**\n * Чете цяло число и символ, след което ги връща като форматиран низ, разделен със запетая.\n * \n * Параметри:\n * - integer_value (int): Входното цяло число.\n * - char_value (char): Входният символ.\n * \n * Връща:\n * - char*: Низ, съдържащ цялото число и символа, разделени със запетая.\n * \n * Пример:\n * f_24(234, 'H') връща \"234,H\"\n */\nchar* f_24(int integer_value, char char_value)", "zh": "#include <bits/stdc++.h>\n/**\n * 读取一个整数和一个字符，然后将它们作为用逗号分隔的格式化字符串返回。\n * \n * 参数:\n * - integer_value (int): 输入的整数。\n * - char_value (char): 输入的字符。\n * \n * 返回:\n * - char*: 一个包含整数和字符并用逗号分隔的字符串。\n * \n * 示例:\n * f_24(234, 'H') 返回 \"234,H\"\n */\nchar* f_24(int integer_value, char char_value)", "fr": "#include <bits/stdc++.h>\n/**\n * Lit un entier et un caractère, puis les retourne sous forme de chaîne formatée séparée par une virgule.\n * \n * Paramètres :\n * - integer_value (int) : L'entier d'entrée.\n * - char_value (char) : Le caractère d'entrée.\n * \n * Renvoie :\n * - char* : Une chaîne contenant l'entier et le caractère séparés par une virgule.\n * \n * Exemple :\n * f_24(234, 'H') returns \"234,H\"\n */\nchar* f_24(int integer_value, char char_value)", "de": "#include <bits/stdc++.h>\n/**\n * Liest eine Ganzzahl und ein Zeichen ein und gibt sie dann als formatierten String, getrennt durch ein Komma, zurück.\n * \n * Parameter:\n * - integer_value (int): Die Eingabe-Ganzzahl.\n * - char_value (char): Das Eingabe-Zeichen.\n * \n * Rückgabewert:\n * - char*: Ein String, der die Ganzzahl und das Zeichen durch ein Komma getrennt enthält.\n * \n * Beispiel:\n * f_24(234, 'H') gibt \"234,H\" zurück\n */\nchar* f_24(int integer_value, char char_value)", "ha": "#include <bits/stdc++.h>\n/**\n * Karanta lamba da harafi, sannan ya mayar da su a matsayin igiyar rubutu mai tsari da aka raba ta alamar rubutu.\n * \n * Sigogi:\n * - integer_value (int): Lambar shigarwa.\n * - char_value (char): Harafin shigarwa.\n * \n * Komawa:\n * - char*: Igiyar rubutu mai dauke da lamba da harafi da aka raba ta alamar rubutu.\n * \n * Misali:\n * f_24(234, 'H') returns \"234,H\"\n */\nchar* f_24(int integer_value, char char_value)", "hi": "#include <bits/stdc++.h>\n/**\n * एक पूर्णांक और एक वर्ण पढ़ता है, फिर उन्हें अल्पविराम से अलग किए गए स्वरूपित स्ट्रिंग के रूप में लौटाता है।\n * \n * पैरामीटर्स:\n * - integer_value (int): इनपुट पूर्णांक।\n * - char_value (char): इनपुट वर्ण।\n * \n * रिटर्न्स:\n * - char*: एक स्ट्रिंग जिसमें पूर्णांक और वर्ण अल्पविराम से अलग किए गए होते हैं।\n * \n * उदाहरण:\n * f_24(234, 'H') \"234,H\" लौटाता है\n */\nchar* f_24(int integer_value, char char_value)", "hu": "#include <bits/stdc++.h>\n/**\n * Beolvas egy egész számot és egy karaktert, majd visszaadja őket egy formázott, vesszővel elválasztott sztringként.\n * \n * Paraméterek:\n * - integer_value (int): A bemeneti egész szám.\n * - char_value (char): A bemeneti karakter.\n * \n * Visszatérési érték:\n * - char*: Egy sztring, amely az egész számot és a karaktert tartalmazza, vesszővel elválasztva.\n * \n * Példa:\n * f_24(234, 'H') visszaadja \"234,H\"\n */\nchar* f_24(int integer_value, char char_value)", "es": "#include <bits/stdc++.h>\n/**\n * Lee un entero y un carácter, luego los devuelve como una cadena formateada separada por una coma.\n * \n * Parámetros:\n * - integer_value (int): El entero de entrada.\n * - char_value (char): El carácter de entrada.\n * \n * Devuelve:\n * - char*: Una cadena que contiene el entero y el carácter separados por una coma.\n * \n * Ejemplo:\n * f_24(234, 'H') returns \"234,H\"\n */\nchar* f_24(int integer_value, char char_value)", "arb": "#include <bits/stdc++.h>\n/**\n * يقرأ عددًا صحيحًا وحرفًا، ثم يعيدهما كسلسلة نصية منسقة مفصولة بفاصلة.\n * \n * المعلمات:\n * - integer_value (int): العدد الصحيح المدخل.\n * - char_value (char): الحرف المدخل.\n * \n * يعيد:\n * - char*: سلسلة نصية تحتوي على العدد الصحيح والحرف مفصولين بفاصلة.\n * \n * مثال:\n * f_24(234, 'H') returns \"234,H\"\n */\nchar* f_24(int integer_value, char char_value)", "sw": "#include <bits/stdc++.h>\n/**\n * Husoma nambari kamili na herufi, kisha kuzirejesha kama mfuatano wa maandishi uliopangwa ukitenganishwa na koma.\n * \n * Vigezo:\n * - integer_value (int): Nambari kamili ya ingizo.\n * - char_value (char): Herufi ya ingizo.\n * \n * Inarejesha:\n * - char*: Mfuatano wa maandishi unao na nambari kamili na herufi zikitenganishwa na koma.\n * \n * Mfano:\n * f_24(234, 'H') inarejesha \"234,H\"\n */\nchar* f_24(int integer_value, char char_value)", "tr": "#include <bits/stdc++.h>\n/**\n * Bir tam sayı ve bir karakter okur, ardından bunları virgülle ayrılmış biçimlendirilmiş bir dize olarak döndürür.\n * \n * Parametreler:\n * - integer_value (int): Girdi tam sayısı.\n * - char_value (char): Girdi karakteri.\n * \n * Döndürür:\n * - char*: Tam sayı ve karakteri virgülle ayrılmış bir dize olarak içeren bir dize.\n * \n * Örnek:\n * f_24(234, 'H') \"234,H\" döndürür\n */\nchar* f_24(int integer_value, char char_value)", "vi": "#include <bits/stdc++.h>\n/**\n * Đọc một số nguyên và một ký tự, sau đó trả về chúng dưới dạng chuỗi định dạng được phân tách bằng dấu phẩy.\n * \n * Tham số:\n * - integer_value (int): Số nguyên đầu vào.\n * - char_value (char): Ký tự đầu vào.\n * \n * Trả về:\n * - char*: Một chuỗi chứa số nguyên và ký tự được phân tách bằng dấu phẩy.\n * \n * Ví dụ:\n * f_24(234, 'H') trả về \"234,H\"\n */\nchar* f_24(int integer_value, char char_value)", "id": "#include <bits/stdc++.h>\n/**\n * Membaca sebuah bilangan bulat dan sebuah karakter, kemudian mengembalikannya sebagai string yang diformat dipisahkan oleh koma.\n * \n * Parameter:\n * - integer_value (int): Bilangan bulat masukan.\n * - char_value (char): Karakter masukan.\n * \n * Mengembalikan:\n * - char*: Sebuah string yang berisi bilangan bulat dan karakter yang dipisahkan oleh koma.\n * \n * Contoh:\n * f_24(234, 'H') mengembalikan \"234,H\"\n */\nchar* f_24(int integer_value, char char_value)", "ja": "#include <bits/stdc++.h>\n/**\n * 整数と文字を読み取り、それらをカンマで区切ったフォーマットされた文字列として返します。\n * \n * パラメータ:\n * - integer_value (int): 入力整数。\n * - char_value (char): 入力文字。\n * \n * 戻り値:\n * - char*: 整数と文字をカンマで区切った文字列。\n * \n * 例:\n * f_24(234, 'H') は \"234,H\" を返します\n */\nchar* f_24(int integer_value, char char_value)", "ko": "#include <bits/stdc++.h>\n/**\n * 정수와 문자를 읽고, 쉼표로 구분된 형식의 문자열로 반환합니다.\n * \n * 매개변수:\n * - integer_value (int): 입력 정수.\n * - char_value (char): 입력 문자.\n * \n * 반환값:\n * - char*: 쉼표로 구분된 정수와 문자를 포함하는 문자열.\n * \n * 예시:\n * f_24(234, 'H') returns \"234,H\"\n */\nchar* f_24(int integer_value, char char_value)", "ml": "#include <bits/stdc++.h>\n/**\n * ഒരു പൂർണ്ണസംഖ്യയും ഒരു അക്ഷരവും വായിച്ച് അവയെ കോമയാൽ വേർതിരിച്ച ഫോർമാറ്റുചെയ്ത സ്ട്രിംഗ് ആയി മടക്കിക്കൊടുക്കുന്നു.\n * \n * പാരാമീറ്ററുകൾ:\n * - integer_value (int): ഇൻപുട്ട് പൂർണ്ണസംഖ്യ.\n * - char_value (char): ഇൻപുട്ട് അക്ഷരം.\n * \n * മടക്കുക:\n * - char*: പൂർണ്ണസംഖ്യയും അക്ഷരവും കോമയാൽ വേർതിരിച്ച സ്ട്രിംഗ്.\n * \n * ഉദാഹരണം:\n * f_24(234, 'H') \"234,H\" മടക്കുന്നു\n */\nchar* f_24(int integer_value, char char_value)", "fa": "#include <bits/stdc++.h>\n/**\n * یک عدد صحیح و یک کاراکتر را می‌خواند، سپس آنها را به عنوان یک رشته قالب‌بندی‌شده با یک کاما جدا می‌کند.\n * \n * پارامترها:\n * - integer_value (int): عدد صحیح ورودی.\n * - char_value (char): کاراکتر ورودی.\n * \n * بازگشت:\n * - char*: یک رشته حاوی عدد صحیح و کاراکتر که با یک کاما جدا شده‌اند.\n * \n * مثال:\n * f_24(234, 'H') returns \"234,H\"\n */\nchar* f_24(int integer_value, char char_value)"}, "canonical_solution": "{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}", "instruction": {"en": "char* f_24(int integer_value, char char_value)\n{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.", "sq": "char* f_24(int integer_value, char char_value)\n{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit CPP në gjuhën shqipe duke përdorur maksimumi 500 karaktere.", "hy": "char* f_24(int integer_value, char char_value)\n{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}\n\nՏվեք CPP կոդի համառոտ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "char* f_24(int integer_value, char char_value)\n{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}\n\nসিপিপি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।", "bg": "char* f_24(int integer_value, char char_value)\n{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}\n\nПредоставете кратко описание на CPP кода на естествен език на български, като използвате най-много 500 знака.", "zh": "char* f_24(int integer_value, char char_value)\n{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}\n\n请用最多500个字符的中文对该CPP代码提供简洁的自然语言描述（文档字符串）。", "fr": "char* f_24(int integer_value, char char_value)\n{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}\n\nFournissez une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.", "de": "char* f_24(int integer_value, char char_value)\n{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen.", "ha": "char* f_24(int integer_value, char char_value)\n{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}\n\nBa da takaitaccen bayanin yare na halitta (docstring) na lambar CPP a cikin Hausa ta amfani da haruffa 500 kawai.", "hi": "char* f_24(int integer_value, char char_value)\n{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रींग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।", "hu": "char* f_24(int integer_value, char char_value)\n{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a CPP kódról magyarul, legfeljebb 500 karakterben.", "es": "char* f_24(int integer_value, char char_value)\n{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando como máximo 500 caracteres.", "arb": "char* f_24(int integer_value, char char_value)\n{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية بلغة C++ باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "char* f_24(int integer_value, char char_value)\n{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "char* f_24(int integer_value, char char_value)\n{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}\n\nAşağıdaki CPP kodunun Türkçe'de en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.", "vi": "char* f_24(int integer_value, char char_value)\n{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự.", "id": "char* f_24(int integer_value, char char_value)\n{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode CPP dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "char* f_24(int integer_value, char char_value)\n{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}\n\n以下のCPPコードの自然言語による簡潔な説明（ドックストリング）を日本語で500文字以内で提供してください。", "ko": "char* f_24(int integer_value, char char_value)\n{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}\n\n다음 CPP 코드에 대한 간결한 자연어 설명(도크스트링)을 한국어로 500자 이내로 제공하세요.", "ml": "char* f_24(int integer_value, char char_value)\n{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}\n\nCPP കോഡ് സംബന്ധിച്ച സംക്ഷിപ്തമായ പ്രകൃതിദത്ത ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) പരമാവധി 500 അക്ഷരങ്ങൾ ഉപയോഗിച്ച് മലയാളത്തിൽ നൽകുക.", "fa": "char* f_24(int integer_value, char char_value)\n{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}\n\nتوضیح مختصر و طبیعی (docstring) از کد CPP را به زبان فارسی با حداکثر ۵۰۰ کاراکتر ارائه دهید."}, "level": "", "test": "int main() {\n    // Test 1\n    char* output1 = f_24(234, 'H');\n    assert(strcmp(output1, \"234,H\") == 0);\n    free(output1); // Don't forget to free the allocated memory\n\n    // Additional tests can be added here with different input values\n    // Test 2\n    char* output2 = f_24(123, 'A');\n    assert(strcmp(output2, \"123,A\") == 0);\n    free(output2);\n\n    // Test 3\n    char* output3 = f_24(0, 'Z');\n    assert(strcmp(output3, \"0,Z\") == 0);\n    free(output3);\n\n    return 0;\n}", "entry_point": "f_24", "signature": "char* f_24(int integer_value, char char_value)", "docstring": {"en": "Reads an integer and a character, then returns them as a formatted string separated by a comma.\n\nParameters:\n- integer_value (int): The input integer.\n- char_value (char): The input character.\n\nReturns:\n- char*: A string containing the integer and character separated by a comma.\n\nExample:\nf_24(234, 'H') returns \"234,H\"", "sq": "Lexon një numër të plotë dhe një karakter, pastaj i kthen ato si një varg i formatuar i ndarë me presje.\n\nParametrat:\n- integer_value (int): Numri i plotë i dhënë si hyrje.\n- char_value (char): Karakteri i dhënë si hyrje.\n\nKthen:\n- char*: Një varg që përmban numrin e plotë dhe karakterin e ndarë me presje.\n\nShembull:\nf_24(234, 'H') kthen \"234,H\"", "hy": "Կարդում է ամբողջ թիվ և սիմվոլ, ապա վերադարձնում է դրանք որպես ձևաչափված տող, որոնք բաժանված են ստորակետով։\n\nՊարամետրեր:\n- integer_value (int): Մուտքային ամբողջ թիվը։\n- char_value (char): Մուտքային սիմվոլը։\n\nՎերադարձնում է:\n- char*: Տող, որը պարունակում է ամբողջ թիվը և սիմվոլը, բաժանված ստորակետով։\n\nՕրինակ:\nf_24(234, 'H') վերադարձնում է \"234,H\"", "bn": "একটি পূর্ণসংখ্যা এবং একটি চরিত্র পড়ে, তারপর সেগুলিকে একটি কমা দ্বারা পৃথক করা ফরম্যাট করা স্ট্রিং হিসাবে ফেরত দেয়।\n\nপ্যারামিটার:\n- integer_value (int): ইনপুট পূর্ণসংখ্যা।\n- char_value (char): ইনপুট চরিত্র।\n\nফেরত:\n- char*: একটি স্ট্রিং যা পূর্ণসংখ্যা এবং চরিত্রকে একটি কমা দ্বারা পৃথক করে ধারণ করে।\n\nউদাহরণ:\nf_24(234, 'H') \"234,H\" ফেরত দেয়।", "bg": "Чете цяло число и символ, след което ги връща като форматиран низ, разделен със запетая.\n\nПараметри:\n- integer_value (int): Входното цяло число.\n- char_value (char): Входният символ.\n\nВръща:\n- char*: Низ, съдържащ цялото число и символа, разделени със запетая.\n\nПример:\nf_24(234, 'H') връща \"234,H\"", "zh": "读取一个整数和一个字符，然后将它们作为用逗号分隔的格式化字符串返回。\n\n参数：\n- integer_value (int): 输入的整数。\n- char_value (char): 输入的字符。\n\n返回：\n- char*: 一个包含整数和字符并用逗号分隔的字符串。\n\n示例：\nf_24(234, 'H') 返回 \"234,H\"", "fr": "Lit un entier et un caractère, puis les renvoie sous forme de chaîne formatée séparée par une virgule.\n\nParamètres :\n- integer_value (int) : L'entier d'entrée.\n- char_value (char) : Le caractère d'entrée.\n\nRenvoie :\n- char* : Une chaîne contenant l'entier et le caractère séparés par une virgule.\n\nExemple :\nf_24(234, 'H') renvoie \"234,H\"", "de": "Liest eine ganze Zahl und ein Zeichen ein und gibt sie als formatierten String getrennt durch ein Komma zurück.\n\nParameter:\n- integer_value (int): Die Eingabe-Ganzzahl.\n- char_value (char): Das Eingabe-Zeichen.\n\nRückgabe:\n- char*: Ein String, der die Ganzzahl und das Zeichen durch ein Komma getrennt enthält.\n\nBeispiel:\nf_24(234, 'H') gibt \"234,H\" zurück.", "ha": "Karanta wata lamba da wata alama, sannan ya mayar da su a matsayin wani tsari na rubutu da aka raba su da alamar kwafa.\n\nSigogi:\n- integer_value (int): Lambar shigarwa.\n- char_value (char): Alamar shigarwa.\n\nDawowa:\n- char*: Wani rubutu da ke dauke da lambar da alamar da aka raba su da alamar kwafa.\n\nMisali:\nf_24(234, 'H') yana dawowa \"234,H\"", "hi": "एक पूर्णांक और एक वर्ण पढ़ता है, फिर उन्हें अल्पविराम से अलग किए गए स्वरूपित स्ट्रिंग के रूप में लौटाता है।\n\nमापदंड:\n- integer_value (int): इनपुट पूर्णांक।\n- char_value (char): इनपुट वर्ण।\n\nवापसी:\n- char*: एक स्ट्रिंग जिसमें पूर्णांक और वर्ण अल्पविराम से अलग किए गए हैं।\n\nउदाहरण:\nf_24(234, 'H') returns \"234,H\"", "hu": "Beolvas egy egész számot és egy karaktert, majd visszaadja őket egy formázott karakterláncként, vesszővel elválasztva.\n\nParaméterek:\n- integer_value (int): A bemeneti egész szám.\n- char_value (char): A bemeneti karakter.\n\nVisszatérési érték:\n- char*: Egy karakterlánc, amely az egész számot és a karaktert tartalmazza, vesszővel elválasztva.\n\nPélda:\nf_24(234, 'H') visszaadja \"234,H\"", "es": "Lee un entero y un carácter, luego los devuelve como una cadena formateada separada por una coma.\n\nParámetros:\n- integer_value (int): El entero de entrada.\n- char_value (char): El carácter de entrada.\n\nDevuelve:\n- char*: Una cadena que contiene el entero y el carácter separados por una coma.\n\nEjemplo:\nf_24(234, 'H') devuelve \"234,H\"", "arb": "يقرأ عددًا صحيحًا وحرفًا، ثم يعيدهما كسلسلة منسقة مفصولة بفاصلة.\n\nالمعلمات:\n- integer_value (int): العدد الصحيح المدخل.\n- char_value (char): الحرف المدخل.\n\nالقيم المعادة:\n- char*: سلسلة تحتوي على العدد الصحيح والحرف مفصولين بفاصلة.\n\nمثال:\nf_24(234, 'H') يعيد \"234,H\"", "sw": "Husoma nambari kamili na herufi, kisha inazirejesha kama kamba iliyopangwa iliyotenganishwa na koma.\n\nVigezo:\n- integer_value (int): Nambari kamili ya ingizo.\n- char_value (char): Herufi ya ingizo.\n\nInarejesha:\n- char*: Kamba inayojumuisha nambari kamili na herufi iliyotenganishwa na koma.\n\nMfano:\nf_24(234, 'H') inarejesha \"234,H\"", "tr": "Bir tam sayı ve bir karakter okur, ardından bunları virgülle ayrılmış biçimlendirilmiş bir dize olarak döndürür.\n\nParametreler:\n- integer_value (int): Girdi tam sayısı.\n- char_value (char): Girdi karakteri.\n\nDöndürür:\n- char*: Tam sayı ve karakteri virgülle ayırarak içeren bir dize.\n\nÖrnek:\nf_24(234, 'H') \"234,H\" döndürür.", "vi": "Đọc một số nguyên và một ký tự, sau đó trả về chúng dưới dạng một chuỗi định dạng được phân tách bằng dấu phẩy.\n\nTham số:\n- integer_value (int): Số nguyên đầu vào.\n- char_value (char): Ký tự đầu vào.\n\nTrả về:\n- char*: Một chuỗi chứa số nguyên và ký tự được phân tách bằng dấu phẩy.\n\nVí dụ:\nf_24(234, 'H') trả về \"234,H\"", "id": "Membaca sebuah bilangan bulat dan sebuah karakter, kemudian mengembalikannya sebagai string berformat yang dipisahkan oleh koma.\n\nParameter:\n- integer_value (int): Bilangan bulat yang diinput.\n- char_value (char): Karakter yang diinput.\n\nMengembalikan:\n- char*: Sebuah string yang berisi bilangan bulat dan karakter yang dipisahkan oleh koma.\n\nContoh:\nf_24(234, 'H') mengembalikan \"234,H\"", "ja": "整数と文字を読み取り、それらをカンマで区切ったフォーマットされた文字列として返します。\n\n引数:\n- integer_value (int): 入力された整数。\n- char_value (char): 入力された文字。\n\n戻り値:\n- char*: 整数と文字をカンマで区切った文字列。\n\n例:\nf_24(234, 'H') は \"234,H\" を返します。", "ko": "정수와 문자를 읽고, 쉼표로 구분된 형식의 문자열로 반환합니다.\n\n매개변수:\n- integer_value (int): 입력 정수.\n- char_value (char): 입력 문자.\n\n반환:\n- char*: 정수와 문자가 쉼표로 구분된 문자열.\n\n예제:\nf_24(234, 'H') returns \"234,H\"", "ml": "ഒരു പൂർണ്ണസംഖ്യയും ഒരു അക്ഷരവും വായിച്ച് അവയെ കോമയാൽ വേർതിരിച്ച ഫോർമാറ്റുചെയ്ത സ്ട്രിംഗ് ആയി മടക്കിക്കൊടുക്കുന്നു..\n\nപാരാമീറ്ററുകൾ:\n- integer_value (int): ഇൻപുട്ട് പൂർണ്ണസംഖ്യ.\n- char_value (char): ഇൻപുട്ട് അക്ഷരം.\n\nമടക്കുന്നു:\n- char*: പൂർണ്ണസംഖ്യയും അക്ഷരവും കോമയാൽ വേർതിരിച്ചുള്ള ഒരു സ്ട്രിംഗ്.\n\nഉദാഹരണം:\nf_24(234, 'H') മടക്കുന്നു \"234,H\"", "fa": "یک عدد صحیح و یک کاراکتر را می‌خواند، سپس آن‌ها را به صورت یک رشته قالب‌بندی شده که با کاما جدا شده‌اند، برمی‌گرداند.\n\nپارامترها:\n- integer_value (int): عدد صحیح ورودی.\n- char_value (char): کاراکتر ورودی.\n\nبرمی‌گرداند:\n- char*: یک رشته که شامل عدد صحیح و کاراکتر است که با کاما جدا شده‌اند.\n\nمثال:\nf_24(234, 'H') برمی‌گرداند \"234,H\""}}
{"task_id": "CPP/25", "prompt": {"en": "#include <bits/stdc++.h>\n/*\nShifts all characters by 5 positions in alphabetical order. Only letters are replaced,\nand all letters are in uppercase.\n\nParameters:\ntext (std::string&): The input text to be processed, modified in place.\n\nReturns:\nstd::string&: The transformed text with characters shifted by 5 positions.\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nstd::string& f_25(std::string& text)", "sq": "#include <bits/stdc++.h>\n/*\nZhvendos të gjitha karakteret me 5 pozicione në rend alfabetik. Vetëm shkronjat zëvendësohen,\ndhe të gjitha shkronjat janë me shkronja të mëdha.\n\nParametrat:\ntext (std::string&): Teksti hyrës që do të përpunohet, modifikohet në vend.\n\nKthen:\nstd::string&: Teksti i transformuar me karaktere të zhvendosura me 5 pozicione.\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nstd::string& f_25(std::string& text)", "hy": "#include <bits/stdc++.h>\n/*\nՏեղափոխում է բոլոր տառերը 5 դիրքով այբբենական կարգով: Միայն տառերն են փոխարինվում,\nև բոլոր տառերը մեծատառ են:\n\nՊարամետրեր:\ntext (std::string&): Մուտքային տեքստը, որը պետք է մշակվի, փոփոխվում է տեղում:\n\nՎերադարձնում է:\nstd::string&: Փոխակերպված տեքստը, որի տառերը տեղափոխված են 5 դիրքով:\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nstd::string& f_25(std::string& text)", "bn": "#include <bits/stdc++.h>\n/*\nবর্ণানুক্রমিক ক্রমে সমস্ত অক্ষরকে ৫টি অবস্থানে স্থানান্তরিত করে। শুধুমাত্র অক্ষরগুলি প্রতিস্থাপিত হয়,\nএবং সমস্ত অক্ষর বড় হাতের।\n\nপ্যারামিটার:\ntext (std::string&): প্রক্রিয়াকরণের জন্য ইনপুট টেক্সট, যা স্থানেই পরিবর্তিত হয়।\n\nফেরত দেয়:\nstd::string&: রূপান্তরিত টেক্সট যার অক্ষরগুলি ৫টি অবস্থানে স্থানান্তরিত হয়েছে।\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nstd::string& f_25(std::string& text)", "bg": "#include <bits/stdc++.h>\n/*\nПремества всички символи с 5 позиции в азбучен ред. Само буквите се заменят,\nи всички букви са с главни букви.\n\nПараметри:\ntext (std::string&): Входният текст, който ще бъде обработен, модифициран на място.\n\nВръща:\nstd::string&: Трансформираният текст със символи, преместени с 5 позиции.\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nstd::string& f_25(std::string& text)", "zh": "#include <bits/stdc++.h>\n/*\n将所有字符在字母顺序中移动5个位置。仅替换字母，且所有字母均为大写。\n\n参数：\ntext (std::string&): 要处理的输入文本，直接修改。\n\n返回：\nstd::string&: 字符移动了5个位置的转换后文本。\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nstd::string& f_25(std::string& text)", "fr": "#include <bits/stdc++.h>\n/*\nDécale tous les caractères de 5 positions dans l'ordre alphabétique. Seules les lettres sont remplacées,\net toutes les lettres sont en majuscules.\n\nParamètres :\ntext (std::string&): Le texte d'entrée à traiter, modifié sur place.\n\nRetourne :\nstd::string&: Le texte transformé avec les caractères décalés de 5 positions.\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nstd::string& f_25(std::string& text)", "de": "#include <bits/stdc++.h>\n/*\nVerschiebt alle Zeichen um 5 Positionen in alphabetischer Reihenfolge. Nur Buchstaben werden ersetzt,\nund alle Buchstaben sind in Großbuchstaben.\n\nParameter:\ntext (std::string&): Der Eingabetext, der verarbeitet und vor Ort modifiziert wird.\n\nRückgabewert:\nstd::string&: Der transformierte Text mit um 5 Positionen verschobenen Zeichen.\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nstd::string& f_25(std::string& text)", "ha": "#include <bits/stdc++.h>\n/*\nYa matsar da duk haruffa da matsayi 5 a cikin tsarin haruffa. Ana maye gurbin haruffa kawai,\nkuma duk haruffa suna cikin manyan baƙaƙe.\n\nSigogi:\ntext (std::string&): Rubutun shigarwa da za a sarrafa, an gyara shi a wurin.\n\nDawowa:\nstd::string&: Rubutun da aka canza tare da haruffa da aka matsar da matsayi 5.\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nstd::string& f_25(std::string& text)", "hi": "#include <bits/stdc++.h>\n/*\nसभी वर्णों को वर्णमाला क्रम में 5 स्थानों से स्थानांतरित करता है। केवल अक्षरों को बदला जाता है,\nऔर सभी अक्षर बड़े अक्षरों में होते हैं।\n\nपैरामीटर्स:\ntext (std::string&): इनपुट टेक्स्ट जिसे संसाधित किया जाना है, स्थान पर संशोधित किया गया।\n\nरिटर्न्स:\nstd::string&: परिवर्तित टेक्स्ट जिसमें वर्ण 5 स्थानों से स्थानांतरित होते हैं।\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nstd::string& f_25(std::string& text)", "hu": "#include <bits/stdc++.h>\n/*\nMinden karaktert 5 pozícióval eltol az ábécében. Csak a betűk kerülnek cserére,\nés minden betű nagybetűs.\n\nParaméterek:\ntext (std::string&): A feldolgozandó bemeneti szöveg, amely helyben módosul.\n\nVisszatér:\nstd::string&: Az átalakított szöveg, amelynek karakterei 5 pozícióval eltolódtak.\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nstd::string& f_25(std::string& text)", "es": "#include <bits/stdc++.h>\n/*\nDesplaza todos los caracteres 5 posiciones en orden alfabético. Solo se reemplazan las letras,\ny todas las letras están en mayúsculas.\n\nParámetros:\ntext (std::string&): El texto de entrada a procesar, modificado en su lugar.\n\nDevuelve:\nstd::string&: El texto transformado con caracteres desplazados 5 posiciones.\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nstd::string& f_25(std::string& text)", "arb": "#include <bits/stdc++.h>\n/*\nينقل جميع الأحرف بمقدار 5 مواقع في الترتيب الأبجدي. يتم استبدال الأحرف فقط،\nوجميع الأحرف تكون بحروف كبيرة.\n\nالمعلمات:\ntext (std::string&): النص المدخل ليتم معالجته، يتم تعديله في مكانه.\n\nيعيد:\nstd::string&: النص المحول مع الأحرف المنقولة بمقدار 5 مواقع.\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nstd::string& f_25(std::string& text)", "sw": "#include <bits/stdc++.h>\n/*\nInasogeza herufi zote kwa nafasi 5 katika mpangilio wa alfabeti. Ni herufi pekee zinazobadilishwa,\nna herufi zote ni za herufi kubwa.\n\nVigezo:\ntext (std::string&): Maandishi ya kuingiza yatakayoshughulikiwa, yanabadilishwa papo hapo.\n\nInarudisha:\nstd::string&: Maandishi yaliyobadilishwa na herufi zilizohamishwa kwa nafasi 5.\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nstd::string& f_25(std::string& text)", "tr": "#include <bits/stdc++.h>\n/*\nAlfabetik sırada tüm karakterleri 5 pozisyon kaydırır. Sadece harfler değiştirilir\nve tüm harfler büyük harfle yazılır.\n\nParametreler:\ntext (std::string&): İşlenecek giriş metni, yerinde değiştirilir.\n\nDöndürür:\nstd::string&: Karakterleri 5 pozisyon kaydırılmış dönüştürülmüş metin.\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nstd::string& f_25(std::string& text)", "vi": "#include <bits/stdc++.h>\n/*\nDịch chuyển tất cả các ký tự 5 vị trí trong thứ tự bảng chữ cái. Chỉ các chữ cái được thay thế,\nvà tất cả các chữ cái đều ở dạng chữ hoa.\n\nTham số:\ntext (std::string&): Văn bản đầu vào cần được xử lý, được sửa đổi tại chỗ.\n\nTrả về:\nstd::string&: Văn bản đã được biến đổi với các ký tự dịch chuyển 5 vị trí.\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nstd::string& f_25(std::string& text)", "id": "#include <bits/stdc++.h>\n/*\nMenggeser semua karakter sebanyak 5 posisi dalam urutan alfabet. Hanya huruf yang diganti,\ndan semua huruf dalam huruf besar.\n\nParameter:\ntext (std::string&): Teks masukan yang akan diproses, dimodifikasi di tempat.\n\nMengembalikan:\nstd::string&: Teks yang telah diubah dengan karakter digeser sebanyak 5 posisi.\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nstd::string& f_25(std::string& text)", "ja": "#include <bits/stdc++.h>\n/*\nアルファベット順で全ての文字を5文字分シフトします。文字のみが置き換えられ、\n全ての文字は大文字です。\n\nパラメータ:\ntext (std::string&): 処理される入力テキスト。インプレースで修正されます。\n\n戻り値:\nstd::string&: 文字が5文字分シフトされた変換後のテキスト。\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nstd::string& f_25(std::string& text)\n", "ko": "#include <bits/stdc++.h>\n/*\n알파벳 순서에서 모든 문자를 5자리씩 이동시킵니다. 문자만 대체되며,\n모든 문자는 대문자입니다.\n\n매개변수:\ntext (std::string&): 처리할 입력 텍스트로, 제자리에서 수정됩니다.\n\n반환값:\nstd::string&: 문자가 5자리씩 이동된 변환된 텍스트입니다.\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nstd::string& f_25(std::string& text)\n", "ml": "#include <bits/stdc++.h>\n/*\nഎല്ലാ അക്ഷരങ്ങളും അക്ഷരമാല ക്രമത്തിൽ 5 സ്ഥാനങ്ങൾ മാറ്റുന്നു. അക്ഷരങ്ങൾ മാത്രമേ മാറ്റപ്പെടുകയുള്ളൂ,\nഎല്ലാ അക്ഷരങ്ങളും വലിയക്ഷരങ്ങളായിരിക്കും.\n\nപാരാമീറ്ററുകൾ:\ntext (std::string&): പ്രോസസ്സ് ചെയ്യേണ്ട ഇൻപുട്ട് ടെക്സ്റ്റ്, സ്ഥലത്ത് തന്നെ മാറ്റം വരുത്തുന്നു.\n\nമടക്കിക്കൊടുക്കുന്നു:\nstd::string&: 5 സ്ഥാനങ്ങൾ മാറ്റിയ അക്ഷരങ്ങളുള്ള പരിവർത്തിത ടെക്സ്റ്റ്.\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nstd::string& f_25(std::string& text)", "fa": "#include <bits/stdc++.h>\n/*\nتمام حروف را به اندازه 5 موقعیت در ترتیب الفبایی جابجا می‌کند. فقط حروف جایگزین می‌شوند\nو همه حروف به صورت حروف بزرگ هستند.\n\nپارامترها:\ntext (std::string&): متن ورودی که باید پردازش شود، به صورت درجا تغییر می‌کند.\n\nبازگشت:\nstd::string&: متن تغییر یافته با حروفی که به اندازه 5 موقعیت جابجا شده‌اند.\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nstd::string& f_25(std::string& text)"}, "canonical_solution": "{\n    size_t len = text.length();\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}", "instruction": {"en": "std::string& f_25(std::string& text)\n{\n    size_t len = text.length();\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.", "sq": "std::string& f_25(std::string& text)\n{\n    size_t len = text.length();\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrale (docstring) të kodit CPP në shqip duke përdorur maksimumi 500 karaktere.", "hy": "std::string& f_25(std::string& text)\n{\n    size_t len = text.length();\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}\n\nՏվեք CPP կոդի հակիրճ բնական լեզվով նկարագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "std::string& f_25(std::string& text)\n{\n    size_t len = text.length();\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}\n\nসিপিপি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।", "bg": "std::string& f_25(std::string& text)\n{\n    size_t len = text.length();\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}\n\nПредоставете кратко описание на CPP кода на естествен език (docstring) на български, използвайки най-много 500 знака.", "zh": "std::string& f_25(std::string& text)\n{\n    size_t len = text.length();\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}\n\n请用不超过500个字符的中文提供对该CPP代码的简洁自然语言描述（文档字符串）。", "fr": "std::string& f_25(std::string& text)\n{\n    size_t len = text.length();\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}\n\nFournissez une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.", "de": "std::string& f_25(std::string& text)\n{\n    size_t len = text.length();\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen.", "ha": "std::string& f_25(std::string& text)\n{\n    size_t len = text.length();\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}\n\nBa da takaitaccen bayanin harshe na halitta (docstring) na lambar CPP cikin Hausa ta amfani da haruffa 500 kacal.", "hi": "std::string& f_25(std::string& text)\n{\n    size_t len = text.length();\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।", "hu": "std::string& f_25(std::string& text)\n{\n    size_t len = text.length();\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a CPP kódról magyarul, legfeljebb 500 karakterben.", "es": "std::string& f_25(std::string& text)\n{\n    size_t len = text.length();\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando como máximo 500 caracteres.", "arb": "std::string& f_25(std::string& text)\n{\n    size_t len = text.length();\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C++ باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "std::string& f_25(std::string& text)\n{\n    size_t len = text.length();\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "std::string& f_25(std::string& text)\n{\n    size_t len = text.length();\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}\n\nAşağıdaki CPP kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda, özlü bir doğal dil açıklaması (docstring) sağlayın.", "vi": "std::string& f_25(std::string& text)\n{\n    size_t len = text.length();\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt, sử dụng tối đa 500 ký tự.", "id": "std::string& f_25(std::string& text)\n{\n    size_t len = text.length();\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode CPP dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "std::string& f_25(std::string& text)\n{\n    size_t len = text.length();\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}\n\n以下のCPPコードの簡潔な自然言語による説明（ドックストリング）を日本語で500文字以内で提供してください。", "ko": "std::string& f_25(std::string& text)\n{\n    size_t len = text.length();\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}\n\n다음 CPP 코드에 대한 간결한 자연어 설명(도크스트링)을 한국어로 최대 500자 이내로 제공하세요.", "ml": "std::string& f_25(std::string& text)\n{\n    size_t len = text.length();\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}\n\nCPP കോഡ് സംബന്ധിച്ച സംക്ഷിപ്തമായ ഒരു സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) പരമാവധി 500 അക്ഷരങ്ങൾ ഉപയോഗിച്ച് മലയാളത്തിൽ നൽകുക.", "fa": "std::string& f_25(std::string& text)\n{\n    size_t len = text.length();\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}\n\nتوضیحات مختصر به زبان طبیعی (docstring) از کد CPP به زبان فارسی ارائه دهید که حداکثر ۵۰۰ کاراکتر باشد."}, "level": "", "test": "int main()\n{\n    std::string test1 = \"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\";\n    std::string test2 = \"N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ\";\n    std::string test3 = \"IFSLJW PSTBX KZQQ BJQQ YMFY HFJXFW NX RTWJ IFSLJWTZX YMFS MJ\";\n\n    assert(f_25(test1) == \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\");\n    assert(f_25(test2) == \"I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME\");\n    assert(f_25(test3) == \"DANGER KNOWS FULL WELL THAT CAESAR IS MORE DANGEROUS THAN HE\");\n    return 0;\n}", "entry_point": "f_25", "signature": "std::string& f_25(std::string& text)", "docstring": {"en": "Shifts all characters by 5 positions in alphabetical order. Only letters are replaced, and all letters are in uppercase.\n\nParameters:\ntext (std::string&): The input text to be processed, modified in place.\n\nReturns:\nstd::string&: The transformed text with characters shifted by 5 positions.\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n", "sq": "Zhvendos të gjitha karakteret me 5 pozicione në rend alfabetik. Vetëm shkronjat zëvendësohen, dhe të gjitha shkronjat janë me shkronja të mëdha.\n\nParametrat:\ntext (std::string&): Teksti hyrës që do të përpunohet, modifikohet në vend.\n\nKthen:\nstd::string&: Teksti i transformuar me karaktere të zhvendosura me 5 pozicione.\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "hy": "Տեղաշարժում է բոլոր տառերը 5 դիրքով այբենական կարգով: Միայն տառերն են փոխարինվում, և բոլոր տառերը մեծատառ են:\n\nՊարամետրեր:\ntext (std::string&): Մուտքային տեքստը, որը պետք է մշակվի, փոփոխվում է տեղում:\n\nՎերադարձնում է:\nstd::string&: Փոխակերպված տեքստը, որտեղ տառերը տեղաշարժված են 5 դիրքով:\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "bn": "বর্ণানুক্রমিক ক্রমে সমস্ত অক্ষরকে ৫ অবস্থানে স্থানান্তর করে। শুধুমাত্র অক্ষরগুলি প্রতিস্থাপিত হয়, এবং সমস্ত অক্ষর বড় হাতের হয়।\n\nপ্যারামিটার:\ntext (std::string&): প্রক্রিয়াকরণের জন্য ইনপুট টেক্সট, যা স্থানে পরিবর্তিত হয়।\n\nরিটার্নস:\nstd::string&: পরিবর্তিত টেক্সট যেখানে অক্ষরগুলি ৫ অবস্থানে স্থানান্তরিত হয়েছে।\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "bg": "Измества всички знаци с 5 позиции в азбучен ред. Само буквите се заменят и всички букви са с главни букви.\n\nПараметри:\ntext (std::string&): Входният текст, който ще бъде обработен, модифициран на място.\n\nВръща:\nstd::string&: Преобразуваният текст със знаци, изместени с 5 позиции.\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "zh": "将所有字符在字母表中移动5个位置。仅替换字母，且所有字母均为大写。\n\n参数：\ntext (std::string&): 要处理的输入文本，原地修改。\n\n返回：\nstd::string&: 字符移动5个位置后的转换文本。\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "fr": "Décale tous les caractères de 5 positions dans l'ordre alphabétique. Seules les lettres sont remplacées, et toutes les lettres sont en majuscules.\n\nParamètres :\ntext (std::string&) : Le texte d'entrée à traiter, modifié sur place.\n\nRenvoie :\nstd::string& : Le texte transformé avec les caractères décalés de 5 positions.\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "de": "Verschiebt alle Zeichen um 5 Positionen in alphabetischer Reihenfolge. Nur Buchstaben werden ersetzt, und alle Buchstaben sind in Großbuchstaben.\n\nParameter:\ntext (std::string&): Der zu verarbeitende Eingabetext, der vor Ort modifiziert wird.\n\nRückgabewert:\nstd::string&: Der transformierte Text mit um 5 Positionen verschobenen Zeichen.\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "ha": "Canza duk haruffa ta wurin matsar da su wurare 5 a cikin tsarin haruffa. Haruffa kawai ake maye gurbinsu, kuma duk haruffa suna cikin manyan baki.\n\nSigogi:\ntext (std::string&): Rubutun shigar da za a sarrafa, a gyara a wurin.\n\nDawowa:\nstd::string&: Rubutun da aka canza tare da haruffa da aka matsar da matsayi 5.\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "hi": "अक्षरों को वर्णमाला क्रम में 5 स्थानों से स्थानांतरित करता है। केवल अक्षरों को बदला जाता है, और सभी अक्षर बड़े अक्षरों में होते हैं।\n\nपैरामीटर्स:\ntext (std::string&): इनपुट टेक्स्ट जिसे संसाधित किया जाना है, स्थान पर ही संशोधित किया जाता है।\n\nवापसी:\nstd::string&: परिवर्तित टेक्स्ट जिसमें अक्षर 5 स्थानों से स्थानांतरित होते हैं।\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "hu": "Az összes karaktert 5 pozícióval eltolja az ábécében. Csak a betűk kerülnek cserére, és minden betű nagybetűs.\n\nParaméterek:\ntext (std::string&): A feldolgozandó bemeneti szöveg, amely helyben módosul.\n\nVisszatérési érték:\nstd::string&: Az átalakított szöveg, amelyben a karakterek 5 pozícióval eltolódtak.\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "es": "Desplaza todos los caracteres 5 posiciones en orden alfabético. Solo se reemplazan letras, y todas las letras están en mayúsculas.\n\nParámetros:\ntext (std::string&): El texto de entrada a procesar, modificado en su lugar.\n\nDevuelve:\nstd::string&: El texto transformado con caracteres desplazados 5 posiciones.\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "arb": "ينقل جميع الأحرف بمقدار 5 مواقع في الترتيب الأبجدي. يتم استبدال الأحرف فقط، وجميع الأحرف تكون بأحرف كبيرة.\n\nالمعلمات:\ntext (std::string&): النص المدخل ليتم معالجته، يتم تعديله في مكانه.\n\nالقيم المعادة:\nstd::string&: النص المحول مع الأحرف المنقولة بمقدار 5 مواقع.\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "sw": "Hubadilisha herufi zote kwa nafasi 5 katika mpangilio wa alfabeti. Ni herufi pekee ndizo hubadilishwa, na herufi zote ziko katika herufi kubwa.\n\nVigezo:\ntext (std::string&): Maandishi ya ingizo yatakayoshughulikiwa, yanabadilishwa papo hapo.\n\nInarejesha:\nstd::string&: Maandishi yaliyobadilishwa na herufi zilizohamishwa kwa nafasi 5.\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "tr": "Alfabetik sırada tüm karakterleri 5 pozisyon kaydırır. Yalnızca harfler değiştirilir ve tüm harfler büyük harfle yazılır.\n\nParametreler:\ntext (std::string&): İşlenecek giriş metni, yerinde değiştirilir.\n\nDöndürür:\nstd::string&: Karakterleri 5 pozisyon kaydırılmış dönüştürülmüş metin.\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "vi": "Dịch chuyển tất cả các ký tự lên 5 vị trí theo thứ tự bảng chữ cái. Chỉ các chữ cái được thay thế, và tất cả các chữ cái đều ở dạng chữ hoa.\n\nTham số:\ntext (std::string&): Văn bản đầu vào cần được xử lý, được sửa đổi tại chỗ.\n\nTrả về:\nstd::string&: Văn bản đã được biến đổi với các ký tự dịch chuyển lên 5 vị trí.\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "id": "Menggeser semua karakter sebanyak 5 posisi dalam urutan alfabet. Hanya huruf yang diganti, dan semua huruf dalam huruf besar.\n\nParameter:\ntext (std::string&): Teks masukan yang akan diproses, dimodifikasi di tempat.\n\nMengembalikan:\nstd::string&: Teks yang telah diubah dengan karakter digeser sebanyak 5 posisi.\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "ja": "アルファベット順で全ての文字を5つの位置ずらします。文字のみが置き換えられ、すべての文字は大文字です。\n\nパラメータ:\ntext (std::string&): 処理される入力テキストで、その場で変更されます。\n\n戻り値:\nstd::string&: 文字が5つの位置ずらされた変換されたテキスト。\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "ko": "알파벳 순서에서 모든 문자를 5자리씩 이동시킵니다. 문자만 대체되며, 모든 문자는 대문자로 표시됩니다.\n\n매개변수:\ntext (std::string&): 처리할 입력 텍스트로, 제자리에서 수정됩니다.\n\n반환:\nstd::string&: 문자가 5자리씩 이동된 변환된 텍스트입니다.\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "ml": "അക്ഷരമാല ക്രമത്തിൽ എല്ലാ അക്ഷരങ്ങളും 5 സ്ഥാനങ്ങൾ മാറ്റുന്നു. അക്ഷരങ്ങൾ മാത്രമേ മാറ്റപ്പെടുകയുള്ളൂ, എല്ലാ അക്ഷരങ്ങളും വലുതായിരിക്കും.\n\nപാരാമീറ്ററുകൾ:\ntext (std::string&): പ്രോസസ്സ് ചെയ്യപ്പെടേണ്ട, സ്ഥലത്ത് തന്നെ മാറ്റം വരുത്തപ്പെടുന്ന ഇൻപുട്ട് ടെക്സ്റ്റ്.\n\nമടക്കം:\nstd::string&: 5 സ്ഥാനങ്ങൾ മാറ്റിയ അക്ഷരങ്ങളുള്ള പരിവർത്തിത ടെക്സ്റ്റ്.\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "fa": "تمام کاراکترها را به اندازه ۵ موقعیت در ترتیب حروف الفبا جابجا می‌کند. تنها حروف جایگزین می‌شوند و تمام حروف به صورت بزرگ هستند.\n\nپارامترها:\ntext (std::string&): متن ورودی که باید پردازش شود و به صورت درجا تغییر یابد.\n\nبازگشت:\nstd::string&: متن تغییر یافته با کاراکترهایی که به اندازه ۵ موقعیت جابجا شده‌اند.\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\""}}
{"task_id": "CPP/26", "prompt": {"en": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Classify the integer x based on the following method:\n * If x is a single-digit number, x belongs to its own class.\n * Otherwise, sum the digits of x, get a new x, and iterate until \n * the class is determined.\n *\n * Parameters:\n * - x (const char*): The integer to be classified in string form.\n *\n * Returns:\n * int: The class to which the integer x belongs.\n *\n * Usage:\n * >>> f_26(\"24\")\n * 6\n */\nint f_26(const char *x)", "sq": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Klasifikoni numrin e plotë x bazuar në metodën e mëposhtme:\n * Nëse x është një numër njëshifror, x i përket klasës së vet.\n * Përndryshe, mblidhni shifrat e x, merrni një x të ri, dhe përsëritni derisa \n * klasa të përcaktohet.\n *\n * Parametrat:\n * - x (const char*): Numri i plotë që do të klasifikohet në formë stringu.\n *\n * Kthen:\n * int: Klasa së cilës i përket numri i plotë x.\n *\n * Përdorimi:\n * >>> f_26(\"24\")\n * 6\n */\nint f_26(const char *x)", "hy": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Դասակարգել ամբողջ թիվը x-ը հետևյալ մեթոդով.\n * Եթե x-ը միանիշ թիվ է, ապա x-ը պատկանում է իր սեփական դասին։\n * Հակառակ դեպքում, գումարել x-ի թվանշանները, ստանալ նոր x և կրկնել, մինչև \n * դասը որոշվի։\n *\n * Պարամետրեր:\n * - x (const char*): Դասակարգվող ամբողջ թիվը տողային ձևով։\n *\n * Վերադարձնում է:\n * int: Դասը, որին պատկանում է ամբողջ թիվը x-ը։\n *\n * Օգտագործում:\n * >>> f_26(\"24\")\n * 6\n */\nint f_26(const char *x)", "bn": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * নিম্নলিখিত পদ্ধতির ভিত্তিতে পূর্ণসংখ্যা x শ্রেণীবদ্ধ করুন:\n * যদি x এক অঙ্কের সংখ্যা হয়, তাহলে x তার নিজস্ব শ্রেণীতে অন্তর্ভুক্ত।\n * অন্যথায়, x এর অঙ্কগুলোর যোগফল নিন, একটি নতুন x পান এবং পুনরাবৃত্তি করুন যতক্ষণ না \n * শ্রেণী নির্ধারিত হয়।\n *\n * প্যারামিটার:\n * - x (const char*): স্ট্রিং আকারে শ্রেণীবদ্ধ করার জন্য পূর্ণসংখ্যা।\n *\n * রিটার্নস:\n * int: যে শ্রেণীতে পূর্ণসংখ্যা x অন্তর্ভুক্ত।\n *\n * ব্যবহার:\n * >>> f_26(\"24\")\n * 6\n */\nint f_26(const char *x)", "bg": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Класифицирайте цялото число x въз основа на следния метод:\n * Ако x е едноцифрено число, x принадлежи към своя собствен клас.\n * В противен случай, съберете цифрите на x, получете ново x и \n * итерайте, докато класът не бъде определен.\n *\n * Параметри:\n * - x (const char*): Цялото число, което ще бъде класифицирано, в стрингова форма.\n *\n * Връща:\n * int: Класът, към който принадлежи цялото число x.\n *\n * Употреба:\n * >>> f_26(\"24\")\n * 6\n */\nint f_26(const char *x)", "zh": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * 根据以下方法对整数 x 进行分类：\n * 如果 x 是一位数，x 属于它自己的类。\n * 否则，将 x 的各位数字相加，得到一个新的 x，并迭代直到确定类别。\n *\n * 参数：\n * - x (const char*): 需要分类的整数，字符串形式。\n *\n * 返回：\n * int: 整数 x 所属的类别。\n *\n * 用法：\n * >>> f_26(\"24\")\n * 6\n */\nint f_26(const char *x)", "fr": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Classifier l'entier x basé sur la méthode suivante :\n * Si x est un nombre à un seul chiffre, x appartient à sa propre classe.\n * Sinon, additionner les chiffres de x, obtenir un nouveau x, et itérer jusqu'à \n * ce que la classe soit déterminée.\n *\n * Paramètres :\n * - x (const char*): L'entier à classifier sous forme de chaîne de caractères.\n *\n * Renvoie :\n * int: La classe à laquelle appartient l'entier x.\n *\n * Utilisation :\n * >>> f_26(\"24\")\n * 6\n */\nint f_26(const char *x)", "de": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Klassifiziere die ganze Zahl x basierend auf der folgenden Methode:\n * Wenn x eine einstellige Zahl ist, gehört x zu seiner eigenen Klasse.\n * Andernfalls summiere die Ziffern von x, erhalte ein neues x und iteriere, \n * bis die Klasse bestimmt ist.\n *\n * Parameter:\n * - x (const char*): Die zu klassifizierende ganze Zahl in String-Form.\n *\n * Rückgabewert:\n * int: Die Klasse, zu der die ganze Zahl x gehört.\n *\n * Verwendung:\n * >>> f_26(\"24\")\n * 6\n */\nint f_26(const char *x)", "ha": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Rarraba lamba x bisa ga hanyar da ke biye:\n * Idan x lamba ce mai lamba guda ɗaya, x tana cikin ajinta na kanta.\n * In ba haka ba, tara lambobin x, sami sabon x, kuma maimaita har sai \n * an tantance ajin.\n *\n * Sigogi:\n * - x (const char*): Lambar da za a rarraba a cikin tsarin kirtani.\n *\n * Komawa:\n * int: Aji da lambar x take ciki.\n *\n * Amfani:\n * >>> f_26(\"24\")\n * 6\n */\nint f_26(const char *x)", "hi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * निम्नलिखित विधि के आधार पर पूर्णांक x को वर्गीकृत करें:\n * यदि x एकल-अंक संख्या है, तो x अपने स्वयं के वर्ग का है।\n * अन्यथा, x के अंकों का योग करें, एक नया x प्राप्त करें, और तब तक पुनरावृत्ति करें \n * जब तक कि वर्ग निर्धारित न हो जाए।\n *\n * पैरामीटर:\n * - x (const char*): पूर्णांक को स्ट्रिंग रूप में वर्गीकृत करने के लिए।\n *\n * लौटाता है:\n * int: वह वर्ग जिसमें पूर्णांक x आता है।\n *\n * उपयोग:\n * >>> f_26(\"24\")\n * 6\n */\nint f_26(const char *x)", "hu": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Osztályozza az egész számot x az alábbi módszer alapján:\n * Ha x egyjegyű szám, akkor x a saját osztályába tartozik.\n * Ellenkező esetben összeadja x számjegyeit, kap egy új x-et, és ismétli, \n * amíg az osztály meg nem határozódik.\n *\n * Paraméterek:\n * - x (const char*): Az egész szám, amelyet osztályozni kell, sztring formában.\n *\n * Visszatér:\n * int: Az osztály, amelyhez az egész szám x tartozik.\n *\n * Használat:\n * >>> f_26(\"24\")\n * 6\n */\nint f_26(const char *x)", "es": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Clasificar el entero x basado en el siguiente método:\n * Si x es un número de un solo dígito, x pertenece a su propia clase.\n * De lo contrario, suma los dígitos de x, obtiene un nuevo x, e itera hasta \n * que se determine la clase.\n *\n * Parámetros:\n * - x (const char*): El entero a clasificar en forma de cadena.\n *\n * Devuelve:\n * int: La clase a la que pertenece el entero x.\n *\n * Uso:\n * >>> f_26(\"24\")\n * 6\n */\nint f_26(const char *x)", "arb": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * صنف العدد الصحيح x بناءً على الطريقة التالية:\n * إذا كان x رقمًا مكونًا من رقم واحد، فإن x ينتمي إلى فئته الخاصة.\n * خلاف ذلك، اجمع أرقام x، واحصل على x جديد، وكرر حتى يتم تحديد الفئة.\n *\n * المعلمات:\n * - x (const char*): العدد الصحيح الذي سيتم تصنيفه في شكل سلسلة.\n *\n * يعيد:\n * int: الفئة التي ينتمي إليها العدد الصحيح x.\n *\n * الاستخدام:\n * >>> f_26(\"24\")\n * 6\n */\nint f_26(const char *x)", "sw": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Ainisha nambari x kulingana na njia ifuatayo:\n * Ikiwa x ni nambari ya tarakimu moja, x inamiliki darasa lake lenyewe.\n * Vinginevyo, jumlisha tarakimu za x, pata x mpya, na rudia hadi \n * darasa litakapobainishwa.\n *\n * Vigezo:\n * - x (const char*): Nambari inayopaswa kuainishwa katika umbo la kamba.\n *\n * Inarudisha:\n * int: Darasa ambalo nambari x inamiliki.\n *\n * Matumizi:\n * >>> f_26(\"24\")\n * 6\n */\nint f_26(const char *x)", "tr": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * x tam sayısını aşağıdaki yönteme göre sınıflandır:\n * Eğer x tek basamaklı bir sayı ise, x kendi sınıfına aittir.\n * Aksi takdirde, x'in basamaklarını topla, yeni bir x elde et ve \n * sınıf belirlenene kadar yinele.\n *\n * Parametreler:\n * - x (const char*): Sınıflandırılacak tam sayı, string formunda.\n *\n * Döndürür:\n * int: x tam sayısının ait olduğu sınıf.\n *\n * Kullanım:\n * >>> f_26(\"24\")\n * 6\n */\nint f_26(const char *x)", "vi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Phân loại số nguyên x dựa trên phương pháp sau:\n * Nếu x là một số có một chữ số, x thuộc về lớp của chính nó.\n * Ngược lại, tổng các chữ số của x, lấy một x mới, và lặp lại cho đến khi \n * lớp được xác định.\n *\n * Tham số:\n * - x (const char*): Số nguyên cần được phân loại dưới dạng chuỗi.\n *\n * Trả về:\n * int: Lớp mà số nguyên x thuộc về.\n *\n * Sử dụng:\n * >>> f_26(\"24\")\n * 6\n */\nint f_26(const char *x)", "id": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Klasifikasikan bilangan bulat x berdasarkan metode berikut:\n * Jika x adalah angka satu digit, x termasuk dalam kelasnya sendiri.\n * Jika tidak, jumlahkan digit-digit dari x, dapatkan x baru, dan iterasi sampai\n * kelas ditentukan.\n *\n * Parameter:\n * - x (const char*): Bilangan bulat yang akan diklasifikasikan dalam bentuk string.\n *\n * Mengembalikan:\n * int: Kelas di mana bilangan bulat x termasuk.\n *\n * Penggunaan:\n * >>> f_26(\"24\")\n * 6\n */\nint f_26(const char *x)\n", "ja": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * 整数 x を次の方法に基づいて分類します:\n * x が一桁の数字の場合、x はそれ自身のクラスに属します。\n * それ以外の場合、x の桁を合計し、新しい x を取得し、クラスが決定されるまで繰り返します。\n *\n * パラメータ:\n * - x (const char*): 文字列形式で分類される整数。\n *\n * 戻り値:\n * int: 整数 x が属するクラス。\n *\n * 使用例:\n * >>> f_26(\"24\")\n * 6\n */\nint f_26(const char *x)\n", "ko": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * 정수 x를 다음 방법에 따라 분류합니다:\n * x가 한 자리 숫자라면, x는 자신의 클래스에 속합니다.\n * 그렇지 않으면, x의 자릿수를 합산하여 새로운 x를 얻고, \n * 클래스가 결정될 때까지 반복합니다.\n *\n * 매개변수:\n * - x (const char*): 문자열 형태로 분류할 정수입니다.\n *\n * 반환값:\n * int: 정수 x가 속하는 클래스입니다.\n *\n * 사용 예:\n * >>> f_26(\"24\")\n * 6\n */\nint f_26(const char *x)\n", "ml": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * താഴെ കൊടുത്തിരിക്കുന്ന രീതിയിൽ പൂർണ്ണസംഖ്യ x-നെ വർഗ്ഗീകരിക്കുക:\n * x ഒറ്റ അക്ക സംഖ്യയായാൽ, x അതിന്റെ സ്വന്തം വർഗ്ഗത്തിൽ പെടുന്നു.\n * അല്ലാത്ത പക്ഷം, x-ന്റെ അക്കങ്ങൾ കൂട്ടിച്ചേർത്തു, പുതിയ x-നെ \n * ലഭ്യമാക്കി, വർഗ്ഗം നിർണ്ണയിക്കുന്നതുവരെ ആവർത്തിക്കുക.\n *\n * പാരാമീറ്ററുകൾ:\n * - x (const char*): പൂർണ്ണസംഖ്യയെ സ്ട്രിംഗ് രൂപത്തിൽ വർഗ്ഗീകരിക്കാനുള്ളത്.\n *\n * മടക്കുന്നു:\n * int: പൂർണ്ണസംഖ്യ x ഏത് വർഗ്ഗത്തിലാണ് പെടുന്നത്.\n *\n * ഉപയോഗം:\n * >>> f_26(\"24\")\n * 6\n */\nint f_26(const char *x)\n", "fa": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * عدد صحیح x را بر اساس روش زیر طبقه‌بندی کنید:\n * اگر x یک عدد یک رقمی باشد، x به کلاس خود تعلق دارد.\n * در غیر این صورت، ارقام x را جمع کنید، یک x جدید بگیرید و تکرار کنید تا \n * کلاس تعیین شود.\n *\n * پارامترها:\n * - x (const char*): عدد صحیحی که باید به صورت رشته طبقه‌بندی شود.\n *\n * بازگشت:\n * int: کلاسی که عدد صحیح x به آن تعلق دارد.\n *\n * استفاده:\n * >>> f_26(\"24\")\n * 6\n */\nint f_26(const char *x)\n"}, "canonical_solution": "{\n    int n = 0, i, a, t;\n    for (i = 0; i < std::strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}", "instruction": {"en": "int f_26(const char *x)\n{\n    int n = 0, i, a, t;\n    for (i = 0; i < std::strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.", "sq": "int f_26(const char *x)\n{\n    int n = 0, i, a, t;\n    for (i = 0; i < std::strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit CPP në shqip duke përdorur maksimumi 500 karaktere.", "hy": "int f_26(const char *x)\n{\n    int n = 0, i, a, t;\n    for (i = 0; i < std::strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}\n\nՏվեք CPP կոդի հակիրճ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։", "bn": "int f_26(const char *x)\n{\n    int n = 0, i, a, t;\n    for (i = 0; i < std::strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}\n\nসিপিপি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।", "bg": "int f_26(const char *x)\n{\n    int n = 0, i, a, t;\n    for (i = 0; i < std::strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}\n\nПредоставете кратко описание на CPP кода на български език, използвайки не повече от 500 символа.", "zh": "int f_26(const char *x)\n{\n    int n = 0, i, a, t;\n    for (i = 0; i < std::strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}\n\n请用不超过500个字符的中文，为以下CPP代码提供简洁的自然语言描述（文档字符串）。", "fr": "int f_26(const char *x)\n{\n    int n = 0, i, a, t;\n    for (i = 0; i < std::strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}\n\nFournissez une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.", "de": "int f_26(const char *x)\n{\n    int n = 0, i, a, t;\n    for (i = 0; i < std::strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "int f_26(const char *x)\n{\n    int n = 0, i, a, t;\n    for (i = 0; i < std::strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar CPP a cikin Hausa, ba tare da wucewa haruffa 500 ba.", "hi": "int f_26(const char *x)\n{\n    int n = 0, i, a, t;\n    for (i = 0; i < std::strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।", "hu": "int f_26(const char *x)\n{\n    int n = 0, i, a, t;\n    for (i = 0; i < std::strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}\n\nAdj meg egy tömör, természetes nyelvű leírást (docstring) a CPP kódhoz magyarul, legfeljebb 500 karakterben.", "es": "int f_26(const char *x)\n{\n    int n = 0, i, a, t;\n    for (i = 0; i < std::strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando como máximo 500 caracteres.", "arb": "int f_26(const char *x)\n{\n    int n = 0, i, a, t;\n    for (i = 0; i < std::strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية بلغة C++ باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.", "sw": "int f_26(const char *x)\n{\n    int n = 0, i, a, t;\n    for (i = 0; i < std::strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "int f_26(const char *x)\n{\n    int n = 0, i, a, t;\n    for (i = 0; i < std::strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}\n\nAşağıdaki CPP kodunun doğal dilde kısa bir açıklamasını (docstring) Türkçe olarak en fazla 500 karakter kullanarak sağlayın.", "vi": "int f_26(const char *x)\n{\n    int n = 0, i, a, t;\n    for (i = 0; i < std::strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự.", "id": "int f_26(const char *x)\n{\n    int n = 0, i, a, t;\n    for (i = 0; i < std::strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode CPP dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "int f_26(const char *x)\n{\n    int n = 0, i, a, t;\n    for (i = 0; i < std::strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}\n\nCPP コードの簡単な自然言語による説明 (docstring) を英語で最大 500 文字まで入力してください。", "ko": "int f_26(const char *x)\n{\n    int n = 0, i, a, t;\n    for (i = 0; i < std::strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}\n\n다음 CPP 코드에 대한 간결한 자연어 설명(도크스트링)을 한국어로 최대 500자 이내로 제공하세요.", "ml": "int f_26(const char *x)\n{\n    int n = 0, i, a, t;\n    for (i = 0; i < std::strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}\n\nCPP കോഡ് സംബന്ധിച്ച സംക്ഷിപ്തമായ സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) മലയാളത്തിൽ 500 അക്ഷരങ്ങളിൽ കൂടുതൽ ഉപയോഗിക്കാതെ നൽകുക.", "fa": "int f_26(const char *x)\n{\n    int n = 0, i, a, t;\n    for (i = 0; i < std::strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}\n\nتوضیح مختصر و طبیعی (docstring) از کد CPP را به زبان فارسی با حداکثر ۵۰۰ کاراکتر ارائه دهید."}, "level": "", "test": "int main() {\n    assert(f_26(\"24\") == 6);\n    assert(f_26(\"39\") == 3);\n    assert(f_26(\"123456789\") == 9);\n    assert(f_26(\"123456789012345678901234567890\") == 9);\n    assert(f_26(\"12345\") == 6);\n    assert(f_26(\"999999999\") == 9);\n    // std::printf(\"All tests passed successfully!\\n\");\n    return 0;\n}", "entry_point": "f_26", "signature": "int f_26(const char *x)", "docstring": {"en": "Classify the integer x based on the following method:\nIf x is a single-digit number, x belongs to its own class.\nOtherwise, sum the digits of x, get a new x, and iterate until the class is determined.\n\nParameters:\n- x (const char*): The integer to be classified in string form.\n\nReturns:\nint: The class to which the integer x belongs.\n\nUsage:\n>>> f_26(\"24\")\n6", "sq": "Klasifikoni numrin e plotë x bazuar në metodën e mëposhtme:\nNëse x është një numër njëshifror, x i përket klasës së vet.\nPërndryshe, mblidhni shifrat e x, merrni një x të ri dhe përsëritni derisa klasa të përcaktohet.\n\nParametrat:\n- x (const char*): Numri i plotë që do të klasifikohet në formë stringu.\n\nKthen:\nint: Klasa së cilës i përket numri i plotë x.\n\nPërdorimi:\n>>> f_26(\"24\")\n6", "hy": "Դասակարգեք ամբողջ թիվը x հետևյալ մեթոդով:\nԵթե x-ը միանիշ թիվ է, ապա x-ը պատկանում է իր սեփական դասին։\nՀակառակ դեպքում, գումարեք x-ի թվանշանները, ստացեք նոր x, և կրկնեք մինչև դասը որոշվի։\n\nՊարամետրեր:  \n- x (const char*): Թիվը, որը պետք է դասակարգվի տողի ձևով։\n\nՎերադարձնում է:  \nint: Դասը, որին պատկանում է թիվ x-ը։\n\nՕգտագործում:  \n>>> f_26(\"24\")  \n6", "bn": "ইন্টিজার x নিম্নলিখিত পদ্ধতির ভিত্তিতে শ্রেণীবদ্ধ করুন:\nযদি x একটি একক-অঙ্কের সংখ্যা হয়, তাহলে x তার নিজস্ব শ্রেণীতে অন্তর্ভুক্ত।\nঅন্যথায়, x এর অঙ্কগুলির যোগফল নিন, একটি নতুন x পান, এবং শ্রেণী নির্ধারিত না হওয়া পর্যন্ত পুনরাবৃত্তি করুন।\n\nপ্যারামিটার:\n- x (const char*): স্ট্রিং আকারে শ্রেণীবদ্ধ করার জন্য ইন্টিজার।\n\nরিটার্নস:\nint: যে শ্রেণীতে ইন্টিজার x অন্তর্ভুক্ত।\n\nব্যবহার:\n>>> f_26(\"24\")\n6", "bg": "Класифицирайте цялото число x въз основа на следния метод:\nАко x е едноцифрено число, x принадлежи към своя собствен клас.\nВ противен случай, съберете цифрите на x, получете ново x и итерайте, докато класът не бъде определен.\n\nПараметри:\n- x (const char*): Цялото число, което трябва да бъде класифицирано, във вид на низ.\n\nВръща:\nint: Класът, към който принадлежи цялото число x.\n\nУпотреба:\n>>> f_26(\"24\")\n6", "zh": "根据以下方法对整数 x 进行分类：\n如果 x 是一个个位数，则 x 属于它自己的类。\n否则，将 x 的各位数字相加，得到一个新的 x，并迭代直到确定类。\n\n参数：\n- x (const char*): 以字符串形式表示的要分类的整数。\n\n返回：\nint: 整数 x 所属的类。\n\n用法：\n>>> f_26(\"24\")\n6", "fr": "Classifiez l'entier x selon la méthode suivante :\nSi x est un nombre à un chiffre, x appartient à sa propre classe.\nSinon, additionnez les chiffres de x, obtenez un nouveau x, et itérez jusqu'à ce que la classe soit déterminée.\n\nParamètres :\n- x (const char*): L'entier à classer sous forme de chaîne de caractères.\n\nRenvoie :\nint : La classe à laquelle appartient l'entier x.\n\nUtilisation :\n>>> f_26(\"24\")\n6", "de": "Klassifizieren Sie die ganze Zahl x basierend auf der folgenden Methode:\nWenn x eine einstellige Zahl ist, gehört x zu seiner eigenen Klasse.\nAndernfalls summieren Sie die Ziffern von x, erhalten ein neues x und iterieren, bis die Klasse bestimmt ist.\n\nParameter:\n\n- x (const char*): The integer to be classified in string form.  \n  - x (const char*): Die ganze Zahl, die in String-Form klassifiziert werden soll.\n\nGibt zurück:\n\nint: Die Klasse, zu der die ganze Zahl x gehört.\n\nVerwendung:\n\n>>> f_26(\"24\")\n6", "ha": "Rarraba lambar x bisa ga hanyar mai zuwa:\nIdan x lamba ce mai ɗigo ɗaya, x na cikin aji nasa.\nIn ba haka ba, tara lambobin x, sami sabon x, kuma maimaita har sai an tantance ajin.\n\nParameters:\n- x (const char*): Lambar da za a tantance a cikin tsarin kirtani.\n\nReturns:\nint: Ajin da lambar x ta ke ciki.\n\nUsage:\n>>> f_26(\"24\")\n6", "hi": "निम्नलिखित विधि के आधार पर पूर्णांक x को वर्गीकृत करें:\nयदि x एक एकल अंक संख्या है, तो x अपनी स्वयं की श्रेणी में आता है।\nअन्यथा, x के अंकों का योग करें, एक नया x प्राप्त करें, और तब तक पुनरावृत्ति करें जब तक कि श्रेणी निर्धारित न हो जाए।\n\nParameters:\n- x (const char*): स्ट्रिंग रूप में वर्गीकृत की जाने वाली पूर्णांक।\n\nReturns:\nint: वह श्रेणी जिसमें पूर्णांक x आता है।\n\nUsage:\n>>> f_26(\"24\")\n6", "hu": "Osztályozza az x egész számot az alábbi módszer alapján:\nHa x egyjegyű szám, akkor x a saját osztályába tartozik.\nEgyébként összegezze x számjegyeit, kapjon egy új x-et, és ismételje meg, amíg az osztály meg nem határozódik.\n\nParaméterek:\n- x (const char*): Az osztályozandó egész szám sztring formában.\n\nVisszatér:\nint: Az osztály, amelyhez az x egész szám tartozik.\n\nHasználat:\n>>> f_26(\"24\")\n6", "es": "Clasificar el entero x basado en el siguiente método:\nSi x es un número de un solo dígito, x pertenece a su propia clase.\nDe lo contrario, suma los dígitos de x, obtiene un nuevo x, e itera hasta que se determine la clase.\n\nParámetros:\n- x (const char*): El entero a clasificar en forma de cadena.\n\nDevuelve:\nint: La clase a la que pertenece el entero x.\n\nUso:\n>>> f_26(\"24\")\n6", "arb": "تصنيف العدد الصحيح x بناءً على الطريقة التالية:\nإذا كان x رقمًا مكونًا من رقم واحد، فإن x ينتمي إلى فئته الخاصة.\nخلاف ذلك، اجمع أرقام x، واحصل على x جديد، وكرر حتى يتم تحديد الفئة.\n\nالمعلمات:\n- x (const char*): العدد الصحيح الذي سيتم تصنيفه في شكل سلسلة.\n\nالقيم المعادة:\nint: الفئة التي ينتمي إليها العدد الصحيح x.\n\nالاستخدام:\n>>> f_26(\"24\")\n6", "sw": "Ainisha nambari x kulingana na njia ifuatayo: \nIkiwa x ni nambari ya tarakimu moja, x ni ya darasa lake lenyewe.  \nVinginevyo, jumlisha tarakimu za x, pata x mpya, na rudia mpaka darasa litakapobainishwa.  \n\nParameters:  \n- x (const char*): Nambari ya kuhesabiwa katika mfumo wa herufi.  \n\nReturns:  \nint: Darasa ambalo nambari x inahusishwa.  \n\nUsage:  \n>>> f_26(\"24\")  \n6", "tr": "Tam sayı x'i aşağıdaki yönteme göre sınıflandırın:\nEğer x tek basamaklı bir sayı ise, x kendi sınıfına aittir.\nAksi takdirde, x'in basamaklarını toplayın, yeni bir x elde edin ve sınıf belirlenene kadar yineleyin.\n\nParametreler:\n- x (const char*): Sınıflandırılacak tam sayının string formu.\n\nDöndürülen:\nint: Tam sayı x'in ait olduğu sınıf.\n\nKullanım:\n>>> f_26(\"24\")\n6", "vi": "Phân loại số nguyên x dựa trên phương pháp sau:\nNếu x là một số có một chữ số, x thuộc về lớp của chính nó.\nNgược lại, tổng các chữ số của x, lấy một x mới, và lặp lại cho đến khi xác định được lớp.\n\nTham số:\n- x (const char*): Số nguyên cần được phân loại dưới dạng chuỗi.\n\nTrả về:\nint: Lớp mà số nguyên x thuộc về.\n\nSử dụng:\n>>> f_26(\"24\")\n6", "id": "Klasifikasikan bilangan bulat x berdasarkan metode berikut:\nJika x adalah angka satu digit, x termasuk dalam kelasnya sendiri.\nJika tidak, jumlahkan digit-digit x, dapatkan x baru, dan iterasi sampai kelas ditentukan.\n\nParameter:\n- x (const char*): Bilangan bulat yang akan diklasifikasikan dalam bentuk string.\n\nMengembalikan:\nint: Kelas di mana bilangan bulat x termasuk.\n\nPenggunaan:\n>>> f_26(\"24\")\n6", "ja": "整数 x を次の方法で分類します:\nx が一桁の数字の場合、x は自分自身のクラスに属します。\nそれ以外の場合、x の各桁を合計し、新しい x を取得し、クラスが決定されるまで繰り返します。\n\nパラメータ:\n- x (const char*): 文字列形式で分類される整数。\n\n戻り値:\nint: 整数 x が属するクラス。\n\n使用例:\n>>> f_26(\"24\")\n6", "ko": "정수 x를 다음 방법에 따라 분류합니다:\nx가 한 자리 숫자이면, x는 자체 클래스에 속합니다.\n그렇지 않으면, x의 자릿수를 합산하여 새로운 x를 얻고, 클래스가 결정될 때까지 반복합니다.\n\n매개변수:\n- x (const char*): 문자열 형태로 분류할 정수.\n\n반환값:\nint: 정수 x가 속하는 클래스.\n\n사용 예:\n>>> f_26(\"24\")\n6", "ml": "പിന്തുടരുന്ന രീതിയിൽ x എന്ന പൂർണ്ണസംഖ്യയെ വർഗ്ഗീകരിക്കുക:\nx ഒറ്റ അക്ക സംഖ്യയായാൽ, x തന്റെ സ്വന്തം വർഗ്ഗത്തിൽ പെട്ടതാണ്.\nഅല്ലെങ്കിൽ, x ന്റെ അക്കങ്ങൾ കൂട്ടിച്ചേർക്കുക, ഒരു പുതിയ x നേടുക, വർഗ്ഗം നിർണ്ണയിക്കുന്നതുവരെ ആവർത്തിക്കുക.\n\nParameters:\n- x (const char*): The integer to be classified in string form.\n- x (const char*): സ്ട്രിംഗ് രൂപത്തിൽ വർഗ്ഗീകരിക്കേണ്ട പൂർണ്ണസംഖ്യ.\n\nReturns:\nint: പൂർണ്ണസംഖ്യ x പെട്ട വർഗ്ഗം.\n\nUsage:\n>>> f_26(\"24\")\n6", "fa": "طبقه‌بندی عدد صحیح x بر اساس روش زیر:\nاگر x یک عدد یک‌رقمی باشد، x به کلاس خودش تعلق دارد.\nدر غیر این صورت، ارقام x را جمع کنید، یک x جدید بگیرید و تکرار کنید تا کلاس تعیین شود.\n\nپارامترها:\n- x (const char*): عدد صحیحی که باید به صورت رشته طبقه‌بندی شود.\n\nبازگشت:\nint: کلاسی که عدد صحیح x به آن تعلق دارد.\n\nاستفاده:\n>>> f_26(\"24\")\n6"}}
{"task_id": "CPP/27", "prompt": {"en": "#include <cassert>\n#include <cstdio>\n/**\n * Transforms the case of a given letter.\n * \n * If the input is a lowercase letter, it returns the uppercase version,\n * and if the input is an uppercase letter, it returns the lowercase version.\n * Non-alphabetic characters are returned unchanged.\n *\n * Usage:\n *   char result = f_27('b'); // result will be 'B'\n *   char result = f_27('B'); // result will be 'b'\n *\n * @param letter The input letter to be transformed.\n * @return The letter with its case reversed if it's alphabetic, otherwise the original letter.\n */\nchar f_27(char letter)", "sq": "#include <cassert>\n#include <cstdio>\n/**\n * Transformon shkronjën e dhënë në shkronjë të madhe ose të vogël.\n * \n * Nëse hyrja është një shkronjë e vogël, kthen versionin e saj në shkronjë të madhe,\n * dhe nëse hyrja është një shkronjë e madhe, kthen versionin e saj në shkronjë të vogël.\n * Karakteret jo-alfabetike kthehen të pandryshuara.\n *\n * Përdorimi:\n *   char result = f_27('b'); // rezultati do të jetë 'B'\n *   char result = f_27('B'); // rezultati do të jetë 'b'\n *\n * @param letter Shkronja e hyrjes që do të transformohet.\n * @return Shkronja me rastin e saj të ndryshuar nëse është alfabetike, përndryshe shkronja origjinale.\n */\nchar f_27(char letter)", "hy": "#include <cassert>\n#include <cstdio>\n/**\n * Փոխակերպում է տրված տառի գրությունը։\n * \n * Եթե մուտքագրվածը փոքրատառ է, վերադարձնում է մեծատառ տարբերակը,\n * իսկ եթե մուտքագրվածը մեծատառ է, վերադարձնում է փոքրատառ տարբերակը։\n * Այլ ոչ այբենական նիշերը վերադարձվում են անփոփոխ։\n *\n * Օգտագործում:\n *   char result = f_27('b'); // result-ը կլինի 'B'\n *   char result = f_27('B'); // result-ը կլինի 'b'\n *\n * @param letter Մուտքագրված տառը, որը պետք է փոխակերպվի։\n * @return Տառը՝ իր գրությունը փոխված, եթե այն այբենական է, հակառակ դեպքում՝ բնօրինակ տառը։\n */\nchar f_27(char letter)", "bn": "#include <cassert>\n#include <cstdio>\n/**\n * একটি প্রদত্ত অক্ষরের কেস পরিবর্তন করে।\n * \n * যদি ইনপুট একটি ছোট হাতের অক্ষর হয়, এটি বড় হাতের সংস্করণ ফেরত দেয়,\n * এবং যদি ইনপুট একটি বড় হাতের অক্ষর হয়, এটি ছোট হাতের সংস্করণ ফেরত দেয়।\n * অ্যালফাবেটিক নয় এমন অক্ষর অপরিবর্তিত অবস্থায় ফেরত দেওয়া হয়।\n *\n * ব্যবহার:\n *   char result = f_27('b'); // result হবে 'B'\n *   char result = f_27('B'); // result হবে 'b'\n *\n * @param letter রূপান্তর করার জন্য ইনপুট অক্ষর।\n * @return অক্ষরটি যদি অ্যালফাবেটিক হয় তবে তার কেস বিপরীত অবস্থায় ফেরত দেয়, অন্যথায় মূল অক্ষরটি।\n */\nchar f_27(char letter)", "bg": "#include <cassert>\n#include <cstdio>\n/**\n * Преобразува регистъра на дадена буква.\n * \n * Ако входът е малка буква, връща главната версия,\n * и ако входът е главна буква, връща малката версия.\n * Неалфабетни символи се връщат непроменени.\n *\n * Употреба:\n *   char result = f_27('b'); // result ще бъде 'B'\n *   char result = f_27('B'); // result ще бъде 'b'\n *\n * @param letter Входната буква, която ще бъде преобразувана.\n * @return Буквата с обърнат регистър, ако е алфабетна, в противен случай оригиналната буква.\n */\nchar f_27(char letter)", "zh": "#include <cassert>\n#include <cstdio>\n/**\n * 转换给定字母的大小写。\n * \n * 如果输入是小写字母，则返回大写版本，\n * 如果输入是大写字母，则返回小写版本。\n * 非字母字符将原样返回。\n *\n * 用法：\n *   char result = f_27('b'); // result 将是 'B'\n *   char result = f_27('B'); // result 将是 'b'\n *\n * @param letter 要转换的输入字母。\n * @return 如果是字母则返回大小写转换后的字母，否则返回原始字母。\n */\nchar f_27(char letter)", "fr": "#include <cassert>\n#include <cstdio>\n/**\n * Transforme la casse d'une lettre donnée.\n * \n * Si l'entrée est une lettre minuscule, elle renvoie la version majuscule,\n * et si l'entrée est une lettre majuscule, elle renvoie la version minuscule.\n * Les caractères non alphabétiques sont renvoyés inchangés.\n *\n * Utilisation :\n *   char result = f_27('b'); // result sera 'B'\n *   char result = f_27('B'); // result sera 'b'\n *\n * @param letter La lettre d'entrée à transformer.\n * @return La lettre avec sa casse inversée si elle est alphabétique, sinon la lettre originale.\n */\nchar f_27(char letter)", "de": "#include <cassert>\n#include <cstdio>\n/**\n * Transformiert den Fall eines gegebenen Buchstabens.\n * \n * Wenn die Eingabe ein Kleinbuchstabe ist, wird die Großbuchstabenversion zurückgegeben,\n * und wenn die Eingabe ein Großbuchstabe ist, wird die Kleinbuchstabenversion zurückgegeben.\n * Nicht-alphabetische Zeichen werden unverändert zurückgegeben.\n *\n * Verwendung:\n *   char result = f_27('b'); // result wird 'B' sein\n *   char result = f_27('B'); // result wird 'b' sein\n *\n * @param letter Der Eingabebuchstabe, der transformiert werden soll.\n * @return Der Buchstabe mit umgekehrtem Fall, wenn er alphabetisch ist, ansonsten der ursprüngliche Buchstabe.\n */\nchar f_27(char letter)", "ha": "#include <cassert>\n#include <cstdio>\n/**\n * Canza harafin da aka bayar daga babba zuwa ƙanana ko akasin haka.\n * \n * Idan harafin da aka shigar yana cikin ƙananan baƙaƙe, zai mayar da shi zuwa babba,\n * kuma idan harafin yana cikin manyan baƙaƙe, zai mayar da shi zuwa ƙanana.\n * Haruffan da ba na alphabet ba za a mayar da su ba tare da canji ba.\n *\n * Amfani:\n *   char result = f_27('b'); // result zai zama 'B'\n *   char result = f_27('B'); // result zai zama 'b'\n *\n * @param letter Harafin da za a canza.\n * @return Harafin da aka juya idan yana cikin alphabet, in ba haka ba asalin harafin.\n */\nchar f_27(char letter)", "hi": "#include <cassert>\n#include <cstdio>\n/**\n * दिए गए अक्षर का केस बदलता है।\n * \n * यदि इनपुट एक लोअरकेस अक्षर है, तो यह अपरकेस संस्करण लौटाता है,\n * और यदि इनपुट एक अपरकेस अक्षर है, तो यह लोअरकेस संस्करण लौटाता है।\n * गैर-अक्षरात्मक वर्ण बिना परिवर्तन के लौटाए जाते हैं।\n *\n * उपयोग:\n *   char result = f_27('b'); // result होगा 'B'\n *   char result = f_27('B'); // result होगा 'b'\n *\n * @param letter इनपुट अक्षर जिसे परिवर्तित करना है।\n * @return अक्षर जिसका केस उल्टा हो गया है यदि यह अक्षरात्मक है, अन्यथा मूल अक्षर।\n */\nchar f_27(char letter)", "hu": "#include <cassert>\n#include <cstdio>\n/**\n * Átalakítja egy adott betű esetét.\n * \n * Ha a bemenet kisbetű, akkor visszaadja a nagybetűs változatát,\n * és ha a bemenet nagybetű, akkor visszaadja a kisbetűs változatát.\n * Nem alfabetikus karakterek változatlanul kerülnek visszaadásra.\n *\n * Használat:\n *   char result = f_27('b'); // result 'B' lesz\n *   char result = f_27('B'); // result 'b' lesz\n *\n * @param letter Az átalakítandó bemeneti betű.\n * @return A betű ellentétes esettel, ha alfabetikus, különben az eredeti betű.\n */\nchar f_27(char letter)", "es": "#include <cassert>\n#include <cstdio>\n/**\n * Transforma el caso de una letra dada.\n * \n * Si la entrada es una letra minúscula, devuelve la versión en mayúscula,\n * y si la entrada es una letra mayúscula, devuelve la versión en minúscula.\n * Los caracteres no alfabéticos se devuelven sin cambios.\n *\n * Uso:\n *   char result = f_27('b'); // result será 'B'\n *   char result = f_27('B'); // result será 'b'\n *\n * @param letter La letra de entrada a transformar.\n * @return La letra con su caso invertido si es alfabética, de lo contrario la letra original.\n */\nchar f_27(char letter)", "arb": "#include <cassert>\n#include <cstdio>\n/**\n * يحول حالة الحرف المعطى.\n * \n * إذا كان الإدخال حرفًا صغيرًا، فإنه يعيد النسخة الكبيرة،\n * وإذا كان الإدخال حرفًا كبيرًا، فإنه يعيد النسخة الصغيرة.\n * الأحرف غير الأبجدية تُعاد دون تغيير.\n *\n * الاستخدام:\n *   char result = f_27('b'); // النتيجة ستكون 'B'\n *   char result = f_27('B'); // النتيجة ستكون 'b'\n *\n * @param letter الحرف المدخل الذي سيتم تحويله.\n * @return الحرف مع عكس حالته إذا كان أبجديًا، وإلا الحرف الأصلي.\n */\nchar f_27(char letter)", "sw": "#include <cassert>\n#include <cstdio>\n/**\n * Hubadilisha herufi kubwa au ndogo ya herufi iliyotolewa.\n * \n * Ikiwa ingizo ni herufi ndogo, inarudisha toleo la herufi kubwa,\n * na ikiwa ingizo ni herufi kubwa, inarudisha toleo la herufi ndogo.\n * Herufi zisizo za alfabeti zinarudishwa bila kubadilishwa.\n *\n * Matumizi:\n *   char result = f_27('b'); // result itakuwa 'B'\n *   char result = f_27('B'); // result itakuwa 'b'\n *\n * @param letter Herufi ya ingizo inayopaswa kubadilishwa.\n * @return Herufi ikiwa imebadilishwa herufi kubwa au ndogo ikiwa ni ya alfabeti, vinginevyo herufi ya asili.\n */\nchar f_27(char letter)", "tr": "#include <cassert>\n#include <cstdio>\n/**\n * Belirtilen bir harfin büyük/küçük harf durumunu değiştirir.\n * \n * Eğer giriş küçük harf ise, büyük harf versiyonunu döndürür,\n * ve eğer giriş büyük harf ise, küçük harf versiyonunu döndürür.\n * Alfabetik olmayan karakterler değişmeden döndürülür.\n *\n * Kullanım:\n *   char result = f_27('b'); // result 'B' olacaktır\n *   char result = f_27('B'); // result 'b' olacaktır\n *\n * @param letter Dönüştürülecek giriş harfi.\n * @return Eğer alfabetikse harfin büyük/küçük harf durumu değiştirilmiş hali, aksi takdirde orijinal harf.\n */\nchar f_27(char letter)", "vi": "#include <cassert>\n#include <cstdio>\n/**\n * Chuyển đổi chữ hoa/thường của một chữ cái cho trước.\n * \n * Nếu đầu vào là một chữ cái thường, nó trả về phiên bản chữ hoa,\n * và nếu đầu vào là một chữ cái hoa, nó trả về phiên bản chữ thường.\n * Các ký tự không phải chữ cái được trả về không thay đổi.\n *\n * Sử dụng:\n *   char result = f_27('b'); // result sẽ là 'B'\n *   char result = f_27('B'); // result sẽ là 'b'\n *\n * @param letter Chữ cái đầu vào cần được chuyển đổi.\n * @return Chữ cái với chữ hoa/thường được đảo ngược nếu nó là chữ cái, nếu không thì trả về chữ cái gốc.\n */\nchar f_27(char letter)", "id": "#include <cassert>\n#include <cstdio>\n/**\n * Mengubah huruf menjadi huruf besar atau kecil.\n * \n * Jika input adalah huruf kecil, fungsi ini mengembalikan versi huruf besar,\n * dan jika input adalah huruf besar, fungsi ini mengembalikan versi huruf kecil.\n * Karakter non-alfabetik dikembalikan tanpa perubahan.\n *\n * Penggunaan:\n *   char result = f_27('b'); // result akan menjadi 'B'\n *   char result = f_27('B'); // result akan menjadi 'b'\n *\n * @param letter Huruf input yang akan diubah.\n * @return Huruf dengan perubahan besar kecil jika itu alfabet, jika tidak, huruf asli.\n */\nchar f_27(char letter)", "ja": "#include <cassert>\n#include <cstdio>\n/**\n * 指定された文字の大文字小文字を変換します。\n * \n * 入力が小文字の場合、大文字バージョンを返し、\n * 入力が大文字の場合、小文字バージョンを返します。\n * アルファベット以外の文字は変更せずに返されます。\n *\n * 使用例:\n *   char result = f_27('b'); // result は 'B' になります\n *   char result = f_27('B'); // result は 'b' になります\n *\n * @param letter 変換する入力文字。\n * @return アルファベットの場合は大文字小文字を反転した文字、それ以外の場合は元の文字。\n */\nchar f_27(char letter)", "ko": "#include <cassert>\n#include <cstdio>\n/**\n * 주어진 문자의 대소문자를 변환합니다.\n * \n * 입력이 소문자일 경우 대문자로 변환하여 반환하고,\n * 입력이 대문자일 경우 소문자로 변환하여 반환합니다.\n * 알파벳이 아닌 문자는 변경 없이 반환됩니다.\n *\n * 사용 예:\n *   char result = f_27('b'); // result는 'B'가 됩니다.\n *   char result = f_27('B'); // result는 'b'가 됩니다.\n *\n * @param letter 변환할 입력 문자입니다.\n * @return 알파벳일 경우 대소문자가 반전된 문자, 그렇지 않으면 원래 문자를 반환합니다.\n */\nchar f_27(char letter)", "ml": "#include <cassert>\n#include <cstdio>\n/**\n * നൽകിയ അക്ഷരത്തിന്റെ കേസിനെ മാറ്റുന്നു.\n * \n * ഇൻപുട്ട് ചെറിയ അക്ഷരമാണെങ്കിൽ, അത് വലിയ അക്ഷരമായി തിരികെ നൽകും,\n * ഇൻപുട്ട് വലിയ അക്ഷരമാണെങ്കിൽ, അത് ചെറിയ അക്ഷരമായി തിരികെ നൽകും.\n * അക്ഷരമല്ലാത്ത പ്രതീകങ്ങൾ മാറ്റമില്ലാതെ തിരികെ നൽകും.\n *\n * ഉപയോഗം:\n *   char result = f_27('b'); // ഫലം 'B' ആയിരിക്കും\n *   char result = f_27('B'); // ഫലം 'b' ആയിരിക്കും\n *\n * @param letter മാറ്റേണ്ട ഇൻപുട്ട് അക്ഷരം.\n * @return ഇത് അക്ഷരമെങ്കിൽ, അതിന്റെ കേസ് മറിച്ചുള്ള അക്ഷരം, അല്ലെങ്കിൽ യഥാർത്ഥ അക്ഷരം.\n */\nchar f_27(char letter)", "fa": "#include <cassert>\n#include <cstdio>\n/**\n * حالت یک حرف داده شده را تغییر می‌دهد.\n * \n * اگر ورودی یک حرف کوچک باشد، نسخه بزرگ آن را برمی‌گرداند،\n * و اگر ورودی یک حرف بزرگ باشد، نسخه کوچک آن را برمی‌گرداند.\n * کاراکترهای غیر الفبایی بدون تغییر برگردانده می‌شوند.\n *\n * استفاده:\n *   char result = f_27('b'); // نتیجه 'B' خواهد بود\n *   char result = f_27('B'); // نتیجه 'b' خواهد بود\n *\n * @param letter حرف ورودی که باید تغییر یابد.\n * @return حرف با حالت معکوس اگر الفبایی باشد، در غیر این صورت حرف اصلی.\n */\nchar f_27(char letter)"}, "canonical_solution": "{\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    }\n    else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}", "instruction": {"en": "char f_27(char letter)\n{\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    }\n    else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.", "sq": "char f_27(char letter)\n{\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    }\n    else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrale (docstring) të kodit CPP në shqip duke përdorur maksimumi 500 karaktere.", "hy": "char f_27(char letter)\n{\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    }\n    else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}\n\nՏվեք CPP կոդի համառոտ բնական լեզվով նկարագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "char f_27(char letter)\n{\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    }\n    else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}\n\nসিপিপি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।", "bg": "char f_27(char letter)\n{\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    }\n    else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}\n\nПредоставете кратко описание на CPP кода на български език, използвайки не повече от 500 символа.", "zh": "char f_27(char letter)\n{\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    }\n    else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}\n\n请用最多500个字符的中文对该CPP代码提供简洁的自然语言描述（文档字符串）。", "fr": "char f_27(char letter)\n{\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    }\n    else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}\n\nFournir une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.", "de": "char f_27(char letter)\n{\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    }\n    else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen.", "ha": "char f_27(char letter)\n{\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    }\n    else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}\n\nBayar da takaitaccen bayani a cikin yare na halitta (docstring) na lambar CPP cikin Hausa, ba fiye da haruffa 500 ba.", "hi": "char f_27(char letter)\n{\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    }\n    else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "char f_27(char letter)\n{\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    }\n    else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a CPP kódról magyarul, legfeljebb 500 karakterben.", "es": "char f_27(char letter)\n{\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    }\n    else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}\n\nProporciona una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando como máximo 500 caracteres.", "arb": "char f_27(char letter)\n{\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    }\n    else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة CPP باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.", "sw": "char f_27(char letter)\n{\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    }\n    else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "char f_27(char letter)\n{\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    }\n    else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}\n\nAşağıdaki CPP kodunun işlevini açıklayan en fazla 500 karakterlik özlü bir doğal dil açıklaması (docstring) sağlayın.", "vi": "char f_27(char letter)\n{\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    }\n    else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự.", "id": "char f_27(char letter)\n{\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    }\n    else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode CPP dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "char f_27(char letter)\n{\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    }\n    else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}\n\n以下のCPPコードの簡潔な自然言語による説明（ドックストリング）を日本語で500文字以内で提供してください。", "ko": "char f_27(char letter)\n{\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    }\n    else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}\n\n다음의 CPP 코드에 대한 간결한 자연어 설명(도크스트링)을 한국어로 500자 이내로 제공하세요.", "ml": "char f_27(char letter)\n{\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    }\n    else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}\n\nCPP കോഡ് സംബന്ധിച്ച സംക്ഷിപ്തമായ ഒരു സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) മലയാളത്തിൽ 500 അക്ഷരങ്ങൾക്കുള്ളിൽ നൽകുക.", "fa": "char f_27(char letter)\n{\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    }\n    else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}\n\nتوضیح مختصری به زبان طبیعی (docstring) از کد CPP به زبان فارسی ارائه دهید که حداکثر ۵۰۰ کاراکتر باشد."}, "level": "", "test": "int main() {\n    assert(f_27('b') == 'B');\n    assert(f_27('B') == 'b');\n    // Additional test cases\n    assert(f_27('z') == 'Z');\n    assert(f_27('Z') == 'z');\n    assert(f_27('m') == 'M');\n    assert(f_27('M') == 'm');\n    assert(f_27('1') == '1'); // Non-alphabetic, should be unchanged\n    assert(f_27('!') == '!'); // Non-alphabetic, should be unchanged\n\n    // Uncomment the following line to print a success message (optional)\n    \n    return 0;\n}", "entry_point": "f_27", "signature": "char f_27(char letter)", "docstring": {"en": "Transforms the case of a given letter.\n\nIf the input is a lowercase letter, it returns the uppercase version,\nand if the input is an uppercase letter, it returns the lowercase version.\nNon-alphabetic characters are returned unchanged.\n\nUsage:\n  char result = f_27('b'); // result will be 'B'\n  char result = f_27('B'); // result will be 'b'\n\n@param letter The input letter to be transformed.\n@return The letter with its case reversed if it's alphabetic, otherwise the original letter.\n", "sq": "Transformon shkronjën e dhënë në rast tjetër.\n\nNëse hyrja është një shkronjë e vogël, kthen versionin e saj me shkronja të mëdha,\ndhe nëse hyrja është një shkronjë e madhe, kthen versionin e saj me shkronja të vogla.\nKarakteret jo-alfabetike kthehen të pandryshuara.\n\nPërdorimi:\n  char result = f_27('b'); // rezultati do të jetë 'B'\n  char result = f_27('B'); // rezultati do të jetë 'b'\n\n@param letter Shkronja hyrëse që do të transformohet.\n@return Shkronja me rastin e saj të kthyer nëse është alfabetike, përndryshe shkronja origjinale.", "hy": "Փոխակերպում է տրված տառի ռեգիստրը։\n\nԵթե մուտքագրվածը փոքրատառ է, վերադարձնում է մեծատառ տարբերակը,\nիսկ եթե մուտքագրվածը մեծատառ է, վերադարձնում է փոքրատառ տարբերակը։\nԱյլ ոչ այբբենական նշանները վերադարձվում են առանց փոփոխության։\n\nՕգտագործում:\n  char result = f_27('b'); // result-ը կլինի 'B'\n  char result = f_27('B'); // result-ը կլինի 'b'\n\n@param letter Մուտքագրված տառը, որը պետք է փոխակերպվի։\n@return Տառը՝ իր ռեգիստրով փոխված, եթե այն այբբենական է, հակառակ դեպքում՝ բնօրինակ տառը։", "bn": "একটি প্রদত্ত অক্ষরের কেস পরিবর্তন করে।\n\nযদি ইনপুটটি একটি ছোট হাতের অক্ষর হয়, এটি বড় হাতের সংস্করণটি ফেরত দেয়,\nএবং যদি ইনপুটটি একটি বড় হাতের অক্ষর হয়, এটি ছোট হাতের সংস্করণটি ফেরত দেয়।\nঅ্যালফাবেটিক নয় এমন অক্ষর অপরিবর্তিত অবস্থায় ফেরত দেওয়া হয়।\n\nব্যবহার:\n  char result = f_27('b'); // result হবে 'B'\n  char result = f_27('B'); // result হবে 'b'\n\n@param letter রূপান্তর করার জন্য ইনপুট অক্ষর।\n@return অক্ষরটি যদি অ্যালফাবেটিক হয় তবে তার কেস উল্টানো অবস্থায় ফেরত দেয়, অন্যথায় মূল অক্ষরটি।", "bg": "Преобразува регистъра на дадена буква.\n\nАко входът е малка буква, връща главната версия,\nа ако входът е главна буква, връща малката версия.\nНеалфабетните символи се връщат непроменени.\n\nУпотреба:\n  char result = f_27('b'); // result ще бъде 'B'\n  char result = f_27('B'); // result ще бъде 'b'\n\n@param letter Входната буква, която ще бъде преобразувана.\n@return Буквата с обърнат регистър, ако е алфабетна, в противен случай оригиналната буква.", "zh": "将给定字母的大小写转换。\n\n如果输入是小写字母，则返回大写版本，\n如果输入是大写字母，则返回小写版本。\n非字母字符将保持不变。\n\n用法:\n  char result = f_27('b'); // result 将是 'B'\n  char result = f_27('B'); // result 将是 'b'\n\n@param letter 要转换的输入字母。\n@return 如果是字母，则返回大小写反转的字母，否则返回原始字母。", "fr": "Transforme la casse d'une lettre donnée.\n\nSi l'entrée est une lettre minuscule, elle retourne la version majuscule,\net si l'entrée est une lettre majuscule, elle retourne la version minuscule.\nLes caractères non alphabétiques sont retournés inchangés.\n\nUtilisation :\n  char result = f_27('b'); // result sera 'B'\n  char result = f_27('B'); // result sera 'b'\n\n@param letter La lettre d'entrée à transformer.\n@return La lettre avec sa casse inversée si elle est alphabétique, sinon la lettre originale.", "de": "Verändert die Groß-/Kleinschreibung eines gegebenen Buchstabens.\n\nWenn die Eingabe ein Kleinbuchstabe ist, wird die Großbuchstabenversion zurückgegeben,\nund wenn die Eingabe ein Großbuchstabe ist, wird die Kleinbuchstabenversion zurückgegeben.\nNicht-alphabetische Zeichen werden unverändert zurückgegeben.\n\nVerwendung:\n  char result = f_27('b'); // result wird 'B' sein\n  char result = f_27('B'); // result wird 'b' sein\n\n@param letter Der Eingabebuchstabe, der umgewandelt werden soll.\n@return Der Buchstabe mit umgekehrter Groß-/Kleinschreibung, wenn er alphabetisch ist, andernfalls der ursprüngliche Buchstabe.", "ha": "Canza harafin da aka bayar daga babba zuwa ƙanana ko daga ƙanana zuwa babba.\n\nIdan harafin da aka shigar harafi ne ƙarami, zai mayar da shi babba,\nkuma idan harafin da aka shigar babba ne, zai mayar da shi ƙarami.\nHaruffan da ba na haruffa ba za a mayar da su ba tare da canji ba.\n\nAmfani:\n  char result = f_27('b'); // sakamakon zai zama 'B'\n  char result = f_27('B'); // sakamakon zai zama 'b'\n\n@param letter Harafin da aka shigar da za a canza.\n@return Harafin da aka juya yanayin idan harafi ne, in ba haka ba asalin harafin.", "hi": "दिए गए अक्षर के मामले को बदलता है।\n\nयदि इनपुट एक लोअरकेस अक्षर है, तो यह अपरकेस संस्करण लौटाता है,\nऔर यदि इनपुट एक अपरकेस अक्षर है, तो यह लोअरकेस संस्करण लौटाता है।\nगैर-अक्षरीय वर्ण अपरिवर्तित लौटाए जाते हैं।\n\nउपयोग:\n  char result = f_27('b'); // result होगा 'B'\n  char result = f_27('B'); // result होगा 'b'\n\n@param letter वह इनपुट अक्षर जिसे बदला जाना है।\n@return अक्षर जिसका मामला उलटा गया है यदि यह अक्षरीय है, अन्यथा मूल अक्षर।", "hu": "Átalakítja egy adott betű kis- és nagybetűs formáját.\n\nHa a bemenet kisbetű, akkor a nagybetűs változatát adja vissza,\nés ha a bemenet nagybetű, akkor a kisbetűs változatát adja vissza.\nA nem alfabetikus karakterek változatlanul kerülnek visszaadásra.\n\nHasználat:\n  char result = f_27('b'); // result 'B' lesz\n  char result = f_27('B'); // result 'b' lesz\n\n@param letter Az átalakítandó bemeneti betű.\n@return A betű megfordított kis- és nagybetűs változata, ha alfabetikus, különben az eredeti betű.", "es": "Transforma el caso de una letra dada.\n\nSi la entrada es una letra minúscula, devuelve la versión en mayúscula,\ny si la entrada es una letra mayúscula, devuelve la versión en minúscula.\nLos caracteres no alfabéticos se devuelven sin cambios.\n\nUso:\n  char result = f_27('b'); // result será 'B'\n  char result = f_27('B'); // result será 'b'\n\n@param letter La letra de entrada a transformar.\n@return La letra con su caso invertido si es alfabética, de lo contrario, la letra original.", "arb": "يحوّل حالة حرف معين.\n\nإذا كان الإدخال حرفًا صغيرًا، فإنه يعيد النسخة الكبيرة،\nوإذا كان الإدخال حرفًا كبيرًا، فإنه يعيد النسخة الصغيرة.\nالحروف غير الأبجدية تُعاد دون تغيير.\n\nالاستخدام:\n  char result = f_27('b'); // النتيجة ستكون 'B'\n  char result = f_27('B'); // النتيجة ستكون 'b'\n\n@param letter الحرف المدخل الذي سيتم تحويله.\n@return الحرف مع عكس حالته إذا كان أبجديًا، وإلا الحرف الأصلي.", "sw": "Hubadilisha herufi ndogo kuwa kubwa au kubwa kuwa ndogo.\n\nIkiwa herufi ni ndogo, inarudisha toleo la herufi kubwa,\nna ikiwa herufi ni kubwa, inarudisha toleo la herufi ndogo.\nHerufi zisizo za alfabeti zinarudishwa bila kubadilishwa.\n\nMatumizi:\n  char result = f_27('b'); // result itakuwa 'B'\n  char result = f_27('B'); // result itakuwa 'b'\n\n@param letter Herufi ya kuingiza inayopaswa kubadilishwa.\n@return Herufi ikiwa imebadilishwa ukubwa wake ikiwa ni ya alfabeti, vinginevyo herufi asili.", "tr": "Verilen bir harfin büyük/küçük harf durumunu dönüştürür.\n\nEğer giriş küçük harfse, büyük harf versiyonunu döndürür,\nve eğer giriş büyük harfse, küçük harf versiyonunu döndürür.\nAlfabetik olmayan karakterler değişmeden döndürülür.\n\nKullanım:\n  char result = f_27('b'); // result 'B' olacak\n  char result = f_27('B'); // result 'b' olacak\n\n@param letter Dönüştürülecek giriş harfi.\n@return Eğer alfabetikse, harfin büyük/küçük harf durumu ters çevrilmiş hali, aksi takdirde orijinal harf.", "vi": "Chuyển đổi chữ hoa/thường của một chữ cái cho trước.\n\nNếu đầu vào là một chữ cái thường, nó sẽ trả về phiên bản chữ hoa,\nvà nếu đầu vào là một chữ cái hoa, nó sẽ trả về phiên bản chữ thường.\nCác ký tự không phải chữ cái được trả về không thay đổi.\n\nSử dụng:\n  char result = f_27('b'); // result sẽ là 'B'\n  char result = f_27('B'); // result sẽ là 'b'\n\n@param letter Chữ cái đầu vào cần được chuyển đổi.\n@return Chữ cái với chữ hoa/thường được đảo ngược nếu nó là chữ cái, nếu không thì trả về chữ cái gốc.", "id": "Mengubah huruf menjadi huruf besar atau kecil.\n\nJika input adalah huruf kecil, fungsi ini mengembalikan versi huruf besar,\ndan jika input adalah huruf besar, fungsi ini mengembalikan versi huruf kecil.\nKarakter non-alfabetik dikembalikan tanpa perubahan.\n\nPenggunaan:\n  char result = f_27('b'); // result akan menjadi 'B'\n  char result = f_27('B'); // result akan menjadi 'b'\n\n@param letter Huruf input yang akan diubah.\n@return Huruf dengan perubahan huruf besar/kecil jika itu alfabet, jika tidak, huruf asli.", "ja": "与えられた文字の大文字小文字を変換します。\n\n入力が小文字の場合、大文字バージョンを返し、\n入力が大文字の場合、小文字バージョンを返します。\nアルファベット以外の文字は変更されずに返されます。\n\n使用例:\n  char result = f_27('b'); // result は 'B' になります\n  char result = f_27('B'); // result は 'b' になります\n\n@param letter 変換される入力文字。\n@return アルファベットの場合は大文字小文字が逆転された文字、それ以外の場合は元の文字。", "ko": "주어진 문자의 대소문자를 변환합니다.\n\n입력이 소문자일 경우 대문자로 변환하여 반환하고,\n입력이 대문자일 경우 소문자로 변환하여 반환합니다.\n알파벳이 아닌 문자는 변경 없이 반환됩니다.\n\n사용 예:\n  char result = f_27('b'); // result는 'B'가 됩니다.\n  char result = f_27('B'); // result는 'b'가 됩니다.\n\n@param letter 변환할 입력 문자입니다.\n@return 알파벳일 경우 대소문자가 반전된 문자를 반환하고, 그렇지 않으면 원래 문자를 반환합니다.", "ml": "നൽകിയ അക്ഷരത്തിന്റെ കേസ് മാറ്റുന്നു.\n\nഇൻപുട്ട് ചെറിയ അക്ഷരമാണെങ്കിൽ, അത് വലിയ അക്ഷരമായി തിരികെ നൽകും, \nഇൻപുട്ട് വലിയ അക്ഷരമാണെങ്കിൽ, അത് ചെറിയ അക്ഷരമായി തിരികെ നൽകും. \nഅക്ഷരമല്ലാത്ത പ്രതീകങ്ങൾ മാറ്റമില്ലാതെ തിരികെ നൽകും.\n\nഉപയോഗം:\n  char result = f_27('b'); // ഫലം 'B' ആയിരിക്കും\n  char result = f_27('B'); // ഫലം 'b' ആയിരിക്കും\n\n@param letter മാറ്റേണ്ട ഇൻപുട്ട് അക്ഷരം.\n@return ഇത് അക്ഷരമാണെങ്കിൽ, അതിന്റെ കേസ് മറിച്ചിരിക്കും, അല്ലെങ്കിൽ യഥാർത്ഥ അക്ഷരം.", "fa": "حالت یک حرف داده شده را تغییر می‌دهد.\n\nاگر ورودی یک حرف کوچک باشد، نسخه بزرگ آن را برمی‌گرداند،\nو اگر ورودی یک حرف بزرگ باشد، نسخه کوچک آن را برمی‌گرداند.\nکاراکترهای غیر الفبایی بدون تغییر برگردانده می‌شوند.\n\nاستفاده:\n  char result = f_27('b'); // نتیجه 'B' خواهد بود\n  char result = f_27('B'); // نتیجه 'b' خواهد بود\n\n@param letter حرف ورودی که باید تغییر یابد.\n@return حرف با حالت معکوس اگر الفبایی باشد، در غیر این صورت حرف اصلی."}}
{"task_id": "CPP/28", "prompt": {"en": "#include <cassert>\n#include <cstdio>\n/**\n * Displays the ASCII information for a given character.\n * \n * @param character The input character for which ASCII information is to be displayed.\n * @return The corresponding ASCII code.\n * \n * Example:\n * ```cpp\n * int asciiCode = f_28('A');\n * std::cout << asciiCode; // Output: 65\n * ```\n */\nint f_28(char character)", "sq": "#include <cassert>\n#include <cstdio>\n/**\n * Shfaq informacionin ASCII për një karakter të dhënë.\n * \n * @param character Karakteri i hyrjes për të cilin informacioni ASCII duhet të shfaqet.\n * @return Kodi përkatës ASCII.\n * \n * Shembull:\n * ```cpp\n * int asciiCode = f_28('A');\n * std::cout << asciiCode; // Output: 65\n * ```\n */\nint f_28(char character)", "hy": "#include <cassert>\n#include <cstdio>\n/**\n * Ցուցադրում է տրված սիմվոլի ASCII տեղեկատվությունը։\n * \n * @param character Մուտքային սիմվոլը, որի համար պետք է ցուցադրվի ASCII տեղեկատվությունը։\n * @return Համապատասխանող ASCII կոդը։\n * \n * Օրինակ:\n * ```cpp\n * int asciiCode = f_28('A');\n * std::cout << asciiCode; // Output: 65\n * ```\n */\nint f_28(char character)", "bn": "#include <cassert>\n#include <cstdio>\n/**\n * একটি প্রদত্ত অক্ষরের জন্য ASCII তথ্য প্রদর্শন করে।\n * \n * @param character ইনপুট অক্ষর যার জন্য ASCII তথ্য প্রদর্শন করা হবে।\n * @return সংশ্লিষ্ট ASCII কোড।\n * \n * উদাহরণ:\n * ```cpp\n * int asciiCode = f_28('A');\n * std::cout << asciiCode; // Output: 65\n * ```\n */\nint f_28(char character)", "bg": "#include <cassert>\n#include <cstdio>\n/**\n * Показва ASCII информацията за даден символ.\n * \n * @param character Входният символ, за който ще се покаже ASCII информацията.\n * @return Съответстващият ASCII код.\n * \n * Пример:\n * ```cpp\n * int asciiCode = f_28('A');\n * std::cout << asciiCode; // Output: 65\n * ```\n */\nint f_28(char character)", "zh": "#include <cassert>\n#include <cstdio>\n/**\n * 显示给定字符的ASCII信息。\n * \n * @param character 要显示ASCII信息的输入字符。\n * @return 对应的ASCII码。\n * \n * 示例:\n * ```cpp\n * int asciiCode = f_28('A');\n * std::cout << asciiCode; // 输出: 65\n * ```\n */\nint f_28(char character)", "fr": "#include <cassert>\n#include <cstdio>\n/**\n * Affiche les informations ASCII pour un caractère donné.\n * \n * @param character Le caractère d'entrée pour lequel les informations ASCII doivent être affichées.\n * @return Le code ASCII correspondant.\n * \n * Exemple:\n * ```cpp\n * int asciiCode = f_28('A');\n * std::cout << asciiCode; // Output: 65\n * ```\n */\nint f_28(char character)", "de": "#include <cassert>\n#include <cstdio>\n/**\n * Zeigt die ASCII-Informationen für ein gegebenes Zeichen an.\n * \n * @param character Das Eingabezeichen, für das die ASCII-Informationen angezeigt werden sollen.\n * @return Der entsprechende ASCII-Code.\n * \n * Beispiel:\n * ```cpp\n * int asciiCode = f_28('A');\n * std::cout << asciiCode; // Ausgabe: 65\n * ```\n */\nint f_28(char character)", "ha": "#include <cassert>\n#include <cstdio>\n/**\n * Nuna bayanin ASCII don wata alama da aka bayar.\n * \n * @param character Alamar shigarwa wanda za a nuna bayanin ASCII.\n * @return Lambar ASCII da ta dace.\n * \n * Misali:\n * ```cpp\n * int asciiCode = f_28('A');\n * std::cout << asciiCode; // Output: 65\n * ```\n */\nint f_28(char character)", "hi": "#include <cassert>\n#include <cstdio>\n/**\n * दिए गए वर्ण के लिए ASCII जानकारी प्रदर्शित करता है।\n * \n * @param character वह इनपुट वर्ण जिसके लिए ASCII जानकारी प्रदर्शित की जानी है।\n * @return संबंधित ASCII कोड।\n * \n * उदाहरण:\n * ```cpp\n * int asciiCode = f_28('A');\n * std::cout << asciiCode; // Output: 65\n * ```\n */\nint f_28(char character)", "hu": "#include <cassert>\n#include <cstdio>\n/**\n * Megjeleníti egy adott karakter ASCII információit.\n * \n * @param character Az a bemeneti karakter, amelynek az ASCII információit meg kell jeleníteni.\n * @return A megfelelő ASCII kód.\n * \n * Példa:\n * ```cpp\n * int asciiCode = f_28('A');\n * std::cout << asciiCode; // Kimenet: 65\n * ```\n */\nint f_28(char character)", "es": "#include <cassert>\n#include <cstdio>\n/**\n * Muestra la información ASCII para un carácter dado.\n * \n * @param character El carácter de entrada para el cual se mostrará la información ASCII.\n * @return El código ASCII correspondiente.\n * \n * Ejemplo:\n * ```cpp\n * int asciiCode = f_28('A');\n * std::cout << asciiCode; // Output: 65\n * ```\n */\nint f_28(char character)", "arb": "#include <cassert>\n#include <cstdio>\n/**\n * يعرض معلومات ASCII للحرف المعطى.\n * \n * @param character الحرف المدخل الذي سيتم عرض معلومات ASCII له.\n * @return الكود ASCII المقابل.\n * \n * مثال:\n * ```cpp\n * int asciiCode = f_28('A');\n * std::cout << asciiCode; // Output: 65\n * ```\n */\nint f_28(char character)", "sw": "#include <cassert>\n#include <cstdio>\n/**\n * Inaonyesha taarifa za ASCII kwa herufi iliyotolewa.\n * \n * @param character Herufi ya kuingiza ambayo taarifa za ASCII zinapaswa kuonyeshwa.\n * @return Nambari inayolingana ya ASCII.\n * \n * Mfano:\n * ```cpp\n * int asciiCode = f_28('A');\n * std::cout << asciiCode; // Output: 65\n * ```\n */\nint f_28(char character)", "tr": "#include <cassert>\n#include <cstdio>\n/**\n * Belirtilen bir karakter için ASCII bilgisini görüntüler.\n * \n * @param character ASCII bilgisinin görüntüleneceği giriş karakteri.\n * @return Karşılık gelen ASCII kodu.\n * \n * Örnek:\n * ```cpp\n * int asciiCode = f_28('A');\n * std::cout << asciiCode; // Çıktı: 65\n * ```\n */\nint f_28(char character)", "vi": "#include <cassert>\n#include <cstdio>\n/**\n * Hiển thị thông tin ASCII cho một ký tự nhất định.\n * \n * @param character Ký tự đầu vào mà thông tin ASCII cần được hiển thị.\n * @return Mã ASCII tương ứng.\n * \n * Ví dụ:\n * ```cpp\n * int asciiCode = f_28('A');\n * std::cout << asciiCode; // Output: 65\n * ```\n */\nint f_28(char character)", "id": "#include <cassert>\n#include <cstdio>\n/**\n * Menampilkan informasi ASCII untuk karakter yang diberikan.\n * \n * @param character Karakter input yang informasi ASCII-nya akan ditampilkan.\n * @return Kode ASCII yang sesuai.\n * \n * Contoh:\n *  * int asciiCode = f_28('A');\n * std::cout << asciiCode; // Output: 65\n * \n */\nint f_28(char character)", "ja": "#include <cassert>\n#include <cstdio>\n/**\n * 指定された文字のASCII情報を表示します。\n * \n * @param character ASCII情報を表示するための入力文字。\n * @return 対応するASCIIコード。\n * \n * 例:\n * cpp\n * int asciiCode = f_28('A');\n * std::cout << asciiCode; // Output: 65\n * \n */\nint f_28(char character)", "ko": "#include <cassert>\n#include <cstdio>\n/**\n * 주어진 문자에 대한 ASCII 정보를 표시합니다.\n * \n * @param character ASCII 정보를 표시할 입력 문자입니다.\n * @return 해당하는 ASCII 코드.\n * \n * 예시:\n * cpp\n * int asciiCode = f_28('A');\n * std::cout << asciiCode; // Output: 65\n * \n */\nint f_28(char character)", "ml": "#include <cassert>\n#include <cstdio>\n/**\n * നൽകിയ അക്ഷരത്തിനായുള്ള ASCII വിവരങ്ങൾ പ്രദർശിപ്പിക്കുന്നു.\n * \n * @param character ASCII വിവരങ്ങൾ പ്രദർശിപ്പിക്കേണ്ട ഇൻപുട്ട് അക്ഷരം.\n * @return അനുബന്ധ ASCII കോഡ്.\n * \n * ഉദാഹരണം:\n * cpp\n * int asciiCode = f_28('A');\n * std::cout << asciiCode; // Output: 65\n * \n */\nint f_28(char character)", "fa": "#include <cassert>\n#include <cstdio>\n/**\n * اطلاعات ASCII را برای یک کاراکتر داده شده نمایش می‌دهد.\n * \n * @param character کاراکتر ورودی که اطلاعات ASCII برای آن نمایش داده می‌شود.\n * @return کد ASCII متناظر.\n * \n * مثال:\n * cpp\n * int asciiCode = f_28('A');\n * std::cout << asciiCode; // Output: 65\n * \n */\nint f_28(char character)"}, "canonical_solution": "{\n    return character;\n}", "instruction": {"en": "int f_28(char character)\n{\n    return character;\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.", "sq": "int f_28(char character)\n{\n    return character;\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit CPP në shqip duke përdorur maksimumi 500 karaktere.", "hy": "int f_28(char character)\n{\n    return character;\n}\n\nՏվեք կարճ բնական լեզվով նկարագրություն (docstring) այս CPP կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։", "bn": "int f_28(char character)\n{\n    return character;\n}\n\nসিপিপি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হতে হবে।", "bg": "int f_28(char character)\n{\n    return character;\n}\n\nПредоставете кратко описание на CPP кода на естествен език на български, като използвате не повече от 500 знака.", "zh": "int f_28(char character)\n{\n    return character;\n}\n\n请用最多500个字符的中文对该CPP代码提供简洁的自然语言描述（文档字符串）。", "fr": "int f_28(char character)\n{\n    return character;\n}\n\nFournissez une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.", "de": "int f_28(char character)\n{\n    return character;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "int f_28(char character)\n{\n    return character;\n}\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar CPP cikin harshen Hausa ta amfani da haruffa 500 kacal.", "hi": "int f_28(char character)\n{\n    return character;\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।", "hu": "int f_28(char character)\n{\n    return character;\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a CPP kódról magyarul, legfeljebb 500 karakterben.", "es": "int f_28(char character)\n{\n    return character;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando como máximo 500 caracteres.", "arb": "int f_28(char character)\n{\n    return character;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة CPP باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.", "sw": "int f_28(char character)\n{\n    return character;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "int f_28(char character)\n{\n    return character;\n}\n\nAşağıdaki CPP kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda, özlü bir doğal dil açıklaması (docstring) sağlayın.", "vi": "int f_28(char character)\n{\n    return character;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự.", "id": "int f_28(char character)\n{\n    return character;\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode CPP dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "int f_28(char character)\n{\n    return character;\n}\n\n以下のCPPコードの簡潔な自然言語による説明（ドックストリング）を日本語で500文字以内で提供してください。", "ko": "int f_28(char character)\n{\n    return character;\n}\n\n다음 CPP 코드에 대한 간결한 자연어 설명(도크스트링)을 한국어로 최대 500자 이내로 제공하세요.", "ml": "int f_28(char character)\n{\n    return character;\n}\n\nCPP കോഡ് ഉപയോഗിച്ച് 500 അക്ഷരങ്ങളിൽ കവിയാതെയുള്ള സംക്ഷിപ്തമായ ഒരു സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) മലയാളത്തിൽ നൽകുക.", "fa": "int f_28(char character)\n{\n    return character;\n}\n\nتوضیح مختصر و طبیعی (docstring) از کد CPP را به زبان فارسی ارائه دهید که حداکثر ۵۰۰ کاراکتر باشد."}, "level": "", "test": "int main() {\n    assert(f_28('A') == 65);\n    assert(f_28('B') == 66); // Additional test case\n    assert(f_28('0') == 48); // Additional test case\n    assert(f_28(' ') == 32); // Additional test case\n    \n    // Uncomment the line below to print a success message if compiled outside a test framework\n    // std::printf(\"All tests passed.\\n\");\n\n    return 0;\n}", "entry_point": "f_28", "signature": "int f_28(char character)", "docstring": {"en": "Displays the ASCII information for a given character.\n\n@param character The input character for which ASCII information is to be displayed.\n@return The corresponding ASCII code.\n\nExample:\n```cpp\nint asciiCode = f_28('A');\nstd::cout << asciiCode; // Output: 65\n```", "sq": "Shfaq informacionin ASCII për një karakter të dhënë.\n\n@param character Karakteri hyrës për të cilin do të shfaqet informacioni ASCII.\n@return Kodi përkatës ASCII.\n\nShembull:\n```cpp\nint asciiCode = f_28('A');\nstd::cout << asciiCode; // Output: 65\n```", "hy": "Տպում է ASCII տեղեկատվությունը տրված սիմվոլի համար։\n\n@param character Մուտքային սիմվոլը, որի համար պետք է տպել ASCII տեղեկատվությունը։\n@return Համապատասխանող ASCII կոդը։\n\nՕրինակ:\n```cpp\nint asciiCode = f_28('A');\nstd::cout << asciiCode; // Output: 65\n```", "bn": "একটি প্রদত্ত অক্ষরের জন্য ASCII তথ্য প্রদর্শন করে।\n\n@param character ইনপুট অক্ষর যার জন্য ASCII তথ্য প্রদর্শন করা হবে।\n@return সংশ্লিষ্ট ASCII কোড।\n\nউদাহরণ:\n```cpp\nint asciiCode = f_28('A');\nstd::cout << asciiCode; // Output: 65\n```", "bg": "Показва ASCII информацията за даден символ.\n\n@param character Входният символ, за който трябва да се покаже ASCII информацията.\n@return Съответният ASCII код.\n\nПример:\n```cpp\nint asciiCode = f_28('A');\nstd::cout << asciiCode; // Изход: 65\n```", "zh": "显示给定字符的ASCII信息。\n\n@param character 要显示ASCII信息的输入字符。\n@return 对应的ASCII代码。\n\n示例：\n```cpp\nint asciiCode = f_28('A');\nstd::cout << asciiCode; // 输出: 65\n```", "fr": "Affiche les informations ASCII pour un caractère donné.\n\n@param character Le caractère d'entrée pour lequel les informations ASCII doivent être affichées.\n@return Le code ASCII correspondant.\n\nExemple :\n```cpp\nint asciiCode = f_28('A');\nstd::cout << asciiCode; // Sortie : 65\n```", "de": "Zeigt die ASCII-Informationen für ein gegebenes Zeichen an.\n\n@param character Das Eingabezeichen, für das die ASCII-Informationen angezeigt werden sollen.\n@return Der entsprechende ASCII-Code.\n\nBeispiel:\n```cpp\nint asciiCode = f_28('A');\nstd::cout << asciiCode; // Ausgabe: 65\n```", "ha": "Nuna bayanin ASCII don wata alama da aka bayar.\n\n@param character Harafin shigarwa wanda za a nuna bayanin ASCII.\n@return Lambar ASCII da ta dace.\n\nMisali:\n```cpp\nint asciiCode = f_28('A');\nstd::cout << asciiCode; // Output: 65\n```", "hi": "दिए गए वर्ण के लिए ASCII जानकारी प्रदर्शित करता है।\n\n@param character वह इनपुट वर्ण जिसके लिए ASCII जानकारी प्रदर्शित की जानी है।\n@return संबंधित ASCII कोड।\n\nउदाहरण:\n```cpp\nint asciiCode = f_28('A');\nstd::cout << asciiCode; // आउटपुट: 65\n```", "hu": "Megjeleníti a megadott karakter ASCII információját.\n\n@param character A bemeneti karakter, amelynek az ASCII információját meg kell jeleníteni.\n@return A megfelelő ASCII kód.\n\nPélda:\n```cpp\nint asciiCode = f_28('A');\nstd::cout << asciiCode; // Kimenet: 65\n```", "es": "Muestra la información ASCII para un carácter dado.\n\n@param character El carácter de entrada para el cual se mostrará la información ASCII.\n@return El código ASCII correspondiente.\n\nEjemplo:\n```cpp\nint asciiCode = f_28('A');\nstd::cout << asciiCode; // Output: 65", "arb": "يعرض معلومات ASCII لحرف معين.\n\n@param character الحرف المدخل الذي سيتم عرض معلومات ASCII له.\n@return رمز ASCII المقابل.\n\nمثال:\n```cpp\nint asciiCode = f_28('A');\nstd::cout << asciiCode; // Output: 65", "sw": "Inaonyesha taarifa za ASCII kwa herufi iliyotolewa.\n\n@param character Herufi ya ingizo ambayo taarifa za ASCII zinapaswa kuonyeshwa.\n@return Nambari ya ASCII inayolingana.\n\nMfano:\n```cpp\nint asciiCode = f_28('A');\nstd::cout << asciiCode; // Output: 65", "tr": "Verilen bir karakter için ASCII bilgisini gösterir.\n\n@param character ASCII bilgisinin gösterileceği giriş karakteri.\n@return Karşılık gelen ASCII kodu.\n\nÖrnek:\n```cpp\nint asciiCode = f_28('A');\nstd::cout << asciiCode; // Çıktı: 65", "vi": "Hiển thị thông tin ASCII cho một ký tự nhất định.\n\n@param character Ký tự đầu vào mà thông tin ASCII sẽ được hiển thị.\n@return Mã ASCII tương ứng.\n\nVí dụ:\n```cpp\nint asciiCode = f_28('A');\nstd::cout << asciiCode; // Output: 65", "id": "Menampilkan informasi ASCII untuk karakter yang diberikan.\n\n@param character Karakter input yang akan ditampilkan informasi ASCII-nya.\n@return Kode ASCII yang sesuai.\n\nContoh:\ncpp\nint asciiCode = f_28('A');\nstd::cout << asciiCode; // Output: 65\n", "ja": "与えられた文字のASCII情報を表示します。\n\n@param character ASCII情報を表示するための入力文字。\n@return 対応するASCIIコード。\n\n例:\ncpp\nint asciiCode = f_28('A');\nstd::cout << asciiCode; // 出力: 65\n", "ko": "주어진 문자에 대한 ASCII 정보를 표시합니다.\n\n@param character ASCII 정보를 표시할 입력 문자입니다.\n@return 해당 ASCII 코드입니다.\n\n예시:\ncpp\nint asciiCode = f_28('A');\nstd::cout << asciiCode; // 출력: 65\n", "ml": "ഒരു നൽകിയ അക്ഷരത്തിനുള്ള ASCII വിവരങ്ങൾ പ്രദർശിപ്പിക്കുന്നു.\n\n@param character ASCII വിവരങ്ങൾ പ്രദർശിപ്പിക്കേണ്ട ഇൻപുട്ട് അക്ഷരം.\n@return അനുബന്ധ ASCII കോഡ്.\n\nഉദാഹരണം:\ncpp\nint asciiCode = f_28('A');\nstd::cout << asciiCode; // Output: 65\n", "fa": "اطلاعات ASCII را برای یک کاراکتر داده شده نمایش می‌دهد.\n\n@param character کاراکتر ورودی که اطلاعات ASCII برای آن نمایش داده می‌شود.\n@return کد ASCII مربوطه.\n\nمثال:\ncpp\nint asciiCode = f_28('A');\nstd::cout << asciiCode; // Output: 65\n"}}
{"task_id": "CPP/29", "prompt": {"en": "#include <cassert> // Used for making assertions in test cases\n/**\n * @brief Evaluate the grade for an input integer.\n * \n * @param score The integer score to be evaluated.\n * @return char The grade corresponding to the input score.\n *              If the score is between 90 and 100 (inclusive), returns 'A'.\n *              Otherwise, returns 'B'.\n * \n * Examples:\n *     f_29(90) -> 'A'\n *     f_29(89) -> 'B'\n */\nchar f_29(int score)", "sq": "#include <cassert> // Përdoret për të bërë pohime në rastet e testimit\n/**\n * @brief Vlerëson notën për një numër të plotë hyrës.\n * \n * @param score Nota e plotë që do të vlerësohet.\n * @return char Nota që korrespondon me notën hyrëse.\n *              Nëse nota është midis 90 dhe 100 (përfshirë), kthen 'A'.\n *              Përndryshe, kthen 'B'.\n * \n * Shembuj:\n *     f_29(90) -> 'A'\n *     f_29(89) -> 'B'\n */\nchar f_29(int score)", "hy": "#include <cassert> // Օգտագործվում է թեստային դեպքերում հաստատումներ կատարելու համար\n/**\n * @brief Գնահատել գնահատականը մուտքային ամբողջ թվի համար։\n * \n * @param score Գնահատման ենթակա ամբողջ թիվը։\n * @return char Մուտքային գնահատականին համապատասխանող գնահատականը։\n *              Եթե գնահատականը 90-ից 100 միջակայքում է (ներառյալ), վերադարձնում է 'A'։\n *              Հակառակ դեպքում, վերադարձնում է 'B'։\n * \n * Օրինակներ:\n *     f_29(90) -> 'A'\n *     f_29(89) -> 'B'\n */\nchar f_29(int score)", "bn": "#include <cassert> // টেস্ট কেসে অ্যাসারশন করার জন্য ব্যবহৃত\n\n/**\n * @brief একটি পূর্ণসংখ্যার জন্য গ্রেড নির্ধারণ করুন।\n * \n * @param score মূল্যায়ন করার জন্য পূর্ণসংখ্যার স্কোর।\n * @return char ইনপুট স্কোরের সাথে সম্পর্কিত গ্রেড।\n *              যদি স্কোর 90 এবং 100 এর মধ্যে (অন্তর্ভুক্ত) হয়, তবে 'A' প্রদান করে।\n *              অন্যথায়, 'B' প্রদান করে।\n * \n * উদাহরণ:\n *     f_29(90) -> 'A'\n *     f_29(89) -> 'B'\n */\nchar f_29(int score)", "bg": "#include <cassert> // Използва се за правене на твърдения в тестовите случаи\n/**\n * @brief Оценява оценката за входно цяло число.\n * \n * @param score Цялото число, което трябва да бъде оценено.\n * @return char Оценката, съответстваща на входното число.\n *              Ако числото е между 90 и 100 (включително), връща 'A'.\n *              В противен случай връща 'B'.\n * \n * Примери:\n *     f_29(90) -> 'A'\n *     f_29(89) -> 'B'\n */\nchar f_29(int score)", "zh": "#include <cassert> // 用于在测试用例中进行断言\n/**\n * @brief 评估输入整数的等级。\n * \n * @param score 要评估的整数分数。\n * @return char 与输入分数对应的等级。\n *              如果分数在90到100之间（包括90和100），返回'A'。\n *              否则，返回'B'。\n * \n * 示例:\n *     f_29(90) -> 'A'\n *     f_29(89) -> 'B'\n */\nchar f_29(int score)", "fr": "#include <cassert> // Utilisé pour faire des assertions dans les cas de test\n/**\n * @brief Évaluer la note pour un entier en entrée.\n * \n * @param score Le score entier à évaluer.\n * @return char La note correspondant au score d'entrée.\n *              Si le score est entre 90 et 100 (inclus), retourne 'A'.\n *              Sinon, retourne 'B'.\n * \n * Exemples:\n *     f_29(90) -> 'A'\n *     f_29(89) -> 'B'\n */\nchar f_29(int score)", "de": "#include <cassert> // Wird für die Erstellung von Assertions in Testfällen verwendet\n/**\n * @brief Bewertet die Note für eine Eingabezahl.\n * \n * @param score Die zu bewertende Ganzzahl.\n * @return char Die Note, die der Eingabezahl entspricht.\n *              Wenn die Punktzahl zwischen 90 und 100 (einschließlich) liegt, wird 'A' zurückgegeben.\n *              Andernfalls wird 'B' zurückgegeben.\n * \n * Beispiele:\n *     f_29(90) -> 'A'\n *     f_29(89) -> 'B'\n */\nchar f_29(int score)", "ha": "#include <cassert> // Ana amfani da wannan don yin tabbaci a cikin gwaje-gwaje\n\n/**\n * @brief Kimanta darajar maki na adadi.\n * \n * @param score Maki na adadi da za a kimanta.\n * @return char Darajar da ta dace da maki da aka shigar.\n *              Idan maki yana tsakanin 90 da 100 (ciki har da), zai dawo da 'A'.\n *              In ba haka ba, zai dawo da 'B'.\n * \n * Misalai:\n *     f_29(90) -> 'A'\n *     f_29(89) -> 'B'\n */ \nchar f_29(int score)", "hi": "#include <cassert> // परीक्षण मामलों में दावे करने के लिए उपयोग किया जाता है\n/**\n * @brief एक इनपुट पूर्णांक के लिए ग्रेड का मूल्यांकन करें।\n * \n * @param score मूल्यांकन के लिए पूर्णांक स्कोर।\n * @return char इनपुट स्कोर के अनुरूप ग्रेड।\n *              यदि स्कोर 90 और 100 (समावेशी) के बीच है, तो 'A' लौटाता है।\n *              अन्यथा, 'B' लौटाता है।\n * \n * उदाहरण:\n *     f_29(90) -> 'A'\n *     f_29(89) -> 'B'\n */\nchar f_29(int score)", "hu": "#include <cassert> // Használva az állítások megfogalmazására tesztesetekben\n/**\n * @brief Értékeli a bemeneti egész szám osztályzatát.\n * \n * @param score Az értékelendő egész szám pontszám.\n * @return char Az osztályzat, amely megfelel a bemeneti pontszámnak.\n *              Ha a pontszám 90 és 100 között van (beleértve), 'A'-t ad vissza.\n *              Egyébként 'B'-t ad vissza.\n * \n * Példák:\n *     f_29(90) -> 'A'\n *     f_29(89) -> 'B'\n */\nchar f_29(int score)", "es": "#include <cassert> // Usado para hacer afirmaciones en casos de prueba\n/**\n * @brief Evalúa la calificación para un entero de entrada.\n * \n * @param score La puntuación entera a evaluar.\n * @return char La calificación correspondiente a la puntuación de entrada.\n *              Si la puntuación está entre 90 y 100 (inclusive), devuelve 'A'.\n *              De lo contrario, devuelve 'B'.\n * \n * Ejemplos:\n *     f_29(90) -> 'A'\n *     f_29(89) -> 'B'\n */\nchar f_29(int score)", "arb": "#include <cassert> // مستخدم لإجراء التأكيدات في حالات الاختبار\n/**\n * @brief تقييم الدرجة لعدد صحيح مدخل.\n * \n * @param score الدرجة الصحيحة التي سيتم تقييمها.\n * @return char الدرجة المقابلة للدرجة المدخلة.\n *              إذا كانت الدرجة بين 90 و 100 (شاملة)، تعيد 'A'.\n *              خلاف ذلك، تعيد 'B'.\n * \n * أمثلة:\n *     f_29(90) -> 'A'\n *     f_29(89) -> 'B'\n */\nchar f_29(int score)", "sw": "#include <cassert> // Inatumika kwa kufanya uthibitisho katika kesi za majaribio\n/**\n * @brief Tambua alama kwa namba kamili iliyoingizwa.\n * \n * @param score Alama ya namba kamili itakayotathminiwa.\n * @return char Alama inayolingana na alama iliyoingizwa.\n *              Ikiwa alama iko kati ya 90 na 100 (ikiwemo), inarudisha 'A'.\n *              Vinginevyo, inarudisha 'B'.\n * \n * Mifano:\n *     f_29(90) -> 'A'\n *     f_29(89) -> 'B'\n */\nchar f_29(int score)", "tr": "#include <cassert> // Test durumlarında doğrulama yapmak için kullanılır\n/**\n * @brief Bir tam sayı notunu değerlendirir.\n * \n * @param score Değerlendirilecek tam sayı notu.\n * @return char Girdi notuna karşılık gelen harf notu.\n *              Eğer not 90 ile 100 arasında (dahil) ise, 'A' döner.\n *              Aksi takdirde, 'B' döner.\n * \n * Örnekler:\n *     f_29(90) -> 'A'\n *     f_29(89) -> 'B'\n */\nchar f_29(int score)", "vi": "#include <cassert> // Được sử dụng để thực hiện các khẳng định trong các trường hợp kiểm tra\n/**\n * @brief Đánh giá điểm cho một số nguyên đầu vào.\n * \n * @param score Điểm số nguyên cần được đánh giá.\n * @return char Điểm tương ứng với điểm số đầu vào.\n *              Nếu điểm số nằm trong khoảng từ 90 đến 100 (bao gồm cả 90 và 100), trả về 'A'.\n *              Ngược lại, trả về 'B'.\n * \n * Ví dụ:\n *     f_29(90) -> 'A'\n *     f_29(89) -> 'B'\n */\nchar f_29(int score)", "id": "#include <cassert> // Digunakan untuk membuat pernyataan dalam kasus uji\n/**\n * @brief Mengevaluasi nilai untuk sebuah bilangan bulat masukan.\n * \n * @param score Skor bilangan bulat yang akan dievaluasi.\n * @return char Nilai yang sesuai dengan skor masukan.\n *              Jika skor antara 90 dan 100 (inklusif), mengembalikan 'A'.\n *              Jika tidak, mengembalikan 'B'.\n * \n * Contoh:\n *     f_29(90) -> 'A'\n *     f_29(89) -> 'B'\n */\nchar f_29(int score)", "ja": "#include <cassert> // テストケースでアサーションを行うために使用されます\n/**\n * @brief 入力された整数の評価を行います。\n * \n * @param score 評価される整数スコア。\n * @return char 入力スコアに対応するグレード。\n *              スコアが90から100の間（含む）の場合、'A'を返します。\n *              それ以外の場合は、'B'を返します。\n * \n * 例:\n *     f_29(90) -> 'A'\n *     f_29(89) -> 'B'\n */\nchar f_29(int score)", "ko": "#include <cassert> // 테스트 케이스에서 주장을 하기 위해 사용됨\n/**\n * @brief 입력 정수에 대한 등급을 평가합니다.\n * \n * @param score 평가할 정수 점수입니다.\n * @return char 입력 점수에 해당하는 등급입니다.\n *              점수가 90에서 100 사이(포함)인 경우, 'A'를 반환합니다.\n *              그렇지 않으면, 'B'를 반환합니다.\n * \n * 예시:\n *     f_29(90) -> 'A'\n *     f_29(89) -> 'B'\n */\nchar f_29(int score)", "ml": "#include <cassert> // ടെസ്റ്റ് കേസുകളിൽ ഉറപ്പുകൾ നടത്താൻ ഉപയോഗിക്കുന്നു\n/**\n * @brief ഒരു ഇൻപുട്ട് പൂർണ്ണസംഖ്യയുടെ ഗ്രേഡ് വിലയിരുത്തുക.\n * \n * @param score വിലയിരുത്തേണ്ട പൂർണ്ണസംഖ്യ സ്കോർ.\n * @return char ഇൻപുട്ട് സ്കോറിനൊത്തുള്ള ഗ്രേഡ്.\n *              സ്കോർ 90 മുതൽ 100 (ഉൾപ്പെടെ) വരെ ആണെങ്കിൽ, 'A' മടക്കിനൽകുന്നു.\n *              അല്ലെങ്കിൽ, 'B' മടക്കിനൽകുന്നു.\n * \n * ഉദാഹരണങ്ങൾ:\n *     f_29(90) -> 'A'\n *     f_29(89) -> 'B'\n */\nchar f_29(int score)", "fa": "#include <cassert> // برای ایجاد اطمینان در موارد تست استفاده می‌شود\n/**\n * @brief ارزیابی نمره برای یک عدد صحیح ورودی.\n * \n * @param score نمره صحیحی که باید ارزیابی شود.\n * @return char نمره‌ای که با نمره ورودی مطابقت دارد.\n *              اگر نمره بین 90 و 100 (شامل) باشد، 'A' برمی‌گرداند.\n *              در غیر این صورت، 'B' برمی‌گرداند.\n * \n * Examples:\n *     f_29(90) -> 'A'\n *     f_29(89) -> 'B'\n */\nchar f_29(int score)"}, "canonical_solution": "{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}", "instruction": {"en": "char f_29(int score)\n{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.", "sq": "char f_29(int score)\n{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit CPP në shqip duke përdorur maksimumi 500 karaktere.", "hy": "char f_29(int score)\n{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}\n\nՏվեք հակիրճ բնական լեզվով նկարագրություն (docstring) այս CPP կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "char f_29(int score)\n{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}\n\nসিপিপি কোডের জন্য একটি সংক্ষিপ্ত বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।", "bg": "char f_29(int score)\n{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}\n\nПредоставете кратко описание на CPP кода на български език, използвайки не повече от 500 символа.", "zh": "char f_29(int score)\n{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}\n\n请用不超过500个字符的中文为以下CPP代码提供简洁的自然语言描述（文档字符串）。", "fr": "char f_29(int score)\n{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}\n\nFournissez une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.", "de": "char f_29(int score)\n{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "char f_29(int score)\n{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar CPP a cikin Hausa ta amfani da haruffa 500 kacal.", "hi": "char f_29(int score)\n{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "char f_29(int score)\n{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a CPP kódról magyarul, legfeljebb 500 karakterben.", "es": "char f_29(int score)\n{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando un máximo de 500 caracteres.", "arb": "char f_29(int score)\n{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C++ باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "char f_29(int score)\n{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "char f_29(int score)\n{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}\n\nAşağıdaki CPP kodunun Türkçe dilinde en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.", "vi": "char f_29(int score)\n{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự.", "id": "char f_29(int score)\n{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode CPP dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "char f_29(int score)\n{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}\n\n以下のCPPコードの簡潔な自然言語による説明（ドックストリング）を日本語で500文字以内で提供してください。", "ko": "char f_29(int score)\n{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}\n\n다음 CPP 코드에 대한 간결한 자연어 설명(도크스트링)을 한국어로 500자 이내로 제공하세요.", "ml": "char f_29(int score)\n{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}\n\nCPP കോഡ് സംബന്ധിച്ച സംക്ഷിപ്തമായ ഒരു സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) പരമാവധി 500 അക്ഷരങ്ങൾ ഉപയോഗിച്ച് മലയാളത്തിൽ നൽകുക.", "fa": "char f_29(int score)\n{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}\n\nتوضیح مختصر و طبیعی (docstring) از کد CPP به زبان فارسی ارائه دهید که حداکثر ۵۰۰ کاراکتر باشد."}, "level": "", "test": "int main() {\n    assert(f_29(90) == 'A'); // Test for lower bound of 'A' grade\n    assert(f_29(89) == 'B'); // Test for score just below 'A' grade\n    assert(f_29(95) == 'A'); // Test for a score well within the 'A' range\n    assert(f_29(100) == 'A'); // Test for upper boundary of 'A' grade\n    assert(f_29(101) == 'B'); // Test for score above 'A' grade range\n\n    // Print \"All tests passed\" if all assertions hold true (optional)\n    // std::cout << \"All tests passed\\n\";\n\n    return 0;\n}", "entry_point": "f_29", "signature": "char f_29(int score)", "docstring": {"en": "Evaluate the grade for an input integer.\n\n@param score The integer score to be evaluated.\n@return char The grade corresponding to the input score.\n             If the score is between 90 and 100 (inclusive), returns 'A'.\n             Otherwise, returns 'B'.\n\nExamples:\n    f_29(90) -> 'A'\n    f_29(89) -> 'B'\n", "sq": "Vlerësoni notën për një numër të plotë hyrës.\n\n@param score Numri i plotë i pikëve që do të vlerësohet.\n@return char Nota që korrespondon me pikët hyrëse.\n             Nëse pikët janë midis 90 dhe 100 (përfshirë), kthen 'A'.\n             Përndryshe, kthen 'B'.\n\nShembuj:\n    f_29(90) -> 'A'\n    f_29(89) -> 'B'", "hy": "Հաշվարկել գնահատականը մուտքային ամբողջ թվի համար։\n\n@param score Գնահատվող ամբողջ թվային միավորը։\n@return char Մուտքային միավորին համապատասխան գնահատականը։\n             Եթե միավորը 90-ից 100-ի (ներառյալ) միջև է, վերադարձնում է 'A'։\n             Հակառակ դեպքում, վերադարձնում է 'B'։\n\nՕրինակներ:\n    f_29(90) -> 'A'\n    f_29(89) -> 'B'", "bn": "একটি ইনপুট পূর্ণসংখ্যার জন্য গ্রেড মূল্যায়ন করুন।\n\n@param score মূল্যায়ন করার জন্য পূর্ণসংখ্যার স্কোর।\n@return char ইনপুট স্কোরের সাথে সম্পর্কিত গ্রেড।\n             যদি স্কোর 90 এবং 100 এর মধ্যে হয় (অন্তর্ভুক্ত), তবে 'A' ফেরত দেয়।\n             অন্যথায়, 'B' ফেরত দেয়।\n\nউদাহরণ:\n    f_29(90) -> 'A'\n    f_29(89) -> 'B'", "bg": "Оценете оценката за входящо цяло число.\n\n@param score Цялото число, което трябва да бъде оценено.\n@return char Оценката, съответстваща на входящия резултат.\n             Ако резултатът е между 90 и 100 (включително), връща 'A'.\n             В противен случай връща 'B'.\n\nПримери:\n    f_29(90) -> 'A'\n    f_29(89) -> 'B'", "zh": "评估输入整数的等级。\n\n@param score 要评估的整数分数。\n@return char 与输入分数对应的等级。\n如果分数在90到100之间（包括90和100），返回'A'。\n             否则，返回'B'。\n\n示例：\n    f_29(90) -> 'A'\n    f_29(89) -> 'B'", "fr": "Évaluer la note pour un entier en entrée.\n\n@param score L'entier score à évaluer.\n@return char La note correspondant au score d'entrée.\n             Si le score est entre 90 et 100 (inclus), retourne 'A'.\n             Sinon, retourne 'B'.\n\nExemples :\n    f_29(90) -> 'A'\n    f_29(89) -> 'B'", "de": "Bewerten Sie die Note für eine eingegebene ganze Zahl.\n\n@param score Die ganzzahlige Punktzahl, die bewertet werden soll.\n@return char Die Note, die der eingegebenen Punktzahl entspricht.\n             Wenn die Punktzahl zwischen 90 und 100 (einschließlich) liegt, wird 'A' zurückgegeben.\n             Andernfalls wird 'B' zurückgegeben.\n\nBeispiele:\n    f_29(90) -> 'A'\n    f_29(89) -> 'B'", "ha": "Kimanta darajar don shigar da cikakken lamba.\n\n@param score Lambar da za a tantance.\n@return char Darajar da ta dace da lambar shigarwa.\n             Idan lambar tana tsakanin 90 da 100 (ciki har da), yana dawowa 'A'.\n             In ba haka ba, yana dawowa 'B'.\n\nMisalai:\n    f_29(90) -> 'A'\n    f_29(89) -> 'B'", "hi": "इनपुट पूर्णांक के लिए ग्रेड का मूल्यांकन करें।\n\n@param score मूल्यांकन के लिए पूर्णांक स्कोर।\n@return char इनपुट स्कोर के अनुरूप ग्रेड।\n             यदि स्कोर 90 और 100 (समावेशी) के बीच है, तो 'A' लौटाता है।\n             अन्यथा, 'B' लौटाता है।\n\nउदाहरण:\n    f_29(90) -> 'A'\n    f_29(89) -> 'B'", "hu": "Értékelje egy bemeneti egész szám osztályzatát.\n\n@param score Az értékelendő egész szám pontszám.\n@return char Az osztályzat, amely megfelel a bemeneti pontszámnak.\n             Ha a pontszám 90 és 100 között van (beleértve), 'A'-t ad vissza.\n             Egyébként 'B'-t ad vissza.\n\nPéldák:\n    f_29(90) -> 'A'\n    f_29(89) -> 'B'", "es": "Evalúa la calificación para un entero de entrada.\n\n@param score El puntaje entero a ser evaluado.\n@return char La calificación correspondiente al puntaje de entrada.\n             Si el puntaje está entre 90 y 100 (inclusive), devuelve 'A'.\n             De lo contrario, devuelve 'B'.\n\nEjemplos:\n    f_29(90) -> 'A'\n    f_29(89) -> 'B'", "arb": "تقييم الدرجة لعدد صحيح مدخل.\n\n@param score الدرجة الصحيحة التي سيتم تقييمها.\n@return char الدرجة المقابلة للدرجة المدخلة.\n             إذا كانت الدرجة بين 90 و 100 (شاملة)، تعيد 'A'.\n             خلاف ذلك، تعيد 'B'.\n\nأمثلة:\n    f_29(90) -> 'A'\n    f_29(89) -> 'B'", "sw": "Tambua alama kwa namba kamili iliyoingizwa.\n\n@param score Alama ya nambari ambayo itatathminiwa.\n@return char Alama inayolingana na alama ya ingizo.\n             Ikiwa alama iko kati ya 90 na 100 (pamoja), inarudisha 'A'.\n             Vinginevyo, inarudisha 'B'.\n\nMifano:\n    f_29(90) -> 'A'\n    f_29(89) -> 'B'", "tr": "Bir girdi tam sayısının notunu değerlendirin.\n\n@param score Değerlendirilecek tam sayı puanı.\n@return char Girdi puanına karşılık gelen not.\n             Eğer puan 90 ile 100 arasında (dahil) ise, 'A' döner.\n             Aksi takdirde, 'B' döner.\n\nÖrnekler:\n    f_29(90) -> 'A'\n    f_29(89) -> 'B'", "vi": "Đánh giá điểm cho một số nguyên đầu vào.\n\n@param score Số nguyên điểm cần được đánh giá.\n@return char Điểm tương ứng với điểm đầu vào.\n             Nếu điểm nằm trong khoảng từ 90 đến 100 (bao gồm cả 90 và 100), trả về 'A'.\n             Ngược lại, trả về 'B'.\n\nVí dụ:\n    f_29(90) -> 'A'\n    f_29(89) -> 'B'", "id": "Evaluasi nilai untuk sebuah bilangan bulat masukan.\n\n@param score Nilai bilangan bulat yang akan dievaluasi.\n@return char Nilai huruf yang sesuai dengan nilai masukan.\n             Jika nilai antara 90 dan 100 (inklusif), mengembalikan 'A'.\n             Jika tidak, mengembalikan 'B'.\n\nContoh:\n    f_29(90) -> 'A'\n    f_29(89) -> 'B'", "ja": "入力された整数の評価を行います。\n\n@param score 評価される整数のスコア。\n@return char 入力スコアに対応する成績。\n             スコアが90から100の間（含む）の場合、'A'を返します。\n             それ以外の場合は、'B'を返します。\n\n例:\n    f_29(90) -> 'A'\n    f_29(89) -> 'B'", "ko": "입력 정수에 대한 등급을 평가합니다.\n\n@param score 평가할 정수 점수입니다.\n@return char 입력 점수에 해당하는 등급입니다.\n             점수가 90에서 100 사이(포함)인 경우 'A'를 반환합니다.\n             그렇지 않으면 'B'를 반환합니다.\n\n예시:\n    f_29(90) -> 'A'\n    f_29(89) -> 'B'", "ml": "ഒരു ഇൻപുട്ട് പൂർണ്ണസംഖ്യയുടെ ഗ്രേഡ് വിലയിരുത്തുക.\n\n@param score മൂല്യനിർണ്ണയം ചെയ്യേണ്ട പൂർണ്ണസംഖ്യ സ്കോർ.\n@return char ഇൻപുട്ട് സ്കോറിനനുസരിച്ചുള്ള ഗ്രേഡ്.\n             സ്കോർ 90നും 100നും ഇടയിൽ (ഉൾപ്പെടെ) ആണെങ്കിൽ, 'A' തിരികെ നൽകുന്നു.\n             അല്ലെങ്കിൽ, 'B' തിരികെ നൽകുന്നു.\n\nഉദാഹരണങ്ങൾ:\n    f_29(90) -> 'A'\n    f_29(89) -> 'B'", "fa": "ارزیابی نمره برای یک عدد صحیح ورودی.\n\n@param score نمره صحیحی که باید ارزیابی شود.\n@return char نمره‌ای که با نمره ورودی مطابقت دارد.\n             اگر نمره بین 90 و 100 (شامل) باشد، 'A' را برمی‌گرداند.\n             در غیر این صورت، 'B' را برمی‌گرداند.\n\nمثال‌ها:\n    f_29(90) -> 'A'\n    f_29(89) -> 'B'"}}
{"task_id": "CPP/30", "prompt": {"en": "#include <cassert>\n#include <cstring>\n#include <cstdio>\n/**\n * Checks if a three-character string has exactly two characters that are the same.\n * \n * @param s A three-character string to be checked.\n * \n * @return Returns \"Yes\" if the input has exactly two equal characters, otherwise \"No\".\n * Examples:\n *   >>> f_30(\"112\")\n *   \"Yes\"\n *   >>> f_30(\"123\")\n *   \"No\"\n */\nconst char* f_30(const char s[4])", "sq": "#include <cassert>\n#include <cstring>\n#include <cstdio>\n/**\n * Kontrollon nëse një varg me tre karaktere ka saktësisht dy karaktere që janë të njëjta.\n * \n * @param s Një varg me tre karaktere që do të kontrollohet.\n * \n * @return Kthen \"Yes\" nëse hyrja ka saktësisht dy karaktere të barabartë, përndryshe \"No\".\n * Shembuj:\n *   >>> f_30(\"112\")\n *   \"Yes\"\n *   >>> f_30(\"123\")\n *   \"No\"\n */\nconst char* f_30(const char s[4])", "hy": "#include <cassert>\n#include <cstring>\n#include <cstdio>\n/**\n * Ստուգում է, արդյոք երեք նիշից բաղկացած տողը ունի՞ հենց երկու նույնական նիշ:\n * \n * @param s Երեք նիշից բաղկացած տող, որը պետք է ստուգվի:\n * \n * @return Վերադարձնում է \"Yes\", եթե մուտքագրումը ունի հենց երկու հավասար նիշ, այլապես \"No\":\n * Օրինակներ:\n *   >>> f_30(\"112\")\n *   \"Yes\"\n *   >>> f_30(\"123\")\n *   \"No\"\n */\nconst char* f_30(const char s[4])", "bn": "#include <cassert>\n#include <cstring>\n#include <cstdio>\n/**\n * পরীক্ষা করে যে একটি তিন-অক্ষরের স্ট্রিংয়ে ঠিক দুটি অক্ষর একই কি না।\n * \n * @param s একটি তিন-অক্ষরের স্ট্রিং যা পরীক্ষা করা হবে।\n * \n * @return \"Yes\" রিটার্ন করে যদি ইনপুটে ঠিক দুটি সমান অক্ষর থাকে, অন্যথায় \"No\"।\n * উদাহরণ:\n *   >>> f_30(\"112\")\n *   \"Yes\"\n *   >>> f_30(\"123\")\n *   \"No\"\n */\nconst char* f_30(const char s[4])", "bg": "#include <cassert>\n#include <cstring>\n#include <cstdio>\n/**\n * Проверява дали низ от три знака има точно два еднакви знака.\n * \n * @param s Низ от три знака, който да бъде проверен.\n * \n * @return Връща \"Yes\", ако входът има точно два еднакви знака, в противен случай \"No\".\n * Примери:\n *   >>> f_30(\"112\")\n *   \"Yes\"\n *   >>> f_30(\"123\")\n *   \"No\"\n */\nconst char* f_30(const char s[4])", "zh": "#include <cassert>\n#include <cstring>\n#include <cstdio>\n/**\n * 检查一个三字符的字符串是否有且仅有两个字符相同。\n * \n * @param s 要检查的三字符字符串。\n * \n * @return 如果输入有且仅有两个相同的字符，返回 \"Yes\"，否则返回 \"No\"。\n * 示例:\n *   >>> f_30(\"112\")\n *   \"Yes\"\n *   >>> f_30(\"123\")\n *   \"No\"\n */\nconst char* f_30(const char s[4])", "fr": "#include <cassert>\n#include <cstring>\n#include <cstdio>\n/**\n * Vérifie si une chaîne de trois caractères a exactement deux caractères identiques.\n * \n * @param s Une chaîne de trois caractères à vérifier.\n * \n * @return Renvoie \"Yes\" si l'entrée a exactement deux caractères égaux, sinon \"No\".\n * Exemples :\n *   >>> f_30(\"112\")\n *   \"Yes\"\n *   >>> f_30(\"123\")\n *   \"No\"\n */\nconst char* f_30(const char s[4])", "de": "#include <cassert>\n#include <cstring>\n#include <cstdio>\n/**\n * Überprüft, ob ein drei Zeichen langer String genau zwei gleiche Zeichen hat.\n * \n * @param s Ein drei Zeichen langer String, der überprüft werden soll.\n * \n * @return Gibt \"Yes\" zurück, wenn der Eingabewert genau zwei gleiche Zeichen hat, andernfalls \"No\".\n * Beispiele:\n *   >>> f_30(\"112\")\n *   \"Yes\"\n *   >>> f_30(\"123\")\n *   \"No\"\n */\nconst char* f_30(const char s[4])", "ha": "#include <cassert>\n#include <cstring>\n#include <cstdio>\n/**\n * Duba idan wata kirtani mai haruffa uku tana da ainihin haruffa biyu da suke daidai.\n * \n * @param s Wata kirtani mai haruffa uku da za a duba.\n * \n * @return Ya dawo da \"Yes\" idan shigarwar tana da ainihin haruffa biyu masu daidai, in ba haka ba \"No\".\n * Misalai:\n *   >>> f_30(\"112\")\n *   \"Yes\"\n *   >>> f_30(\"123\")\n *   \"No\"\n */\nconst char* f_30(const char s[4])", "hi": "#include <cassert>\n#include <cstring>\n#include <cstdio>\n/**\n * जाँचता है कि क्या तीन-अक्षरों की स्ट्रिंग में ठीक दो अक्षर समान हैं।\n * \n * @param s एक तीन-अक्षरों की स्ट्रिंग जिसे जाँचना है।\n * \n * @return \"Yes\" लौटाता है यदि इनपुट में ठीक दो समान अक्षर हैं, अन्यथा \"No\"।\n * उदाहरण:\n *   >>> f_30(\"112\")\n *   \"Yes\"\n *   >>> f_30(\"123\")\n *   \"No\"\n */\nconst char* f_30(const char s[4])", "hu": "#include <cassert>\n#include <cstring>\n#include <cstdio>\n/**\n * Ellenőrzi, hogy egy három karakterből álló stringben pontosan két azonos karakter van-e.\n * \n * @param s Egy három karakterből álló string, amelyet ellenőrizni kell.\n * \n * @return Visszatér \"Yes\"-szel, ha a bemenetben pontosan két egyenlő karakter van, különben \"No\"-val.\n * Példák:\n *   >>> f_30(\"112\")\n *   \"Yes\"\n *   >>> f_30(\"123\")\n *   \"No\"\n */\nconst char* f_30(const char s[4])", "es": "#include <cassert>\n#include <cstring>\n#include <cstdio>\n/**\n * Verifica si una cadena de tres caracteres tiene exactamente dos caracteres que son iguales.\n * \n * @param s Una cadena de tres caracteres a verificar.\n * \n * @return Devuelve \"Yes\" si la entrada tiene exactamente dos caracteres iguales, de lo contrario \"No\".\n * Ejemplos:\n *   >>> f_30(\"112\")\n *   \"Yes\"\n *   >>> f_30(\"123\")\n *   \"No\"\n */\nconst char* f_30(const char s[4])", "arb": "#include <cassert>\n#include <cstring>\n#include <cstdio>\n/**\n * يتحقق مما إذا كانت سلسلة مكونة من ثلاثة أحرف تحتوي على حرفين متطابقين بالضبط.\n * \n * @param s سلسلة مكونة من ثلاثة أحرف للتحقق منها.\n * \n * @return يعيد \"Yes\" إذا كانت المدخلات تحتوي على حرفين متساويين بالضبط، وإلا يعيد \"No\".\n * أمثلة:\n *   >>> f_30(\"112\")\n *   \"Yes\"\n *   >>> f_30(\"123\")\n *   \"No\"\n */\nconst char* f_30(const char s[4])", "sw": "#include <cassert>\n#include <cstring>\n#include <cstdio>\n/**\n * Hukagua kama kamba yenye herufi tatu ina herufi mbili ambazo ni sawa.\n * \n * @param s Kamba yenye herufi tatu inayopaswa kukaguliwa.\n * \n * @return Inarudisha \"Yes\" ikiwa ingizo lina herufi mbili sawa, vinginevyo \"No\".\n * Mifano:\n *   >>> f_30(\"112\")\n *   \"Yes\"\n *   >>> f_30(\"123\")\n *   \"No\"\n */\nconst char* f_30(const char s[4])", "tr": "#include <cassert>\n#include <cstring>\n#include <cstdio>\n/**\n * Üç karakterli bir dizgede tam olarak iki karakterin aynı olup olmadığını kontrol eder.\n * \n * @param s Kontrol edilecek üç karakterli bir dizge.\n * \n * @return Girdi tam olarak iki eşit karaktere sahipse \"Yes\", aksi takdirde \"No\" döner.\n * Örnekler:\n *   >>> f_30(\"112\")\n *   \"Yes\"\n *   >>> f_30(\"123\")\n *   \"No\"\n */\nconst char* f_30(const char s[4])", "vi": "#include <cassert>\n#include <cstring>\n#include <cstdio>\n/**\n * Kiểm tra xem một chuỗi ba ký tự có chính xác hai ký tự giống nhau hay không.\n * \n * @param s Một chuỗi ba ký tự cần được kiểm tra.\n * \n * @return Trả về \"Yes\" nếu đầu vào có chính xác hai ký tự bằng nhau, ngược lại \"No\".\n * Ví dụ:\n *   >>> f_30(\"112\")\n *   \"Yes\"\n *   >>> f_30(\"123\")\n *   \"No\"\n */\nconst char* f_30(const char s[4])", "id": "#include <cassert>\n#include <cstring>\n#include <cstdio>\n/**\n * Memeriksa apakah string tiga karakter memiliki tepat dua karakter yang sama.\n * \n * @param s Sebuah string tiga karakter yang akan diperiksa.\n * \n * @return Mengembalikan \"Yes\" jika input memiliki tepat dua karakter yang sama, jika tidak \"No\".\n * Contoh:\n *   >>> f_30(\"112\")\n *   \"Yes\"\n *   >>> f_30(\"123\")\n *   \"No\"\n */\nconst char* f_30(const char s[4])", "ja": "#include <cassert>\n#include <cstring>\n#include <cstdio>\n/**\n * 3文字の文字列に、正確に2つの同じ文字があるかどうかを確認します。\n * \n * @param s 確認する3文字の文字列。\n * \n * @return 入力に正確に2つの等しい文字がある場合は \"Yes\" を返し、そうでない場合は \"No\" を返します。\n * 例:\n *   >>> f_30(\"112\")\n *   \"Yes\"\n *   >>> f_30(\"123\")\n *   \"No\"\n */\nconst char* f_30(const char s[4])\n", "ko": "#include <cassert>\n#include <cstring>\n#include <cstdio>\n/**\n * 세 글자 문자열에 정확히 두 개의 동일한 문자가 있는지 확인합니다.\n * \n * @param s 확인할 세 글자 문자열입니다.\n * \n * @return 입력에 정확히 두 개의 동일한 문자가 있으면 \"Yes\"를 반환하고, 그렇지 않으면 \"No\"를 반환합니다.\n * 예시:\n *   >>> f_30(\"112\")\n *   \"Yes\"\n *   >>> f_30(\"123\")\n *   \"No\"\n */\nconst char* f_30(const char s[4])", "ml": "#include <cassert>\n#include <cstring>\n#include <cstdio>\n/**\n * ഒരു മൂന്ന് അക്ഷരങ്ങളുള്ള സ്ട്രിംഗിൽ കൃത്യമായി രണ്ട് അക്ഷരങ്ങൾ ഒരേപോലെയാണോ എന്ന് പരിശോധിക്കുന്നു.\n * \n * @param s പരിശോധിക്കേണ്ട മൂന്ന് അക്ഷരങ്ങളുള്ള സ്ട്രിംഗ്.\n * \n * @return ഇൻപുട്ടിൽ കൃത്യമായി രണ്ട് സമാനമായ അക്ഷരങ്ങൾ ഉണ്ടെങ്കിൽ \"Yes\" തിരികെ നൽകുന്നു, അല്ലെങ്കിൽ \"No\" തിരികെ നൽകുന്നു.\n * ഉദാഹരണങ്ങൾ:\n *   >>> f_30(\"112\")\n *   \"Yes\"\n *   >>> f_30(\"123\")\n *   \"No\"\n */\nconst char* f_30(const char s[4])", "fa": "#include <cassert>\n#include <cstring>\n#include <cstdio>\n/**\n * بررسی می‌کند که آیا یک رشته سه‌کاراکتری دقیقاً دو کاراکتر مشابه دارد.\n * \n * @param s یک رشته سه‌کاراکتری که باید بررسی شود.\n * \n * @return \"Yes\" را برمی‌گرداند اگر ورودی دقیقاً دو کاراکتر برابر داشته باشد، در غیر این صورت \"No\".\n * مثال‌ها:\n *   >>> f_30(\"112\")\n *   \"Yes\"\n *   >>> f_30(\"123\")\n *   \"No\"\n */\nconst char* f_30(const char s[4])"}, "canonical_solution": "{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}", "instruction": {"en": "const char* f_30(const char s[4])\n{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.", "sq": "const char* f_30(const char s[4])\n{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrale (docstring) të kodit CPP në shqip duke përdorur maksimumi 500 karaktere.", "hy": "const char* f_30(const char s[4])\n{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\nՏվեք կարճ բնական լեզվով նկարագրություն (docstring) այս CPP կոդի համար՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "const char* f_30(const char s[4])\n{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\nসিপিপি কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।", "bg": "const char* f_30(const char s[4])\n{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\nПредоставете кратко описание на CPP кода на естествен език на български, като използвате максимум 500 знака.", "zh": "const char* f_30(const char s[4])\n{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\n请用不超过500个字符的中文为以下CPP代码提供简洁的自然语言描述（文档字符串）。", "fr": "const char* f_30(const char s[4])\n{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\nFournir une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.", "de": "const char* f_30(const char s[4])\n{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "const char* f_30(const char s[4])\n{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar CPP cikin Hausa ta amfani da haruffa 500 kacal.", "hi": "const char* f_30(const char s[4])\n{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "const char* f_30(const char s[4])\n{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a CPP kódról magyarul, legfeljebb 500 karakterben.", "es": "const char* f_30(const char s[4])\n{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando como máximo 500 caracteres.", "arb": "const char* f_30(const char s[4])\n{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C++ باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "const char* f_30(const char s[4])\n{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "const char* f_30(const char s[4])\n{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\nAşağıdaki CPP kodunun doğal dilde kısa bir açıklamasını (docstring) Türkçe olarak en fazla 500 karakter kullanarak sağlayın.", "vi": "const char* f_30(const char s[4])\n{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt, tối đa 500 ký tự.", "id": "const char* f_30(const char s[4])\n{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode CPP dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "const char* f_30(const char s[4])\n{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\n以下のCPPコードの簡潔な自然言語による説明（ドックストリング）を日本語で500文字以内で提供してください。", "ko": "const char* f_30(const char s[4])\n{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\n다음 CPP 코드의 동작을 최대 500자 이내의 자연어로 간결하게 설명하는 문서 문자열(docstring)을 한국어로 제공하십시오.", "ml": "const char* f_30(const char s[4])\n{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\nസിപിപി കോഡിന്റെ സംക്ഷിപ്തമായ സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) മലയാളത്തിൽ 500 അക്ഷരങ്ങളിൽ കൂടുതൽ അല്ലാത്ത രീതിയിൽ നൽകുക.", "fa": "const char* f_30(const char s[4])\n{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\nتوضیح مختصری به زبان طبیعی (docstring) از کد CPP به زبان فارسی ارائه دهید که حداکثر ۵۰۰ کاراکتر باشد."}, "level": "", "test": "int main() {\n    // Testing the logic with various cases and using string comparison for assert.\n    assert(strcmp(f_30(\"112\"), \"Yes\") == 0);\n    assert(strcmp(f_30(\"123\"), \"No\") == 0);\n    assert(strcmp(f_30(\"232\"), \"Yes\") == 0);\n    assert(strcmp(f_30(\"444\"), \"No\") == 0); // All three characters are equal, not two.\n    assert(strcmp(f_30(\"121\"), \"Yes\") == 0);\n\n    // Additional test cases to cover more scenarios\n    assert(strcmp(f_30(\"787\"), \"Yes\") == 0);\n    assert(strcmp(f_30(\"999\"), \"No\") == 0); // All three characters are equal\n    assert(strcmp(f_30(\"890\"), \"No\") == 0);\n    assert(strcmp(f_30(\"556\"), \"Yes\") == 0);\n    assert(strcmp(f_30(\"353\"), \"Yes\") == 0); // No two characters are equal\n\n    \n    return 0;\n}", "entry_point": "f_30", "signature": "const char* f_30(const char s[4])", "docstring": {"en": "Checks if a three-character string has exactly two characters that are the same.\n\nParameters:\n@param s A three-character string to be checked.\n \nReturns:\nReturns \"Yes\" if the input has exactly two equal characters, otherwise \"No\".\nExamples:\n  >>> f_30(\"112\")\n  \"Yes\"\n  >>> f_30(\"123\")\n  \"No\"\n", "sq": "Kontrollon nëse një varg me tre karaktere ka saktësisht dy karaktere që janë të njëjta.\n\nParametrat:\n@param s Një varg me tre karaktere që do të kontrollohet.\n\nKthen:\nKthen \"Po\" nëse hyrja ka saktësisht dy karaktere të barabarta, përndryshe \"Jo\".\nShembuj:\n  >>> f_30(\"112\")\n  \"Po\"\n  >>> f_30(\"123\")\n  \"Jo\"", "hy": "Ստուգում է, արդյոք երեք նիշից բաղկացած տողը ունի՞ հենց երկու նույն նիշ:\n\nՊարամետրեր:\n@param s Երեք նիշից բաղկացած տող, որը պետք է ստուգվի:\n\nՎերադարձնում է:\nՎերադարձնում է \"Yes\", եթե մուտքագրվածը ունի հենց երկու հավասար նիշ, հակառակ դեպքում՝ \"No\":\nՕրինակներ:\n  >>> f_30(\"112\")\n  \"Yes\"\n  >>> f_30(\"123\")\n  \"No\"", "bn": "পরীক্ষা করে যে একটি তিন-অক্ষরের স্ট্রিংয়ে ঠিক দুটি অক্ষর একই আছে কিনা।\n\nপ্যারামিটারসমূহ:\n@param s একটি তিন-অক্ষরের স্ট্রিং যা পরীক্ষা করা হবে।\n\nফেরত দেয়:\nযদি ইনপুটে ঠিক দুটি সমান অক্ষর থাকে তবে \"Yes\" ফেরত দেয়, অন্যথায় \"No\"।\n\nউদাহরণসমূহ:\n  >>> f_30(\"112\")\n  \"Yes\"\n  >>> f_30(\"123\")\n  \"No\"", "bg": "Проверява дали низ с три знака има точно два еднакви знака.\n\nПараметри:\n@param s Низ с три знака, който да бъде проверен.\n\nВръща:\nВръща \"Yes\", ако входът има точно два еднакви знака, в противен случай \"No\".\nПримери:\n  >>> f_30(\"112\")\n  \"Yes\"\n  >>> f_30(\"123\")\n  \"No\"", "zh": "检查一个三字符字符串是否恰好有两个字符相同。\n\n参数：\n@param s 要检查的三字符字符串。\n\n返回：\n如果输入恰好有两个相同的字符，则返回 \"Yes\"，否则返回 \"No\"。\n\n示例：\n  >>> f_30(\"112\")\n  \"Yes\"\n  >>> f_30(\"123\")\n  \"No\"", "fr": "Vérifie si une chaîne de trois caractères a exactement deux caractères identiques.\n\nParamètres:\n@param s Une chaîne de trois caractères à vérifier.\n\nRetourne:\nRetourne \"Yes\" si l'entrée a exactement deux caractères égaux, sinon \"No\".\nExemples:\n  >>> f_30(\"112\")\n  \"Yes\"\n  >>> f_30(\"123\")\n  \"No\"", "de": "Prüft, ob ein dreistelliger String genau zwei gleiche Zeichen hat.\n\nParameter:\n@param s Ein dreistelliger String, der überprüft werden soll.\n\nRückgabe:\nGibt \"Ja\" zurück, wenn der Eingabewert genau zwei gleiche Zeichen hat, andernfalls \"Nein\".\nBeispiele:\n  >>> f_30(\"112\")\n  \"Ja\"\n  >>> f_30(\"123\")\n  \"Nein\"", "ha": "Duba idan kirtani mai haruffa uku yana da daidai haruffa biyu da suke daidai.\n\nSigogi:\n@param s Wani kirtani mai haruffa uku da za a duba.\n\nDawowa:\nYana dawowa \"Yes\" idan shigarwar tana da daidai haruffa biyu masu daidaituwa, in ba haka ba \"No\".\n\nMisalai:\n  >>> f_30(\"112\")\n  \"Yes\"\n  >>> f_30(\"123\")\n  \"No\"", "hi": "तीन-अक्षरों की स्ट्रिंग में जांच करता है कि क्या इसमें ठीक दो अक्षर समान हैं।\n\nपैरामीटर्स:\n@param s एक तीन-अक्षरों की स्ट्रिंग जिसे जांचा जाना है।\n\nवापसी:\nयदि इनपुट में ठीक दो समान अक्षर हैं तो \"Yes\" लौटाता है, अन्यथा \"No\"।\n\nउदाहरण:\n  >>> f_30(\"112\")\n  \"Yes\"\n  >>> f_30(\"123\")\n  \"No\"", "hu": "Ellenőrzi, hogy egy három karakter hosszú stringben pontosan két azonos karakter van-e.\n\nParaméterek:\n@param s Egy három karakter hosszú string, amelyet ellenőrizni kell.\n\nVisszatérési érték:\n\"Yes\"-t ad vissza, ha a bemenetben pontosan két egyenlő karakter van, különben \"No\"-t.\n\nPéldák:\n  >>> f_30(\"112\")\n  \"Yes\"\n  >>> f_30(\"123\")\n  \"No\"", "es": "Verifica si una cadena de tres caracteres tiene exactamente dos caracteres que son iguales.\n\nParámetros:\n@param s Una cadena de tres caracteres a verificar.\n\nDevuelve:\nDevuelve \"Sí\" si la entrada tiene exactamente dos caracteres iguales, de lo contrario \"No\".\nEjemplos:\n  >>> f_30(\"112\")\n  \"Yes\"\n  >>> f_30(\"123\")\n  \"No\"", "arb": "يتحقق مما إذا كانت سلسلة مكونة من ثلاثة أحرف تحتوي على حرفين متطابقين بالضبط.\n\nالمعلمات:\n@param s سلسلة مكونة من ثلاثة أحرف ليتم التحقق منها.\n\nالقيم المعادة:\nيعيد \"Yes\" إذا كان الإدخال يحتوي على حرفين متساويين بالضبط، وإلا يعيد \"No\".\n\nأمثلة:\n  >>> f_30(\"112\")\n  \"Yes\"\n  >>> f_30(\"123\")\n  \"No\"", "sw": "Hukagua kama mfuatano wa herufi tatu una herufi mbili sawa.\n\nVigezo:\n@param s Mfuatano wa herufi tatu ambao unapaswa kukaguliwa.\n\nInarejesha:\nInarejesha \"Yes\" ikiwa ingizo lina herufi mbili sawa, vinginevyo \"No\".\n\nMifano:\n  >>> f_30(\"112\")\n  \"Yes\"\n  >>> f_30(\"123\")\n  \"No\"", "tr": "Üç karakterli bir dizgede tam olarak iki karakterin aynı olup olmadığını kontrol eder.\n\nParametreler:\n@param s Kontrol edilecek üç karakterli bir dizge.\n\nDöndürür:\nGirdi tam olarak iki eşit karaktere sahipse \"Yes\", aksi takdirde \"No\" döndürür.\nÖrnekler:\n  >>> f_30(\"112\")\n  \"Yes\"\n  >>> f_30(\"123\")\n  \"No\"", "vi": "Kiểm tra xem một chuỗi ba ký tự có chính xác hai ký tự giống nhau hay không.\n\nTham số:\n@param s Một chuỗi ba ký tự cần được kiểm tra.\n\nTrả về:\nTrả về \"Yes\" nếu đầu vào có chính xác hai ký tự bằng nhau, ngược lại trả về \"No\".\n\nVí dụ:\n  >>> f_30(\"112\")\n  \"Yes\"\n  >>> f_30(\"123\")\n  \"No\"", "id": "Memeriksa apakah sebuah string tiga karakter memiliki tepat dua karakter yang sama.\n\nParameter:\n@param s Sebuah string tiga karakter yang akan diperiksa.\n\nMengembalikan:\nMengembalikan \"Yes\" jika input memiliki tepat dua karakter yang sama, jika tidak \"No\".\nContoh:\n  >>> f_30(\"112\")\n  \"Yes\"\n  >>> f_30(\"123\")\n  \"No\"", "ja": "3文字の文字列に、正確に2つの同じ文字が含まれているかどうかを確認します。\n\nパラメータ:\n@param s チェックする3文字の文字列。\n\n戻り値:\n入力に正確に2つの等しい文字が含まれている場合は \"Yes\" を返し、それ以外の場合は \"No\" を返します。\n\n例:\n  >>> f_30(\"112\")\n  \"Yes\"\n  >>> f_30(\"123\")\n  \"No\"", "ko": "세 글자 문자열에 정확히 두 개의 동일한 문자가 있는지 확인합니다.\n\n매개변수:\n@param s 확인할 세 글자 문자열입니다.\n\n반환값:\n입력에 정확히 두 개의 동일한 문자가 있으면 \"Yes\"를 반환하고, 그렇지 않으면 \"No\"를 반환합니다.\n예시:\n  >>> f_30(\"112\")\n  \"Yes\"\n  >>> f_30(\"123\")\n  \"No\"", "ml": "ഒരു മൂന്ന് അക്ഷരങ്ങളുള്ള സ്ട്രിംഗിൽ കൃത്യമായി രണ്ട് അക്ഷരങ്ങൾ ഒരേപോലെയാണോ എന്ന് പരിശോധിക്കുന്നു.\n\nപാരാമീറ്ററുകൾ:\n@param s പരിശോധിക്കേണ്ട മൂന്നു അക്ഷരങ്ങളുള്ള ഒരു സ്ട്രിംഗ്.\n\nമടക്കുന്നു:\nഇൻപുട്ടിന് കൃത്യമായി രണ്ട് സമാന അക്ഷരങ്ങൾ ഉണ്ടെങ്കിൽ \"Yes\" മടക്കുന്നു, അല്ലെങ്കിൽ \"No\".\n\nഉദാഹരണങ്ങൾ:\n  >>> f_30(\"112\")\n  \"Yes\"\n  >>> f_30(\"123\")\n  \"No\"", "fa": "بررسی می‌کند که آیا یک رشته سه‌کاراکتری دقیقاً دو کاراکتر مشابه دارد یا خیر.\n\nپارامترها:\n@param s یک رشته سه‌کاراکتری که باید بررسی شود.\n\nبازگشت:\n\"Yes\" را برمی‌گرداند اگر ورودی دقیقاً دو کاراکتر برابر داشته باشد، در غیر این صورت \"No\" را برمی‌گرداند.\nمثال‌ها:\n  >>> f_30(\"112\")\n  \"Yes\"\n  >>> f_30(\"123\")\n  \"No\""}}
{"task_id": "CPP/31", "prompt": {"en": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/**\n * Given a string consisting of lowercase English letters, in each round you can change\n * one of the characters to another character. The question is: what is the minimum\n * number of rounds needed to make the string composed of the same character?\n * \n * Examples:\n * >>> f_31(\"aab\")\n * 1\n * >>> f_31(\"abc\")\n * 2\n * >>> f_31(\"aaa\")\n * 0\n */\nint f_31(const char* s)", "sq": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/**\n * Duke pasur një varg që përbëhet nga shkronjat e vogla të anglishtes, në secilën raund mund të ndryshoni\n * një nga karakteret në një karakter tjetër. Pyetja është: cili është numri minimal\n * i raundeve të nevojshme për ta bërë vargun të përbërë nga i njëjti karakter?\n * \n * Shembuj:\n * >>> f_31(\"aab\")\n * 1\n * >>> f_31(\"abc\")\n * 2\n * >>> f_31(\"aaa\")\n * 0\n */\nint f_31(const char* s)", "hy": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/**\n * Տրված է փոքրատառ անգլերեն տառերից բաղկացած տող, յուրաքանչյուր փուլում դուք կարող եք փոխել\n * տառերից մեկը մեկ այլ տառով: Հարցն այն է՝ ինչքա՞ն է նվազագույն\n * փուլերի քանակը, որը անհրաժեշտ է, որպեսզի տողը կազմված լինի նույն տառից:\n * \n * Օրինակներ:\n * >>> f_31(\"aab\")\n * 1\n * >>> f_31(\"abc\")\n * 2\n * >>> f_31(\"aaa\")\n * 0\n */\nint f_31(const char* s)", "bn": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/**\n * একটি স্ট্রিং দেওয়া হয়েছে যা ছোট হাতের ইংরেজি অক্ষর নিয়ে গঠিত, প্রতিটি রাউন্ডে আপনি\n * একটি অক্ষরকে অন্য অক্ষরে পরিবর্তন করতে পারেন। প্রশ্ন হল: স্ট্রিংটিকে একই অক্ষর দিয়ে\n * গঠিত করতে ন্যূনতম কত রাউন্ড প্রয়োজন?\n * \n * উদাহরণসমূহ:\n * >>> f_31(\"aab\")\n * 1\n * >>> f_31(\"abc\")\n * 2\n * >>> f_31(\"aaa\")\n * 0\n */\nint f_31(const char* s)", "bg": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/**\n * Даден е низ, състоящ се от малки английски букви, като във всеки рунд можете да промените\n * един от символите на друг символ. Въпросът е: какъв е минималният\n * брой рундове, необходими, за да се направи низът съставен от един и същ символ?\n * \n * Примери:\n * >>> f_31(\"aab\")\n * 1\n * >>> f_31(\"abc\")\n * 2\n * >>> f_31(\"aaa\")\n * 0\n */\nint f_31(const char* s)", "zh": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/**\n * 给定一个由小写英文字母组成的字符串，每一轮你可以将其中一个字符更改为另一个字符。\n * 问题是：需要多少轮才能使字符串由相同的字符组成？\n * \n * 示例：\n * >>> f_31(\"aab\")\n * 1\n * >>> f_31(\"abc\")\n * 2\n * >>> f_31(\"aaa\")\n * 0\n */\nint f_31(const char* s)", "fr": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/**\n * Étant donné une chaîne composée de lettres minuscules anglaises, à chaque tour, vous pouvez changer\n * l'un des caractères en un autre caractère. La question est : quel est le nombre minimum\n * de tours nécessaires pour que la chaîne soit composée du même caractère ?\n * \n * Exemples :\n * >>> f_31(\"aab\")\n * 1\n * >>> f_31(\"abc\")\n * 2\n * >>> f_31(\"aaa\")\n * 0\n */\nint f_31(const char* s)", "de": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/**\n * Gegeben ist ein String, der aus Kleinbuchstaben des englischen Alphabets besteht. In jeder Runde kann\n * man eines der Zeichen in ein anderes Zeichen ändern. Die Frage ist: Was ist die minimale\n * Anzahl von Runden, die benötigt werden, um den String aus demselben Zeichen bestehen zu lassen?\n * \n * Beispiele:\n * >>> f_31(\"aab\")\n * 1\n * >>> f_31(\"abc\")\n * 2\n * >>> f_31(\"aaa\")\n * 0\n */\nint f_31(const char* s)", "ha": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/**\n * An ba da wani kirtani da ya ƙunshi ƙananan haruffan Turanci, a kowace zagaye za ka iya canza\n * ɗaya daga cikin haruffan zuwa wani harafi. Tambayar ita ce: menene mafi ƙarancin\n * adadin zagaye da ake buƙata don sanya kirtanin ya ƙunshi harafi ɗaya kawai?\n * \n * Misalai:\n * >>> f_31(\"aab\")\n * 1\n * >>> f_31(\"abc\")\n * 2\n * >>> f_31(\"aaa\")\n * 0\n */\nint f_31(const char* s)", "hi": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/**\n * एक स्ट्रिंग दी गई है जिसमें छोटे अक्षरों वाले अंग्रेजी अक्षर हैं, प्रत्येक राउंड में आप\n * एक वर्ण को दूसरे वर्ण में बदल सकते हैं। प्रश्न यह है: स्ट्रिंग को एक ही वर्ण से\n * मिलकर बनाने के लिए न्यूनतम कितने राउंड की आवश्यकता है?\n * \n * उदाहरण:\n * >>> f_31(\"aab\")\n * 1\n * >>> f_31(\"abc\")\n * 2\n * >>> f_31(\"aaa\")\n * 0\n */\nint f_31(const char* s)", "hu": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/**\n * Adott egy kisbetűs angol betűkből álló karakterlánc, minden körben megváltoztathatod\n * az egyik karaktert egy másik karakterre. A kérdés: mi a minimális körök száma,\n * amely ahhoz szükséges, hogy a karakterlánc ugyanabból a karakterből álljon?\n * \n * Példák:\n * >>> f_31(\"aab\")\n * 1\n * >>> f_31(\"abc\")\n * 2\n * >>> f_31(\"aaa\")\n * 0\n */\nint f_31(const char* s)", "es": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/**\n * Dada una cadena compuesta por letras minúsculas del alfabeto inglés, en cada ronda puedes cambiar\n * uno de los caracteres por otro carácter. La pregunta es: ¿cuál es el número mínimo\n * de rondas necesarias para hacer que la cadena esté compuesta por el mismo carácter?\n * \n * Ejemplos:\n * >>> f_31(\"aab\")\n * 1\n * >>> f_31(\"abc\")\n * 2\n * >>> f_31(\"aaa\")\n * 0\n */\nint f_31(const char* s)", "arb": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/**\n * بالنظر إلى سلسلة تتكون من أحرف إنجليزية صغيرة، في كل جولة يمكنك تغيير\n * أحد الأحرف إلى حرف آخر. السؤال هو: ما هو الحد الأدنى\n * لعدد الجولات اللازمة لجعل السلسلة تتكون من نفس الحرف؟\n * \n * أمثلة:\n * >>> f_31(\"aab\")\n * 1\n * >>> f_31(\"abc\")\n * 2\n * >>> f_31(\"aaa\")\n * 0\n */\nint f_31(const char* s)", "sw": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/**\n * Ukipewa kamba inayojumuisha herufi ndogo za Kiingereza, katika kila raundi unaweza kubadilisha\n * moja ya herufi kuwa herufi nyingine. Swali ni: ni idadi ndogo ya raundi ngapi zinazohitajika\n * kufanya kamba iwe na herufi sawa?\n * \n * Mifano:\n * >>> f_31(\"aab\")\n * 1\n * >>> f_31(\"abc\")\n * 2\n * >>> f_31(\"aaa\")\n * 0\n */\nint f_31(const char* s)", "tr": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/**\n * Küçük harflerden oluşan bir dize verildiğinde, her turda karakterlerden birini başka bir karaktere\n * değiştirebilirsiniz. Soru şu: Diziyi aynı karakterden oluşacak şekilde yapmak için gereken minimum\n * tur sayısı nedir?\n * \n * Örnekler:\n * >>> f_31(\"aab\")\n * 1\n * >>> f_31(\"abc\")\n * 2\n * >>> f_31(\"aaa\")\n * 0\n */\nint f_31(const char* s)", "vi": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/**\n * Cho một chuỗi bao gồm các chữ cái tiếng Anh viết thường, trong mỗi vòng bạn có thể thay đổi\n * một trong các ký tự thành ký tự khác. Câu hỏi là: số vòng tối thiểu\n * cần thiết để làm cho chuỗi được tạo thành từ cùng một ký tự là bao nhiêu?\n * \n * Ví dụ:\n * >>> f_31(\"aab\")\n * 1\n * >>> f_31(\"abc\")\n * 2\n * >>> f_31(\"aaa\")\n * 0\n */\nint f_31(const char* s)", "id": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/**\n * Diberikan sebuah string yang terdiri dari huruf kecil bahasa Inggris, pada setiap putaran Anda dapat mengubah\n * salah satu karakter menjadi karakter lain. Pertanyaannya adalah: berapa jumlah\n * putaran minimum yang dibutuhkan untuk membuat string terdiri dari karakter yang sama?\n * \n * Contoh:\n * >>> f_31(\"aab\")\n * 1\n * >>> f_31(\"abc\")\n * 2\n * >>> f_31(\"aaa\")\n * 0\n */\nint f_31(const char* s)", "ja": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/**\n * 小文字の英字からなる文字列が与えられたとき、各ラウンドで1つの文字を別の文字に変更できます。\n * 問題は、文字列を同じ文字で構成するために必要な最小ラウンド数は何かということです。\n * \n * 例:\n * >>> f_31(\"aab\")\n * 1\n * >>> f_31(\"abc\")\n * 2\n * >>> f_31(\"aaa\")\n * 0\n */\nint f_31(const char* s)\n", "ko": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/**\n * 소문자로 구성된 문자열이 주어졌을 때, 각 라운드마다 하나의 문자를 다른 문자로 변경할 수 있습니다.\n * 질문은: 문자열을 동일한 문자로 구성하기 위해 필요한 최소 라운드 수는 얼마입니까?\n * \n * 예시:\n * >>> f_31(\"aab\")\n * 1\n * >>> f_31(\"abc\")\n * 2\n * >>> f_31(\"aaa\")\n * 0\n */\nint f_31(const char* s)", "ml": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/**\n * ചെറിയ അക്ഷരങ്ങളായ ഇംഗ്ലീഷ് അക്ഷരങ്ങൾ അടങ്ങിയ ഒരു സ്ട്രിംഗ് നൽകിയാൽ, ഓരോ റൗണ്ടിലും\n * നിങ്ങൾക്ക് ഒരു അക്ഷരം മറ്റൊരു അക്ഷരമായി മാറ്റാൻ കഴിയും. ചോദ്യം: സ്ട്രിംഗ് ഒരേ\n * അക്ഷരത്തിൽ നിന്നു നിർമ്മിക്കപ്പെടാൻ എത്ര മിനിമം റൗണ്ടുകൾ വേണ്ടിവരും?\n * \n * ഉദാഹരണങ്ങൾ:\n * >>> f_31(\"aab\")\n * 1\n * >>> f_31(\"abc\")\n * 2\n * >>> f_31(\"aaa\")\n * 0\n */\nint f_31(const char* s)", "fa": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/**\n * با توجه به یک رشته که از حروف کوچک انگلیسی تشکیل شده است، در هر دور می‌توانید\n * یکی از کاراکترها را به کاراکتری دیگر تغییر دهید. سوال این است: حداقل تعداد\n * دورهایی که لازم است تا رشته از یک کاراکتر یکسان تشکیل شود، چقدر است؟\n * \n * مثال‌ها:\n * >>> f_31(\"aab\")\n * 1\n * >>> f_31(\"abc\")\n * 2\n * >>> f_31(\"aaa\")\n * 0\n */\nint f_31(const char* s)"}, "canonical_solution": "{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}\n\n", "instruction": {"en": "int f_31(const char* s)\n{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}\n\n\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.", "sq": "int f_31(const char* s)\n{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}\n\n\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit CPP në shqip duke përdorur maksimumi 500 karaktere.", "hy": "int f_31(const char* s)\n{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}\n\n\n\nՀամառոտ բնական լեզվով նկարագրեք (docstring) այս CPP կոդը հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։", "bn": "int f_31(const char* s)\n{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}\n\n\n\nসিপিপি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলা ভাষায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।", "bg": "int f_31(const char* s)\n{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}\n\n\n\nПредоставете кратко описание на CPP кода на български език, използвайки не повече от 500 знака.", "zh": "int f_31(const char* s)\n{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}\n\n\n\n请用最多500个字符的中文对该CPP代码提供简洁的自然语言描述（文档字符串）。", "fr": "int f_31(const char* s)\n{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}\n\n\n\nFournissez une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.", "de": "int f_31(const char* s)\n{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}\n\n\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen.", "ha": "int f_31(const char* s)\n{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}\n\n\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar CPP cikin Hausa ta amfani da haruffa 500 kawai.", "hi": "int f_31(const char* s)\n{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}\n\n\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।", "hu": "int f_31(const char* s)\n{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}\n\n\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a CPP kódról magyarul, legfeljebb 500 karakterben.", "es": "int f_31(const char* s)\n{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}\n\n\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando como máximo 500 caracteres.", "arb": "int f_31(const char* s)\n{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}\n\n\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) للكود المكتوب بلغة C++ باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.", "sw": "int f_31(const char* s)\n{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}\n\n\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "int f_31(const char* s)\n{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}\n\n\n\nAşağıdaki CPP kodunun Türkçe olarak en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.", "vi": "int f_31(const char* s)\n{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}\n\n\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã CPP bằng tiếng Việt với tối đa 500 ký tự.", "id": "int f_31(const char* s)\n{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}\n\n\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode CPP dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "int f_31(const char* s)\n{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}\n\n\n\n以下のCPPコードの簡潔な自然言語による説明（ドックストリング）を日本語で500文字以内で提供してください。", "ko": "int f_31(const char* s)\n{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}\n\n\n\n최대 500자를 사용하여 영어로 CPP 코드에 대한 간결한 자연어 설명(docstring)을 제공하세요.", "ml": "int f_31(const char* s)\n{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}\n\n\n\nസിപിപി കോഡിന്റെ സംക്ഷിപ്തമായ സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) മലയാളത്തിൽ 500 പ്രതീകങ്ങൾക്കുള്ളിൽ നൽകുക.", "fa": "int f_31(const char* s)\n{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}\n\n\n\nتوضیح مختصر و طبیعی (docstring) از کد CPP را به زبان فارسی ارائه دهید که حداکثر ۵۰۰ کاراکتر باشد."}, "level": "", "test": "int main() {\n    assert(f_31(\"aab\") == 1);\n    assert(f_31(\"abc\") == 2);\n    assert(f_31(\"aaa\") == 0);\n    assert(f_31(\"abab\") == 1);\n    assert(f_31(\"zzzzz\") == 0);\n\n    return 0;\n}", "entry_point": "f_31", "signature": "int f_31(const char* s)", "docstring": {"en": "Given a string consisting of lowercase English letters, in each round you can change\none of the characters to another character. The question is: what is the minimum\nnumber of rounds needed to make the string composed of the same character?\n\nExamples:\n>>> f_31(\"aab\")\n1\n>>> f_31(\"abc\")\n2\n>>> f_31(\"aaa\")\n0", "sq": "Duke pasur një varg që përbëhet nga shkronja të vogla të anglishtes, në çdo raund mund të ndryshoni\nnjë nga karakteret në një karakter tjetër. Pyetja është: sa është numri minimal\ni raundeve të nevojshme për ta bërë vargun të përbërë nga i njëjti karakter?\n\nShembuj:\n>>> f_31(\"aab\")\n1\n>>> f_31(\"abc\")\n2\n>>> f_31(\"aaa\")\n0", "hy": "Տրված է փոքրատառ անգլերեն տառերից կազմված տող, յուրաքանչյուր փուլում կարող եք փոխել\nտողերից մեկը մեկ այլ տառով։ Հարցն այն է՝ ինչքա՞ն է նվազագույն\nփուլերի քանակը, որը անհրաժեշտ է, որպեսզի տողը կազմված լինի նույն տառից։\n\nՕրինակներ:\n>>> f_31(\"aab\")\n1\n>>> f_31(\"abc\")\n2\n>>> f_31(\"aaa\")\n0", "bn": "প্রদত্ত একটি স্ট্রিং যা ছোট হাতের ইংরেজি অক্ষর নিয়ে গঠিত, প্রতিটি রাউন্ডে আপনি একটি অক্ষরকে অন্য একটি অক্ষরে পরিবর্তন করতে পারেন। প্রশ্ন হল: স্ট্রিংটিকে একই অক্ষর দিয়ে গঠিত করতে ন্যূনতম কত রাউন্ড প্রয়োজন?\n\nউদাহরণসমূহ:\n>>> f_31(\"aab\")\n1\n>>> f_31(\"abc\")\n2\n>>> f_31(\"aaa\")\n0", "bg": "Даден е низ, състоящ се от малки английски букви, като във всеки рунд можете да промените един от символите на друг символ. Въпросът е: какъв е минималният брой рундове, необходими, за да се направи низът съставен от един и същ символ?\n\nПримери:\n>>> f_31(\"aab\")\n1\n>>> f_31(\"abc\")\n2\n>>> f_31(\"aaa\")\n0", "zh": "给定一个由小写英文字母组成的字符串，在每一轮中，你可以将其中一个字符更改为另一个字符。问题是：使字符串由相同字符组成所需的最少轮数是多少？\n\n示例：\n>>> f_31(\"aab\")\n1\n>>> f_31(\"abc\")\n2\n>>> f_31(\"aaa\")\n0", "fr": "Étant donné une chaîne composée de lettres minuscules anglaises, à chaque tour, vous pouvez changer l'un des caractères en un autre caractère. La question est : quel est le nombre minimum de tours nécessaires pour que la chaîne soit composée du même caractère ?\n\nExemples :\n>>> f_31(\"aab\")\n1\n>>> f_31(\"abc\")\n2\n>>> f_31(\"aaa\")\n0", "de": "Angenommen, ein String besteht aus kleinen englischen Buchstaben. In jeder Runde können Sie eines der Zeichen in ein anderes Zeichen ändern. Die Frage ist: Wie viele Runden sind mindestens erforderlich, um den String aus demselben Zeichen zu machen?\n\nBeispiele:\n>>> f_31(\"aab\")\n1\n>>> f_31(\"abc\")\n2\n>>> f_31(\"aaa\")\n0", "ha": "An ba da wata ƙirtani mai ƙunshi ƙananan haruffan Ingilishi, a kowace zagaye za ka iya canza ɗaya daga cikin haruffan zuwa wani harafi. Tambayar ita ce: menene mafi ƙarancin adadin zagaye da ake buƙata don sanya ƙirtanin ya ƙunshi harafi ɗaya kawai?\n\nMisalai:\n>>> f_31(\"aab\")\n1\n>>> f_31(\"abc\")\n2\n>>> f_31(\"aaa\")\n0", "hi": "दिए गए स्ट्रिंग में छोटे अंग्रेजी अक्षरों का समावेश है, प्रत्येक राउंड में आप एक अक्षर को दूसरे अक्षर में बदल सकते हैं। प्रश्न यह है: स्ट्रिंग को एक ही अक्षर से मिलकर बनाने के लिए न्यूनतम कितने राउंड की आवश्यकता है?\n\nउदाहरण:\n>>> f_31(\"aab\")\n1\n>>> f_31(\"abc\")\n2\n>>> f_31(\"aaa\")\n0", "hu": "Adott egy kisbetűs angol betűkből álló karakterlánc, minden körben megváltoztathatod az egyik karaktert egy másikra. A kérdés az: mi a minimális körök száma, amely szükséges ahhoz, hogy a karakterlánc azonos karakterekből álljon?\n\nPéldák:\n>>> f_31(\"aab\")\n1\n>>> f_31(\"abc\")\n2\n>>> f_31(\"aaa\")\n0", "es": "Dada una cadena que consiste en letras minúsculas del alfabeto inglés, en cada ronda puedes cambiar uno de los caracteres por otro carácter. La pregunta es: ¿cuál es el número mínimo de rondas necesarias para que la cadena esté compuesta por el mismo carácter?\n\nEjemplos:\n>>> f_31(\"aab\")\n1\n>>> f_31(\"abc\")\n2\n>>> f_31(\"aaa\")\n0", "arb": "بالنظر إلى سلسلة تتكون من أحرف إنجليزية صغيرة، في كل جولة يمكنك تغيير أحد الأحرف إلى حرف آخر. السؤال هو: ما هو الحد الأدنى لعدد الجولات اللازمة لجعل السلسلة تتكون من نفس الحرف؟\n\nأمثلة:\n>>> f_31(\"aab\")\n1\n>>> f_31(\"abc\")\n2\n>>> f_31(\"aaa\")\n0", "sw": "Kutolewa kwa herufi ndogo za Kiingereza, katika kila mzunguko unaweza kubadilisha moja ya herufi kuwa herufi nyingine. Swali ni: ni idadi ndogo ya mizunguko gani inahitajika kufanya herufi zote ziwe sawa?\n\nMifano:\n>>> f_31(\"aab\")\n1\n>>> f_31(\"abc\")\n2\n>>> f_31(\"aaa\")\n0", "tr": "Verilen bir küçük İngiliz harflerinden oluşan bir dizede, her turda karakterlerden birini başka bir karaktere değiştirebilirsiniz. Soru şu: Dizenin aynı karakterden oluşması için gereken minimum tur sayısı nedir?\n\nÖrnekler:\n>>> f_31(\"aab\")\n1\n>>> f_31(\"abc\")\n2\n>>> f_31(\"aaa\")\n0", "vi": "Cho một chuỗi bao gồm các chữ cái tiếng Anh viết thường, trong mỗi vòng bạn có thể thay đổi một trong các ký tự thành ký tự khác. Câu hỏi là: số vòng tối thiểu cần thiết để làm cho chuỗi được tạo thành từ cùng một ký tự là bao nhiêu?\n\nVí dụ:\n>>> f_31(\"aab\")\n1\n>>> f_31(\"abc\")\n2\n>>> f_31(\"aaa\")\n0", "id": "Diberikan sebuah string yang terdiri dari huruf kecil bahasa Inggris, pada setiap putaran Anda dapat mengubah salah satu karakter menjadi karakter lain. Pertanyaannya adalah: berapa jumlah putaran minimum yang diperlukan untuk membuat string tersebut terdiri dari karakter yang sama?\n\nContoh:\n>>> f_31(\"aab\")\n1\n>>> f_31(\"abc\")\n2\n>>> f_31(\"aaa\")\n0", "ja": "与えられた文字列が小文字の英字で構成されている場合、各ラウンドで文字の1つを別の文字に変更できます。質問は、文字列を同じ文字で構成されるようにするために必要な最小ラウンド数は何ですか？\n\n例:\n>>> f_31(\"aab\")\n1\n>>> f_31(\"abc\")\n2\n>>> f_31(\"aaa\")\n0", "ko": "주어진 문자열이 소문자 영어 문자로 구성되어 있을 때, 각 라운드에서 하나의 문자를 다른 문자로 변경할 수 있습니다. 질문은: 문자열을 동일한 문자로 구성되도록 만들기 위해 필요한 최소 라운드 수는 얼마입니까?\n\n예시:\n>>> f_31(\"aab\")\n1\n>>> f_31(\"abc\")\n2\n>>> f_31(\"aaa\")\n0", "ml": "ഒരു ചെറിയ ഇംഗ്ലീഷ് അക്ഷരങ്ങൾ അടങ്ങിയ ഒരു സ്ട്രിംഗ് നൽകിയാൽ, ഓരോ റൗണ്ടിലും നിങ്ങൾക്ക് ഒരു അക്ഷരം മറ്റൊരു അക്ഷരമായി മാറ്റാൻ കഴിയും. സ്ട്രിംഗ് ഒരേ അക്ഷരത്തിൽ നിന്ന് നിർമ്മിക്കാൻ എത്ര കുറഞ്ഞ റൗണ്ടുകൾ വേണമെന്ന് ചോദ്യം.\n\nഉദാഹരണങ്ങൾ:\n>>> f_31(\"aab\")\n1\n>>> f_31(\"abc\")\n2\n>>> f_31(\"aaa\")\n0", "fa": "با توجه به یک رشته که از حروف کوچک انگلیسی تشکیل شده است، در هر دور می‌توانید یکی از کاراکترها را به کاراکتر دیگری تغییر دهید. سوال این است: حداقل تعداد دورهای مورد نیاز برای تبدیل رشته به رشته‌ای که از یک کاراکتر یکسان تشکیل شده باشد چقدر است؟\n\nمثال‌ها:\n>>> f_31(\"aab\")\n1\n>>> f_31(\"abc\")\n2\n>>> f_31(\"aaa\")\n0"}}
{"task_id": "CPP/32", "prompt": {"en": "#include <cassert>\n#include <cstdio>\n/**\n * Given a sequence of n events, each occurring with a periodicity of a_i years, the task is to find\n * the year Y_n when the n-th event occurs. The countdown for event i+1 only starts in the year\n * immediately following the occurrence of event i.\n * Example usage:\n *     f_32(6, {3,2,4,5,9,18}) returns 36\n */\nint f_32(int n, int signs[])", "sq": "#include <cassert>\n#include <cstdio>\n/**\n * Duke pasur një sekuencë prej n ngjarjesh, secila që ndodh me një periodikë prej a_i vitesh, detyra është të gjendet\n * viti Y_n kur ndodh ngjarja e n-të. Numërimi mbrapsht për ngjarjen i+1 fillon vetëm në vitin\n * menjëherë pas ndodhjes së ngjarjes i.\n * Shembull përdorimi:\n *     f_32(6, {3,2,4,5,9,18}) kthen 36\n */\nint f_32(int n, int signs[])", "hy": "#include <cassert>\n#include <cstdio>\n/**\n * Տրված է n իրադարձությունների հաջորդականություն, որոնցից յուրաքանչյուրը տեղի է ունենում a_i տարիների պարբերականությամբ, խնդիրն է գտնել\n * Y_n տարին, երբ տեղի է ունենում n-րդ իրադարձությունը։ i+1 իրադարձության համար հետհաշվարկը սկսվում է միայն\n * i իրադարձության տեղի ունենալուց անմիջապես հետո։\n * Օրինակ օգտագործում:\n *     f_32(6, {3,2,4,5,9,18}) վերադարձնում է 36\n */\nint f_32(int n, int signs[])", "bn": "#include <cassert>\n#include <cstdio>\n/**\n * nটি ঘটনার একটি ক্রম দেওয়া হয়েছে, প্রতিটি a_i বছর পরপর ঘটে, কাজটি হল\n * n-তম ঘটনা ঘটে এমন বছর Y_n খুঁজে বের করা। ঘটনা i+1 এর জন্য কাউন্টডাউন কেবল তখনই শুরু হয়\n * যখন ঘটনা i ঘটে যাওয়ার পরের বছর।\n * উদাহরণ ব্যবহার:\n *     f_32(6, {3,2,4,5,9,18}) 36 প্রদান করে\n */\nint f_32(int n, int signs[])", "bg": "#include <cassert>\n#include <cstdio>\n/**\n * Дадена е последователност от n събития, всяко от които се случва с периодичност от a_i години, задачата е да се намери\n * годината Y_n, когато се случва n-тото събитие. Обратното броене за събитие i+1 започва само в годината\n * непосредствено след настъпването на събитие i.\n * Пример за използване:\n *     f_32(6, {3,2,4,5,9,18}) връща 36\n */\nint f_32(int n, int signs[])", "zh": "#include <cassert>\n#include <cstdio>\n/**\n * 给定一个由 n 个事件组成的序列，每个事件以 a_i 年为周期发生，任务是找到第 n 个事件发生的年份 Y_n。\n * 事件 i+1 的倒计时仅在事件 i 发生后的下一年开始。\n * 示例用法:\n *     f_32(6, {3,2,4,5,9,18}) 返回 36\n */\nint f_32(int n, int signs[])", "fr": "#include <cassert>\n#include <cstdio>\n/**\n * Étant donné une séquence de n événements, chacun se produisant avec une périodicité de a_i années, la tâche consiste à trouver\n * l'année Y_n lorsque le n-ième événement se produit. Le compte à rebours pour l'événement i+1 ne commence que l'année\n * suivant immédiatement la survenue de l'événement i.\n * Exemple d'utilisation :\n *     f_32(6, {3,2,4,5,9,18}) retourne 36\n */\nint f_32(int n, int signs[])", "de": "#include <cassert>\n#include <cstdio>\n/**\n * Gegeben eine Sequenz von n Ereignissen, die jeweils mit einer Periodizität von a_i Jahren auftreten, besteht die Aufgabe darin,\n * das Jahr Y_n zu finden, in dem das n-te Ereignis eintritt. Der Countdown für Ereignis i+1 beginnt erst im Jahr\n * unmittelbar nach dem Auftreten von Ereignis i.\n * Beispielverwendung:\n *     f_32(6, {3,2,4,5,9,18}) gibt 36 zurück\n */\nint f_32(int n, int signs[])", "ha": "#include <cassert>\n#include <cstdio>\n/**\n * An ba da jerin abubuwan da suka faru na n, kowanne yana faruwa tare da maimaitawar a_i shekaru, aikin shine nemo\n * shekarar Y_n lokacin da abin da ya faru na n-th ya faru. Kirga don abin da ya faru i+1 kawai yana farawa a cikin shekarar\n * nan da nan bayan faruwar abin da ya faru i.\n * Misalin amfani:\n *     f_32(6, {3,2,4,5,9,18}) returns 36\n */\nint f_32(int n, int signs[])", "hi": "#include <cassert>\n#include <cstdio>\n/**\n * n घटनाओं के अनुक्रम को दिया गया है, प्रत्येक घटना a_i वर्षों की आवृत्ति के साथ होती है, कार्य यह है कि\n * वह वर्ष Y_n खोजें जब nवीं घटना होती है। घटना i+1 की उलटी गिनती केवल घटना i के होने के तुरंत बाद वाले वर्ष में शुरू होती है।\n * उदाहरण उपयोग:\n *     f_32(6, {3,2,4,5,9,18}) 36 लौटाता है\n */\nint f_32(int n, int signs[])", "hu": "#include <cassert>\n#include <cstdio>\n/**\n * Adott egy n eseményből álló sorozat, amelyek mindegyike a_i évenkénti periodicitással fordul elő, a feladat az,\n * hogy megtaláljuk az Y_n évet, amikor az n-edik esemény bekövetkezik. Az i+1-edik esemény visszaszámlálása csak\n * az i-edik esemény bekövetkezését követő évben kezdődik.\n * Példa használat:\n *     f_32(6, {3,2,4,5,9,18}) visszaadja 36\n */\nint f_32(int n, int signs[])", "es": "#include <cassert>\n#include <cstdio>\n/**\n * Dada una secuencia de n eventos, cada uno ocurriendo con una periodicidad de a_i años, la tarea es encontrar\n * el año Y_n cuando ocurre el n-ésimo evento. La cuenta regresiva para el evento i+1 solo comienza en el año\n * inmediatamente después de la ocurrencia del evento i.\n * Ejemplo de uso:\n *     f_32(6, {3,2,4,5,9,18}) devuelve 36\n */\nint f_32(int n, int signs[])", "arb": "#include <cassert>\n#include <cstdio>\n/**\n * بالنظر إلى تسلسل من n أحداث، كل منها يحدث بشكل دوري كل a_i سنة، المهمة هي إيجاد\n * السنة Y_n عندما يحدث الحدث n. يبدأ العد التنازلي للحدث i+1 فقط في السنة\n * التي تلي مباشرة حدوث الحدث i.\n * مثال على الاستخدام:\n *     f_32(6, {3,2,4,5,9,18}) returns 36\n */\nint f_32(int n, int signs[])", "sw": "#include <cassert>\n#include <cstdio>\n/**\n * Ukipewa mlolongo wa matukio n, kila moja likitokea kwa kipindi cha miaka a_i, kazi ni kupata\n * mwaka Y_n ambapo tukio la n-th linatokea. Hesabu ya tukio i+1 inaanza tu katika mwaka\n * unaofuata mara tu baada ya tukio i kutokea.\n * Mfano wa matumizi:\n *     f_32(6, {3,2,4,5,9,18}) inarudisha 36\n */\nint f_32(int n, int signs[])", "tr": "#include <cassert>\n#include <cstdio>\n/**\n * n adet olaydan oluşan bir dizide, her biri a_i yıl periyoduyla meydana gelen olaylar verildiğinde,\n * n'inci olayın meydana geldiği Y_n yılını bulma görevidir. i+1'inci olayın geri sayımı, yalnızca\n * i'inci olayın meydana gelmesinden hemen sonraki yılda başlar.\n * Örnek kullanım:\n *     f_32(6, {3,2,4,5,9,18}) 36 döndürür\n */\nint f_32(int n, int signs[])", "vi": "#include <cassert>\n#include <cstdio>\n/**\n * Cho một dãy n sự kiện, mỗi sự kiện xảy ra với chu kỳ a_i năm, nhiệm vụ là tìm\n * năm Y_n khi sự kiện thứ n xảy ra. Đếm ngược cho sự kiện i+1 chỉ bắt đầu vào năm\n * ngay sau khi sự kiện i xảy ra.\n * Ví dụ sử dụng:\n *     f_32(6, {3,2,4,5,9,18}) trả về 36\n */\nint f_32(int n, int signs[])", "id": "#include <cassert>\n#include <cstdio>\n/**\n * Diberikan urutan dari n kejadian, masing-masing terjadi dengan periodisitas a_i tahun, tugasnya adalah menemukan\n * tahun Y_n ketika kejadian ke-n terjadi. Hitungan mundur untuk kejadian i+1 hanya dimulai pada tahun\n * segera setelah terjadinya kejadian i.\n * Contoh penggunaan:\n *     f_32(6, {3,2,4,5,9,18}) mengembalikan 36\n */\nint f_32(int n, int signs[])", "ja": "#include <cassert>\n#include <cstdio>\n/**\n * n個のイベントのシーケンスが与えられ、それぞれがa_i年の周期で発生する場合、n番目のイベントが発生する年Y_nを見つけるタスクです。イベントi+1のカウントダウンは、イベントiの発生直後の年にのみ開始されます。\n * 使用例:\n *     f_32(6, {3,2,4,5,9,18}) は36を返します\n */\nint f_32(int n, int signs[])", "ko": "#include <cassert>\n#include <cstdio>\n/**\n * n개의 사건이 주어졌을 때, 각각 a_i년 주기로 발생하는 사건의 연속에서\n * n번째 사건이 발생하는 해 Y_n을 찾는 것이 과제입니다. 사건 i+1의 카운트다운은\n * 사건 i가 발생한 바로 다음 해부터 시작됩니다.\n * 사용 예:\n *     f_32(6, {3,2,4,5,9,18})는 36을 반환합니다\n */\nint f_32(int n, int signs[])", "ml": "#include <cassert>\n#include <cstdio>\n/**\n * n സംഭവങ്ങളുടെ ഒരു ശ്രേണിയ്ക്ക്, ഓരോന്നും a_i വർഷങ്ങളുടെ കാലയളവിൽ സംഭവിക്കുന്നതായിരിക്കും, \n * n-ആമത്തെ സംഭവം സംഭവിക്കുന്ന Y_n വർഷം കണ്ടെത്തുക എന്നതാണ് പ്രവർത്തനം. \n * സംഭവം i+1 ന്റെ കൗണ്ട്ഡൗൺ, സംഭവം i സംഭവിച്ച വർഷത്തിന് തൊട്ടുപിന്നാലെ മാത്രമേ തുടങ്ങുകയുള്ളു.\n * ഉദാഹരണ ഉപയോഗം:\n *     f_32(6, {3,2,4,5,9,18}) 36 തിരികെ നൽകുന്നു\n */\nint f_32(int n, int signs[])", "fa": "#include <cassert>\n#include <cstdio>\n/**\n * با توجه به دنباله‌ای از n رویداد، که هر کدام با دوره تناوب a_i سال رخ می‌دهند، وظیفه این است که\n * سال Y_n را پیدا کنیم که در آن n-امین رویداد رخ می‌دهد. شمارش معکوس برای رویداد i+1 تنها در سال\n * بلافاصله پس از وقوع رویداد i شروع می‌شود.\n * مثال استفاده:\n *     f_32(6, {3,2,4,5,9,18}) مقدار 36 را برمی‌گرداند\n */\nint f_32(int n, int signs[])"}, "canonical_solution": "{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        year = ((year / period) + 1) * period;\n    }\n    return year;\n}", "instruction": {"en": "int f_32(int n, int signs[])\n{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        year = ((year / period) + 1) * period;\n    }\n    return year;\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.", "sq": "int f_32(int n, int signs[])\n{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        year = ((year / period) + 1) * period;\n    }\n    return year;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit CPP në shqip duke përdorur maksimumi 500 karaktere.", "hy": "int f_32(int n, int signs[])\n{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        year = ((year / period) + 1) * period;\n    }\n    return year;\n}\n\nՏվեք կարճ բնութագիր (docstring) այս CPP կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "int f_32(int n, int signs[])\n{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        year = ((year / period) + 1) * period;\n    }\n    return year;\n}\n\nসিপিপি কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।", "bg": "int f_32(int n, int signs[])\n{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        year = ((year / period) + 1) * period;\n    }\n    return year;\n}\n\nПредоставете кратко описание на CPP кода на естествен език (docstring) на български, използвайки най-много 500 знака.", "zh": "int f_32(int n, int signs[])\n{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        year = ((year / period) + 1) * period;\n    }\n    return year;\n}\n\n将以下 CPP 代码的功能描述为简洁的自然语言（文档字符串），使用不超过 500 个字符的中文。", "fr": "int f_32(int n, int signs[])\n{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        year = ((year / period) + 1) * period;\n    }\n    return year;\n}\n\nFournissez une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.", "de": "int f_32(int n, int signs[])\n{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        year = ((year / period) + 1) * period;\n    }\n    return year;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen.", "ha": "int f_32(int n, int signs[])\n{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        year = ((year / period) + 1) * period;\n    }\n    return year;\n}\n\nBa da takaitaccen bayani a cikin yare na halitta (docstring) na lambar CPP a cikin Hausa, ba tare da wucewa haruffa 500 ba.", "hi": "int f_32(int n, int signs[])\n{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        year = ((year / period) + 1) * period;\n    }\n    return year;\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।", "hu": "int f_32(int n, int signs[])\n{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        year = ((year / period) + 1) * period;\n    }\n    return year;\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a CPP kódról magyarul, legfeljebb 500 karakter használatával.", "es": "int f_32(int n, int signs[])\n{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        year = ((year / period) + 1) * period;\n    }\n    return year;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando como máximo 500 caracteres.", "arb": "int f_32(int n, int signs[])\n{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        year = ((year / period) + 1) * period;\n    }\n    return year;\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لشفرة CPP باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.", "sw": "int f_32(int n, int signs[])\n{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        year = ((year / period) + 1) * period;\n    }\n    return year;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "int f_32(int n, int signs[])\n{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        year = ((year / period) + 1) * period;\n    }\n    return year;\n}\n\nAşağıdaki CPP kodunun Türkçe olarak en fazla 500 karakter kullanarak kısa ve doğal bir dilde açıklamasını (docstring) sağlayın.", "vi": "int f_32(int n, int signs[])\n{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        year = ((year / period) + 1) * period;\n    }\n    return year;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự.", "id": "int f_32(int n, int signs[])\n{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        year = ((year / period) + 1) * period;\n    }\n    return year;\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode CPP dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "int f_32(int n, int signs[])\n{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        year = ((year / period) + 1) * period;\n    }\n    return year;\n}\n\n以下のCPPコードの簡潔な自然言語による説明（ドックストリング）を日本語で500文字以内で提供してください。", "ko": "int f_32(int n, int signs[])\n{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        year = ((year / period) + 1) * period;\n    }\n    return year;\n}\n\n다음 CPP 코드의 동작을 설명하는 간결한 자연어 설명(docstring)을 한국어로 작성하세요. 최대 500자 이내로 작성하십시오.", "ml": "int f_32(int n, int signs[])\n{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        year = ((year / period) + 1) * period;\n    }\n    return year;\n}\n\nCPP കോഡ് ഉപയോഗിച്ച് 500 അക്ഷരങ്ങളിൽ കൂടുതൽ അല്ലാത്ത വിധത്തിൽ ഒരു സംക്ഷിപ്തമായ സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) മലയാളത്തിൽ നൽകുക.", "fa": "int f_32(int n, int signs[])\n{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        year = ((year / period) + 1) * period;\n    }\n    return year;\n}\n\nتوضیح مختصر و طبیعی (docstring) از کد CPP به زبان فارسی ارائه دهید که حداکثر ۵۰۰ کاراکتر باشد."}, "level": "", "test": "int main() {\n    int arr1[] = {3,2,4,5,9,18};\n    assert(f_32(6, arr1) == 36);\n    int arr2[] = {1, 2,3,4,5};\n    assert(f_32(5, arr2) == 5);\n    int arr3[] = {1,1,1,1,1};\n    assert(f_32(5, arr3) == 5);\n    int arr4[] = {50,30,711,200,503,1006};\n    assert(f_32(6, arr4) == 2012);\n    int arr5[] = {1, 2};\n    assert(f_32(2, arr5) == 2);\n    int arr6[] = {3, 1, 2};\n    assert(f_32(3, arr6) == 6);\n    int arr7[] = {2, 3, 4};\n    assert(f_32(3, arr7) == 4);\n    int arr8[] = {1, 2, 3, 4};\n    assert(f_32(4, arr8) == 4);\n    int arr9[] = {5, 7, 11, 13};\n    assert(f_32(4, arr9) == 13);\n    int arr10[] = {2, 2, 2, 2, 2};\n    assert(f_32(5, arr10) == 10);\n    int arr11[] = {6, 10, 15};\n    assert(f_32(3, arr11) == 15);\n    int arr12[] = {4, 6, 14};\n    assert(f_32(3, arr12) == 14);\n    int arr13[] = {50, 30, 711, 200};\n    assert(f_32(4, arr13) == 800);\n    int arr14[] = {1, 1, 1, 1, 1, 1};\n    assert(f_32(6, arr14) == 6);\n    int arr15[] = {1000000, 999999};\n    assert(f_32(2, arr15) == 1999998);\n    return 0;\n}", "entry_point": "f_32", "signature": "int f_32(int n, int signs[])", "docstring": {"en": "Given a sequence of n events, each occurring with a periodicity of a_i years, the task is to find\nthe year Y_n when the n-th event occurs. The countdown for event i+1 only starts in the year\nimmediately following the occurrence of event i.\nExample usage:\nf_32(6, {3,2,4,5,9,18}) returns 36", "sq": "Duke pasur një sekuencë prej n ngjarjesh, secila që ndodh me një periodikë prej a_i vitesh, detyra është të gjendet viti Y_n kur ndodh ngjarja e n-të. Numërimi mbrapsht për ngjarjen i+1 fillon vetëm në vitin menjëherë pas ndodhjes së ngjarjes i.\nShembull përdorimi:\nf_32(6, {3,2,4,5,9,18}) kthen 36", "hy": "Տրված է n իրադարձությունների հաջորդականություն, որոնցից յուրաքանչյուրը տեղի է ունենում a_i տարիների պարբերականությամբ, խնդիրը գտնելն է Y_n տարին, երբ տեղի է ունենում n-րդ իրադարձությունը։ i+1 իրադարձության համար հետհաշվարկը սկսվում է միայն i իրադարձության տեղի ունենալուց անմիջապես հետո։ Օրինակ օգտագործում՝ f_32(6, {3,2,4,5,9,18}) վերադարձնում է 36", "bn": "একটি n ইভেন্টের ক্রম দেওয়া হয়েছে, যেখানে প্রতিটি ইভেন্ট a_i বছর পরপর ঘটে, কাজটি হল n-তম ইভেন্টটি কখন ঘটে সেই বছর Y_n খুঁজে বের করা। ইভেন্ট i+1 এর জন্য কাউন্টডাউন শুধুমাত্র ইভেন্ট i ঘটার পরের বছর থেকে শুরু হয়।\n\nউদাহরণ ব্যবহার:\nf_32(6, {3,2,4,5,9,18}) 36 রিটার্ন করে", "bg": "Дадена е последователност от n събития, всяко от които се случва с периодичност от a_i години, задачата е да се намери годината Y_n, когато n-тото събитие се случва. Обратното броене за събитие i+1 започва само в годината непосредствено след настъпването на събитие i.\nПример за използване:\nf_32(6, {3,2,4,5,9,18}) връща 36", "zh": "给定一个包含 n 个事件的序列，每个事件以 a_i 年为周期发生，任务是找到第 n 个事件发生的年份 Y_n。事件 i+1 的倒计时仅在事件 i 发生后的年份开始。\n\n示例用法：\nf_32(6, {3,2,4,5,9,18}) 返回 36", "fr": "Étant donné une séquence de n événements, chacun se produisant avec une périodicité de a_i années, la tâche consiste à trouver l'année Y_n lorsque le n-ième événement se produit. Le compte à rebours pour l'événement i+1 ne commence que l'année suivant immédiatement la survenue de l'événement i.\nExemple d'utilisation :\nf_32(6, {3,2,4,5,9,18}) retourne 36", "de": "Gegeben eine Sequenz von n Ereignissen, die jeweils mit einer Periodizität von a_i Jahren auftreten, besteht die Aufgabe darin, das Jahr Y_n zu finden, in dem das n-te Ereignis eintritt. Der Countdown für das Ereignis i+1 beginnt erst im Jahr unmittelbar nach dem Auftreten des Ereignisses i.\nBeispielverwendung:\nf_32(6, {3,2,4,5,9,18}) gibt 36 zurück", "ha": "An ba da jerin abubuwan n, kowanne yana faruwa da tsawon lokaci na a_i shekaru, aikin shine nemo shekarar Y_n lokacin da abin n-th ya faru. Kirga don abin i+1 kawai yana farawa a shekarar da ke biye da faruwar abin i.\n\nMisalin amfani:\nf_32(6, {3,2,4,5,9,18}) returns 36", "hi": "n घटनाओं के अनुक्रम को दिया गया है, जिनमें से प्रत्येक a_i वर्षों की आवृत्ति के साथ होती है, कार्य यह है कि nवीं घटना किस वर्ष Y_n में होती है, यह पता लगाना है। घटना i+1 की उलटी गिनती केवल घटना i के घटित होने के तुरंत बाद वाले वर्ष में ही शुरू होती है।\n\nउदाहरण उपयोग:\nf_32(6, {3,2,4,5,9,18}) 36 लौटाता है", "hu": "Adott egy n eseményből álló sorozat, ahol mindegyik esemény a_i évenkénti periodicitással következik be, a feladat az, hogy megtaláljuk az Y_n évet, amikor az n-edik esemény bekövetkezik. Az i+1-edik esemény visszaszámlálása csak az i-edik esemény bekövetkezését követő évben kezdődik.\nPélda használat:\nf_32(6, {3,2,4,5,9,18}) visszaadja 36", "es": "Dada una secuencia de n eventos, cada uno ocurriendo con una periodicidad de a_i años, la tarea es encontrar el año Y_n cuando ocurre el n-ésimo evento. La cuenta regresiva para el evento i+1 solo comienza en el año inmediatamente posterior a la ocurrencia del evento i.\nUso de ejemplo:\nf_32(6, {3,2,4,5,9,18}) devuelve 36", "arb": "بالنظر إلى تسلسل من n أحداث، كل منها يحدث بتكرار a_i سنوات، فإن المهمة هي إيجاد السنة Y_n عندما يحدث الحدث n. يبدأ العد التنازلي للحدث i+1 فقط في السنة التي تلي مباشرة حدوث الحدث i.\n\nاستخدام المثال:\nf_32(6, {3,2,4,5,9,18}) يعيد 36", "sw": "Kwa kupewa mlolongo wa matukio n, kila moja likitokea kwa kipindi cha miaka a_i, kazi ni kupata mwaka Y_n ambapo tukio la n linatokea. Hesabu ya tukio i+1 inaanza tu katika mwaka unaofuata mara tu baada ya tukio i kutokea. \n\nMfano wa matumizi:\nf_32(6, {3,2,4,5,9,18}) inarudisha 36", "tr": "Verilen n olayından oluşan bir dizide, her biri a_i yıllık bir periyodiklikle meydana gelen, n'inci olayın gerçekleştiği Y_n yılını bulma görevi. i+1 olayının geri sayımı, yalnızca i olayının gerçekleştiği yılın hemen ardından başlar.\nÖrnek kullanım:\nf_32(6, {3,2,4,5,9,18}) 36 döndürür", "vi": "Cho một dãy gồm n sự kiện, mỗi sự kiện xảy ra với chu kỳ a_i năm, nhiệm vụ là tìm năm Y_n khi sự kiện thứ n xảy ra. Đếm ngược cho sự kiện i+1 chỉ bắt đầu vào năm ngay sau khi sự kiện i xảy ra.\n\nVí dụ sử dụng:\nf_32(6, {3,2,4,5,9,18}) returns 36", "id": "Diberikan urutan dari n peristiwa, masing-masing terjadi dengan periodisitas a_i tahun, tugasnya adalah menemukan tahun Y_n ketika peristiwa ke-n terjadi. Hitungan mundur untuk peristiwa i+1 hanya dimulai pada tahun segera setelah terjadinya peristiwa i.\n\nPenggunaan contoh:\nf_32(6, {3,2,4,5,9,18}) mengembalikan 36", "ja": "与えられた n 個のイベントのシーケンスがあり、それぞれが a_i 年の周期で発生します。このタスクは、n 番目のイベントが発生する年 Y_n を見つけることです。イベント i+1 のカウントダウンは、イベント i が発生した直後の年からのみ開始されます。\n\n使用例:\nf_32(6, {3,2,4,5,9,18}) は 36 を返します。", "ko": "주어진 n개의 사건 시퀀스에서 각 사건은 a_i년의 주기로 발생하며, n번째 사건이 발생하는 연도 Y_n을 찾는 것이 과제입니다. 사건 i+1의 카운트다운은 사건 i가 발생한 직후의 해부터 시작됩니다.  \n사용 예시:  \nf_32(6, {3,2,4,5,9,18})는 36을 반환합니다.", "ml": "നൽകിയിരിക്കുന്ന n സംഭവങ്ങളുടെ ഒരു ശ്രേണിയിൽ, ഓരോന്നും a_i വർഷങ്ങളുടെ കാലക്രമത്തിൽ സംഭവിക്കുന്നു, n-ആമത്തെ സംഭവം സംഭവിക്കുന്ന വർഷം Y_n കണ്ടെത്തുകയാണ് ഈ പ്രവർത്തിയുടെ ലക്ഷ്യം. സംഭവം i+1-ന്റെ കൗണ്ട്ഡൗൺ, സംഭവം i സംഭവിക്കുന്ന വർഷത്തിന് തൊട്ടുപിന്നാലെ മാത്രം ആരംഭിക്കും.\n\nഉദാഹരണ ഉപയോഗം:\nf_32(6, {3,2,4,5,9,18}) 36-നെ തിരികെ നൽകുന്നു", "fa": "با توجه به دنباله‌ای از n رویداد، که هر کدام با دوره تناوب a_i سال رخ می‌دهند، وظیفه این است که سال Y_n را پیدا کنیم که در آن n-امین رویداد رخ می‌دهد. شمارش معکوس برای رویداد i+1 فقط در سال بلافاصله پس از وقوع رویداد i شروع می‌شود.\nمثال استفاده:\nf_32(6, {3,2,4,5,9,18}) returns 36"}}
{"task_id": "CPP/33", "prompt": {"en": "#include <cassert>\n#include <cstdio>\n/**\n * This problem introduces a custom modulo operation, denoted by \"⊕\".\n * When calculating x ⊕ y, if x is not a multiple of y, the result is x % y.\n * If x is a multiple of y, divide x by y repeatedly until x is no longer a\n * multiple of y, denoting this final value as x'. Then the result is x' % y.\n * For example:\n * - 4⊕5=4,\n * - 20⊕5=4,\n * - 100⊕5=4.\n * Given a prime number p, you need to handle several queries where you're given\n * an integer n and you must compute n! ⊕ p. Here, n! is the factorial of n.\n * Example:\n *    f_33(3, 7) returns 6\n */\nunsigned long long f_33(unsigned long long n, unsigned long long p)", "sq": "#include <cassert>\n#include <cstdio>\n/**\n * Ky problem prezanton një operacion të personalizuar modulo, i shënuar me \"⊕\".\n * Kur llogarit x ⊕ y, nëse x nuk është shumëfish i y, rezultati është x % y.\n * Nëse x është shumëfish i y, ndaj x me y në mënyrë të përsëritur derisa x të mos\n * jetë më shumëfish i y, duke e shënuar këtë vlerë përfundimtare si x'. Atëherë rezultati është x' % y.\n * Për shembull:\n * - 4⊕5=4,\n * - 20⊕5=4,\n * - 100⊕5=4.\n * Duke pasur një numër të plotë p, ju duhet të trajtoni disa kërkesa ku ju jepet\n * një numër i plotë n dhe duhet të llogaritni n! ⊕ p. Këtu, n! është faktoriali i n.\n * Shembull:\n *    f_33(3, 7) kthen 6\n */\nunsigned long long f_33(unsigned long long n, unsigned long long p)", "hy": "#include <cassert>\n#include <cstdio>\n/**\n * Այս խնդիրը ներկայացնում է հատուկ մնացորդի գործողություն, որը նշվում է \"⊕\" նշանով:\n * Երբ հաշվարկում ենք x ⊕ y, եթե x-ը y-ի բազմապատիկ չէ, արդյունքը x % y է:\n * Եթե x-ը y-ի բազմապատիկ է, բաժանում ենք x-ը y-ի վրա բազմիցս, մինչև x-ը այլևս\n * y-ի բազմապատիկ չլինի, և այս վերջնական արժեքը նշում ենք որպես x': Ապա արդյունքը x' % y է:\n * Օրինակ:\n * - 4⊕5=4,\n * - 20⊕5=4,\n * - 100⊕5=4:\n * Տրված է p պարզ թիվը, և անհրաժեշտ է մշակել մի քանի հարցումներ, որտեղ տրված է\n * n ամբողջ թիվը, և դուք պետք է հաշվարկեք n! ⊕ p: Այստեղ n! նշում է n-ի ֆակտորիալը:\n * Օրինակ:\n *    f_33(3, 7) վերադարձնում է 6\n */\nunsigned long long f_33(unsigned long long n, unsigned long long p)", "bn": "#include <cassert>\n#include <cstdio>\n/**\n * এই সমস্যাটি একটি কাস্টম মডুলো অপারেশন পরিচয় করায়, যা \"⊕\" দ্বারা চিহ্নিত।\n * x ⊕ y গণনা করার সময়, যদি x y এর গুণিতক না হয়, ফলাফল হয় x % y।\n * যদি x y এর গুণিতক হয়, তবে x কে y দ্বারা বারবার ভাগ করুন যতক্ষণ না x আর\n * y এর গুণিতক থাকে না, এই চূড়ান্ত মানটিকে x' হিসাবে চিহ্নিত করুন। তারপর ফলাফল হয় x' % y।\n * উদাহরণস্বরূপ:\n * - 4⊕5=4,\n * - 20⊕5=4,\n * - 100⊕5=4।\n * একটি মৌলিক সংখ্যা p দেওয়া হলে, আপনাকে বেশ কয়েকটি প্রশ্নের সমাধান করতে হবে যেখানে আপনাকে একটি পূর্ণসংখ্যা n দেওয়া হয় এবং আপনাকে n! ⊕ p গণনা করতে হবে। এখানে, n! হল n এর ফ্যাক্টোরিয়াল।\n * উদাহরণ:\n *    f_33(3, 7) ফলাফল দেয় 6\n */\nunsigned long long f_33(unsigned long long n, unsigned long long p)", "bg": "#include <cassert>\n#include <cstdio>\n/**\n * Този проблем въвежда персонализирана операция за модуло, обозначена с \"⊕\".\n * При изчисляване на x ⊕ y, ако x не е кратно на y, резултатът е x % y.\n * Ако x е кратно на y, разделете x на y многократно, докато x вече не е\n * кратно на y, обозначавайки тази крайна стойност като x'. Тогава резултатът е x' % y.\n * Например:\n * - 4⊕5=4,\n * - 20⊕5=4,\n * - 100⊕5=4.\n * Дадено е просто число p, трябва да обработите няколко заявки, където ви е дадено\n * цяло число n и трябва да изчислите n! ⊕ p. Тук n! е факториелът на n.\n * Пример:\n *    f_33(3, 7) връща 6\n */\nunsigned long long f_33(unsigned long long n, unsigned long long p)", "zh": "#include <cassert>\n#include <cstdio>\n/**\n * 这个问题引入了一种自定义的模运算，用“⊕”表示。\n * 计算 x ⊕ y 时，如果 x 不是 y 的倍数，结果是 x % y。\n * 如果 x 是 y 的倍数，则反复将 x 除以 y，直到 x 不再是 y 的倍数，将此最终值记为 x'。然后结果是 x' % y。\n * 例如：\n * - 4⊕5=4，\n * - 20⊕5=4，\n * - 100⊕5=4。\n * 给定一个素数 p，你需要处理若干查询，每个查询给定一个整数 n，你必须计算 n! ⊕ p。这里，n! 是 n 的阶乘。\n * 示例：\n *    f_33(3, 7) 返回 6\n */\nunsigned long long f_33(unsigned long long n, unsigned long long p)", "fr": "#include <cassert>\n#include <cstdio>\n/**\n * Ce problème introduit une opération de modulo personnalisée, notée par \"⊕\".\n * Lors du calcul de x ⊕ y, si x n'est pas un multiple de y, le résultat est x % y.\n * Si x est un multiple de y, divisez x par y de manière répétée jusqu'à ce que x ne soit plus un\n * multiple de y, notant cette valeur finale comme x'. Ensuite, le résultat est x' % y.\n * Par exemple :\n * - 4⊕5=4,\n * - 20⊕5=4,\n * - 100⊕5=4.\n * Étant donné un nombre premier p, vous devez traiter plusieurs requêtes où un\n * entier n vous est donné et vous devez calculer n! ⊕ p. Ici, n! est la factorielle de n.\n * Exemple :\n *    f_33(3, 7) retourne 6\n */\nunsigned long long f_33(unsigned long long n, unsigned long long p)", "de": "#include <cassert>\n#include <cstdio>\n/**\n * Dieses Problem führt eine benutzerdefinierte Modulo-Operation ein, bezeichnet durch \"⊕\".\n * Bei der Berechnung von x ⊕ y, wenn x kein Vielfaches von y ist, ist das Ergebnis x % y.\n * Wenn x ein Vielfaches von y ist, teile x wiederholt durch y, bis x kein Vielfaches von y\n * mehr ist, und bezeichne diesen Endwert als x'. Dann ist das Ergebnis x' % y.\n * Zum Beispiel:\n * - 4⊕5=4,\n * - 20⊕5=4,\n * - 100⊕5=4.\n * Gegeben eine Primzahl p, müssen Sie mehrere Anfragen bearbeiten, bei denen Ihnen eine\n * ganze Zahl n gegeben ist und Sie n! ⊕ p berechnen müssen. Hierbei ist n! die Fakultät von n.\n * Beispiel:\n *    f_33(3, 7) gibt 6 zurück\n */ \nunsigned long long f_33(unsigned long long n, unsigned long long p)", "ha": "#include <cassert>\n#include <cstdio>\n/**\n * Wannan matsalar tana gabatar da wani aiki na modulo na al'ada, wanda aka nuna da \"⊕\".\n * Lokacin da ake lissafin x ⊕ y, idan x ba shi ne ninki na y ba, sakamakon shi ne x % y.\n * Idan x ninki ne na y, raba x da y akai-akai har sai x ba shi ne ninki na y ba,\n * ana nuna wannan ƙimar ƙarshe da x'. Sannan sakamakon shi ne x' % y.\n * Alal misali:\n * - 4⊕5=4,\n * - 20⊕5=4,\n * - 100⊕5=4.\n * An ba da lamba mai lamba p, kana buƙatar magance tambayoyi da yawa inda aka ba ka\n * lamba n kuma dole ne ka lissafa n! ⊕ p. Anan, n! shine factorial na n.\n * Misali:\n *    f_33(3, 7) yana dawowa 6\n */\nunsigned long long f_33(unsigned long long n, unsigned long long p)", "hi": "#include <cassert>\n#include <cstdio>\n/**\n * यह समस्या एक कस्टम मोड्यूलो ऑपरेशन को प्रस्तुत करती है, जिसे \"⊕\" द्वारा निरूपित किया गया है।\n * जब x ⊕ y की गणना की जाती है, यदि x y का गुणज नहीं है, तो परिणाम x % y होता है।\n * यदि x y का गुणज है, तो x को y द्वारा बार-बार विभाजित करें जब तक कि x अब y का गुणज न हो,\n * इस अंतिम मान को x' के रूप में निरूपित करते हैं। फिर परिणाम x' % y होता है।\n * उदाहरण के लिए:\n * - 4⊕5=4,\n * - 20⊕5=4,\n * - 100⊕5=4।\n * एक अभाज्य संख्या p दी गई है, आपको कई प्रश्नों को संभालना है जहाँ आपको एक पूर्णांक n दिया जाता है\n * और आपको n! ⊕ p की गणना करनी होती है। यहाँ, n! n का फैक्टोरियल है।\n * उदाहरण:\n *    f_33(3, 7) 6 लौटाता है\n */\nunsigned long long f_33(unsigned long long n, unsigned long long p)", "hu": "#include <cassert>\n#include <cstdio>\n/**\n * Ez a probléma egy egyedi modulo műveletet vezet be, amelyet \"⊕\" jelöl.\n * Amikor az x ⊕ y-t számítjuk, ha x nem osztható y-nal, az eredmény x % y.\n * Ha x osztható y-nal, osszuk el x-et y-nal ismételten, amíg x már nem\n * osztható y-nal, és ezt a végső értéket jelöljük x'-ként. Ekkor az eredmény x' % y.\n * Például:\n * - 4⊕5=4,\n * - 20⊕5=4,\n * - 100⊕5=4.\n * Adott egy prímszám p, több lekérdezést kell kezelnie, ahol egy\n * egész számot n kap, és ki kell számítania n! ⊕ p értékét. Itt n! az n faktoriálisa.\n * Példa:\n *    f_33(3, 7) visszatér 6\n */\nunsigned long long f_33(unsigned long long n, unsigned long long p)", "es": "#include <cassert>\n#include <cstdio>\n/**\n * Este problema introduce una operación de módulo personalizada, denotada por \"⊕\".\n * Al calcular x ⊕ y, si x no es un múltiplo de y, el resultado es x % y.\n * Si x es un múltiplo de y, divide x por y repetidamente hasta que x ya no sea un\n * múltiplo de y, denotando este valor final como x'. Entonces el resultado es x' % y.\n * Por ejemplo:\n * - 4⊕5=4,\n * - 20⊕5=4,\n * - 100⊕5=4.\n * Dado un número primo p, necesitas manejar varias consultas donde se te da\n * un entero n y debes calcular n! ⊕ p. Aquí, n! es el factorial de n.\n * Ejemplo:\n *    f_33(3, 7) devuelve 6\n */\nunsigned long long f_33(unsigned long long n, unsigned long long p)", "arb": "#include <cassert>\n#include <cstdio>\n/**\n * هذه المسألة تقدم عملية باقي مخصصة، يرمز لها بـ \"⊕\".\n * عند حساب x ⊕ y، إذا لم يكن x مضاعفًا لـ y، تكون النتيجة x % y.\n * إذا كان x مضاعفًا لـ y، قسّم x على y بشكل متكرر حتى لا يكون x\n * مضاعفًا لـ y، يرمز لهذه القيمة النهائية بـ x'. ثم تكون النتيجة x' % y.\n * على سبيل المثال:\n * - 4⊕5=4،\n * - 20⊕5=4،\n * - 100⊕5=4.\n * بالنظر إلى عدد أولي p، تحتاج إلى معالجة عدة استفسارات حيث يُعطى لك\n * عدد صحيح n ويجب عليك حساب n! ⊕ p. هنا، n! هو مضروب n.\n * مثال:\n *    f_33(3, 7) يعيد 6\n */\nunsigned long long f_33(unsigned long long n, unsigned long long p)", "sw": "#include <cassert>\n#include <cstdio>\n/**\n * Shida hii inatambulisha operesheni maalum ya modulo, inayojulikana kama \"⊕\".\n * Wakati wa kuhesabu x ⊕ y, ikiwa x si kizio cha y, matokeo ni x % y.\n * Ikiwa x ni kizio cha y, gawanya x kwa y mara kwa mara hadi x si kizio tena cha y,\n * ukitaja thamani hii ya mwisho kama x'. Kisha matokeo ni x' % y.\n * Kwa mfano:\n * - 4⊕5=4,\n * - 20⊕5=4,\n * - 100⊕5=4.\n * Ukipewa nambari ya kwanza p, unahitaji kushughulikia maswali kadhaa ambapo umepewa\n * nambari nzima n na lazima uhakiki n! ⊕ p. Hapa, n! ni factorial ya n.\n * Mfano:\n *    f_33(3, 7) inarudisha 6\n */\nunsigned long long f_33(unsigned long long n, unsigned long long p)", "tr": "#include <cassert>\n#include <cstdio>\n/**\n * Bu problem, \"⊕\" ile gösterilen özel bir modül işlemi tanıtır.\n * x ⊕ y hesaplanırken, eğer x, y'nin katı değilse, sonuç x % y olur.\n * Eğer x, y'nin katı ise, x artık y'nin katı olmayana kadar x'i y'ye bölün,\n * bu son değeri x' olarak belirtin. Sonra sonuç x' % y olur.\n * Örneğin:\n * - 4⊕5=4,\n * - 20⊕5=4,\n * - 100⊕5=4.\n * Verilen bir asal sayı p ile, size bir tamsayı n verildiğinde birkaç sorguyu\n * ele almanız ve n! ⊕ p hesaplamanız gerekir. Burada, n! n'nin faktöriyelidir.\n * Örnek:\n *    f_33(3, 7) 6 döndürür\n */\nunsigned long long f_33(unsigned long long n, unsigned long long p)", "vi": "#include <cassert>\n#include <cstdio>\n/**\n * Vấn đề này giới thiệu một phép toán modulo tùy chỉnh, được ký hiệu là \"⊕\".\n * Khi tính toán x ⊕ y, nếu x không phải là bội số của y, kết quả là x % y.\n * Nếu x là bội số của y, chia x cho y liên tục cho đến khi x không còn là\n * bội số của y, ký hiệu giá trị cuối cùng này là x'. Sau đó kết quả là x' % y.\n * Ví dụ:\n * - 4⊕5=4,\n * - 20⊕5=4,\n * - 100⊕5=4.\n * Cho một số nguyên tố p, bạn cần xử lý một số truy vấn trong đó bạn được cho\n * một số nguyên n và bạn phải tính n! ⊕ p. Ở đây, n! là giai thừa của n.\n * Ví dụ:\n *    f_33(3, 7) trả về 6\n */\nunsigned long long f_33(unsigned long long n, unsigned long long p)", "id": "#include <cassert>\n#include <cstdio>\n/**\n * Masalah ini memperkenalkan operasi modulo kustom, yang dilambangkan dengan \"⊕\".\n * Ketika menghitung x ⊕ y, jika x bukan kelipatan dari y, hasilnya adalah x % y.\n * Jika x adalah kelipatan dari y, bagi x dengan y berulang kali hingga x tidak lagi\n * menjadi kelipatan dari y, menandai nilai akhir ini sebagai x'. Kemudian hasilnya adalah x' % y.\n * Sebagai contoh:\n * - 4⊕5=4,\n * - 20⊕5=4,\n * - 100⊕5=4.\n * Diberikan bilangan prima p, Anda perlu menangani beberapa kueri di mana Anda diberikan\n * sebuah bilangan bulat n dan Anda harus menghitung n! ⊕ p. Di sini, n! adalah faktorial dari n.\n * Contoh:\n *    f_33(3, 7) mengembalikan 6\n */\nunsigned long long f_33(unsigned long long n, unsigned long long p)", "ja": "#include <cassert>\n#include <cstdio>\n/**\n * この問題では、\"⊕\"で表されるカスタムの剰余演算を紹介します。\n * x ⊕ y を計算する際、x が y の倍数でない場合、結果は x % y です。\n * x が y の倍数である場合、x を y で割り続け、x がもはや y の倍数でなくなるまで行い、\n * この最終的な値を x' とします。その後、結果は x' % y です。\n * 例えば:\n * - 4⊕5=4,\n * - 20⊕5=4,\n * - 100⊕5=4.\n * 素数 p が与えられたとき、いくつかのクエリを処理する必要があります。\n * ここで、整数 n が与えられ、n! ⊕ p を計算しなければなりません。ここで、n! は n の階乗です。\n * 例:\n *    f_33(3, 7) は 6 を返します\n */\nunsigned long long f_33(unsigned long long n, unsigned long long p)\n", "ko": "#include <cassert>\n#include <cstdio>\n/**\n * 이 문제는 \"⊕\"로 표시되는 사용자 정의 모듈로 연산을 소개합니다.\n * x ⊕ y를 계산할 때, x가 y의 배수가 아니면 결과는 x % y입니다.\n * x가 y의 배수인 경우, x가 더 이상 y의 배수가 아닐 때까지 x를 y로 반복적으로 나누고,\n * 이 최종 값을 x'로 표시합니다. 그런 다음 결과는 x' % y입니다.\n * 예를 들어:\n * - 4⊕5=4,\n * - 20⊕5=4,\n * - 100⊕5=4.\n * 소수 p가 주어졌을 때, 여러 쿼리를 처리해야 하며, 여기서 정수 n이 주어지고\n * n! ⊕ p를 계산해야 합니다. 여기서 n!은 n의 팩토리얼입니다.\n * 예:\n *    f_33(3, 7)은 6을 반환합니다.\n */\nunsigned long long f_33(unsigned long long n, unsigned long long p)\n", "ml": "#include <cassert>\n#include <cstdio>\n/**\n * ഈ പ്രശ്നം \"⊕\" എന്ന ചിഹ്നം ഉപയോഗിച്ച് ഒരു കസ്റ്റം മോഡുലോ ഓപ്പറേഷൻ പരിചയപ്പെടുത്തുന്നു.\n * x ⊕ y കണക്കാക്കുമ്പോൾ, x y-യുടെ ഗുണിതമല്ലെങ്കിൽ, ഫലം x % y ആണ്.\n * x y-യുടെ ഗുണിതമാണെങ്കിൽ, x y-ൽ നിന്ന് പൂർണ്ണമായും വിഭജിക്കുമ്പോൾ x y-യുടെ ഗുണിതമല്ലാത്ത\n * ഒരു മൂല്യമായി മാറും, ഈ അവസാന മൂല്യത്തെ x' എന്ന് സൂചിപ്പിക്കുന്നു. അപ്പോൾ ഫലം x' % y ആണ്.\n * ഉദാഹരണത്തിന്:\n * - 4⊕5=4,\n * - 20⊕5=4,\n * - 100⊕5=4.\n * ഒരു പ്രധാന സംഖ്യ p നൽകിയാൽ, നിങ്ങൾക്ക് n എന്ന ഒരു പൂർണ്ണസംഖ്യ നൽകിയിരിക്കുന്ന\n * പല ചോദ്യങ്ങളും കൈകാര്യം ചെയ്യേണ്ടതുണ്ട്, നിങ്ങൾ n! ⊕ p കണക്കാക്കണം. ഇവിടെ, n! എന്നത് n-ന്റെ ഫാക്ടോറിയലാണ്.\n * ഉദാഹരണം:\n *    f_33(3, 7) 6 മടക്കുന്നു\n */\nunsigned long long f_33(unsigned long long n, unsigned long long p)", "fa": "#include <cassert>\n#include <cstdio>\n/**\n * این مسئله یک عملگر باقی‌مانده سفارشی معرفی می‌کند که با \"⊕\" نشان داده می‌شود.\n * هنگام محاسبه x ⊕ y، اگر x مضربی از y نباشد، نتیجه x % y است.\n * اگر x مضربی از y باشد، x را به طور مکرر بر y تقسیم کنید تا زمانی که x دیگر\n * مضربی از y نباشد، این مقدار نهایی را به عنوان x' نشان می‌دهیم. سپس نتیجه x' % y است.\n * برای مثال:\n * - 4⊕5=4،\n * - 20⊕5=4،\n * - 100⊕5=4.\n * با توجه به یک عدد اول p، شما باید چندین پرسش را مدیریت کنید که در آن‌ها یک عدد صحیح n داده می‌شود\n * و شما باید n! ⊕ p را محاسبه کنید. در اینجا، n! فاکتوریل n است.\n * مثال:\n *    f_33(3, 7) مقدار 6 را برمی‌گرداند\n */\nunsigned long long f_33(unsigned long long n, unsigned long long p)\n"}, "canonical_solution": "{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n\n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}", "instruction": {"en": "unsigned long long f_33(unsigned long long n, unsigned long long p)\n{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n\n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.", "sq": "unsigned long long f_33(unsigned long long n, unsigned long long p)\n{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n\n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit CPP në shqip duke përdorur maksimumi 500 karaktere.", "hy": "unsigned long long f_33(unsigned long long n, unsigned long long p)\n{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n\n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}\n\nՏվեք CPP կոդի համառոտ բնութագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "unsigned long long f_33(unsigned long long n, unsigned long long p)\n{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n\n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}\n\nসিপিপি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।", "bg": "unsigned long long f_33(unsigned long long n, unsigned long long p)\n{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n\n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}\n\nПредоставете кратко описание на CPP кода на български език, използвайки не повече от 500 знака.", "zh": "unsigned long long f_33(unsigned long long n, unsigned long long p)\n{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n\n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}\n\n请用不超过500个字符的中文为以下CPP代码提供简洁的自然语言描述（文档字符串）。", "fr": "unsigned long long f_33(unsigned long long n, unsigned long long p)\n{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n\n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}\n\nFournissez une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.", "de": "unsigned long long f_33(unsigned long long n, unsigned long long p)\n{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n\n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "unsigned long long f_33(unsigned long long n, unsigned long long p)\n{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n\n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar CPP cikin Hausa ta amfani da haruffa 500 kawai.", "hi": "unsigned long long f_33(unsigned long long n, unsigned long long p)\n{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n\n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।", "hu": "unsigned long long f_33(unsigned long long n, unsigned long long p)\n{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n\n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a CPP kódról magyarul, legfeljebb 500 karakterben.", "es": "unsigned long long f_33(unsigned long long n, unsigned long long p)\n{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n\n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}\n\nProporciona una descripción concisa en lenguaje natural (docstring) del código CPP en español usando como máximo 500 caracteres.", "arb": "unsigned long long f_33(unsigned long long n, unsigned long long p)\n{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n\n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C++ باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "unsigned long long f_33(unsigned long long n, unsigned long long p)\n{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n\n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "unsigned long long f_33(unsigned long long n, unsigned long long p)\n{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n\n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}\n\nAşağıdaki CPP kodunun Türkçe'de en fazla 500 karakter kullanarak özlü bir doğal dil açıklamasını (docstring) sağlayın.", "vi": "unsigned long long f_33(unsigned long long n, unsigned long long p)\n{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n\n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự.", "id": "unsigned long long f_33(unsigned long long n, unsigned long long p)\n{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n\n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode CPP dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "unsigned long long f_33(unsigned long long n, unsigned long long p)\n{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n\n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}\n\n以下のCPPコードの簡潔な自然言語による説明（ドックストリング）を日本語で500文字以内で提供してください。", "ko": "unsigned long long f_33(unsigned long long n, unsigned long long p)\n{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n\n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}\n\n다음 CPP 코드에 대한 간결한 자연어 설명(도크스트링)을 한국어로 최대 500자 이내로 제공하세요.", "ml": "unsigned long long f_33(unsigned long long n, unsigned long long p)\n{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n\n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}\n\nസിപിപി കോഡിന്റെ സംക്ഷിപ്തമായ സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) മലയാളത്തിൽ 500 അക്ഷരങ്ങളിൽ കൂടുതൽ ഇല്ലാതെ നൽകുക.", "fa": "unsigned long long f_33(unsigned long long n, unsigned long long p)\n{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n\n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}\n\nتوضیح مختصر و طبیعی (docstring) از کد CPP به زبان فارسی ارائه دهید که حداکثر ۵۰۰ کاراکتر باشد."}, "level": "", "test": "int main() {\n    // Test cases\n    assert(f_33(3, 7) == 6);\n    assert(f_33(10, 3) == 1);\n    assert(f_33(11, 7) == 4);\n    assert(f_33(45, 7) == 1);\n    assert(f_33(14, 7) == 2);\n    assert(f_33(1919, 10007) == 3152);\n    assert(f_33(810, 10007) == 3679);\n    assert(f_33(3, 7) == 6);\n    assert(f_33(10, 3) == 1);\n    assert(f_33(1, 2) == 1);\n    assert(f_33(5, 11) == 10);\n    assert(f_33(6, 13) == 5);\n    assert(f_33(8, 17) == 13);\n    assert(f_33(15, 19) == 16);\n    assert(f_33(21, 23) == 1);\n    assert(f_33(30, 29) == 28);\n    assert(f_33(100, 101) == 100);\n    return 0;\n}", "entry_point": "f_33", "signature": "unsigned long long f_33(unsigned long long n, unsigned long long p)", "docstring": {"en": "This problem introduces a custom modulo operation, denoted by \"⊕\".\nWhen calculating x ⊕ y, if x is not a multiple of y, the result is x % y.\nIf x is a multiple of y, divide x by y repeatedly until x is no longer a\nmultiple of y, denoting this final value as x'. Then the result is x' % y.\nFor example:\n- 4⊕5=4,\n- 20⊕5=4,\n- 100⊕5=4.\nGiven a prime number p, you need to handle several queries where you're given\nan integer n and you must compute n! ⊕ p. Here, n! is the factorial of n.\nExample:\n   f_33(3, 7) returns 6\n", "sq": "Ky problem prezanton një operacion të personalizuar modulo, i shënuar me \"⊕\".  \nKur llogarit x ⊕ y, nëse x nuk është një shumëfish i y, rezultati është x % y.  \nNëse x është një shumëfish i y, ndaj x me y vazhdimisht derisa x të mos jetë më  \nnjë shumëfish i y, duke e shënuar këtë vlerë përfundimtare si x'. Atëherë rezultati është x' % y.  \nPër shembull:  \n- 4⊕5=4,  \n- 20⊕5=4,  \n- 100⊕5=4.  \nDuke pasur një numër të thjeshtë p, ju duhet të trajtoni disa kërkesa ku ju jepet  \nnjë numër i plotë n dhe duhet të llogaritni n! ⊕ p. Këtu, n! është faktoriali i n.  \nShembull:  \n   f_33(3, 7) kthen 6  ", "hy": "Այս խնդիրը ներկայացնում է հատուկ մնացորդային գործողություն, որը նշված է \"⊕\" նշանով։  \nԵրբ հաշվարկում ենք x ⊕ y, եթե x-ը y-ի բազմապատիկ չէ, արդյունքը x % y է։  \nԵթե x-ը y-ի բազմապատիկ է, բաժանեք x-ը y-ի վրա կրկնակիորեն, մինչև x-ը այլևս y-ի բազմապատիկ չլինի, և այս վերջնական արժեքը նշեք որպես x'։ Այնուհետև արդյունքը x' % y է։  \nՕրինակ՝  \n- 4⊕5=4,  \n- 20⊕5=4,  \n- 100⊕5=4։  \nՏրված է p պարզ թիվը, դուք պետք է մշակեք մի քանի հարցումներ, որտեղ տրված է n ամբողջ թիվը, և դուք պետք է հաշվարկեք n! ⊕ p։ Այստեղ, n! նշանակում է n-ի ֆակտորիալը։  \nՕրինակ՝  \n   f_33(3, 7) վերադարձնում է 6  ", "bn": "এই সমস্যাটি একটি কাস্টম মডুলো অপারেশন পরিচয় করিয়ে দেয়, যা \"⊕\" দ্বারা নির্দেশিত। \nযখন x ⊕ y গণনা করা হয়, যদি x y এর গুণিতক না হয়, তাহলে ফলাফল হয় x % y। \nযদি x y এর গুণিতক হয়, তাহলে x কে y দ্বারা বারবার ভাগ করুন যতক্ষণ না x আর y এর গুণিতক থাকে, এই চূড়ান্ত মানটিকে x' হিসাবে নির্দেশিত করুন। তারপর ফলাফল হয় x' % y। \nউদাহরণস্বরূপ:\n- 4⊕5=4,\n- 20⊕5=4,\n- 100⊕5=4।\nএকটি মৌলিক সংখ্যা p দেওয়া হলে, আপনাকে বেশ কয়েকটি প্রশ্ন পরিচালনা করতে হবে যেখানে আপনাকে একটি পূর্ণসংখ্যা n দেওয়া হয় এবং আপনাকে n! ⊕ p গণনা করতে হবে। এখানে, n! হল n এর ফ্যাক্টোরিয়াল।\nউদাহরণ:\n   f_33(3, 7) 6 প্রদান করে", "bg": "Този проблем въвежда персонализирана операция модуло, обозначена с \"⊕\".  \nКогато се изчислява x ⊕ y, ако x не е кратно на y, резултатът е x % y.  \nАко x е кратно на y, разделете x на y многократно, докато x вече не е  \nкратно на y, като обозначите тази крайна стойност като x'. Тогава резултатът е x' % y.  \nНапример:  \n- 4⊕5=4,  \n- 20⊕5=4,  \n- 100⊕5=4.  \nДадено е просто число p, трябва да обработите няколко заявки, при които е дадено  \nцяло число n и трябва да изчислите n! ⊕ p. Тук n! е факториелът на n.  \nПример:  \n   f_33(3, 7) връща 6  ", "zh": "这个问题引入了一个自定义的模运算，用“⊕”表示。  \n当计算 x ⊕ y 时，如果 x 不是 y 的倍数，结果是 x % y。  \n如果 x 是 y 的倍数，则反复将 x 除以 y，直到 x 不再是 y 的倍数，将此最终值记为 x'。然后结果是 x' % y。  \n例如：  \n- 4⊕5=4，  \n- 20⊕5=4，  \n- 100⊕5=4。  \n给定一个素数 p，你需要处理若干个查询，其中给定一个整数 n，你必须计算 n! ⊕ p。这里，n! 是 n 的阶乘。  \n示例：  \n   f_33(3, 7) 返回 6  ", "fr": "Ce problème introduit une opération modulo personnalisée, notée par \"⊕\".  \nLors du calcul de x ⊕ y, si x n'est pas un multiple de y, le résultat est x % y.  \nSi x est un multiple de y, divisez x par y de manière répétée jusqu'à ce que x ne soit plus un multiple de y, en désignant cette valeur finale par x'. Ensuite, le résultat est x' % y.  \nPar exemple :  \n- 4⊕5=4,  \n- 20⊕5=4,  \n- 100⊕5=4.  \nÉtant donné un nombre premier p, vous devez traiter plusieurs requêtes où un entier n vous est donné et vous devez calculer n! ⊕ p. Ici, n! est la factorielle de n.  \nExemple :  \n   f_33(3, 7) renvoie 6  ", "de": "Dieses Problem führt eine benutzerdefinierte Modulo-Operation ein, bezeichnet durch \"⊕\".  \nBeim Berechnen von x ⊕ y, wenn x kein Vielfaches von y ist, ist das Ergebnis x % y.  \nWenn x ein Vielfaches von y ist, teile x wiederholt durch y, bis x kein Vielfaches von y mehr ist, und bezeichne diesen Endwert als x'. Dann ist das Ergebnis x' % y.  \nZum Beispiel:  \n- 4⊕5=4,  \n- 20⊕5=4,  \n- 100⊕5=4.  \nGegeben eine Primzahl p, müssen Sie mehrere Anfragen bearbeiten, bei denen Ihnen eine ganze Zahl n gegeben wird und Sie n! ⊕ p berechnen müssen. Hierbei ist n! die Fakultät von n.  \nBeispiel:  \n   f_33(3, 7) gibt 6 zurück  ", "ha": "Wannan matsalar tana gabatar da wani aiki na modulo na musamman, wanda aka nuna da \"⊕\". \nLokacin da ake lissafin x ⊕ y, idan x ba sau ɗaya ba ne na y, sakamakon shine x % y. \nIdan x sau ɗaya ne na y, raba x da y akai-akai har sai x ba sau ɗaya ba ne na y, ana nuna wannan ƙimar ƙarshe da x'. Sannan sakamakon shine x' % y. \nMisali:\n- 4⊕5=4,\n- 20⊕5=4,\n- 100⊕5=4.\nAn ba da lambar farko p, kuna buƙatar sarrafa tambayoyi da yawa inda aka ba ku \nwani lamba n kuma dole ne ku lissafa n! ⊕ p. Anan, n! shine factorial na n.\nMisali:\n   f_33(3, 7) yana dawowa 6", "hi": "यह समस्या एक कस्टम मोड्यूलो ऑपरेशन को प्रस्तुत करती है, जिसे \"⊕\" द्वारा दर्शाया गया है।  \nजब x ⊕ y की गणना की जाती है, यदि x, y का गुणज नहीं है, तो परिणाम x % y होता है।  \nयदि x, y का गुणज है, तो x को y द्वारा बार-बार विभाजित करें जब तक कि x अब y का गुणज न रहे, इस अंतिम मान को x' के रूप में दर्शाते हुए। फिर परिणाम x' % y होता है।  \nउदाहरण के लिए:  \n- 4⊕5=4,  \n- 20⊕5=4,  \n- 100⊕5=4।  \nएक अभाज्य संख्या p दी गई है, आपको कई क्वेरीज़ को संभालना है जहाँ आपको एक पूर्णांक n दिया गया है और आपको n! ⊕ p की गणना करनी होगी। यहाँ, n! n का फैक्टोरियल है।  \nउदाहरण:  \n   f_33(3, 7) 6 लौटाता है।  ", "hu": "Ez a probléma egy egyedi modulo műveletet vezet be, amelyet \"⊕\" jelöl.  \nAmikor x ⊕ y-t számítunk, ha x nem osztható y-nal, az eredmény x % y.  \nHa x osztható y-nal, osszuk el x-et y-nal ismételten, amíg x már nem osztható y-nal, és ezt a végső értéket jelöljük x'-ként. Ekkor az eredmény x' % y.  \nPéldául:  \n- 4⊕5=4,  \n- 20⊕5=4,  \n- 100⊕5=4.  \nAdott egy prímszám p, több lekérdezést kell kezelnie, ahol egy n egész számot kap, és ki kell számítania n! ⊕ p értékét. Itt n! az n faktoriálisa.  \nPélda:  \n   f_33(3, 7) visszaadja 6  ", "es": "Este problema introduce una operación de módulo personalizada, denotada por \"⊕\".  \nAl calcular x ⊕ y, si x no es un múltiplo de y, el resultado es x % y.  \nSi x es un múltiplo de y, divide x por y repetidamente hasta que x ya no sea un múltiplo de y, denotando este valor final como x'. Entonces el resultado es x' % y.  \nPor ejemplo:  \n- 4⊕5=4,  \n- 20⊕5=4,  \n- 100⊕5=4.  \nDado un número primo p, necesitas manejar varias consultas donde se te da un entero n y debes calcular n! ⊕ p. Aquí, n! es el factorial de n.  \nEjemplo:  \n   f_33(3, 7) devuelve 6  ", "arb": "هذه المشكلة تقدم عملية باقي مخصصة، يرمز لها بـ \"⊕\".  \nعند حساب x ⊕ y، إذا لم يكن x مضاعفًا لـ y، فإن النتيجة هي x % y.  \nإذا كان x مضاعفًا لـ y، قم بقسمة x على y بشكل متكرر حتى لا يكون x مضاعفًا لـ y، مشيرًا إلى هذه القيمة النهائية بـ x'. ثم تكون النتيجة هي x' % y.  \nعلى سبيل المثال:  \n- 4⊕5=4،  \n- 20⊕5=4،  \n- 100⊕5=4.  \nبالنظر إلى عدد أولي p، تحتاج إلى معالجة عدة استفسارات حيث يُعطى لك عدد صحيح n ويجب عليك حساب n! ⊕ p. هنا، n! هو مضروب n.  \nمثال:  \n   f_33(3, 7) returns 6  ", "sw": "Tatizo hili linaanzisha operesheni maalum ya modulo, inayojulikana kama \"⊕\". Wakati wa kuhesabu x ⊕ y, ikiwa x si kigezo cha y, matokeo ni x % y. Ikiwa x ni kigezo cha y, gawanya x kwa y mara kwa mara hadi x isiwe tena kigezo cha y, ukitaja thamani hii ya mwisho kama x'. Kisha matokeo ni x' % y. Kwa mfano:\n- 4⊕5=4,\n- 20⊕5=4,\n- 100⊕5=4.\nUkipewa nambari ya kwanza p, unahitaji kushughulikia maswali kadhaa ambapo umepewa nambari n na lazima uhakiki n! ⊕ p. Hapa, n! ni factorial ya n.\nMfano:\n   f_33(3, 7) inarudisha 6", "tr": "Bu problem, \"⊕\" ile gösterilen özel bir modül işlemi tanıtmaktadır.\nx ⊕ y hesaplanırken, eğer x, y'nin katı değilse, sonuç x % y olur.\nEğer x, y'nin katıysa, x'i artık y'nin katı olmayana kadar y ile tekrar tekrar bölün, bu son değeri x' olarak belirtin. Sonuç x' % y olur.\nÖrneğin:\n- 4⊕5=4,\n- 20⊕5=4,\n- 100⊕5=4.\nVerilen bir asal sayı p için, birkaç sorguyu ele almanız gerekmektedir; burada size bir tamsayı n verilir ve n! ⊕ p hesaplamanız gerekir. Burada n!, n'nin faktöriyelidir.\nÖrnek:\n   f_33(3, 7) 6 döndürür.", "vi": "Vấn đề này giới thiệu một phép toán modulo tùy chỉnh, được ký hiệu là \"⊕\".  \nKhi tính toán x ⊕ y, nếu x không phải là bội số của y, kết quả là x % y.  \nNếu x là bội số của y, chia x cho y liên tục cho đến khi x không còn là bội số của y, ký hiệu giá trị cuối cùng này là x'. Sau đó kết quả là x' % y.  \nVí dụ:  \n- 4⊕5=4,  \n- 20⊕5=4,  \n- 100⊕5=4.  \nCho một số nguyên tố p, bạn cần xử lý một số truy vấn trong đó bạn được cho một số nguyên n và bạn phải tính n! ⊕ p. Ở đây, n! là giai thừa của n.  \nVí dụ:  \n   f_33(3, 7) trả về 6  ", "id": "Masalah ini memperkenalkan operasi modulo khusus, yang dilambangkan dengan \"⊕\".  \nKetika menghitung x ⊕ y, jika x bukan kelipatan dari y, hasilnya adalah x % y.  \nJika x adalah kelipatan dari y, bagi x dengan y berulang kali sampai x tidak lagi menjadi kelipatan dari y, menandai nilai akhir ini sebagai x'. Kemudian hasilnya adalah x' % y.  \nSebagai contoh:  \n- 4⊕5=4,  \n- 20⊕5=4,  \n- 100⊕5=4.  \nDiberikan bilangan prima p, Anda perlu menangani beberapa kueri di mana Anda diberikan bilangan bulat n dan Anda harus menghitung n! ⊕ p. Di sini, n! adalah faktorial dari n.  \nContoh:  \n   f_33(3, 7) mengembalikan 6  ", "ja": "この問題では、「⊕」で表されるカスタムの剰余演算を導入します。\nx ⊕ y を計算する際、x が y の倍数でない場合、結果は x % y です。\nx が y の倍数である場合、x を y で割り続け、x がもはや y の倍数でなくなるまで繰り返します。この最終的な値を x' とします。すると結果は x' % y です。\n例えば：\n- 4⊕5=4,\n- 20⊕5=4,\n- 100⊕5=4.\n素数 p が与えられたとき、いくつかのクエリを処理する必要があります。ここで整数 n が与えられ、n! ⊕ p を計算しなければなりません。ここで、n! は n の階乗です。\n例:\n   f_33(3, 7) は 6 を返します。", "ko": "이 문제는 \"⊕\"로 표시되는 사용자 정의 모듈로 연산을 소개합니다.  \nx ⊕ y를 계산할 때, x가 y의 배수가 아니면 결과는 x % y입니다.  \nx가 y의 배수인 경우, x가 더 이상 y의 배수가 아닐 때까지 x를 y로 반복해서 나누고, 이 최종 값을 x'로 표시합니다. 그런 다음 결과는 x' % y입니다.  \n예를 들어:  \n- 4⊕5=4,  \n- 20⊕5=4,  \n- 100⊕5=4.  \n소수 p가 주어졌을 때, 여러 쿼리를 처리해야 하며, 여기서 정수 n이 주어지고 n! ⊕ p를 계산해야 합니다. 여기서 n!은 n의 팩토리얼입니다.  \n예:  \n   f_33(3, 7) returns 6  ", "ml": "ഈ പ്രശ്നം \"⊕\" എന്ന ചിഹ്നം ഉപയോഗിച്ച് ഒരു കസ്റ്റം മോഡുലോ പ്രവർത്തനം പരിചയപ്പെടുത്തുന്നു. \nx ⊕ y കണക്കാക്കുമ്പോൾ, x y-ന്റെ ഗുണിതമല്ലെങ്കിൽ, ഫലമായത് x % y ആണ്. \nx y-ന്റെ ഗുണിതമാണെങ്കിൽ, x y-ൽ നിന്ന് വീണ്ടും വീണ്ടും വിഭജിക്കുക, x y-ന്റെ ഗുണിതമല്ലാത്തതുവരെ, ഈ അന്തിമ മൂല്യം x' എന്ന് സൂചിപ്പിക്കുക. \nഅപ്പോൾ ഫലമായത് x' % y ആണ്. \nഉദാഹരണത്തിന്: \n- 4⊕5=4,\n- 20⊕5=4,\n- 100⊕5=4.\nഒരു പ്രൈം സംഖ്യ p ലഭിച്ചാൽ, നിങ്ങൾക്ക് പല ക്വറിയുകളും കൈകാര്യം ചെയ്യേണ്ടതുണ്ട്, ഇവിടെ നിങ്ങൾക്ക് ഒരു പൂർണ്ണസംഖ്യ n ലഭിക്കും, നിങ്ങൾ n! ⊕ p കണക്കാക്കണം. ഇവിടെ, n! എന്നത് n-ന്റെ ഫാക്ടോറിയലാണ്. \nഉദാഹരണം: \n   f_33(3, 7) 6 മടക്കുന്നു", "fa": "این مسئله یک عملیات باقی‌مانده سفارشی را معرفی می‌کند که با \"⊕\" نشان داده می‌شود.\nهنگام محاسبه x ⊕ y، اگر x مضربی از y نباشد، نتیجه x % y است.\nاگر x مضربی از y باشد، x را به طور مکرر بر y تقسیم کنید تا زمانی که x دیگر مضربی از y نباشد، این مقدار نهایی را به عنوان x' نشان می‌دهیم. سپس نتیجه x' % y است.\nبرای مثال:\n- 4⊕5=4،\n- 20⊕5=4،\n- 100⊕5=4.\nبا توجه به یک عدد اول p، شما باید چندین پرس‌وجو را مدیریت کنید که در آن یک عدد صحیح n داده شده و شما باید n! ⊕ p را محاسبه کنید. در اینجا، n! فاکتوریل n است.\nمثال:\n   f_33(3, 7) مقدار 6 را برمی‌گرداند."}}
{"task_id": "CPP/34", "prompt": {"en": "#include <cstdio>\n#include <cassert>\n/**\n * You are given an array a of n integers. You can perform at most one operation where you\n * select three integers i, j, x (1 <= i <= j <= n) and replace all elements from a[i] to a[j] with x,\n * at a cost of (j - i + 1). Find the minimum cost to make all elements in the array equal.\n *\n * Examples:\n *    >>> f_34(3, (int[]){1, 2, 1})\n *    1\n *    >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n *    1\n */\nint f_34(int n, int a[])", "sq": "#include <cstdio>\n#include <cassert>\n/**\n * Ju jepet një varg a me n numra të plotë. Ju mund të kryeni maksimumi një operacion ku\n * zgjidhni tre numra të plotë i, j, x (1 <= i <= j <= n) dhe zëvendësoni të gjitha elementet nga a[i] deri te a[j] me x,\n * me një kosto prej (j - i + 1). Gjeni koston minimale për të bërë të gjitha elementet në varg të barabartë.\n *\n * Shembuj:\n *    >>> f_34(3, (int[]){1, 2, 1})\n *    1\n *    >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n *    1\n */\nint f_34(int n, int a[])", "hy": "#include <cstdio>\n#include <cassert>\n/**\n * Ձեզ տրված է n ամբողջ թվերի զանգված a։ Դուք կարող եք կատարել առավելագույնը մեկ գործողություն, որտեղ\n * ընտրում եք երեք ամբողջ թվեր i, j, x (1 <= i <= j <= n) և փոխարինում եք բոլոր տարրերը a[i]-ից a[j]-ով x-ով,\n * արժեքով (j - i + 1)։ Գտեք նվազագույն արժեքը, որպեսզի բոլոր տարրերը զանգվածում հավասար լինեն։\n *\n * Օրինակներ:\n *    >>> f_34(3, (int[]){1, 2, 1})\n *    1\n *    >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n *    1\n */\nint f_34(int n, int a[])", "bn": "#include <cstdio>\n#include <cassert>\n/**\n * আপনাকে n পূর্ণসংখ্যার একটি অ্যারে a দেওয়া হয়েছে। আপনি সর্বাধিক একটি অপারেশন করতে পারেন যেখানে আপনি\n * তিনটি পূর্ণসংখ্যা i, j, x (1 <= i <= j <= n) নির্বাচন করেন এবং a[i] থেকে a[j] পর্যন্ত সব উপাদান x দিয়ে প্রতিস্থাপন করেন,\n * যার খরচ (j - i + 1)। অ্যারের সব উপাদান সমান করতে সর্বনিম্ন খরচ খুঁজে বের করুন।\n *\n * উদাহরণ:\n *    >>> f_34(3, (int[]){1, 2, 1})\n *    1\n *    >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n *    1\n */\nint f_34(int n, int a[])", "bg": "#include <cstdio>\n#include <cassert>\n/**\n * Даден е масив a от n цели числа. Можете да извършите най-много една операция, при която\n * избирате три цели числа i, j, x (1 <= i <= j <= n) и заменяте всички елементи от a[i] до a[j] с x,\n * на цена от (j - i + 1). Намерете минималната цена, за да направите всички елементи в масива равни.\n *\n * Примери:\n *    >>> f_34(3, (int[]){1, 2, 1})\n *    1\n *    >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n *    1\n */\nint f_34(int n, int a[])", "zh": "#include <cstdio>\n#include <cassert>\n/**\n * 给定一个由 n 个整数组成的数组 a。你可以执行最多一次操作，其中你选择三个整数 i, j, x (1 <= i <= j <= n)，\n * 并将从 a[i] 到 a[j] 的所有元素替换为 x，代价为 (j - i + 1)。找到使数组中所有元素相等的最小代价。\n *\n * 示例:\n *    >>> f_34(3, (int[]){1, 2, 1})\n *    1\n *    >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n *    1\n */\nint f_34(int n, int a[])", "fr": "#include <cstdio>\n#include <cassert>\n/**\n * Vous avez un tableau a de n entiers. Vous pouvez effectuer au plus une opération où vous\n * sélectionnez trois entiers i, j, x (1 <= i <= j <= n) et remplacez tous les éléments de a[i] à a[j] par x,\n * à un coût de (j - i + 1). Trouvez le coût minimum pour rendre tous les éléments du tableau égaux.\n *\n * Exemples :\n *    >>> f_34(3, (int[]){1, 2, 1})\n *    1\n *    >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n *    1\n */\nint f_34(int n, int a[])", "de": "#include <cstdio>\n#include <cassert>\n/**\n * Gegeben ist ein Array a mit n ganzen Zahlen. Sie können höchstens eine Operation ausführen, bei der Sie\n * drei ganze Zahlen i, j, x (1 <= i <= j <= n) auswählen und alle Elemente von a[i] bis a[j] durch x ersetzen,\n * zu Kosten von (j - i + 1). Finden Sie die minimalen Kosten, um alle Elemente im Array gleich zu machen.\n *\n * Beispiele:\n *    >>> f_34(3, (int[]){1, 2, 1})\n *    1\n *    >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n *    1\n */\nint f_34(int n, int a[])", "ha": "#include <cstdio>\n#include <cassert>\n/**\n * An ba ku wani jerin a na lambobi n. Kuna iya aiwatar da aƙalla aiki ɗaya inda za ku\n * zaɓi lambobi uku i, j, x (1 <= i <= j <= n) kuma ku maye gurbin dukkan abubuwa daga a[i] zuwa a[j] da x,\n * a kan kuɗin (j - i + 1). Nemo mafi ƙarancin kuɗi don sanya duk abubuwan cikin jerin su zama daidai.\n *\n * Misalai:\n *    >>> f_34(3, (int[]){1, 2, 1})\n *    1\n *    >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n *    1\n */\nint f_34(int n, int a[])", "hi": "#include <cstdio>\n#include <cassert>\n/**\n * आपको n पूर्णांकों की एक सरणी a दी गई है। आप अधिकतम एक ऑपरेशन कर सकते हैं जहाँ आप\n * तीन पूर्णांक i, j, x (1 <= i <= j <= n) चुनते हैं और a[i] से a[j] तक के सभी तत्वों को x से बदल देते हैं,\n * जिसकी लागत (j - i + 1) होती है। सभी तत्वों को सरणी में समान बनाने की न्यूनतम लागत खोजें।\n *\n * उदाहरण:\n *    >>> f_34(3, (int[]){1, 2, 1})\n *    1\n *    >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n *    1\n */\nint f_34(int n, int a[])", "hu": "#include <cstdio>\n#include <cassert>\n/**\n * Adott egy n egész számot tartalmazó tömb. Legfeljebb egy műveletet hajthatsz végre, ahol\n * kiválasztasz három egész számot i, j, x (1 <= i <= j <= n) és az a[i] és a[j] közötti összes elemet x-re cseréled,\n * (j - i + 1) költséggel. Találd meg a minimális költséget, hogy az összes elem a tömbben egyenlő legyen.\n *\n * Példák:\n *    >>> f_34(3, (int[]){1, 2, 1})\n *    1\n *    >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n *    1\n */\nint f_34(int n, int a[])", "es": "#include <cstdio>\n#include <cassert>\n/**\n * Se te da un array a de n enteros. Puedes realizar como máximo una operación donde\n * seleccionas tres enteros i, j, x (1 <= i <= j <= n) y reemplazas todos los elementos desde a[i] hasta a[j] con x,\n * a un costo de (j - i + 1). Encuentra el costo mínimo para hacer que todos los elementos en el array sean iguales.\n *\n * Ejemplos:\n *    >>> f_34(3, (int[]){1, 2, 1})\n *    1\n *    >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n *    1\n */\nint f_34(int n, int a[])", "arb": "#include <cstdio>\n#include <cassert>\n/**\n * لديك مصفوفة a تحتوي على n من الأعداد الصحيحة. يمكنك تنفيذ عملية واحدة على الأكثر حيث\n * تختار ثلاثة أعداد صحيحة i, j, x (1 <= i <= j <= n) وتستبدل جميع العناصر من a[i] إلى a[j] بـ x،\n * بتكلفة (j - i + 1). جد التكلفة الدنيا لجعل جميع العناصر في المصفوفة متساوية.\n *\n * أمثلة:\n *    >>> f_34(3, (int[]){1, 2, 1})\n *    1\n *    >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n *    1\n */\nint f_34(int n, int a[])", "sw": "#include <cstdio>\n#include <cassert>\n/**\n * Umepewa safu a ya n nambari za mzima. Unaweza kufanya operesheni moja tu ambapo unachagua nambari tatu i, j, x (1 <= i <= j <= n) na kubadilisha vipengele vyote kutoka a[i] hadi a[j] na x, kwa gharama ya (j - i + 1). Pata gharama ya chini zaidi ya kufanya vipengele vyote katika safu kuwa sawa.\n *\n * Mifano:\n *    >>> f_34(3, (int[]){1, 2, 1})\n *    1\n *    >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n *    1\n */\nint f_34(int n, int a[])", "tr": "#include <cstdio>\n#include <cassert>\n/**\n * Size n olan bir tamsayı dizisi verilmektedir. En fazla bir işlem gerçekleştirebilirsiniz, bu işlemde\n * i, j, x (1 <= i <= j <= n) üç tamsayısını seçip a[i] ile a[j] arasındaki tüm elemanları x ile değiştirebilirsiniz,\n * maliyeti (j - i + 1) olacak şekilde. Dizideki tüm elemanları eşit yapmak için minimum maliyeti bulun.\n *\n * Örnekler:\n *    >>> f_34(3, (int[]){1, 2, 1})\n *    1\n *    >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n *    1\n */\nint f_34(int n, int a[])", "vi": "#include <cstdio>\n#include <cassert>\n/**\n * Bạn được cho một mảng a gồm n số nguyên. Bạn có thể thực hiện tối đa một thao tác, trong đó bạn\n * chọn ba số nguyên i, j, x (1 <= i <= j <= n) và thay thế tất cả các phần tử từ a[i] đến a[j] bằng x,\n * với chi phí là (j - i + 1). Tìm chi phí tối thiểu để làm cho tất cả các phần tử trong mảng bằng nhau.\n *\n * Ví dụ:\n *    >>> f_34(3, (int[]){1, 2, 1})\n *    1\n *    >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n *    1\n */\nint f_34(int n, int a[])", "id": "#include <cstdio>\n#include <cassert>\n/**\n * Anda diberikan sebuah array a yang terdiri dari n bilangan bulat. Anda dapat melakukan paling banyak satu operasi di mana Anda\n * memilih tiga bilangan bulat i, j, x (1 <= i <= j <= n) dan mengganti semua elemen dari a[i] hingga a[j] dengan x,\n * dengan biaya (j - i + 1). Temukan biaya minimum untuk membuat semua elemen dalam array menjadi sama.\n *\n * Contoh:\n *    >>> f_34(3, (int[]){1, 2, 1})\n *    1\n *    >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n *    1\n */\nint f_34(int n, int a[])", "ja": "#include <cstdio>\n#include <cassert>\n/**\n * あなたはn個の整数からなる配列aを与えられます。最大で1回の操作を行うことができ、\n * 3つの整数i, j, x (1 <= i <= j <= n) を選択し、a[i]からa[j]までのすべての要素をxに置き換えます。\n * そのコストは (j - i + 1) です。配列内のすべての要素を等しくするための最小コストを見つけてください。\n *\n * 例:\n *    >>> f_34(3, (int[]){1, 2, 1})\n *    1\n *    >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n *    1\n */\nint f_34(int n, int a[])", "ko": "#include <cstdio>\n#include <cassert>\n/**\n * n개의 정수로 이루어진 배열 a가 주어집니다. 최대 한 번의 연산을 수행할 수 있으며, \n * 여기서 세 정수 i, j, x (1 <= i <= j <= n)를 선택하고 a[i]부터 a[j]까지의 모든 요소를 x로 바꿉니다.\n * 이때 비용은 (j - i + 1)입니다. 배열의 모든 요소를 같게 만드는 최소 비용을 찾으세요.\n *\n * 예시:\n *    >>> f_34(3, (int[]){1, 2, 1})\n *    1\n *    >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n *    1\n */\nint f_34(int n, int a[])", "ml": "#include <cstdio>\n#include <cassert>\n/**\n * നിങ്ങൾക്ക് n പൂർണ്ണസംഖ്യകളുടെ ഒരു നിര a ലഭിക്കും. നിങ്ങൾക്ക് i, j, x (1 <= i <= j <= n) എന്ന മൂന്ന് പൂർണ്ണസംഖ്യകൾ തിരഞ്ഞെടുക്കുകയും \n * a[i] മുതൽ a[j] വരെയുള്ള എല്ലാ ഘടകങ്ങളും x-ൽ മാറ്റിസ്ഥാപിക്കുകയും ചെയ്യാവുന്ന ഒരു പ്രവർത്തനം പരമാവധി നടത്താവുന്നതാണ്, \n * (j - i + 1) എന്ന ചെലവിൽ. നിരയിലെ എല്ലാ ഘടകങ്ങളും തുല്യമായിത്തീരാൻ കുറഞ്ഞ ചെലവ് കണ്ടെത്തുക.\n *\n * ഉദാഹരണങ്ങൾ:\n *    >>> f_34(3, (int[]){1, 2, 1})\n *    1\n *    >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n *    1\n */\nint f_34(int n, int a[])", "fa": "#include <cstdio>\n#include <cassert>\n/**\n * شما یک آرایه a شامل n عدد صحیح دارید. شما می‌توانید حداکثر یک عملیات انجام دهید که در آن\n * سه عدد صحیح i، j، x (1 <= i <= j <= n) را انتخاب کرده و تمام عناصر از a[i] تا a[j] را با x جایگزین کنید،\n * با هزینه‌ای برابر با (j - i + 1). حداقل هزینه برای برابر کردن تمام عناصر در آرایه را پیدا کنید.\n *\n * مثال‌ها:\n *    >>> f_34(3, (int[]){1, 2, 1})\n *    1\n *    >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n *    1\n */\nint f_34(int n, int a[])"}, "canonical_solution": "{\n    int j = 0, p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}", "instruction": {"en": "int f_34(int n, int a[])\n{\n    int j = 0, p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.", "sq": "int f_34(int n, int a[])\n{\n    int j = 0, p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit CPP në shqip duke përdorur maksimumi 500 karaktere.", "hy": "int f_34(int n, int a[])\n{\n    int j = 0, p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}\n\nՏվյալ C++ կոդի համար տրամադրել հակիրճ բնութագիր (docstring) հայերեն լեզվով՝ օգտագործելով առավելագույնը 500 նիշ։", "bn": "int f_34(int n, int a[])\n{\n    int j = 0, p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}\n\nসিপিপি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলা ভাষায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।", "bg": "int f_34(int n, int a[])\n{\n    int j = 0, p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}\n\nДайте кратко описание на CPP кода на български език, използвайки не повече от 500 знака.", "zh": "int f_34(int n, int a[])\n{\n    int j = 0, p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}\n\n将以下CPP代码的自然语言描述（文档字符串）用中文简洁地提供，限制在500个字符以内。", "fr": "int f_34(int n, int a[])\n{\n    int j = 0, p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}\n\nFournir une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.", "de": "int f_34(int n, int a[])\n{\n    int j = 0, p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen.", "ha": "int f_34(int n, int a[])\n{\n    int j = 0, p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}\n\nBa da takaitaccen bayani a cikin harshen dabi'a (docstring) na lambar CPP cikin Hausa ta amfani da haruffa 500 kacal.", "hi": "int f_34(int n, int a[])\n{\n    int j = 0, p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "int f_34(int n, int a[])\n{\n    int j = 0, p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a CPP kódról magyarul, legfeljebb 500 karakterben.", "es": "int f_34(int n, int a[])\n{\n    int j = 0, p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando un máximo de 500 caracteres.", "arb": "int f_34(int n, int a[])\n{\n    int j = 0, p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية بلغة C++ باللغة العربية الفصحى، باستخدام 500 حرف كحد أقصى.", "sw": "int f_34(int n, int a[])\n{\n    int j = 0, p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "int f_34(int n, int a[])\n{\n    int j = 0, p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}\n\nAşağıdaki CPP kodunun Türkçe olarak en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.", "vi": "int f_34(int n, int a[])\n{\n    int j = 0, p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự.", "id": "int f_34(int n, int a[])\n{\n    int j = 0, p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode CPP dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "int f_34(int n, int a[])\n{\n    int j = 0, p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}\n\n以下のCPPコードの簡潔な自然言語による説明（ドックストリング）を日本語で500文字以内で提供してください。", "ko": "int f_34(int n, int a[])\n{\n    int j = 0, p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}\n\n다음 CPP 코드에 대한 간결한 자연어 설명(도크스트링)을 한국어로 최대 500자 이내로 제공하세요.", "ml": "int f_34(int n, int a[])\n{\n    int j = 0, p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}\n\nCPP കോഡ് സംബന്ധിച്ച സംക്ഷിപ്തമായ ഒരു സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) പരമാവധി 500 അക്ഷരങ്ങൾ ഉപയോഗിച്ച് മലയാളത്തിൽ നൽകുക.", "fa": "int f_34(int n, int a[])\n{\n    int j = 0, p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}\n\nتوضیح مختصر و طبیعی (docstring) از کد CPP به زبان فارسی ارائه دهید که حداکثر ۵۰۰ کاراکتر باشد."}, "level": "", "test": "int main() {\n    int a1[] = {1,2,3,4,5,1};\n    int a2[] = {1,1,1,1,1,1,1};\n    int a3[] = {8,8,8,1,2,8,8,8};\n    int a4[] = {1,2,3};\n    int a5[] = {4,3,2,7,1,1,3};\n    int a6[] = {9,9,2,9,2,5,5,5,3};\n    \n    assert(f_34(6, a1) == 4);\n    assert(f_34(7, a2) == 0);\n    assert(f_34(8, a3) == 2);\n    assert(f_34(3, a4) == 2);\n    assert(f_34(7, a5) == 6);\n    assert(f_34(9, a6) == 7);\n\n    int a7[] = {1, 2, 1};\n    int a8[] = {5, 5, 1, 5, 5};\n    int a9[] = {1, 1, 1, 1};\n    int a10[] = {2, 2, 2, 3, 2, 2};\n    int a11[] = {1};\n    int a12[] = {1, 2};\n    int a13[] = {1, 2, 2, 1};\n    int a14[] = {4, 4, 4, 3, 3, 4, 4};\n    int a15[] = {5, 4, 4, 4, 5, 5};\n    int a16[] = {1, 2, 1, 2, 1, 2, 1};\n    // Additional provided tests\n    assert(f_34(3, a7) == 1);\n    assert(f_34(5, a8) == 1);\n    assert(f_34(4, a9) == 0);\n    assert(f_34(6, a10) == 1);\n    assert(f_34(1, a11) == 0);\n    assert(f_34(2, a12) == 1);\n    assert(f_34(4, a13) == 2);\n    assert(f_34(7, a14) == 2);\n    assert(f_34(6, a15) == 3);\n    assert(f_34(7, a16) == 5);\n    \n    return 0;\n}", "entry_point": "f_34", "signature": "int f_34(int n, int a[])", "docstring": {"en": "You are given an array a of n integers. You can perform at most one operation where you select three integers i, j, x (1 <= i <= j <= n) and replace all elements from a[i] to a[j] with x, at a cost of (j - i + 1). Find the minimum cost to make all elements in the array equal.\n\nExamples:\n   >>> f_34(3, (int[]){1, 2, 1})\n   1\n   >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n   1\n", "sq": "Ju jepet një varg a me n numra të plotë. Ju mund të kryeni maksimumi një operacion ku zgjidhni tre numra të plotë i, j, x (1 <= i <= j <= n) dhe zëvendësoni të gjitha elementet nga a[i] në a[j] me x, me një kosto prej (j - i + 1). Gjeni koston minimale për t'i bërë të gjitha elementet në varg të barabarta.\n\nShembuj:\n   >>> f_34(3, (int[]){1, 2, 1})\n   1\n   >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n   1", "hy": "Դուք տրված եք n ամբողջ թվերի a զանգվածով։ Դուք կարող եք կատարել առավելագույնը մեկ գործողություն, որտեղ ընտրում եք երեք ամբողջ թվեր i, j, x (1 <= i <= j <= n) և փոխարինում եք a[i]-ից a[j]-ը բոլոր տարրերը x-ով, արժեքով (j - i + 1)։ Գտեք նվազագույն արժեքը, որպեսզի զանգվածի բոլոր տարրերը հավասար լինեն։\n\nՕրինակներ:\n   >>> f_34(3, (int[]){1, 2, 1})\n   1\n   >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n   1", "bn": "আপনাকে n পূর্ণসংখ্যার একটি অ্যারে a দেওয়া হয়েছে। আপনি সর্বাধিক একটি অপারেশন করতে পারেন যেখানে আপনি তিনটি পূর্ণসংখ্যা i, j, x (1 <= i <= j <= n) নির্বাচন করেন এবং a[i] থেকে a[j] পর্যন্ত সমস্ত উপাদান x দিয়ে প্রতিস্থাপন করেন, যার খরচ (j - i + 1)। অ্যারের সমস্ত উপাদান সমান করতে ন্যূনতম খরচ খুঁজুন।\n\nউদাহরণসমূহ:\n   >>> f_34(3, (int[]){1, 2, 1})\n   1\n   >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n   1", "bg": "Даден е масив a от n цели числа. Можете да извършите най-много една операция, при която избирате три цели числа i, j, x (1 <= i <= j <= n) и заменяте всички елементи от a[i] до a[j] с x, на цена (j - i + 1). Намерете минималната цена, за да направите всички елементи в масива равни.\n\nПримери:\n   >>> f_34(3, (int[]){1, 2, 1})\n   1\n   >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n   1", "zh": "你有一个包含 n 个整数的数组 a。你最多可以执行一次操作，在其中选择三个整数 i, j, x (1 <= i <= j <= n)，并将从 a[i] 到 a[j] 的所有元素替换为 x，代价为 (j - i + 1)。找出使数组中所有元素相等的最小代价。\n\n示例：\n   >>> f_34(3, (int[]){1, 2, 1})\n   1\n   >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n   1", "fr": "Vous disposez d'un tableau a de n entiers. Vous pouvez effectuer au plus une opération où vous sélectionnez trois entiers i, j, x (1 <= i <= j <= n) et remplacez tous les éléments de a[i] à a[j] par x, à un coût de (j - i + 1). Trouvez le coût minimum pour rendre tous les éléments du tableau égaux.\n\nExemples :\n   >>> f_34(3, (int[]){1, 2, 1})\n   1\n   >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n   1", "de": "Du hast ein Array a mit n ganzen Zahlen. Du kannst höchstens eine Operation durchführen, bei der du drei ganze Zahlen i, j, x (1 <= i <= j <= n) auswählst und alle Elemente von a[i] bis a[j] durch x ersetzt, zu Kosten von (j - i + 1). Finde die minimalen Kosten, um alle Elemente im Array gleich zu machen.\n\nBeispiele:\n   >>> f_34(3, (int[]){1, 2, 1})\n   1\n   >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n   1", "ha": "An ba ku wani tsari a na n lambobi. Kuna iya yin aiki ɗaya kawai inda kuka zaɓi lambobi uku i, j, x (1 <= i <= j <= n) kuma ku maye gurbin dukkan abubuwa daga a[i] zuwa a[j] da x, a kan farashi na (j - i + 1). Nemo mafi ƙarancin farashi don sanya duk abubuwan a cikin tsari su zama daidai.\n\nMisalai:\n   >>> f_34(3, (int[]){1, 2, 1})\n   1\n   >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n   1", "hi": "आपको n पूर्णांकों के एक array a दिया गया है। आप अधिकतम एक ऑपरेशन कर सकते हैं जहाँ आप तीन पूर्णांक i, j, x (1 <= i <= j <= n) का चयन करते हैं और a[i] से a[j] तक के सभी तत्वों को x से बदलते हैं, जिसकी लागत (j - i + 1) होती है। सभी तत्वों को array में समान बनाने के लिए न्यूनतम लागत खोजें।\n\nउदाहरण:\n   >>> f_34(3, (int[]){1, 2, 1})\n   1\n   >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n   1", "hu": "Meg van adva egy n egész számot tartalmazó tömb, a. Legfeljebb egy műveletet hajthatsz végre, ahol kiválasztasz három egész számot i, j, x (1 <= i <= j <= n), és az összes elemet a[i]-től a[j]-ig x-re cseréled, (j - i + 1) költséggel. Találd meg a minimális költséget, hogy az összes elem a tömbben egyenlő legyen.\n\nPéldák:\n   >>> f_34(3, (int[]){1, 2, 1})\n   1\n   >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n   1", "es": "Se te da un array a de n enteros. Puedes realizar como máximo una operación donde seleccionas tres enteros i, j, x (1 <= i <= j <= n) y reemplazas todos los elementos desde a[i] hasta a[j] con x, a un costo de (j - i + 1). Encuentra el costo mínimo para hacer que todos los elementos en el array sean iguales.\n\nEjemplos:\n   >>> f_34(3, (int[]){1, 2, 1})\n   1\n   >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n   1", "arb": "أنت مُعطى مصفوفة a تحتوي على n عدد صحيح. يمكنك تنفيذ عملية واحدة على الأكثر حيث تختار ثلاثة أعداد صحيحة i، j، x (1 <= i <= j <= n) وتستبدل جميع العناصر من a[i] إلى a[j] بـ x، بتكلفة (j - i + 1). جد الحد الأدنى للتكلفة لجعل جميع العناصر في المصفوفة متساوية.\n\nأمثلة:\n   >>> f_34(3, (int[]){1, 2, 1})\n   1\n   >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n   1", "sw": "Umepewa safu a ya n ya nambari za mzima. Unaweza kufanya operesheni moja tu ambapo unachagua nambari tatu i, j, x (1 <= i <= j <= n) na kubadilisha vipengele vyote kutoka a[i] hadi a[j] na x, kwa gharama ya (j - i + 1). Pata gharama ya chini kabisa ya kufanya vipengele vyote katika safu kuwa sawa.\n\nMifano:\n   >>> f_34(3, (int[]){1, 2, 1})\n   1\n   >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n   1", "tr": "Bir n tam sayısından oluşan bir dizi verildi. En fazla bir işlem gerçekleştirebilirsiniz; burada i, j, x (1 <= i <= j <= n) üç tam sayısını seçip a[i] ile a[j] arasındaki tüm elemanları x ile değiştirirsiniz, bu işlemin maliyeti (j - i + 1) olur. Dizideki tüm elemanları eşit hale getirmek için minimum maliyeti bulun.\n\nÖrnekler:\n   >>> f_34(3, (int[]){1, 2, 1})\n   1\n   >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n   1", "vi": "Bạn được cung cấp một mảng a gồm n số nguyên. Bạn có thể thực hiện tối đa một thao tác, trong đó bạn chọn ba số nguyên i, j, x (1 <= i <= j <= n) và thay thế tất cả các phần tử từ a[i] đến a[j] bằng x, với chi phí là (j - i + 1). Tìm chi phí tối thiểu để làm cho tất cả các phần tử trong mảng bằng nhau.\n\nVí dụ:\n   >>> f_34(3, (int[]){1, 2, 1})\n   1\n   >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n   1", "id": "Anda diberikan sebuah array a yang terdiri dari n bilangan bulat. Anda dapat melakukan paling banyak satu operasi di mana Anda memilih tiga bilangan bulat i, j, x (1 <= i <= j <= n) dan mengganti semua elemen dari a[i] hingga a[j] dengan x, dengan biaya (j - i + 1). Temukan biaya minimum untuk membuat semua elemen dalam array menjadi sama.\n\nContoh:\n   >>> f_34(3, (int[]){1, 2, 1})\n   1\n   >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n   1", "ja": "配列 a が n 個の整数を持っています。1 回だけ操作を行うことができ、3 つの整数 i, j, x (1 <= i <= j <= n) を選択し、a[i] から a[j] までのすべての要素を x に置き換えます。そのコストは (j - i + 1) です。配列内のすべての要素を等しくするための最小コストを見つけてください。\n\n例:\n   >>> f_34(3, (int[]){1, 2, 1})\n   1\n   >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n   1", "ko": "당신에게 n개의 정수로 이루어진 배열 a가 주어집니다. 최대 한 번의 연산을 수행할 수 있으며, 여기서 세 개의 정수 i, j, x (1 <= i <= j <= n)를 선택하고 a[i]부터 a[j]까지의 모든 요소를 x로 교체할 수 있습니다. 이때 비용은 (j - i + 1)입니다. 배열의 모든 요소를 동일하게 만드는 최소 비용을 찾으세요.\n\n예시:\n   >>> f_34(3, (int[]){1, 2, 1})\n   1\n   >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n   1", "ml": "നിങ്ങൾക്ക് n പൂർണ്ണസംഖ്യകളുടെ ഒരു നിര ലഭിച്ചിട്ടുണ്ട്. നിങ്ങൾക്ക് പരമാവധി ഒരു പ്രവർത്തനം നടത്താം, അതായത് നിങ്ങൾ മൂന്ന് പൂർണ്ണസംഖ്യകൾ i, j, x (1 <= i <= j <= n) തിരഞ്ഞെടുക്കുകയും a[i] മുതൽ a[j] വരെയുള്ള എല്ലാ മൂല്യങ്ങളും x-നായി മാറ്റുകയും ചെയ്യാം, (j - i + 1) എന്ന ചെലവിൽ. നിരയിലെ എല്ലാ മൂല്യങ്ങളും തുല്യമായാക്കാനുള്ള കുറഞ്ഞ ചെലവ് കണ്ടെത്തുക.\n\nഉദാഹരണങ്ങൾ:\n   >>> f_34(3, (int[]){1, 2, 1})\n   1\n   >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n   1", "fa": "شما یک آرایه a از n عدد صحیح دارید. می‌توانید حداکثر یک عملیات انجام دهید که در آن سه عدد صحیح i، j، x (1 <= i <= j <= n) را انتخاب کرده و تمام عناصر از a[i] تا a[j] را با x جایگزین کنید، با هزینه (j - i + 1). حداقل هزینه برای برابر کردن تمام عناصر در آرایه را پیدا کنید.\n\nمثال‌ها:\n   >>> f_34(3, (int[]){1, 2, 1})\n   1\n   >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n   1"}}
{"task_id": "CPP/35", "prompt": {"en": "#include <cassert>\n#include <iostream>\n/**\n * Given a sequence of N piles of stones numbered from 1 to N, each containing a positive number of stones, determine the winner\n * of a game played by Charlie and Dan. Charlie starts, taking turns with Dan moving stones from the leftmost non-empty pile\n * to the adjacent right pile. The one who can only move stones in the last pile loses. Assuming perfect play, find the winner.\n *\n * >>> f_35(3, {1, 2, 2})\n * \"Dan\"\n */\nconst char* f_35(int n, const int piles[])", "sq": "#include <cassert>\n#include <iostream>\n/**\n * Duke pasur një sekuencë prej N grumbuj gurësh të numëruar nga 1 deri në N, secili që përmban një numër pozitiv gurësh, përcaktoni fituesin\n * të një loje të luajtur nga Charlie dhe Dan. Charlie fillon, duke marrë radhën me Dan për të lëvizur gurët nga grumbulli më i majtë që nuk është bosh\n * te grumbulli ngjitur në të djathtë. Ai që mund të lëvizë gurë vetëm në grumbullin e fundit humbet. Duke supozuar lojë të përsosur, gjeni fituesin.\n *\n * >>> f_35(3, {1, 2, 2})\n * \"Dan\"\n */\nconst char* f_35(int n, const int piles[])", "hy": "#include <cassert>\n#include <iostream>\n/**\n * Տրված է քարերի N կույտերից բաղկացած հաջորդականություն, որոնք համարակալված են 1-ից N, և որոնցից յուրաքանչյուրը պարունակում է քարերի դրական քանակ:\n * որոշեք խաղի հաղթողին, որը խաղում են Չարլին և Դանը: Չարլին սկսում է, հերթով Դանի հետ տեղափոխելով քարերը ձախից աջ հարևան կույտ:\n * Նա, ով կարող է միայն տեղափոխել քարերը վերջին կույտում, պարտվում է: Ենթադրելով կատարյալ խաղ, գտեք հաղթողին:\n *\n * >>> f_35(3, {1, 2, 2})\n * \"Dan\"\n */\nconst char* f_35(int n, const int piles[])", "bn": "#include <cassert>\n#include <iostream>\n/**\n * ১ থেকে N পর্যন্ত নম্বরযুক্ত Nটি পাথরের স্তূপের একটি ক্রম দেওয়া হয়েছে, প্রতিটিতে একটি ইতিবাচক সংখ্যক পাথর রয়েছে, চার্লি এবং ড্যান দ্বারা খেলা একটি গেমের বিজয়ী নির্ধারণ করুন।\n * চার্লি শুরু করে, ড্যানের সাথে পালা করে বামদিকের প্রথম পূর্ণ স্তূপ থেকে ডানদিকে সংলগ্ন স্তূপে পাথর সরিয়ে নিয়ে যায়।\n * যে ব্যক্তি শুধুমাত্র শেষ স্তূপে পাথর সরাতে পারে সে হেরে যায়। নিখুঁত খেলার অনুমান করে, বিজয়ী খুঁজে বের করুন।\n *\n * >>> f_35(3, {1, 2, 2})\n * \"Dan\"\n */\nconst char* f_35(int n, const int piles[])", "bg": "#include <cassert>\n#include <iostream>\n/**\n * Дадена е последователност от N купчини камъни, номерирани от 1 до N, всяка съдържаща положителен брой камъни, определете победителя\n * в игра, играна от Чарли и Дан. Чарли започва, като се редува с Дан да мести камъни от най-лявата непразна купчина\n * към съседната дясна купчина. Този, който може да мести камъни само в последната купчина, губи. Приемайки перфектна игра, намерете победителя.\n *\n * >>> f_35(3, {1, 2, 2})\n * \"Dan\"\n */\nconst char* f_35(int n, const int piles[])", "zh": "#include <cassert>\n#include <iostream>\n/**\n * 给定一个编号从1到N的石堆序列，每堆包含正数个石头，确定Charlie和Dan玩的游戏的赢家。Charlie先开始，与Dan轮流\n * 从最左边的非空堆移动石头到相邻的右边堆。只能在最后一堆移动石头的人输。假设完美游戏，找出赢家。\n *\n * >>> f_35(3, {1, 2, 2})\n * \"Dan\"\n */\nconst char* f_35(int n, const int piles[])", "fr": "#include <cassert>\n#include <iostream>\n/**\n * Étant donné une séquence de N tas de pierres numérotés de 1 à N, chacun contenant un nombre positif de pierres, déterminez le gagnant\n * d'un jeu joué par Charlie et Dan. Charlie commence, prenant des tours avec Dan pour déplacer des pierres du tas le plus à gauche non vide\n * vers le tas adjacent à droite. Celui qui ne peut déplacer des pierres que dans le dernier tas perd. En supposant un jeu parfait, trouvez le gagnant.\n *\n * >>> f_35(3, {1, 2, 2})\n * \"Dan\"\n */\nconst char* f_35(int n, const int piles[])", "de": "#include <cassert>\n#include <iostream>\n/**\n * Gegeben eine Sequenz von N Steinhaufen, nummeriert von 1 bis N, wobei jeder Haufen eine positive Anzahl von Steinen enthält, bestimme den Gewinner\n * eines Spiels, das von Charlie und Dan gespielt wird. Charlie beginnt und wechselt sich mit Dan ab, indem sie Steine vom linken, nicht leeren Haufen\n * zum benachbarten rechten Haufen bewegen. Derjenige, der nur noch Steine im letzten Haufen bewegen kann, verliert. Angenommen, beide spielen perfekt, finde den Gewinner.\n *\n * >>> f_35(3, {1, 2, 2})\n * \"Dan\"\n */\nconst char* f_35(int n, const int piles[])", "ha": "#include <cassert>\n#include <iostream>\n/**\n * An ba da jerin N na tarin duwatsu da aka lamba daga 1 zuwa N, kowanne yana dauke da adadin duwatsu masu kyau, tantance wanda zai ci\n * wasa da Charlie da Dan suka buga. Charlie yana farawa, suna juyawa da Dan suna motsa duwatsu daga mafi hagu wanda ba komai a ciki\n * zuwa tarin da ke makwabta a dama. Wanda zai iya motsa duwatsu a cikin tarin karshe kadai zai yi asara. Idan ana wasa daidai, gano wanda zai ci.\n *\n * >>> f_35(3, {1, 2, 2})\n * \"Dan\"\n */\nconst char* f_35(int n, const int piles[])", "hi": "#include <cassert>\n#include <iostream>\n/**\n * 1 से N तक क्रमांकित पत्थरों के N ढेरों की एक श्रृंखला दी गई है, जिनमें से प्रत्येक में पत्थरों की एक सकारात्मक संख्या है, \n * चार्ली और डैन द्वारा खेले गए एक खेल के विजेता का निर्धारण करें। चार्ली शुरू करता है, डैन के साथ बारी-बारी से बाएं से \n * दाएं सबसे निकट के ढेर से पत्थरों को दाएं सटे ढेर में ले जाता है। जो केवल अंतिम ढेर में पत्थरों को ले जा सकता है, वह हार जाता है। \n * पूर्ण खेल मानते हुए, विजेता का पता लगाएं।\n *\n * >>> f_35(3, {1, 2, 2})\n * \"Dan\"\n */\nconst char* f_35(int n, const int piles[])", "hu": "#include <cassert>\n#include <iostream>\n/**\n * Adott egy N halomból álló kősorozat, amelyeket 1-től N-ig számoztak, mindegyik halom pozitív számú követ tartalmaz. Határozza meg a győztest\n * egy játékban, amelyet Charlie és Dan játszik. Charlie kezd, és Dan-nel felváltva lépnek, köveket mozgatva a bal szélső nem üres halomból\n * a szomszédos jobb halomba. Az veszít, aki csak az utolsó halomban tud köveket mozgatni. Tökéletes játékot feltételezve találja meg a győztest.\n *\n * >>> f_35(3, {1, 2, 2})\n * \"Dan\"\n */\nconst char* f_35(int n, const int piles[])", "es": "#include <cassert>\n#include <iostream>\n/**\n * Dada una secuencia de N pilas de piedras numeradas del 1 al N, cada una conteniendo un número positivo de piedras, determina el ganador\n * de un juego jugado por Charlie y Dan. Charlie comienza, turnándose con Dan moviendo piedras desde la pila más a la izquierda no vacía\n * a la pila adyacente a la derecha. El que solo pueda mover piedras en la última pila pierde. Asumiendo juego perfecto, encuentra al ganador.\n *\n * >>> f_35(3, {1, 2, 2})\n * \"Dan\"\n */\nconst char* f_35(int n, const int piles[])", "arb": "#include <cassert>\n#include <iostream>\n/**\n * بالنظر إلى تسلسل من N أكوام من الحجارة مرقمة من 1 إلى N، يحتوي كل منها على عدد موجب من الحجارة، حدد الفائز\n * في لعبة يلعبها تشارلي ودان. يبدأ تشارلي، بالتناوب مع دان في نقل الحجارة من الكومة اليسرى غير الفارغة\n * إلى الكومة المجاورة على اليمين. الشخص الذي لا يستطيع نقل الحجارة إلا في الكومة الأخيرة يخسر. بافتراض اللعب المثالي، حدد الفائز.\n *\n * >>> f_35(3, {1, 2, 2})\n * \"Dan\"\n */\nconst char* f_35(int n, const int piles[])", "sw": "#include <cassert>\n#include <iostream>\n/**\n * Ukipewa mlolongo wa marundo ya mawe N yaliyo na namba kutoka 1 hadi N, kila moja likiwa na idadi chanya ya mawe, amua mshindi\n * wa mchezo unaochezwa na Charlie na Dan. Charlie anaanza, wakibadilishana na Dan kuhamisha mawe kutoka kwenye rundo la kwanza lisilo tupu\n * kwenda kwenye rundo la kulia lililo karibu. Yule ambaye anaweza tu kuhamisha mawe kwenye rundo la mwisho anapoteza. Ukizingatia uchezaji kamili, pata mshindi.\n *\n * >>> f_35(3, {1, 2, 2})\n * \"Dan\"\n */\nconst char* f_35(int n, const int piles[])", "tr": "#include <cassert>\n#include <iostream>\n/**\n * 1'den N'e kadar numaralandırılmış N taş yığını dizisi verildiğinde, her biri pozitif sayıda taş içeren, Charlie ve Dan tarafından oynanan bir oyunun kazananını belirleyin.\n * Charlie başlar, Dan ile sırayla taşları en soldaki boş olmayan yığından bitişik sağdaki yığına taşır.\n * Sadece son yığındaki taşları hareket ettirebilen kişi kaybeder. Mükemmel oyun varsayıldığında, kazananı bulun.\n *\n * >>> f_35(3, {1, 2, 2})\n * \"Dan\"\n */\nconst char* f_35(int n, const int piles[])", "vi": "#include <cassert>\n#include <iostream>\n/**\n * Cho một dãy N đống đá được đánh số từ 1 đến N, mỗi đống chứa một số lượng đá dương, xác định người chiến thắng\n * của trò chơi được chơi bởi Charlie và Dan. Charlie bắt đầu, lần lượt với Dan di chuyển đá từ đống không rỗng bên trái nhất\n * sang đống liền kề bên phải. Người chỉ có thể di chuyển đá trong đống cuối cùng sẽ thua. Giả sử chơi hoàn hảo, tìm người chiến thắng.\n *\n * >>> f_35(3, {1, 2, 2})\n * \"Dan\"\n */\nconst char* f_35(int n, const int piles[])", "id": "#include <cassert>\n#include <iostream>\n/**\n * Diberikan urutan N tumpukan batu bernomor dari 1 hingga N, masing-masing berisi sejumlah batu positif, tentukan pemenang\n * dari permainan yang dimainkan oleh Charlie dan Dan. Charlie memulai, bergantian dengan Dan memindahkan batu dari tumpukan paling kiri yang tidak kosong\n * ke tumpukan kanan yang berdekatan. Orang yang hanya dapat memindahkan batu di tumpukan terakhir kalah. Dengan asumsi permainan sempurna, temukan pemenangnya.\n *\n * >>> f_35(3, {1, 2, 2})\n * \"Dan\"\n */\nconst char* f_35(int n, const int piles[])", "ja": "#include <cassert>\n#include <iostream>\n/**\n * 1からNまで番号が付けられたN個の石の山の列が与えられ、それぞれが正の数の石を含んでいます。チャーリーとダンによって行われるゲームの勝者を決定します。チャーリーが開始し、ダンと交互に左端の空でない山から隣接する右の山に石を移動します。最後の山でしか石を動かせない者が負けます。完璧なプレイを仮定して、勝者を見つけます。\n *\n * >>> f_35(3, {1, 2, 2})\n * \"Dan\"\n */\nconst char* f_35(int n, const int piles[])", "ko": "#include <cassert>\n#include <iostream>\n/**\n * 1부터 N까지 번호가 매겨진 N개의 돌무더기 시퀀스가 주어졌을 때, 각 돌무더기는 양수의 돌을 포함하고 있으며, Charlie와 Dan이 게임을 했을 때 승자를 결정합니다.\n * Charlie가 시작하며, Dan과 번갈아 가며 가장 왼쪽에 있는 비어 있지 않은 돌무더기에서 인접한 오른쪽 돌무더기로 돌을 옮깁니다.\n * 마지막 돌무더기에서만 돌을 옮길 수 있는 사람이 패배합니다. 완벽한 플레이를 가정했을 때, 승자를 찾으세요.\n *\n * >>> f_35(3, {1, 2, 2})\n * \"Dan\"\n */\nconst char* f_35(int n, const int piles[])", "ml": "#include <cassert>\n#include <iostream>\n/**\n * 1 മുതൽ N വരെ നമ്പർ ചെയ്ത N കൂമ്പാരങ്ങളുള്ള കല്ലുകളുടെ ഒരു നിര നൽകിയിരിക്കുമ്പോൾ, ഓരോ കൂമ്പാരത്തിലും ഒരു പോസിറ്റീവ് സംഖ്യയിലുള്ള കല്ലുകൾ അടങ്ങിയിരിക്കുന്നു, \n * ചാർളിയും ഡാനും കളിക്കുന്ന ഒരു ഗെയിമിന്റെ വിജയിയെ നിർണ്ണയിക്കുക. ചാർളി ആരംഭിക്കുന്നു, ഡാനുമായി മാറി മാറി ഇടതുവശത്തെ ശൂന്യമല്ലാത്ത കൂമ്പാരത്തിൽ നിന്ന് \n * സമീപവാസിയായ വലതുവശത്തെ കൂമ്പാരത്തിലേക്ക് കല്ലുകൾ നീക്കുന്നു. അവസാന കൂമ്പാരത്തിൽ മാത്രം കല്ലുകൾ നീക്കാൻ കഴിയുന്നയാൾ തോൽക്കും. \n * പൂർണ്ണമായ കളി കണക്കാക്കുമ്പോൾ, വിജയിയെ കണ്ടെത്തുക.\n *\n * >>> f_35(3, {1, 2, 2})\n * \"Dan\"\n */\nconst char* f_35(int n, const int piles[])", "fa": "#include <cassert>\n#include <iostream>\n/**\n * با توجه به دنباله‌ای از N توده سنگ شماره‌گذاری شده از 1 تا N، که هر کدام شامل تعداد مثبتی از سنگ‌ها هستند، برنده\n * بازی که توسط چارلی و دن انجام می‌شود را تعیین کنید. چارلی شروع می‌کند و به نوبت با دن سنگ‌ها را از توده غیرخالی سمت چپ\n * به توده مجاور سمت راست حرکت می‌دهند. کسی که فقط می‌تواند سنگ‌ها را در توده آخر حرکت دهد، بازنده است. با فرض بازی کامل، برنده را پیدا کنید.\n *\n * >>> f_35(3, {1, 2, 2})\n * \"Dan\"\n */\nconst char* f_35(int n, const int piles[])"}, "canonical_solution": "{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}", "instruction": {"en": "const char* f_35(int n, const int piles[])\n{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.", "sq": "const char* f_35(int n, const int piles[])\n{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit CPP në shqip duke përdorur maksimumi 500 karaktere.", "hy": "const char* f_35(int n, const int piles[])\n{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}\n\nՏվեք CPP կոդի համառոտ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "const char* f_35(int n, const int piles[])\n{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}\n\nসিপিপি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলা ভাষায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।", "bg": "const char* f_35(int n, const int piles[])\n{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}\n\nДайте кратко описание на CPP кода на български език, използвайки не повече от 500 знака.", "zh": "const char* f_35(int n, const int piles[])\n{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}\n\n将以下 CPP 代码的自然语言描述（文档字符串）用中文简明扼要地提供，字数不超过 500 个字符。", "fr": "const char* f_35(int n, const int piles[])\n{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}\n\nFournissez une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.", "de": "const char* f_35(int n, const int piles[])\n{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "const char* f_35(int n, const int piles[])\n{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar CPP a cikin Hausa ta amfani da haruffa 500 kawai.", "hi": "const char* f_35(int n, const int piles[])\n{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रींग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "const char* f_35(int n, const int piles[])\n{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a CPP kódhoz magyarul, legfeljebb 500 karakterben.", "es": "const char* f_35(int n, const int piles[])\n{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando como máximo 500 caracteres.", "arb": "const char* f_35(int n, const int piles[])\n{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية بلغة C++ باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "const char* f_35(int n, const int piles[])\n{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "const char* f_35(int n, const int piles[])\n{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}\n\nAşağıdaki CPP kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda, özlü bir doğal dil açıklaması (docstring) sağlayın.", "vi": "const char* f_35(int n, const int piles[])\n{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự.", "id": "const char* f_35(int n, const int piles[])\n{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode CPP dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "const char* f_35(int n, const int piles[])\n{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}\n\n以下のCPPコードの簡潔な自然言語による説明（ドックストリング）を日本語で500文字以内で提供してください。", "ko": "const char* f_35(int n, const int piles[])\n{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}\n\n다음 CPP 코드에 대한 간결한 자연어 설명(도크스트링)을 한국어로 500자 이내로 제공하세요.", "ml": "const char* f_35(int n, const int piles[])\n{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}\n\nസിപിപി കോഡിന്റെ മലയാളത്തിലുള്ള വിവരണം (ഡോക്സ്ട്രിംഗ്) 500 അക്ഷരങ്ങളിൽ കവിയാതെ നൽകുക.", "fa": "const char* f_35(int n, const int piles[])\n{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}\n\nتوضیح مختصر و طبیعی (docstring) از کد CPP را به زبان فارسی ارائه دهید که حداکثر ۵۰۰ کاراکتر باشد."}, "level": "", "test": "int main() {\n    int test1[] = {1, 2, 2};\n    int test2[] = {5, 5, 5, 5, 5};\n    int test3[] = {2, 1, 2};\n    int test4[] = {3, 3, 3, 3};\n    int test5[] = {1, 1};\n    int test6[] = {2, 1};\n    int test7[] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};\n    int test8[] = {2, 2, 2, 2, 2, 2, 2, 2, 2, 1};\n    int test9[] = {10, 10, 10, 10, 10, 10, 10, 10, 10, 10};\n    int test10[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n\n    assert(std::string(f_35(3, test1)) == \"Dan\");\n    assert(std::string(f_35(5, test2)) == \"Charlie\");\n    assert(std::string(f_35(3, test3)) == \"Charlie\");\n    assert(std::string(f_35(4, test4)) == \"Charlie\");\n    assert(std::string(f_35(2, test5)) == \"Charlie\");\n    assert(std::string(f_35(2, test6)) == \"Charlie\");\n    assert(std::string(f_35(11, test7)) == \"Dan\");\n    assert(std::string(f_35(10, test8)) == \"Charlie\");\n    assert(std::string(f_35(10, test9)) == \"Charlie\");\n    assert(std::string(f_35(10, test10)) == \"Dan\");\n\n    return 0;\n}", "entry_point": "f_35", "signature": "const char* f_35(int n, const int piles[])", "docstring": {"en": "Given a sequence of N piles of stones numbered from 1 to N, each containing a positive number of stones, determine the winner of a game played by Charlie and Dan. Charlie starts, taking turns with Dan moving stones from the leftmost non-empty pile to the adjacent right pile. The one who can only move stones in the last pile loses. Assuming perfect play, find the winner.\n\n>>> f_35(3, {1, 2, 2})\n\"Dan\"\n", "sq": "Duke pasur një sekuencë prej N grumbuj gurësh të numëruar nga 1 deri në N, secili që përmban një numër pozitiv gurësh, përcaktoni fituesin e një loje të luajtur nga Charlie dhe Dan. Charlie fillon, duke marrë radhën me Dan duke lëvizur gurë nga grumbulli më i majtë jo bosh në grumbullin fqinj në të djathtë. Ai që mund të lëvizë gurë vetëm në grumbullin e fundit humbet. Duke supozuar lojë të përsosur, gjeni fituesin.\n\n>>> f_35(3, {1, 2, 2})\n\"Dan\"", "hy": "Տրված է քարերի N կույտերի հաջորդականություն, որոնք համարակալված են 1-ից մինչև N, և յուրաքանչյուրը պարունակում է դրական թվով քարեր: Պարզեք Չարլիի և Դենի խաղի հաղթողին: Չարլին սկսում է, հերթով Դենի հետ տեղափոխելով քարերը ձախից աջ առաջին ոչ դատարկ կույտից դեպի հարակից աջ կույտ: Նա, ով կարող է միայն տեղափոխել քարերը վերջին կույտում, պարտվում է: Ենթադրելով կատարյալ խաղ, գտեք հաղթողին:\n\n>>> f_35(3, {1, 2, 2})\n\"Dan\"", "bn": "N সংখ্যক পাথরের স্তূপের একটি ক্রম দেওয়া হয়েছে, যা 1 থেকে N পর্যন্ত নম্বরযুক্ত, প্রতিটি স্তূপে একটি ইতিবাচক সংখ্যক পাথর রয়েছে। চার্লি এবং ড্যান দ্বারা খেলা একটি গেমের বিজয়ী নির্ধারণ করুন। চার্লি শুরু করে, ড্যানের সাথে পালা করে বামদিকের প্রথম খালি নয় এমন স্তূপ থেকে ডানপাশের সংলগ্ন স্তূপে পাথর সরিয়ে নেয়। যে ব্যক্তি কেবলমাত্র শেষ স্তূপে পাথর সরাতে পারে, সে হেরে যায়। নিখুঁত খেলার ধরণ ধরে নিয়ে, বিজয়ী খুঁজে বের করুন।\n\n>>> f_35(3, {1, 2, 2})\n\"Dan\"", "bg": "Дадена е последователност от N купчини камъни, номерирани от 1 до N, всяка съдържаща положителен брой камъни, определете победителя в игра, играна от Чарли и Дан. Чарли започва, като се редува с Дан да премества камъни от най-лявата непразна купчина към съседната дясна купчина. Този, който може да премества камъни само в последната купчина, губи. Приемайки перфектна игра, намерете победителя.\n\n>>> f_35(3, {1, 2, 2})\n\"Dan\"", "zh": "给定一个编号从1到N的石堆序列，每堆包含一个正数的石头，确定Charlie和Dan玩游戏的赢家。Charlie开始，与Dan轮流从最左边的非空堆移动石头到相邻的右边堆。只能在最后一堆移动石头的人输。假设完美的游戏，找出赢家。\n\n>>> f_35(3, {1, 2, 2})\n\"Dan\"", "fr": "Étant donné une séquence de N tas de pierres numérotés de 1 à N, chacun contenant un nombre positif de pierres, déterminez le gagnant d'un jeu joué par Charlie et Dan. Charlie commence, prenant des tours avec Dan pour déplacer des pierres du tas le plus à gauche non vide vers le tas adjacent à droite. Celui qui ne peut déplacer des pierres que dans le dernier tas perd. En supposant un jeu parfait, trouvez le gagnant.\n\n>>> f_35(3, {1, 2, 2})\n\"Dan\"", "de": "Angenommen, es gibt eine Sequenz von N Steinhaufen, die von 1 bis N nummeriert sind, wobei jeder Haufen eine positive Anzahl von Steinen enthält. Bestimmen Sie den Gewinner eines Spiels, das von Charlie und Dan gespielt wird. Charlie beginnt, abwechselnd mit Dan, indem er Steine vom linken, nicht leeren Haufen zum benachbarten rechten Haufen bewegt. Derjenige, der nur noch Steine im letzten Haufen bewegen kann, verliert. Angenommen, es wird perfekt gespielt, finden Sie den Gewinner.\n\n>>> f_35(3, {1, 2, 2})\n\"Dan\"", "ha": "An ba da jerin N na tarin duwatsu da aka lamba daga 1 zuwa N, kowanne yana dauke da adadin duwatsu masu kyau, a tantance wanda ya ci nasara a wani wasa da Charlie da Dan suka buga. Charlie yana farawa, suna juyawa da Dan suna motsa duwatsu daga mafi hagu wanda ba komai ba zuwa tarin dama kusa. Wanda zai iya motsa duwatsu a cikin tarin karshe kadai zai yi rashin nasara. Idan aka dauka cikakken wasa, gano wanda ya ci nasara.\n\n>>> f_35(3, {1, 2, 2})\n\"Dan\"", "hi": "N पत्थरों के ढेरों की एक अनुक्रमणिका दी गई है, जिन्हें 1 से N तक क्रमांकित किया गया है, प्रत्येक में पत्थरों की एक सकारात्मक संख्या है, चार्ली और डैन द्वारा खेले गए खेल के विजेता का निर्धारण करें। चार्ली शुरू करता है, डैन के साथ बारी-बारी से बाएं से दाएं सबसे पहले गैर-खाली ढेर से पत्थरों को अगले दाएं ढेर में ले जाता है। जो केवल अंतिम ढेर में पत्थरों को हिला सकता है, वह हार जाता है। पूर्ण खेल मानते हुए, विजेता का पता लगाएं।\n\n>>> f_35(3, {1, 2, 2})\n\"Dan\"", "hu": "Adott egy N kövekből álló halom sorozat, amelyeket 1-től N-ig számoztak, mindegyik pozitív számú követ tartalmaz. Határozd meg a Charlie és Dan által játszott játék győztesét. Charlie kezd, Dan-nel felváltva lépéseket téve, a baloldali nem üres halomból köveket mozgatva a szomszédos jobb oldali halomba. Az veszít, aki csak az utolsó halomban tud köveket mozgatni. Feltételezve a tökéletes játékot, találd meg a győztest.\n\n>>> f_35(3, {1, 2, 2})\n\"Dan\"", "es": "Dada una secuencia de N pilas de piedras numeradas del 1 al N, cada una conteniendo un número positivo de piedras, determina el ganador de un juego jugado por Charlie y Dan. Charlie comienza, turnándose con Dan moviendo piedras de la pila más a la izquierda que no esté vacía a la pila adyacente a la derecha. El que solo pueda mover piedras en la última pila pierde. Suponiendo un juego perfecto, encuentra al ganador.\n\n>>> f_35(3, {1, 2, 2})\n\"Dan\"", "arb": "بالنظر إلى تسلسل من N أكوام من الحجارة مرقمة من 1 إلى N، كل منها يحتوي على عدد إيجابي من الحجارة، حدد الفائز في لعبة يلعبها تشارلي ودان. يبدأ تشارلي، بالتناوب مع دان في نقل الحجارة من الكومة غير الفارغة اليسرى إلى الكومة المجاورة على اليمين. الشخص الذي لا يمكنه سوى نقل الحجارة في الكومة الأخيرة يخسر. بافتراض اللعب المثالي، حدد الفائز.\n\n>>> f_35(3, {1, 2, 2})\n\"Dan\"", "sw": "Kwa kuzingatia mlolongo wa marundo N ya mawe yaliyohesabiwa kutoka 1 hadi N, kila moja ikiwa na idadi chanya ya mawe, tambua mshindi wa mchezo unaochezwa na Charlie na Dan. Charlie anaanza, wakibadilishana zamu na Dan kuhamisha mawe kutoka kwenye rundo la kwanza lisilo tupu kwenda kwenye rundo la kulia lililo karibu. Yule ambaye anaweza tu kuhamisha mawe kwenye rundo la mwisho anapoteza. Tukichukulia uchezaji kamili, pata mshindi.\n\n>>> f_35(3, {1, 2, 2})\n\"Dan\"", "tr": "Taşlardan oluşan N yığınından oluşan bir diziliş verildiğinde, her biri pozitif sayıda taş içeren ve 1'den N'ye kadar numaralandırılmış, Charlie ve Dan tarafından oynanan bir oyunun kazananını belirleyin. Charlie başlar, Dan ile sırayla taşları en soldaki boş olmayan yığından bitişik sağdaki yığına taşır. Sadece son yığındaki taşları hareket ettirebilen kişi kaybeder. Mükemmel oyun varsayıldığında, kazananı bulun.\n\n>>> f_35(3, {1, 2, 2})\n\"Dan\"", "vi": "Cho một dãy N đống đá được đánh số từ 1 đến N, mỗi đống chứa một số lượng đá dương, xác định người chiến thắng của trò chơi được chơi bởi Charlie và Dan. Charlie bắt đầu, lần lượt với Dan di chuyển đá từ đống không trống bên trái nhất sang đống liền kề bên phải. Người chỉ có thể di chuyển đá trong đống cuối cùng sẽ thua. Giả sử chơi hoàn hảo, tìm người chiến thắng.\n\n>>> f_35(3, {1, 2, 2})\n\"Dan\"", "id": "Diberikan urutan N tumpukan batu bernomor dari 1 hingga N, masing-masing berisi sejumlah batu positif, tentukan pemenang dari permainan yang dimainkan oleh Charlie dan Dan. Charlie memulai, bergantian dengan Dan memindahkan batu dari tumpukan paling kiri yang tidak kosong ke tumpukan kanan yang berdekatan. Orang yang hanya dapat memindahkan batu di tumpukan terakhir kalah. Dengan asumsi permainan sempurna, temukan pemenangnya.\n\n>>> f_35(3, {1, 2, 2})\n\"Dan\"", "ja": "石の山が1からNまで番号付けられたN個の山があり、それぞれが正の数の石を含んでいます。チャーリーとダンが行うゲームの勝者を決定します。チャーリーが開始し、ダンと交互に左端の空でない山から隣の右の山に石を移動させます。最後の山でしか石を移動できない者が負けます。完璧なプレイを仮定して、勝者を見つけます。\n\n>>> f_35(3, {1, 2, 2})\n\"Dan\"", "ko": "돌무더기 1번부터 N번까지 번호가 매겨진 N개의 돌무더기가 주어졌을 때, 각각의 돌무더기는 양의 수의 돌을 포함하고 있습니다. Charlie와 Dan이 게임을 하여 승자를 결정합니다. Charlie가 시작하며, Dan과 번갈아 가며 가장 왼쪽의 비어 있지 않은 돌무더기에서 인접한 오른쪽 돌무더기로 돌을 옮깁니다. 마지막 돌무더기에서만 돌을 옮길 수 있는 사람은 패배합니다. 완벽한 플레이를 가정했을 때, 승자를 찾으세요.\n\n>>> f_35(3, {1, 2, 2})\n\"Dan\"", "ml": "N കൂമ്പാരങ്ങൾ ഉള്ള ഒരു നിരയിൽ, ഓരോന്നിലും ഒരു പോസിറ്റീവ് എണ്ണം കല്ലുകൾ അടങ്ങിയിരിക്കുന്നു, ചാർളിയും ഡാനും കളിക്കുന്ന ഒരു ഗെയിമിന്റെ വിജയിയെ നിർണ്ണയിക്കുക. ചാർളി ആരംഭിക്കുന്നു, ഡാനുമായി മാറി മാറി കല്ലുകൾ ഇടതുവശത്തെ ശൂന്യമായിട്ടില്ലാത്ത കൂമ്പാരത്തിൽ നിന്ന് അടുത്ത വലതുവശത്തെ കൂമ്പാരത്തിലേക്ക് നീക്കുന്നു. അവസാന കൂമ്പാരത്തിൽ മാത്രം കല്ലുകൾ നീക്കാൻ കഴിയുന്നയാൾ തോൽക്കും. പരിപൂർണ്ണമായ കളി അനുസരിച്ച്, വിജയിയെ കണ്ടെത്തുക.\n\n>>> f_35(3, {1, 2, 2})\n\"Dan\"", "fa": "با توجه به دنباله‌ای از N توده سنگ شماره‌گذاری شده از 1 تا N، که هر کدام شامل تعدادی سنگ مثبت هستند، برنده بازی که توسط چارلی و دن بازی می‌شود را تعیین کنید. چارلی شروع می‌کند و به نوبت با دن سنگ‌ها را از توده غیرخالی سمت چپ به توده مجاور سمت راست حرکت می‌دهند. کسی که تنها می‌تواند سنگ‌ها را در توده آخر حرکت دهد، می‌بازد. با فرض بازی کامل، برنده را پیدا کنید.\n\n>>> f_35(3, {1, 2, 2})\n\"Dan\""}}
{"task_id": "CPP/36", "prompt": {"en": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * @doc\n * Given n doors arranged in a circle, the player starts in front of door 1.\n * Each turn, the player can choose a number i and pay a cost C_i to move i steps to the right\n * and then open the door at that position. It is guaranteed that C_i >= C_{i+1} for 1 <= i < n.\n * The task is to determine the minimum total cost required to open all doors.\n *\n * Example:\n *     >>> f_36(3, (1, 1, 1))\n *     3\n */\nlong long f_36(int n, const std::vector<int>& C)", "sq": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * @doc\n * Duke pasur parasysh n dyer të rregulluara në një rreth, lojtari fillon përpara derës 1.\n * Çdo radhë, lojtari mund të zgjedhë një numër i dhe të paguajë një kosto C_i për të lëvizur i hapa djathtas\n * dhe pastaj të hapë derën në atë pozicion. Është e garantuar që C_i >= C_{i+1} për 1 <= i < n.\n * Detyra është të përcaktohet kostoja minimale totale e kërkuar për të hapur të gjitha dyert.\n *\n * Shembull:\n *     >>> f_36(3, (1, 1, 1))\n *     3\n */\nlong long f_36(int n, const std::vector<int>& C)", "hy": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * @doc\n * Տրված են n դռներ, որոնք դասավորված են շրջանաձև, խաղացողը սկսում է դուռ 1-ի դիմացից:\n * Յուրաքանչյուր քայլի ժամանակ խաղացողը կարող է ընտրել թիվ i և վճարել արժեք C_i՝ i քայլ աջ շարժվելու\n * և այնուհետև այդ դիրքում դուռը բացելու համար: Երաշխավորված է, որ C_i >= C_{i+1} 1 <= i < n-ի համար:\n * Խնդիրը կայանում է որոշել բոլոր դռները բացելու համար անհրաժեշտ նվազագույն ընդհանուր արժեքը:\n *\n * Օրինակ:\n *     >>> f_36(3, (1, 1, 1))\n *     3\n */\nlong long f_36(int n, const std::vector<int>& C)", "bn": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * @doc\n * একটি বৃত্তে সাজানো n টি দরজা দেওয়া আছে, খেলোয়াড় দরজা 1 এর সামনে থেকে শুরু করে।\n * প্রতিটি পালায়, খেলোয়াড় একটি সংখ্যা i বেছে নিতে পারে এবং i ধাপ ডানদিকে যেতে C_i খরচ দিতে পারে\n * এবং তারপর সেই অবস্থানে দরজা খুলতে পারে। এটি নিশ্চিত যে C_i >= C_{i+1} যেখানে 1 <= i < n।\n * কাজটি হল সমস্ত দরজা খোলার জন্য প্রয়োজনীয় সর্বনিম্ন মোট খরচ নির্ধারণ করা।\n *\n * উদাহরণ:\n *     >>> f_36(3, (1, 1, 1))\n *     3\n */\nlong long f_36(int n, const std::vector<int>& C)", "bg": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * @doc\n * Дадени са n врати, подредени в кръг, играчът започва пред врата 1.\n * Всеки ход, играчът може да избере число i и да плати цена C_i, за да се премести i стъпки надясно\n * и след това да отвори вратата на тази позиция. Гарантирано е, че C_i >= C_{i+1} за 1 <= i < n.\n * Задачата е да се определи минималната обща цена, необходима за отваряне на всички врати.\n *\n * Пример:\n *     >>> f_36(3, (1, 1, 1))\n *     3\n */\nlong long f_36(int n, const std::vector<int>& C)", "zh": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * @doc\n * 给定 n 个门按圆形排列，玩家从门 1 前面开始。\n * 每回合，玩家可以选择一个数字 i 并支付一个代价 C_i 向右移动 i 步，\n * 然后打开该位置的门。保证 C_i >= C_{i+1} 对于 1 <= i < n。\n * 任务是确定打开所有门所需的最小总成本。\n *\n * 示例:\n *     >>> f_36(3, (1, 1, 1))\n *     3\n */\nlong long f_36(int n, const std::vector<int>& C)", "fr": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * @doc\n * Étant donné n portes disposées en cercle, le joueur commence devant la porte 1.\n * À chaque tour, le joueur peut choisir un nombre i et payer un coût C_i pour avancer de i pas vers la droite\n * puis ouvrir la porte à cette position. Il est garanti que C_i >= C_{i+1} pour 1 <= i < n.\n * La tâche consiste à déterminer le coût total minimum nécessaire pour ouvrir toutes les portes.\n *\n * Exemple:\n *     >>> f_36(3, (1, 1, 1))\n *     3\n */\nlong long f_36(int n, const std::vector<int>& C)", "de": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * @doc\n * Gegeben sind n Türen, die in einem Kreis angeordnet sind, beginnt der Spieler vor Tür 1.\n * In jedem Zug kann der Spieler eine Zahl i wählen und einen Kosten C_i zahlen, um i Schritte nach rechts zu gehen\n * und dann die Tür an dieser Position zu öffnen. Es ist garantiert, dass C_i >= C_{i+1} für 1 <= i < n.\n * Die Aufgabe besteht darin, die minimalen Gesamtkosten zu bestimmen, die erforderlich sind, um alle Türen zu öffnen.\n *\n * Beispiel:\n *     >>> f_36(3, (1, 1, 1))\n *     3\n */\nlong long f_36(int n, const std::vector<int>& C)", "ha": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * @doc\n * An ba da n kofofi da aka shirya a cikin da'ira, ɗan wasa yana farawa a gaban kofa ta 1.\n * Kowanne juyawa, ɗan wasan na iya zaɓar lamba i kuma ya biya kuɗi C_i don matsawa matakai i zuwa dama\n * sannan ya buɗe ƙofar a wannan matsayi. An tabbatar da cewa C_i >= C_{i+1} don 1 <= i < n.\n * Aikin shine a tantance mafi ƙarancin jimlar kuɗi da ake buƙata don buɗe duk kofofin.\n *\n * Misali:\n *     >>> f_36(3, (1, 1, 1))\n *     3\n */\nlong long f_36(int n, const std::vector<int>& C)", "hi": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * @doc\n * दिए गए n दरवाजे जो एक वृत्त में व्यवस्थित हैं, खिलाड़ी दरवाजा 1 के सामने से शुरू होता है।\n * प्रत्येक चाल में, खिलाड़ी एक संख्या i चुन सकता है और i कदम दाईं ओर जाने के लिए लागत C_i का भुगतान कर सकता है\n * और फिर उस स्थिति पर दरवाजा खोल सकता है। यह गारंटी है कि C_i >= C_{i+1} जहाँ 1 <= i < n।\n * कार्य यह निर्धारित करना है कि सभी दरवाजे खोलने के लिए न्यूनतम कुल लागत क्या होगी।\n *\n * उदाहरण:\n *     >>> f_36(3, (1, 1, 1))\n *     3\n */\nlong long f_36(int n, const std::vector<int>& C)", "hu": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * @doc\n * Adott n ajtó, amelyek körben vannak elrendezve, a játékos az 1-es ajtó előtt kezd.\n * Minden körben a játékos választhat egy számot i, és fizet egy C_i költséget, hogy i lépést tegyen jobbra,\n * majd kinyitja az adott pozíción lévő ajtót. Garantált, hogy C_i >= C_{i+1} minden 1 <= i < n esetén.\n * A feladat annak meghatározása, hogy mi a minimális összköltség az összes ajtó kinyitásához.\n *\n * Példa:\n *     >>> f_36(3, (1, 1, 1))\n *     3\n */\nlong long f_36(int n, const std::vector<int>& C)", "es": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * @doc\n * Dado n puertas dispuestas en un círculo, el jugador comienza frente a la puerta 1.\n * En cada turno, el jugador puede elegir un número i y pagar un costo C_i para moverse i pasos a la derecha\n * y luego abrir la puerta en esa posición. Se garantiza que C_i >= C_{i+1} para 1 <= i < n.\n * La tarea es determinar el costo total mínimo requerido para abrir todas las puertas.\n *\n * Ejemplo:\n *     >>> f_36(3, (1, 1, 1))\n *     3\n */\nlong long f_36(int n, const std::vector<int>& C)", "arb": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * @doc\n * بالنظر إلى n أبواب مرتبة في دائرة، يبدأ اللاعب أمام الباب 1.\n * في كل دور، يمكن للاعب اختيار رقم i ودفع تكلفة C_i للتحرك i خطوات إلى اليمين\n * ثم فتح الباب في ذلك الموقع. من المضمون أن C_i >= C_{i+1} لـ 1 <= i < n.\n * المهمة هي تحديد الحد الأدنى للتكلفة الإجمالية المطلوبة لفتح جميع الأبواب.\n *\n * مثال:\n *     >>> f_36(3, (1, 1, 1))\n *     3\n */\nlong long f_36(int n, const std::vector<int>& C)", "sw": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * @doc\n * Ukipewa milango n iliyopangwa katika mduara, mchezaji huanza mbele ya mlango wa 1.\n * Kila zamu, mchezaji anaweza kuchagua namba i na kulipa gharama C_i ili kusonga hatua i kwenda kulia\n * na kisha kufungua mlango katika nafasi hiyo. Inahakikishwa kuwa C_i >= C_{i+1} kwa 1 <= i < n.\n * Kazi ni kubaini gharama ndogo kabisa inayohitajika kufungua milango yote.\n *\n * Mfano:\n *     >>> f_36(3, (1, 1, 1))\n *     3\n */\nlong long f_36(int n, const std::vector<int>& C)", "tr": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * @doc\n * Daire şeklinde düzenlenmiş n kapı verildiğinde, oyuncu 1 numaralı kapının önünde başlar.\n * Her turda, oyuncu bir sayı i seçebilir ve i adım sağa hareket etmek için bir maliyet C_i ödeyebilir\n * ve ardından o konumdaki kapıyı açabilir. C_i >= C_{i+1} olduğu garanti edilir, 1 <= i < n için.\n * Görev, tüm kapıları açmak için gereken minimum toplam maliyeti belirlemektir.\n *\n * Örnek:\n *     >>> f_36(3, (1, 1, 1))\n *     3\n */\nlong long f_36(int n, const std::vector<int>& C)", "vi": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * @doc\n * Cho n cánh cửa được sắp xếp thành một vòng tròn, người chơi bắt đầu trước cửa số 1.\n * Mỗi lượt, người chơi có thể chọn một số i và trả một chi phí C_i để di chuyển i bước sang phải\n * và sau đó mở cánh cửa ở vị trí đó. Đảm bảo rằng C_i >= C_{i+1} cho 1 <= i < n.\n * Nhiệm vụ là xác định tổng chi phí tối thiểu cần thiết để mở tất cả các cửa.\n *\n * Ví dụ:\n *     >>> f_36(3, (1, 1, 1))\n *     3\n */\nlong long f_36(int n, const std::vector<int>& C)", "id": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * @doc\n * Diberikan n pintu yang diatur dalam lingkaran, pemain mulai di depan pintu 1.\n * Setiap giliran, pemain dapat memilih angka i dan membayar biaya C_i untuk bergerak i langkah ke kanan\n * dan kemudian membuka pintu di posisi tersebut. Dijamin bahwa C_i >= C_{i+1} untuk 1 <= i < n.\n * Tugasnya adalah menentukan total biaya minimum yang diperlukan untuk membuka semua pintu.\n *\n * Contoh:\n *     >>> f_36(3, (1, 1, 1))\n *     3\n */\nlong long f_36(int n, const std::vector<int>& C)", "ja": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * @doc\n * 円形に配置された n 個のドアがあり、プレイヤーはドア1の前に立っています。\n * 各ターンで、プレイヤーは番号 i を選び、コスト C_i を支払って右に i ステップ移動し、\n * その位置のドアを開けることができます。1 <= i < n に対して C_i >= C_{i+1} が保証されています。\n * すべてのドアを開けるために必要な最小の総コストを求めることが課題です。\n *\n * 例:\n *     >>> f_36(3, (1, 1, 1))\n *     3\n */\nlong long f_36(int n, const std::vector<int>& C)", "ko": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * @doc\n * 원형으로 배열된 n개의 문이 주어졌을 때, 플레이어는 문 1 앞에서 시작합니다.\n * 각 턴마다 플레이어는 숫자 i를 선택하고 비용 C_i를 지불하여 오른쪽으로 i단계 이동한 후\n * 해당 위치의 문을 엽니다. C_i >= C_{i+1}가 1 <= i < n에 대해 보장됩니다.\n * 모든 문을 여는 데 필요한 최소 총 비용을 결정하는 것이 과제입니다.\n *\n * 예시:\n *     >>> f_36(3, (1, 1, 1))\n *     3\n */\nlong long f_36(int n, const std::vector<int>& C)\n", "ml": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * @doc\n * വൃത്താകൃതിയിൽ ക്രമീകരിച്ച n വാതിലുകൾ നൽകിയിരിക്കുന്നു, കളിക്കാരൻ വാതിൽ 1-ന്റെ മുന്നിൽ നിന്ന് ആരംഭിക്കുന്നു.\n * ഓരോ തവണയും, കളിക്കാരൻ ഒരു സംഖ്യ i തിരഞ്ഞെടുക്കുകയും i ഘട്ടങ്ങൾ വലത്തേക്ക് നീങ്ങി ആ സ്ഥാനത്തുള്ള വാതിൽ തുറക്കുകയും ചെയ്യാം, അതിന് C_i ചെലവ് നൽകണം.\n * 1 <= i < n എന്നതിനായി C_i >= C_{i+1} എന്നത് ഉറപ്പാണ്.\n * എല്ലാ വാതിലുകളും തുറക്കാൻ ആവശ്യമായ കുറഞ്ഞ മൊത്തം ചെലവ് നിർണയിക്കാനുള്ളതാണ് ഈ ജോലി.\n *\n * ഉദാഹരണം:\n *     >>> f_36(3, (1, 1, 1))\n *     3\n */\nlong long f_36(int n, const std::vector<int>& C)", "fa": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * @doc\n * با توجه به n در که به صورت دایره‌ای چیده شده‌اند، بازیکن در مقابل در 1 شروع می‌کند.\n * در هر نوبت، بازیکن می‌تواند عددی i را انتخاب کرده و هزینه C_i را پرداخت کند تا i قدم به راست حرکت کند\n * و سپس در آن موقعیت در را باز کند. تضمین شده است که C_i >= C_{i+1} برای 1 <= i < n.\n * وظیفه این است که حداقل هزینه کل مورد نیاز برای باز کردن همه درها را تعیین کنید.\n *\n * مثال:\n *     >>> f_36(3, (1, 1, 1))\n *     3\n */\nlong long f_36(int n, const std::vector<int>& C)\n"}, "canonical_solution": "{\n    return static_cast<long long>(C[n - 2]) * (n - 1) + C[n - 1];\n}", "instruction": {"en": "long long f_36(int n, const std::vector<int>& C)\n{\n    return static_cast<long long>(C[n - 2]) * (n - 1) + C[n - 1];\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.", "sq": "long long f_36(int n, const std::vector<int>& C)\n{\n    return static_cast<long long>(C[n - 2]) * (n - 1) + C[n - 1];\n}\n\nJepni një përshkrim të shkurtër në gjuhën natyrore (docstring) të kodit CPP në shqip duke përdorur maksimumi 500 karaktere.", "hy": "long long f_36(int n, const std::vector<int>& C)\n{\n    return static_cast<long long>(C[n - 2]) * (n - 1) + C[n - 1];\n}\n\nՏվեք CPP կոդի համառոտ բնական լեզվով նկարագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "long long f_36(int n, const std::vector<int>& C)\n{\n    return static_cast<long long>(C[n - 2]) * (n - 1) + C[n - 1];\n}\n\nসিপিপি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলা ভাষায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।", "bg": "long long f_36(int n, const std::vector<int>& C)\n{\n    return static_cast<long long>(C[n - 2]) * (n - 1) + C[n - 1];\n}\n\nПредоставете кратко описание на CPP кода на естествен език (docstring) на български, използвайки най-много 500 знака.", "zh": "long long f_36(int n, const std::vector<int>& C)\n{\n    return static_cast<long long>(C[n - 2]) * (n - 1) + C[n - 1];\n}\n\n请用不超过500个字符的中文，为以下CPP代码提供简洁的自然语言描述（文档字符串）。", "fr": "long long f_36(int n, const std::vector<int>& C)\n{\n    return static_cast<long long>(C[n - 2]) * (n - 1) + C[n - 1];\n}\n\nFournissez une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.", "de": "long long f_36(int n, const std::vector<int>& C)\n{\n    return static_cast<long long>(C[n - 2]) * (n - 1) + C[n - 1];\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "long long f_36(int n, const std::vector<int>& C)\n{\n    return static_cast<long long>(C[n - 2]) * (n - 1) + C[n - 1];\n}\n\nBa da takaitaccen bayani na halayen lambar CPP a cikin Hausa ta amfani da haruffa 500 kacal.", "hi": "long long f_36(int n, const std::vector<int>& C)\n{\n    return static_cast<long long>(C[n - 2]) * (n - 1) + C[n - 1];\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "long long f_36(int n, const std::vector<int>& C)\n{\n    return static_cast<long long>(C[n - 2]) * (n - 1) + C[n - 1];\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a CPP kódról magyarul, legfeljebb 500 karakterben.", "es": "long long f_36(int n, const std::vector<int>& C)\n{\n    return static_cast<long long>(C[n - 2]) * (n - 1) + C[n - 1];\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando como máximo 500 caracteres.", "arb": "long long f_36(int n, const std::vector<int>& C)\n{\n    return static_cast<long long>(C[n - 2]) * (n - 1) + C[n - 1];\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C++ باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "long long f_36(int n, const std::vector<int>& C)\n{\n    return static_cast<long long>(C[n - 2]) * (n - 1) + C[n - 1];\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "long long f_36(int n, const std::vector<int>& C)\n{\n    return static_cast<long long>(C[n - 2]) * (n - 1) + C[n - 1];\n}\n\nAşağıdaki CPP kodunun Türkçe olarak en fazla 500 karakterle doğal dilde kısa bir açıklamasını (docstring) sağlayın.", "vi": "long long f_36(int n, const std::vector<int>& C)\n{\n    return static_cast<long long>(C[n - 2]) * (n - 1) + C[n - 1];\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự.", "id": "long long f_36(int n, const std::vector<int>& C)\n{\n    return static_cast<long long>(C[n - 2]) * (n - 1) + C[n - 1];\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode CPP dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "long long f_36(int n, const std::vector<int>& C)\n{\n    return static_cast<long long>(C[n - 2]) * (n - 1) + C[n - 1];\n}\n\n以下のCPPコードの簡潔な自然言語による説明（ドックストリング）を日本語で500文字以内で提供してください。", "ko": "long long f_36(int n, const std::vector<int>& C)\n{\n    return static_cast<long long>(C[n - 2]) * (n - 1) + C[n - 1];\n}\n\n다음 CPP 코드의 동작을 간결하게 설명하는 자연어 설명(docstring)을 최대 500자 이내로 한국어로 제공하세요.", "ml": "long long f_36(int n, const std::vector<int>& C)\n{\n    return static_cast<long long>(C[n - 2]) * (n - 1) + C[n - 1];\n}\n\nസിപിപി കോഡിന്റെ മലയാളത്തിൽ 500 അക്ഷരങ്ങളിൽ കൂടുതലല്ലാത്ത സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) നൽകുക.", "fa": "long long f_36(int n, const std::vector<int>& C)\n{\n    return static_cast<long long>(C[n - 2]) * (n - 1) + C[n - 1];\n}\n\nتوضیح مختصر و طبیعی (docstring) از کد CPP به زبان فارسی ارائه دهید که حداکثر ۵۰۰ کاراکتر باشد."}, "level": "", "test": "int main() {\n    std::vector<int> costs1 = {4, 3, 3, 3, 3}; // 1-indexed array\n    assert(f_36(5, costs1) == 15);\n\n    std::vector<int> costs2 = {1, 1, 1};\n    assert(f_36(3, costs2) == 3);\n\n    std::vector<int> costs3 = {5, 4, 3, 2};\n    assert(f_36(4, costs3) == 11);\n\n    std::vector<int> costs4 = {100, 99, 98, 97};\n    assert(f_36(4, costs4) == 391);\n\n    std::vector<int> costs5 = {10, 9, 8, 7, 6, 5};\n    assert(f_36(6, costs5) == 35);\n\n    std::vector<int> costs6 = {2, 2, 2, 2, 2, 2, 2};\n    assert(f_36(7, costs6) == 14);\n\n    std::vector<int> costs7 = {9, 7, 7, 7, 7, 7, 7, 7};\n    assert(f_36(8, costs7) == 56);\n\n    std::vector<int> costs8 = {3, 2, 2, 2, 2, 2, 2, 2, 2};\n    assert(f_36(9, costs8) == 18);\n\n    std::vector<int> costs9 = {6, 5, 5, 5, 5, 5, 5, 5, 5, 5};\n    assert(f_36(10, costs9) == 50);\n\n    std::vector<int> costs10 = {8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};\n    assert(f_36(11, costs10) == 11);\n\n\n    return 0;\n}", "entry_point": "f_36", "signature": "long long f_36(int n, const std::vector<int>& C)", "docstring": {"en": "Given n doors arranged in a circle, the player starts in front of door 1.\nEach turn, the player can choose a number i and pay a cost C_i to move i steps to the right\nand then open the door at that position. It is guaranteed that C_i >= C_{i+1} for 1 <= i < n.\nThe task is to determine the minimum total cost required to open all doors.\n\nExample:\n    >>> f_36(3, (1, 1, 1))\n    3\n", "sq": "Duke pasur n dyer të rregulluara në një rreth, lojtari fillon përballë derës 1.  \nÇdo radhë, lojtari mund të zgjedhë një numër i dhe të paguajë një kosto C_i për të lëvizur i hapa në të djathtë  \ndhe pastaj të hapë derën në atë pozicion. Është e garantuar që C_i >= C_{i+1} për 1 <= i < n.  \nDetyra është të përcaktohet kostoja totale minimale e nevojshme për të hapur të gjitha dyert.\n\nShembull:\n    >>> f_36(3, (1, 1, 1))\n    3", "hy": "Տրված է n դռներ, որոնք դասավորված են շրջանաձև, խաղացողը սկսում է դուռ 1-ի դիմաց:  \nՅուրաքանչյուր քայլի ժամանակ խաղացողը կարող է ընտրել թիվ i և վճարել C_i արժեքը՝ i քայլ աջ շարժվելու և այնուհետև այդ դիրքի դուռը բացելու համար: Երաշխավորված է, որ C_i >= C_{i+1} 1 <= i < n-ի համար:  \nԽնդիրը կայանում է բոլոր դռները բացելու համար պահանջվող նվազագույն ընդհանուր արժեքը որոշելու մեջ:\n\nՕրինակ:\n    >>> f_36(3, (1, 1, 1))\n    3", "bn": "nটি দরজা একটি বৃত্তে সাজানো আছে, খেলোয়াড় দরজা 1 এর সামনে থেকে শুরু করে।  \nপ্রতিটি পালায়, খেলোয়াড় একটি সংখ্যা i বেছে নিতে পারে এবং i ধাপ ডানদিকে যেতে C_i খরচ দিতে পারে  \nএবং তারপর সেই অবস্থানে দরজা খুলতে পারে। এটি নিশ্চিত যে C_i >= C_{i+1} যেখানে 1 <= i < n।  \nসমস্ত দরজা খোলার জন্য প্রয়োজনীয় সর্বনিম্ন মোট খরচ নির্ধারণ করার কাজ।\n\nউদাহরণ:\n    >>> f_36(3, (1, 1, 1))\n    3", "bg": "Дадени са n врати, подредени в кръг, играчът започва пред врата 1.  \nВсеки ход играчът може да избере число i и да плати цена C_i, за да се премести i стъпки надясно  \nи след това да отвори вратата на тази позиция. Гарантирано е, че C_i >= C_{i+1} за 1 <= i < n.  \nЗадачата е да се определи минималната обща цена, необходима за отваряне на всички врати.\n\nПример:\n    >>> f_36(3, (1, 1, 1))\n    3", "zh": "给定 n 个门按圆形排列，玩家从门 1 前开始。  \n每回合，玩家可以选择一个数字 i 并支付代价 C_i 向右移动 i 步，然后打开该位置的门。保证 C_i >= C_{i+1} 对于 1 <= i < n。  \n任务是确定打开所有门所需的最小总成本。\n\n示例：  \n    >>> f_36(3, (1, 1, 1))  \n    3  ", "fr": "Étant donné n portes disposées en cercle, le joueur commence devant la porte 1.  \nÀ chaque tour, le joueur peut choisir un nombre i et payer un coût C_i pour avancer de i pas vers la droite  \net ensuite ouvrir la porte à cette position. Il est garanti que C_i >= C_{i+1} pour 1 <= i < n.  \nLa tâche consiste à déterminer le coût total minimum nécessaire pour ouvrir toutes les portes.\n\nExemple :\n    >>> f_36(3, (1, 1, 1))\n    3", "de": "Gegeben n Türen, die in einem Kreis angeordnet sind, beginnt der Spieler vor Tür 1. \nIn jedem Zug kann der Spieler eine Zahl i wählen und die Kosten C_i zahlen, um i Schritte nach rechts zu gehen \nund dann die Tür an dieser Position zu öffnen. Es ist garantiert, dass C_i >= C_{i+1} für 1 <= i < n. \nDie Aufgabe besteht darin, die minimalen Gesamtkosten zu bestimmen, die erforderlich sind, um alle Türen zu öffnen.\n\nBeispiel:\n    >>> f_36(3, (1, 1, 1))\n    3", "ha": "An ba ƙofar n da aka shirya a cikin da'ira, ɗan wasan yana farawa a gaban ƙofa ta 1. \nKowane juyi, ɗan wasan na iya zaɓar lamba i kuma ya biya kuɗi C_i don matsawa matakai i zuwa dama \nsannan ya buɗe ƙofar a wannan matsayi. An tabbatar da cewa C_i >= C_{i+1} don 1 <= i < n. \nAikin shi ne a tantance mafi ƙarancin jimillar kuɗi da ake buƙata don buɗe duk ƙofofi.\n\nMisali:\n    >>> f_36(3, (1, 1, 1))\n    3", "hi": "दी गई n दरवाजों को एक वृत्त में व्यवस्थित किया गया है, खिलाड़ी दरवाजा 1 के सामने से शुरू करता है। \nप्रत्येक चाल में, खिलाड़ी एक संख्या i चुन सकता है और i कदम दाईं ओर जाने के लिए लागत C_i का भुगतान कर सकता है \nऔर फिर उस स्थिति पर दरवाजा खोल सकता है। यह गारंटी दी जाती है कि C_i >= C_{i+1} जहाँ 1 <= i < n। \nकार्य यह निर्धारित करना है कि सभी दरवाजों को खोलने के लिए न्यूनतम कुल लागत क्या होगी।\n\nउदाहरण:\n    >>> f_36(3, (1, 1, 1))\n    3", "hu": "Adott n ajtó, amelyek körben vannak elrendezve, a játékos az 1-es ajtó előtt kezd.\nMinden körben a játékos választhat egy számot i, és fizet egy C_i költséget, hogy i lépést tegyen jobbra,\nmajd kinyitja az ajtót azon a helyen. Garantált, hogy C_i >= C_{i+1} minden 1 <= i < n esetén.\nA feladat annak meghatározása, hogy mi a minimális összköltség az összes ajtó kinyitásához.\n\nPélda:\n    >>> f_36(3, (1, 1, 1))\n    3", "es": "Dado n puertas dispuestas en un círculo, el jugador comienza frente a la puerta 1.  \nCada turno, el jugador puede elegir un número i y pagar un costo C_i para moverse i pasos a la derecha  \ny luego abrir la puerta en esa posición. Se garantiza que C_i >= C_{i+1} para 1 <= i < n.  \nLa tarea es determinar el costo total mínimo requerido para abrir todas las puertas.\n\nEjemplo:\n    >>> f_36(3, (1, 1, 1))\n    3", "arb": "معطى n أبواب مرتبة في دائرة، يبدأ اللاعب أمام الباب 1.  \nفي كل دور، يمكن للاعب اختيار رقم i ودفع تكلفة C_i للتحرك i خطوات إلى اليمين ثم فتح الباب في ذلك الموقع. من المضمون أن C_i >= C_{i+1} لكل 1 <= i < n.  \nالمهمة هي تحديد الحد الأدنى للتكلفة الإجمالية المطلوبة لفتح جميع الأبواب.\n\nمثال:  \n    >>> f_36(3, (1, 1, 1))  \n    3  ", "sw": "Kwa kuwa kuna milango n iliyopangwa katika mduara, mchezaji anaanza mbele ya mlango wa 1.  \nKila zamu, mchezaji anaweza kuchagua namba i na kulipa gharama C_i ili kusonga hatua i kwenda kulia  \nkisha kufungua mlango katika nafasi hiyo. Inahakikishwa kuwa C_i >= C_{i+1} kwa 1 <= i < n.  \nKazi ni kuamua gharama ndogo kabisa inayohitajika kufungua milango yote.\n\nMfano:\n    >>> f_36(3, (1, 1, 1))\n    3", "tr": "Verilen n kapı bir çember şeklinde düzenlenmiştir, oyuncu kapı 1'in önünde başlar.  \nHer turda, oyuncu bir sayı i seçebilir ve i adım sağa hareket etmek için bir maliyet C_i ödeyebilir  \nve ardından o konumdaki kapıyı açabilir. C_i >= C_{i+1} olduğu garanti edilmiştir, 1 <= i < n için.  \nGörev, tüm kapıları açmak için gereken minimum toplam maliyeti belirlemektir.\n\nÖrnek:\n    >>> f_36(3, (1, 1, 1))\n    3", "vi": "Cho n cửa được sắp xếp thành vòng tròn, người chơi bắt đầu trước cửa số 1.  \nMỗi lượt, người chơi có thể chọn một số i và trả một chi phí C_i để di chuyển i bước sang phải  \nvà sau đó mở cửa tại vị trí đó. Đảm bảo rằng C_i >= C_{i+1} cho 1 <= i < n.  \nNhiệm vụ là xác định tổng chi phí tối thiểu cần thiết để mở tất cả các cửa.\n\nVí dụ:\n    >>> f_36(3, (1, 1, 1))\n    3", "id": "Diberikan n pintu yang disusun dalam lingkaran, pemain mulai di depan pintu 1.  \nSetiap giliran, pemain dapat memilih angka i dan membayar biaya C_i untuk bergerak i langkah ke kanan  \ndan kemudian membuka pintu di posisi tersebut. Dijamin bahwa C_i >= C_{i+1} untuk 1 <= i < n.  \nTugasnya adalah menentukan total biaya minimum yang diperlukan untuk membuka semua pintu.\n\nContoh:\n    >>> f_36(3, (1, 1, 1))\n    3", "ja": "与えられた n 個のドアが円形に配置されており、プレイヤーはドア 1 の前に立っています。\n各ターンで、プレイヤーは数 i を選び、コスト C_i を支払って右に i ステップ移動し、その位置のドアを開けることができます。C_i >= C_{i+1} が 1 <= i < n の範囲で保証されています。\nすべてのドアを開けるために必要な最小の総コストを求めることが課題です。\n\n例:\n    >>> f_36(3, (1, 1, 1))\n    3", "ko": "n개의 문이 원형으로 배열되어 있을 때, 플레이어는 문 1 앞에서 시작합니다.  \n각 턴마다, 플레이어는 숫자 i를 선택하고 비용 C_i를 지불하여 오른쪽으로 i칸 이동한 후 그 위치에 있는 문을 엽니다.  \nC_i >= C_{i+1}가 1 <= i < n에 대해 보장됩니다.  \n모든 문을 여는 데 필요한 최소 총 비용을 결정하는 것이 과제입니다.\n\n예시:\n    >>> f_36(3, (1, 1, 1))\n    3", "ml": "n വാതിലുകൾ ഒരു വൃത്തത്തിൽ ക്രമീകരിച്ചിരിക്കുന്നതിനാൽ, കളിക്കാരൻ വാതിൽ 1-ന്റെ മുൻപിൽ നിന്ന് ആരംഭിക്കുന്നു. \nഓരോ തവണയും, കളിക്കാരൻ ഒരു സംഖ്യ i തിരഞ്ഞെടുക്കുകയും i ഘട്ടങ്ങൾ വലത്തേക്ക് നീങ്ങാൻ ഒരു ചെലവ് C_i നൽകുകയും \nആ സ്ഥിതിയിലെ വാതിൽ തുറക്കുകയും ചെയ്യാം. 1 <= i < n എന്നതിനായി C_i >= C_{i+1} എന്ന് ഉറപ്പാണ്. \nഎല്ലാ വാതിലുകളും തുറക്കാൻ ആവശ്യമായ കുറഞ്ഞ മൊത്തം ചെലവ് നിർണയിക്കുകയാണ് ഈ പ്രവൃത്തിയുടെ ലക്ഷ്യം.\n\nഉദാഹരണം:\n    >>> f_36(3, (1, 1, 1))\n    3", "fa": "با توجه به n در که به صورت دایره‌ای چیده شده‌اند، بازیکن در مقابل در شماره 1 شروع می‌کند.  \nدر هر نوبت، بازیکن می‌تواند یک عدد i را انتخاب کند و هزینه C_i را بپردازد تا i قدم به سمت راست حرکت کند  \nو سپس در را در آن موقعیت باز کند. تضمین شده است که C_i >= C_{i+1} برای 1 <= i < n.  \nوظیفه این است که حداقل هزینه کل مورد نیاز برای باز کردن همه درها را تعیین کنید.\n\nمثال:\n    >>> f_36(3, (1, 1, 1))\n    3"}}
{"task_id": "CPP/37", "prompt": {"en": "#include <cassert>\n#include <vector>\n/**\n * Computes the total number of handshakes in a classroom scenario given\n * the sequence of student IDs as they enter the classroom. It assumes\n * that students have IDs ranging from 0 to N-1 and that each student\n * will shake hands only with students already in the classroom with a\n * smaller ID.\n *\n * Examples:\n * >>> f_37(3, {2, 1, 0})\n * 0\n */\nlong long f_37(int n, const std::vector<int>& order)", "sq": "#include <cassert>\n#include <vector>\n/**\n * Llogarit numrin total të shtrëngimeve të duarve në një skenar klase duke pasur parasysh\n * sekuencën e ID-ve të studentëve ndërsa hyjnë në klasë. Supozohet\n * që studentët kanë ID që variojnë nga 0 deri në N-1 dhe që çdo student\n * do të shtrëngojë duart vetëm me studentët që tashmë janë në klasë me një\n * ID më të vogël.\n *\n * Shembuj:\n * >>> f_37(3, {2, 1, 0})\n * 0\n */\nlong long f_37(int n, const std::vector<int>& order)", "hy": "#include <cassert>\n#include <vector>\n/**\n * Հաշվում է ձեռքսեղմումների ընդհանուր քանակը դասարանում տրված\n * ուսանողների ID-ների հաջորդականությամբ, երբ նրանք մտնում են դասարան: Ենթադրվում է,\n * որ ուսանողները ունեն ID-ներ 0-ից մինչև N-1, և որ յուրաքանչյուր ուսանող\n * ձեռք կսեղմի միայն այն ուսանողների հետ, ովքեր արդեն դասարանում են ավելի փոքր ID-ով:\n *\n * Օրինակներ:\n * >>> f_37(3, {2, 1, 0})\n * 0\n */\nlong long f_37(int n, const std::vector<int>& order)", "bn": "#include <cassert>\n#include <vector>\n/**\n * একটি শ্রেণীকক্ষের পরিস্থিতিতে মোট কতগুলি হ্যান্ডশেক হয় তা গণনা করে\n * যখন ছাত্রদের আইডির ক্রম অনুযায়ী তারা শ্রেণীকক্ষে প্রবেশ করে। এটি ধরে নেয়\n * যে ছাত্রদের আইডি 0 থেকে N-1 পর্যন্ত এবং প্রতিটি ছাত্র\n * শুধুমাত্র তাদের চেয়ে ছোট আইডি সহ ইতিমধ্যে শ্রেণীকক্ষে থাকা ছাত্রদের সাথে হ্যান্ডশেক করবে।\n *\n * উদাহরণ:\n * >>> f_37(3, {2, 1, 0})\n * 0\n */\nlong long f_37(int n, const std::vector<int>& order)", "bg": "#include <cassert>\n#include <vector>\n/**\n * Изчислява общия брой ръкостискания в класна стая, като се даде\n * последователността от идентификатори на учениците, когато влизат в класната стая. Предполага се,\n * че учениците имат идентификатори в диапазона от 0 до N-1 и че всеки ученик\n * ще се ръкува само с ученици, които вече са в класната стая с\n * по-малък идентификатор.\n *\n * Примери:\n * >>> f_37(3, {2, 1, 0})\n * 0\n */\nlong long f_37(int n, const std::vector<int>& order)", "zh": "#include <cassert>\n#include <vector>\n/**\n * 计算在教室场景中给定学生进入教室的顺序时的握手总数。假设学生的ID范围是从0到N-1，并且每个学生只会与已经在教室中且ID较小的学生握手。\n *\n * 示例:\n * >>> f_37(3, {2, 1, 0})\n * 0\n */\nlong long f_37(int n, const std::vector<int>& order)", "fr": "#include <cassert>\n#include <vector>\n/**\n * Calcule le nombre total de poignées de main dans un scénario de salle de classe donné\n * la séquence des identifiants des étudiants à mesure qu'ils entrent dans la salle de classe. Il suppose\n * que les étudiants ont des identifiants allant de 0 à N-1 et que chaque étudiant\n * serrera la main uniquement avec les étudiants déjà dans la salle de classe avec un\n * identifiant plus petit.\n *\n * Exemples :\n * >>> f_37(3, {2, 1, 0})\n * 0\n */\nlong long f_37(int n, const std::vector<int>& order)", "de": "#include <cassert>\n#include <vector>\n/**\n * Berechnet die Gesamtanzahl der Händeschüttelvorgänge in einem Klassenzimmerszenario,\n * gegeben die Reihenfolge der Schüler-IDs, wie sie das Klassenzimmer betreten. Es wird\n * angenommen, dass die Schüler IDs im Bereich von 0 bis N-1 haben und dass jeder Schüler\n * nur mit Schülern Händeschütteln wird, die sich bereits mit einer kleineren ID im\n * Klassenzimmer befinden.\n *\n * Beispiele:\n * >>> f_37(3, {2, 1, 0})\n * 0\n */\nlong long f_37(int n, const std::vector<int>& order)", "ha": "#include <cassert>\n#include <vector>\n/**\n * Yana lissafin jimillar yawan musabaha a cikin yanayin aji da aka bayar\n * jerin lambobin dalibai yayin da suke shiga aji. Yana dauka\n * cewa dalibai suna da lambobi daga 0 zuwa N-1 kuma cewa kowane dalibi\n * zai yi musabaha ne kawai da daliban da suke cikin aji da\n * karamar lamba.\n *\n * Misalai:\n * >>> f_37(3, {2, 1, 0})\n * 0\n */\nlong long f_37(int n, const std::vector<int>& order)", "hi": "#include <cassert>\n#include <vector>\n/**\n * यह गणना करता है कि कक्षा परिदृश्य में कुल कितनी हाथ मिलाने की घटनाएँ होती हैं,\n * जब छात्रों के आईडी का क्रम दिया गया है जैसे वे कक्षा में प्रवेश करते हैं। यह मानता है\n * कि छात्रों के आईडी 0 से N-1 तक होते हैं और प्रत्येक छात्र केवल उन्हीं छात्रों से\n * हाथ मिलाएगा जो पहले से ही कक्षा में हैं और जिनका आईडी उससे छोटा है।\n *\n * उदाहरण:\n * >>> f_37(3, {2, 1, 0})\n * 0\n */\nlong long f_37(int n, const std::vector<int>& order)", "hu": "#include <cassert>\n#include <vector>\n/**\n * Kiszámítja a kézfogások teljes számát egy osztálytermi szituációban,\n * figyelembe véve a diákok azonosítóinak sorrendjét, ahogy belépnek az\n * osztályterembe. Feltételezi, hogy a diákok azonosítói 0-tól N-1-ig\n * terjednek, és hogy minden diák csak azokkal a diákokkal fog kezet,\n * akik már az osztályteremben vannak és kisebb azonosítóval rendelkeznek.\n *\n * Példák:\n * >>> f_37(3, {2, 1, 0})\n * 0\n */\nlong long f_37(int n, const std::vector<int>& order)", "es": "#include <cassert>\n#include <vector>\n/**\n * Calcula el número total de apretones de manos en un escenario de aula dado\n * la secuencia de IDs de estudiantes a medida que ingresan al aula. Se asume\n * que los estudiantes tienen IDs que van de 0 a N-1 y que cada estudiante\n * solo dará la mano a estudiantes que ya están en el aula con un\n * ID más pequeño.\n *\n * Ejemplos:\n * >>> f_37(3, {2, 1, 0})\n * 0\n */\nlong long f_37(int n, const std::vector<int>& order)", "arb": "#include <cassert>\n#include <vector>\n/**\n * يحسب العدد الإجمالي للمصافحات في سيناريو الفصل الدراسي المعطى\n * تسلسل معرفات الطلاب عند دخولهم الفصل. يفترض\n * أن الطلاب لديهم معرفات تتراوح من 0 إلى N-1 وأن كل طالب\n * سيصافح فقط الطلاب الموجودين بالفعل في الفصل مع\n * معرف أصغر.\n *\n * أمثلة:\n * >>> f_37(3, {2, 1, 0})\n * 0\n */\nlong long f_37(int n, const std::vector<int>& order)", "sw": "#include <cassert>\n#include <vector>\n/**\n * Inahesabu jumla ya mikono iliyoshikwa katika hali ya darasani kutokana na\n * mfuatano wa vitambulisho vya wanafunzi wanapoingia darasani. Inadhani\n * kwamba wanafunzi wana vitambulisho vinavyoanzia 0 hadi N-1 na kwamba kila\n * mwanafunzi atashikana mikono tu na wanafunzi ambao tayari wako darasani\n * wenye kitambulisho kidogo.\n *\n * Mifano:\n * >>> f_37(3, {2, 1, 0})\n * 0\n */\nlong long f_37(int n, const std::vector<int>& order)", "tr": "#include <cassert>\n#include <vector>\n/**\n * Bir sınıf senaryosunda, öğrencilerin sınıfa giriş sırasına göre toplam\n * tokalaşma sayısını hesaplar. Öğrencilerin kimliklerinin 0'dan N-1'e kadar\n * olduğunu ve her öğrencinin yalnızca sınıfta zaten bulunan ve daha küçük\n * kimlikli öğrencilerle tokalaşacağını varsayar.\n *\n * Örnekler:\n * >>> f_37(3, {2, 1, 0})\n * 0\n */\nlong long f_37(int n, const std::vector<int>& order)", "vi": "#include <cassert>\n#include <vector>\n/**\n * Tính tổng số lần bắt tay trong một tình huống lớp học cho trước\n * dãy số ID của học sinh khi họ vào lớp. Giả định rằng\n * học sinh có ID từ 0 đến N-1 và mỗi học sinh\n * sẽ chỉ bắt tay với những học sinh đã có mặt trong lớp với\n * ID nhỏ hơn.\n *\n * Ví dụ:\n * >>> f_37(3, {2, 1, 0})\n * 0\n */\nlong long f_37(int n, const std::vector<int>& order)", "id": "#include <cassert>\n#include <vector>\n/**\n * Menghitung total jumlah jabat tangan dalam skenario kelas yang diberikan\n * urutan ID siswa saat mereka memasuki kelas. Diasumsikan\n * bahwa siswa memiliki ID berkisar dari 0 hingga N-1 dan bahwa setiap siswa\n * hanya akan berjabat tangan dengan siswa yang sudah ada di kelas dengan\n * ID yang lebih kecil.\n *\n * Contoh:\n * >>> f_37(3, {2, 1, 0})\n * 0\n */\nlong long f_37(int n, const std::vector<int>& order)", "ja": "#include <cassert>\n#include <vector>\n/**\n * 教室のシナリオで、生徒が教室に入る順番が与えられたときの握手の総数を計算します。\n * 生徒はIDが0からN-1の範囲であると仮定し、各生徒は自分より小さいIDを持つ\n * すでに教室にいる生徒とだけ握手をするものとします。\n *\n * 例:\n * >>> f_37(3, {2, 1, 0})\n * 0\n */\nlong long f_37(int n, const std::vector<int>& order)", "ko": "#include <cassert>\n#include <vector>\n/**\n * 학생들이 교실에 들어오는 순서가 주어졌을 때, 교실 시나리오에서 총 악수의 수를 계산합니다.\n * 학생들은 0부터 N-1까지의 ID를 가지고 있으며, 각 학생은 이미 교실에 있는 자신보다 작은 ID를 가진 학생들과만 악수한다고 가정합니다.\n *\n * 예시:\n * >>> f_37(3, {2, 1, 0})\n * 0\n */\nlong long f_37(int n, const std::vector<int>& order)", "ml": "#include <cassert>\n#include <vector>\n/**\n * ഒരു ക്ലാസ്‌റൂം സാഹചര്യത്തിൽ വിദ്യാർത്ഥികളുടെ ഐഡി ക്രമത്തിൽ ക്ലാസ്‌റൂമിൽ പ്രവേശിക്കുന്നതിനനുസരിച്ച്\n * കൈകോർക്കലുകളുടെ മൊത്തം എണ്ണം കണക്കാക്കുന്നു. വിദ്യാർത്ഥികൾക്ക് 0 മുതൽ N-1 വരെ ഐഡികൾ\n * ഉണ്ടെന്ന് കരുതുന്നു, കൂടാതെ ഓരോ വിദ്യാർത്ഥിയും ചെറിയ ഐഡി ഉള്ള ക്ലാസ്‌റൂമിൽ ഇതിനകം\n * ഉള്ള വിദ്യാർത്ഥികളുമായി മാത്രം കൈകുലുക്കും.\n *\n * ഉദാഹരണങ്ങൾ:\n * >>> f_37(3, {2, 1, 0})\n * 0\n */\nlong long f_37(int n, const std::vector<int>& order)", "fa": "#include <cassert>\n#include <vector>\n/**\n * تعداد کل دست دادن‌ها را در یک سناریوی کلاس درس محاسبه می‌کند با توجه به\n * دنباله‌ای از شناسه‌های دانش‌آموزان به عنوان ورود آنها به کلاس. فرض بر این است\n * که شناسه‌های دانش‌آموزان از 0 تا N-1 هستند و هر دانش‌آموز تنها با دانش‌آموزانی\n * که قبلاً با شناسه کوچکتر در کلاس حضور دارند دست می‌دهد.\n *\n * مثال‌ها:\n * >>> f_37(3, {2, 1, 0})\n * 0\n */\nlong long f_37(int n, const std::vector<int>& order)"}, "canonical_solution": "{\n    long long ans = 0;\n    std::vector<int> tr(n + 1, 0);\n    \n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n\n    return ans;\n}", "instruction": {"en": "long long f_37(int n, const std::vector<int>& order)\n{\n    long long ans = 0;\n    std::vector<int> tr(n + 1, 0);\n    \n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n\n    return ans;\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.", "sq": "long long f_37(int n, const std::vector<int>& order)\n{\n    long long ans = 0;\n    std::vector<int> tr(n + 1, 0);\n    \n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n\n    return ans;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit CPP në shqip duke përdorur maksimumi 500 karaktere.", "hy": "long long f_37(int n, const std::vector<int>& order)\n{\n    long long ans = 0;\n    std::vector<int> tr(n + 1, 0);\n    \n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n\n    return ans;\n}\n\nՏվեք CPP կոդի համառոտ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "long long f_37(int n, const std::vector<int>& order)\n{\n    long long ans = 0;\n    std::vector<int> tr(n + 1, 0);\n    \n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n\n    return ans;\n}\n\nসিপিপি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।", "bg": "long long f_37(int n, const std::vector<int>& order)\n{\n    long long ans = 0;\n    std::vector<int> tr(n + 1, 0);\n    \n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n\n    return ans;\n}\n\nПредоставете кратко описание на CPP кода на български език, използвайки не повече от 500 знака.", "zh": "long long f_37(int n, const std::vector<int>& order)\n{\n    long long ans = 0;\n    std::vector<int> tr(n + 1, 0);\n    \n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n\n    return ans;\n}\n\n请用最多500个字符的中文对该CPP代码提供简洁的自然语言描述（文档字符串）。", "fr": "long long f_37(int n, const std::vector<int>& order)\n{\n    long long ans = 0;\n    std::vector<int> tr(n + 1, 0);\n    \n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n\n    return ans;\n}\n\nFournissez une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.", "de": "long long f_37(int n, const std::vector<int>& order)\n{\n    long long ans = 0;\n    std::vector<int> tr(n + 1, 0);\n    \n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n\n    return ans;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "long long f_37(int n, const std::vector<int>& order)\n{\n    long long ans = 0;\n    std::vector<int> tr(n + 1, 0);\n    \n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n\n    return ans;\n}\n\nBa da takaitaccen bayanin yanayi na lamba (docstring) na lambar CPP a cikin Hausa ta amfani da haruffa 500 kacal.", "hi": "long long f_37(int n, const std::vector<int>& order)\n{\n    long long ans = 0;\n    std::vector<int> tr(n + 1, 0);\n    \n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n\n    return ans;\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "long long f_37(int n, const std::vector<int>& order)\n{\n    long long ans = 0;\n    std::vector<int> tr(n + 1, 0);\n    \n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n\n    return ans;\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a CPP kódhoz magyarul, legfeljebb 500 karakterben.", "es": "long long f_37(int n, const std::vector<int>& order)\n{\n    long long ans = 0;\n    std::vector<int> tr(n + 1, 0);\n    \n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n\n    return ans;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando como máximo 500 caracteres.", "arb": "long long f_37(int n, const std::vector<int>& order)\n{\n    long long ans = 0;\n    std::vector<int> tr(n + 1, 0);\n    \n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n\n    return ans;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C++ باللغة العربية الفصحى، على ألا يتجاوز 500 حرف.", "sw": "long long f_37(int n, const std::vector<int>& order)\n{\n    long long ans = 0;\n    std::vector<int> tr(n + 1, 0);\n    \n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n\n    return ans;\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "long long f_37(int n, const std::vector<int>& order)\n{\n    long long ans = 0;\n    std::vector<int> tr(n + 1, 0);\n    \n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n\n    return ans;\n}\n\nAşağıdaki CPP kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, Türkçe olarak ve en fazla 500 karakter kullanılarak yazılmalıdır.", "vi": "long long f_37(int n, const std::vector<int>& order)\n{\n    long long ans = 0;\n    std::vector<int> tr(n + 1, 0);\n    \n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n\n    return ans;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự.", "id": "long long f_37(int n, const std::vector<int>& order)\n{\n    long long ans = 0;\n    std::vector<int> tr(n + 1, 0);\n    \n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n\n    return ans;\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode CPP dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "long long f_37(int n, const std::vector<int>& order)\n{\n    long long ans = 0;\n    std::vector<int> tr(n + 1, 0);\n    \n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n\n    return ans;\n}\n\n以下のCPPコードの簡潔な自然言語による説明（ドックストリング）を日本語で500文字以内で提供してください。", "ko": "long long f_37(int n, const std::vector<int>& order)\n{\n    long long ans = 0;\n    std::vector<int> tr(n + 1, 0);\n    \n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n\n    return ans;\n}\n\n다음 CPP 코드의 동작을 설명하는 간결한 자연어 설명(도크스트링)을 한국어로 작성하세요. 최대 500자 이내로 작성해 주세요.", "ml": "long long f_37(int n, const std::vector<int>& order)\n{\n    long long ans = 0;\n    std::vector<int> tr(n + 1, 0);\n    \n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n\n    return ans;\n}\n\nCPP കോഡ് ഉപയോഗിച്ച് 500 അക്ഷരങ്ങളിൽ കവിയാതെയുള്ള ഒരു സംക്ഷിപ്ത സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) മലയാളത്തിൽ നൽകുക.", "fa": "long long f_37(int n, const std::vector<int>& order)\n{\n    long long ans = 0;\n    std::vector<int> tr(n + 1, 0);\n    \n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n\n    return ans;\n}\n\nیک توضیح مختصر به زبان طبیعی (docstring) از کد CPP به زبان فارسی ارائه دهید که حداکثر ۵۰۰ کاراکتر باشد."}, "level": "", "test": "int main() {\n    assert(f_37(4, {2, 1, 3, 0}) == 2);\n    assert(f_37(6, {0, 1, 2, 3, 4, 5}) == 15);\n    assert(f_37(3, {1, 2, 0}) == 1);\n    assert(f_37(4, {3, 2, 1, 0}) == 0);\n    assert(f_37(4, {0, 1, 2, 3}) == 6);\n    assert(f_37(6, {5, 4, 3, 2, 1, 0}) == 0);\n    assert(f_37(4, {0, 2, 1, 3}) == 5);\n    assert(f_37(5, {3, 1, 4, 2, 0}) == 3);\n    assert(f_37(4, {1, 0, 3, 2}) == 4);\n    assert(f_37(3, {2, 0, 1}) == 1);\n    assert(f_37(5, {1, 3, 0, 2, 4}) == 7);\n    assert(f_37(5, {4, 3, 2, 1, 0}) == 0);\n\n    return 0;\n}", "entry_point": "f_37", "signature": "long long f_37(int n, const std::vector<int>& order)", "docstring": {"en": "Computes the total number of handshakes in a classroom scenario given the sequence of student IDs as they enter the classroom. It assumes that students have IDs ranging from 0 to N-1 and that each student will shake hands only with students already in the classroom with a smaller ID.\n\nExamples:\n>>> f_37(3, {2, 1, 0})\n0\n", "sq": "Llogarit numrin total të shtrëngimeve të duarve në një skenar klase duke pasur parasysh rendin e ID-ve të studentëve ndërsa hyjnë në klasë. Supozohet se studentët kanë ID që variojnë nga 0 deri në N-1 dhe se çdo student do të shtrëngojë duart vetëm me studentët që janë tashmë në klasë me një ID më të vogël.\n\nShembuj:\n>>> f_37(3, {2, 1, 0})\n0", "hy": "Հաշվում է ընդհանուր ձեռքսեղմումների թիվը դասարանում, երբ տրվում է ուսանողների ID-ների հաջորդականությունը, երբ նրանք մտնում են դասարան։ Ենթադրվում է, որ ուսանողները ունեն ID-ներ 0-ից մինչև N-1 և որ յուրաքանչյուր ուսանող ձեռք կսեղմի միայն այն ուսանողների հետ, որոնք արդեն դասարանում են և ունեն ավելի փոքր ID։\n\nՕրինակներ:\n>>> f_37(3, {2, 1, 0})\n0", "bn": "ক্লাসরুমের দৃশ্যে শিক্ষার্থীদের আইডির ক্রম অনুযায়ী ক্লাসরুমে প্রবেশ করার সময় মোট কতগুলি হ্যান্ডশেক হয় তা গণনা করে। এটি ধরে নেয় যে শিক্ষার্থীদের আইডি 0 থেকে N-1 পর্যন্ত এবং প্রতিটি শিক্ষার্থী কেবলমাত্র তাদের চেয়ে ছোট আইডি সহ ইতিমধ্যে ক্লাসরুমে থাকা শিক্ষার্থীদের সাথে হ্যান্ডশেক করবে।\n\nউদাহরণসমূহ:\n>>> f_37(3, {2, 1, 0})\n0", "bg": "Изчислява общия брой ръкостискания в класна стая, като се вземе предвид последователността на идентификаторите на учениците при влизането им в класната стая. Предполага се, че учениците имат идентификатори в диапазона от 0 до N-1 и че всеки ученик ще се ръкува само с ученици, които вече са в класната стая с по-малък идентификатор.\n\nПримери:\n>>> f_37(3, {2, 1, 0})\n0", "zh": "计算在一个教室场景中，根据学生进入教室的顺序，握手的总次数。假设学生的ID范围是从0到N-1，并且每个学生只会与已经在教室中且ID较小的学生握手。\n\n示例：\n>>> f_37(3, {2, 1, 0})\n0", "fr": "Calcule le nombre total de poignées de main dans un scénario de salle de classe donné la séquence des identifiants des étudiants lorsqu'ils entrent dans la salle de classe. Il suppose que les étudiants ont des identifiants allant de 0 à N-1 et que chaque étudiant serrera la main uniquement avec les étudiants déjà présents dans la salle de classe avec un identifiant plus petit.\n\nExemples :\n>>> f_37(3, {2, 1, 0})\n0", "de": "Berechnet die Gesamtanzahl der Händedrucke in einem Klassenzimmer-Szenario, gegeben die Sequenz der Schüler-IDs, während sie das Klassenzimmer betreten. Es wird angenommen, dass die Schüler IDs im Bereich von 0 bis N-1 haben und dass jeder Schüler nur mit Schülern Händeschütteln wird, die bereits im Klassenzimmer sind und eine kleinere ID haben.\n\nBeispiele:\n>>> f_37(3, {2, 1, 0})\n0", "ha": "Yana ƙididdige jimillar yawan gaisuwar hannu a cikin yanayin aji la'akari da jerin lambobin dalibai yayin da suke shiga aji. Yana ɗauka cewa dalibai suna da lambobi daga 0 zuwa N-1 kuma cewa kowane dalibi zai gaisa da hannu kawai da daliban da suka riga sun shiga aji da ƙaramin lamba.\n\nMisalai:\n>>> f_37(3, {2, 1, 0})\n0", "hi": "कक्षा परिदृश्य में हाथ मिलाने की कुल संख्या की गणना करता है, जब छात्रों की आईडी का अनुक्रम दिया जाता है जैसे वे कक्षा में प्रवेश करते हैं। यह मानता है कि छात्रों की आईडी 0 से N-1 तक होती हैं और प्रत्येक छात्र केवल उन छात्रों से हाथ मिलाएगा जो पहले से ही कक्षा में छोटे आईडी के साथ हैं।\n\nउदाहरण:\n>>> f_37(3, {2, 1, 0})\n0", "hu": "Számítja az összes kézfogás számát egy osztálytermi szituációban, adott a diákok azonosítóinak sorrendje, ahogy belépnek az osztályterembe. Feltételezi, hogy a diákok azonosítói 0-tól N-1-ig terjednek, és hogy minden diák csak azokkal a diákokkal fog kezet, akik már az osztályteremben vannak, és kisebb azonosítóval rendelkeznek.\n\nPéldák:\n>>> f_37(3, {2, 1, 0})\n0", "es": "Calcula el número total de apretones de manos en un escenario de aula dado la secuencia de identificaciones de estudiantes a medida que ingresan al aula. Se asume que los estudiantes tienen identificaciones que van de 0 a N-1 y que cada estudiante solo estrechará la mano con estudiantes que ya están en el aula con una identificación menor.\n\nEjemplos:\n>>> f_37(3, {2, 1, 0})\n0", "arb": "يحسب العدد الإجمالي للمصافحات في سيناريو الفصل الدراسي بالنظر إلى تسلسل معرفات الطلاب عند دخولهم الفصل. يفترض أن الطلاب لديهم معرفات تتراوح من 0 إلى N-1 وأن كل طالب سيصافح فقط الطلاب الموجودين بالفعل في الفصل بمعرف أصغر.\n\nأمثلة:\n>>> f_37(3, {2, 1, 0})\n0", "sw": "Hesabu jumla ya mikono iliyoshikana katika hali ya darasani ukizingatia mlolongo wa vitambulisho vya wanafunzi wanapoingia darasani. Inadhani kwamba wanafunzi wana vitambulisho vinavyotoka 0 hadi N-1 na kwamba kila mwanafunzi atashikana mikono tu na wanafunzi ambao tayari wapo darasani wenye kitambulisho kidogo.\n\nMifano:\n>>> f_37(3, {2, 1, 0})\n0\n", "tr": "Sınıfa giren öğrenci kimlik numaralarının sırasına göre bir sınıf senaryosunda toplam el sıkışma sayısını hesaplar. Öğrencilerin kimlik numaralarının 0'dan N-1'e kadar olduğu ve her öğrencinin yalnızca sınıfta zaten bulunan ve daha küçük kimlik numarasına sahip öğrencilerle el sıkışacağı varsayılır.\n\nÖrnekler:\n>>> f_37(3, {2, 1, 0})\n0", "vi": "Tính tổng số lần bắt tay trong một kịch bản lớp học dựa trên trình tự các ID sinh viên khi họ vào lớp. Giả sử rằng các sinh viên có ID từ 0 đến N-1 và mỗi sinh viên chỉ bắt tay với những sinh viên đã có mặt trong lớp với ID nhỏ hơn.\n\nVí dụ:\n>>> f_37(3, {2, 1, 0})\n0", "id": "Menghitung jumlah total jabat tangan dalam skenario kelas yang diberikan urutan ID siswa saat mereka memasuki kelas. Diasumsikan bahwa siswa memiliki ID berkisar dari 0 hingga N-1 dan bahwa setiap siswa hanya akan berjabat tangan dengan siswa yang sudah ada di kelas dengan ID lebih kecil.\n\nContoh:\n>>> f_37(3, {2, 1, 0})\n0", "ja": "教室のシナリオで学生IDの順序が与えられたときの握手の総数を計算します。学生はIDが0からN-1までの範囲であり、各学生は教室にすでにいる自分より小さいIDの学生とだけ握手をするものと仮定します。\n\n例:\n>>> f_37(3, {2, 1, 0})\n0", "ko": "교실 시나리오에서 학생 ID의 순서가 주어졌을 때 총 악수 횟수를 계산합니다. 학생들은 ID가 0부터 N-1까지 있다고 가정하며, 각 학생은 교실에 이미 있는 자신보다 작은 ID를 가진 학생들과만 악수를 합니다.\n\n예시:\n>>> f_37(3, {2, 1, 0})\n0", "ml": "ക്ലാസ്സ്‌റൂം സിനാരിയോയിൽ വിദ്യാർത്ഥികളുടെ ഐഡി ക്രമത്തിൽ ക്ലാസ്സ്‌റൂമിലേക്ക് പ്രവേശിക്കുമ്പോൾ ആകെ കൈകൊടുക്കലുകളുടെ എണ്ണം കണക്കാക്കുന്നു. വിദ്യാർത്ഥികൾക്ക് 0 മുതൽ N-1 വരെയുള്ള ഐഡികൾ ഉണ്ടെന്ന്, കൂടാതെ ഓരോ വിദ്യാർത്ഥിയും ക്ലാസ്സ്‌റൂമിൽ ഇതിനകം ചെറിയ ഐഡി ഉള്ള വിദ്യാർത്ഥികളുമായി മാത്രമേ കൈകൊടുക്കൂ എന്ന് കരുതുന്നു.\n\nഉദാഹരണങ്ങൾ:\n>>> f_37(3, {2, 1, 0})\n0", "fa": "محاسبه تعداد کل دست دادن‌ها در یک سناریوی کلاس درس با توجه به توالی شناسه‌های دانش‌آموزان هنگام ورود به کلاس. فرض بر این است که دانش‌آموزان دارای شناسه‌هایی از 0 تا N-1 هستند و هر دانش‌آموز فقط با دانش‌آموزانی که قبلاً وارد کلاس شده‌اند و شناسه کمتری دارند، دست می‌دهد.\n\nمثال‌ها:\n>>> f_37(3, {2, 1, 0})\n0"}}
{"task_id": "CPP/38", "prompt": {"en": "#include <cassert>\n#include <cstdio>\n/**\n * Given n positive integers representing the count of each number from 1 to n,\n * find the maximum sum of the mode (most frequent element) for all prefixes of\n * a sequence constructed from these numbers. The mode is the largest number among\n * the most frequent elements in a sequence.\n * \n * Example:\n * >>> f_38(3, {1, 2, 3})\n * 17\n * A sequence that reaches its maximum value is (3,2,3,1,2,2).\n */\nlong long f_38(int n, const int* counts)", "sq": "#include <cassert>\n#include <cstdio>\n/**\n * Duke pasur n numra pozitivë që përfaqësojnë numrin e secilit numër nga 1 deri në n,\n * gjeni shumën maksimale të modës (elementi më i shpeshtë) për të gjitha prefikset e\n * një sekuence të ndërtuar nga këta numra. Moda është numri më i madh ndër elementët më të shpeshtë\n * në një sekuencë.\n * \n * Shembull:\n * >>> f_38(3, {1, 2, 3})\n * 17\n * Një sekuencë që arrin vlerën e saj maksimale është (3,2,3,1,2,2).\n */\nlong long f_38(int n, const int* counts)", "hy": "#include <cassert>\n#include <cstdio>\n/**\n * Տրված են n դրական ամբողջ թվեր, որոնք ներկայացնում են 1-ից n թվերի քանակը,\n * գտնել մոդի (ամենահաճախ հանդիպող տարր) առավելագույն գումարը բոլոր նախածանցների համար\n * այս թվերից կազմված հաջորդականության։ Մոդը հաջորդականության ամենահաճախ հանդիպող տարրերի\n * մեջ ամենամեծ թիվն է։\n * \n * Օրինակ:\n * >>> f_38(3, {1, 2, 3})\n * 17\n * Հաջորդականություն, որը հասնում է իր առավելագույն արժեքին, դա (3,2,3,1,2,2) է։\n */\nlong long f_38(int n, const int* counts)", "bn": "#include <cassert>\n#include <cstdio>\n/**\n * n টি ধনাত্মক পূর্ণসংখ্যা দেওয়া আছে যা ১ থেকে n পর্যন্ত প্রতিটি সংখ্যার গণনা উপস্থাপন করে,\n * একটি ক্রম থেকে সমস্ত উপসর্গের জন্য মোডের (সবচেয়ে ঘন ঘন উপাদান) সর্বাধিক যোগফল খুঁজে বের করুন\n * এই সংখ্যাগুলি থেকে নির্মিত। মোড হল একটি ক্রমের সবচেয়ে ঘন ঘন উপাদানগুলির মধ্যে বৃহত্তম সংখ্যা।\n * \n * উদাহরণ:\n * >>> f_38(3, {1, 2, 3})\n * 17\n * একটি ক্রম যা তার সর্বাধিক মানে পৌঁছায় তা হল (3,2,3,1,2,2)।\n */\nlong long f_38(int n, const int* counts)", "bg": "#include <cassert>\n#include <cstdio>\n/**\n * Дадени са n положителни цели числа, представляващи броя на всяко число от 1 до n,\n * намерете максималната сума на режима (най-често срещания елемент) за всички префикси на\n * последователност, конструирана от тези числа. Режимът е най-голямото число сред\n * най-често срещаните елементи в последователност.\n * \n * Пример:\n * >>> f_38(3, {1, 2, 3})\n * 17\n * Последователност, която достига максималната си стойност, е (3,2,3,1,2,2).\n */\nlong long f_38(int n, const int* counts)", "zh": "#include <cassert>\n#include <cstdio>\n/**\n * 给定 n 个正整数，表示从 1 到 n 的每个数字的计数，\n * 找出从这些数字构造的序列的所有前缀的众数（最频繁元素）的最大和。\n * 众数是序列中最频繁元素中的最大数字。\n * \n * 示例：\n * >>> f_38(3, {1, 2, 3})\n * 17\n * 达到最大值的序列是 (3,2,3,1,2,2)。\n */\nlong long f_38(int n, const int* counts)", "fr": "#include <cassert>\n#include <cstdio>\n/**\n * Étant donné n entiers positifs représentant le nombre de chaque nombre de 1 à n,\n * trouver la somme maximale de la mode (élément le plus fréquent) pour tous les préfixes\n * d'une séquence construite à partir de ces nombres. La mode est le plus grand nombre parmi\n * les éléments les plus fréquents dans une séquence.\n * \n * Exemple :\n * >>> f_38(3, {1, 2, 3})\n * 17\n * Une séquence qui atteint sa valeur maximale est (3,2,3,1,2,2).\n */\nlong long f_38(int n, const int* counts)", "de": "#include <cassert>\n#include <cstdio>\n/**\n * Gegeben n positive ganze Zahlen, die die Anzahl jedes Zahl von 1 bis n darstellen,\n * finde die maximale Summe des Modus (häufigstes Element) für alle Präfixe einer\n * Sequenz, die aus diesen Zahlen konstruiert wurde. Der Modus ist die größte Zahl\n * unter den häufigsten Elementen in einer Sequenz.\n * \n * Beispiel:\n * >>> f_38(3, {1, 2, 3})\n * 17\n * Eine Sequenz, die ihren maximalen Wert erreicht, ist (3,2,3,1,2,2).\n */\nlong long f_38(int n, const int* counts)", "ha": "#include <cassert>\n#include <cstdio>\n/**\n * An ba n lambobi masu kyau waɗanda ke wakiltar adadin kowanne lamba daga 1 zuwa n,\n * nemo mafi girman jimlar yanayin (abu mafi yawan faruwa) don dukkan farkon\n * jerin da aka gina daga waɗannan lambobin. Yanayin shine mafi girman lamba daga cikin\n * abubuwan da suka fi yawa a cikin jerin.\n * \n * Misali:\n * >>> f_38(3, {1, 2, 3})\n * 17\n * Jerin da ya kai darajarsa mafi girma shine (3,2,3,1,2,2).\n */\nlong long f_38(int n, const int* counts)", "hi": "#include <cassert>\n#include <cstdio>\n/**\n * दिए गए n धनात्मक पूर्णांक जो 1 से n तक प्रत्येक संख्या की गिनती का प्रतिनिधित्व करते हैं,\n * उन सभी अनुक्रमों के उपसर्गों के लिए मोड (सबसे अधिक बार आने वाला तत्व) का अधिकतम योग खोजें\n * जो इन संख्याओं से निर्मित होते हैं। मोड अनुक्रम में सबसे अधिक बार आने वाले तत्वों में सबसे बड़ा संख्या है।\n * \n * उदाहरण:\n * >>> f_38(3, {1, 2, 3})\n * 17\n * एक अनुक्रम जो अपने अधिकतम मान तक पहुँचता है वह है (3,2,3,1,2,2)।\n */\nlong long f_38(int n, const int* counts)", "hu": "#include <cassert>\n#include <cstdio>\n/**\n * Adott n pozitív egész szám, amelyek az 1-től n-ig terjedő számok előfordulási számát jelölik,\n * keresse meg a módusz (leggyakrabban előforduló elem) maximális összegét az összes előtagra\n * egy ezen számokból felépített sorozat esetén. A módusz a legnagyobb szám a sorozat leggyakrabban\n * előforduló elemei között.\n * \n * Példa:\n * >>> f_38(3, {1, 2, 3})\n * 17\n * Egy sorozat, amely eléri a maximális értékét: (3,2,3,1,2,2).\n */\nlong long f_38(int n, const int* counts)", "es": "#include <cassert>\n#include <cstdio>\n/**\n * Dado n números enteros positivos que representan la cantidad de cada número de 1 a n,\n * encuentra la suma máxima del modo (elemento más frecuente) para todos los prefijos de\n * una secuencia construida a partir de estos números. El modo es el número más grande entre\n * los elementos más frecuentes en una secuencia.\n * \n * Ejemplo:\n * >>> f_38(3, {1, 2, 3})\n * 17\n * Una secuencia que alcanza su valor máximo es (3,2,3,1,2,2).\n */\nlong long f_38(int n, const int* counts)", "arb": "#include <cassert>\n#include <cstdio>\n/**\n * معطى n من الأعداد الصحيحة الموجبة التي تمثل عدد كل رقم من 1 إلى n،\n * ابحث عن الحد الأقصى لمجموع النمط (العنصر الأكثر تكرارًا) لجميع البادئات\n * لتسلسل مُنشأ من هذه الأرقام. النمط هو أكبر رقم بين\n * العناصر الأكثر تكرارًا في تسلسل.\n * \n * مثال:\n * >>> f_38(3, {1, 2, 3})\n * 17\n * تسلسل يصل إلى قيمته القصوى هو (3,2,3,1,2,2).\n */\nlong long f_38(int n, const int* counts)", "sw": "#include <cassert>\n#include <cstdio>\n/**\n * Ukipewa n nambari chanya zinazowakilisha idadi ya kila nambari kutoka 1 hadi n,\n * pata jumla ya juu zaidi ya hali (kipengele kinachojitokeza mara nyingi zaidi) kwa viambishi vyote vya\n * mlolongo uliojengwa kutoka kwa nambari hizi. Hali ni nambari kubwa zaidi kati ya\n * vipengele vinavyojitokeza mara nyingi zaidi katika mlolongo.\n * \n * Mfano:\n * >>> f_38(3, {1, 2, 3})\n * 17\n * Mlolongo unaofikia thamani yake ya juu zaidi ni (3,2,3,1,2,2).\n */\nlong long f_38(int n, const int* counts)", "tr": "#include <cassert>\n#include <cstdio>\n/**\n * 1'den n'e kadar olan her sayının sayısını temsil eden n pozitif tamsayı verildiğinde,\n * bu sayılardan oluşturulan bir dizinin tüm ön ekleri için modun (en sık görülen eleman) maksimum\n * toplamını bulun. Mod, bir dizideki en sık görülen elemanlar arasında en büyük sayıdır.\n * \n * Örnek:\n * >>> f_38(3, {1, 2, 3})\n * 17\n * Maksimum değerine ulaşan bir dizi (3,2,3,1,2,2) şeklindedir.\n */\nlong long f_38(int n, const int* counts)", "vi": "#include <cassert>\n#include <cstdio>\n/**\n * Cho n số nguyên dương đại diện cho số lượng của mỗi số từ 1 đến n,\n * tìm tổng lớn nhất của mode (phần tử xuất hiện nhiều nhất) cho tất cả các tiền tố của\n * một dãy được tạo từ các số này. Mode là số lớn nhất trong số\n * các phần tử xuất hiện nhiều nhất trong một dãy.\n * \n * Ví dụ:\n * >>> f_38(3, {1, 2, 3})\n * 17\n * Một dãy đạt giá trị lớn nhất là (3,2,3,1,2,2).\n */\nlong long f_38(int n, const int* counts)", "id": "#include <cassert>\n#include <cstdio>\n/**\n * Diberikan n bilangan bulat positif yang mewakili jumlah masing-masing angka dari 1 hingga n,\n * temukan jumlah maksimum dari modus (elemen yang paling sering muncul) untuk semua awalan dari\n * sebuah urutan yang dibentuk dari angka-angka ini. Modus adalah angka terbesar di antara\n * elemen-elemen yang paling sering muncul dalam sebuah urutan.\n * \n * Contoh:\n * >>> f_38(3, {1, 2, 3})\n * 17\n * Sebuah urutan yang mencapai nilai maksimumnya adalah (3,2,3,1,2,2).\n */\nlong long f_38(int n, const int* counts)", "ja": "#include <cassert>\n#include <cstdio>\n/**\n * n 個の正の整数が与えられ、それぞれが 1 から n までの数のカウントを表します。\n * これらの数から構成されるシーケンスのすべての接頭辞に対して、モード（最頻出要素）の最大合計を見つけます。\n * モードは、シーケンス内の最頻出要素の中で最も大きな数です。\n * \n * 例:\n * >>> f_38(3, {1, 2, 3})\n * 17\n * 最大値に達するシーケンスは (3,2,3,1,2,2) です。\n */\nlong long f_38(int n, const int* counts)", "ko": "#include <cassert>\n#include <cstdio>\n/**\n * n개의 양의 정수가 주어졌을 때, 1부터 n까지 각 숫자의 개수를 나타내며,\n * 이러한 숫자로 구성된 시퀀스의 모든 접두사의 최빈값(가장 빈번한 요소)의 최대 합을 찾습니다.\n * 최빈값은 시퀀스에서 가장 빈번한 요소 중 가장 큰 숫자입니다.\n * \n * 예시:\n * >>> f_38(3, {1, 2, 3})\n * 17\n * 최대값에 도달하는 시퀀스는 (3,2,3,1,2,2)입니다.\n */\nlong long f_38(int n, const int* counts)\n", "ml": "#include <cassert>\n#include <cstdio>\n/**\n * 1 മുതൽ n വരെ ഓരോ സംഖ്യയുടെ എണ്ണവും പ്രതിനിധീകരിക്കുന്ന n അനുകൂല സംഖ്യകൾ നൽകിയാൽ,\n * ഈ സംഖ്യകളിൽ നിന്ന് നിർമ്മിച്ച ഒരു ശ്രേണിയുടെ എല്ലാ മുൻഗാമികളുടെയും മോഡ് (ഏറ്റവും അധികം ആവർത്തിക്കുന്ന ഘടകം) എന്നതിന്റെ പരമാവധി തുക കണ്ടെത്തുക.\n * മോഡ് എന്നത് ഒരു ശ്രേണിയിലെ ഏറ്റവും അധികം ആവർത്തിക്കുന്ന ഘടകങ്ങളിൽ ഏറ്റവും വലിയ സംഖ്യയാണ്.\n * \n * ഉദാഹരണം:\n * >>> f_38(3, {1, 2, 3})\n * 17\n * പരമാവധി മൂല്യത്തിൽ എത്തുന്ന ഒരു ശ്രേണി (3,2,3,1,2,2) ആണ്.\n */\nlong long f_38(int n, const int* counts)", "fa": "#include <cassert>\n#include <cstdio>\n/**\n * با داشتن n عدد صحیح مثبت که نشان‌دهنده تعداد هر عدد از 1 تا n هستند،\n * حداکثر مجموع مد (عنصر پرتکرار) را برای تمام پیشوندهای\n * یک دنباله ساخته شده از این اعداد پیدا کنید. مد بزرگترین عدد در میان\n * عناصر پرتکرار در یک دنباله است.\n * \n * مثال:\n * >>> f_38(3, {1, 2, 3})\n * 17\n * دنباله‌ای که به حداکثر مقدار خود می‌رسد (3,2,3,1,2,2) است.\n */\nlong long f_38(int n, const int* counts)"}, "canonical_solution": "{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}", "instruction": {"en": "long long f_38(int n, const int* counts)\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.", "sq": "long long f_38(int n, const int* counts)\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit CPP në shqip duke përdorur maksimumi 500 karaktere.", "hy": "long long f_38(int n, const int* counts)\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}\n\nՏվեք CPP կոդի համառոտ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "long long f_38(int n, const int* counts)\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}\n\nসিপিপি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলা ভাষায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।", "bg": "long long f_38(int n, const int* counts)\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}\n\nПредоставете кратко описание на C++ кода на естествен език (docstring) на български, използвайки не повече от 500 символа.", "zh": "long long f_38(int n, const int* counts)\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}\n\n请用不超过500个字符的中文为以下CPP代码提供简洁的自然语言描述（文档字符串）。", "fr": "long long f_38(int n, const int* counts)\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}\n\nFournissez une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.", "de": "long long f_38(int n, const int* counts)\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen.", "ha": "long long f_38(int n, const int* counts)\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar CPP a cikin Hausa, ba tare da wucewa haruffa 500 ba.", "hi": "long long f_38(int n, const int* counts)\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।", "hu": "long long f_38(int n, const int* counts)\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a CPP kódról magyarul, legfeljebb 500 karakterben.", "es": "long long f_38(int n, const int* counts)\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando como máximo 500 caracteres.", "arb": "long long f_38(int n, const int* counts)\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C++ باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "long long f_38(int n, const int* counts)\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "long long f_38(int n, const int* counts)\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}\n\nAşağıdaki CPP kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda, özlü bir doğal dil açıklaması (docstring) sağlayın.", "vi": "long long f_38(int n, const int* counts)\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự.", "id": "long long f_38(int n, const int* counts)\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode CPP dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "long long f_38(int n, const int* counts)\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}\n\n以下のCPPコードの簡潔な自然言語による説明（ドックストリング）を日本語で500文字以内で提供してください。", "ko": "long long f_38(int n, const int* counts)\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}\n\n다음 CPP 코드에 대한 간결한 자연어 설명(독스트링)을 한국어로 최대 500자 이내로 제공하세요.", "ml": "long long f_38(int n, const int* counts)\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}\n\nCPP കോഡിന്റെ സംക്ഷിപ്തമായ സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) പരമാവധി 500 അക്ഷരങ്ങൾ ഉപയോഗിച്ച് മലയാളത്തിൽ നൽകുക.", "fa": "long long f_38(int n, const int* counts)\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}\n\nتوضیح مختصر و طبیعی (docstring) از کد CPP به زبان فارسی ارائه دهید که حداکثر ۵۰۰ کاراکتر باشد."}, "level": "", "test": "int main() {\n    int a1[] = {1, 3, 2};\n    int a2[] = {4, 1, 2, 3};\n    int a3[] = {1, 1};\n    int a4[] = {1, 2, 3, 4, 5};\n    int a5[] = {100000};\n    int a6[] = {5, 3, 2, 4, 1};\n    int a7[] = {100000, 100000, 100000};\n    int a8[] = {2, 2, 5};\n    int a9[] = {4, 4, 4, 4};\n    int a10[] = {1, 2, 3, 4, 5, 6};\n    int a11[] = {3, 1, 2};\n\n    assert(f_38(3, a1) == 17);\n    assert(f_38(4, a2) == 37);\n    assert(f_38(2, a3) == 4);\n    assert(f_38(5, a4) == 75);\n    assert(f_38(1, a5) == 100000);\n    assert(f_38(5, a6) == 62);\n    assert(f_38(3, a7) == 900000);\n    assert(f_38(3, a8) == 27);\n    assert(f_38(4, a9) == 64);\n    assert(f_38(6, a10) == 126);\n    assert(f_38(3, a11) == 16);\n    return 0;\n}", "entry_point": "f_38", "signature": "long long f_38(int n, const int* counts)", "docstring": {"en": "Given n positive integers representing the count of each number from 1 to n,\nfind the maximum sum of the mode (most frequent element) for all prefixes of\na sequence constructed from these numbers. The mode is the largest number among\nthe most frequent elements in a sequence.\n\nExample:\n>>> f_38(3, {1, 2, 3})\n17\nA sequence that reaches its maximum value is (3,2,3,1,2,2).\n", "sq": "Duke pasur n numra të plotë pozitivë që përfaqësojnë numrin e secilit numër nga 1 deri në n,\ngjeni shumën maksimale të modës (elementi më i shpeshtë) për të gjitha parashtesat e\nnjë sekuence të ndërtuar nga këta numra. Moda është numri më i madh ndër elementet më të shpeshta në një sekuencë.\n\nShembull:\n>>> f_38(3, {1, 2, 3})\n17\nNjë sekuencë që arrin vlerën e saj maksimale është (3,2,3,1,2,2).", "hy": "Տրված են n դրական ամբողջ թվեր, որոնք ներկայացնում են 1-ից n թվերի քանակը, գտնել մաքսիմալ գումարը մոդի (ամենահաճախ հանդիպող տարրը) բոլոր նախածանցների համար հաջորդականության, որը կազմված է այս թվերից: Մոդը ամենամեծ թիվն է ամենահաճախ հանդիպող տարրերի մեջ հաջորդականության մեջ:\n\nՕրինակ:\n>>> f_38(3, {1, 2, 3})\n17\nՀաջորդականություն, որը հասնում է իր մաքսիմալ արժեքին, (3,2,3,1,2,2)-ն է:", "bn": "প্রদত্ত n ধনাত্মক পূর্ণসংখ্যা যা 1 থেকে n পর্যন্ত প্রতিটি সংখ্যার গণনা উপস্থাপন করে, একটি ক্রমের সমস্ত উপসর্গের জন্য মোডের (সবচেয়ে ঘন ঘন উপাদান) সর্বাধিক যোগফল খুঁজে বের করুন। মোড হল একটি ক্রমের সবচেয়ে ঘন ঘন উপাদানগুলির মধ্যে বৃহত্তম সংখ্যা।\n\nউদাহরণ:\n>>> f_38(3, {1, 2, 3})\n17\nএকটি ক্রম যা তার সর্বাধিক মানে পৌঁছায় তা হল (3,2,3,1,2,2)।", "bg": "Дадени са n положителни цели числа, представляващи броя на всяко число от 1 до n, намерете максималната сума на модата (най-често срещания елемент) за всички префикси на последователност, изградена от тези числа. Модата е най-голямото число сред най-често срещаните елементи в последователност.\n\nПример:\n>>> f_38(3, {1, 2, 3})\n17\nПоследователност, която достига максималната си стойност, е (3,2,3,1,2,2).", "zh": "给定 n 个正整数，表示从 1 到 n 的每个数字的计数，找到从这些数字构造的序列的所有前缀的众数（最频繁元素）的最大和。众数是序列中最频繁元素中最大的数字。\n\n示例：\n>>> f_38(3, {1, 2, 3})\n17\n一个达到其最大值的序列是 (3,2,3,1,2,2)。", "fr": "Étant donné n entiers positifs représentant le compte de chaque nombre de 1 à n, trouvez la somme maximale du mode (élément le plus fréquent) pour tous les préfixes d'une séquence construite à partir de ces nombres. Le mode est le plus grand nombre parmi les éléments les plus fréquents dans une séquence.\n\nExemple :\n>>> f_38(3, {1, 2, 3})\n17\nUne séquence qui atteint sa valeur maximale est (3,2,3,1,2,2).", "de": "Gegeben n positive ganze Zahlen, die die Anzahl jedes Zahl von 1 bis n darstellen,\nfinden Sie die maximale Summe des Modus (häufigstes Element) für alle Präfixe einer\naus diesen Zahlen konstruierten Sequenz. Der Modus ist die größte Zahl unter den\nhäufigsten Elementen in einer Sequenz.\n\nBeispiel:\n>>> f_38(3, {1, 2, 3})\n17\nEine Sequenz, die ihren maximalen Wert erreicht, ist (3,2,3,1,2,2).", "ha": "An ba da n lambobi masu kyau da ke wakiltar adadin kowace lamba daga 1 zuwa n, nemo mafi girman jimillar yanayin (abun da aka fi samu) don dukkan abubuwan farko na jerin da aka gina daga wadannan lambobin. Yanayin shi ne mafi girman lamba a cikin abubuwan da aka fi samu a cikin jerin.\n\nMisali:\n>>> f_38(3, {1, 2, 3})\n17\nJerin da ya kai matsakaicinsa shine (3,2,3,1,2,2).", "hi": "दिए गए n धनात्मक पूर्णांक जो 1 से n तक प्रत्येक संख्या की गिनती का प्रतिनिधित्व करते हैं, उन सभी अनुक्रमों के उपसर्गों के लिए मोड (सबसे अधिक बार आने वाला तत्व) का अधिकतम योग खोजें जो इन संख्याओं से निर्मित होते हैं। मोड अनुक्रम में सबसे अधिक बार आने वाले तत्वों में सबसे बड़ा संख्या है।\n\nउदाहरण:\n>>> f_38(3, {1, 2, 3})\n17\nएक अनुक्रम जो अपने अधिकतम मान तक पहुँचता है वह है (3,2,3,1,2,2)।", "hu": "Adott n pozitív egész szám, amelyek az 1-től n-ig terjedő számok előfordulási számát jelölik, \ntaláld meg a módusz (leggyakrabban előforduló elem) maximális összegét az ezekből a számokból \nfelépített sorozat minden prefixére. A módusz a legnagyobb szám a sorozat leggyakrabban előforduló elemei között.\n\nPélda:\n>>> f_38(3, {1, 2, 3})\n17\nEgy sorozat, amely eléri a maximális értékét: (3,2,3,1,2,2).", "es": "Dado n enteros positivos que representan el conteo de cada número del 1 al n, encuentra la suma máxima de la moda (elemento más frecuente) para todos los prefijos de una secuencia construida a partir de estos números. La moda es el número más grande entre los elementos más frecuentes en una secuencia.\n\nEjemplo:\n>>> f_38(3, {1, 2, 3})\n17\nUna secuencia que alcanza su valor máximo es (3,2,3,1,2,2).", "arb": "معطى n من الأعداد الصحيحة الموجبة التي تمثل عدد كل رقم من 1 إلى n، \nابحث عن الحد الأقصى لمجموع النمط (العنصر الأكثر تكرارًا) لجميع البادئات \nلسلسلة تم إنشاؤها من هذه الأرقام. النمط هو أكبر عدد بين \nالعناصر الأكثر تكرارًا في سلسلة.\n\nمثال:\n>>> f_38(3, {1, 2, 3})\n17\nسلسلة تصل إلى قيمتها القصوى هي (3,2,3,1,2,2).", "sw": "Kutolewa n nambari chanya zinazowakilisha idadi ya kila nambari kutoka 1 hadi n, pata jumla ya juu zaidi ya hali (kipengele kinachojitokeza mara nyingi zaidi) kwa viambishi vyote vya mlolongo uliotengenezwa kutoka kwa nambari hizi. Hali ni nambari kubwa zaidi kati ya vipengele vinavyojitokeza mara nyingi zaidi katika mlolongo.\n\nMfano:\n>>> f_38(3, {1, 2, 3})\n17\nMlolongo unaofikia thamani yake ya juu zaidi ni (3,2,3,1,2,2).", "tr": "Verilen n pozitif tamsayı, 1'den n'e kadar olan her sayının sayısını temsil eder,\nbu sayılardan oluşturulan bir dizinin tüm önekleri için modun (en sık görülen eleman) maksimum toplamını bulun. Mod, bir dizideki en sık görülen elemanlar arasında en büyük sayıdır.\n\nÖrnek:\n>>> f_38(3, {1, 2, 3})\n17\nMaksimum değerine ulaşan bir dizi (3,2,3,1,2,2) şeklindedir.", "vi": "Cho n số nguyên dương đại diện cho số lượng của mỗi số từ 1 đến n, tìm tổng lớn nhất của mode (phần tử xuất hiện nhiều nhất) cho tất cả các tiền tố của một dãy được tạo từ các số này. Mode là số lớn nhất trong số các phần tử xuất hiện nhiều nhất trong một dãy.\n\nVí dụ:\n>>> f_38(3, {1, 2, 3})\n17\nMột dãy đạt giá trị tối đa là (3,2,3,1,2,2).", "id": "Diberikan n bilangan bulat positif yang mewakili jumlah masing-masing angka dari 1 hingga n, temukan jumlah maksimum dari modus (elemen yang paling sering muncul) untuk semua awalan dari sebuah urutan yang dibangun dari angka-angka ini. Modus adalah angka terbesar di antara elemen yang paling sering muncul dalam sebuah urutan.\n\nContoh:\n>>> f_38(3, {1, 2, 3})\n17\nSebuah urutan yang mencapai nilai maksimumnya adalah (3,2,3,1,2,2).", "ja": "n個の正の整数が1からnまでの各数のカウントを表しているとき、これらの数から構成されるシーケンスのすべての接頭辞に対して、モード（最も頻繁に出現する要素）の最大合計を見つけます。モードは、シーケンス内で最も頻繁に出現する要素の中で最大の数です。\n\n例:\n>>> f_38(3, {1, 2, 3})\n17\n最大値に達するシーケンスは (3,2,3,1,2,2) です。", "ko": "주어진 n개의 양의 정수는 1부터 n까지의 각 숫자의 개수를 나타내며, 이러한 숫자로 구성된 시퀀스의 모든 접두사에 대해 최빈값(가장 빈번한 요소)의 최대 합을 찾습니다. 최빈값은 시퀀스에서 가장 빈번한 요소 중에서 가장 큰 숫자입니다.\n\n예시:\n>>> f_38(3, {1, 2, 3})\n17\n최대값에 도달하는 시퀀스는 (3,2,3,1,2,2)입니다.", "ml": "നൽകിയ n പോസിറ്റീവ് പൂർണ്ണസംഖ്യകൾ ഓരോ സംഖ്യയുടെ എണ്ണവും 1 മുതൽ n വരെ പ്രതിനിധീകരിക്കുന്നു, ഈ സംഖ്യകളിൽ നിന്ന് നിർമ്മിച്ച ഒരു ശ്രേണിയുടെ എല്ലാ പ്രിഫിക്സുകൾക്കും മോഡ് (ഏറ്റവും അധികം ആവർത്തിക്കുന്ന ഘടകം) പരമാവധി തുക കണ്ടെത്തുക. ഒരു ശ്രേണിയിലെ ഏറ്റവും അധികം ആവർത്തിക്കുന്ന ഘടകങ്ങളിൽ ഏറ്റവും വലിയ സംഖ്യയാണ് മോഡ്.\n\nഉദാഹരണം:\n>>> f_38(3, {1, 2, 3})\n17\nഅതിന്റേതായ പരമാവധി മൂല്യത്തിലെത്തുന്ന ഒരു ശ്രേണി (3,2,3,1,2,2) ആണ്.", "fa": "با توجه به n عدد صحیح مثبت که نشان‌دهنده تعداد هر عدد از 1 تا n هستند، \nحداکثر مجموع مد (عنصر با بیشترین تکرار) برای تمامی پیشوندهای \nیک دنباله ساخته شده از این اعداد را پیدا کنید. مد بزرگترین عدد در میان \nعناصر با بیشترین تکرار در یک دنباله است.\n\nمثال:\n>>> f_38(3, {1, 2, 3})\n17\nیک دنباله که به حداکثر مقدار خود می‌رسد (3,2,3,1,2,2) است."}}
{"task_id": "CPP/39", "prompt": {"en": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Given an array A of integers, the task is to calculate the sum of the XOR of all subarrays.\n * A subarray is defined by a pair of indices (L, R) such that 1 <= L <= R <= n, where n is the size of the array.\n * The XOR sum of a subarray is the result of XORing all elements from L to R.\n * The final result is the sum of the XOR sums for all possible subarrays.\n *\n * Example cases:\n *     >>> f_39({1, 2, 3, 4, 5}, 5)\n *     39\n */\nlong long f_39(const std::vector<int>& A)", "sq": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Duke pasur një varg A të numrave të plotë, detyra është të llogaritet shuma e XOR-it të të gjitha nënvargjeve.\n * Një nënvarg është i përcaktuar nga një çift indeksesh (L, R) të tilla që 1 <= L <= R <= n, ku n është madhësia e vargut.\n * Shuma XOR e një nënvargu është rezultati i XOR-it të të gjitha elementeve nga L në R.\n * Rezultati përfundimtar është shuma e shumave XOR për të gjitha nënvargjet e mundshme.\n *\n * Shembuj rastesh:\n *     >>> f_39({1, 2, 3, 4, 5}, 5)\n *     39\n */\nlong long f_39(const std::vector<int>& A)", "hy": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Տրված է ամբողջ թվերի զանգված A, խնդիրն է հաշվարկել բոլոր ենթազանգվածների XOR գումարը։\n * Ենթազանգվածը սահմանվում է (L, R) ինդեքսների զույգով, այնպես որ 1 <= L <= R <= n, որտեղ n-ը զանգվածի չափն է։\n * Ենթազանգվածի XOR գումարը L-ից R բոլոր տարրերի XOR-ի արդյունքն է։\n * Վերջնական արդյունքը բոլոր հնարավոր ենթազանգվածների համար XOR գումարների գումարն է։\n *\n * Օրինակ դեպքեր:\n *     >>> f_39({1, 2, 3, 4, 5}, 5)\n *     39\n */\nlong long f_39(const std::vector<int>& A)", "bn": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * একটি পূর্ণসংখ্যার অ্যারে A দেওয়া হলে, কাজটি হল সমস্ত উপঅ্যারের XOR এর যোগফল গণনা করা।\n * একটি উপঅ্যারে একটি ইন্ডেক্সের জোড়া (L, R) দ্বারা সংজ্ঞায়িত করা হয় যেখানে 1 <= L <= R <= n, যেখানে n হল অ্যারের আকার।\n * একটি উপঅ্যারের XOR যোগফল হল L থেকে R পর্যন্ত সমস্ত উপাদানের XOR এর ফলাফল।\n * চূড়ান্ত ফলাফল হল সমস্ত সম্ভাব্য উপঅ্যারের জন্য XOR যোগফলগুলির যোগফল।\n *\n * উদাহরণ কেস:\n *     >>> f_39({1, 2, 3, 4, 5}, 5)\n *     39\n */\nlong long f_39(const std::vector<int>& A)", "bg": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Даден е масив A от цели числа, задачата е да се изчисли сумата на XOR на всички подмасиви.\n * Подмасив се определя от двойка индекси (L, R) така че 1 <= L <= R <= n, където n е размерът на масива.\n * XOR сумата на подмасив е резултатът от XOR на всички елементи от L до R.\n * Крайният резултат е сумата на XOR сумите за всички възможни подмасиви.\n *\n * Примерни случаи:\n *     >>> f_39({1, 2, 3, 4, 5}, 5)\n *     39\n */\nlong long f_39(const std::vector<int>& A)", "zh": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * 给定一个整数数组A，任务是计算所有子数组的异或和的总和。\n * 子数组由一对索引(L, R)定义，其中1 <= L <= R <= n，n是数组的大小。\n * 子数组的异或和是从L到R的所有元素的异或结果。\n * 最终结果是所有可能子数组的异或和的总和。\n *\n * 示例案例：\n *     >>> f_39({1, 2, 3, 4, 5}, 5)\n *     39\n */\nlong long f_39(const std::vector<int>& A)", "fr": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Étant donné un tableau A d'entiers, la tâche consiste à calculer la somme du XOR de tous les sous-tableaux.\n * Un sous-tableau est défini par une paire d'indices (L, R) telle que 1 <= L <= R <= n, où n est la taille du tableau.\n * La somme XOR d'un sous-tableau est le résultat du XOR de tous les éléments de L à R.\n * Le résultat final est la somme des sommes XOR pour tous les sous-tableaux possibles.\n *\n * Exemples de cas :\n *     >>> f_39({1, 2, 3, 4, 5}, 5)\n *     39\n */\nlong long f_39(const std::vector<int>& A)", "de": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Gegeben ein Array A von ganzen Zahlen, besteht die Aufgabe darin, die Summe des XOR aller Teilarrays zu berechnen.\n * Ein Teilarray wird durch ein Paar von Indizes (L, R) definiert, so dass 1 <= L <= R <= n, wobei n die Größe des Arrays ist.\n * Die XOR-Summe eines Teilarrays ist das Ergebnis des XORs aller Elemente von L bis R.\n * Das Endergebnis ist die Summe der XOR-Summen für alle möglichen Teilarrays.\n *\n * Beispiel-Fälle:\n *     >>> f_39({1, 2, 3, 4, 5}, 5)\n *     39\n */\nlong long f_39(const std::vector<int>& A)", "ha": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * An ba wani tsari A na lambobi, aikin shi ne a lissafa jumlar XOR na dukkan ƙananan tsaruka.\n * Ana ayyana ƙaramin tsari ta hanyar ma'aurata na alamomi (L, R) inda 1 <= L <= R <= n, inda n shine girman tsari.\n * Jumlar XOR na ƙaramin tsari shine sakamakon XORing dukkan abubuwa daga L zuwa R.\n * Sakamakon ƙarshe shine jumlar XOR sums don dukkan yiwuwar ƙananan tsaruka.\n *\n * Misalan lokuta:\n *     >>> f_39({1, 2, 3, 4, 5}, 5)\n *     39\n */\nlong long f_39(const std::vector<int>& A)", "hi": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * दिए गए पूर्णांकों की एक array A के लिए, कार्य सभी उप-श्रृंखलाओं के XOR के योग की गणना करना है।\n * एक उप-श्रृंखला को (L, R) सूचकांक की एक जोड़ी द्वारा परिभाषित किया जाता है, जहाँ 1 <= L <= R <= n, जहाँ n array का आकार है।\n * एक उप-श्रृंखला का XOR योग L से R तक के सभी तत्वों का XOR करने का परिणाम है।\n * अंतिम परिणाम सभी संभावित उप-श्रृंखलाओं के लिए XOR योगों का योग है।\n *\n * उदाहरण मामले:\n *     >>> f_39({1, 2, 3, 4, 5}, 5)\n *     39\n */\nlong long f_39(const std::vector<int>& A)", "hu": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Adott egy A egész számokat tartalmazó tömb, a feladat az, hogy kiszámoljuk az összes részhalmaz XOR összegét.\n * Egy részhalmazt egy (L, R) indexpár határoz meg, ahol 1 <= L <= R <= n, ahol n a tömb mérete.\n * Egy részhalmaz XOR összege az L-től R-ig terjedő összes elem XOR-olásának eredménye.\n * A végső eredmény az összes lehetséges részhalmaz XOR összegeinek összege.\n *\n * Példa esetek:\n *     >>> f_39({1, 2, 3, 4, 5}, 5)\n *     39\n */\nlong long f_39(const std::vector<int>& A)", "es": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Dado un array A de enteros, la tarea es calcular la suma del XOR de todos los subarrays.\n * Un subarray se define por un par de índices (L, R) tal que 1 <= L <= R <= n, donde n es el tamaño del array.\n * La suma XOR de un subarray es el resultado de aplicar XOR a todos los elementos desde L hasta R.\n * El resultado final es la suma de las sumas XOR para todos los subarrays posibles.\n *\n * Casos de ejemplo:\n *     >>> f_39({1, 2, 3, 4, 5}, 5)\n *     39\n */\nlong long f_39(const std::vector<int>& A)", "arb": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * بالنظر إلى مصفوفة A من الأعداد الصحيحة، المهمة هي حساب مجموع XOR لجميع المصفوفات الجزئية.\n * تُعرّف المصفوفة الجزئية بواسطة زوج من الفهارس (L, R) بحيث 1 <= L <= R <= n، حيث n هو حجم المصفوفة.\n * مجموع XOR لمصفوفة جزئية هو نتيجة XOR لجميع العناصر من L إلى R.\n * النتيجة النهائية هي مجموع مجموعات XOR لجميع المصفوفات الجزئية الممكنة.\n *\n * أمثلة الحالات:\n *     >>> f_39({1, 2, 3, 4, 5}, 5)\n *     39\n */\nlong long f_39(const std::vector<int>& A)", "sw": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Ukipewa safu A ya nambari za mzima, kazi ni kuhesabu jumla ya XOR ya vipengele vidogo vyote.\n * Kipengele kidogo kinafafanuliwa na jozi ya faharasa (L, R) ambapo 1 <= L <= R <= n, ambapo n ni ukubwa wa safu.\n * Jumla ya XOR ya kipengele kidogo ni matokeo ya XOR ya vipengele vyote kutoka L hadi R.\n * Matokeo ya mwisho ni jumla ya jumla za XOR kwa vipengele vidogo vyote vinavyowezekana.\n *\n * Mifano ya kesi:\n *     >>> f_39({1, 2, 3, 4, 5}, 5)\n *     39\n */\nlong long f_39(const std::vector<int>& A)", "tr": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Bir tamsayı dizisi A verildiğinde, görev tüm alt dizilerin XOR toplamını hesaplamaktır.\n * Bir alt dizi, 1 <= L <= R <= n olacak şekilde (L, R) indeks çifti ile tanımlanır, burada n dizinin boyutudur.\n * Bir alt dizinin XOR toplamı, L'den R'ye kadar olan tüm elemanların XOR'lanması sonucu elde edilir.\n * Nihai sonuç, tüm olası alt diziler için XOR toplamlarının toplamıdır.\n *\n * Örnek durumlar:\n *     >>> f_39({1, 2, 3, 4, 5}, 5)\n *     39\n */\nlong long f_39(const std::vector<int>& A)", "vi": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Cho một mảng A gồm các số nguyên, nhiệm vụ là tính tổng của XOR của tất cả các mảng con.\n * Một mảng con được định nghĩa bởi một cặp chỉ số (L, R) sao cho 1 <= L <= R <= n, trong đó n là kích thước của mảng.\n * Tổng XOR của một mảng con là kết quả của việc XOR tất cả các phần tử từ L đến R.\n * Kết quả cuối cùng là tổng của các tổng XOR cho tất cả các mảng con có thể.\n *\n * Các trường hợp ví dụ:\n *     >>> f_39({1, 2, 3, 4, 5}, 5)\n *     39\n */\nlong long f_39(const std::vector<int>& A)", "id": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Diberikan sebuah array A dari bilangan bulat, tugasnya adalah menghitung jumlah XOR dari semua subarray.\n * Sebuah subarray didefinisikan oleh sepasang indeks (L, R) sehingga 1 <= L <= R <= n, di mana n adalah ukuran array.\n * Jumlah XOR dari sebuah subarray adalah hasil dari XOR semua elemen dari L hingga R.\n * Hasil akhirnya adalah jumlah dari semua hasil XOR untuk semua subarray yang mungkin.\n *\n * Contoh kasus:\n *     >>> f_39({1, 2, 3, 4, 5}, 5)\n *     39\n */\nlong long f_39(const std::vector<int>& A)", "ja": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * 整数の配列 A が与えられたとき、すべての部分配列の XOR の合計を計算するタスクです。\n * 部分配列は、1 <= L <= R <= n であるインデックスのペア (L, R) によって定義されます。ここで、n は配列のサイズです。\n * 部分配列の XOR 合計は、L から R までのすべての要素を XOR した結果です。\n * 最終結果は、可能なすべての部分配列の XOR 合計の合計です。\n *\n * 例:\n *     >>> f_39({1, 2, 3, 4, 5}, 5)\n *     39\n */\nlong long f_39(const std::vector<int>& A)\n", "ko": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * 정수 배열 A가 주어졌을 때, 모든 부분 배열의 XOR 합을 계산하는 작업입니다.\n * 부분 배열은 인덱스 쌍 (L, R)에 의해 정의되며, 여기서 1 <= L <= R <= n이고, n은 배열의 크기입니다.\n * 부분 배열의 XOR 합은 L에서 R까지의 모든 요소를 XOR한 결과입니다.\n * 최종 결과는 가능한 모든 부분 배열의 XOR 합의 합입니다.\n *\n * 예제 경우:\n *     >>> f_39({1, 2, 3, 4, 5}, 5)\n *     39\n */\nlong long f_39(const std::vector<int>& A)\n", "ml": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * ഒരു പൂർണ്ണസംഖ്യകളുടെ നിരയായ A നൽകിയാൽ, എല്ലാ ഉപനിരകളുടെയും XOR യുടെ മൊത്തം കൂട്ടം കണക്കാക്കാനുള്ളതാണ് ഈ പ്രവർത്തി.\n * ഒരു ഉപനിര (subarray) 1 <= L <= R <= n എന്നിങ്ങനെയുള്ള സൂചികകളുടെ (indices) ഒരു ജോഡിയാൽ നിർവചിക്കപ്പെടുന്നു, ഇവിടെ n ആണ് നിരയുടെ വലിപ്പം.\n * ഒരു ഉപനിരയുടെ XOR കൂട്ടം L മുതൽ R വരെയുള്ള എല്ലാ മൂല്യങ്ങളും XOR ചെയ്തുള്ള ഫലമാണ്.\n * എല്ലാ സാധ്യതയുള്ള ഉപനിരകളുടെയും XOR കൂട്ടങ്ങളുടെ മൊത്തം കൂട്ടമാണ് അന്തിമ ഫലം.\n *\n * ഉദാഹരണ കേസുകൾ:\n *     >>> f_39({1, 2, 3, 4, 5}, 5)\n *     39\n */\nlong long f_39(const std::vector<int>& A)", "fa": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * با توجه به آرایه‌ای A از اعداد صحیح، وظیفه این است که مجموع XOR تمام زیرآرایه‌ها را محاسبه کنیم.\n * یک زیرآرایه با یک جفت اندیس (L, R) تعریف می‌شود به طوری که 1 <= L <= R <= n، که n اندازه آرایه است.\n * مجموع XOR یک زیرآرایه نتیجه‌ی XOR کردن تمام عناصر از L تا R است.\n * نتیجه نهایی مجموع مجموع‌های XOR برای تمام زیرآرایه‌های ممکن است.\n *\n * مثال‌ها:\n *     >>> f_39({1, 2, 3, 4, 5}, 5)\n *     39\n */\nlong long f_39(const std::vector<int>& A)\n"}, "canonical_solution": "{\n    int n = A.size();\n    std::vector<long long> q(n + 1, 0);\n    std::vector<std::vector<long long>> w(21, std::vector<long long>(2, 0));\n    long long ans = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        q[i] = q[i - 1] ^ A[i - 1];\n    }\n\n    for (int i = 0; i <= n; ++i) {\n        for (int j = 20; j >= 0; --j) {\n            w[j][(q[i] >> j) & 1]++;\n        }\n    }\n\n    for (int i = 0; i <= 20; ++i) {\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    }\n\n    return ans;\n}", "instruction": {"en": "long long f_39(const std::vector<int>& A)\n{\n    int n = A.size();\n    std::vector<long long> q(n + 1, 0);\n    std::vector<std::vector<long long>> w(21, std::vector<long long>(2, 0));\n    long long ans = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        q[i] = q[i - 1] ^ A[i - 1];\n    }\n\n    for (int i = 0; i <= n; ++i) {\n        for (int j = 20; j >= 0; --j) {\n            w[j][(q[i] >> j) & 1]++;\n        }\n    }\n\n    for (int i = 0; i <= 20; ++i) {\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    }\n\n    return ans;\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.", "sq": "long long f_39(const std::vector<int>& A)\n{\n    int n = A.size();\n    std::vector<long long> q(n + 1, 0);\n    std::vector<std::vector<long long>> w(21, std::vector<long long>(2, 0));\n    long long ans = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        q[i] = q[i - 1] ^ A[i - 1];\n    }\n\n    for (int i = 0; i <= n; ++i) {\n        for (int j = 20; j >= 0; --j) {\n            w[j][(q[i] >> j) & 1]++;\n        }\n    }\n\n    for (int i = 0; i <= 20; ++i) {\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    }\n\n    return ans;\n}\n\nSiguroni një përshkrim të shkurtër në gjuhën natyrore (docstring) të kodit CPP në shqip duke përdorur maksimumi 500 karaktere.", "hy": "long long f_39(const std::vector<int>& A)\n{\n    int n = A.size();\n    std::vector<long long> q(n + 1, 0);\n    std::vector<std::vector<long long>> w(21, std::vector<long long>(2, 0));\n    long long ans = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        q[i] = q[i - 1] ^ A[i - 1];\n    }\n\n    for (int i = 0; i <= n; ++i) {\n        for (int j = 20; j >= 0; --j) {\n            w[j][(q[i] >> j) & 1]++;\n        }\n    }\n\n    for (int i = 0; i <= 20; ++i) {\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    }\n\n    return ans;\n}\n\nՏվեք CPP կոդի կարճ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "long long f_39(const std::vector<int>& A)\n{\n    int n = A.size();\n    std::vector<long long> q(n + 1, 0);\n    std::vector<std::vector<long long>> w(21, std::vector<long long>(2, 0));\n    long long ans = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        q[i] = q[i - 1] ^ A[i - 1];\n    }\n\n    for (int i = 0; i <= n; ++i) {\n        for (int j = 20; j >= 0; --j) {\n            w[j][(q[i] >> j) & 1]++;\n        }\n    }\n\n    for (int i = 0; i <= 20; ++i) {\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    }\n\n    return ans;\n}\n\nসিপিপি কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।", "bg": "long long f_39(const std::vector<int>& A)\n{\n    int n = A.size();\n    std::vector<long long> q(n + 1, 0);\n    std::vector<std::vector<long long>> w(21, std::vector<long long>(2, 0));\n    long long ans = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        q[i] = q[i - 1] ^ A[i - 1];\n    }\n\n    for (int i = 0; i <= n; ++i) {\n        for (int j = 20; j >= 0; --j) {\n            w[j][(q[i] >> j) & 1]++;\n        }\n    }\n\n    for (int i = 0; i <= 20; ++i) {\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    }\n\n    return ans;\n}\n\nПредоставете кратко описание на CPP кода на естествен език (docstring) на български, използвайки най-много 500 знака.", "zh": "long long f_39(const std::vector<int>& A)\n{\n    int n = A.size();\n    std::vector<long long> q(n + 1, 0);\n    std::vector<std::vector<long long>> w(21, std::vector<long long>(2, 0));\n    long long ans = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        q[i] = q[i - 1] ^ A[i - 1];\n    }\n\n    for (int i = 0; i <= n; ++i) {\n        for (int j = 20; j >= 0; --j) {\n            w[j][(q[i] >> j) & 1]++;\n        }\n    }\n\n    for (int i = 0; i <= 20; ++i) {\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    }\n\n    return ans;\n}\n\n请用最多500个字符的中文对该CPP代码提供简洁的自然语言描述（文档字符串）。", "fr": "long long f_39(const std::vector<int>& A)\n{\n    int n = A.size();\n    std::vector<long long> q(n + 1, 0);\n    std::vector<std::vector<long long>> w(21, std::vector<long long>(2, 0));\n    long long ans = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        q[i] = q[i - 1] ^ A[i - 1];\n    }\n\n    for (int i = 0; i <= n; ++i) {\n        for (int j = 20; j >= 0; --j) {\n            w[j][(q[i] >> j) & 1]++;\n        }\n    }\n\n    for (int i = 0; i <= 20; ++i) {\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    }\n\n    return ans;\n}\n\nFournissez une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.", "de": "long long f_39(const std::vector<int>& A)\n{\n    int n = A.size();\n    std::vector<long long> q(n + 1, 0);\n    std::vector<std::vector<long long>> w(21, std::vector<long long>(2, 0));\n    long long ans = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        q[i] = q[i - 1] ^ A[i - 1];\n    }\n\n    for (int i = 0; i <= n; ++i) {\n        for (int j = 20; j >= 0; --j) {\n            w[j][(q[i] >> j) & 1]++;\n        }\n    }\n\n    for (int i = 0; i <= 20; ++i) {\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    }\n\n    return ans;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "long long f_39(const std::vector<int>& A)\n{\n    int n = A.size();\n    std::vector<long long> q(n + 1, 0);\n    std::vector<std::vector<long long>> w(21, std::vector<long long>(2, 0));\n    long long ans = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        q[i] = q[i - 1] ^ A[i - 1];\n    }\n\n    for (int i = 0; i <= n; ++i) {\n        for (int j = 20; j >= 0; --j) {\n            w[j][(q[i] >> j) & 1]++;\n        }\n    }\n\n    for (int i = 0; i <= 20; ++i) {\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    }\n\n    return ans;\n}\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar CPP a cikin Hausa ta amfani da haruffa 500 kacal.", "hi": "long long f_39(const std::vector<int>& A)\n{\n    int n = A.size();\n    std::vector<long long> q(n + 1, 0);\n    std::vector<std::vector<long long>> w(21, std::vector<long long>(2, 0));\n    long long ans = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        q[i] = q[i - 1] ^ A[i - 1];\n    }\n\n    for (int i = 0; i <= n; ++i) {\n        for (int j = 20; j >= 0; --j) {\n            w[j][(q[i] >> j) & 1]++;\n        }\n    }\n\n    for (int i = 0; i <= 20; ++i) {\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    }\n\n    return ans;\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।", "hu": "long long f_39(const std::vector<int>& A)\n{\n    int n = A.size();\n    std::vector<long long> q(n + 1, 0);\n    std::vector<std::vector<long long>> w(21, std::vector<long long>(2, 0));\n    long long ans = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        q[i] = q[i - 1] ^ A[i - 1];\n    }\n\n    for (int i = 0; i <= n; ++i) {\n        for (int j = 20; j >= 0; --j) {\n            w[j][(q[i] >> j) & 1]++;\n        }\n    }\n\n    for (int i = 0; i <= 20; ++i) {\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    }\n\n    return ans;\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a CPP kódról magyar nyelven, legfeljebb 500 karakterben.", "es": "long long f_39(const std::vector<int>& A)\n{\n    int n = A.size();\n    std::vector<long long> q(n + 1, 0);\n    std::vector<std::vector<long long>> w(21, std::vector<long long>(2, 0));\n    long long ans = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        q[i] = q[i - 1] ^ A[i - 1];\n    }\n\n    for (int i = 0; i <= n; ++i) {\n        for (int j = 20; j >= 0; --j) {\n            w[j][(q[i] >> j) & 1]++;\n        }\n    }\n\n    for (int i = 0; i <= 20; ++i) {\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    }\n\n    return ans;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando un máximo de 500 caracteres.", "arb": "long long f_39(const std::vector<int>& A)\n{\n    int n = A.size();\n    std::vector<long long> q(n + 1, 0);\n    std::vector<std::vector<long long>> w(21, std::vector<long long>(2, 0));\n    long long ans = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        q[i] = q[i - 1] ^ A[i - 1];\n    }\n\n    for (int i = 0; i <= n; ++i) {\n        for (int j = 20; j >= 0; --j) {\n            w[j][(q[i] >> j) & 1]++;\n        }\n    }\n\n    for (int i = 0; i <= 20; ++i) {\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    }\n\n    return ans;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C++ باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "long long f_39(const std::vector<int>& A)\n{\n    int n = A.size();\n    std::vector<long long> q(n + 1, 0);\n    std::vector<std::vector<long long>> w(21, std::vector<long long>(2, 0));\n    long long ans = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        q[i] = q[i - 1] ^ A[i - 1];\n    }\n\n    for (int i = 0; i <= n; ++i) {\n        for (int j = 20; j >= 0; --j) {\n            w[j][(q[i] >> j) & 1]++;\n        }\n    }\n\n    for (int i = 0; i <= 20; ++i) {\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    }\n\n    return ans;\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "long long f_39(const std::vector<int>& A)\n{\n    int n = A.size();\n    std::vector<long long> q(n + 1, 0);\n    std::vector<std::vector<long long>> w(21, std::vector<long long>(2, 0));\n    long long ans = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        q[i] = q[i - 1] ^ A[i - 1];\n    }\n\n    for (int i = 0; i <= n; ++i) {\n        for (int j = 20; j >= 0; --j) {\n            w[j][(q[i] >> j) & 1]++;\n        }\n    }\n\n    for (int i = 0; i <= 20; ++i) {\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    }\n\n    return ans;\n}\n\nAşağıdaki CPP kodunun Türkçe'de en fazla 500 karakter kullanarak doğal dilde kısa bir açıklamasını (docstring) sağlayın.", "vi": "long long f_39(const std::vector<int>& A)\n{\n    int n = A.size();\n    std::vector<long long> q(n + 1, 0);\n    std::vector<std::vector<long long>> w(21, std::vector<long long>(2, 0));\n    long long ans = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        q[i] = q[i - 1] ^ A[i - 1];\n    }\n\n    for (int i = 0; i <= n; ++i) {\n        for (int j = 20; j >= 0; --j) {\n            w[j][(q[i] >> j) & 1]++;\n        }\n    }\n\n    for (int i = 0; i <= 20; ++i) {\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    }\n\n    return ans;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự.", "id": "long long f_39(const std::vector<int>& A)\n{\n    int n = A.size();\n    std::vector<long long> q(n + 1, 0);\n    std::vector<std::vector<long long>> w(21, std::vector<long long>(2, 0));\n    long long ans = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        q[i] = q[i - 1] ^ A[i - 1];\n    }\n\n    for (int i = 0; i <= n; ++i) {\n        for (int j = 20; j >= 0; --j) {\n            w[j][(q[i] >> j) & 1]++;\n        }\n    }\n\n    for (int i = 0; i <= 20; ++i) {\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    }\n\n    return ans;\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode CPP dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "long long f_39(const std::vector<int>& A)\n{\n    int n = A.size();\n    std::vector<long long> q(n + 1, 0);\n    std::vector<std::vector<long long>> w(21, std::vector<long long>(2, 0));\n    long long ans = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        q[i] = q[i - 1] ^ A[i - 1];\n    }\n\n    for (int i = 0; i <= n; ++i) {\n        for (int j = 20; j >= 0; --j) {\n            w[j][(q[i] >> j) & 1]++;\n        }\n    }\n\n    for (int i = 0; i <= 20; ++i) {\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    }\n\n    return ans;\n}\n\n以下のCPPコードの簡潔な自然言語による説明（ドックストリング）を日本語で500文字以内で提供してください。", "ko": "long long f_39(const std::vector<int>& A)\n{\n    int n = A.size();\n    std::vector<long long> q(n + 1, 0);\n    std::vector<std::vector<long long>> w(21, std::vector<long long>(2, 0));\n    long long ans = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        q[i] = q[i - 1] ^ A[i - 1];\n    }\n\n    for (int i = 0; i <= n; ++i) {\n        for (int j = 20; j >= 0; --j) {\n            w[j][(q[i] >> j) & 1]++;\n        }\n    }\n\n    for (int i = 0; i <= 20; ++i) {\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    }\n\n    return ans;\n}\n\n다음 CPP 코드의 동작을 설명하는 간결한 자연어 설명(도크스트링)을 최대 500자 이내로 한국어로 제공하세요.", "ml": "long long f_39(const std::vector<int>& A)\n{\n    int n = A.size();\n    std::vector<long long> q(n + 1, 0);\n    std::vector<std::vector<long long>> w(21, std::vector<long long>(2, 0));\n    long long ans = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        q[i] = q[i - 1] ^ A[i - 1];\n    }\n\n    for (int i = 0; i <= n; ++i) {\n        for (int j = 20; j >= 0; --j) {\n            w[j][(q[i] >> j) & 1]++;\n        }\n    }\n\n    for (int i = 0; i <= 20; ++i) {\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    }\n\n    return ans;\n}\n\nCPP കോഡ് മലയാളത്തിൽ പരമാവധി 500 അക്ഷരങ്ങൾ ഉപയോഗിച്ച് സംക്ഷിപ്തമായ സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) നൽകുക.", "fa": "long long f_39(const std::vector<int>& A)\n{\n    int n = A.size();\n    std::vector<long long> q(n + 1, 0);\n    std::vector<std::vector<long long>> w(21, std::vector<long long>(2, 0));\n    long long ans = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        q[i] = q[i - 1] ^ A[i - 1];\n    }\n\n    for (int i = 0; i <= n; ++i) {\n        for (int j = 20; j >= 0; --j) {\n            w[j][(q[i] >> j) & 1]++;\n        }\n    }\n\n    for (int i = 0; i <= 20; ++i) {\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    }\n\n    return ans;\n}\n\nتوضیح مختصر و طبیعی (docstring) از کد CPP به زبان فارسی ارائه دهید که حداکثر ۵۰۰ کاراکتر باشد."}, "level": "", "test": "int main() {\n    assert(f_39({1, 2, 3, 4, 5}) == 39);\n    assert(f_39({1, 1, 1}) == 4);\n    assert(f_39({2, 3, 1}) == 9);\n    assert(f_39({4, 5, 7, 9}) == 74);\n    assert(f_39({0, 0, 0, 0}) == 0);\n    assert(f_39({8, 8, 8, 8, 8}) == 72);\n    assert(f_39({3, 6, 9, 12, 15}) == 125);\n    assert(f_39({10, 20, 30, 40, 50}) == 390);\n    assert(f_39({16, 16, 16, 16, 16, 16}) == 192);\n    assert(f_39({1, 3, 5, 7, 9, 11, 13}) == 192);\n    assert(f_39({0, 1, 2, 3, 4, 5, 6, 7, 8, 9}) == 218);\n\n\n    return 0;\n}", "entry_point": "f_39", "signature": "long long f_39(const std::vector<int>& A)", "docstring": {"en": "Given an array A of integers, the task is to calculate the sum of the XOR of all subarrays.\nA subarray is defined by a pair of indices (L, R) such that 1 <= L <= R <= n, where n is the size of the array.\nThe XOR sum of a subarray is the result of XORing all elements from L to R.\nThe final result is the sum of the XOR sums for all possible subarrays.\n\nExample cases:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39\n", "sq": "Duke pasur një varg A të numrave të plotë, detyra është të llogarisim shumën e XOR-it të të gjitha nënvargjeve. Një nënvarg është i përcaktuar nga një çift indeksesh (L, R) të tilla që 1 <= L <= R <= n, ku n është madhësia e vargut. Shuma XOR e një nënvargu është rezultati i XOR-it të të gjithë elementeve nga L në R. Rezultati përfundimtar është shuma e shumave XOR për të gjitha nënvargjet e mundshme.\n\nShembuj rastesh:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "hy": "Տրված է ամբողջ թվերի A զանգվածը, խնդիրը բոլոր ենթազանգվածների XOR-ի գումարը հաշվարկելն է:\nԵնթազանգվածը սահմանվում է (L, R) ինդեքսների զույգով, որտեղ 1 <= L <= R <= n, n-ը զանգվածի չափն է:\nԵնթազանգվածի XOR գումարը L-ից R բոլոր տարրերի XOR-ի արդյունքն է:\nՎերջնական արդյունքը բոլոր հնարավոր ենթազանգվածների XOR գումարների գումարն է:\n\nՕրինակ դեպքեր:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "bn": "একটি পূর্ণসংখ্যার অ্যারে A দেওয়া হয়েছে, কাজটি হল সমস্ত উপঅ্যারের XOR এর যোগফল গণনা করা।\nএকটি উপঅ্যারে একটি জোড়া সূচক (L, R) দ্বারা সংজ্ঞায়িত করা হয় যেখানে 1 <= L <= R <= n, যেখানে n হল অ্যারের আকার।\nএকটি উপঅ্যারের XOR যোগফল হল L থেকে R পর্যন্ত সমস্ত উপাদানের XOR করার ফলাফল।\nচূড়ান্ত ফলাফল হল সমস্ত সম্ভাব্য উপঅ্যারের জন্য XOR যোগফলের যোগফল।\n\nউদাহরণ কেস:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "bg": "Даден е масив A от цели числа, задачата е да се изчисли сумата от XOR на всички подмасиви. Подмасив се дефинира чрез двойка индекси (L, R) така че 1 <= L <= R <= n, където n е размерът на масива. XOR сумата на подмасив е резултатът от XOR на всички елементи от L до R. Крайният резултат е сумата от XOR сумите за всички възможни подмасиви.\n\nПримерни случаи:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "zh": "给定一个整数数组A，任务是计算所有子数组的异或和之和。  \n子数组由一对索引(L, R)定义，其中1 <= L <= R <= n，n是数组的大小。  \n子数组的异或和是从L到R的所有元素进行异或运算的结果。  \n最终结果是所有可能子数组的异或和之和。\n\n示例案例:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "fr": "Étant donné un tableau A d'entiers, la tâche consiste à calculer la somme du XOR de tous les sous-tableaux.  \nUn sous-tableau est défini par une paire d'indices (L, R) telle que 1 <= L <= R <= n, où n est la taille du tableau.  \nLa somme XOR d'un sous-tableau est le résultat du XOR de tous les éléments de L à R.  \nLe résultat final est la somme des sommes XOR pour tous les sous-tableaux possibles.\n\nCas d'exemple :\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "de": "Gegeben ein Array A von ganzen Zahlen, besteht die Aufgabe darin, die Summe des XOR aller Teilarrays zu berechnen. Ein Teilarray wird durch ein Paar von Indizes (L, R) definiert, so dass 1 <= L <= R <= n, wobei n die Größe des Arrays ist. Die XOR-Summe eines Teilarrays ist das Ergebnis des XORs aller Elemente von L bis R. Das Endergebnis ist die Summe der XOR-Summen für alle möglichen Teilarrays.\n\nBeispielhafte Fälle:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "ha": "An ba da wani jerin A na lambobin cikakkun lambobi, aikin shi ne lissafin jimillar XOR na dukkan ƙananan jerin.\nAna ayyana ƙaramin jeri ta hanyar ma'aurata na alamomi (L, R) inda 1 <= L <= R <= n, inda n shine girman jerin.\nJimillar XOR na ƙaramin jeri shine sakamakon XORing dukkan abubuwa daga L zuwa R.\nSakamakon ƙarshe shine jimillar XOR na dukkan yiwuwar ƙananan jerin.\n\nMisalan lamura:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "hi": "दिए गए पूर्णांकों के एक array A के लिए, कार्य सभी उप-समुच्चयों के XOR का योग गणना करना है। \nएक उप-समुच्चय को (L, R) सूचकांकों की एक जोड़ी द्वारा परिभाषित किया जाता है, जहाँ 1 <= L <= R <= n, और n array का आकार है। \nएक उप-समुच्चय का XOR योग L से R तक के सभी तत्वों का XOR करने का परिणाम है। \nअंतिम परिणाम सभी संभावित उप-समुच्चयों के XOR योगों का योग है।\n\nउदाहरण मामले:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "hu": "Adott egy A egész számokat tartalmazó tömb, a feladat az összes részhalmaz XOR összegének kiszámítása.\nEgy részhalmazt egy (L, R) indexpár határoz meg, ahol 1 <= L <= R <= n, ahol n a tömb mérete.\nEgy részhalmaz XOR összege az L-től R-ig terjedő elemek XOR-olásának eredménye.\nA végső eredmény az összes lehetséges részhalmaz XOR összegeinek összege.\n\nPélda esetek:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "es": "Dado un array A de enteros, la tarea es calcular la suma del XOR de todos los subarrays.  \nUn subarray se define por un par de índices (L, R) tal que 1 <= L <= R <= n, donde n es el tamaño del array.  \nLa suma XOR de un subarray es el resultado de aplicar XOR a todos los elementos desde L hasta R.  \nEl resultado final es la suma de las sumas XOR para todos los subarrays posibles.\n\nCasos de ejemplo:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "arb": "بالنظر إلى مصفوفة A من الأعداد الصحيحة، المهمة هي حساب مجموع عملية XOR لجميع المصفوفات الفرعية. \nيتم تعريف المصفوفة الفرعية بواسطة زوج من الفهارس (L, R) بحيث 1 <= L <= R <= n، حيث n هو حجم المصفوفة. \nمجموع XOR لمصفوفة فرعية هو نتيجة عملية XOR لجميع العناصر من L إلى R. \nالنتيجة النهائية هي مجموع نتائج XOR لجميع المصفوفات الفرعية الممكنة.\n\nحالات المثال:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "sw": "Kwa kupewa safu A ya nambari za mzima, kazi ni kuhesabu jumla ya XOR ya sehemu ndogo zote.\nSehemu ndogo inafafanuliwa na jozi ya fahirisi (L, R) ambapo 1 <= L <= R <= n, ambapo n ni ukubwa wa safu.\nJumla ya XOR ya sehemu ndogo ni matokeo ya XOR ya vipengele vyote kutoka L hadi R.\nMatokeo ya mwisho ni jumla ya jumla za XOR kwa sehemu ndogo zote zinazowezekana.\n\nMifano ya kesi:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "tr": "Verilen bir tamsayı dizisi A için, tüm alt dizilerin XOR toplamını hesaplama görevi.\nBir alt dizi, (L, R) indeks çifti ile tanımlanır ve burada 1 <= L <= R <= n, n dizinin boyutudur.\nBir alt dizinin XOR toplamı, L'den R'ye kadar olan tüm elemanların XOR'lanması sonucudur.\nNihai sonuç, tüm olası alt diziler için XOR toplamlarının toplamıdır.\n\nÖrnek durumlar:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "vi": "Cho một mảng A gồm các số nguyên, nhiệm vụ là tính tổng của phép XOR của tất cả các mảng con. \nMột mảng con được định nghĩa bởi một cặp chỉ số (L, R) sao cho 1 <= L <= R <= n, trong đó n là kích thước của mảng. \nTổng XOR của một mảng con là kết quả của phép XOR tất cả các phần tử từ L đến R. \nKết quả cuối cùng là tổng của các tổng XOR cho tất cả các mảng con có thể.\n\nCác trường hợp ví dụ:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "id": "Diberikan sebuah array A dari bilangan bulat, tugasnya adalah menghitung jumlah dari XOR semua subarray.  \nSebuah subarray didefinisikan oleh sepasang indeks (L, R) sehingga 1 <= L <= R <= n, di mana n adalah ukuran array.  \nJumlah XOR dari sebuah subarray adalah hasil dari XOR semua elemen dari L hingga R.  \nHasil akhirnya adalah jumlah dari semua jumlah XOR untuk semua subarray yang mungkin.  \n\nContoh kasus:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "ja": "整数の配列 A が与えられたとき、すべての部分配列の XOR の合計を計算することが課題です。\n部分配列は、1 <= L <= R <= n であるようなインデックスのペア (L, R) によって定義されます。ここで、n は配列のサイズです。\n部分配列の XOR 合計は、L から R までのすべての要素を XOR した結果です。\n最終結果は、可能なすべての部分配列の XOR 合計の合計です。\n\n例:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "ko": "주어진 정수 배열 A에 대해, 모든 부분 배열의 XOR 합계를 계산하는 작업입니다.\n부분 배열은 인덱스 쌍 (L, R)에 의해 정의되며, 여기서 1 <= L <= R <= n이고, n은 배열의 크기입니다.\n부분 배열의 XOR 합계는 L부터 R까지의 모든 요소를 XOR한 결과입니다.\n최종 결과는 가능한 모든 부분 배열에 대한 XOR 합계의 합입니다.\n\n예제 사례:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "ml": "ഇന്റിജറുകളുടെ ഒരു നിരയായ A നല്കിയിരിക്കുന്നപ്പോൾ, എല്ലാ ഉപനിരകളുടെയും XOR യുടെ മൊത്തം കണക്കാക്കുക എന്നതാണ് ഈ പ്രവർത്തിയുടെ ലക്ഷ്യം. 1 <= L <= R <= n എന്നിടത്ത്, n നിരയുടെ വലുപ്പമാണെങ്കിൽ, (L, R) എന്ന ഇന്ഡക്സ് ജോഡികൾ ഉപയോഗിച്ച് ഒരു ഉപനിര നിർവചിക്കപ്പെടുന്നു. ഒരു ഉപനിരയുടെ XOR മൊത്തം L മുതൽ R വരെയുള്ള എല്ലാ ഘടകങ്ങളും XOR ചെയ്യുന്നതിന്റെ ഫലമാണ്. എല്ലാ സാധ്യതയുള്ള ഉപനിരകളുടെയും XOR മൊത്തങ്ങളുടെ തുകയാണ് അന്തിമ ഫലം.\n\nഉദാഹരണ കേസുകൾ:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "fa": "با توجه به آرایه‌ای A از اعداد صحیح، وظیفه محاسبه مجموع XOR تمام زیرآرایه‌ها است. \nیک زیرآرایه با یک جفت شاخص (L, R) تعریف می‌شود به طوری که 1 <= L <= R <= n، که n اندازه آرایه است. \nمجموع XOR یک زیرآرایه نتیجه XOR کردن تمام عناصر از L تا R است. \nنتیجه نهایی مجموع مجموع‌های XOR برای تمام زیرآرایه‌های ممکن است.\n\nموارد مثال:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39"}}
{"task_id": "CPP/40", "prompt": {"en": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n/**\n * Given two positive integers n and k, find the number of positive integers x,\n * where 1 <= x <= n, that can be expressed as x = a^b with a and b being\n * positive integers and b >= k. Different legal representations of x are counted\n * only once. For example:\n *     >>> f_40(99, 1)\n *     99\n */\nint f_40(int n, int k)", "sq": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n/**\n * Duke pasur dy numra të plotë pozitivë n dhe k, gjeni numrin e numrave të plotë pozitivë x,\n * ku 1 <= x <= n, që mund të shprehen si x = a^b me a dhe b që janë\n * numra të plotë pozitivë dhe b >= k. Përfaqësimet e ndryshme të ligjshme të x numërohen\n * vetëm një herë. Për shembull:\n *     >>> f_40(99, 1)\n *     99\n */\nint f_40(int n, int k)", "hy": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n/**\n * Տրված են n և k դրական ամբողջ թվերը, գտնել դրական ամբողջ թվերի քանակը x,\n * որտեղ 1 <= x <= n, որոնք կարող են արտահայտվել որպես x = a^b, որտեղ a և b\n * դրական ամբողջ թվեր են և b >= k: x-ի տարբեր թույլատրելի ներկայացումները հաշվում են\n * միայն մեկ անգամ: Օրինակ՝\n *     >>> f_40(99, 1)\n *     99\n */\nint f_40(int n, int k)", "bn": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n/**\n * দুটি ধনাত্মক পূর্ণসংখ্যা n এবং k দেওয়া হলে, ধনাত্মক পূর্ণসংখ্যা x এর সংখ্যা খুঁজে বের করুন,\n * যেখানে 1 <= x <= n, যা x = a^b হিসাবে প্রকাশ করা যায় যেখানে a এবং b\n * ধনাত্মক পূর্ণসংখ্যা এবং b >= k। x এর বিভিন্ন বৈধ উপস্থাপনাগুলি শুধুমাত্র একবার গণনা করা হয়। উদাহরণস্বরূপ:\n *     >>> f_40(99, 1)\n *     99\n */\nint f_40(int n, int k)", "bg": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n/**\n * Дадени са две положителни цели числа n и k, намерете броя на положителните цели числа x,\n * където 1 <= x <= n, които могат да бъдат изразени като x = a^b с a и b, които са\n * положителни цели числа и b >= k. Различните легални представяния на x се броят\n * само веднъж. Например:\n *     >>> f_40(99, 1)\n *     99\n */\nint f_40(int n, int k)", "zh": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n/**\n * 给定两个正整数 n 和 k，找出多少个正整数 x，\n * 其中 1 <= x <= n，可以表示为 x = a^b，a 和 b 为\n * 正整数且 b >= k。x 的不同合法表示只计数一次。例如：\n *     >>> f_40(99, 1)\n *     99\n */\nint f_40(int n, int k)", "fr": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n/**\n * Étant donnés deux entiers positifs n et k, trouver le nombre d'entiers positifs x,\n * où 1 <= x <= n, qui peuvent être exprimés comme x = a^b avec a et b étant\n * des entiers positifs et b >= k. Les différentes représentations légales de x sont comptées\n * une seule fois. Par exemple :\n *     >>> f_40(99, 1)\n *     99\n */\nint f_40(int n, int k)", "de": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n/**\n * Gegeben zwei positive ganze Zahlen n und k, finde die Anzahl der positiven ganzen Zahlen x,\n * wobei 1 <= x <= n, die als x = a^b ausgedrückt werden können, wobei a und b\n * positive ganze Zahlen sind und b >= k. Verschiedene zulässige Darstellungen von x werden\n * nur einmal gezählt. Zum Beispiel:\n *     >>> f_40(99, 1)\n *     99\n */\nint f_40(int n, int k)", "ha": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n/**\n * An ba da lambobi guda biyu masu kyau n da k, nemo yawan lambobi masu kyau x,\n * inda 1 <= x <= n, waɗanda za a iya bayyana su a matsayin x = a^b tare da a da b suna\n * lambobi masu kyau kuma b >= k. Ana kirga bambance-bambancen halattattun wakilcin x\n * sau ɗaya kawai. Misali:\n *     >>> f_40(99, 1)\n *     99\n */\nint f_40(int n, int k)", "hi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n/**\n * दिए गए दो धनात्मक पूर्णांक n और k, ऐसे धनात्मक पूर्णांकों x की संख्या खोजें,\n * जहाँ 1 <= x <= n, जिसे x = a^b के रूप में व्यक्त किया जा सकता है जहाँ a और b\n * धनात्मक पूर्णांक हैं और b >= k है। x के विभिन्न वैध निरूपण केवल एक बार गिने जाते हैं। उदाहरण के लिए:\n *     >>> f_40(99, 1)\n *     99\n */\nint f_40(int n, int k)", "hu": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n/**\n * Két pozitív egész szám, n és k megadása esetén találjuk meg azon pozitív egész számok x számát,\n * ahol 1 <= x <= n, és amelyek kifejezhetők x = a^b alakban, ahol a és b pozitív egész számok és b >= k. \n * Az x különböző érvényes ábrázolásait csak egyszer számoljuk. Például:\n *     >>> f_40(99, 1)\n *     99\n */\nint f_40(int n, int k)", "es": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n/**\n * Dado dos enteros positivos n y k, encuentra el número de enteros positivos x,\n * donde 1 <= x <= n, que pueden expresarse como x = a^b con a y b siendo\n * enteros positivos y b >= k. Diferentes representaciones legales de x se cuentan\n * solo una vez. Por ejemplo:\n *     >>> f_40(99, 1)\n *     99\n */\nint f_40(int n, int k)", "arb": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n/**\n * معطى عددين صحيحين موجبين n و k، جد عدد الأعداد الصحيحة الموجبة x،\n * حيث 1 <= x <= n، التي يمكن التعبير عنها كـ x = a^b مع كون a و b\n * أعدادًا صحيحة موجبة و b >= k. يتم احتساب التمثيلات القانونية المختلفة لـ x\n * مرة واحدة فقط. على سبيل المثال:\n *     >>> f_40(99, 1)\n *     99\n */\nint f_40(int n, int k)", "sw": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n/**\n * Ukipewa nambari mbili nzima chanya n na k, pata idadi ya nambari chanya x,\n * ambapo 1 <= x <= n, ambazo zinaweza kuonyeshwa kama x = a^b na a na b zikiwa\n * nambari nzima chanya na b >= k. Uwakilishi tofauti halali wa x unahesabiwa\n * mara moja tu. Kwa mfano:\n *     >>> f_40(99, 1)\n *     99\n */\nint f_40(int n, int k)", "tr": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n/**\n * İki pozitif tamsayı n ve k verildiğinde, 1 <= x <= n aralığında olan ve\n * x = a^b şeklinde ifade edilebilen pozitif tamsayı x sayısını bulun,\n * burada a ve b pozitif tamsayılar ve b >= k. x'in farklı yasal gösterimleri\n * yalnızca bir kez sayılır. Örneğin:\n *     >>> f_40(99, 1)\n *     99\n */\nint f_40(int n, int k)", "vi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n/**\n * Cho hai số nguyên dương n và k, tìm số lượng số nguyên dương x,\n * với 1 <= x <= n, có thể được biểu diễn dưới dạng x = a^b với a và b là\n * các số nguyên dương và b >= k. Các biểu diễn hợp lệ khác nhau của x chỉ được đếm\n * một lần. Ví dụ:\n *     >>> f_40(99, 1)\n *     99\n */\nint f_40(int n, int k)", "id": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n/**\n * Diberikan dua bilangan bulat positif n dan k, temukan jumlah bilangan bulat positif x,\n * di mana 1 <= x <= n, yang dapat dinyatakan sebagai x = a^b dengan a dan b adalah\n * bilangan bulat positif dan b >= k. Representasi legal yang berbeda dari x dihitung\n * hanya sekali. Sebagai contoh:\n *     >>> f_40(99, 1)\n *     99\n */\nint f_40(int n, int k)\n", "ja": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n/**\n * 2つの正の整数nとkが与えられたとき、1 <= x <= nの範囲で、\n * x = a^bと表現できる正の整数xの数を求めます。ただし、aとbは正の整数であり、\n * b >= kです。xの異なる合法的な表現は一度だけカウントされます。例えば:\n *     >>> f_40(99, 1)\n *     99\n */\nint f_40(int n, int k)\n", "ko": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n/**\n * 두 개의 양의 정수 n과 k가 주어졌을 때, 다음 조건을 만족하는 양의 정수 x의 개수를 찾으시오:\n * 1 <= x <= n, x = a^b로 표현될 수 있으며, a와 b는 양의 정수이고 b >= k입니다.\n * x의 서로 다른 합법적인 표현은 한 번만 계산됩니다. 예를 들어:\n *     >>> f_40(99, 1)\n *     99\n */\nint f_40(int n, int k)", "ml": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n/**\n * രണ്ട് ധനാത്മക പൂര്‍ണ്ണസംഖ്യകള്‍ n, k നല്‍കിയാല്‍, 1 <= x <= n എന്ന നിലയില്‍ x = a^b എന്ന രൂപത്തില്‍\n * രേഖപ്പെടുത്താവുന്ന ധനാത്മക പൂര്‍ണ്ണസംഖ്യകളുടെ എണ്ണം കണ്ടെത്തുക, ഇവിടെ a, b ധനാത്മക പൂര്‍ണ്ണസംഖ്യകളാണ്\n * കൂടാതെ b >= k. x ന്റെ വ്യത്യസ്തമായ നിയമാനുസൃതമായ പ്രതിനിധാനങ്ങള്‍ ഒരിക്കല്‍ മാത്രം എണ്ണപ്പെടും. ഉദാഹരണത്തിന്:\n *     >>> f_40(99, 1)\n *     99\n */\nint f_40(int n, int k)", "fa": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n/**\n * با داشتن دو عدد صحیح مثبت n و k، تعداد اعداد صحیح مثبت x را پیدا کنید،\n * که در آن 1 <= x <= n، که می‌توان به صورت x = a^b با a و b به عنوان\n * اعداد صحیح مثبت و b >= k بیان کرد. نمایش‌های قانونی مختلف x فقط یک بار شمارش می‌شوند. برای مثال:\n *     >>> f_40(99, 1)\n *     99\n */\nint f_40(int n, int k)"}, "canonical_solution": "{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += static_cast<int>(sqrt(n)) - x;\n    }\n    free(mp);\n    return count;\n}", "instruction": {"en": "int f_40(int n, int k)\n{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += static_cast<int>(sqrt(n)) - x;\n    }\n    free(mp);\n    return count;\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.", "sq": "int f_40(int n, int k)\n{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += static_cast<int>(sqrt(n)) - x;\n    }\n    free(mp);\n    return count;\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit CPP në shqip duke përdorur maksimumi 500 karaktere.", "hy": "int f_40(int n, int k)\n{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += static_cast<int>(sqrt(n)) - x;\n    }\n    free(mp);\n    return count;\n}\n\nՏվեք հակիրճ բնական լեզվով նկարագրություն (docstring) այս CPP կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "int f_40(int n, int k)\n{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += static_cast<int>(sqrt(n)) - x;\n    }\n    free(mp);\n    return count;\n}\n\nসিপিপি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হতে হবে।", "bg": "int f_40(int n, int k)\n{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += static_cast<int>(sqrt(n)) - x;\n    }\n    free(mp);\n    return count;\n}\n\nПредоставете кратко описание на CPP кода на естествен език на български, използвайки не повече от 500 знака.", "zh": "int f_40(int n, int k)\n{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += static_cast<int>(sqrt(n)) - x;\n    }\n    free(mp);\n    return count;\n}\n\n将以下 CPP 代码的自然语言描述（文档字符串）翻译成中文，字数不超过 500 个字符。", "fr": "int f_40(int n, int k)\n{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += static_cast<int>(sqrt(n)) - x;\n    }\n    free(mp);\n    return count;\n}\n\nFournir une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.", "de": "int f_40(int n, int k)\n{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += static_cast<int>(sqrt(n)) - x;\n    }\n    free(mp);\n    return count;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "int f_40(int n, int k)\n{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += static_cast<int>(sqrt(n)) - x;\n    }\n    free(mp);\n    return count;\n}\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar CPP a cikin Hausa ta amfani da haruffa 500 kacal.", "hi": "int f_40(int n, int k)\n{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += static_cast<int>(sqrt(n)) - x;\n    }\n    free(mp);\n    return count;\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।", "hu": "int f_40(int n, int k)\n{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += static_cast<int>(sqrt(n)) - x;\n    }\n    free(mp);\n    return count;\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a CPP kódhoz magyarul, legfeljebb 500 karakterben.", "es": "int f_40(int n, int k)\n{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += static_cast<int>(sqrt(n)) - x;\n    }\n    free(mp);\n    return count;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando un máximo de 500 caracteres.", "arb": "int f_40(int n, int k)\n{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += static_cast<int>(sqrt(n)) - x;\n    }\n    free(mp);\n    return count;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة CPP باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.", "sw": "int f_40(int n, int k)\n{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += static_cast<int>(sqrt(n)) - x;\n    }\n    free(mp);\n    return count;\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "int f_40(int n, int k)\n{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += static_cast<int>(sqrt(n)) - x;\n    }\n    free(mp);\n    return count;\n}\n\nAşağıdaki CPP kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter kullanılmalıdır.", "vi": "int f_40(int n, int k)\n{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += static_cast<int>(sqrt(n)) - x;\n    }\n    free(mp);\n    return count;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự.", "id": "int f_40(int n, int k)\n{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += static_cast<int>(sqrt(n)) - x;\n    }\n    free(mp);\n    return count;\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode CPP dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "int f_40(int n, int k)\n{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += static_cast<int>(sqrt(n)) - x;\n    }\n    free(mp);\n    return count;\n}\n\n以下のCPPコードの自然言語による簡潔な説明（ドックストリング）を日本語で500文字以内で提供してください。", "ko": "int f_40(int n, int k)\n{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += static_cast<int>(sqrt(n)) - x;\n    }\n    free(mp);\n    return count;\n}\n\n다음 CPP 코드의 동작을 최대 500자 이내의 자연어로 간결하게 설명하는 문서 문자열(docstring)을 한국어로 제공하세요.", "ml": "int f_40(int n, int k)\n{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += static_cast<int>(sqrt(n)) - x;\n    }\n    free(mp);\n    return count;\n}\n\nസിപിപി കോഡിന്റെ സംക്ഷിപ്തമായ സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) പരമാവധി 500 അക്ഷരങ്ങൾ ഉപയോഗിച്ച് മലയാളത്തിൽ നൽകുക.", "fa": "int f_40(int n, int k)\n{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += static_cast<int>(sqrt(n)) - x;\n    }\n    free(mp);\n    return count;\n}\n\nتوضیح مختصر و طبیعی از کد CPP را به زبان فارسی ارائه دهید که حداکثر ۵۰۰ کاراکتر باشد."}, "level": "", "test": "int main() {\n    assert(f_40(99, 1) == 99);\n    assert(f_40(99, 3) == 7);\n    assert(f_40(99, 2) == 12);\n    assert(f_40(10, 1) == 10);\n    assert(f_40(10, 2) == 4);\n    assert(f_40(500, 1) == 500);\n    assert(f_40(500, 2) == 30);\n    assert(f_40(500, 3) == 13);\n    assert(f_40(1000, 1) == 1000);\n    assert(f_40(1000, 2) == 41);\n    assert(f_40(1000, 3) == 17);\n    assert(f_40(1000, 93) == 1);\n    assert(f_40(50, 2) == 10);\n    assert(f_40(50, 3) == 5);\n    assert(f_40(2, 3) == 1);\n    return 0;\n}", "entry_point": "f_40", "signature": "int f_40(int n, int k)", "docstring": {"en": "Given two positive integers n and k, find the number of positive integers x, where 1 <= x <= n, that can be expressed as x = a^b with a and b being positive integers and b >= k. Different legal representations of x are counted only once. For example:\n    >>> f_40(99, 1)\n    99\n", "sq": "Dhënë dy numra të plotë pozitivë n dhe k, gjeni numrin e numrave të plotë pozitivë x, ku 1 <= x <= n, që mund të shprehen si x = a^b me a dhe b që janë numra të plotë pozitivë dhe b >= k. Përfaqësimet e ndryshme të ligjshme të x numërohen vetëm një herë. Për shembull:\n    >>> f_40(99, 1)\n    99", "hy": "Տրված են երկու դրական ամբողջ թվեր՝ n և k, գտնել դրական ամբողջ թվերի x քանակը, որտեղ 1 <= x <= n, որոնք կարող են արտահայտվել որպես x = a^b, որտեղ a և b դրական ամբողջ թվեր են և b >= k: x-ի տարբեր օրինական ներկայացումները հաշվում են միայն մեկ անգամ: Օրինակ՝\n    >>> f_40(99, 1)\n    99", "bn": "দুটি ধনাত্মক পূর্ণসংখ্যা n এবং k দেওয়া আছে, 1 <= x <= n এর মধ্যে কতগুলি ধনাত্মক পূর্ণসংখ্যা x আছে তা খুঁজে বের করুন, যা x = a^b হিসাবে প্রকাশ করা যায় যেখানে a এবং b ধনাত্মক পূর্ণসংখ্যা এবং b >= k। x এর বিভিন্ন বৈধ উপস্থাপনাগুলি কেবল একবার গণনা করা হয়। উদাহরণস্বরূপ:\n    >>> f_40(99, 1)\n    99", "bg": "Дадени са две положителни цели числа n и k, намерете броя на положителните цели числа x, където 1 <= x <= n, които могат да бъдат изразени като x = a^b с a и b като положителни цели числа и b >= k. Различните легални представяния на x се броят само веднъж. Например:\n    >>> f_40(99, 1)\n    99", "zh": "给定两个正整数 n 和 k，找出有多少个正整数 x，其中 1 <= x <= n，可以表示为 x = a^b，其中 a 和 b 是正整数且 b >= k。不同的合法表示方法的 x 只计数一次。例如：\n    >>> f_40(99, 1)\n    99", "fr": "Étant donné deux entiers positifs n et k, trouvez le nombre d'entiers positifs x, où 1 <= x <= n, qui peuvent être exprimés sous la forme x = a^b avec a et b étant des entiers positifs et b >= k. Différentes représentations légales de x sont comptées une seule fois. Par exemple :\n    >>> f_40(99, 1)\n    99", "de": "Gegeben zwei positive ganze Zahlen n und k, finde die Anzahl der positiven ganzen Zahlen x, wobei 1 <= x <= n, die als x = a^b ausgedrückt werden können, wobei a und b positive ganze Zahlen sind und b >= k. Verschiedene gültige Darstellungen von x werden nur einmal gezählt. Zum Beispiel:\n    >>> f_40(99, 1)\n    99", "ha": "An ba da lambobi masu kyau guda biyu n da k, nemo adadin lambobi masu kyau x, inda 1 <= x <= n, waɗanda za a iya bayyana su a matsayin x = a^b tare da a da b suna zama lambobi masu kyau kuma b >= k. Ana ƙidaya daban-daban halattattun wakilcin x sau ɗaya kawai. Alal misali:\n    >>> f_40(99, 1)\n    99", "hi": "दो सकारात्मक पूर्णांक n और k दिए गए हैं, उन सकारात्मक पूर्णांकों x की संख्या खोजें, जहाँ 1 <= x <= n, जिन्हें x = a^b के रूप में व्यक्त किया जा सकता है जहाँ a और b सकारात्मक पूर्णांक हैं और b >= k है। x के विभिन्न वैध निरूपणों को केवल एक बार गिना जाता है। उदाहरण के लिए:\n    >>> f_40(99, 1)\n    99", "hu": "Két pozitív egész szám, n és k esetén, találjuk meg azon pozitív egész számok x számát, ahol 1 <= x <= n, és amelyek kifejezhetők x = a^b alakban, ahol a és b pozitív egész számok és b >= k. Az x különböző érvényes ábrázolásait csak egyszer számoljuk. Például:\n    >>> f_40(99, 1)\n    99", "es": "Dado dos enteros positivos n y k, encuentra el número de enteros positivos x, donde 1 <= x <= n, que pueden expresarse como x = a^b con a y b siendo enteros positivos y b >= k. Diferentes representaciones legales de x se cuentan solo una vez. Por ejemplo:\n    >>> f_40(99, 1)\n    99", "arb": "بالنظر إلى عددين صحيحين موجبين n و k، ابحث عن عدد الأعداد الصحيحة الموجبة x، حيث 1 <= x <= n، والتي يمكن التعبير عنها كـ x = a^b مع كون a و b أعداد صحيحة موجبة و b >= k. يتم احتساب التمثيلات القانونية المختلفة لـ x مرة واحدة فقط. على سبيل المثال:\n    >>> f_40(99, 1)\n    99", "sw": "Ukipewa nambari mbili nzima chanya n na k, tafuta idadi ya nambari chanya x, ambapo 1 <= x <= n, ambazo zinaweza kuonyeshwa kama x = a^b huku a na b zikiwa nambari nzima chanya na b >= k. Uwiano tofauti halali wa x unahesabiwa mara moja tu. Kwa mfano:\n    >>> f_40(99, 1)\n    99", "tr": "İki pozitif tamsayı n ve k verildiğinde, 1 <= x <= n olacak şekilde x = a^b olarak ifade edilebilen pozitif tamsayı x'lerin sayısını bulun, burada a ve b pozitif tamsayılar ve b >= k'dir. x'in farklı yasal gösterimleri yalnızca bir kez sayılır. Örneğin:\n    >>> f_40(99, 1)\n    99", "vi": "Cho hai số nguyên dương n và k, tìm số lượng số nguyên dương x, với 1 <= x <= n, có thể được biểu diễn dưới dạng x = a^b với a và b là các số nguyên dương và b >= k. Các biểu diễn hợp lệ khác nhau của x chỉ được đếm một lần. Ví dụ:\n    >>> f_40(99, 1)\n    99", "id": "Diberikan dua bilangan bulat positif n dan k, temukan jumlah bilangan bulat positif x, di mana 1 <= x <= n, yang dapat dinyatakan sebagai x = a^b dengan a dan b adalah bilangan bulat positif dan b >= k. Representasi legal yang berbeda dari x dihitung hanya sekali. Sebagai contoh:\n    >>> f_40(99, 1)\n    99", "ja": "2つの正の整数 n と k が与えられたとき、1 <= x <= n の範囲で、x = a^b と表現できる正の整数 x の数を求めます。ただし、a と b は正の整数で、b >= k です。x の異なる合法的な表現は1回だけカウントされます。例えば:\n    >>> f_40(99, 1)\n    99", "ko": "두 개의 양의 정수 n과 k가 주어졌을 때, 1 <= x <= n 범위 내에서 x = a^b로 표현될 수 있는 양의 정수 x의 개수를 찾으시오. 여기서 a와 b는 양의 정수이며 b >= k입니다. x의 서로 다른 합법적인 표현은 한 번만 계산됩니다. 예를 들어:\n    >>> f_40(99, 1)\n    99", "ml": "രണ്ട് പോസിറ്റീവ് പൂർണ്ണസംഖ്യകൾ n, k എന്നിവ നൽകിയാൽ, 1 <= x <= n എന്നതിനിടയിൽ x = a^b എന്ന രൂപത്തിൽ പ്രകടിപ്പിക്കാവുന്ന പോസിറ്റീവ് പൂർണ്ണസംഖ്യകളുടെ എണ്ണം കണ്ടെത്തുക, ഇവിടെ a, b എന്നിവ പോസിറ്റീവ് പൂർണ്ണസംഖ്യകളാണ്, b >= k. x ന്റെ വ്യത്യസ്തമായ നിയമാനുസൃത പ്രതിനിധാനങ്ങൾ ഒരിക്കൽ മാത്രമേ എണ്ണപ്പെടുകയുള്ളൂ. ഉദാഹരണത്തിന്:\n    >>> f_40(99, 1)\n    99", "fa": "با توجه به دو عدد صحیح مثبت n و k، تعداد اعداد صحیح مثبت x را پیدا کنید، به طوری که 1 <= x <= n، که می‌توان آن‌ها را به صورت x = a^b بیان کرد، با این شرط که a و b اعداد صحیح مثبت باشند و b >= k. نمایش‌های قانونی مختلف از x فقط یک بار شمارش می‌شوند. برای مثال:\n    >>> f_40(99, 1)\n    99"}}
{"task_id": "CPP/41", "prompt": {"en": "#include <cassert>\n/* Given three integers n, m, and k, find the number of sequences consisting of n '(' and m ')',\nsuch that the longest balanced subsequence is of length 2 * k. The result should be calculated modulo 1,000,000,007 (10^9 + 7).\n\nFor example:\n    >>> f_41(2, 2, 2)\n    2\n*/\nlong long f_41(long long n, long long m, long long k)", "sq": "#include <cassert>\n/* Duke pasur tre numra të plotë n, m, dhe k, gjeni numrin e sekuencave që përbëhen nga n '(' dhe m ')',\ntë tilla që nënsekuenca më e gjatë e balancuar është me gjatësi 2 * k. Rezultati duhet të llogaritet modulo 1,000,000,007 (10^9 + 7).\n\nPër shembull:\n    >>> f_41(2, 2, 2)\n    2\n*/\nlong long f_41(long long n, long long m, long long k)", "hy": "#include <cassert>\n/* Տրված է երեք ամբողջ թիվ՝ n, m և k, գտնել հաջորդականությունների քանակը, որոնք կազմված են n '(' և m ')',\nայնպես, որ ամենաերկար հավասարակշռված ենթահաջորդականությունը լինի 2 * k երկարությամբ։ Արդյունքը պետք է հաշվարկվի 1,000,000,007 (10^9 + 7) մոդուլով։\n\nՕրինակ:\n    >>> f_41(2, 2, 2)\n    2\n*/\nlong long f_41(long long n, long long m, long long k)", "bn": "#include <cassert>\n/* তিনটি পূর্ণসংখ্যা n, m, এবং k দেওয়া আছে, n '(' এবং m ')' নিয়ে গঠিত সিকোয়েন্সের সংখ্যা খুঁজে বের করুন,\nযাতে দীর্ঘতম ব্যালান্সড উপসিকোয়েন্সের দৈর্ঘ্য 2 * k হয়। ফলাফলটি 1,000,000,007 (10^9 + 7) দ্বারা মডুলো গণনা করা উচিত।\n\nউদাহরণস্বরূপ:\n    >>> f_41(2, 2, 2)\n    2\n*/\nlong long f_41(long long n, long long m, long long k)", "bg": "#include <cassert>\n/* Дадени са три цели числа n, m и k, намерете броя на последователностите, състоящи се от n '(' и m ')',\nтакива че най-дългата балансирана подредена последователност е с дължина 2 * k. Резултатът трябва да бъде изчислен по модул 1,000,000,007 (10^9 + 7).\n\nНапример:\n    >>> f_41(2, 2, 2)\n    2\n*/\nlong long f_41(long long n, long long m, long long k)", "zh": "#include <cassert>\n/* 给定三个整数 n, m 和 k，找出由 n 个 '(' 和 m 个 ')' 组成的序列的数量，\n使得最长的平衡子序列的长度为 2 * k。结果应以 1,000,000,007 (10^9 + 7) 为模计算。\n\n例如:\n    >>> f_41(2, 2, 2)\n    2\n*/\nlong long f_41(long long n, long long m, long long k)", "fr": "#include <cassert>\n/* Étant donné trois entiers n, m, et k, trouver le nombre de séquences consistant en n '(' et m ')',\ntelles que la plus longue sous-séquence équilibrée soit de longueur 2 * k. Le résultat doit être calculé modulo 1,000,000,007 (10^9 + 7).\n\nPar exemple :\n    >>> f_41(2, 2, 2)\n    2\n*/\nlong long f_41(long long n, long long m, long long k)", "de": "#include <cassert>\n/* Gegeben drei ganze Zahlen n, m und k, finde die Anzahl der Sequenzen, die aus n '(' und m ')' bestehen,\nso dass die längste ausbalancierte Teilsequenz die Länge 2 * k hat. Das Ergebnis sollte modulo 1.000.000.007 (10^9 + 7) berechnet werden.\n\nZum Beispiel:\n    >>> f_41(2, 2, 2)\n    2\n*/\nlong long f_41(long long n, long long m, long long k)", "ha": "#include <cassert>\n/* An ba da lambobi guda uku n, m, da k, nemo adadin jerin abubuwan da suka ƙunshi n '(' da m ')',\nta yadda mafi tsawon jere mai daidaito yana da tsawon 2 * k. Ya kamata a ƙididdige sakamakon modulo 1,000,000,007 (10^9 + 7).\n\nMisali:\n    >>> f_41(2, 2, 2)\n    2\n*/\nlong long f_41(long long n, long long m, long long k)", "hi": "#include <cassert>\n/* तीन पूर्णांक n, m, और k दिए गए हैं, उन अनुक्रमों की संख्या खोजें जो n '(' और m ')' से बने होते हैं,\nऐसे कि सबसे लंबा संतुलित उप-अनुक्रम 2 * k लंबाई का हो। परिणाम को 1,000,000,007 (10^9 + 7) के माड्यूलो में गणना की जानी चाहिए।\n\nउदाहरण के लिए:\n    >>> f_41(2, 2, 2)\n    2\n*/\nlong long f_41(long long n, long long m, long long k)", "hu": "#include <cassert>\n/* Adott három egész szám: n, m és k. Meg kell találni az olyan sorozatok számát, amelyek n '(' és m ')' jelekből állnak,\núgy, hogy a leghosszabb kiegyensúlyozott részszekvencia hossza 2 * k. Az eredményt 1,000,000,007 (10^9 + 7) modulo szerint kell kiszámítani.\n\nPéldául:\n    >>> f_41(2, 2, 2)\n    2\n*/\nlong long f_41(long long n, long long m, long long k)", "es": "#include <cassert>\n/* Dados tres enteros n, m, y k, encuentra el número de secuencias que consisten en n '(' y m ')',\ntal que la subsecuencia balanceada más larga tenga una longitud de 2 * k. El resultado debe ser calculado módulo 1,000,000,007 (10^9 + 7).\n\nPor ejemplo:\n    >>> f_41(2, 2, 2)\n    2\n*/\nlong long f_41(long long n, long long m, long long k)", "arb": "#include <cassert>\n/* معطى ثلاثة أعداد صحيحة n، m، و k، ابحث عن عدد التتابعات التي تتكون من n '(' و m ')',\nبحيث يكون أطول تتابع متوازن بطول 2 * k. يجب حساب النتيجة بتطبيق باقي القسمة على 1,000,000,007 (10^9 + 7).\n\nعلى سبيل المثال:\n    >>> f_41(2, 2, 2)\n    2\n*/\nlong long f_41(long long n, long long m, long long k)", "sw": "#include <cassert>\n/* Ukipewa nambari tatu n, m, na k, pata idadi ya misururu inayojumuisha n '(' na m ')',\nhivyo kwamba mfuatano mrefu zaidi ulio sawa ni wa urefu 2 * k. Matokeo yanapaswa kuhesabiwa kwa modulo 1,000,000,007 (10^9 + 7).\n\nKwa mfano:\n    >>> f_41(2, 2, 2)\n    2\n*/\nlong long f_41(long long n, long long m, long long k)", "tr": "#include <cassert>\n/* Üç tamsayı n, m ve k verildiğinde, n '(' ve m ')' karakterlerinden oluşan dizilerin sayısını bulun,\nöyle ki en uzun dengeli alt dizi uzunluğu 2 * k olsun. Sonuç 1,000,000,007 (10^9 + 7) modunda hesaplanmalıdır.\n\nÖrneğin:\n    >>> f_41(2, 2, 2)\n    2\n*/\nlong long f_41(long long n, long long m, long long k)", "vi": "#include <cassert>\n/* Cho ba số nguyên n, m và k, tìm số lượng dãy bao gồm n '(' và m ')',\nsao cho dãy con cân bằng dài nhất có độ dài 2 * k. Kết quả nên được tính theo modulo 1,000,000,007 (10^9 + 7).\n\nVí dụ:\n    >>> f_41(2, 2, 2)\n    2\n*/\nlong long f_41(long long n, long long m, long long k)", "id": "#include <cassert>\n/* Diberikan tiga bilangan bulat n, m, dan k, temukan jumlah urutan yang terdiri dari n '(' dan m ')',\nsedemikian rupa sehingga subsekuens seimbang terpanjang memiliki panjang 2 * k. Hasilnya harus dihitung modulo 1,000,000,007 (10^9 + 7).\n\nSebagai contoh:\n    >>> f_41(2, 2, 2)\n    2\n*/\nlong long f_41(long long n, long long m, long long k)", "ja": "#include <cassert>\n/* 3つの整数 n, m, k が与えられたとき、n 個の '(' と m 個の ')' からなるシーケンスのうち、\n最も長いバランスの取れた部分シーケンスの長さが 2 * k であるものの数を求めます。結果は 1,000,000,007 (10^9 + 7) で計算されるべきです。\n\n例:\n    >>> f_41(2, 2, 2)\n    2\n*/\nlong long f_41(long long n, long long m, long long k)", "ko": "#include <cassert>\n/* 세 개의 정수 n, m, k가 주어졌을 때, n개의 '('와 m개의 ')'로 구성된 시퀀스 중에서 가장 긴 균형 잡힌 부분 시퀀스의 길이가 2 * k인 경우의 수를 찾으세요. 결과는 1,000,000,007 (10^9 + 7)로 나눈 나머지로 계산되어야 합니다.\n\n예를 들어:\n    >>> f_41(2, 2, 2)\n    2\n*/\nlong long f_41(long long n, long long m, long long k)", "ml": "#include <cassert>\n/* മൂന്ന് പൂർണ്ണസംഖ്യകൾ n, m, k നൽകിയാൽ, n '('  മും m ')'  മും അടങ്ങിയ അനുക്രമങ്ങളുടെ എണ്ണം കണ്ടെത്തുക,\nഅതിൽ ഏറ്റവും നീളമുള്ള സുസ്ഥിര ഉപക്രമം 2 * k നീളമുള്ളതായിരിക്കും. ഫലം 1,000,000,007 (10^9 + 7) കൊണ്ട് മോഡുലോ കണക്കാക്കണം.\n\nഉദാഹരണത്തിന്:\n    >>> f_41(2, 2, 2)\n    2\n*/\nlong long f_41(long long n, long long m, long long k)", "fa": "#include <cassert>\n/* با توجه به سه عدد صحیح n، m و k، تعداد دنباله‌هایی را بیابید که از n '(' و m ')' تشکیل شده‌اند،\nبه طوری که طولانی‌ترین زیر دنباله متعادل دارای طول 2 * k باشد. نتیجه باید به پیمانه 1,000,000,007 (10^9 + 7) محاسبه شود.\n\nبرای مثال:\n    >>> f_41(2, 2, 2)\n    2\n*/\nlong long f_41(long long n, long long m, long long k)"}, "canonical_solution": "{\n    const long long P = static_cast<long long>(1e9) + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}", "instruction": {"en": "long long f_41(long long n, long long m, long long k)\n{\n    const long long P = static_cast<long long>(1e9) + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.", "sq": "long long f_41(long long n, long long m, long long k)\n{\n    const long long P = static_cast<long long>(1e9) + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit CPP në shqip duke përdorur maksimumi 500 karaktere.", "hy": "long long f_41(long long n, long long m, long long k)\n{\n    const long long P = static_cast<long long>(1e9) + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}\n\nՀամառոտ բնութագրեք (docstring) տրված CPP կոդը հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "long long f_41(long long n, long long m, long long k)\n{\n    const long long P = static_cast<long long>(1e9) + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}\n\nনিচের CPP কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।", "bg": "long long f_41(long long n, long long m, long long k)\n{\n    const long long P = static_cast<long long>(1e9) + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}\n\nПредоставете кратко описание на CPP кода на естествен език на български, използвайки не повече от 500 знака.", "zh": "long long f_41(long long n, long long m, long long k)\n{\n    const long long P = static_cast<long long>(1e9) + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}\n\n请用不超过500个字符的中文为以下CPP代码提供简洁的自然语言描述（文档字符串）。", "fr": "long long f_41(long long n, long long m, long long k)\n{\n    const long long P = static_cast<long long>(1e9) + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}\n\nFournissez une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.", "de": "long long f_41(long long n, long long m, long long k)\n{\n    const long long P = static_cast<long long>(1e9) + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "long long f_41(long long n, long long m, long long k)\n{\n    const long long P = static_cast<long long>(1e9) + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar CPP a cikin Hausa, ta amfani da haruffa 500 kacal.", "hi": "long long f_41(long long n, long long m, long long k)\n{\n    const long long P = static_cast<long long>(1e9) + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।", "hu": "long long f_41(long long n, long long m, long long k)\n{\n    const long long P = static_cast<long long>(1e9) + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a CPP kódról magyarul, legfeljebb 500 karakterben.", "es": "long long f_41(long long n, long long m, long long k)\n{\n    const long long P = static_cast<long long>(1e9) + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando como máximo 500 caracteres.", "arb": "long long f_41(long long n, long long m, long long k)\n{\n    const long long P = static_cast<long long>(1e9) + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C++ باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "long long f_41(long long n, long long m, long long k)\n{\n    const long long P = static_cast<long long>(1e9) + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "long long f_41(long long n, long long m, long long k)\n{\n    const long long P = static_cast<long long>(1e9) + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}\n\nAşağıdaki CPP kodunun işlevini açıklayan, en fazla 500 karakterlik özlü bir doğal dil açıklaması (docstring) sağlayın.", "vi": "long long f_41(long long n, long long m, long long k)\n{\n    const long long P = static_cast<long long>(1e9) + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự.", "id": "long long f_41(long long n, long long m, long long k)\n{\n    const long long P = static_cast<long long>(1e9) + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode CPP dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "long long f_41(long long n, long long m, long long k)\n{\n    const long long P = static_cast<long long>(1e9) + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}\n\n以下のCPPコードの自然言語による簡潔な説明（ドックストリング）を日本語で500文字以内で提供してください。", "ko": "long long f_41(long long n, long long m, long long k)\n{\n    const long long P = static_cast<long long>(1e9) + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}\n\n다음 CPP 코드에 대한 간결한 자연어 설명(도크스트링)을 한국어로 최대 500자 이내로 제공하세요.", "ml": "long long f_41(long long n, long long m, long long k)\n{\n    const long long P = static_cast<long long>(1e9) + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}\n\nസിപിപി കോഡിന്റെ സംക്ഷിപ്തമായ സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) മലയാളത്തിൽ 500 അക്ഷരങ്ങളിൽ കവിയാതെ നൽകുക.", "fa": "long long f_41(long long n, long long m, long long k)\n{\n    const long long P = static_cast<long long>(1e9) + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}\n\nتوضیح مختصر و طبیعی (docstring) از کد CPP را به زبان فارسی ارائه دهید که حداکثر ۵۰۰ کاراکتر باشد."}, "level": "", "test": "int main() {\n    assert(f_41(2, 2, 2) == 2);\n    assert(f_41(3, 2, 3) == 0);\n    assert(f_41(3, 2, 1) == 4);\n    assert(f_41(4, 3, 2) == 14);\n    assert(f_41(5, 5, 2) == 35);\n    assert(f_41(6, 1, 1) == 6);\n    assert(f_41(1, 6, 1) == 6);\n    assert(f_41(7, 2, 2) == 27);\n    assert(f_41(8, 3, 3) == 110);\n    assert(f_41(10, 10, 5) == 10659);\n    assert(f_41(20, 20, 10) == 574221648);\n    assert(f_41(2000, 2000, 1000) == 854104531);\n    assert(f_41(2000, 1999, 1000) == 334874485);\n    assert(f_41(2000, 2000, 1999) == 259428024);\n    return 0;\n}", "entry_point": "f_41", "signature": "long long f_41(long long n, long long m, long long k)", "docstring": {"en": "Given three integers n, m, and k, find the number of sequences consisting of n '(' and m ')',\nsuch that the longest balanced subsequence is of length 2 * k. The result should be calculated modulo 1,000,000,007 (10^9 + 7).\n\nFor example:\n    >>> f_41(2, 2, 2)\n    2\n", "sq": "Duke pasur tre numra të plotë n, m, dhe k, gjeni numrin e sekuencave që përbëhen nga n '(' dhe m ')',\ntë tilla që nënsekuenca më e gjatë e balancuar është me gjatësi 2 * k. Rezultati duhet të llogaritet modulo 1,000,000,007 (10^9 + 7).\n\nPër shembull:\n    >>> f_41(2, 2, 2)\n    2", "hy": "Երեք ամբողջ թիվ n, m և k ունենալով, գտնել հաջորդականությունների քանակը, որոնք բաղկացած են n '(' և m ')' նշաններից, այնպես, որ ամենաերկար հավասարակշռված ենթահաջորդականությունը լինի 2 * k երկարությամբ։ Արդյունքը պետք է հաշվել 1,000,000,007 (10^9 + 7) մոդուլով։\n\nՕրինակ:\n    >>> f_41(2, 2, 2)\n    2", "bn": "তিনটি পূর্ণসংখ্যা n, m, এবং k দেওয়া হয়েছে, n টির '(' এবং m টির ')' নিয়ে গঠিত ক্রমের সংখ্যা খুঁজে বের করুন, যাতে দীর্ঘতম সুষম উপধারা 2 * k দৈর্ঘ্যের হয়। ফলাফলটি 1,000,000,007 (10^9 + 7) দ্বারা মডুলোতে গণনা করা উচিত।\n\nউদাহরণস্বরূপ:\n    >>> f_41(2, 2, 2)\n    2", "bg": "Дадени са три цели числа n, m и k, намерете броя на последователностите, състоящи се от n '(' и m ')',\nтака че най-дългата балансирана подпоследователност да е с дължина 2 * k. Резултатът трябва да бъде изчислен по модул 1,000,000,007 (10^9 + 7).\n\nНапример:\n    >>> f_41(2, 2, 2)\n    2", "zh": "给定三个整数 n, m 和 k，找出由 n 个 '(' 和 m 个 ')' 组成的序列的数量，使得最长的平衡子序列的长度为 2 * k。结果应取模 1,000,000,007 (10^9 + 7)。\n\n例如：\n    >>> f_41(2, 2, 2)\n    2", "fr": "Étant donné trois entiers n, m, et k, trouvez le nombre de séquences constituées de n '(' et m ')', \ntelles que la plus longue sous-séquence équilibrée soit de longueur 2 * k. Le résultat doit être calculé modulo 1,000,000,007 (10^9 + 7).\n\nPar exemple :\n    >>> f_41(2, 2, 2)\n    2", "de": "Gegeben drei ganze Zahlen n, m und k, finde die Anzahl der Sequenzen, die aus n '(' und m ')' bestehen, \nso dass die längste ausgeglichene Teilsequenz die Länge 2 * k hat. Das Ergebnis sollte modulo 1.000.000.007 (10^9 + 7) berechnet werden.\n\nZum Beispiel:\n    >>> f_41(2, 2, 2)\n    2", "ha": "An ba da lambobi guda uku n, m, da k, nemo yawan jerin lambobi da suka ƙunshi n '(' da m ')', \nta yadda mafi tsawon jeri mai daidaito yana da tsawon 2 * k. Sakamakon ya kamata a ƙididdige shi modulo 1,000,000,007 (10^9 + 7).\n\nMisali:\n    >>> f_41(2, 2, 2)\n    2", "hi": "तीन पूर्णांक n, m, और k दिए गए हैं, उन अनुक्रमों की संख्या खोजें जो n '(' और m ')' से बने होते हैं, ताकि सबसे लंबा संतुलित उप-अनुक्रम 2 * k लंबाई का हो। परिणाम को 1,000,000,007 (10^9 + 7) से मापांकित करके गणना की जानी चाहिए।\n\nउदाहरण के लिए:\n    >>> f_41(2, 2, 2)\n    2", "hu": "Három egész szám, n, m és k megadása esetén találja meg az olyan sorozatok számát, amelyek n '(' és m ')' jelekből állnak, úgy, hogy a leghosszabb kiegyensúlyozott részsorozat hossza 2 * k. Az eredményt 1,000,000,007 (10^9 + 7) modulo szerint kell kiszámítani.\n\nPéldául:\n    >>> f_41(2, 2, 2)\n    2", "es": "Dado tres enteros n, m, y k, encuentra el número de secuencias que consisten en n '(' y m ')', \ntal que la subsecuencia balanceada más larga tenga una longitud de 2 * k. El resultado debe ser calculado módulo 1,000,000,007 (10^9 + 7).\n\nPor ejemplo:\n    >>> f_41(2, 2, 2)\n    2", "arb": "بالنظر إلى ثلاثة أعداد صحيحة n و m و k، ابحث عن عدد التسلسلات المكونة من n '(' و m ')',\nبحيث يكون أطول تسلسل متوازن بطول 2 * k. يجب حساب النتيجة بتقسيمها على 1,000,000,007 (10^9 + 7).\n\nعلى سبيل المثال:\n    >>> f_41(2, 2, 2)\n    2", "sw": "Kwa kupewa nambari tatu nzima n, m, na k, pata idadi ya mlolongo unaojumuisha n '(' na m ')', \nhivyo kwamba mlolongo mrefu zaidi ulio na usawa una urefu wa 2 * k. Matokeo yanapaswa kuhesabiwa kwa modulo 1,000,000,007 (10^9 + 7).\n\nKwa mfano:\n    >>> f_41(2, 2, 2)\n    2", "tr": "Üç tam sayı n, m ve k verildiğinde, n '(' ve m ')' karakterlerinden oluşan dizilerin sayısını bulun, öyle ki en uzun dengeli alt dizi uzunluğu 2 * k olsun. Sonuç 1,000,000,007 (10^9 + 7) modunda hesaplanmalıdır.\n\nÖrneğin:\n    >>> f_41(2, 2, 2)\n    2", "vi": "Được cho ba số nguyên n, m và k, tìm số lượng dãy bao gồm n dấu '(' và m dấu ')', sao cho dãy con cân bằng dài nhất có độ dài 2 * k. Kết quả nên được tính theo modulo 1,000,000,007 (10^9 + 7).\n\nVí dụ:\n    >>> f_41(2, 2, 2)\n    2", "id": "Diberikan tiga bilangan bulat n, m, dan k, temukan jumlah urutan yang terdiri dari n '(' dan m ')',\nsehingga subsekuens seimbang terpanjang memiliki panjang 2 * k. Hasilnya harus dihitung dengan modulo 1,000,000,007 (10^9 + 7).\n\nSebagai contoh:\n    >>> f_41(2, 2, 2)\n    2", "ja": "3つの整数 n、m、および k が与えられたとき、n 個の '(' と m 個の ')' からなるシーケンスのうち、最長のバランスの取れた部分列の長さが 2 * k であるものの数を求めます。結果は 1,000,000,007 (10^9 + 7) で割った余りとして計算されるべきです。\n\n例えば:\n    >>> f_41(2, 2, 2)\n    2", "ko": "세 개의 정수 n, m, k가 주어졌을 때, n개의 '('와 m개의 ')'로 구성된 시퀀스 중 가장 긴 균형 잡힌 부분 시퀀스의 길이가 2 * k인 경우의 수를 찾으세요. 결과는 1,000,000,007 (10^9 + 7)로 나눈 나머지로 계산되어야 합니다.\n\n예를 들어:\n    >>> f_41(2, 2, 2)\n    2", "ml": "മൂന്ന് പൂർണ്ണസംഖ്യകൾ n, m, k എന്നിവ നൽകിയാൽ, n '(' മുകൾക്കൂടി m ')' അടങ്ങിയ അനുബന്ധങ്ങളുടെ എണ്ണം കണ്ടെത്തുക, ഏറ്റവും നീളമുള്ള സമതുലിത ഉപക്രമം 2 * k നീളമുള്ളതാണ്. ഫലം 1,000,000,007 (10^9 + 7) മൊഡുലോയിൽ കണക്കാക്കണം.\n\nഉദാഹരണത്തിന്:\n    >>> f_41(2, 2, 2)\n    2", "fa": "با توجه به سه عدد صحیح n، m و k، تعداد دنباله‌هایی را پیدا کنید که شامل n '(' و m ')' باشند، به طوری که طولانی‌ترین زیر دنباله متوازن دارای طول 2 * k باشد. نتیجه باید به پیمانه 1,000,000,007 (10^9 + 7) محاسبه شود.\n\nبرای مثال:\n    >>> f_41(2, 2, 2)\n    2"}}
{"task_id": "CPP/42", "prompt": {"en": "#include <cassert>\n#include <cstdio>\n/**\n * Given a rectangle paper of size n x m placed on a plane Cartesian coordinate \n * system with its bottom-left corner at (0,0) and top-right corner at (n,m), \n * you need to calculate the expected number of operations to cut the paper such that \n * the remaining area is less than k. In each operation, a line is randomly chosen \n * that is parallel to the axes, passes through points with integer coordinates, \n * and cuts through (not just touching the edge) the paper. The bottom or right part \n * of the paper along this line is then discarded. The answer should be modulo 10^9+7.\n *\n * For example:\n *     >>> f_42(3, 3, 4)\n *     3\n *     >>> f_42(5, 5, 12)\n *     2\n */\nlong long f_42(int n, int m, long long k)", "sq": "#include <cassert>\n#include <cstdio>\n/**\n * Duke pasur një letër drejtkëndëshe me madhësi n x m të vendosur në një sistem \n * koordinativ Kartezian në plan me këndin e poshtëm të majtë në (0,0) dhe këndin \n * e sipërm të djathtë në (n,m), ju duhet të llogaritni numrin e pritur të operacioneve \n * për të prerë letrën në mënyrë që sipërfaqja e mbetur të jetë më pak se k. Në çdo \n * operacion, zgjidhet rastësisht një vijë që është paralele me boshtet, kalon nëpër \n * pika me koordinata të plota, dhe pret (jo vetëm prek skajin) letrën. Pjesa e poshtme \n * ose e djathtë e letrës përgjatë kësaj vije pastaj hidhet poshtë. Përgjigjja duhet të \n * jetë modulo 10^9+7.\n *\n * Për shembull:\n *     >>> f_42(3, 3, 4)\n *     3\n *     >>> f_42(5, 5, 12)\n *     2\n */\nlong long f_42(int n, int m, long long k)", "hy": "#include <cassert>\n#include <cstdio>\n/**\n * Տրված է n x m չափսի ուղղանկյուն թուղթ, որը տեղադրված է հարթության \n * Կարտեզյան կոորդինատային համակարգում՝ իր ներքևի-ձախ անկյունով (0,0) \n * կետում և վերևի-աջ անկյունով (n,m) կետում, դուք պետք է հաշվեք \n * սպասվող գործողությունների քանակը՝ թուղթը կտրելու համար այնպես, որ \n * մնացած մակերեսը լինի k-ից փոքր: Յուրաքանչյուր գործողության ժամանակ \n * պատահականորեն ընտրվում է գիծ, որը զուգահեռ է առանցքներին, անցնում է \n * ամբողջ թվային կոորդինատներով կետերով և կտրում է թուղթը (ոչ միայն \n * շոշափում է եզրը): Թղթի այս գծի երկայնքով ներքևի կամ աջ մասը \n * հեռացվում է: Պատասխանը պետք է լինի 10^9+7 մոդուլով:\n *\n * Օրինակ:\n *     >>> f_42(3, 3, 4)\n *     3\n *     >>> f_42(5, 5, 12)\n *     2\n */\nlong long f_42(int n, int m, long long k)", "bn": "#include <cassert>\n#include <cstdio>\n/**\n * একটি আয়তাকার কাগজ n x m আকারের যা একটি সমতল কার্টেসিয়ান স্থানাঙ্ক \n * পদ্ধতিতে রাখা হয়েছে যার নিচের-বাম কোণ (0,0) এবং উপরের-ডান কোণ (n,m) এ, \n * আপনাকে কাগজ কাটার প্রত্যাশিত সংখ্যক অপারেশন গণনা করতে হবে যাতে \n * অবশিষ্ট এলাকা k এর চেয়ে কম হয়। প্রতিটি অপারেশনে, একটি লাইন এলোমেলোভাবে \n * নির্বাচন করা হয় যা অক্ষের সাথে সমান্তরাল, পূর্ণসংখ্যা স্থানাঙ্ক সহ \n * বিন্দুগুলির মধ্য দিয়ে যায়, এবং কাগজের মধ্য দিয়ে কেটে যায় (শুধুমাত্র \n * প্রান্ত স্পর্শ করে না)। এই লাইনের সাথে বরাবর কাগজের নিচের বা ডান অংশ \n * তারপর বাতিল করা হয়। উত্তরটি 10^9+7 মডুলোতে হওয়া উচিত।\n *\n * উদাহরণস্বরূপ:\n *     >>> f_42(3, 3, 4)\n *     3\n *     >>> f_42(5, 5, 12)\n *     2\n */\nlong long f_42(int n, int m, long long k)", "bg": "#include <cassert>\n#include <cstdio>\n/**\n * Даден е правоъгълен лист хартия с размер n x m, поставен в равнинна \n * декартова координатна система с долния ляв ъгъл в (0,0) и горния десен ъгъл в (n,m). \n * Трябва да изчислите очаквания брой операции за рязане на хартията така, че \n * оставащата площ да е по-малка от k. При всяка операция се избира случайна линия, \n * която е успоредна на осите, преминава през точки с цели координати и \n * пресича (не само докосва ръба) хартията. Долната или дясната част на хартията \n * по тази линия след това се изхвърля. Отговорът трябва да бъде модул 10^9+7.\n *\n * Например:\n *     >>> f_42(3, 3, 4)\n *     3\n *     >>> f_42(5, 5, 12)\n *     2\n */\nlong long f_42(int n, int m, long long k)", "zh": "#include <cassert>\n#include <cstdio>\n/**\n * 给定一个大小为 n x m 的矩形纸张，放置在平面直角坐标系中，其左下角在 (0,0)，右上角在 (n,m)，\n * 需要计算切割纸张的期望操作次数，使得剩余面积小于 k。在每次操作中，随机选择一条与坐标轴平行的线，\n * 该线通过整数坐标点，并切割（不仅仅是接触边缘）纸张。沿着这条线的底部或右侧部分的纸张将被丢弃。\n * 答案应对 10^9+7 取模。\n *\n * 例如：\n *     >>> f_42(3, 3, 4)\n *     3\n *     >>> f_42(5, 5, 12)\n *     2\n */\nlong long f_42(int n, int m, long long k)", "fr": "#include <cassert>\n#include <cstdio>\n/**\n * Étant donné un papier rectangulaire de taille n x m placé sur un système de coordonnées \n * cartésiennes avec son coin inférieur gauche à (0,0) et son coin supérieur droit à (n,m), \n * vous devez calculer le nombre attendu d'opérations pour couper le papier de sorte que \n * la surface restante soit inférieure à k. À chaque opération, une ligne est choisie au hasard \n * qui est parallèle aux axes, passe par des points avec des coordonnées entières, \n * et coupe (sans se contenter de toucher le bord) le papier. La partie inférieure ou droite \n * du papier le long de cette ligne est ensuite éliminée. La réponse doit être modulo 10^9+7.\n *\n * Par exemple :\n *     >>> f_42(3, 3, 4)\n *     3\n *     >>> f_42(5, 5, 12)\n *     2\n */\nlong long f_42(int n, int m, long long k)", "de": "#include <cassert>\n#include <cstdio>\n/**\n * Gegeben ein rechteckiges Papier der Größe n x m, das in einem kartesischen Koordinatensystem \n * platziert ist, mit seiner unteren linken Ecke bei (0,0) und der oberen rechten Ecke bei (n,m), \n * müssen Sie die erwartete Anzahl von Operationen berechnen, um das Papier so zu schneiden, dass \n * die verbleibende Fläche kleiner als k ist. Bei jeder Operation wird eine Linie zufällig gewählt, \n * die parallel zu den Achsen verläuft, durch Punkte mit ganzzahligen Koordinaten geht und das Papier \n * durchschneidet (nicht nur den Rand berührt). Der untere oder rechte Teil des Papiers entlang dieser \n * Linie wird dann verworfen. Die Antwort sollte modulo 10^9+7 sein.\n *\n * Zum Beispiel:\n *     >>> f_42(3, 3, 4)\n *     3\n *     >>> f_42(5, 5, 12)\n *     2\n */\nlong long f_42(int n, int m, long long k)", "ha": "#include <cassert>\n#include <cstdio>\n/**\n * An ba takardar murabba'i mai girman n x m da aka sanya a kan tsarin daidaitawar Cartesian \n * tare da kusurwar ƙasa-hagu a (0,0) da kuma kusurwar sama-dama a (n,m), \n * kana buƙatar lissafin yawan ayyukan da ake tsammanin za a yi don yanke takardar ta yadda \n * yankin da ya rage ya zama ƙasa da k. A kowane aiki, ana zaɓar layi a bazuwar \n * wanda yake daidai da ginshiƙai, yana wucewa ta wuraren da ke da daidaitattun lambobi, \n * kuma yana yanke (ba kawai taɓa gefen ba) takardar. Ana watsar da ɓangaren ƙasa ko dama \n * na takardar tare da wannan layin. Amsar ya kamata ta zama modulo 10^9+7.\n *\n * Alal misali:\n *     >>> f_42(3, 3, 4)\n *     3\n *     >>> f_42(5, 5, 12)\n *     2\n */\nlong long f_42(int n, int m, long long k)", "hi": "#include <cassert>\n#include <cstdio>\n/**\n * दिए गए एक आयताकार कागज का आकार n x m है जो एक समतल कार्टेशियन निर्देशांक \n * प्रणाली पर रखा गया है, जिसका निचला-बायां कोना (0,0) पर है और ऊपरी-दायां कोना (n,m) पर है। \n * आपको उन ऑपरेशनों की अपेक्षित संख्या की गणना करनी है ताकि कागज का शेष क्षेत्रफल k से कम हो जाए। \n * प्रत्येक ऑपरेशन में, एक रेखा यादृच्छिक रूप से चुनी जाती है जो अक्षों के समानांतर होती है, \n * पूर्णांक निर्देशांक वाले बिंदुओं से गुजरती है, और कागज को काटती है (सिर्फ किनारे को छूती नहीं है)। \n * इस रेखा के साथ कागज का निचला या दायां हिस्सा फिर त्याग दिया जाता है। उत्तर 10^9+7 के मापांक में होना चाहिए।\n *\n * उदाहरण के लिए:\n *     >>> f_42(3, 3, 4)\n *     3\n *     >>> f_42(5, 5, 12)\n *     2\n */\nlong long f_42(int n, int m, long long k)", "hu": "#include <cassert>\n#include <cstdio>\n/**\n * Adott egy n x m méretű téglalap alakú papír, amely egy derékszögű koordináta-rendszerben \n * helyezkedik el, az alsó-bal sarka a (0,0) pontban, a jobb-felső sarka pedig az (n,m) pontban van. \n * Ki kell számítani a várható műveletek számát, hogy a papírt úgy vágjuk, hogy a megmaradt terület \n * kisebb legyen, mint k. Minden művelet során véletlenszerűen kiválasztunk egy vonalat, amely \n * párhuzamos a tengelyekkel, egész koordinátákkal rendelkező pontokon halad át, és átvágja \n * (nem csak érinti a szélét) a papírt. A papír alsó vagy jobb oldali része ezután eldobásra kerül \n * ezen a vonalon. Az eredménynek 10^9+7 modulo szerint kell lennie.\n *\n * Például:\n *     >>> f_42(3, 3, 4)\n *     3\n *     >>> f_42(5, 5, 12)\n *     2\n */\nlong long f_42(int n, int m, long long k)", "es": "#include <cassert>\n#include <cstdio>\n/**\n * Dado un papel rectangular de tamaño n x m colocado en un sistema de coordenadas \n * cartesianas en un plano, con su esquina inferior izquierda en (0,0) y la esquina \n * superior derecha en (n,m), necesitas calcular el número esperado de operaciones \n * para cortar el papel de tal manera que el área restante sea menor que k. En cada \n * operación, se elige aleatoriamente una línea que es paralela a los ejes, pasa por \n * puntos con coordenadas enteras, y corta (no solo toca el borde) el papel. La parte \n * inferior o derecha del papel a lo largo de esta línea se descarta. La respuesta \n * debe ser módulo 10^9+7.\n *\n * Por ejemplo:\n *     >>> f_42(3, 3, 4)\n *     3\n *     >>> f_42(5, 5, 12)\n *     2\n */\nlong long f_42(int n, int m, long long k)", "arb": "#include <cassert>\n#include <cstdio>\n/**\n * بالنظر إلى ورقة مستطيلة بحجم n x m موضوعة على نظام إحداثيات ديكارتي \n * على مستوى مع الزاوية السفلية اليسرى عند (0,0) والزاوية العلوية اليمنى عند (n,m)، \n * تحتاج إلى حساب العدد المتوقع من العمليات لقطع الورقة بحيث \n * تكون المساحة المتبقية أقل من k. في كل عملية، يتم اختيار خط عشوائي \n * يكون موازياً للمحاور، ويمر عبر نقاط ذات إحداثيات صحيحة، \n * ويقطع الورقة (وليس فقط لمس الحافة). يتم بعد ذلك التخلص من الجزء السفلي أو الأيمن \n * من الورقة على طول هذا الخط. يجب أن تكون الإجابة موديولو 10^9+7.\n *\n * على سبيل المثال:\n *     >>> f_42(3, 3, 4)\n *     3\n *     >>> f_42(5, 5, 12)\n *     2\n */\nlong long f_42(int n, int m, long long k)", "sw": "#include <cassert>\n#include <cstdio>\n/**\n * Ukipewa karatasi ya mstatili ya ukubwa n x m iliyowekwa kwenye mfumo wa kuratibu wa \n * Cartesian kwenye ndege na kona yake ya chini-kushoto iko kwenye (0,0) na kona ya juu-kulia \n * iko kwenye (n,m), unahitaji kuhesabu idadi inayotarajiwa ya operesheni za kukata karatasi \n * ili eneo lililobaki liwe chini ya k. Katika kila operesheni, mstari unachaguliwa kwa nasibu \n * ambao ni sambamba na mhimili, unapita kupitia pointi zenye kuratibu za nambari kamili, \n * na unakata (si kugusa tu ukingo) karatasi. Sehemu ya chini au ya kulia ya karatasi \n * kando ya mstari huu kisha inatupwa. Jibu linapaswa kuwa modulo 10^9+7.\n *\n * Kwa mfano:\n *     >>> f_42(3, 3, 4)\n *     3\n *     >>> f_42(5, 5, 12)\n *     2\n */\nlong long f_42(int n, int m, long long k)", "tr": "#include <cassert>\n#include <cstdio>\n/**\n * n x m boyutlarında bir dikdörtgen kağıt, alt-sol köşesi (0,0) ve üst-sağ köşesi (n,m) \n * olan bir Kartezyen koordinat sistemine yerleştirilmiştir. Kağıdı kesmek için gereken \n * beklenen işlem sayısını hesaplamanız gerekmektedir, böylece kalan alan k'dan küçük olur. \n * Her işlemde, eksenlere paralel, tam sayı koordinatlarına sahip noktalardan geçen ve \n * kağıdı kesen (sadece kenara dokunmayan) bir çizgi rastgele seçilir. Bu çizgi boyunca \n * kağıdın alt veya sağ kısmı atılır. Cevap 10^9+7 modunda olmalıdır.\n *\n * Örneğin:\n *     >>> f_42(3, 3, 4)\n *     3\n *     >>> f_42(5, 5, 12)\n *     2\n */\nlong long f_42(int n, int m, long long k)", "vi": "#include <cassert>\n#include <cstdio>\n/**\n * Cho một tờ giấy hình chữ nhật kích thước n x m đặt trên hệ tọa độ phẳng \n * Cartesian với góc dưới bên trái tại (0,0) và góc trên bên phải tại (n,m), \n * bạn cần tính số lượng thao tác kỳ vọng để cắt tờ giấy sao cho diện tích còn lại \n * nhỏ hơn k. Trong mỗi thao tác, một đường thẳng được chọn ngẫu nhiên \n * song song với các trục, đi qua các điểm có tọa độ nguyên, \n * và cắt qua (không chỉ chạm vào cạnh) tờ giấy. Phần dưới hoặc bên phải \n * của tờ giấy dọc theo đường này sau đó bị loại bỏ. Kết quả nên được lấy modulo 10^9+7.\n *\n * Ví dụ:\n *     >>> f_42(3, 3, 4)\n *     3\n *     >>> f_42(5, 5, 12)\n *     2\n */\nlong long f_42(int n, int m, long long k)", "id": "#include <cassert>\n#include <cstdio>\n/**\n * Diberikan selembar kertas persegi panjang berukuran n x m yang ditempatkan pada sistem koordinat Kartesius \n * dengan sudut kiri bawah di (0,0) dan sudut kanan atas di (n,m), Anda perlu menghitung jumlah operasi yang \n * diharapkan untuk memotong kertas sehingga area yang tersisa kurang dari k. Dalam setiap operasi, sebuah garis \n * dipilih secara acak yang sejajar dengan sumbu, melewati titik-titik dengan koordinat bilangan bulat, dan \n * memotong (tidak hanya menyentuh tepi) kertas. Bagian bawah atau kanan dari kertas sepanjang garis ini kemudian \n * dibuang. Jawabannya harus dalam modulo 10^9+7.\n *\n * Sebagai contoh:\n *     >>> f_42(3, 3, 4)\n *     3\n *     >>> f_42(5, 5, 12)\n *     2\n */\nlong long f_42(int n, int m, long long k)\n", "ja": "#include <cassert>\n#include <cstdio>\n/**\n * サイズ n x m の長方形の紙が平面のデカルト座標系に配置されており、\n * その左下の角が (0,0) に、右上の角が (n,m) にあるとします。\n * 残りの面積が k 未満になるように紙を切るために必要な操作の期待値を計算する必要があります。\n * 各操作では、軸に平行で整数座標を持つ点を通り、紙を切断する（端に触れるだけではない）線がランダムに選ばれます。\n * この線に沿って紙の下部または右側が捨てられます。答えは 10^9+7 で割った余りである必要があります。\n *\n * 例えば:\n *     >>> f_42(3, 3, 4)\n *     3\n *     >>> f_42(5, 5, 12)\n *     2\n */\nlong long f_42(int n, int m, long long k)\n", "ko": "#include <cassert>\n#include <cstdio>\n/**\n * 크기 n x m의 직사각형 종이가 평면 직교 좌표계에 놓여 있고, \n * 그 왼쪽 아래 모서리가 (0,0)에, 오른쪽 위 모서리가 (n,m)에 있을 때, \n * 남은 면적이 k보다 작아지도록 종이를 자르는 데 필요한 예상 작업 수를 계산해야 합니다. \n * 각 작업에서는 축에 평행하고 정수 좌표를 지나는 선이 무작위로 선택되어 \n * 종이를 자릅니다(단순히 가장자리에 닿는 것이 아님). \n * 그런 다음 이 선을 따라 종이의 아래쪽 또는 오른쪽 부분이 버려집니다. \n * 답은 10^9+7로 나눈 나머지여야 합니다.\n *\n * 예를 들어:\n *     >>> f_42(3, 3, 4)\n *     3\n *     >>> f_42(5, 5, 12)\n *     2\n */\nlong long f_42(int n, int m, long long k)\n", "ml": "#include <cassert>\n#include <cstdio>\n/**\n * n x m വലിപ്പമുള്ള ഒരു ചതുരശ്രാകൃതത്തിലുള്ള കാഗിതം (0,0) ലെ അതിന്റെ അടിഭാഗം-ഇടത് മൂലയിൽ \n * നിന്നും (n,m) ലെ മുകളിലെ-വലത് മൂലയിലേക്ക് ഒരു പ്ലെയിൻ കാർട്ടീസിയൻ കോർഡിനേറ്റ് \n * സിസ്റ്റത്തിൽ വച്ചിരിക്കുന്നതായി കണക്കാക്കുക, \n * ശേഷിക്കുന്ന വിസ്തീർണം k-ൽ കുറവായിരിക്കേണ്ടതിന്ന് കാഗിതം മുറിക്കാൻ പ്രതീക്ഷിക്കപ്പെടുന്ന \n * പ്രവർത്തനങ്ങളുടെ എണ്ണം കണക്കാക്കേണ്ടതുണ്ട്. ഓരോ പ്രവർത്തനത്തിലും, അച്ചുതണ്ടുകളോട് \n * സമാന്തരമായി, പൂർണ്ണസംഖ്യ കോർഡിനേറ്റുകളുള്ള പോയിന്റുകൾ വഴി കടന്നുപോകുന്ന, \n * കാഗിതത്തെ മുറിക്കുന്ന (വരമ്പ് മാത്രം സ്പർശിക്കുന്നതല്ല) ഒരു വരി യാദൃശ്ചികമായി തിരഞ്ഞെടുക്കപ്പെടുന്നു. \n * ഈ വരിയോടൊപ്പം കാഗിതത്തിന്റെ അടിഭാഗം അല്ലെങ്കിൽ വലത് ഭാഗം പിന്നീട് ഉപേക്ഷിക്കുന്നു. \n * ഉത്തരം 10^9+7 മോഡുലോ ആയിരിക്കണം.\n *\n * ഉദാഹരണത്തിന്:\n *     >>> f_42(3, 3, 4)\n *     3\n *     >>> f_42(5, 5, 12)\n *     2\n */\nlong long f_42(int n, int m, long long k)\n", "fa": "#include <cassert>\n#include <cstdio>\n/**\n * با توجه به یک کاغذ مستطیلی به اندازه n x m که در یک سیستم مختصات دکارتی صفحه قرار دارد\n * با گوشه پایین-چپ آن در (0,0) و گوشه بالا-راست آن در (n,m)،\n * شما باید تعداد عملیات‌های مورد انتظار برای برش کاغذ را محاسبه کنید به طوری که\n * مساحت باقی‌مانده کمتر از k باشد. در هر عملیات، یک خط به صورت تصادفی انتخاب می‌شود\n * که موازی با محورها است، از نقاط با مختصات صحیح عبور می‌کند،\n * و از کاغذ عبور می‌کند (نه فقط لبه را لمس کند). بخش پایین یا راست کاغذ در امتداد این خط\n * سپس دور انداخته می‌شود. پاسخ باید به صورت مدولوی 10^9+7 باشد.\n *\n * برای مثال:\n *     >>> f_42(3, 3, 4)\n *     3\n *     >>> f_42(5, 5, 12)\n *     2\n */\nlong long f_42(int n, int m, long long k)\n"}, "canonical_solution": "{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n\n    if (k > (long long)n * m) {\n        return 0;\n    }\n\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}", "instruction": {"en": "long long f_42(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n\n    if (k > (long long)n * m) {\n        return 0;\n    }\n\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.", "sq": "long long f_42(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n\n    if (k > (long long)n * m) {\n        return 0;\n    }\n\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}\n\nSiguroni një përshkrim të shkurtër në gjuhën natyrore (docstring) të kodit CPP në shqip duke përdorur maksimumi 500 karaktere.", "hy": "long long f_42(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n\n    if (k > (long long)n * m) {\n        return 0;\n    }\n\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}\n\nՀամաձայն CPP կոդի, տրամադրել կարճ բնութագիր (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "long long f_42(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n\n    if (k > (long long)n * m) {\n        return 0;\n    }\n\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}\n\nসিপিপি কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।", "bg": "long long f_42(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n\n    if (k > (long long)n * m) {\n        return 0;\n    }\n\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}\n\nПредоставете кратко описание на CPP кода на български език, използвайки не повече от 500 знака.", "zh": "long long f_42(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n\n    if (k > (long long)n * m) {\n        return 0;\n    }\n\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}\n\n将以下CPP代码的功能描述为简洁的自然语言（文档字符串），使用不超过500个字符的中文。", "fr": "long long f_42(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n\n    if (k > (long long)n * m) {\n        return 0;\n    }\n\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}\n\nFournissez une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.", "de": "long long f_42(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n\n    if (k > (long long)n * m) {\n        return 0;\n    }\n\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "long long f_42(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n\n    if (k > (long long)n * m) {\n        return 0;\n    }\n\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}\n\nBa da takaitaccen bayani a cikin yaren halitta (docstring) na lambar CPP a cikin Hausa ta amfani da haruffa 500 kacal.", "hi": "long long f_42(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n\n    if (k > (long long)n * m) {\n        return 0;\n    }\n\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "long long f_42(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n\n    if (k > (long long)n * m) {\n        return 0;\n    }\n\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a CPP kódhoz magyarul, legfeljebb 500 karakterben.", "es": "long long f_42(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n\n    if (k > (long long)n * m) {\n        return 0;\n    }\n\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando como máximo 500 caracteres.", "arb": "long long f_42(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n\n    if (k > (long long)n * m) {\n        return 0;\n    }\n\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية بلغة C++ باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "long long f_42(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n\n    if (k > (long long)n * m) {\n        return 0;\n    }\n\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "long long f_42(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n\n    if (k > (long long)n * m) {\n        return 0;\n    }\n\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}\n\nAşağıdaki CPP kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda bir doğal dil açıklaması (docstring) sağlayın.", "vi": "long long f_42(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n\n    if (k > (long long)n * m) {\n        return 0;\n    }\n\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự.", "id": "long long f_42(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n\n    if (k > (long long)n * m) {\n        return 0;\n    }\n\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode CPP dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "long long f_42(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n\n    if (k > (long long)n * m) {\n        return 0;\n    }\n\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}\n\n以下のCPPコードの簡潔な自然言語による説明（ドックストリング）を日本語で500文字以内で提供してください。", "ko": "long long f_42(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n\n    if (k > (long long)n * m) {\n        return 0;\n    }\n\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}\n\n다음 CPP 코드의 동작을 간결하게 설명하는 자연어 설명(도크스트링)을 한국어로 작성하세요. 최대 500자까지 가능합니다.", "ml": "long long f_42(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n\n    if (k > (long long)n * m) {\n        return 0;\n    }\n\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}\n\nസിപിപി കോഡ് ഉപയോഗിച്ച് 500 അക്ഷരങ്ങളിൽ കൂടാതെയുള്ള സംക്ഷിപ്തമായ സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) മലയാളത്തിൽ നൽകുക.", "fa": "long long f_42(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n\n    if (k > (long long)n * m) {\n        return 0;\n    }\n\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}\n\nتوضیح مختصر و طبیعی (docstring) از کد CPP را به زبان فارسی ارائه دهید که حداکثر ۵۰۰ کاراکتر باشد."}, "level": "", "test": "int main() {\n    assert(f_42(2, 4, 10) == 0);\n    assert(f_42(2, 4, 8) == 1);\n    assert(f_42(2, 4, 2) == 833333342);\n    assert(f_42(2, 4, 6) == 250000003);\n    assert(f_42(3, 3, 4) == 666666673);\n    assert(f_42(5, 5, 12) == 666666673);\n    assert(f_42(6, 7, 20) == 722222229);\n    assert(f_42(8, 8, 30) == 72727275);\n    assert(f_42(10, 10, 50) == 714285721);\n    assert(f_42(1, 10, 5) == 945634929);\n    assert(f_42(10, 1, 5) == 945634929);\n    return 0;\n}", "entry_point": "f_42", "signature": "long long f_42(int n, int m, long long k)", "docstring": {"en": "Given a rectangle paper of size n x m placed on a plane Cartesian coordinate \n system with its bottom-left corner at (0,0) and top-right corner at (n,m), \n you need to calculate the expected number of operations to cut the paper such that \n the remaining area is less than k. In each operation, a line is randomly chosen \n that is parallel to the axes, passes through points with integer coordinates, \n and cuts through (not just touching the edge) the paper. The bottom or right part \n of the paper along this line is then discarded. The answer should be modulo 10^9+7.\n\nFor example:\n    >>> f_42(3, 3, 4)\n    3\n    >>> f_42(5, 5, 12)\n    2\n", "sq": "Duke pasur një letër drejtkëndëshe me madhësi n x m të vendosur në një sistem koordinativ Kartesian të planit me këndin e poshtëm të majtë në (0,0) dhe këndin e sipërm të djathtë në (n,m), ju duhet të llogaritni numrin e pritur të operacioneve për të prerë letrën në mënyrë që sipërfaqja e mbetur të jetë më pak se k. Në secilën operacion, një vijë zgjidhet rastësisht që është paralele me boshtet, kalon nëpër pika me koordinata të plota, dhe pret (jo vetëm prek buzën) letrën. Pjesa e poshtme ose e djathtë e letrës përgjatë kësaj vije pastaj hidhet. Përgjigjja duhet të jetë modulo 10^9+7.\n\nPër shembull:\n    >>> f_42(3, 3, 4)\n    3\n    >>> f_42(5, 5, 12)\n    2", "hy": "Ունենալով n x m չափսի ուղղանկյուն թուղթ, որը տեղադրված է հարթ Cartesian կոորդինատային \nհամակարգում՝ իր ներքևի ձախ անկյունը (0,0) կետում և վերևի աջ անկյունը (n,m) կետում, \nպետք է հաշվարկել սպասվող գործողությունների քանակը, որպեսզի կտրենք թուղթը այնպես, որ \nմնացած մակերեսը լինի փոքր քան k: Յուրաքանչյուր գործողության ժամանակ պատահականորեն ընտրվում է \nգիծ, որը զուգահեռ է առանցքներին, անցնում է ամբողջ թվային կոորդինատներով կետերով, \nև կտրում է (ոչ միայն հպվում է եզրին) թուղթը: Թղթի այդ գծի երկայնքով ներքևի կամ աջ մասը \nապա հեռացվում է: Պատասխանը պետք է լինի 10^9+7 մոդուլով:\n\nՕրինակ:\n    >>> f_42(3, 3, 4)\n    3\n    >>> f_42(5, 5, 12)\n    2", "bn": "দেওয়া একটি আয়তাকার কাগজের আকার n x m যা একটি সমতল কার্টেসিয়ান স্থানাঙ্ক ব্যবস্থায় স্থাপন করা হয়েছে, যার নিচের-বাম কোণ (0,0) এবং উপরের-ডান কোণ (n,m) এ রয়েছে, আপনাকে কাগজ কাটার প্রত্যাশিত সংখ্যক অপারেশন গণনা করতে হবে যাতে অবশিষ্ট এলাকা k এর চেয়ে কম হয়। প্রতিটি অপারেশনে, একটি লাইন এলোমেলোভাবে বেছে নেওয়া হয় যা অক্ষগুলোর সমান্তরাল, পূর্ণসংখ্যা স্থানাঙ্ক সহ বিন্দুগুলির মধ্য দিয়ে যায়, এবং কাগজের মধ্য দিয়ে কেটে যায় (শুধুমাত্র প্রান্ত স্পর্শ নয়)। এই লাইনের সাথে কাগজের নিচের বা ডান দিকের অংশটি তারপর বাতিল করা হয়। উত্তরটি 10^9+7 মডুলোতে হওয়া উচিত।\n\nউদাহরণস্বরূপ:\n    >>> f_42(3, 3, 4)\n    3\n    >>> f_42(5, 5, 12)\n    2", "bg": "Даден е правоъгълен лист хартия с размер n x m, разположен в равнинна \nдекартова координатна система с долен ляв ъгъл в (0,0) и горен десен ъгъл в (n,m). \nТрябва да изчислите очаквания брой операции за изрязване на хартията така, че \nоставащата площ да е по-малка от k. При всяка операция се избира произволна линия, \nкоято е успоредна на осите, минава през точки с цели координати и пресича (не само \nдокосва ръба) хартията. Долната или дясната част на хартията по тази линия след това \nсе изхвърля. Отговорът трябва да бъде модул 10^9+7.\n\nПример:\n    >>> f_42(3, 3, 4)\n    3\n    >>> f_42(5, 5, 12)\n    2", "zh": "给定一个大小为 n x m 的矩形纸张，放置在平面直角坐标系中，其左下角在 (0,0) 位置，右上角在 (n,m) 位置，你需要计算切割纸张的期望操作次数，使得剩余面积小于 k。在每次操作中，随机选择一条与坐标轴平行的直线，该直线通过整数坐标的点，并切割（不仅仅是触及边缘）纸张。沿着这条线的纸张底部或右侧部分将被丢弃。答案应取模 10^9+7。\n\n例如：\n    >>> f_42(3, 3, 4)\n    3\n    >>> f_42(5, 5, 12)\n    2", "fr": "Étant donné un papier rectangulaire de taille n x m placé sur un système de coordonnées \ncartésiennes plan avec son coin inférieur gauche à (0,0) et son coin supérieur droit à (n,m), \nvous devez calculer le nombre attendu d'opérations pour couper le papier de sorte que \nla surface restante soit inférieure à k. À chaque opération, une ligne est choisie au hasard \nqui est parallèle aux axes, passe par des points avec des coordonnées entières, \net coupe (ne fait pas que toucher le bord) le papier. La partie inférieure ou droite \ndu papier le long de cette ligne est ensuite jetée. La réponse doit être modulo 10^9+7.\n\nPar exemple :\n    >>> f_42(3, 3, 4)\n    3\n    >>> f_42(5, 5, 12)\n    2", "de": "Gegeben ein rechteckiges Papier der Größe n x m, das auf einem kartesischen Koordinatensystem liegt, mit seiner unteren linken Ecke bei (0,0) und der oberen rechten Ecke bei (n,m), müssen Sie die erwartete Anzahl von Operationen berechnen, um das Papier so zu schneiden, dass die verbleibende Fläche kleiner als k ist. Bei jeder Operation wird zufällig eine Linie gewählt, die parallel zu den Achsen verläuft, durch Punkte mit ganzzahligen Koordinaten geht und das Papier durchschneidet (nicht nur den Rand berührt). Der untere oder rechte Teil des Papiers entlang dieser Linie wird dann verworfen. Die Antwort sollte modulo 10^9+7 sein.\n\nZum Beispiel:\n    >>> f_42(3, 3, 4)\n    3\n    >>> f_42(5, 5, 12)\n    2", "ha": "An ba takarda rectangle mai girman n x m da aka sanya a kan tsarin daidaitawa na Cartesian tare da kusurwar ƙasa-hagu a (0,0) da kuma kusurwar sama-dama a (n,m), kana buƙatar ƙididdige adadin ayyukan da ake tsammani don yanke takardar ta yadda yankin da ya rage ya zama ƙasa da k. A kowane aiki, ana zaɓar layi a bazuwar wanda yake daidai da ginshiƙai, yana wucewa ta wuraren da ke da daidaitattun lambobi, kuma yana yanke (ba kawai taɓa gefen ba) takardar. Ana watsar da ɓangaren ƙasa ko dama na takardar tare da wannan layin. Amsar ya kamata ta zama modulo 10^9+7.\n\nMisali:\n    >>> f_42(3, 3, 4)\n    3\n    >>> f_42(5, 5, 12)\n    2", "hi": "दिया गया एक आयताकार कागज जिसका आकार n x m है, एक समतल कार्टेशियन निर्देशांक प्रणाली पर रखा गया है, जिसकी निचली-बाएँ कोना (0,0) पर है और ऊपरी-दाएँ कोना (n,m) पर है। आपको कागज को इस तरह से काटने के लिए अपेक्षित संचालन की संख्या की गणना करनी है कि शेष क्षेत्रफल k से कम हो। प्रत्येक संचालन में, एक रेखा यादृच्छिक रूप से चुनी जाती है जो अक्षों के समानांतर होती है, पूर्णांक निर्देशांक वाले बिंदुओं से गुजरती है, और कागज को काटती है (सिर्फ किनारे को छूने तक नहीं)। इस रेखा के साथ कागज का निचला या दायाँ भाग तब हटा दिया जाता है। उत्तर को 10^9+7 के मापांक में होना चाहिए।\n\nउदाहरण के लिए:\n    >>> f_42(3, 3, 4)\n    3\n    >>> f_42(5, 5, 12)\n    2", "hu": "Adott egy n x m méretű téglalap alakú papír, amely egy síkbeli derékszögű koordináta-rendszerben helyezkedik el, az alsó-bal sarka a (0,0) pontban, a felső-jobb sarka pedig az (n,m) pontban van. Ki kell számítani a várható műveletek számát ahhoz, hogy a papírt úgy vágjuk el, hogy a megmaradt terület kisebb legyen, mint k. Minden művelet során véletlenszerűen választunk egy vonalat, amely párhuzamos a tengelyekkel, egész koordinátájú pontokon halad át, és átvágja (nem csak érinti a szélét) a papírt. A papír ezen vonal mentén lévő alsó vagy jobb része ezután eldobásra kerül. Az eredményt 10^9+7 modullal kell megadni.\n\nPéldául:\n    >>> f_42(3, 3, 4)\n    3\n    >>> f_42(5, 5, 12)\n    2", "es": "Dado un papel rectangular de tamaño n x m colocado en un sistema de coordenadas \ncartesianas en un plano, con su esquina inferior izquierda en (0,0) y la esquina superior derecha en (n,m), \nnecesitas calcular el número esperado de operaciones para cortar el papel de tal manera que \nel área restante sea menor que k. En cada operación, se elige aleatoriamente una línea \nque es paralela a los ejes, pasa por puntos con coordenadas enteras, \ny corta (no solo toca el borde) el papel. La parte inferior o derecha \ndel papel a lo largo de esta línea se descarta. La respuesta debe ser módulo 10^9+7.\n\nPor ejemplo:\n    >>> f_42(3, 3, 4)\n    3\n    >>> f_42(5, 5, 12)\n    2", "arb": "معطى ورقة مستطيلة بحجم n x m موضوعة على نظام إحداثيات ديكارتي مستوي مع الزاوية السفلية اليسرى عند (0,0) والزاوية العلوية اليمنى عند (n,m)، تحتاج إلى حساب العدد المتوقع من العمليات لقطع الورقة بحيث تكون المساحة المتبقية أقل من k. في كل عملية، يتم اختيار خط عشوائي موازٍ للمحاور، يمر عبر نقاط ذات إحداثيات صحيحة، ويقطع (وليس فقط يلامس الحافة) الورقة. يتم بعد ذلك التخلص من الجزء السفلي أو الأيمن من الورقة على طول هذا الخط. يجب أن تكون الإجابة موديولو 10^9+7.\n\nعلى سبيل المثال:\n    >>> f_42(3, 3, 4)\n    3\n    >>> f_42(5, 5, 12)\n    2", "sw": "Ukipata karatasi ya mstatili ya ukubwa n x m iliyowekwa kwenye mfumo wa kuratibu wa Cartesian kwenye ndege na kona yake ya chini-kushoto iko kwenye (0,0) na kona ya juu-kulia iko kwenye (n,m), unahitaji kuhesabu idadi inayotarajiwa ya operesheni za kukata karatasi hiyo ili eneo lililosalia liwe chini ya k. Katika kila operesheni, mstari unachaguliwa kwa nasibu ambao ni sambamba na mhimili, unapita kwenye pointi zenye kuratibu za nambari kamili, na unakata (sio kugusa tu ukingo) karatasi hiyo. Sehemu ya chini au ya kulia ya karatasi kando ya mstari huu kisha hutupwa. Jibu linapaswa kuwa moduli 10^9+7.\n\nKwa mfano:\n    >>> f_42(3, 3, 4)\n    3\n    >>> f_42(5, 5, 12)\n    2", "tr": "Verilen bir dikdörtgen kağıt, (0,0) noktasında sol alt köşesi ve (n,m) noktasında sağ üst köşesi olan bir düzlem Kartezyen koordinat sistemine yerleştirilmiştir. Kağıdın kalan alanının k'dan küçük olması için gereken beklenen işlem sayısını hesaplamanız gerekmektedir. Her işlemde, eksenlere paralel, tam sayı koordinatlarına sahip noktalardan geçen ve kağıdı kesen (sadece kenara dokunmayan) bir çizgi rastgele seçilir. Bu çizgi boyunca kağıdın alt veya sağ kısmı atılır. Cevap 10^9+7 modunda olmalıdır.\n\nÖrneğin:\n    >>> f_42(3, 3, 4)\n    3\n    >>> f_42(5, 5, 12)\n    2", "vi": "Cho một tờ giấy hình chữ nhật kích thước n x m đặt trên hệ tọa độ Đề-các phẳng với góc dưới bên trái tại (0,0) và góc trên bên phải tại (n,m), bạn cần tính số lần cắt dự kiến để cắt tờ giấy sao cho diện tích còn lại nhỏ hơn k. Trong mỗi lần cắt, một đường thẳng được chọn ngẫu nhiên song song với các trục, đi qua các điểm có tọa độ nguyên và cắt qua (không chỉ chạm vào cạnh) tờ giấy. Phần dưới hoặc bên phải của tờ giấy dọc theo đường này sau đó bị loại bỏ. Câu trả lời phải được lấy modulo 10^9+7.\n\nVí dụ:\n    >>> f_42(3, 3, 4)\n    3\n    >>> f_42(5, 5, 12)\n    2", "id": "Diberikan selembar kertas berbentuk persegi panjang berukuran n x m yang ditempatkan pada sistem koordinat Kartesius dengan sudut kiri bawah di (0,0) dan sudut kanan atas di (n,m), Anda perlu menghitung jumlah operasi yang diharapkan untuk memotong kertas sehingga area yang tersisa kurang dari k. Dalam setiap operasi, sebuah garis dipilih secara acak yang sejajar dengan sumbu, melewati titik-titik dengan koordinat bilangan bulat, dan memotong (bukan hanya menyentuh tepi) kertas. Bagian bawah atau kanan kertas sepanjang garis ini kemudian dibuang. Jawabannya harus dalam modulo 10^9+7.\n\nSebagai contoh:\n    >>> f_42(3, 3, 4)\n    3\n    >>> f_42(5, 5, 12)\n    2", "ja": "長方形の紙が n x m のサイズで、平面のデカルト座標系において左下の角が (0,0)、右上の角が (n,m) に配置されています。この紙を切る操作を行い、残りの面積が k 未満になるまでの期待される操作回数を計算する必要があります。各操作では、軸に平行で、整数座標を持つ点を通り、紙を（端に触れるだけでなく）切断する線がランダムに選ばれます。この線に沿った紙の下部または右側が廃棄されます。答えは 10^9+7 での剰余として求める必要があります。\n\n例えば:\n    >>> f_42(3, 3, 4)\n    3\n    >>> f_42(5, 5, 12)\n    2", "ko": "주어진 크기 n x m의 직사각형 종이가 평면 직교 좌표계에 놓여 있으며, \n그의 왼쪽 아래 모서리는 (0,0)에, 오른쪽 위 모서리는 (n,m)에 있습니다. \n남은 면적이 k보다 작아지도록 종이를 자르는 작업의 기대 횟수를 계산해야 합니다. \n각 작업에서는 축에 평행하고 정수 좌표를 지나는 선이 무작위로 선택되어 \n종이를 자릅니다(가장자리를 단순히 접하는 것이 아님). \n이 선을 따라 종이의 아래쪽 또는 오른쪽 부분이 버려집니다. \n답은 10^9+7로 나눈 나머지여야 합니다.\n\n예를 들어:\n    >>> f_42(3, 3, 4)\n    3\n    >>> f_42(5, 5, 12)\n    2", "ml": "നിർദ്ദിഷ്ട n x m വലുപ്പമുള്ള ഒരു ചതുരശ്ര കാഗിതം (0,0) ൽ താഴത്തെ ഇടത് കോണിലും (n,m) ൽ മുകളിൽ വലത് കോണിലും ഉള്ള പ്ലെയിൻ കാർട്ടീഷ്യൻ കോഓർഡിനേറ്റ് സിസ്റ്റത്തിൽ സ്ഥാപിച്ചിരിക്കുമ്പോൾ, ശേഷിക്കുന്ന വിസ്തീർണം k-ൽ കുറവായിരിക്കാനായി കട്ടിയെടുക്കുന്നതിനുള്ള പ്രതീക്ഷിക്കുന്ന പ്രവർത്തനങ്ങളുടെ എണ്ണം കണക്കാക്കേണ്ടതുണ്ട്. ഓരോ പ്രവർത്തനത്തിലും, അക്ഷങ്ങളോട് സമാന്തരമായ, പൂർണ്ണസംഖ്യാ കോഓർഡിനേറ്റുകളുള്ള പോയിന്റുകൾ വഴി കടന്നുപോകുന്ന ഒരു വരി യാദൃശ്ചികമായി തിരഞ്ഞെടുക്കപ്പെടുന്നു, ഇത് കാഗിതത്തിന്റെ അറ്റം മാത്രമല്ല, മറിച്ച് കട്ടിയെടുക്കുന്നു. ഈ വരിയോടൊപ്പം കാഗിതത്തിന്റെ താഴത്തെ അല്ലെങ്കിൽ വലത് ഭാഗം പിന്നീട് ഉപേക്ഷിക്കുന്നു. ഉത്തരം 10^9+7-ന്റെ മോഡുലോ ആയിരിക്കണം.\n\nഉദാഹരണത്തിന്:\n    >>> f_42(3, 3, 4)\n    3\n    >>> f_42(5, 5, 12)\n    2", "fa": "با توجه به یک کاغذ مستطیلی به ابعاد n x m که در یک سیستم مختصات دکارتی صفحه قرار گرفته است و گوشه پایین-چپ آن در نقطه (0,0) و گوشه بالا-راست آن در نقطه (n,m) قرار دارد، شما باید تعداد مورد انتظار عملیات‌ها را محاسبه کنید تا کاغذ به گونه‌ای بریده شود که مساحت باقی‌مانده کمتر از k باشد. در هر عملیات، یک خط به صورت تصادفی انتخاب می‌شود که موازی با محور‌ها است، از نقاط با مختصات صحیح عبور می‌کند و از کاغذ عبور می‌کند (نه فقط لبه را لمس کند). قسمت پایین یا راست کاغذ در امتداد این خط سپس دور انداخته می‌شود. پاسخ باید به پیمانه 10^9+7 باشد.\n\nبرای مثال:\n    >>> f_42(3, 3, 4)\n    3\n    >>> f_42(5, 5, 12)\n    2"}}
{"task_id": "CPP/43", "prompt": {"en": "#include <bits/stdc++.h>\n/*\nGiven a permutation q of n elements and an integer k, find the number of permutations p of n elements such that f(p) = q, where f(p) is the lexicographically smallest permutation that can be obtained by dividing p into exactly k non-empty contiguous segments and sorting each segment (i.e., choose k-1 breakpoints 1 <= x_1 < x_2 < ... < x_{k-1} < n, and divide it into [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). The result should be modulo 998244353.\n\n    >>> f_43(2, 1, [1, 2])\n    2\n\n*/\nint f_43(int n, int k, int qq[])", "sq": "#include <bits/stdc++.h>\n/*\nDuke pasur një permutacion q të n elementeve dhe një numër të plotë k, gjeni numrin e permutacioneve p të n elementeve të tilla që f(p) = q, ku f(p) është permutacioni më i vogël leksikografik që mund të merret duke ndarë p në saktësisht k segmente të pandryshuara dhe duke renditur secilin segment (dmth, zgjidhni k-1 pika ndarëse 1 <= x_1 < x_2 < ... < x_{k-1} < n, dhe ndajeni në [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). Rezultati duhet të jetë modulo 998244353.\n\n    >>> f_43(2, 1, [1, 2])\n    2\n\n*/\nint f_43(int n, int k, int qq[])", "hy": "#include <bits/stdc++.h>\n/*\nՈւնենալով n տարրերի q փոխատեղում և k ամբողջ թիվ, գտնել n տարրերի p փոխատեղումների քանակը, այնպես, որ f(p) = q, որտեղ f(p)-ն լեքսիկոգրաֆիկորեն ամենափոքր փոխատեղումն է, որը կարելի է ստանալ p-ն ճշգրիտ k ոչ դատարկ հարակից հատվածների բաժանելով և յուրաքանչյուր հատվածը դասավորելով (այսինքն՝ ընտրել k-1 բաժանման կետեր 1 <= x_1 < x_2 < ... < x_{k-1} < n, և բաժանել այն [1, x_1], (x_1, x_2], ..., (x_{k-1}, n] հատվածների): Արդյունքը պետք է լինի 998244353 մոդուլով:\n\n    >>> f_43(2, 1, [1, 2])\n    2\n\n*/\nint f_43(int n, int k, int qq[])", "bn": "#include <bits/stdc++.h>\n/*\nএকটি n উপাদানের permutation q এবং একটি পূর্ণসংখ্যা k দেওয়া আছে, n উপাদানের কতগুলি permutation p আছে তা খুঁজে বের করুন যাতে f(p) = q, যেখানে f(p) হল বর্ণানুক্রমিকভাবে সবচেয়ে ছোট permutation যা p কে ঠিক k টি খালি নয় এমন ধারাবাহিক segment এ ভাগ করে এবং প্রতিটি segment কে সাজিয়ে পাওয়া যায় (অর্থাৎ, k-1 টি breakpoint নির্বাচন করুন 1 <= x_1 < x_2 < ... < x_{k-1} < n, এবং এটিকে [1, x_1], (x_1, x_2], ..., (x_{k-1}, n] এ ভাগ করুন)। ফলাফলটি 998244353 দ্বারা মডুলো করা উচিত।\n\n    >>> f_43(2, 1, [1, 2])\n    2\n\n*/\nint f_43(int n, int k, int qq[])", "bg": "#include <bits/stdc++.h>\n/*\nДадена е пермутация q от n елемента и цяло число k, намерете броя на пермутациите p от n елемента, такива че f(p) = q, където f(p) е лексикографски най-малката пермутация, която може да се получи, като се раздели p на точно k непразни съседни сегмента и се сортира всеки сегмент (т.е. изберете k-1 точки на прекъсване 1 <= x_1 < x_2 < ... < x_{k-1} < n, и го разделете на [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). Резултатът трябва да бъде модуло 998244353.\n\n    >>> f_43(2, 1, [1, 2])\n    2\n\n*/\nint f_43(int n, int k, int qq[])", "zh": "#include <bits/stdc++.h>\n/*\n给定一个由 n 个元素组成的排列 q 和一个整数 k，找出有多少个 n 元素的排列 p 使得 f(p) = q，其中 f(p) 是通过将 p 分成恰好 k 个非空连续段并对每个段进行排序（即选择 k-1 个断点 1 <= x_1 < x_2 < ... < x_{k-1} < n，并将其划分为 [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]）可以获得的字典序最小的排列。结果应对 998244353 取模。\n\n    >>> f_43(2, 1, [1, 2])\n    2\n\n*/\nint f_43(int n, int k, int qq[])", "fr": "#include <bits/stdc++.h>\n/*\nÉtant donné une permutation q de n éléments et un entier k, trouvez le nombre de permutations p de n éléments tel que f(p) = q, où f(p) est la permutation lexicographiquement la plus petite qui peut être obtenue en divisant p en exactement k segments contigus non vides et en triant chaque segment (c'est-à-dire, choisir k-1 points de rupture 1 <= x_1 < x_2 < ... < x_{k-1} < n, et le diviser en [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). Le résultat doit être modulo 998244353.\n\n    >>> f_43(2, 1, [1, 2])\n    2\n\n*/\nint f_43(int n, int k, int qq[])", "de": "#include <bits/stdc++.h>\n/*\nGegeben eine Permutation q von n Elementen und eine ganze Zahl k, finde die Anzahl der Permutationen p von n Elementen, so dass f(p) = q, wobei f(p) die lexikographisch kleinste Permutation ist, die durch Aufteilen von p in genau k nicht-leere zusammenhängende Segmente und Sortieren jedes Segments erhalten werden kann (d.h., wähle k-1 Trennpunkte 1 <= x_1 < x_2 < ... < x_{k-1} < n, und teile es in [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). Das Ergebnis sollte modulo 998244353 sein.\n\n    >>> f_43(2, 1, [1, 2])\n    2\n\n*/\nint f_43(int n, int k, int qq[])", "ha": "#include <bits/stdc++.h>\n/*\nAn ba da permutation q na abubuwa n da kuma lamba k, nemo yawan permutations p na abubuwa n inda f(p) = q, inda f(p) shine mafi ƙarancin permutation a cikin tsarin haruffa wanda za a iya samu ta hanyar raba p zuwa daidai k sassa masu cike da abubuwa masu jere kuma a tsara kowanne sashe (wato, zaɓi k-1 wuraren tsagewa 1 <= x_1 < x_2 < ... < x_{k-1} < n, kuma a raba shi zuwa [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). Sakamakon ya zama modulo 998244353.\n\n    >>> f_43(2, 1, [1, 2])\n    2\n\n*/\nint f_43(int n, int k, int qq[])", "hi": "#include <bits/stdc++.h>\n/*\nदिए गए n तत्वों के एक क्रमचय q और एक पूर्णांक k के लिए, n तत्वों के क्रमचयों की संख्या खोजें p ताकि f(p) = q, जहाँ f(p) वह शब्दकोशानुसार सबसे छोटी क्रमचय है जो p को ठीक k गैर-खाली निरंतर खंडों में विभाजित करके और प्रत्येक खंड को क्रमबद्ध करके प्राप्त की जा सकती है (अर्थात्, k-1 ब्रेकपॉइंट्स चुनें 1 <= x_1 < x_2 < ... < x_{k-1} < n, और इसे [1, x_1], (x_1, x_2], ..., (x_{k-1}, n] में विभाजित करें)। परिणाम 998244353 के मापांक में होना चाहिए।\n\n    >>> f_43(2, 1, [1, 2])\n    2\n\n*/\nint f_43(int n, int k, int qq[])", "hu": "#include <bits/stdc++.h>\n/*\nAdott egy q permutáció n elemről és egy egész szám k, találd meg azon p permutációk számát n elemről, amelyekre f(p) = q, ahol f(p) az a lexikográfiailag legkisebb permutáció, amelyet úgy kapunk, hogy p-t pontosan k nem üres, összefüggő szegmensre osztjuk és minden szegmenst sorba rendezünk (azaz válasszunk k-1 töréspontot 1 <= x_1 < x_2 < ... < x_{k-1} < n, és osszuk fel [1, x_1], (x_1, x_2], ..., (x_{k-1}, n] részekre). Az eredménynek modulo 998244353 kell lennie.\n\n    >>> f_43(2, 1, [1, 2])\n    2\n\n*/\nint f_43(int n, int k, int qq[])", "es": "#include <bits/stdc++.h>\n/*\nDada una permutación q de n elementos y un entero k, encuentra el número de permutaciones p de n elementos tal que f(p) = q, donde f(p) es la permutación lexicográficamente más pequeña que se puede obtener dividiendo p en exactamente k segmentos contiguos no vacíos y ordenando cada segmento (es decir, elige k-1 puntos de corte 1 <= x_1 < x_2 < ... < x_{k-1} < n, y divídelo en [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). El resultado debe ser módulo 998244353.\n\n    >>> f_43(2, 1, [1, 2])\n    2\n\n*/\nint f_43(int n, int k, int qq[])", "arb": "#include <bits/stdc++.h>\n/*\nمعطى تبديل q لعدد n من العناصر وعدد صحيح k، ابحث عن عدد التبديلات p لعدد n من العناصر بحيث يكون f(p) = q، حيث أن f(p) هو التبديل الأصغر لغوياً الذي يمكن الحصول عليه عن طريق تقسيم p إلى k مقاطع متجاورة غير فارغة بالضبط وترتيب كل مقطع (أي اختيار k-1 نقاط تقسيم 1 <= x_1 < x_2 < ... < x_{k-1} < n، وتقسيمه إلى [1, x_1]، (x_1, x_2]، ...، (x_{k-1}, n]). يجب أن تكون النتيجة موديولو 998244353.\n\n    >>> f_43(2, 1, [1, 2])\n    2\n\n*/\nint f_43(int n, int k, int qq[])", "sw": "#include <bits/stdc++.h>\n/*\nUkipiwa mpangilio q wa vipengele n na nambari k, pata idadi ya mipangilio p ya vipengele n kama f(p) = q, ambapo f(p) ni mpangilio mdogo zaidi kwa mpangilio wa lexicographically ambao unaweza kupatikana kwa kugawanya p katika sehemu k zisizo tupu na kupanga kila sehemu (yaani, chagua sehemu k-1 za kuvunja 1 <= x_1 < x_2 < ... < x_{k-1} < n, na igawanye katika [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). Matokeo yanapaswa kuwa modulo 998244353.\n\n    >>> f_43(2, 1, [1, 2])\n    2\n\n*/\nint f_43(int n, int k, int qq[])", "tr": "#include <bits/stdc++.h>\n/*\nn elemanlı bir q permütasyonu ve bir k tam sayısı verildiğinde, f(p) = q olacak şekilde n elemanlı kaç tane p permütasyonu olduğunu bulun, burada f(p), p'yi tam olarak k boş olmayan ardışık segmente bölerek ve her segmenti sıralayarak elde edilebilecek sözlük sırasına göre en küçük permütasyondur (yani, k-1 tane kırılma noktası seçin 1 <= x_1 < x_2 < ... < x_{k-1} < n ve [1, x_1], (x_1, x_2], ..., (x_{k-1}, n] şeklinde bölün). Sonuç 998244353 ile mod alınmalıdır.\n\n    >>> f_43(2, 1, [1, 2])\n    2\n\n*/\nint f_43(int n, int k, int qq[])", "vi": "#include <bits/stdc++.h>\n/*\nCho một hoán vị q của n phần tử và một số nguyên k, tìm số lượng hoán vị p của n phần tử sao cho f(p) = q, trong đó f(p) là hoán vị nhỏ nhất theo từ điển có thể thu được bằng cách chia p thành chính xác k đoạn liên tiếp không rỗng và sắp xếp mỗi đoạn (tức là, chọn k-1 điểm ngắt 1 <= x_1 < x_2 < ... < x_{k-1} < n, và chia nó thành [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). Kết quả nên được lấy modulo 998244353.\n\n    >>> f_43(2, 1, [1, 2])\n    2\n\n*/\nint f_43(int n, int k, int qq[])", "id": "#include <bits/stdc++.h>\n/*\nDiberikan sebuah permutasi q dari n elemen dan sebuah bilangan bulat k, temukan jumlah permutasi p dari n elemen sedemikian rupa sehingga f(p) = q, di mana f(p) adalah permutasi terkecil secara leksikografis yang dapat diperoleh dengan membagi p menjadi tepat k segmen kontigu yang tidak kosong dan mengurutkan setiap segmen (yaitu, pilih k-1 titik putus 1 <= x_1 < x_2 < ... < x_{k-1} < n, dan bagi menjadi [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). Hasilnya harus dalam modulo 998244353.\n\n    >>> f_43(2, 1, [1, 2])\n    2\n\n*/\nint f_43(int n, int k, int qq[])\n", "ja": "#include <bits/stdc++.h>\n/*\nn個の要素の順列qと整数kが与えられたとき、f(p) = qとなるn個の要素の順列pの数を求めます。ここで、f(p)はpをちょうどk個の空でない連続したセグメントに分割し、各セグメントをソートすることで得られる辞書順で最小の順列です（つまり、k-1個のブレークポイント1 <= x_1 < x_2 < ... < x_{k-1} < nを選び、[1, x_1], (x_1, x_2], ..., (x_{k-1}, n]に分割します）。結果は998244353での剰余とします。\n\n    >>> f_43(2, 1, [1, 2])\n    2\n\n*/\nint f_43(int n, int k, int qq[])\n", "ko": "#include <bits/stdc++.h>\n/*\nn개의 요소로 구성된 순열 q와 정수 k가 주어졌을 때, n개의 요소로 구성된 순열 p의 개수를 찾으시오. 여기서 f(p) = q이며, f(p)는 p를 정확히 k개의 비어 있지 않은 연속된 구간으로 나누고 각 구간을 정렬하여 얻을 수 있는 사전식으로 가장 작은 순열입니다 (즉, k-1개의 분할점을 선택하여 1 <= x_1 < x_2 < ... < x_{k-1} < n, [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]으로 나누는 것입니다). 결과는 998244353로 나눈 나머지여야 합니다.\n\n    >>> f_43(2, 1, [1, 2])\n    2\n\n*/\nint f_43(int n, int k, int qq[])", "ml": "#include <bits/stdc++.h>\n/*\nn ഘടകങ്ങളുടെ ഒരു permutation q, ഒരു പൂർണ്ണസംഖ്യ k എന്നിവ നൽകിയാൽ, n ഘടകങ്ങളുടെ permutation p-കളുടെ എണ്ണം കണ്ടെത്തുക, അങ്ങനെ f(p) = q, ഇവിടെ f(p) എന്നത് p-നെ കൃത്യമായി k ശൂന്യമല്ലാത്ത തുടർച്ചയായ വിഭാഗങ്ങളായി വിഭജിച്ച് ഓരോ വിഭാഗവും ക്രമീകരിച്ച് ലഭിക്കാവുന്ന ലെക്സികോഗ്രാഫിക്‌ ആയി ഏറ്റവും ചെറിയ permutation ആണ് (അത്, k-1 ബ്രേക്ക്‌പോയിന്റുകൾ 1 <= x_1 < x_2 < ... < x_{k-1} < n തിരഞ്ഞെടുക്കുക, അതിനെ [1, x_1], (x_1, x_2], ..., (x_{k-1}, n] ആയി വിഭജിക്കുക). ഫലം 998244353-ൽ മോഡുലോ ആയിരിക്കണം.\n\n    >>> f_43(2, 1, [1, 2])\n    2\n\n*/\nint f_43(int n, int k, int qq[])", "fa": "#include <bits/stdc++.h>\n/*\nبا توجه به یک جایگشت q از n عنصر و یک عدد صحیح k، تعداد جایگشت‌های p از n عنصر را بیابید به طوری که f(p) = q، که در آن f(p) کوچک‌ترین جایگشت به ترتیب لغت‌نامه‌ای است که می‌توان با تقسیم p به دقیقاً k بخش متوالی غیر خالی و مرتب‌سازی هر بخش به دست آورد (یعنی k-1 نقطه شکست را انتخاب کنید 1 <= x_1 < x_2 < ... < x_{k-1} < n، و آن را به [1, x_1]، (x_1, x_2]، ...، (x_{k-1}, n] تقسیم کنید). نتیجه باید به پیمانه 998244353 باشد.\n\n    >>> f_43(2, 1, [1, 2])\n    2\n\n*/\nint f_43(int n, int k, int qq[])"}, "canonical_solution": "{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i != m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}", "instruction": {"en": "int f_43(int n, int k, int qq[])\n{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i != m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.", "sq": "int f_43(int n, int k, int qq[])\n{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i != m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit CPP në gjuhën shqipe duke përdorur maksimumi 500 karaktere.", "hy": "int f_43(int n, int k, int qq[])\n{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i != m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}\n\nՏրամադրեք հակիրճ բնական լեզվով նկարագրություն (docstring) այս CPP կոդի համար՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "int f_43(int n, int k, int qq[])\n{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i != m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}\n\nসিপিপি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।", "bg": "int f_43(int n, int k, int qq[])\n{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i != m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}\n\nПредоставете кратко описание на кода на CPP на естествен език на български, използвайки не повече от 500 знака.", "zh": "int f_43(int n, int k, int qq[])\n{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i != m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}\n\n请用中文为以下CPP代码提供简洁的自然语言描述（文档字符串），字数不超过500个字符。", "fr": "int f_43(int n, int k, int qq[])\n{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i != m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}\n\nFournissez une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.", "de": "int f_43(int n, int k, int qq[])\n{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i != m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen.", "ha": "int f_43(int n, int k, int qq[])\n{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i != m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar CPP cikin Hausa ta amfani da haruffa 500 kawai.", "hi": "int f_43(int n, int k, int qq[])\n{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i != m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "int f_43(int n, int k, int qq[])\n{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i != m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a CPP kódról magyarul, legfeljebb 500 karakterben.", "es": "int f_43(int n, int k, int qq[])\n{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i != m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando un máximo de 500 caracteres.", "arb": "int f_43(int n, int k, int qq[])\n{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i != m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة CPP باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.", "sw": "int f_43(int n, int k, int qq[])\n{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i != m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "int f_43(int n, int k, int qq[])\n{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i != m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}\n\nAşağıdaki CPP kodunun Türkçe olarak en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.", "vi": "int f_43(int n, int k, int qq[])\n{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i != m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt, sử dụng tối đa 500 ký tự.", "id": "int f_43(int n, int k, int qq[])\n{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i != m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode CPP dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "int f_43(int n, int k, int qq[])\n{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i != m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}\n\n以下のCPPコードの自然言語による簡潔な説明（ドックストリング）を日本語で500文字以内で提供してください。", "ko": "int f_43(int n, int k, int qq[])\n{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i != m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}\n\n다음 CPP 코드의 동작을 설명하는 간결한 자연어 설명(도큐멘트 문자열)을 최대 500자 이내로 한국어로 제공하세요.", "ml": "int f_43(int n, int k, int qq[])\n{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i != m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}\n\nCPP കോഡ് ഉപയോഗിച്ച് 500 അക്ഷരങ്ങളിൽ കൂടുതൽ അല്ലാത്ത ഒരു സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) മലയാളത്തിൽ നൽകുക.", "fa": "int f_43(int n, int k, int qq[])\n{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i != m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}\n\nتوضیح مختصر و طبیعی (docstring) از کد CPP را به زبان فارسی ارائه دهید که حداکثر ۵۰۰ کاراکتر باشد."}, "level": "", "test": "int main() {\n    int q1[] = {1, 2};\n    assert(f_43(2, 1, q1) == 2);\n\n    int q2[] = {3, 1, 2};\n    assert(f_43(3, 3, q2) == 1);\n\n    int q3[] = {1, 2, 3, 6, 5, 4};\n    assert(f_43(6, 3, q3) == 13);\n\n    int q4[] = {1, 2, 3, 4, 5, 6};\n    assert(f_43(6, 1, q4) == 720);\n\n    int q5[] = {1, 2, 5, 3, 4, 5};\n    assert(f_43(6, 3, q5) == 0);\n\n    int q6[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n    assert(f_43(9, 9, q6) == 1);\n\n    int q7[] = {1, 2, 3, 4, 5, 6, 7, 9, 8};\n    assert(f_43(9, 2, q7) == 29093);\n    return 0;}", "entry_point": "f_43", "signature": "int f_43(int n, int k, int qq[])", "docstring": {"en": "Given a permutation q of n elements and an integer k, find the number of permutations p of n elements such that f(p) = q, where f(p) is the lexicographically smallest permutation that can be obtained by dividing p into exactly k non-empty contiguous segments and sorting each segment (i.e., choose k-1 breakpoints 1 <= x_1 < x_2 < ... < x_{k-1} < n, and divide it into [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). The result should be modulo 998244353.\n\n    >>> f_43(2, 1, [1, 2])\n    2\n\n", "sq": "Duke pasur një permutacion q të n elementeve dhe një numër të plotë k, gjeni numrin e permutacioneve p të n elementeve të tilla që f(p) = q, ku f(p) është permutacioni më i vogël leksikografik që mund të merret duke ndarë p në saktësisht k segmente të pandara jo-bosh dhe duke renditur secilin segment (d.m.th., zgjidhni k-1 pika ndarëse 1 <= x_1 < x_2 < ... < x_{k-1} < n, dhe ndajeni në [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). Rezultati duhet të jetë modulo 998244353.\n\n    >>> f_43(2, 1, [1, 2])\n    2", "hy": "Տրված է n տարրերի q փոխատեղումը և k ամբողջ թիվը, գտնել n տարրերի p փոխատեղումների քանակը, այնպես, որ f(p) = q, որտեղ f(p)-ն ամենափոքր լեքսիկոգրաֆիկ փոխատեղումն է, որը կարելի է ստանալ p-ն ճշգրիտ k ոչ դատարկ հարակից հատվածների բաժանելով և յուրաքանչյուր հատվածը դասավորելով (այսինքն՝ ընտրել k-1 կոտրման կետեր 1 <= x_1 < x_2 < ... < x_{k-1} < n, և բաժանել այն [1, x_1], (x_1, x_2], ..., (x_{k-1}, n] հատվածների): Արդյունքը պետք է լինի 998244353 մոդուլով:\n\n    >>> f_43(2, 1, [1, 2])\n    2", "bn": "n উপাদানের একটি permutation q এবং একটি পূর্ণসংখ্যা k দেওয়া হয়েছে, n উপাদানের কতগুলি permutation p আছে তা খুঁজে বের করুন যাতে f(p) = q হয়, যেখানে f(p) হল lexicographically ক্ষুদ্রতম permutation যা ঠিক k টি খালি নয় এমন সংলগ্ন segment-এ p ভাগ করে এবং প্রতিটি segment sort করে পাওয়া যায় (অর্থাৎ, k-1 টি breakpoint 1 <= x_1 < x_2 < ... < x_{k-1} < n নির্বাচন করুন, এবং এটিকে [1, x_1], (x_1, x_2], ..., (x_{k-1}, n] তে ভাগ করুন)। ফলাফলটি 998244353 দ্বারা modulo করা উচিত।\n\n    >>> f_43(2, 1, [1, 2])\n    2", "bg": "Дадена е пермутация q от n елемента и цяло число k, намерете броя на пермутациите p от n елемента, такива че f(p) = q, където f(p) е лексикографски най-малката пермутация, която може да бъде получена чрез разделяне на p на точно k непразни съседни сегмента и сортиране на всеки сегмент (т.е. изберете k-1 точки на прекъсване 1 <= x_1 < x_2 < ... < x_{k-1} < n, и го разделете на [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). Резултатът трябва да бъде модуло 998244353.\n\n    >>> f_43(2, 1, [1, 2])\n    2", "zh": "给定一个由 n 个元素组成的排列 q 和一个整数 k，找出有多少个由 n 个元素组成的排列 p 使得 f(p) = q，其中 f(p) 是可以通过将 p 精确地划分为 k 个非空连续段并对每个段进行排序而获得的字典序最小的排列（即，选择 k-1 个断点 1 <= x_1 < x_2 < ... < x_{k-1} < n，并将其划分为 [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]）。结果应对 998244353 取模。\n\n    >>> f_43(2, 1, [1, 2])\n    2", "fr": "Étant donné une permutation q de n éléments et un entier k, trouvez le nombre de permutations p de n éléments telles que f(p) = q, où f(p) est la permutation lexicographiquement la plus petite qui peut être obtenue en divisant p en exactement k segments contigus non vides et en triant chaque segment (c'est-à-dire, choisissez k-1 points de rupture 1 <= x_1 < x_2 < ... < x_{k-1} < n, et divisez-le en [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). Le résultat doit être modulo 998244353.\n\n    >>> f_43(2, 1, [1, 2])\n    2", "de": "Gegeben eine Permutation q von n Elementen und eine ganze Zahl k, finde die Anzahl der Permutationen p von n Elementen, so dass f(p) = q, wobei f(p) die lexikographisch kleinste Permutation ist, die erhalten werden kann, indem p in genau k nicht-leere zusammenhängende Segmente unterteilt und jedes Segment sortiert wird (d.h. wähle k-1 Trennpunkte 1 <= x_1 < x_2 < ... < x_{k-1} < n, und teile es in [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). Das Ergebnis sollte modulo 998244353 sein.\n\n    >>> f_43(2, 1, [1, 2])\n    2", "ha": "An ba da permutation q na abubuwa n da kuma lamba k, nemo yawan permutations p na abubuwa n irin cewa f(p) = q, inda f(p) shine permutation mafi ƙanƙanta a cikin tsarin lexicographically wanda za a iya samu ta hanyar raba p zuwa daidai k sassa masu cike da abubuwa masu jere kuma a tsara kowanne sashe (wato, zaɓi k-1 wuraren tsayawa 1 <= x_1 < x_2 < ... < x_{k-1} < n, kuma a raba shi zuwa [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). Sakamakon ya kasance modulo 998244353.\n\n    >>> f_43(2, 1, [1, 2])\n    2", "hi": "दिए गए n तत्वों के एक क्रमचय q और एक पूर्णांक k के लिए, n तत्वों के क्रमचयों की संख्या ज्ञात करें p ताकि f(p) = q, जहाँ f(p) वह शब्दकोशानुसार सबसे छोटी क्रमचय है जो p को ठीक k गैर-खाली संलग्न खंडों में विभाजित करके और प्रत्येक खंड को क्रमबद्ध करके प्राप्त की जा सकती है (अर्थात, k-1 ब्रेकपॉइंट चुनें 1 <= x_1 < x_2 < ... < x_{k-1} < n, और इसे [1, x_1], (x_1, x_2], ..., (x_{k-1}, n] में विभाजित करें)। परिणाम 998244353 के मापांक में होना चाहिए।\n\n    >>> f_43(2, 1, [1, 2])\n    2", "hu": "Adott egy q permutáció n elemre és egy egész szám k, találd meg azon p permutációk számát n elemre, amelyekre f(p) = q, ahol f(p) a lexikografikusan legkisebb permutáció, amelyet úgy lehet megkapni, hogy p-t pontosan k nem üres, összefüggő szegmensre osztjuk és minden szegmenst sorba rendezünk (azaz válasszunk k-1 töréspontot 1 <= x_1 < x_2 < ... < x_{k-1} < n, és osszuk fel [1, x_1], (x_1, x_2], ..., (x_{k-1}, n] részekre). Az eredménynek 998244353-mal kell modulozni.\n\n    >>> f_43(2, 1, [1, 2])\n    2", "es": "Dada una permutación q de n elementos y un entero k, encuentra el número de permutaciones p de n elementos tal que f(p) = q, donde f(p) es la permutación lexicográficamente más pequeña que se puede obtener dividiendo p en exactamente k segmentos contiguos no vacíos y ordenando cada segmento (es decir, elige k-1 puntos de ruptura 1 <= x_1 < x_2 < ... < x_{k-1} < n, y divídelo en [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). El resultado debe ser módulo 998244353.\n\n    >>> f_43(2, 1, [1, 2])\n    2", "arb": "بالنظر إلى ترتيب q من n عنصر وعدد صحيح k، ابحث عن عدد الترتيبات p من n عنصر بحيث f(p) = q، حيث أن f(p) هو الترتيب الأصغر لغوياً الذي يمكن الحصول عليه عن طريق تقسيم p إلى k مقاطع متجاورة غير فارغة تماماً وترتيب كل مقطع (أي اختيار k-1 نقطة قطع 1 <= x_1 < x_2 < ... < x_{k-1} < n، وتقسيمها إلى [1, x_1]، (x_1, x_2]، ...، (x_{k-1}, n]). يجب أن تكون النتيجة موديولو 998244353.\n\n    >>> f_43(2, 1, [1, 2])\n    2", "sw": "Kwa kupewa mpangilio q wa vipengele n na nambari k, pata idadi ya mipangilio p ya vipengele n kama f(p) = q, ambapo f(p) ni mpangilio mdogo zaidi wa lexicographically ambao unaweza kupatikana kwa kugawanya p katika sehemu k zisizo tupu na zinazofuatana na kupanga kila sehemu (yaani, chagua k-1 sehemu za kuvunja 1 <= x_1 < x_2 < ... < x_{k-1} < n, na igawanye katika [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). Matokeo yanapaswa kuwa modulo 998244353.\n\n    >>> f_43(2, 1, [1, 2])\n    2", "tr": "Verilen n elemanlı bir q permütasyonu ve bir k tam sayısı için, f(p) = q olacak şekilde n elemanlı kaç tane p permütasyonu olduğunu bulun. Burada f(p), p'yi tam olarak k tane boş olmayan ardışık segmente bölerek ve her segmenti sıralayarak elde edilebilecek sözlük sırasına göre en küçük permütasyondur (yani, k-1 tane kırılma noktası seçin 1 <= x_1 < x_2 < ... < x_{k-1} < n ve [1, x_1], (x_1, x_2], ..., (x_{k-1}, n] olarak bölün). Sonuç 998244353 ile mod alınmalıdır.\n\n    >>> f_43(2, 1, [1, 2])\n    2", "vi": "Đưa ra một hoán vị q của n phần tử và một số nguyên k, tìm số lượng hoán vị p của n phần tử sao cho f(p) = q, trong đó f(p) là hoán vị nhỏ nhất theo từ điển có thể thu được bằng cách chia p thành chính xác k đoạn liên tiếp không rỗng và sắp xếp từng đoạn (tức là, chọn k-1 điểm ngắt 1 <= x_1 < x_2 < ... < x_{k-1} < n, và chia nó thành [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). Kết quả cần lấy modulo 998244353.\n\n    >>> f_43(2, 1, [1, 2])\n    2", "id": "Diberikan sebuah permutasi q dari n elemen dan sebuah bilangan bulat k, temukan jumlah permutasi p dari n elemen sedemikian rupa sehingga f(p) = q, di mana f(p) adalah permutasi terkecil secara leksikografis yang dapat diperoleh dengan membagi p menjadi tepat k segmen berurutan yang tidak kosong dan mengurutkan setiap segmen (yaitu, pilih k-1 titik putus 1 <= x_1 < x_2 < ... < x_{k-1} < n, dan bagi menjadi [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). Hasilnya harus dalam modulo 998244353.\n\n    >>> f_43(2, 1, [1, 2])\n    2", "ja": "与えられた n 要素の順列 q と整数 k に対して、f(p) = q となる n 要素の順列 p の数を求めます。ここで、f(p) は p を正確に k 個の空でない連続したセグメントに分割し、各セグメントをソートすることで得られる辞書順で最小の順列です（すなわち、k-1 個のブレークポイント 1 <= x_1 < x_2 < ... < x_{k-1} < n を選び、[1, x_1], (x_1, x_2], ..., (x_{k-1}, n] に分割します）。結果は 998244353 でのモジュロとします。\n\n    >>> f_43(2, 1, [1, 2])\n    2", "ko": "주어진 n 요소의 순열 q와 정수 k가 주어졌을 때, n 요소의 순열 p 중에서 f(p) = q가 되는 순열의 수를 찾으시오. 여기서 f(p)는 p를 정확히 k개의 비어 있지 않은 연속된 구간으로 나누고 각 구간을 정렬하여 얻을 수 있는 사전식으로 가장 작은 순열입니다 (즉, k-1개의 분할점을 선택하여 1 <= x_1 < x_2 < ... < x_{k-1} < n, 그리고 이를 [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]으로 나누는 것입니다). 결과는 998244353로 나눈 나머지가 되어야 합니다.\n\n    >>> f_43(2, 1, [1, 2])\n    2", "ml": "നൽകിയിരിക്കുന്ന n ഘടകങ്ങളുടെ ഒരു ക്രമവിന്യാസം q, ഒരു പൂർണ്ണസംഖ്യ k എന്നിവ നൽകിയാൽ, f(p) = q ആയ n ഘടകങ്ങളുടെ ക്രമവിന്യാസങ്ങളുടെ എണ്ണം കണ്ടെത്തുക, ഇവിടെ f(p) എന്നത് p കൃത്യമായി k ശൂന്യമല്ലാത്ത തുടർച്ചയായ വിഭാഗങ്ങളായി വിഭജിച്ച് ഓരോ വിഭാഗവും ക്രമീകരിച്ച് ലഭിക്കാവുന്ന ലെക്സികോഗ്രാഫിക്‌ ആയി ഏറ്റവും ചെറിയ ക്രമവിന്യാസമാണ് (അഥവാ, k-1 ബ്രേക്ക്‌പോയിന്റുകൾ 1 <= x_1 < x_2 < ... < x_{k-1} < n തിരഞ്ഞെടുക്കുക, അതിനെ [1, x_1], (x_1, x_2], ..., (x_{k-1}, n] എന്നിങ്ങനെ വിഭജിക്കുക). ഫലം 998244353-ൽ മോഡുലോ ആയിരിക്കണം.\n\n    >>> f_43(2, 1, [1, 2])\n    2", "fa": "با توجه به یک جایگشت q از n عنصر و یک عدد صحیح k، تعداد جایگشت‌های p از n عنصر را بیابید به طوری که f(p) = q، که در آن f(p) کوچکترین جایگشت به ترتیب لغت‌نامه‌ای است که می‌تواند با تقسیم p به طور دقیق به k بخش متوالی غیر خالی و مرتب کردن هر بخش به دست آید (یعنی k-1 نقطه شکست 1 <= x_1 < x_2 < ... < x_{k-1} < n را انتخاب کنید و آن را به [1, x_1]، (x_1, x_2]، ...، (x_{k-1}, n] تقسیم کنید). نتیجه باید به پیمانه 998244353 باشد.\n\n    >>> f_43(2, 1, [1, 2])\n    2"}}
{"task_id": "CPP/44", "prompt": {"en": "#include <cassert>\n#include <algorithm>\n#include <vector>\n/**\n * Given an array of n distinct integers representing the heights of Kira's friends, \n * find the number of ways to choose a triplet (a, b, c) such that the greatest common divisor (GCD) \n * of the maximum and minimum values of the triplet is 1.\n * \n * Example usage:\n * >>> f_44({1, 5, 7})\n * 1\n */\nint f_44(const std::vector<int>& heights)", "sq": "#include <cassert>\n#include <algorithm>\n#include <vector>\n/**\n * Duke pasur një varg prej n numrash të plotë të dallueshëm që përfaqësojnë lartësitë e miqve të Kirës,\n * gjeni numrin e mënyrave për të zgjedhur një treshe (a, b, c) të tillë që maksimumi dhe minimumi i tresheve\n * të kenë si përbashkët vetëm numrin 1.\n * \n * Shembull përdorimi:\n * >>> f_44({1, 5, 7})\n * 1\n */\nint f_44(const std::vector<int>& heights)", "hy": "#include <cassert>\n#include <algorithm>\n#include <vector>\n/**\n * Տրված է n տարբեր ամբողջ թվերից կազմված զանգված, որը ներկայացնում է Կիրայի ընկերների բարձրությունները,\n * գտնել եղանակների քանակը, որոնցով կարելի է ընտրել եռյակ (a, b, c) այնպես, որ եռյակի առավելագույն և նվազագույն արժեքների \n * ամենամեծ ընդհանուր բաժանարարը (GCD) լինի 1:\n * \n * Օրինակ օգտագործում:\n * >>> f_44({1, 5, 7})\n * 1\n */\nint f_44(const std::vector<int>& heights)", "bn": "#include <cassert>\n#include <algorithm>\n#include <vector>\n/**\n * কিরার বন্ধুদের উচ্চতা প্রতিনিধিত্বকারী n টি স্বতন্ত্র পূর্ণসংখ্যার একটি অ্যারে দেওয়া আছে,\n * এমন একটি ত্রয়ী (a, b, c) বেছে নেওয়ার উপায়ের সংখ্যা খুঁজুন যাতে ত্রয়ীর সর্বাধিক এবং সর্বনিম্ন\n * মানের গ্রেটেস্ট কমন ডিভাইজর (GCD) 1 হয়।\n * \n * উদাহরণ ব্যবহার:\n * >>> f_44({1, 5, 7})\n * 1\n */\nint f_44(const std::vector<int>& heights)", "bg": "#include <cassert>\n#include <algorithm>\n#include <vector>\n/**\n * Даден е масив от n различни цели числа, представляващи височините на приятелите на Кира,\n * намерете броя на начините да изберете тройка (a, b, c) така, че най-големият общ делител (НОД)\n * на максималната и минималната стойност на тройката да е 1.\n * \n * Пример за използване:\n * >>> f_44({1, 5, 7})\n * 1\n */\nint f_44(const std::vector<int>& heights)", "zh": "#include <cassert>\n#include <algorithm>\n#include <vector>\n/**\n * 给定一个由 n 个不同整数组成的数组，表示 Kira 的朋友们的身高，\n * 找出选择一个三元组 (a, b, c) 的方法数，使得该三元组的最大值和最小值的最大公约数 (GCD) 为 1。\n * \n * 示例用法:\n * >>> f_44({1, 5, 7})\n * 1\n */\nint f_44(const std::vector<int>& heights)", "fr": "#include <cassert>\n#include <algorithm>\n#include <vector>\n/**\n * Étant donné un tableau de n entiers distincts représentant les hauteurs des amis de Kira,\n * trouver le nombre de façons de choisir un triplet (a, b, c) tel que le plus grand commun diviseur (PGCD)\n * des valeurs maximale et minimale du triplet soit 1.\n * \n * Exemple d'utilisation :\n * >>> f_44({1, 5, 7})\n * 1\n */\nint f_44(const std::vector<int>& heights)", "de": "#include <cassert>\n#include <algorithm>\n#include <vector>\n/**\n * Gegeben ein Array von n verschiedenen ganzen Zahlen, die die Höhen von Kiras Freunden darstellen, \n * finde die Anzahl der Möglichkeiten, ein Tripel (a, b, c) zu wählen, sodass der größte gemeinsame Teiler (GCD) \n * der maximalen und minimalen Werte des Tripels 1 ist.\n * \n * Beispielverwendung:\n * >>> f_44({1, 5, 7})\n * 1\n */\nint f_44(const std::vector<int>& heights)", "ha": "#include <cassert>\n#include <algorithm>\n#include <vector>\n/**\n * An ba da wani tsari na lambobi daban-daban n da ke wakiltar tsayin abokan Kira,\n * nemo adadin hanyoyin zaɓar triplet (a, b, c) ta yadda mafi girman abin raba kowa da kowa (GCD)\n * na mafi girma da mafi ƙanƙanta ƙima na triplet ɗin shine 1.\n * \n * Misalin amfani:\n * >>> f_44({1, 5, 7})\n * 1\n */\nint f_44(const std::vector<int>& heights)", "hi": "#include <cassert>\n#include <algorithm>\n#include <vector>\n/**\n * Kira के दोस्तों की ऊँचाइयों का प्रतिनिधित्व करने वाले n भिन्न पूर्णांकों के एक array को दिया गया है,\n * उन तरीकों की संख्या खोजें जिनसे एक त्रय (a, b, c) चुना जा सकता है ताकि त्रय के अधिकतम और न्यूनतम मानों का \n * महत्तम समापवर्तक (GCD) 1 हो।\n * \n * उदाहरण उपयोग:\n * >>> f_44({1, 5, 7})\n * 1\n */\nint f_44(const std::vector<int>& heights)", "hu": "#include <cassert>\n#include <algorithm>\n#include <vector>\n/**\n * Adott egy tömb n különböző egész számmal, amelyek Kira barátainak magasságát képviselik,\n * meg kell találni, hányféleképpen lehet kiválasztani egy hármast (a, b, c) úgy, hogy a hármas \n * legnagyobb és legkisebb értékeinek legnagyobb közös osztója (GCD) 1 legyen.\n * \n * Példa használat:\n * >>> f_44({1, 5, 7})\n * 1\n */\nint f_44(const std::vector<int>& heights)", "es": "#include <cassert>\n#include <algorithm>\n#include <vector>\n/**\n * Dado un array de n enteros distintos que representan las alturas de los amigos de Kira,\n * encuentra el número de formas de elegir un triplete (a, b, c) tal que el máximo común divisor (MCD)\n * de los valores máximo y mínimo del triplete sea 1.\n * \n * Ejemplo de uso:\n * >>> f_44({1, 5, 7})\n * 1\n */\nint f_44(const std::vector<int>& heights)", "arb": "#include <cassert>\n#include <algorithm>\n#include <vector>\n/**\n * بالنظر إلى مصفوفة من n عدد صحيح مميز تمثل ارتفاعات أصدقاء كيرا،\n * جد عدد الطرق لاختيار ثلاثية (a, b, c) بحيث يكون القاسم المشترك الأكبر (GCD)\n * للقيمتين العظمى والصغرى للثلاثية هو 1.\n * \n * مثال على الاستخدام:\n * >>> f_44({1, 5, 7})\n * 1\n */\nint f_44(const std::vector<int>& heights)", "sw": "#include <cassert>\n#include <algorithm>\n#include <vector>\n/**\n * Ukipewa safu ya n ya nambari tofauti zinazoashiria urefu wa marafiki wa Kira,\n * pata idadi ya njia za kuchagua tatu (a, b, c) kama kwamba kipeo cha mgawanyiko wa kawaida (GCD)\n * wa thamani za juu na za chini za tatu ni 1.\n * \n * Mfano wa matumizi:\n * >>> f_44({1, 5, 7})\n * 1\n */\nint f_44(const std::vector<int>& heights)", "tr": "#include <cassert>\n#include <algorithm>\n#include <vector>\n/**\n * Kira'nın arkadaşlarının yüksekliklerini temsil eden n farklı tamsayıdan oluşan bir dizi verildiğinde,\n * maksimum ve minimum değerlerinin en büyük ortak böleni (GCD) 1 olan bir üçlü (a, b, c) seçmenin\n * kaç yolu olduğunu bulun.\n * \n * Örnek kullanım:\n * >>> f_44({1, 5, 7})\n * 1\n */\nint f_44(const std::vector<int>& heights)", "vi": "#include <cassert>\n#include <algorithm>\n#include <vector>\n/**\n * Cho một mảng gồm n số nguyên khác nhau đại diện cho chiều cao của bạn bè Kira,\n * tìm số cách chọn một bộ ba (a, b, c) sao cho ước số chung lớn nhất (GCD)\n * của giá trị lớn nhất và nhỏ nhất của bộ ba là 1.\n * \n * Ví dụ sử dụng:\n * >>> f_44({1, 5, 7})\n * 1\n */\nint f_44(const std::vector<int>& heights)", "id": "#include <cassert>\n#include <algorithm>\n#include <vector>\n/**\n * Diberikan sebuah array dari n bilangan bulat berbeda yang mewakili tinggi teman-teman Kira,\n * temukan jumlah cara untuk memilih triplet (a, b, c) sedemikian rupa sehingga pembagi terbesar\n * (GCD) dari nilai maksimum dan minimum triplet adalah 1.\n * \n * Contoh penggunaan:\n * >>> f_44({1, 5, 7})\n * 1\n */\nint f_44(const std::vector<int>& heights)", "ja": "#include <cassert>\n#include <algorithm>\n#include <vector>\n/**\n * Kiraの友人の身長を表すn個の異なる整数の配列が与えられたとき、\n * トリプレット(a, b, c)を選ぶ方法の数を見つけてください。そのトリプレットの最大値と最小値の最大公約数(GCD)が1であるようにします。\n * \n * 使用例:\n * >>> f_44({1, 5, 7})\n * 1\n */\nint f_44(const std::vector<int>& heights)", "ko": "#include <cassert>\n#include <algorithm>\n#include <vector>\n/**\n * Kira의 친구들의 키를 나타내는 n개의 서로 다른 정수 배열이 주어졌을 때, \n * 최대값과 최소값의 최대공약수(GCD)가 1인 세 쌍 (a, b, c)을 선택하는 방법의 수를 찾습니다.\n * \n * 사용 예:\n * >>> f_44({1, 5, 7})\n * 1\n */\nint f_44(const std::vector<int>& heights)", "ml": "#include <cassert>\n#include <algorithm>\n#include <vector>\n/**\n * കിരയുടെ സുഹൃത്തുക്കളുടെ ഉയരങ്ങളെ പ്രതിനിധീകരിക്കുന്ന n വ്യത്യസ്തമായ പൂർണ്ണസംഖ്യകളുടെ ഒരു നിര നൽകിയാൽ, \n * ത്രയീക (a, b, c) തിരഞ്ഞെടുക്കാനുള്ള മാർഗങ്ങളുടെ എണ്ണം കണ്ടെത്തുക, \n * അത്തരം ത്രയീകത്തിന്റെ പരമാവധി, കുറഞ്ഞ മൂല്യങ്ങളുടെ മഹത്തായ പൊതുഹര (GCD) 1 ആണ്.\n * \n * ഉദാഹരണ ഉപയോഗം:\n * >>> f_44({1, 5, 7})\n * 1\n */\nint f_44(const std::vector<int>& heights)", "fa": "#include <cassert>\n#include <algorithm>\n#include <vector>\n/**\n * با توجه به یک آرایه از n عدد صحیح متمایز که نشان‌دهنده ارتفاع دوستان کیرا هستند، \n * تعداد روش‌های انتخاب یک سه‌تایی (a, b, c) را بیابید به‌طوری‌که بزرگترین مقسوم‌علیه مشترک (GCD) \n * مقادیر حداکثر و حداقل سه‌تایی برابر با 1 باشد.\n * \n * مثال استفاده:\n * >>> f_44({1, 5, 7})\n * 1\n */\nint f_44(const std::vector<int>& heights)"}, "canonical_solution": "{\n    int count = 0;\n    int n = heights.size();\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = std::min({heights[i], heights[j], heights[k]});\n                int maxVal = std::max({heights[i], heights[j], heights[k]});\n                \n                // GCD algorithm\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                \n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}", "instruction": {"en": "int f_44(const std::vector<int>& heights)\n{\n    int count = 0;\n    int n = heights.size();\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = std::min({heights[i], heights[j], heights[k]});\n                int maxVal = std::max({heights[i], heights[j], heights[k]});\n                \n                // GCD algorithm\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                \n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.", "sq": "int f_44(const std::vector<int>& heights)\n{\n    int count = 0;\n    int n = heights.size();\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = std::min({heights[i], heights[j], heights[k]});\n                int maxVal = std::max({heights[i], heights[j], heights[k]});\n                \n                // GCD algorithm\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                \n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit CPP në shqip duke përdorur maksimumi 500 karaktere.", "hy": "int f_44(const std::vector<int>& heights)\n{\n    int count = 0;\n    int n = heights.size();\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = std::min({heights[i], heights[j], heights[k]});\n                int maxVal = std::max({heights[i], heights[j], heights[k]});\n                \n                // GCD algorithm\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                \n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\nՏվեք CPP կոդի հակիրճ բնութագրումը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "int f_44(const std::vector<int>& heights)\n{\n    int count = 0;\n    int n = heights.size();\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = std::min({heights[i], heights[j], heights[k]});\n                int maxVal = std::max({heights[i], heights[j], heights[k]});\n                \n                // GCD algorithm\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                \n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\nসিপিপি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।", "bg": "int f_44(const std::vector<int>& heights)\n{\n    int count = 0;\n    int n = heights.size();\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = std::min({heights[i], heights[j], heights[k]});\n                int maxVal = std::max({heights[i], heights[j], heights[k]});\n                \n                // GCD algorithm\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                \n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\nПредоставете кратко описание на CPP кода на естествен език на български, използвайки не повече от 500 знака.", "zh": "int f_44(const std::vector<int>& heights)\n{\n    int count = 0;\n    int n = heights.size();\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = std::min({heights[i], heights[j], heights[k]});\n                int maxVal = std::max({heights[i], heights[j], heights[k]});\n                \n                // GCD algorithm\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                \n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\n请用不超过500个字符的中文为以下CPP代码提供简洁的自然语言描述（文档字符串）。", "fr": "int f_44(const std::vector<int>& heights)\n{\n    int count = 0;\n    int n = heights.size();\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = std::min({heights[i], heights[j], heights[k]});\n                int maxVal = std::max({heights[i], heights[j], heights[k]});\n                \n                // GCD algorithm\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                \n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\nFournissez une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.", "de": "int f_44(const std::vector<int>& heights)\n{\n    int count = 0;\n    int n = heights.size();\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = std::min({heights[i], heights[j], heights[k]});\n                int maxVal = std::max({heights[i], heights[j], heights[k]});\n                \n                // GCD algorithm\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                \n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen.", "ha": "int f_44(const std::vector<int>& heights)\n{\n    int count = 0;\n    int n = heights.size();\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = std::min({heights[i], heights[j], heights[k]});\n                int maxVal = std::max({heights[i], heights[j], heights[k]});\n                \n                // GCD algorithm\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                \n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar CPP a cikin Hausa ta amfani da haruffa 500 kawai.", "hi": "int f_44(const std::vector<int>& heights)\n{\n    int count = 0;\n    int n = heights.size();\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = std::min({heights[i], heights[j], heights[k]});\n                int maxVal = std::max({heights[i], heights[j], heights[k]});\n                \n                // GCD algorithm\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                \n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।", "hu": "int f_44(const std::vector<int>& heights)\n{\n    int count = 0;\n    int n = heights.size();\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = std::min({heights[i], heights[j], heights[k]});\n                int maxVal = std::max({heights[i], heights[j], heights[k]});\n                \n                // GCD algorithm\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                \n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a CPP kódról magyarul, legfeljebb 500 karakterben.", "es": "int f_44(const std::vector<int>& heights)\n{\n    int count = 0;\n    int n = heights.size();\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = std::min({heights[i], heights[j], heights[k]});\n                int maxVal = std::max({heights[i], heights[j], heights[k]});\n                \n                // GCD algorithm\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                \n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando como máximo 500 caracteres.", "arb": "int f_44(const std::vector<int>& heights)\n{\n    int count = 0;\n    int n = heights.size();\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = std::min({heights[i], heights[j], heights[k]});\n                int maxVal = std::max({heights[i], heights[j], heights[k]});\n                \n                // GCD algorithm\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                \n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C++ باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "int f_44(const std::vector<int>& heights)\n{\n    int count = 0;\n    int n = heights.size();\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = std::min({heights[i], heights[j], heights[k]});\n                int maxVal = std::max({heights[i], heights[j], heights[k]});\n                \n                // GCD algorithm\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                \n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "int f_44(const std::vector<int>& heights)\n{\n    int count = 0;\n    int n = heights.size();\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = std::min({heights[i], heights[j], heights[k]});\n                int maxVal = std::max({heights[i], heights[j], heights[k]});\n                \n                // GCD algorithm\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                \n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\nAşağıdaki CPP kodunun Türkçe olarak en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.", "vi": "int f_44(const std::vector<int>& heights)\n{\n    int count = 0;\n    int n = heights.size();\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = std::min({heights[i], heights[j], heights[k]});\n                int maxVal = std::max({heights[i], heights[j], heights[k]});\n                \n                // GCD algorithm\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                \n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự.", "id": "int f_44(const std::vector<int>& heights)\n{\n    int count = 0;\n    int n = heights.size();\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = std::min({heights[i], heights[j], heights[k]});\n                int maxVal = std::max({heights[i], heights[j], heights[k]});\n                \n                // GCD algorithm\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                \n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode CPP dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "int f_44(const std::vector<int>& heights)\n{\n    int count = 0;\n    int n = heights.size();\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = std::min({heights[i], heights[j], heights[k]});\n                int maxVal = std::max({heights[i], heights[j], heights[k]});\n                \n                // GCD algorithm\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                \n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\n以下のCPPコードの簡潔な自然言語による説明（ドックストリング）を日本語で500文字以内で提供してください。", "ko": "int f_44(const std::vector<int>& heights)\n{\n    int count = 0;\n    int n = heights.size();\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = std::min({heights[i], heights[j], heights[k]});\n                int maxVal = std::max({heights[i], heights[j], heights[k]});\n                \n                // GCD algorithm\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                \n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\n다음 CPP 코드에 대한 간결한 자연어 설명(docstring)을 한국어로 최대 500자 이내로 제공하세요.", "ml": "int f_44(const std::vector<int>& heights)\n{\n    int count = 0;\n    int n = heights.size();\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = std::min({heights[i], heights[j], heights[k]});\n                int maxVal = std::max({heights[i], heights[j], heights[k]});\n                \n                // GCD algorithm\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                \n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\nസിപിപി കോഡിന്റെ സംക്ഷിപ്തമായ സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) മലയാളത്തിൽ 500 അക്ഷരങ്ങളിൽ കൂടുതൽ അല്ലാതെ നൽകുക.", "fa": "int f_44(const std::vector<int>& heights)\n{\n    int count = 0;\n    int n = heights.size();\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = std::min({heights[i], heights[j], heights[k]});\n                int maxVal = std::max({heights[i], heights[j], heights[k]});\n                \n                // GCD algorithm\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                \n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\nتوضیح مختصری به زبان طبیعی (docstring) از کد CPP به زبان فارسی با حداکثر ۵۰۰ کاراکتر ارائه دهید."}, "level": "", "test": "int main() {\n    assert(f_44({1, 5, 7}) == 1);\n    assert(f_44({1, 6, 2, 3}) == 3);\n    assert(f_44({16, 4, 8, 2}) == 0);\n    assert(f_44({10, 1, 6, 7, 9, 8, 4, 3, 5, 2}) == 77);\n    assert(f_44({4, 5, 9, 11, 14}) == 7);\n    assert(f_44({15, 10, 6, 9, 7, 3, 12, 8, 11, 1, 2}) == 104);\n    assert(f_44({3, 7, 11, 13}) == 4);\n    assert(f_44({5, 12, 13, 17, 19}) == 10);\n    assert(f_44({2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}) == 87);\n    assert(f_44({1, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17}) == 122);\n\n    return 0;\n}", "entry_point": "f_44", "signature": "int f_44(const std::vector<int>& heights)", "docstring": {"en": "Given an array of n distinct integers representing the heights of Kira's friends, find the number of ways to choose a triplet (a, b, c) such that the greatest common divisor (GCD) of the maximum and minimum values of the triplet is 1.\n\nExample usage:\n>>> f_44({1, 5, 7})\n1", "sq": "Jepet një varg me n numra të plotë të dallueshëm që përfaqësojnë lartësitë e miqve të Kirës, gjeni numrin e mënyrave për të zgjedhur një treshe (a, b, c) të tillë që faktori më i madh i përbashkët (GCD) i vlerave maksimale dhe minimale të treshes të jetë 1.\n\nShembull përdorimi:\n>>> f_44({1, 5, 7})\n1", "hy": "Տրված է n տարբեր ամբողջ թվերի զանգված, որոնք ներկայացնում են Կիրայի ընկերների բարձրությունները, գտնել եղանակների քանակը, որպեսզի ընտրել եռյակ (a, b, c), այնպես, որ եռյակի առավելագույն և նվազագույն արժեքների ամենամեծ ընդհանուր բաժանարարը (GCD) լինի 1:\n\nՕրինակ օգտագործում:\n>>> f_44({1, 5, 7})\n1", "bn": "একটি n ভিন্ন পূর্ণসংখ্যার অ্যারে দেওয়া হয়েছে যা কিরার বন্ধুদের উচ্চতা উপস্থাপন করে, ট্রিপলেট (a, b, c) বেছে নেওয়ার উপায়ের সংখ্যা খুঁজুন যাতে ট্রিপলেটের সর্বাধিক এবং সর্বনিম্ন মানের গ্রেটেস্ট কমন ডিভাইসার (GCD) 1 হয়।\n\nব্যবহারের উদাহরণ:\n>>> f_44({1, 5, 7})\n1", "bg": "Даден е масив от n различни цели числа, представляващи височините на приятелите на Кира, намерете броя на начините да изберете тройка (a, b, c) така, че най-големият общ делител (НОД) на максималната и минималната стойност на тройката да е 1.\n\nПример за използване:\n>>> f_44({1, 5, 7})\n1", "zh": "给定一个由 n 个不同整数组成的数组，表示 Kira 的朋友的身高，找出选择一个三元组 (a, b, c) 的方法数，使得该三元组的最大值和最小值的最大公约数 (GCD) 为 1。\n\n示例用法：\n>>> f_44({1, 5, 7})\n1", "fr": "Étant donné un tableau de n entiers distincts représentant les hauteurs des amis de Kira, trouver le nombre de façons de choisir un triplet (a, b, c) tel que le plus grand commun diviseur (PGCD) des valeurs maximale et minimale du triplet soit 1.\n\nExemple d'utilisation :\n>>> f_44({1, 5, 7})\n1", "de": "Gegeben ein Array von n verschiedenen ganzen Zahlen, die die Höhen von Kiras Freunden darstellen, finde die Anzahl der Möglichkeiten, ein Tripel (a, b, c) so zu wählen, dass der größte gemeinsame Teiler (GCD) der maximalen und minimalen Werte des Tripels 1 ist.\n\nBeispielverwendung:\n>>> f_44({1, 5, 7})\n1", "ha": "An ba da wani tsari na lambobi daban-daban n da ke wakiltar tsayin abokai na Kira, nemo adadin hanyoyin da za a zaɓi triplet (a, b, c) ta yadda mafi girman raba mai yawa (GCD) na mafi girma da ƙananan ƙimomi na triplet ɗin ya zama 1.\n\nMisalin amfani:\n>>> f_44({1, 5, 7})\n1", "hi": "n अद्वितीय पूर्णांकों की एक array दी गई है जो कि किरा के दोस्तों की ऊँचाई का प्रतिनिधित्व करती है, उन तरीकों की संख्या खोजें जिनसे एक त्रिक (a, b, c) चुना जा सके ताकि त्रिक के अधिकतम और न्यूनतम मानों का महत्तम समापवर्तक (GCD) 1 हो।\n\nउदाहरण उपयोग:\n>>> f_44({1, 5, 7})\n1", "hu": "Egy n különböző egész számot tartalmazó tömböt kapunk, amely Kira barátainak magasságát jelképezi. Meg kell találni, hányféleképpen lehet kiválasztani egy hármast (a, b, c) úgy, hogy a hármas maximumának és minimumának legnagyobb közös osztója (GCD) 1 legyen.\n\nPélda használat:\n>>> f_44({1, 5, 7})\n1", "es": "Dado un array de n enteros distintos que representan las alturas de los amigos de Kira, encuentra el número de formas de elegir un triplete (a, b, c) tal que el máximo común divisor (GCD) de los valores máximo y mínimo del triplete sea 1.\n\nUso de ejemplo:\n>>> f_44({1, 5, 7})\n1", "arb": "إعطاء مصفوفة تحتوي على n من الأعداد الصحيحة المميزة التي تمثل ارتفاعات أصدقاء كيرا، ابحث عن عدد الطرق لاختيار ثلاثية (a، b، c) بحيث يكون القاسم المشترك الأكبر (GCD) للقيمتين القصوى والدنيا للثلاثية هو 1.\n\nاستخدام المثال:\n>>> f_44({1, 5, 7})\n1", "sw": "Ikizingatiwa safu ya n ya nambari tofauti zinazoashiria urefu wa marafiki wa Kira, tafuta idadi ya njia za kuchagua tatu (a, b, c) ili kwamba mgawanyiko mkuu wa kawaida (GCD) wa thamani ya juu na ya chini ya tatu hiyo ni 1.\n\nMfano wa matumizi:\n>>> f_44({1, 5, 7})\n1", "tr": "n tane farklı tam sayıdan oluşan ve Kira'nın arkadaşlarının boylarını temsil eden bir dizi verildiğinde, maksimum ve minimum değerlerinin en büyük ortak böleni (GCD) 1 olan bir üçlü (a, b, c) seçmenin kaç yolu olduğunu bulun.\n\nÖrnek kullanım:\n>>> f_44({1, 5, 7})\n1", "vi": "Cho một mảng gồm n số nguyên khác nhau đại diện cho chiều cao của bạn bè Kira, tìm số cách chọn một bộ ba (a, b, c) sao cho ước số chung lớn nhất (GCD) của giá trị lớn nhất và nhỏ nhất của bộ ba là 1.\n\nVí dụ sử dụng:\n>>> f_44({1, 5, 7})\n1", "id": "Diberikan sebuah array dari n bilangan bulat unik yang mewakili tinggi teman-teman Kira, temukan jumlah cara untuk memilih triplet (a, b, c) sedemikian rupa sehingga pembagi terbesar (GCD) dari nilai maksimum dan minimum dari triplet tersebut adalah 1.\n\nPenggunaan contoh:\n>>> f_44({1, 5, 7})\n1", "ja": "与えられた配列は、Kiraの友人たちの高さを表すn個の異なる整数です。この配列から、三つ組 (a, b, c) を選ぶ方法の数を見つけます。このとき、三つ組の最大値と最小値の最大公約数 (GCD) が1である必要があります。\n\n使用例:\n>>> f_44({1, 5, 7})\n1", "ko": "n개의 서로 다른 정수 배열이 주어졌을 때, 이는 Kira의 친구들의 키를 나타냅니다. 최대값과 최소값의 최대 공약수(GCD)가 1인 세 개의 숫자 (a, b, c)를 선택하는 방법의 수를 찾으세요.\n\n사용 예:\n>>> f_44({1, 5, 7})\n1", "ml": "n വ്യത്യസ്തമായ മുഴുവൻ സംഖ്യകളുടെ ഒരു നിര നൽകിയിരിക്കുന്നു, ഇത് കിറയുടെ സുഹൃത്തുക്കളുടെ ഉയരങ്ങളെ പ്രതിനിധീകരിക്കുന്നു, ട്രിപ്പ്ലെറ്റ് (a, b, c) തിരഞ്ഞെടുക്കാനുള്ള മാർഗങ്ങളുടെ എണ്ണം കണ്ടെത്തുക, അങ്ങനെ ട്രിപ്പ്ലെറ്റിന്റെ പരമാവധി, കുറഞ്ഞ മൂല്യങ്ങളുടെ മഹത്തായ പൊതുഹരവും 1 ആണ്.\n\nഉദാഹരണ ഉപയോഗം:\n>>> f_44({1, 5, 7})\n1", "fa": "آرایه‌ای از n عدد صحیح متمایز داده شده که نشان‌دهنده قد دوستان کیرا است، تعداد راه‌های انتخاب یک سه‌تایی (a, b, c) را بیابید به‌طوری‌که بزرگ‌ترین مقسوم‌علیه مشترک (GCD) مقادیر حداکثر و حداقل سه‌تایی برابر 1 باشد.\n\nExample usage:\nمثال استفاده:\n>>> f_44({1, 5, 7})\n1"}}
{"task_id": "CPP/45", "prompt": {"en": "#include <cassert>\n#include <cstdio>\n/**\n * You are given a 1 by n pixel image, where each pixel has a color \n * represented by an integer. You can perform an operation where you \n * pick a color and change all connected pixels of the same color to \n * the chosen color. Two pixels are connected if they are adjacent \n * and have the same color. Find the minimum number of operations \n * required to make all pixels the same color.\n *\n * Note: For each color, there are at most 20 pixels of that color.\n *\n * Examples:\n *   f_45(5, {1, 2, 3, 2, 1}) -> 2\n */\nint f_45(int n, int* pixels)", "sq": "#include <cassert>\n#include <cstdio>\n/**\n * Ju jepet një imazh 1 me n piksel, ku secili piksel ka një ngjyrë\n * të përfaqësuar nga një numër i plotë. Ju mund të kryeni një operacion ku\n * zgjidhni një ngjyrë dhe ndryshoni të gjithë piksela të lidhur të së njëjtës ngjyrë\n * në ngjyrën e zgjedhur. Dy piksela janë të lidhur nëse janë ngjitur\n * dhe kanë të njëjtën ngjyrë. Gjeni numrin minimal të operacioneve\n * të nevojshme për të bërë të gjithë piksela të së njëjtës ngjyrë.\n *\n * Shënim: Për çdo ngjyrë, ka maksimumi 20 piksela të asaj ngjyre.\n *\n * Shembuj:\n *   f_45(5, {1, 2, 3, 2, 1}) -> 2\n */\nint f_45(int n, int* pixels)", "hy": "#include <cassert>\n#include <cstdio>\n/**\n * Ձեզ տրված է 1x n պիքսել պատկեր, որտեղ յուրաքանչյուր պիքսել ունի գույն, \n * որը ներկայացված է ամբողջ թվով: Դուք կարող եք կատարել գործողություն, \n * որտեղ ընտրում եք գույն և փոխում նույն գույնի բոլոր միացված պիքսելները \n * ընտրված գույնով: Երկու պիքսելներ միացված են, եթե նրանք հարևան են և ունեն \n * նույն գույնը: Գտեք նվազագույն գործողությունների քանակը, որը պահանջվում է \n * բոլոր պիքսելները նույն գույնի դարձնելու համար:\n *\n * Նշում: Յուրաքանչյուր գույնի համար առավելագույնը 20 պիքսել կա այդ գույնից:\n *\n * Օրինակներ:\n *   f_45(5, {1, 2, 3, 2, 1}) -> 2\n */\nint f_45(int n, int* pixels)", "bn": "#include <cassert>\n#include <cstdio>\n/**\n * আপনাকে 1 বাই n পিক্সেল ইমেজ দেওয়া হয়েছে, যেখানে প্রতিটি পিক্সেলের একটি রঙ \n * একটি পূর্ণসংখ্যা দ্বারা উপস্থাপিত হয়। আপনি একটি অপারেশন সম্পাদন করতে পারেন যেখানে আপনি \n * একটি রঙ বেছে নেন এবং একই রঙের সংযুক্ত সমস্ত পিক্সেলকে \n * নির্বাচিত রঙে পরিবর্তন করেন। দুটি পিক্সেল সংযুক্ত যদি তারা সংলগ্ন হয় \n * এবং একই রঙ থাকে। সমস্ত পিক্সেলকে একই রঙে করতে \n * প্রয়োজনীয় সর্বনিম্ন সংখ্যক অপারেশন খুঁজুন।\n *\n * নোট: প্রতিটি রঙের জন্য, সর্বাধিক 20টি পিক্সেল সেই রঙের হতে পারে।\n *\n * উদাহরণ:\n *   f_45(5, {1, 2, 3, 2, 1}) -> 2\n */\nint f_45(int n, int* pixels)", "bg": "#include <cassert>\n#include <cstdio>\n/**\n * Дадено ви е изображение с размер 1 на n пиксела, където всеки пиксел има цвят,\n * представен от цяло число. Можете да извършите операция, при която избирате цвят\n * и променяте всички свързани пиксели със същия цвят на избрания цвят. Два пиксела\n * са свързани, ако са съседни и имат същия цвят. Намерете минималния брой операции,\n * необходими, за да направите всички пиксели с един и същи цвят.\n *\n * Забележка: За всеки цвят има най-много 20 пиксела от този цвят.\n *\n * Примери:\n *   f_45(5, {1, 2, 3, 2, 1}) -> 2\n */\nint f_45(int n, int* pixels)", "zh": "#include <cassert>\n#include <cstdio>\n/**\n * 给定一个1乘n像素的图像，其中每个像素的颜色由一个整数表示。你可以执行一个操作，\n * 即选择一种颜色并将所有相连的同色像素更改为所选颜色。如果两个像素相邻且颜色相同，\n * 则它们是相连的。找出将所有像素变为同一颜色所需的最小操作次数。\n *\n * 注意：对于每种颜色，最多有20个该颜色的像素。\n *\n * 示例：\n *   f_45(5, {1, 2, 3, 2, 1}) -> 2\n */\nint f_45(int n, int* pixels)", "fr": "#include <cassert>\n#include <cstdio>\n/**\n * Vous avez une image de 1 par n pixels, où chaque pixel a une couleur \n * représentée par un entier. Vous pouvez effectuer une opération où vous \n * choisissez une couleur et changez tous les pixels connectés de la même couleur \n * en la couleur choisie. Deux pixels sont connectés s'ils sont adjacents \n * et ont la même couleur. Trouvez le nombre minimum d'opérations \n * nécessaires pour que tous les pixels soient de la même couleur.\n *\n * Remarque : Pour chaque couleur, il y a au plus 20 pixels de cette couleur.\n *\n * Exemples :\n *   f_45(5, {1, 2, 3, 2, 1}) -> 2\n */\nint f_45(int n, int* pixels)", "de": "#include <cassert>\n#include <cstdio>\n/**\n * Sie haben ein 1xN-Pixel-Bild, bei dem jeder Pixel eine Farbe hat, \n * die durch eine ganze Zahl dargestellt wird. Sie können eine \n * Operation durchführen, bei der Sie eine Farbe auswählen und alle \n * verbundenen Pixel derselben Farbe in die gewählte Farbe ändern. \n * Zwei Pixel sind verbunden, wenn sie benachbart sind und die \n * gleiche Farbe haben. Finden Sie die minimale Anzahl von \n * Operationen, die erforderlich sind, um alle Pixel in die gleiche \n * Farbe zu ändern.\n *\n * Hinweis: Für jede Farbe gibt es höchstens 20 Pixel dieser Farbe.\n *\n * Beispiele:\n *   f_45(5, {1, 2, 3, 2, 1}) -> 2\n */\nint f_45(int n, int* pixels)", "ha": "#include <cassert>\n#include <cstdio>\n/**\n * An ba ku hoton pixel 1 ta n, inda kowanne pixel yana da launi \n * wanda aka wakilta da lamba. Kuna iya aiwatar da aiki inda za ku \n * zaɓi launi kuma ku canza duk pixels da aka haɗa na launi ɗaya zuwa \n * launin da aka zaɓa. Ana haɗa pixels biyu idan suna kusa da juna \n * kuma suna da launi ɗaya. Nemo mafi ƙarancin adadin ayyuka da ake \n * buƙata don sanya duk pixels su zama launi ɗaya.\n *\n * Lura: Ga kowanne launi, akwai a kalla pixels 20 na wannan launi.\n *\n * Misalai:\n *   f_45(5, {1, 2, 3, 2, 1}) -> 2\n */\nint f_45(int n, int* pixels)", "hi": "#include <cassert>\n#include <cstdio>\n/**\n * आपको एक 1 बाय n पिक्सेल छवि दी गई है, जहाँ प्रत्येक पिक्सेल का रंग \n * एक पूर्णांक द्वारा दर्शाया गया है। आप एक ऑपरेशन कर सकते हैं जहाँ आप \n * एक रंग चुनते हैं और उसी रंग के सभी जुड़े पिक्सेल को चुने गए रंग में \n * बदल देते हैं। दो पिक्सेल जुड़े होते हैं यदि वे आसन्न होते हैं और उनका \n * रंग समान होता है। सभी पिक्सेल को एक ही रंग में बनाने के लिए आवश्यक \n * न्यूनतम ऑपरेशनों की संख्या खोजें।\n *\n * नोट: प्रत्येक रंग के लिए, उस रंग के अधिकतम 20 पिक्सेल होते हैं।\n *\n * उदाहरण:\n *   f_45(5, {1, 2, 3, 2, 1}) -> 2\n */\nint f_45(int n, int* pixels)", "hu": "#include <cassert>\n#include <cstdio>\n/**\n * Adott egy 1 x n képpontból álló kép, ahol minden képpont színét egy \n * egész szám reprezentálja. Végrehajtható egy olyan művelet, amely során \n * kiválaszt egy színt, és az összes összekapcsolt, azonos színű képpontot \n * megváltoztatja a kiválasztott színre. Két képpont akkor van összekapcsolva, \n * ha szomszédosak és azonos színűek. Határozza meg a minimális műveletek \n * számát, amelyek szükségesek ahhoz, hogy az összes képpont azonos színű legyen.\n *\n * Megjegyzés: Minden szín esetében legfeljebb 20 képpont van az adott színből.\n *\n * Példák:\n *   f_45(5, {1, 2, 3, 2, 1}) -> 2\n */\nint f_45(int n, int* pixels)", "es": "#include <cassert>\n#include <cstdio>\n/**\n * Se te da una imagen de 1 por n píxeles, donde cada píxel tiene un color \n * representado por un entero. Puedes realizar una operación donde \n * eliges un color y cambias todos los píxeles conectados del mismo color \n * al color elegido. Dos píxeles están conectados si son adyacentes \n * y tienen el mismo color. Encuentra el número mínimo de operaciones \n * requeridas para hacer que todos los píxeles sean del mismo color.\n *\n * Nota: Para cada color, hay como máximo 20 píxeles de ese color.\n *\n * Ejemplos:\n *   f_45(5, {1, 2, 3, 2, 1}) -> 2\n */\nint f_45(int n, int* pixels)", "arb": "#include <cassert>\n#include <cstdio>\n/**\n * لديك صورة مكونة من 1 في n بكسل، حيث يتم تمثيل كل بكسل بلون \n * ممثل بعدد صحيح. يمكنك تنفيذ عملية حيث تختار لونًا وتغير \n * جميع البكسلات المتصلة من نفس اللون إلى اللون المختار. \n * يعتبر البكسلان متصلين إذا كانا متجاورين ولهما نفس اللون. \n * ابحث عن الحد الأدنى لعدد العمليات المطلوبة لجعل جميع \n * البكسلات بنفس اللون.\n *\n * ملاحظة: لكل لون، هناك بحد أقصى 20 بكسل من ذلك اللون.\n *\n * أمثلة:\n *   f_45(5, {1, 2, 3, 2, 1}) -> 2\n */\nint f_45(int n, int* pixels)", "sw": "#include <cassert>\n#include <cstdio>\n/**\n * Umepewa picha ya pikseli 1 kwa n, ambapo kila pikseli ina rangi \n * inayowakilishwa na nambari. Unaweza kufanya operesheni ambapo unachagua \n * rangi na kubadilisha pikseli zote zilizounganishwa za rangi sawa kuwa \n * rangi iliyochaguliwa. Pikseli mbili zimeunganishwa ikiwa ziko karibu \n * na zina rangi sawa. Pata idadi ndogo ya operesheni zinazohitajika \n * kufanya pikseli zote ziwe na rangi sawa.\n *\n * Kumbuka: Kwa kila rangi, kuna pikseli zisizozidi 20 za rangi hiyo.\n *\n * Mifano:\n *   f_45(5, {1, 2, 3, 2, 1}) -> 2\n */\nint f_45(int n, int* pixels)", "tr": "#include <cassert>\n#include <cstdio>\n/**\n * 1'e n pikselden oluşan bir görüntü verilir, burada her piksel bir \n * tamsayı ile temsil edilen bir renge sahiptir. Bir renk seçip aynı \n * renkteki tüm bağlı pikselleri seçilen renge değiştirebileceğiniz \n * bir işlem gerçekleştirebilirsiniz. İki piksel, bitişik ve aynı \n * renkte ise bağlıdır. Tüm pikselleri aynı renkte yapmak için gereken \n * minimum işlem sayısını bulun.\n *\n * Not: Her renk için en fazla 20 piksel vardır.\n *\n * Örnekler:\n *   f_45(5, {1, 2, 3, 2, 1}) -> 2\n */\nint f_45(int n, int* pixels)", "vi": "#include <cassert>\n#include <cstdio>\n/**\n * Bạn được cung cấp một hình ảnh 1 x n pixel, trong đó mỗi pixel có một màu \n * được biểu diễn bằng một số nguyên. Bạn có thể thực hiện một thao tác mà bạn \n * chọn một màu và thay đổi tất cả các pixel kết nối có cùng màu thành màu đã chọn. \n * Hai pixel được kết nối nếu chúng liền kề và có cùng màu. Tìm số lượng thao tác \n * tối thiểu cần thiết để làm cho tất cả các pixel có cùng màu.\n *\n * Lưu ý: Đối với mỗi màu, có tối đa 20 pixel của màu đó.\n *\n * Ví dụ:\n *   f_45(5, {1, 2, 3, 2, 1}) -> 2\n */\nint f_45(int n, int* pixels)", "id": "#include <cassert>\n#include <cstdio>\n/**\n * Anda diberikan gambar 1 kali n piksel, di mana setiap piksel memiliki warna \n * yang diwakili oleh sebuah bilangan bulat. Anda dapat melakukan operasi di mana Anda \n * memilih sebuah warna dan mengubah semua piksel yang terhubung dengan warna yang sama \n * menjadi warna yang dipilih. Dua piksel terhubung jika mereka berdekatan \n * dan memiliki warna yang sama. Temukan jumlah operasi minimum \n * yang diperlukan untuk membuat semua piksel memiliki warna yang sama.\n *\n * Catatan: Untuk setiap warna, ada paling banyak 20 piksel dengan warna tersebut.\n *\n * Contoh:\n *   f_45(5, {1, 2, 3, 2, 1}) -> 2\n */\nint f_45(int n, int* pixels)", "ja": "#include <cassert>\n#include <cstdio>\n/**\n * あなたは1×nピクセルの画像を与えられています。各ピクセルは整数で表される色を持っています。\n * あなたは色を選び、同じ色の連結したピクセルを選んだ色に変える操作を行うことができます。\n * 2つのピクセルは、隣接していて同じ色であれば連結しています。\n * すべてのピクセルを同じ色にするために必要な最小の操作回数を求めてください。\n *\n * 注意: 各色について、その色のピクセルは最大で20個です。\n *\n * 例:\n *   f_45(5, {1, 2, 3, 2, 1}) -> 2\n */\nint f_45(int n, int* pixels)", "ko": "#include <cassert>\n#include <cstdio>\n/**\n * 1 by n 픽셀 이미지가 주어집니다. 각 픽셀은 정수로 표현된 색상을 가지고 있습니다. \n * 색상을 선택하고 같은 색상의 연결된 모든 픽셀을 선택한 색상으로 변경하는 \n * 작업을 수행할 수 있습니다. 두 픽셀이 연결되려면 인접해 있고 같은 색상이어야 합니다. \n * 모든 픽셀을 동일한 색상으로 만들기 위해 필요한 최소 작업 수를 찾으세요.\n *\n * 참고: 각 색상에 대해 해당 색상의 픽셀이 최대 20개입니다.\n *\n * 예시:\n *   f_45(5, {1, 2, 3, 2, 1}) -> 2\n */\nint f_45(int n, int* pixels)\n", "ml": "#include <cassert>\n#include <cstdio>\n/**\n * നിങ്ങൾക്ക് 1 ബൈ n പിക്സൽ ഇമേജ് ലഭിക്കും, ഓരോ പിക്സലിനും \n * ഒരു പൂർണ്ണസംഖ്യയാൽ പ്രതിനിധീകരിച്ച നിറം ഉണ്ടായിരിക്കും. \n * നിങ്ങൾക്ക് ഒരു പ്രവർത്തനം നടത്താൻ കഴിയും, അതായത് നിങ്ങൾ \n * ഒരു നിറം തിരഞ്ഞെടുക്കുകയും ആ നിറത്തിലുള്ള എല്ലാ \n * ബന്ധിപ്പിച്ചിരിക്കുന്ന പിക്സലുകളും തിരഞ്ഞെടുത്ത നിറത്തിലേക്ക് \n * മാറ്റുകയും ചെയ്യുക. രണ്ട് പിക്സലുകൾ ബന്ധിപ്പിച്ചിരിക്കുന്നതാണെങ്കിൽ \n * അവ ചേർന്നിരിക്കുന്നതും ഒരേ നിറമുള്ളതുമാണ്. എല്ലാ പിക്സലുകളും \n * ഒരേ നിറത്തിലാക്കാൻ ആവശ്യമായ കുറഞ്ഞ പ്രവർത്തനങ്ങളുടെ എണ്ണം \n * കണ്ടെത്തുക.\n *\n * കുറിപ്പ്: ഓരോ നിറത്തിനും ആ നിറത്തിലുള്ള പരമാവധി 20 പിക്സലുകൾ \n * മാത്രമേ ഉണ്ടാകൂ.\n *\n * ഉദാഹരണങ്ങൾ:\n *   f_45(5, {1, 2, 3, 2, 1}) -> 2\n */\nint f_45(int n, int* pixels)", "fa": "#include <cassert>\n#include <cstdio>\n/**\n * یک تصویر ۱ در n پیکسلی به شما داده شده است، که هر پیکسل دارای رنگی \n * است که با یک عدد صحیح نشان داده می‌شود. شما می‌توانید عملیاتی انجام دهید \n * که در آن یک رنگ انتخاب کرده و تمام پیکسل‌های متصل با همان رنگ را به \n * رنگ انتخاب شده تغییر دهید. دو پیکسل متصل هستند اگر مجاور باشند و \n * رنگ یکسانی داشته باشند. حداقل تعداد عملیات مورد نیاز برای یکسان \n * کردن رنگ تمام پیکسل‌ها را پیدا کنید.\n *\n * توجه: برای هر رنگ، حداکثر ۲۰ پیکسل با آن رنگ وجود دارد.\n *\n * مثال‌ها:\n *   f_45(5, {1, 2, 3, 2, 1}) -> 2\n */\nint f_45(int n, int* pixels)"}, "canonical_solution": "{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}", "instruction": {"en": "int f_45(int n, int* pixels)\n{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.", "sq": "int f_45(int n, int* pixels)\n{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit CPP në shqip duke përdorur maksimumi 500 karaktere.", "hy": "int f_45(int n, int* pixels)\n{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}\n\nՏվեք կարճ բնութագրություն (docstring) այս CPP կոդի մասին հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։", "bn": "int f_45(int n, int* pixels)\n{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}\n\nসিপিপি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হতে হবে।", "bg": "int f_45(int n, int* pixels)\n{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}\n\nПредоставете кратко описание на CPP кода на естествен език (docstring) на български, използвайки най-много 500 знака.", "zh": "int f_45(int n, int* pixels)\n{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}\n\n将以下CPP代码的自然语言描述（文档字符串）简洁地翻译成中文，字数不超过500个字符。", "fr": "int f_45(int n, int* pixels)\n{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}\n\nFournissez une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.", "de": "int f_45(int n, int* pixels)\n{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "int f_45(int n, int* pixels)\n{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}\n\nBa da takaitaccen bayani a cikin yaren halitta (docstring) na lambar CPP cikin Hausa ta amfani da haruffa 500 kacal.", "hi": "int f_45(int n, int* pixels)\n{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।", "hu": "int f_45(int n, int* pixels)\n{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a CPP kódról magyarul, legfeljebb 500 karakterben.", "es": "int f_45(int n, int* pixels)\n{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando como máximo 500 caracteres.", "arb": "int f_45(int n, int* pixels)\n{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C++ باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "int f_45(int n, int* pixels)\n{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "int f_45(int n, int* pixels)\n{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}\n\nAşağıdaki CPP kodunun Türkçe olarak en fazla 500 karakterle doğal dilde kısa bir açıklamasını (docstring) sağlayın.", "vi": "int f_45(int n, int* pixels)\n{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự.", "id": "int f_45(int n, int* pixels)\n{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode CPP dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "int f_45(int n, int* pixels)\n{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}\n\nCPP コードの簡単な自然言語による説明 (docstring) を英語で最大 500 文字まで入力してください。", "ko": "int f_45(int n, int* pixels)\n{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}\n\n다음 CPP 코드에 대한 간결한 자연어 설명(도크스트링)을 한국어로 최대 500자 이내로 제공하세요.", "ml": "int f_45(int n, int* pixels)\n{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}\n\nസിപിപി കോഡിന്റെ മലയാളത്തിലുള്ള സംക്ഷിപ്ത സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) 500 അക്ഷരങ്ങളിൽ കൂടാതെ നൽകുക.", "fa": "int f_45(int n, int* pixels)\n{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}\n\nتوضیح مختصر و طبیعی (docstring) از کد CPP را به زبان فارسی با حداکثر ۵۰۰ کاراکتر ارائه دهید."}, "level": "", "test": "int main() {\n    int a1[] = {1, 2, 3, 2, 1};\n    int a2[] = {1, 1, 2, 2};\n    int a3[] = {1, 2, 1, 4, 2};\n    int a4[] = {5, 5, 5, 5, 5};\n    int a5[] = {1, 1, 1, 2, 2, 2};\n    int a6[] = {1, 3, 3, 3, 2, 2, 2};\n    int a7[] = {4, 4, 4, 4, 3, 3, 3, 3};\n    int a8[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n    int a9[] = {1, 2, 1, 2, 1, 2, 1, 2, 1, 2};\n    int a10[] = {3, 3, 3};\n    int a11[] = {2, 1, 1, 2};\n    assert(f_45(5, a1) == 2);\n    assert(f_45(4, a2) == 1);\n    assert(f_45(5, a3) == 3);\n    assert(f_45(5, a4) == 0);\n    assert(f_45(6, a5) == 1);\n    assert(f_45(7, a6) == 2);\n    assert(f_45(8, a7) == 1);\n    assert(f_45(9, a8) == 8);\n    assert(f_45(10, a9) == 5);\n    assert(f_45(3, a10) == 0);\n    assert(f_45(4, a11) == 1);\n    return 0;\n}", "entry_point": "f_45", "signature": "int f_45(int n, int* pixels)", "docstring": {"en": "You are given a 1 by n pixel image, where each pixel has a color represented by an integer. You can perform an operation where you pick a color and change all connected pixels of the same color to the chosen color. Two pixels are connected if they are adjacent and have the same color. Find the minimum number of operations required to make all pixels the same color.\n\nNote: For each color, there are at most 20 pixels of that color.\n\nExamples:\n  f_45(5, {1, 2, 3, 2, 1}) -> 2\n", "sq": "Ju jeni dhënë një imazh 1 me n piksel, ku secili piksel ka një ngjyrë të përfaqësuar nga një numër i plotë. Ju mund të kryeni një operacion ku zgjidhni një ngjyrë dhe ndryshoni të gjithë piksela të lidhur të së njëjtës ngjyrë në ngjyrën e zgjedhur. Dy piksela janë të lidhur nëse janë ngjitur dhe kanë të njëjtën ngjyrë. Gjeni numrin minimal të operacioneve të kërkuara për të bërë që të gjithë piksela të kenë të njëjtën ngjyrë.\n\nShënim: Për çdo ngjyrë, ka maksimumi 20 piksela të asaj ngjyre.\n\nShembuj:\n  f_45(5, {1, 2, 3, 2, 1}) -> 2", "hy": "Դուք ունեք 1 x n պիքսել պատկեր, որտեղ յուրաքանչյուր պիքսել ունի գույն, որը ներկայացված է ամբողջ թվով: Դուք կարող եք կատարել գործողություն, որտեղ ընտրում եք գույն և փոխում նույն գույնի բոլոր միացված պիքսելները ընտրված գույնով: Երկու պիքսել միացված են, եթե նրանք հարակից են և ունեն նույն գույնը: Գտեք նվազագույն գործողությունների քանակը, որը պահանջվում է, որպեսզի բոլոր պիքսելները ունենան նույն գույնը:\n\nՆշում: Յուրաքանչյուր գույնի համար առավելագույնը կա 20 պիքսել:\n\nՕրինակներ:\n  f_45(5, {1, 2, 3, 2, 1}) -> 2", "bn": "আপনাকে একটি 1 বাই n পিক্সেল চিত্র দেওয়া হয়েছে, যেখানে প্রতিটি পিক্সেলের একটি রঙ একটি পূর্ণসংখ্যা দ্বারা উপস্থাপিত হয়। আপনি একটি অপারেশন সম্পাদন করতে পারেন যেখানে আপনি একটি রঙ বেছে নেন এবং একই রঙের সমস্ত সংযুক্ত পিক্সেলকে নির্বাচিত রঙে পরিবর্তন করেন। দুটি পিক্সেল সংযুক্ত যদি তারা সংলগ্ন হয় এবং একই রঙের হয়। সমস্ত পিক্সেলকে একই রঙে করার জন্য প্রয়োজনীয় সর্বনিম্ন সংখ্যক অপারেশন খুঁজে বের করুন।\n\nবিঃদ্রঃ: প্রতিটি রঙের জন্য, সর্বাধিক ২০টি পিক্সেল সেই রঙের হতে পারে।\n\nউদাহরণ:\n  f_45(5, {1, 2, 3, 2, 1}) -> 2", "bg": "Дадено е изображение с размер 1 на n пиксела, където всеки пиксел има цвят, представен с цяло число. Можете да извършите операция, при която избирате цвят и променяте всички свързани пиксели със същия цвят на избрания цвят. Два пиксела са свързани, ако са съседни и имат същия цвят. Намерете минималния брой операции, необходими, за да направите всички пиксели с един и същ цвят.\n\nЗабележка: За всеки цвят има най-много 20 пиксела от този цвят.\n\nПримери:\n  f_45(5, {1, 2, 3, 2, 1}) -> 2", "zh": "你有一个1 x n像素的图像，其中每个像素的颜色由一个整数表示。你可以执行一个操作，选择一种颜色并将所有连接的同色像素更改为所选颜色。如果两个像素是相邻的并且具有相同的颜色，则它们是连接的。找出将所有像素变为相同颜色所需的最小操作次数。\n\n注意：对于每种颜色，最多有20个该颜色的像素。\n\n示例：\n  f_45(5, {1, 2, 3, 2, 1}) -> 2", "fr": "Vous avez une image de 1 par n pixels, où chaque pixel a une couleur représentée par un entier. Vous pouvez effectuer une opération où vous choisissez une couleur et changez tous les pixels connectés de la même couleur en la couleur choisie. Deux pixels sont connectés s'ils sont adjacents et ont la même couleur. Trouvez le nombre minimum d'opérations nécessaires pour que tous les pixels aient la même couleur.\n\nRemarque : Pour chaque couleur, il y a au plus 20 pixels de cette couleur.\n\nExemples:\n  f_45(5, {1, 2, 3, 2, 1}) -> 2", "de": "Du hast ein 1 mal n Pixel-Bild, wobei jeder Pixel eine durch eine ganze Zahl dargestellte Farbe hat. Du kannst eine Operation durchführen, bei der du eine Farbe auswählst und alle verbundenen Pixel derselben Farbe in die gewählte Farbe änderst. Zwei Pixel sind verbunden, wenn sie benachbart sind und die gleiche Farbe haben. Finde die minimale Anzahl von Operationen, die erforderlich sind, um alle Pixel in die gleiche Farbe zu bringen.\n\nHinweis: Für jede Farbe gibt es höchstens 20 Pixel dieser Farbe.\n\nBeispiele:\n  f_45(5, {1, 2, 3, 2, 1}) -> 2", "ha": "An ba ku hoton pixel 1 ta n, inda kowane pixel yana da launi da aka wakilta ta hanyar lamba. Kuna iya aiwatar da aiki inda kuka zaɓi launi kuma ku canza duk pixels masu alaƙa na launi ɗaya zuwa launin da aka zaɓa. Ana haɗa pixels biyu idan suna kusa kuma suna da launi ɗaya. Nemo mafi ƙarancin adadin ayyuka da ake buƙata don sanya duk pixels su zama launi ɗaya.\n\nLura: Don kowane launi, akwai a kalla pixels 20 na wannan launi.\n\nMisalai:\n  f_45(5, {1, 2, 3, 2, 1}) -> 2", "hi": "आपको 1 बाई n पिक्सेल छवि दी गई है, जहाँ प्रत्येक पिक्सेल का रंग एक पूर्णांक द्वारा दर्शाया गया है। आप एक ऑपरेशन कर सकते हैं जहाँ आप एक रंग चुनते हैं और उसी रंग के सभी जुड़े पिक्सेल को चुने गए रंग में बदल देते हैं। दो पिक्सेल जुड़े होते हैं यदि वे आसन्न होते हैं और उनका रंग समान होता है। सभी पिक्सेल को एक ही रंग का बनाने के लिए आवश्यक न्यूनतम ऑपरेशनों की संख्या ज्ञात करें।\n\nध्यान दें: प्रत्येक रंग के लिए, उस रंग के अधिकतम 20 पिक्सेल होते हैं।\n\nउदाहरण:\n  f_45(5, {1, 2, 3, 2, 1}) -> 2", "hu": "Meg van adva egy 1 x n képpontból álló kép, ahol minden képpont színét egy egész szám képviseli. Végrehajthatsz egy olyan műveletet, ahol kiválasztasz egy színt, és az összes összekapcsolt, azonos színű képpontot megváltoztatod a választott színre. Két képpont akkor van összekapcsolva, ha szomszédosak és azonos színűek. Találd meg a minimális műveletek számát, amelyek szükségesek ahhoz, hogy az összes képpont azonos színű legyen.\n\nMegjegyzés: Minden szín esetében legfeljebb 20 képpont van abból a színből.\n\nPéldák:\n  f_45(5, {1, 2, 3, 2, 1}) -> 2", "es": "Se te da una imagen de 1 por n píxeles, donde cada píxel tiene un color representado por un entero. Puedes realizar una operación donde eliges un color y cambias todos los píxeles conectados del mismo color al color elegido. Dos píxeles están conectados si son adyacentes y tienen el mismo color. Encuentra el número mínimo de operaciones necesarias para hacer que todos los píxeles sean del mismo color.\n\nNota: Para cada color, hay como máximo 20 píxeles de ese color.\n\nEjemplos:\n  f_45(5, {1, 2, 3, 2, 1}) -> 2", "arb": "أنت تملك صورة مكونة من 1 في n بكسل، حيث أن كل بكسل له لون ممثل برقم صحيح. يمكنك تنفيذ عملية حيث تختار لونًا وتغير جميع البكسلات المتصلة من نفس اللون إلى اللون المختار. يعتبر البكسلان متصلين إذا كانا متجاورين ولهما نفس اللون. ابحث عن الحد الأدنى لعدد العمليات المطلوبة لجعل جميع البكسلات بنفس اللون.\n\nملاحظة: لكل لون، هناك بحد أقصى 20 بكسل من ذلك اللون.\n\nأمثلة:\n  f_45(5, {1, 2, 3, 2, 1}) -> 2", "sw": "Unapewa picha ya pikseli 1 kwa n, ambapo kila pikseli ina rangi inayowakilishwa na nambari. Unaweza kufanya operesheni ambapo unachagua rangi na kubadilisha pikseli zote zilizounganishwa za rangi sawa kuwa rangi iliyochaguliwa. Pikseli mbili zimeunganishwa ikiwa ziko karibu na zina rangi sawa. Tafuta idadi ndogo ya operesheni zinazohitajika ili kufanya pikseli zote kuwa na rangi sawa.\n\nKumbuka: Kwa kila rangi, kuna pikseli zisizozidi 20 za rangi hiyo.\n\nMifano:\n  f_45(5, {1, 2, 3, 2, 1}) -> 2", "tr": "1'e n piksel boyutunda bir görüntü verilir ve her piksel bir tamsayı ile temsil edilen bir renge sahiptir. Bir renk seçip aynı renkteki tüm bağlı pikselleri seçilen renge değiştirebileceğiniz bir işlem gerçekleştirebilirsiniz. İki piksel, bitişikse ve aynı renge sahipse bağlı kabul edilir. Tüm pikselleri aynı renge getirmek için gereken minimum işlem sayısını bulun.\n\nNot: Her renk için en fazla 20 piksel bulunmaktadır.\n\nÖrnekler:\n  f_45(5, {1, 2, 3, 2, 1}) -> 2", "vi": "Bạn được cung cấp một hình ảnh 1 x n pixel, trong đó mỗi pixel có một màu được biểu diễn bằng một số nguyên. Bạn có thể thực hiện một thao tác trong đó bạn chọn một màu và thay đổi tất cả các pixel kết nối có cùng màu thành màu đã chọn. Hai pixel được kết nối nếu chúng liền kề và có cùng màu. Tìm số lượng thao tác tối thiểu cần thiết để làm cho tất cả các pixel có cùng màu.\n\nLưu ý: Đối với mỗi màu, có tối đa 20 pixel của màu đó.\n\nVí dụ:\n  f_45(5, {1, 2, 3, 2, 1}) -> 2", "id": "Anda diberikan gambar 1 x n piksel, di mana setiap piksel memiliki warna yang diwakili oleh sebuah bilangan bulat. Anda dapat melakukan operasi di mana Anda memilih sebuah warna dan mengubah semua piksel yang terhubung dengan warna yang sama menjadi warna yang dipilih. Dua piksel terhubung jika mereka berdekatan dan memiliki warna yang sama. Temukan jumlah operasi minimum yang diperlukan untuk membuat semua piksel memiliki warna yang sama.\n\nCatatan: Untuk setiap warna, terdapat paling banyak 20 piksel dengan warna tersebut.\n\nContoh:\n  f_45(5, {1, 2, 3, 2, 1}) -> 2", "ja": "1行nピクセルの画像が与えられています。各ピクセルは整数で表される色を持っています。ある色を選び、同じ色の隣接するピクセルをすべて選んだ色に変更する操作を行うことができます。2つのピクセルは、隣接していて同じ色である場合に接続されています。すべてのピクセルを同じ色にするために必要な最小の操作回数を求めなさい。\n\n注意: 各色について、その色のピクセルは最大で20個です。\n\n例:\n  f_45(5, {1, 2, 3, 2, 1}) -> 2", "ko": "1 by n 픽셀 이미지가 주어지며, 각 픽셀은 정수로 표현된 색상을 가지고 있습니다. 색상을 선택하여 동일한 색상의 연결된 모든 픽셀을 선택한 색상으로 변경하는 작업을 수행할 수 있습니다. 두 픽셀이 연결되었다는 것은 인접해 있고 같은 색상이라는 것을 의미합니다. 모든 픽셀을 동일한 색상으로 만들기 위해 필요한 최소 작업 수를 찾으십시오.\n\n참고: 각 색상에 대해 해당 색상의 픽셀은 최대 20개입니다.\n\n예시:\n  f_45(5, {1, 2, 3, 2, 1}) -> 2", "ml": "നിങ്ങൾക്ക് 1 by n പിക്സൽ ചിത്രം ലഭിച്ചിട്ടുണ്ട്, ഇവിടെ ഓരോ പിക്സലിനും ഒരു പൂർണ്ണസംഖ്യയാൽ പ്രതിനിധാനം ചെയ്യുന്ന ഒരു നിറമുണ്ട്. നിങ്ങൾ ഒരു നിറം തിരഞ്ഞെടുക്കുകയും അതേ നിറമുള്ള എല്ലാ ബന്ധിപ്പിച്ച പിക്സലുകളും തിരഞ്ഞെടുത്ത നിറത്തിലേക്ക് മാറ്റുകയും ചെയ്യുന്ന ഒരു പ്രവർത്തനം നടത്താൻ കഴിയും. രണ്ട് പിക്സലുകൾ ചേർന്നിരിക്കുന്നതും ഒരേ നിറമുള്ളതുമായിരിക്കുമ്പോൾ അവ ബന്ധിപ്പിച്ചിരിക്കുന്നു. എല്ലാ പിക്സലുകളും ഒരേ നിറത്തിൽ ആക്കാൻ ആവശ്യമായ കുറഞ്ഞ പ്രവർത്തനങ്ങളുടെ എണ്ണം കണ്ടെത്തുക.\n\nകുറിപ്പ്: ഓരോ നിറത്തിനും ആ നിറത്തിലുള്ള പരമാവധി 20 പിക്സലുകൾ മാത്രമേ ഉണ്ടാകൂ.\n\nExamples:\n  f_45(5, {1, 2, 3, 2, 1}) -> 2\n\nഉദാഹരണങ്ങൾ:\n  f_45(5, {1, 2, 3, 2, 1}) -> 2", "fa": "شما یک تصویر ۱ در n پیکسلی دارید، که هر پیکسل دارای رنگی است که با یک عدد صحیح نمایش داده می‌شود. شما می‌توانید عملیاتی انجام دهید که در آن یک رنگ انتخاب کرده و تمام پیکسل‌های متصل با همان رنگ را به رنگ انتخاب شده تغییر دهید. دو پیکسل متصل هستند اگر مجاور باشند و رنگ یکسانی داشته باشند. حداقل تعداد عملیات لازم برای یکسان کردن رنگ تمام پیکسل‌ها را پیدا کنید.\n\nتوجه: برای هر رنگ، حداکثر ۲۰ پیکسل از آن رنگ وجود دارد.\n\nمثال‌ها:\n  f_45(5, {1, 2, 3, 2, 1}) -> 2"}}
{"task_id": "CPP/46", "prompt": {"en": "#include <cassert>\n#include <iostream>\n/**\n * @brief Computes the sum of all numbers from 1 to n that are multiples of either 3 or 5.\n *\n * Counts each number only once even if it is a multiple of both 3 and 5.\n * For example:\n *     @code\n *     std::cout << f_46(10); // Outputs: 33 (3 + 5 + 6 + 9 + 10)\n *     @endcode\n *\n * @param n The upper bound of the range to check for multiples.\n * @return The sum of the multiples of either 3 or 5 within the range.\n */\nint f_46(int n)", "sq": "#include <cassert>\n#include <iostream>\n/**\n * @brief Llogarit shumën e të gjitha numrave nga 1 deri në n që janë shumëfish i 3 ose 5.\n *\n * Numëron çdo numër vetëm një herë edhe nëse është shumëfish i të dyjave 3 dhe 5.\n * Për shembull:\n *     @code\n *     std::cout << f_46(10); // Outputs: 33 (3 + 5 + 6 + 9 + 10)\n *     @endcode\n *\n * @param n Kufiri i sipërm i intervalit për të kontrolluar për shumëfishat.\n * @return Shuma e shumëfishave të 3 ose 5 brenda intervalit.\n */\nint f_46(int n)", "hy": "#include <cassert>\n#include <iostream>\n/**\n * @brief Հաշվում է 1-ից n բոլոր թվերի գումարը, որոնք բազմապատիկ են 3-ի կամ 5-ի։\n *\n * Յուրաքանչյուր թիվ հաշվում է միայն մեկ անգամ, նույնիսկ եթե այն բազմապատիկ է և՛ 3-ի, և՛ 5-ի։\n * Օրինակ՝\n *     @code\n *     std::cout << f_46(10); // Outputs: 33 (3 + 5 + 6 + 9 + 10)\n *     @endcode\n *\n * @param n Շրջանակի վերին սահմանը բազմապատիկների ստուգման համար։\n * @return 3-ի կամ 5-ի բազմապատիկների գումարը տրված շրջակայքում։\n */\nint f_46(int n)", "bn": "#include <cassert>\n#include <iostream>\n/**\n * @brief ১ থেকে n পর্যন্ত সমস্ত সংখ্যার যোগফল গণনা করে যা 3 বা 5 এর গুণিতক।\n *\n * প্রতিটি সংখ্যাকে শুধুমাত্র একবার গণনা করে, এমনকি যদি এটি 3 এবং 5 উভয়েরই গুণিতক হয়।\n * উদাহরণস্বরূপ:\n *     @code\n *     std::cout << f_46(10); // আউটপুট: 33 (3 + 5 + 6 + 9 + 10)\n *     @endcode\n *\n * @param n গুণিতকগুলির জন্য পরীক্ষা করার পরিসরের উপরের সীমা।\n * @return পরিসরের মধ্যে 3 বা 5 এর গুণিতকের যোগফল।\n */\nint f_46(int n)", "bg": "#include <cassert>\n#include <iostream>\n/**\n * @brief Изчислява сумата на всички числа от 1 до n, които са кратни на 3 или 5.\n *\n * Брои всяко число само веднъж, дори ако е кратно и на 3, и на 5.\n * Например:\n *     @code\n *     std::cout << f_46(10); // Извежда: 33 (3 + 5 + 6 + 9 + 10)\n *     @endcode\n *\n * @param n Горната граница на диапазона за проверка на кратни.\n * @return Сумата на кратните на 3 или 5 в рамките на диапазона.\n */\nint f_46(int n)", "zh": "#include <cassert>\n#include <iostream>\n/**\n * @brief 计算从 1 到 n 的所有 3 或 5 的倍数的和。\n *\n * 每个数字只计算一次，即使它同时是 3 和 5 的倍数。\n * 例如：\n *     @code\n *     std::cout << f_46(10); // 输出: 33 (3 + 5 + 6 + 9 + 10)\n *     @endcode\n *\n * @param n 要检查倍数的范围上限。\n * @return 范围内 3 或 5 的倍数的和。\n */\nint f_46(int n)", "fr": "#include <cassert>\n#include <iostream>\n/**\n * @brief Calcule la somme de tous les nombres de 1 à n qui sont des multiples de 3 ou 5.\n *\n * Compte chaque nombre une seule fois même s'il est un multiple à la fois de 3 et de 5.\n * Par exemple :\n *     @code\n *     std::cout << f_46(10); // Outputs: 33 (3 + 5 + 6 + 9 + 10)\n *     @endcode\n *\n * @param n La limite supérieure de la plage à vérifier pour les multiples.\n * @return La somme des multiples de 3 ou 5 dans la plage.\n */\nint f_46(int n)", "de": "#include <cassert>\n#include <iostream>\n/**\n * @brief Berechnet die Summe aller Zahlen von 1 bis n, die Vielfache von entweder 3 oder 5 sind.\n *\n * Zählt jede Zahl nur einmal, auch wenn sie ein Vielfaches von sowohl 3 als auch 5 ist.\n * Zum Beispiel:\n *     @code\n *     std::cout << f_46(10); // Gibt aus: 33 (3 + 5 + 6 + 9 + 10)\n *     @endcode\n *\n * @param n Die obere Grenze des Bereichs, in dem nach Vielfachen gesucht wird.\n * @return Die Summe der Vielfachen von entweder 3 oder 5 innerhalb des Bereichs.\n */\nint f_46(int n)", "ha": "#include <cassert>\n#include <iostream>\n/**\n * @brief Lissafin jimillar dukkan lambobi daga 1 zuwa n waɗanda suke masu yawa na 3 ko 5.\n *\n * Yana ƙidaya kowace lamba sau ɗaya kawai ko da kuwa tana da yawa na 3 da 5.\n * Alal misali:\n *     @code\n *     std::cout << f_46(10); // Fitarwa: 33 (3 + 5 + 6 + 9 + 10)\n *     @endcode\n *\n * @param n Iyakar sama na kewayon da za a duba masu yawa.\n * @return Jimillar masu yawa na 3 ko 5 a cikin kewayon.\n */\nint f_46(int n)", "hi": "#include <cassert>\n#include <iostream>\n/**\n * @brief 1 से n तक के सभी संख्याओं का योग गणना करता है जो या तो 3 या 5 के गुणज हैं।\n *\n * प्रत्येक संख्या को केवल एक बार गिना जाता है, भले ही वह 3 और 5 दोनों का गुणज हो।\n * उदाहरण के लिए:\n *     @code\n *     std::cout << f_46(10); // Outputs: 33 (3 + 5 + 6 + 9 + 10)\n *     @endcode\n *\n * @param n गुणजों की जाँच के लिए सीमा का ऊपरी बिंदु।\n * @return सीमा के भीतर या तो 3 या 5 के गुणजों का योग।\n */\nint f_46(int n)", "hu": "#include <cassert>\n#include <iostream>\n/**\n * @brief Kiszámítja az összes olyan szám összegét 1-től n-ig, amelyek 3 vagy 5 többszörösei.\n *\n * Minden számot csak egyszer számol, még akkor is, ha az 3-nak és 5-nek is többszöröse.\n * Például:\n *     @code\n *     std::cout << f_46(10); // Kimenet: 33 (3 + 5 + 6 + 9 + 10)\n *     @endcode\n *\n * @param n Az intervallum felső határa, amelyben a többszörösöket keressük.\n * @return Az intervallumban lévő 3 vagy 5 többszöröseinek összege.\n */\nint f_46(int n)", "es": "#include <cassert>\n#include <iostream>\n/**\n * @brief Calcula la suma de todos los números desde 1 hasta n que son múltiplos de 3 o 5.\n *\n * Cuenta cada número solo una vez, incluso si es múltiplo de ambos 3 y 5.\n * Por ejemplo:\n *     @code\n *     std::cout << f_46(10); // Outputs: 33 (3 + 5 + 6 + 9 + 10)\n *     @endcode\n *\n * @param n El límite superior del rango para verificar múltiplos.\n * @return La suma de los múltiplos de 3 o 5 dentro del rango.\n */\nint f_46(int n)", "arb": "#include <cassert>\n#include <iostream>\n/**\n * @brief يحسب مجموع جميع الأرقام من 1 إلى n التي هي مضاعفات إما لـ 3 أو 5.\n *\n * يحسب كل رقم مرة واحدة فقط حتى لو كان مضاعفًا لكل من 3 و 5.\n * على سبيل المثال:\n *     @code\n *     std::cout << f_46(10); // Outputs: 33 (3 + 5 + 6 + 9 + 10)\n *     @endcode\n *\n * @param n الحد الأعلى للنطاق للتحقق من المضاعفات.\n * @return مجموع المضاعفات إما لـ 3 أو 5 ضمن النطاق.\n */\nint f_46(int n)", "sw": "#include <cassert>\n#include <iostream>\n/**\n * @brief Inahesabu jumla ya namba zote kutoka 1 hadi n ambazo ni marudufu ya 3 au 5.\n *\n * Inahesabu kila namba mara moja tu hata kama ni marudufu ya 3 na 5.\n * Kwa mfano:\n *     @code\n *     std::cout << f_46(10); // Inatoa: 33 (3 + 5 + 6 + 9 + 10)\n *     @endcode\n *\n * @param n Kikomo cha juu cha upeo wa kuangalia marudufu.\n * @return Jumla ya marudufu ya 3 au 5 ndani ya upeo.\n */\nint f_46(int n)", "tr": "#include <cassert>\n#include <iostream>\n/**\n * @brief 1'den n'ye kadar olan sayılardan 3 veya 5'in katı olanların toplamını hesaplar.\n *\n * Hem 3 hem de 5'in katı olan sayıları yalnızca bir kez sayar.\n * Örneğin:\n *     @code\n *     std::cout << f_46(10); // Çıktı: 33 (3 + 5 + 6 + 9 + 10)\n *     @endcode\n *\n * @param n Katlar için kontrol edilecek aralığın üst sınırı.\n * @return Aralık içindeki 3 veya 5'in katlarının toplamı.\n */\nint f_46(int n)", "vi": "#include <cassert>\n#include <iostream>\n/**\n * @brief Tính tổng của tất cả các số từ 1 đến n mà là bội số của 3 hoặc 5.\n *\n * Chỉ đếm mỗi số một lần ngay cả khi nó là bội số của cả 3 và 5.\n * Ví dụ:\n *     @code\n *     std::cout << f_46(10); // Outputs: 33 (3 + 5 + 6 + 9 + 10)\n *     @endcode\n *\n * @param n Giới hạn trên của phạm vi để kiểm tra các bội số.\n * @return Tổng của các bội số của 3 hoặc 5 trong phạm vi.\n */\nint f_46(int n)", "id": "#include <cassert>\n#include <iostream>\n/**\n * @brief Menghitung jumlah semua angka dari 1 hingga n yang merupakan kelipatan dari 3 atau 5.\n *\n * Menghitung setiap angka hanya sekali meskipun merupakan kelipatan dari 3 dan 5.\n * Sebagai contoh:\n *     @code\n *     std::cout << f_46(10); // Outputs: 33 (3 + 5 + 6 + 9 + 10)\n *     @endcode\n *\n * @param n Batas atas dari rentang untuk memeriksa kelipatan.\n * @return Jumlah dari kelipatan 3 atau 5 dalam rentang tersebut.\n */\nint f_46(int n)", "ja": "#include <cassert>\n#include <iostream>\n/**\n * @brief 1からnまでの数のうち、3または5の倍数であるものの合計を計算します。\n *\n * 3と5の両方の倍数である場合でも、各数は一度だけカウントされます。\n * 例えば:\n *     @code\n *     std::cout << f_46(10); // 出力: 33 (3 + 5 + 6 + 9 + 10)\n *     @endcode\n *\n * @param n 倍数をチェックする範囲の上限。\n * @return 範囲内の3または5の倍数の合計。\n */\nint f_46(int n)", "ko": "#include <cassert>\n#include <iostream>\n/**\n * @brief 1부터 n까지의 숫자 중 3 또는 5의 배수인 모든 숫자의 합을 계산합니다.\n *\n * 3과 5의 공배수인 경우에도 각 숫자는 한 번만 계산됩니다.\n * 예를 들어:\n *     @code\n *     std::cout << f_46(10); // 출력: 33 (3 + 5 + 6 + 9 + 10)\n *     @endcode\n *\n * @param n 배수를 확인할 범위의 상한값.\n * @return 범위 내에서 3 또는 5의 배수의 합.\n */\nint f_46(int n)", "ml": "#include <cassert>\n#include <iostream>\n/**\n * @brief 1 മുതൽ n വരെ 3 അല്ലെങ്കിൽ 5 ന്റെ ഗുണകങ്ങൾ ആയ എല്ലാ സംഖ്യകളുടെയും മൊത്തം കണക്കാക്കുന്നു.\n *\n * 3 നും 5 നും ഇരുവരുടെയും ഗുണകമാണെങ്കിൽ പോലും ഓരോ സംഖ്യയും ഒരിക്കൽ മാത്രമേ എണ്ണൂ.\n * ഉദാഹരണത്തിന്:\n *     @code\n *     std::cout << f_46(10); // Outputs: 33 (3 + 5 + 6 + 9 + 10)\n *     @endcode\n *\n * @param n ഗുണകങ്ങൾ പരിശോധിക്കുന്ന പരിധിയുടെ മുകളിലെ അതിർത്തി.\n * @return പരിധിയിലുള്ള 3 അല്ലെങ്കിൽ 5 ന്റെ ഗുണകങ്ങളുടെ മൊത്തം.\n */\nint f_46(int n)", "fa": "#include <cassert>\n#include <iostream>\n/**\n * @brief محاسبه مجموع تمام اعداد از 1 تا n که مضرب 3 یا 5 هستند.\n *\n * هر عدد را فقط یک بار شمارش می‌کند حتی اگر مضرب هر دو 3 و 5 باشد.\n * برای مثال:\n *     @code\n *     std::cout << f_46(10); // خروجی: 33 (3 + 5 + 6 + 9 + 10)\n *     @endcode\n *\n * @param n حد بالای محدوده‌ای که برای مضرب‌ها بررسی می‌شود.\n * @return مجموع مضرب‌های 3 یا 5 درون محدوده.\n */\nint f_46(int n)"}, "canonical_solution": "{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}", "instruction": {"en": "int f_46(int n)\n{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.", "sq": "int f_46(int n)\n{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit CPP në shqip duke përdorur maksimumi 500 karaktere.", "hy": "int f_46(int n)\n{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nՏվեք CPP կոդի հակիրճ բնութագրություն (docstring) հայերեն լեզվով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "int f_46(int n)\n{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nসিপিপি কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।", "bg": "int f_46(int n)\n{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nДайте кратко описание на CPP кода на български език, използвайки не повече от 500 знака.", "zh": "int f_46(int n)\n{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\n将以下 CPP 代码的自然语言描述（文档字符串）翻译成中文，字数不超过 500 个字符。", "fr": "int f_46(int n)\n{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nFournissez une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.", "de": "int f_46(int n)\n{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "int f_46(int n)\n{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nBa da takaitaccen bayani a cikin yaren halitta (docstring) na lambar CPP cikin Hausa ta amfani da haruffa 500 ko kasa da haka.", "hi": "int f_46(int n)\n{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।", "hu": "int f_46(int n)\n{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a CPP kódról magyarul, legfeljebb 500 karakterben.", "es": "int f_46(int n)\n{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando como máximo 500 caracteres.", "arb": "int f_46(int n)\n{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C++ باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "int f_46(int n)\n{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "int f_46(int n)\n{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nAşağıdaki CPP kodunun Türkçe olarak en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.", "vi": "int f_46(int n)\n{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự.", "id": "int f_46(int n)\n{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode CPP dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "int f_46(int n)\n{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nCPP コードの簡単な自然言語による説明 (docstring) を英語で最大 500 文字まで入力してください。", "ko": "int f_46(int n)\n{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\n다음 CPP 코드의 동작을 최대 500자 이내의 자연어로 간결하게 설명하는 문서 문자열(docstring)을 한국어로 제공하세요.", "ml": "int f_46(int n)\n{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nCPP കോഡിന് 500 അക്ഷരങ്ങളിൽ കൂടുതൽ അല്ലാത്ത മലയാളത്തിൽ സംക്ഷിപ്തമായ സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) നൽകുക.", "fa": "int f_46(int n)\n{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nتوضیح مختصر و طبیعی (docstring) از کد CPP را به زبان فارسی ارائه دهید و از حداکثر ۵۰۰ کاراکتر استفاده کنید."}, "level": "", "test": "int main()\n{\n    assert(f_46(10) == 33);\n    assert(f_46(15) == 60);\n    assert(f_46(20) == 98);\n    assert(f_46(5) == 8);\n    assert(f_46(3) == 3);\n    assert(f_46(6) == 14);\n    assert(f_46(9) == 23);\n    assert(f_46(12) == 45);\n    assert(f_46(17) == 60);\n    assert(f_46(21) == 119);\n    assert(f_46(25) == 168);\n\n    return 0;\n}", "entry_point": "f_46", "signature": "int f_46(int n)", "docstring": {"en": "Computes the sum of all numbers from 1 to n that are multiples of either 3 or 5.\n\nCounts each number only once even if it is a multiple of both 3 and 5.\nFor example:\n    std::cout << f_46(10); // Outputs: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n The upper bound of the range to check for multiples.\n@return The sum of the multiples of either 3 or 5 within the range.", "sq": "Llogarit shumën e të gjitha numrave nga 1 deri në n që janë shumëfish i 3 ose 5.\n\nNumëron secilin numër vetëm një herë edhe nëse është shumëfish i të dyjave, 3 dhe 5.\nPër shembull:\n    std::cout << f_46(10); // Shfaq: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n Kufiri i sipërm i intervalit për të kontrolluar për shumëfish.\n@return Shuma e shumëfishëve të 3 ose 5 brenda intervalit.", "hy": "Հաշվում է 1-ից n բոլոր թվերի գումարը, որոնք բազմապատիկ են կամ 3-ի, կամ 5-ի։\n\nՅուրաքանչյուր թիվ հաշվում է միայն մեկ անգամ, նույնիսկ եթե այն բազմապատիկ է և՛ 3-ի, և՛ 5-ի։\nՕրինակ՝\n    std::cout << f_46(10); // Արդյունք՝ 33 (3 + 5 + 6 + 9 + 10)\n\n@param n Շրջանակի վերին սահմանը բազմապատիկների ստուգման համար։\n@return 3-ի կամ 5-ի բազմապատիկների գումարը տրված շրջանակում։", "bn": "1 থেকে n পর্যন্ত সমস্ত সংখ্যার যোগফল গণনা করে যা 3 বা 5 এর গুণিতক।\n\nপ্রতিটি সংখ্যাকে কেবল একবার গণনা করা হয়, এমনকি যদি এটি 3 এবং 5 উভয়ের গুণিতক হয়।\nউদাহরণস্বরূপ:\n    std::cout << f_46(10); // আউটপুট: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n গুণিতক চেক করার জন্য পরিসরের উপরের সীমা।\n@return পরিসরের মধ্যে 3 বা 5 এর গুণিতকের যোগফল।", "bg": "Изчислява сумата на всички числа от 1 до n, които са кратни на 3 или 5.\n\nБрои всяко число само веднъж, дори ако е кратно и на 3, и на 5.\nНапример:\n    std::cout << f_46(10); // Извежда: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n Горната граница на диапазона за проверка на кратни.\n@return Сумата на кратните на 3 или 5 в рамките на диапазона.", "zh": "计算从 1 到 n 的所有 3 或 5 的倍数的和。\n\n即使一个数字同时是 3 和 5 的倍数，也只计算一次。\n例如：\n    std::cout << f_46(10); // 输出: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n 要检查倍数的范围上限。\n@return 范围内 3 或 5 的倍数之和。", "fr": "Calcule la somme de tous les nombres de 1 à n qui sont des multiples de 3 ou 5.\n\nCompte chaque nombre une seule fois même s'il est un multiple à la fois de 3 et de 5.\nPar exemple :\n    std::cout << f_46(10); // Affiche : 33 (3 + 5 + 6 + 9 + 10)\n\n@param n La limite supérieure de la plage à vérifier pour les multiples.\n@return La somme des multiples de 3 ou 5 dans la plage.", "de": "Berechnet die Summe aller Zahlen von 1 bis n, die Vielfache von entweder 3 oder 5 sind.\n\nZählt jede Zahl nur einmal, auch wenn sie ein Vielfaches von sowohl 3 als auch 5 ist.\nZum Beispiel:\n    std::cout << f_46(10); // Gibt aus: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n Die obere Grenze des Bereichs, in dem nach Vielfachen gesucht wird.\n@return Die Summe der Vielfachen von entweder 3 oder 5 innerhalb des Bereichs.", "ha": "Lissafi jimillar dukkan lambobi daga 1 zuwa n waɗanda suke lambobi masu yawa na 3 ko 5.\n\nYana ƙididdige kowanne lamba sau ɗaya kawai ko da kuwa yana ninkawa ne na 3 da 5.\nMisali:\n    std::cout << f_46(10); // Outputs: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n Babban iyaka na zangon da za a duba don ninkawa.\n@return Jimillar lambobin da suke ninkawa na ko dai 3 ko 5 a cikin zangon.", "hi": "1 से n तक के सभी संख्याओं का योग गणना करता है जो या तो 3 या 5 के गुणज हैं।\n\nप्रत्येक संख्या को केवल एक बार गिना जाता है, भले ही वह 3 और 5 दोनों का गुणज हो।\nउदाहरण के लिए:\n    std::cout << f_46(10); // आउटपुट: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n वह ऊपरी सीमा है जिस रेंज में गुणजों की जांच की जानी है।\n@return उस रेंज के भीतर 3 या 5 के गुणजों का योग।", "hu": "Számítja az 1-től n-ig terjedő összes szám összegét, amelyek 3 vagy 5 többszörösei.\n\nMinden számot csak egyszer számol, még akkor is, ha az 3-nak és 5-nek is többszöröse.\nPéldául:\n    std::cout << f_46(10); // Kimenet: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n A tartomány felső határa, amelyet a többszörösök ellenőrzésére használunk.\n@return A 3 vagy 5 többszöröseinek összege a tartományon belül.", "es": "Calcula la suma de todos los números desde 1 hasta n que son múltiplos de 3 o 5.\n\nCuenta cada número solo una vez, incluso si es un múltiplo de ambos 3 y 5.\nPor ejemplo:\n    std::cout << f_46(10); // Outputs: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n El límite superior del rango para verificar múltiplos.\n@return La suma de los múltiplos de 3 o 5 dentro del rango.", "arb": "يحسب مجموع جميع الأرقام من 1 إلى n التي هي مضاعفات إما لـ 3 أو 5.\n\nيحسب كل رقم مرة واحدة فقط حتى لو كان مضاعفًا لكل من 3 و 5. على سبيل المثال:\n    std::cout << f_46(10); // المخرجات: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n الحد الأعلى للنطاق للتحقق من المضاعفات.\n@return مجموع المضاعفات إما لـ 3 أو 5 ضمن النطاق.", "sw": "Hesabu jumla ya namba zote kutoka 1 hadi n ambazo ni maradufu ya aidha 3 au 5.\n\nHesabu kila namba mara moja tu hata kama ni maradufu ya 3 na 5.\nKwa mfano:\n    std::cout << f_46(10); // Inatoa: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n Kikomo cha juu cha safu ya kuangalia maradufu.\n@return Jumla ya maradufu ya aidha 3 au 5 ndani ya safu.", "tr": "1'den n'ye kadar olan sayılardan 3 veya 5'in katı olanların toplamını hesaplar.\n\nBir sayı hem 3 hem de 5'in katı olsa bile her sayıyı yalnızca bir kez sayar.\nÖrneğin:\n    std::cout << f_46(10); // Çıktı: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n Katları kontrol etmek için aralığın üst sınırı.\n@return Aralık içindeki 3 veya 5'in katlarının toplamı.", "vi": "Tính tổng của tất cả các số từ 1 đến n mà là bội số của 3 hoặc 5.\n\nĐếm mỗi số chỉ một lần ngay cả khi nó là bội số của cả 3 và 5.\nVí dụ:\n    std::cout << f_46(10); // Kết quả: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n Giới hạn trên của phạm vi để kiểm tra bội số.\n@return Tổng của các bội số của 3 hoặc 5 trong phạm vi.", "id": "Menghitung jumlah semua angka dari 1 hingga n yang merupakan kelipatan dari 3 atau 5.\n\nMenghitung setiap angka hanya sekali meskipun merupakan kelipatan dari 3 dan 5.\nSebagai contoh:\n    std::cout << f_46(10); // Menghasilkan: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n Batas atas dari rentang untuk memeriksa kelipatan.\n@return Jumlah dari kelipatan 3 atau 5 dalam rentang tersebut.", "ja": "1からnまでのすべての数のうち、3または5の倍数であるものの合計を計算します。\n\n3と5の両方の倍数である場合でも、各数を一度だけカウントします。\n例えば:\n    std::cout << f_46(10); // 出力: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n 倍数をチェックする範囲の上限。\n@return 範囲内の3または5の倍数の合計。", "ko": "1부터 n까지의 숫자 중 3 또는 5의 배수인 모든 숫자의 합을 계산합니다.\n\n3과 5의 공배수인 경우에도 각 숫자는 한 번만 계산됩니다.\n예를 들어:\n    std::cout << f_46(10); // 출력: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n 배수를 확인할 범위의 상한값입니다.\n@return 범위 내에서 3 또는 5의 배수의 합을 반환합니다.", "ml": "1 മുതൽ n വരെ 3 അല്ലെങ്കിൽ 5 ന്റെ ഗുണകങ്ങൾ ആയ എല്ലാ സംഖ്യകളുടെയും മൊത്തം കണക്കാക്കുന്നു.\n\n3 നും 5 നും ഇരട്ടിയുള്ള നമ്പറുകൾ ആയാലും ഓരോ നമ്പറും ഒരിക്കൽ മാത്രം എണ്ണുന്നു.\nഉദാഹരണത്തിന്:\n    std::cout << f_46(10); // Outputs: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n 3 നും 5 നും ഇരട്ടിയുള്ളവകൾ പരിശോധിക്കാനുള്ള പരിധിയുടെ മുകളിലെ പരിധി.\n@return പരിധിക്കുള്ളിൽ 3 നും 5 നും ഇരട്ടിയുള്ളവയുടെ മൊത്തം.", "fa": "محاسبه مجموع تمام اعداد از 1 تا n که مضربی از 3 یا 5 هستند.\n\nهر عدد فقط یک بار شمارش می‌شود حتی اگر مضربی از هر دو 3 و 5 باشد.\nبرای مثال:\n    std::cout << f_46(10); // خروجی: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n حد بالای دامنه برای بررسی مضرب‌ها.\n@return مجموع مضرب‌های 3 یا 5 درون دامنه."}}
{"task_id": "CPP/47", "prompt": {"en": "#include <cassert>\n#include <cctype> // For isalnum and tolower\n#include <cstring> // For strlen\n/**\n * Determine if a given string is a palindrome. A palindrome is a word, phrase,\n * number, or other sequence of characters that reads the same forward and\n * backward (ignoring spaces, punctuation, and capitalization).\n * Examples:\n *   >>> f_47(\"racecar\")\n *   true\n *   >>> f_47(\"hello\")\n *   false\n */\nbool f_47(const char* str)", "sq": "#include <cassert>\n#include <cctype> // Për isalnum dhe tolower\n#include <cstring> // Për strlen\n/**\n * Përcaktoni nëse një varg i dhënë është një palindrom. Një palindrom është një fjalë, frazë,\n * numër, ose sekuencë tjetër karakteresh që lexohet njësoj përpara dhe\n * prapa (duke injoruar hapësirat, shenjat e pikësimit dhe kapitalizimin).\n * Shembuj:\n *   >>> f_47(\"racecar\")\n *   true\n *   >>> f_47(\"hello\")\n *   false\n */\nbool f_47(const char* str)", "hy": "#include <cassert>\n#include <cctype> // isalnum և tolower-ի համար\n#include <cstring> // strlen-ի համար\n/**\n * Սահմանել, արդյոք տրված տողը պալինդրոմ է: Պալինդրոմը բառ է, արտահայտություն,\n * թիվ կամ այլ նիշերի հաջորդականություն, որը կարդացվում է նույն ձևով առաջ և\n * հետ (անտեսելով բացատները, կետադրությունը և մեծատառերը):\n * Օրինակներ:\n *   >>> f_47(\"racecar\")\n *   true\n *   >>> f_47(\"hello\")\n *   false\n */\nbool f_47(const char* str)", "bn": "#include <cassert>\n#include <cctype> // isalnum এবং tolower এর জন্য\n#include <cstring> // strlen এর জন্য\n/**\n * নির্ধারণ করুন একটি প্রদত্ত স্ট্রিং প্যালিনড্রোম কিনা। একটি প্যালিনড্রোম হল একটি শব্দ, বাক্যাংশ,\n * সংখ্যা, বা অন্যান্য অক্ষরের ক্রম যা সামনের দিকে এবং\n * পিছনের দিকে একইভাবে পড়ে (স্পেস, বিরামচিহ্ন, এবং বড় হাতের অক্ষর উপেক্ষা করে)।\n * উদাহরণ:\n *   >>> f_47(\"racecar\")\n *   true\n *   >>> f_47(\"hello\")\n *   false\n */\nbool f_47(const char* str)", "bg": "#include <cassert>\n#include <cctype> // За isalnum и tolower\n#include <cstring> // За strlen\n/**\n * Определете дали даден низ е палиндром. Палиндром е дума, фраза,\n * число или друга последователност от символи, която се чете еднакво напред и\n * назад (като се игнорират интервали, пунктуация и главни букви).\n * Примери:\n *   >>> f_47(\"racecar\")\n *   true\n *   >>> f_47(\"hello\")\n *   false\n */\nbool f_47(const char* str)", "zh": "#include <cassert>\n#include <cctype> // For isalnum and tolower\n#include <cstring> // For strlen\n/**\n * 确定给定的字符串是否是回文。回文是指正读和反读都相同的单词、短语、\n * 数字或其他字符序列（忽略空格、标点和大小写）。\n * 例子:\n *   >>> f_47(\"racecar\")\n *   true\n *   >>> f_47(\"hello\")\n *   false\n */\nbool f_47(const char* str)", "fr": "#include <cassert>\n#include <cctype> // Pour isalnum et tolower\n#include <cstring> // Pour strlen\n/**\n * Déterminer si une chaîne de caractères donnée est un palindrome. Un palindrome est un mot, une phrase,\n * un nombre ou une autre séquence de caractères qui se lit de la même manière à l'endroit et à l'envers\n * (en ignorant les espaces, la ponctuation et la capitalisation).\n * Exemples :\n *   >>> f_47(\"racecar\")\n *   true\n *   >>> f_47(\"hello\")\n *   false\n */\nbool f_47(const char* str)", "de": "#include <cassert>\n#include <cctype> // Für isalnum und tolower\n#include <cstring> // Für strlen\n/**\n * Bestimmen, ob ein gegebener String ein Palindrom ist. Ein Palindrom ist ein Wort, ein Satz,\n * eine Zahl oder eine andere Zeichenfolge, die vorwärts und rückwärts gleich gelesen wird\n * (unter Ignorierung von Leerzeichen, Satzzeichen und Groß-/Kleinschreibung).\n * Beispiele:\n *   >>> f_47(\"racecar\")\n *   true\n *   >>> f_47(\"hello\")\n *   false\n */\nbool f_47(const char* str)", "ha": "#include <cassert>\n#include <cctype> // Don amfani da isalnum da tolower\n#include <cstring> // Don amfani da strlen\n/**\n * Tantance idan wani kirtani da aka bayar palindrome ne. Palindrome kalma ce, jimla,\n * lamba, ko wata jerin haruffa da ake karantawa iri daya gaba da baya\n * (ba tare da la'akari da sarari, rubutu, da manyan baki ba).\n * Misalai:\n *   >>> f_47(\"racecar\")\n *   true\n *   >>> f_47(\"hello\")\n *   false\n */\nbool f_47(const char* str)", "hi": "#include <cassert>\n#include <cctype> // isalnum और tolower के लिए\n#include <cstring> // strlen के लिए\n/**\n * यह निर्धारित करें कि दिया गया स्ट्रिंग एक पालिंड्रोम है या नहीं। एक पालिंड्रोम एक शब्द, वाक्यांश,\n * संख्या, या अन्य वर्णों का अनुक्रम है जो आगे और पीछे से पढ़ने पर समान होता है\n * (स्पेस, विराम चिह्न, और कैपिटलाइज़ेशन को नजरअंदाज करते हुए)।\n * उदाहरण:\n *   >>> f_47(\"racecar\")\n *   true\n *   >>> f_47(\"hello\")\n *   false\n */\nbool f_47(const char* str)", "hu": "#include <cassert>\n#include <cctype> // isalnum és tolower használatához\n#include <cstring> // strlen használatához\n/**\n * Meghatározza, hogy egy adott string palindróm-e. Egy palindróm egy szó, kifejezés,\n * szám vagy más karakterlánc, amely előre és hátrafelé olvasva is ugyanaz\n * (figyelmen kívül hagyva a szóközöket, írásjeleket és nagybetűket).\n * Példák:\n *   >>> f_47(\"racecar\")\n *   true\n *   >>> f_47(\"hello\")\n *   false\n */\nbool f_47(const char* str)", "es": "#include <cassert>\n#include <cctype> // For isalnum and tolower\n#include <cstring> // For strlen\n/**\n * Determinar si una cadena dada es un palíndromo. Un palíndromo es una palabra, frase,\n * número u otra secuencia de caracteres que se lee igual de adelante hacia atrás\n * y de atrás hacia adelante (ignorando espacios, puntuación y mayúsculas).\n * Ejemplos:\n *   >>> f_47(\"racecar\")\n *   true\n *   >>> f_47(\"hello\")\n *   false\n */\nbool f_47(const char* str)", "arb": "#include <cassert>\n#include <cctype> // For isalnum and tolower\n#include <cstring> // For strlen\n/**\n * تحديد ما إذا كانت سلسلة معينة هي كلمة متكاملة. الكلمة المتكاملة هي كلمة أو عبارة أو\n * رقم أو تسلسل آخر من الأحرف الذي يقرأ نفسه بنفس الطريقة من الأمام إلى الخلف\n * والعكس صحيح (مع تجاهل المسافات وعلامات الترقيم والحروف الكبيرة).\n * أمثلة:\n *   >>> f_47(\"racecar\")\n *   true\n *   >>> f_47(\"hello\")\n *   false\n */\nbool f_47(const char* str)", "sw": "#include <cassert>\n#include <cctype> // For isalnum and tolower\n#include <cstring> // For strlen\n/**\n * Kuamua kama kamba iliyotolewa ni palindrome. Palindrome ni neno, kifungu,\n * nambari, au mlolongo mwingine wa herufi ambao unasomwa sawa mbele na\n * nyuma (ukipuuza nafasi, alama za uakifishaji, na herufi kubwa).\n * Mifano:\n *   >>> f_47(\"racecar\")\n *   true\n *   >>> f_47(\"hello\")\n *   false\n */\nbool f_47(const char* str)", "tr": "#include <cassert>\n#include <cctype> // isalnum ve tolower için\n#include <cstring> // strlen için\n/**\n * Verilen bir dizgenin palindrom olup olmadığını belirleyin. Palindrom, ileri ve\n * geri okunduğunda aynı olan (boşluklar, noktalama işaretleri ve büyük/küçük harf farkı göz ardı edilerek)\n * kelime, ifade, sayı veya diğer karakter dizisidir.\n * Örnekler:\n *   >>> f_47(\"racecar\")\n *   true\n *   >>> f_47(\"hello\")\n *   false\n */\nbool f_47(const char* str)", "vi": "#include <cassert>\n#include <cctype> // For isalnum and tolower\n#include <cstring> // For strlen\n/**\n * Xác định xem một chuỗi đã cho có phải là palindrome hay không. Một palindrome là một từ, cụm từ,\n * số, hoặc chuỗi ký tự khác mà đọc xuôi hay ngược đều giống nhau (bỏ qua khoảng trắng, dấu câu, và chữ hoa).\n * Ví dụ:\n *   >>> f_47(\"racecar\")\n *   true\n *   >>> f_47(\"hello\")\n *   false\n */\nbool f_47(const char* str)", "id": "#include <cassert>\n#include <cctype> // Untuk isalnum dan tolower\n#include <cstring> // Untuk strlen\n/**\n * Menentukan apakah string yang diberikan adalah palindrom. Palindrom adalah sebuah kata, frasa,\n * angka, atau urutan karakter lain yang dibaca sama maju dan mundur (mengabaikan spasi, tanda baca, dan kapitalisasi).\n * Contoh:\n *   >>> f_47(\"racecar\")\n *   true\n *   >>> f_47(\"hello\")\n *   false\n */\nbool f_47(const char* str)", "ja": "#include <cassert>\n#include <cctype> // For isalnum and tolower\n#include <cstring> // For strlen\n/**\n * 与えられた文字列が回文かどうかを判断します。回文とは、前から読んでも後ろから読んでも同じになる単語、フレーズ、数字、またはその他の文字列のことです（スペース、句読点、大文字小文字を無視します）。\n * 例:\n *   >>> f_47(\"racecar\")\n *   true\n *   >>> f_47(\"hello\")\n *   false\n */\nbool f_47(const char* str)", "ko": "#include <cassert>\n#include <cctype> // isalnum 및 tolower를 위해\n#include <cstring> // strlen을 위해\n/**\n * 주어진 문자열이 회문인지 확인합니다. 회문은 단어, 구, 숫자 또는 다른 문자\n * 시퀀스로, 앞뒤로 읽을 때 동일한 시퀀스를 의미합니다 (공백, 구두점, 대소문자를 무시합니다).\n * 예시:\n *   >>> f_47(\"racecar\")\n *   true\n *   >>> f_47(\"hello\")\n *   false\n */\nbool f_47(const char* str)\n", "ml": "#include <cassert>\n#include <cctype> // isalnum, tolower എന്നിവയ്ക്കായി\n#include <cstring> // strlen നായി\n/**\n * ഒരു നൽകിയ സ്ട്രിംഗ് പാലിൻഡ്രോമാണോ എന്ന് നിർണയിക്കുക. ഒരു പാലിൻഡ്രോം എന്നത് ഒരു വാക്ക്, വാചകം,\n * സംഖ്യ, അല്ലെങ്കിൽ മറ്റേതെങ്കിലും അക്ഷരങ്ങളുടെ ശ്രേണിയാണ്, ഇത് മുന്നോട്ടും\n * പിന്നോട്ടും ഒരേപോലെ വായിക്കപ്പെടുന്നു (വിരാമചിഹ്നങ്ങൾ, പങ്ക്‌ചുവേഷൻ, ക്യാപിറ്റലൈസേഷൻ എന്നിവ അവഗണിക്കുന്നു).\n * ഉദാഹരണങ്ങൾ:\n *   >>> f_47(\"racecar\")\n *   true\n *   >>> f_47(\"hello\")\n *   false\n */\nbool f_47(const char* str)", "fa": "#include <cassert>\n#include <cctype> // برای isalnum و tolower\n#include <cstring> // برای strlen\n/**\n * تعیین کنید که آیا یک رشته داده شده یک پالیندروم است یا خیر. پالیندروم کلمه، عبارت،\n * عدد یا دنباله‌ای از کاراکترها است که به همان صورت از جلو و عقب خوانده می‌شود\n * (با نادیده گرفتن فاصله‌ها، نشانه‌گذاری و حروف بزرگ و کوچک).\n * مثال‌ها:\n *   >>> f_47(\"racecar\")\n *   true\n *   >>> f_47(\"hello\")\n *   false\n */\nbool f_47(const char* str)"}, "canonical_solution": "{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}", "instruction": {"en": "bool f_47(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.", "sq": "bool f_47(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}\n\nJepni një përshkrim të shkurtër në gjuhën natyrore (docstring) të kodit CPP në shqip duke përdorur maksimumi 500 karaktere.", "hy": "bool f_47(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}\n\nՏվեք CPP կոդի համառոտ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "bool f_47(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}\n\nসিপিপি কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।", "bg": "bool f_47(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}\n\nПредоставете кратко описание на CPP кода на естествен език (docstring) на български, използвайки най-много 500 знака.", "zh": "bool f_47(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}\n\n将以下CPP代码的自然语言描述（文档字符串）用中文简明扼要地提供，字数不超过500个字符。", "fr": "bool f_47(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}\n\nFournissez une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.", "de": "bool f_47(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen.", "ha": "bool f_47(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}\n\nBa da takaitaccen bayanin yanayi na halitta (docstring) na lambar CPP cikin Hausa ta amfani da haruffa 500 kawai.", "hi": "bool f_47(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।", "hu": "bool f_47(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a CPP kódról magyarul, legfeljebb 500 karakterben.", "es": "bool f_47(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando como máximo 500 caracteres.", "arb": "bool f_47(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة CPP باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.", "sw": "bool f_47(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "bool f_47(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}\n\nAşağıdaki CPP kodunun işlevini açıklayan en fazla 500 karakterlik öz bir doğal dil açıklaması (docstring) sağlayın.", "vi": "bool f_47(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự.", "id": "bool f_47(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode CPP dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "bool f_47(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}\n\n以下のCPPコードの簡潔な自然言語による説明（ドックストリング）を日本語で500文字以内で提供してください。", "ko": "bool f_47(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}\n\n다음 CPP 코드에 대한 간결한 자연어 설명(도크스트링)을 최대 500자 이내로 한국어로 제공하세요.", "ml": "bool f_47(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}\n\nസിപിപി കോഡിന്റെ സംക്ഷിപ്തമായ സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) മലയാളത്തിൽ 500 പ്രതീകങ്ങൾക്കുള്ളിൽ നൽകുക.", "fa": "bool f_47(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}\n\nتوضیح مختصر و طبیعی (docstring) از کد CPP به زبان فارسی با حداکثر ۵۰۰ کاراکتر ارائه دهید."}, "level": "", "test": "int main()\n{\n    assert(f_47(\"A man a plan a canal Panama\") == true);\n    assert(f_47(\"No lemon, no melon\") == true);\n    assert(f_47(\"Was it a car or a cat I saw\") == true);\n    assert(f_47(\"Madam, in Eden, I'm Adam\") == true);\n    assert(f_47(\"Never odd or even\") == true);\n    assert(f_47(\"Eva, can I see bees in a cave\") == true);\n    assert(f_47(\"hello\") == false);\n    assert(f_47(\"GitHub\") == false);\n    assert(f_47(\"programming\") == false);\n    \n    return 0;\n}", "entry_point": "f_47", "signature": "bool f_47(const char* str)", "docstring": {"en": "Determine if a given string is a palindrome. A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward (ignoring spaces, punctuation, and capitalization).\nExamples:\n  >>> f_47(\"racecar\")\n  true\n  >>> f_47(\"hello\")\n  false", "sq": "Përcaktoni nëse një varg i dhënë është një palindrom. Një palindrom është një fjalë, frazë, numër, ose sekuencë tjetër karakteresh që lexohet njësoj përpara dhe prapa (duke injoruar hapësirat, shenjat e pikësimit dhe kapitalizimin).\nShembuj:\n  >>> f_47(\"racecar\")\n  true\n  >>> f_47(\"hello\")\n  false", "hy": "Սահմանել, արդյոք տրված տողը պալինդրոմ է: Պալինդրոմը բառ է, արտահայտություն, թիվ կամ այլ նիշերի հաջորդականություն, որը կարդացվում է նույնը առաջ և հետ (անտեսելով բացատները, կետադրությունը և մեծատառերը):\nՕրինակներ:\n  >>> f_47(\"racecar\")\n  true\n  >>> f_47(\"hello\")\n  false", "bn": "একটি প্রদত্ত স্ট্রিং প্যালিনড্রোম কিনা তা নির্ধারণ করুন। একটি প্যালিনড্রোম হল একটি শব্দ, বাক্যাংশ, সংখ্যা, বা অন্যান্য অক্ষরের ক্রম যা সামনের দিকে এবং পিছনের দিকে একইভাবে পড়ে (স্পেস, বিরামচিহ্ন এবং বড় হাতের অক্ষর উপেক্ষা করে)।\n\nউদাহরণ:\n  >>> f_47(\"racecar\")\n  true\n  >>> f_47(\"hello\")\n  false", "bg": "Определете дали даден низ е палиндром. Палиндром е дума, фраза, число или друга последователност от символи, която се чете еднакво напред и назад (като се игнорират интервали, пунктуация и главни букви).\nПримери:\n  >>> f_47(\"racecar\")\n  true\n  >>> f_47(\"hello\")\n  false", "zh": "确定给定的字符串是否是回文。回文是指无论正向还是反向读取都相同的单词、短语、数字或其他字符序列（忽略空格、标点和大小写）。\n\n示例：\n  >>> f_47(\"racecar\")\n  true\n  >>> f_47(\"hello\")\n  false", "fr": "Déterminer si une chaîne donnée est un palindrome. Un palindrome est un mot, une phrase, un nombre ou une autre séquence de caractères qui se lit de la même façon à l'endroit et à l'envers (en ignorant les espaces, la ponctuation et la capitalisation).\nExemples :\n  >>> f_47(\"racecar\")\n  true\n  >>> f_47(\"hello\")\n  false", "de": "Bestimmen Sie, ob ein gegebener String ein Palindrom ist. Ein Palindrom ist ein Wort, ein Satz, eine Zahl oder eine andere Zeichenfolge, die vorwärts und rückwärts gleich gelesen wird (unter Ignorieren von Leerzeichen, Satzzeichen und Groß-/Kleinschreibung).\nBeispiele:\n  >>> f_47(\"racecar\")\n  true\n  >>> f_47(\"hello\")\n  false", "ha": "Gano idan wata kirtani da aka bayar palindrome ne. Palindrome kalma ce, jimla, lamba, ko wata jerin haruffa da ke karantawa iri ɗaya gaba da baya (ba tare da la'akari da sarari, rubutu, da manyan ba).\n\nMisalai:\n  >>> f_47(\"racecar\")\n  true\n  >>> f_47(\"hello\")\n  false", "hi": "दिया गया स्ट्रिंग एक पालिंड्रोम है या नहीं, यह निर्धारित करें। एक पालिंड्रोम एक शब्द, वाक्यांश, संख्या, या अन्य वर्णों का अनुक्रम है जो आगे और पीछे से समान रूप से पढ़ा जाता है (स्थान, विराम चिह्न, और बड़े अक्षरों की अनदेखी करते हुए)।\n\nउदाहरण:\n  >>> f_47(\"racecar\")\n  true\n  >>> f_47(\"hello\")\n  false", "hu": "Határozza meg, hogy egy adott karakterlánc palindróm-e. A palindróm egy olyan szó, kifejezés, szám vagy más karakterlánc, amely előre és visszafelé olvasva is ugyanaz (figyelmen kívül hagyva a szóközöket, írásjeleket és nagybetűket).\n\nPéldák:\n  >>> f_47(\"racecar\")\n  true\n  >>> f_47(\"hello\")\n  false", "es": "Determinar si una cadena dada es un palíndromo. Un palíndromo es una palabra, frase, número u otra secuencia de caracteres que se lee igual de adelante hacia atrás (ignorando espacios, puntuación y mayúsculas).\n\nEjemplos:\n  >>> f_47(\"racecar\")\n  true\n  >>> f_47(\"hello\")\n  false", "arb": "تحديد ما إذا كانت سلسلة معينة هي جملة مقلوبة. الجملة المقلوبة هي كلمة أو عبارة أو رقم أو تسلسل آخر من الأحرف التي تُقرأ بنفس الطريقة للأمام والخلف (مع تجاهل المسافات وعلامات الترقيم والحروف الكبيرة).\n\nأمثلة:\n  >>> f_47(\"racecar\")\n  true\n  >>> f_47(\"hello\")\n  false", "sw": "Amua kama kamba fulani ni palindrome. Palindrome ni neno, kifungu, nambari, au mlolongo mwingine wa herufi ambao unasomwa sawa mbele na nyuma (kupuuza nafasi, alama za uakifishaji, na herufi kubwa na ndogo).\n\nMifano:\n  >>> f_47(\"racecar\")\n  true\n  >>> f_47(\"hello\")\n  false", "tr": "Verilen bir stringin palindrom olup olmadığını belirleyin. Palindrom, ileri ve geri okunduğunda aynı olan (boşluklar, noktalama işaretleri ve büyük/küçük harf duyarlılığı göz ardı edilerek) bir kelime, ifade, sayı veya başka bir karakter dizisidir.\nÖrnekler:\n  >>> f_47(\"racecar\")\n  true\n  >>> f_47(\"hello\")\n  false", "vi": "Xác định xem một chuỗi cho trước có phải là palindrome hay không. Một palindrome là một từ, cụm từ, số, hoặc chuỗi ký tự khác mà đọc xuôi hay ngược đều giống nhau (bỏ qua khoảng trắng, dấu câu và chữ hoa chữ thường).\n\nVí dụ:\n  >>> f_47(\"racecar\")\n  true\n  >>> f_47(\"hello\")\n  false", "id": "Menentukan apakah string yang diberikan adalah palindrom. Palindrom adalah sebuah kata, frasa, angka, atau urutan karakter lain yang dibaca sama dari depan ke belakang (mengabaikan spasi, tanda baca, dan kapitalisasi).\nContoh:\n  >>> f_47(\"racecar\")\n  true\n  >>> f_47(\"hello\")\n  false", "ja": "与えられた文字列が回文であるかどうかを判断します。回文とは、前から読んでも後ろから読んでも同じになる単語、フレーズ、数字、またはその他の文字列のことです（スペース、句読点、大文字小文字は無視します）。\n\n例:\n  >>> f_47(\"racecar\")\n  true\n  >>> f_47(\"hello\")\n  false", "ko": "주어진 문자열이 회문인지 확인합니다. 회문은 앞뒤로 읽어도 동일한 단어, 구, 숫자 또는 기타 문자 시퀀스를 말합니다 (공백, 구두점 및 대소문자는 무시).\n\n예시:\n  >>> f_47(\"racecar\")\n  true\n  >>> f_47(\"hello\")\n  false", "ml": "ഒരു നൽകിയ സ്റ്റ്രിംഗ് പലിൻഡ്രോം ആണോ എന്ന് നിർണ്ണയിക്കുക. പലിൻഡ്രോം എന്നത് ഒരു വാക്ക്, വാചകം, സംഖ്യ, അല്ലെങ്കിൽ മറ്റ് പ്രതീകങ്ങളുടെ നിരയാണ്, ഇത് മുന്നോട്ടും പിന്നോട്ടും ഒരുപോലെ വായിക്കപ്പെടുന്നു (വിരാമചിഹ്നങ്ങളും, പുനർവിന്യാസങ്ങളും, വലുതും ചെറുതുമായ അക്ഷരങ്ങൾ അവഗണിക്കുന്നു).\n\nഉദാഹരണങ്ങൾ:\n  >>> f_47(\"racecar\")\n  true\n  >>> f_47(\"hello\")\n  false", "fa": "برای strlen\n/**\n * تعیین کنید که آیا یک رشته داده شده یک پالیندروم است یا خیر. پالیندروم کلمه، عبارت،\n * عدد یا دنباله‌ای از کاراکترها است که به همان صورت از جلو و عقب خوانده می‌شود\n * (با نادیده گرفتن فاصله‌ها، نشانه‌گذاری و حروف بزرگ و کوچک).\nمثال‌ها:\n  >>> f_47(\"racecar\")\n  true\n  >>> f_47(\"hello\")\n  false"}}
{"task_id": "CPP/48", "prompt": {"en": "#include <cassert>\n#include <cstdio>\n/*\nGiven a non-negative integer num, this function reduces it to a single digit by repeatedly adding all its digits.\nFor example:\n    >>> f_48(38)\n    2\nThe calculation is because 3 + 8 = 11, and further 1 + 1 = 2. 2 is returned since it is a single-digit number.\n*/\nint f_48(int num)", "sq": "#include <cassert>\n#include <cstdio>\n/*\nDuke pasur një numër të plotë jo-negativ num, kjo funksion e redukton atë në një shifër të vetme duke shtuar vazhdimisht të gjitha shifrat e tij.\nPër shembull:\n    >>> f_48(38)\n    2\nLlogaritja është sepse 3 + 8 = 11, dhe më tej 1 + 1 = 2. 2 kthehet pasi është një numër me një shifër.\n*/\nint f_48(int num)", "hy": "#include <cassert>\n#include <cstdio>\n/*\nՏրված է ոչ բացասական ամբողջ թիվ num, այս ֆունկցիան այն նվազեցնում է մինչև միանիշ՝ կրկնակիորեն գումարելով նրա բոլոր թվանշանները:\nՕրինակ:\n    >>> f_48(38)\n    2\nՀաշվարկը կատարվում է, քանի որ 3 + 8 = 11, և հետագայում 1 + 1 = 2: Վերադարձվում է 2, քանի որ դա միանիշ թիվ է:\n*/\nint f_48(int num)", "bn": "#include <cassert>\n#include <cstdio>\n/*\nএকটি অ-ঋণাত্মক পূর্ণসংখ্যা num দেওয়া হয়েছে, এই ফাংশনটি বারবার এর সমস্ত অঙ্ক যোগ করে এটিকে একটি একক অঙ্কে হ্রাস করে।\nউদাহরণস্বরূপ:\n    >>> f_48(38)\n    2\nগণনা হল কারণ 3 + 8 = 11, এবং আরও 1 + 1 = 2। 2 ফেরত দেওয়া হয় যেহেতু এটি একটি একক অঙ্কের সংখ্যা।\n*/\nint f_48(int num)", "bg": "#include <cassert>\n#include <cstdio>\n/*\nДадено е неотрицателно цяло число num, тази функция го свежда до едноцифрено число, като многократно събира всички негови цифри.\nНапример:\n    >>> f_48(38)\n    2\nИзчислението е, защото 3 + 8 = 11, и по-нататък 1 + 1 = 2. 2 се връща, тъй като е едноцифрено число.\n*/\nint f_48(int num)", "zh": "#include <cassert>\n#include <cstdio>\n/*\n给定一个非负整数 num，此函数通过重复相加其所有数字将其减少到一位数字。\n例如：\n    >>> f_48(38)\n    2\n计算过程是因为 3 + 8 = 11，进一步 1 + 1 = 2。返回 2 因为它是一个一位数。\n*/\nint f_48(int num)", "fr": "#include <cassert>\n#include <cstdio>\n/*\nÉtant donné un entier non négatif num, cette fonction le réduit à un seul chiffre en ajoutant de manière répétée tous ses chiffres.\nPar exemple :\n    >>> f_48(38)\n    2\nLe calcul est le suivant : 3 + 8 = 11, et ensuite 1 + 1 = 2. 2 est retourné car c'est un nombre à un seul chiffre.\n*/\nint f_48(int num)", "de": "#include <cassert>\n#include <cstdio>\n/*\nGegeben eine nicht-negative ganze Zahl num, reduziert diese Funktion sie auf eine einstellige Zahl, indem sie wiederholt alle ihre Ziffern addiert.\nZum Beispiel:\n    >>> f_48(38)\n    2\nDie Berechnung erfolgt, weil 3 + 8 = 11 und weiter 1 + 1 = 2. 2 wird zurückgegeben, da es eine einstellige Zahl ist.\n*/\nint f_48(int num)", "ha": "#include <cassert>\n#include <cstdio>\n/*\nAn ba da wani lamba mara kyau num, wannan aikin yana rage shi zuwa lamba guda ta hanyar ƙara duk lambobinsa akai-akai.\nMisali:\n    >>> f_48(38)\n    2\nLissafin yana nufin 3 + 8 = 11, kuma gaba 1 + 1 = 2. 2 ana dawowa da shi tunda lamba guda ce.\n*/\nint f_48(int num)", "hi": "#include <cassert>\n#include <cstdio>\n/*\nदिया गया एक गैर-ऋणात्मक पूर्णांक num, यह फ़ंक्शन इसे एकल अंक में घटाता है सभी अंकों को बार-बार जोड़कर।\nउदाहरण के लिए:\n    >>> f_48(38)\n    2\nगणना इसलिए है क्योंकि 3 + 8 = 11, और आगे 1 + 1 = 2. 2 लौटाया जाता है क्योंकि यह एकल अंक संख्या है।\n*/\nint f_48(int num)", "hu": "#include <cassert>\n#include <cstdio>\n/*\nEgy nem negatív egész számot megadva, ez a függvény egyetlen számjegyre csökkenti azt az összes számjegyének ismételt összeadásával.\nPéldául:\n    >>> f_48(38)\n    2\nA számítás azért van, mert 3 + 8 = 11, és tovább 1 + 1 = 2. 2 kerül visszaadásra, mivel ez egy egyjegyű szám.\n*/\nint f_48(int num)", "es": "#include <cassert>\n#include <cstdio>\n/*\nDado un número entero no negativo num, esta función lo reduce a un solo dígito sumando repetidamente todos sus dígitos.\nPor ejemplo:\n    >>> f_48(38)\n    2\nEl cálculo es porque 3 + 8 = 11, y además 1 + 1 = 2. Se devuelve 2 ya que es un número de un solo dígito.\n*/\nint f_48(int num)", "arb": "#include <cassert>\n#include <cstdio>\n/*\nبالنظر إلى عدد صحيح غير سالب num، تقوم هذه الدالة بتقليله إلى رقم واحد عن طريق جمع جميع أرقامه بشكل متكرر.\nعلى سبيل المثال:\n    >>> f_48(38)\n    2\nالحساب هو لأن 3 + 8 = 11، ومزيد من 1 + 1 = 2. يتم إرجاع 2 لأنه رقم مكون من خانة واحدة.\n*/\nint f_48(int num)", "sw": "#include <cassert>\n#include <cstdio>\n/*\nIkizingatiwa nambari isiyo hasi num, kazi hii inapunguza hadi tarakimu moja kwa kuongeza mara kwa mara tarakimu zake zote.\nKwa mfano:\n    >>> f_48(38)\n    2\nHesabu ni kwa sababu 3 + 8 = 11, na zaidi 1 + 1 = 2. 2 inarudishwa kwa kuwa ni nambari ya tarakimu moja.\n*/\nint f_48(int num)", "tr": "#include <cassert>\n#include <cstdio>\n/*\nVerilen negatif olmayan bir tam sayı num, bu fonksiyon tüm basamaklarını tekrar tekrar toplayarak tek bir rakama indirger.\nÖrneğin:\n    >>> f_48(38)\n    2\nHesaplama, 3 + 8 = 11 ve daha sonra 1 + 1 = 2 olduğu içindir. 2, tek basamaklı bir sayı olduğu için döndürülür.\n*/\nint f_48(int num)", "vi": "#include <cassert>\n#include <cstdio>\n/*\nCho một số nguyên không âm num, hàm này giảm nó xuống một chữ số bằng cách liên tục cộng tất cả các chữ số của nó.\nVí dụ:\n    >>> f_48(38)\n    2\nPhép tính là vì 3 + 8 = 11, và tiếp tục 1 + 1 = 2. 2 được trả về vì nó là một số có một chữ số.\n*/\nint f_48(int num)", "id": "#include <cassert>\n#include <cstdio>\n/*\nDiberikan bilangan bulat non-negatif num, fungsi ini menguranginya menjadi satu digit dengan menambahkan semua digitnya berulang kali.\nSebagai contoh:\n    >>> f_48(38)\n    2\nPerhitungannya adalah karena 3 + 8 = 11, dan selanjutnya 1 + 1 = 2. 2 dikembalikan karena itu adalah angka satu digit.\n*/\nint f_48(int num)", "ja": "#include <cassert>\n#include <cstdio>\n/*\n非負整数 num が与えられたとき、この関数はその桁をすべて足し合わせて1桁に減らします。\n例えば:\n    >>> f_48(38)\n    2\n計算は 3 + 8 = 11 で、さらに 1 + 1 = 2 です。2 は1桁の数なので返されます。\n*/\nint f_48(int num)", "ko": "#include <cassert>\n#include <cstdio>\n/*\n비음수 정수 num이 주어졌을 때, 이 함수는 모든 자릿수를 반복적으로 더하여 한 자리 숫자로 줄입니다.\n예를 들어:\n    >>> f_48(38)\n    2\n계산은 3 + 8 = 11이고, 더 나아가 1 + 1 = 2입니다. 2는 한 자리 숫자이기 때문에 반환됩니다.\n*/\nint f_48(int num)", "ml": "#include <cassert>\n#include <cstdio>\n/*\nഒരു നെഗറ്റീവ് അല്ലാത്ത പൂർണ്ണസംഖ്യ നൽകിയാൽ, ഈ ഫംഗ്ഷൻ അതിന്റെ എല്ലാ അക്കങ്ങളും ആവർത്തിച്ച് കൂട്ടി അത് ഒറ്റ അക്കമായി കുറയ്ക്കുന്നു.\nഉദാഹരണത്തിന്:\n    >>> f_48(38)\n    2\nകണക്കുകൂട്ടൽ 3 + 8 = 11 എന്നതിനാൽ, പിന്നെ 1 + 1 = 2. 2 ഒരു ഒറ്റ അക്ക സംഖ്യയായതിനാൽ മടക്കിവരുന്നു.\n*/\nint f_48(int num)", "fa": "#include <cassert>\n#include <cstdio>\n/*\nبا توجه به یک عدد صحیح غیر منفی num، این تابع آن را با جمع مکرر تمام ارقامش به یک رقم کاهش می‌دهد.\nبرای مثال:\n    >>> f_48(38)\n    2\nمحاسبه به این صورت است که 3 + 8 = 11، و بیشتر 1 + 1 = 2. 2 بازگردانده می‌شود زیرا یک عدد یک‌رقمی است.\n*/\nint f_48(int num)"}, "canonical_solution": "{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}", "instruction": {"en": "int f_48(int num)\n{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.", "sq": "int f_48(int num)\n{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit CPP në shqip duke përdorur maksimumi 500 karaktere.", "hy": "int f_48(int num)\n{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}\n\nՏվեք CPP կոդի համառոտ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "int f_48(int num)\n{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}\n\nনিচের CPP কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।", "bg": "int f_48(int num)\n{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}\n\nПредоставете кратко описание на CPP кода на естествен език на български, използвайки не повече от 500 символа.", "zh": "int f_48(int num)\n{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}\n\n请用最多500个字符的中文对该CPP代码提供简洁的自然语言描述（文档字符串）。", "fr": "int f_48(int num)\n{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}\n\nFournissez une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.", "de": "int f_48(int num)\n{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen.", "ha": "int f_48(int num)\n{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}\n\nBa da takaitaccen bayanin yaren halitta (docstring) na lambar CPP cikin Hausa ta amfani da haruffa 500 kawai.", "hi": "int f_48(int num)\n{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "int f_48(int num)\n{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a CPP kódról magyarul, legfeljebb 500 karakterben.", "es": "int f_48(int num)\n{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando como máximo 500 caracteres.", "arb": "int f_48(int num)\n{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لشفرة CPP باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.", "sw": "int f_48(int num)\n{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "int f_48(int num)\n{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}\n\nAşağıdaki CPP kodunun Türkçe'de en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.", "vi": "int f_48(int num)\n{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự.", "id": "int f_48(int num)\n{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode CPP dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "int f_48(int num)\n{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}\n\n以下のCPPコードの簡潔な自然言語による説明（ドックストリング）を日本語で500文字以内で提供してください。", "ko": "int f_48(int num)\n{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}\n\n다음 CPP 코드에 대한 간결한 자연어 설명(도크스트링)을 한국어로 최대 500자 이내로 제공하세요.", "ml": "int f_48(int num)\n{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}\n\nസിപിപി കോഡിന്റെ സംക്ഷിപ്തമായ സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) മലയാളത്തിൽ 500 അക്ഷരങ്ങളിൽ കവിയാതെ നൽകുക.", "fa": "int f_48(int num)\n{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}\n\nتوضیح مختصر به زبان طبیعی (docstring) از کد CPP به زبان فارسی ارائه دهید که حداکثر ۵۰۰ کاراکتر باشد."}, "level": "", "test": "int main() {\n    assert(f_48(38) == 2);\n    assert(f_48(0) == 0);\n    assert(f_48(9) == 9);\n    assert(f_48(123) == 6);\n    assert(f_48(456) == 6);\n    assert(f_48(9999) == 9);\n    assert(f_48(100) == 1);\n    assert(f_48(1010) == 2);\n    assert(f_48(1234) == 1);\n    assert(f_48(9876) == 3);\n    assert(f_48(199) == 1);\n    return 0;\n}", "entry_point": "f_48", "signature": "int f_48(int num)", "docstring": {"en": "Given a non-negative integer num, this function reduces it to a single digit by repeatedly adding all its digits.\nFor example:\n    >>> f_48(38)\n    2\nThe calculation is because 3 + 8 = 11, and further 1 + 1 = 2. 2 is returned since it is a single-digit number.\n", "sq": "Duke pasur një numër të plotë jo-negativ num, kjo funksion e redukton atë në një shifër të vetme duke mbledhur vazhdimisht të gjitha shifrat e tij.\nPër shembull:\n    >>> f_48(38)\n    2\nLlogaritja është sepse 3 + 8 = 11, dhe më tej 1 + 1 = 2. 2 kthehet pasi është një numër me një shifër.", "hy": "Տրված է ոչ բացասական ամբողջ թիվ num, այս ֆունկցիան այն նվազեցնում է մինչև մեկանիշ թիվ՝ բազմիցս գումարելով դրա բոլոր թվանշանները:\nՕրինակ:\n    >>> f_48(38)\n    2\nՀաշվարկը հետևյալն է՝ 3 + 8 = 11, և հետագայում 1 + 1 = 2: 2-ը վերադարձվում է, քանի որ այն մեկանիշ թիվ է:", "bn": "একটি অ-ঋণাত্মক পূর্ণসংখ্যা num দেওয়া হলে, এই ফাংশনটি বারবার এর সমস্ত অঙ্ক যোগ করে এটিকে একটি একক অঙ্কে কমিয়ে দেয়। উদাহরণস্বরূপ:\n    >>> f_48(38)\n    2\nগণনা এই কারণে যে 3 + 8 = 11, এবং আরও 1 + 1 = 2। 2 ফেরত দেওয়া হয় কারণ এটি একটি একক অঙ্কের সংখ্যা।", "bg": "Дадено е неотрицателно цяло число num, тази функция го намалява до едноцифрено число, като многократно събира всички негови цифри.\nНапример:\n    >>> f_48(38)\n    2\nИзчислението е, защото 3 + 8 = 11, и по-нататък 1 + 1 = 2. Връща се 2, тъй като е едноцифрено число.", "zh": "给定一个非负整数 num，此函数通过重复相加其所有数字将其减少到一位数字。  \n例如：  \n    >>> f_48(38)  \n    2  \n计算过程是因为 3 + 8 = 11，然后 1 + 1 = 2。返回 2，因为它是一个一位数。", "fr": "Étant donné un entier non négatif num, cette fonction le réduit à un seul chiffre en ajoutant de manière répétée tous ses chiffres.\nPar exemple :\n    >>> f_48(38)\n    2\nLe calcul est parce que 3 + 8 = 11, et ensuite 1 + 1 = 2. 2 est retourné car c'est un nombre à un seul chiffre.", "de": "Angenommen, eine nicht-negative ganze Zahl num, reduziert diese Funktion sie auf eine einstellige Zahl, indem sie wiederholt alle ihre Ziffern addiert.\n\nBeispiel:\n    >>> f_48(38)\n    2\n\nDie Berechnung erfolgt, weil 3 + 8 = 11 und weiter 1 + 1 = 2. 2 wird zurückgegeben, da es sich um eine einstellige Zahl handelt.", "ha": "An ba da wani lamba mai kyau wanda ba shi da alamar rashin kyau num, wannan aikin yana rage shi zuwa lamba guda ta hanyar kara dukkan lambobinsa akai-akai.\nMisali:\n    >>> f_48(38)\n    2\nLissafin yana nufin 3 + 8 = 11, kuma daga baya 1 + 1 = 2. 2 ana dawowa da shi saboda yana lamba guda ce.", "hi": "गैर-ऋणात्मक पूर्णांक num को दिया गया है, यह फ़ंक्शन इसे एकल अंक तक घटाता है सभी अंकों को बार-बार जोड़कर।\nउदाहरण के लिए:\n    >>> f_48(38)\n    2\nगणना इसलिए है क्योंकि 3 + 8 = 11, और आगे 1 + 1 = 2। 2 लौटाया जाता है क्योंकि यह एकल-अंक संख्या है।", "hu": "Adott egy nem negatív egész szám, ez a függvény egyetlen számjegyre csökkenti azáltal, hogy ismételten összeadja az összes számjegyét.\nPéldául:\n    >>> f_48(38)\n    2\nA számítás azért van, mert 3 + 8 = 11, és tovább 1 + 1 = 2. 2 kerül visszaadásra, mivel ez egy egyjegyű szám.", "es": "Dado un número entero no negativo num, esta función lo reduce a un solo dígito sumando repetidamente todos sus dígitos.\nPor ejemplo:\n    >>> f_48(38)\n    2\nEl cálculo es porque 3 + 8 = 11, y además 1 + 1 = 2. Se devuelve 2 ya que es un número de un solo dígito.", "arb": "بالنظر إلى عدد صحيح غير سالب num، تقوم هذه الدالة بتقليله إلى رقم واحد عن طريق جمع جميع أرقامه بشكل متكرر.\nعلى سبيل المثال:\n    >>> f_48(38)\n    2\nالحساب هو لأن 3 + 8 = 11، وأيضًا 1 + 1 = 2. يتم إرجاع 2 لأنه رقم مكون من خانة واحدة.", "sw": "Kwa kupewa nambari isiyo hasi num, kazi hii inapunguza hadi tarakimu moja kwa kuongeza mara kwa mara tarakimu zake zote. \n\nKwa mfano:\n    >>> f_48(38)\n    2\n\nHesabu ni kwa sababu 3 + 8 = 11, na zaidi 1 + 1 = 2. 2 inarudishwa kwa kuwa ni nambari ya tarakimu moja.", "tr": "Verilen negatif olmayan bir tamsayı num için, bu fonksiyon tüm basamaklarını tekrar tekrar toplayarak onu tek bir rakama indirger.\nÖrneğin:\n    >>> f_48(38)\n    2\nHesaplama 3 + 8 = 11 ve daha sonra 1 + 1 = 2 olduğu içindir. 2, tek basamaklı bir sayı olduğu için döndürülür.", "vi": "Cho một số nguyên không âm num, hàm này sẽ giảm nó xuống một chữ số bằng cách liên tục cộng tất cả các chữ số của nó.\nVí dụ:\n    >>> f_48(38)\n    2\nPhép tính là vì 3 + 8 = 11, và tiếp tục 1 + 1 = 2. 2 được trả về vì nó là một số có một chữ số.", "id": "Diberikan bilangan bulat non-negatif num, fungsi ini menguranginya menjadi satu digit dengan menambahkan semua digitnya secara berulang.  \nSebagai contoh:\n    >>> f_48(38)\n    2\nPerhitungannya adalah karena 3 + 8 = 11, dan selanjutnya 1 + 1 = 2. 2 dikembalikan karena itu adalah angka satu digit.", "ja": "非負整数 num が与えられたとき、この関数はその桁をすべて足し続けて一桁に減らします。\n例えば:\n    >>> f_48(38)\n    2\n計算は 3 + 8 = 11 であり、さらに 1 + 1 = 2 です。2 は一桁の数字なので返されます。", "ko": "주어진 비음수 정수 num에 대해, 이 함수는 모든 자릿수를 반복적으로 더하여 한 자리 숫자로 줄입니다.  \n예를 들어:\n    >>> f_48(38)\n    2\n계산은 3 + 8 = 11이고, 더 나아가 1 + 1 = 2입니다. 2는 한 자리 숫자이기 때문에 반환됩니다.", "ml": "ദിയ്ക്കപ്പെട്ട ഒരു നെഗറ്റീവ് അല്ലാത്ത പൂർണ്ണസംഖ്യ num, ഈ ഫംഗ്ഷൻ അതിന്റെ എല്ലാ അക്കങ്ങളും ആവർത്തിച്ച് ചേർത്ത് ഒരു അക്കമായി കുറയ്ക്കുന്നു. ഉദാഹരണത്തിന്:\n    >>> f_48(38)\n    2\nകണക്കുകൂട്ടൽ 3 + 8 = 11 എന്നതിനാൽ, പിന്നെ 1 + 1 = 2. 2 തിരികെ നൽകുന്നു കാരണം അത് ഒരു അക്ക സംഖ്യയാണ്.", "fa": "با توجه به یک عدد صحیح غیرمنفی num، این تابع آن را با جمع مکرر تمام ارقامش به یک رقم کاهش می‌دهد.\nبرای مثال:\n    >>> f_48(38)\n    2\nمحاسبه به این دلیل است که 3 + 8 = 11، و بیشتر 1 + 1 = 2. 2 برگردانده می‌شود زیرا یک عدد یک‌رقمی است."}}
{"task_id": "CPP/49", "prompt": {"en": "#include <cassert>\n#include <cstdio>\n/**\n * You are playing a game called Nim. In this game, you start with a pile of n stones, and you and\n * your opponent take turns to remove 1 to 3 stones from the pile. The one who removes the last\n * stone wins the game. Given the number of stones n, determine if you can win the game if both you\n * and your opponent play optimally.\n * Note: You always take the first turn.\n *\n * Here are some cases:\n *     >>> f_49(1)\n *     true\n */\nbool f_49(int n)", "sq": "#include <cassert>\n#include <cstdio>\n/**\n * Ju po luani një lojë të quajtur Nim. Në këtë lojë, ju filloni me një grumbull prej n gurësh, dhe ju dhe\n * kundërshtari juaj merrni me radhë për të hequr 1 deri në 3 gurë nga grumbulli. Ai që heq gurin e fundit\n * fiton lojën. Duke pasur parasysh numrin e gurëve n, përcaktoni nëse mund të fitoni lojën nëse si ju\n * ashtu edhe kundërshtari juaj luani në mënyrë optimale.\n * Shënim: Ju gjithmonë bëni lëvizjen e parë.\n *\n * Ja disa raste:\n *     >>> f_49(1)\n *     true\n */\nbool f_49(int n)", "hy": "#include <cassert>\n#include <cstdio>\n/**\n * Դուք խաղում եք Nim կոչվող խաղը։ Այս խաղում դուք սկսում եք n քարերի կույտով, և դուք և\n * ձեր հակառակորդը հերթով հեռացնում եք 1-ից 3 քար կույտից։ Նա, ով հեռացնում է վերջին\n * քարը, հաղթում է խաղը։ Տրված է քարերի քանակը n, որոշեք՝ արդյոք դուք կարող եք հաղթել խաղը, եթե դուք և\n * ձեր հակառակորդը խաղում եք օպտիմալ կերպով։\n * Նշում. Դուք միշտ առաջինն եք խաղում։\n *\n * Ահա որոշ դեպքեր.\n *     >>> f_49(1)\n *     true\n */\nbool f_49(int n)", "bn": "#include <cassert>\n#include <cstdio>\n/**\n * আপনি একটি গেম খেলছেন যার নাম নিম। এই গেমে, আপনি n পাথর দিয়ে শুরু করেন, এবং আপনি এবং\n * আপনার প্রতিদ্বন্দ্বী পালা করে 1 থেকে 3 পাথর পাইল থেকে সরান। যে শেষ পাথরটি সরায় সে গেমটি জেতে। পাথরের সংখ্যা n দেওয়া হলে, নির্ধারণ করুন আপনি গেমটি জিততে পারবেন কিনা যদি আপনি এবং আপনার প্রতিদ্বন্দ্বী উভয়ই সর্বোত্তমভাবে খেলেন।\n * লক্ষ্য করুন: আপনি সবসময় প্রথম পালা নেন।\n *\n * এখানে কিছু উদাহরণ:\n *     >>> f_49(1)\n *     true\n */\nbool f_49(int n)", "bg": "#include <cassert>\n#include <cstdio>\n/**\n * Играете игра, наречена Ним. В тази игра започвате с купчина от n камъка и вие и вашият\n * противник се редувате да премахвате от 1 до 3 камъка от купчината. Този, който премахне\n * последния камък, печели играта. Като се има предвид броят на камъните n, определете дали\n * можете да спечелите играта, ако и вие, и вашият противник играете оптимално.\n * Забележка: Винаги вие правите първия ход.\n *\n * Ето някои случаи:\n *     >>> f_49(1)\n *     true\n */\nbool f_49(int n)", "zh": "#include <cassert>\n#include <cstdio>\n/**\n * 你正在玩一个叫做 Nim 的游戏。在这个游戏中，你从一堆 n 个石头开始，你和你的对手轮流从堆中移除 1 到 3 个石头。移除最后一个石头的人赢得游戏。给定石头的数量 n，判断如果你和你的对手都采取最优策略，你是否能赢得游戏。\n * 注意：你总是先走。\n *\n * 这里有一些情况：\n *     >>> f_49(1)\n *     true\n */\nbool f_49(int n)", "fr": "#include <cassert>\n#include <cstdio>\n/**\n * Vous jouez à un jeu appelé Nim. Dans ce jeu, vous commencez avec un tas de n pierres, et vous et\n * votre adversaire prenez à tour de rôle 1 à 3 pierres du tas. Celui qui enlève la dernière\n * pierre gagne la partie. Étant donné le nombre de pierres n, déterminez si vous pouvez gagner la partie si vous et votre adversaire jouez de manière optimale.\n * Remarque : Vous prenez toujours le premier tour.\n *\n * Voici quelques cas :\n *     >>> f_49(1)\n *     true\n */\nbool f_49(int n)", "de": "#include <cassert>\n#include <cstdio>\n/**\n * Du spielst ein Spiel namens Nim. In diesem Spiel beginnst du mit einem Haufen von n Steinen, und du und\n * dein Gegner wechseln euch ab, um 1 bis 3 Steine aus dem Haufen zu entfernen. Derjenige, der den letzten\n * Stein entfernt, gewinnt das Spiel. Gegeben die Anzahl der Steine n, bestimme, ob du das Spiel gewinnen kannst, wenn sowohl du\n * als auch dein Gegner optimal spielen.\n * Hinweis: Du bist immer der Erste, der an der Reihe ist.\n *\n * Hier sind einige Fälle:\n *     >>> f_49(1)\n *     true\n */\nbool f_49(int n)", "ha": "#include <cassert>\n#include <cstdio>\n/**\n * Kuna wasa da wani wasa mai suna Nim. A cikin wannan wasa, kuna farawa da tarin duwatsu n, ku da\n * abokin hamayyarku kuna juyawa don cire duwatsu 1 zuwa 3 daga tarin. Wanda ya cire dutse na ƙarshe\n * shi ne ya lashe wasan. An ba da adadin duwatsu n, tantance idan za ku iya cin nasara a wasan idan\n * ku da abokin hamayyarku kuna wasa da kyau.\n * Lura: Kullum kuna fara juyawa.\n *\n * Ga wasu lokuta:\n *     >>> f_49(1)\n *     true\n */\nbool f_49(int n)", "hi": "#include <cassert>\n#include <cstdio>\n/**\n * आप एक खेल खेल रहे हैं जिसे निम कहा जाता है। इस खेल में, आप n पत्थरों के ढेर से शुरू करते हैं, और आप और\n * आपका प्रतिद्वंद्वी बारी-बारी से ढेर से 1 से 3 पत्थर हटाते हैं। जो आखिरी पत्थर हटाता है वह खेल जीतता है। दिए गए पत्थरों की संख्या n के आधार पर, यह निर्धारित करें कि क्या आप खेल जीत सकते हैं यदि आप और आपका प्रतिद्वंद्वी दोनों ही सर्वोत्तम तरीके से खेलते हैं।\n * नोट: आप हमेशा पहली बारी लेते हैं।\n *\n * यहाँ कुछ मामले हैं:\n *     >>> f_49(1)\n *     true\n */\nbool f_49(int n)", "hu": "#include <cassert>\n#include <cstdio>\n/**\n * Egy Nim nevű játékot játszol. Ebben a játékban egy halom n kővel kezdesz, és te, valamint az\n * ellenfeled felváltva távolítotok el 1-től 3-ig terjedő köveket a halomból. Az nyer, aki az utolsó\n * követ eltávolítja. Adott a kövek száma n, határozd meg, hogy megnyerheted-e a játékot, ha te és\n * az ellenfeled is optimálisan játszotok.\n * Megjegyzés: Mindig te kezded az első lépést.\n *\n * Íme néhány eset:\n *     >>> f_49(1)\n *     true\n */\nbool f_49(int n)", "es": "#include <cassert>\n#include <cstdio>\n/**\n * Estás jugando un juego llamado Nim. En este juego, comienzas con una pila de n piedras, y tú y\n * tu oponente se turnan para quitar de 1 a 3 piedras de la pila. Quien quite la última\n * piedra gana el juego. Dado el número de piedras n, determina si puedes ganar el juego si tanto tú\n * como tu oponente juegan de manera óptima.\n * Nota: Siempre tomas el primer turno.\n *\n * Aquí hay algunos casos:\n *     >>> f_49(1)\n *     true\n */\nbool f_49(int n)", "arb": "#include <cassert>\n#include <cstdio>\n/**\n * أنت تلعب لعبة تسمى نيم. في هذه اللعبة، تبدأ بكومة من الحجارة n، وأنت وخصمك تتناوبان على إزالة 1 إلى 3 حجارة من الكومة. الشخص الذي يزيل آخر حجر يفوز باللعبة. بالنظر إلى عدد الحجارة n، حدد ما إذا كان بإمكانك الفوز باللعبة إذا كنت أنت وخصمك تلعبان بشكل مثالي.\n * ملاحظة: أنت دائمًا تأخذ الدور الأول.\n *\n * هنا بعض الحالات:\n *     >>> f_49(1)\n *     true\n */\nbool f_49(int n)", "sw": "#include <cassert>\n#include <cstdio>\n/**\n * Unacheza mchezo unaoitwa Nim. Katika mchezo huu, unaanza na rundo la mawe n, na wewe na\n * mpinzani wako mnapokezana kuondoa mawe 1 hadi 3 kutoka kwenye rundo. Yule anayeondoa jiwe la mwisho\n * anashinda mchezo. Ukipewa idadi ya mawe n, amua kama unaweza kushinda mchezo ikiwa wote wewe\n * na mpinzani wako mna cheza kwa ustadi.\n * Kumbuka: Daima unachukua zamu ya kwanza.\n *\n * Hizi ni baadhi ya kesi:\n *     >>> f_49(1)\n *     true\n */\nbool f_49(int n)", "tr": "#include <cassert>\n#include <cstdio>\n/**\n * Nim adında bir oyun oynuyorsunuz. Bu oyunda, n taşlık bir yığınla başlarsınız ve siz ve\n * rakibiniz sırayla yığından 1 ila 3 taş çıkarırsınız. Son taşı çıkaran oyunu kazanır. Taş sayısı n\n * verildiğinde, hem siz hem de rakibiniz en iyi şekilde oynarsa oyunu kazanıp kazanamayacağınızı\n * belirleyin.\n * Not: Her zaman ilk hamleyi siz yaparsınız.\n *\n * İşte bazı durumlar:\n *     >>> f_49(1)\n *     true\n */\nbool f_49(int n)", "vi": "#include <cassert>\n#include <cstdio>\n/**\n * Bạn đang chơi một trò chơi gọi là Nim. Trong trò chơi này, bạn bắt đầu với một đống n viên đá, và bạn cùng\n * đối thủ của bạn lần lượt lấy đi từ 1 đến 3 viên đá từ đống. Người lấy viên đá cuối cùng sẽ thắng trò chơi. Cho số lượng viên đá n, xác định xem bạn có thể thắng trò chơi nếu cả bạn\n * và đối thủ của bạn chơi tối ưu hay không.\n * Lưu ý: Bạn luôn đi trước.\n *\n * Dưới đây là một số trường hợp:\n *     >>> f_49(1)\n *     true\n */\nbool f_49(int n)", "id": "#include <cassert>\n#include <cstdio>\n/**\n * Anda sedang bermain permainan bernama Nim. Dalam permainan ini, Anda mulai dengan tumpukan n batu, dan Anda serta\n * lawan Anda bergiliran untuk mengambil 1 hingga 3 batu dari tumpukan. Orang yang mengambil batu terakhir\n * memenangkan permainan. Diberikan jumlah batu n, tentukan apakah Anda bisa memenangkan permainan jika Anda dan\n * lawan Anda bermain secara optimal.\n * Catatan: Anda selalu mengambil giliran pertama.\n *\n * Berikut adalah beberapa kasus:\n *     >>> f_49(1)\n *     true\n */\nbool f_49(int n)", "ja": "#include <cassert>\n#include <cstdio>\n/**\n * あなたはNimというゲームをプレイしています。このゲームでは、n個の石の山から始め、\n * あなたと対戦相手が交互に1から3個の石を山から取り除きます。最後の石を取り除いた人が\n * ゲームに勝ちます。石の数nが与えられたとき、あなたと対戦相手が最適にプレイした場合、\n * あなたがゲームに勝てるかどうかを判断してください。\n * 注意: あなたは常に最初のターンを取ります。\n *\n * 以下はいくつかのケースです:\n *     >>> f_49(1)\n *     true\n */\nbool f_49(int n)", "ko": "#include <cassert>\n#include <cstdio>\n/**\n * 당신은 Nim이라는 게임을 하고 있습니다. 이 게임에서, 당신은 n개의 돌무더기로 시작하며,\n * 당신과 상대방은 번갈아 가며 돌무더기에서 1개에서 3개의 돌을 제거합니다. 마지막 돌을 제거하는 사람이\n * 게임에서 승리합니다. 돌의 수 n이 주어졌을 때, 당신과 상대방이 최적으로 플레이할 경우 당신이\n * 게임에서 승리할 수 있는지 판단하세요.\n * 참고: 당신이 항상 첫 번째 턴을 가집니다.\n *\n * 몇 가지 경우는 다음과 같습니다:\n *     >>> f_49(1)\n *     true\n */\nbool f_49(int n)", "ml": "#include <cassert>\n#include <cstdio>\n/**\n * നിങ്ങൾ നിം എന്നൊരു ഗെയിം കളിക്കുകയാണ്. ഈ ഗെയിമിൽ, നിങ്ങൾക്ക് n കല്ലുകൾ ഉള്ള ഒരു കൂമ്പാരം ആരംഭിക്കുന്നു, നിങ്ങൾക്കും\n * നിങ്ങളുടെ എതിരാളിക്കും കൂമ്പാരത്തിൽ നിന്ന് 1 മുതൽ 3 വരെ കല്ലുകൾ നീക്കം ചെയ്യാൻ തവണകൾ ലഭിക്കുന്നു. അവസാനത്തെ\n * കല്ല് നീക്കം ചെയ്യുന്നവൻ ഗെയിം ജയിക്കും. കല്ലുകളുടെ എണ്ണം n നൽകിയാൽ, നിങ്ങൾക്കും നിങ്ങളുടെ\n * എതിരാളിയും മികച്ച രീതിയിൽ കളിച്ചാൽ നിങ്ങൾക്ക് ഗെയിം ജയിക്കാനാകുമോ എന്ന് നിർണ്ണയിക്കുക.\n * കുറിപ്പ്: നിങ്ങൾ എപ്പോഴും ആദ്യ തവണ എടുക്കുന്നു.\n *\n * ചില കേസുകൾ ഇവയാണ്:\n *     >>> f_49(1)\n *     true\n */\nbool f_49(int n)", "fa": "#include <cassert>\n#include <cstdio>\n/**\n * شما در حال بازی به نام Nim هستید. در این بازی، شما با یک توده از n سنگ شروع می‌کنید و شما و\n * حریف‌تان به نوبت 1 تا 3 سنگ را از توده برمی‌دارید. کسی که آخرین سنگ را برمی‌دارد برنده بازی است.\n * با توجه به تعداد سنگ‌ها n، تعیین کنید که آیا می‌توانید بازی را ببرید اگر هر دو شما و حریف‌تان بهینه بازی کنید.\n * توجه: شما همیشه اولین نوبت را دارید.\n *\n * در اینجا چند مورد وجود دارد:\n *     >>> f_49(1)\n *     true\n */\nbool f_49(int n)\n"}, "canonical_solution": "{\n    return n % 4 != 0;\n}", "instruction": {"en": "bool f_49(int n)\n{\n    return n % 4 != 0;\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.", "sq": "bool f_49(int n)\n{\n    return n % 4 != 0;\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit CPP në gjuhën shqipe duke përdorur maksimumi 500 karaktere.", "hy": "bool f_49(int n)\n{\n    return n % 4 != 0;\n}\n\nՏվեք CPP կոդի համառոտ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։", "bn": "bool f_49(int n)\n{\n    return n % 4 != 0;\n}\n\nনিচের CPP কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।", "bg": "bool f_49(int n)\n{\n    return n % 4 != 0;\n}\n\nПредоставете кратко описание на CPP кода на естествен език на български, използвайки не повече от 500 знака.", "zh": "bool f_49(int n)\n{\n    return n % 4 != 0;\n}\n\n请用最多500个字符的中文对该CPP代码提供简洁的自然语言描述（文档字符串）。", "fr": "bool f_49(int n)\n{\n    return n % 4 != 0;\n}\n\nFournissez une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.", "de": "bool f_49(int n)\n{\n    return n % 4 != 0;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "bool f_49(int n)\n{\n    return n % 4 != 0;\n}\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar CPP a cikin Hausa ta amfani da haruffa 500 kawai.", "hi": "bool f_49(int n)\n{\n    return n % 4 != 0;\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "bool f_49(int n)\n{\n    return n % 4 != 0;\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a CPP kódról magyarul, legfeljebb 500 karakterben.", "es": "bool f_49(int n)\n{\n    return n % 4 != 0;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando como máximo 500 caracteres.", "arb": "bool f_49(int n)\n{\n    return n % 4 != 0;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C++ باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "bool f_49(int n)\n{\n    return n % 4 != 0;\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "bool f_49(int n)\n{\n    return n % 4 != 0;\n}\n\nAşağıdaki CPP kodunun Türkçe'de en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.", "vi": "bool f_49(int n)\n{\n    return n % 4 != 0;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự.", "id": "bool f_49(int n)\n{\n    return n % 4 != 0;\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode CPP dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "bool f_49(int n)\n{\n    return n % 4 != 0;\n}\n\n以下のCPPコードの簡潔な自然言語による説明（ドックストリング）を日本語で500文字以内で提供してください。", "ko": "bool f_49(int n)\n{\n    return n % 4 != 0;\n}\n\n다음 CPP 코드의 동작을 설명하는 간결한 자연어 설명(도크스트링)을 최대 500자 이내로 한국어로 제공하세요.", "ml": "bool f_49(int n)\n{\n    return n % 4 != 0;\n}\n\nCPP കോഡ് ഉപയോഗിച്ച് 500 അക്ഷരങ്ങളിൽ കൂടുതൽ അല്ലാത്ത മലയാളത്തിൽ സംക്ഷിപ്തമായ ഒരു സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) നൽകുക.", "fa": "bool f_49(int n)\n{\n    return n % 4 != 0;\n}\n\nتوضیح مختصر و طبیعی (docstring) از کد CPP به زبان فارسی ارائه دهید که حداکثر ۵۰۰ کاراکتر باشد."}, "level": "", "test": "int main() {\n    assert(f_49(1) == true);\n    assert(f_49(2) == true);\n    assert(f_49(3) == true);\n    assert(f_49(4) == false);\n    assert(f_49(5) == true);\n    assert(f_49(6) == true);\n    assert(f_49(7) == true);\n    assert(f_49(8) == false);\n    assert(f_49(9) == true);\n    assert(f_49(10) == true);\n    assert(f_49(11) == true);\n    assert(f_49(12) == false);\n    assert(f_49(13) == true);\n    assert(f_49(14) == true);\n    assert(f_49(15) == true);\n    assert(f_49(16) == false);\n    assert(f_49(17) == true);\n    assert(f_49(18) == true);\n    assert(f_49(19) == true);\n    assert(f_49(20) == false);\n    return 0;\n}", "entry_point": "f_49", "signature": "bool f_49(int n)", "docstring": {"en": "You are playing a game called Nim. In this game, you start with a pile of n stones, and you and\nyour opponent take turns to remove 1 to 3 stones from the pile. The one who removes the last\nstone wins the game. Given the number of stones n, determine if you can win the game if both you\nand your opponent play optimally.\nNote: You always take the first turn.\n\nHere are some cases:\n    >>> f_49(1)\n    true\n", "sq": "Ju po luani një lojë të quajtur Nim. Në këtë lojë, ju filloni me një grumbull prej n gurësh, dhe ju dhe kundërshtari juaj merrni radhë për të hequr 1 deri në 3 gurë nga grumbulli. Ai që heq gurin e fundit fiton lojën. Duke pasur parasysh numrin e gurëve n, përcaktoni nëse mund ta fitoni lojën nëse si ju ashtu edhe kundërshtari juaj luani në mënyrë optimale. \nShënim: Ju gjithmonë merrni radhën e parë.\n\nJa disa raste:\n    >>> f_49(1)\n    true", "hy": "Դուք խաղում եք Նիմ կոչվող խաղը։ Այս խաղում դուք սկսում եք n քարերի կույտով, և դուք ու ձեր հակառակորդը հերթով հեռացնում եք 1-ից 3 քարեր կույտից։ Նա, ով հեռացնում է վերջին քարը, հաղթում է խաղը։ Տրված է քարերի քանակը՝ n, որոշեք՝ արդյոք դուք կարող եք հաղթել խաղը, եթե և դուք, և ձեր հակառակորդը խաղում եք օպտիմալ կերպով։\nՆշում: Դուք միշտ առաջին հերթն եք կատարում։\n\nԱհա որոշ դեպքեր.\n    >>> f_49(1)\n    true", "bn": "তুমি একটি খেলা খেলছো যার নাম নিম। এই খেলায়, তুমি একটি স্তূপ থেকে n টি পাথর দিয়ে শুরু করো, এবং তুমি ও তোমার প্রতিদ্বন্দ্বী পালাক্রমে ১ থেকে ৩ টি পাথর স্তূপ থেকে সরিয়ে নাও। যে ব্যক্তি শেষ পাথরটি সরায়, সে খেলায় জিতে যায়। প্রদত্ত পাথরের সংখ্যা n, নির্ধারণ করো তুমি খেলাটি জিততে পারবে কিনা যদি তুমি এবং তোমার প্রতিদ্বন্দ্বী উভয়েই সর্বোত্তমভাবে খেলে।\nনোট: তুমি সবসময় প্রথম পালা নাও।\n\nকিছু উদাহরণ এখানে:\n    >>> f_49(1)\n    true", "bg": "Играете игра, наречена Nim. В тази игра започвате с купчина от n камъка и вие и вашият противник се редувате да премахвате от 1 до 3 камъка от купчината. Този, който премахне последния камък, печели играта. Даден е броят на камъните n, определете дали можете да спечелите играта, ако и вие, и вашият противник играете оптимално.  \nЗабележка: Винаги вие започвате първи.\n\nЕто някои случаи:\n    >>> f_49(1)\n    true", "zh": "你正在玩一个叫做 Nim 的游戏。在这个游戏中，你从一堆 n 个石头开始，你和你的对手轮流从堆中移除 1 到 3 个石头。移除最后一个石头的人赢得游戏。给定石头的数量 n，判断如果你和你的对手都采取最佳策略，你是否能赢得游戏。\n注意：你总是先手。\n\n以下是一些情况：\n    >>> f_49(1)\n    true", "fr": "Vous jouez à un jeu appelé Nim. Dans ce jeu, vous commencez avec un tas de n pierres, et vous et votre adversaire prenez à tour de rôle 1 à 3 pierres du tas. Celui qui enlève la dernière pierre gagne la partie. Étant donné le nombre de pierres n, déterminez si vous pouvez gagner la partie si vous et votre adversaire jouez de manière optimale.  \nRemarque : Vous jouez toujours en premier.\n\nVoici quelques cas :\n    >>> f_49(1)\n    true", "de": "Du spielst ein Spiel namens Nim. In diesem Spiel beginnst du mit einem Haufen von n Steinen, und du und dein Gegner wechseln euch ab, um 1 bis 3 Steine vom Haufen zu entfernen. Derjenige, der den letzten Stein entfernt, gewinnt das Spiel. Gegeben ist die Anzahl der Steine n, bestimme, ob du das Spiel gewinnen kannst, wenn sowohl du als auch dein Gegner optimal spielen.\nHinweis: Du bist immer als Erster an der Reihe.\n\nHier sind einige Fälle:\n    >>> f_49(1)\n    true\n", "ha": "Kana wasa mai suna Nim. A cikin wannan wasa, ka fara da tarin duwatsu n, kai da abokin adawarka kuna juyawa don cire 1 zuwa 3 daga cikin duwatsun. Wanda ya cire dutse na ƙarshe shi ne ya ci wasan. Idan aka ba da adadin duwatsu n, tantance ko zaka iya cin wasa idan kai da abokin adawarka kuna wasa cikin hikima.\nLura: Kai ne kake fara wasa.\n\nGa wasu lokuta:\n    >>> f_49(1)\n    true", "hi": "आप एक खेल खेल रहे हैं जिसे निम कहा जाता है। इस खेल में, आप n पत्थरों के ढेर से शुरू करते हैं, और आप और आपका प्रतिद्वंद्वी बारी-बारी से ढेर से 1 से 3 पत्थर हटाते हैं। जो अंतिम पत्थर हटाता है वह खेल जीतता है। दिए गए पत्थरों की संख्या n के आधार पर, यह निर्धारित करें कि क्या आप खेल जीत सकते हैं यदि आप और आपका प्रतिद्वंद्वी दोनों सर्वोत्तम तरीके से खेलते हैं।\nध्यान दें: आप हमेशा पहली बारी लेते हैं।\n\nयहाँ कुछ मामले हैं:\n    >>> f_49(1)\n    true", "hu": "Egy Nim nevű játékot játszol. Ebben a játékban egy halom n kővel kezdesz, és te, valamint az ellenfeled felváltva távolítotok el 1-3 követ a halomból. Az nyeri a játékot, aki az utolsó követ eltávolítja. Adott a kövek száma n, határozd meg, hogy meg tudod-e nyerni a játékot, ha te és az ellenfeled is optimálisan játszik.\nMegjegyzés: Mindig te kezded az első lépést.\n\nÍme néhány eset:\n    >>> f_49(1)\n    true", "es": "Estás jugando un juego llamado Nim. En este juego, comienzas con una pila de n piedras, y tú y tu oponente se turnan para quitar de 1 a 3 piedras de la pila. El que quita la última piedra gana el juego. Dado el número de piedras n, determina si puedes ganar el juego si tanto tú como tu oponente juegan de manera óptima.\nNota: Siempre tomas el primer turno.\n\nAquí hay algunos casos:\n    >>> f_49(1)\n    true", "arb": "أنت تلعب لعبة تسمى نيم. في هذه اللعبة، تبدأ بكومة من الحجارة عددها n، وأنت وخصمك تتناوبان على إزالة 1 إلى 3 حجارة من الكومة. الشخص الذي يزيل آخر حجر يفوز باللعبة. بالنظر إلى عدد الحجارة n، حدد ما إذا كان بإمكانك الفوز باللعبة إذا لعبت أنت وخصمك بشكل مثالي.\nملاحظة: أنت دائمًا تأخذ الدور الأول.\n\nهنا بعض الحالات:\n    >>> f_49(1)\n    true", "sw": "Unacheza mchezo unaoitwa Nim. Katika mchezo huu, unaanza na rundo la mawe n, na wewe na mpinzani wako mnachukua zamu kuondoa mawe 1 hadi 3 kutoka kwenye rundo. Yule anayeondoa jiwe la mwisho anashinda mchezo. Ukipewa idadi ya mawe n, amua kama unaweza kushinda mchezo ikiwa wewe na mpinzani wako mna cheza kwa ustadi.\n\nKumbuka: Daima unachukua zamu ya kwanza.\n\nHapa kuna baadhi ya kesi:\n    >>> f_49(1)\n    true", "tr": "Nim adlı bir oyun oynuyorsunuz. Bu oyunda, n taşlık bir yığınla başlarsınız ve siz ve rakibiniz sırayla yığından 1 ila 3 taş alırsınız. Son taşı alan oyunu kazanır. Taş sayısı n verildiğinde, hem sizin hem de rakibinizin en iyi şekilde oynadığı durumda oyunu kazanıp kazanamayacağınızı belirleyin. \nNot: Her zaman ilk hamleyi siz yaparsınız.\n\nİşte bazı durumlar:\n    >>> f_49(1)\n    true\n", "vi": "Bạn đang chơi một trò chơi có tên là Nim. Trong trò chơi này, bạn bắt đầu với một đống n viên đá, và bạn cùng đối thủ luân phiên nhau loại bỏ từ 1 đến 3 viên đá khỏi đống. Người nào loại bỏ viên đá cuối cùng sẽ thắng trò chơi. Với số lượng viên đá n cho trước, xác định xem bạn có thể thắng trò chơi hay không nếu cả bạn và đối thủ đều chơi tối ưu. \nLưu ý: Bạn luôn đi trước.\n\nDưới đây là một số trường hợp:\n    >>> f_49(1)\n    true", "id": "Anda sedang bermain game bernama Nim. Dalam permainan ini, Anda mulai dengan tumpukan n batu, dan Anda serta lawan Anda bergantian mengambil 1 hingga 3 batu dari tumpukan. Orang yang mengambil batu terakhir memenangkan permainan. Diberikan jumlah batu n, tentukan apakah Anda bisa memenangkan permainan jika Anda dan lawan Anda bermain secara optimal. \nCatatan: Anda selalu mengambil giliran pertama.\n\nBerikut adalah beberapa kasus:\n    >>> f_49(1)\n    true", "ja": "あなたはニムというゲームをプレイしています。このゲームでは、n個の石の山から始め、あなたと対戦相手が交互に1から3個の石を山から取り除きます。最後の石を取り除いた人がゲームに勝ちます。石の数nが与えられたとき、あなたと対戦相手が最適にプレイした場合に、あなたがゲームに勝てるかどうかを判断してください。\n注意: あなたは常に最初のターンを取ります。\n\nいくつかのケースを示します:\n    >>> f_49(1)\n    true", "ko": "당신은 Nim이라는 게임을 하고 있습니다. 이 게임에서, 당신은 n개의 돌 더미로 시작하며, 당신과 상대는 번갈아 가며 1개에서 3개의 돌을 더미에서 제거합니다. 마지막 돌을 제거하는 사람이 게임에서 승리합니다. 돌의 수 n이 주어졌을 때, 당신과 상대가 최적으로 플레이할 경우 당신이 게임에서 승리할 수 있는지 판단하세요. 참고: 당신이 항상 첫 번째 턴을 가집니다.\n\n다음은 몇 가지 경우입니다:\n    >>> f_49(1)\n    true", "ml": "നിങ്ങൾ നിം എന്നൊരു ഗെയിം കളിക്കുകയാണ്. ഈ ഗെയിമിൽ, നിങ്ങൾ n കല്ലുകൾ ഉള്ള ഒരു കൂമ്പാരം കൊണ്ട് ആരംഭിക്കുന്നു, നിങ്ങൾക്കും നിങ്ങളുടെ എതിരാളിക്കും കൂമ്പാരത്തിൽ നിന്ന് 1 മുതൽ 3 വരെ കല്ലുകൾ നീക്കം ചെയ്യാൻ കഴിയുന്നു. അവസാന കല്ല് നീക്കം ചെയ്യുന്നവൻ ഗെയിം ജയിക്കും. കല്ലുകളുടെ എണ്ണം n നൽകിയാൽ, നിങ്ങൾക്കും നിങ്ങളുടെ എതിരാളിക്കും മികച്ച രീതിയിൽ കളിക്കുമ്പോൾ നിങ്ങൾക്ക് ഗെയിം ജയിക്കാനാകുമോ എന്ന് നിർണയിക്കുക. കുറിപ്പ്: നിങ്ങൾ എപ്പോഴും ആദ്യ തവണ കളിക്കും.\n\nഇവിടെ ചില കേസുകൾ:\n    >>> f_49(1)\n    true", "fa": "شما در حال بازی به نام نیم هستید. در این بازی، شما با یک توده از n سنگ شروع می‌کنید و شما و حریف‌تان به نوبت 1 تا 3 سنگ را از توده برمی‌دارید. کسی که آخرین سنگ را برمی‌دارد برنده بازی است. با توجه به تعداد سنگ‌ها n، تعیین کنید که آیا می‌توانید بازی را ببرید اگر هم شما و هم حریف‌تان بهینه بازی کنید.\nتوجه: شما همیشه اولین نوبت را دارید.\n\nدر اینجا چند مورد وجود دارد:\n    >>> f_49(1)\n    true"}}
{"task_id": "CPP/50", "prompt": {"en": "#include <cassert>\n#include <cstdio>\n/**\n * Given two integers a and b, return the sum if the sum is even, or the product of a and b if the sum is odd.\n * Examples:\n *    f_50(2, 3) returns 6\n *    f_50(5, 5) returns 10\n */\nint f_50(int a, int b)", "sq": "#include <cassert>\n#include <cstdio>\n/**\n * Duke pasur dy numra të plotë a dhe b, kthejeni shumën nëse shuma është çift, ose prodhimin e a dhe b nëse shuma është tek.\n * Shembuj:\n *    f_50(2, 3) kthen 6\n *    f_50(5, 5) kthen 10\n */\nint f_50(int a, int b)", "hy": "#include <cassert>\n#include <cstdio>\n/**\n * Տրված է երկու ամբողջ թիվ a և b, վերադարձնել գումարը, եթե գումարը զույգ է, կամ a և b-ի արտադրյալը, եթե գումարը կենտ է։\n * Օրինակներ:\n *    f_50(2, 3) վերադարձնում է 6\n *    f_50(5, 5) վերադարձնում է 10\n */\nint f_50(int a, int b)", "bn": "#include <cassert>\n#include <cstdio>\n/**\n * দুটি পূর্ণসংখ্যা a এবং b দেওয়া হলে, যদি যোগফলটি জোড় হয় তাহলে যোগফল ফেরত দিন, অথবা যদি যোগফলটি বিজোড় হয় তাহলে a এবং b এর গুণফল ফেরত দিন।\n * উদাহরণস্বরূপ:\n *    f_50(2, 3) 6 ফেরত দেয়\n *    f_50(5, 5) 10 ফেরত দেয়\n */\nint f_50(int a, int b)", "bg": "#include <cassert>\n#include <cstdio>\n/**\n * Дадени са две цели числа a и b, върнете сумата, ако сумата е четна, или произведението на a и b, ако сумата е нечетна.\n * Примери:\n *    f_50(2, 3) връща 6\n *    f_50(5, 5) връща 10\n */\nint f_50(int a, int b)", "zh": "#include <cassert>\n#include <cstdio>\n/**\n * 给定两个整数 a 和 b，如果它们的和是偶数，则返回和；如果和是奇数，则返回 a 和 b 的乘积。\n * 例子:\n *    f_50(2, 3) 返回 6\n *    f_50(5, 5) 返回 10\n */\nint f_50(int a, int b)", "fr": "#include <cassert>\n#include <cstdio>\n/**\n * Étant donné deux entiers a et b, retourner la somme si la somme est paire, ou le produit de a et b si la somme est impaire.\n * Exemples :\n *    f_50(2, 3) retourne 6\n *    f_50(5, 5) retourne 10\n */\nint f_50(int a, int b)", "de": "#include <cassert>\n#include <cstdio>\n/**\n * Gegeben zwei ganze Zahlen a und b, gib die Summe zurück, wenn die Summe gerade ist, oder das Produkt von a und b, wenn die Summe ungerade ist.\n * Beispiele:\n *    f_50(2, 3) gibt 6 zurück\n *    f_50(5, 5) gibt 10 zurück\n */\nint f_50(int a, int b)", "ha": "#include <cassert>\n#include <cstdio>\n/**\n * Idan aka ba da lambobi guda biyu a da b, a mayar da jumlar idan jumlar ta zama lamba mai mafarin biyu, ko kuma samfurin a da b idan jumlar ta zama lamba mai mafarin daya.\n * Misalai:\n *    f_50(2, 3) yana mayar da 6\n *    f_50(5, 5) yana mayar da 10\n */\nint f_50(int a, int b)", "hi": "#include <cassert>\n#include <cstdio>\n/**\n * दिए गए दो पूर्णांक a और b के लिए, योग को लौटाएं यदि योग सम है, या a और b का गुणनफल यदि योग विषम है।\n * उदाहरण:\n *    f_50(2, 3) 6 लौटाता है\n *    f_50(5, 5) 10 लौटाता है\n */\nint f_50(int a, int b)", "hu": "#include <cassert>\n#include <cstdio>\n/**\n * Két egész szám, a és b esetén adja vissza az összeget, ha az összeg páros, vagy a és b szorzatát, ha az összeg páratlan.\n * Példák:\n *    f_50(2, 3) visszaadja 6\n *    f_50(5, 5) visszaadja 10\n */\nint f_50(int a, int b)", "es": "#include <cassert>\n#include <cstdio>\n/**\n * Dados dos enteros a y b, devuelve la suma si la suma es par, o el producto de a y b si la suma es impar.\n * Ejemplos:\n *    f_50(2, 3) returns 6\n *    f_50(5, 5) returns 10\n */\nint f_50(int a, int b)", "arb": "#include <cassert>\n#include <cstdio>\n/**\n * معطى عددين صحيحين a و b، أعد المجموع إذا كان المجموع زوجيًا، أو حاصل ضرب a و b إذا كان المجموع فرديًا.\n * أمثلة:\n *    f_50(2, 3) returns 6\n *    f_50(5, 5) returns 10\n */\nint f_50(int a, int b)", "sw": "#include <cassert>\n#include <cstdio>\n/**\n * Ukipewa nambari mbili a na b, rudisha jumla ikiwa jumla ni shufwa, au bidhaa ya a na b ikiwa jumla ni witiri.\n * Mifano:\n *    f_50(2, 3) returns 6\n *    f_50(5, 5) returns 10\n */\nint f_50(int a, int b)", "tr": "#include <cassert>\n#include <cstdio>\n/**\n * İki tamsayı a ve b verildiğinde, toplam çift ise toplamı, toplam tek ise a ve b'nin çarpımını döndürün.\n * Örnekler:\n *    f_50(2, 3) 6 döndürür\n *    f_50(5, 5) 10 döndürür\n */\nint f_50(int a, int b)", "vi": "#include <cassert>\n#include <cstdio>\n/**\n * Cho hai số nguyên a và b, trả về tổng nếu tổng là số chẵn, hoặc tích của a và b nếu tổng là số lẻ.\n * Ví dụ:\n *    f_50(2, 3) trả về 6\n *    f_50(5, 5) trả về 10\n */\nint f_50(int a, int b)", "id": "#include <cassert>\n#include <cstdio>\n/**\n * Diberikan dua bilangan bulat a dan b, kembalikan jumlahnya jika jumlahnya genap, atau hasil kali a dan b jika jumlahnya ganjil.\n * Contoh:\n *    f_50(2, 3) mengembalikan 6\n *    f_50(5, 5) mengembalikan 10\n */\nint f_50(int a, int b)", "ja": "#include <cassert>\n#include <cstdio>\n/**\n * 2つの整数aとbが与えられたとき、合計が偶数の場合は合計を返し、合計が奇数の場合はaとbの積を返します。\n * 例:\n *    f_50(2, 3) は6を返します\n *    f_50(5, 5) は10を返します\n */\nint f_50(int a, int b)", "ko": "#include <cassert>\n#include <cstdio>\n/**\n * 두 정수 a와 b가 주어졌을 때, 합이 짝수이면 합을 반환하고, 합이 홀수이면 a와 b의 곱을 반환합니다.\n * 예시:\n *    f_50(2, 3) returns 6\n *    f_50(5, 5) returns 10\n */\nint f_50(int a, int b)", "ml": "#include <cassert>\n#include <cstdio>\n/**\n * രണ്ട് പൂർണ്ണസംഖ്യകളായ a, b എന്നിവ നൽകിയാൽ, തുക സമം ആണെങ്കിൽ തുക മടക്കുക, അല്ലെങ്കിൽ തുക അനിശ്ചിതമാണെങ്കിൽ a, b എന്നിവയുടെ ഗുണഫലം മടക്കുക.\n * ഉദാഹരണങ്ങൾ:\n *    f_50(2, 3) 6 മടക്കുന്നു\n *    f_50(5, 5) 10 മടക്കുന്നു\n */\nint f_50(int a, int b)", "fa": "#include <cassert>\n#include <cstdio>\n/**\n * با توجه به دو عدد صحیح a و b، اگر مجموع زوج باشد، مجموع را برگردانید، یا اگر مجموع فرد باشد، حاصل‌ضرب a و b را برگردانید.\n * مثال‌ها:\n *    f_50(2, 3) returns 6\n *    f_50(5, 5) returns 10\n */\nint f_50(int a, int b)"}, "canonical_solution": "{\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}", "instruction": {"en": "int f_50(int a, int b)\n{\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.", "sq": "int f_50(int a, int b)\n{\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit CPP në gjuhën shqipe duke përdorur maksimumi 500 karaktere.", "hy": "int f_50(int a, int b)\n{\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}\n\nՏվեք CPP կոդի հակիրճ բնութագրումը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "int f_50(int a, int b)\n{\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}\n\nসিপিপি কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলা ভাষায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।", "bg": "int f_50(int a, int b)\n{\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}\n\nПредоставете кратко описание на CPP кода на български език, използвайки не повече от 500 знака.", "zh": "int f_50(int a, int b)\n{\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}\n\n将以下CPP代码的自然语言描述（文档字符串）翻译成中文，字数不超过500个字符。", "fr": "int f_50(int a, int b)\n{\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}\n\nFournissez une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.", "de": "int f_50(int a, int b)\n{\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen.", "ha": "int f_50(int a, int b)\n{\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}\n\nBa da taƙaitaccen bayanin harshen halitta (docstring) na lambar CPP cikin Hausa ta amfani da haruffa 500 ko ƙasa da haka.", "hi": "int f_50(int a, int b)\n{\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "int f_50(int a, int b)\n{\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a CPP kódról magyarul, legfeljebb 500 karakterben.", "es": "int f_50(int a, int b)\n{\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando como máximo 500 caracteres.", "arb": "int f_50(int a, int b)\n{\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C++ باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "int f_50(int a, int b)\n{\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "int f_50(int a, int b)\n{\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}\n\nAşağıdaki CPP kodunun Türkçe olarak en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.", "vi": "int f_50(int a, int b)\n{\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự.", "id": "int f_50(int a, int b)\n{\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode CPP dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "int f_50(int a, int b)\n{\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}\n\n以下のCPPコードの簡潔な自然言語による説明（ドックストリング）を日本語で500文字以内で提供してください。", "ko": "int f_50(int a, int b)\n{\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}\n\n다음 CPP 코드에 대한 간결한 자연어 설명(도크스트링)을 한국어로 500자 이내로 제공하세요.", "ml": "int f_50(int a, int b)\n{\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}\n\nസിപിപി കോഡിന്റെ സംക്ഷിപ്തമായ സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) മലയാളത്തിൽ 500 അക്ഷരങ്ങളിൽ കൂടാതെയായി നൽകുക.", "fa": "int f_50(int a, int b)\n{\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}\n\nتوضیح مختصر و طبیعی (docstring) از کد CPP را به زبان فارسی ارائه دهید که حداکثر ۵۰۰ کاراکتر باشد."}, "level": "", "test": "int main() {\n    assert(f_50(2, 3) == 6);\n    assert(f_50(5, 5) == 10);\n    assert(f_50(1, 1) == 2);\n    assert(f_50(0, 0) == 0);\n    assert(f_50(-1, -1) == -2);\n    assert(f_50(100, 200) == 300);\n    assert(f_50(3, 4) == 12);\n    assert(f_50(-5, 5) == 0);\n    assert(f_50(7, 8) == 56);\n    assert(f_50(9, 10) == 90);\n    assert(f_50(11, 14) == 154);\n    return 0;\n}", "entry_point": "f_50", "signature": "int f_50(int a, int b)", "docstring": {"en": "Given two integers a and b, return the sum if the sum is even, or the product of a and b if the sum is odd.\nExamples:\nf_50(2, 3) returns 6\nf_50(5, 5) returns 10", "sq": "Duke pasur dy numra të plotë a dhe b, kthejeni shumën nëse shuma është çift, ose produktin e a dhe b nëse shuma është tek.\nShembuj:\nf_50(2, 3) kthen 6\nf_50(5, 5) kthen 10", "hy": "Տրված երկու ամբողջ թիվ a և b, վերադարձնել գումարը, եթե գումարը զույգ է, կամ a և b արտադրյալը, եթե գումարը կենտ է:\nՕրինակներ:\nf_50(2, 3) վերադարձնում է 6\nf_50(5, 5) վերադարձնում է 10", "bn": "দুটি পূর্ণসংখ্যা a এবং b দেওয়া হলে, যদি যোগফলটি জোড় হয় তবে যোগফলটি ফেরত দিন, অথবা যদি যোগফলটি বিজোড় হয় তবে a এবং b এর গুণফল ফেরত দিন।\nউদাহরণ:\nf_50(2, 3) 6 ফেরত দেয়\nf_50(5, 5) 10 ফেরত দেয়", "bg": "Дадени са две цели числа a и b, върнете сумата, ако сумата е четна, или произведението на a и b, ако сумата е нечетна.\nПримери:\nf_50(2, 3) връща 6\nf_50(5, 5) връща 10", "zh": "给定两个整数 a 和 b，如果它们的和是偶数，则返回和；如果和是奇数，则返回 a 和 b 的乘积。\n示例：\nf_50(2, 3) 返回 6\nf_50(5, 5) 返回 10", "fr": "Étant donné deux entiers a et b, renvoyez la somme si la somme est paire, ou le produit de a et b si la somme est impaire.\nExemples :\nf_50(2, 3) renvoie 6\nf_50(5, 5) renvoie 10", "de": "Gegeben zwei ganze Zahlen a und b, gib die Summe zurück, wenn die Summe gerade ist, oder das Produkt von a und b, wenn die Summe ungerade ist.\nBeispiele:\nf_50(2, 3) gibt 6 zurück\nf_50(5, 5) gibt 10 zurück", "ha": "An ba da lambobi guda biyu a da b, mayar da jumlar idan jumlar tana da lamba mai ma'ana, ko kuma samfurin a da b idan jumlar tana da lamba mai wauta.\nMisalai:\nf_50(2, 3) yana mayar da 6\nf_50(5, 5) yana mayar da 10", "hi": "दो पूर्णांक a और b दिए गए हैं, यदि योग सम है तो योग लौटाएं, या यदि योग विषम है तो a और b का गुणनफल लौटाएं।\n\nउदाहरण:\nf_50(2, 3) 6 लौटाता है\nf_50(5, 5) 10 लौटाता है", "hu": "Két egész szám, a és b esetén adja vissza az összeget, ha az összeg páros, vagy a és b szorzatát, ha az összeg páratlan.\nPéldák:\nf_50(2, 3) visszaadja 6\nf_50(5, 5) visszaadja 10", "es": "Dado dos enteros a y b, devuelve la suma si la suma es par, o el producto de a y b si la suma es impar.\nEjemplos:\nf_50(2, 3) devuelve 6\nf_50(5, 5) devuelve 10", "arb": "نظرًا لعددين صحيحين a و b، قم بإرجاع المجموع إذا كان المجموع زوجيًا، أو حاصل ضرب a و b إذا كان المجموع فرديًا.\nأمثلة:\nf_50(2, 3) returns 6\nf_50(5, 5) returns 10", "sw": "Ukipewa nambari mbili a na b, rudisha jumla ikiwa jumla ni shufwa, au bidhaa ya a na b ikiwa jumla ni witiri.\nMfano:\nf_50(2, 3) inarudisha 6\nf_50(5, 5) inarudisha 10", "tr": "Verilen iki tamsayı a ve b için, toplam çift ise toplamı, toplam tek ise a ve b'nin çarpımını döndürün.\nÖrnekler:\nf_50(2, 3) 6 döndürür\nf_50(5, 5) 10 döndürür", "vi": "Cho hai số nguyên a và b, trả về tổng nếu tổng là số chẵn, hoặc tích của a và b nếu tổng là số lẻ.\nVí dụ:\nf_50(2, 3) trả về 6\nf_50(5, 5) trả về 10", "id": "Diberikan dua bilangan bulat a dan b, kembalikan jumlahnya jika jumlahnya genap, atau hasil kali dari a dan b jika jumlahnya ganjil.\nContoh:\nf_50(2, 3) mengembalikan 6\nf_50(5, 5) mengembalikan 10", "ja": "2つの整数aとbが与えられたとき、合計が偶数であればその合計を返し、合計が奇数であればaとbの積を返します。\n例:\nf_50(2, 3) は 6 を返します\nf_50(5, 5) は 10 を返します", "ko": "두 정수 a와 b가 주어지면, 합이 짝수일 경우 합을 반환하고, 합이 홀수일 경우 a와 b의 곱을 반환합니다.\n예시:\nf_50(2, 3) returns 6\nf_50(5, 5) returns 10", "ml": "രണ്ട് പൂർണ്ണസംഖ്യകളായ a, b എന്നിവ നൽകിയാൽ, തുക സമം ആണെങ്കിൽ തുക മടക്കുക, അല്ലെങ്കിൽ തുക അനിശ്ചിതമാണെങ്കിൽ a, b എന്നിവയുടെ ഗുണഫലം മടക്കുക.  \nരണ്ട് പൂർണ്ണസംഖ്യകൾ ആയ a, b എന്നിവ നൽകിയാൽ, തുക സമം ആണെങ്കിൽ തുക തിരികെ നൽകുക, അല്ലെങ്കിൽ തുക ബിസമ്മാണെങ്കിൽ a, b എന്നിവയുടെ ഗുണഫലം തിരികെ നൽകുക.\n\nExamples:  \nഉദാഹരണങ്ങൾ:\n\nf_50(2, 3) returns 6  \nf_50(5, 5) returns 10", "fa": "دو عدد صحیح a و b داده شده است، اگر مجموع آنها زوج باشد، مجموع را برگردانید، یا اگر مجموع فرد باشد، حاصلضرب a و b را برگردانید.\n\nمثال‌ها:\nf_50(2, 3) مقدار 6 را برمی‌گرداند\nf_50(5, 5) مقدار 10 را برمی‌گرداند"}}
