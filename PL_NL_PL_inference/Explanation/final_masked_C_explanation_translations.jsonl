{"task_id": "C/1", "prompt": {"en": "#include <assert.h>\n#include <string.h>\n// Return \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"\nchar *f_1()", "sq": "#include <assert.h>\n#include <string.h>\n// Kthen \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"\nchar *f_1()", "hy": "#include <assert.h>\n#include <string.h>\n// Վերադարձնել \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"\nchar *f_1()", "bn": "#include <assert.h>\n#include <string.h>\n// \"Hello, Mass-McEval: massively scaled multilingual code evaluation\" ফেরত দিন\nchar *f_1()", "bg": "#include <assert.h>\n#include <string.h>\n// Връща \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"\nchar *f_1()", "zh": "#include <assert.h>\n#include <string.h>\n// 返回 \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"\nchar *f_1()", "fr": "#include <assert.h>\n#include <string.h>\n// Retourne \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"\nchar *f_1()", "de": "#include <assert.h>\n#include <string.h>\n// Rückgabe \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"\nchar *f_1()", "ha": "#include <assert.h>\n#include <string.h>\n// Mayar da \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"\nchar *f_1()", "hi": "#include <assert.h>\n#include <string.h>\n// \"Hello, Mass-McEval: massively scaled multilingual code evaluation\" लौटाएं\nchar *f_1()", "hu": "#include <assert.h>\n#include <string.h>\n// Adja vissza a \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"\nchar *f_1()", "es": "#include <assert.h>\n#include <string.h>\n// Devuelve \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"\nchar *f_1()", "arb": "#include <assert.h>\n#include <string.h>\n// إرجاع \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"\nchar *f_1()", "sw": "#include <assert.h>\n#include <string.h>\n// Rudisha \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"\nchar *f_1()", "tr": "#include <assert.h>\n#include <string.h>\n// çözün\"Hello, Mass-McEval: massively scaled multilingual code evaluation\" döndür\nchar *f_1()", "vi": "#include <assert.h>\n#include <string.h>\n// Trả về \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"\nchar *f_1()", "id": "#include <assert.h>\n#include <string.h>\n// Mengembalikan \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"\nchar *f_1()", "ja": "#include <assert.h>\n#include <string.h>\n// \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"を返す\nchar *f_1()", "ko": "#include <assert.h>\n#include <string.h>\n// \"Hello, Mass-McEval: massively scaled multilingual code evaluation\" 반환\nchar *f_1()", "ml": "#include <assert.h>\n#include <string.h>\n// \"Hello, Mass-McEval: massively scaled multilingual code evaluation\" എന്നത് തിരികെ നൽകുക\nchar *f_1()", "fa": "#include <assert.h>\n#include <string.h>\n// بازگرداندن \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"\nchar *f_1()"}, "canonical_solution": "{\n    return \"Hello, Mass-McEval: massively scaled multilingual code evaluation\";\n}", "instruction": {"en": "char *f_1()\n{\n    return \"Hello, Mass-McEval: massively scaled multilingual code evaluation\";\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "sq": "char *f_1()\n{\n    return \"Hello, Mass-McEval: massively scaled multilingual code evaluation\";\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrale (docstring) të kodit C në shqip duke përdorur maksimumi 500 karaktere.", "hy": "char *f_1()\n{\n    return \"Hello, Mass-McEval: massively scaled multilingual code evaluation\";\n}\n\nՏվեք C կոդի համառոտ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "char *f_1()\n{\n    return \"Hello, Mass-McEval: massively scaled multilingual code evaluation\";\n}\n\nসি কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।", "bg": "char *f_1()\n{\n    return \"Hello, Mass-McEval: massively scaled multilingual code evaluation\";\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, използвайки не повече от 500 символа.", "zh": "char *f_1()\n{\n    return \"Hello, Mass-McEval: massively scaled multilingual code evaluation\";\n}\n\n请用不超过500个字符的中文，为以下C代码提供简明的自然语言描述（文档字符串）。", "fr": "char *f_1()\n{\n    return \"Hello, Mass-McEval: massively scaled multilingual code evaluation\";\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.", "de": "char *f_1()\n{\n    return \"Hello, Mass-McEval: massively scaled multilingual code evaluation\";\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "char *f_1()\n{\n    return \"Hello, Mass-McEval: massively scaled multilingual code evaluation\";\n}\n\nBa da takaitaccen bayanin yaren halitta (docstring) na lambar C a cikin Hausa ta amfani da haruffa 500 kacal.", "hi": "char *f_1()\n{\n    return \"Hello, Mass-McEval: massively scaled multilingual code evaluation\";\n}\n\nC कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "char *f_1()\n{\n    return \"Hello, Mass-McEval: massively scaled multilingual code evaluation\";\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben.", "es": "char *f_1()\n{\n    return \"Hello, Mass-McEval: massively scaled multilingual code evaluation\";\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando como máximo 500 caracteres.", "arb": "char *f_1()\n{\n    return \"Hello, Mass-McEval: massively scaled multilingual code evaluation\";\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية بلغة C باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "char *f_1()\n{\n    return \"Hello, Mass-McEval: massively scaled multilingual code evaluation\";\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "char *f_1()\n{\n    return \"Hello, Mass-McEval: massively scaled multilingual code evaluation\";\n}\n\nC kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanarak Türkçe olarak yazılmalıdır.", "vi": "char *f_1()\n{\n    return \"Hello, Mass-McEval: massively scaled multilingual code evaluation\";\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã C bằng tiếng Việt, sử dụng tối đa 500 ký tự.", "id": "char *f_1()\n{\n    return \"Hello, Mass-McEval: massively scaled multilingual code evaluation\";\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode C dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "char *f_1()\n{\n    return \"Hello, Mass-McEval: massively scaled multilingual code evaluation\";\n}\n\nCコードの内容を日本語で簡潔に説明するドキュメンテーション文字列（docstring）を、最大500文字で提供してください。", "ko": "char *f_1()\n{\n    return \"Hello, Mass-McEval: massively scaled multilingual code evaluation\";\n}\n\nC 코드의 동작을 설명하는 간결한 자연어 설명(도크스트링)을 한국어로 작성하세요. 최대 500자까지 가능합니다.", "ml": "char *f_1()\n{\n    return \"Hello, Mass-McEval: massively scaled multilingual code evaluation\";\n}\n\nസിയുടെ കോഡിന് 500 അക്ഷരങ്ങളിൽ കൂടാതെയുള്ള മലയാളത്തിൽ സംക്ഷിപ്തമായ ഒരു സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) നൽകുക.", "fa": "char *f_1()\n{\n    return \"Hello, Mass-McEval: massively scaled multilingual code evaluation\";\n}\n\nتوضیح مختصر و طبیعی (docstring) از کد C را به زبان فارسی ارائه دهید که حداکثر ۵۰۰ کاراکتر باشد."}, "level": "", "test": "int main()\n{\n    assert(strcmp(f_1(), \"Hello, Mass-McEval: massively scaled multilingual code evaluation\") == 0);\n    return 0;\n}", "entry_point": "f_1", "signature": "char *f_1()", "docstring": {"en": "Return \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "sq": "Kthe \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "hy": "Վերադարձնել \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "bn": "রিটার্ন \"Hello, Mass-McEval: massively scaled multilingual code evaluation", "bg": "Върнете \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "zh": "返回 \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "fr": "Retourne \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "de": "Rückgabe \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "ha": "Komawa \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "hi": "रिटर्न \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "hu": "Visszatér \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "es": "Devuelve \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "arb": "إرجاع \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "sw": "Rudisha \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "tr": "Return \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "vi": "Trả về \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "id": "Mengembalikan \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "ja": "\"Hello, Mass-McEval: massively scaled multilingual code evaluation\" を返します", "ko": "반환 \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "ml": "എന്നത് തിരികെ നൽകുക \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "fa": "بازگرداندن \"Hello, Mass-McEval: massively scaled multilingual code evaluation\""}}
{"task_id": "C/2", "prompt": {"en": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCalculate the area of a triangle given its three sides.\n​    Parameters:\n- a (float): Length of side 'a'.\n- b (float): Length of side 'b'.\n- c (float): Length of side 'c'.\n​    Returns:\n- str: If the provided sides form a triangle, return the calculated area with 2 decimal places.\nOtherwise, return \"-1\"\n    >>> f_2(3,5,4)\n    6\n*/\ndouble f_2(double a, double b, double c)", "sq": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nLlogarit sipërfaqen e një trekëndëshi duke pasur parasysh tre anët e tij.\n​    Parametrat:\n- a (float): Gjatësia e anës 'a'.\n- b (float): Gjatësia e anës 'b'.\n- c (float): Gjatësia e anës 'c'.\n​    Kthen:\n- str: Nëse anët e dhëna formojnë një trekëndësh, kthen sipërfaqen e llogaritur me 2 vende dhjetore.\nPërndryshe, kthe \"-1\"\n    >>> f_2(3,5,4)\n    6\n*/\ndouble f_2(double a, double b, double c)", "hy": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nՀաշվել եռանկյան մակերեսը՝ տրված նրա երեք կողմերը:\n​    Պարամետրեր:\n- a (float): 'a' կողմի երկարությունը:\n- b (float): 'b' կողմի երկարությունը:\n- c (float): 'c' կողմի երկարությունը:\n​    Վերադարձնում է:\n- str: Եթե տրված կողմերը կազմում են եռանկյուն, վերադարձնել հաշվարկված մակերեսը 2 տասնորդական թվանշաններով:\nՀակառակ դեպքում, վերադարձնել \"-1\"\n    >>> f_2(3,5,4)\n    6\n*/\ndouble f_2(double a, double b, double c)", "bn": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nএকটি ত্রিভুজের তিনটি বাহু দেওয়া থাকলে তার ক্ষেত্রফল গণনা করুন।\n​    প্যারামিটার:\n- a (float): বাহু 'a' এর দৈর্ঘ্য।\n- b (float): বাহু 'b' এর দৈর্ঘ্য।\n- c (float): বাহু 'c' এর দৈর্ঘ্য।\n​    রিটার্নস:\n- str: যদি প্রদত্ত বাহুগুলি একটি ত্রিভুজ গঠন করে, তবে 2 দশমিক স্থান সহ গণনা করা ক্ষেত্রফল ফেরত দিন।\nঅন্যথায়, \"-1\" ফেরত দিন\n    >>> f_2(3,5,4)\n    6\n*/\ndouble f_2(double a, double b, double c)", "bg": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nИзчислява площта на триъгълник, дадени неговите три страни.\n​    Параметри:\n- a (float): Дължина на страна 'a'.\n- b (float): Дължина на страна 'b'.\n- c (float): Дължина на страна 'c'.\n​    Връща:\n- str: Ако предоставените страни образуват триъгълник, връща изчислената площ с 2 десетични знака.\nВ противен случай връща \"-1\"\n    >>> f_2(3,5,4)\n    6\n*/\ndouble f_2(double a, double b, double c)", "zh": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n计算给定三边的三角形面积。\n    参数：\n- a (float): 边 'a' 的长度。\n- b (float): 边 'b' 的长度。\n- c (float): 边 'c' 的长度。\n    返回：\n- str: 如果提供的边能构成三角形，返回计算出的面积，保留两位小数。\n否则，返回 \"-1\"\n    >>> f_2(3,5,4)\n    6\n*/\ndouble f_2(double a, double b, double c)", "fr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCalculez l'aire d'un triangle donné ses trois côtés.\n    Paramètres :\n- a (float) : Longueur du côté 'a'.\n- b (float) : Longueur du côté 'b'.\n- c (float) : Longueur du côté 'c'.\n    Renvoie :\n- str : Si les côtés fournis forment un triangle, renvoie l'aire calculée avec 2 décimales.\nSinon, renvoie \"-1\"\n    >>> f_2(3,5,4)\n    6\n*/\ndouble f_2(double a, double b, double c)", "de": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nBerechnet die Fläche eines Dreiecks anhand seiner drei Seiten.\n​    Parameter:\n- a (float): Länge der Seite 'a'.\n- b (float): Länge der Seite 'b'.\n- c (float): Länge der Seite 'c'.\n​    Rückgabe:\n- str: Wenn die angegebenen Seiten ein Dreieck bilden, geben Sie die berechnete Fläche mit 2 Dezimalstellen zurück.\nAndernfalls geben Sie \"-1\" zurück.\n    >>> f_2(3,5,4)\n    6\n*/\ndouble f_2(double a, double b, double c)", "ha": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nƘididdige yanki na alwatika idan aka ba da gefenta uku.\n​    Sigogi:\n- a (float): Tsawon gefe 'a'.\n- b (float): Tsawon gefe 'b'.\n- c (float): Tsawon gefe 'c'.\n​    Mayarwa:\n- str: Idan gefen da aka bayar sun samar da alwatika, mayar da yankin da aka ƙididdige tare da wurare biyu na goma.\nIn ba haka ba, mayar da \"-1\"\n    >>> f_2(3,5,4)\n    6\n*/\ndouble f_2(double a, double b, double c)", "hi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nकिसी त्रिभुज के तीन भुजाओं के आधार पर उसका क्षेत्रफल गणना करें।\n    पैरामीटर्स:\n- a (float): भुजा 'a' की लंबाई।\n- b (float): भुजा 'b' की लंबाई।\n- c (float): भुजा 'c' की लंबाई।\n    रिटर्न्स:\n- str: यदि दी गई भुजाएँ एक त्रिभुज बनाती हैं, तो 2 दशमलव स्थानों के साथ गणना किया गया क्षेत्रफल लौटाएं।\nअन्यथा, \"-1\" लौटाएं\n    >>> f_2(3,5,4)\n    6\n*/\ndouble f_2(double a, double b, double c)", "hu": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nSzámítsa ki egy háromszög területét a három oldalának ismeretében.\n​    Paraméterek:\n- a (float): Az 'a' oldal hossza.\n- b (float): A 'b' oldal hossza.\n- c (float): A 'c' oldal hossza.\n​    Visszatér:\n- str: Ha a megadott oldalak háromszöget alkotnak, térjen vissza a kiszámított területtel 2 tizedesjegy pontossággal.\nEllenkező esetben térjen vissza \"-1\" értékkel.\n    >>> f_2(3,5,4)\n    6\n*/\ndouble f_2(double a, double b, double c)", "es": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCalcular el área de un triángulo dados sus tres lados.\n    Parámetros:\n- a (float): Longitud del lado 'a'.\n- b (float): Longitud del lado 'b'.\n- c (float): Longitud del lado 'c'.\n    Devuelve:\n- str: Si los lados proporcionados forman un triángulo, devuelve el área calculada con 2 decimales.\nDe lo contrario, devuelve \"-1\"\n    >>> f_2(3,5,4)\n    6\n*/\ndouble f_2(double a, double b, double c)", "arb": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nاحسب مساحة المثلث المعطى أضلاعه الثلاثة.\n    المعاملات:\n- a (float): طول الضلع 'a'.\n- b (float): طول الضلع 'b'.\n- c (float): طول الضلع 'c'.\n    يعيد:\n- str: إذا كانت الأضلاع المقدمة تشكل مثلثًا، يعيد المساحة المحسوبة بدقة منزلتين عشريتين.\nخلاف ذلك، يعيد \"-1\"\n    >>> f_2(3,5,4)\n    6\n*/\ndouble f_2(double a, double b, double c)", "sw": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nHesabu eneo la pembetatu ukitumia pande zake tatu.\n​    Vigezo:\n- a (float): Urefu wa upande 'a'.\n- b (float): Urefu wa upande 'b'.\n- c (float): Urefu wa upande 'c'.\n​    Inarudisha:\n- str: Ikiwa pande zilizotolewa zinaunda pembetatu, rudisha eneo lililohesabiwa na sehemu 2 za desimali.\nVinginevyo, rudisha \"-1\"\n    >>> f_2(3,5,4)\n    6\n*/\ndouble f_2(double a, double b, double c)", "tr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nÜç kenarı verilen bir üçgenin alanını hesaplayın.\n​    Parametreler:\n- a (float): 'a' kenarının uzunluğu.\n- b (float): 'b' kenarının uzunluğu.\n- c (float): 'c' kenarının uzunluğu.\n​    Döndürür:\n- str: Eğer verilen kenarlar bir üçgen oluşturuyorsa, hesaplanan alanı 2 ondalık basamakla döndürün.\nAksi takdirde, \"-1\" döndürün.\n    >>> f_2(3,5,4)\n    6\n*/\ndouble f_2(double a, double b, double c)", "vi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nTính diện tích của một tam giác khi biết ba cạnh của nó.\n​    Tham số:\n- a (float): Độ dài cạnh 'a'.\n- b (float): Độ dài cạnh 'b'.\n- c (float): Độ dài cạnh 'c'.\n​    Trả về:\n- str: Nếu các cạnh được cung cấp tạo thành một tam giác, trả về diện tích đã tính với 2 chữ số thập phân.\nNếu không, trả về \"-1\"\n    >>> f_2(3,5,4)\n    6\n*/\ndouble f_2(double a, double b, double c)", "id": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nMenghitung luas segitiga berdasarkan tiga sisinya.\n    Parameter:\n- a (float): Panjang sisi 'a'.\n- b (float): Panjang sisi 'b'.\n- c (float): Panjang sisi 'c'.\n    Mengembalikan:\n- str: Jika sisi yang diberikan membentuk segitiga, kembalikan luas yang dihitung dengan 2 angka desimal.\nJika tidak, kembalikan \"-1\"\n    >>> f_2(3,5,4)\n    6\n*/\ndouble f_2(double a, double b, double c)", "ja": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n三角形の3辺が与えられたときに、その面積を計算します。\n    パラメータ:\n- a (float): 辺 'a' の長さ。\n- b (float): 辺 'b' の長さ。\n- c (float): 辺 'c' の長さ。\n    戻り値:\n- str: 提供された辺が三角形を形成する場合、計算された面積を小数点以下2桁で返します。\nそれ以外の場合は \"-1\" を返します。\n    >>> f_2(3,5,4)\n    6\n*/\ndouble f_2(double a, double b, double c)", "ko": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n주어진 세 변의 길이를 통해 삼각형의 넓이를 계산합니다.\n​    매개변수:\n- a (float): 변 'a'의 길이.\n- b (float): 변 'b'의 길이.\n- c (float): 변 'c'의 길이.\n​    반환:\n- str: 제공된 변들이 삼각형을 형성하면, 소수점 두 자리까지 계산된 넓이를 반환합니다.\n그렇지 않으면, \"-1\"을 반환합니다.\n    >>> f_2(3,5,4)\n    6\n*/\ndouble f_2(double a, double b, double c)", "ml": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nഒരു ത്രികോണമിന്റെ മൂന്ന് വശങ്ങൾ നൽകിയാൽ അതിന്റെ വിസ്തീർണം കണക്കാക്കുക.\n    പാരാമീറ്ററുകൾ:\n- a (float): വശം 'a'യുടെ നീളം.\n- b (float): വശം 'b'യുടെ നീളം.\n- c (float): വശം 'c'യുടെ നീളം.\n    മടക്കുക:\n- str: നൽകിയ വശങ്ങൾ ഒരു ത്രികോണം രൂപീകരിക്കുന്നുവെങ്കിൽ, 2 ദശാംശസ്ഥാനം വരെ കണക്കാക്കിയ വിസ്തീർണം മടക്കുക.\nഇല്ലെങ്കിൽ, \"-1\" മടക്കുക\n    >>> f_2(3,5,4)\n    6\n*/\ndouble f_2(double a, double b, double c)", "fa": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nمساحت یک مثلث را با توجه به سه ضلع آن محاسبه کنید.\n    پارامترها:\n- a (float): طول ضلع 'a'.\n- b (float): طول ضلع 'b'.\n- c (float): طول ضلع 'c'.\n    بازگشت:\n- str: اگر اضلاع ارائه شده یک مثلث تشکیل دهند، مساحت محاسبه شده را با 2 رقم اعشار برگردانید.\nدر غیر این صورت، \"-1\" را برگردانید.\n    >>> f_2(3,5,4)\n    6\n*/\ndouble f_2(double a, double b, double c)"}, "canonical_solution": "{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        // printf(\"Not a triangle.\\n\");\n        return -1; // Use a special value to indicate not a triangle\n    }\n}", "instruction": {"en": "double f_2(double a, double b, double c)\n{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        // printf(\"Not a triangle.\\n\");\n        return -1; // Use a special value to indicate not a triangle\n    }\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "sq": "double f_2(double a, double b, double c)\n{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        // printf(\"Not a triangle.\\n\");\n        return -1; // Use a special value to indicate not a triangle\n    }\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C në shqip duke përdorur maksimumi 500 karaktere.", "hy": "double f_2(double a, double b, double c)\n{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        // printf(\"Not a triangle.\\n\");\n        return -1; // Use a special value to indicate not a triangle\n    }\n}\n\nՏվեք C կոդի հակիրճ բնութագրումը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "double f_2(double a, double b, double c)\n{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        // printf(\"Not a triangle.\\n\");\n        return -1; // Use a special value to indicate not a triangle\n    }\n}\n\nসি কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।", "bg": "double f_2(double a, double b, double c)\n{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        // printf(\"Not a triangle.\\n\");\n        return -1; // Use a special value to indicate not a triangle\n    }\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, използвайки най-много 500 знака.", "zh": "double f_2(double a, double b, double c)\n{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        // printf(\"Not a triangle.\\n\");\n        return -1; // Use a special value to indicate not a triangle\n    }\n}\n\n请用不超过500个字符的中文，为以下C代码提供简洁的自然语言描述（文档字符串）。", "fr": "double f_2(double a, double b, double c)\n{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        // printf(\"Not a triangle.\\n\");\n        return -1; // Use a special value to indicate not a triangle\n    }\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.", "de": "double f_2(double a, double b, double c)\n{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        // printf(\"Not a triangle.\\n\");\n        return -1; // Use a special value to indicate not a triangle\n    }\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "double f_2(double a, double b, double c)\n{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        // printf(\"Not a triangle.\\n\");\n        return -1; // Use a special value to indicate not a triangle\n    }\n}\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar C cikin Hausa ta amfani da haruffa 500 kacal.", "hi": "double f_2(double a, double b, double c)\n{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        // printf(\"Not a triangle.\\n\");\n        return -1; // Use a special value to indicate not a triangle\n    }\n}\n\nC कोड का संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "double f_2(double a, double b, double c)\n{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        // printf(\"Not a triangle.\\n\");\n        return -1; // Use a special value to indicate not a triangle\n    }\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben.", "es": "double f_2(double a, double b, double c)\n{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        // printf(\"Not a triangle.\\n\");\n        return -1; // Use a special value to indicate not a triangle\n    }\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando como máximo 500 caracteres.", "arb": "double f_2(double a, double b, double c)\n{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        // printf(\"Not a triangle.\\n\");\n        return -1; // Use a special value to indicate not a triangle\n    }\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "double f_2(double a, double b, double c)\n{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        // printf(\"Not a triangle.\\n\");\n        return -1; // Use a special value to indicate not a triangle\n    }\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "double f_2(double a, double b, double c)\n{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        // printf(\"Not a triangle.\\n\");\n        return -1; // Use a special value to indicate not a triangle\n    }\n}\n\nC kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanarak Türkçe olarak yazılmalıdır.", "vi": "double f_2(double a, double b, double c)\n{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        // printf(\"Not a triangle.\\n\");\n        return -1; // Use a special value to indicate not a triangle\n    }\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã C bằng tiếng Việt với tối đa 500 ký tự.", "id": "double f_2(double a, double b, double c)\n{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        // printf(\"Not a triangle.\\n\");\n        return -1; // Use a special value to indicate not a triangle\n    }\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode C dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "double f_2(double a, double b, double c)\n{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        // printf(\"Not a triangle.\\n\");\n        return -1; // Use a special value to indicate not a triangle\n    }\n}\n\nCコードの内容を日本語で簡潔に説明するドキュメンテーション文字列（docstring）を500文字以内で提供してください。", "ko": "double f_2(double a, double b, double c)\n{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        // printf(\"Not a triangle.\\n\");\n        return -1; // Use a special value to indicate not a triangle\n    }\n}\n\nC 코드의 동작을 설명하는 간결한 자연어 설명(docstring)을 한국어로 작성하세요. 최대 500자까지 가능합니다.", "ml": "double f_2(double a, double b, double c)\n{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        // printf(\"Not a triangle.\\n\");\n        return -1; // Use a special value to indicate not a triangle\n    }\n}\n\nC കോഡിന്റെ സംക്ഷിപ്തമായ സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) മലയാളത്തിൽ 500 അക്ഷരങ്ങളിൽ കവിയാതെയായി നൽകുക.", "fa": "double f_2(double a, double b, double c)\n{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        // printf(\"Not a triangle.\\n\");\n        return -1; // Use a special value to indicate not a triangle\n    }\n}\n\nیک توضیح مختصر به زبان طبیعی (docstring) از کد C به زبان فارسی ارائه دهید که حداکثر ۵۰۰ کاراکتر باشد."}, "level": "", "test": "int main()\n{\n    double area;\n\n    // Triangle with sides 3, 5, 4 should return area 6\n    area = f_2(3, 5, 4);\n    assert(fabs(area - 6) < 1e-6);\n\n    // Not a triangle with sides 1, 1, 4 should print \"Not a triangle.\"\n    area = f_2(1, 1, 4);\n    assert(area == -1);\n\n    // Triangle with sides 7, 24, 25 should return area 84\n    area = f_2(7, 24, 25);\n    assert(fabs(area - 84) < 1e-6);\n\n    // Triangle with sides 10.5, 6.2, 7.3 should return a correct area\n    area = f_2(10.5, 6.2, 7.3);\n    // printf(\"%lf\\n\", area); // Print the area with 2 decimal places\n    // For precision issues, we test if the calculated area is close enough to the expected value\n    assert(fabs(area - 22.15) < 1e-2);\n\n    \n    return 0;\n}", "entry_point": "f_2", "signature": "double f_2(double a, double b, double c)", "docstring": {"en": "Calculate the area of a triangle given its three sides.\n    Parameters:\n- a (float): Length of side 'a'.\n- b (float): Length of side 'b'.\n- c (float): Length of side 'c'.\n    Returns:\n- str: If the provided sides form a triangle, return the calculated area with 2 decimal places.\nOtherwise, return \"-1\"\n    >>> f_2(3,5,4)\n    6\n", "sq": "Llogarit sipërfaqen e një trekëndëshi duke pasur parasysh tre anët e tij.\n    Parametra:\n- a (float): Gjatësia e anës 'a'.\n- b (float): Gjatësia e anës 'b'.\n- c (float): Gjatësia e anës 'c'.\n    Kthen:\n- str: Nëse anët e dhëna formojnë një trekëndësh, kthen sipërfaqen e llogaritur me 2 vende dhjetore.\nPërndryshe, kthen \"-1\"\n    >>> f_2(3,5,4)\n    6", "hy": "Հաշվարկել եռանկյան մակերեսը՝ հաշվի առնելով նրա երեք կողմերը:\n    Պարամետրեր:\n- a (float): 'a' կողմի երկարությունը:\n- b (float): 'b' կողմի երկարությունը:\n- c (float): 'c' կողմի երկարությունը:\n    Վերադարձնում է:\n- str: Եթե տրված կողմերը կազմում են եռանկյուն, վերադարձնում է հաշվարկված մակերեսը՝ 2 տասնորդական թվանշաններով:\nՀակառակ դեպքում վերադարձնում է \"-1\"\n    >>> f_2(3,5,4)\n    6", "bn": "ত্রিভুজের তিনটি বাহু দেওয়া থাকলে তার ক্ষেত্রফল গণনা করুন।\n    প্যারামিটারসমূহ:\n- a (float): 'a' বাহুর দৈর্ঘ্য।\n- b (float): 'b' বাহুর দৈর্ঘ্য।\n- c (float): 'c' বাহুর দৈর্ঘ্য।\n    রিটার্ন:\n- str: যদি প্রদত্ত বাহুগুলি একটি ত্রিভুজ গঠন করে, তবে 2 দশমিক স্থান সহ গণনা করা ক্ষেত্রফল ফেরত দিন।\nঅন্যথায়, \"-1\" ফেরত দিন\n    >>> f_2(3,5,4)\n    6", "bg": "Изчислява площта на триъгълник, дадени неговите три страни.\n    Параметри:\n- a (float): Дължина на страна 'a'.\n- b (float): Дължина на страна 'b'.\n- c (float): Дължина на страна 'c'.\n    Връща:\n- str: Ако предоставените страни образуват триъгълник, връща изчислената площ с 2 десетични знака.\nВ противен случай, връща \"-1\"\n    >>> f_2(3,5,4)\n    6", "zh": "计算给定三边的三角形面积。\n    参数:\n- a (float): 边 'a' 的长度。\n- b (float): 边 'b' 的长度。\n- c (float): 边 'c' 的长度。\n    返回:\n- str: 如果提供的边能构成一个三角形，返回计算出的面积，保留两位小数。\n否则，返回 \"-1\"\n    >>> f_2(3,5,4)\n    6", "fr": "Calculer l'aire d'un triangle donné ses trois côtés.\n    Paramètres:\n- a (float): Longueur du côté 'a'.\n- b (float): Longueur du côté 'b'.\n- c (float): Longueur du côté 'c'.\n    Renvoie:\n- str: Si les côtés fournis forment un triangle, renvoie l'aire calculée avec 2 décimales.\nSinon, renvoie \"-1\"\n    >>> f_2(3,5,4)\n    6", "de": "Berechnen Sie die Fläche eines Dreiecks, gegeben seine drei Seiten.\n    Parameter:\n- a (float): Länge der Seite 'a'.\n- b (float): Länge der Seite 'b'.\n- c (float): Länge der Seite 'c'.\n    Rückgabewert:\n- str: Wenn die angegebenen Seiten ein Dreieck bilden, geben Sie die berechnete Fläche mit 2 Dezimalstellen zurück.\nAndernfalls geben Sie \"-1\" zurück.\n    >>> f_2(3,5,4)\n    6", "ha": "Calculate the area of a triangle given its three sides.\n    Sigogi:\n- a (float): Tsawon gefen 'a'.\n- b (float): Tsawon gefen 'b'.\n- c (float): Tsawon gefen 'c'.\n    Abin da ake dawowa da shi:\n- str: Idan gefen da aka bayar sun samar da alwatika, dawo da yankin da aka lissafa tare da wurare guda 2 na adadi.\nIn ba haka ba, dawo da \"-1\"\n    >>> f_2(3,5,4)\n    6", "hi": "त्रिभुज के तीन भुजाओं के आधार पर उसका क्षेत्रफल गणना करें।\n    पैरामीटर्स:\n- a (float): भुजा 'a' की लंबाई।\n- b (float): भुजा 'b' की लंबाई।\n- c (float): भुजा 'c' की लंबाई।\n    रिटर्न्स:\n- str: यदि दी गई भुजाएँ एक त्रिभुज बनाती हैं, तो 2 दशमलव स्थानों के साथ गणना किया गया क्षेत्रफल लौटाएँ।\nअन्यथा, \"-1\" लौटाएँ\n    >>> f_2(3,5,4)\n    6", "hu": "Számítsa ki egy háromszög területét a három oldalának ismeretében.\n    Paraméterek:\n- a (float): Az 'a' oldal hossza.\n- b (float): A 'b' oldal hossza.\n- c (float): A 'c' oldal hossza.\n    Visszatérési érték:\n- str: Ha a megadott oldalak háromszöget alkotnak, térjen vissza a kiszámított területtel 2 tizedesjegy pontossággal.\nEgyébként térjen vissza \"-1\"\n    >>> f_2(3,5,4)\n    6", "es": "Calcular el área de un triángulo dados sus tres lados.\n    Parámetros:\n- a (float): Longitud del lado 'a'.\n- b (float): Longitud del lado 'b'.\n- c (float): Longitud del lado 'c'.\n    Devuelve:\n- str: Si los lados proporcionados forman un triángulo, devuelve el área calculada con 2 decimales.\nDe lo contrario, devuelve \"-1\"\n    >>> f_2(3,5,4)\n    6", "arb": "حساب مساحة مثلث معطى أضلاعه الثلاثة.\n    المعلمات:\n- a (float): طول الضلع 'a'.\n- b (float): طول الضلع 'b'.\n- c (float): طول الضلع 'c'.\n    يعيد:\n- str: إذا كانت الأضلاع المقدمة تشكل مثلثًا، يتم إرجاع المساحة المحسوبة مع منزلتين عشريتين.\nخلاف ذلك، يتم إرجاع \"-1\"\n    >>> f_2(3,5,4)\n    6", "sw": "Hesabu eneo la pembetatu ukitumia pande zake tatu.\n    Vigezo:\n- a (float): Urefu wa upande 'a'.\n- b (float): Urefu wa upande 'b'.\n- c (float): Urefu wa upande 'c'.\n    Inarejesha:\n- str: Ikiwa pande zilizotolewa zinaunda pembetatu, rejesha eneo lililohesabiwa na sehemu 2 za desimali.\nVinginevyo, rejesha \"-1\"\n    >>> f_2(3,5,4)\n    6", "tr": "Üç kenarı verilen bir üçgenin alanını hesaplayın.\n    Parametreler:\n- a (float): 'a' kenarının uzunluğu.\n- b (float): 'b' kenarının uzunluğu.\n- c (float): 'c' kenarının uzunluğu.\n    Döndürülenler:\n- str: Verilen kenarlar bir üçgen oluşturuyorsa, hesaplanan alanı 2 ondalık basamakla döndürün.\nAksi takdirde, \"-1\" döndürün.\n    >>> f_2(3,5,4)\n    6", "vi": "Tính diện tích của một tam giác khi biết ba cạnh của nó.\n    Tham số:\n- a (float): Độ dài của cạnh 'a'.\n- b (float): Độ dài của cạnh 'b'.\n- c (float): Độ dài của cạnh 'c'.\n    Trả về:\n- str: Nếu các cạnh được cung cấp tạo thành một tam giác, trả về diện tích đã tính với 2 chữ số thập phân.\nNếu không, trả về \"-1\"\n    >>> f_2(3,5,4)\n    6", "id": "Hitung luas segitiga berdasarkan tiga sisinya.\n    Parameter:\n- a (float): Panjang sisi 'a'.\n- b (float): Panjang sisi 'b'.\n- c (float): Panjang sisi 'c'.\n    Mengembalikan:\n- str: Jika sisi yang diberikan membentuk segitiga, kembalikan luas yang dihitung dengan 2 tempat desimal.\nJika tidak, kembalikan \"-1\"\n    >>> f_2(3,5,4)\n    6", "ja": "三角形の3辺が与えられたときの面積を計算します。\n    引数:\n- a (float): 辺 'a' の長さ。\n- b (float): 辺 'b' の長さ。\n- c (float): 辺 'c' の長さ。\n    戻り値:\n- str: 提供された辺が三角形を形成する場合、計算された面積を小数点以下2桁で返します。\nそれ以外の場合は \"-1\" を返します。\n    >>> f_2(3,5,4)\n    6", "ko": "삼각형의 세 변이 주어졌을 때 면적을 계산합니다.\n    매개변수:\n- a (float): 변 'a'의 길이.\n- b (float): 변 'b'의 길이.\n- c (float): 변 'c'의 길이.\n    반환값:\n- str: 제공된 변들이 삼각형을 형성하면, 소수점 둘째 자리까지 계산된 면적을 반환합니다.\n그렇지 않으면 \"-1\"을 반환합니다.\n    >>> f_2(3,5,4)\n    6", "ml": "ത്രികോണമിതിയുടെ മൂന്നു വശങ്ങളും നൽകിയാൽ ത്രികോണമിതിയുടെ വിസ്തീർണ്ണം കണക്കാക്കുക.\n    പാരാമീറ്ററുകൾ:\n- a (float): വശം 'a'യുടെ നീളം.\n- b (float): വശം 'b'യുടെ നീളം.\n- c (float): വശം 'c'യുടെ നീളം.\n    മടക്കങ്ങൾ:\n- str: നൽകിയ വശങ്ങൾ ഒരു ത്രികോണം രൂപീകരിക്കുന്നുവെങ്കിൽ, കണക്കാക്കിയ വിസ്തീർണ്ണം 2 ദശാംശസ്ഥാനം വരെ മടക്കുക.\nഅല്ലെങ്കിൽ, \"-1\" മടക്കുക.\n    >>> f_2(3,5,4)\n    6", "fa": "محاسبه مساحت یک مثلث با توجه به سه ضلع آن.\n    پارامترها:\n- a (float): طول ضلع 'a'.\n- b (float): طول ضلع 'b'.\n- c (float): طول ضلع 'c'.\n    بازگشت:\n- str: اگر اضلاع ارائه شده یک مثلث تشکیل دهند، مساحت محاسبه شده را با 2 رقم اعشار برمی‌گرداند.\nدر غیر این صورت، \"-1\" را برمی‌گرداند.\n    >>> f_2(3,5,4)\n    6"}}
{"task_id": "C/3", "prompt": {"en": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCalculate the value of the function for a given input.\n    Parameters:\n- x (int): Input value for the function.\n    Returns:\n- double or string: If x is not in the defined domain, returns \"Not define\".\nOtherwise, returns the calculated function value rounded to 5 decimal places.\n\n    Function Definitions:\n- For 0 <= x < 10: y = cos(x + 3.0)\n- For 10 <= x < 20: y = (cos(x + 7.5))^2\n- For 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n\tNot define\n*/\nconst char* f_3(int x)", "sq": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nLlogarit vlerën e funksionit për një hyrje të dhënë.\n    Parametrat:\n- x (int): Vlera e hyrjes për funksionin.\n    Kthen:\n- double ose string: Nëse x nuk është në domenin e përcaktuar, kthen \"Not define\".\nPërndryshe, kthen vlerën e llogaritur të funksionit të rrumbullakosur në 5 vende dhjetore.\n\n    Përkufizimet e Funksionit:\n- Për 0 <= x < 10: y = cos(x + 3.0)\n- Për 10 <= x < 20: y = (cos(x + 7.5))^2\n- Për 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n\tNot define\n*/\nconst char* f_3(int x)", "hy": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nՀաշվել ֆունկցիայի արժեքը տրված մուտքագրվածի համար։\n    Պարամետրեր:\n- x (int): Մուտքագրված արժեքը ֆունկցիայի համար։\n    Վերադարձնում է:\n- double կամ string: Եթե x-ը սահմանված տիրույթում չէ, վերադարձնում է \"Not define\"։\nՀակառակ դեպքում, վերադարձնում է հաշվարկված ֆունկցիայի արժեքը, կլորացված մինչև 5 տասնորդական թվանշան։\n\n    Ֆունկցիայի սահմանումներ:\n- 0 <= x < 10: y = cos(x + 3.0)\n- 10 <= x < 20: y = (cos(x + 7.5))^2\n- 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n\tNot define\n*/\nconst char* f_3(int x)", "bn": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nএকটি প্রদত্ত ইনপুটের জন্য ফাংশনের মান গণনা করুন।\n    প্যারামিটার:\n- x (int): ফাংশনের জন্য ইনপুট মান।\n    রিটার্ন:\n- double বা string: যদি x সংজ্ঞায়িত ডোমেইনে না থাকে, তাহলে \"Not define\" রিটার্ন করে।\nঅন্যথায়, গণনা করা ফাংশনের মান 5 দশমিক স্থান পর্যন্ত রাউন্ড করে রিটার্ন করে।\n\n    ফাংশন সংজ্ঞা:\n- 0 <= x < 10 এর জন্য: y = cos(x + 3.0)\n- 10 <= x < 20 এর জন্য: y = (cos(x + 7.5))^2\n- 20 <= x < 30 এর জন্য: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n\tNot define\n*/\nconst char* f_3(int x)", "bg": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nИзчислява стойността на функцията за даден вход.\n    Параметри:\n- x (int): Входна стойност за функцията.\n    Връща:\n- double или string: Ако x не е в дефинираното множество, връща \"Not define\".\nВ противен случай, връща изчислената стойност на функцията, закръглена до 5 знака след десетичната запетая.\n\n    Дефиниции на функцията:\n- За 0 <= x < 10: y = cos(x + 3.0)\n- За 10 <= x < 20: y = (cos(x + 7.5))^2\n- За 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n\tNot define\n*/\nconst char* f_3(int x)", "zh": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n计算给定输入的函数值。\n    参数：\n- x (int): 函数的输入值。\n    返回：\n- double 或 string: 如果 x 不在定义域内，返回 \"Not define\"。\n否则，返回计算的函数值，保留到小数点后5位。\n\n    函数定义：\n- 对于 0 <= x < 10: y = cos(x + 3.0)\n- 对于 10 <= x < 20: y = (cos(x + 7.5))^2\n- 对于 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n\tNot define\n*/\nconst char* f_3(int x)", "fr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCalculez la valeur de la fonction pour une entrée donnée.\n    Paramètres:\n- x (int): Valeur d'entrée pour la fonction.\n    Renvoie:\n- double ou chaîne: Si x n'est pas dans le domaine défini, renvoie \"Not define\".\nSinon, renvoie la valeur calculée de la fonction arrondie à 5 décimales.\n\n    Définitions de la fonction:\n- Pour 0 <= x < 10: y = cos(x + 3.0)\n- Pour 10 <= x < 20: y = (cos(x + 7.5))^2\n- Pour 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n\tNot define\n*/\nconst char* f_3(int x)", "de": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nBerechnet den Wert der Funktion für eine gegebene Eingabe.\n    Parameter:\n- x (int): Eingabewert für die Funktion.\n    Rückgabe:\n- double oder string: Wenn x nicht im definierten Bereich liegt, wird \"Not define\" zurückgegeben.\nAndernfalls wird der berechnete Funktionswert auf 5 Dezimalstellen gerundet zurückgegeben.\n\n    Funktionsdefinitionen:\n- Für 0 <= x < 10: y = cos(x + 3.0)\n- Für 10 <= x < 20: y = (cos(x + 7.5))^2\n- Für 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n\tNot define\n*/\nconst char* f_3(int x)", "ha": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nƘididdige ƙimar aikin don wani shigarwar da aka bayar.\n    Sigogi:\n- x (int): Ƙimar shigarwa don aikin.\n    Mayar da:\n- double ko string: Idan x ba ya cikin yankin da aka ayyana, yana mayar da \"Not define\".\nIn ba haka ba, yana mayar da ƙimar aikin da aka ƙididdige tare da zagaye zuwa wurare 5 na ɗigo.\n\n    Ma'anar Aiki:\n- Don 0 <= x < 10: y = cos(x + 3.0)\n- Don 10 <= x < 20: y = (cos(x + 7.5))^2\n- Don 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n\tNot define\n*/\nconst char* f_3(int x)", "hi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nदिए गए इनपुट के लिए फ़ंक्शन का मान गणना करें।\n    पैरामीटर्स:\n- x (int): फ़ंक्शन के लिए इनपुट मान।\n    रिटर्न करता है:\n- double या string: यदि x परिभाषित डोमेन में नहीं है, तो \"Not define\" लौटाता है।\nअन्यथा, गणना किए गए फ़ंक्शन मान को 5 दशमलव स्थानों तक राउंड करके लौटाता है।\n\n    फ़ंक्शन परिभाषाएँ:\n- 0 <= x < 10 के लिए: y = cos(x + 3.0)\n- 10 <= x < 20 के लिए: y = (cos(x + 7.5))^2\n- 20 <= x < 30 के लिए: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n\tNot define\n*/\nconst char* f_3(int x)", "hu": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nSzámítsa ki a függvény értékét egy adott bemenetre.\n    Paraméterek:\n- x (int): A függvény bemeneti értéke.\n    Visszatér:\n- double vagy string: Ha x nincs a meghatározott tartományban, \"Not define\"-t ad vissza.\nEgyébként a kiszámított függvényértéket adja vissza, 5 tizedesjegyre kerekítve.\n\n    Függvény definíciók:\n- Ha 0 <= x < 10: y = cos(x + 3.0)\n- Ha 10 <= x < 20: y = (cos(x + 7.5))^2\n- Ha 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n\tNot define\n*/\nconst char* f_3(int x)", "es": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCalcular el valor de la función para una entrada dada.\n    Parámetros:\n- x (int): Valor de entrada para la función.\n    Retorna:\n- double o string: Si x no está en el dominio definido, retorna \"Not define\".\nDe lo contrario, retorna el valor calculado de la función redondeado a 5 decimales.\n\n    Definiciones de Función:\n- Para 0 <= x < 10: y = cos(x + 3.0)\n- Para 10 <= x < 20: y = (cos(x + 7.5))^2\n- Para 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n\tNot define\n*/\nconst char* f_3(int x)", "arb": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nاحسب قيمة الدالة لمدخل معين.\n    المعاملات:\n- x (int): قيمة المدخل للدالة.\n    يعيد:\n- double أو string: إذا لم يكن x في النطاق المحدد، يعيد \"Not define\".\nوإلا، يعيد قيمة الدالة المحسوبة مقربة إلى 5 منازل عشرية.\n\n    تعريفات الدوال:\n- لـ 0 <= x < 10: y = cos(x + 3.0)\n- لـ 10 <= x < 20: y = (cos(x + 7.5))^2\n- لـ 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n\tNot define\n*/\nconst char* f_3(int x)", "sw": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nHesabu thamani ya kazi kwa pembejeo iliyotolewa.\n    Vigezo:\n- x (int): Thamani ya pembejeo kwa kazi.\n    Inarejesha:\n- double au string: Ikiwa x haipo katika kikoa kilichobainishwa, inarejesha \"Not define\".\nVinginevyo, inarejesha thamani ya kazi iliyohesabiwa iliyokatwa hadi sehemu 5 za desimali.\n\n    Ufafanuzi wa Kazi:\n- Kwa 0 <= x < 10: y = cos(x + 3.0)\n- Kwa 10 <= x < 20: y = (cos(x + 7.5))^2\n- Kwa 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n\tNot define\n*/\nconst char* f_3(int x)", "tr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nBelirtilen bir giriş için fonksiyonun değerini hesaplayın.\n    Parametreler:\n- x (int): Fonksiyon için giriş değeri.\n    Döndürür:\n- double veya string: Eğer x tanımlı alanda değilse, \"Not define\" döndürür.\nAksi takdirde, hesaplanan fonksiyon değerini 5 ondalık basamağa yuvarlanmış olarak döndürür.\n\n    Fonksiyon Tanımları:\n- 0 <= x < 10 için: y = cos(x + 3.0)\n- 10 <= x < 20 için: y = (cos(x + 7.5))^2\n- 20 <= x < 30 için: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n\tNot define\n*/\nconst char* f_3(int x)", "vi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nTính giá trị của hàm cho một đầu vào cho trước.\n    Tham số:\n- x (int): Giá trị đầu vào cho hàm.\n    Trả về:\n- double hoặc string: Nếu x không nằm trong miền xác định, trả về \"Not define\".\nNgược lại, trả về giá trị hàm đã tính toán được làm tròn đến 5 chữ số thập phân.\n\n    Định nghĩa hàm:\n- Đối với 0 <= x < 10: y = cos(x + 3.0)\n- Đối với 10 <= x < 20: y = (cos(x + 7.5))^2\n- Đối với 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n\tNot define\n*/\nconst char* f_3(int x)", "id": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nMenghitung nilai fungsi untuk input yang diberikan.\n    Parameter:\n- x (int): Nilai input untuk fungsi.\n    Mengembalikan:\n- double atau string: Jika x tidak dalam domain yang ditentukan, mengembalikan \"Not define\".\nJika tidak, mengembalikan nilai fungsi yang dihitung dibulatkan hingga 5 tempat desimal.\n\n    Definisi Fungsi:\n- Untuk 0 <= x < 10: y = cos(x + 3.0)\n- Untuk 10 <= x < 20: y = (cos(x + 7.5))^2\n- Untuk 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n\tNot define\n*/\nconst char* f_3(int x)", "ja": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n指定された入力に対して関数の値を計算します。\n    パラメータ:\n- x (int): 関数の入力値。\n    戻り値:\n- double または string: x が定義域にない場合は \"Not define\" を返します。\nそれ以外の場合は、計算された関数の値を小数点以下5桁に丸めて返します。\n\n    関数定義:\n- 0 <= x < 10 の場合: y = cos(x + 3.0)\n- 10 <= x < 20 の場合: y = (cos(x + 7.5))^2\n- 20 <= x < 30 の場合: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n\tNot define\n*/\nconst char* f_3(int x)\n", "ko": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n주어진 입력에 대한 함수의 값을 계산합니다.\n    매개변수:\n- x (int): 함수의 입력 값.\n    반환:\n- double 또는 string: x가 정의된 도메인에 없으면 \"Not define\"을 반환합니다.\n그렇지 않으면, 계산된 함수 값을 소수점 5자리로 반올림하여 반환합니다.\n\n    함수 정의:\n- 0 <= x < 10: y = cos(x + 3.0)\n- 10 <= x < 20: y = (cos(x + 7.5))^2\n- 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n\tNot define\n*/\nconst char* f_3(int x)", "ml": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nഒരു നൽകിയ ഇൻപുട്ടിനായി ഫംഗ്ഷന്റെ മൂല്യം കണക്കാക്കുക.\n    പാരാമീറ്ററുകൾ:\n- x (int): ഫംഗ്ഷന്റെ ഇൻപുട്ട് മൂല്യം.\n    റിട്ടേൺസ്:\n- double അല്ലെങ്കിൽ string: x നിർവ്വചിച്ചിരിക്കുന്ന ഡൊമെയ്‌നിൽ ഇല്ലെങ്കിൽ, \"Not define\" റിട്ടേൺ ചെയ്യുന്നു.\nഅല്ലെങ്കിൽ, 5 ഡെസിമൽ സ്ഥാനങ്ങളിൽ വട്ടമിട്ട കണക്കാക്കിയ ഫംഗ്ഷൻ മൂല്യം റിട്ടേൺ ചെയ്യുന്നു.\n\n    ഫംഗ്ഷൻ നിർവ്വചനങ്ങൾ:\n- 0 <= x < 10: y = cos(x + 3.0)\n- 10 <= x < 20: y = (cos(x + 7.5))^2\n- 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n\tNot define\n*/\nconst char* f_3(int x)", "fa": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nمحاسبه مقدار تابع برای یک ورودی داده شده.\n    پارامترها:\n- x (int): مقدار ورودی برای تابع.\n    بازگشت:\n- double یا string: اگر x در دامنه تعریف شده نباشد، \"Not define\" را برمی‌گرداند.\nدر غیر این صورت، مقدار محاسبه شده تابع را با گرد کردن به 5 رقم اعشار برمی‌گرداند.\n\n    تعریف توابع:\n- برای 0 <= x < 10: y = cos(x + 3.0)\n- برای 10 <= x < 20: y = (cos(x + 7.5))^2\n- برای 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n\tNot define\n*/\nconst char* f_3(int x)"}, "canonical_solution": "{\n    static char output[50]; // Buffer to hold the output string.\n    \n    if (0 <= x && x < 10) {\n        sprintf(output, \"%.5lf\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return output;\n}", "instruction": {"en": "const char* f_3(int x)\n{\n    static char output[50]; // Buffer to hold the output string.\n    \n    if (0 <= x && x < 10) {\n        sprintf(output, \"%.5lf\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return output;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "sq": "const char* f_3(int x)\n{\n    static char output[50]; // Buffer to hold the output string.\n    \n    if (0 <= x && x < 10) {\n        sprintf(output, \"%.5lf\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return output;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C në shqip duke përdorur maksimumi 500 karaktere.", "hy": "const char* f_3(int x)\n{\n    static char output[50]; // Buffer to hold the output string.\n    \n    if (0 <= x && x < 10) {\n        sprintf(output, \"%.5lf\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return output;\n}\n\nՏվեք C կոդի համառոտ բնութագրումը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "const char* f_3(int x)\n{\n    static char output[50]; // Buffer to hold the output string.\n    \n    if (0 <= x && x < 10) {\n        sprintf(output, \"%.5lf\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return output;\n}\n\nসি কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।", "bg": "const char* f_3(int x)\n{\n    static char output[50]; // Buffer to hold the output string.\n    \n    if (0 <= x && x < 10) {\n        sprintf(output, \"%.5lf\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return output;\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, използвайки най-много 500 знака.", "zh": "const char* f_3(int x)\n{\n    static char output[50]; // Buffer to hold the output string.\n    \n    if (0 <= x && x < 10) {\n        sprintf(output, \"%.5lf\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return output;\n}\n\n请用中文为以下C代码提供简洁的自然语言描述（文档字符串），字数不超过500个字符。", "fr": "const char* f_3(int x)\n{\n    static char output[50]; // Buffer to hold the output string.\n    \n    if (0 <= x && x < 10) {\n        sprintf(output, \"%.5lf\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return output;\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.", "de": "const char* f_3(int x)\n{\n    static char output[50]; // Buffer to hold the output string.\n    \n    if (0 <= x && x < 10) {\n        sprintf(output, \"%.5lf\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return output;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "const char* f_3(int x)\n{\n    static char output[50]; // Buffer to hold the output string.\n    \n    if (0 <= x && x < 10) {\n        sprintf(output, \"%.5lf\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return output;\n}\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar C cikin Hausa ta amfani da haruffa 500 ko kasa da haka.", "hi": "const char* f_3(int x)\n{\n    static char output[50]; // Buffer to hold the output string.\n    \n    if (0 <= x && x < 10) {\n        sprintf(output, \"%.5lf\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return output;\n}\n\nC कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "const char* f_3(int x)\n{\n    static char output[50]; // Buffer to hold the output string.\n    \n    if (0 <= x && x < 10) {\n        sprintf(output, \"%.5lf\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return output;\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben.", "es": "const char* f_3(int x)\n{\n    static char output[50]; // Buffer to hold the output string.\n    \n    if (0 <= x && x < 10) {\n        sprintf(output, \"%.5lf\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return output;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando un máximo de 500 caracteres.", "arb": "const char* f_3(int x)\n{\n    static char output[50]; // Buffer to hold the output string.\n    \n    if (0 <= x && x < 10) {\n        sprintf(output, \"%.5lf\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return output;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية المكتوبة بلغة C باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "const char* f_3(int x)\n{\n    static char output[50]; // Buffer to hold the output string.\n    \n    if (0 <= x && x < 10) {\n        sprintf(output, \"%.5lf\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return output;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "const char* f_3(int x)\n{\n    static char output[50]; // Buffer to hold the output string.\n    \n    if (0 <= x && x < 10) {\n        sprintf(output, \"%.5lf\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return output;\n}\n\nC kodunun işlevini açıklayan kısa bir doğal dil tanımı (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe olarak yazılmalıdır.", "vi": "const char* f_3(int x)\n{\n    static char output[50]; // Buffer to hold the output string.\n    \n    if (0 <= x && x < 10) {\n        sprintf(output, \"%.5lf\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return output;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã C bằng tiếng Việt, sử dụng tối đa 500 ký tự.", "id": "const char* f_3(int x)\n{\n    static char output[50]; // Buffer to hold the output string.\n    \n    if (0 <= x && x < 10) {\n        sprintf(output, \"%.5lf\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return output;\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode C dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "const char* f_3(int x)\n{\n    static char output[50]; // Buffer to hold the output string.\n    \n    if (0 <= x && x < 10) {\n        sprintf(output, \"%.5lf\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return output;\n}\n\nC コードの簡単な自然言語による説明 (docstring) を英語で最大 500 文字まで入力してください。", "ko": "const char* f_3(int x)\n{\n    static char output[50]; // Buffer to hold the output string.\n    \n    if (0 <= x && x < 10) {\n        sprintf(output, \"%.5lf\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return output;\n}\n\nC 코드의 기능을 설명하는 간결한 자연어 설명(docstring)을 한국어로 작성하되, 최대 500자 이내로 작성하세요.", "ml": "const char* f_3(int x)\n{\n    static char output[50]; // Buffer to hold the output string.\n    \n    if (0 <= x && x < 10) {\n        sprintf(output, \"%.5lf\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return output;\n}\n\nസീ കോഡിന് 500 അക്ഷരങ്ങൾക്കുള്ളിൽ മലയാളത്തിൽ സംക്ഷിപ്തമായ സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) നൽകുക.", "fa": "const char* f_3(int x)\n{\n    static char output[50]; // Buffer to hold the output string.\n    \n    if (0 <= x && x < 10) {\n        sprintf(output, \"%.5lf\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return output;\n}\n\nیک توضیح مختصر به زبان طبیعی (docstring) از کد C به زبان فارسی ارائه دهید که حداکثر ۵۰۰ کاراکتر باشد."}, "level": "", "test": "int main() {\n    const char* result = f_3(40);\n    assert(strcmp(result, \"Not define\") == 0);\n    \n    // Additional test cases based on provided function definitions\n    assert(strcmp(f_3(40), \"Not define\") == 0);\n    assert(strcmp(f_3(5), \"-0.14550\") == 0);\n    assert(strcmp(f_3(15), \"0.76266\") == 0);\n    assert(strcmp(f_3(25), \"0.31314\") == 0);\n    assert(strcmp(f_3(-1), \"Not define\") == 0);\n    return 0;\n}", "entry_point": "f_3", "signature": "const char* f_3(int x)", "docstring": {"en": "Calculate the value of the function for a given input.\n    Parameters:\n- x (int): Input value for the function.\n    Returns:\n- double or string: If x is not in the defined domain, returns \"Not define\".\nOtherwise, returns the calculated function value rounded to 5 decimal places.\n\n    Function Definitions:\n- For 0 <= x < 10: y = cos(x + 3.0)\n- For 10 <= x < 20: y = (cos(x + 7.5))^2\n- For 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n    Not define\n", "sq": "Llogarit vlerën e funksionit për një hyrje të dhënë.\n    Parametrat:\n- x (int): Vlera e hyrjes për funksionin.\n    Kthen:\n- double ose string: Nëse x nuk është në domenin e përcaktuar, kthen \"Not define\".\nPërndryshe, kthen vlerën e llogaritur të funksionit të rrumbullakosur në 5 shifra dhjetore.\n\n    Përkufizimet e Funksionit:\n- Për 0 <= x < 10: y = cos(x + 3.0)\n- Për 10 <= x < 20: y = (cos(x + 7.5))^2\n- Për 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n    Not define", "hy": "Հաշվարկել ֆունկցիայի արժեքը տրված մուտքագրման համար։\n    Պարամետրեր:\n- x (int): Մուտքագրման արժեք ֆունկցիայի համար։\n    Վերադարձնում է:\n- double կամ string: Եթե x-ը սահմանված տիրույթում չէ, վերադարձնում է \"Not define\"։\nՀակառակ դեպքում, վերադարձնում է հաշվարկված ֆունկցիայի արժեքը կլորացված մինչև 5 տասնորդական թվանշան։\n\n    Ֆունկցիայի սահմանումներ:\n- 0 <= x < 10: y = cos(x + 3.0)\n- 10 <= x < 20: y = (cos(x + 7.5))^2\n- 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n    Not define", "bn": "প্রদত্ত ইনপুটের জন্য ফাংশনের মান গণনা করুন।\n    প্যারামিটারসমূহ:\n- x (int): ফাংশনের জন্য ইনপুট মান।\n    রিটার্নস:\n- double বা string: যদি x সংজ্ঞায়িত ডোমেইনে না থাকে, তাহলে \"Not define\" রিটার্ন করে।\nঅন্যথায়, গণনা করা ফাংশনের মান 5 দশমিক স্থান পর্যন্ত রাউন্ড করে রিটার্ন করে।\n\n    ফাংশন সংজ্ঞাসমূহ:\n- 0 <= x < 10 এর জন্য: y = cos(x + 3.0)\n- 10 <= x < 20 এর জন্য: y = (cos(x + 7.5))^2\n- 20 <= x < 30 এর জন্য: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n    Not define", "bg": "Изчислява стойността на функцията за даден вход.\n    Параметри:\n- x (int): Входна стойност за функцията.\n    Връща:\n- double или string: Ако x не е в определения домейн, връща \"Not define\".\nВ противен случай, връща изчислената стойност на функцията, закръглена до 5 десетични знака.\n\n    Определения на функцията:\n- За 0 <= x < 10: y = cos(x + 3.0)\n- За 10 <= x < 20: y = (cos(x + 7.5))^2\n- За 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n    Not define", "zh": "计算给定输入的函数值。\n    参数:\n- x (int): 函数的输入值。\n    返回:\n- double 或 string: 如果 x 不在定义域内，返回 \"Not define\"。\n否则，返回计算后的函数值，保留小数点后5位。\n\n    函数定义:\n- 对于 0 <= x < 10: y = cos(x + 3.0)\n- 对于 10 <= x < 20: y = (cos(x + 7.5))^2\n- 对于 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n    Not define", "fr": "Calculer la valeur de la fonction pour une entrée donnée.\n    Paramètres:\n- x (int): Valeur d'entrée pour la fonction.\n    Renvoie:\n- double ou string: Si x n'est pas dans le domaine défini, renvoie \"Not define\".\nSinon, renvoie la valeur calculée de la fonction arrondie à 5 décimales.\n\n    Définitions de la fonction:\n- Pour 0 <= x < 10: y = cos(x + 3.0)\n- Pour 10 <= x < 20: y = (cos(x + 7.5))^2\n- Pour 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n    Not define", "de": "Berechne den Wert der Funktion für eine gegebene Eingabe.\n    Parameter:\n- x (int): Eingabewert für die Funktion.\n    Rückgabewerte:\n- double oder string: Wenn x nicht im definierten Bereich liegt, wird \"Nicht definiert\" zurückgegeben.\nAndernfalls wird der berechnete Funktionswert auf 5 Dezimalstellen gerundet zurückgegeben.\n\n    Funktionsdefinitionen:\n- Für 0 <= x < 10: y = cos(x + 3.0)\n- Für 10 <= x < 20: y = (cos(x + 7.5))^2\n- Für 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n    Nicht definiert", "ha": "Ƙididdige ƙimar aikin don wani shigarwa da aka bayar.\n    Sigogi:\n- x (int): Ƙimar shigarwa don aikin.\n\n    Returns:\n- double or string: Idan x ba ya cikin yankin da aka ayyana, yana dawowa \"Not define\".\nIn ba haka ba, yana dawowa da ƙimar aikin da aka ƙididdige tare da zagaye zuwa wurare 5 na decimal.\n\n    Function Definitions:\n- Don 0 <= x < 10: y = cos(x + 3.0)\n- Don 10 <= x < 20: y = (cos(x + 7.5))^2\n- Don 20 <= x < 30: y = (cos(x + 4.0))^4\n\n    >>> f_3(40)\n    Not define", "hi": "दिए गए इनपुट के लिए फ़ंक्शन का मान गणना करें।\n    पैरामीटर्स:\n- x (int): फ़ंक्शन के लिए इनपुट मान।\n    रिटर्न्स:\n- double या string: यदि x परिभाषित डोमेन में नहीं है, तो \"Not define\" लौटाता है।\nअन्यथा, गणना किए गए फ़ंक्शन मान को 5 दशमलव स्थानों तक राउंड करके लौटाता है।\n\n    फ़ंक्शन परिभाषाएँ:\n- 0 <= x < 10 के लिए: y = cos(x + 3.0)\n- 10 <= x < 20 के लिए: y = (cos(x + 7.5))^2\n- 20 <= x < 30 के लिए: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n    Not define", "hu": "Számítsa ki a függvény értékét egy adott bemenethez.\n    Paraméterek:\n- x (int): A függvény bemeneti értéke.\n    Visszatérési értékek:\n- double vagy string: Ha x nincs a meghatározott tartományban, \"Not define\" értéket ad vissza.\nEgyébként visszaadja a kiszámított függvényértéket, 5 tizedesjegyre kerekítve.\n\n    Függvénydefiníciók:\n- Ha 0 <= x < 10: y = cos(x + 3.0)\n- Ha 10 <= x < 20: y = (cos(x + 7.5))^2\n- Ha 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n    Not define", "es": "Calcular el valor de la función para una entrada dada.\n    Parámetros:\n- x (int): Valor de entrada para la función.\n    Retorna:\n- double o string: Si x no está en el dominio definido, retorna \"Not define\".\nDe lo contrario, retorna el valor calculado de la función redondeado a 5 decimales.\n\n    Definiciones de Función:\n- Para 0 <= x < 10: y = cos(x + 3.0)\n- Para 10 <= x < 20: y = (cos(x + 7.5))^2\n- Para 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n    Not define", "arb": "احسب قيمة الدالة لمدخل معين.\n    المعلمات:\n- x (int): قيمة المدخل للدالة.\n    يعيد:\n- double أو string: إذا لم يكن x في النطاق المحدد، يعيد \"غير معرف\".\nوإلا، يعيد قيمة الدالة المحسوبة مقربة إلى 5 منازل عشرية.\n\n    تعريفات الدوال:\n- لـ 0 <= x < 10: y = cos(x + 3.0)\n- لـ 10 <= x < 20: y = (cos(x + 7.5))^2\n- لـ 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n    Not define", "sw": "Hesabu thamani ya kazi kwa pembejeo iliyotolewa.\n    Vigezo:\n- x (int): Thamani ya pembejeo kwa kazi.\n    Inarejesha:\n- double au string: Ikiwa x haipo katika kikoa kilichobainishwa, inarejesha \"Not define\".\nVinginevyo, inarejesha thamani ya kazi iliyohesabiwa iliyopunguzwa hadi sehemu 5 za desimali.\n\n    Ufafanuzi wa Kazi:\n- Kwa 0 <= x < 10: y = cos(x + 3.0)\n- Kwa 10 <= x < 20: y = (cos(x + 7.5))^2\n- Kwa 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n    Not define", "tr": "Fonksiyonun değerini verilen bir girdi için hesaplayın.\n    Parametreler:\n- x (int): Fonksiyon için giriş değeri.\n    Döndürülenler:\n- double veya string: Eğer x tanımlı alanda değilse, \"Not define\" döndürür.\nAksi takdirde, hesaplanan fonksiyon değerini 5 ondalık basamağa yuvarlanmış olarak döndürür.\n\n    Fonksiyon Tanımları:\n- 0 <= x < 10 için: y = cos(x + 3.0)\n- 10 <= x < 20 için: y = (cos(x + 7.5))^2\n- 20 <= x < 30 için: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n    Not define", "vi": "Tính giá trị của hàm cho một đầu vào nhất định.\n    Tham số:\n- x (int): Giá trị đầu vào cho hàm.\n    Trả về:\n- double hoặc string: Nếu x không nằm trong miền xác định, trả về \"Not define\".\nNgược lại, trả về giá trị hàm đã tính toán được làm tròn đến 5 chữ số thập phân.\n\n    Định nghĩa hàm:\n- Đối với 0 <= x < 10: y = cos(x + 3.0)\n- Đối với 10 <= x < 20: y = (cos(x + 7.5))^2\n- Đối với 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n    Not define", "id": "Hitung nilai fungsi untuk input yang diberikan.\n    Parameter:\n- x (int): Nilai input untuk fungsi.\n    Mengembalikan:\n- double atau string: Jika x tidak dalam domain yang ditentukan, mengembalikan \"Not define\".\nJika tidak, mengembalikan nilai fungsi yang dihitung dibulatkan ke 5 tempat desimal.\n\n    Definisi Fungsi:\n- Untuk 0 <= x < 10: y = cos(x + 3.0)\n- Untuk 10 <= x < 20: y = (cos(x + 7.5))^2\n- Untuk 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n    Not define", "ja": "与えられた入力に対して関数の値を計算します。\n    パラメータ:\n- x (int): 関数の入力値。\n    戻り値:\n- double または string: x が定義された範囲にない場合、\"Not define\" を返します。\nそれ以外の場合は、計算された関数の値を小数点以下5桁に丸めて返します。\n\n    関数定義:\n- 0 <= x < 10 の場合: y = cos(x + 3.0)\n- 10 <= x < 20 の場合: y = (cos(x + 7.5))^2\n- 20 <= x < 30 の場合: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n    Not define", "ko": "주어진 입력에 대한 함수의 값을 계산합니다.\n    매개변수:\n- x (int): 함수의 입력 값.\n    반환값:\n- double 또는 string: x가 정의된 도메인에 없으면 \"Not define\"을 반환합니다.\n그렇지 않으면, 계산된 함수 값을 소수점 5자리로 반올림하여 반환합니다.\n\n    함수 정의:\n- 0 <= x < 10: y = cos(x + 3.0)\n- 10 <= x < 20: y = (cos(x + 7.5))^2\n- 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n    Not define", "ml": "ഒരു നൽകിയ ഇൻപുട്ടിനായി ഫംഗ്ഷന്റെ മൂല്യം കണക്കാക്കുക.\n    Parameters:\n- x (int): ഫംഗ്ഷനുള്ള ഇൻപുട്ട് മൂല്യം.\n    Returns:\n- double or string: x നിർവചിച്ചിരിക്കുന്ന ഡൊമൈനിൽ ഇല്ലെങ്കിൽ, \"Not define\" തിരികെ നൽകും.\nഅല്ലെങ്കിൽ, 5 ഡെസിമൽ സ്ഥാനങ്ങളിൽ വട്ടമിട്ട കണക്കാക്കിയ ഫംഗ്ഷൻ മൂല്യം തിരികെ നൽകും.\n\n    Function Definitions:\n- 0 <= x < 10: y = cos(x + 3.0)\n- 10 <= x < 20: y = (cos(x + 7.5))^2\n- 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n    Not define", "fa": "محاسبه مقدار تابع برای یک ورودی مشخص.\n    پارامترها:\n- x (int): مقدار ورودی برای تابع.\n    بازگشتی:\n- double یا string: اگر x در دامنه تعریف شده نباشد، \"Not define\" را برمی‌گرداند.\nدر غیر این صورت، مقدار محاسبه شده تابع را با گرد کردن به 5 رقم اعشار برمی‌گرداند.\n\n    تعریف توابع:\n- برای 0 <= x < 10: y = cos(x + 3.0)\n- برای 10 <= x < 20: y = (cos(x + 7.5))^2\n- برای 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n    Not define"}}
{"task_id": "C/4", "prompt": {"en": "#include <assert.h>\n#include <stdio.h>\n/*\nFind the maximum and minimum of three distinct integers.\nParameters:\na (int): The first integer.\nb (int): The second integer.\nc (int): The third integer.\n\nReturns:\nTuple[int, int]: A tuple is not a concept in C; instead, we will return by reference.\n\n>>> Example call: \nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid f_4(int a, int b, int c, int *max, int *min)", "sq": "#include <assert.h>\n#include <stdio.h>\n/*\nGjeni maksimumin dhe minimumin e tre numrave të plotë të dallueshëm.\nParametrat:\na (int): Numri i parë i plotë.\nb (int): Numri i dytë i plotë.\nc (int): Numri i tretë i plotë.\n\nKthen:\nTuple[int, int]: Një tuple nuk është një koncept në C; në vend të kësaj, ne do të kthejmë me referencë.\n\n>>> Thirrja e shembullit: \nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid f_4(int a, int b, int c, int *max, int *min)", "hy": "#include <assert.h>\n#include <stdio.h>\n/*\nԳտնել երեք տարբեր ամբողջ թվերի առավելագույնն ու նվազագույնը։\nՊարամետրեր՝\na (int): Առաջին ամբողջ թիվը։\nb (int): Երկրորդ ամբողջ թիվը։\nc (int): Երրորդ ամբողջ թիվը։\n\nՎերադարձնում է՝\nTuple[int, int]: Tuple-ը հասկացություն չէ C-ում; փոխարենը, մենք կվերադարձնենք հղումով։\n\n>>> Օրինակ զանգ՝ \nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid f_4(int a, int b, int c, int *max, int *min)", "bn": "#include <assert.h>\n#include <stdio.h>\n/*\nতিনটি পৃথক পূর্ণসংখ্যার সর্বাধিক এবং সর্বনিম্ন খুঁজুন।\nপ্যারামিটার:\na (int): প্রথম পূর্ণসংখ্যা।\nb (int): দ্বিতীয় পূর্ণসংখ্যা।\nc (int): তৃতীয় পূর্ণসংখ্যা।\n\nফেরত:\nTuple[int, int]: C তে একটি টিউপল ধারণা নয়; পরিবর্তে, আমরা রেফারেন্স দ্বারা ফেরত দেব।\n\n>>> উদাহরণ কল:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid f_4(int a, int b, int c, int *max, int *min)", "bg": "#include <assert.h>\n#include <stdio.h>\n/*\nНамерете максимума и минимума на три различни цели числа.\nПараметри:\na (int): Първото цяло число.\nb (int): Второто цяло число.\nc (int): Третото цяло число.\n\nВръща:\nTuple[int, int]: Кортеж не е концепция в C; вместо това ще върнем чрез препратка.\n\n>>> Примерно извикване: \nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid f_4(int a, int b, int c, int *max, int *min)", "zh": "#include <assert.h>\n#include <stdio.h>\n/*\n找到三个不同整数中的最大值和最小值。\n参数：\na (int): 第一个整数。\nb (int): 第二个整数。\nc (int): 第三个整数。\n\n返回：\nTuple[int, int]: 在C中没有元组的概念，我们将通过引用返回。\n\n>>> 示例调用: \nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid f_4(int a, int b, int c, int *max, int *min)", "fr": "#include <assert.h>\n#include <stdio.h>\n/*\nTrouver le maximum et le minimum de trois entiers distincts.\nParamètres :\na (int) : Le premier entier.\nb (int) : Le deuxième entier.\nc (int) : Le troisième entier.\n\nRenvoie :\nTuple[int, int] : Un tuple n'est pas un concept en C ; à la place, nous allons retourner par référence.\n\n>>> Exemple d'appel : \nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid f_4(int a, int b, int c, int *max, int *min)", "de": "#include <assert.h>\n#include <stdio.h>\n/*\nFinde das Maximum und Minimum von drei verschiedenen ganzen Zahlen.\nParameter:\na (int): Die erste ganze Zahl.\nb (int): Die zweite ganze Zahl.\nc (int): Die dritte ganze Zahl.\n\nRückgabewert:\nTuple[int, int]: Ein Tupel ist kein Konzept in C; stattdessen werden wir per Referenz zurückgeben.\n\n>>> Beispielaufruf: \nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid f_4(int a, int b, int c, int *max, int *min)", "ha": "#include <assert.h>\n#include <stdio.h>\n/*\nNemo mafi girma da mafi ƙanƙanta daga cikin lambobi guda uku masu bambanta.\nSigogi:\na (int): Lamba ta farko.\nb (int): Lamba ta biyu.\nc (int): Lamba ta uku.\n\nDawowa:\nTuple[int, int]: Ba a da ma'anar tuple a cikin C; maimakon haka, za mu dawo ta hanyar tunani.\n\n>>> Misalin kira: \nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid f_4(int a, int b, int c, int *max, int *min)", "hi": "#include <assert.h>\n#include <stdio.h>\n/*\nतीन भिन्न पूर्णांकों का अधिकतम और न्यूनतम मान खोजें।\nपैरामीटर्स:\na (int): पहला पूर्णांक।\nb (int): दूसरा पूर्णांक।\nc (int): तीसरा पूर्णांक।\n\nवापसी मान:\nTuple[int, int]: C में एक टपल की अवधारणा नहीं है; इसके बजाय, हम संदर्भ द्वारा वापसी करेंगे।\n\n>>> उदाहरण कॉल:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid f_4(int a, int b, int c, int *max, int *min)", "hu": "#include <assert.h>\n#include <stdio.h>\n/*\nKeresse meg három különböző egész szám maximumát és minimumát.\nParaméterek:\na (int): Az első egész szám.\nb (int): A második egész szám.\nc (int): A harmadik egész szám.\n\nVisszatérési érték:\nTuple[int, int]: A tuple nem egy fogalom a C nyelvben; ehelyett referencia útján térünk vissza.\n\n>>> Példa hívás:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid f_4(int a, int b, int c, int *max, int *min)", "es": "#include <assert.h>\n#include <stdio.h>\n/*\nEncuentra el máximo y mínimo de tres enteros distintos.\nParámetros:\na (int): El primer entero.\nb (int): El segundo entero.\nc (int): El tercer entero.\n\nDevuelve:\nTuple[int, int]: Una tupla no es un concepto en C; en su lugar, devolveremos por referencia.\n\n>>> Llamada de ejemplo: \nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid f_4(int a, int b, int c, int *max, int *min)", "arb": "#include <assert.h>\n#include <stdio.h>\n/*\nالعثور على الحد الأقصى والحد الأدنى من ثلاثة أعداد صحيحة مميزة.\nالمعلمات:\na (int): العدد الصحيح الأول.\nb (int): العدد الصحيح الثاني.\nc (int): العدد الصحيح الثالث.\n\nالإرجاع:\nTuple[int, int]: الزوج ليس مفهومًا في C؛ بدلاً من ذلك، سنقوم بالإرجاع عن طريق المرجع.\n\n>>> مثال على الاستدعاء: \nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid f_4(int a, int b, int c, int *max, int *min)", "sw": "#include <assert.h>\n#include <stdio.h>\n/*\nPata ya juu na ya chini ya nambari tatu tofauti za mzima.\nVigezo:\na (int): Nambari ya kwanza ya mzima.\nb (int): Nambari ya pili ya mzima.\nc (int): Nambari ya tatu ya mzima.\n\nInarejesha:\nTuple[int, int]: Tuple si dhana katika C; badala yake, tutarejesha kwa marejeleo.\n\n>>> Mfano wa kuita: \nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid f_4(int a, int b, int c, int *max, int *min)", "tr": "#include <assert.h>\n#include <stdio.h>\n/*\nÜç farklı tam sayının maksimum ve minimumunu bulun.\nParametreler:\na (int): Birinci tam sayı.\nb (int): İkinci tam sayı.\nc (int): Üçüncü tam sayı.\n\nDöndürür:\nTuple[int, int]: C'de bir tuple kavramı yoktur; bunun yerine referansla döndüreceğiz.\n\n>>> Örnek çağrı: \nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid f_4(int a, int b, int c, int *max, int *min)", "vi": "#include <assert.h>\n#include <stdio.h>\n/*\nTìm giá trị lớn nhất và nhỏ nhất của ba số nguyên khác nhau.\nTham số:\na (int): Số nguyên thứ nhất.\nb (int): Số nguyên thứ hai.\nc (int): Số nguyên thứ ba.\n\nTrả về:\nTuple[int, int]: Một tuple không phải là khái niệm trong C; thay vào đó, chúng ta sẽ trả về bằng tham chiếu.\n\n>>> Ví dụ gọi:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid f_4(int a, int b, int c, int *max, int *min)", "id": "#include <assert.h>\n#include <stdio.h>\n/*\nTemukan nilai maksimum dan minimum dari tiga bilangan bulat yang berbeda.\nParameter:\na (int): Bilangan bulat pertama.\nb (int): Bilangan bulat kedua.\nc (int): Bilangan bulat ketiga.\n\nMengembalikan:\nTuple[int, int]: Tuple bukanlah konsep dalam C; sebagai gantinya, kita akan mengembalikan melalui referensi.\n\n>>> Contoh pemanggilan: \nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid f_4(int a, int b, int c, int *max, int *min)", "ja": "#include <assert.h>\n#include <stdio.h>\n/*\n3つの異なる整数の最大値と最小値を見つけます。\nパラメータ:\na (int): 最初の整数。\nb (int): 2番目の整数。\nc (int): 3番目の整数。\n\n戻り値:\nTuple[int, int]: Cではタプルは概念として存在しないため、参照によって返します。\n\n>>> 例の呼び出し: \nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid f_4(int a, int b, int c, int *max, int *min)", "ko": "#include <assert.h>\n#include <stdio.h>\n/*\n세 개의 서로 다른 정수의 최대값과 최소값을 찾습니다.\n매개변수:\na (int): 첫 번째 정수.\nb (int): 두 번째 정수.\nc (int): 세 번째 정수.\n\n반환값:\nTuple[int, int]: 튜플은 C에서 개념이 아니므로, 참조로 반환합니다.\n\n>>> 예시 호출: \nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid f_4(int a, int b, int c, int *max, int *min)", "ml": "#include <assert.h>\n#include <stdio.h>\n/*\nമൂന്ന് വ്യത്യസ്തമായ പൂർണ്ണസംഖ്യകളുടെ പരമാവധിയും കുറഞ്ഞതും കണ്ടെത്തുക.\nപാരാമീറ്ററുകൾ:\na (int): ആദ്യത്തെ പൂർണ്ണസംഖ്യ.\nb (int): രണ്ടാം പൂർണ്ണസംഖ്യ.\nc (int): മൂന്നാമത്തെ പൂർണ്ണസംഖ്യ.\n\nമടക്കൽ:\nTuple[int, int]: C-യിൽ ട്യൂപ്പിൾ എന്ന ആശയം ഇല്ല; പകരം, നാം റഫറൻസിലൂടെ മടക്കും.\n\n>>> ഉദാഹരണ കോൾ:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid f_4(int a, int b, int c, int *max, int *min)", "fa": "#include <assert.h>\n#include <stdio.h>\n/*\nحداکثر و حداقل سه عدد صحیح متمایز را پیدا کنید.\nپارامترها:\na (int): عدد صحیح اول.\nb (int): عدد صحیح دوم.\nc (int): عدد صحیح سوم.\n\nبازگشت:\nTuple[int, int]: تاپل یک مفهوم در C نیست؛ در عوض، ما با ارجاع برمی‌گردیم.\n\n>>> مثال فراخوانی: \nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid f_4(int a, int b, int c, int *max, int *min)"}, "canonical_solution": "{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else {\n        if (b > c) {\n            *max = b;\n            *min = (a < c) ? a : c;\n        } else {\n            *max = c;\n            *min = a;\n        }\n    }\n}", "instruction": {"en": "void f_4(int a, int b, int c, int *max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else {\n        if (b > c) {\n            *max = b;\n            *min = (a < c) ? a : c;\n        } else {\n            *max = c;\n            *min = a;\n        }\n    }\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "sq": "void f_4(int a, int b, int c, int *max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else {\n        if (b > c) {\n            *max = b;\n            *min = (a < c) ? a : c;\n        } else {\n            *max = c;\n            *min = a;\n        }\n    }\n}\n\nJepni një përshkrim të shkurtër në gjuhën natyrore (docstring) të kodit C në gjuhën shqipe duke përdorur maksimumi 500 karaktere.", "hy": "void f_4(int a, int b, int c, int *max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else {\n        if (b > c) {\n            *max = b;\n            *min = (a < c) ? a : c;\n        } else {\n            *max = c;\n            *min = a;\n        }\n    }\n}\n\nՏվեք C կոդի համառոտ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "void f_4(int a, int b, int c, int *max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else {\n        if (b > c) {\n            *max = b;\n            *min = (a < c) ? a : c;\n        } else {\n            *max = c;\n            *min = a;\n        }\n    }\n}\n\nসি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।", "bg": "void f_4(int a, int b, int c, int *max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else {\n        if (b > c) {\n            *max = b;\n            *min = (a < c) ? a : c;\n        } else {\n            *max = c;\n            *min = a;\n        }\n    }\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, използвайки не повече от 500 символа.", "zh": "void f_4(int a, int b, int c, int *max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else {\n        if (b > c) {\n            *max = b;\n            *min = (a < c) ? a : c;\n        } else {\n            *max = c;\n            *min = a;\n        }\n    }\n}\n\n请用不超过500个字符的中文，为以下C代码提供简明的自然语言描述（文档字符串）。", "fr": "void f_4(int a, int b, int c, int *max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else {\n        if (b > c) {\n            *max = b;\n            *min = (a < c) ? a : c;\n        } else {\n            *max = c;\n            *min = a;\n        }\n    }\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.", "de": "void f_4(int a, int b, int c, int *max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else {\n        if (b > c) {\n            *max = b;\n            *min = (a < c) ? a : c;\n        } else {\n            *max = c;\n            *min = a;\n        }\n    }\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "void f_4(int a, int b, int c, int *max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else {\n        if (b > c) {\n            *max = b;\n            *min = (a < c) ? a : c;\n        } else {\n            *max = c;\n            *min = a;\n        }\n    }\n}\n\nBa da takaitaccen bayani a cikin harshen dabi'a (docstring) na lambar C a cikin Hausa ta amfani da haruffa 500 kacal.", "hi": "void f_4(int a, int b, int c, int *max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else {\n        if (b > c) {\n            *max = b;\n            *min = (a < c) ? a : c;\n        } else {\n            *max = c;\n            *min = a;\n        }\n    }\n}\n\nC कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "void f_4(int a, int b, int c, int *max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else {\n        if (b > c) {\n            *max = b;\n            *min = (a < c) ? a : c;\n        } else {\n            *max = c;\n            *min = a;\n        }\n    }\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakter felhasználásával.", "es": "void f_4(int a, int b, int c, int *max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else {\n        if (b > c) {\n            *max = b;\n            *min = (a < c) ? a : c;\n        } else {\n            *max = c;\n            *min = a;\n        }\n    }\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando como máximo 500 caracteres.", "arb": "void f_4(int a, int b, int c, int *max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else {\n        if (b > c) {\n            *max = b;\n            *min = (a < c) ? a : c;\n        } else {\n            *max = c;\n            *min = a;\n        }\n    }\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "void f_4(int a, int b, int c, int *max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else {\n        if (b > c) {\n            *max = b;\n            *min = (a < c) ? a : c;\n        } else {\n            *max = c;\n            *min = a;\n        }\n    }\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "void f_4(int a, int b, int c, int *max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else {\n        if (b > c) {\n            *max = b;\n            *min = (a < c) ? a : c;\n        } else {\n            *max = c;\n            *min = a;\n        }\n    }\n}\n\nC kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe olarak yazılmalıdır.", "vi": "void f_4(int a, int b, int c, int *max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else {\n        if (b > c) {\n            *max = b;\n            *min = (a < c) ? a : c;\n        } else {\n            *max = c;\n            *min = a;\n        }\n    }\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã C bằng tiếng Việt, sử dụng tối đa 500 ký tự.", "id": "void f_4(int a, int b, int c, int *max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else {\n        if (b > c) {\n            *max = b;\n            *min = (a < c) ? a : c;\n        } else {\n            *max = c;\n            *min = a;\n        }\n    }\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode C dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "void f_4(int a, int b, int c, int *max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else {\n        if (b > c) {\n            *max = b;\n            *min = (a < c) ? a : c;\n        } else {\n            *max = c;\n            *min = a;\n        }\n    }\n}\n\nCコードの内容を日本語で簡潔に説明するドキュメンテーションストリング（docstring）を500文字以内で提供してください。", "ko": "void f_4(int a, int b, int c, int *max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else {\n        if (b > c) {\n            *max = b;\n            *min = (a < c) ? a : c;\n        } else {\n            *max = c;\n            *min = a;\n        }\n    }\n}\n\nC 코드의 동작을 설명하는 간결한 자연어 설명(docstring)을 한국어로 작성하세요. 최대 500자까지 가능합니다.", "ml": "void f_4(int a, int b, int c, int *max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else {\n        if (b > c) {\n            *max = b;\n            *min = (a < c) ? a : c;\n        } else {\n            *max = c;\n            *min = a;\n        }\n    }\n}\n\nC കോഡ് ഉപയോഗിച്ച് 500 അക്ഷരങ്ങളിൽ കൂടുതൽ അല്ലാത്ത പ്രകൃതിദത്ത ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) മലയാളത്തിൽ നൽകുക.", "fa": "void f_4(int a, int b, int c, int *max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else {\n        if (b > c) {\n            *max = b;\n            *min = (a < c) ? a : c;\n        } else {\n            *max = c;\n            *min = a;\n        }\n    }\n}\n\nیک توضیح مختصر به زبان طبیعی (docstring) از کد C به زبان فارسی ارائه دهید که حداکثر ۵۰۰ کاراکتر باشد."}, "level": "", "test": "int main() {\n    int max, min;\n\n    f_4(1, 2, 3, &max, &min);\n    assert(max == 3 && min == 1);\n\n    // Additional tests\n    f_4(5, 3, 4, &max, &min);\n    assert(max == 5 && min == 3);\n\n    f_4(10, -2, 7, &max, &min);\n    assert(max == 10 && min == -2);\n\n    f_4(-1, -3, -2, &max, &min);\n    assert(max == -1 && min == -3);\n\n    return 0;\n}", "entry_point": "f_4", "signature": "void f_4(int a, int b, int c, int *max, int *min)", "docstring": {"en": "Find the maximum and minimum of three distinct integers.\nParameters:\na (int): The first integer.\nb (int): The second integer.\nc (int): The third integer.\n\nReturns:\nTuple[int, int]: A tuple is not a concept in C; instead, we will return by reference.\n\n>>> Example call: \nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "sq": "Gjeni maksimumin dhe minimumin e tre numrave të plotë të ndryshëm.\nParametrat:\na (int): Numri i parë i plotë.\nb (int): Numri i dytë i plotë.\nc (int): Numri i tretë i plotë.\n\nKthen:\nTuple[int, int]: Një tuple nuk është një koncept në C; në vend të kësaj, ne do të kthejmë me referencë.\n\n>>> Thirrja e shembullit:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "hy": "Երեք տարբեր ամբողջ թվերի առավելագույնը և նվազագույնը գտնել:\nՊարամետրեր:\na (int): Առաջին ամբողջ թիվը:\nb (int): Երկրորդ ամբողջ թիվը:\nc (int): Երրորդ ամբողջ թիվը:\n\nՎերադարձնում է:\nTuple[int, int]: Tuple-ը հասկացություն չէ C-ում; փոխարենը մենք կվերադարձնենք հղումով:\n\n>>> Օրինակ կանչ:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "bn": "তিনটি পৃথক পূর্ণসংখ্যার মধ্যে সর্বাধিক এবং সর্বনিম্ন খুঁজুন।\nপ্যারামিটারসমূহ:\na (int): প্রথম পূর্ণসংখ্যা।\nb (int): দ্বিতীয় পূর্ণসংখ্যা।\nc (int): তৃতীয় পূর্ণসংখ্যা।\n\nরিটার্নস:\nTuple[int, int]: একটি টিউপল C তে একটি ধারণা নয়; পরিবর্তে, আমরা রেফারেন্সের মাধ্যমে রিটার্ন করব।\n\n>>> উদাহরণ কল:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "bg": "Намерете максимума и минимума на три различни цели числа.\nПараметри:\na (int): Първото цяло число.\nb (int): Второто цяло число.\nc (int): Третото цяло число.\n\nВръща:\nTuple[int, int]: Кортеж не е концепция в C; вместо това ще върнем чрез референция.\n\n>>> Примерно извикване:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "zh": "找到三个不同整数的最大值和最小值。\n参数：\na (int): 第一个整数。\nb (int): 第二个整数。\nc (int): 第三个整数。\n\n返回：\nTuple[int, int]: 元组在C语言中不是一个概念，因此我们将通过引用返回。\n\n>>> 示例调用：\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "fr": "Trouver le maximum et le minimum de trois entiers distincts.  \nParamètres :  \na (int) : Le premier entier.  \nb (int) : Le deuxième entier.  \nc (int) : Le troisième entier.  \n\nRenvoie :  \nTuple[int, int] : Un tuple n'est pas un concept en C ; à la place, nous allons retourner par référence.  \n\n>>> Appel d'exemple :  \nint max, min;  \nf_4(1,2,3, &max, &min);  \nassert(max == 3 && min == 1);  ", "de": "Finde das Maximum und Minimum von drei verschiedenen ganzen Zahlen.\nParameter:\na (int): Die erste ganze Zahl.\nb (int): Die zweite ganze Zahl.\nc (int): Die dritte ganze Zahl.\n\nRückgabewert:\nTuple[int, int]: Ein Tupel ist kein Konzept in C; stattdessen werden wir durch Referenz zurückgeben.\n\n>>> Beispielaufruf:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "ha": "Find the maximum and minimum na lambobi guda uku daban-daban.\nnSigogi:\na (int): Lamba na farko.\nb (int): Lamba na biyu.\nc (int): Lamba na uku.\n\nReturns:\nTuple[int, int]: Tuple ba wani abu ne a cikin C ba; maimakon haka, za mu mayar ta hanyar nuni.\n\n>>> Misali kira:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "hi": "तीन भिन्न पूर्णांकों का अधिकतम और न्यूनतम खोजें।  \nपैरामीटर्स:  \na (int): पहला पूर्णांक।  \nb (int): दूसरा पूर्णांक।  \nc (int): तीसरा पूर्णांक।  \n\nवापसी:  \nTuple[int, int]: एक ट्यूपल C में एक अवधारणा नहीं है; इसके बजाय, हम संदर्भ द्वारा लौटाएंगे।  \n\n>>> उदाहरण कॉल:  \nint max, min;  \nf_4(1,2,3, &max, &min);  \nassert(max == 3 && min == 1);  ", "hu": "Három különböző egész szám maximumának és minimumának meghatározása.\nParaméterek:\na (int): Az első egész szám.\nb (int): A második egész szám.\nc (int): A harmadik egész szám.\n\nVisszatér:\nTuple[int, int]: A tuple nem egy fogalom a C nyelvben; ehelyett referencia szerint fogunk visszatérni.\n\n>>> Példa hívás:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "es": "Encuentra el máximo y el mínimo de tres enteros distintos.\nParámetros:\na (int): El primer entero.\nb (int): El segundo entero.\nc (int): El tercer entero.\n\nDevuelve:\nTuple[int, int]: Una tupla no es un concepto en C; en su lugar, devolveremos por referencia.\n\n>>> Llamada de ejemplo: \nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "arb": "إيجاد القيمة القصوى والدنيا لثلاثة أعداد صحيحة متميزة.\nالمعلمات:\na (int): العدد الصحيح الأول.\nb (int): العدد الصحيح الثاني.\nc (int): العدد الصحيح الثالث.\n\nالقيم المعادة:\nTuple[int, int]: الزوج ليس مفهومًا في C؛ بدلاً من ذلك، سنعيد القيم بالإشارة.\n\n>>> مثال على الاستدعاء:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "sw": "Pata kubwa na ndogo kati ya nambari tatu tofauti za mzima.\n\nVipengele:\na (int): Nambari ya kwanza ya mzima.\nb (int): Nambari ya pili ya mzima.\nc (int): Nambari ya tatu ya mzima.\n\nInarejesha:\nTuple[int, int]: Tuple si dhana katika C; badala yake, tutarejesha kwa marejeleo.\n\n>>> Mfano wa kuita:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "tr": "Üç farklı tam sayının maksimum ve minimumunu bulun.  \nParametreler:  \na (int): Birinci tam sayı.  \nb (int): İkinci tam sayı.  \nc (int): Üçüncü tam sayı.  \n\nDöndürülenler:  \nTuple[int, int]: C'de bir kavram olarak tuple yoktur; bunun yerine referansla döneceğiz.  \n\n>>> Örnek çağrı:  \nint max, min;  \nf_4(1,2,3, &max, &min);  \nassert(max == 3 && min == 1);  ", "vi": "Tìm giá trị lớn nhất và nhỏ nhất của ba số nguyên khác nhau.  \nTham số:  \na (int): Số nguyên thứ nhất.  \nb (int): Số nguyên thứ hai.  \nc (int): Số nguyên thứ ba.  \n\nTrả về:  \nTuple[int, int]: Một tuple không phải là khái niệm trong C; thay vào đó, chúng ta sẽ trả về bằng tham chiếu.  \n\n>>> Ví dụ gọi:  \nint max, min;  \nf_4(1,2,3, &max, &min);  \nassert(max == 3 && min == 1);  ", "id": "Temukan nilai maksimum dan minimum dari tiga bilangan bulat yang berbeda.  \nParameter:  \na (int): Bilangan bulat pertama.  \nb (int): Bilangan bulat kedua.  \nc (int): Bilangan bulat ketiga.  \n\nMengembalikan:  \nTuple[int, int]: Sebuah tuple bukanlah konsep dalam C; sebagai gantinya, kita akan mengembalikan melalui referensi.\n\n>>> Contoh panggilan:  \nint max, min;  \nf_4(1,2,3, &max, &min);  \nassert(max == 3 && min == 1);", "ja": "3つの異なる整数の最大値と最小値を見つけます。\nパラメータ:\na (int): 最初の整数。\nb (int): 2番目の整数。\nc (int): 3番目の整数。\n\n戻り値:\nTuple[int, int]: タプルはCの概念ではないため、参照によって返します。\n\n>>> 例の呼び出し: \nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "ko": "세 개의 서로 다른 정수의 최대값과 최소값을 찾습니다.\n매개변수:\na (int): 첫 번째 정수.\nb (int): 두 번째 정수.\nc (int): 세 번째 정수.\n\n반환:\nTuple[int, int]: 튜플은 C에서 개념이 아닙니다; 대신 참조로 반환합니다.\n\n>>> 예시 호출:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "ml": "മൂന്ന് വ്യത്യസ്തമായ പൂർണ്ണസംഖ്യകളുടെ പരമാവധിയും കുറഞ്ഞതും കണ്ടെത്തുക.\nപാരാമീറ്ററുകൾ:\na (int): ആദ്യത്തെ പൂർണ്ണസംഖ്യ.\nb (int): രണ്ടാമത്തെ പൂർണ്ണസംഖ്യ.\nc (int): മൂന്നാമത്തെ പൂർണ്ണസംഖ്യ.\n\nമടക്കുന്നു:\nTuple[int, int]: ട്യൂപ്പിൾ C-യിൽ ഒരു ആശയം അല്ല; പകരം, ഞങ്ങൾ റഫറൻസിലൂടെ മടക്കും.\n\n>>> ഉദാഹരണ കോൾ:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "fa": "حداکثر و حداقل سه عدد صحیح متمایز را پیدا کنید.\nپارامترها:\na (int): عدد صحیح اول.\nb (int): عدد صحیح دوم.\nc (int): عدد صحیح سوم.\n\nبازگشت:\nTuple[int, int]: تاپل یک مفهوم در C نیست؛ در عوض، ما با ارجاع باز خواهیم گشت.\n\n>>> مثال فراخوانی:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);"}}
{"task_id": "C/5", "prompt": {"en": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCalculate the distance between two points A (xa, ya) and B (xb, yb).\n    Parameters:\n- xa (double): x-coordinate of point A.\n- ya (double): y-coordinate of point A.\n- xb (double): x-coordinate of point B.\n- yb (double): y-coordinate of point B.\n    \n    Returns:\n    double: The distance between points A and B.\n    >>> f_5(0,0,3,4)\n    5\n*/\ndouble f_5(double xa, double ya, double xb, double yb)", "sq": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nLlogarit distancën midis dy pikave A (xa, ya) dhe B (xb, yb).\n    Parametrat:\n- xa (double): koordinata x e pikës A.\n- ya (double): koordinata y e pikës A.\n- xb (double): koordinata x e pikës B.\n- yb (double): koordinata y e pikës B.\n    \n    Kthen:\n    double: Distanca midis pikave A dhe B.\n    >>> f_5(0,0,3,4)\n    5\n*/\ndouble f_5(double xa, double ya, double xb, double yb)", "hy": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nՀաշվել հեռավորությունը երկու կետերի A (xa, ya) և B (xb, yb) միջև։\n    Պարամետրեր:\n- xa (double): A կետի x-կոորդինատը։\n- ya (double): A կետի y-կոորդինատը։\n- xb (double): B կետի x-կոորդինատը։\n- yb (double): B կետի y-կոորդինատը։\n    \n    Վերադարձնում է:\n    double: A և B կետերի միջև հեռավորությունը։\n    >>> f_5(0,0,3,4)\n    5\n*/\ndouble f_5(double xa, double ya, double xb, double yb)", "bn": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nদুটি বিন্দু A (xa, ya) এবং B (xb, yb) এর মধ্যে দূরত্ব গণনা করুন।\n    প্যারামিটার:\n- xa (double): বিন্দু A এর x-সমন্বয়।\n- ya (double): বিন্দু A এর y-সমন্বয়।\n- xb (double): বিন্দু B এর x-সমন্বয়।\n- yb (double): বিন্দু B এর y-সমন্বয়।\n    \n    রিটার্নস:\n    double: বিন্দু A এবং B এর মধ্যে দূরত্ব।\n    >>> f_5(0,0,3,4)\n    5\n*/\ndouble f_5(double xa, double ya, double xb, double yb)", "bg": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nИзчислява разстоянието между две точки A (xa, ya) и B (xb, yb).\n    Параметри:\n- xa (double): x-координата на точка A.\n- ya (double): y-координата на точка A.\n- xb (double): x-координата на точка B.\n- yb (double): y-координата на точка B.\n    \n    Връща:\n    double: Разстоянието между точките A и B.\n    >>> f_5(0,0,3,4)\n    5\n*/\ndouble f_5(double xa, double ya, double xb, double yb)", "zh": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n计算两个点 A (xa, ya) 和 B (xb, yb) 之间的距离。\n    参数:\n- xa (double): 点 A 的 x 坐标。\n- ya (double): 点 A 的 y 坐标。\n- xb (double): 点 B 的 x 坐标。\n- yb (double): 点 B 的 y 坐标。\n    \n    返回:\n    double: 点 A 和 B 之间的距离。\n    >>> f_5(0,0,3,4)\n    5\n*/\ndouble f_5(double xa, double ya, double xb, double yb)", "fr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCalcule la distance entre deux points A (xa, ya) et B (xb, yb).\n    Paramètres:\n- xa (double): coordonnée x du point A.\n- ya (double): coordonnée y du point A.\n- xb (double): coordonnée x du point B.\n- yb (double): coordonnée y du point B.\n    \n    Renvoie:\n    double: La distance entre les points A et B.\n    >>> f_5(0,0,3,4)\n    5\n*/\ndouble f_5(double xa, double ya, double xb, double yb)", "de": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nBerechnet die Entfernung zwischen zwei Punkten A (xa, ya) und B (xb, yb).\n    Parameter:\n- xa (double): x-Koordinate des Punktes A.\n- ya (double): y-Koordinate des Punktes A.\n- xb (double): x-Koordinate des Punktes B.\n- yb (double): y-Koordinate des Punktes B.\n    \n    Rückgabe:\n    double: Die Entfernung zwischen den Punkten A und B.\n    >>> f_5(0,0,3,4)\n    5\n*/\ndouble f_5(double xa, double ya, double xb, double yb)", "ha": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nƘididdige nisan tsakanin maki biyu A (xa, ya) da B (xb, yb).\n    Sigogi:\n- xa (double): x-ƙudurin maki A.\n- ya (double): y-ƙudurin maki A.\n- xb (double): x-ƙudurin maki B.\n- yb (double): y-ƙudurin maki B.\n    \n    Mayar da:\n    double: Nisan tsakanin maki A da B.\n    >>> f_5(0,0,3,4)\n    5\n*/\ndouble f_5(double xa, double ya, double xb, double yb)", "hi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nदो बिंदुओं A (xa, ya) और B (xb, yb) के बीच की दूरी की गणना करें।\n    पैरामीटर्स:\n- xa (double): बिंदु A का x-निर्देशांक।\n- ya (double): बिंदु A का y-निर्देशांक।\n- xb (double): बिंदु B का x-निर्देशांक।\n- yb (double): बिंदु B का y-निर्देशांक।\n    \n    रिटर्न करता है:\n    double: बिंदुओं A और B के बीच की दूरी।\n    >>> f_5(0,0,3,4)\n    5\n*/\ndouble f_5(double xa, double ya, double xb, double yb)", "hu": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nSzámítsa ki a távolságot két pont, A (xa, ya) és B (xb, yb) között.\n    Paraméterek:\n- xa (double): A pont x-koordinátája.\n- ya (double): A pont y-koordinátája.\n- xb (double): B pont x-koordinátája.\n- yb (double): B pont y-koordinátája.\n    \n    Visszatérési érték:\n    double: A távolság A és B pontok között.\n    >>> f_5(0,0,3,4)\n    5\n*/\ndouble f_5(double xa, double ya, double xb, double yb)", "es": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCalcular la distancia entre dos puntos A (xa, ya) y B (xb, yb).\n    Parámetros:\n- xa (double): coordenada x del punto A.\n- ya (double): coordenada y del punto A.\n- xb (double): coordenada x del punto B.\n- yb (double): coordenada y del punto B.\n    \n    Devuelve:\n    double: La distancia entre los puntos A y B.\n    >>> f_5(0,0,3,4)\n    5\n*/\ndouble f_5(double xa, double ya, double xb, double yb)", "arb": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nاحسب المسافة بين نقطتين A (xa, ya) و B (xb, yb).\n    المعلمات:\n- xa (double): الإحداثي السيني للنقطة A.\n- ya (double): الإحداثي الصادي للنقطة A.\n- xb (double): الإحداثي السيني للنقطة B.\n- yb (double): الإحداثي الصادي للنقطة B.\n    \n    يعيد:\n    double: المسافة بين النقطتين A و B.\n    >>> f_5(0,0,3,4)\n    5\n*/\ndouble f_5(double xa, double ya, double xb, double yb)", "sw": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nHesabu umbali kati ya pointi mbili A (xa, ya) na B (xb, yb).\n    Vigezo:\n- xa (double): x-kiwianishi cha pointi A.\n- ya (double): y-kiwianishi cha pointi A.\n- xb (double): x-kiwianishi cha pointi B.\n- yb (double): y-kiwianishi cha pointi B.\n    \n    Inarejesha:\n    double: Umbali kati ya pointi A na B.\n    >>> f_5(0,0,3,4)\n    5\n*/\ndouble f_5(double xa, double ya, double xb, double yb)", "tr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nİki nokta A (xa, ya) ve B (xb, yb) arasındaki mesafeyi hesapla.\n    Parametreler:\n- xa (double): A noktasının x-koordinatı.\n- ya (double): A noktasının y-koordinatı.\n- xb (double): B noktasının x-koordinatı.\n- yb (double): B noktasının y-koordinatı.\n    \n    Döndürür:\n    double: A ve B noktaları arasındaki mesafe.\n    >>> f_5(0,0,3,4)\n    5\n*/\ndouble f_5(double xa, double ya, double xb, double yb)", "vi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nTính khoảng cách giữa hai điểm A (xa, ya) và B (xb, yb).\n    Tham số:\n- xa (double): tọa độ x của điểm A.\n- ya (double): tọa độ y của điểm A.\n- xb (double): tọa độ x của điểm B.\n- yb (double): tọa độ y của điểm B.\n    \n    Trả về:\n    double: Khoảng cách giữa điểm A và B.\n    >>> f_5(0,0,3,4)\n    5\n*/\ndouble f_5(double xa, double ya, double xb, double yb)", "id": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nMenghitung jarak antara dua titik A (xa, ya) dan B (xb, yb).\n    Parameter:\n- xa (double): koordinat x dari titik A.\n- ya (double): koordinat y dari titik A.\n- xb (double): koordinat x dari titik B.\n- yb (double): koordinat y dari titik B.\n    \n    Mengembalikan:\n    double: Jarak antara titik A dan B.\n    >>> f_5(0,0,3,4)\n    5\n*/\ndouble f_5(double xa, double ya, double xb, double yb)", "ja": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n2点A (xa, ya) とB (xb, yb) の間の距離を計算します。\n    パラメータ:\n- xa (double): 点Aのx座標。\n- ya (double): 点Aのy座標。\n- xb (double): 点Bのx座標。\n- yb (double): 点Bのy座標。\n    \n    戻り値:\n    double: 点AとBの間の距離。\n    >>> f_5(0,0,3,4)\n    5\n*/\ndouble f_5(double xa, double ya, double xb, double yb)\n", "ko": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n두 점 A (xa, ya)와 B (xb, yb) 사이의 거리를 계산합니다.\n    매개변수:\n- xa (double): 점 A의 x-좌표.\n- ya (double): 점 A의 y-좌표.\n- xb (double): 점 B의 x-좌표.\n- yb (double): 점 B의 y-좌표.\n    \n    반환값:\n    double: 점 A와 B 사이의 거리.\n    >>> f_5(0,0,3,4)\n    5\n*/\ndouble f_5(double xa, double ya, double xb, double yb)", "ml": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nരണ്ടു ബിന്ദുക്കൾ A (xa, ya) and B (xb, yb) തമ്മിലുള്ള ദൂരം കണക്കാക്കുക.\n    പാരാമീറ്ററുകൾ:\n- xa (double): ബിന്ദു A യുടെ x-കോഓർഡിനേറ്റ്.\n- ya (double): ബിന്ദു A യുടെ y-കോഓർഡിനേറ്റ്.\n- xb (double): ബിന്ദു B യുടെ x-കോഓർഡിനേറ്റ്.\n- yb (double): ബിന്ദു B യുടെ y-കോഓർഡിനേറ്റ്.\n    \n    മടക്കുന്നു:\n    double: ബിന്ദുക്കൾ A and B തമ്മിലുള്ള ദൂരം.\n    >>> f_5(0,0,3,4)\n    5\n*/\ndouble f_5(double xa, double ya, double xb, double yb)", "fa": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nفاصله بین دو نقطه A (xa, ya) و B (xb, yb) را محاسبه کنید.\n    پارامترها:\n- xa (double): مختصات x نقطه A.\n- ya (double): مختصات y نقطه A.\n- xb (double): مختصات x نقطه B.\n- yb (double): مختصات y نقطه B.\n    \n    بازگشت:\n    double: فاصله بین نقاط A و B.\n    >>> f_5(0,0,3,4)\n    5\n*/\ndouble f_5(double xa, double ya, double xb, double yb)"}, "canonical_solution": "{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}", "instruction": {"en": "double f_5(double xa, double ya, double xb, double yb)\n{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "sq": "double f_5(double xa, double ya, double xb, double yb)\n{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C në shqip duke përdorur maksimumi 500 karaktere.", "hy": "double f_5(double xa, double ya, double xb, double yb)\n{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}\n\nՏվեք C կոդի հակիրճ բնութագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "double f_5(double xa, double ya, double xb, double yb)\n{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}\n\nনিচের C কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।", "bg": "double f_5(double xa, double ya, double xb, double yb)\n{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}\n\nПредоставете кратко описание на C кода на естествен език (документация) на български, като използвате не повече от 500 знака.", "zh": "double f_5(double xa, double ya, double xb, double yb)\n{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}\n\n请用不超过500个字符的中文，为以下C代码提供简明的自然语言描述（文档字符串）。", "fr": "double f_5(double xa, double ya, double xb, double yb)\n{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.", "de": "double f_5(double xa, double ya, double xb, double yb)\n{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "double f_5(double xa, double ya, double xb, double yb)\n{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}\n\nBa da takaitaccen bayani a cikin yare na halitta (docstring) na lambar C cikin harshen Hausa ta amfani da haruffa 500 kacal.", "hi": "double f_5(double xa, double ya, double xb, double yb)\n{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}\n\nC कोड के लिए संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "double f_5(double xa, double ya, double xb, double yb)\n{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben.", "es": "double f_5(double xa, double ya, double xb, double yb)\n{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando como máximo 500 caracteres.", "arb": "double f_5(double xa, double ya, double xb, double yb)\n{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "double f_5(double xa, double ya, double xb, double yb)\n{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "double f_5(double xa, double ya, double xb, double yb)\n{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}\n\nC kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, Türkçe dilinde ve en fazla 500 karakter olmalıdır.", "vi": "double f_5(double xa, double ya, double xb, double yb)\n{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã C bằng tiếng Việt, sử dụng tối đa 500 ký tự.", "id": "double f_5(double xa, double ya, double xb, double yb)\n{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode C dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "double f_5(double xa, double ya, double xb, double yb)\n{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}\n\nC コードの簡単な自然言語による説明 (docstring) を英語で最大 500 文字まで入力してください。", "ko": "double f_5(double xa, double ya, double xb, double yb)\n{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}\n\nC 코드의 동작을 설명하는 간결한 자연어 설명(docstring)을 한국어로 작성하세요. 최대 500자까지 가능합니다.", "ml": "double f_5(double xa, double ya, double xb, double yb)\n{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}\n\nസിഎ കോഡിന്റെ സംക്ഷിപ്തമായ നാചുറൽ ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) പരമാവധി 500 അക്ഷരങ്ങൾ ഉപയോഗിച്ച് മലയാളത്തിൽ നൽകുക.", "fa": "double f_5(double xa, double ya, double xb, double yb)\n{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}\n\nتوضیح مختصر و طبیعی (docstring) از کد C را به زبان فارسی با حداکثر ۵۰۰ کاراکتر ارائه دهید."}, "level": "", "test": "int main() {\n    assert(fabs(f_5(0,0,3,4) - 5) < 1e-6);\n    assert(fabs(f_5(0,0,0,0) - 0) < 1e-6);\n    assert(fabs(f_5(-1,-1,2,2) - 4.242640687) < 1e-6);\n    assert(fabs(f_5(1.5,3.9,4.2,-1.1) - 5.68243) < 1e-6);\n    // printf(\"All test cases passed!\\n\");\n    return 0;\n}", "entry_point": "f_5", "signature": "double f_5(double xa, double ya, double xb, double yb)", "docstring": {"en": "Calculate the distance between two points A (xa, ya) and B (xb, yb).\n    Parameters:\n- xa (double): x-coordinate of point A.\n- ya (double): y-coordinate of point A.\n- xb (double): x-coordinate of point B.\n- yb (double): y-coordinate of point B.\n    \n    Returns:\n    double: The distance between points A and B.\n    >>> f_5(0,0,3,4)\n    5\n", "sq": "Llogarit distancën midis dy pikave A (xa, ya) dhe B (xb, yb).\n    Parametra:\n- xa (double): koordinata x e pikës A.\n- ya (double): koordinata y e pikës A.\n- xb (double): koordinata x e pikës B.\n- yb (double): koordinata y e pikës B.\n    \n    Kthen:\n    double: Distanca midis pikave A dhe B.\n    >>> f_5(0,0,3,4)\n    5", "hy": "Հաշվել հեռավորությունը երկու կետերի A (xa, ya) և B (xb, yb) միջև:\n    Պարամետրեր:\n- xa (double): A կետի x-կոորդինատը:\n- ya (double): A կետի y-կոորդինատը:\n- xb (double): B կետի x-կոորդինատը:\n- yb (double): B կետի y-կոորդինատը:\n    \n    Վերադարձնում է:\n    double: Հեռավորությունը A և B կետերի միջև:\n    >>> f_5(0,0,3,4)\n    5", "bn": "দুটি বিন্দু A (xa, ya) এবং B (xb, yb) এর মধ্যে দূরত্ব গণনা করুন।\n    প্যারামিটারসমূহ:\n- xa (double): বিন্দু A এর x-সমন্বয়।\n- ya (double): বিন্দু A এর y-সমন্বয়।\n- xb (double): বিন্দু B এর x-সমন্বয়।\n- yb (double): বিন্দু B এর y-সমন্বয়।\n    \n    রিটার্নস:\n    double: বিন্দু A এবং B এর মধ্যে দূরত্ব।\n    >>> f_5(0,0,3,4)\n    5", "bg": "Изчисляване на разстоянието между две точки A (xa, ya) и B (xb, yb).\n    Параметри:\n- xa (double): x-координата на точка A.\n- ya (double): y-координата на точка A.\n- xb (double): x-координата на точка B.\n- yb (double): y-координата на точка B.\n    \n    Връща:\n    double: Разстоянието между точките A и B.\n    >>> f_5(0,0,3,4)\n    5", "zh": "计算两点 A (xa, ya) 和 B (xb, yb) 之间的距离。\n    参数:\n- xa (double): 点 A 的 x 坐标。\n- ya (double): 点 A 的 y 坐标。\n- xb (double): 点 B 的 x 坐标。\n- yb (double): 点 B 的 y 坐标。\n    \n    返回:\n    double: 点 A 和 B 之间的距离。\n    >>> f_5(0,0,3,4)\n    5", "fr": "Calculer la distance entre deux points A (xa, ya) et B (xb, yb).\n    Paramètres:\n- xa (double): coordonnée x du point A.\n- ya (double): coordonnée y du point A.\n- xb (double): coordonnée x du point B.\n- yb (double): coordonnée y du point B.\n    \n    Retourne:\n    double: La distance entre les points A et B.\n    >>> f_5(0,0,3,4)\n    5", "de": "Berechnen Sie die Entfernung zwischen zwei Punkten A (xa, ya) und B (xb, yb).\n    Parameter:\n- xa (double): x-Koordinate des Punktes A.\n- ya (double): y-Koordinate des Punktes A.\n- xb (double): x-Koordinate des Punktes B.\n- yb (double): y-Koordinate des Punktes B.\n    \n    Rückgabewert:\n    double: Die Entfernung zwischen den Punkten A und B.\n    >>> f_5(0,0,3,4)\n    5", "ha": "Calculate the distance tsakanin maki biyu A (xa, ya) da B (xb, yb).\n    Sigogi:\n- xa (double): x-hadin gwiwa na maki A.\n- ya (double): y-hadin gwiwa na maki A.\n- xb (double): x-hadin gwiwa na maki B.\n- yb (double): y-hadin gwiwa na maki B.\n    \n    Returns:\n    double: Nisan tsakanin maki A da B.\n    >>> f_5(0,0,3,4)\n    5", "hi": "दो बिंदुओं A (xa, ya) और B (xb, yb) के बीच की दूरी की गणना करें।\n    पैरामीटर्स:\n- xa (double): बिंदु A का x-निर्देशांक।\n- ya (double): बिंदु A का y-निर्देशांक।\n- xb (double): बिंदु B का x-निर्देशांक।\n- yb (double): बिंदु B का y-निर्देशांक।\n    \n    रिटर्न:\n    double: बिंदु A और B के बीच की दूरी।\n    >>> f_5(0,0,3,4)\n    5", "hu": "Számítsa ki a távolságot két pont, A (xa, ya) és B (xb, yb) között.\n    Paraméterek:\n- xa (double): A pont x-koordinátája.\n- ya (double): A pont y-koordinátája.\n- xb (double): B pont x-koordinátája.\n- yb (double): B pont y-koordinátája.\n    \n    Visszatér:\n    double: A távolság A és B pontok között.\n    >>> f_5(0,0,3,4)\n    5", "es": "Calcular la distancia entre dos puntos A (xa, ya) y B (xb, yb).\n    Parámetros:\n- xa (double): coordenada x del punto A.\n- ya (double): coordenada y del punto A.\n- xb (double): coordenada x del punto B.\n- yb (double): coordenada y del punto B.\n    \n    Devuelve:\n    double: La distancia entre los puntos A y B.\n    >>> f_5(0,0,3,4)\n    5", "arb": "احسب المسافة بين نقطتين A (xa, ya) و B (xb, yb).\n    المعلمات:\n- xa (double): الإحداثي السيني للنقطة A.\n- ya (double): الإحداثي الصادي للنقطة A.\n- xb (double): الإحداثي السيني للنقطة B.\n- yb (double): الإحداثي الصادي للنقطة B.\n    \n    يعيد:\n    double: المسافة بين النقطتين A و B.\n    >>> f_5(0,0,3,4)\n    5", "sw": "Hesabu umbali kati ya pointi mbili A (xa, ya) na B (xb, yb). \n    Vigezo:\n- xa (double): x-kiwianishi cha pointi A.\n- ya (double): y-kiwianishi cha pointi A.\n- xb (double): x-kiwianishi cha pointi B.\n- yb (double): y-kiwianishi cha pointi B.\n    \n    Inarejesha:\n    double: Umbali kati ya pointi A na B.\n    >>> f_5(0,0,3,4)\n    5", "tr": "Calculate the distance between two points A (xa, ya) and B (xb, yb).\n    Parametreler:\n- xa (double): A noktasının x-koordinatı.\n- ya (double): A noktasının y-koordinatı.\n- xb (double): B noktasının x-koordinatı.\n- yb (double): B noktasının y-koordinatı.\n    \n    Döndürülenler:\n    double: A ve B noktaları arasındaki mesafe.\n    >>> f_5(0,0,3,4)\n    5", "vi": "Tính khoảng cách giữa hai điểm A (xa, ya) và B (xb, yb).\n    Tham số:\n- xa (double): tọa độ x của điểm A.\n- ya (double): tọa độ y của điểm A.\n- xb (double): tọa độ x của điểm B.\n- yb (double): tọa độ y của điểm B.\n    \n    Trả về:\n    double: Khoảng cách giữa điểm A và B.\n    >>> f_5(0,0,3,4)\n    5", "id": "Hitung jarak antara dua titik A (xa, ya) dan B (xb, yb).\n    Parameter:\n- xa (double): koordinat x dari titik A.\n- ya (double): koordinat y dari titik A.\n- xb (double): koordinat x dari titik B.\n- yb (double): koordinat y dari titik B.\n    \n    Mengembalikan:\n    double: Jarak antara titik A dan B.\n    >>> f_5(0,0,3,4)\n    5", "ja": "2点A (xa, ya) とB (xb, yb) の間の距離を計算します。\n    パラメータ:\n- xa (double): 点Aのx座標。\n- ya (double): 点Aのy座標。\n- xb (double): 点Bのx座標。\n- yb (double): 点Bのy座標。\n    \n    戻り値:\n    double: 点AとBの間の距離。\n    >>> f_5(0,0,3,4)\n    5", "ko": "두 점 A (xa, ya)와 B (xb, yb) 사이의 거리를 계산합니다.\n    매개변수:\n- xa (double): 점 A의 x-좌표.\n- ya (double): 점 A의 y-좌표.\n- xb (double): 점 B의 x-좌표.\n- yb (double): 점 B의 y-좌표.\n    \n    반환값:\n    double: 점 A와 B 사이의 거리.\n    >>> f_5(0,0,3,4)\n    5", "ml": "രണ്ടു ബിന്ദുക്കൾ A (xa, ya) and B (xb, yb) തമ്മിലുള്ള ദൂരം കണക്കാക്കുക.\n    പാരാമീറ്ററുകൾ:\n- xa (double): A ബിന്ദുവിന്റെ x-കോഓർഡിനേറ്റ്.\n- ya (double): A ബിന്ദുവിന്റെ y-കോഓർഡിനേറ്റ്.\n- xb (double): B ബിന്ദുവിന്റെ x-കോഓർഡിനേറ്റ്.\n- yb (double): B ബിന്ദുവിന്റെ y-കോഓർഡിനേറ്റ്.\n    \n    മടക്കങ്ങൾ:\n    double: A, B ബിന്ദുക്കളുടെ ഇടയിലെ ദൂരം.\n    >>> f_5(0,0,3,4)\n    5", "fa": "محاسبه فاصله بین دو نقطه A (xa, ya) و B (xb, yb).\n    پارامترها:\n- xa (double): مختصات x نقطه A.\n- ya (double): مختصات y نقطه A.\n- xb (double): مختصات x نقطه B.\n- yb (double): مختصات y نقطه B.\n    \n    بازگشت:\n    double: فاصله بین نقاط A و B.\n    >>> f_5(0,0,3,4)\n    5"}}
{"task_id": "C/6", "prompt": {"en": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nFind the factorial of N and take the modulo 10007 of the result.\n​    Parameters:\n- N (int): An integer representing the input value (N <= 10000).\n​    Returns:\n​    int: The result after taking the modulo 10007 of the output.\n    >>> f_6(1)\n    1\n*/\nint f_6(int n)", "sq": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nGjej faktorielin e N dhe merr modulo 10007 të rezultatit.\n​    Parametrat:\n- N (int): Një numër i plotë që përfaqëson vlerën hyrëse (N <= 10000).\n​    Kthen:\n​    int: Rezultati pas marrjes së modulo 10007 të daljes.\n    >>> f_6(1)\n    1\n*/\nint f_6(int n)", "hy": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nԳտնել N-ի ֆակտորիալը և վերցնել արդյունքի 10007 մոդուլը։\n​    Պարամետրեր:\n- N (int): Անթերի թիվ, որը ներկայացնում է մուտքային արժեքը (N <= 10000)։\n​    Վերադարձնում է:\n​    int: Արդյունքը՝ 10007 մոդուլը վերցնելուց հետո։\n    >>> f_6(1)\n    1\n*/\nint f_6(int n)", "bn": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nN এর ফ্যাক্টোরিয়াল খুঁজে বের করুন এবং ফলাফলের 10007 এর মডুলো নিন।\n    প্যারামিটার:\n- N (int): একটি পূর্ণসংখ্যা যা ইনপুট মানকে উপস্থাপন করে (N <= 10000)।\n    রিটার্নস:\n    int: আউটপুটের 10007 এর মডুলো নেওয়ার পরের ফলাফল।\n    >>> f_6(1)\n    1\n*/\nint f_6(int n)", "bg": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nНамерете факториела на N и вземете модуло 10007 от резултата.\n​    Параметри:\n- N (int): Цяло число, представляващо входната стойност (N <= 10000).\n​    Връща:\n​    int: Резултатът след вземане на модуло 10007 от изхода.\n    >>> f_6(1)\n    1\n*/\nint f_6(int n)", "zh": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n找到N的阶乘并对结果取模10007。\n    参数：\n- N (int): 表示输入值的整数 (N <= 10000)。\n    返回：\n    int: 对输出取模10007后的结果。\n    >>> f_6(1)\n    1\n*/\nint f_6(int n)", "fr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nTrouver le factoriel de N et prendre le modulo 10007 du résultat.\n    Paramètres :\n- N (int) : Un entier représentant la valeur d'entrée (N <= 10000).\n    Renvoie :\n    int : Le résultat après avoir pris le modulo 10007 de la sortie.\n    >>> f_6(1)\n    1\n*/\nint f_6(int n)", "de": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nFinde die Fakultät von N und nehme das Modulo 10007 des Ergebnisses.\n​    Parameter:\n- N (int): Eine ganze Zahl, die den Eingabewert darstellt (N <= 10000).\n​    Rückgabe:\n​    int: Das Ergebnis nach der Modulo-Operation 10007 des Outputs.\n    >>> f_6(1)\n    1\n*/\nint f_6(int n)", "ha": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nNemo factorial na N kuma ɗauki modulo 10007 na sakamakon.\n​    Sigogi:\n- N (int): Wani cikakken lamba da ke wakiltar ƙimar shigarwa (N <= 10000).\n​    Komawa:\n​    int: Sakamakon bayan ɗaukar modulo 10007 na fitarwa.\n    >>> f_6(1)\n    1\n*/\nint f_6(int n)", "hi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nN का फैक्टोरियल खोजें और परिणाम का 10007 से माड्यूलो लें।\n    पैरामीटर्स:\n- N (int): इनपुट मान का प्रतिनिधित्व करने वाला एक पूर्णांक (N <= 10000)।\n    रिटर्न्स:\n    int: आउटपुट का 10007 से माड्यूलो लेने के बाद का परिणाम।\n    >>> f_6(1)\n    1\n*/\nint f_6(int n)", "hu": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nTaláld meg N faktoriálisát, és vedd az eredmény 10007-es modulóját.\n​    Paraméterek:\n- N (int): Egy egész szám, amely az input értéket jelöli (N <= 10000).\n​    Visszatér:\n​    int: Az eredmény, miután vettük az output 10007-es modulóját.\n    >>> f_6(1)\n    1\n*/\nint f_6(int n)", "es": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nEncuentra el factorial de N y toma el módulo 10007 del resultado.\n​    Parámetros:\n- N (int): Un entero que representa el valor de entrada (N <= 10000).\n​    Retorna:\n​    int: El resultado después de tomar el módulo 10007 de la salida.\n    >>> f_6(1)\n    1\n*/\nint f_6(int n)", "arb": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nابحث عن مضروب N وخذ باقي القسمة 10007 للنتيجة.\n​    المعلمات:\n- N (int): عدد صحيح يمثل قيمة الإدخال (N <= 10000).\n​    يعيد:\n​    int: النتيجة بعد أخذ باقي القسمة 10007 من المخرجات.\n    >>> f_6(1)\n    1\n*/\nint f_6(int n)", "sw": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nTafuta faktoria ya N na chukua modulo 10007 ya matokeo.\n​    Vigezo:\n- N (int): Nambari kamili inayowakilisha thamani ya ingizo (N <= 10000).\n​    Inarejesha:\n​    int: Matokeo baada ya kuchukua modulo 10007 ya pato.\n    >>> f_6(1)\n    1\n*/\nint f_6(int n)", "tr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nN'in faktöriyelini bulun ve sonucun 10007 ile modunu alın.\n​    Parametreler:\n- N (int): Girdi değerini temsil eden bir tamsayı (N <= 10000).\n​    Döndürür:\n​    int: Çıktının 10007 ile modunu aldıktan sonra elde edilen sonuç.\n    >>> f_6(1)\n    1\n*/\nint f_6(int n)", "vi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nTìm giai thừa của N và lấy modulo 10007 của kết quả.\n​    Tham số:\n- N (int): Một số nguyên đại diện cho giá trị đầu vào (N <= 10000).\n​    Trả về:\n​    int: Kết quả sau khi lấy modulo 10007 của đầu ra.\n    >>> f_6(1)\n    1\n*/\nint f_6(int n)", "id": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nTemukan faktorial dari N dan ambil modulo 10007 dari hasilnya.\n​    Parameter:\n- N (int): Sebuah bilangan bulat yang mewakili nilai masukan (N <= 10000).\n​    Mengembalikan:\n​    int: Hasil setelah mengambil modulo 10007 dari keluaran.\n    >>> f_6(1)\n    1\n*/\nint f_6(int n)", "ja": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nNの階乗を求め、その結果を10007で割った余りを取ります。\n​    パラメータ:\n- N (int): 入力値を表す整数 (N <= 10000)。\n​    戻り値:\n​    int: 出力を10007で割った余りの結果。\n    >>> f_6(1)\n    1\n*/\nint f_6(int n)", "ko": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nN의 팩토리얼을 구하고 결과의 10007로 모듈로를 구합니다.\n​    매개변수:\n- N (int): 입력 값을 나타내는 정수 (N <= 10000).\n​    반환값:\n​    int: 출력의 10007로 모듈로를 구한 결과.\n    >>> f_6(1)\n    1\n*/\nint f_6(int n)", "ml": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nN ന്റെ ഫാക്ടോറിയൽ കണ്ടെത്തി ഫലം 10007 ന്റെ മോഡുലോ എടുക്കുക.\n    പാരാമീറ്ററുകൾ:\n- N (int): ഇൻപുട്ട് മൂല്യം പ്രതിനിധീകരിക്കുന്ന ഒരു പൂർണ്ണസംഖ്യ (N <= 10000).\n    റിട്ടേൺസ്:\n    int: ഔട്ട്പുട്ടിന്റെ മോഡുലോ 10007 എടുത്ത后的 ഫലം.\n    >>> f_6(1)\n    1\n*/\nint f_6(int n)", "fa": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nفاکتوریل N را پیدا کنید و باقیمانده تقسیم آن بر 10007 را محاسبه کنید.\n​    پارامترها:\n- N (int): یک عدد صحیح که نمایانگر مقدار ورودی است (N <= 10000).\n​    بازگشت:\n​    int: نتیجه پس از گرفتن باقیمانده تقسیم بر 10007.\n    >>> f_6(1)\n    1\n*/\nint f_6(int n)"}, "canonical_solution": "{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for(register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i-1] * i) % 10007;\n    }\n    return a[n];\n}", "instruction": {"en": "int f_6(int n)\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for(register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i-1] * i) % 10007;\n    }\n    return a[n];\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "sq": "int f_6(int n)\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for(register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i-1] * i) % 10007;\n    }\n    return a[n];\n}\n\nJepni një përshkrim të shkurtër në gjuhën natyrore (docstring) të kodit C në gjuhën shqipe duke përdorur maksimumi 500 karaktere.", "hy": "int f_6(int n)\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for(register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i-1] * i) % 10007;\n    }\n    return a[n];\n}\n\nՏվեք C կոդի հակիրճ բնութագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "int f_6(int n)\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for(register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i-1] * i) % 10007;\n    }\n    return a[n];\n}\n\nসি কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।", "bg": "int f_6(int n)\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for(register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i-1] * i) % 10007;\n    }\n    return a[n];\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, използвайки най-много 500 знака.", "zh": "int f_6(int n)\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for(register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i-1] * i) % 10007;\n    }\n    return a[n];\n}\n\n请用最多500个字符的中文对该C代码提供简洁的自然语言描述（文档字符串）。", "fr": "int f_6(int n)\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for(register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i-1] * i) % 10007;\n    }\n    return a[n];\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.", "de": "int f_6(int n)\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for(register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i-1] * i) % 10007;\n    }\n    return a[n];\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "int f_6(int n)\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for(register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i-1] * i) % 10007;\n    }\n    return a[n];\n}\n\nBa da takaitaccen bayanin yare na halitta (docstring) na lambar C cikin Hausa ta amfani da haruffa 500 kacal.", "hi": "int f_6(int n)\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for(register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i-1] * i) % 10007;\n    }\n    return a[n];\n}\n\nC कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "int f_6(int n)\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for(register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i-1] * i) % 10007;\n    }\n    return a[n];\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben.", "es": "int f_6(int n)\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for(register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i-1] * i) % 10007;\n    }\n    return a[n];\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando un máximo de 500 caracteres.", "arb": "int f_6(int n)\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for(register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i-1] * i) % 10007;\n    }\n    return a[n];\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "int f_6(int n)\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for(register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i-1] * i) % 10007;\n    }\n    return a[n];\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "int f_6(int n)\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for(register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i-1] * i) % 10007;\n    }\n    return a[n];\n}\n\nC kodunun işlevini açıklayan en fazla 500 karakterlik kısa bir doğal dil tanımı (docstring) sağlayın.", "vi": "int f_6(int n)\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for(register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i-1] * i) % 10007;\n    }\n    return a[n];\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã C bằng tiếng Việt, sử dụng tối đa 500 ký tự.", "id": "int f_6(int n)\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for(register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i-1] * i) % 10007;\n    }\n    return a[n];\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode C dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "int f_6(int n)\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for(register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i-1] * i) % 10007;\n    }\n    return a[n];\n}\n\nC コードの簡単な自然言語による説明 (docstring) を英語で最大 500 文字まで入力してください。", "ko": "int f_6(int n)\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for(register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i-1] * i) % 10007;\n    }\n    return a[n];\n}\n\nC 코드의 동작을 설명하는 간결한 자연어 설명(문서 문자열)을 한국어로 500자 이내로 제공하세요.", "ml": "int f_6(int n)\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for(register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i-1] * i) % 10007;\n    }\n    return a[n];\n}\n\nസിയുടെ കോഡിന് 500 അക്ഷരങ്ങളിൽ കവിയാത്ത പ്രകൃതിദത്ത ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) മലയാളത്തിൽ നൽകുക.", "fa": "int f_6(int n)\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for(register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i-1] * i) % 10007;\n    }\n    return a[n];\n}\n\nبرای کد C ارائه شده، یک توضیح مختصر به زبان طبیعی (docstring) به زبان فارسی با حداکثر ۵۰۰ کاراکتر بنویسید."}, "level": "", "test": "int main()\n{\n    assert(f_6(0) == 1); // Added test for boundary condition\n    assert(f_6(1) == 1);\n    assert(f_6(2) == 2);\n    assert(f_6(3) == 6);\n    assert(f_6(4) == 24);\n    assert(f_6(10) == 6266); // 10! % 10007 = 3628800 % 10007 = 362\n    assert(f_6(10000) == 6991); // Added a test for upper boundary condition\n    // printf(\"All tests passed.\\n\");\n    return 0;\n}", "entry_point": "f_6", "signature": "int f_6(int n)", "docstring": {"en": "Find the factorial of N and take the modulo 10007 of the result.\n    Parameters:\n- N (int): An integer representing the input value (N <= 10000).\n    Returns:\n    int: The result after taking the modulo 10007 of the output.\n    >>> f_6(1)\n    1\n", "sq": "Gjej faktorielin e N dhe merr modulo 10007 të rezultatit.\n    Parametrat:\n- N (int): Një numër i plotë që përfaqëson vlerën e hyrjes (N <= 10000).\n    Kthen:\n    int: Rezultati pasi të merret modulo 10007 i daljes.\n    >>> f_6(1)\n    1", "hy": "Գտնել N-ի ֆակտորիալը և վերցնել արդյունքի 10007 մոդուլը։\n    Պարամետրեր:  \n- N (int): Ընդհանուր թիվ, որը ներկայացնում է մուտքային արժեքը (N <= 10000):  \n    Վերադարձնում է:  \n    int: Արդյունքը՝ 10007-ի մոդուլո վերցնելուց հետո:  \n    >>> f_6(1)  \n    1  ", "bn": "N এর ফ্যাক্টোরিয়াল খুঁজে বের করুন এবং ফলাফলের 10007 এর মডুলো নিন।\n    প্যারামিটার:\n- N (int): একটি পূর্ণসংখ্যা যা ইনপুট মানকে উপস্থাপন করে (N <= 10000)।\n    রিটার্নস:\n    int: আউটপুটের 10007 এর মডুলো নেওয়ার পরের ফলাফল।\n    >>> f_6(1)\n    1", "bg": "Намерете факториела на N и вземете модуло 10007 от резултата.\n    Параметри:\n- N (int): Цяло число, представляващо входната стойност (N <= 10000).\n    Връща:\n    int: Резултатът след вземане на модуло 10007 от изхода.\n    >>> f_6(1)\n    1", "zh": "计算N的阶乘并对结果取模10007。\n    参数：\n- N (int): 表示输入值的整数 (N <= 10000)。\n    返回：\n    int: 对输出取模10007后的结果。\n    >>> f_6(1)\n    1", "fr": "Trouver la factorielle de N et prendre le modulo 10007 du résultat.\n    Paramètres:\n- N (int): Un entier représentant la valeur d'entrée (N <= 10000).\n    Renvoie:\n    int: Le résultat après avoir pris le modulo 10007 de la sortie.\n    >>> f_6(1)\n    1", "de": "Finde die Fakultät von N und nimm das Modulo 10007 des Ergebnisses.\n    Parameter:\n- N (int): Eine ganze Zahl, die den Eingabewert darstellt (N <= 10000).\n    Rückgabe:\n    int: Das Ergebnis nach dem Nehmen des Modulo 10007 der Ausgabe.\n    >>> f_6(1)\n    1", "ha": "Nemo factorial na N kuma ɗauki modulo 10007 na sakamakon.\n    Sigogi:\n- N (int): Wani lamba mai nuna ƙimar shigarwa (N <= 10000).\n    Dawowa:\n    int: Sakamakon bayan ɗaukar modulo 10007 na fitarwa.\n    >>> f_6(1)\n    1", "hi": "N का फैक्टरियल खोजें और परिणाम का 10007 से मॉड्यूलो लें।\n    पैरामीटर्स:\n- N (int): इनपुट मान का प्रतिनिधित्व करने वाला एक पूर्णांक (N <= 10000)।\n    रिटर्न्स:\n    int: आउटपुट का 10007 से मॉड्यूलो लेने के बाद का परिणाम।\n    >>> f_6(1)\n    1", "hu": "Találd meg N faktoriálisát, és vedd az eredmény 10007-es modulóját.\n    Paraméterek:  \n- N (int): Egy egész szám, amely az input értéket jelöli (N <= 10000).  \nVisszatérési érték:  \nint: Az eredmény, miután az outputot 10007-tel vettük modulo.  \n>>> f_6(1)  \n1  ", "es": "Encontrar el factorial de N y tomar el módulo 10007 del resultado.\n    Parámetros:\n- N (int): Un entero que representa el valor de entrada (N <= 10000).\n    Devuelve:\n    int: El resultado después de tomar el módulo 10007 de la salida.\n    >>> f_6(1)\n    1", "arb": "ابحث عن مضروب N وخذ باقي القسمة 10007 من النتيجة.\n    المعلمات:\n- N (int): عدد صحيح يمثل قيمة الإدخال (N <= 10000).\n    يعيد:\n    int: النتيجة بعد أخذ باقي القسمة 10007 من الناتج.\n    >>> f_6(1)\n    1", "sw": "Tafuta factorial ya N na chukua modulo 10007 ya matokeo.\n    Vigezo:\n- N (int): Nambari kamili inayowakilisha thamani ya ingizo (N <= 10000).\n    Inarejesha:\n    int: Matokeo baada ya kuchukua modulo 10007 ya pato.\n    >>> f_6(1)\n    1", "tr": "Find the factorial of N and take the modulo 10007 of the result.\n    Parametreler:\n- N (int): Girdi değerini temsil eden bir tamsayı (N <= 10000).\n    Döndürür:\n    int: Çıktının 10007 ile modülüsünün alınmasından sonra elde edilen sonuç.\n    >>> f_6(1)\n    1", "vi": "Tìm giai thừa của N và lấy modulo 10007 của kết quả.\n    Tham số:\n- N (int): Một số nguyên đại diện cho giá trị đầu vào (N <= 10000).\n    Trả về:\n    int: Kết quả sau khi lấy modulo 10007 của đầu ra.\n    >>> f_6(1)\n    1", "id": "Temukan faktorial dari N dan ambil hasil modulo 10007.\n    Parameter:\n- N (int): Sebuah bilangan bulat yang mewakili nilai input (N <= 10000).\n    Mengembalikan:\n    int: Hasil setelah mengambil modulo 10007 dari output.\n    >>> f_6(1)\n    1", "ja": "Nの階乗を求め、その結果を10007で割った余りを取ります。\n    パラメータ:\n- N (int): 入力値を表す整数 (N <= 10000)。\n    戻り値:\n    int: 出力を10007で割った余りの結果。\n    >>> f_6(1)\n    1", "ko": "Find the factorial of N and take the modulo 10007 of the result.\n    매개변수:\n- N (int): 입력 값을 나타내는 정수 (N <= 10000).\n    반환:\n    int: 결과에 10007로 모듈로 연산을 한 후의 결과.\n    >>> f_6(1)\n    1", "ml": "N ന്റെ ഫാക്ടോറിയൽ കണ്ടെത്തി ഫലം 10007 ന്റെ മോഡുലോ എടുക്കുക.\n    പാരാമീറ്ററുകൾ:\n- N (int): ഇൻപുട്ട് മൂല്യം പ്രതിനിധീകരിക്കുന്ന ഒരു പൂർണ്ണസംഖ്യ (N <= 10000).\n    മടക്കുന്നു:\n    int: ഔട്ട്പുട്ടിന്റെ മോഡുലോ 10007 എടുത്ത后的 ഫലം.\n    >>> f_6(1)\n    1", "fa": "پیدا کردن فاکتوریل N و گرفتن باقیمانده 10007 از نتیجه.\n\nپارامترها:\n- N (int): یک عدد صحیح که نمایانگر مقدار ورودی است (N <= 10000).\n\nبازگشت:\nint: نتیجه پس از گرفتن باقیمانده 10007 از خروجی.\n\n>>> f_6(1)\n1"}}
{"task_id": "C/7", "prompt": {"en": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCalculate the area of a triangle given its base and height.\n​    Parameters:\n- base (int): The base length of the triangle.\n- height (int): The height of the triangle.\n​    Returns:\n​    float: The calculated area of the triangle, rounded to one decimal place.\n\t>>> f_7(1,2)\n\t1.0\n*/\nfloat f_7(int base, int height)", "sq": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nLlogarit sipërfaqen e një trekëndëshi duke pasur bazën dhe lartësinë e tij.\n    Parametrat:\n- base (int): Gjatësia e bazës së trekëndëshit.\n- height (int): Lartësia e trekëndëshit.\n    Kthen:\n    float: Sipërfaqja e llogaritur e trekëndëshit, e rrumbullakosur në një vend dhjetor.\n\t>>> f_7(1,2)\n\t1.0\n*/\nfloat f_7(int base, int height)", "hy": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nՀաշվել եռանկյունու մակերեսը՝ հաշվի առնելով դրա հիմքը և բարձրությունը։\n​    Պարամետրեր:\n- base (int): Եռանկյունու հիմքի երկարությունը։\n- height (int): Եռանկյունու բարձրությունը։\n​    Վերադարձնում է:\n​    float: Եռանկյունու հաշվարկված մակերեսը՝ կլորացված մինչև մեկ տասնորդական։\n\t>>> f_7(1,2)\n\t1.0\n*/\nfloat f_7(int base, int height)", "bn": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nএকটি ত্রিভুজের ভিত্তি এবং উচ্চতা দেওয়া হলে এর ক্ষেত্রফল গণনা করুন।\n    প্যারামিটার:\n- base (int): ত্রিভুজের ভিত্তির দৈর্ঘ্য।\n- height (int): ত্রিভুজের উচ্চতা।\n    রিটার্নস:\n    float: ত্রিভুজের গণনা করা ক্ষেত্রফল, এক দশমিক স্থানে রাউন্ড করা।\n\t>>> f_7(1,2)\n\t1.0\n*/\nfloat f_7(int base, int height)", "bg": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nИзчисляване на лицето на триъгълник, като се дадат неговата основа и височина.\n​    Параметри:\n- base (int): Дължината на основата на триъгълника.\n- height (int): Височината на триъгълника.\n​    Връща:\n​    float: Изчисленото лице на триъгълника, закръглено до един десетичен знак.\n\t>>> f_7(1,2)\n\t1.0\n*/\nfloat f_7(int base, int height)", "zh": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n计算给定底和高的三角形面积。\n    参数:\n- base (int): 三角形的底边长度。\n- height (int): 三角形的高。\n    返回:\n    float: 计算出的三角形面积，四舍五入到小数点后一位。\n\t>>> f_7(1,2)\n\t1.0\n*/\nfloat f_7(int base, int height)", "fr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCalculez l'aire d'un triangle donné sa base et sa hauteur.\n    Paramètres :\n- base (int) : La longueur de la base du triangle.\n- height (int) : La hauteur du triangle.\n    Renvoie :\n    float : L'aire calculée du triangle, arrondie à un chiffre après la virgule.\n\t>>> f_7(1,2)\n\t1.0\n*/\nfloat f_7(int base, int height)", "de": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nBerechnet die Fläche eines Dreiecks, gegeben durch seine Basis und Höhe.\n    Parameter:\n- base (int): Die Basislänge des Dreiecks.\n- height (int): Die Höhe des Dreiecks.\n    Rückgabe:\n    float: Die berechnete Fläche des Dreiecks, gerundet auf eine Dezimalstelle.\n    >>> f_7(1,2)\n    1.0\n*/\nfloat f_7(int base, int height)", "ha": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nƘididdige yanki na alwatika la'akari da ginshiƙinsa da tsayinsa.\n​    Sigogi:\n- base (int): Tsawon ginshiƙin alwatika.\n- height (int): Tsayin alwatika.\n​    Komawa:\n​    float: Yankin da aka ƙididdige na alwatika, an zagaye zuwa wurin ɗaya na goma.\n\t>>> f_7(1,2)\n\t1.0\n*/\nfloat f_7(int base, int height)", "hi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nत्रिभुज का क्षेत्रफल इसकी आधार और ऊँचाई के आधार पर गणना करें।\n    पैरामीटर्स:\n- base (int): त्रिभुज की आधार लंबाई।\n- height (int): त्रिभुज की ऊँचाई।\n    रिटर्न्स:\n    float: त्रिभुज का गणना किया गया क्षेत्रफल, एक दशमलव स्थान तक गोल किया गया।\n\t>>> f_7(1,2)\n\t1.0\n*/\nfloat f_7(int base, int height)", "hu": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nSzámítsa ki egy háromszög területét az alapja és magassága alapján.\n    Paraméterek:\n- base (int): A háromszög alapjának hossza.\n- height (int): A háromszög magassága.\n    Visszatér:\n    float: A háromszög kiszámított területe, egy tizedesjegyre kerekítve.\n\t>>> f_7(1,2)\n\t1.0\n*/\nfloat f_7(int base, int height)", "es": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCalcular el área de un triángulo dado su base y altura.\n    Parámetros:\n- base (int): La longitud de la base del triángulo.\n- height (int): La altura del triángulo.\n    Retorna:\n    float: El área calculada del triángulo, redondeada a un decimal.\n\t>>> f_7(1,2)\n\t1.0\n*/\nfloat f_7(int base, int height)", "arb": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nحساب مساحة المثلث المعطى قاعدته وارتفاعه.\n    المعلمات:\n- base (int): طول قاعدة المثلث.\n- height (int): ارتفاع المثلث.\n    يعيد:\n    float: المساحة المحسوبة للمثلث، مقربة إلى منزلة عشرية واحدة.\n\t>>> f_7(1,2)\n\t1.0\n*/\nfloat f_7(int base, int height)", "sw": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nHesabu eneo la pembetatu ukizingatia msingi wake na urefu.\n​    Vigezo:\n- base (int): Urefu wa msingi wa pembetatu.\n- height (int): Urefu wa pembetatu.\n​    Inarejesha:\n​    float: Eneo lililohesabiwa la pembetatu, limezungushwa hadi sehemu moja ya desimali.\n\t>>> f_7(1,2)\n\t1.0\n*/\nfloat f_7(int base, int height)", "tr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nBir üçgenin tabanı ve yüksekliği verildiğinde alanını hesaplayın.\n​    Parametreler:\n- base (int): Üçgenin taban uzunluğu.\n- height (int): Üçgenin yüksekliği.\n​    Döndürür:\n​    float: Üçgenin hesaplanan alanı, bir ondalık basamağa yuvarlanmış.\n\t>>> f_7(1,2)\n\t1.0\n*/\nfloat f_7(int base, int height)", "vi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nTính diện tích của một tam giác khi biết đáy và chiều cao của nó.\n​    Tham số:\n- base (int): Chiều dài đáy của tam giác.\n- height (int): Chiều cao của tam giác.\n​    Trả về:\n​    float: Diện tích đã tính của tam giác, làm tròn đến một chữ số thập phân.\n\t>>> f_7(1,2)\n\t1.0\n*/\nfloat f_7(int base, int height)", "id": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nMenghitung luas segitiga berdasarkan alas dan tingginya.\n    Parameter:\n- base (int): Panjang alas segitiga.\n- height (int): Tinggi segitiga.\n    Mengembalikan:\n    float: Luas segitiga yang dihitung, dibulatkan ke satu tempat desimal.\n\t>>> f_7(1,2)\n\t1.0\n*/\nfloat f_7(int base, int height)", "ja": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n三角形の底辺と高さが与えられたときの面積を計算します。\n    パラメータ:\n- base (int): 三角形の底辺の長さ。\n- height (int): 三角形の高さ。\n    戻り値:\n    float: 計算された三角形の面積を小数点以下1桁に丸めたもの。\n\t>>> f_7(1,2)\n\t1.0\n*/\nfloat f_7(int base, int height)", "ko": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n삼각형의 밑변과 높이가 주어졌을 때 면적을 계산합니다.\n​    매개변수:\n- base (int): 삼각형의 밑변 길이.\n- height (int): 삼각형의 높이.\n​    반환값:\n​    float: 소수점 한 자리까지 반올림된 삼각형의 계산된 면적.\n\t>>> f_7(1,2)\n\t1.0\n*/\nfloat f_7(int base, int height)", "ml": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nഒരു ത്രികോണത്തിന്റെ അടിസ്ഥാനവും ഉയരവും നൽകിയാൽ അതിന്റെ വിസ്തീർണ്ണം കണക്കാക്കുക.\n    പാരാമീറ്ററുകൾ:\n- base (int): ത്രികോണത്തിന്റെ അടിസ്ഥാനത്തിന്റെ നീളം.\n- height (int): ത്രികോണത്തിന്റെ ഉയരം.\n    തിരികെ നൽകുന്നു:\n    float: ഒരു ദശാംശ സ്ഥാനം വരെ വട്ടമിട്ട ത്രികോണത്തിന്റെ കണക്കാക്കിയ വിസ്തീർണ്ണം.\n\t>>> f_7(1,2)\n\t1.0\n*/\nfloat f_7(int base, int height)", "fa": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nمساحت یک مثلث را با توجه به قاعده و ارتفاع آن محاسبه کنید.\n    پارامترها:\n- base (int): طول قاعده مثلث.\n- height (int): ارتفاع مثلث.\n    بازگشت:\n    float: مساحت محاسبه شده مثلث، گرد شده به یک رقم اعشار.\n\t>>> f_7(1,2)\n\t1.0\n*/\nfloat f_7(int base, int height)"}, "canonical_solution": "{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}", "instruction": {"en": "float f_7(int base, int height)\n{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "sq": "float f_7(int base, int height)\n{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C në gjuhën shqipe duke përdorur maksimumi 500 karaktere.", "hy": "float f_7(int base, int height)\n{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}\n\nԱպահովեք C կոդի կարճ բնութագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "float f_7(int base, int height)\n{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}\n\nসি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হতে হবে।", "bg": "float f_7(int base, int height)\n{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, използвайки не повече от 500 знака.", "zh": "float f_7(int base, int height)\n{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}\n\n请用最多500个字符的中文对该C代码提供简洁的自然语言描述（文档字符串）。", "fr": "float f_7(int base, int height)\n{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.", "de": "float f_7(int base, int height)\n{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "float f_7(int base, int height)\n{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar C a cikin Hausa, ba tare da wuce haruffa 500 ba.", "hi": "float f_7(int base, int height)\n{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}\n\nC कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "float f_7(int base, int height)\n{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben.", "es": "float f_7(int base, int height)\n{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando como máximo 500 caracteres.", "arb": "float f_7(int base, int height)\n{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "float f_7(int base, int height)\n{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "float f_7(int base, int height)\n{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}\n\nC kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe olarak yazılmalıdır.", "vi": "float f_7(int base, int height)\n{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã C bằng tiếng Việt, sử dụng tối đa 500 ký tự.", "id": "float f_7(int base, int height)\n{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode C dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "float f_7(int base, int height)\n{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}\n\nC コードの簡単な自然言語による説明 (docstring) を英語で最大 500 文字まで入力してください。", "ko": "float f_7(int base, int height)\n{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}\n\nC 코드에 대한 간결한 자연어 설명(도크스트링)을 한국어로 최대 500자 이내로 제공하세요.", "ml": "float f_7(int base, int height)\n{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}\n\nസിഎ കോഡിന്റെ മലയാളത്തിൽ 500 അക്ഷരങ്ങൾക്കുള്ളിൽ ഒരു സംക്ഷിപ്ത സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) നൽകുക.", "fa": "float f_7(int base, int height)\n{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}\n\nیک توضیح مختصر به زبان طبیعی (docstring) از کد C به زبان فارسی ارائه دهید که حداکثر ۵۰۰ کاراکتر باشد."}, "level": "", "test": "int main()\n{\n    // Adding more comprehensive test cases and correcting the expected values\n    assert(fabs(f_7(1, 2) - 1.0) < 1e-6); // Should assert true with close approximate comparison\n    assert(fabs(f_7(3, 4) - 6.0) < 1e-6); // Should assert true with close approximate comparison\n    assert(fabs(f_7(5, 8) - 20.0) < 1e-6); // Additional test case\n    assert(fabs(f_7(7, 3) - 10.5) < 1e-6); // Additional test case\n    assert(fabs(f_7(10, 10) - 50.0) < 1e-6); // Additional test case\n\n    // printf(\"All tests passed.\\n\");\n    return 0;\n}", "entry_point": "f_7", "signature": "float f_7(int base, int height)", "docstring": {"en": "Calculate the area of a triangle given its base and height.\n    Parameters:\n- base (int): The base length of the triangle.\n- height (int): The height of the triangle.\n    Returns:\n    float: The calculated area of the triangle, rounded to one decimal place.\n    >>> f_7(1,2)\n    1.0\n", "sq": "Llogarit sipërfaqen e një trekëndëshi duke pasur bazën dhe lartësinë e tij.\n    Parametrat:\n- base (int): Gjatësia e bazës së trekëndëshit.\n- height (int): Lartësia e trekëndëshit.\n    Kthen:\n    float: Sipërfaqja e llogaritur e trekëndëshit, e rrumbullakosur në një vend dhjetor.\n    >>> f_7(1,2)\n    1.0", "hy": "Եռանկյան մակերեսը հաշվարկել՝ հաշվի առնելով նրա հիմքը և բարձրությունը:\n    Պարամետրեր:\n- base (int): Եռանկյան հիմքի երկարությունը:\n- height (int): Եռանկյան բարձրությունը:\n    Վերադարձնում է:\n    float: Եռանկյան հաշվարկված մակերեսը, կլորացված մինչև մեկ տասնորդական:\n    >>> f_7(1,2)\n    1.0", "bn": "ত্রিভুজের ভিত্তি এবং উচ্চতা দেওয়া হলে তার ক্ষেত্রফল গণনা করুন।\n    Parameters:\n- base (int): ত্রিভুজের ভিত্তির দৈর্ঘ্য।\n- height (int): ত্রিভুজের উচ্চতা।\n    Returns:\n    float: ত্রিভুজের গণনা করা ক্ষেত্রফল, এক দশমিক স্থানে গোলাকার।\n    >>> f_7(1,2)\n    1.0", "bg": "Изчисляване на лицето на триъгълник, дадени неговата основа и височина.\n    Параметри:\n- base (int): Дължината на основата на триъгълника.\n- height (int): Височината на триъгълника.\n    Връща:\n    float: Изчисленото лице на триъгълника, закръглено до един десетичен знак.\n    >>> f_7(1,2)\n    1.0", "zh": "计算给定底边和高的三角形面积。\n    参数:\n- base (int): 三角形的底边长度。\n- height (int): 三角形的高度。\n    返回:\n    float: 计算的三角形面积，四舍五入到小数点后一位。\n    >>> f_7(1,2)\n    1.0", "fr": "Calculer l'aire d'un triangle donné sa base et sa hauteur.\n    Paramètres:\n- base (int): La longueur de la base du triangle.\n- height (int): La hauteur du triangle.\n    Renvoie:\n    float: L'aire calculée du triangle, arrondie à un chiffre après la virgule.\n    >>> f_7(1,2)\n    1.0", "de": "Berechnen Sie die Fläche eines Dreiecks, gegeben durch seine Basis und Höhe.\n    Parameter:\n- base (int): Die Basislänge des Dreiecks.\n- height (int): Die Höhe des Dreiecks.\n    Rückgabewerte:\n    float: Die berechnete Fläche des Dreiecks, gerundet auf eine Dezimalstelle.\n    >>> f_7(1,2)\n    1.0", "ha": "Ƙididdige yanki na alwatika la'akari da tushenta da tsayinta.\n    Sigogi:\n- base (int): Tsawon tushe na alwatika.\n- height (int): Tsawon tsawo na alwatika.\n    Returns:\n    float: Yankin da aka lissafa na alwatika, an zagaye zuwa wurin goma daya.\n    >>> f_7(1,2)\n    1.0", "hi": "त्रिभुज का क्षेत्रफल उसकी आधार और ऊँचाई के आधार पर गणना करें।\n    पैरामीटर्स:\n- base (int): त्रिभुज की आधार लंबाई।\n- height (int): त्रिभुज की ऊँचाई।\n    रिटर्न्स:\n    float: त्रिभुज का गणना किया गया क्षेत्रफल, एक दशमलव स्थान तक गोल किया गया।\n    >>> f_7(1,2)\n    1.0", "hu": "Számítsa ki a háromszög területét az alapja és magassága alapján.\n    Paraméterek:\n- base (int): A háromszög alapjának hossza.\n- height (int): A háromszög magassága.\n    Visszatér:\n    float: A háromszög kiszámított területe, egy tizedesjegyre kerekítve.\n    >>> f_7(1,2)\n    1.0", "es": "Calcular el área de un triángulo dada su base y altura.\n    Parámetros:\n- base (int): La longitud de la base del triángulo.\n- height (int): La altura del triángulo.\n    Devuelve:\n    float: El área calculada del triángulo, redondeada a un decimal.\n    >>> f_7(1,2)\n    1.0", "arb": "حساب مساحة المثلث بناءً على قاعدته وارتفاعه.\n    المعلمات:\n- base (int): طول قاعدة المثلث.\n- height (int): ارتفاع المثلث.\n    يعيد:\n    float: المساحة المحسوبة للمثلث، مقربة إلى منزلة عشرية واحدة.\n    >>> f_7(1,2)\n    1.0", "sw": "Hesabu eneo la pembetatu ukizingatia msingi wake na urefu.\n    Vigezo:\n- base (int): Urefu wa msingi wa pembetatu.\n- height (int): Urefu wa pembetatu.\n    Inarejesha:\n    float: Eneo lililohesabiwa la pembetatu, limezungushwa hadi sehemu moja ya desimali.\n    >>> f_7(1,2)\n    1.0", "tr": "Üçgenin tabanı ve yüksekliği verildiğinde alanını hesaplayın.\n    Parametreler:\n- base (int): Üçgenin taban uzunluğu.\n- height (int): Üçgenin yüksekliği.\n    Döndürür:\n    float: Üçgenin hesaplanan alanı, bir ondalık basamağa yuvarlanmış olarak.\n    >>> f_7(1,2)\n    1.0", "vi": "Tính diện tích của một tam giác dựa trên đáy và chiều cao của nó.\n    Tham số:\n- base (int): Chiều dài đáy của tam giác.\n- height (int): Chiều cao của tam giác.\n    Trả về:\n    float: Diện tích được tính của tam giác, làm tròn đến một chữ số thập phân.\n    >>> f_7(1,2)\n    1.0", "id": "Hitung luas segitiga berdasarkan alas dan tingginya.\n    Parameter:\n- base (int): Panjang alas segitiga.\n- height (int): Tinggi segitiga.\n    Mengembalikan:\n    float: Luas segitiga yang dihitung, dibulatkan ke satu tempat desimal.\n    >>> f_7(1,2)\n    1.0", "ja": "三角形の底辺と高さが与えられたときの面積を計算します。\n    パラメータ:\n- base (int): 三角形の底辺の長さ。\n- height (int): 三角形の高さ。\n    戻り値:\n    float: 計算された三角形の面積を小数点以下1桁に四捨五入したもの。\n    >>> f_7(1,2)\n    1.0", "ko": "삼각형의 밑변과 높이가 주어졌을 때 삼각형의 면적을 계산합니다.\n    매개변수:\n- base (int): 삼각형의 밑변 길이.\n- height (int): 삼각형의 높이.\n    반환값:\n    float: 소수점 한 자리까지 반올림된 삼각형의 계산된 면적.\n    >>> f_7(1,2)\n    1.0", "ml": "ത്രികോണമിതിയുടെ അടിസ്ഥാനവും ഉയരവും നൽകിയാൽ അതിന്റെ വിസ്തീർണം കണക്കാക്കുക.\n    പാരാമീറ്ററുകൾ:\n- base (int): ത്രികോണത്തിന്റെ അടിസ്ഥാനത്തിന്റെ നീളം.\n- height (int): ത്രികോണത്തിന്റെ ഉയരം.\n    മടക്കങ്ങൾ:\n    float: ഒരു ദശാംശ സ്ഥാനത്തേക്ക് വട്ടമിട്ട ത്രികോണത്തിന്റെ കണക്കാക്കിയ വിസ്തീർണം.\n    >>> f_7(1,2)\n    1.0", "fa": "محاسبه مساحت یک مثلث با توجه به قاعده و ارتفاع آن.\n    پارامترها:\n- base (int): طول قاعده مثلث.\n- height (int): ارتفاع مثلث.\n    بازگشت:\n    float: مساحت محاسبه شده مثلث، گرد شده به یک رقم اعشار.\n    >>> f_7(1,2)\n    1.0"}}
{"task_id": "C/8", "prompt": {"en": "#include <assert.h>\n#include <stdio.h>\n/*\nCalculate the Hamming distance between two integers in binary representation.\n​    Parameters:\n- x (int): The first positive integer (x <= 1,000,000,000).\n- y (int): The second positive integer (y <= 1,000,000,000).\n​    Returns:\n​    int: The Hamming distance between x and y, i.e., the number of bits that need to be flipped\n​         to transform x into y in binary.\n\t>>> f_8(1,2)\n\t2\n*/\nint f_8(int x, int y)", "sq": "#include <assert.h>\n#include <stdio.h>\n/*\nLlogarit distancën Hamming midis dy numrave të plotë në paraqitjen binare.\n​    Parametrat:\n- x (int): Numri i parë pozitiv (x <= 1,000,000,000).\n- y (int): Numri i dytë pozitiv (y <= 1,000,000,000).\n​    Kthen:\n​    int: Distanca Hamming midis x dhe y, dmth, numri i biteve që duhet të ndryshohen\n​         për të transformuar x në y në binar.\n\t>>> f_8(1,2)\n\t2\n*/\nint f_8(int x, int y)", "hy": "#include <assert.h>\n#include <stdio.h>\n/*\nՀաշվել Հեմինգի հեռավորությունը երկու ամբողջ թվերի միջև երկբայն ներկայացմամբ։\n​    Պարամետրեր:\n- x (int): Առաջին դրական ամբողջ թիվը (x <= 1,000,000,000)։\n- y (int): Երկրորդ դրական ամբողջ թիվը (y <= 1,000,000,000)։\n​    Վերադարձնում է:\n​    int: Հեմինգի հեռավորությունը x և y միջև, այսինքն՝ բիթերի քանակը, որոնք պետք է փոխվեն\n​         x-ը y-ի վերածելու համար երկբայն համակարգում։\n\t>>> f_8(1,2)\n\t2\n*/\nint f_8(int x, int y)", "bn": "#include <assert.h>\n#include <stdio.h>\n/*\nদুটি পূর্ণসংখ্যার বাইনারি উপস্থাপনার মধ্যে হ্যামিং দূরত্ব গণনা করুন।\n​    প্যারামিটারসমূহ:\n- x (int): প্রথম ধনাত্মক পূর্ণসংখ্যা (x <= 1,000,000,000)।\n- y (int): দ্বিতীয় ধনাত্মক পূর্ণসংখ্যা (y <= 1,000,000,000)।\n​    রিটার্নস:\n​    int: x এবং y এর মধ্যে হ্যামিং দূরত্ব, অর্থাৎ x কে বাইনারিতে y তে রূপান্তর করতে যে সংখ্যক বিট পরিবর্তন করতে হবে।\n\t>>> f_8(1,2)\n\t2\n*/\nint f_8(int x, int y)", "bg": "#include <assert.h>\n#include <stdio.h>\n/*\nИзчислява разстоянието на Хаминг между две цели числа в двоична форма.\n​    Параметри:\n- x (int): Първото положително цяло число (x <= 1,000,000,000).\n- y (int): Второто положително цяло число (y <= 1,000,000,000).\n​    Връща:\n​    int: Разстоянието на Хаминг между x и y, т.е. броят на битовете, които трябва да бъдат обърнати,\n​         за да се трансформира x в y в двоична форма.\n\t>>> f_8(1,2)\n\t2\n*/\nint f_8(int x, int y)", "zh": "#include <assert.h>\n#include <stdio.h>\n/*\n计算两个整数在二进制表示中的汉明距离。\n    参数:\n- x (int): 第一个正整数 (x <= 1,000,000,000)。\n- y (int): 第二个正整数 (y <= 1,000,000,000)。\n    返回:\n    int: x 和 y 之间的汉明距离，即需要翻转的位数以将 x 转换为二进制中的 y。\n\t>>> f_8(1,2)\n\t2\n*/\nint f_8(int x, int y)", "fr": "#include <assert.h>\n#include <stdio.h>\n/*\nCalculer la distance de Hamming entre deux entiers en représentation binaire.\n​    Paramètres :\n- x (int) : Le premier entier positif (x <= 1,000,000,000).\n- y (int) : Le second entier positif (y <= 1,000,000,000).\n​    Renvoie :\n​    int : La distance de Hamming entre x et y, c'est-à-dire le nombre de bits qui doivent être inversés\n​         pour transformer x en y en binaire.\n\t>>> f_8(1,2)\n\t2\n*/\nint f_8(int x, int y)", "de": "#include <assert.h>\n#include <stdio.h>\n/*\nBerechne die Hamming-Distanz zwischen zwei ganzen Zahlen in binärer Darstellung.\n    Parameter:\n- x (int): Die erste positive ganze Zahl (x <= 1.000.000.000).\n- y (int): Die zweite positive ganze Zahl (y <= 1.000.000.000).\n    Rückgabe:\n    int: Die Hamming-Distanz zwischen x und y, d.h. die Anzahl der Bits, die umgekehrt werden müssen,\n         um x in y in binär zu transformieren.\n\t>>> f_8(1,2)\n\t2\n*/\nint f_8(int x, int y)", "ha": "#include <assert.h>\n#include <stdio.h>\n/*\nƘididdige nisan Hamming tsakanin lambobi biyu a cikin wakilcin binary.\n​    Sigogi:\n- x (int): Lamba ta farko mai kyau (x <= 1,000,000,000).\n- y (int): Lamba ta biyu mai kyau (y <= 1,000,000,000).\n​    Komawa:\n​    int: Nisan Hamming tsakanin x da y, wato, yawan bits da ake buƙatar a juya\n​         don canza x zuwa y a cikin binary.\n\t>>> f_8(1,2)\n\t2\n*/\nint f_8(int x, int y)", "hi": "#include <assert.h>\n#include <stdio.h>\n/*\nदो पूर्णांकों के द्विआधारी अभ्यावेदन में हैमिंग दूरी की गणना करें।\n    पैरामीटर्स:\n- x (int): पहला धनात्मक पूर्णांक (x <= 1,000,000,000)।\n- y (int): दूसरा धनात्मक पूर्णांक (y <= 1,000,000,000)।\n    रिटर्न करता है:\n    int: x और y के बीच हैमिंग दूरी, अर्थात्, x को y में द्विआधारी में बदलने के लिए कितने बिट्स को उलटना होगा\n\t>>> f_8(1,2)\n\t2\n*/\nint f_8(int x, int y)", "hu": "#include <assert.h>\n#include <stdio.h>\n/*\nSzámítsa ki a Hamming-távolságot két egész szám bináris ábrázolása között.\n​    Paraméterek:\n- x (int): Az első pozitív egész szám (x <= 1,000,000,000).\n- y (int): A második pozitív egész szám (y <= 1,000,000,000).\n​    Visszatérési érték:\n​    int: A Hamming-távolság x és y között, azaz a bitek száma, amelyeket meg kell változtatni\n​         ahhoz, hogy x-ből y-t alakítsunk binárisan.\n\t>>> f_8(1,2)\n\t2\n*/\nint f_8(int x, int y)", "es": "#include <assert.h>\n#include <stdio.h>\n/*\nCalcular la distancia de Hamming entre dos enteros en representación binaria.\n    Parámetros:\n- x (int): El primer entero positivo (x <= 1,000,000,000).\n- y (int): El segundo entero positivo (y <= 1,000,000,000).\n    Devuelve:\n    int: La distancia de Hamming entre x e y, es decir, el número de bits que necesitan ser cambiados\n         para transformar x en y en binario.\n\t>>> f_8(1,2)\n\t2\n*/\nint f_8(int x, int y)", "arb": "#include <assert.h>\n#include <stdio.h>\n/*\nاحسب مسافة هامنج بين عددين صحيحين في التمثيل الثنائي.\n    المعلمات:\n- x (int): العدد الصحيح الأول الموجب (x <= 1,000,000,000).\n- y (int): العدد الصحيح الثاني الموجب (y <= 1,000,000,000).\n    يعيد:\n    int: مسافة هامنج بين x و y، أي عدد البتات التي تحتاج إلى قلب\n         لتحويل x إلى y في النظام الثنائي.\n\t>>> f_8(1,2)\n\t2\n*/\nint f_8(int x, int y)", "sw": "#include <assert.h>\n#include <stdio.h>\n/*\nHesabu umbali wa Hamming kati ya nambari mbili katika uwakilishi wa binary.\n​    Vigezo:\n- x (int): Nambari ya kwanza chanya (x <= 1,000,000,000).\n- y (int): Nambari ya pili chanya (y <= 1,000,000,000).\n​    Inarejesha:\n​    int: Umbali wa Hamming kati ya x na y, yaani, idadi ya biti zinazohitajika kubadilishwa\n​         ili kubadilisha x kuwa y katika binary.\n\t>>> f_8(1,2)\n\t2\n*/\nint f_8(int x, int y)", "tr": "#include <assert.h>\n#include <stdio.h>\n/*\nİki tam sayı arasındaki Hamming mesafesini ikili gösterimde hesaplayın.\n​    Parametreler:\n- x (int): İlk pozitif tam sayı (x <= 1,000,000,000).\n- y (int): İkinci pozitif tam sayı (y <= 1,000,000,000).\n​    Döndürür:\n​    int: x ve y arasındaki Hamming mesafesi, yani x'i ikili olarak y'ye dönüştürmek için\n​         çevrilmesi gereken bit sayısı.\n\t>>> f_8(1,2)\n\t2\n*/\nint f_8(int x, int y)", "vi": "#include <assert.h>\n#include <stdio.h>\n/*\nTính khoảng cách Hamming giữa hai số nguyên trong biểu diễn nhị phân.\n​    Tham số:\n- x (int): Số nguyên dương thứ nhất (x <= 1,000,000,000).\n- y (int): Số nguyên dương thứ hai (y <= 1,000,000,000).\n​    Trả về:\n​    int: Khoảng cách Hamming giữa x và y, tức là số bit cần lật để biến đổi x thành y trong nhị phân.\n\t>>> f_8(1,2)\n\t2\n*/\nint f_8(int x, int y)", "id": "#include <assert.h>\n#include <stdio.h>\n/*\nMenghitung jarak Hamming antara dua bilangan bulat dalam representasi biner.\n    Parameter:\n- x (int): Bilangan bulat positif pertama (x <= 1,000,000,000).\n- y (int): Bilangan bulat positif kedua (y <= 1,000,000,000).\n    Mengembalikan:\n    int: Jarak Hamming antara x dan y, yaitu jumlah bit yang perlu dibalik\n         untuk mengubah x menjadi y dalam biner.\n\t>>> f_8(1,2)\n\t2\n*/\nint f_8(int x, int y)", "ja": "#include <assert.h>\n#include <stdio.h>\n/*\n2つの整数の2進数表現におけるハミング距離を計算します。\n​    パラメータ:\n- x (int): 最初の正の整数 (x <= 1,000,000,000)。\n- y (int): 2番目の正の整数 (y <= 1,000,000,000)。\n​    戻り値:\n​    int: xとyの間のハミング距離、すなわちxを2進数でyに変換するために反転する必要があるビット数。\n\t>>> f_8(1,2)\n\t2\n*/\nint f_8(int x, int y)", "ko": "#include <assert.h>\n#include <stdio.h>\n/*\n두 정수를 이진 표현으로 변환했을 때의 해밍 거리 계산.\n​    매개변수:\n- x (int): 첫 번째 양의 정수 (x <= 1,000,000,000).\n- y (int): 두 번째 양의 정수 (y <= 1,000,000,000).\n​    반환값:\n​    int: x와 y 사이의 해밍 거리, 즉 x를 이진수로 y로 변환하기 위해 뒤집어야 하는 비트의 수.\n\t>>> f_8(1,2)\n\t2\n*/\nint f_8(int x, int y)", "ml": "#include <assert.h>\n#include <stdio.h>\n/*\nരണ്ട് പൂർണ്ണസംഖ്യകളുടെ ബൈനറി പ്രതിനിധാനത്തിൽ ഹാമിംഗ് ദൂരം കണക്കാക്കുക.\n​    പാരാമീറ്ററുകൾ:\n- x (int): ആദ്യത്തെ പോസിറ്റീവ് പൂർണ്ണസംഖ്യ (x <= 1,000,000,000).\n- y (int): രണ്ടാം പോസിറ്റീവ് പൂർണ്ണസംഖ്യ (y <= 1,000,000,000).\n​    മടക്കുന്നു:\n​    int: x നും y നും ഇടയിലെ ഹാമിംഗ് ദൂരം, അഥവാ ബൈനറിയിൽ x നെ y ആക്കാൻ മാറ്റേണ്ട ബിറ്റുകളുടെ എണ്ണം.\n\t>>> f_8(1,2)\n\t2\n*/\nint f_8(int x, int y)", "fa": "#include <assert.h>\n#include <stdio.h>\n/*\nمحاسبه فاصله همینگ بین دو عدد صحیح در نمایش باینری.\n​    پارامترها:\n- x (int): عدد صحیح اول (x <= 1,000,000,000).\n- y (int): عدد صحیح دوم (y <= 1,000,000,000).\n​    بازگشت:\n​    int: فاصله همینگ بین x و y، یعنی تعداد بیت‌هایی که باید تغییر کنند\n​         تا x به y در باینری تبدیل شود.\n\t>>> f_8(1,2)\n\t2\n*/\nint f_8(int x, int y)"}, "canonical_solution": "{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}", "instruction": {"en": "int f_8(int x, int y)\n{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "sq": "int f_8(int x, int y)\n{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrale (docstring) të kodit C në shqip duke përdorur maksimumi 500 karaktere.", "hy": "int f_8(int x, int y)\n{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}\n\nՏվեք C կոդի կարճ բնութագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։", "bn": "int f_8(int x, int y)\n{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}\n\nসি কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলা ভাষায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।", "bg": "int f_8(int x, int y)\n{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, използвайки най-много 500 знака.", "zh": "int f_8(int x, int y)\n{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}\n\n将以下C代码的功能用中文自然语言简洁描述（文档字符串），字数不超过500个字符。", "fr": "int f_8(int x, int y)\n{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.", "de": "int f_8(int x, int y)\n{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "int f_8(int x, int y)\n{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar C a cikin Hausa ta amfani da haruffa 500 ko kasa da haka.", "hi": "int f_8(int x, int y)\n{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}\n\nC कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "int f_8(int x, int y)\n{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben.", "es": "int f_8(int x, int y)\n{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando como máximo 500 caracteres.", "arb": "int f_8(int x, int y)\n{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "int f_8(int x, int y)\n{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "int f_8(int x, int y)\n{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}\n\nC kodunun işlevselliğini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe olarak yazılmalıdır.", "vi": "int f_8(int x, int y)\n{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã C bằng tiếng Việt với tối đa 500 ký tự.", "id": "int f_8(int x, int y)\n{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode C dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "int f_8(int x, int y)\n{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}\n\n以下のCコードの簡潔な自然言語による説明（ドックストリング）を日本語で500文字以内で提供してください。", "ko": "int f_8(int x, int y)\n{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}\n\n다음 C 코드의 동작을 설명하는 간결한 자연어 설명(docstring)을 한국어로 최대 500자 이내로 작성하세요.", "ml": "int f_8(int x, int y)\n{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}\n\nസിയുടെ കോഡ് സംബന്ധിച്ച സംക്ഷിപ്തമായ ഒരു സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) മലയാളത്തിൽ 500 അക്ഷരങ്ങൾക്കുള്ളിൽ നൽകുക.", "fa": "int f_8(int x, int y)\n{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}\n\nتوضیح مختصر و طبیعی (docstring) از کد C به زبان فارسی ارائه دهید که حداکثر ۵۰۰ کاراکتر باشد."}, "level": "", "test": "int main() {\n    assert(f_8(1, 2) == 2); // 01 and 10 have 2 different bits\n    assert(f_8(4, 7) == 2); // 100 and 111 have 2 different bits\n    assert(f_8(25, 30) == 3); // Additional test: 11001 and 11110 have 3 different bits\n    assert(f_8(0, 0) == 0); // Additional test: Same numbers have 0 different bits\n    assert(f_8(0xFFFFFFF, 0x0000000) == 28); // Additional test: Max unsigned int and 0 have 32 different bits\n    return 0;\n}", "entry_point": "f_8", "signature": "int f_8(int x, int y)", "docstring": {"en": "Calculate the Hamming distance between two integers in binary representation.\n    Parameters:\n- x (int): The first positive integer (x <= 1,000,000,000).\n- y (int): The second positive integer (y <= 1,000,000,000).\n    Returns:\n    int: The Hamming distance between x and y, i.e., the number of bits that need to be flipped to transform x into y in binary.\n    >>> f_8(1,2)\n    2\n", "sq": "Llogarit distancën Hamming midis dy numrave të plotë në përfaqësimin binar.\n    Parametrat:\n- x (int): Numri i parë i plotë pozitiv (x <= 1,000,000,000).\n- y (int): Numri i dytë i plotë pozitiv (y <= 1,000,000,000).\n    Kthen:\n    int: Distanca Hamming midis x dhe y, dmth, numri i biteve që duhet të ndryshohen për të transformuar x në y në binar.\n    >>> f_8(1,2)\n    2", "hy": "Հաշվել Հեմինգի հեռավորությունը երկու ամբողջ թվերի միջև երկբայական ներկայացման մեջ։\n    Պարամետրեր:\n- x (int): Առաջին դրական ամբողջ թիվը (x <= 1,000,000,000)։\n- y (int): Երկրորդ դրական ամբողջ թիվը (y <= 1,000,000,000)։\n    Վերադարձնում է:\n    int: Հեմինգի հեռավորությունը x-ի և y-ի միջև, այսինքն՝ բիթերի քանակը, որոնք պետք է փոխվեն՝ x-ը y-ի վերածելու համար երկբայականում։\n    >>> f_8(1,2)\n    2", "bn": "দুটি পূর্ণসংখ্যার বাইনারি উপস্থাপনার মধ্যে হ্যামিং দূরত্ব গণনা করুন।\n    প্যারামিটারসমূহ:\n- x (int): প্রথম ধনাত্মক পূর্ণসংখ্যা (x <= 1,000,000,000)।\n- y (int): দ্বিতীয় ধনাত্মক পূর্ণসংখ্যা (y <= 1,000,000,000)।\n    রিটার্নস:\n    int: x এবং y এর মধ্যে হ্যামিং দূরত্ব, অর্থাৎ x কে বাইনারিতে y তে রূপান্তর করতে যে সংখ্যক বিট পরিবর্তন করতে হবে।\n    >>> f_8(1,2)\n    2", "bg": "Изчисляване на разстоянието на Хаминг между две цели числа в двоична репрезентация.\n    Параметри:\n- x (int): Първото положително цяло число (x <= 1,000,000,000).\n- y (int): Второто положително цяло число (y <= 1,000,000,000).\n    Връща:\n    int: Разстоянието на Хаминг между x и y, т.е. броят на битовете, които трябва да бъдат променени, за да се трансформира x в y в двоичен вид.\n    >>> f_8(1,2)\n    2", "zh": "计算两个整数在二进制表示中的汉明距离。\n    参数:\n- x (int): 第一个正整数 (x <= 1,000,000,000)。\n- y (int): 第二个正整数 (y <= 1,000,000,000)。\n    返回:\n    int: x 和 y 之间的汉明距离，即在二进制中将 x 转换为 y 需要翻转的位数。\n    >>> f_8(1,2)\n    2", "fr": "Calculer la distance de Hamming entre deux entiers en représentation binaire.\n    Paramètres:\n- x (int): Le premier entier positif (x <= 1,000,000,000).\n- y (int): Le deuxième entier positif (y <= 1,000,000,000).\n    Renvoie:\n    int: La distance de Hamming entre x et y, c'est-à-dire le nombre de bits qui doivent être inversés pour transformer x en y en binaire.\n    >>> f_8(1,2)\n    2", "de": "Berechne die Hamming-Distanz zwischen zwei ganzen Zahlen in binärer Darstellung.\n    Parameter:\n- x (int): Die erste positive ganze Zahl (x <= 1,000,000,000).\n- y (int): Die zweite positive ganze Zahl (y <= 1,000,000,000).\n    Rückgabewert:\n    int: Die Hamming-Distanz zwischen x und y, d.h. die Anzahl der Bits, die umgekippt werden müssen, um x in y in binär zu transformieren.\n    >>> f_8(1,2)\n    2", "ha": "Ƙididdige nisan Hamming tsakanin lambobi biyu a cikin wakilcin binary.\n    Sigogi:\n- x (int): Lamba na farko mai kyau (x <= 1,000,000,000).\n- y (int): Lamba na biyu mai kyau (y <= 1,000,000,000).\n    Returns:\n    int: Nisan Hamming tsakanin x da y, wato, adadin bits da ake buƙatar juyawa don canza x zuwa y a cikin binary.\n    >>> f_8(1,2)\n    2", "hi": "दो पूर्णांकों के बीच बाइनरी प्रतिनिधित्व में हैमिंग दूरी की गणना करें।\n    पैरामीटर्स:\n- x (int): पहला धनात्मक पूर्णांक (x <= 1,000,000,000)।\n- y (int): दूसरा धनात्मक पूर्णांक (y <= 1,000,000,000)।\n    रिटर्न्स:\n    int: x और y के बीच हैमिंग दूरी, अर्थात्, x को बाइनरी में y में बदलने के लिए जिन बिट्स को उलटना आवश्यक है उनकी संख्या।\n    >>> f_8(1,2)\n    2", "hu": "Számítsa ki a Hamming-távolságot két egész szám bináris ábrázolása között.\n    Paraméterek:\n- x (int): Az első pozitív egész szám (x <= 1,000,000,000).\n- y (int): A második pozitív egész szám (y <= 1,000,000,000).\n    Visszatérési érték:\n    int: A Hamming-távolság x és y között, azaz hány bitet kell megváltoztatni ahhoz, hogy x-ből y-t kapjunk binárisan.\n    >>> f_8(1,2)\n    2", "es": "Calcular la distancia de Hamming entre dos enteros en representación binaria.\n    Parámetros:\n- x (int): El primer entero positivo (x <= 1,000,000,000).\n- y (int): El segundo entero positivo (y <= 1,000,000,000).\n    Devuelve:\n    int: La distancia de Hamming entre x e y, es decir, el número de bits que deben ser cambiados para transformar x en y en binario.\n    >>> f_8(1,2)\n    2", "arb": "احسب مسافة هامينغ بين عددين صحيحين في التمثيل الثنائي.\n    المعلمات:\n- x (int): العدد الصحيح الأول الموجب (x <= 1,000,000,000).\n- y (int): العدد الصحيح الثاني الموجب (y <= 1,000,000,000).\n    يعيد:\n    int: مسافة هامينغ بين x و y، أي عدد البتات التي تحتاج إلى قلبها لتحويل x إلى y في التمثيل الثنائي.\n    >>> f_8(1,2)\n    2", "sw": "Hesabu umbali wa Hamming kati ya nambari mbili katika uwakilishi wa binary.\n    Vigezo:\n- x (int): Nambari ya kwanza chanya (x <= 1,000,000,000).\n- y (int): Nambari ya pili chanya (y <= 1,000,000,000).\n    Inarejesha:\n    int: Umbali wa Hamming kati ya x na y, yaani, idadi ya biti zinazohitajika kubadilishwa ili kubadilisha x kuwa y katika binary.\n    >>> f_8(1,2)\n    2", "tr": "İki tamsayı arasındaki ikili gösterimdeki Hamming mesafesini hesaplayın.\n    Parametreler:\n- x (int): İlk pozitif tamsayı (x <= 1,000,000,000).\n- y (int): İkinci pozitif tamsayı (y <= 1,000,000,000).\n    Döndürür:\n    int: x ve y arasındaki Hamming mesafesi, yani x'i ikili olarak y'ye dönüştürmek için çevrilmesi gereken bit sayısı.\n    >>> f_8(1,2)\n    2", "vi": "Tính khoảng cách Hamming giữa hai số nguyên trong biểu diễn nhị phân.\n    Tham số:\n- x (int): Số nguyên dương thứ nhất (x <= 1,000,000,000).\n- y (int): Số nguyên dương thứ hai (y <= 1,000,000,000).\n    Trả về:\n    int: Khoảng cách Hamming giữa x và y, tức là số bit cần phải lật để biến đổi x thành y trong nhị phân.\n    >>> f_8(1,2)\n    2", "id": "Hitung jarak Hamming antara dua bilangan bulat dalam representasi biner.\n    Parameter:\n- x (int): Bilangan bulat positif pertama (x <= 1,000,000,000).\n- y (int): Bilangan bulat positif kedua (y <= 1,000,000,000).\n    Mengembalikan:\n    int: Jarak Hamming antara x dan y, yaitu jumlah bit yang perlu dibalik untuk mengubah x menjadi y dalam biner.\n    >>> f_8(1,2)\n    2", "ja": "2つの整数の2進数表現におけるハミング距離を計算します。\n    引数:\n- x (int): 最初の正の整数 (x <= 1,000,000,000)。\n- y (int): 2番目の正の整数 (y <= 1,000,000,000)。\n    戻り値:\n    int: xとyの間のハミング距離、つまりxをyに変換するために反転する必要があるビットの数。\n    >>> f_8(1,2)\n    2", "ko": "이진 표현에서 두 정수 사이의 해밍 거리를 계산합니다.\n    매개변수:\n- x (int): 첫 번째 양의 정수 (x <= 1,000,000,000).\n- y (int): 두 번째 양의 정수 (y <= 1,000,000,000).\n    반환값:\n    int: x를 y로 변환하기 위해 뒤집어야 하는 비트의 수, 즉 x와 y 사이의 해밍 거리.\n    >>> f_8(1,2)\n    2", "ml": "രണ്ട് പൂർണ്ണസംഖ്യകളുടെ ബൈനറി പ്രതിനിധാനത്തിൽ ഹാമിംഗ് ദൂരം കണക്കാക്കുക.\n    പാരാമീറ്ററുകൾ:\n- x (int): ആദ്യത്തെ പോസിറ്റീവ് പൂർണ്ണസംഖ്യ (x <= 1,000,000,000).\n- y (int): രണ്ടാമത്തെ പോസിറ്റീവ് പൂർണ്ണസംഖ്യ (y <= 1,000,000,000).\n    മടക്കം:\n    int: x-നെയും y-നെയും തമ്മിലുള്ള ഹാമ്മിംഗ് ദൂരം, അഥവാ, ബൈനറിയിൽ x-നെ y-യാക്കി മാറ്റാൻ മാറ്റേണ്ട ബിറ്റുകളുടെ എണ്ണം.\n    >>> f_8(1,2)\n    2", "fa": "محاسبه فاصله همینگ بین دو عدد صحیح در نمایش دودویی.\n    پارامترها:\n- x (int): اولین عدد صحیح مثبت (x <= 1,000,000,000).\n- y (int): دومین عدد صحیح مثبت (y <= 1,000,000,000).\n    بازگشت:\n    int: فاصله همینگ بین x و y، یعنی تعداد بیت‌هایی که باید تغییر کنند تا x به y در دودویی تبدیل شود.\n    >>> f_8(1,2)\n    2"}}
{"task_id": "C/9", "prompt": {"en": "#include <assert.h>\n#include <stdarg.h>\n\n/*\nCount the number of odd integers in a given list of numbers.\n    Parameters:\n- count (int): The count of numbers to evaluate.\n- ... (int): A sequence of integers.\n    Returns:\n    int: The count of odd numbers in the input list.\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3\n*/\nint f_9(int count, ...)", "sq": "#include <assert.h>\n#include <stdarg.h>\n\n/*\nNumëron numrin e numrave tek në një listë të dhënë numrash.\n    Parametrat:\n- count (int): Numri i numrave për t'u vlerësuar.\n- ... (int): Një sekuencë e numrave të plotë.\n    Kthen:\n    int: Numri i numrave tek në listën e dhënë.\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3\n*/\nint f_9(int count, ...)", "hy": "#include <assert.h>\n#include <stdarg.h>\n\n/*\nՀաշվել տրված թվերի ցուցակում կենտ ամբողջ թվերի քանակը:\n    Պարամետրեր:\n- count (int): Գնահատվող թվերի քանակը:\n- ... (int): Ամբողջ թվերի հաջորդականություն:\n    Վերադարձնում է:\n    int: Մուտքային ցուցակում գտնվող կենտ թվերի քանակը:\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3\n*/\nint f_9(int count, ...)", "bn": "#include <assert.h>\n#include <stdarg.h>\n\n/*\nএকটি প্রদত্ত সংখ্যার তালিকায় বিজোড় পূর্ণসংখ্যার সংখ্যা গণনা করুন।\n    প্যারামিটার:\n- count (int): মূল্যায়ন করার জন্য সংখ্যার সংখ্যা।\n- ... (int): পূর্ণসংখ্যার একটি ক্রম।\n    রিটার্ন:\n    int: ইনপুট তালিকায় বিজোড় সংখ্যার সংখ্যা।\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3\n*/\nint f_9(int count, ...)", "bg": "#include <assert.h>\n#include <stdarg.h>\n\n/*\nБройте броя на нечетните цели числа в даден списък от числа.\n    Параметри:\n- count (int): Броят на числата за оценка.\n- ... (int): Последователност от цели числа.\n    Връща:\n    int: Броят на нечетните числа в входния списък.\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3\n*/\nint f_9(int count, ...)", "zh": "#include <assert.h>\n#include <stdarg.h>\n\n/*\n计算给定数字列表中奇数的数量。\n    参数:\n- count (int): 要评估的数字数量。\n- ... (int): 一系列整数。\n    返回:\n    int: 输入列表中奇数的数量。\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3\n*/\nint f_9(int count, ...)", "fr": "#include <assert.h>\n#include <stdarg.h>\n\n/*\nCompter le nombre d'entiers impairs dans une liste donnée de nombres.\n    Paramètres:\n- count (int): Le nombre de nombres à évaluer.\n- ... (int): Une séquence d'entiers.\n    Retourne:\n    int: Le nombre de nombres impairs dans la liste d'entrée.\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3\n*/\nint f_9(int count, ...)", "de": "#include <assert.h>\n#include <stdarg.h>\n\n/*\nZählt die Anzahl der ungeraden Ganzzahlen in einer gegebenen Liste von Zahlen.\n    Parameter:\n- count (int): Die Anzahl der zu bewertenden Zahlen.\n- ... (int): Eine Sequenz von Ganzzahlen.\n    Rückgabe:\n    int: Die Anzahl der ungeraden Zahlen in der Eingabeliste.\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3\n*/\nint f_9(int count, ...)", "ha": "#include <assert.h>\n#include <stdarg.h>\n\n/*\nƘirga adadin lambobin da ba su da ma'ana a cikin jerin lambobi da aka bayar.\n    Sigogi:\n- count (int): Adadin lambobin da za a tantance.\n- ... (int): Jerin lambobi.\n    Komawa:\n    int: Adadin lambobin da ba su da ma'ana a cikin jerin shigarwa.\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3\n*/\nint f_9(int count, ...)", "hi": "#include <assert.h>\n#include <stdarg.h>\n\n/*\nदी गई संख्या की सूची में विषम पूर्णांकों की संख्या गिनें।\n    पैरामीटर्स:\n- count (int): मूल्यांकन करने के लिए संख्याओं की गिनती।\n- ... (int): पूर्णांकों की एक श्रृंखला।\n    रिटर्न्स:\n    int: इनपुट सूची में विषम संख्याओं की गिनती।\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3\n*/\nint f_9(int count, ...)", "hu": "#include <assert.h>\n#include <stdarg.h>\n\n/*\nSzámolja meg a páratlan egész számok számát egy adott számok listájában.\n    Paraméterek:\n- count (int): A kiértékelendő számok száma.\n- ... (int): Egész számok sorozata.\n    Visszatér:\n    int: A bemeneti listában található páratlan számok száma.\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3\n*/\nint f_9(int count, ...)", "es": "#include <assert.h>\n#include <stdarg.h>\n\n/*\nCuenta el número de enteros impares en una lista dada de números.\n    Parámetros:\n- count (int): La cantidad de números a evaluar.\n- ... (int): Una secuencia de enteros.\n    Devuelve:\n    int: La cantidad de números impares en la lista de entrada.\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3\n*/\nint f_9(int count, ...)", "arb": "#include <assert.h>\n#include <stdarg.h>\n\n/*\nاحسب عدد الأعداد الفردية في قائمة معينة من الأرقام.\n    المعلمات:\n- count (int): عدد الأرقام لتقييمها.\n- ... (int): تسلسل من الأعداد الصحيحة.\n    يعيد:\n    int: عدد الأعداد الفردية في قائمة الإدخال.\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3\n*/\nint f_9(int count, ...)", "sw": "#include <assert.h>\n#include <stdarg.h>\n\n/*\nHesabu idadi ya nambari zisizo za kawaida katika orodha iliyotolewa ya nambari.\n    Vigezo:\n- count (int): Idadi ya nambari za kutathmini.\n- ... (int): Mfululizo wa nambari za mzima.\n    Inarudisha:\n    int: Idadi ya nambari zisizo za kawaida katika orodha ya pembejeo.\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3\n*/\nint f_9(int count, ...)", "tr": "#include <assert.h>\n#include <stdarg.h>\n\n/*\nVerilen bir sayı listesindeki tek sayıların sayısını sayar.\n    Parametreler:\n- count (int): Değerlendirilecek sayıların sayısı.\n- ... (int): Bir dizi tam sayı.\n    Döndürür:\n    int: Girdi listesindeki tek sayıların sayısı.\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3\n*/\nint f_9(int count, ...)", "vi": "#include <assert.h>\n#include <stdarg.h>\n\n/*\nĐếm số lượng số nguyên lẻ trong một danh sách số đã cho.\n    Tham số:\n- count (int): Số lượng số cần đánh giá.\n- ... (int): Một dãy số nguyên.\n    Trả về:\n    int: Số lượng số lẻ trong danh sách đầu vào.\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3\n*/\nint f_9(int count, ...)", "id": "#include <assert.h>\n#include <stdarg.h>\n\n/*\nMenghitung jumlah bilangan ganjil dalam daftar bilangan yang diberikan.\n    Parameter:\n- count (int): Jumlah bilangan yang akan dievaluasi.\n- ... (int): Urutan bilangan bulat.\n    Mengembalikan:\n    int: Jumlah bilangan ganjil dalam daftar input.\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3\n*/\nint f_9(int count, ...)", "ja": "#include <assert.h>\n#include <stdarg.h>\n\n/*\n与えられた数のリストの中で奇数の整数の数を数えます。\n    パラメータ:\n- count (int): 評価する数のカウント。\n- ... (int): 整数のシーケンス。\n    戻り値:\n    int: 入力リスト内の奇数の数。\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3\n*/\nint f_9(int count, ...)", "ko": "#include <assert.h>\n#include <stdarg.h>\n\n/*\n주어진 숫자 목록에서 홀수의 개수를 센다.\n    매개변수:\n- count (int): 평가할 숫자의 개수.\n- ... (int): 정수의 시퀀스.\n    반환:\n    int: 입력 목록에서 홀수의 개수.\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3\n*/\nint f_9(int count, ...)", "ml": "#include <assert.h>\n#include <stdarg.h>\n\n/*\nഒരു നൽകിയ ലിസ്റ്റിലെ ഒറ്റ സംഖ്യകളുടെ എണ്ണം എണ്ണുക.\n    പാരാമീറ്ററുകൾ:\n- count (int): വിലയിരുത്തേണ്ട സംഖ്യകളുടെ എണ്ണം.\n- ... (int): ഒരു സംഖ്യകളുടെ ശ്രേണി.\n    മടങ്ങിവരവ്:\n    int: ഇൻപുട്ട് ലിസ്റ്റിലെ ഒറ്റ സംഖ്യകളുടെ എണ്ണം.\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3\n*/\nint f_9(int count, ...)", "fa": "#include <assert.h>\n#include <stdarg.h>\n\n/*\nتعداد اعداد فرد را در یک لیست از اعداد داده شده بشمارید.\n    پارامترها:\n- count (int): تعداد اعدادی که باید ارزیابی شوند.\n- ... (int): یک دنباله از اعداد صحیح.\n    بازگشت:\n    int: تعداد اعداد فرد در لیست ورودی.\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3\n*/\nint f_9(int count, ...)"}, "canonical_solution": "{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1)\n            ans++;\n    }\n    va_end(args);\n    return ans;\n}", "instruction": {"en": "int f_9(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1)\n            ans++;\n    }\n    va_end(args);\n    return ans;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "sq": "int f_9(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1)\n            ans++;\n    }\n    va_end(args);\n    return ans;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C në shqip duke përdorur maksimumi 500 karaktere.", "hy": "int f_9(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1)\n            ans++;\n    }\n    va_end(args);\n    return ans;\n}\n\nՏվեք C կոդի հակիրճ բնութագիր (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "int f_9(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1)\n            ans++;\n    }\n    va_end(args);\n    return ans;\n}\n\nসি কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলা ভাষায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।", "bg": "int f_9(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1)\n            ans++;\n    }\n    va_end(args);\n    return ans;\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, използвайки най-много 500 знака.", "zh": "int f_9(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1)\n            ans++;\n    }\n    va_end(args);\n    return ans;\n}\n\n请用不超过500个字符的中文，为以下C代码提供简洁的自然语言描述（文档字符串）。", "fr": "int f_9(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1)\n            ans++;\n    }\n    va_end(args);\n    return ans;\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.", "de": "int f_9(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1)\n            ans++;\n    }\n    va_end(args);\n    return ans;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen.", "ha": "int f_9(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1)\n            ans++;\n    }\n    va_end(args);\n    return ans;\n}\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar C a cikin Hausa ta amfani da haruffa 500 kawai.", "hi": "int f_9(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1)\n            ans++;\n    }\n    va_end(args);\n    return ans;\n}\n\nC कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "int f_9(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1)\n            ans++;\n    }\n    va_end(args);\n    return ans;\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben.", "es": "int f_9(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1)\n            ans++;\n    }\n    va_end(args);\n    return ans;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando como máximo 500 caracteres.", "arb": "int f_9(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1)\n            ans++;\n    }\n    va_end(args);\n    return ans;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية بلغة C باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "int f_9(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1)\n            ans++;\n    }\n    va_end(args);\n    return ans;\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "int f_9(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1)\n            ans++;\n    }\n    va_end(args);\n    return ans;\n}\n\nVerilen C kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda, özlü bir doğal dil açıklaması (docstring) sağlayın.", "vi": "int f_9(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1)\n            ans++;\n    }\n    va_end(args);\n    return ans;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã C bằng tiếng Việt, không quá 500 ký tự.", "id": "int f_9(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1)\n            ans++;\n    }\n    va_end(args);\n    return ans;\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode C dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "int f_9(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1)\n            ans++;\n    }\n    va_end(args);\n    return ans;\n}\n\nCコードの内容を簡潔に説明する日本語のドキュメンテーション文字列（docstring）を、最大500文字で提供してください。", "ko": "int f_9(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1)\n            ans++;\n    }\n    va_end(args);\n    return ans;\n}\n\nC 코드에 대한 간결한 자연어 설명(도크스트링)을 한국어로 최대 500자 이내로 제공하세요.", "ml": "int f_9(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1)\n            ans++;\n    }\n    va_end(args);\n    return ans;\n}\n\nസീ കോഡിന്റെ ഡോക്സ്ട്രിംഗ് മലയാളത്തിൽ 500 അക്ഷരങ്ങളിൽ കൂടുതൽ ഇല്ലാതെ സംക്ഷിപ്തമായ സ്വാഭാവിക ഭാഷാ വിവരണം നൽകുക.", "fa": "int f_9(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1)\n            ans++;\n    }\n    va_end(args);\n    return ans;\n}\n\nتوضیح مختصر و طبیعی (docstring) از کد C به زبان فارسی ارائه دهید که حداکثر ۵۰۰ کاراکتر باشد."}, "level": "", "test": "int main() {\n    assert(f_9(5, 1, 4, 3, 2, 5) == 3);\n    assert(f_9(4, 2, 2, 0, 0) == 0);\n    assert(f_9(6, 7, 7, 8, 1, 9, 10) == 4); // Additional Test Sample\n    // printf(\"All tests passed!\\n\");\n    return 0;\n}", "entry_point": "f_9", "signature": "int f_9(int count, ...)", "docstring": {"en": "Count the number of odd integers in a given list of numbers.\n    Parameters:\n- count (int): The count of numbers to evaluate.\n- ... (int): A sequence of integers.\n    Returns:\n    int: The count of odd numbers in the input list.\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3\n", "sq": "Numëroni numrin e numrave tek në një listë të dhënë numrash.\n    Parametrat:\n- count (int): Numri i numrave për t'u vlerësuar.\n- ... (int): Një sekuencë numrash të plotë.\n    Kthen:\n    int: Numri i numrave tek në listën e dhënë.\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3", "hy": "Հաշվել տրված թվերի ցանկում կենտ ամբողջ թվերի քանակը:\n    Պարամետրեր:\n- count (int): Գնահատվող թվերի քանակը:\n- ... (int): Ամբողջ թվերի հաջորդականություն:\n    Վերադարձնում է:\n    int: Մուտքային ցանկում կենտ թվերի քանակը:\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3", "bn": "দেওয়া সংখ্যার তালিকায় বিজোড় পূর্ণসংখ্যার সংখ্যা গণনা করুন।\n    Parameters:\n- count (int): মূল্যায়ন করার জন্য সংখ্যার সংখ্যা।\n- ... (int): পূর্ণসংখ্যার একটি ক্রম।\n    Returns:\n    int: ইনপুট তালিকায় বিজোড় সংখ্যার সংখ্যা।\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3", "bg": "Бройте броя на нечетните цели числа в даден списък от числа.\n    Параметри:\n- count (int): Броят на числата за оценка.\n- ... (int): Последователност от цели числа.\n    Връща:\n    int: Броят на нечетните числа в списъка на входа.\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3", "zh": "计算给定数字列表中奇数的数量。\n    参数:\n- count (int): 要评估的数字数量。\n- ... (int): 整数序列。\n    返回:\n    int: 输入列表中奇数的数量。\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3", "fr": "Compter le nombre d'entiers impairs dans une liste donnée de nombres.\n    Paramètres:\n- count (int): Le nombre de chiffres à évaluer.\n- ... (int): Une séquence d'entiers.\n    Renvoie:\n    int: Le nombre de nombres impairs dans la liste d'entrée.\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3", "de": "Zähle die Anzahl der ungeraden Ganzzahlen in einer gegebenen Liste von Zahlen.\n    Parameter:\n- count (int): Die Anzahl der zu bewertenden Zahlen.\n- ... (int): Eine Sequenz von Ganzzahlen.\n    Rückgabewert:\n    int: Die Anzahl der ungeraden Zahlen in der Eingabeliste.\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3", "ha": "Kirga adadin lambobin da ba su daidai ba a cikin jerin lambobi da aka bayar.\n    Sigogi:\n- count (int): Adadin lambobin da za a tantance.\n- ... (int): Jerin lambobi.\n    Komawa:\n    int: Adadin lambobin da ba su daidai ba a cikin jerin shigarwa.\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3", "hi": "दिए गए संख्याओं की सूची में विषम पूर्णांकों की संख्या गिनें।\n    पैरामीटर्स:\n- count (int): मूल्यांकन करने के लिए संख्याओं की गिनती।\n- ... (int): पूर्णांकों का एक अनुक्रम।\n    रिटर्न्स:\n    int: इनपुट सूची में विषम संख्याओं की गिनती।\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3", "hu": "Számolja meg a páratlan egész számokat egy adott számok listájában.\n    Paraméterek:\n- count (int): Az értékelendő számok száma.\n- ... (int): Egy egész számok sorozata.\n    Visszatér:\n    int: A bemeneti listában található páratlan számok száma.\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3", "es": "Cuenta el número de enteros impares en una lista dada de números.\n    Parámetros:\n- count (int): La cantidad de números a evaluar.\n- ... (int): Una secuencia de enteros.\n    Devuelve:\n    int: La cantidad de números impares en la lista de entrada.\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3", "arb": "احسب عدد الأعداد الفردية في قائمة معينة من الأرقام.\n    المعلمات:\n- count (int): عدد الأرقام لتقييمها.\n- ... (int): تسلسل من الأعداد الصحيحة.\n    يعيد:\n    int: عدد الأعداد الفردية في قائمة الإدخال.\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3", "sw": "Hesabu idadi ya nambari zisizo za kawaida katika orodha iliyotolewa ya nambari.\n    Vigezo:\n- count (int): Idadi ya nambari za kutathmini.\n- ... (int): Mfululizo wa nambari za mzima.\n    Inarejesha:\n    int: Idadi ya nambari zisizo za kawaida katika orodha ya ingizo.\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3", "tr": "Verilen bir sayı listesindeki tek sayıların sayısını sayın.\n    Parametreler:\n- count (int): Değerlendirilecek sayıların sayısı.\n- ... (int): Bir dizi tam sayı.\n    Döndürür:\n    int: Girdi listesindeki tek sayıların sayısı.\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3", "vi": "Đếm số lượng số nguyên lẻ trong một danh sách số đã cho.\n    Tham số:\n- count (int): Số lượng số cần đánh giá.\n- ... (int): Một dãy số nguyên.\n    Trả về:\n    int: Số lượng số lẻ trong danh sách đầu vào.\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3", "id": "Hitung jumlah bilangan bulat ganjil dalam daftar angka yang diberikan.\n    Parameter:\n- count (int): Jumlah angka yang akan dievaluasi.\n- ... (int): Sebuah urutan bilangan bulat.\n    Mengembalikan:\n    int: Jumlah bilangan ganjil dalam daftar input.\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3", "ja": "与えられた数値のリスト内の奇数の整数の数を数えます。\n    パラメータ:\n- count (int): 評価する数の数。\n- ... (int): 整数のシーケンス。\n    戻り値:\n    int: 入力リスト内の奇数の数。\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3", "ko": "주어진 숫자 목록에서 홀수 정수의 개수를 셉니다.\n    매개변수:\n- count (int): 평가할 숫자의 개수.\n- ... (int): 정수의 시퀀스.\n    반환:\n    int: 입력 목록에서 홀수의 개수.\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3", "ml": "ദിയ്ക്കപ്പെട്ട സംഖ്യകളുടെ പട്ടികയിൽ എത്ര ഒറ്റ സംഖ്യകൾ ഉണ്ടെന്ന് എണ്ണുക.\n    പാരാമീറ്ററുകൾ:\n- count (int): വിലയിരുത്താനുള്ള സംഖ്യകളുടെ എണ്ണം.\n- ... (int): ഒരു പദവിനുള്ളിലെ സംഖ്യകൾ.\n    മടക്കം:\n    int: ഇൻപുട്ട് പട്ടികയിലെ ഒറ്റ സംഖ്യകളുടെ എണ്ണം.\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3", "fa": "تعداد اعداد فرد را در یک لیست داده شده از اعداد بشمارید.\n    پارامترها:\n- count (int): تعداد اعدادی که باید ارزیابی شوند.\n- ... (int): یک دنباله از اعداد صحیح.\n    بازمی‌گرداند:\n    int: تعداد اعداد فرد در لیست ورودی.\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3"}}
{"task_id": "C/10", "prompt": {"en": "#include <assert.h>\n#include <stdio.h>\n/*\nCalculate the sum of even numbers in a given list.\n    Parameters:\n- numbers (list): A list of integers.\n- size (int): The size of the list.\n    Returns:\n    int: The sum of even numbers in the input list.\n    >>> f_10([1,4,3,2,5], 5)\n    6\n*/\nint f_10(int *numbers, int size); // Fixed declaration", "sq": "#include <assert.h>\n#include <stdio.h>\n/*\nLlogarit shumën e numrave çift në një listë të dhënë.\n    Parametrat:\n- numbers (listë): Një listë e numrave të plotë.\n- size (int): Madhësia e listës.\n    Kthen:\n    int: Shuma e numrave çift në listën hyrëse.\n    >>> f_10([1,4,3,2,5], 5)\n    6\n*/\nint f_10(int *numbers, int size); // Deklarim i fiksuar", "hy": "#include <assert.h>\n#include <stdio.h>\n/*\nՀաշվել զույգ թվերի գումարը տրված ցուցակում։\n    Պարամետրեր:\n- numbers (list): Թվերի ցուցակ։\n- size (int): Ցուցակի չափը։\n    Վերադարձնում է:\n    int: Մուտքային ցուցակի զույգ թվերի գումարը։\n    >>> f_10([1,4,3,2,5], 5)\n    6\n*/\nint f_10(int *numbers, int size); // Ֆիքսված հայտարարություն", "bn": "#include <assert.h>\n#include <stdio.h>\n/*\nএকটি প্রদত্ত তালিকার জোড় সংখ্যাগুলির যোগফল গণনা করুন।\n    প্যারামিটার:\n- numbers (list): পূর্ণসংখ্যার একটি তালিকা।\n- size (int): তালিকার আকার।\n    রিটার্নস:\n    int: ইনপুট তালিকার জোড় সংখ্যাগুলির যোগফল।\n    >>> f_10([1,4,3,2,5], 5)\n    6\n*/\nint f_10(int *numbers, int size); // Fixed declaration", "bg": "#include <assert.h>\n#include <stdio.h>\n/*\nИзчислява сумата на четните числа в даден списък.\n    Параметри:\n- numbers (list): Списък от цели числа.\n- size (int): Размерът на списъка.\n    Връща:\n    int: Сумата на четните числа в входния списък.\n    >>> f_10([1,4,3,2,5], 5)\n    6\n*/\nint f_10(int *numbers, int size); // Фиксирана декларация", "zh": "#include <assert.h>\n#include <stdio.h>\n/*\n计算给定列表中偶数的和。\n    参数:\n- numbers (list): 整数列表。\n- size (int): 列表的大小。\n    返回:\n    int: 输入列表中偶数的和。\n    >>> f_10([1,4,3,2,5], 5)\n    6\n*/\nint f_10(int *numbers, int size); // 固定声明", "fr": "#include <assert.h>\n#include <stdio.h>\n/*\nCalculer la somme des nombres pairs dans une liste donnée.\n    Paramètres:\n- numbers (list): Une liste d'entiers.\n- size (int): La taille de la liste.\n    Renvoie:\n    int: La somme des nombres pairs dans la liste d'entrée.\n    >>> f_10([1,4,3,2,5], 5)\n    6\n*/\nint f_10(int *numbers, int size); // Déclaration corrigée", "de": "#include <assert.h>\n#include <stdio.h>\n/*\nBerechne die Summe der geraden Zahlen in einer gegebenen Liste.\n    Parameter:\n- numbers (list): Eine Liste von ganzen Zahlen.\n- size (int): Die Größe der Liste.\n    Rückgabewert:\n    int: Die Summe der geraden Zahlen in der Eingabeliste.\n    >>> f_10([1,4,3,2,5], 5)\n    6\n*/\nint f_10(int *numbers, int size); // Feste Deklaration", "ha": "#include <assert.h>\n#include <stdio.h>\n/*\nƘididdige jimillar lambobin da suka zama ma'aurata a cikin jerin da aka bayar.\n    Sigogi:\n- numbers (list): Jerin lambobi masu cikakken lamba.\n- size (int): Girman jerin.\n    Komawa:\n    int: Jimillar lambobin da suka zama ma'aurata a cikin jerin shigarwa.\n    >>> f_10([1,4,3,2,5], 5)\n    6\n*/\nint f_10(int *numbers, int size); // Gyaran sanarwa", "hi": "#include <assert.h>\n#include <stdio.h>\n/*\nदिए गए सूची में सम संख्याओं का योग गणना करें।\n    पैरामीटर्स:\n- numbers (list): पूर्णांकों की एक सूची।\n- size (int): सूची का आकार।\n    रिटर्न करता है:\n    int: इनपुट सूची में सम संख्याओं का योग।\n    >>> f_10([1,4,3,2,5], 5)\n    6\n*/\nint f_10(int *numbers, int size); // Fixed declaration", "hu": "#include <assert.h>\n#include <stdio.h>\n/*\nSzámolja ki a páros számok összegét egy adott listában.\n    Paraméterek:\n- numbers (list): Egész számok listája.\n- size (int): A lista mérete.\n    Visszatérési érték:\n    int: A bemeneti listában található páros számok összege.\n    >>> f_10([1,4,3,2,5], 5)\n    6\n*/\nint f_10(int *numbers, int size); // Rögzített deklaráció", "es": "#include <assert.h>\n#include <stdio.h>\n/*\nCalcular la suma de los números pares en una lista dada.\n    Parámetros:\n- numbers (list): Una lista de enteros.\n- size (int): El tamaño de la lista.\n    Devuelve:\n    int: La suma de los números pares en la lista de entrada.\n    >>> f_10([1,4,3,2,5], 5)\n    6\n*/\nint f_10(int *numbers, int size); // Fixed declaration", "arb": "#include <assert.h>\n#include <stdio.h>\n/*\nحساب مجموع الأرقام الزوجية في قائمة معينة.\n    المعاملات:\n- numbers (list): قائمة من الأعداد الصحيحة.\n- size (int): حجم القائمة.\n    يعيد:\n    int: مجموع الأرقام الزوجية في القائمة المدخلة.\n    >>> f_10([1,4,3,2,5], 5)\n    6\n*/\nint f_10(int *numbers, int size); // Fixed declaration", "sw": "#include <assert.h>\n#include <stdio.h>\n/*\nHesabu jumla ya nambari shufwa katika orodha iliyotolewa.\n    Vigezo:\n- numbers (list): Orodha ya nambari kamili.\n- size (int): Ukubwa wa orodha.\n    Inarudisha:\n    int: Jumla ya nambari shufwa katika orodha ya ingizo.\n    >>> f_10([1,4,3,2,5], 5)\n    6\n*/\nint f_10(int *numbers, int size); // Fixed declaration", "tr": "#include <assert.h>\n#include <stdio.h>\n/*\nVerilen bir listedeki çift sayıların toplamını hesapla.\n    Parametreler:\n- numbers (list): Bir tamsayı listesi.\n- size (int): Listenin boyutu.\n    Döndürür:\n    int: Girdi listesindeki çift sayıların toplamı.\n    >>> f_10([1,4,3,2,5], 5)\n    6\n*/\nint f_10(int *numbers, int size); // Sabit bildirim", "vi": "#include <assert.h>\n#include <stdio.h>\n/*\nTính tổng các số chẵn trong một danh sách cho trước.\n    Tham số:\n- numbers (list): Một danh sách các số nguyên.\n- size (int): Kích thước của danh sách.\n    Trả về:\n    int: Tổng các số chẵn trong danh sách đầu vào.\n    >>> f_10([1,4,3,2,5], 5)\n    6\n*/\nint f_10(int *numbers, int size); // Fixed declaration", "id": "#include <assert.h>\n#include <stdio.h>\n/*\nMenghitung jumlah bilangan genap dalam daftar yang diberikan.\n    Parameter:\n- numbers (list): Sebuah daftar bilangan bulat.\n- size (int): Ukuran dari daftar.\n    Mengembalikan:\n    int: Jumlah bilangan genap dalam daftar input.\n    >>> f_10([1,4,3,2,5], 5)\n    6\n*/\nint f_10(int *numbers, int size); // Deklarasi tetap", "ja": "#include <assert.h>\n#include <stdio.h>\n/*\n与えられたリスト内の偶数の合計を計算します。\n    パラメータ:\n- numbers (list): 整数のリスト。\n- size (int): リストのサイズ。\n    戻り値:\n    int: 入力リスト内の偶数の合計。\n    >>> f_10([1,4,3,2,5], 5)\n    6\n*/\nint f_10(int *numbers, int size); // Fixed declaration", "ko": "#include <assert.h>\n#include <stdio.h>\n/*\n주어진 리스트에서 짝수의 합을 계산합니다.\n    매개변수:\n- numbers (list): 정수의 리스트.\n- size (int): 리스트의 크기.\n    반환값:\n    int: 입력 리스트에서 짝수의 합.\n    >>> f_10([1,4,3,2,5], 5)\n    6\n*/\nint f_10(int *numbers, int size); // 고정된 선언", "ml": "#include <assert.h>\n#include <stdio.h>\n/*\nഒരു നൽകിയ ലിസ്റ്റിലെ സമവായ സംഖ്യകളുടെ മൊത്തം കണക്കാക്കുക.\n    പാരാമീറ്ററുകൾ:\n- numbers (list): പൂർണ്ണസംഖ്യകളുടെ ഒരു ലിസ്റ്റ്.\n- size (int): ലിസ്റ്റിന്റെ വലുപ്പം.\n    മടങ്ങിവരവ്:\n    int: ഇൻപുട്ട് ലിസ്റ്റിലെ സമവായ സംഖ്യകളുടെ മൊത്തം.\n    >>> f_10([1,4,3,2,5], 5)\n    6\n*/\nint f_10(int *numbers, int size); // Fixed declaration", "fa": "#include <assert.h>\n#include <stdio.h>\n/*\nمحاسبه مجموع اعداد زوج در یک لیست داده شده.\n    پارامترها:\n- numbers (list): یک لیست از اعداد صحیح.\n- size (int): اندازه لیست.\n    بازگشت:\n    int: مجموع اعداد زوج در لیست ورودی.\n    >>> f_10([1,4,3,2,5], 5)\n    6\n*/\nint f_10(int *numbers, int size); // Fixed declaration"}, "canonical_solution": "int f_10(int *numbers, int size) { // Fixed solution\n    int ans = 0;\n    for (int i = 0; i < size; i++) {\n        if ((numbers[i] & 1) == 0) { // Only sum the even numbers\n            ans += numbers[i];\n        }\n    }\n    return ans;\n}", "instruction": {"en": "int f_10(int *numbers, int size)\nint f_10(int *numbers, int size) { // Fixed solution\n    int ans = 0;\n    for (int i = 0; i < size; i++) {\n        if ((numbers[i] & 1) == 0) { // Only sum the even numbers\n            ans += numbers[i];\n        }\n    }\n    return ans;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "sq": "int f_10(int *numbers, int size)\nint f_10(int *numbers, int size) { // Fixed solution\n    int ans = 0;\n    for (int i = 0; i < size; i++) {\n        if ((numbers[i] & 1) == 0) { // Only sum the even numbers\n            ans += numbers[i];\n        }\n    }\n    return ans;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C në gjuhën shqipe duke përdorur maksimumi 500 karaktere.", "hy": "int f_10(int *numbers, int size)\nint f_10(int *numbers, int size) { // Fixed solution\n    int ans = 0;\n    for (int i = 0; i < size; i++) {\n        if ((numbers[i] & 1) == 0) { // Only sum the even numbers\n            ans += numbers[i];\n        }\n    }\n    return ans;\n}\n\nՏվեք C կոդի հակիրճ բնութագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "int f_10(int *numbers, int size)\nint f_10(int *numbers, int size) { // Fixed solution\n    int ans = 0;\n    for (int i = 0; i < size; i++) {\n        if ((numbers[i] & 1) == 0) { // Only sum the even numbers\n            ans += numbers[i];\n        }\n    }\n    return ans;\n}\n\nসি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।", "bg": "int f_10(int *numbers, int size)\nint f_10(int *numbers, int size) { // Fixed solution\n    int ans = 0;\n    for (int i = 0; i < size; i++) {\n        if ((numbers[i] & 1) == 0) { // Only sum the even numbers\n            ans += numbers[i];\n        }\n    }\n    return ans;\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, използвайки не повече от 500 знака.", "zh": "int f_10(int *numbers, int size)\nint f_10(int *numbers, int size) { // Fixed solution\n    int ans = 0;\n    for (int i = 0; i < size; i++) {\n        if ((numbers[i] & 1) == 0) { // Only sum the even numbers\n            ans += numbers[i];\n        }\n    }\n    return ans;\n}\n\n请用不超过500个字符的中文，为以下C代码提供简洁的自然语言描述（文档字符串）。", "fr": "int f_10(int *numbers, int size)\nint f_10(int *numbers, int size) { // Fixed solution\n    int ans = 0;\n    for (int i = 0; i < size; i++) {\n        if ((numbers[i] & 1) == 0) { // Only sum the even numbers\n            ans += numbers[i];\n        }\n    }\n    return ans;\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.", "de": "int f_10(int *numbers, int size)\nint f_10(int *numbers, int size) { // Fixed solution\n    int ans = 0;\n    for (int i = 0; i < size; i++) {\n        if ((numbers[i] & 1) == 0) { // Only sum the even numbers\n            ans += numbers[i];\n        }\n    }\n    return ans;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen.", "ha": "int f_10(int *numbers, int size)\nint f_10(int *numbers, int size) { // Fixed solution\n    int ans = 0;\n    for (int i = 0; i < size; i++) {\n        if ((numbers[i] & 1) == 0) { // Only sum the even numbers\n            ans += numbers[i];\n        }\n    }\n    return ans;\n}\n\nBa da takaitaccen bayani a cikin yare na halitta (docstring) na lambar C a cikin Hausa, ba tare da wuce haruffa 500 ba.", "hi": "int f_10(int *numbers, int size)\nint f_10(int *numbers, int size) { // Fixed solution\n    int ans = 0;\n    for (int i = 0; i < size; i++) {\n        if ((numbers[i] & 1) == 0) { // Only sum the even numbers\n            ans += numbers[i];\n        }\n    }\n    return ans;\n}\n\nC कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "int f_10(int *numbers, int size)\nint f_10(int *numbers, int size) { // Fixed solution\n    int ans = 0;\n    for (int i = 0; i < size; i++) {\n        if ((numbers[i] & 1) == 0) { // Only sum the even numbers\n            ans += numbers[i];\n        }\n    }\n    return ans;\n}\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben.", "es": "int f_10(int *numbers, int size)\nint f_10(int *numbers, int size) { // Fixed solution\n    int ans = 0;\n    for (int i = 0; i < size; i++) {\n        if ((numbers[i] & 1) == 0) { // Only sum the even numbers\n            ans += numbers[i];\n        }\n    }\n    return ans;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando un máximo de 500 caracteres.", "arb": "int f_10(int *numbers, int size)\nint f_10(int *numbers, int size) { // Fixed solution\n    int ans = 0;\n    for (int i = 0; i < size; i++) {\n        if ((numbers[i] & 1) == 0) { // Only sum the even numbers\n            ans += numbers[i];\n        }\n    }\n    return ans;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشيفرة البرمجية المكتوبة بلغة C باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "int f_10(int *numbers, int size)\nint f_10(int *numbers, int size) { // Fixed solution\n    int ans = 0;\n    for (int i = 0; i < size; i++) {\n        if ((numbers[i] & 1) == 0) { // Only sum the even numbers\n            ans += numbers[i];\n        }\n    }\n    return ans;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "int f_10(int *numbers, int size)\nint f_10(int *numbers, int size) { // Fixed solution\n    int ans = 0;\n    for (int i = 0; i < size; i++) {\n        if ((numbers[i] & 1) == 0) { // Only sum the even numbers\n            ans += numbers[i];\n        }\n    }\n    return ans;\n}\n\nC kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe olarak yazılmalıdır.", "vi": "int f_10(int *numbers, int size)\nint f_10(int *numbers, int size) { // Fixed solution\n    int ans = 0;\n    for (int i = 0; i < size; i++) {\n        if ((numbers[i] & 1) == 0) { // Only sum the even numbers\n            ans += numbers[i];\n        }\n    }\n    return ans;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã C bằng tiếng Việt với tối đa 500 ký tự.", "id": "int f_10(int *numbers, int size)\nint f_10(int *numbers, int size) { // Fixed solution\n    int ans = 0;\n    for (int i = 0; i < size; i++) {\n        if ((numbers[i] & 1) == 0) { // Only sum the even numbers\n            ans += numbers[i];\n        }\n    }\n    return ans;\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode C dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "int f_10(int *numbers, int size)\nint f_10(int *numbers, int size) { // Fixed solution\n    int ans = 0;\n    for (int i = 0; i < size; i++) {\n        if ((numbers[i] & 1) == 0) { // Only sum the even numbers\n            ans += numbers[i];\n        }\n    }\n    return ans;\n}\n\nC コードの簡単な自然言語による説明 (docstring) を英語で最大 500 文字まで入力してください。", "ko": "int f_10(int *numbers, int size)\nint f_10(int *numbers, int size) { // Fixed solution\n    int ans = 0;\n    for (int i = 0; i < size; i++) {\n        if ((numbers[i] & 1) == 0) { // Only sum the even numbers\n            ans += numbers[i];\n        }\n    }\n    return ans;\n}\n\nC 코드의 동작을 설명하는 간결한 자연어 설명(docstring)을 한국어로 작성하세요. 최대 500자까지 가능합니다.", "ml": "int f_10(int *numbers, int size)\nint f_10(int *numbers, int size) { // Fixed solution\n    int ans = 0;\n    for (int i = 0; i < size; i++) {\n        if ((numbers[i] & 1) == 0) { // Only sum the even numbers\n            ans += numbers[i];\n        }\n    }\n    return ans;\n}\n\nസിയുടെ കോഡിന് 500 അക്ഷരങ്ങളിൽ കവിയാതെ മലയാളത്തിൽ സംക്ഷിപ്തമായ ഒരു സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) നൽകുക.", "fa": "int f_10(int *numbers, int size)\nint f_10(int *numbers, int size) { // Fixed solution\n    int ans = 0;\n    for (int i = 0; i < size; i++) {\n        if ((numbers[i] & 1) == 0) { // Only sum the even numbers\n            ans += numbers[i];\n        }\n    }\n    return ans;\n}\n\nیک توضیح مختصر به زبان طبیعی (docstring) از کد C به زبان فارسی ارائه دهید که حداکثر ۵۰۰ کاراکتر باشد."}, "level": "", "test": "int main() {\n    int sample1[] = {1, 4, 3, 2, 5};\n    int sample2[] = {2, 2, 0, 0};\n    int sample3[] = {7, 11, 19}; // Additional test with no even numbers\n    int sample4[] = {12, 14, 16, 18, 20}; // Additional test with all even numbers\n\n    assert(f_10(sample1, 5) == 6);\n    assert(f_10(sample2, 4) == 4);\n    assert(f_10(sample3, 3) == 0); // Should return 0 because there are no even numbers\n    assert(f_10(sample4, 5) == 12 + 14 + 16 + 18 + 20);\n\n    \n\n    return 0;\n}", "entry_point": "f_10", "signature": "int f_10(int *numbers, int size)", "docstring": {"en": "Calculate the sum of even numbers in a given list.\n    Parameters:\n- numbers (list): A list of integers.\n- size (int): The size of the list.\n    Returns:\n    int: The sum of even numbers in the input list.\n    >>> f_10([1,4,3,2,5], 5)\n    6\n", "sq": "Llogarit shumën e numrave çift në një listë të dhënë.\n    Parametrat:\n- numbers (list): Një listë e numrave të plotë.\n- size (int): Madhësia e listës.\n    Kthen:\n    int: Shuma e numrave çift në listën hyrëse.\n    >>> f_10([1,4,3,2,5], 5)\n    6", "hy": "Հաշվել տրված ցուցակի զույգ թվերի գումարը։\n    Պարամետրեր:\n- numbers (list): ամբողջ թվերի ցուցակ։\n- size (int): ցուցակի չափը։\n    Վերադարձնում է:\n    int: մուտքային ցուցակի զույգ թվերի գումարը։\n    >>> f_10([1,4,3,2,5], 5)\n    6", "bn": "দেওয়া তালিকায় জোড় সংখ্যাগুলির যোগফল গণনা করুন।\n    প্যারামিটারসমূহ:\n- numbers (list): পূর্ণসংখ্যার একটি তালিকা।\n- size (int): তালিকার আকার।\n    রিটার্নস:\n    int: ইনপুট তালিকায় জোড় সংখ্যাগুলির যোগফল।\n    >>> f_10([1,4,3,2,5], 5)\n    6", "bg": "Изчисляване на сумата от четни числа в даден списък.\n    Параметри:\n- numbers (list): Списък от цели числа.\n- size (int): Размерът на списъка.\n    Връща:\n    int: Сумата от четните числа в входния списък.\n    >>> f_10([1,4,3,2,5], 5)\n    6", "zh": "计算给定列表中偶数的和。\n    参数：\n- numbers (list): 整数列表。\n- size (int): 列表的大小。\n    返回：\n    int: 输入列表中偶数的和。\n    >>> f_10([1,4,3,2,5], 5)\n    6", "fr": "Calculer la somme des nombres pairs dans une liste donnée.\n    Paramètres:\n- numbers (list): Une liste d'entiers.\n- size (int): La taille de la liste.\n    Renvoie:\n    int: La somme des nombres pairs dans la liste d'entrée.\n    >>> f_10([1,4,3,2,5], 5)\n    6", "de": "Berechne die Summe der geraden Zahlen in einer gegebenen Liste.\n    Parameter:\n- numbers (list): Eine Liste von ganzen Zahlen.\n- size (int): Die Größe der Liste.\n    Rückgabe:\n    int: Die Summe der geraden Zahlen in der Eingabeliste.\n    >>> f_10([1,4,3,2,5], 5)\n    6", "ha": "Ƙididdige jimillar lambobin da ke daidai a cikin jerin da aka bayar.\n    Ma'auni:\n- numbers (list): Jerin lambobi.\n- size (int): Girman jerin.\n    Mayarwa:\n    int: Jimillar lambobin da ke daidai a cikin jerin shigarwa.\n    >>> f_10([1,4,3,2,5], 5)\n    6", "hi": "दिए गए सूची में सम संख्या का योग गणना करें।\n    पैरामीटर्स:\n- numbers (list): पूर्णांकों की एक सूची।\n- size (int): सूची का आकार।\n    रिटर्न्स:\n    int: इनपुट सूची में सम संख्याओं का योग।\n    >>> f_10([1,4,3,2,5], 5)\n    6", "hu": "Számítsa ki a páros számok összegét egy adott listában.\n    Paraméterek:\n- numbers (list): Egész számok listája.\n- size (int): A lista mérete.\n    Visszatér:\n    int: A bemeneti listában található páros számok összege.\n    >>> f_10([1,4,3,2,5], 5)\n    6", "es": "Calcular la suma de los números pares en una lista dada.\n    Parámetros:\n- numbers (list): Una lista de enteros.\n- size (int): El tamaño de la lista.\n    Devuelve:\n    int: La suma de los números pares en la lista de entrada.\n    >>> f_10([1,4,3,2,5], 5)\n    6", "arb": "حساب مجموع الأعداد الزوجية في قائمة معينة.\n    المعاملات:\n- numbers (list): قائمة من الأعداد الصحيحة.\n- size (int): حجم القائمة.\n    يعيد:\n    int: مجموع الأعداد الزوجية في القائمة المدخلة.\n    >>> f_10([1,4,3,2,5], 5)\n    6", "sw": "Hesabu jumla ya namba shufwa katika orodha iliyotolewa.\n    Vigezo:\n- numbers (list): Orodha ya namba nzima.\n- size (int): Ukubwa wa orodha.\n    Inarejesha:\n    int: Jumla ya namba shufwa katika orodha iliyoingizwa.\n    >>> f_10([1,4,3,2,5], 5)\n    6", "tr": "Verilen bir listedeki çift sayıların toplamını hesaplayın.\n    Parametreler:\n- numbers (list): Bir tamsayı listesi.\n- size (int): Listenin boyutu.\n    Döndürür:\n    int: Girdi listesindeki çift sayıların toplamı.\n    >>> f_10([1,4,3,2,5], 5)\n    6", "vi": "Tính tổng các số chẵn trong một danh sách cho trước.\n    Tham số:\n- numbers (list): Một danh sách các số nguyên.\n- size (int): Kích thước của danh sách.\n    Trả về:\n    int: Tổng các số chẵn trong danh sách đầu vào.\n    >>> f_10([1,4,3,2,5], 5)\n    6", "id": "Hitung jumlah bilangan genap dalam daftar yang diberikan.\n    Parameter:\n- numbers (list): Daftar bilangan bulat.\n- size (int): Ukuran daftar.\n    Mengembalikan:\n    int: Jumlah bilangan genap dalam daftar input.\n    >>> f_10([1,4,3,2,5], 5)\n    6", "ja": "与えられたリスト内の偶数の合計を計算します。\n    パラメータ:\n- numbers (list): 整数のリスト。\n- size (int): リストのサイズ。\n    戻り値:\n    int: 入力リスト内の偶数の合計。\n    >>> f_10([1,4,3,2,5], 5)\n    6", "ko": "주어진 리스트에서 짝수의 합을 계산합니다.\n    매개변수:\n- numbers (list): 정수의 리스트.\n- size (int): 리스트의 크기.\n    반환:\n    int: 입력 리스트에서 짝수의 합.\n    >>> f_10([1,4,3,2,5], 5)\n    6", "ml": "നൽകിയ പട്ടികയിലെ സമവായ സംഖ്യകളുടെ മൊത്തം മൂല്യം കണക്കാക്കുക.\n    പാരാമീറ്ററുകൾ:\n- numbers (list): പൂർണ്ണസംഖ്യകളുടെ പട്ടിക.\n- size (int): പട്ടികയുടെ വലിപ്പം.\n    മടക്കൽ:\n    int: ഇൻപുട്ട് പട്ടികയിലെ സമവായ സംഖ്യകളുടെ മൊത്തം മൂല്യം.\n    >>> f_10([1,4,3,2,5], 5)\n    6", "fa": "محاسبه مجموع اعداد زوج در یک لیست داده شده.\n    پارامترها:\n- numbers (list): یک لیست از اعداد صحیح.\n- size (int): اندازه لیست.\n    بازگشت:\n    int: مجموع اعداد زوج در لیست ورودی.\n    >>> f_10([1,4,3,2,5], 5)\n    6"}}
{"task_id": "C/11", "prompt": {"en": "#include <assert.h>\n#include <stdio.h>\n/*\nDetermine if two closed intervals intersect.\n​    Args:\n​    a, b: Representing the first closed interval [a, b] where 0 <= a <= b <= 1000.\n​    c, d: Representing the second closed interval [c, d] where 0 <= c <= d <= 1000.\n​    Returns:\n​    int: 1 if the intervals intersect, 0 otherwise.\n*/\nint are_intervals_intersecting(int a, int b, int c, int d)", "sq": "#include <assert.h>\n#include <stdio.h>\n/*\nPërcaktoni nëse dy intervale të mbyllura ndërpriten.\n​    Argumentet:\n​    a, b: Përfaqësojnë intervalin e parë të mbyllur [a, b] ku 0 <= a <= b <= 1000.\n​    c, d: Përfaqësojnë intervalin e dytë të mbyllur [c, d] ku 0 <= c <= d <= 1000.\n​    Kthen:\n​    int: 1 nëse intervalet ndërpriten, 0 përndryshe.\n*/\nint are_intervals_intersecting(int a, int b, int c, int d)", "hy": "#include <assert.h>\n#include <stdio.h>\n/*\nՊարզել՝ արդյոք երկու փակ միջակայքեր հատվում են:\n​    Արգումենտներ:\n​    a, b: Ներկայացնում են առաջին փակ միջակայքը [a, b], որտեղ 0 <= a <= b <= 1000:\n​    c, d: Ներկայացնում են երկրորդ փակ միջակայքը [c, d], որտեղ 0 <= c <= d <= 1000:\n​    Վերադարձնում է:\n​    int: 1, եթե միջակայքերը հատվում են, 0՝ հակառակ դեպքում:\n*/\nint are_intervals_intersecting(int a, int b, int c, int d)", "bn": "#include <assert.h>\n#include <stdio.h>\n/*\nদুটি বন্ধ ইন্টারভাল ছেদ করে কিনা নির্ধারণ করুন।\n​    আর্গুমেন্ট:\n​    a, b: প্রথম বন্ধ ইন্টারভাল [a, b] প্রতিনিধিত্ব করছে যেখানে 0 <= a <= b <= 1000।\n​    c, d: দ্বিতীয় বন্ধ ইন্টারভাল [c, d] প্রতিনিধিত্ব করছে যেখানে 0 <= c <= d <= 1000।\n​    রিটার্নস:\n​    int: ইন্টারভালগুলি ছেদ করলে 1, অন্যথায় 0।\n*/\nint are_intervals_intersecting(int a, int b, int c, int d)", "bg": "#include <assert.h>\n#include <stdio.h>\n/*\nОпределете дали два затворени интервала се пресичат.\n​    Аргументи:\n​    a, b: Представлява първия затворен интервал [a, b], където 0 <= a <= b <= 1000.\n​    c, d: Представлява втория затворен интервал [c, d], където 0 <= c <= d <= 1000.\n​    Връща:\n​    int: 1 ако интервалите се пресичат, 0 в противен случай.\n*/\nint are_intervals_intersecting(int a, int b, int c, int d)", "zh": "#include <assert.h>\n#include <stdio.h>\n/*\n确定两个闭区间是否相交。\n    参数:\n    a, b: 表示第一个闭区间 [a, b]，其中 0 <= a <= b <= 1000。\n    c, d: 表示第二个闭区间 [c, d]，其中 0 <= c <= d <= 1000。\n    返回:\n    int: 如果区间相交返回 1，否则返回 0。\n*/\nint are_intervals_intersecting(int a, int b, int c, int d)", "fr": "#include <assert.h>\n#include <stdio.h>\n/*\nDéterminer si deux intervalles fermés s'intersectent.\n​    Args:\n​    a, b: Représentant le premier intervalle fermé [a, b] où 0 <= a <= b <= 1000.\n​    c, d: Représentant le deuxième intervalle fermé [c, d] où 0 <= c <= d <= 1000.\n​    Retourne:\n​    int: 1 si les intervalles s'intersectent, 0 sinon.\n*/\nint are_intervals_intersecting(int a, int b, int c, int d)", "de": "#include <assert.h>\n#include <stdio.h>\n/*\nBestimmen, ob zwei abgeschlossene Intervalle sich überschneiden.\n​    Argumente:\n​    a, b: Repräsentieren das erste abgeschlossene Intervall [a, b], wobei 0 <= a <= b <= 1000.\n​    c, d: Repräsentieren das zweite abgeschlossene Intervall [c, d], wobei 0 <= c <= d <= 1000.\n​    Rückgabe:\n​    int: 1, wenn die Intervalle sich überschneiden, 0 andernfalls.\n*/\nint are_intervals_intersecting(int a, int b, int c, int d)", "ha": "#include <assert.h>\n#include <stdio.h>\n/*\nKayyade idan tazara biyu masu rufewa suna haduwa.\n​    Args:\n​    a, b: Wakiltar tazara na farko mai rufewa [a, b] inda 0 <= a <= b <= 1000.\n​    c, d: Wakiltar tazara na biyu mai rufewa [c, d] inda 0 <= c <= d <= 1000.\n​    Returns:\n​    int: 1 idan tazarorin suna haduwa, 0 in ba haka ba.\n*/\nint are_intervals_intersecting(int a, int b, int c, int d)", "hi": "#include <assert.h>\n#include <stdio.h>\n/*\nनिर्धारित करें कि क्या दो बंद अंतराल परस्पर हैं।\n​    तर्क:\n​    a, b: पहले बंद अंतराल [a, b] का प्रतिनिधित्व करते हैं जहां 0 <= a <= b <= 1000।\n​    c, d: दूसरे बंद अंतराल [c, d] का प्रतिनिधित्व करते हैं जहां 0 <= c <= d <= 1000।\n​    वापसी:\n​    int: 1 यदि अंतराल परस्पर हैं, अन्यथा 0।\n*/\nint are_intervals_intersecting(int a, int b, int c, int d)", "hu": "#include <assert.h>\n#include <stdio.h>\n/*\nHatározza meg, hogy két zárt intervallum metszi-e egymást.\n​    Args:\n​    a, b: Az első zárt intervallumot [a, b] képviselik, ahol 0 <= a <= b <= 1000.\n​    c, d: A második zárt intervallumot [c, d] képviselik, ahol 0 <= c <= d <= 1000.\n​    Visszatérési érték:\n​    int: 1, ha az intervallumok metszik egymást, 0 különben.\n*/\nint are_intervals_intersecting(int a, int b, int c, int d)", "es": "#include <assert.h>\n#include <stdio.h>\n/*\nDeterminar si dos intervalos cerrados se intersectan.\n​    Args:\n​    a, b: Representando el primer intervalo cerrado [a, b] donde 0 <= a <= b <= 1000.\n​    c, d: Representando el segundo intervalo cerrado [c, d] donde 0 <= c <= d <= 1000.\n​    Retorna:\n​    int: 1 si los intervalos se intersectan, 0 de lo contrario.\n*/\nint are_intervals_intersecting(int a, int b, int c, int d)", "arb": "#include <assert.h>\n#include <stdio.h>\n/*\nتحديد ما إذا كان هناك تقاطع بين فترتين مغلقتين.\n​    Args:\n​    a, b: تمثل الفترة المغلقة الأولى [a, b] حيث 0 <= a <= b <= 1000.\n​    c, d: تمثل الفترة المغلقة الثانية [c, d] حيث 0 <= c <= d <= 1000.\n​    Returns:\n​    int: 1 إذا كانت الفترات تتقاطع، 0 خلاف ذلك.\n*/\nint are_intervals_intersecting(int a, int b, int c, int d)", "sw": "#include <assert.h>\n#include <stdio.h>\n/*\nTambua kama vipindi viwili vilivyofungwa vinakatana.\n​    Args:\n​    a, b: Inawakilisha kipindi cha kwanza kilichofungwa [a, b] ambapo 0 <= a <= b <= 1000.\n​    c, d: Inawakilisha kipindi cha pili kilichofungwa [c, d] ambapo 0 <= c <= d <= 1000.\n​    Inarudisha:\n​    int: 1 ikiwa vipindi vinakatana, 0 vinginevyo.\n*/\nint are_intervals_intersecting(int a, int b, int c, int d)", "tr": "#include <assert.h>\n#include <stdio.h>\n/*\nİki kapalı aralığın kesişip kesişmediğini belirleyin.\n​    Args:\n​    a, b: İlk kapalı aralığı [a, b] temsil eder, burada 0 <= a <= b <= 1000.\n​    c, d: İkinci kapalı aralığı [c, d] temsil eder, burada 0 <= c <= d <= 1000.\n​    Döndürür:\n​    int: Aralıklar kesişiyorsa 1, aksi takdirde 0.\n*/\nint are_intervals_intersecting(int a, int b, int c, int d)", "vi": "#include <assert.h>\n#include <stdio.h>\n/*\nXác định xem hai khoảng đóng có giao nhau hay không.\n​    Args:\n​    a, b: Đại diện cho khoảng đóng đầu tiên [a, b] với điều kiện 0 <= a <= b <= 1000.\n​    c, d: Đại diện cho khoảng đóng thứ hai [c, d] với điều kiện 0 <= c <= d <= 1000.\n​    Trả về:\n​    int: 1 nếu các khoảng giao nhau, 0 nếu không.\n*/\nint are_intervals_intersecting(int a, int b, int c, int d)", "id": "#include <assert.h>\n#include <stdio.h>\n/*\nMenentukan apakah dua interval tertutup saling berpotongan.\n​    Argumen:\n​    a, b: Mewakili interval tertutup pertama [a, b] di mana 0 <= a <= b <= 1000.\n​    c, d: Mewakili interval tertutup kedua [c, d] di mana 0 <= c <= d <= 1000.\n​    Mengembalikan:\n​    int: 1 jika interval saling berpotongan, 0 jika tidak.\n*/\nint are_intervals_intersecting(int a, int b, int c, int d)", "ja": "#include <assert.h>\n#include <stdio.h>\n/*\n二つの閉区間が交差するかどうかを判断します。\n​    引数:\n​    a, b: 最初の閉区間 [a, b] を表します。ここで 0 <= a <= b <= 1000。\n​    c, d: 二番目の閉区間 [c, d] を表します。ここで 0 <= c <= d <= 1000。\n​    戻り値:\n​    int: 区間が交差する場合は 1、そうでない場合は 0。\n*/\nint are_intervals_intersecting(int a, int b, int c, int d)", "ko": "#include <assert.h>\n#include <stdio.h>\n/*\n두 닫힌 구간이 교차하는지 확인합니다.\n​    인자:\n​    a, b: 첫 번째 닫힌 구간 [a, b]을 나타내며, 0 <= a <= b <= 1000입니다.\n​    c, d: 두 번째 닫힌 구간 [c, d]을 나타내며, 0 <= c <= d <= 1000입니다.\n​    반환값:\n​    int: 구간이 교차하면 1을, 그렇지 않으면 0을 반환합니다.\n*/\nint are_intervals_intersecting(int a, int b, int c, int d)", "ml": "#include <assert.h>\n#include <stdio.h>\n/*\nരണ്ട് അടച്ച ഇടവേളകൾ തമ്മിൽ മുറുകെ പിടിക്കുന്നുണ്ടോ എന്ന് നിർണയിക്കുക.\n​    Args:\n​    a, b: ആദ്യത്തെ അടച്ച ഇടവേള [a, b] പ്രതിനിധീകരിക്കുന്നു, ഇവിടെ 0 <= a <= b <= 1000.\n​    c, d: രണ്ടാം അടച്ച ഇടവേള [c, d] പ്രതിനിധീകരിക്കുന്നു, ഇവിടെ 0 <= c <= d <= 1000.\n​    Returns:\n​    int: ഇടവേളകൾ മുറുകെ പിടിക്കുന്നുണ്ടെങ്കിൽ 1, അല്ലെങ്കിൽ 0.\n*/\nint are_intervals_intersecting(int a, int b, int c, int d)", "fa": "#include <assert.h>\n#include <stdio.h>\n/*\nتعیین کنید که آیا دو بازه بسته با هم تلاقی دارند یا خیر.\n​    آرگومان‌ها:\n​    a, b: نمایانگر اولین بازه بسته [a, b] که در آن 0 <= a <= b <= 1000.\n​    c, d: نمایانگر دومین بازه بسته [c, d] که در آن 0 <= c <= d <= 1000.\n​    بازگشت:\n​    int: 1 اگر بازه‌ها تلاقی دارند، 0 در غیر این صورت.\n*/\nint are_intervals_intersecting(int a, int b, int c, int d)"}, "canonical_solution": "{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}", "instruction": {"en": "int are_intervals_intersecting(int a, int b, int c, int d)\n{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "sq": "int are_intervals_intersecting(int a, int b, int c, int d)\n{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C në shqip duke përdorur maksimumi 500 karaktere.", "hy": "int are_intervals_intersecting(int a, int b, int c, int d)\n{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}\n\nՏրամադրել C կոդի հակիրճ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "int are_intervals_intersecting(int a, int b, int c, int d)\n{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}\n\nসি কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষর ব্যবহার করে।", "bg": "int are_intervals_intersecting(int a, int b, int c, int d)\n{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}\n\nПредоставете кратко описание на C кода на естествен език (докстринг) на български, използвайки не повече от 500 знака.", "zh": "int are_intervals_intersecting(int a, int b, int c, int d)\n{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}\n\n请用中文为以下C代码提供简洁的自然语言描述（文档字符串），不超过500个字符。", "fr": "int are_intervals_intersecting(int a, int b, int c, int d)\n{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.", "de": "int are_intervals_intersecting(int a, int b, int c, int d)\n{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "int are_intervals_intersecting(int a, int b, int c, int d)\n{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar C cikin Hausa ta amfani da haruffa 500 kacal.", "hi": "int are_intervals_intersecting(int a, int b, int c, int d)\n{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}\n\nC कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "int are_intervals_intersecting(int a, int b, int c, int d)\n{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben.", "es": "int are_intervals_intersecting(int a, int b, int c, int d)\n{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando como máximo 500 caracteres.", "arb": "int are_intervals_intersecting(int a, int b, int c, int d)\n{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "int are_intervals_intersecting(int a, int b, int c, int d)\n{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "int are_intervals_intersecting(int a, int b, int c, int d)\n{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}\n\nVerilen C kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda, özlü bir doğal dil açıklaması (docstring) sağlayın.", "vi": "int are_intervals_intersecting(int a, int b, int c, int d)\n{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã C bằng tiếng Việt với tối đa 500 ký tự.", "id": "int are_intervals_intersecting(int a, int b, int c, int d)\n{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode C dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "int are_intervals_intersecting(int a, int b, int c, int d)\n{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}\n\nC コードの簡単な自然言語による説明 (docstring) を英語で最大 500 文字まで入力してください。", "ko": "int are_intervals_intersecting(int a, int b, int c, int d)\n{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}\n\nC 코드의 동작을 설명하는 간결한 자연어 설명(docstring)을 한국어로 제공하세요. 최대 500자 이내로 작성하십시오.", "ml": "int are_intervals_intersecting(int a, int b, int c, int d)\n{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}\n\nസിയുടെ കോഡ് ഉപയോഗിച്ച് 500 അക്ഷരങ്ങളിൽ കവിയാതെയുള്ള മലയാളത്തിൽ സംക്ഷിപ്തമായ സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) നൽകുക.", "fa": "int are_intervals_intersecting(int a, int b, int c, int d)\n{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}\n\nتوضیح مختصر و طبیعی (docstring) از کد C را به زبان فارسی با حداکثر ۵۰۰ کاراکتر ارائه دهید."}, "level": "", "test": "int main() {\n    assert(are_intervals_intersecting(1, 1, 1, 2) == 1);\n    assert(are_intervals_intersecting(3, 5, 2, 6) == 1);\n    assert(are_intervals_intersecting(3, 5, 4, 7) == 1);\n    assert(are_intervals_intersecting(3, 5, 6, 7) == 0);\n    // Additional test cases\n    assert(are_intervals_intersecting(0, 0, 0, 0) == 1);\n    assert(are_intervals_intersecting(1, 3, 2, 4) == 1);\n    assert(are_intervals_intersecting(1, 3, 4, 6) == 0);\n    assert(are_intervals_intersecting(10, 20, 20, 30) == 1);\n    assert(are_intervals_intersecting(10, 20, 21, 30) == 0);\n    \n    return 0;\n}", "entry_point": "are_intervals_intersecting", "signature": "int are_intervals_intersecting(int a, int b, int c, int d)", "docstring": {"en": "Determine if two closed intervals intersect.\n    Args:\n    a, b: Representing the first closed interval [a, b] where 0 <= a <= b <= 1000.\n    c, d: Representing the second closed interval [c, d] where 0 <= c <= d <= 1000.\n    Returns:\n    int: 1 if the intervals intersect, 0 otherwise.\n", "sq": "Përcaktoni nëse dy intervale të mbyllura ndërpriten.\n    Argumentet:\n    a, b: Përfaqësojnë intervalin e parë të mbyllur [a, b] ku 0 <= a <= b <= 1000.\n    c, d: Përfaqësojnë intervalin e dytë të mbyllur [c, d] ku 0 <= c <= d <= 1000.\n    Returns:\n    int: 1 nëse intervalet ndërpriten, 0 përndryshe.", "hy": "Երկու փակ միջակայքերի հատման որոշում։\n    Արձանագրումներ:\n    a, b: Ներկայացնում են առաջին փակ միջակայքը [a, b], որտեղ 0 <= a <= b <= 1000։\n    c, d: Ներկայացնում են երկրորդ փակ միջակայքը [c, d], որտեղ 0 <= c <= d <= 1000։\n    Վերադարձնում է:\n    int: 1, եթե միջակայքերը հատվում են, 0՝ հակառակ դեպքում։", "bn": "নির্ধারণ করুন দুটি বন্ধ ইন্টারভাল ছেদ করে কিনা।\n    আর্গুমেন্ট:\n    a, b: প্রথম বন্ধ ইন্টারভাল [a, b] উপস্থাপন করে যেখানে 0 <= a <= b <= 1000।\n    c, d: দ্বিতীয় বন্ধ ইন্টারভাল [c, d] উপস্থাপন করে যেখানে 0 <= c <= d <= 1000।\n    Returns:\n    int: 1 যদি ইন্টারভালগুলি ছেদ করে, অন্যথায় 0।", "bg": "Определете дали два затворени интервала се пресичат.\n    Аргументи:\n    a, b: Представляващи първия затворен интервал [a, b], където 0 <= a <= b <= 1000.\n    c, d: Представляващи втория затворен интервал [c, d], където 0 <= c <= d <= 1000.\n    Връща:\n    int: 1 ако интервалите се пресичат, 0 в противен случай.", "zh": "确定两个闭区间是否相交。\n    参数：\n    a, b: 表示第一个闭区间 [a, b]，其中 0 <= a <= b <= 1000。\n    c, d: 表示第二个闭区间 [c, d]，其中 0 <= c <= d <= 1000。\n    返回：\n    int: 如果区间相交则返回 1，否则返回 0。", "fr": "Déterminer si deux intervalles fermés s'intersectent.\n    Args:\n    a, b: Représentant le premier intervalle fermé [a, b] où 0 <= a <= b <= 1000.\n    c, d: Représentant le deuxième intervalle fermé [c, d] où 0 <= c <= d <= 1000.\n    Returns:\n    int: 1 si les intervalles s'intersectent, 0 sinon.", "de": "Bestimmen, ob zwei abgeschlossene Intervalle sich überschneiden.\n    Argumente:\n    a, b: Repräsentiert das erste abgeschlossene Intervall [a, b], wobei 0 <= a <= b <= 1000.\n    c, d: Repräsentiert das zweite abgeschlossene Intervall [c, d], wobei 0 <= c <= d <= 1000.\n    Returns:\n    int: 1, wenn die Intervalle sich überschneiden, 0 andernfalls.", "ha": "Kayyade idan tsaka-tsakin rufe guda biyu suna haduwa.\n    Args:\n    a, b: Wakiltar farkon rufaffiyar tazara [a, b] inda 0 <= a <= b <= 1000.\n    c, d: Wakiltar tazara ta biyu rufaffiya [c, d] inda 0 <= c <= d <= 1000.\n    Returns:\n    int: 1 idan tazarorin sun yi karo, 0 in ba haka ba.", "hi": "दो बंद अंतरालों के प्रतिच्छेदन का निर्धारण करें।\n    तर्क:\n    a, b: पहले बंद अंतराल [a, b] का प्रतिनिधित्व करते हैं जहाँ 0 <= a <= b <= 1000।\n    c, d: दूसरे बंद अंतराल [c, d] का प्रतिनिधित्व करते हैं जहाँ 0 <= c <= d <= 1000।\n    वापसी:\n    int: 1 यदि अंतराल प्रतिच्छेद करते हैं, अन्यथा 0।", "hu": "Határozza meg, hogy két zárt intervallum metszi-e egymást.\n    Args:\n    a, b: Az első zárt intervallumot [a, b] képviselik, ahol 0 <= a <= b <= 1000.\n    c, d: A második zárt intervallumot [c, d] képviselik, ahol 0 <= c <= d <= 1000.\n    Returns:\n    int: 1, ha az intervallumok metszik egymást, különben 0.", "es": "Determinar si dos intervalos cerrados se intersectan.\n    Args:\n    a, b: Representando el primer intervalo cerrado [a, b] donde 0 <= a <= b <= 1000.\n    c, d: Representando el segundo intervalo cerrado [c, d] donde 0 <= c <= d <= 1000.\n    Returns:\n    int: 1 si los intervalos se intersectan, 0 en caso contrario.", "arb": "Determine if two closed intervals intersect.  \n    Args:  \n    a, b: تمثل الفترة المغلقة الأولى [a, b] حيث 0 <= a <= b <= 1000.  \n    c, d: تمثل الفترة المغلقة الثانية [c, d] حيث 0 <= c <= d <= 1000.  \n    Returns:  \n    int: 1 إذا كانت الفترات تتقاطع، 0 خلاف ذلك.  ", "sw": "Determine if two closed intervals intersect.\n    Args:\n    a, b: Inawakilisha kipengele cha kwanza kilichofungwa [a, b] ambapo 0 <= a <= b <= 1000.\n    c, d: Inawakilisha kipengele cha pili kilichofungwa [c, d] ambapo 0 <= c <= d <= 1000.\n    Returns:\n    int: 1 ikiwa vipengele vinaingiliana, 0 vinginevyo.", "tr": "Determine if two closed intervals intersect.\n    Args:\n    a, b: İlk kapalı aralığı temsil eden [a, b] burada 0 <= a <= b <= 1000.\n    c, d: İkinci kapalı aralığı temsil eden [c, d] burada 0 <= c <= d <= 1000.\n    Returns:\n    int: Aralıklar kesişiyorsa 1, aksi takdirde 0.", "vi": "Xác định xem hai khoảng đóng có giao nhau hay không.\n    Args:\n    a, b: Đại diện cho khoảng đóng đầu tiên [a, b] với 0 <= a <= b <= 1000.\n    c, d: Đại diện cho khoảng đóng thứ hai [c, d] với 0 <= c <= d <= 1000.\n    Trả về:\n    int: 1 nếu các khoảng giao nhau, 0 nếu không.", "id": "Menentukan apakah dua interval tertutup berpotongan.\n    Args:\n    a, b: Mewakili interval tertutup pertama [a, b] di mana 0 <= a <= b <= 1000.\n    c, d: Mewakili interval tertutup kedua [c, d] di mana 0 <= c <= d <= 1000.\n    Returns:\n    int: 1 jika interval berpotongan, 0 jika tidak.", "ja": "2つの閉区間が交差するかどうかを判定します。\n    引数:\n    a, b: 最初の閉区間 [a, b] を表します。ここで 0 <= a <= b <= 1000。\n    c, d: 2番目の閉区間 [c, d] を表します。ここで 0 <= c <= d <= 1000。\n    戻り値:\n    int: 区間が交差する場合は1、そうでない場合は0。", "ko": "두 닫힌 구간이 교차하는지 결정합니다.\n    Args:\n    a, b: 첫 번째 닫힌 구간 [a, b]을 나타내며, 0 <= a <= b <= 1000입니다.\n    c, d: 두 번째 닫힌 구간 [c, d]을 나타내며, 0 <= c <= d <= 1000입니다.\n    Returns:\n    int: 구간이 교차하면 1, 그렇지 않으면 0을 반환합니다.", "ml": "രണ്ട് അടച്ച ഇടവേളകൾ തമ്മിൽ മുറുകെ പിടിക്കുന്നുണ്ടോ എന്ന് നിർണയിക്കുക.\n    Args:\n    a, b: ആദ്യത്തെ അടച്ച ഇടവേള [a, b] പ്രതിനിധീകരിക്കുന്നു, ഇവിടെ 0 <= a <= b <= 1000.\n    c, d: രണ്ടാം അടച്ച ഇടവേള [c, d] പ്രതിനിധീകരിക്കുന്നു, ഇവിടെ 0 <= c <= d <= 1000.\n    Returns:\n    int: ഇടവേളകൾ തമ്മിൽ മുട്ടിയാൽ 1, അല്ലെങ്കിൽ 0.", "fa": "تعیین کنید که آیا دو بازه بسته با هم تلاقی دارند یا خیر.\n    آرگومان‌ها:\n    a, b: نشان‌دهنده اولین بازه بسته [a, b] که در آن 0 <= a <= b <= 1000.\n    c, d: نشان‌دهنده دومین بازه بسته [c, d] که در آن 0 <= c <= d <= 1000.\n    بازگشت:\n    int: 1 اگر بازه‌ها هم‌پوشانی داشته باشند، در غیر این صورت 0."}}
{"task_id": "C/12", "prompt": {"en": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nYou are given three digits a, b, c. Two of them are equal, but the third one is different from the other two. Find the value that occurs exactly once.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3\n*/\nint extraNumber(int a, int b, int c)", "sq": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nJu janë dhënë tre shifra a, b, c. Dy prej tyre janë të barabarta, por e treta është e ndryshme nga dy të tjerat. Gjeni vlerën që ndodh saktësisht një herë.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3\n*/\nint extraNumber(int a, int b, int c)", "hy": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nՁեզ տրված են երեք թվանշան a, b, c։ Նրանցից երկուսը հավասար են, բայց երրորդը տարբերվում է մյուս երկուսից։ Գտեք այն արժեքը, որը հանդիպում է հենց մեկ անգամ։\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3\n*/\nint extraNumber(int a, int b, int c)", "bn": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nতোমাকে তিনটি অঙ্ক দেওয়া হয়েছে a, b, c। এদের মধ্যে দুটি সমান, কিন্তু তৃতীয়টি অন্য দুটি থেকে আলাদা। যে মানটি ঠিক একবার ঘটে সেটি খুঁজে বের করো।\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3\n*/\nint extraNumber(int a, int b, int c)", "bg": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nДадени са ви три цифри a, b, c. Две от тях са равни, но третата е различна от другите две. Намерете стойността, която се среща точно веднъж.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3\n*/\nint extraNumber(int a, int b, int c)", "zh": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\n给定三个数字 a, b, c。其中两个是相等的，但第三个与其他两个不同。找出只出现一次的值。\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3\n*/\nint extraNumber(int a, int b, int c)", "fr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nOn vous donne trois chiffres a, b, c. Deux d'entre eux sont égaux, mais le troisième est différent des deux autres. Trouvez la valeur qui apparaît exactement une fois.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3\n*/\nint extraNumber(int a, int b, int c)", "de": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nSie haben drei Ziffern a, b, c. Zwei von ihnen sind gleich, aber die dritte unterscheidet sich von den anderen beiden. Finden Sie den Wert, der genau einmal vorkommt.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3\n*/\nint extraNumber(int a, int b, int c)", "ha": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nAn ba ku lambobi uku a, b, c. Biyu daga cikinsu suna daidai, amma na ukun ya bambanta da sauran biyun. Nemo ƙimar da ta bayyana sau ɗaya kawai.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3\n*/\nint extraNumber(int a, int b, int c)", "hi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nआपको तीन अंक a, b, c दिए गए हैं। इनमें से दो समान हैं, लेकिन तीसरा अन्य दो से भिन्न है। उस मान को खोजें जो केवल एक बार आता है।\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3\n*/\nint extraNumber(int a, int b, int c)", "hu": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nHárom számjegy van megadva: a, b, c. Kettő közülük egyenlő, de a harmadik különbözik a másik kettőtől. Találd meg azt az értéket, amely pontosan egyszer fordul elő.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3\n*/\nint extraNumber(int a, int b, int c)", "es": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nSe te dan tres dígitos a, b, c. Dos de ellos son iguales, pero el tercero es diferente de los otros dos. Encuentra el valor que aparece exactamente una vez.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3\n*/\nint extraNumber(int a, int b, int c)", "arb": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nأنت تُعطى ثلاثة أرقام a، b، c. اثنان منهما متساويان، لكن الثالث مختلف عن الآخرين. جد القيمة التي تظهر مرة واحدة فقط.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3\n*/\nint extraNumber(int a, int b, int c)", "sw": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nUnapewa tarakimu tatu a, b, c. Mbili kati ya hizo ni sawa, lakini ya tatu ni tofauti na zile nyingine mbili. Tafuta thamani inayotokea mara moja tu.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3\n*/\nint extraNumber(int a, int b, int c)", "tr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nÜç basamak a, b, c verilir. İkisi eşittir, ancak üçüncüsü diğer ikisinden farklıdır. Tam olarak bir kez geçen değeri bulun.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3\n*/\nint extraNumber(int a, int b, int c)", "vi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nBạn được cung cấp ba chữ số a, b, c. Hai trong số đó bằng nhau, nhưng chữ số thứ ba khác với hai chữ số còn lại. Tìm giá trị xuất hiện chính xác một lần.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3\n*/\nint extraNumber(int a, int b, int c)", "id": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nAnda diberikan tiga digit a, b, c. Dua di antaranya sama, tetapi yang ketiga berbeda dari dua lainnya. Temukan nilai yang muncul tepat sekali.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3\n*/\nint extraNumber(int a, int b, int c)", "ja": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\n3つの数字 a, b, c が与えられます。そのうち2つは等しく、残りの1つは他の2つと異なります。ちょうど1回だけ出現する値を見つけてください。\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3\n*/\nint extraNumber(int a, int b, int c)", "ko": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\n세 숫자 a, b, c가 주어집니다. 이 중 두 숫자는 같고, 나머지 하나는 다른 두 숫자와 다릅니다. 정확히 한 번만 나타나는 값을 찾으세요.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3\n*/\nint extraNumber(int a, int b, int c)", "ml": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nനിങ്ങൾക്ക് മൂന്ന് അക്കങ്ങൾ a, b, c നൽകിയിരിക്കുന്നു. ഇവയിൽ രണ്ടെണ്ണം തുല്യമാണ്, എന്നാൽ മൂന്നാമത്തേത് മറ്റുള്ള രണ്ടെണ്ണത്തേക്കാൾ വ്യത്യസ്തമാണ്. ഒരിക്കൽ മാത്രം സംഭവിക്കുന്ന മൂല്യം കണ്ടെത്തുക.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3\n*/\nint extraNumber(int a, int b, int c)", "fa": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nسه رقم a، b، c به شما داده شده است. دو تا از آنها برابر هستند، اما سومی با دو تای دیگر متفاوت است. مقداری را پیدا کنید که دقیقا یک بار ظاهر می‌شود.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3\n*/\nint extraNumber(int a, int b, int c)"}, "canonical_solution": "{\n    if (a == b)\n        return c;\n    else if (a == c)\n        return b;\n    else\n        return a;\n}", "instruction": {"en": "int extraNumber(int a, int b, int c)\n{\n    if (a == b)\n        return c;\n    else if (a == c)\n        return b;\n    else\n        return a;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "sq": "int extraNumber(int a, int b, int c)\n{\n    if (a == b)\n        return c;\n    else if (a == c)\n        return b;\n    else\n        return a;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C në shqip duke përdorur maksimumi 500 karaktere.", "hy": "int extraNumber(int a, int b, int c)\n{\n    if (a == b)\n        return c;\n    else if (a == c)\n        return b;\n    else\n        return a;\n}\n\nՏվեք C կոդի հակիրճ բնութագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "int extraNumber(int a, int b, int c)\n{\n    if (a == b)\n        return c;\n    else if (a == c)\n        return b;\n    else\n        return a;\n}\n\nসি কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।", "bg": "int extraNumber(int a, int b, int c)\n{\n    if (a == b)\n        return c;\n    else if (a == c)\n        return b;\n    else\n        return a;\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, като използвате не повече от 500 знака.", "zh": "int extraNumber(int a, int b, int c)\n{\n    if (a == b)\n        return c;\n    else if (a == c)\n        return b;\n    else\n        return a;\n}\n\n请用不超过500个字符的中文，为以下C代码提供简洁的自然语言描述（文档字符串）。", "fr": "int extraNumber(int a, int b, int c)\n{\n    if (a == b)\n        return c;\n    else if (a == c)\n        return b;\n    else\n        return a;\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.", "de": "int extraNumber(int a, int b, int c)\n{\n    if (a == b)\n        return c;\n    else if (a == c)\n        return b;\n    else\n        return a;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "int extraNumber(int a, int b, int c)\n{\n    if (a == b)\n        return c;\n    else if (a == c)\n        return b;\n    else\n        return a;\n}\n\nBa da takaitaccen bayani a cikin yaren halitta (docstring) na lambar C cikin Hausa ta amfani da haruffa 500 kacal.", "hi": "int extraNumber(int a, int b, int c)\n{\n    if (a == b)\n        return c;\n    else if (a == c)\n        return b;\n    else\n        return a;\n}\n\nC कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "int extraNumber(int a, int b, int c)\n{\n    if (a == b)\n        return c;\n    else if (a == c)\n        return b;\n    else\n        return a;\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakter felhasználásával.", "es": "int extraNumber(int a, int b, int c)\n{\n    if (a == b)\n        return c;\n    else if (a == c)\n        return b;\n    else\n        return a;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando un máximo de 500 caracteres.", "arb": "int extraNumber(int a, int b, int c)\n{\n    if (a == b)\n        return c;\n    else if (a == c)\n        return b;\n    else\n        return a;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "int extraNumber(int a, int b, int c)\n{\n    if (a == b)\n        return c;\n    else if (a == c)\n        return b;\n    else\n        return a;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "int extraNumber(int a, int b, int c)\n{\n    if (a == b)\n        return c;\n    else if (a == c)\n        return b;\n    else\n        return a;\n}\n\nC kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe olarak yazılmalıdır.", "vi": "int extraNumber(int a, int b, int c)\n{\n    if (a == b)\n        return c;\n    else if (a == c)\n        return b;\n    else\n        return a;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã C bằng tiếng Việt, sử dụng tối đa 500 ký tự.", "id": "int extraNumber(int a, int b, int c)\n{\n    if (a == b)\n        return c;\n    else if (a == c)\n        return b;\n    else\n        return a;\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode C dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "int extraNumber(int a, int b, int c)\n{\n    if (a == b)\n        return c;\n    else if (a == c)\n        return b;\n    else\n        return a;\n}\n\nCコードの内容を日本語で簡潔に説明するドキュメンテーションストリング（docstring）を500文字以内で提供してください。", "ko": "int extraNumber(int a, int b, int c)\n{\n    if (a == b)\n        return c;\n    else if (a == c)\n        return b;\n    else\n        return a;\n}\n\nC 코드에 대한 간결한 자연어 설명(docstring)을 한국어로 최대 500자 이내로 제공하세요.", "ml": "int extraNumber(int a, int b, int c)\n{\n    if (a == b)\n        return c;\n    else if (a == c)\n        return b;\n    else\n        return a;\n}\n\nസിയുടെ കോഡിന് 500 അക്ഷരങ്ങളിൽ കൂടാത്ത മലയാളത്തിൽ സംക്ഷിപ്തമായ ഒരു സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) നൽകുക.", "fa": "int extraNumber(int a, int b, int c)\n{\n    if (a == b)\n        return c;\n    else if (a == c)\n        return b;\n    else\n        return a;\n}\n\nتوضیحی مختصر و طبیعی (docstring) از کد C به زبان فارسی ارائه دهید که حداکثر ۵۰۰ کاراکتر باشد."}, "level": "", "test": "int main()\n{\n    assert(extraNumber(2, 7, 2) == 7);\n    assert(extraNumber(3, 2, 2) == 3);\n    assert(extraNumber(5, 5, 1) == 1);\n    assert(extraNumber(500000000, 3, 500000000) == 3);\n    assert(extraNumber(500000000, 500000000, 3) == 3);\n    return 0;\n}", "entry_point": "extraNumber", "signature": "int extraNumber(int a, int b, int c)", "docstring": {"en": "You are given three digits a, b, c. Two of them are equal, but the third one is different from the other two. Find the value that occurs exactly once.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3\n", "sq": "Ju jepen tre shifra a, b, c. Dy prej tyre janë të barabarta, por e treta është e ndryshme nga dy të tjerat. Gjeni vlerën që shfaqet saktësisht një herë.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3", "hy": "Ձեզ տրված են երեք թվանշան՝ a, b, c։ Նրանցից երկուսը հավասար են, բայց երրորդը տարբերվում է մյուս երկուսից։ Գտեք այն արժեքը, որը հանդիպում է հենց մեկ անգամ։\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3", "bn": "তোমাকে তিনটি সংখ্যা দেওয়া হয়েছে a, b, c। এদের মধ্যে দুটি সংখ্যা সমান, কিন্তু তৃতীয়টি অন্য দুটি থেকে আলাদা। সেই মানটি খুঁজে বের কর যা ঠিক একবার ঘটে।\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3", "bg": "Дадени са ви три цифри a, b, c. Две от тях са равни, но третата е различна от другите две. Намерете стойността, която се среща точно веднъж.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3", "zh": "你有三个数字 a, b, c。其中两个是相等的，但第三个与其他两个不同。找出只出现一次的值。\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3", "fr": "Vous avez trois chiffres a, b, c. Deux d'entre eux sont égaux, mais le troisième est différent des deux autres. Trouvez la valeur qui apparaît exactement une fois.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3", "de": "Du hast drei Ziffern a, b, c. Zwei von ihnen sind gleich, aber die dritte unterscheidet sich von den anderen beiden. Finde den Wert, der genau einmal vorkommt.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3", "ha": "An a ba ka lambobi uku a, b, c. Biyu daga cikinsu suna daidai, amma na uku ya bambanta daga sauran biyun. Nemo ƙimar da ta bayyana sau ɗaya kawai.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3", "hi": "आपको तीन अंक दिए गए हैं a, b, c। इनमें से दो समान हैं, लेकिन तीसरा अन्य दो से भिन्न है। उस मान को खोजें जो केवल एक बार आता है।\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3", "hu": "Három számjegy van megadva: a, b, c. Kettő közülük egyenlő, de a harmadik különbözik a másik kettőtől. Találd meg azt az értéket, amely pontosan egyszer fordul elő.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3", "es": "Se te dan tres dígitos a, b, c. Dos de ellos son iguales, pero el tercero es diferente de los otros dos. Encuentra el valor que ocurre exactamente una vez.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3", "arb": "أنت مُعطى ثلاثة أرقام a، b، c. اثنان منهما متساويان، ولكن الرقم الثالث مختلف عن الاثنين الآخرين. ابحث عن القيمة التي تظهر مرة واحدة فقط.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3", "sw": "Unapewa tarakimu tatu a, b, c. Mbili kati ya hizo ni sawa, lakini ya tatu ni tofauti na zile nyingine mbili. Tafuta thamani inayotokea mara moja tu.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3", "tr": "Üç basamaklı sayı verilir: a, b, c. Bunlardan ikisi eşittir, ancak üçüncüsü diğer ikisinden farklıdır. Tam olarak bir kez meydana gelen değeri bulun.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3", "vi": "Bạn được cho ba chữ số a, b, c. Hai trong số chúng bằng nhau, nhưng chữ số thứ ba khác với hai chữ số còn lại. Tìm giá trị xuất hiện chính xác một lần.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3", "id": "Anda diberikan tiga digit a, b, c. Dua di antaranya sama, tetapi yang ketiga berbeda dari dua lainnya. Temukan nilai yang muncul tepat sekali.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3", "ja": "3つの数字 a, b, c が与えられます。そのうち2つは等しく、残りの1つは他の2つとは異なります。ちょうど1回だけ現れる値を見つけてください。\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3", "ko": "세 개의 숫자 a, b, c가 주어집니다. 이 중 두 숫자는 같고, 나머지 하나는 다른 두 숫자와 다릅니다. 정확히 한 번만 나타나는 값을 찾으세요.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3", "ml": "നിങ്ങൾക്ക് മൂന്ന് അക്കങ്ങൾ a, b, c നൽകിയിരിക്കുന്നു. അവയിൽ രണ്ടെണ്ണം തുല്യമാണ്, പക്ഷേ മൂന്നാമത്തേത് മറ്റവയുമായി വ്യത്യസ്തമാണ്. ഒരിക്കൽ മാത്രം സംഭവിക്കുന്ന മൂല്യം കണ്ടെത്തുക.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3", "fa": "شما سه رقم a، b، c دارید. دو تا از آنها برابر هستند، اما سومی با دو تای دیگر متفاوت است. مقداری را پیدا کنید که دقیقاً یک بار رخ می‌دهد.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3"}}
{"task_id": "C/13", "prompt": {"en": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCalculate the total score for a student based on the scores in different subjects.\n    Parameters:\n- subject_scores (list): A list containing the scores for each subject.\n    Returns:\n    int: The total score obtained by summing up the scores in all subjects.\n    >>> calculate_total_score(100,100,100,100,100)\n    500\n*/\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)", "sq": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nLlogaritni rezultatin total për një student bazuar në rezultatet në lëndë të ndryshme.\n    Parametrat:\n- subject_scores (listë): Një listë që përmban rezultatet për secilën lëndë.\n    Kthen:\n    int: Rezultati total i marrë duke mbledhur rezultatet në të gjitha lëndët.\n    >>> calculate_total_score(100,100,100,100,100)\n    500\n*/\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)", "hy": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nՀաշվել ուսանողի ընդհանուր միավորը տարբեր առարկաներում ստացած միավորների հիման վրա։\n    Պարամետրեր:\n- subject_scores (ցանկ): Ցանկ, որը պարունակում է յուրաքանչյուր առարկայի համար ստացած միավորները։\n    Վերադարձնում է:\n    int: Ընդհանուր միավորը, որը ստացվում է բոլոր առարկաների միավորների գումարումով։\n    >>> calculate_total_score(100,100,100,100,100)\n    500\n*/\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)", "bn": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nএকজন ছাত্রের জন্য বিভিন্ন বিষয়ের স্কোরের উপর ভিত্তি করে মোট স্কোর গণনা করুন।\n    প্যারামিটার:\n- subject_scores (list): প্রতিটি বিষয়ে স্কোর ধারণকারী একটি তালিকা।\n    রিটার্নস:\n    int: সব বিষয়ের স্কোর যোগ করে প্রাপ্ত মোট স্কোর।\n    >>> calculate_total_score(100,100,100,100,100)\n    500\n*/\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)", "bg": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nИзчислете общия резултат за ученик въз основа на резултатите в различни предмети.\n    Параметри:\n- subject_scores (списък): Списък, съдържащ резултатите за всеки предмет.\n    Връща:\n    int: Общият резултат, получен чрез сумиране на резултатите във всички предмети.\n    >>> calculate_total_score(100,100,100,100,100)\n    500\n*/\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)", "zh": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n计算学生在不同科目中的总分。\n    参数:\n- subject_scores (list): 包含每个科目分数的列表。\n    返回:\n    int: 通过将所有科目的分数相加得到的总分。\n    >>> calculate_total_score(100,100,100,100,100)\n    500\n*/\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)", "fr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCalcule le score total pour un étudiant basé sur les scores dans différentes matières.\n    Paramètres:\n- subject_scores (liste): Une liste contenant les scores pour chaque matière.\n    Retourne:\n    int: Le score total obtenu en additionnant les scores de toutes les matières.\n    >>> calculate_total_score(100,100,100,100,100)\n    500\n*/\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)", "de": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nBerechnet die Gesamtpunktzahl für einen Schüler basierend auf den Punktzahlen in verschiedenen Fächern.\n    Parameter:\n- subject_scores (list): Eine Liste, die die Punktzahlen für jedes Fach enthält.\n    Rückgabe:\n    int: Die Gesamtpunktzahl, die durch das Summieren der Punktzahlen in allen Fächern erreicht wird.\n    >>> calculate_total_score(100,100,100,100,100)\n    500\n*/\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)", "ha": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nƘididdige jimillar maki ga ɗalibi bisa la'akari da maki a fannoni daban-daban.\n    Sigogi:\n- subject_scores (list): Jerin da ke ƙunshe da maki don kowane fanni.\n    Komawa:\n    int: Jimillar maki da aka samu ta hanyar tara maki a duk fannoni.\n    >>> calculate_total_score(100,100,100,100,100)\n    500\n*/\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)", "hi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nविभिन्न विषयों में अंकों के आधार पर एक छात्र के लिए कुल स्कोर की गणना करें।\n    पैरामीटर्स:\n- subject_scores (list): प्रत्येक विषय के लिए अंक शामिल करने वाली एक सूची।\n    रिटर्न करता है:\n    int: सभी विषयों में अंकों को जोड़कर प्राप्त कुल स्कोर।\n    >>> calculate_total_score(100,100,100,100,100)\n    500\n*/\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)", "hu": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nSzámítsa ki a diák összpontszámát a különböző tantárgyakban elért pontszámok alapján.\n    Paraméterek:\n- subject_scores (list): Egy lista, amely tartalmazza az egyes tantárgyak pontszámait.\n    Visszatér:\n    int: Az összpontszám, amelyet az összes tantárgy pontszámának összeadásával kapunk.\n    >>> calculate_total_score(100,100,100,100,100)\n    500\n*/\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)", "es": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCalcular la puntuación total de un estudiante basada en las puntuaciones en diferentes asignaturas.\n    Parámetros:\n- subject_scores (list): Una lista que contiene las puntuaciones para cada asignatura.\n    Devuelve:\n    int: La puntuación total obtenida sumando las puntuaciones en todas las asignaturas.\n    >>> calculate_total_score(100,100,100,100,100)\n    500\n*/\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)", "arb": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nاحسب المجموع الكلي للدرجات لطالب بناءً على الدرجات في مواد مختلفة.\n    المعلمات:\n- subject_scores (list): قائمة تحتوي على الدرجات لكل مادة.\n    يعيد:\n    int: المجموع الكلي للدرجات المحصل عليه بجمع الدرجات في جميع المواد.\n    >>> calculate_total_score(100,100,100,100,100)\n    500\n*/\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)", "sw": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nHesabu jumla ya alama kwa mwanafunzi kulingana na alama katika masomo tofauti.\n    Vigezo:\n- subject_scores (orodha): Orodha inayoonyesha alama za kila somo.\n    Inarudisha:\n    int: Jumla ya alama zilizopatikana kwa kujumlisha alama katika masomo yote.\n    >>> calculate_total_score(100,100,100,100,100)\n    500\n*/\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)", "tr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nBir öğrencinin farklı derslerdeki puanlarına göre toplam puanını hesaplayın.\n    Parametreler:\n- subject_scores (list): Her ders için puanları içeren bir liste.\n    Döndürür:\n    int: Tüm derslerdeki puanların toplamını elde ederek elde edilen toplam puan.\n    >>> calculate_total_score(100,100,100,100,100)\n    500\n*/\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)", "vi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nTính tổng điểm cho một học sinh dựa trên điểm số trong các môn học khác nhau.\n    Tham số:\n- subject_scores (list): Một danh sách chứa điểm số cho mỗi môn học.\n    Trả về:\n    int: Tổng điểm đạt được bằng cách cộng điểm số trong tất cả các môn học.\n    >>> calculate_total_score(100,100,100,100,100)\n    500\n*/\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)", "id": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nMenghitung total skor untuk seorang siswa berdasarkan skor dalam berbagai mata pelajaran.\n    Parameter:\n- subject_scores (list): Daftar yang berisi skor untuk setiap mata pelajaran.\n    Mengembalikan:\n    int: Total skor yang diperoleh dengan menjumlahkan skor di semua mata pelajaran.\n    >>> calculate_total_score(100,100,100,100,100)\n    500\n*/\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)", "ja": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n異なる科目のスコアに基づいて学生の合計スコアを計算します。\n    パラメータ:\n- subject_scores (list): 各科目のスコアを含むリスト。\n    戻り値:\n    int: すべての科目のスコアを合計して得られる合計スコア。\n    >>> calculate_total_score(100,100,100,100,100)\n    500\n*/\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)\n", "ko": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n학생의 총 점수를 다양한 과목의 점수를 기반으로 계산합니다.\n    매개변수:\n- subject_scores (list): 각 과목의 점수를 포함하는 리스트.\n    반환값:\n    int: 모든 과목의 점수를 합산하여 얻은 총 점수.\n    >>> calculate_total_score(100,100,100,100,100)\n    500\n*/\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)", "ml": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nവിവിധ വിഷയങ്ങളിലെ സ്കോറുകൾ അടിസ്ഥാനമാക്കി ഒരു വിദ്യാർത്ഥിയുടെ മൊത്തം സ്കോർ കണക്കാക്കുക.\n    പാരാമീറ്ററുകൾ:\n- subject_scores (list): ഓരോ വിഷയത്തിനും സ്കോറുകൾ അടങ്ങിയ ഒരു പട്ടിക.\n    റിട്ടേൺസ്:\n    int: എല്ലാ വിഷയങ്ങളിലെയും സ്കോറുകൾ കൂട്ടിച്ചേർത്തു ലഭിക്കുന്ന മൊത്തം സ്കോർ.\n    >>> calculate_total_score(100,100,100,100,100)\n    500\n*/\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)", "fa": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nمحاسبه نمره کل برای یک دانش‌آموز بر اساس نمرات در موضوعات مختلف.\n    پارامترها:\n- subject_scores (list): لیستی که نمرات هر موضوع را شامل می‌شود.\n    بازگشت:\n    int: نمره کل که با جمع کردن نمرات در تمام موضوعات به دست می‌آید.\n    >>> calculate_total_score(100,100,100,100,100)\n    500\n*/\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)"}, "canonical_solution": "{\n    return score1 + score2 + score3 + score4 + score5;\n}", "instruction": {"en": "int calculate_total_score(int score1, int score2, int score3, int score4, int score5)\n{\n    return score1 + score2 + score3 + score4 + score5;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "sq": "int calculate_total_score(int score1, int score2, int score3, int score4, int score5)\n{\n    return score1 + score2 + score3 + score4 + score5;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C në shqip duke përdorur maksimumi 500 karaktere.", "hy": "int calculate_total_score(int score1, int score2, int score3, int score4, int score5)\n{\n    return score1 + score2 + score3 + score4 + score5;\n}\n\nՀամառոտ բնական լեզվով նկարագրություն (docstring) տրամադրեք C կոդի համար՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "int calculate_total_score(int score1, int score2, int score3, int score4, int score5)\n{\n    return score1 + score2 + score3 + score4 + score5;\n}\n\nসি কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।", "bg": "int calculate_total_score(int score1, int score2, int score3, int score4, int score5)\n{\n    return score1 + score2 + score3 + score4 + score5;\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, използвайки най-много 500 знака.", "zh": "int calculate_total_score(int score1, int score2, int score3, int score4, int score5)\n{\n    return score1 + score2 + score3 + score4 + score5;\n}\n\n请用最多500个字符的中文对该C代码提供简洁的自然语言描述（文档字符串）。", "fr": "int calculate_total_score(int score1, int score2, int score3, int score4, int score5)\n{\n    return score1 + score2 + score3 + score4 + score5;\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.", "de": "int calculate_total_score(int score1, int score2, int score3, int score4, int score5)\n{\n    return score1 + score2 + score3 + score4 + score5;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "int calculate_total_score(int score1, int score2, int score3, int score4, int score5)\n{\n    return score1 + score2 + score3 + score4 + score5;\n}\n\nBa da taƙaitaccen bayani a cikin yare na halitta (docstring) na lambar C cikin Hausa ta amfani da haruffa 500 kacal.", "hi": "int calculate_total_score(int score1, int score2, int score3, int score4, int score5)\n{\n    return score1 + score2 + score3 + score4 + score5;\n}\n\nC कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रींग) हिंदी में अधिकतम 500 वर्णों का उपयोग करके प्रदान करें।", "hu": "int calculate_total_score(int score1, int score2, int score3, int score4, int score5)\n{\n    return score1 + score2 + score3 + score4 + score5;\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben.", "es": "int calculate_total_score(int score1, int score2, int score3, int score4, int score5)\n{\n    return score1 + score2 + score3 + score4 + score5;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando un máximo de 500 caracteres.", "arb": "int calculate_total_score(int score1, int score2, int score3, int score4, int score5)\n{\n    return score1 + score2 + score3 + score4 + score5;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "int calculate_total_score(int score1, int score2, int score3, int score4, int score5)\n{\n    return score1 + score2 + score3 + score4 + score5;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "int calculate_total_score(int score1, int score2, int score3, int score4, int score5)\n{\n    return score1 + score2 + score3 + score4 + score5;\n}\n\nAşağıdaki C kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda, özlü bir doğal dil açıklaması (docstring) sağlayın.", "vi": "int calculate_total_score(int score1, int score2, int score3, int score4, int score5)\n{\n    return score1 + score2 + score3 + score4 + score5;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã C bằng tiếng Việt, sử dụng tối đa 500 ký tự.", "id": "int calculate_total_score(int score1, int score2, int score3, int score4, int score5)\n{\n    return score1 + score2 + score3 + score4 + score5;\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode C dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "int calculate_total_score(int score1, int score2, int score3, int score4, int score5)\n{\n    return score1 + score2 + score3 + score4 + score5;\n}\n\nCコードの内容を簡潔に説明する自然言語の記述（ドキュメンテーションコメント）を、日本語で500文字以内で提供してください。", "ko": "int calculate_total_score(int score1, int score2, int score3, int score4, int score5)\n{\n    return score1 + score2 + score3 + score4 + score5;\n}\n\n다음 C 코드의 동작을 설명하는 간결한 자연어 설명(도크스트링)을 한국어로 작성하세요. 최대 500자까지 가능합니다.", "ml": "int calculate_total_score(int score1, int score2, int score3, int score4, int score5)\n{\n    return score1 + score2 + score3 + score4 + score5;\n}\n\nസി കോഡിന്റെ സംക്ഷിപ്തമായ സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) മലയാളത്തിൽ 500 അക്ഷരങ്ങൾക്കുള്ളിൽ നൽകുക.", "fa": "int calculate_total_score(int score1, int score2, int score3, int score4, int score5)\n{\n    return score1 + score2 + score3 + score4 + score5;\n}\n\nتوضیح مختصر و طبیعی (docstring) از کد C را به زبان فارسی با حداکثر ۵۰۰ کاراکتر ارائه دهید."}, "level": "", "test": "int main()\n{\n    assert(calculate_total_score(100,100,100,100,100) == 500);\n    assert(calculate_total_score(0,0,0,0,0) == 0);\n    assert(calculate_total_score(20, 30, 40, 10, 50) == 150);\n    assert(calculate_total_score(23, 45, 67, 89, 12) == 236);\n    assert(calculate_total_score(5, 5, 5, 5, 5) == 25);\n    return 0;\n}", "entry_point": "calculate_total_score", "signature": "int calculate_total_score(int score1, int score2, int score3, int score4, int score5)", "docstring": {"en": "Calculate the total score for a student based on the scores in different subjects.\n    Parameters:\n- subject_scores (list): A list containing the scores for each subject.\n    Returns:\n    int: The total score obtained by summing up the scores in all subjects.\n    >>> calculate_total_score(100,100,100,100,100)\n    500\n", "sq": "Llogarit totalin e pikëve për një student bazuar në pikët në lëndë të ndryshme.\n    Parametrat:\n- subject_scores (list): Një listë që përmban pikët për secilën lëndë.\n    Kthen:\n    int: Totali i pikëve të marra duke mbledhur pikët në të gjitha lëndët.\n    >>> calculate_total_score(100,100,100,100,100)\n    500", "hy": "Հաշվարկել ուսանողի ընդհանուր միավորը տարբեր առարկաներում ստացված միավորների հիման վրա։\n    Պարամետրեր:\n- subject_scores (list): Ցանկ, որը պարունակում է յուրաքանչյուր առարկայի միավորները։\n    Վերադարձնում է:\n    int: Ընդհանուր միավորը, որը ստացվում է բոլոր առարկաների միավորները գումարելով։\n    >>> calculate_total_score(100,100,100,100,100)\n    500", "bn": "ছাত্রের মোট স্কোর বিভিন্ন বিষয়ে প্রাপ্ত স্কোরের ভিত্তিতে গণনা করুন।\n    Parameters:\n- subject_scores (list): প্রতিটি বিষয়ের স্কোর ধারণকারী একটি তালিকা।\n    Returns:\n    int: সমস্ত বিষয়ের স্কোর যোগ করে প্রাপ্ত মোট স্কোর।\n    >>> calculate_total_score(100,100,100,100,100)\n    500", "bg": "Изчислете общия резултат за ученик въз основа на резултатите от различни предмети.\n    Параметри:\n- subject_scores (list): Списък, съдържащ резултатите за всеки предмет.\n    Връща:\n    int: Общият резултат, получен чрез сумиране на резултатите от всички предмети.\n    >>> calculate_total_score(100,100,100,100,100)\n    500", "zh": "计算学生在不同科目中的总分。\n    参数：\n- subject_scores (list): 包含每个科目分数的列表。\n    返回：\n    int: 通过将所有科目的分数相加得到的总分。\n    >>> calculate_total_score(100,100,100,100,100)\n    500", "fr": "Calculer le score total pour un étudiant basé sur les scores dans différentes matières.\n    Paramètres:\n- subject_scores (list): Une liste contenant les scores pour chaque matière.\n    Renvoie:\n    int: Le score total obtenu en additionnant les scores de toutes les matières.\n    >>> calculate_total_score(100,100,100,100,100)\n    500", "de": "Berechnen Sie die Gesamtpunktzahl für einen Schüler basierend auf den Punktzahlen in verschiedenen Fächern.\n    Parameter:\n- subject_scores (list): Eine Liste, die die Punktzahlen für jedes Fach enthält.\n    Rückgabewert:\n    int: Die Gesamtpunktzahl, die durch Summieren der Punktzahlen in allen Fächern erhalten wird.\n    >>> calculate_total_score(100,100,100,100,100)\n    500", "ha": "Ƙididdige jimillar maki ga ɗalibi bisa ga maki a fannoni daban-daban.\n    Sigogi:\n- subject_scores (list): Jerin da ke ɗauke da maki ga kowane fanni.\n    Dawowa:\n    int: Jimillar maki da aka samu ta hanyar tara maki a dukkan fannoni.\n    >>> calculate_total_score(100,100,100,100,100)\n    500", "hi": "छात्र के विभिन्न विषयों में प्राप्त अंकों के आधार पर कुल स्कोर की गणना करें।\n    पैरामीटर्स:\n- subject_scores (list): प्रत्येक विषय के लिए अंकों की सूची।\n    रिटर्न्स:\n    int: सभी विषयों के अंकों को जोड़कर प्राप्त कुल स्कोर।\n    >>> calculate_total_score(100,100,100,100,100)\n    500", "hu": "Számítsa ki a hallgató összpontszámát a különböző tantárgyakban elért pontszámok alapján.\n    Paraméterek:\n- subject_scores (list): Egy lista, amely tartalmazza az egyes tantárgyak pontszámait.\n    Visszatérési érték:\n    int: Az összpontszám, amelyet az összes tantárgyban elért pontszámok összeadásával kapunk.\n    >>> calculate_total_score(100,100,100,100,100)\n    500", "es": "Calcular la puntuación total de un estudiante basada en las puntuaciones en diferentes materias.\n    Parámetros:\n- subject_scores (list): Una lista que contiene las puntuaciones para cada materia.\n    Devuelve:\n    int: La puntuación total obtenida al sumar las puntuaciones en todas las materias.\n    >>> calculate_total_score(100,100,100,100,100)\n    500", "arb": "احسب المجموع الكلي للدرجات لطالب بناءً على الدرجات في مواد مختلفة.\n    المعاملات:\n- subject_scores (list): قائمة تحتوي على الدرجات لكل مادة.\n    يعيد:\n    int: المجموع الكلي للدرجات المحصل عليه عن طريق جمع الدرجات في جميع المواد.\n    >>> calculate_total_score(100,100,100,100,100)\n    500", "sw": "Hesabu jumla ya alama kwa mwanafunzi kulingana na alama katika masomo tofauti.\n    Vigezo:\n- subject_scores (list): Orodha inayojumuisha alama za kila somo.\n    Inarejesha:\n    int: Jumla ya alama inayopatikana kwa kujumlisha alama katika masomo yote.\n    >>> calculate_total_score(100,100,100,100,100)\n    500", "tr": "Öğrencinin farklı derslerdeki puanlarına göre toplam puanını hesaplayın.\n    Parametreler:\n- subject_scores (list): Her ders için puanları içeren bir liste.\n    Döndürülen:\n    int: Tüm derslerdeki puanların toplanmasıyla elde edilen toplam puan.\n    >>> calculate_total_score(100,100,100,100,100)\n    500", "vi": "Tính tổng điểm cho một học sinh dựa trên điểm số trong các môn học khác nhau.\n    Tham số:\n- subject_scores (list): Một danh sách chứa điểm số cho mỗi môn học.\n    Trả về:\n    int: Tổng điểm đạt được bằng cách cộng điểm số trong tất cả các môn học.\n    >>> calculate_total_score(100,100,100,100,100)\n    500", "id": "Hitung total skor untuk seorang siswa berdasarkan skor dalam berbagai mata pelajaran.\n    Parameter:\n- subject_scores (list): Daftar yang berisi skor untuk setiap mata pelajaran.\n    Mengembalikan:\n    int: Total skor yang diperoleh dengan menjumlahkan skor di semua mata pelajaran.\n    >>> calculate_total_score(100,100,100,100,100)\n    500", "ja": "学生の異なる科目のスコアに基づいて、総合得点を計算します。\n    引数:\n- subject_scores (list): 各科目のスコアを含むリスト。\n    戻り値:\n    int: すべての科目のスコアを合計して得られる総合得点。\n    >>> calculate_total_score(100,100,100,100,100)\n    500", "ko": "학생의 다양한 과목 점수를 기반으로 총점을 계산합니다.\n    매개변수:\n- subject_scores (list): 각 과목의 점수를 포함하는 리스트입니다.\n    반환:\n    int: 모든 과목의 점수를 합산하여 얻은 총점입니다.\n    >>> calculate_total_score(100,100,100,100,100)\n    500", "ml": "വിദ്യാർത്ഥിയുടെ വിവിധ വിഷയങ്ങളിലെ മാർക്കുകൾ അടിസ്ഥാനമാക്കി മൊത്തം സ്കോർ കണക്കാക്കുക.\n    പാരാമീറ്ററുകൾ:\n- subject_scores (list): ഓരോ വിഷയത്തിനും ലഭിച്ച മാർക്കുകൾ അടങ്ങിയ ഒരു ലിസ്റ്റ്.\n    മടക്കങ്ങൾ:\n    int: എല്ലാ വിഷയങ്ങളിലെയും മാർക്കുകൾ കൂട്ടിച്ചേർത്തു ലഭിക്കുന്ന മൊത്തം സ്കോർ.\n    >>> calculate_total_score(100,100,100,100,100)\n    500", "fa": "محاسبه امتیاز کل برای یک دانش‌آموز بر اساس امتیازات در موضوعات مختلف.\n    پارامترها:\n- subject_scores (list): لیستی که شامل امتیازات هر موضوع است.\n    بازگشت:\n    int: امتیاز کل که با جمع کردن امتیازات در همه موضوعات به دست می‌آید.\n    >>> calculate_total_score(100,100,100,100,100)\n    500"}}
{"task_id": "C/14", "prompt": {"en": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDecode a series of numbers to reveal the pattern and understand the actual values \neach digit represents.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParameters:\n- data_str: A string representing a series of numbers. Length does not exceed 100.\n\nReturns:\nint: The result of each data string corresponding to the right-hand side of the equation.\n\nExample usage:\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)", "sq": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDekodo një seri numrash për të zbuluar modelin dhe për të kuptuar vlerat aktuale \nqë secila shifër përfaqëson.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParametrat:\n- data_str: Një varg që përfaqëson një seri numrash. Gjatësia nuk i kalon 100.\n\nKthen:\nint: Rezultati i secilit varg të dhënash që korrespondon me anën e djathtë të ekuacionit.\n\nShembull përdorimi:\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)", "hy": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nՎերծանել թվերի շարք՝ բացահայտելու համար օրինաչափությունը և հասկանալու, թե իրականում ինչ արժեքներ \nեն ներկայացնում յուրաքանչյուր թվանշան:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nՊարամետրեր:\n- data_str: Թվերի շարքը ներկայացնող տող: Երկարությունը չի գերազանցում 100-ը:\n\nՎերադարձնում է:\nint: Յուրաքանչյուր տվյալ տողի արդյունքը, որը համապատասխանում է հավասարման աջ կողմին:\n\nՕրինակ օգտագործում:\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)", "bn": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nসংখ্যার একটি সিরিজ ডিকোড করুন প্যাটার্নটি প্রকাশ করার জন্য এবং প্রতিটি অঙ্ক আসলে কোন মানটি উপস্থাপন করে তা বোঝার জন্য।\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nপ্যারামিটার:\n- data_str: একটি স্ট্রিং যা সংখ্যার একটি সিরিজ উপস্থাপন করে। দৈর্ঘ্য 100 অতিক্রম করে না।\n\nফেরত দেয়:\nint: প্রতিটি ডেটা স্ট্রিং এর সমীকরণের ডান দিকের মানের সাথে সংশ্লিষ্ট ফলাফল।\n\nউদাহরণ ব্যবহার:\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)", "bg": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nДекодирайте серия от числа, за да разкриете модела и да разберете действителните стойности, \nкоито всяка цифра представлява.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nПараметри:\n- data_str: Низ, представляващ серия от числа. Дължината не надвишава 100.\n\nВръща:\nint: Резултатът от всеки низ от данни, съответстващ на дясната страна на уравнението.\n\nПример за използване:\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)", "zh": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\n解码一系列数字以揭示模式并理解每个数字代表的实际值。\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\n参数：\n- data_str: 表示一系列数字的字符串。长度不超过100。\n\n返回：\nint: 每个数据字符串对应方程右侧的结果。\n\n示例用法：\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)", "fr": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDécoder une série de chiffres pour révéler le motif et comprendre les valeurs réelles \nque chaque chiffre représente.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParamètres :\n- data_str : Une chaîne représentant une série de chiffres. La longueur ne dépasse pas 100.\n\nRetourne :\nint : Le résultat de chaque chaîne de données correspondant au côté droit de l'équation.\n\nExemple d'utilisation :\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)", "de": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDekodiere eine Serie von Zahlen, um das Muster zu erkennen und die tatsächlichen Werte zu verstehen, \ndie jede Ziffer darstellt.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParameter:\n- data_str: Ein String, der eine Serie von Zahlen darstellt. Die Länge überschreitet nicht 100.\n\nRückgabewert:\nint: Das Ergebnis jedes Datenstrings, das der rechten Seite der Gleichung entspricht.\n\nBeispielverwendung:\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)", "ha": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nFassara jerin lambobi don bayyana tsarin kuma fahimtar ainihin ƙimomin da kowace lamba ke wakilta.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nSigogi:\n- data_str: Wani igiyar haruffa da ke wakiltar jerin lambobi. Tsawon ba zai wuce 100 ba.\n\nDawowa:\nint: Sakamakon kowane igiyar bayanai da ya dace da gefen dama na lissafin.\n\nMisalin amfani:\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)", "hi": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nसंख्याओं की एक श्रृंखला को डिकोड करें ताकि पैटर्न का पता चल सके और समझ सकें कि \nप्रत्येक अंक वास्तव में क्या मान दर्शाता है।\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nपैरामीटर्स:\n- data_str: एक स्ट्रिंग जो संख्याओं की एक श्रृंखला का प्रतिनिधित्व करती है। लंबाई 100 से अधिक नहीं होती।\n\nवापसी:\nint: प्रत्येक डेटा स्ट्रिंग का परिणाम जो समीकरण के दाईं ओर के अनुरूप होता है।\n\nउदाहरण उपयोग:\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)", "hu": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDekódolja a számok sorozatát, hogy felfedje a mintát és megértse, hogy az egyes számjegyek valójában milyen értékeket képviselnek.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParaméterek:\n- data_str: Egy karakterlánc, amely számok sorozatát képviseli. Hossza nem haladja meg a 100-at.\n\nVisszatér:\nint: Az egyes adatkarakterláncok eredménye, amely megfelel az egyenlet jobb oldalának.\n\nPélda használat:\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)", "es": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDecodificar una serie de números para revelar el patrón y entender los valores reales \nque representa cada dígito.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParámetros:\n- data_str: Una cadena que representa una serie de números. La longitud no excede 100.\n\nDevuelve:\nint: El resultado de cada cadena de datos correspondiente al lado derecho de la ecuación.\n\nEjemplo de uso:\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)", "arb": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nفك شفرة سلسلة من الأرقام للكشف عن النمط وفهم القيم الفعلية التي يمثلها كل رقم.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nالمعلمات:\n- data_str: سلسلة تمثل سلسلة من الأرقام. الطول لا يتجاوز 100.\n\nالإرجاع:\nint: نتيجة كل سلسلة بيانات تتوافق مع الجانب الأيمن من المعادلة.\n\nمثال على الاستخدام:\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)", "sw": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nFasiri mfululizo wa nambari ili kufichua muundo na kuelewa thamani halisi \nkila tarakimu inawakilisha.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nVigezo:\n- data_str: Kamba inayowakilisha mfululizo wa nambari. Urefu hauzidi 100.\n\nInarejesha:\nint: Matokeo ya kila kamba ya data inayolingana na upande wa kulia wa mlingano.\n\nMfano wa matumizi:\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)", "tr": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nBir dizi sayıyı çözerek deseni ortaya çıkarın ve her bir rakamın temsil ettiği gerçek \ndeğerleri anlayın.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParametreler:\n- data_str: Bir dizi sayıyı temsil eden bir dize. Uzunluk 100'ü geçmez.\n\nDöndürülenler:\nint: Her bir veri dizisinin, eşitliğin sağ tarafına karşılık gelen sonucu.\n\nÖrnek kullanım:\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)", "vi": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nGiải mã một chuỗi số để tiết lộ mẫu và hiểu các giá trị thực tế\nmỗi chữ số đại diện.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nTham số:\n- data_str: Một chuỗi đại diện cho một chuỗi số. Độ dài không vượt quá 100.\n\nTrả về:\nint: Kết quả của mỗi chuỗi dữ liệu tương ứng với phía bên phải của phương trình.\n\nVí dụ sử dụng:\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)", "id": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDekode serangkaian angka untuk mengungkap pola dan memahami nilai sebenarnya\nyang diwakili oleh setiap digit.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParameter:\n- data_str: Sebuah string yang mewakili serangkaian angka. Panjangnya tidak melebihi 100.\n\nMengembalikan:\nint: Hasil dari setiap string data yang sesuai dengan sisi kanan persamaan.\n\nContoh penggunaan:\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)\n", "ja": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\n一連の数字をデコードしてパターンを明らかにし、各桁が表す実際の値を理解します。\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nパラメータ:\n- data_str: 数字の列を表す文字列。長さは100を超えません。\n\n戻り値:\nint: 方程式の右辺に対応する各データ文字列の結果。\n\n使用例:\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)", "ko": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\n숫자 시리즈를 디코딩하여 패턴을 밝히고 각 자릿수가 나타내는 실제 값을 이해합니다.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\n매개변수:\n- data_str: 일련의 숫자를 나타내는 문자열입니다. 길이는 100을 초과하지 않습니다.\n\n반환값:\nint: 방정식의 오른쪽에 해당하는 각 데이터 문자열의 결과입니다.\n\n사용 예:\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)\n", "ml": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nഒരു സംഖ്യാ പരമ്പര ഡികോഡ് ചെയ്ത് ഓരോ അക്കവും പ്രതിനിധാനം ചെയ്യുന്ന യഥാർത്ഥ മൂല്യങ്ങൾ മനസ്സിലാക്കുക.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nപാരാമീറ്ററുകൾ:\n- data_str: സംഖ്യകളുടെ പരമ്പരയെ പ്രതിനിധീകരിക്കുന്ന ഒരു സ്ട്രിംഗ്. നീളം 100-നെ കവിയില്ല.\n\nമടക്കം:\nint: സമവാക്യത്തിന്റെ വലതുഭാഗത്തുള്ള ഓരോ ഡാറ്റ സ്ട്രിംഗിനും അനുയോജ്യമായ ഫലം.\n\nഉദാഹരണ ഉപയോഗം:\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)", "fa": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nرمزگشایی یک سری از اعداد برای آشکار کردن الگو و درک مقادیر واقعی که هر رقم نشان می‌دهد.\n\nپارامترها:\n- data_str: یک رشته که یک سری از اعداد را نشان می‌دهد. طول آن از 100 تجاوز نمی‌کند.\n\nبازگشت:\nint: نتیجه هر رشته داده که با سمت راست معادله مطابقت دارد.\n\nمثال استفاده:\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)"}, "canonical_solution": "{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}", "instruction": {"en": "int decode_numbers(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "sq": "int decode_numbers(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C në shqip duke përdorur maksimumi 500 karaktere.", "hy": "int decode_numbers(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}\n\nՏվեք C կոդի հակիրճ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։", "bn": "int decode_numbers(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}\n\nনিচের C কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।", "bg": "int decode_numbers(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, използвайки не повече от 500 знака.", "zh": "int decode_numbers(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}\n\n请用不超过500个字符的中文，为以下C代码提供简洁的自然语言描述（文档字符串）。", "fr": "int decode_numbers(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.", "de": "int decode_numbers(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "int decode_numbers(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar C cikin Hausa ta amfani da haruffa 500 kacal.", "hi": "int decode_numbers(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}\n\nC कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।", "hu": "int decode_numbers(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben.", "es": "int decode_numbers(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando como máximo 500 caracteres.", "arb": "int decode_numbers(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "int decode_numbers(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "int decode_numbers(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}\n\nC kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe olarak yazılmalıdır.", "vi": "int decode_numbers(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã C bằng tiếng Việt, sử dụng tối đa 500 ký tự.", "id": "int decode_numbers(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode C dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "int decode_numbers(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}\n\nCコードの内容を簡潔に説明する自然言語の記述（ドックストリング）を日本語で500文字以内で提供してください。", "ko": "int decode_numbers(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}\n\nC 코드에 대한 간결한 자연어 설명(docstring)을 한국어로 작성하세요. 최대 500자까지 가능합니다.", "ml": "int decode_numbers(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}\n\nC കോഡിന്റെ സംക്ഷിപ്തമായ ഒരു സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) മലയാളത്തിൽ പരമാവധി 500 അക്ഷരങ്ങൾ ഉപയോഗിച്ച് നൽകുക.", "fa": "int decode_numbers(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}\n\nتوضیح مختصر و طبیعی (docstring) از کد C به زبان فارسی ارائه دهید که حداکثر ۵۰۰ کاراکتر باشد."}, "level": "", "test": "int main() {\n    assert(decode_numbers(\"0000\") == 4);\n    assert(decode_numbers(\"8888\") == 8);\n    assert(decode_numbers(\"1234\") == 1);\n    assert(decode_numbers(\"5678\") == 3);\n    assert(decode_numbers(\"9012\") == 2);\n    assert(decode_numbers(\"1357\") == 0);\n    assert(decode_numbers(\"2468\") == 4);\n\n    // Additional test samples\n    assert(decode_numbers(\"9999\") == 4);\n    assert(decode_numbers(\"1111\") == 0);\n    assert(decode_numbers(\"2222\") == 0);\n    assert(decode_numbers(\"3333\") == 0);\n    assert(decode_numbers(\"4444\") == 4);\n    assert(decode_numbers(\"5555\") == 0);\n    assert(decode_numbers(\"6666\") == 4);\n    assert(decode_numbers(\"7777\") == 0);\n    assert(decode_numbers(\"0001\") == 3);\n    assert(decode_numbers(\"2301\") == 1);\n\n    return 0;\n}", "entry_point": "decode_numbers", "signature": "int decode_numbers(const char* data_str)", "docstring": {"en": "Decode a series of numbers to reveal the pattern and understand the actual values each digit represents.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParameters:\n- data_str: A string representing a series of numbers. Length does not exceed 100.\n\nReturns:\nint: The result of each data string corresponding to the right-hand side of the equation.\n\nExample usage:\nassert(decode_numbers(\"0000\") == 4);\n", "sq": "Dekodo një seri numrash për të zbuluar modelin dhe për të kuptuar vlerat aktuale që secila shifër përfaqëson.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParametrat:\n- data_str: Një varg që përfaqëson një seri numrash. Gjatësia nuk e kalon 100.\n\nKthen:\nint: Rezultati i secilit varg të dhënash që korrespondon me anën e djathtë të ekuacionit.\n\nShembull përdorimi:\nassert(decode_numbers(\"0000\") == 4);", "hy": "Թվերի շարք ապակոդավորել՝ բացահայտելու օրինաչափությունը և հասկանալու, թե իրականում ինչ արժեքներ են ներկայացնում յուրաքանչյուր թվանշան։\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nՊարամետրեր:\n- data_str: Թվերի շարք ներկայացնող տող։ Երկարությունը չի գերազանցում 100-ը։\n\nՎերադարձնում է:\nint: Յուրաքանչյուր տվյալ տողի արդյունքը, որը համապատասխանում է հավասարման աջ կողմին։\n\nՕրինակ օգտագործում:\nassert(decode_numbers(\"0000\") == 4);", "bn": "সংখ্যার একটি সিরিজ ডিকোড করে প্যাটার্নটি প্রকাশ করুন এবং প্রতিটি অঙ্ক আসলে কোন মানগুলি উপস্থাপন করে তা বোঝার চেষ্টা করুন।\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nপ্যারামিটারসমূহ:\n- data_str: একটি স্ট্রিং যা সংখ্যার একটি সিরিজ উপস্থাপন করে। দৈর্ঘ্য ১০০ অতিক্রম করে না।\n\nরিটার্নস:\nint: প্রতিটি ডেটা স্ট্রিং এর ফলাফল যা সমীকরণের ডান দিকের সাথে সঙ্গতিপূর্ণ।\n\nউদাহরণ ব্যবহার:\nassert(decode_numbers(\"0000\") == 4);", "bg": "Декодирайте серия от числа, за да разкриете модела и да разберете действителните стойности, които всяка цифра представлява.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nПараметри:\n- data_str: Низ, представляващ серия от числа. Дължината не надвишава 100.\n\nВръща:\nint: Резултатът от всеки низ от данни, съответстващ на дясната страна на уравнението.\n\nПример за използване:\nassert(decode_numbers(\"0000\") == 4);", "zh": "解码一系列数字以揭示模式并理解每个数字实际代表的值。\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\n参数:\n- data_str: 一个表示一系列数字的字符串。长度不超过100。\n\n返回:\nint: 每个数据字符串对应方程右侧的结果。\n\n示例用法:\nassert(decode_numbers(\"0000\") == 4);", "fr": "Décoder une série de chiffres pour révéler le motif et comprendre les valeurs réelles que chaque chiffre représente.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParamètres:\n- data_str: Une chaîne représentant une série de chiffres. La longueur ne dépasse pas 100.\n\nRenvoie:\nint: Le résultat de chaque chaîne de données correspondant au côté droit de l'équation.\n\nExemple d'utilisation:\nassert(decode_numbers(\"0000\") == 4);", "de": "Dekodiere eine Serie von Zahlen, um das Muster zu erkennen und die tatsächlichen Werte zu verstehen, die jede Ziffer darstellt.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParameter:\n- data_str: Ein String, der eine Serie von Zahlen darstellt. Die Länge überschreitet nicht 100.\n\nRückgabewert:\nint: Das Ergebnis jeder Datenzeichenfolge, das der rechten Seite der Gleichung entspricht.\n\nBeispielverwendung:\nassert(decode_numbers(\"0000\") == 4);", "ha": "Fassara jerin lambobi don bayyana tsarin kuma fahimtar ainihin ƙimar da kowace lamba ke wakilta.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nSigogi:\n- data_str: Wani kirtani da ke wakiltar jerin lambobi. Tsawon ba zai wuce 100 ba.\n\nDawowa:\nint: Sakamakon kowanne kirtani na bayanan da ya dace da gefen dama na lissafin.\n\nMisalin amfani:\nassert(decode_numbers(\"0000\") == 4);", "hi": "संख्या की एक श्रृंखला को डिकोड करें ताकि पैटर्न का पता चल सके और प्रत्येक अंक का वास्तविक मान समझा जा सके।\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nपैरामीटर्स:\n- data_str: एक स्ट्रिंग जो संख्याओं की श्रृंखला का प्रतिनिधित्व करती है। लंबाई 100 से अधिक नहीं होती।\n\nवापसी:\nint: प्रत्येक डेटा स्ट्रिंग का परिणाम जो समीकरण के दाईं ओर के अनुरूप है।\n\nउदाहरण उपयोग:\nassert(decode_numbers(\"0000\") == 4);", "hu": "Dekódoljon egy számsorozatot, hogy felfedje a mintát és megértse, hogy az egyes számjegyek valójában milyen értékeket képviselnek.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParaméterek:\n- data_str: Egy számsorozatot reprezentáló karakterlánc. Hossza nem haladja meg a 100-at.\n\nVisszatér:\nint: Az egyes adatkarakterláncok eredménye, amely megfelel az egyenlet jobb oldalának.\n\nPélda használat:\nassert(decode_numbers(\"0000\") == 4);", "es": "Decodificar una serie de números para revelar el patrón y entender los valores reales que representa cada dígito.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParámetros:\n- data_str: Una cadena que representa una serie de números. La longitud no excede 100.\n\nDevuelve:\nint: El resultado de cada cadena de datos correspondiente al lado derecho de la ecuación.\n\nEjemplo de uso:\nassert(decode_numbers(\"0000\") == 4);", "arb": "فك سلسلة من الأرقام للكشف عن النمط وفهم القيم الفعلية التي يمثلها كل رقم.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nالمعلمات:\n- data_str: سلسلة تمثل مجموعة من الأرقام. الطول لا يتجاوز 100.\n\nالقيم المعادة:\nint: نتيجة كل سلسلة بيانات تتوافق مع الجانب الأيمن من المعادلة.\n\nمثال على الاستخدام:\nassert(decode_numbers(\"0000\") == 4);", "sw": "Decode nambari kadhaa ili kufichua muundo na kuelewa thamani halisi ambayo kila tarakimu inawakilisha.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nVigezo:\n- data_str: Kamba inayoashiria mfululizo wa nambari. Urefu hauzidi 100.\n\nInarejesha:\nint: Matokeo ya kila kamba ya data inayolingana na upande wa kulia wa usawa.\n\nMfano wa matumizi:\nassert(decode_numbers(\"0000\") == 4);", "tr": "Bir dizi sayıyı çözerek deseni ortaya çıkarın ve her bir rakamın temsil ettiği gerçek değerleri anlayın.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParametreler:\n- data_str: Bir dizi sayıyı temsil eden bir string. Uzunluk 100'ü geçmez.\n\nDöndürülenler:\nint: Her bir veri dizisinin denklemin sağ tarafına karşılık gelen sonucu.\n\nÖrnek kullanım:\nassert(decode_numbers(\"0000\") == 4);", "vi": "Giải mã một chuỗi số để tiết lộ mô hình và hiểu các giá trị thực mà mỗi chữ số đại diện.\n\nTham số:\n- data_str: Một chuỗi đại diện cho một loạt các số. Độ dài không vượt quá 100.\n\nTrả về:\nint: Kết quả của mỗi chuỗi dữ liệu tương ứng với phía bên phải của phương trình.\n\nVí dụ sử dụng:\nassert(decode_numbers(\"0000\") == 4);", "id": "Menguraikan serangkaian angka untuk mengungkap pola dan memahami nilai sebenarnya yang diwakili oleh setiap digit.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParameter:\n- data_str: Sebuah string yang mewakili serangkaian angka. Panjang tidak melebihi 100.\n\nMengembalikan:\nint: Hasil dari setiap string data yang sesuai dengan sisi kanan persamaan.\n\nContoh penggunaan:\nassert(decode_numbers(\"0000\") == 4);", "ja": "数字のシリーズをデコードしてパターンを明らかにし、各桁が表す実際の値を理解します。\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nパラメータ:\n- data_str: 数字のシリーズを表す文字列。長さは100を超えません。\n\n戻り値:\nint: 方程式の右辺に対応する各データ文字列の結果。\n\n使用例:\nassert(decode_numbers(\"0000\") == 4);", "ko": "숫자 시퀀스를 해독하여 패턴을 밝히고 각 숫자가 나타내는 실제 값을 이해합니다.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\n매개변수:\n- data_str: 일련의 숫자를 나타내는 문자열입니다. 길이는 100을 초과하지 않습니다.\n\n반환:\nint: 방정식의 오른쪽에 해당하는 각 데이터 문자열의 결과입니다.\n\n사용 예:\nassert(decode_numbers(\"0000\") == 4);", "ml": "ഒരു സംഖ്യാ പരമ്പര ഡികോഡ് ചെയ്ത് ഓരോ അക്കവും പ്രതിനിധാനം ചെയ്യുന്ന യഥാർത്ഥ മൂല്യങ്ങൾ മനസ്സിലാക്കുക.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nപാരാമീറ്ററുകൾ:\n- data_str: സംഖ്യകളുടെ ഒരു ശ്രേണിയെ പ്രതിനിധീകരിക്കുന്ന ഒരു സ്ട്രിംഗ്. നീളം 100 കവിഞ്ഞുപോവില്ല.\n\nമടക്കുക:\nint: സമവാക്യത്തിന്റെ വലതുഭാഗത്തോട് അനുബന്ധിച്ച ഓരോ ഡാറ്റ സ്ട്രിംഗിന്റെയും ഫലം.\n\nഉദാഹരണ ഉപയോഗം:\nassert(decode_numbers(\"0000\") == 4);", "fa": "یک سری از اعداد را رمزگشایی کنید تا الگو را آشکار کرده و مقادیر واقعی هر رقم را درک کنید.  \n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4  \n\nParameters:  \nپارامترها:  \n- data_str: یک رشته که نشان‌دهنده یک سری از اعداد است. طول آن از 100 تجاوز نمی‌کند.  \n\nReturns:  \nبازمی‌گرداند:  \nint: The result of each data string corresponding to the right-hand side of the equation.  \nint: نتیجه هر رشته داده که با سمت راست معادله مطابقت دارد.  \n\nExample usage:  \nمثال استفاده:  \nassert(decode_numbers(\"0000\") == 4);  "}}
{"task_id": "C/15", "prompt": {"en": "#include <assert.h>\n#include <stdio.h>\n/*\nCounts the number of different coloring methods for n squares with m colors,\nconsidering the requirement that adjacent squares and the first/last squares\nmust have different colors.\n    Args:\n- n (int): The number of squares.\n- m (int): The number of colors.\n    Returns:\n    int: The count of different coloring methods satisfying the specified conditions. Result is modulo 1000003.\n    >>> count_coloring_methods(1,1)\n    1\n*/\nint count_coloring_methods(int n, int m)", "sq": "#include <assert.h>\n#include <stdio.h>\n/*\nNumëron numrin e metodave të ndryshme të ngjyrosjes për n katrorë me m ngjyra,\nduke konsideruar kërkesën që katrorët ngjitur dhe katrorët e parë/fundit\nduhet të kenë ngjyra të ndryshme.\n    Argumentet:\n- n (int): Numri i katrorëve.\n- m (int): Numri i ngjyrave.\n    Kthen:\n    int: Numri i metodave të ndryshme të ngjyrosjes që plotësojnë kushtet e specifikuara. Rezultati është modulo 1000003.\n    >>> count_coloring_methods(1,1)\n    1\n*/\nint count_coloring_methods(int n, int m)", "hy": "#include <assert.h>\n#include <stdio.h>\n/*\nՀաշվում է n քառակուսիների համար տարբեր գունավորման մեթոդների քանակը m գույներով,\nհաշվի առնելով այն պահանջը, որ հարակից քառակուսիները և առաջին/վերջին քառակուսիները\nպետք է ունենան տարբեր գույներ։\n    Արգումենտներ:\n- n (int): Քառակուսիների քանակը։\n- m (int): Գույների քանակը։\n    Վերադարձնում է:\n    int: Տարբեր գունավորման մեթոդների քանակը, որը բավարարում է նշված պայմանները։ Արդյունքը մոդուլ 1000003։\n    >>> count_coloring_methods(1,1)\n    1\n*/\nint count_coloring_methods(int n, int m)", "bn": "#include <assert.h>\n#include <stdio.h>\n/*\nn টি বর্গক্ষেত্র এবং m টি রঙের জন্য বিভিন্ন রঙ করার পদ্ধতির সংখ্যা গণনা করে,\nযেখানে শর্ত হল যে সংলগ্ন বর্গক্ষেত্র এবং প্রথম/শেষ বর্গক্ষেত্রগুলির রঙ ভিন্ন হতে হবে।\n    Args:\n- n (int): বর্গক্ষেত্রের সংখ্যা।\n- m (int): রঙের সংখ্যা।\n    Returns:\n    int: নির্দিষ্ট শর্তগুলি পূরণকারী বিভিন্ন রঙ করার পদ্ধতির সংখ্যা। ফলাফল 1000003 দ্বারা মডুলো।\n    >>> count_coloring_methods(1,1)\n    1\n*/\nint count_coloring_methods(int n, int m)", "bg": "#include <assert.h>\n#include <stdio.h>\n/*\nБрои броя на различните методи за оцветяване на n квадрата с m цвята,\nкато се има предвид изискването съседните квадрати и първият/последният квадрат\nда имат различни цветове.\n    Аргументи:\n- n (int): Броят на квадратите.\n- m (int): Броят на цветовете.\n    Връща:\n    int: Броят на различните методи за оцветяване, които удовлетворяват указаните условия. Резултатът е по модул 1000003.\n    >>> count_coloring_methods(1,1)\n    1\n*/\nint count_coloring_methods(int n, int m)", "zh": "#include <assert.h>\n#include <stdio.h>\n/*\n计算使用 m 种颜色对 n 个方格进行不同着色的方法数，\n考虑到相邻方格以及首尾方格必须具有不同颜色的要求。\n    参数:\n- n (int): 方格的数量。\n- m (int): 颜色的数量。\n    返回:\n    int: 满足指定条件的不同着色方法的数量。结果取模 1000003。\n    >>> count_coloring_methods(1,1)\n    1\n*/\nint count_coloring_methods(int n, int m)", "fr": "#include <assert.h>\n#include <stdio.h>\n/*\nCompte le nombre de méthodes de coloration différentes pour n carrés avec m couleurs,\nen tenant compte de l'exigence que les carrés adjacents et les premiers/derniers carrés\ndoivent avoir des couleurs différentes.\n    Args:\n- n (int): Le nombre de carrés.\n- m (int): Le nombre de couleurs.\n    Returns:\n    int: Le nombre de méthodes de coloration différentes satisfaisant les conditions spécifiées. Le résultat est modulo 1000003.\n    >>> count_coloring_methods(1,1)\n    1\n*/\nint count_coloring_methods(int n, int m)", "de": "#include <assert.h>\n#include <stdio.h>\n/*\nZählt die Anzahl der verschiedenen Färbemethoden für n Quadrate mit m Farben,\nunter Berücksichtigung der Anforderung, dass benachbarte Quadrate und die ersten/letzten Quadrate\nunterschiedliche Farben haben müssen.\n    Argumente:\n- n (int): Die Anzahl der Quadrate.\n- m (int): Die Anzahl der Farben.\n    Rückgabe:\n    int: Die Anzahl der verschiedenen Färbemethoden, die die angegebenen Bedingungen erfüllen. Das Ergebnis ist modulo 1000003.\n    >>> count_coloring_methods(1,1)\n    1\n*/\nint count_coloring_methods(int n, int m)", "ha": "#include <assert.h>\n#include <stdio.h>\n/*\nYana ƙididdige adadin hanyoyin canza launi daban-daban don murabba'i n tare da launuka m,\nla'akari da buƙatar cewa murabba'ai masu makwabtaka da murabba'i na farko/na ƙarshe\ndole ne su kasance da launuka daban-daban.\n    Args:\n- n (int): Yawan murabba'ai.\n- m (int): Yawan launuka.\n    Returns:\n    int: Adadin hanyoyin canza launi daban-daban da suka cika sharuɗɗan da aka fayyace. Sakamakon yana cikin modulo 1000003.\n    >>> count_coloring_methods(1,1)\n    1\n*/\nint count_coloring_methods(int n, int m)", "hi": "#include <assert.h>\n#include <stdio.h>\n/*\nn वर्गों के लिए m रंगों के विभिन्न रंगने के तरीकों की गिनती करता है,\nइस आवश्यकता को ध्यान में रखते हुए कि आसन्न वर्गों और पहले/अंतिम वर्गों के\nरंग अलग-अलग होने चाहिए।\n    तर्क:\n- n (int): वर्गों की संख्या।\n- m (int): रंगों की संख्या।\n    लौटाता है:\n    int: निर्दिष्ट शर्तों को संतोषजनक बनाने वाले विभिन्न रंगने के तरीकों की गिनती। परिणाम 1000003 के माड्यूलो में है।\n    >>> count_coloring_methods(1,1)\n    1\n*/\nint count_coloring_methods(int n, int m)", "hu": "#include <assert.h>\n#include <stdio.h>\n/*\nMegszámolja az n négyzet különböző színezési módszereinek számát m színnel,\nfigyelembe véve azt a követelményt, hogy a szomszédos négyzetek és az első/utolsó négyzetek\nkülönböző színűek legyenek.\n    Args:\n- n (int): A négyzetek száma.\n- m (int): A színek száma.\n    Returns:\n    int: A megadott feltételeknek megfelelő különböző színezési módszerek száma. Az eredmény modulo 1000003.\n    >>> count_coloring_methods(1,1)\n    1\n*/\nint count_coloring_methods(int n, int m)", "es": "#include <assert.h>\n#include <stdio.h>\n/*\nCuenta el número de diferentes métodos de coloreado para n cuadrados con m colores,\nconsiderando el requisito de que los cuadrados adyacentes y los primeros/últimos cuadrados\ndeben tener colores diferentes.\n    Args:\n- n (int): El número de cuadrados.\n- m (int): El número de colores.\n    Returns:\n    int: La cuenta de diferentes métodos de coloreado que satisfacen las condiciones especificadas. El resultado es módulo 1000003.\n    >>> count_coloring_methods(1,1)\n    1\n*/\nint count_coloring_methods(int n, int m)", "arb": "#include <assert.h>\n#include <stdio.h>\n/*\nيحسب عدد طرق التلوين المختلفة لمربعات n بألوان m،\nمع مراعاة الشرط الذي يتطلب أن تكون المربعات المتجاورة والمربعات الأولى/الأخيرة\nلها ألوان مختلفة.\n    Args:\n- n (int): عدد المربعات.\n- m (int): عدد الألوان.\n    Returns:\n    int: عدد طرق التلوين المختلفة التي تلبي الشروط المحددة. النتيجة تكون موديولو 1000003.\n    >>> count_coloring_methods(1,1)\n    1\n*/\nint count_coloring_methods(int n, int m)", "sw": "#include <assert.h>\n#include <stdio.h>\n/*\nInahesabu idadi ya mbinu tofauti za kupaka rangi miraba n kwa rangi m,\nikizingatia hitaji kwamba miraba ya karibu na miraba ya kwanza/mwisho\nlazima iwe na rangi tofauti.\n    Args:\n- n (int): Idadi ya miraba.\n- m (int): Idadi ya rangi.\n    Returns:\n    int: Idadi ya mbinu tofauti za kupaka rangi zinazokidhi masharti maalum. Matokeo ni modulo 1000003.\n    >>> count_coloring_methods(1,1)\n    1\n*/\nint count_coloring_methods(int n, int m)", "tr": "#include <assert.h>\n#include <stdio.h>\n/*\nn kare için m renk ile farklı boyama yöntemlerinin sayısını sayar,\nbitişik karelerin ve ilk/son karelerin farklı renklere sahip olması gerektiği şartını dikkate alarak.\n    Args:\n- n (int): Karelerin sayısı.\n- m (int): Renklerin sayısı.\n    Returns:\n    int: Belirtilen koşulları karşılayan farklı boyama yöntemlerinin sayısı. Sonuç 1000003 ile mod alınır.\n    >>> count_coloring_methods(1,1)\n    1\n*/\nint count_coloring_methods(int n, int m)", "vi": "#include <assert.h>\n#include <stdio.h>\n/*\nĐếm số lượng phương pháp tô màu khác nhau cho n ô vuông với m màu,\nxét đến yêu cầu rằng các ô vuông liền kề và ô đầu/cuối\nphải có màu khác nhau.\n    Tham số:\n- n (int): Số lượng ô vuông.\n- m (int): Số lượng màu.\n    Trả về:\n    int: Số lượng phương pháp tô màu khác nhau thỏa mãn các điều kiện đã chỉ định. Kết quả là modulo 1000003.\n    >>> count_coloring_methods(1,1)\n    1\n*/\nint count_coloring_methods(int n, int m)", "id": "#include <assert.h>\n#include <stdio.h>\n/*\nMenghitung jumlah metode pewarnaan berbeda untuk n kotak dengan m warna,\ndengan mempertimbangkan persyaratan bahwa kotak yang bersebelahan dan kotak pertama/terakhir\nharus memiliki warna yang berbeda.\n    Args:\n- n (int): Jumlah kotak.\n- m (int): Jumlah warna.\n    Returns:\n    int: Jumlah metode pewarnaan berbeda yang memenuhi kondisi yang ditentukan. Hasil adalah modulo 1000003.\n    >>> count_coloring_methods(1,1)\n    1\n*/\nint count_coloring_methods(int n, int m)", "ja": "#include <assert.h>\n#include <stdio.h>\n/*\nn個の正方形をm色で塗る異なる方法の数を数えます。\n隣接する正方形と最初/最後の正方形が異なる色である必要があることを考慮します。\n    引数:\n- n (int): 正方形の数。\n- m (int): 色の数。\n    戻り値:\n    int: 指定された条件を満たす異なる塗り方の数。結果は1000003での剰余です。\n    >>> count_coloring_methods(1,1)\n    1\n*/\nint count_coloring_methods(int n, int m)\n", "ko": "#include <assert.h>\n#include <stdio.h>\n/*\nn개의 정사각형을 m개의 색상으로 칠하는 서로 다른 방법의 수를 계산합니다.\n인접한 정사각형과 첫 번째/마지막 정사각형은 다른 색상이어야 한다는 요구 사항을 고려합니다.\n    인자:\n- n (int): 정사각형의 수.\n- m (int): 색상의 수.\n    반환:\n    int: 지정된 조건을 만족하는 서로 다른 색칠 방법의 수. 결과는 1000003으로 모듈로 연산됩니다.\n    >>> count_coloring_methods(1,1)\n    1\n*/\nint count_coloring_methods(int n, int m)", "ml": "#include <assert.h>\n#include <stdio.h>\n/*\nn ചതുരങ്ങൾ m നിറങ്ങളുമായി വ്യത്യസ്തമായ നിറപ്പെടുത്തൽ രീതികളുടെ എണ്ണം എണ്ണുന്നു,\nചതുരങ്ങൾ തമ്മിലുള്ള സമീപസ്ഥിതിയിലുള്ള ചതുരങ്ങളും ആദ്യ/അവസാന ചതുരങ്ങളും\nവ്യത്യസ്ത നിറങ്ങൾ വേണം എന്ന ആവശ്യകത പരിഗണിക്കുന്നു.\n    Args:\n- n (int): ചതുരങ്ങളുടെ എണ്ണം.\n- m (int): നിറങ്ങളുടെ എണ്ണം.\n    Returns:\n    int: നിർദ്ദിഷ്ട വ്യവസ്ഥകൾ പാലിക്കുന്ന വ്യത്യസ്ത നിറപ്പെടുത്തൽ രീതികളുടെ എണ്ണം. ഫലം 1000003 ന്റെ മോഡുലോ ആണ്.\n    >>> count_coloring_methods(1,1)\n    1\n*/\nint count_coloring_methods(int n, int m)", "fa": "#include <assert.h>\n#include <stdio.h>\n/*\nتعداد روش‌های مختلف رنگ‌آمیزی برای n مربع با m رنگ را شمارش می‌کند،\nبا در نظر گرفتن این شرط که مربع‌های مجاور و مربع‌های اول/آخر باید رنگ‌های متفاوتی داشته باشند.\n    آرگومان‌ها:\n- n (int): تعداد مربع‌ها.\n- m (int): تعداد رنگ‌ها.\n    بازگشت:\n    int: تعداد روش‌های مختلف رنگ‌آمیزی که شرایط مشخص شده را برآورده می‌کند. نتیجه به صورت مدولوی 1000003 است.\n    >>> count_coloring_methods(1,1)\n    1\n*/\nint count_coloring_methods(int n, int m)\n"}, "canonical_solution": "{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return (long long)m * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = (long long)m * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = (long long)f[2] * (m - 2) % 1000003;\n    for(int i = 4; i <= n; i++) {\n        f[i] = ((long long)f[i - 1] * (m - 2) % 1000003 +\n                (long long)f[i - 2] * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}", "instruction": {"en": "int count_coloring_methods(int n, int m)\n{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return (long long)m * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = (long long)m * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = (long long)f[2] * (m - 2) % 1000003;\n    for(int i = 4; i <= n; i++) {\n        f[i] = ((long long)f[i - 1] * (m - 2) % 1000003 +\n                (long long)f[i - 2] * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "sq": "int count_coloring_methods(int n, int m)\n{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return (long long)m * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = (long long)m * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = (long long)f[2] * (m - 2) % 1000003;\n    for(int i = 4; i <= n; i++) {\n        f[i] = ((long long)f[i - 1] * (m - 2) % 1000003 +\n                (long long)f[i - 2] * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrale (docstring) të kodit C në shqip duke përdorur maksimumi 500 karaktere.", "hy": "int count_coloring_methods(int n, int m)\n{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return (long long)m * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = (long long)m * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = (long long)f[2] * (m - 2) % 1000003;\n    for(int i = 4; i <= n; i++) {\n        f[i] = ((long long)f[i - 1] * (m - 2) % 1000003 +\n                (long long)f[i - 2] * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}\n\nՏվեք C կոդի հակիրճ բնական լեզվով նկարագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "int count_coloring_methods(int n, int m)\n{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return (long long)m * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = (long long)m * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = (long long)f[2] * (m - 2) % 1000003;\n    for(int i = 4; i <= n; i++) {\n        f[i] = ((long long)f[i - 1] * (m - 2) % 1000003 +\n                (long long)f[i - 2] * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}\n\nসি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।", "bg": "int count_coloring_methods(int n, int m)\n{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return (long long)m * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = (long long)m * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = (long long)f[2] * (m - 2) % 1000003;\n    for(int i = 4; i <= n; i++) {\n        f[i] = ((long long)f[i - 1] * (m - 2) % 1000003 +\n                (long long)f[i - 2] * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, използвайки най-много 500 знака.", "zh": "int count_coloring_methods(int n, int m)\n{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return (long long)m * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = (long long)m * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = (long long)f[2] * (m - 2) % 1000003;\n    for(int i = 4; i <= n; i++) {\n        f[i] = ((long long)f[i - 1] * (m - 2) % 1000003 +\n                (long long)f[i - 2] * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}\n\n请用不超过500个字符的中文，为以下C代码提供简洁的自然语言描述（文档字符串）。", "fr": "int count_coloring_methods(int n, int m)\n{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return (long long)m * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = (long long)m * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = (long long)f[2] * (m - 2) % 1000003;\n    for(int i = 4; i <= n; i++) {\n        f[i] = ((long long)f[i - 1] * (m - 2) % 1000003 +\n                (long long)f[i - 2] * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.", "de": "int count_coloring_methods(int n, int m)\n{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return (long long)m * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = (long long)m * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = (long long)f[2] * (m - 2) % 1000003;\n    for(int i = 4; i <= n; i++) {\n        f[i] = ((long long)f[i - 1] * (m - 2) % 1000003 +\n                (long long)f[i - 2] * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "int count_coloring_methods(int n, int m)\n{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return (long long)m * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = (long long)m * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = (long long)f[2] * (m - 2) % 1000003;\n    for(int i = 4; i <= n; i++) {\n        f[i] = ((long long)f[i - 1] * (m - 2) % 1000003 +\n                (long long)f[i - 2] * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}\n\nBa da taƙaitaccen bayani a cikin yare na halitta (docstring) na lambar C cikin Hausa, ba tare da wuce haruffa 500 ba.", "hi": "int count_coloring_methods(int n, int m)\n{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return (long long)m * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = (long long)m * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = (long long)f[2] * (m - 2) % 1000003;\n    for(int i = 4; i <= n; i++) {\n        f[i] = ((long long)f[i - 1] * (m - 2) % 1000003 +\n                (long long)f[i - 2] * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}\n\nC कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "int count_coloring_methods(int n, int m)\n{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return (long long)m * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = (long long)m * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = (long long)f[2] * (m - 2) % 1000003;\n    for(int i = 4; i <= n; i++) {\n        f[i] = ((long long)f[i - 1] * (m - 2) % 1000003 +\n                (long long)f[i - 2] * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben.", "es": "int count_coloring_methods(int n, int m)\n{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return (long long)m * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = (long long)m * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = (long long)f[2] * (m - 2) % 1000003;\n    for(int i = 4; i <= n; i++) {\n        f[i] = ((long long)f[i - 1] * (m - 2) % 1000003 +\n                (long long)f[i - 2] * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando como máximo 500 caracteres.", "arb": "int count_coloring_methods(int n, int m)\n{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return (long long)m * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = (long long)m * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = (long long)f[2] * (m - 2) % 1000003;\n    for(int i = 4; i <= n; i++) {\n        f[i] = ((long long)f[i - 1] * (m - 2) % 1000003 +\n                (long long)f[i - 2] * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "int count_coloring_methods(int n, int m)\n{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return (long long)m * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = (long long)m * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = (long long)f[2] * (m - 2) % 1000003;\n    for(int i = 4; i <= n; i++) {\n        f[i] = ((long long)f[i - 1] * (m - 2) % 1000003 +\n                (long long)f[i - 2] * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "int count_coloring_methods(int n, int m)\n{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return (long long)m * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = (long long)m * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = (long long)f[2] * (m - 2) % 1000003;\n    for(int i = 4; i <= n; i++) {\n        f[i] = ((long long)f[i - 1] * (m - 2) % 1000003 +\n                (long long)f[i - 2] * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}\n\nC kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, Türkçe olarak en fazla 500 karakter içermelidir.", "vi": "int count_coloring_methods(int n, int m)\n{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return (long long)m * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = (long long)m * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = (long long)f[2] * (m - 2) % 1000003;\n    for(int i = 4; i <= n; i++) {\n        f[i] = ((long long)f[i - 1] * (m - 2) % 1000003 +\n                (long long)f[i - 2] * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã C bằng tiếng Việt, sử dụng tối đa 500 ký tự.", "id": "int count_coloring_methods(int n, int m)\n{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return (long long)m * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = (long long)m * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = (long long)f[2] * (m - 2) % 1000003;\n    for(int i = 4; i <= n; i++) {\n        f[i] = ((long long)f[i - 1] * (m - 2) % 1000003 +\n                (long long)f[i - 2] * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode C dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "int count_coloring_methods(int n, int m)\n{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return (long long)m * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = (long long)m * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = (long long)f[2] * (m - 2) % 1000003;\n    for(int i = 4; i <= n; i++) {\n        f[i] = ((long long)f[i - 1] * (m - 2) % 1000003 +\n                (long long)f[i - 2] * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}\n\nCコードの簡潔な自然言語による説明（ドックストリング）を日本語で500文字以内で提供してください。", "ko": "int count_coloring_methods(int n, int m)\n{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return (long long)m * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = (long long)m * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = (long long)f[2] * (m - 2) % 1000003;\n    for(int i = 4; i <= n; i++) {\n        f[i] = ((long long)f[i - 1] * (m - 2) % 1000003 +\n                (long long)f[i - 2] * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}\n\nC 코드의 동작을 설명하는 간결한 자연어 설명(docstring)을 한국어로 작성하세요. 최대 500자 이내로 작성해야 합니다.", "ml": "int count_coloring_methods(int n, int m)\n{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return (long long)m * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = (long long)m * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = (long long)f[2] * (m - 2) % 1000003;\n    for(int i = 4; i <= n; i++) {\n        f[i] = ((long long)f[i - 1] * (m - 2) % 1000003 +\n                (long long)f[i - 2] * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}\n\nC കോഡ് ഉപയോഗിച്ച് 500 അക്ഷരങ്ങളിൽ കൂടാതെയുള്ള സംക്ഷിപ്തമായ സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) മലയാളത്തിൽ നൽകുക.", "fa": "int count_coloring_methods(int n, int m)\n{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return (long long)m * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = (long long)m * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = (long long)f[2] * (m - 2) % 1000003;\n    for(int i = 4; i <= n; i++) {\n        f[i] = ((long long)f[i - 1] * (m - 2) % 1000003 +\n                (long long)f[i - 2] * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}\n\nتوضیح مختصر و طبیعی (docstring) از کد C را به زبان فارسی با حداکثر ۵۰۰ کاراکتر ارائه دهید."}, "level": "", "test": "int main() {\n    assert(count_coloring_methods(1, 1) == 1);\n    assert(count_coloring_methods(2, 2) == 2);\n    assert(count_coloring_methods(3, 3) == 6);\n    assert(count_coloring_methods(4, 2) == 2);\n    assert(count_coloring_methods(1000, 10) == 566585); // We don't have the expected result for this case\n\n    // Additional test cases\n    assert(count_coloring_methods(2, 3) == 6);\n    assert(count_coloring_methods(1000, 1000) == 67911);\n    assert(count_coloring_methods(999,66) == 501817);\n    assert(count_coloring_methods(5, 3) == 30); // Example of an expected output\n\n    // printf(\"All tests passed!\\n\");\n    return 0;\n}", "entry_point": "count_coloring_methods", "signature": "int count_coloring_methods(int n, int m)", "docstring": {"en": "Counts the number of different coloring methods for n squares with m colors, considering the requirement that adjacent squares and the first/last squares must have different colors.\n    Args:\n- n (int): The number of squares.\n- m (int): The number of colors.\n    Returns:\n    int: The count of different coloring methods satisfying the specified conditions. Result is modulo 1000003.\n    >>> count_coloring_methods(1,1)\n    1\n", "sq": "Numëron numrin e metodave të ndryshme të ngjyrosjes për n katrorë me m ngjyra, duke marrë parasysh kërkesën që katrorët fqinjë dhe katrorët e parë/fundit duhet të kenë ngjyra të ndryshme.\n    Argumentet:\n- n (int): Numri i katrorëve.\n- m (int): Numri i ngjyrave.\n    Kthen:\n    int: Numri i metodave të ndryshme të ngjyrosjes që plotësojnë kushtet e specifikuara. Rezultati është modulo 1000003.\n    >>> count_coloring_methods(1,1)\n    1", "hy": "Հաշվում է քառակուսիների n քանակի տարբեր գունավորման մեթոդների քանակը m գույներով՝ հաշվի առնելով այն պահանջը, որ հարակից քառակուսիները և առաջին/վերջին քառակուսիները պետք է ունենան տարբեր գույներ:\n    Արգումենտներ:\n- n (int): Քառակուսիների քանակը:\n- m (int): Գույների քանակը:\n    Վերադարձնում է:\n    int: Տարբեր գունավորման մեթոդների քանակը, որոնք բավարարում են նշված պայմանները: Արդյունքը մոդուլո 1000003 է:\n    >>> count_coloring_methods(1,1)\n    1", "bn": "nটি বর্গক্ষেত্রের জন্য mটি রঙের বিভিন্ন রঙ করার পদ্ধতির সংখ্যা গণনা করে, যেখানে শর্ত হল যে সংলগ্ন বর্গক্ষেত্র এবং প্রথম/শেষ বর্গক্ষেত্রের রঙ ভিন্ন হতে হবে।\n    Args:\n- n (int): বর্গক্ষেত্রের সংখ্যা।\n- m (int): রঙের সংখ্যা।\n    Returns:\n    int: নির্দিষ্ট শর্তগুলি পূরণ করে এমন বিভিন্ন রঙ করার পদ্ধতির সংখ্যা। ফলাফল 1000003 দ্বারা মডুলো।\n    >>> count_coloring_methods(1,1)\n    1", "bg": "Брои броя на различните методи за оцветяване на n квадрата с m цвята, като се взема предвид изискването съседните квадрати и първият/последният квадрат да имат различни цветове.\n    Аргументи:\n- n (int): Броят на квадратите.\n- m (int): Броят на цветовете.\n    Връща:\n    int: Броят на различните методи за оцветяване, които удовлетворяват посочените условия. Резултатът е модуло 1000003.\n    >>> count_coloring_methods(1,1)\n    1", "zh": "计算使用 m 种颜色对 n 个方格进行不同着色的方法数量，考虑到相邻方格以及第一个/最后一个方格必须具有不同颜色的要求。\n    参数：\n- n (int): 方格的数量。\n- m (int): 颜色的数量。\n    返回：\n    int: 满足指定条件的不同着色方法的数量。结果取模 1000003。\n    >>> count_coloring_methods(1,1)\n    1", "fr": "Compte le nombre de méthodes de coloration différentes pour n carrés avec m couleurs, en considérant l'exigence que les carrés adjacents et les premiers/derniers carrés doivent avoir des couleurs différentes.\n    Args:\n- n (int): Le nombre de carrés.\n- m (int): Le nombre de couleurs.\n    Returns:\n    int: Le compte des différentes méthodes de coloration satisfaisant les conditions spécifiées. Le résultat est modulo 1000003.\n    >>> count_coloring_methods(1,1)\n    1", "de": "Zählt die Anzahl der verschiedenen Färbemethoden für n Quadrate mit m Farben, unter Berücksichtigung der Anforderung, dass benachbarte Quadrate und die ersten/letzten Quadrate unterschiedliche Farben haben müssen.\nArgs:\n- n (int): Die Anzahl der Quadrate.\n- m (int): Die Anzahl der Farben.\nReturns:\nint: Die Anzahl der verschiedenen Färbemethoden, die die angegebenen Bedingungen erfüllen. Das Ergebnis ist modulo 1000003.\n>>> count_coloring_methods(1,1)\n1", "ha": "Yana ƙididdige yawan hanyoyin launuka daban-daban don murabba'i n tare da launuka m, la'akari da buƙatar cewa murabba'i masu makwabtaka da murabba'i na farko/na ƙarshe dole ne su sami launuka daban-daban.\n    Args:\n- n (int): Yawan murabba'ai.\n- m (int): Yawan launuka.\n    Returns:\n    int: Adadin hanyoyin launuka daban-daban da suka cika sharuɗɗan da aka fayyace. Sakamakon yana daidai da modulo 1000003.\n    >>> count_coloring_methods(1,1)\n    1", "hi": "विभिन्न रंगाई विधियों की संख्या की गणना करता है n वर्गों के लिए m रंगों के साथ, इस आवश्यकता को ध्यान में रखते हुए कि आसन्न वर्गों और पहले/अंतिम वर्गों के रंग अलग-अलग होने चाहिए।\n    तर्क:\n- n (int): वर्गों की संख्या।\n- m (int): रंगों की संख्या।\n    वापसी:\n    int: निर्दिष्ट शर्तों को संतुष्ट करने वाली विभिन्न रंगाई विधियों की संख्या। परिणाम 1000003 के मापांक में है।\n    >>> count_coloring_methods(1,1)\n    1", "hu": "Számolja meg az n négyzet különböző színezési módszereinek számát m színnel, figyelembe véve azt a követelményt, hogy a szomszédos négyzetek és az első/utolsó négyzetek különböző színűek legyenek.\n    Args:\n- n (int): A négyzetek száma.\n- m (int): A színek száma.\n    Returns:\n    int: A megadott feltételeknek megfelelő különböző színezési módszerek száma. Az eredmény modulo 1000003.\n    >>> count_coloring_methods(1,1)\n    1", "es": "Cuenta el número de diferentes métodos de coloreado para n cuadrados con m colores, considerando el requisito de que los cuadrados adyacentes y los primeros/últimos cuadrados deben tener colores diferentes.\n    Args:\n- n (int): El número de cuadrados.\n- m (int): El número de colores.\n    Returns:\n    int: El conteo de diferentes métodos de coloreado que satisfacen las condiciones especificadas. El resultado es módulo 1000003.\n    >>> count_coloring_methods(1,1)\n    1", "arb": "يحسب عدد طرق التلوين المختلفة لمربعات n باستخدام ألوان m، مع مراعاة الشرط الذي ينص على أن المربعات المتجاورة والمربعات الأولى/الأخيرة يجب أن تكون بألوان مختلفة.\n    المعاملات:\n- n (int): عدد المربعات.\n- m (int): عدد الألوان.\n    يعيد:\n    int: عدد طرق التلوين المختلفة التي تلبي الشروط المحددة. النتيجة هي باقي القسمة على 1000003.\n    >>> count_coloring_methods(1,1)\n    1", "sw": "Hesabu idadi ya mbinu tofauti za kupaka rangi mraba n kwa rangi m, ukizingatia hitaji kwamba miraba iliyo karibu na mraba wa kwanza/wa mwisho lazima iwe na rangi tofauti.\n    Args:\n- n (int): Idadi ya miraba.\n- m (int): Idadi ya rangi.\n    Returns:\n    int: Idadi ya mbinu tofauti za kupaka rangi zinazokidhi masharti maalum. Matokeo ni modulo 1000003.\n    >>> count_coloring_methods(1,1)\n    1", "tr": "n kareyi m renkle boyamak için farklı yöntemlerin sayısını, bitişik karelerin ve ilk/son karelerin farklı renklere sahip olması gerektiği şartını göz önünde bulundurarak sayar.\n    Args:\n- n (int): Karelerin sayısı.\n- m (int): Renklerin sayısı.\n    Returns:\n    int: Belirtilen koşulları karşılayan farklı boyama yöntemlerinin sayısı. Sonuç 1000003 ile mod alınır.\n    >>> count_coloring_methods(1,1)\n    1", "vi": "Đếm số lượng phương pháp tô màu khác nhau cho n ô vuông với m màu, xem xét yêu cầu rằng các ô vuông liền kề và ô vuông đầu/cuối phải có màu khác nhau.\n    Tham số:\n- n (int): Số lượng ô vuông.\n- m (int): Số lượng màu.\n    Trả về:\n    int: Số lượng phương pháp tô màu khác nhau thỏa mãn các điều kiện đã chỉ định. Kết quả là modulo 1000003.\n    >>> count_coloring_methods(1,1)\n    1", "id": "Menghitung jumlah metode pewarnaan berbeda untuk n kotak dengan m warna, dengan mempertimbangkan persyaratan bahwa kotak yang berdekatan dan kotak pertama/terakhir harus memiliki warna yang berbeda.\n    Args:\n- n (int): Jumlah kotak.\n- m (int): Jumlah warna.\n    Returns:\n    int: Jumlah metode pewarnaan berbeda yang memenuhi kondisi yang ditentukan. Hasil adalah modulo 1000003.\n    >>> count_coloring_methods(1,1)\n    1", "ja": "n個の正方形をm色で塗り分ける方法の数を数えます。ただし、隣接する正方形および最初と最後の正方形は異なる色でなければなりません。\n    引数:\n- n (int): 正方形の数。\n- m (int): 色の数。\n    戻り値:\n    int: 指定された条件を満たす異なる塗り分け方法の数。結果は1000003での剰余です。\n    >>> count_coloring_methods(1,1)\n    1", "ko": "n개의 정사각형을 m개의 색상으로 색칠하는 서로 다른 방법의 수를 계산합니다. 인접한 정사각형과 첫 번째/마지막 정사각형은 다른 색상이어야 한다는 요구 사항을 고려합니다.\n    인수:\n- n (int): 정사각형의 수.\n- m (int): 색상의 수.\n    반환값:\n    int: 지정된 조건을 만족하는 서로 다른 색칠 방법의 수. 결과는 1000003으로 나눈 나머지입니다.\n    >>> count_coloring_methods(1,1)\n    1", "ml": "n ചതുരങ്ങൾ m നിറങ്ങളുമായി വ്യത്യസ്തമായ നിറപ്പെടുത്തൽ രീതികളുടെ എണ്ണം, ചേർന്നിരിക്കുന്ന ചതുരങ്ങൾക്കും ആദ്യ/അവസാന ചതുരങ്ങൾക്കും വ്യത്യസ്ത നിറങ്ങൾ വേണമെന്ന ആവശ്യം പരിഗണിച്ച് കണക്കാക്കുന്നു.\n    Args:\n- n (int): ചതുരങ്ങളുടെ എണ്ണം.\n- m (int): നിറങ്ങളുടെ എണ്ണം.\n    Returns:\n    int: നിർദ്ദിഷ്ട വ്യവസ്ഥകൾ പാലിക്കുന്ന വ്യത്യസ്ത നിറപ്പെടുത്തൽ രീതികളുടെ എണ്ണം. ഫലം 1000003-നു മോഡുലോ ആണ്.\n    >>> count_coloring_methods(1,1)\n    1", "fa": "تعداد روش‌های مختلف رنگ‌آمیزی برای n مربع با m رنگ را محاسبه می‌کند، با توجه به این شرط که مربع‌های مجاور و مربع‌های اول/آخر باید رنگ‌های مختلفی داشته باشند.\n    آرگومان‌ها:\n- n (int): تعداد مربع‌ها.\n- m (int): تعداد رنگ‌ها.\n    بازگشت:\n    int: تعداد روش‌های مختلف رنگ‌آمیزی که شرایط مشخص شده را برآورده می‌کنند. نتیجه به پیمانه 1000003 است.\n    >>> count_coloring_methods(1,1)\n    1"}}
{"task_id": "C/16", "prompt": {"en": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCount the number of valid coin toss sequences with no consecutive heads in n tosses.\n​    Parameters:\n- n (int): The number of coin tosses.\n​    Returns:\n​    unsigned long long: The count of valid sequences.\n    >>> count_valid_coin_toss_sequences(1)\n    2\n*/\nunsigned long long count_valid_coin_toss_sequences(int n)", "sq": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nNumëroni numrin e sekuencave të vlefshme të hedhjeve të monedhës pa koka radhazi në n hedhje.\n​    Parametrat:\n- n (int): Numri i hedhjeve të monedhës.\n​    Kthen:\n​    unsigned long long: Numri i sekuencave të vlefshme.\n    >>> count_valid_coin_toss_sequences(1)\n    2\n*/\nunsigned long long count_valid_coin_toss_sequences(int n)", "hy": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nՀաշվել վավեր մետաղադրամի նետումների հաջորդականությունների քանակը, որտեղ n նետումների ժամանակ հաջորդական գլուխներ չկան։\n​    Պարամետրեր:\n- n (int): Մետաղադրամի նետումների քանակը։\n​    Վերադարձնում է:\n​    unsigned long long: Վավեր հաջորդականությունների քանակը։\n    >>> count_valid_coin_toss_sequences(1)\n    2\n*/\nunsigned long long count_valid_coin_toss_sequences(int n)", "bn": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nকোনো পরপর হেড না থাকা n টসের বৈধ কয়েন টস সিকোয়েন্সের সংখ্যা গণনা করুন।\n    প্যারামিটার:\n- n (int): কয়েন টসের সংখ্যা।\n    রিটার্নস:\n    unsigned long long: বৈধ সিকোয়েন্সের সংখ্যা।\n    >>> count_valid_coin_toss_sequences(1)\n    2\n*/\nunsigned long long count_valid_coin_toss_sequences(int n)", "bg": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nБрой на валидните последователности от хвърляния на монета без последователни ези в n хвърляния.\n​    Параметри:\n- n (int): Броят на хвърлянията на монета.\n​    Връща:\n​    unsigned long long: Броят на валидните последователности.\n    >>> count_valid_coin_toss_sequences(1)\n    2\n*/\nunsigned long long count_valid_coin_toss_sequences(int n)", "zh": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n计算在 n 次投掷中没有连续正面的有效投币序列的数量。\n​    参数:\n- n (int): 投币次数。\n​    返回:\n​    unsigned long long: 有效序列的数量。\n    >>> count_valid_coin_toss_sequences(1)\n    2\n*/\nunsigned long long count_valid_coin_toss_sequences(int n)", "fr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCompter le nombre de séquences de lancers de pièces valides sans faces consécutives dans n lancers.\n    Paramètres:\n- n (int): Le nombre de lancers de pièces.\n    Renvoie:\n    unsigned long long: Le nombre de séquences valides.\n    >>> count_valid_coin_toss_sequences(1)\n    2\n*/\nunsigned long long count_valid_coin_toss_sequences(int n)", "de": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nZählt die Anzahl der gültigen Münzwurfsequenzen ohne aufeinanderfolgende Köpfe bei n Würfen.\n​    Parameter:\n- n (int): Die Anzahl der Münzwürfe.\n​    Rückgabe:\n​    unsigned long long: Die Anzahl der gültigen Sequenzen.\n    >>> count_valid_coin_toss_sequences(1)\n    2\n*/\nunsigned long long count_valid_coin_toss_sequences(int n)", "ha": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nƘirga adadin sahihan jerin jefa tsabar kudi ba tare da kanun kai a jere ba a cikin jefa tsabar kudi n.\n​    Sigogi:\n- n (int): Yawan jefa tsabar kudi.\n​    Komawa:\n​    unsigned long long: Adadin sahihan jerin.\n    >>> count_valid_coin_toss_sequences(1)\n    2\n*/\nunsigned long long count_valid_coin_toss_sequences(int n)", "hi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nn उछालों में बिना लगातार हेड्स के वैध सिक्का उछाल अनुक्रमों की संख्या गिनें।\n​    पैरामीटर्स:\n- n (int): सिक्का उछालों की संख्या।\n​    रिटर्न करता है:\n​    unsigned long long: वैध अनुक्रमों की गिनती।\n    >>> count_valid_coin_toss_sequences(1)\n    2\n*/\nunsigned long long count_valid_coin_toss_sequences(int n)", "hu": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nSzámolja meg az érvényes pénzfeldobási sorozatok számát, ahol n dobásban nincs egymást követő fej.\n​    Paraméterek:\n- n (int): A pénzfeldobások száma.\n​    Visszatérési érték:\n​    unsigned long long: Az érvényes sorozatok száma.\n    >>> count_valid_coin_toss_sequences(1)\n    2\n*/\nunsigned long long count_valid_coin_toss_sequences(int n)", "es": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCuenta el número de secuencias válidas de lanzamientos de moneda sin caras consecutivas en n lanzamientos.\n    Parámetros:\n- n (int): El número de lanzamientos de moneda.\n    Devuelve:\n    unsigned long long: El conteo de secuencias válidas.\n    >>> count_valid_coin_toss_sequences(1)\n    2\n*/\nunsigned long long count_valid_coin_toss_sequences(int n)", "arb": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nاحسب عدد تسلسلات رمي العملة الصحيحة بدون رؤوس متتالية في n رميات.\n    المعلمات:\n- n (int): عدد رميات العملة.\n    يعيد:\n    unsigned long long: عدد التسلسلات الصحيحة.\n    >>> count_valid_coin_toss_sequences(1)\n    2\n*/\nunsigned long long count_valid_coin_toss_sequences(int n)", "sw": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nHesabu idadi ya mfuatano halali wa kurusha sarafu bila vichwa mfululizo katika kurusha n.\n    Vigezo:\n- n (int): Idadi ya kurusha sarafu.\n    Inarudisha:\n    unsigned long long: Idadi ya mfuatano halali.\n    >>> count_valid_coin_toss_sequences(1)\n    2\n*/\nunsigned long long count_valid_coin_toss_sequences(int n)", "tr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nArdışık yazı tura atışlarında ardışık turalar olmadan geçerli atış dizilerinin sayısını sayın.\n​    Parametreler:\n- n (int): Yazı tura atışlarının sayısı.\n​    Döndürür:\n​    unsigned long long: Geçerli dizilerin sayısı.\n    >>> count_valid_coin_toss_sequences(1)\n    2\n*/\nunsigned long long count_valid_coin_toss_sequences(int n)", "vi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nĐếm số lượng chuỗi tung đồng xu hợp lệ không có hai mặt ngửa liên tiếp trong n lần tung.\n    Tham số:\n- n (int): Số lần tung đồng xu.\n    Trả về:\n    unsigned long long: Số lượng chuỗi hợp lệ.\n    >>> count_valid_coin_toss_sequences(1)\n    2\n*/\nunsigned long long count_valid_coin_toss_sequences(int n)", "id": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nMenghitung jumlah urutan lemparan koin yang valid tanpa kepala berturut-turut dalam n lemparan.\n    Parameter:\n- n (int): Jumlah lemparan koin.\n    Mengembalikan:\n    unsigned long long: Jumlah urutan yang valid.\n    >>> count_valid_coin_toss_sequences(1)\n    2\n*/\nunsigned long long count_valid_coin_toss_sequences(int n)", "ja": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n連続した表がないn回のコイントスの有効なシーケンスの数を数えます。\n​    パラメータ:\n- n (int): コイントスの回数。\n​    戻り値:\n​    unsigned long long: 有効なシーケンスの数。\n    >>> count_valid_coin_toss_sequences(1)\n    2\n*/\nunsigned long long count_valid_coin_toss_sequences(int n)", "ko": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n연속된 앞면이 없는 유효한 동전 던지기 시퀀스의 수를 n번 던졌을 때 계산합니다.\n​    매개변수:\n- n (int): 동전 던지기의 횟수.\n​    반환값:\n​    unsigned long long: 유효한 시퀀스의 수.\n    >>> count_valid_coin_toss_sequences(1)\n    2\n*/\nunsigned long long count_valid_coin_toss_sequences(int n)", "ml": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nനിലവിലുളള നാണയം എറിയൽ ശ്രേണികളുടെ എണ്ണം എണ്ണുക, n എറിയലുകളിൽ തുടർച്ചയായ തലകളില്ലാതെ.\n    പാരാമീറ്ററുകൾ:\n- n (int): നാണയം എറിയലുകളുടെ എണ്ണം.\n    മടക്കുന്നു:\n    unsigned long long: നിലവിൽ ഉള്ള ശ്രേണികളുടെ എണ്ണം.\n    >>> count_valid_coin_toss_sequences(1)\n    2\n*/\nunsigned long long count_valid_coin_toss_sequences(int n)", "fa": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nتعداد دنباله‌های معتبر پرتاب سکه را که در آن‌ها هیچ شیر متوالی وجود ندارد، در n پرتاب بشمارید.\n    پارامترها:\n- n (int): تعداد پرتاب‌های سکه.\n    بازگشت:\n    unsigned long long: تعداد دنباله‌های معتبر.\n    >>> count_valid_coin_toss_sequences(1)\n    2\n*/\nunsigned long long count_valid_coin_toss_sequences(int n)"}, "canonical_solution": "{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n    \n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n    \n    return a[n][0] + a[n][1];\n}", "instruction": {"en": "unsigned long long count_valid_coin_toss_sequences(int n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n    \n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n    \n    return a[n][0] + a[n][1];\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "sq": "unsigned long long count_valid_coin_toss_sequences(int n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n    \n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n    \n    return a[n][0] + a[n][1];\n}\n\nJepni një përshkrim të shkurtër në gjuhën natyrore (docstring) të kodit C në shqip duke përdorur maksimumi 500 karaktere.", "hy": "unsigned long long count_valid_coin_toss_sequences(int n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n    \n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n    \n    return a[n][0] + a[n][1];\n}\n\nՏվեք C կոդի համառոտ բնութագիր (docstring) հայերեն՝ օգտագործելով առավելագույնը 500 նիշ։", "bn": "unsigned long long count_valid_coin_toss_sequences(int n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n    \n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n    \n    return a[n][0] + a[n][1];\n}\n\nসি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।", "bg": "unsigned long long count_valid_coin_toss_sequences(int n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n    \n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n    \n    return a[n][0] + a[n][1];\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, използвайки най-много 500 знака.", "zh": "unsigned long long count_valid_coin_toss_sequences(int n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n    \n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n    \n    return a[n][0] + a[n][1];\n}\n\n请用最多500个字符的中文对该C代码提供简洁的自然语言描述（文档字符串）。", "fr": "unsigned long long count_valid_coin_toss_sequences(int n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n    \n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n    \n    return a[n][0] + a[n][1];\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.", "de": "unsigned long long count_valid_coin_toss_sequences(int n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n    \n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n    \n    return a[n][0] + a[n][1];\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "unsigned long long count_valid_coin_toss_sequences(int n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n    \n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n    \n    return a[n][0] + a[n][1];\n}\n\nBa da takaitaccen bayanin yanayi na lamba (docstring) na lambar C cikin harshen Hausa ta amfani da haruffa 500 kacal.", "hi": "unsigned long long count_valid_coin_toss_sequences(int n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n    \n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n    \n    return a[n][0] + a[n][1];\n}\n\nC कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "unsigned long long count_valid_coin_toss_sequences(int n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n    \n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n    \n    return a[n][0] + a[n][1];\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben.", "es": "unsigned long long count_valid_coin_toss_sequences(int n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n    \n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n    \n    return a[n][0] + a[n][1];\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando como máximo 500 caracteres.", "arb": "unsigned long long count_valid_coin_toss_sequences(int n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n    \n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n    \n    return a[n][0] + a[n][1];\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "unsigned long long count_valid_coin_toss_sequences(int n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n    \n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n    \n    return a[n][0] + a[n][1];\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "unsigned long long count_valid_coin_toss_sequences(int n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n    \n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n    \n    return a[n][0] + a[n][1];\n}\n\nC kodunun işlevini açıklayan kısa bir doğal dil tanımı (docstring) sağlayın. Açıklama, Türkçe olarak en fazla 500 karakter kullanılacak şekilde olmalıdır.", "vi": "unsigned long long count_valid_coin_toss_sequences(int n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n    \n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n    \n    return a[n][0] + a[n][1];\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã C bằng tiếng Việt, sử dụng tối đa 500 ký tự.", "id": "unsigned long long count_valid_coin_toss_sequences(int n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n    \n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n    \n    return a[n][0] + a[n][1];\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode C dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "unsigned long long count_valid_coin_toss_sequences(int n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n    \n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n    \n    return a[n][0] + a[n][1];\n}\n\nCコードの内容を簡潔に説明する日本語のドキュメンテーション文字列（docstring）を、最大500文字で提供してください。", "ko": "unsigned long long count_valid_coin_toss_sequences(int n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n    \n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n    \n    return a[n][0] + a[n][1];\n}\n\nC 코드의 동작을 설명하는 간결한 자연어 설명(docstring)을 한국어로 작성하되, 최대 500자 이내로 작성하세요.", "ml": "unsigned long long count_valid_coin_toss_sequences(int n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n    \n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n    \n    return a[n][0] + a[n][1];\n}\n\nC കോഡ് ഉപയോഗിച്ച് 500 അക്ഷരങ്ങളിൽ കൂടുതൽ അല്ലാത്ത ഒരു സംക്ഷിപ്ത സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) മലയാളത്തിൽ നൽകുക.", "fa": "unsigned long long count_valid_coin_toss_sequences(int n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n    \n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n    \n    return a[n][0] + a[n][1];\n}\n\nتوضیح مختصر و طبیعی (docstring) از کد C را به زبان فارسی با حداکثر ۵۰۰ کاراکتر ارائه دهید."}, "level": "", "test": "int main() {\n    assert(count_valid_coin_toss_sequences(1) == 2);\n    assert(count_valid_coin_toss_sequences(2) == 3);\n    assert(count_valid_coin_toss_sequences(3) == 5);\n    assert(count_valid_coin_toss_sequences(4) == 8); // Additional test\n    assert(count_valid_coin_toss_sequences(5) == 13); // Additional test\n    // Feel free to add more tests here\n    assert(count_valid_coin_toss_sequences(40) == 267914296); // Additional test\n    assert(count_valid_coin_toss_sequences(39) == 165580141); \n    assert(count_valid_coin_toss_sequences(38) == 102334155);\n    // printf(\"All tests passed!\\n\");\n    return 0;\n}", "entry_point": "count_valid_coin_toss_sequences", "signature": "unsigned long long count_valid_coin_toss_sequences(int n)", "docstring": {"en": "Count the number of valid coin toss sequences with no consecutive heads in n tosses.\n    Parameters:\n- n (int): The number of coin tosses.\n​    Returns:\n​    unsigned long long: The count of valid sequences.\n    >>> count_valid_coin_toss_sequences(1)\n    2\n", "sq": "Numëroni numrin e sekuencave të vlefshme të hedhjeve të monedhës pa kokërradhë kokash në n hedhje.\n    Parametrat:\n- n (int): Numri i hedhjeve të monedhës.\n​    Kthen:\n​    unsigned long long: Numri i sekuencave të vlefshme.\n    >>> count_valid_coin_toss_sequences(1)\n    2", "hy": "Հաշվել վավեր մետաղադրամի նետումների հաջորդականությունների քանակը, որտեղ n նետումների ընթացքում չկան հաջորդական գլուխներ:\n    Պարամետրեր:\n- n (int): Մետաղադրամի նետումների քանակը.\n    Վերադարձնում է:\n    unsigned long long: Վավեր հաջորդականությունների քանակը:\n    >>> count_valid_coin_toss_sequences(1)\n    2", "bn": "n টি টসে কোনো পরপর হেড ছাড়াই বৈধ কয়েন টস সিকোয়েন্সের সংখ্যা গণনা করুন।\n    Parameters:\n- n (int): কয়েন টসের সংখ্যা।\n    Returns:\n    unsigned long long: বৈধ সিকোয়েন্সের সংখ্যা।\n    >>> count_valid_coin_toss_sequences(1)\n    2", "bg": "Бройте броя на валидните последователности от хвърляния на монета без последователни ези в n хвърляния.\n    Параметри:\n- n (int): Броят на хвърлянията на монетата.\n​    Връща:\n​    unsigned long long: Броят на валидните последователности.\n    >>> count_valid_coin_toss_sequences(1)\n    2", "zh": "计算在 n 次投掷中没有连续正面的有效硬币投掷序列的数量。\n    参数:\n- n (int): 硬币投掷的次数。\n    返回:\n    unsigned long long: 有效序列的数量。\n    >>> count_valid_coin_toss_sequences(1)\n    2", "fr": "Compter le nombre de séquences de lancers de pièces valides sans faces consécutives dans n lancers.\n    Paramètres:\n- n (int): Le nombre de lancers de pièces.\n    Renvoie:\n    unsigned long long: Le nombre de séquences valides.\n    >>> count_valid_coin_toss_sequences(1)\n    2", "de": "Zähle die Anzahl der gültigen Münzwurfsequenzen ohne aufeinanderfolgende Köpfe in n Würfen.\n    Parameter:\n- n (int): Die Anzahl der Münzwürfe.\n​    Rückgabe:\n​    unsigned long long: Die Anzahl der gültigen Sequenzen.\n    >>> count_valid_coin_toss_sequences(1)\n    2", "ha": "Ƙirga adadin sahihan jeri na jefa tsabar kudi ba tare da kai biyu a jere ba a cikin jefa n.\n    Sigogi:\n- n (int): Yawan jefa tsabar kudi.\n​    Komawa:\n​    unsigned long long: Adadin sahihan jeri.\n    >>> count_valid_coin_toss_sequences(1)\n    2", "hi": "n उछालों में कोई लगातार हेड्स नहीं होने वाले वैध सिक्का उछाल अनुक्रमों की संख्या गिनें।\n    पैरामीटर्स:\n- n (int): सिक्का उछालों की संख्या।\n​    रिटर्न्स:\n​    unsigned long long: वैध अनुक्रमों की गिनती।\n    >>> count_valid_coin_toss_sequences(1)\n    2", "hu": "Számolja meg az érvényes pénzfeldobás sorozatok számát, ahol nincs egymást követő fej n dobás esetén.\n    Paraméterek:\n- n (int): A pénzfeldobások száma.\n    Visszatér:\n    unsigned long long: Az érvényes sorozatok száma.\n    >>> count_valid_coin_toss_sequences(1)\n    2", "es": "Cuenta el número de secuencias válidas de lanzamientos de moneda sin caras consecutivas en n lanzamientos.\n    Parámetros:\n- n (int): El número de lanzamientos de moneda.\n​    Devuelve:\n​    unsigned long long: El conteo de secuencias válidas.\n    >>> count_valid_coin_toss_sequences(1)\n    2", "arb": "احسب عدد تسلسلات رمي العملة الصحيحة بدون رؤوس متتالية في n رميات.\n    Parameters:\n- n (int): عدد رميات العملة.\n​    Returns:\n​    unsigned long long: عدد التسلسلات الصحيحة.\n    >>> count_valid_coin_toss_sequences(1)\n    2", "sw": "Hesabu idadi ya mfuatano halali wa kurusha sarafu bila vichwa mfululizo katika kurusha mara n.\n    Vigezo:\n- n (int): Idadi ya kurusha sarafu.\n​    Inarejesha:\n​    unsigned long long: Idadi ya mfuatano halali.\n    >>> count_valid_coin_toss_sequences(1)\n    2", "tr": "n atışında ardışık yazı olmayan geçerli para atışı dizilerinin sayısını sayın.\n    Parametreler:\n    - n (int): Para atışlarının sayısı.\n    Döndürür:\n    unsigned long long: Geçerli dizilerin sayısı.\n    >>> count_valid_coin_toss_sequences(1)\n    2", "vi": "Đếm số lượng dãy tung đồng xu hợp lệ mà không có hai mặt ngửa liên tiếp trong n lần tung.\n    Tham số:\n- n (int): Số lần tung đồng xu.\n    Trả về:\n    unsigned long long: Số lượng dãy hợp lệ.\n    >>> count_valid_coin_toss_sequences(1)\n    2", "id": "Hitung jumlah urutan lemparan koin yang valid tanpa kepala berturut-turut dalam n lemparan.\n    Parameter:\n- n (int): Jumlah lemparan koin.\n    Mengembalikan:\n    unsigned long long: Jumlah urutan yang valid.\n    >>> count_valid_coin_toss_sequences(1)\n    2", "ja": "n回のコイントスで連続して表が出ない有効なコイントスのシーケンスの数を数えます。\n    パラメータ:\n- n (int): コイントスの回数。\n    戻り値:\n    unsigned long long: 有効なシーケンスの数。\n    >>> count_valid_coin_toss_sequences(1)\n    2", "ko": "n번의 동전 던지기에서 연속된 앞면이 없는 유효한 동전 던지기 시퀀스의 수를 계산합니다.\n    매개변수:\n    - n (int): 동전 던지기의 횟수.\n    반환:\n    unsigned long long: 유효한 시퀀스의 수.\n    >>> count_valid_coin_toss_sequences(1)\n    2", "ml": "n തവണ എറിയുമ്പോൾ തുടർച്ചയായ തലകൾ ഇല്ലാത്ത സാധുവായ നാണയ എറിയൽ ക്രമങ്ങളുടെ എണ്ണം എണ്ണുക.\n    പാരാമീറ്ററുകൾ:\n- n (int): നാണയ എറിയലുകളുടെ എണ്ണം.\n    മടക്കുന്നു:\n    unsigned long long: സാധുവായ ക്രമങ്ങളുടെ എണ്ണം.\n    >>> count_valid_coin_toss_sequences(1)\n    2", "fa": "تعداد دنباله‌های معتبر پرتاب سکه را که در آن‌ها هیچ شیر متوالی وجود ندارد در n پرتاب بشمارید.\n    پارامترها:\n- n (int): تعداد پرتاب‌های سکه.\n    بازگشت:\n    unsigned long long: تعداد دنباله‌های معتبر.\n    >>> count_valid_coin_toss_sequences(1)\n    2"}}
{"task_id": "C/17", "prompt": {"en": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nFind the length of the longest consecutive sequence of 1s in the binary representation of a non-negative integer.\n​    Parameters:\n- n (unsigned long long): A non-negative integer (0 ≤ n ≤ 2^64 - 1).\n​    Returns:\n​    int: The length of the longest consecutive sequence of 1s in the binary representation of the given integer.\n​    \n    Examples:\n    >>> find_longest_consecutive_ones_length(7)\n    3\n*/\nint find_longest_consecutive_ones_length(unsigned long long n)", "sq": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nGjeni gjatësinë e sekuencës më të gjatë të njëshave radhazi në paraqitjen binare të një numri të plotë jo-negativ.\n​    Parametrat:\n- n (unsigned long long): Një numër i plotë jo-negativ (0 ≤ n ≤ 2^64 - 1).\n​    Kthen:\n​    int: Gjatësia e sekuencës më të gjatë të njëshave radhazi në paraqitjen binare të numrit të dhënë.\n​    \n    Shembuj:\n    >>> find_longest_consecutive_ones_length(7)\n    3\n*/\nint find_longest_consecutive_ones_length(unsigned long long n)", "hy": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nԳտնել ամենաերկար հաջորդական 1-երի երկարությունը ոչ բացասական ամբողջ թվի երկբայական ներկայացման մեջ:\n​    Պարամետրեր:\n- n (unsigned long long): Ոչ բացասական ամբողջ թիվ (0 ≤ n ≤ 2^64 - 1):\n​    Վերադարձնում է:\n​    int: Տրված ամբողջ թվի երկբայական ներկայացման մեջ ամենաերկար հաջորդական 1-երի երկարությունը:\n​    \n    Օրինակներ:\n    >>> find_longest_consecutive_ones_length(7)\n    3\n*/\nint find_longest_consecutive_ones_length(unsigned long long n)", "bn": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nএকটি অ-ঋণাত্মক পূর্ণসংখ্যার বাইনারি উপস্থাপনায় 1-এর দীর্ঘতম ধারাবাহিক ক্রমের দৈর্ঘ্য খুঁজুন।\n    প্যারামিটার:\n- n (unsigned long long): একটি অ-ঋণাত্মক পূর্ণসংখ্যা (0 ≤ n ≤ 2^64 - 1)।\n    রিটার্নস:\n    int: প্রদত্ত পূর্ণসংখ্যার বাইনারি উপস্থাপনায় 1-এর দীর্ঘতম ধারাবাহিক ক্রমের দৈর্ঘ্য।\n    \n    উদাহরণ:\n    >>> find_longest_consecutive_ones_length(7)\n    3\n*/\nint find_longest_consecutive_ones_length(unsigned long long n)", "bg": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nНамерете дължината на най-дългата последователна поредица от 1-ци в двоичното представяне на неотрицателно цяло число.\n​    Параметри:\n- n (unsigned long long): Неотрицателно цяло число (0 ≤ n ≤ 2^64 - 1).\n​    Връща:\n​    int: Дължината на най-дългата последователна поредица от 1-ци в двоичното представяне на даденото число.\n​    \n    Примери:\n    >>> find_longest_consecutive_ones_length(7)\n    3\n*/\nint find_longest_consecutive_ones_length(unsigned long long n)", "zh": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n找到非负整数的二进制表示中最长连续1的序列长度。\n    参数：\n- n (unsigned long long): 一个非负整数 (0 ≤ n ≤ 2^64 - 1)。\n    返回：\n    int: 给定整数的二进制表示中最长连续1的序列长度。\n    \n    示例：\n    >>> find_longest_consecutive_ones_length(7)\n    3\n*/\nint find_longest_consecutive_ones_length(unsigned long long n)", "fr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nTrouver la longueur de la plus longue séquence consécutive de 1 dans la représentation binaire d'un entier non négatif.\n​    Paramètres :\n- n (unsigned long long) : Un entier non négatif (0 ≤ n ≤ 2^64 - 1).\n​    Renvoie :\n​    int : La longueur de la plus longue séquence consécutive de 1 dans la représentation binaire de l'entier donné.\n​    \n    Exemples :\n    >>> find_longest_consecutive_ones_length(7)\n    3\n*/\nint find_longest_consecutive_ones_length(unsigned long long n)", "de": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nFinde die Länge der längsten aufeinanderfolgenden Sequenz von 1en in der Binärdarstellung einer nicht-negativen ganzen Zahl.\n​    Parameter:\n- n (unsigned long long): Eine nicht-negative ganze Zahl (0 ≤ n ≤ 2^64 - 1).\n​    Rückgabe:\n​    int: Die Länge der längsten aufeinanderfolgenden Sequenz von 1en in der Binärdarstellung der gegebenen Zahl.\n​    \n    Beispiele:\n    >>> find_longest_consecutive_ones_length(7)\n    3\n*/\nint find_longest_consecutive_ones_length(unsigned long long n)", "ha": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nNemo tsawon jerin lambobi 1 mafi tsawo a cikin wakilcin binary na lamba maras kyau.\n​    Sigogi:\n- n (unsigned long long): Lamba maras kyau (0 ≤ n ≤ 2^64 - 1).\n​    Dawowa:\n​    int: Tsawon jerin lambobi 1 mafi tsawo a cikin wakilcin binary na lambar da aka bayar.\n​    \n    Misalai:\n    >>> find_longest_consecutive_ones_length(7)\n    3\n*/\nint find_longest_consecutive_ones_length(unsigned long long n)", "hi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nकिसी गैर-ऋणात्मक पूर्णांक के द्विआधारी रूप में 1s के सबसे लंबे अनुक्रम की लंबाई खोजें।\n    पैरामीटर्स:\n- n (unsigned long long): एक गैर-ऋणात्मक पूर्णांक (0 ≤ n ≤ 2^64 - 1)।\n    रिटर्न करता है:\n    int: दिए गए पूर्णांक के द्विआधारी रूप में 1s के सबसे लंबे अनुक्रम की लंबाई।\n    \n    उदाहरण:\n    >>> find_longest_consecutive_ones_length(7)\n    3\n*/\nint find_longest_consecutive_ones_length(unsigned long long n)", "hu": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nTaláld meg a leghosszabb egymást követő 1-es sorozat hosszát egy nem negatív egész szám bináris ábrázolásában.\n​    Paraméterek:\n- n (unsigned long long): Egy nem negatív egész szám (0 ≤ n ≤ 2^64 - 1).\n​    Visszatérési érték:\n​    int: A leghosszabb egymást követő 1-es sorozat hossza a megadott egész szám bináris ábrázolásában.\n​    \n    Példák:\n    >>> find_longest_consecutive_ones_length(7)\n    3\n*/\nint find_longest_consecutive_ones_length(unsigned long long n)", "es": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nEncuentra la longitud de la secuencia consecutiva más larga de 1s en la representación binaria de un entero no negativo.\n    Parámetros:\n- n (unsigned long long): Un entero no negativo (0 ≤ n ≤ 2^64 - 1).\n    Devuelve:\n    int: La longitud de la secuencia consecutiva más larga de 1s en la representación binaria del entero dado.\n    \n    Ejemplos:\n    >>> find_longest_consecutive_ones_length(7)\n    3\n*/\nint find_longest_consecutive_ones_length(unsigned long long n)", "arb": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nإيجاد طول أطول تسلسل متتابع من الأرقام 1 في التمثيل الثنائي لعدد صحيح غير سالب.\nالمعطيات:\n- n (unsigned long long): عدد صحيح غير سالب (0 ≤ n ≤ 2^64 - 1).\nالإرجاع:\nint: طول أطول تسلسل متتابع من الأرقام 1 في التمثيل الثنائي للعدد الصحيح المعطى.\n\nأمثلة:\n>>> find_longest_consecutive_ones_length(7)\n3\n*/\nint find_longest_consecutive_ones_length(unsigned long long n)", "sw": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nPata urefu wa mlolongo mrefu zaidi wa 1 katika uwakilishi wa binary wa nambari isiyo hasi.\n​    Vigezo:\n- n (unsigned long long): Nambari isiyo hasi (0 ≤ n ≤ 2^64 - 1).\n​    Inarejesha:\n​    int: Urefu wa mlolongo mrefu zaidi wa 1 katika uwakilishi wa binary wa nambari iliyotolewa.\n​    \n    Mifano:\n    >>> find_longest_consecutive_ones_length(7)\n    3\n*/\nint find_longest_consecutive_ones_length(unsigned long long n)", "tr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nBir negatif olmayan tam sayının ikili gösterimindeki en uzun ardışık 1 dizisinin uzunluğunu bulun.\n​    Parametreler:\n- n (unsigned long long): Negatif olmayan bir tam sayı (0 ≤ n ≤ 2^64 - 1).\n​    Döndürür:\n​    int: Verilen tam sayının ikili gösterimindeki en uzun ardışık 1 dizisinin uzunluğu.\n​    \n    Örnekler:\n    >>> find_longest_consecutive_ones_length(7)\n    3\n*/\nint find_longest_consecutive_ones_length(unsigned long long n)", "vi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nTìm độ dài của dãy liên tiếp dài nhất của các số 1 trong biểu diễn nhị phân của một số nguyên không âm.\n​    Tham số:\n- n (unsigned long long): Một số nguyên không âm (0 ≤ n ≤ 2^64 - 1).\n​    Trả về:\n​    int: Độ dài của dãy liên tiếp dài nhất của các số 1 trong biểu diễn nhị phân của số nguyên đã cho.\n​    \n    Ví dụ:\n    >>> find_longest_consecutive_ones_length(7)\n    3\n*/\nint find_longest_consecutive_ones_length(unsigned long long n)", "id": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nTemukan panjang urutan 1s terpanjang yang berurutan dalam representasi biner dari bilangan bulat non-negatif.\n​    Parameter:\n- n (unsigned long long): Bilangan bulat non-negatif (0 ≤ n ≤ 2^64 - 1).\n​    Mengembalikan:\n​    int: Panjang urutan 1s terpanjang yang berurutan dalam representasi biner dari bilangan bulat yang diberikan.\n​    \n    Contoh:\n    >>> find_longest_consecutive_ones_length(7)\n    3\n*/\nint find_longest_consecutive_ones_length(unsigned long long n)", "ja": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n非負整数の2進数表現における1の連続シーケンスの最長の長さを見つけます。\n​    パラメータ:\n- n (unsigned long long): 非負整数 (0 ≤ n ≤ 2^64 - 1)。\n​    戻り値:\n​    int: 与えられた整数の2進数表現における1の連続シーケンスの最長の長さ。\n​    \n    例:\n    >>> find_longest_consecutive_ones_length(7)\n    3\n*/\nint find_longest_consecutive_ones_length(unsigned long long n)\n", "ko": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n비음수가 아닌 정수의 이진 표현에서 1의 가장 긴 연속 시퀀스의 길이를 찾습니다.\n​    매개변수:\n- n (unsigned long long): 비음수 정수 (0 ≤ n ≤ 2^64 - 1).\n​    반환값:\n​    int: 주어진 정수의 이진 표현에서 1의 가장 긴 연속 시퀀스의 길이.\n​    \n    예시:\n    >>> find_longest_consecutive_ones_length(7)\n    3\n*/\nint find_longest_consecutive_ones_length(unsigned long long n)", "ml": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nഒരു അസാധാരണമായ പൂർണ്ണസംഖ്യയുടെ ബൈനറി പ്രതിനിധാനത്തിൽ ഏറ്റവും നീണ്ട അനുക്രമമായ 1 കളുടെ പരമ്പരയുടെ നീളം കണ്ടെത്തുക.\n    പാരാമീറ്ററുകൾ:\n- n (unsigned long long): ഒരു അസാധാരണമായ പൂർണ്ണസംഖ്യ (0 ≤ n ≤ 2^64 - 1).\n    തിരികെ നൽകുന്നു:\n    int: നൽകിയ പൂർണ്ണസംഖ്യയുടെ ബൈനറി പ്രതിനിധാനത്തിൽ ഏറ്റവും നീണ്ട അനുക്രമമായ 1 കളുടെ പരമ്പരയുടെ നീളം.\n    \n    ഉദാഹരണങ്ങൾ:\n    >>> find_longest_consecutive_ones_length(7)\n    3\n*/\nint find_longest_consecutive_ones_length(unsigned long long n)", "fa": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nطول بلندترین دنباله متوالی از 1ها را در نمایش باینری یک عدد صحیح غیرمنفی پیدا کنید.\n    پارامترها:\n- n (unsigned long long): یک عدد صحیح غیرمنفی (0 ≤ n ≤ 2^64 - 1).\n    بازگشت:\n    int: طول بلندترین دنباله متوالی از 1ها در نمایش باینری عدد داده شده.\n\n    مثال‌ها:\n    >>> find_longest_consecutive_ones_length(7)\n    3\n*/\nint find_longest_consecutive_ones_length(unsigned long long n)\n"}, "canonical_solution": "{\n    int max = 0;\n    int ans = 0;\n    while(n){\n        if(n & 1)\n            ans++;\n        else{\n            if(ans > max)\n                max = ans;\n            ans = 0;\n        }\n        n >>= 1;\n    }\n    if(ans > max)\n        max = ans;\n    return max;\n}", "instruction": {"en": "int find_longest_consecutive_ones_length(unsigned long long n)\n{\n    int max = 0;\n    int ans = 0;\n    while(n){\n        if(n & 1)\n            ans++;\n        else{\n            if(ans > max)\n                max = ans;\n            ans = 0;\n        }\n        n >>= 1;\n    }\n    if(ans > max)\n        max = ans;\n    return max;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "sq": "int find_longest_consecutive_ones_length(unsigned long long n)\n{\n    int max = 0;\n    int ans = 0;\n    while(n){\n        if(n & 1)\n            ans++;\n        else{\n            if(ans > max)\n                max = ans;\n            ans = 0;\n        }\n        n >>= 1;\n    }\n    if(ans > max)\n        max = ans;\n    return max;\n}\n\nJepni një përshkrim të shkurtër në gjuhën natyrore (docstring) të kodit C në gjuhën shqipe duke përdorur maksimumi 500 karaktere.", "hy": "int find_longest_consecutive_ones_length(unsigned long long n)\n{\n    int max = 0;\n    int ans = 0;\n    while(n){\n        if(n & 1)\n            ans++;\n        else{\n            if(ans > max)\n                max = ans;\n            ans = 0;\n        }\n        n >>= 1;\n    }\n    if(ans > max)\n        max = ans;\n    return max;\n}\n\nՏվեք C կոդի հակիրճ բնութագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "int find_longest_consecutive_ones_length(unsigned long long n)\n{\n    int max = 0;\n    int ans = 0;\n    while(n){\n        if(n & 1)\n            ans++;\n        else{\n            if(ans > max)\n                max = ans;\n            ans = 0;\n        }\n        n >>= 1;\n    }\n    if(ans > max)\n        max = ans;\n    return max;\n}\n\nনিচের C কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।", "bg": "int find_longest_consecutive_ones_length(unsigned long long n)\n{\n    int max = 0;\n    int ans = 0;\n    while(n){\n        if(n & 1)\n            ans++;\n        else{\n            if(ans > max)\n                max = ans;\n            ans = 0;\n        }\n        n >>= 1;\n    }\n    if(ans > max)\n        max = ans;\n    return max;\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, използвайки не повече от 500 знака.", "zh": "int find_longest_consecutive_ones_length(unsigned long long n)\n{\n    int max = 0;\n    int ans = 0;\n    while(n){\n        if(n & 1)\n            ans++;\n        else{\n            if(ans > max)\n                max = ans;\n            ans = 0;\n        }\n        n >>= 1;\n    }\n    if(ans > max)\n        max = ans;\n    return max;\n}\n\n请用最多500个字符的中文为以下C代码提供简洁的自然语言描述（文档字符串）。", "fr": "int find_longest_consecutive_ones_length(unsigned long long n)\n{\n    int max = 0;\n    int ans = 0;\n    while(n){\n        if(n & 1)\n            ans++;\n        else{\n            if(ans > max)\n                max = ans;\n            ans = 0;\n        }\n        n >>= 1;\n    }\n    if(ans > max)\n        max = ans;\n    return max;\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.", "de": "int find_longest_consecutive_ones_length(unsigned long long n)\n{\n    int max = 0;\n    int ans = 0;\n    while(n){\n        if(n & 1)\n            ans++;\n        else{\n            if(ans > max)\n                max = ans;\n            ans = 0;\n        }\n        n >>= 1;\n    }\n    if(ans > max)\n        max = ans;\n    return max;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "int find_longest_consecutive_ones_length(unsigned long long n)\n{\n    int max = 0;\n    int ans = 0;\n    while(n){\n        if(n & 1)\n            ans++;\n        else{\n            if(ans > max)\n                max = ans;\n            ans = 0;\n        }\n        n >>= 1;\n    }\n    if(ans > max)\n        max = ans;\n    return max;\n}\n\nBa da kwatancin gajeren bayani (docstring) na lambar C cikin Hausa ta amfani da haruffa 500 ko kasa da haka.", "hi": "int find_longest_consecutive_ones_length(unsigned long long n)\n{\n    int max = 0;\n    int ans = 0;\n    while(n){\n        if(n & 1)\n            ans++;\n        else{\n            if(ans > max)\n                max = ans;\n            ans = 0;\n        }\n        n >>= 1;\n    }\n    if(ans > max)\n        max = ans;\n    return max;\n}\n\nC कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "int find_longest_consecutive_ones_length(unsigned long long n)\n{\n    int max = 0;\n    int ans = 0;\n    while(n){\n        if(n & 1)\n            ans++;\n        else{\n            if(ans > max)\n                max = ans;\n            ans = 0;\n        }\n        n >>= 1;\n    }\n    if(ans > max)\n        max = ans;\n    return max;\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben.", "es": "int find_longest_consecutive_ones_length(unsigned long long n)\n{\n    int max = 0;\n    int ans = 0;\n    while(n){\n        if(n & 1)\n            ans++;\n        else{\n            if(ans > max)\n                max = ans;\n            ans = 0;\n        }\n        n >>= 1;\n    }\n    if(ans > max)\n        max = ans;\n    return max;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando como máximo 500 caracteres.", "arb": "int find_longest_consecutive_ones_length(unsigned long long n)\n{\n    int max = 0;\n    int ans = 0;\n    while(n){\n        if(n & 1)\n            ans++;\n        else{\n            if(ans > max)\n                max = ans;\n            ans = 0;\n        }\n        n >>= 1;\n    }\n    if(ans > max)\n        max = ans;\n    return max;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "int find_longest_consecutive_ones_length(unsigned long long n)\n{\n    int max = 0;\n    int ans = 0;\n    while(n){\n        if(n & 1)\n            ans++;\n        else{\n            if(ans > max)\n                max = ans;\n            ans = 0;\n        }\n        n >>= 1;\n    }\n    if(ans > max)\n        max = ans;\n    return max;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "int find_longest_consecutive_ones_length(unsigned long long n)\n{\n    int max = 0;\n    int ans = 0;\n    while(n){\n        if(n & 1)\n            ans++;\n        else{\n            if(ans > max)\n                max = ans;\n            ans = 0;\n        }\n        n >>= 1;\n    }\n    if(ans > max)\n        max = ans;\n    return max;\n}\n\nC kodunun işlevini açıklayan kısa bir doğal dil tanımı (docstring) sağlayın. Açıklama en fazla 500 karakter olmalıdır.", "vi": "int find_longest_consecutive_ones_length(unsigned long long n)\n{\n    int max = 0;\n    int ans = 0;\n    while(n){\n        if(n & 1)\n            ans++;\n        else{\n            if(ans > max)\n                max = ans;\n            ans = 0;\n        }\n        n >>= 1;\n    }\n    if(ans > max)\n        max = ans;\n    return max;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã C bằng tiếng Việt, sử dụng tối đa 500 ký tự.", "id": "int find_longest_consecutive_ones_length(unsigned long long n)\n{\n    int max = 0;\n    int ans = 0;\n    while(n){\n        if(n & 1)\n            ans++;\n        else{\n            if(ans > max)\n                max = ans;\n            ans = 0;\n        }\n        n >>= 1;\n    }\n    if(ans > max)\n        max = ans;\n    return max;\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode C dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "int find_longest_consecutive_ones_length(unsigned long long n)\n{\n    int max = 0;\n    int ans = 0;\n    while(n){\n        if(n & 1)\n            ans++;\n        else{\n            if(ans > max)\n                max = ans;\n            ans = 0;\n        }\n        n >>= 1;\n    }\n    if(ans > max)\n        max = ans;\n    return max;\n}\n\nC コードの簡単な自然言語による説明 (docstring) を英語で最大 500 文字まで入力してください。", "ko": "int find_longest_consecutive_ones_length(unsigned long long n)\n{\n    int max = 0;\n    int ans = 0;\n    while(n){\n        if(n & 1)\n            ans++;\n        else{\n            if(ans > max)\n                max = ans;\n            ans = 0;\n        }\n        n >>= 1;\n    }\n    if(ans > max)\n        max = ans;\n    return max;\n}\n\nC 코드의 동작을 설명하는 간결한 자연어 설명(docstring)을 한국어로 작성하세요. 최대 500자까지 가능합니다.", "ml": "int find_longest_consecutive_ones_length(unsigned long long n)\n{\n    int max = 0;\n    int ans = 0;\n    while(n){\n        if(n & 1)\n            ans++;\n        else{\n            if(ans > max)\n                max = ans;\n            ans = 0;\n        }\n        n >>= 1;\n    }\n    if(ans > max)\n        max = ans;\n    return max;\n}\n\nസിയി കോഡിന്റെ മലയാളത്തിലുള്ള സംക്ഷിപ്തമായ പ്രകൃതിദത്ത ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) 500 അക്ഷരങ്ങളിൽ കൂടുതൽ അല്ലാതിരിക്കാൻ നൽകുക.", "fa": "int find_longest_consecutive_ones_length(unsigned long long n)\n{\n    int max = 0;\n    int ans = 0;\n    while(n){\n        if(n & 1)\n            ans++;\n        else{\n            if(ans > max)\n                max = ans;\n            ans = 0;\n        }\n        n >>= 1;\n    }\n    if(ans > max)\n        max = ans;\n    return max;\n}\n\nیک توضیح مختصر به زبان طبیعی (docstring) از کد C به زبان فارسی ارائه دهید که حداکثر ۵۰۰ کاراکتر باشد."}, "level": "", "test": "int main()\n{\n    assert(find_longest_consecutive_ones_length(7) == 3);\n    assert(find_longest_consecutive_ones_length(13) == 2);\n    assert(find_longest_consecutive_ones_length(12345) == 3); // New test sample\n    assert(find_longest_consecutive_ones_length(0b11011101111) == 4); // New test sample using binary literal for clarity\n    assert(find_longest_consecutive_ones_length(0xFFFFFFFF) == 32); // New test sample: all ones for a 32-bit number\n    assert(find_longest_consecutive_ones_length(0) == 0); // New test sample: no ones in a zero\n\n    // printf(\"All tests passed!\\n\");\n    return 0;\n}", "entry_point": "find_longest_consecutive_ones_length", "signature": "int find_longest_consecutive_ones_length(unsigned long long n)", "docstring": {"en": "Find the length of the longest consecutive sequence of 1s in the binary representation of a non-negative integer.\n    Parameters:\n- n (unsigned long long): A non-negative integer (0 ≤ n ≤ 2^64 - 1).\n    Returns:\n    int: The length of the longest consecutive sequence of 1s in the binary representation of the given integer.\n    \n    Examples:\n    >>> find_longest_consecutive_ones_length(7)\n    3\n", "sq": "Gjeni gjatësinë e sekuencës më të gjatë të njëshave radhazi në përfaqësimin binar të një numri të plotë jo-negativ.\n    Parametrat:\n- n (unsigned long long): Një numër i plotë jo-negativ (0 ≤ n ≤ 2^64 - 1).\n    Kthen:\n    int: Gjatësia e sekuencës më të gjatë të njëshave radhazi në përfaqësimin binar të numrit të dhënë.\n    \n    Shembuj:\n    >>> find_longest_consecutive_ones_length(7)\n    3", "hy": "Գտնել ամենաերկար հաջորդական 1-երի երկարությունը ոչ բացասական ամբողջ թվի բինար ներկայացման մեջ։\n    Պարամետրեր:\n- n (unsigned long long): Ոչ բացասական ամբողջ թիվ (0 ≤ n ≤ 2^64 - 1)։\n    Վերադարձնում է:\n    int: Տրված ամբողջ թվի բինար ներկայացման մեջ ամենաերկար հաջորդական 1-երի երկարությունը։\n    \n    Օրինակներ:\n    >>> find_longest_consecutive_ones_length(7)\n    3", "bn": "একটি অ-ঋণাত্মক পূর্ণসংখ্যার বাইনারি উপস্থাপনার মধ্যে 1 এর দীর্ঘতম ধারাবাহিক ক্রমের দৈর্ঘ্য খুঁজে বের করুন।\n    প্যারামিটার:\n- n (unsigned long long): একটি অ-ঋণাত্মক পূর্ণসংখ্যা (0 ≤ n ≤ 2^64 - 1)।\n    Returns:\n    int: প্রদত্ত পূর্ণসংখ্যার বাইনারি উপস্থাপনার মধ্যে 1s এর দীর্ঘতম ক্রমিক অনুক্রমের দৈর্ঘ্য।\n\n    উদাহরণ:\n    >>> find_longest_consecutive_ones_length(7)\n    3", "bg": "Намерете дължината на най-дългата последователна поредица от 1-ци в двоичното представяне на неотрицателно цяло число.\n    Параметри:\n- n (unsigned long long): Неотрицателно цяло число (0 ≤ n ≤ 2^64 - 1).\n    Връща:\n    int: Дължината на най-дългата последователна поредица от 1-ци в двоичното представяне на даденото число.\n    \n    Примери:\n    >>> find_longest_consecutive_ones_length(7)\n    3", "zh": "找到非负整数的二进制表示中最长连续1的序列的长度。\n    参数：\n- n (unsigned long long): 一个非负整数 (0 ≤ n ≤ 2^64 - 1)。\n    返回：\n    int: 给定整数的二进制表示中最长连续1的序列的长度。\n    \n    示例：\n    >>> find_longest_consecutive_ones_length(7)\n    3", "fr": "Trouver la longueur de la plus longue séquence consécutive de 1 dans la représentation binaire d'un entier non négatif.\n    Paramètres:\n- n (unsigned long long): Un entier non négatif (0 ≤ n ≤ 2^64 - 1).\n    Renvoie:\n    int: La longueur de la plus longue séquence consécutive de 1 dans la représentation binaire de l'entier donné.\n    \n    Exemples:\n    >>> find_longest_consecutive_ones_length(7)\n    3", "de": "Finde die Länge der längsten aufeinanderfolgenden Sequenz von 1en in der Binärdarstellung einer nicht-negativen ganzen Zahl.\n    Parameter:\n- n (unsigned long long): Eine nicht-negative ganze Zahl (0 ≤ n ≤ 2^64 - 1).\n    Rückgabewert:\n    int: Die Länge der längsten aufeinanderfolgenden Sequenz von 1en in der Binärdarstellung der gegebenen Zahl.\n    \n    Beispiele:\n    >>> find_longest_consecutive_ones_length(7)\n    3", "ha": "Nemo tsawon jere mafi tsawo na 1s a cikin wakilcin binary na lamba mara kyau.\n    Sigogi:\n- n (unsigned long long): Wani lamba mara kyau (0 ≤ n ≤ 2^64 - 1).\n    Returns:\n    int: Tsawon mafi tsawo jere na 1s a cikin wakilcin binary na lambar da aka bayar.\n    \n    Examples:\n    >>> find_longest_consecutive_ones_length(7)\n    3\n", "hi": "एक गैर-ऋणात्मक पूर्णांक के बाइनरी प्रतिनिधित्व में 1s के सबसे लंबे अनुक्रम की लंबाई खोजें।\n    पैरामीटर्स:\n- n (unsigned long long): एक गैर-ऋणात्मक पूर्णांक (0 ≤ n ≤ 2^64 - 1)।\n    रिटर्न्स:\n    int: दिए गए पूर्णांक के द्विआधारी प्रतिनिधित्व में 1s के सबसे लंबे लगातार अनुक्रम की लंबाई।\n    \n    उदाहरण:\n    >>> find_longest_consecutive_ones_length(7)\n    3", "hu": "Keresse meg a leghosszabb egymást követő 1-esek sorozatának hosszát egy nem negatív egész szám bináris ábrázolásában.\n    Paraméterek:\n- n (unsigned long long): Egy nem negatív egész szám (0 ≤ n ≤ 2^64 - 1).\n    Visszatérési érték:\n    int: A leghosszabb egymást követő 1-esek sorozatának hossza a megadott egész szám bináris ábrázolásában.\n    \n    Példák:\n    >>> find_longest_consecutive_ones_length(7)\n    3", "es": "Encontrar la longitud de la secuencia consecutiva más larga de 1s en la representación binaria de un entero no negativo.\n    Parámetros:\n- n (unsigned long long): Un entero no negativo (0 ≤ n ≤ 2^64 - 1).\n    Devuelve:\n    int: La longitud de la secuencia consecutiva más larga de 1s en la representación binaria del entero dado.\n    \n    Ejemplos:\n    >>> find_longest_consecutive_ones_length(7)\n    3", "arb": "ابحث عن طول أطول تسلسل متتابع من الأرقام 1 في التمثيل الثنائي لعدد صحيح غير سالب.\n    المعاملات:\n- n (unsigned long long): عدد صحيح غير سالب (0 ≤ n ≤ 2^64 - 1).\n    يعود:\n    int: طول أطول تسلسل متتابع من الأرقام 1 في التمثيل الثنائي للعدد الصحيح المعطى.\n    \n    أمثلة:\n    >>> find_longest_consecutive_ones_length(7)\n    3", "sw": "Pata urefu wa mlolongo mrefu zaidi wa 1 mfululizo katika uwakilishi wa binary wa nambari isiyo hasi.\n    Vigezo:\n- n (unsigned long long): Nambari isiyo hasi (0 ≤ n ≤ 2^64 - 1).\n    Inarejesha:\n    int: Urefu wa mlolongo mrefu zaidi wa 1 mfululizo katika uwakilishi wa binary wa nambari iliyotolewa.\n    \n    Mifano:\n    >>> find_longest_consecutive_ones_length(7)\n    3", "tr": "Find the length of the longest consecutive sequence of 1s in the binary representation of a non-negative integer.\n    Parametreler:\n- n (unsigned long long): Negatif olmayan bir tam sayı (0 ≤ n ≤ 2^64 - 1).\n    Döndürür:\n    int: Verilen tam sayının ikili gösterimindeki en uzun ardışık 1'ler dizisinin uzunluğu.\n    \n    Örnekler:\n    >>> find_longest_consecutive_ones_length(7)\n    3", "vi": "Tìm độ dài của dãy liên tiếp dài nhất của các số 1 trong biểu diễn nhị phân của một số nguyên không âm.\n    Tham số:\n- n (unsigned long long): Một số nguyên không âm (0 ≤ n ≤ 2^64 - 1).\n    Trả về:\n    int: Độ dài của dãy liên tiếp dài nhất của các số 1 trong biểu diễn nhị phân của số nguyên đã cho.\n    \n    Ví dụ:\n    >>> find_longest_consecutive_ones_length(7)\n    3", "id": "Temukan panjang urutan 1 berturut-turut terpanjang dalam representasi biner dari bilangan bulat non-negatif.\n    Parameter:\n- n (unsigned long long): Sebuah bilangan bulat non-negatif (0 ≤ n ≤ 2^64 - 1).\n    Mengembalikan:\n    int: Panjang urutan 1 berturut-turut terpanjang dalam representasi biner dari bilangan bulat yang diberikan.\n    \n    Contoh:\n    >>> find_longest_consecutive_ones_length(7)\n    3", "ja": "非負整数の2進数表現における1の連続シーケンスの最長の長さを見つけます。  \nパラメータ:\n- n (unsigned long long): 非負の整数 (0 ≤ n ≤ 2^64 - 1)。  \n戻り値:\n    int: 与えられた整数の2進数表現における1の最長連続シーケンスの長さ。  \n    \n例:\n    >>> find_longest_consecutive_ones_length(7)\n    3", "ko": "비음수가 아닌 정수의 이진 표현에서 1의 가장 긴 연속 시퀀스의 길이를 찾습니다.\n    매개변수:\n- n (unsigned long long): 음이 아닌 정수 (0 ≤ n ≤ 2^64 - 1).\n    반환:\n    int: 주어진 정수의 이진 표현에서 가장 긴 연속된 1의 시퀀스의 길이.\n    \n    예제:\n    >>> find_longest_consecutive_ones_length(7)\n    3", "ml": "ഒരു അസാധാരണമായ പൂർണ്ണസംഖ്യയുടെ ബൈനറി പ്രതിനിധാനത്തിൽ ഏറ്റവും നീണ്ട അനുക്രമമായ 1 കളുടെ പരമ്പരയുടെ നീളം കണ്ടെത്തുക.\n    പാരാമീറ്ററുകൾ:\n- n (unsigned long long): ഒരു നെഗറ്റീവ് അല്ലാത്ത പൂർണ്ണസംഖ്യ (0 ≤ n ≤ 2^64 - 1).\n    മടക്കുന്നു:\n    int: നൽകിയിരിക്കുന്ന പൂർണ്ണസംഖ്യയുടെ ബൈനറി പ്രതിനിധാനത്തിലെ ഏറ്റവും നീണ്ട അനന്തര 1കളുടെ നീളം.\n    \n    ഉദാഹരണങ്ങൾ:\n    >>> find_longest_consecutive_ones_length(7)\n    3", "fa": "طول بلندترین دنباله متوالی از 1ها در نمایش باینری یک عدد صحیح غیرمنفی را پیدا کنید.\n    پارامترها:\n- n (unsigned long long): یک عدد صحیح غیرمنفی (0 ≤ n ≤ 2^64 - 1).\n    بازگشتی:\n    int: طول بلندترین دنباله متوالی از 1ها در نمایش باینری عدد داده شده.\n\n    مثال‌ها:\n    >>> find_longest_consecutive_ones_length(7)\n    3"}}
{"task_id": "C/18", "prompt": {"en": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n/*\nCreates an ID by combining two words in a specific manner.\n​Parameters:\n- word1 (char*): The first word to be used in the ID.\n- word2 (char*): The second word to be used in the ID.\n​Returns:\n​char*: A divine ID formed by reversing every other character of the second \n        word and combining it with the first word.\ne.g.:\n    >>> create_id(fish,cat)\n\tftiasch\n*/\nchar* create_id(const char* word1, const char* word2)", "sq": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n/*\nKrijon një ID duke kombinuar dy fjalë në një mënyrë specifike.\n​Parametrat:\n- word1 (char*): Fjala e parë që do të përdoret në ID.\n- word2 (char*): Fjala e dytë që do të përdoret në ID.\n​Kthen:\n​char*: Një ID hyjnore e formuar duke përmbysur çdo karakter tjetër të fjalës së dytë dhe duke e kombinuar atë me fjalën e parë.\np.sh.:\n    >>> create_id(fish,cat)\n\tftiasch\n*/\nchar* create_id(const char* word1, const char* word2)", "hy": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n/*\nՍտեղծում է ID՝ երկու բառերը հատուկ կերպով համադրելով։\nՊարամետրեր:\n- word1 (char*): Առաջին բառը, որը կօգտագործվի ID-ում։\n- word2 (char*): Երկրորդ բառը, որը կօգտագործվի ID-ում։\nՎերադարձնում է:\nchar*: Աստվածային ID, որը ձևավորվում է երկրորդ բառի յուրաքանչյուր երկրորդ \n        տառը շրջելով և այն առաջին բառի հետ համադրելով։\nօր.:\n    >>> create_id(fish,cat)\n\tftiasch\n*/\nchar* create_id(const char* word1, const char* word2)", "bn": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n/*\nএকটি নির্দিষ্ট পদ্ধতিতে দুটি শব্দ একত্রিত করে একটি আইডি তৈরি করে।\n​প্যারামিটারসমূহ:\n- word1 (char*): আইডিতে ব্যবহৃত প্রথম শব্দ।\n- word2 (char*): আইডিতে ব্যবহৃত দ্বিতীয় শব্দ।\n​ফেরত দেয়:\n​char*: দ্বিতীয় শব্দের প্রতিটি অন্য অক্ষর উল্টিয়ে এবং প্রথম শব্দের সাথে \n        একত্রিত করে একটি অনন্য আইডি তৈরি করে।\nউদাহরণ:\n    >>> create_id(fish,cat)\n\tftiasch\n*/\nchar* create_id(const char* word1, const char* word2)", "bg": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n/*\nСъздава ID, като комбинира две думи по специфичен начин.\nПараметри:\n- word1 (char*): Първата дума, която ще се използва в ID.\n- word2 (char*): Втората дума, която ще се използва в ID.\nВръща:\nchar*: Божествено ID, образувано чрез обръщане на всеки втори символ на \n       втората дума и комбинирането му с първата дума.\nнапр.:\n    >>> create_id(fish,cat)\n\tftiasch\n*/\nchar* create_id(const char* word1, const char* word2)", "zh": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n/*\n通过以特定方式组合两个单词来创建ID。\n参数:\n- word1 (char*): 用于ID的第一个单词。\n- word2 (char*): 用于ID的第二个单词。\n返回:\nchar*: 一个神圣的ID，通过反转第二个单词的每隔一个字符并将其与第一个单词组合而成。\n例如:\n    >>> create_id(fish,cat)\n\tftiasch\n*/\nchar* create_id(const char* word1, const char* word2)", "fr": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n/*\nCrée un ID en combinant deux mots d'une manière spécifique.\nParamètres :\n- word1 (char*): Le premier mot à utiliser dans l'ID.\n- word2 (char*): Le deuxième mot à utiliser dans l'ID.\nRenvoie :\nchar*: Un ID divin formé en inversant chaque autre caractère du deuxième \n        mot et en le combinant avec le premier mot.\ne.g.:\n    >>> create_id(fish,cat)\n\tftiasch\n*/\nchar* create_id(const char* word1, const char* word2)", "de": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n/*\nErstellt eine ID, indem zwei Wörter auf eine bestimmte Weise kombiniert werden.\nParameter:\n- word1 (char*): Das erste Wort, das in der ID verwendet werden soll.\n- word2 (char*): Das zweite Wort, das in der ID verwendet werden soll.\nRückgabe:\nchar*: Eine göttliche ID, die gebildet wird, indem jedes zweite Zeichen des \n        zweiten Wortes umgekehrt und mit dem ersten Wort kombiniert wird.\nz.B.:\n    >>> create_id(fish,cat)\n\tftiasch\n*/\nchar* create_id(const char* word1, const char* word2)", "ha": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n/*\nYana ƙirƙirar ID ta hanyar haɗa kalmomi biyu a cikin wata hanya ta musamman.\n​Sigogi:\n- word1 (char*): Kalma ta farko da za a yi amfani da ita a cikin ID.\n- word2 (char*): Kalma ta biyu da za a yi amfani da ita a cikin ID.\n​Yana dawowa:\n​char*: Wani ID mai ban mamaki da aka ƙirƙira ta hanyar juyar da kowace harafi ta biyu na kalma ta biyu \n        da haɗa shi da kalma ta farko.\nmisali:\n    >>> create_id(fish,cat)\n\tftiasch\n*/\nchar* create_id(const char* word1, const char* word2)", "hi": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n/*\nविशिष्ट तरीके से दो शब्दों को मिलाकर एक आईडी बनाता है।\nपैरामीटर्स:\n- word1 (char*): आईडी में उपयोग के लिए पहला शब्द।\n- word2 (char*): आईडी में उपयोग के लिए दूसरा शब्द।\nरिटर्न करता है:\n​char*: एक दिव्य आईडी जो दूसरे शब्द के हर दूसरे अक्षर को उलटकर और \n        पहले शब्द के साथ मिलाकर बनाई जाती है।\nउदाहरण:\n    >>> create_id(fish,cat)\n\tftiasch\n*/\nchar* create_id(const char* word1, const char* word2)", "hu": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n/*\nLétrehoz egy azonosítót két szó speciális módon történő kombinálásával.\nParaméterek:\n- word1 (char*): Az első szó, amelyet az azonosítóban használunk.\n- word2 (char*): A második szó, amelyet az azonosítóban használunk.\nVisszatér:\nchar*: Egy isteni azonosító, amelyet a második szó minden második karakterének \n       megfordításával és az első szóval való kombinálásával hozunk létre.\npl.:\n    >>> create_id(fish,cat)\n\tftiasch\n*/\nchar* create_id(const char* word1, const char* word2)", "es": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n/*\nCrea un ID combinando dos palabras de una manera específica.\nParámetros:\n- word1 (char*): La primera palabra que se usará en el ID.\n- word2 (char*): La segunda palabra que se usará en el ID.\nDevuelve:\nchar*: Un ID divino formado invirtiendo cada otro carácter de la segunda \n       palabra y combinándolo con la primera palabra.\np.ej.:\n    >>> create_id(fish,cat)\n\tftiasch\n*/\nchar* create_id(const char* word1, const char* word2)", "arb": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n/*\nينشئ معرفًا عن طريق دمج كلمتين بطريقة معينة.\nالمعلمات:\n- word1 (char*): الكلمة الأولى المستخدمة في المعرف.\n- word2 (char*): الكلمة الثانية المستخدمة في المعرف.\nيعيد:\nchar*: معرف إلهي يتم تشكيله عن طريق عكس كل حرف آخر من الكلمة الثانية ودمجه مع الكلمة الأولى.\nمثال:\n    >>> create_id(fish,cat)\n\tftiasch\n*/\nchar* create_id(const char* word1, const char* word2)", "sw": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n/*\nHutengeneza kitambulisho kwa kuchanganya maneno mawili kwa namna maalum.\n​Vigezo:\n- word1 (char*): Neno la kwanza litakalotumika kwenye kitambulisho.\n- word2 (char*): Neno la pili litakalotumika kwenye kitambulisho.\n​Inarudisha:\n​char*: Kitambulisho cha kipekee kinachoundwa kwa kurudisha kila herufi nyingine ya neno la pili \n        na kuichanganya na neno la kwanza.\nmfano:\n    >>> create_id(fish,cat)\n\tftiasch\n*/\nchar* create_id(const char* word1, const char* word2)", "tr": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n/*\nBelirli bir şekilde iki kelimeyi birleştirerek bir kimlik oluşturur.\nParametreler:\n- word1 (char*): Kimlikte kullanılacak ilk kelime.\n- word2 (char*): Kimlikte kullanılacak ikinci kelime.\nDöndürür:\n​char*: İkinci kelimenin her iki karakterini ters çevirerek ve ilk kelimeyle \n        birleştirerek oluşturulan ilahi bir kimlik.\nÖrnek:\n    >>> create_id(fish,cat)\n\tftiasch\n*/\nchar* create_id(const char* word1, const char* word2)", "vi": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n/*\nTạo một ID bằng cách kết hợp hai từ theo một cách cụ thể.\nTham số:\n- word1 (char*): Từ đầu tiên được sử dụng trong ID.\n- word2 (char*): Từ thứ hai được sử dụng trong ID.\nTrả về:\nchar*: Một ID thần thánh được tạo bằng cách đảo ngược mỗi ký tự thứ hai của từ thứ hai\n        và kết hợp nó với từ đầu tiên.\nví dụ:\n    >>> create_id(fish,cat)\n\tftiasch\n*/\nchar* create_id(const char* word1, const char* word2)", "id": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n/*\nMembuat sebuah ID dengan menggabungkan dua kata dengan cara tertentu.\nParameter:\n- word1 (char*): Kata pertama yang akan digunakan dalam ID.\n- word2 (char*): Kata kedua yang akan digunakan dalam ID.\nMengembalikan:\nchar*: Sebuah ID ilahi yang dibentuk dengan membalik setiap karakter kedua \n       dari kata kedua dan menggabungkannya dengan kata pertama.\ncontoh:\n    >>> create_id(fish,cat)\n\tftiasch\n*/\nchar* create_id(const char* word1, const char* word2)", "ja": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n/*\n特定の方法で2つの単語を組み合わせてIDを作成します。\n​パラメータ:\n- word1 (char*): IDに使用する最初の単語。\n- word2 (char*): IDに使用する2番目の単語。\n​戻り値:\n​char*: 2番目の単語の1文字おきに反転させたものと最初の単語を組み合わせて形成された神聖なID。\n例:\n    >>> create_id(fish,cat)\n\tftiasch\n*/\nchar* create_id(const char* word1, const char* word2)", "ko": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n/*\n특정 방식으로 두 단어를 결합하여 ID를 생성합니다.\n매개변수:\n- word1 (char*): ID에 사용될 첫 번째 단어입니다.\n- word2 (char*): ID에 사용될 두 번째 단어입니다.\n반환값:\nchar*: 두 번째 단어의 모든 다른 문자를 뒤집고 첫 번째 단어와 결합하여 형성된 신성한 ID입니다.\n예시:\n    >>> create_id(fish,cat)\n\tftiasch\n*/\nchar* create_id(const char* word1, const char* word2)", "ml": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n/*\nഒരു ഐഡി സൃഷ്ടിക്കുന്നു, പ്രത്യേക രീതിയിൽ രണ്ട് വാക്കുകൾ ചേർത്ത്.\nപാരാമീറ്ററുകൾ:\n- word1 (char*): ഐഡിയിൽ ഉപയോഗിക്കേണ്ട ആദ്യത്തെ വാക്ക്.\n- word2 (char*): ഐഡിയിൽ ഉപയോഗിക്കേണ്ട രണ്ടാം വാക്ക്.\nമടക്കം:\nchar*: രണ്ടാം വാക്കിന്റെ ഓരോ മറ്റൊരു അക്ഷരവും മറിച്ച് അത് ആദ്യത്തെ വാക്കുമായി \n        ചേർത്തുണ്ടാക്കുന്ന ദിവ്യമായ ഒരു ഐഡി.\nഉദാ.:\n    >>> create_id(fish,cat)\n\tftiasch\n*/\nchar* create_id(const char* word1, const char* word2)", "fa": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n/*\nیک شناسه با ترکیب دو کلمه به روش خاصی ایجاد می‌کند.\n​پارامترها:\n- word1 (char*): اولین کلمه‌ای که در شناسه استفاده می‌شود.\n- word2 (char*): دومین کلمه‌ای که در شناسه استفاده می‌شود.\n​برمی‌گرداند:\n​char*: یک شناسه الهی که با معکوس کردن هر کاراکتر دیگر از کلمه دوم و \n        ترکیب آن با کلمه اول تشکیل شده است.\nمثال:\n    >>> create_id(fish,cat)\n\tftiasch\n*/\nchar* create_id(const char* word1, const char* word2)"}, "canonical_solution": "{\n    int length1 = strlen(word1);\n    int length2 = strlen(word2);\n    int total_length = length1 + length2;\n    char* id = malloc(sizeof(char) * (total_length + 1)); // +1 for the null-terminator\n\n    for (int i = 0, j = 0, k = length2 - 1; i < total_length; ++i) {\n        if (i & 1) {\n            id[i] = word2[k--]; // Take character from word2 in reverse\n        } else {\n            id[i] = word1[j++]; // Take character from word1\n        }\n    }\n    \n    id[total_length] = '\\0'; // Null-terminate the string\n    return id;\n}", "instruction": {"en": "char* create_id(const char* word1, const char* word2)\n{\n    int length1 = strlen(word1);\n    int length2 = strlen(word2);\n    int total_length = length1 + length2;\n    char* id = malloc(sizeof(char) * (total_length + 1)); // +1 for the null-terminator\n\n    for (int i = 0, j = 0, k = length2 - 1; i < total_length; ++i) {\n        if (i & 1) {\n            id[i] = word2[k--]; // Take character from word2 in reverse\n        } else {\n            id[i] = word1[j++]; // Take character from word1\n        }\n    }\n    \n    id[total_length] = '\\0'; // Null-terminate the string\n    return id;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "sq": "char* create_id(const char* word1, const char* word2)\n{\n    int length1 = strlen(word1);\n    int length2 = strlen(word2);\n    int total_length = length1 + length2;\n    char* id = malloc(sizeof(char) * (total_length + 1)); // +1 for the null-terminator\n\n    for (int i = 0, j = 0, k = length2 - 1; i < total_length; ++i) {\n        if (i & 1) {\n            id[i] = word2[k--]; // Take character from word2 in reverse\n        } else {\n            id[i] = word1[j++]; // Take character from word1\n        }\n    }\n    \n    id[total_length] = '\\0'; // Null-terminate the string\n    return id;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C në shqip duke përdorur maksimumi 500 karaktere.", "hy": "char* create_id(const char* word1, const char* word2)\n{\n    int length1 = strlen(word1);\n    int length2 = strlen(word2);\n    int total_length = length1 + length2;\n    char* id = malloc(sizeof(char) * (total_length + 1)); // +1 for the null-terminator\n\n    for (int i = 0, j = 0, k = length2 - 1; i < total_length; ++i) {\n        if (i & 1) {\n            id[i] = word2[k--]; // Take character from word2 in reverse\n        } else {\n            id[i] = word1[j++]; // Take character from word1\n        }\n    }\n    \n    id[total_length] = '\\0'; // Null-terminate the string\n    return id;\n}\n\nՏրամադրեք C կոդի հակիրճ բնութագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "char* create_id(const char* word1, const char* word2)\n{\n    int length1 = strlen(word1);\n    int length2 = strlen(word2);\n    int total_length = length1 + length2;\n    char* id = malloc(sizeof(char) * (total_length + 1)); // +1 for the null-terminator\n\n    for (int i = 0, j = 0, k = length2 - 1; i < total_length; ++i) {\n        if (i & 1) {\n            id[i] = word2[k--]; // Take character from word2 in reverse\n        } else {\n            id[i] = word1[j++]; // Take character from word1\n        }\n    }\n    \n    id[total_length] = '\\0'; // Null-terminate the string\n    return id;\n}\n\nনিচের C কোডটির একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।", "bg": "char* create_id(const char* word1, const char* word2)\n{\n    int length1 = strlen(word1);\n    int length2 = strlen(word2);\n    int total_length = length1 + length2;\n    char* id = malloc(sizeof(char) * (total_length + 1)); // +1 for the null-terminator\n\n    for (int i = 0, j = 0, k = length2 - 1; i < total_length; ++i) {\n        if (i & 1) {\n            id[i] = word2[k--]; // Take character from word2 in reverse\n        } else {\n            id[i] = word1[j++]; // Take character from word1\n        }\n    }\n    \n    id[total_length] = '\\0'; // Null-terminate the string\n    return id;\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, използвайки не повече от 500 символа.", "zh": "char* create_id(const char* word1, const char* word2)\n{\n    int length1 = strlen(word1);\n    int length2 = strlen(word2);\n    int total_length = length1 + length2;\n    char* id = malloc(sizeof(char) * (total_length + 1)); // +1 for the null-terminator\n\n    for (int i = 0, j = 0, k = length2 - 1; i < total_length; ++i) {\n        if (i & 1) {\n            id[i] = word2[k--]; // Take character from word2 in reverse\n        } else {\n            id[i] = word1[j++]; // Take character from word1\n        }\n    }\n    \n    id[total_length] = '\\0'; // Null-terminate the string\n    return id;\n}\n\n请用不超过500个字符的中文，为以下C代码提供简洁的自然语言描述（文档字符串）。", "fr": "char* create_id(const char* word1, const char* word2)\n{\n    int length1 = strlen(word1);\n    int length2 = strlen(word2);\n    int total_length = length1 + length2;\n    char* id = malloc(sizeof(char) * (total_length + 1)); // +1 for the null-terminator\n\n    for (int i = 0, j = 0, k = length2 - 1; i < total_length; ++i) {\n        if (i & 1) {\n            id[i] = word2[k--]; // Take character from word2 in reverse\n        } else {\n            id[i] = word1[j++]; // Take character from word1\n        }\n    }\n    \n    id[total_length] = '\\0'; // Null-terminate the string\n    return id;\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.", "de": "char* create_id(const char* word1, const char* word2)\n{\n    int length1 = strlen(word1);\n    int length2 = strlen(word2);\n    int total_length = length1 + length2;\n    char* id = malloc(sizeof(char) * (total_length + 1)); // +1 for the null-terminator\n\n    for (int i = 0, j = 0, k = length2 - 1; i < total_length; ++i) {\n        if (i & 1) {\n            id[i] = word2[k--]; // Take character from word2 in reverse\n        } else {\n            id[i] = word1[j++]; // Take character from word1\n        }\n    }\n    \n    id[total_length] = '\\0'; // Null-terminate the string\n    return id;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "char* create_id(const char* word1, const char* word2)\n{\n    int length1 = strlen(word1);\n    int length2 = strlen(word2);\n    int total_length = length1 + length2;\n    char* id = malloc(sizeof(char) * (total_length + 1)); // +1 for the null-terminator\n\n    for (int i = 0, j = 0, k = length2 - 1; i < total_length; ++i) {\n        if (i & 1) {\n            id[i] = word2[k--]; // Take character from word2 in reverse\n        } else {\n            id[i] = word1[j++]; // Take character from word1\n        }\n    }\n    \n    id[total_length] = '\\0'; // Null-terminate the string\n    return id;\n}\n\nBa da taƙaitaccen bayanin harshen halitta (docstring) na lambar C a cikin Hausa ta amfani da haruffa 500 ko ƙasa da haka.", "hi": "char* create_id(const char* word1, const char* word2)\n{\n    int length1 = strlen(word1);\n    int length2 = strlen(word2);\n    int total_length = length1 + length2;\n    char* id = malloc(sizeof(char) * (total_length + 1)); // +1 for the null-terminator\n\n    for (int i = 0, j = 0, k = length2 - 1; i < total_length; ++i) {\n        if (i & 1) {\n            id[i] = word2[k--]; // Take character from word2 in reverse\n        } else {\n            id[i] = word1[j++]; // Take character from word1\n        }\n    }\n    \n    id[total_length] = '\\0'; // Null-terminate the string\n    return id;\n}\n\nC कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "char* create_id(const char* word1, const char* word2)\n{\n    int length1 = strlen(word1);\n    int length2 = strlen(word2);\n    int total_length = length1 + length2;\n    char* id = malloc(sizeof(char) * (total_length + 1)); // +1 for the null-terminator\n\n    for (int i = 0, j = 0, k = length2 - 1; i < total_length; ++i) {\n        if (i & 1) {\n            id[i] = word2[k--]; // Take character from word2 in reverse\n        } else {\n            id[i] = word1[j++]; // Take character from word1\n        }\n    }\n    \n    id[total_length] = '\\0'; // Null-terminate the string\n    return id;\n}\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben.", "es": "char* create_id(const char* word1, const char* word2)\n{\n    int length1 = strlen(word1);\n    int length2 = strlen(word2);\n    int total_length = length1 + length2;\n    char* id = malloc(sizeof(char) * (total_length + 1)); // +1 for the null-terminator\n\n    for (int i = 0, j = 0, k = length2 - 1; i < total_length; ++i) {\n        if (i & 1) {\n            id[i] = word2[k--]; // Take character from word2 in reverse\n        } else {\n            id[i] = word1[j++]; // Take character from word1\n        }\n    }\n    \n    id[total_length] = '\\0'; // Null-terminate the string\n    return id;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando un máximo de 500 caracteres.", "arb": "char* create_id(const char* word1, const char* word2)\n{\n    int length1 = strlen(word1);\n    int length2 = strlen(word2);\n    int total_length = length1 + length2;\n    char* id = malloc(sizeof(char) * (total_length + 1)); // +1 for the null-terminator\n\n    for (int i = 0, j = 0, k = length2 - 1; i < total_length; ++i) {\n        if (i & 1) {\n            id[i] = word2[k--]; // Take character from word2 in reverse\n        } else {\n            id[i] = word1[j++]; // Take character from word1\n        }\n    }\n    \n    id[total_length] = '\\0'; // Null-terminate the string\n    return id;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "char* create_id(const char* word1, const char* word2)\n{\n    int length1 = strlen(word1);\n    int length2 = strlen(word2);\n    int total_length = length1 + length2;\n    char* id = malloc(sizeof(char) * (total_length + 1)); // +1 for the null-terminator\n\n    for (int i = 0, j = 0, k = length2 - 1; i < total_length; ++i) {\n        if (i & 1) {\n            id[i] = word2[k--]; // Take character from word2 in reverse\n        } else {\n            id[i] = word1[j++]; // Take character from word1\n        }\n    }\n    \n    id[total_length] = '\\0'; // Null-terminate the string\n    return id;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "char* create_id(const char* word1, const char* word2)\n{\n    int length1 = strlen(word1);\n    int length2 = strlen(word2);\n    int total_length = length1 + length2;\n    char* id = malloc(sizeof(char) * (total_length + 1)); // +1 for the null-terminator\n\n    for (int i = 0, j = 0, k = length2 - 1; i < total_length; ++i) {\n        if (i & 1) {\n            id[i] = word2[k--]; // Take character from word2 in reverse\n        } else {\n            id[i] = word1[j++]; // Take character from word1\n        }\n    }\n    \n    id[total_length] = '\\0'; // Null-terminate the string\n    return id;\n}\n\nC kodunun işlevini açıklayan kısa bir doğal dil tanımı (docstring) sağlayın. Açıklama 500 karakteri geçmemelidir.", "vi": "char* create_id(const char* word1, const char* word2)\n{\n    int length1 = strlen(word1);\n    int length2 = strlen(word2);\n    int total_length = length1 + length2;\n    char* id = malloc(sizeof(char) * (total_length + 1)); // +1 for the null-terminator\n\n    for (int i = 0, j = 0, k = length2 - 1; i < total_length; ++i) {\n        if (i & 1) {\n            id[i] = word2[k--]; // Take character from word2 in reverse\n        } else {\n            id[i] = word1[j++]; // Take character from word1\n        }\n    }\n    \n    id[total_length] = '\\0'; // Null-terminate the string\n    return id;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã C bằng tiếng Việt, sử dụng tối đa 500 ký tự.", "id": "char* create_id(const char* word1, const char* word2)\n{\n    int length1 = strlen(word1);\n    int length2 = strlen(word2);\n    int total_length = length1 + length2;\n    char* id = malloc(sizeof(char) * (total_length + 1)); // +1 for the null-terminator\n\n    for (int i = 0, j = 0, k = length2 - 1; i < total_length; ++i) {\n        if (i & 1) {\n            id[i] = word2[k--]; // Take character from word2 in reverse\n        } else {\n            id[i] = word1[j++]; // Take character from word1\n        }\n    }\n    \n    id[total_length] = '\\0'; // Null-terminate the string\n    return id;\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode C dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "char* create_id(const char* word1, const char* word2)\n{\n    int length1 = strlen(word1);\n    int length2 = strlen(word2);\n    int total_length = length1 + length2;\n    char* id = malloc(sizeof(char) * (total_length + 1)); // +1 for the null-terminator\n\n    for (int i = 0, j = 0, k = length2 - 1; i < total_length; ++i) {\n        if (i & 1) {\n            id[i] = word2[k--]; // Take character from word2 in reverse\n        } else {\n            id[i] = word1[j++]; // Take character from word1\n        }\n    }\n    \n    id[total_length] = '\\0'; // Null-terminate the string\n    return id;\n}\n\nC コードの簡単な自然言語による説明 (docstring) を英語で最大 500 文字まで入力してください。", "ko": "char* create_id(const char* word1, const char* word2)\n{\n    int length1 = strlen(word1);\n    int length2 = strlen(word2);\n    int total_length = length1 + length2;\n    char* id = malloc(sizeof(char) * (total_length + 1)); // +1 for the null-terminator\n\n    for (int i = 0, j = 0, k = length2 - 1; i < total_length; ++i) {\n        if (i & 1) {\n            id[i] = word2[k--]; // Take character from word2 in reverse\n        } else {\n            id[i] = word1[j++]; // Take character from word1\n        }\n    }\n    \n    id[total_length] = '\\0'; // Null-terminate the string\n    return id;\n}\n\nC 코드의 기능을 설명하는 간결한 자연어 설명(docstring)을 한국어로 작성하세요. 최대 500자 이내로 작성해야 합니다.", "ml": "char* create_id(const char* word1, const char* word2)\n{\n    int length1 = strlen(word1);\n    int length2 = strlen(word2);\n    int total_length = length1 + length2;\n    char* id = malloc(sizeof(char) * (total_length + 1)); // +1 for the null-terminator\n\n    for (int i = 0, j = 0, k = length2 - 1; i < total_length; ++i) {\n        if (i & 1) {\n            id[i] = word2[k--]; // Take character from word2 in reverse\n        } else {\n            id[i] = word1[j++]; // Take character from word1\n        }\n    }\n    \n    id[total_length] = '\\0'; // Null-terminate the string\n    return id;\n}\n\nസിയുടെ കോഡ് ഉപയോഗിച്ച് 500 അക്ഷരങ്ങൾക്കുള്ളിൽ മലയാളത്തിൽ സംക്ഷിപ്തമായ സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) നൽകുക.", "fa": "char* create_id(const char* word1, const char* word2)\n{\n    int length1 = strlen(word1);\n    int length2 = strlen(word2);\n    int total_length = length1 + length2;\n    char* id = malloc(sizeof(char) * (total_length + 1)); // +1 for the null-terminator\n\n    for (int i = 0, j = 0, k = length2 - 1; i < total_length; ++i) {\n        if (i & 1) {\n            id[i] = word2[k--]; // Take character from word2 in reverse\n        } else {\n            id[i] = word1[j++]; // Take character from word1\n        }\n    }\n    \n    id[total_length] = '\\0'; // Null-terminate the string\n    return id;\n}\n\nتوصیف مختصر به زبان طبیعی (docstring) از کد C به زبان فارسی ارائه دهید که حداکثر ۵۰۰ کاراکتر باشد."}, "level": "", "test": "int main() {\n    char* id; // To hold the results from create_id\n\n    id = create_id(\"fish\", \"cat\");\n    assert(strcmp(id, \"ftiasch\") == 0);\n    free(id);\n\n    id = create_id(\"icpc\", \"acm\");\n    assert(strcmp(id, \"imccpac\") == 0);\n    free(id);\n\n    id = create_id(\"oo\", \"w\");\n    assert(strcmp(id, \"owo\") == 0);\n    free(id);\n\n    // Add more test samples\n    id = create_id(\"hello\", \"world\");\n    assert(strcmp(id, \"hdellrloow\") == 0);\n    free(id);\n\n    id = create_id(\"abc\", \"def\");\n    assert(strcmp(id, \"afbecd\") == 0);\n    free(id);\n\n    id = create_id(\"buaanb\", \"nbbuaa\");\n    assert(strcmp(id, \"bauaauabnbbn\") == 0);\n    free(id);\n\n    id = create_id(\"xtuisgood\", \"ilovextu\");\n    assert(strcmp(id, \"xuttuxiesvgooloid\") == 0);\n    free(id);\n\n    return 0;\n}", "entry_point": "create_id", "signature": "char* create_id(const char* word1, const char* word2)", "docstring": {"en": "Creates an ID by combining two words in a specific manner.\nParameters:\n- word1 (char*): The first word to be used in the ID.\n- word2 (char*): The second word to be used in the ID.\nReturns:\nchar*: A divine ID formed by reversing every other character of the second word and combining it with the first word.\ne.g.:\n    >>> create_id(fish,cat)\n    ftiasch\n", "sq": "Krijon një ID duke kombinuar dy fjalë në një mënyrë specifike.  \nParametrat:  \n- word1 (char*): Fjala e parë që do të përdoret në ID.  \n- word2 (char*): Fjala e dytë që do të përdoret në ID.  \nKthen:  \nchar*: Një ID hyjnore e formuar duke përmbysur çdo karakter të dytë të fjalës së dytë dhe duke e kombinuar atë me fjalën e parë.  \np.sh.:  \n    >>> create_id(fish,cat)  \n    ftiasch  ", "hy": "Ստեղծում է ID՝ երկու բառերը հատուկ ձևով համատեղելով։  \nՊարամետրեր:  \n- word1 (char*): Առաջին բառը, որը կօգտագործվի ID-ում։  \n- word2 (char*): Երկրորդ բառը, որը կօգտագործվի ID-ում։  \nՎերադարձնում է:  \nchar*: Աստվածային ID, որը ձևավորվում է երկրորդ բառի յուրաքանչյուր երկրորդ նիշը շրջելով և այն առաջին բառի հետ համատեղելով։  \nօր.՝  \n    >>> create_id(fish,cat)  \n    ftiasch  ", "bn": "একটি নির্দিষ্ট পদ্ধতিতে দুটি শব্দ একত্রিত করে একটি আইডি তৈরি করে।\nপ্যারামিটারসমূহ:\n- word1 (char*): প্রথম শব্দ যা আইডিতে ব্যবহৃত হবে।\n- word2 (char*): দ্বিতীয় শব্দ যা আইডিতে ব্যবহৃত হবে।\nফেরত দেয়:\nchar*: একটি ঐশ্বরিক আইডি যা দ্বিতীয় শব্দের প্রতিটি বিকল্প অক্ষর উল্টে এবং প্রথম শব্দের সাথে একত্রিত করে গঠিত হয়।\nউদাহরণ:\n    >>> create_id(fish,cat)\n    ftiasch", "bg": "Създава ID, като комбинира две думи по специфичен начин.\nПараметри:\n- word1 (char*): Първата дума, която ще се използва в ID.\n- word2 (char*): Втората дума, която ще се използва в ID.\nВръща:\nchar*: Божествен ID, образуван чрез обръщане на всеки втори символ от втората дума и комбинирането му с първата дума.\nнапр.:\n    >>> create_id(fish,cat)\n    ftiasch", "zh": "通过以特定方式组合两个单词来创建一个ID。\n参数：\n- word1 (char*): 用于ID的第一个单词。\n- word2 (char*): 用于ID的第二个单词。\n返回：\nchar*: 一个神奇的ID，通过反转第二个单词的每隔一个字符并将其与第一个单词组合而成。\n例如：\n    >>> create_id(fish,cat)\n    ftiasch", "fr": "Crée un identifiant en combinant deux mots d'une manière spécifique.\nParamètres :\n- word1 (char*): Le premier mot à utiliser dans l'identifiant.\n- word2 (char*): Le deuxième mot à utiliser dans l'identifiant.\nRenvoie :\nchar*: Un identifiant divin formé en inversant chaque autre caractère du deuxième mot et en le combinant avec le premier mot.\nex. :\n    >>> create_id(fish,cat)\n    ftiasch", "de": "Erstellt eine ID, indem zwei Wörter auf eine bestimmte Weise kombiniert werden.\nParameter:\n- word1 (char*): Das erste Wort, das in der ID verwendet werden soll.\n- word2 (char*): Das zweite Wort, das in der ID verwendet werden soll.\nRückgabewert:\nchar*: Eine göttliche ID, die gebildet wird, indem jeder zweite Buchstabe des zweiten Wortes umgekehrt und mit dem ersten Wort kombiniert wird.\nz.B.:\n    >>> create_id(fish,cat)\n    ftiasch", "ha": "Yana ƙirƙirar ID ta hanyar haɗa kalmomi biyu ta wata hanya ta musamman.\n\nSigogi:\n- word1 (char*): Kalma ta farko da za a yi amfani da ita a cikin ID.\n- word2 (char*): Kalma ta biyu da za a yi amfani da ita a cikin ID.\n\nDawowa:\nchar*: Wani ID mai ban mamaki da aka ƙirƙira ta hanyar juyar da kowace harafi ta biyu na kalma ta biyu da haɗa shi da kalma ta farko.\n\ne.g.:\n    >>> create_id(fish,cat)\n    ftiasch", "hi": "दो शब्दों को एक विशिष्ट तरीके से मिलाकर एक आईडी बनाता है।\nमापदंड:  \n- word1 (char*): आईडी में उपयोग के लिए पहला शब्द।  \n- word2 (char*): आईडी में उपयोग के लिए दूसरा शब्द।  \nवापसी:  \nchar*: एक दिव्य आईडी जो दूसरे शब्द के हर दूसरे अक्षर को उलट कर और इसे पहले शब्द के साथ जोड़कर बनाई जाती है।  \nउदाहरण:  \n    >>> create_id(fish,cat)  \n    ftiasch  ", "hu": "Létrehoz egy azonosítót két szó meghatározott módon történő kombinálásával.  \nParaméterek:  \n- word1 (char*): Az első szó, amelyet az azonosítóban használunk.  \n- word2 (char*): A második szó, amelyet az azonosítóban használunk.  \nVisszatér:  \nchar*: Egy isteni azonosító, amely a második szó minden második karakterének megfordításával és az első szóval való kombinálásával jön létre.  \npélda:  \n    >>> create_id(fish,cat)  \n    ftiasch  ", "es": "Crea un ID combinando dos palabras de una manera específica.\nParámetros:\n- word1 (char*): La primera palabra que se utilizará en el ID.\n- word2 (char*): La segunda palabra que se utilizará en el ID.\nDevuelve:\nchar*: Un ID divino formado al invertir cada otro carácter de la segunda palabra y combinarlo con la primera palabra.\ne.g.:\n    >>> create_id(fish,cat)\n    ftiasch", "arb": "ينشئ معرفًا عن طريق دمج كلمتين بطريقة محددة.\nالمعلمات:\n- word1 (char*): الكلمة الأولى التي سيتم استخدامها في المعرف.\n- word2 (char*): الكلمة الثانية التي سيتم استخدامها في المعرف.\nالقيم المعادة:\nchar*: معرف إلهي يتكون من عكس كل حرف آخر من الكلمة الثانية ودمجه مع الكلمة الأولى.\nمثال:\n    >>> create_id(fish,cat)\n    ftiasch", "sw": "Huumba kitambulisho kwa kuchanganya maneno mawili kwa njia maalum.  \nVigezo:  \n- word1 (char*): Neno la kwanza litakalotumika kwenye kitambulisho.  \n- word2 (char*): Neno la pili litakalotumika kwenye kitambulisho.  \nRudisha:  \nchar*: Kitambulisho cha kipekee kinachoundwa kwa kubadilisha mpangilio wa kila herufi nyingine ya neno la pili na kuichanganya na neno la kwanza.  \nmfano:  \n    >>> create_id(fish,cat)  \n    ftiasch  ", "tr": "Belirli bir şekilde iki kelimeyi birleştirerek bir kimlik oluşturur.\nParametreler:\n- word1 (char*): Kimlikte kullanılacak ilk kelime.\n- word2 (char*): Kimlikte kullanılacak ikinci kelime.\nDöndürür:\nchar*: İkinci kelimenin her iki karakterini ters çevirerek ve ilk kelimeyle birleştirerek oluşturulan ilahi bir kimlik.\nörneğin:\n    >>> create_id(fish,cat)\n    ftiasch", "vi": "Tạo một ID bằng cách kết hợp hai từ theo một cách cụ thể.  \nTham số:  \n- word1 (char*): Từ đầu tiên được sử dụng trong ID.  \n- word2 (char*): Từ thứ hai được sử dụng trong ID.  \nTrả về:  \nchar*: Một ID thần thánh được tạo ra bằng cách đảo ngược mỗi ký tự khác của từ thứ hai và kết hợp với từ đầu tiên.  \nví dụ:  \n    >>> create_id(fish,cat)  \n    ftiasch  ", "id": "Membuat ID dengan menggabungkan dua kata dengan cara tertentu.\nParameter:\n- word1 (char*): Kata pertama yang akan digunakan dalam ID.\n- word2 (char*): Kata kedua yang akan digunakan dalam ID.\nMengembalikan:\nchar*: ID ilahi yang dibentuk dengan membalik setiap karakter kedua dari kata kedua dan menggabungkannya dengan kata pertama.\ncontoh:\n    >>> create_id(fish,cat)\n    ftiasch", "ja": "特定の方法で2つの単語を組み合わせてIDを作成します。\n引数:\n- word1 (char*): IDに使用する最初の単語。\n- word2 (char*): IDに使用する2番目の単語。\n戻り値:\nchar*: 2番目の単語の1文字おきに反転させたものを最初の単語と組み合わせて形成された神聖なID。\n例:\n    >>> create_id(fish,cat)\n    ftiasch", "ko": "ID를 특정 방식으로 두 단어를 결합하여 생성합니다.  \n매개변수:  \n- word1 (char*): ID에 사용될 첫 번째 단어입니다.  \n- word2 (char*): ID에 사용될 두 번째 단어입니다.  \n반환:  \nchar*: 두 번째 단어의 모든 다른 문자를 뒤집고 첫 번째 단어와 결합하여 형성된 신성한 ID입니다.  \n예시:  \n    >>> create_id(fish,cat)  \n    ftiasch  ", "ml": "ഒരു ഐഡി സൃഷ്ടിക്കുന്നു, പ്രത്യേക രീതിയിൽ രണ്ട് വാക്കുകൾ ചേർത്ത്.\nParameters:\n- word1 (char*): ID-ൽ ഉപയോഗിക്കാനുള്ള ആദ്യത്തെ വാക്ക്.\n- word2 (char*): ID-ൽ ഉപയോഗിക്കാനുള്ള രണ്ടാം വാക്ക്.\nReturns:\nchar*: രണ്ടാമത്തെ വാക്കിന്റെ ഓരോ മറ്റൊരു അക്ഷരവും മറിച്ച് ആദ്യത്തെ വാക്കുമായി ചേർത്ത് രൂപീകരിച്ച ഒരു ദിവ്യമായ ID.\ne.g.:\n    >>> create_id(fish,cat)\n    ftiasch", "fa": "ایجاد یک شناسه با ترکیب دو کلمه به روشی خاص.\nپارامترها:\n- word1 (char*): اولین کلمه‌ای که در شناسه استفاده می‌شود.\n- word2 (char*): دومین کلمه‌ای که در شناسه استفاده می‌شود.\nبازگشت:\nchar*: یک شناسه خاص که با برعکس کردن هر کاراکتر دیگر از کلمه دوم و ترکیب آن با کلمه اول تشکیل شده است.\nمثال:\n    >>> create_id(fish,cat)\n    ftiasch"}}
{"task_id": "C/19", "prompt": {"en": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCount the number of different permutation schemes for a binary string of length n,\nwhere the number of '1's is m and the number of '0's is n - m.\n​    Parameters:\n- n (int): Length of the binary string.\n- m (int): Number of '1's in the binary string.\n​    Returns:\n​    int: The total number of different permutation schemes.\n*/\nint count_permutations_of_binary_string(int n, int m)", "sq": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nNumëron numrin e skemave të ndryshme të permutimit për një varg binar me gjatësi n,\nku numri i '1'-ve është m dhe numri i '0'-ve është n - m.\n​    Parametrat:\n- n (int): Gjatësia e vargut binar.\n- m (int): Numri i '1'-ve në vargun binar.\n​    Kthen:\n​    int: Numri total i skemave të ndryshme të permutimit.\n*/\nint count_permutations_of_binary_string(int n, int m)", "hy": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nՀաշվել տարբեր փոխատեղման սխեմաների քանակը երկբայական տողի համար, որի երկարությունը n է,\nորտեղ '1'-երի քանակը m է, իսկ '0'-երի քանակը n - m է։\n​    Պարամետրեր:\n- n (int): Երկբայական տողի երկարությունը։\n- m (int): '1'-երի քանակը երկբայական տողի մեջ։\n​    Վերադարձնում է:\n​    int: Տարբեր փոխատեղման սխեմաների ընդհանուր քանակը։\n*/\nint count_permutations_of_binary_string(int n, int m)", "bn": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nএকটি বাইনারি স্ট্রিংয়ের জন্য বিভিন্ন বিন্যাস পরিকল্পনার সংখ্যা গণনা করুন যার দৈর্ঘ্য n,\nযেখানে '1' এর সংখ্যা m এবং '0' এর সংখ্যা n - m।\n    প্যারামিটার:\n- n (int): বাইনারি স্ট্রিংয়ের দৈর্ঘ্য।\n- m (int): বাইনারি স্ট্রিংয়ে '1' এর সংখ্যা।\n    রিটার্ন:\n    int: বিভিন্ন বিন্যাস পরিকল্পনার মোট সংখ্যা।\n*/\nint count_permutations_of_binary_string(int n, int m)", "bg": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nБройте броя на различните схеми на пермутации за двоичен низ с дължина n,\nкъдето броят на '1'-ците е m, а броят на '0'-ите е n - m.\n    Параметри:\n- n (int): Дължина на двоичния низ.\n- m (int): Брой на '1'-ците в двоичния низ.\n    Връща:\n    int: Общият брой на различните схеми на пермутации.\n*/\nint count_permutations_of_binary_string(int n, int m)", "zh": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n计算长度为 n 的二进制字符串的不同排列方案数量，\n其中 '1' 的数量为 m，'0' 的数量为 n - m。\n    参数：\n- n (int): 二进制字符串的长度。\n- m (int): 二进制字符串中 '1' 的数量。\n    返回：\n    int: 不同排列方案的总数量。\n*/\nint count_permutations_of_binary_string(int n, int m)", "fr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCompter le nombre de différents schémas de permutation pour une chaîne binaire de longueur n,\noù le nombre de '1' est m et le nombre de '0' est n - m.\n    Paramètres:\n- n (int): Longueur de la chaîne binaire.\n- m (int): Nombre de '1' dans la chaîne binaire.\n    Renvoie:\n    int: Le nombre total de différents schémas de permutation.\n*/\nint count_permutations_of_binary_string(int n, int m)", "de": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nZählt die Anzahl der verschiedenen Permutationsschemata für einen Binärstring der Länge n,\nwobei die Anzahl der '1's m ist und die Anzahl der '0's n - m ist.\n    Parameter:\n- n (int): Länge des Binärstrings.\n- m (int): Anzahl der '1's im Binärstring.\n    Rückgabe:\n    int: Die Gesamtanzahl der verschiedenen Permutationsschemata.\n*/\nint count_permutations_of_binary_string(int n, int m)", "ha": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nƘididdige adadin tsarin juyawa daban-daban don igiyar binary mai tsawon n,\ninda adadin '1's shine m kuma adadin '0's shine n - m.\n​    Sigogi:\n- n (int): Tsawon igiyar binary.\n- m (int): Adadin '1's a cikin igiyar binary.\n​    Yana dawowa:\n​    int: Jimillar adadin tsarin juyawa daban-daban.\n*/\nint count_permutations_of_binary_string(int n, int m)", "hi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nएक बाइनरी स्ट्रिंग की विभिन्न क्रमचय योजनाओं की संख्या गिनें जिसकी लंबाई n है,\nजहां '1's की संख्या m है और '0's की संख्या n - m है।\n    पैरामीटर्स:\n- n (int): बाइनरी स्ट्रिंग की लंबाई।\n- m (int): बाइनरी स्ट्रिंग में '1's की संख्या।\n    रिटर्न करता है:\n    int: विभिन्न क्रमचय योजनाओं की कुल संख्या।\n*/\nint count_permutations_of_binary_string(int n, int m)", "hu": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nSzámolja meg a különböző permutációs sémák számát egy n hosszúságú bináris karakterlánc esetén,\nahol az '1'-ek száma m, és a '0'-k száma n - m.\n    Paraméterek:\n- n (int): A bináris karakterlánc hossza.\n- m (int): Az '1'-ek száma a bináris karakterláncban.\n    Visszatérési érték:\n    int: A különböző permutációs sémák teljes száma.\n*/\nint count_permutations_of_binary_string(int n, int m)", "es": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCuenta el número de diferentes esquemas de permutación para una cadena binaria de longitud n,\ndonde el número de '1's es m y el número de '0's es n - m.\n    Parámetros:\n- n (int): Longitud de la cadena binaria.\n- m (int): Número de '1's en la cadena binaria.\n    Devuelve:\n    int: El número total de diferentes esquemas de permutación.\n*/\nint count_permutations_of_binary_string(int n, int m)", "arb": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nاحسب عدد مخططات التبديل المختلفة لسلسلة ثنائية بطول n،\nحيث أن عدد '1's هو m وعدد '0's هو n - m.\n​    المعاملات:\n- n (int): طول السلسلة الثنائية.\n- m (int): عدد '1's في السلسلة الثنائية.\n​    يعيد:\n​    int: العدد الإجمالي لمخططات التبديل المختلفة.\n*/\nint count_permutations_of_binary_string(int n, int m)", "sw": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nHesabu idadi ya mipango tofauti ya mpangilio kwa kamba ya binary yenye urefu n,\nambapo idadi ya '1's ni m na idadi ya '0's ni n - m.\n​    Vigezo:\n- n (int): Urefu wa kamba ya binary.\n- m (int): Idadi ya '1's katika kamba ya binary.\n​    Inarudisha:\n​    int: Jumla ya idadi ya mipango tofauti ya mpangilio.\n*/\nint count_permutations_of_binary_string(int n, int m)", "tr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nUzunluğu n olan bir ikili dizge için, '1'lerin sayısının m ve '0'ların sayısının n - m olduğu farklı permütasyon şemalarının sayısını sayın.\n    Parametreler:\n- n (int): İkili dizgenin uzunluğu.\n- m (int): İkili dizgedeki '1'lerin sayısı.\n    Döndürür:\n    int: Farklı permütasyon şemalarının toplam sayısı.\n*/\nint count_permutations_of_binary_string(int n, int m)", "vi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nĐếm số lượng các sơ đồ hoán vị khác nhau cho một chuỗi nhị phân có độ dài n,\ntrong đó số lượng '1' là m và số lượng '0' là n - m.\n    Tham số:\n- n (int): Độ dài của chuỗi nhị phân.\n- m (int): Số lượng '1' trong chuỗi nhị phân.\n    Trả về:\n    int: Tổng số lượng các sơ đồ hoán vị khác nhau.\n*/\nint count_permutations_of_binary_string(int n, int m)", "id": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nHitung jumlah skema permutasi berbeda untuk string biner dengan panjang n,\ndi mana jumlah '1' adalah m dan jumlah '0' adalah n - m.\n    Parameter:\n- n (int): Panjang string biner.\n- m (int): Jumlah '1' dalam string biner.\n    Mengembalikan:\n    int: Jumlah total skema permutasi berbeda.\n*/\nint count_permutations_of_binary_string(int n, int m)", "ja": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n長さ n の2進文字列に対する異なる順列スキームの数を数えます。\nここで、'1' の数は m であり、'0' の数は n - m です。\n    パラメータ:\n- n (int): 2進文字列の長さ。\n- m (int): 2進文字列内の '1' の数。\n    戻り値:\n    int: 異なる順列スキームの総数。\n*/\nint count_permutations_of_binary_string(int n, int m)", "ko": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n길이가 n인 이진 문자열에 대해, '1'의 개수가 m이고 '0'의 개수가 n - m인 서로 다른 순열의 수를 계산합니다.\n​    매개변수:\n- n (int): 이진 문자열의 길이.\n- m (int): 이진 문자열에서 '1'의 개수.\n​    반환값:\n​    int: 서로 다른 순열의 총 개수.\n*/\nint count_permutations_of_binary_string(int n, int m)", "ml": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nഒരു ബൈനറി സ്ട്രിംഗ് നീളം n ആയതിനായി വ്യത്യസ്തമായ പെർമ്യൂട്ടേഷൻ സ്കീമുകളുടെ എണ്ണം എണ്ണുക,\n'1' കളുടെ എണ്ണം m ആകുകയും '0' കളുടെ എണ്ണം n - m ആകുകയും ചെയ്യുന്നു.\n    പാരാമീറ്ററുകൾ:\n- n (int): ബൈനറി സ്ട്രിംഗിന്റെ നീളം.\n- m (int): ബൈനറി സ്ട്രിംഗിലെ '1' കളുടെ എണ്ണം.\n    തിരികെ നൽകുന്നു:\n    int: വ്യത്യസ്തമായ പെർമ്യൂട്ടേഷൻ സ്കീമുകളുടെ മൊത്തം എണ്ണം.\n*/\nint count_permutations_of_binary_string(int n, int m)", "fa": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nتعداد طرح‌های جایگشت مختلف برای یک رشته باینری با طول n را شمارش کنید،\nکه تعداد '1'ها برابر m و تعداد '0'ها برابر n - m است.\n    پارامترها:\n- n (int): طول رشته باینری.\n- m (int): تعداد '1'ها در رشته باینری.\n    بازگشت:\n    int: تعداد کل طرح‌های جایگشت مختلف.\n*/\nint count_permutations_of_binary_string(int n, int m)"}, "canonical_solution": "{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    // printf(\"%f %f %f\\n\", numerator, denominator1, denominator2);\n\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // printf(\"%f\\n\", numerator / denominator1 / denominator2);\n        // Calculating the number of permutations using the factorial values\n        return (int)(numerator / denominator1 / denominator2 + 0.5);\n    }\n}", "instruction": {"en": "int count_permutations_of_binary_string(int n, int m)\n{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    // printf(\"%f %f %f\\n\", numerator, denominator1, denominator2);\n\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // printf(\"%f\\n\", numerator / denominator1 / denominator2);\n        // Calculating the number of permutations using the factorial values\n        return (int)(numerator / denominator1 / denominator2 + 0.5);\n    }\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "sq": "int count_permutations_of_binary_string(int n, int m)\n{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    // printf(\"%f %f %f\\n\", numerator, denominator1, denominator2);\n\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // printf(\"%f\\n\", numerator / denominator1 / denominator2);\n        // Calculating the number of permutations using the factorial values\n        return (int)(numerator / denominator1 / denominator2 + 0.5);\n    }\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C në shqip duke përdorur maksimumi 500 karaktere.", "hy": "int count_permutations_of_binary_string(int n, int m)\n{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    // printf(\"%f %f %f\\n\", numerator, denominator1, denominator2);\n\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // printf(\"%f\\n\", numerator / denominator1 / denominator2);\n        // Calculating the number of permutations using the factorial values\n        return (int)(numerator / denominator1 / denominator2 + 0.5);\n    }\n}\n\nՏվեք C կոդի հակիրճ բնութագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։", "bn": "int count_permutations_of_binary_string(int n, int m)\n{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    // printf(\"%f %f %f\\n\", numerator, denominator1, denominator2);\n\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // printf(\"%f\\n\", numerator / denominator1 / denominator2);\n        // Calculating the number of permutations using the factorial values\n        return (int)(numerator / denominator1 / denominator2 + 0.5);\n    }\n}\n\nনিচের C কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।", "bg": "int count_permutations_of_binary_string(int n, int m)\n{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    // printf(\"%f %f %f\\n\", numerator, denominator1, denominator2);\n\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // printf(\"%f\\n\", numerator / denominator1 / denominator2);\n        // Calculating the number of permutations using the factorial values\n        return (int)(numerator / denominator1 / denominator2 + 0.5);\n    }\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, използвайки най-много 500 знака.", "zh": "int count_permutations_of_binary_string(int n, int m)\n{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    // printf(\"%f %f %f\\n\", numerator, denominator1, denominator2);\n\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // printf(\"%f\\n\", numerator / denominator1 / denominator2);\n        // Calculating the number of permutations using the factorial values\n        return (int)(numerator / denominator1 / denominator2 + 0.5);\n    }\n}\n\n请用不超过500个字符的中文，为以下C代码提供简洁的自然语言描述（文档字符串）。", "fr": "int count_permutations_of_binary_string(int n, int m)\n{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    // printf(\"%f %f %f\\n\", numerator, denominator1, denominator2);\n\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // printf(\"%f\\n\", numerator / denominator1 / denominator2);\n        // Calculating the number of permutations using the factorial values\n        return (int)(numerator / denominator1 / denominator2 + 0.5);\n    }\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.", "de": "int count_permutations_of_binary_string(int n, int m)\n{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    // printf(\"%f %f %f\\n\", numerator, denominator1, denominator2);\n\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // printf(\"%f\\n\", numerator / denominator1 / denominator2);\n        // Calculating the number of permutations using the factorial values\n        return (int)(numerator / denominator1 / denominator2 + 0.5);\n    }\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "int count_permutations_of_binary_string(int n, int m)\n{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    // printf(\"%f %f %f\\n\", numerator, denominator1, denominator2);\n\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // printf(\"%f\\n\", numerator / denominator1 / denominator2);\n        // Calculating the number of permutations using the factorial values\n        return (int)(numerator / denominator1 / denominator2 + 0.5);\n    }\n}\n\nBa da takaitaccen bayanin yare na halitta (docstring) na lambar C cikin Hausa ta amfani da haruffa 500 kacal.", "hi": "int count_permutations_of_binary_string(int n, int m)\n{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    // printf(\"%f %f %f\\n\", numerator, denominator1, denominator2);\n\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // printf(\"%f\\n\", numerator / denominator1 / denominator2);\n        // Calculating the number of permutations using the factorial values\n        return (int)(numerator / denominator1 / denominator2 + 0.5);\n    }\n}\n\nC कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "int count_permutations_of_binary_string(int n, int m)\n{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    // printf(\"%f %f %f\\n\", numerator, denominator1, denominator2);\n\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // printf(\"%f\\n\", numerator / denominator1 / denominator2);\n        // Calculating the number of permutations using the factorial values\n        return (int)(numerator / denominator1 / denominator2 + 0.5);\n    }\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben.", "es": "int count_permutations_of_binary_string(int n, int m)\n{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    // printf(\"%f %f %f\\n\", numerator, denominator1, denominator2);\n\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // printf(\"%f\\n\", numerator / denominator1 / denominator2);\n        // Calculating the number of permutations using the factorial values\n        return (int)(numerator / denominator1 / denominator2 + 0.5);\n    }\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando como máximo 500 caracteres.", "arb": "int count_permutations_of_binary_string(int n, int m)\n{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    // printf(\"%f %f %f\\n\", numerator, denominator1, denominator2);\n\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // printf(\"%f\\n\", numerator / denominator1 / denominator2);\n        // Calculating the number of permutations using the factorial values\n        return (int)(numerator / denominator1 / denominator2 + 0.5);\n    }\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "int count_permutations_of_binary_string(int n, int m)\n{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    // printf(\"%f %f %f\\n\", numerator, denominator1, denominator2);\n\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // printf(\"%f\\n\", numerator / denominator1 / denominator2);\n        // Calculating the number of permutations using the factorial values\n        return (int)(numerator / denominator1 / denominator2 + 0.5);\n    }\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "int count_permutations_of_binary_string(int n, int m)\n{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    // printf(\"%f %f %f\\n\", numerator, denominator1, denominator2);\n\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // printf(\"%f\\n\", numerator / denominator1 / denominator2);\n        // Calculating the number of permutations using the factorial values\n        return (int)(numerator / denominator1 / denominator2 + 0.5);\n    }\n}\n\nC kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe olarak yazılmalıdır.", "vi": "int count_permutations_of_binary_string(int n, int m)\n{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    // printf(\"%f %f %f\\n\", numerator, denominator1, denominator2);\n\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // printf(\"%f\\n\", numerator / denominator1 / denominator2);\n        // Calculating the number of permutations using the factorial values\n        return (int)(numerator / denominator1 / denominator2 + 0.5);\n    }\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã C bằng tiếng Việt, sử dụng tối đa 500 ký tự.", "id": "int count_permutations_of_binary_string(int n, int m)\n{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    // printf(\"%f %f %f\\n\", numerator, denominator1, denominator2);\n\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // printf(\"%f\\n\", numerator / denominator1 / denominator2);\n        // Calculating the number of permutations using the factorial values\n        return (int)(numerator / denominator1 / denominator2 + 0.5);\n    }\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode C dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "int count_permutations_of_binary_string(int n, int m)\n{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    // printf(\"%f %f %f\\n\", numerator, denominator1, denominator2);\n\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // printf(\"%f\\n\", numerator / denominator1 / denominator2);\n        // Calculating the number of permutations using the factorial values\n        return (int)(numerator / denominator1 / denominator2 + 0.5);\n    }\n}\n\n以下のCコードの簡潔な自然言語による説明（ドックストリング）を日本語で500文字以内で提供してください。", "ko": "int count_permutations_of_binary_string(int n, int m)\n{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    // printf(\"%f %f %f\\n\", numerator, denominator1, denominator2);\n\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // printf(\"%f\\n\", numerator / denominator1 / denominator2);\n        // Calculating the number of permutations using the factorial values\n        return (int)(numerator / denominator1 / denominator2 + 0.5);\n    }\n}\n\nC 코드에 대한 간결한 자연어 설명(docstring)을 한국어로 최대 500자 이내로 제공하세요.", "ml": "int count_permutations_of_binary_string(int n, int m)\n{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    // printf(\"%f %f %f\\n\", numerator, denominator1, denominator2);\n\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // printf(\"%f\\n\", numerator / denominator1 / denominator2);\n        // Calculating the number of permutations using the factorial values\n        return (int)(numerator / denominator1 / denominator2 + 0.5);\n    }\n}\n\nസിയി കോഡിന്റെ സംക്ഷിപ്തമായ സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) മലയാളത്തിൽ 500 അക്ഷരങ്ങളിൽ കൂടാതെയായി നൽകുക.", "fa": "int count_permutations_of_binary_string(int n, int m)\n{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    // printf(\"%f %f %f\\n\", numerator, denominator1, denominator2);\n\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // printf(\"%f\\n\", numerator / denominator1 / denominator2);\n        // Calculating the number of permutations using the factorial values\n        return (int)(numerator / denominator1 / denominator2 + 0.5);\n    }\n}\n\nتوضیح مختصر و طبیعی (docstring) از کد C به زبان فارسی ارائه دهید که حداکثر ۵۰۰ کاراکتر باشد."}, "level": "", "test": "int main() {\n    // printf(\"%d\\n\", count_permutations_of_binary_string(2, 0));\n    assert(count_permutations_of_binary_string(2, 0) == 2);\n    assert(count_permutations_of_binary_string(2, 1) == 0);\n    assert(count_permutations_of_binary_string(3, 0) == 0);\n    assert(count_permutations_of_binary_string(3, 1) == 3);\n    assert(count_permutations_of_binary_string(3, 2) == 0);\n    assert(count_permutations_of_binary_string(30, 2) == 145422675);\n    assert(count_permutations_of_binary_string(4, 2) == 4);\n    assert(count_permutations_of_binary_string(5, 5) == 1);\n    assert(count_permutations_of_binary_string(33, 17) == 13884156);\n    assert(count_permutations_of_binary_string(1000, 1000) == 1);\n    // Add more test cases if necessary\n    return 0;\n}", "entry_point": "count_permutations_of_binary_string", "signature": "int count_permutations_of_binary_string(int n, int m)", "docstring": {"en": "Count the number of different permutation schemes for a binary string of length n,\nwhere the number of '1's is m and the number of '0's is n - m.\n​    Parameters:\n- n (int): Length of the binary string.\n- m (int): Number of '1's in the binary string.\n​    Returns:\n​    int: The total number of different permutation schemes.\n", "sq": "Numëroni numrin e skemave të ndryshme të permutimit për një varg binar me gjatësi n, ku numri i '1'-ve është m dhe numri i '0'-ve është n - m.\n​    Parametra:\n- n (int): Gjatësia e vargut binar.\n- m (int): Numri i '1'-ve në vargun binar.\n​    Kthen:\n​    int: Numri total i skemave të ndryshme të permutimit.", "hy": "Հաշվել տարբեր տեղաբաշխման սխեմաների քանակը երկբանական տողի համար, որի երկարությունը n է, որտեղ '1'-երի քանակը m է, իսկ '0'-երի քանակը n - m:\n​    Պարամետրեր:\n- n (int): Երկբանական տողի երկարությունը։\n- m (int): '1'-երի քանակը երկբանական տողի մեջ։\n​    Վերադարձնում է:\n​    int: Տարբեր տեղաբաշխման սխեմաների ընդհանուր քանակը։", "bn": "বাইনারি স্ট্রিংয়ের দৈর্ঘ্য n এর জন্য বিভিন্ন বিন্যাস স্কিমের সংখ্যা গণনা করুন, যেখানে '1' এর সংখ্যা m এবং '0' এর সংখ্যা n - m।\n\nParameters:\n- n (int): বাইনারি স্ট্রিংয়ের দৈর্ঘ্য।\n- m (int): বাইনারি স্ট্রিংয়ে '1' এর সংখ্যা।\n\nReturns:\nint: বিভিন্ন বিন্যাস স্কিমের মোট সংখ্যা।", "bg": "Бройте броя на различните схеми на пермутации за двоична низ с дължина n, където броят на '1'-ците е m и броят на '0'-ците е n - m.\n    Параметри:\n- n (int): Дължина на двоичната низ.\n- m (int): Брой на '1'-ците в двоичната низ.\n    Връща:\n    int: Общият брой на различните схеми на пермутации.", "zh": "计算长度为 n 的二进制字符串的不同排列方案数量，其中 '1' 的数量为 m，'0' 的数量为 n - m。\n\n参数：\n- n (int): 二进制字符串的长度。\n- m (int): 二进制字符串中 '1' 的数量。\n\n返回：\nint: 不同排列方案的总数量。", "fr": "Compter le nombre de différents schémas de permutation pour une chaîne binaire de longueur n, où le nombre de '1' est m et le nombre de '0' est n - m.\n    Paramètres:\n- n (int): Longueur de la chaîne binaire.\n- m (int): Nombre de '1' dans la chaîne binaire.\n    Renvoie:\n    int: Le nombre total de différents schémas de permutation.", "de": "Zähle die Anzahl der verschiedenen Permutationsschemata für einen Binärstring der Länge n, wobei die Anzahl der '1's m ist und die Anzahl der '0's n - m.  \n​    Parameter:\n- n (int): Länge des Binärstrings.\n- m (int): Anzahl der '1's im Binärstring.\n​    Rückgabe:\n​    int: Die Gesamtanzahl der verschiedenen Permutationsschemata.", "ha": "Ƙirga adadin tsarin juyawa daban-daban don igiyar binary mai tsawon n,\ninda adadin '1's shine m da adadin '0's shine n - m. \n    Parameters:\n- n (int): Tsawon igiyar binary.\n- m (int): Adadin '1's a cikin igiyar binary.\n    Returns:\n    int: Jimillar adadin tsarin permutation daban-daban.", "hi": "बाइनरी स्ट्रिंग की लंबाई n के लिए विभिन्न क्रमपरिवर्तन योजनाओं की संख्या गिनें, जहाँ '1's की संख्या m है और '0's की संख्या n - m है।\n    पैरामीटर्स:\n- n (int): बाइनरी स्ट्रिंग की लंबाई।\n- m (int): बाइनरी स्ट्रिंग में '1's की संख्या।\n    रिटर्न्स:\n    int: विभिन्न क्रमपरिवर्तन योजनाओं की कुल संख्या।", "hu": "Számolja meg a különböző permutációs sémák számát egy n hosszúságú bináris karakterlánc esetén, ahol az '1'-ek száma m, és a '0'-k száma n - m.\n    Paraméterek:\n- n (int): A bináris karakterlánc hossza.\n- m (int): Az '1'-ek száma a bináris karakterláncban.\n    Visszatér:\n    int: A különböző permutációs sémák összesített száma.", "es": "Cuenta el número de diferentes esquemas de permutación para una cadena binaria de longitud n, donde el número de '1's es m y el número de '0's es n - m.\n    Parámetros:\n- n (int): Longitud de la cadena binaria.\n- m (int): Número de '1's en la cadena binaria.\n    Devuelve:\n    int: El número total de diferentes esquemas de permutación.", "arb": "احسب عدد مخططات التبديل المختلفة لسلسلة ثنائية بطول n، حيث يكون عدد '1's هو m وعدد '0's هو n - m.\n    المعلمات:\n- n (int): طول السلسلة الثنائية.\n- m (int): عدد '1's في السلسلة الثنائية.\n    يعيد:\n    int: العدد الإجمالي لمخططات التبديل المختلفة.", "sw": "Hesabu idadi ya mpangilio tofauti wa mpangilio kwa kamba ya binary yenye urefu n, ambapo idadi ya '1' ni m na idadi ya '0' ni n - m.\n​    Vigezo:\n- n (int): Urefu wa kamba ya binary.\n- m (int): Idadi ya '1' katika kamba ya binary.\n​    Inarudisha:\n​    int: Jumla ya idadi ya mpangilio tofauti wa mpangilio.", "tr": "İkili bir dizginin uzunluğu n olan ve '1'lerin sayısı m, '0'ların sayısı n - m olan farklı permütasyon şemalarının sayısını sayın.\n\nParametreler:\n- n (int): İkili dizginin uzunluğu.\n- m (int): İkili dizgideki '1'lerin sayısı.\n\nDöndürür:\nint: Farklı permütasyon şemalarının toplam sayısı.", "vi": "Đếm số lượng các sơ đồ hoán vị khác nhau cho một chuỗi nhị phân có độ dài n, trong đó số lượng '1' là m và số lượng '0' là n - m.\n\n    Tham số:\n    - n (int): Độ dài của chuỗi nhị phân.\n    - m (int): Số lượng '1' trong chuỗi nhị phân.\n\n    Trả về:\n    int: Tổng số lượng các sơ đồ hoán vị khác nhau.", "id": "Hitung jumlah skema permutasi berbeda untuk string biner dengan panjang n, di mana jumlah '1' adalah m dan jumlah '0' adalah n - m.\n    Parameter:\n- n (int): Panjang dari string biner.\n- m (int): Jumlah '1' dalam string biner.\n    Mengembalikan:\n    int: Jumlah total skema permutasi berbeda.", "ja": "バイナリ文字列の長さnに対する異なる順列スキームの数を数えます。ここで、'1'の数はmで、'0'の数はn - mです。\n\n​    パラメータ:\n- n (int): バイナリ文字列の長さ。\n- m (int): バイナリ文字列内の'1'の数。\n\n​    戻り値:\n​    int: 異なる順列スキームの総数。", "ko": "이진 문자열의 길이가 n이고, '1'의 개수가 m이며 '0'의 개수가 n - m인 경우의 서로 다른 순열 방식을 계산합니다.\n\n매개변수:\n- n (int): 이진 문자열의 길이.\n- m (int): 이진 문자열에서 '1'의 개수.\n\n반환:\nint: 서로 다른 순열 방식의 총 개수.", "ml": "ഒരു ബൈനറി സ്ട്രിംഗ് നീളം n ആയതിനായി വ്യത്യസ്തമായ പെർമ്യൂട്ടേഷൻ സ്കീമുകളുടെ എണ്ണം എണ്ണുക,\n'1' കളുടെ എണ്ണം m ആകുകയും '0' കളുടെ എണ്ണം n - m ആകുകയും ചെയ്യുന്നു. \n\nപാരാമീറ്ററുകൾ:\n- n (int): ബൈനറി സ്ട്രിംഗിന്റെ നീളം.\n- m (int): ബൈനറി സ്ട്രിംഗിലെ '1' കളുടെ എണ്ണം.\n\nമടക്കം:\nint: വ്യത്യസ്തമായ പെർമ്യൂട്ടേഷൻ സ്കീമുകളുടെ മൊത്തം എണ്ണം.", "fa": "تعداد طرح‌های جایگشت مختلف برای یک رشته باینری با طول n را بشمارید، \nکه تعداد '1'ها برابر با m و تعداد '0'ها برابر با n - m است.\n​    پارامترها:\n- n (int): طول رشته باینری.\n- m (int): تعداد '1'ها در رشته باینری.\n​    بازگشت:\n​    int: تعداد کل طرح‌های جایگشت مختلف."}}
{"task_id": "C/20", "prompt": {"en": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n​    Answer a series of questions by providing choices A, B, C, or D for each question.\n​    Question 1:\n​    Constants like 1e6 belong to which data type?\n​        A. unsigned int\n​        B. int\n​        C. float\n​        D. double\n​    Question 2:\n​    Given 21! = 51,090,942,171,709,440,000, which data type can be used to store this value?\n​        A. int\n​        B. long long\n​        C. double\n​        D. None of the above\n​    Question 3:\n​    Which statement about left values in expressions is incorrect?\n​        A. Variable name expressions are left values.\n​        B. Increment operation requires the operand to be a left value.\n​        C. Pointer dereference expressions are left values.\n​        D. Prefix increment operation expressions are left values.\n​    Question 4:\n​    Which statement about functions is incorrect?\n​        A. Formal parameters of a function are local variables.\n​        B. Local variables are allocated space in the stack.\n​        C. The function type is the same as the return value type.\n​        D. A function can call itself from within its body.\n​    Question 5:\n​    Which statement about pointers is incorrect?\n​        A. Subtracting two pointers equals the difference in their address values.\n​        B. Pointer dereference involves resolving based on the pointer's type.\n​        C. int *p[4], p is an array of int pointers.\n​        D. Function names can be assigned to function pointers.\n\t>>> answer_questions()\n\tAAAAA\nYou're supposed to only return strings similar to \"AAAAA\", which stand for the choices of the question.\n*/\nconst char* answer_questions()", "sq": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n​    Përgjigju një serie pyetjesh duke ofruar zgjedhje A, B, C, ose D për secilën pyetje.\n​    Pyetja 1:\n​    Konstantet si 1e6 i përkasin cilit lloj të dhënash?\n​        A. unsigned int\n​        B. int\n​        C. float\n​        D. double\n​    Pyetja 2:\n​    Duke pasur parasysh 21! = 51,090,942,171,709,440,000, cili lloj i të dhënave mund të përdoret për të ruajtur këtë vlerë?\n​        A. int\n​        B. long long\n​        C. double\n​        D. Asnjë nga të mësipërmet\n​    Pyetja 3:\n​    Cila deklaratë në lidhje me vlerat e majta në shprehje është e pasaktë?\n​        A. Shprehjet e emrave të variablave janë vlera të majta.\n​        B. Operacioni i inkrementimit kërkon që operand të jetë një vlerë e majtë.\n​        C. Shprehjet e dereferencimit të treguesve janë vlera të majta.\n​        D. Shprehjet e operacionit të inkrementimit prefiks janë vlera të majta.\n​    Pyetja 4:\n​    Cila deklaratë në lidhje me funksionet është e pasaktë?\n​        A. Parametrat formalë të një funksioni janë variabla lokale.\n​        B. Variablat lokale kanë hapësirë të caktuar në stack.\n​        C. Lloji i funksionit është i njëjtë me llojin e vlerës së kthimit.\n​        D. Një funksion mund të thërrasë vetveten nga brenda trupit të tij.\n​    Pyetja 5:\n​    Cila deklaratë në lidhje me treguesit është e pasaktë?\n​        A. Zbritja e dy treguesve është e barabartë me ndryshimin në vlerat e adresave të tyre.\n​        B. Dereferencimi i treguesit përfshin zgjidhjen bazuar në llojin e treguesit.\n​        C. int *p[4], p është një varg treguesish int.\n​        D. Emrat e funksioneve mund të caktohen në tregues të funksioneve.\n\t>>> answer_questions()\n\tAAAAA\nTi supozohet të kthesh vetëm vargje të ngjashme me \"AAAAA\", të cilat përfaqësojnë zgjedhjet e pyetjes.\n*/\nconst char* answer_questions()", "hy": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n​    Պատասխանեք մի շարք հարցերի՝ յուրաքանչյուր հարցի համար տրամադրելով A, B, C կամ D ընտրանքները:\n​    Հարց 1:\n​    Նման հաստատունները, ինչպիսիք են 1e6-ը, որ տվյալների տիպին են պատկանում?\n​        A. unsigned int\n​        B. int\n​        C. float\n​        D. double\n​    Հարց 2:\n​    Տրված է 21! = 51,090,942,171,709,440,000, որ տվյալների տիպը կարող է օգտագործվել այս արժեքը պահելու համար?\n​        A. int\n​        B. long long\n​        C. double\n​        D. Վերը նշվածներից ոչ մեկը\n​    Հարց 3:\n​    Ո՞ր հայտարարությունը ձախ արժեքների մասին արտահայտություններում սխալ է:\n​        A. Փոփոխականի անվան արտահայտությունները ձախ արժեքներ են:\n​        B. Ինկրեմենտի գործողությունը պահանջում է, որ օպերանդը լինի ձախ արժեք:\n​        C. Ցուցիչի դերհղման արտահայտությունները ձախ արժեքներ են:\n​        D. Նախածանց ինկրեմենտի գործողության արտահայտությունները ձախ արժեքներ են:\n​    Հարց 4:\n​    Ո՞ր հայտարարությունը ֆունկցիաների մասին սխալ է:\n​        A. Ֆունկցիայի ֆորմալ պարամետրերը տեղական փոփոխականներ են:\n​        B. Տեղական փոփոխականների համար տարածքը հատկացվում է ստեկում:\n​        C. Ֆունկցիայի տիպը նույնն է, ինչ վերադարձվող արժեքի տիպը:\n​        D. Ֆունկցիան կարող է ինքն իրեն կանչել իր մարմնից:\n​    Հարց 5:\n​    Ո՞ր հայտարարությունը ցուցիչների մասին սխալ է:\n​        A. Երկու ցուցիչների հանումը հավասար է նրանց հասցեների արժեքների տարբերությանը:\n​        B. Ցուցիչի դերհղումը ներառում է լուծում՝ հիմնված ցուցիչի տիպի վրա:\n​        C. int *p[4], p-ն int ցուցիչների զանգված է:\n​        D. Ֆունկցիաների անունները կարող են վերագրվել ֆունկցիայի ցուցիչներին:\n\t>>> answer_questions()\n\tAAAAA\nԴուք պետք է վերադարձնեք միայն այնպիսի տողեր, ինչպիսիք են \"AAAAA\"-ն, որոնք ներկայացնում են հարցի ընտրանքները:\n*/\nconst char* answer_questions()", "bn": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n​    প্রতিটি প্রশ্নের জন্য A, B, C, বা D পছন্দ প্রদান করে প্রশ্নগুলির একটি সিরিজের উত্তর দিন।\n​    প্রশ্ন ১:\n​    1e6 এর মতো ধ্রুবক কোন ডেটা টাইপের অন্তর্গত?\n​        A. unsigned int\n​        B. int\n​        C. float\n​        D. double\n​    প্রশ্ন ২:\n​    প্রদত্ত 21! = 51,090,942,171,709,440,000, কোন ডেটা টাইপ এই মানটি সংরক্ষণ করতে ব্যবহার করা যেতে পারে?\n​        A. int\n​        B. long long\n​        C. double\n​        D. উপরোক্ত কোনোটিই নয়\n​    প্রশ্ন ৩:\n​    এক্সপ্রেশনে বাম মান সম্পর্কে কোন বিবৃতি ভুল?\n​        A. ভেরিয়েবল নাম এক্সপ্রেশনগুলি বাম মান।\n​        B. ইনক্রিমেন্ট অপারেশনটির জন্য অপারেন্ডটি একটি বাম মান হতে হবে।\n​        C. পয়েন্টার ডেরেফারেন্স এক্সপ্রেশনগুলি বাম মান।\n​        D. প্রিফিক্স ইনক্রিমেন্ট অপারেশন এক্সপ্রেশনগুলি বাম মান।\n​    প্রশ্ন ৪:\n​    ফাংশন সম্পর্কে কোন বিবৃতি ভুল?\n​        A. একটি ফাংশনের আনুষ্ঠানিক প্যারামিটারগুলি স্থানীয় ভেরিয়েবল।\n​        B. স্থানীয় ভেরিয়েবলগুলি স্ট্যাকে স্থান বরাদ্দ করা হয়।\n​        C. ফাংশনের টাইপ এবং রিটার্ন মানের টাইপ একই।\n​        D. একটি ফাংশন তার দেহের ভিতর থেকে নিজেকে কল করতে পারে।\n​    প্রশ্ন ৫:\n​    পয়েন্টার সম্পর্কে কোন বিবৃতি ভুল?\n​        A. দুটি পয়েন্টার বিয়োগ করলে তাদের ঠিকানা মানের পার্থক্য সমান হয়।\n​        B. পয়েন্টার ডেরেফারেন্স পয়েন্টারের টাইপের উপর ভিত্তি করে সমাধান করে।\n​        C. int *p[4], p একটি int পয়েন্টারের অ্যারে।\n​        D. ফাংশনের নামগুলি ফাংশন পয়েন্টারগুলিতে বরাদ্দ করা যেতে পারে।\n\t>>> answer_questions()\n\tAAAAA\nআপনার শুধুমাত্র \"AAAAA\" এর মতো স্ট্রিং ফেরত দেওয়ার কথা, যা প্রশ্নের পছন্দগুলির জন্য দাঁড়ায়।\n*/\nconst char* answer_questions()", "bg": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n​    Отговорете на серия от въпроси, като предоставите избори A, B, C или D за всеки въпрос.\n​    Въпрос 1:\n​    Константи като 1e6 принадлежат към кой тип данни?\n​        A. unsigned int\n​        B. int\n​        C. float\n​        D. double\n​    Въпрос 2:\n​    Дадено е 21! = 51,090,942,171,709,440,000, кой тип данни може да се използва за съхранение на тази стойност?\n​        A. int\n​        B. long long\n​        C. double\n​        D. Нито едно от горните\n​    Въпрос 3:\n​    Кое твърдение за левите стойности в изразите е неправилно?\n​        A. Изразите с имена на променливи са леви стойности.\n​        B. Операцията за инкрементиране изисква операндът да е лява стойност.\n​        C. Изразите за разименование на указатели са леви стойности.\n​        D. Изразите за префиксно инкрементиране са леви стойности.\n​    Въпрос 4:\n​    Кое твърдение за функциите е неправилно?\n​        A. Формалните параметри на функцията са локални променливи.\n​        B. Локалните променливи се разпределят в стека.\n​        C. Типът на функцията е същият като типа на стойността на връщане.\n​        D. Функцията може да извика себе си от тялото си.\n​    Въпрос 5:\n​    Кое твърдение за указателите е неправилно?\n​        A. Изваждането на два указателя е равно на разликата в техните адресни стойности.\n​        B. Разименованието на указател включва разрешаване на базата на типа на указателя.\n​        C. int *p[4], p е масив от указатели към int.\n​        D. Имената на функции могат да бъдат присвоени на указатели към функции.\n\t>>> answer_questions()\n\tAAAAA\nТрябва да върнете само низове, подобни на \"AAAAA\", които представляват изборите на въпросите.\n*/\nconst char* answer_questions()", "zh": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n​    通过为每个问题提供选择A、B、C或D来回答一系列问题。\n​    问题1：\n​    常量如1e6属于哪种数据类型？\n​        A. unsigned int\n​        B. int\n​        C. float\n​        D. double\n​    问题2：\n​    给定21! = 51,090,942,171,709,440,000，哪种数据类型可以用来存储这个值？\n​        A. int\n​        B. long long\n​        C. double\n​        D. 以上都不是\n​    问题3：\n​    关于表达式中的左值，哪种说法是不正确的？\n​        A. 变量名表达式是左值。\n​        B. 增量操作要求操作数是左值。\n​        C. 指针解引用表达式是左值。\n​        D. 前缀增量操作表达式是左值。\n​    问题4：\n​    关于函数，哪种说法是不正确的？\n​        A. 函数的形式参数是局部变量。\n​        B. 局部变量在栈中分配空间。\n​        C. 函数类型与返回值类型相同。\n​        D. 函数可以在其主体内调用自身。\n​    问题5：\n​    关于指针，哪种说法是不正确的？\n​        A. 减去两个指针等于它们地址值的差。\n​        B. 指针解引用涉及根据指针的类型进行解析。\n​        C. int *p[4]，p是一个int指针数组。\n​        D. 函数名可以赋值给函数指针。\n\t>>> answer_questions()\n\tAAAAA\n你应该只返回类似于\"AAAAA\"的字符串，代表问题的选择。\n*/\nconst char* answer_questions()", "fr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n​    Répondez à une série de questions en fournissant des choix A, B, C ou D pour chaque question.\n​    Question 1:\n​    Les constantes comme 1e6 appartiennent à quel type de données ?\n​        A. unsigned int\n​        B. int\n​        C. float\n​        D. double\n​    Question 2:\n​    Étant donné 21! = 51,090,942,171,709,440,000, quel type de données peut être utilisé pour stocker cette valeur ?\n​        A. int\n​        B. long long\n​        C. double\n​        D. Aucun des précédents\n​    Question 3:\n​    Quelle affirmation concernant les valeurs à gauche dans les expressions est incorrecte ?\n​        A. Les expressions de nom de variable sont des valeurs à gauche.\n​        B. L'opération d'incrément nécessite que l'opérande soit une valeur à gauche.\n​        C. Les expressions de déréférencement de pointeur sont des valeurs à gauche.\n​        D. Les expressions d'opération d'incrément préfixé sont des valeurs à gauche.\n​    Question 4:\n​    Quelle affirmation concernant les fonctions est incorrecte ?\n​        A. Les paramètres formels d'une fonction sont des variables locales.\n​        B. Les variables locales sont allouées dans la pile.\n​        C. Le type de la fonction est le même que le type de la valeur de retour.\n​        D. Une fonction peut s'appeler elle-même à l'intérieur de son corps.\n​    Question 5:\n​    Quelle affirmation concernant les pointeurs est incorrecte ?\n​        A. Soustraire deux pointeurs équivaut à la différence de leurs valeurs d'adresse.\n​        B. Le déréférencement de pointeur implique une résolution basée sur le type du pointeur.\n​        C. int *p[4], p est un tableau de pointeurs int.\n​        D. Les noms de fonctions peuvent être assignés à des pointeurs de fonction.\n\t>>> answer_questions()\n\tAAAAA\nVous êtes censé ne retourner que des chaînes similaires à \"AAAAA\", qui représentent les choix de la question.\n*/\nconst char* answer_questions()", "de": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n​    Beantworten Sie eine Reihe von Fragen, indem Sie für jede Frage die Auswahlmöglichkeiten A, B, C oder D angeben.\n​    Frage 1:\n​    Konstanten wie 1e6 gehören zu welchem Datentyp?\n​        A. unsigned int\n​        B. int\n​        C. float\n​        D. double\n​    Frage 2:\n​    Gegeben 21! = 51,090,942,171,709,440,000, welcher Datentyp kann verwendet werden, um diesen Wert zu speichern?\n​        A. int\n​        B. long long\n​        C. double\n​        D. Keine der oben genannten\n​    Frage 3:\n​    Welche Aussage über linke Werte in Ausdrücken ist falsch?\n​        A. Variablennamenausdrücke sind linke Werte.\n​        B. Der Inkrementoperator erfordert, dass der Operand ein linker Wert ist.\n​        C. Zeiger-Dereferenz-Ausdrücke sind linke Werte.\n​        D. Präfix-Inkrement-Ausdrucksoperationen sind linke Werte.\n​    Frage 4:\n​    Welche Aussage über Funktionen ist falsch?\n​        A. Formale Parameter einer Funktion sind lokale Variablen.\n​        B. Lokale Variablen werden im Stack Speicherplatz zugewiesen.\n​        C. Der Funktionstyp ist derselbe wie der Rückgabewerttyp.\n​        D. Eine Funktion kann sich selbst innerhalb ihres Körpers aufrufen.\n​    Frage 5:\n​    Welche Aussage über Zeiger ist falsch?\n​        A. Das Subtrahieren von zwei Zeigern entspricht der Differenz ihrer Adresswerte.\n​        B. Die Zeiger-Dereferenzierung beinhaltet das Auflösen basierend auf dem Typ des Zeigers.\n​        C. int *p[4], p ist ein Array von int-Zeigern.\n​        D. Funktionsnamen können Funktionszeigern zugewiesen werden.\n\t>>> answer_questions()\n\tAAAAA\nSie sollen nur Zeichenfolgen wie \"AAAAA\" zurückgeben, die für die Auswahlmöglichkeiten der Frage stehen.\n*/\nconst char* answer_questions()", "ha": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n​    Amsa jerin tambayoyi ta hanyar bayar da zaɓuɓɓuka A, B, C, ko D ga kowace tambaya.\n​    Tambaya ta 1:\n​    Kwatankwacin kamar 1e6 suna cikin wane nau'in bayanai?\n​        A. unsigned int\n​        B. int\n​        C. float\n​        D. double\n​    Tambaya ta 2:\n​    An ba da 21! = 51,090,942,171,709,440,000, wane nau'in bayanai za a iya amfani da shi don adana wannan ƙima?\n​        A. int\n​        B. long long\n​        C. double\n​        D. Babu ɗaya daga cikin waɗannan\n​    Tambaya ta 3:\n​    Wane bayani game da ƙimar hagu a cikin maganganu ba daidai ba ne?\n​        A. Maganganun sunayen masu canji ƙimar hagu ne.\n​        B. Aikin ƙara yana buƙatar mai aiki ya zama ƙimar hagu.\n​        C. Maganganun cire alamar mai nuna suna ƙimar hagu ne.\n​        D. Maganganun aikin ƙara na farko ƙimar hagu ne.\n​    Tambaya ta 4:\n​    Wane bayani game da ayyuka ba daidai ba ne?\n​        A. Ma'auni na yau da kullun na aiki masu canji ne na gida.\n​        B. Ana ware sarari don masu canji na gida a cikin tsari.\n​        C. Nau'in aikin yana daidai da nau'in ƙimar dawowa.\n​        D. Aiki na iya kiran kansa daga cikin jikinsa.\n​    Tambaya ta 5:\n​    Wane bayani game da masu nuna ba daidai ba ne?\n​        A. Cire masu nuna biyu yana daidai da bambancin a cikin ƙimar adireshinsu.\n​        B. Cire alamar mai nuna yana da alaƙa da nau'in mai nuna.\n​        C. int *p[4], p tsari ne na masu nuna int.\n​        D. Ana iya ba da sunayen ayyuka ga masu nuna ayyuka.\n\t>>> answer_questions()\n\tAAAAA\nAna tsammanin ka dawo da kirtani iri ɗaya da \"AAAAA\", wanda ke wakiltar zaɓuɓɓukan tambayoyin.\n*/\nconst char* answer_questions()", "hi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n​    प्रत्येक प्रश्न के लिए विकल्प A, B, C, या D प्रदान करके प्रश्नों की एक श्रृंखला का उत्तर दें।\n​    प्रश्न 1:\n​    1e6 जैसे स्थिरांक किस डेटा प्रकार से संबंधित हैं?\n​        A. unsigned int\n​        B. int\n​        C. float\n​        D. double\n​    प्रश्न 2:\n​    दिए गए 21! = 51,090,942,171,709,440,000, इस मान को संग्रहीत करने के लिए कौन सा डेटा प्रकार उपयोग किया जा सकता है?\n​        A. int\n​        B. long long\n​        C. double\n​        D. उपरोक्त में से कोई नहीं\n​    प्रश्न 3:\n​    अभिव्यक्तियों में बाएँ मानों के बारे में कौन सा कथन गलत है?\n​        A. वेरिएबल नाम अभिव्यक्तियाँ बाएँ मान हैं।\n​        B. वृद्धि ऑपरेशन के लिए ऑपरेन्ड का बाएँ मान होना आवश्यक है।\n​        C. पॉइंटर डिरेफरेंस अभिव्यक्तियाँ बाएँ मान हैं।\n​        D. उपसर्ग वृद्धि ऑपरेशन अभिव्यक्तियाँ बाएँ मान हैं।\n​    प्रश्न 4:\n​    कार्यों के बारे में कौन सा कथन गलत है?\n​        A. एक फ़ंक्शन के औपचारिक पैरामीटर स्थानीय वेरिएबल होते हैं।\n​        B. स्थानीय वेरिएबल स्टैक में स्थान आवंटित किए जाते हैं।\n​        C. फ़ंक्शन प्रकार वही है जो रिटर्न मान प्रकार है।\n​        D. एक फ़ंक्शन अपने शरीर के भीतर से स्वयं को कॉल कर सकता है।\n​    प्रश्न 5:\n​    पॉइंटर्स के बारे में कौन सा कथन गलत है?\n​        A. दो पॉइंटर्स को घटाने से उनके पते के मानों का अंतर मिलता है।\n​        B. पॉइंटर डिरेफरेंस में पॉइंटर के प्रकार के आधार पर समाधान शामिल होता है।\n​        C. int *p[4], p इंट पॉइंटर्स की एक सरणी है।\n​        D. फ़ंक्शन नामों को फ़ंक्शन पॉइंटर्स को सौंपा जा सकता है।\n\t>>> answer_questions()\n\tAAAAA\nआपको केवल \"AAAAA\" जैसे स्ट्रिंग्स लौटाने हैं, जो प्रश्न के विकल्पों के लिए खड़े होते हैं।\n*/\nconst char* answer_questions()", "hu": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n​    Válaszolj egy sor kérdésre az A, B, C vagy D választási lehetőségek megadásával minden kérdésre.\n​    1. kérdés:\n​    Az olyan konstansok, mint az 1e6, melyik adattípushoz tartoznak?\n​        A. unsigned int\n​        B. int\n​        C. float\n​        D. double\n​    2. kérdés:\n​    Adott 21! = 51,090,942,171,709,440,000, melyik adattípussal tárolható ez az érték?\n​        A. int\n​        B. long long\n​        C. double\n​        D. Egyik sem a fentiek közül\n​    3. kérdés:\n​    Melyik állítás helytelen a baloldali értékekről a kifejezésekben?\n​        A. A változónév kifejezések baloldali értékek.\n​        B. Az inkrementáló művelet megköveteli, hogy az operandus baloldali érték legyen.\n​        C. A pointer dereferálás kifejezések baloldali értékek.\n​        D. A prefix inkrementáló művelet kifejezések baloldali értékek.\n​    4. kérdés:\n​    Melyik állítás helytelen a függvényekről?\n​        A. A függvény formális paraméterei lokális változók.\n​        B. A lokális változók a veremben kapnak helyet.\n​        C. A függvény típusa megegyezik a visszatérési érték típusával.\n​        D. Egy függvény meghívhatja önmagát a saját törzsén belül.\n​    5. kérdés:\n​    Melyik állítás helytelen a pointerekről?\n​        A. Két pointer kivonása egyenlő a címértékeik különbségével.\n​        B. A pointer dereferálás a pointer típusának alapján történik.\n​        C. int *p[4], p egy int pointerek tömbje.\n​        D. A függvénynevek hozzárendelhetők függvénypointerekhez.\n\t>>> answer_questions()\n\tAAAAA\nCsak olyan karakterláncokat kell visszaadnod, mint az \"AAAAA\", amelyek a kérdések választásait jelentik.\n*/\nconst char* answer_questions()", "es": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n​    Responder a una serie de preguntas proporcionando opciones A, B, C o D para cada pregunta.\n​    Pregunta 1:\n​    ¿A qué tipo de datos pertenecen las constantes como 1e6?\n​        A. unsigned int\n​        B. int\n​        C. float\n​        D. double\n​    Pregunta 2:\n​    Dado 21! = 51,090,942,171,709,440,000, ¿qué tipo de datos se puede usar para almacenar este valor?\n​        A. int\n​        B. long long\n​        C. double\n​        D. Ninguna de las anteriores\n​    Pregunta 3:\n​    ¿Qué afirmación sobre los valores a la izquierda en las expresiones es incorrecta?\n​        A. Las expresiones de nombres de variables son valores a la izquierda.\n​        B. La operación de incremento requiere que el operando sea un valor a la izquierda.\n​        C. Las expresiones de desreferencia de punteros son valores a la izquierda.\n​        D. Las expresiones de operación de incremento prefijo son valores a la izquierda.\n​    Pregunta 4:\n​    ¿Qué afirmación sobre las funciones es incorrecta?\n​        A. Los parámetros formales de una función son variables locales.\n​        B. Las variables locales se asignan espacio en la pila.\n​        C. El tipo de la función es el mismo que el tipo de valor de retorno.\n​        D. Una función puede llamarse a sí misma desde dentro de su cuerpo.\n​    Pregunta 5:\n​    ¿Qué afirmación sobre los punteros es incorrecta?\n​        A. Restar dos punteros equivale a la diferencia en sus valores de dirección.\n​        B. La desreferencia de puntero implica resolver en función del tipo del puntero.\n​        C. int *p[4], p es un arreglo de punteros a int.\n​        D. Los nombres de funciones se pueden asignar a punteros de funciones.\n\t>>> answer_questions()\n\tAAAAA\nSe supone que solo debes devolver cadenas similares a \"AAAAA\", que representan las opciones de la pregunta.\n*/\nconst char* answer_questions()", "arb": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n​    أجب عن سلسلة من الأسئلة بتقديم الخيارات A، B، C، أو D لكل سؤال.\n​    السؤال 1:\n​    الثوابت مثل 1e6 تنتمي إلى أي نوع من البيانات؟\n​        A. unsigned int\n​        B. int\n​        C. float\n​        D. double\n​    السؤال 2:\n​    بالنظر إلى 21! = 51,090,942,171,709,440,000، أي نوع من البيانات يمكن استخدامه لتخزين هذه القيمة؟\n​        A. int\n​        B. long long\n​        C. double\n​        D. لا شيء مما سبق\n​    السؤال 3:\n​    أي عبارة عن القيم اليسرى في التعبيرات غير صحيحة؟\n​        A. تعبيرات أسماء المتغيرات هي قيم يسرى.\n​        B. عملية الزيادة تتطلب أن يكون المعامل قيمة يسرى.\n​        C. تعبيرات إلغاء الإشارة للمؤشر هي قيم يسرى.\n​        D. تعبيرات عملية الزيادة المسبقة هي قيم يسرى.\n​    السؤال 4:\n​    أي عبارة عن الدوال غير صحيحة؟\n​        A. المعاملات الشكلية للدالة هي متغيرات محلية.\n​        B. يتم تخصيص مساحة للمتغيرات المحلية في المكدس.\n​        C. نوع الدالة هو نفسه نوع قيمة الإرجاع.\n​        D. يمكن للدالة أن تستدعي نفسها من داخل جسمها.\n​    السؤال 5:\n​    أي عبارة عن المؤشرات غير صحيحة؟\n​        A. طرح مؤشرين يساوي الفرق في قيم عناوينهما.\n​        B. إلغاء إشارة المؤشر يتضمن الحل بناءً على نوع المؤشر.\n​        C. int *p[4]، p هو مصفوفة من مؤشرات int.\n​        D. يمكن تعيين أسماء الدوال إلى مؤشرات الدوال.\n\t>>> answer_questions()\n\tAAAAA\nمن المفترض أن تعيد فقط سلاسل مشابهة لـ \"AAAAA\"، والتي تمثل اختيارات السؤال.\n*/\nconst char* answer_questions()", "sw": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n​    Jibu mfululizo wa maswali kwa kutoa chaguo A, B, C, au D kwa kila swali.\n​    Swali la 1:\n​    Vigezo kama 1e6 vinatoka kwa aina gani ya data?\n​        A. unsigned int\n​        B. int\n​        C. float\n​        D. double\n​    Swali la 2:\n​    Ikitolewa 21! = 51,090,942,171,709,440,000, ni aina gani ya data inaweza kutumika kuhifadhi thamani hii?\n​        A. int\n​        B. long long\n​        C. double\n​        D. Hakuna kati ya hapo juu\n​    Swali la 3:\n​    Ni kauli gani kuhusu thamani za kushoto katika maelezo si sahihi?\n​        A. Maelezo ya jina la kigezo ni thamani za kushoto.\n​        B. Operesheni ya kuongeza inahitaji operand kuwa thamani ya kushoto.\n​        C. Maelezo ya kufuta pointer ni thamani za kushoto.\n​        D. Maelezo ya operesheni ya kuongeza awali ni thamani za kushoto.\n​    Swali la 4:\n​    Ni kauli gani kuhusu kazi si sahihi?\n​        A. Vigezo rasmi vya kazi ni vigezo vya ndani.\n​        B. Vigezo vya ndani vinapewa nafasi katika stack.\n​        C. Aina ya kazi ni sawa na aina ya thamani ya kurudi.\n​        D. Kazi inaweza kujirejelea yenyewe kutoka ndani ya mwili wake.\n​    Swali la 5:\n​    Ni kauli gani kuhusu pointers si sahihi?\n​        A. Kutoa tofauti ya anwani za pointers mbili ni sawa na kutoa tofauti katika thamani zao za anwani.\n​        B. Kufuta pointer kunahusisha kutatua kulingana na aina ya pointer.\n​        C. int *p[4], p ni safu ya pointers za int.\n​        D. Majina ya kazi yanaweza kupewa pointers za kazi.\n\t>>> answer_questions()\n\tAAAAA\nUnatakiwa kurudisha tu misururu inayofanana na \"AAAAA\", ambayo inawakilisha chaguo za swali.\n*/\nconst char* answer_questions()", "tr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n​    Her bir soru için A, B, C veya D seçeneklerini sağlayarak bir dizi soruyu yanıtlayın.\n​    Soru 1:\n​    1e6 gibi sabitler hangi veri türüne aittir?\n​        A. unsigned int\n​        B. int\n​        C. float\n​        D. double\n​    Soru 2:\n​    21! = 51,090,942,171,709,440,000 verildiğinde, bu değeri saklamak için hangi veri türü kullanılabilir?\n​        A. int\n​        B. long long\n​        C. double\n​        D. Yukarıdakilerin hiçbiri\n​    Soru 3:\n​    İfadelerdeki sol değerler hakkında hangi ifade yanlıştır?\n​        A. Değişken adı ifadeleri sol değerlerdir.\n​        B. Artırma işlemi, operandın bir sol değer olmasını gerektirir.\n​        C. İşaretçi dereference ifadeleri sol değerlerdir.\n​        D. Ön ek artırma işlemi ifadeleri sol değerlerdir.\n​    Soru 4:\n​    Fonksiyonlar hakkında hangi ifade yanlıştır?\n​        A. Bir fonksiyonun resmi parametreleri yerel değişkenlerdir.\n​        B. Yerel değişkenler yığın içinde alan tahsis edilir.\n​        C. Fonksiyon türü, dönüş değeri türü ile aynıdır.\n​        D. Bir fonksiyon kendi gövdesinden kendisini çağırabilir.\n​    Soru 5:\n​    İşaretçiler hakkında hangi ifade yanlıştır?\n​        A. İki işaretçinin çıkarılması, adres değerlerindeki farkı eşittir.\n​        B. İşaretçi dereference, işaretçinin türüne göre çözümlemeyi içerir.\n​        C. int *p[4], p bir int işaretçi dizisidir.\n​        D. Fonksiyon adları, fonksiyon işaretçilerine atanabilir.\n\t>>> answer_questions()\n\tAAAAA\nSadece soruların seçeneklerini temsil eden \"AAAAA\" gibi dizeleri döndürmeniz gerekiyor.\n*/\nconst char* answer_questions()", "vi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n    Trả lời một loạt câu hỏi bằng cách cung cấp lựa chọn A, B, C, hoặc D cho mỗi câu hỏi.\n    Câu hỏi 1:\n    Hằng số như 1e6 thuộc kiểu dữ liệu nào?\n        A. unsigned int\n        B. int\n        C. float\n        D. double\n    Câu hỏi 2:\n    Cho 21! = 51,090,942,171,709,440,000, kiểu dữ liệu nào có thể được sử dụng để lưu trữ giá trị này?\n        A. int\n        B. long long\n        C. double\n        D. Không có cái nào ở trên\n    Câu hỏi 3:\n    Câu nào về giá trị bên trái trong biểu thức là không đúng?\n        A. Biểu thức tên biến là giá trị bên trái.\n        B. Phép toán tăng yêu cầu toán hạng phải là giá trị bên trái.\n        C. Biểu thức giải tham chiếu con trỏ là giá trị bên trái.\n        D. Biểu thức phép toán tăng tiền tố là giá trị bên trái.\n    Câu hỏi 4:\n    Câu nào về hàm là không đúng?\n        A. Tham số hình thức của một hàm là biến cục bộ.\n        B. Biến cục bộ được cấp phát không gian trong ngăn xếp.\n        C. Kiểu hàm giống với kiểu giá trị trả về.\n        D. Một hàm có thể gọi chính nó từ bên trong thân hàm.\n    Câu hỏi 5:\n    Câu nào về con trỏ là không đúng?\n        A. Trừ hai con trỏ bằng với sự khác biệt trong giá trị địa chỉ của chúng.\n        B. Giải tham chiếu con trỏ liên quan đến việc giải quyết dựa trên kiểu của con trỏ.\n        C. int *p[4], p là một mảng các con trỏ int.\n        D. Tên hàm có thể được gán cho con trỏ hàm.\n    >>> answer_questions()\n    AAAAA\nBạn chỉ cần trả về các chuỗi tương tự như \"AAAAA\", đại diện cho các lựa chọn của câu hỏi.\n*/\nconst char* answer_questions()", "id": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n​    Jawab serangkaian pertanyaan dengan memberikan pilihan A, B, C, atau D untuk setiap pertanyaan.\n​    Pertanyaan 1:\n​    Konstanta seperti 1e6 termasuk ke dalam tipe data apa?\n​        A. unsigned int\n​        B. int\n​        C. float\n​        D. double\n​    Pertanyaan 2:\n​    Diketahui 21! = 51,090,942,171,709,440,000, tipe data apa yang dapat digunakan untuk menyimpan nilai ini?\n​        A. int\n​        B. long long\n​        C. double\n​        D. Tidak ada dari yang di atas\n​    Pertanyaan 3:\n​    Pernyataan mana tentang nilai kiri dalam ekspresi yang salah?\n​        A. Ekspresi nama variabel adalah nilai kiri.\n​        B. Operasi inkremen memerlukan operan menjadi nilai kiri.\n​        C. Ekspresi dereferensi pointer adalah nilai kiri.\n​        D. Ekspresi operasi inkremen prefix adalah nilai kiri.\n​    Pertanyaan 4:\n​    Pernyataan mana tentang fungsi yang salah?\n​        A. Parameter formal dari sebuah fungsi adalah variabel lokal.\n​        B. Variabel lokal dialokasikan ruang di stack.\n​        C. Tipe fungsi sama dengan tipe nilai kembalian.\n​        D. Sebuah fungsi dapat memanggil dirinya sendiri dari dalam tubuhnya.\n​    Pertanyaan 5:\n​    Pernyataan mana tentang pointer yang salah?\n​        A. Mengurangkan dua pointer sama dengan selisih dalam nilai alamat mereka.\n​        B. Dereferensi pointer melibatkan penyelesaian berdasarkan tipe pointer.\n​        C. int *p[4], p adalah array dari pointer int.\n​        D. Nama fungsi dapat ditetapkan ke pointer fungsi.\n\t>>> answer_questions()\n\tAAAAA\nAnda seharusnya hanya mengembalikan string yang mirip dengan \"AAAAA\", yang mewakili pilihan dari pertanyaan.\n*/\nconst char* answer_questions()\n", "ja": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n​    各質問に対して選択肢 A、B、C、または D を提供して一連の質問に答えてください。\n​    質問1:\n​    1e6 のような定数はどのデータ型に属しますか？\n​        A. unsigned int\n​        B. int\n​        C. float\n​        D. double\n​    質問2:\n​    21! = 51,090,942,171,709,440,000 が与えられた場合、この値を格納するために使用できるデータ型はどれですか？\n​        A. int\n​        B. long long\n​        C. double\n​        D. 上記のいずれでもない\n​    質問3:\n​    式の左辺値に関する記述のうち、誤っているものはどれですか？\n​        A. 変数名の式は左辺値です。\n​        B. インクリメント操作にはオペランドが左辺値であることが必要です。\n​        C. ポインタのデリファレンス式は左辺値です。\n​        D. プレフィックスインクリメント操作の式は左辺値です。\n​    質問4:\n​    関数に関する記述のうち、誤っているものはどれですか？\n​        A. 関数の仮引数はローカル変数です。\n​        B. ローカル変数はスタックにスペースが割り当てられます。\n​        C. 関数の型は戻り値の型と同じです。\n​        D. 関数はその本体から自分自身を呼び出すことができます。\n​    質問5:\n​    ポインタに関する記述のうち、誤っているものはどれですか？\n​        A. 2つのポインタを引くと、それらのアドレス値の差になります。\n​        B. ポインタのデリファレンスはポインタの型に基づいて解決されます。\n​        C. int *p[4], p は int ポインタの配列です。\n​        D. 関数名は関数ポインタに代入できます。\n\t>>> answer_questions()\n\tAAAAA\n質問の選択肢を表す \"AAAAA\" のような文字列を返すだけです。\n*/\nconst char* answer_questions()", "ko": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n​    각 질문에 대해 선택지 A, B, C, 또는 D를 제공하여 일련의 질문에 답하십시오.\n​    질문 1:\n​    1e6과 같은 상수는 어떤 데이터 유형에 속합니까?\n​        A. unsigned int\n​        B. int\n​        C. float\n​        D. double\n​    질문 2:\n​    21! = 51,090,942,171,709,440,000이 주어졌을 때, 이 값을 저장할 수 있는 데이터 유형은 무엇입니까?\n​        A. int\n​        B. long long\n​        C. double\n​        D. 위의 것들 중 어느 것도 아님\n​    질문 3:\n​    표현식의 왼쪽 값에 대한 설명 중 틀린 것은 무엇입니까?\n​        A. 변수 이름 표현식은 왼쪽 값입니다.\n​        B. 증가 연산은 피연산자가 왼쪽 값이어야 합니다.\n​        C. 포인터 역참조 표현식은 왼쪽 값입니다.\n​        D. 접두사 증가 연산 표현식은 왼쪽 값입니다.\n​    질문 4:\n​    함수에 대한 설명 중 틀린 것은 무엇입니까?\n​        A. 함수의 형식 매개변수는 지역 변수입니다.\n​        B. 지역 변수는 스택에 공간이 할당됩니다.\n​        C. 함수 유형은 반환 값 유형과 동일합니다.\n​        D. 함수는 본문 내에서 자신을 호출할 수 있습니다.\n​    질문 5:\n​    포인터에 대한 설명 중 틀린 것은 무엇입니까?\n​        A. 두 포인터를 빼면 주소 값의 차이가 됩니다.\n​        B. 포인터 역참조는 포인터의 유형에 따라 해석됩니다.\n​        C. int *p[4], p는 int 포인터 배열입니다.\n​        D. 함수 이름은 함수 포인터에 할당할 수 있습니다.\n\t>>> answer_questions()\n\tAAAAA\n당신은 질문의 선택지를 나타내는 \"AAAAA\"와 유사한 문자열만 반환해야 합니다.\n*/\nconst char* answer_questions()\n", "ml": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n​    ഓരോ ചോദ്യത്തിനും A, B, C, അല്ലെങ്കിൽ D എന്നിങ്ങനെ തിരഞ്ഞെടുക്കലുകൾ നൽകിക്കൊണ്ട് ചോദ്യങ്ങളുടെ ഒരു പരമ്പരയ്ക്ക് ഉത്തരം നൽകുക.\n​    ചോദ്യം 1:\n​    1e6 പോലുള്ള സ്ഥിരാങ്കങ്ങൾ ഏത് ഡാറ്റാ തരം ആണു പെട്ടത്?\n​        A. unsigned int\n​        B. int\n​        C. float\n​        D. double\n​    ചോദ്യം 2:\n​    21! = 51,090,942,171,709,440,000 എന്നത് നൽകിയാൽ, ഈ മൂല്യം സംഭരിക്കാൻ ഏത് ഡാറ്റാ തരം ഉപയോഗിക്കാം?\n​        A. int\n​        B. long long\n​        C. double\n​        D. മുകളിൽ പറയുന്നവയൊന്നുമല്ല\n​    ചോദ്യം 3:\n​    വ്യാകരണങ്ങളിൽ ഇടത് മൂല്യങ്ങളെക്കുറിച്ചുള്ള ഏത് പ്രസ്താവന തെറ്റാണ്?\n​        A. ചൊല്ലിന്റെ പേരിന്റെ വ്യാകരണങ്ങൾ ഇടത് മൂല്യങ്ങളാണ്.\n​        B. വർദ്ധന പ്രവർത്തനം ഇടത് മൂല്യമായ ഓപ്പറാൻഡിനെ ആവശ്യപ്പെടുന്നു.\n​        C. സൂചിക ഡിറഫറൻസ് വ്യാകരണങ്ങൾ ഇടത് മൂല്യങ്ങളാണ്.\n​        D. പ്രിഫിക്സ് വർദ്ധന പ്രവർത്തന വ്യാകരണങ്ങൾ ഇടത് മൂല്യങ്ങളാണ്.\n​    ചോദ്യം 4:\n​    ഫംഗ്ഷനുകളെക്കുറിച്ചുള്ള ഏത് പ്രസ്താവന തെറ്റാണ്?\n​        A. ഒരു ഫംഗ്ഷന്റെ ഔപചാരിക പാരാമീറ്ററുകൾ പ്രാദേശിക ചൊല്ലുകളാണ്.\n​        B. പ്രാദേശിക ചൊല്ലുകൾ സ്റ്റാക്കിൽ സ്ഥലം അനുവദിക്കുന്നു.\n​        C. ഫംഗ്ഷൻ തരം മടക്ക മൂല്യ തരം പോലെയാണ്.\n​        D. ഒരു ഫംഗ്ഷൻ അതിന്റെ ശരീരത്തിനുള്ളിൽ നിന്ന് തന്നെ വിളിക്കാം.\n​    ചോദ്യം 5:\n​    സൂചികകളെക്കുറിച്ചുള്ള ഏത് പ്രസ്താവന തെറ്റാണ്?\n​        A. രണ്ട് സൂചികകൾ കുറയ്ക്കുന്നത് അവരുടെ വിലാസ മൂല്യങ്ങളിലെ വ്യത്യാസത്തിനെ തുല്യമാണ്.\n​        B. സൂചിക ഡിറഫറൻസ് സൂചികയുടെ തരം അടിസ്ഥാനമാക്കി പരിഹരിക്കുന്നതാണ്.\n​        C. int *p[4], p ഒരു int സൂചികകളുടെ നിരയാണ്.\n​        D. ഫംഗ്ഷൻ പേരുകൾ ഫംഗ്ഷൻ സൂചികകൾക്ക് നിയോഗിക്കാം.\n\t>>> answer_questions()\n\tAAAAA\nനിങ്ങൾ \"AAAAA\" പോലുള്ള സ്ട്രിംഗുകൾ മാത്രം മടക്കേണ്ടതാണ്, ഇത് ചോദ്യത്തിന്റെ തിരഞ്ഞെടുക്കലുകൾക്കു വേണ്ടി നിൽക്കുന്നു.\n*/\nconst char* answer_questions()\n", "fa": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n​    به یک سری سوال با ارائه گزینه‌های A، B، C، یا D برای هر سوال پاسخ دهید.\n​    سوال 1:\n​    ثابت‌هایی مانند 1e6 به کدام نوع داده تعلق دارند؟\n​        A. unsigned int\n​        B. int\n​        C. float\n​        D. double\n​    سوال 2:\n​    با توجه به 21! = 51,090,942,171,709,440,000، از کدام نوع داده می‌توان برای ذخیره این مقدار استفاده کرد؟\n​        A. int\n​        B. long long\n​        C. double\n​        D. هیچ‌کدام از موارد بالا\n​    سوال 3:\n​    کدام عبارت درباره مقادیر چپ در عبارات نادرست است؟\n​        A. عبارات نام متغیر مقادیر چپ هستند.\n​        B. عملیات افزایش نیاز دارد که عملوند یک مقدار چپ باشد.\n​        C. عبارات اشاره‌گر به مقادیر چپ هستند.\n​        D. عبارات عملیات افزایش پیشوندی مقادیر چپ هستند.\n​    سوال 4:\n​    کدام عبارت درباره توابع نادرست است؟\n​        A. پارامترهای رسمی یک تابع متغیرهای محلی هستند.\n​        B. متغیرهای محلی در پشته فضا اختصاص داده می‌شوند.\n​        C. نوع تابع همان نوع مقدار بازگشتی است.\n​        D. یک تابع می‌تواند خود را از درون بدنه‌اش فراخوانی کند.\n​    سوال 5:\n​    کدام عبارت درباره اشاره‌گرها نادرست است؟\n​        A. تفریق دو اشاره‌گر برابر با تفاوت در مقادیر آدرس آن‌ها است.\n​        B. اشاره‌گر به نوع اشاره‌گر برای حل نیاز دارد.\n​        C. int *p[4]، p یک آرایه از اشاره‌گرهای int است.\n​        D. نام‌های تابع می‌توانند به اشاره‌گرهای تابع اختصاص داده شوند.\n\t>>> answer_questions()\n\tAAAAA\nشما باید فقط رشته‌هایی مشابه \"AAAAA\" را برگردانید، که نشان‌دهنده انتخاب‌های سوال هستند.\n*/\nconst char* answer_questions()\n"}, "canonical_solution": "{\n    return \"DDDBA\";\n}", "instruction": {"en": "const char* answer_questions()\n{\n    return \"DDDBA\";\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "sq": "const char* answer_questions()\n{\n    return \"DDDBA\";\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C në shqip duke përdorur maksimumi 500 karaktere.", "hy": "const char* answer_questions()\n{\n    return \"DDDBA\";\n}\n\nՏվեք C կոդի հակիրճ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "const char* answer_questions()\n{\n    return \"DDDBA\";\n}\n\nসি কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলা ভাষায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।", "bg": "const char* answer_questions()\n{\n    return \"DDDBA\";\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, използвайки не повече от 500 знака.", "zh": "const char* answer_questions()\n{\n    return \"DDDBA\";\n}\n\n请用最多500个字符的中文对该C代码提供简洁的自然语言描述（文档字符串）。", "fr": "const char* answer_questions()\n{\n    return \"DDDBA\";\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.", "de": "const char* answer_questions()\n{\n    return \"DDDBA\";\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "const char* answer_questions()\n{\n    return \"DDDBA\";\n}\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar C a cikin Hausa ta amfani da haruffa 500 kacal.", "hi": "const char* answer_questions()\n{\n    return \"DDDBA\";\n}\n\nदिए गए C कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "const char* answer_questions()\n{\n    return \"DDDBA\";\n}\n\nAdj meg egy tömör, legfeljebb 500 karakteres természetes nyelvű leírást (docstring) a C kódról magyarul.", "es": "const char* answer_questions()\n{\n    return \"DDDBA\";\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando como máximo 500 caracteres.", "arb": "const char* answer_questions()\n{\n    return \"DDDBA\";\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.", "sw": "const char* answer_questions()\n{\n    return \"DDDBA\";\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "const char* answer_questions()\n{\n    return \"DDDBA\";\n}\n\nAşağıdaki C kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda, özlü bir doğal dil açıklaması (docstring) sağlayın.", "vi": "const char* answer_questions()\n{\n    return \"DDDBA\";\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã C bằng tiếng Việt, sử dụng tối đa 500 ký tự.", "id": "const char* answer_questions()\n{\n    return \"DDDBA\";\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode C dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "const char* answer_questions()\n{\n    return \"DDDBA\";\n}\n\nC コードの簡単な自然言語による説明 (docstring) を英語で最大 500 文字まで入力してください。", "ko": "const char* answer_questions()\n{\n    return \"DDDBA\";\n}\n\nC 코드에 대한 간결한 자연어 설명(도크스트링)을 최대 500자 이내로 한국어로 제공하세요.", "ml": "const char* answer_questions()\n{\n    return \"DDDBA\";\n}\n\nC കോഡ് ഉപയോഗിച്ച് 500 അക്ഷരങ്ങളിൽ കൂടുതൽ അല്ലാത്ത ഒരു സംക്ഷിപ്ത സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) മലയാളത്തിൽ നൽകുക.", "fa": "const char* answer_questions()\n{\n    return \"DDDBA\";\n}\n\nتوضیح مختصر و طبیعی (docstring) از کد C به زبان فارسی ارائه دهید که حداکثر ۵۰۰ کاراکتر باشد."}, "level": "", "test": "int main() {\n    // The assert should compare strings, not literals or enums, using strcmp\n    const char* expected_answers = \"DDDBA\";\n    assert(strcmp(answer_questions(), expected_answers) == 0);\n    \n    return 0;\n}", "entry_point": "answer_questions", "signature": "const char* answer_questions()", "docstring": {"en": "Answer a series of questions by providing choices A, B, C, or D for each question.\n\nQuestion 1:\nConstants like 1e6 belong to which data type?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nQuestion 2:\nGiven 21! = 51,090,942,171,709,440,000, which data type can be used to store this value?\n    A. int\n    B. long long\n    C. double\n    D. None of the above\n\nQuestion 3:\nWhich statement about left values in expressions is incorrect?\n    A. Variable name expressions are left values.\n    B. Increment operation requires the operand to be a left value.\n    C. Pointer dereference expressions are left values.\n    D. Prefix increment operation expressions are left values.\n\nQuestion 4:\nWhich statement about functions is incorrect?\n    A. Formal parameters of a function are local variables.\n    B. Local variables are allocated space in the stack.\n    C. The function type is the same as the return value type.\n    D. A function can call itself from within its body.\n\nQuestion 5:\nWhich statement about pointers is incorrect?\n    A. Subtracting two pointers equals the difference in their address values.\n    B. Pointer dereference involves resolving based on the pointer's type.\n    C. int *p[4], p is an array of int pointers.\n    D. Function names can be assigned to function pointers.\n\n>>> answer_questions()\nAAAAA\nYou're supposed to only return strings similar to \"AAAAA\", which stand for the choices of the question.", "sq": "Përgjigjuni një serie pyetjesh duke dhënë zgjedhjet A, B, C, ose D për secilën pyetje.\n\nPyetja 1:\nKonstantet si 1e6 i përkasin cilit tip të dhënash?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nPyetja 2:\nDuke pasur parasysh 21! = 51,090,942,171,709,440,000, cili tip i të dhënave mund të përdoret për të ruajtur këtë vlerë?\n    A. int\n    B. long long\n    C. double\n    D. Asnjë nga më sipër\n\nPyetja 3:\nCila deklaratë për vlerat e majta në shprehje është e pasaktë?\n    A. Shprehjet e emrave të variablave janë vlera të majta.\n    B. Operacioni i inkrementimit kërkon që operand të jetë një vlerë e majtë.\n    C. Shprehjet e dereferencimit të treguesve janë vlera të majta.\n    D. Shprehjet e operacionit të inkrementimit prefiks janë vlera të majta.\n\nPyetja 4:\nCila deklaratë për funksionet është e pasaktë?\n    A. Parametrat formalë të një funksioni janë variabla lokale.\n    B. Variablat lokale alokohen hapësirë në stack.\n    C. Tipi i funksionit është i njëjtë me tipin e vlerës së kthimit.\n    D. Një funksion mund të thërrasë vetveten nga brenda trupit të tij.\n\nPyetja 5:\nCila deklaratë për treguesit është e pasaktë?\n    A. Zbritja e dy treguesve është e barabartë me diferencën në vlerat e adresave të tyre.\n    B. Dereferencimi i treguesit përfshin zgjidhjen bazuar në tipin e treguesit.\n    C. int *p[4], p është një varg i treguesve int.\n    D. Emrat e funksioneve mund t'u caktohen treguesve të funksioneve.\n\n>>> answer_questions()\nAAAAA\nJu duhet të ktheni vetëm vargje të ngjashme me \"AAAAA\", të cilat përfaqësojnë zgjedhjet e pyetjes.", "hy": "Պատասխանեք մի շարք հարցերի՝ յուրաքանչյուր հարցի համար տրամադրելով ընտրանքներ A, B, C կամ D:\n\nՀարց 1:\nՆման 1e6 հաստատունները որ տվյալների տիպին են պատկանում?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nՀարց 2:\nՀաշվի առնելով 21! = 51,090,942,171,709,440,000, որ տվյալների տիպը կարող է օգտագործվել այս արժեքը պահելու համար?\n    A. int\n    B. long long\n    C. double\n    D. Վերոնշյալներից ոչ մեկը\n\nՀարց 3:\nՈր հայտարարությունը ձախ արժեքների վերաբերյալ արտահայտություններում սխալ է?\n    A. Փոփոխականի անվան արտահայտությունները ձախ արժեքներ են:\n    B. Ինկրեմենտի գործողությունը պահանջում է, որ օպերանդը լինի ձախ արժեք:\n    C. Ցուցիչի ապահանել արտահայտությունները ձախ արժեքներ են:\n    D. Նախածանց ինկրեմենտի գործողության արտահայտությունները ձախ արժեքներ են:\n\nՀարց 4:\nՈր հայտարարությունը ֆունկցիաների վերաբերյալ սխալ է?\n    A. Ֆունկցիայի ֆորմալ պարամետրերը տեղական փոփոխականներ են:\n    B. Տեղական փոփոխականները հատկացվում են կույտում:\n    C. Ֆունկցիայի տիպը նույնն է, ինչ վերադարձվող արժեքի տիպը:\n    D. Ֆունկցիան կարող է ինքն իրեն կանչել իր մարմնից:\n\nՀարց 5:\nՈր հայտարարությունը ցուցիչների վերաբերյալ սխալ է?\n    A. Երկու ցուցիչների հանումը հավասար է նրանց հասցեների արժեքների տարբերությանը:\n    B. Ցուցիչի ապահանումը ներառում է լուծում ցուցիչի տիպի հիման վրա:\n    C. int *p[4], p-ն int ցուցիչների զանգված է:\n    D. Ֆունկցիաների անունները կարող են նշանակվել ֆունկցիայի ցուցիչներին:\n\n>>> answer_questions()\nAAAAA\nԴուք պետք է վերադարձնեք միայն այնպիսի տողեր, ինչպիսիք են \"AAAAA\", որոնք ներկայացնում են հարցի ընտրանքները:", "bn": "প্রশ্নগুলির একটি সিরিজের উত্তর দিন প্রতিটি প্রশ্নের জন্য পছন্দগুলি A, B, C, বা D প্রদান করে।\n\nপ্রশ্ন ১:\n1e6 এর মতো ধ্রুবকগুলি কোন ডেটা টাইপের অন্তর্গত?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nপ্রশ্ন ২:\nযদি 21! = 51,090,942,171,709,440,000 হয়, তাহলে কোন ডেটা টাইপটি এই মানটি সংরক্ষণ করতে ব্যবহার করা যেতে পারে?\n    A. int\n    B. long long\n    C. double\n    D. উপরের কোনোটিই নয়\n\nপ্রশ্ন ৩:\nএক্সপ্রেশনে বাম মান সম্পর্কে কোন বিবৃতিটি ভুল?\n    A. ভেরিয়েবল নাম এক্সপ্রেশনগুলি বাম মান।\n    B. ইনক্রিমেন্ট অপারেশনটির জন্য অপারেন্ডটি একটি বাম মান হতে হবে।\n    C. পয়েন্টার ডেরেফারেন্স এক্সপ্রেশনগুলি বাম মান।\n    D. প্রিফিক্স ইনক্রিমেন্ট অপারেশন এক্সপ্রেশনগুলি বাম মান।\n\nপ্রশ্ন ৪:\nফাংশন সম্পর্কে কোন বিবৃতিটি ভুল?\n    A. একটি ফাংশনের আনুষ্ঠানিক প্যারামিটারগুলি স্থানীয় ভেরিয়েবল।\n    B. স্থানীয় ভেরিয়েবলগুলি স্ট্যাকে স্থান বরাদ্দ করে।\n    C. ফাংশনের টাইপটি রিটার্ন ভ্যালু টাইপের সমান।\n    D. একটি ফাংশন তার দেহের ভিতর থেকে নিজেকে কল করতে পারে।\n\nপ্রশ্ন ৫:\nপয়েন্টার সম্পর্কে কোন বিবৃতিটি ভুল?\n    A. দুটি পয়েন্টার বিয়োগ করলে তাদের ঠিকানা মানের পার্থক্য সমান হয়।\n    B. পয়েন্টার ডেরেফারেন্স পয়েন্টারের টাইপের উপর ভিত্তি করে সমাধান করা জড়িত।\n    C. int *p[4], p একটি int পয়েন্টারের অ্যারে।\n    D. ফাংশনের নামগুলি ফাংশন পয়েন্টারগুলিতে বরাদ্দ করা যেতে পারে।\n\n>>> answer_questions()\nAAAAA\nআপনাকে শুধুমাত্র \"AAAAA\" এর মতো স্ট্রিংগুলি ফেরত দিতে হবে, যা প্রশ্নের পছন্দগুলির জন্য দাঁড়ায়।", "bg": "Отговорете на серия от въпроси, като предоставите избори A, B, C или D за всеки въпрос.\n\nВъпрос 1:\nКонстанти като 1e6 принадлежат към кой тип данни?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nВъпрос 2:\nДадено е 21! = 51,090,942,171,709,440,000, кой тип данни може да се използва за съхранение на тази стойност?\n    A. int\n    B. long long\n    C. double\n    D. Нито едно от горните\n\nВъпрос 3:\nКое твърдение за левите стойности в изразите е неправилно?\n    A. Изразите с имена на променливи са леви стойности.\n    B. Операцията за инкрементиране изисква операндът да бъде лява стойност.\n    C. Изразите за разименуване на указатели са леви стойности.\n    D. Изразите за префиксно инкрементиране са леви стойности.\n\nВъпрос 4:\nКое твърдение за функциите е неправилно?\n    A. Формалните параметри на функцията са локални променливи.\n    B. Локалните променливи се разпределят в стека.\n    C. Типът на функцията е същият като типа на върнатата стойност.\n    D. Функцията може да извика себе си от своето тяло.\n\nВъпрос 5:\nКое твърдение за указателите е неправилно?\n    A. Изваждането на два указателя е равно на разликата в техните адресни стойности.\n    B. Разименуването на указател включва разрешаване въз основа на типа на указателя.\n    C. int *p[4], p е масив от указатели към int.\n    D. Имената на функции могат да бъдат присвоени на указатели към функции.\n\n>>> answer_questions()\nAAAAA\nТрябва да върнете само низове, подобни на \"AAAAA\", които представляват изборите за въпроса.", "zh": "回答一系列问题，为每个问题提供选项 A、B、C 或 D。\n\n问题 1：\n像 1e6 这样的常量属于哪种数据类型？\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\n问题 2：\n给定 21! = 51,090,942,171,709,440,000，哪种数据类型可以用来存储这个值？\n    A. int\n    B. long long\n    C. double\n    D. 以上都不是\n\n问题 3：\n关于表达式中的左值，哪种说法是不正确的？\n    A. 变量名表达式是左值。\n    B. 增量运算要求操作数是左值。\n    C. 指针解引用表达式是左值。\n    D. 前缀增量运算表达式是左值。\n\n问题 4：\n关于函数，哪种说法是不正确的？\n    A. 函数的形式参数是局部变量。\n    B. 局部变量在栈中分配空间。\n    C. 函数类型与返回值类型相同。\n    D. 函数可以在其内部调用自身。\n\n问题 5：\n关于指针，哪种说法是不正确的？\n    A. 两个指针相减等于它们地址值的差。\n    B. 指针解引用涉及基于指针类型的解析。\n    C. int *p[4], p 是一个 int 指针数组。\n    D. 函数名可以赋值给函数指针。\n\n>>> answer_questions()\nAAAAA\n你应该只返回类似于 \"AAAAA\" 的字符串，代表问题的选项。", "fr": "Répondez à une série de questions en fournissant les choix A, B, C ou D pour chaque question.\n\nQuestion 1 :\nLes constantes comme 1e6 appartiennent à quel type de données ?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nQuestion 2 :\nÉtant donné 21! = 51,090,942,171,709,440,000, quel type de données peut être utilisé pour stocker cette valeur ?\n    A. int\n    B. long long\n    C. double\n    D. Aucun des précédents\n\nQuestion 3 :\nQuelle affirmation concernant les valeurs à gauche dans les expressions est incorrecte ?\n    A. Les expressions de noms de variables sont des valeurs à gauche.\n    B. L'opération d'incrément nécessite que l'opérande soit une valeur à gauche.\n    C. Les expressions de déréférencement de pointeur sont des valeurs à gauche.\n    D. Les expressions d'opération d'incrémentation préfixée sont des valeurs à gauche.\n\nQuestion 4 :\nQuelle affirmation concernant les fonctions est incorrecte ?\n    A. Les paramètres formels d'une fonction sont des variables locales.\n    B. Les variables locales sont allouées dans la pile.\n    C. Le type de la fonction est le même que le type de la valeur de retour.\n    D. Une fonction peut s'appeler elle-même depuis son corps.\n\nQuestion 5 :\nQuelle affirmation concernant les pointeurs est incorrecte ?\n    A. Soustraire deux pointeurs équivaut à la différence de leurs valeurs d'adresse.\n    B. Le déréférencement de pointeur implique une résolution basée sur le type du pointeur.\n    C. int *p[4], p est un tableau de pointeurs int.\n    D. Les noms de fonctions peuvent être assignés à des pointeurs de fonction.\n\n>>> answer_questions()\nAAAAA\nVous êtes censé ne retourner que des chaînes similaires à \"AAAAA\", qui représentent les choix des questions.", "de": "Beantworte eine Reihe von Fragen, indem du für jede Frage die Auswahlmöglichkeiten A, B, C oder D angibst.\n\nFrage 1:\nKonstanten wie 1e6 gehören zu welchem Datentyp?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nFrage 2:\nAngenommen, 21! = 51,090,942,171,709,440,000, welcher Datentyp kann verwendet werden, um diesen Wert zu speichern?\n    A. int\n    B. long long\n    C. double\n    D. Keiner der oben genannten\n\nFrage 3:\nWelche Aussage über linke Werte in Ausdrücken ist falsch?\n    A. Variablennamenausdrücke sind linke Werte.\n    B. Der Inkrementierungsoperator erfordert, dass der Operand ein linker Wert ist.\n    C. Zeigerdereferenzierungs-Ausdrücke sind linke Werte.\n    D. Präfix-Inkrementierungsoperationen sind linke Werte.\n\nFrage 4:\nWelche Aussage über Funktionen ist falsch?\n    A. Formale Parameter einer Funktion sind lokale Variablen.\n    B. Lokale Variablen werden im Stack Speicherplatz zugewiesen.\n    C. Der Funktionstyp ist derselbe wie der Rückgabewerttyp.\n    D. Eine Funktion kann sich selbst innerhalb ihres Körpers aufrufen.\n\nFrage 5:\nWelche Aussage über Zeiger ist falsch?\n    A. Das Subtrahieren von zwei Zeigern entspricht der Differenz ihrer Adresswerte.\n    B. Zeigerdereferenzierung beinhaltet die Auflösung basierend auf dem Typ des Zeigers.\n    C. int *p[4], p ist ein Array von int-Zeigern.\n    D. Funktionsnamen können Funktionszeigern zugewiesen werden.\n\n>>> answer_questions()\nAAAAA\nDu sollst nur Zeichenfolgen wie \"AAAAA\" zurückgeben, die für die Auswahlmöglichkeiten der Frage stehen.", "ha": "Amsa jerin tambayoyi ta hanyar bayar da zaɓuɓɓuka A, B, C, ko D ga kowace tambaya.\n\nTambaya ta 1:\nConstant kamar 1e6 suna cikin wane nau'in bayanai?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nTambaya ta 2:\nAn ba da 21! = 51,090,942,171,709,440,000, wane nau'in bayanai za a iya amfani da shi don adana wannan ƙima?\n    A. int\n    B. long long\n    C. double\n    D. Babu ɗaya daga cikin waɗanda ke sama\n\nTambaya ta 3:\nWace magana game da ƙimar hagu a cikin maganganu ba daidai ba ce?\n    A. Maganganun sunayen masu canji ƙimar hagu ne.\n    B. Aiki na ƙara yana buƙatar mai aiki ya zama ƙimar hagu.\n    C. Maganganun cire alamar adireshi ƙimar hagu ne.\n    D. Maganganun aikin ƙara na farko ƙimar hagu ne.\n\nTambaya ta 4:\nWace magana game da ayyuka ba daidai ba ce?\n    A. Sigogin aiki na aiki masu canji na gida ne.\n    B. Ana ware sarari don masu canji na gida a cikin faifai.\n    C. Nau'in aiki iri ɗaya ne da nau'in ƙimar dawowa.\n    D. Aiki na iya kiran kansa daga cikin jikinsa.\n\nTambaya ta 5:\nWace magana game da pointers ba daidai ba ce?\n    A. Ragewa pointers biyu yana daidai da bambanci a cikin ƙimar adireshinsu.\n    B. Cire alamar adireshi yana haɗawa da warwarewa bisa nau'in pointer.\n    C. int *p[4], p tsari ne na pointers int.\n    D. Ana iya sanya sunayen ayyuka ga pointers ayyuka.\n\n>>> answer_questions()\nAAAAA\nAna tsammanin ka dawo da igiyoyi makamantan \"AAAAA\", waɗanda suke wakiltar zaɓuɓɓukan tambayoyin.", "hi": "प्रश्नों की एक श्रृंखला का उत्तर A, B, C, या D विकल्प देकर दें।\n\nप्रश्न 1:\n1e6 जैसी स्थिरांक किस डेटा प्रकार से संबंधित हैं?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nप्रश्न 2:\nयदि 21! = 51,090,942,171,709,440,000 है, तो इस मान को संग्रहीत करने के लिए किस डेटा प्रकार का उपयोग किया जा सकता है?\n    A. int\n    B. long long\n    C. double\n    D. उपरोक्त में से कोई नहीं\n\nप्रश्न 3:\nकिस अभिव्यक्ति के बारे में बाएँ मानों के संबंध में कथन गलत है?\n    A. चर नाम अभिव्यक्तियाँ बाएँ मान हैं।\n    B. वृद्धि ऑपरेशन के लिए ऑपरेन्ड का बाएँ मान होना आवश्यक है।\n    C. पॉइंटर डिरेफरेंस अभिव्यक्तियाँ बाएँ मान हैं।\n    D. उपसर्ग वृद्धि ऑपरेशन अभिव्यक्तियाँ बाएँ मान हैं।\n\nप्रश्न 4:\nकिस कथन के बारे में कार्य गलत है?\n    A. एक फ़ंक्शन के औपचारिक पैरामीटर स्थानीय चर होते हैं।\n    B. स्थानीय चर स्टैक में स्थान आवंटित करते हैं।\n    C. फ़ंक्शन प्रकार वही है जो वापसी मूल्य प्रकार है।\n    D. एक फ़ंक्शन अपने शरीर के भीतर से खुद को कॉल कर सकता है।\n\nप्रश्न 5:\nकिस कथन के बारे में पॉइंटर्स गलत है?\n    A. दो पॉइंटर्स को घटाने से उनके पते के मूल्यों में अंतर होता है।\n    B. पॉइंटर डिरेफरेंस में पॉइंटर के प्रकार के आधार पर समाधान शामिल होता है।\n    C. int *p[4], p एक int पॉइंटर्स की सरणी है।\n    D. फ़ंक्शन नामों को फ़ंक्शन पॉइंटर्स को सौंपा जा सकता है।\n\n>>> answer_questions()\nAAAAA\nआपको केवल \"AAAAA\" जैसे स्ट्रिंग्स लौटाने हैं, जो प्रश्न के विकल्पों के लिए खड़े होते हैं।", "hu": "Válaszolj egy sor kérdésre az A, B, C vagy D választási lehetőségek megadásával minden kérdéshez.\n\n1. kérdés:\nAz olyan konstansok, mint az 1e6, melyik adattípushoz tartoznak?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\n2. kérdés:\nAdott a 21! = 51,090,942,171,709,440,000, melyik adattípus használható ennek az értéknek a tárolására?\n    A. int\n    B. long long\n    C. double\n    D. Egyik sem a fentiek közül\n\n3. kérdés:\nMelyik állítás helytelen a balértékekkel kapcsolatban a kifejezésekben?\n    A. A változónév kifejezések balértékek.\n    B. Az inkrementáló művelet megköveteli, hogy az operandus balérték legyen.\n    C. A pointer dereferálás kifejezések balértékek.\n    D. A prefix inkrementáló művelet kifejezések balértékek.\n\n4. kérdés:\nMelyik állítás helytelen a függvényekkel kapcsolatban?\n    A. A függvény formális paraméterei lokális változók.\n    B. A lokális változók a veremben kapnak helyet.\n    C. A függvény típusa megegyezik a visszatérési érték típusával.\n    D. Egy függvény meghívhatja önmagát a saját törzsén belül.\n\n5. kérdés:\nMelyik állítás helytelen a pointerekkel kapcsolatban?\n    A. Két pointer kivonása egyenlő a címértékeik különbségével.\n    B. A pointer dereferálás a pointer típusának alapján történik.\n    C. int *p[4], p egy int pointerekből álló tömb.\n    D. A függvénynevek hozzárendelhetők függvénypointerekhez.\n\n>>> answer_questions()\nAAAAA\nCsak olyan karakterláncokat kell visszaadnod, mint például \"AAAAA\", amelyek a kérdés választásait jelölik.", "es": "Responder a una serie de preguntas proporcionando opciones A, B, C o D para cada pregunta.\n\nPregunta 1:\n¿Las constantes como 1e6 pertenecen a qué tipo de dato?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nPregunta 2:\nDado 21! = 51,090,942,171,709,440,000, ¿qué tipo de dato se puede usar para almacenar este valor?\n    A. int\n    B. long long\n    C. double\n    D. Ninguna de las anteriores\n\nPregunta 3:\n¿Cuál afirmación sobre los valores de la izquierda en expresiones es incorrecta?\n    A. Las expresiones de nombres de variables son valores de la izquierda.\n    B. La operación de incremento requiere que el operando sea un valor de la izquierda.\n    C. Las expresiones de desreferencia de punteros son valores de la izquierda.\n    D. Las expresiones de operación de incremento prefijo son valores de la izquierda.\n\nPregunta 4:\n¿Cuál afirmación sobre las funciones es incorrecta?\n    A. Los parámetros formales de una función son variables locales.\n    B. Las variables locales se asignan espacio en la pila.\n    C. El tipo de la función es el mismo que el tipo de valor de retorno.\n    D. Una función puede llamarse a sí misma desde dentro de su cuerpo.\n\nPregunta 5:\n¿Cuál afirmación sobre los punteros es incorrecta?\n    A. Restar dos punteros equivale a la diferencia en sus valores de dirección.\n    B. La desreferencia de punteros implica resolver basado en el tipo del puntero.\n    C. int *p[4], p es un arreglo de punteros a int.\n    D. Los nombres de funciones pueden asignarse a punteros de función.\n\n>>> answer_questions()\nAAAAA\nSe supone que solo debes devolver cadenas similares a \"AAAAA\", que representan las opciones de la pregunta.", "arb": "ترجمة سلسلة من الأسئلة عن طريق تقديم الخيارات A، B، C، أو D لكل سؤال.\n\nالسؤال 1:\nالثوابت مثل 1e6 تنتمي إلى أي نوع من البيانات؟\n    A. عدد صحيح غير موقع\n    B. عدد صحيح\n    C. عدد عشري\n    D. مزدوج\n\nالسؤال 2:\nبالنظر إلى 21! = 51,090,942,171,709,440,000، أي نوع من البيانات يمكن استخدامه لتخزين هذه القيمة؟\n    A. عدد صحيح\n    B. عدد صحيح طويل طويل\n    C. مزدوج\n    D. لا شيء مما سبق\n\nالسؤال 3:\nأي عبارة عن القيم اليسارية في التعبيرات غير صحيحة؟\n    A. تعبيرات أسماء المتغيرات هي قيم يسارية.\n    B. تتطلب عملية الزيادة أن يكون المعامل قيمة يسارية.\n    C. تعبيرات إلغاء المؤشر هي قيم يسارية.\n    D. تعبيرات عملية الزيادة المسبقة هي قيم يسارية.\n\nالسؤال 4:\nأي عبارة عن الدوال غير صحيحة؟\n    A. المعاملات الشكلية للدالة هي متغيرات محلية.\n    B. يتم تخصيص مساحة للمتغيرات المحلية في المكدس.\n    C. نوع الدالة هو نفس نوع قيمة الإرجاع.\n    D. يمكن للدالة أن تستدعي نفسها من داخل جسمها.\n\nالسؤال 5:\nأي عبارة عن المؤشرات غير صحيحة؟\n    A. طرح مؤشرين يساوي الفرق في قيم عناوينهما.\n    B. إلغاء المؤشر يتضمن الحل بناءً على نوع المؤشر.\n    C. int *p[4]، p هو مصفوفة من مؤشرات int.\n    D. يمكن تعيين أسماء الدوال إلى مؤشرات الدوال.\n\n>>> answer_questions()\nAAAAA\nمن المفترض أن تعيد فقط سلاسل مشابهة لـ \"AAAAA\"، والتي تمثل اختيارات السؤال.", "sw": "Jibu maswali kadhaa kwa kutoa chaguo A, B, C, au D kwa kila swali.\n\nSwali la 1:\nKonstant kama 1e6 ni ya aina gani ya data?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nSwali la 2:\nKwa kuzingatia 21! = 51,090,942,171,709,440,000, ni aina gani ya data inaweza kutumika kuhifadhi thamani hii?\n    A. int\n    B. long long\n    C. double\n    D. Hakuna kati ya haya\n\nSwali la 3:\nNi kauli gani kuhusu thamani za kushoto katika maonyesho si sahihi?\n    A. Maonyesho ya majina ya vigezo ni thamani za kushoto.\n    B. Operesheni ya kuongeza inahitaji operand kuwa thamani ya kushoto.\n    C. Maonyesho ya kufuta pointer ni thamani za kushoto.\n    D. Maonyesho ya operesheni ya kuongeza awali ni thamani za kushoto.\n\nSwali la 4:\nNi kauli gani kuhusu kazi si sahihi?\n    A. Vigezo rasmi vya kazi ni vigezo vya ndani.\n    B. Vigezo vya ndani vinatengewa nafasi kwenye stack.\n    C. Aina ya kazi ni sawa na aina ya thamani ya kurudi.\n    D. Kazi inaweza kujiita yenyewe kutoka ndani ya mwili wake.\n\nSwali la 5:\nNi kauli gani kuhusu pointer si sahihi?\n    A. Kutoa pointer mbili ni sawa na tofauti katika thamani za anwani zao.\n    B. Kufuta pointer kunahusisha kutatua kulingana na aina ya pointer.\n    C. int *p[4], p ni safu ya pointer za int.\n    D. Majina ya kazi yanaweza kupewa pointer za kazi.\n\n>>> answer_questions()\nAAAAA\nUnatakiwa kurudisha tu mistari inayofanana na \"AAAAA\", ambayo inasimama kwa chaguo za swali.", "tr": "Sorulara A, B, C veya D seçeneklerini vererek yanıtlayın.\n\nSoru 1:\n1e6 gibi sabitler hangi veri tipine aittir?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nSoru 2:\n21! = 51,090,942,171,709,440,000 verildiğinde, bu değeri saklamak için hangi veri tipi kullanılabilir?\n    A. int\n    B. long long\n    C. double\n    D. Yukarıdakilerin hiçbiri\n\nSoru 3:\nİfadelerdeki sol değerler hakkında hangi ifade yanlıştır?\n    A. Değişken adı ifadeleri sol değerlerdir.\n    B. Artırma işlemi, operandın sol değer olmasını gerektirir.\n    C. İşaretçi çözme ifadeleri sol değerlerdir.\n    D. Ön ek artırma işlemi ifadeleri sol değerlerdir.\n\nSoru 4:\nFonksiyonlar hakkında hangi ifade yanlıştır?\n    A. Bir fonksiyonun resmi parametreleri yerel değişkenlerdir.\n    B. Yerel değişkenler yığın içinde alan tahsis edilir.\n    C. Fonksiyon tipi, dönüş değeri tipi ile aynıdır.\n    D. Bir fonksiyon, gövdesi içinde kendisini çağırabilir.\n\nSoru 5:\nİşaretçiler hakkında hangi ifade yanlıştır?\n    A. İki işaretçinin çıkarılması, adres değerlerindeki farkı eşittir.\n    B. İşaretçi çözme, işaretçinin türüne göre çözümlemeyi içerir.\n    C. int *p[4], p bir int işaretçi dizisidir.\n    D. Fonksiyon isimleri, fonksiyon işaretçilerine atanabilir.\n\n>>> answer_questions()\nAAAAA\nSadece soruların seçeneklerini temsil eden \"AAAAA\" gibi dizeleri döndürmeniz gerekiyor.", "vi": "Trả lời một loạt câu hỏi bằng cách cung cấp lựa chọn A, B, C, hoặc D cho mỗi câu hỏi.\n\nCâu hỏi 1:\nHằng số như 1e6 thuộc kiểu dữ liệu nào?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nCâu hỏi 2:\nCho 21! = 51,090,942,171,709,440,000, kiểu dữ liệu nào có thể được sử dụng để lưu trữ giá trị này?\n    A. int\n    B. long long\n    C. double\n    D. Không có kiểu nào trong số trên\n\nCâu hỏi 3:\nCâu nào về giá trị bên trái trong biểu thức là không đúng?\n    A. Biểu thức tên biến là giá trị bên trái.\n    B. Toán tử tăng yêu cầu toán hạng phải là giá trị bên trái.\n    C. Biểu thức giải tham chiếu con trỏ là giá trị bên trái.\n    D. Biểu thức toán tử tăng trước là giá trị bên trái.\n\nCâu hỏi 4:\nCâu nào về hàm là không đúng?\n    A. Tham số hình thức của một hàm là biến cục bộ.\n    B. Biến cục bộ được cấp phát không gian trong ngăn xếp.\n    C. Kiểu của hàm giống với kiểu giá trị trả về.\n    D. Một hàm có thể tự gọi trong thân của nó.\n\nCâu hỏi 5:\nCâu nào về con trỏ là không đúng?\n    A. Trừ hai con trỏ bằng sự khác biệt trong giá trị địa chỉ của chúng.\n    B. Giải tham chiếu con trỏ liên quan đến việc giải quyết dựa trên kiểu của con trỏ.\n    C. int *p[4], p là một mảng con trỏ int.\n    D. Tên hàm có thể được gán cho con trỏ hàm.\n\n>>> answer_questions()\nAAAAA\nBạn cần chỉ trả về chuỗi tương tự như \"AAAAA\", đại diện cho các lựa chọn của câu hỏi.", "id": "Menjawab serangkaian pertanyaan dengan memberikan pilihan A, B, C, atau D untuk setiap pertanyaan.\n\nPertanyaan 1:\nKonstanta seperti 1e6 termasuk ke dalam tipe data apa?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nPertanyaan 2:\nDiberikan 21! = 51,090,942,171,709,440,000, tipe data mana yang dapat digunakan untuk menyimpan nilai ini?\n    A. int\n    B. long long\n    C. double\n    D. Tidak ada di atas\n\nPertanyaan 3:\nPernyataan mana tentang nilai kiri dalam ekspresi yang tidak benar?\n    A. Ekspresi nama variabel adalah nilai kiri.\n    B. Operasi peningkatan memerlukan operan menjadi nilai kiri.\n    C. Ekspresi dereferensi pointer adalah nilai kiri.\n    D. Ekspresi operasi peningkatan prefiks adalah nilai kiri.\n\nPertanyaan 4:\nPernyataan mana tentang fungsi yang tidak benar?\n    A. Parameter formal dari sebuah fungsi adalah variabel lokal.\n    B. Variabel lokal dialokasikan ruang di stack.\n    C. Tipe fungsi sama dengan tipe nilai kembalian.\n    D. Sebuah fungsi dapat memanggil dirinya sendiri dari dalam tubuhnya.\n\nPertanyaan 5:\nPernyataan mana tentang pointer yang tidak benar?\n    A. Mengurangi dua pointer sama dengan selisih dalam nilai alamat mereka.\n    B. Dereferensi pointer melibatkan penyelesaian berdasarkan tipe pointer.\n    C. int *p[4], p adalah array dari pointer int.\n    D. Nama fungsi dapat ditugaskan ke pointer fungsi.\n\n>>> answer_questions()\nAAAAA\nAnda seharusnya hanya mengembalikan string yang mirip dengan \"AAAAA\", yang mewakili pilihan dari pertanyaan.", "ja": "質問に対して、各質問に対する選択肢A、B、C、またはDを提供して答えてください。\n\n質問1:\n1e6のような定数はどのデータ型に属しますか？\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\n質問2:\n21! = 51,090,942,171,709,440,000であるとき、この値を格納するために使用できるデータ型はどれですか？\n    A. int\n    B. long long\n    C. double\n    D. 上記のいずれでもない\n\n質問3:\n式における左辺値についての記述で誤っているものはどれですか？\n    A. 変数名の式は左辺値である。\n    B. インクリメント操作はオペランドが左辺値であることを要求する。\n    C. ポインタのデリファレンス式は左辺値である。\n    D. プレフィックスインクリメント操作の式は左辺値である。\n\n質問4:\n関数についての記述で誤っているものはどれですか？\n    A. 関数の形式パラメータはローカル変数である。\n    B. ローカル変数はスタックにスペースが割り当てられる。\n    C. 関数の型は戻り値の型と同じである。\n    D. 関数はその本体から自身を呼び出すことができる。\n\n質問5:\nポインタについての記述で誤っているものはどれですか？\n    A. 2つのポインタを引くと、それらのアドレス値の差になる。\n    B. ポインタのデリファレンスはポインタの型に基づいて解決される。\n    C. int *p[4], pはintポインタの配列である。\n    D. 関数名は関数ポインタに代入できる。\n\n>>> answer_questions()\nAAAAA\n質問の選択肢を表す「AAAAA」のような文字列のみを返すことになっています。", "ko": "질문에 대해 각 질문에 대해 선택지 A, B, C, 또는 D를 제공하여 답하십시오.\n\n질문 1:\n1e6과 같은 상수는 어떤 데이터 유형에 속합니까?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\n질문 2:\n21! = 51,090,942,171,709,440,000이 주어졌을 때, 이 값을 저장하는 데 사용할 수 있는 데이터 유형은 무엇입니까?\n    A. int\n    B. long long\n    C. double\n    D. 위의 것 중 아무것도 아님\n\n질문 3:\n표현식에서 왼쪽 값에 대한 설명 중 틀린 것은 무엇입니까?\n    A. 변수 이름 표현식은 왼쪽 값입니다.\n    B. 증가 연산은 피연산자가 왼쪽 값이어야 합니다.\n    C. 포인터 역참조 표현식은 왼쪽 값입니다.\n    D. 접두사 증가 연산 표현식은 왼쪽 값입니다.\n\n질문 4:\n함수에 대한 설명 중 틀린 것은 무엇입니까?\n    A. 함수의 형식 매개변수는 지역 변수입니다.\n    B. 지역 변수는 스택에 공간이 할당됩니다.\n    C. 함수의 유형은 반환 값의 유형과 동일합니다.\n    D. 함수는 본문 내에서 자신을 호출할 수 있습니다.\n\n질문 5:\n포인터에 대한 설명 중 틀린 것은 무엇입니까?\n    A. 두 포인터를 빼면 주소 값의 차이가 됩니다.\n    B. 포인터 역참조는 포인터의 유형에 따라 해석됩니다.\n    C. int *p[4], p는 int 포인터의 배열입니다.\n    D. 함수 이름은 함수 포인터에 할당할 수 있습니다.\n\n>>> answer_questions()\nAAAAA\n당신은 질문의 선택지를 나타내는 \"AAAAA\"와 유사한 문자열만 반환해야 합니다.", "ml": "ഓരോ ചോദ്യത്തിനും A, B, C, അല്ലെങ്കിൽ D എന്നിങ്ങനെ തിരഞ്ഞെടുക്കലുകൾ നൽകിക്കൊണ്ട് ചോദ്യങ്ങളുടെ ഒരു പരമ്പരയ്ക്ക് ഉത്തരം നൽകുക.\n1e6 പോലുള്ള സ്ഥിരാങ്കങ്ങൾ ഏത് ഡാറ്റാ തരം ആകുന്നു?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nചോദ്യം 2:\n21! = 51,090,942,171,709,440,000 എന്നത് നൽകിയാൽ, ഈ മൂല്യം സംഭരിക്കാൻ ഏത് ഡാറ്റാ തരം ഉപയോഗിക്കാം?\n    A. int\n    B. long long\n    C. double\n    D. മുകളിൽ പറയുന്നവയൊന്നുമല്ല\n\nചോദ്യം 3:\nവ്യക്തമാക്കലുകളിൽ ഇടത് മൂല്യങ്ങളെക്കുറിച്ചുള്ള ഏത് പ്രസ്താവന തെറ്റാണ്?\n    A. വ്യത്യാസ നാമ വ്യക്തമാക്കലുകൾ ഇടത് മൂല്യങ്ങളാണ്.\n    B. വർദ്ധനവിന്റെ പ്രവർത്തനം ഓപ്പറാൻഡ് ഇടത് മൂല്യമായിരിക്കണം.\n    C. സൂചിക ഡീറഫറൻസ് വ്യക്തമാക്കലുകൾ ഇടത് മൂല്യങ്ങളാണ്.\n    D. പ്രിഫിക്സ് വർദ്ധനവിന്റെ പ്രവർത്തന വ്യക്തമാക്കലുകൾ ഇടത് മൂല്യങ്ങളാണ്.\n\nചോദ്യം 4:\nഫംഗ്ഷനുകളെക്കുറിച്ചുള്ള ഏത് പ്രസ്താവന തെറ്റാണ്?\n    A. ഒരു ഫംഗ്ഷന്റെ ഔപചാരിക പാരാമീറ്ററുകൾ പ്രാദേശിക വ്യത്യാസങ്ങളാണ്.\n    B. പ്രാദേശിക വ്യത്യാസങ്ങൾക്ക് സ്റ്റാക്കിൽ സ്ഥലം അനുവദിച്ചിരിക്കുന്നു.\n    C. ഫംഗ്ഷൻ തരം മടക്കിയ മൂല്യത്തിന്റെ തരം തന്നെയാണ്.\n    D. ഒരു ഫംഗ്ഷൻ അതിന്റെ ശരീരത്തിനുള്ളിൽ നിന്ന് തന്നെ വിളിക്കാം.\n\nചോദ്യം 5:\nസൂചികകളെക്കുറിച്ചുള്ള ഏത് പ്രസ്താവന തെറ്റാണ്?\n    A. രണ്ട് സൂചികകൾ കുറയ്ക്കുന്നത് അവരുടെ വിലാസ മൂല്യങ്ങളിലെ വ്യത്യാസത്തിന് തുല്യമാണ്.\n    B. സൂചിക ഡീറഫറൻസ് സൂചികയുടെ തരം അടിസ്ഥാനമാക്കി പരിഹരിക്കുന്നത് ഉൾപ്പെടുന്നു.\n    C. int *p[4], p ഒരു int സൂചികകളുടെ നിരയാണ്.\n    D. ഫംഗ്ഷൻ നാമങ്ങൾ ഫംഗ്ഷൻ സൂചികകൾക്ക് നിയോഗിക്കാം.\n\n>>> answer_questions()\nAAAAA\nനിങ്ങൾ \"AAAAA\" പോലുള്ള സ്ട്രിംഗുകൾ മാത്രം മടക്കേണ്ടതാണ്, ഇത് ചോദ്യത്തിന്റെ തിരഞ്ഞെടുപ്പുകൾക്ക് നിൽക്കുന്നു.", "fa": "پاسخ به یک سری سوال با ارائه گزینه‌های A، B، C یا D برای هر سوال.\n\nسوال 1:\nثابت‌هایی مانند 1e6 به کدام نوع داده تعلق دارند؟\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nسوال 2:\nبا توجه به 21! = 51,090,942,171,709,440,000، از کدام نوع داده می‌توان برای ذخیره این مقدار استفاده کرد؟\n    A. int\n    B. long long\n    C. double\n    D. هیچ‌کدام از موارد بالا\n\nسوال 3:\nکدام عبارت درباره مقادیر چپ در عبارات نادرست است؟\n    A. عبارات نام متغیر مقادیر چپ هستند.\n    B. عملیات افزایش نیاز دارد که عملوند یک مقدار چپ باشد.\n    C. عبارات اشاره‌گر به مقدار مقادیر چپ هستند.\n    D. عبارات عملیات افزایش پیشوندی مقادیر چپ هستند.\n\nسوال 4:\nکدام عبارت درباره توابع نادرست است؟\n    A. پارامترهای رسمی یک تابع متغیرهای محلی هستند.\n    B. متغیرهای محلی در پشته فضای اختصاص داده می‌شوند.\n    C. نوع تابع همانند نوع مقدار بازگشتی است.\n    D. یک تابع می‌تواند از درون بدنه خود را فراخوانی کند.\n\nسوال 5:\nکدام عبارت درباره اشاره‌گرها نادرست است؟\n    A. تفریق دو اشاره‌گر برابر با تفاوت در مقادیر آدرس آنها است.\n    B. اشاره‌گر به مقدار شامل حل بر اساس نوع اشاره‌گر است.\n    C. int *p[4], p یک آرایه از اشاره‌گرهای int است.\n    D. نام‌های تابع می‌توانند به اشاره‌گرهای تابع اختصاص داده شوند.\n\n>>> answer_questions()\nAAAAA\nشما باید تنها رشته‌هایی مشابه \"AAAAA\" که نشان‌دهنده گزینه‌های سوال هستند را برگردانید."}}
{"task_id": "C/21", "prompt": {"en": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nThe task is to determine if it is possible to assemble the wooden squares from n buckets,\nwhere each bucket contains $a_i$ squares with a side length of 1, into a single larger square.\nInput: length of list, array of numbers\n    >>> Is_Square(1, (int[]){9})\n    1\n*/\nint Is_Square(int length, int squares[])", "sq": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDetyra është të përcaktohet nëse është e mundur të montohet katrorët prej druri nga n kovë,\nku secila kovë përmban $a_i$ katrorë me një gjatësi anësore prej 1, në një katror më të madh.\nHyrja: gjatësia e listës, vargu i numrave\n    >>> Is_Square(1, (int[]){9})\n    1\n*/\nint Is_Square(int length, int squares[])", "hy": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nԽնդիրը որոշելն է՝ արդյոք հնարավոր է n դույլերից հավաքել փայտե քառակուսիներ,\nորտեղ յուրաքանչյուր դույլ պարունակում է $a_i$ քառակուսիներ՝ կողքի երկարությունը 1, մեկ մեծ քառակուսի մեջ:\nՄուտքագրում: ցուցակի երկարություն, թվերի զանգված\n    >>> Is_Square(1, (int[]){9})\n    1\n*/\nint Is_Square(int length, int squares[])", "bn": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nকাজটি হল n বালতি থেকে কাঠের বর্গক্ষেত্রগুলি একত্রিত করা সম্ভব কিনা তা নির্ধারণ করা,\nযেখানে প্রতিটি বালতিতে ১ পার্শ্ব দৈর্ঘ্যের $a_i$ বর্গক্ষেত্র রয়েছে, একটি বড় বর্গক্ষেত্রে।\nইনপুট: তালিকার দৈর্ঘ্য, সংখ্যার অ্যারে\n    >>> Is_Square(1, (int[]){9})\n    1\n*/\nint Is_Square(int length, int squares[])", "bg": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nЗадачата е да се определи дали е възможно да се сглобят дървените квадратчета от n кофи,\nкъдето всяка кофа съдържа $a_i$ квадратчета със страна с дължина 1, в един по-голям квадрат.\nВход: дължина на списъка, масив от числа\n    >>> Is_Square(1, (int[]){9})\n    1\n*/\nint Is_Square(int length, int squares[])", "zh": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n任务是确定是否可以从 n 个桶中组装木制正方形，其中每个桶包含 $a_i$ 个边长为 1 的正方形，组装成一个更大的正方形。\n输入：列表长度，数字数组\n    >>> Is_Square(1, (int[]){9})\n    1\n*/\nint Is_Square(int length, int squares[])", "fr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nLa tâche consiste à déterminer s'il est possible d'assembler les carrés en bois à partir de n seaux,\noù chaque seau contient $a_i$ carrés avec une longueur de côté de 1, en un seul carré plus grand.\nEntrée : longueur de la liste, tableau de nombres\n    >>> Is_Square(1, (int[]){9})\n    1\n*/\nint Is_Square(int length, int squares[])", "de": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDie Aufgabe besteht darin, festzustellen, ob es möglich ist, die Holzquadrate aus n Eimern,\nwobei jeder Eimer $a_i$ Quadrate mit einer Seitenlänge von 1 enthält, zu einem einzigen größeren Quadrat zusammenzusetzen.\nEingabe: Länge der Liste, Array von Zahlen\n    >>> Is_Square(1, (int[]){9})\n    1\n*/\nint Is_Square(int length, int squares[])", "ha": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nAikin shi ne tantance ko yana yiwuwa a tara murabba'ai na katako daga guga n,\ninda kowanne guga yana dauke da $a_i$ murabba'ai tare da tsawon gefe 1, zuwa cikin babban murabba'i guda.\nShigarwa: tsawon jerin, jerin lambobi\n    >>> Is_Square(1, (int[]){9})\n    1\n*/\nint Is_Square(int length, int squares[])", "hi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nकार्य यह निर्धारित करना है कि क्या n बाल्टियों से लकड़ी के वर्गों को इकट्ठा करना संभव है,\nजहां प्रत्येक बाल्टी में $a_i$ वर्ग होते हैं जिनकी भुजा की लंबाई 1 होती है, एक बड़े वर्ग में।\nइनपुट: सूची की लंबाई, संख्याओं की श्रृंखला\n    >>> Is_Square(1, (int[]){9})\n    1\n*/\nint Is_Square(int length, int squares[])", "hu": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nA feladat annak meghatározása, hogy lehetséges-e a fa négyzeteket n vödörből összeállítani,\nahol minden vödör $a_i$ darab, 1 oldalhosszúságú négyzetet tartalmaz, egyetlen nagyobb négyzetté.\nBemenet: a lista hossza, számok tömbje\n    >>> Is_Square(1, (int[]){9})\n    1\n*/\nint Is_Square(int length, int squares[])", "es": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nLa tarea es determinar si es posible ensamblar los cuadrados de madera de n cubetas,\ndonde cada cubeta contiene $a_i$ cuadrados con un lado de longitud 1, en un solo cuadrado más grande.\nEntrada: longitud de la lista, arreglo de números\n    >>> Is_Square(1, (int[]){9})\n    1\n*/\nint Is_Square(int length, int squares[])", "arb": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nالمهمة هي تحديد ما إذا كان من الممكن تجميع المربعات الخشبية من n دلاء،\nحيث يحتوي كل دلو على $a_i$ مربعات بطول ضلع 1، في مربع أكبر واحد.\nالمدخلات: طول القائمة، مصفوفة الأرقام\n    >>> Is_Square(1, (int[]){9})\n    1\n*/\nint Is_Square(int length, int squares[])", "sw": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nKazi ni kuamua kama inawezekana kuunganisha miraba ya mbao kutoka kwenye ndoo n,\nambapo kila ndoo ina $a_i$ miraba yenye urefu wa upande wa 1, kuwa mraba mmoja mkubwa.\nIngizo: urefu wa orodha, safu ya namba\n    >>> Is_Square(1, (int[]){9})\n    1\n*/\nint Is_Square(int length, int squares[])", "tr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nGörev, her kovada kenar uzunluğu 1 olan $a_i$ kare bulunan n kovadan ahşap kareleri tek bir büyük kareye monte etmenin mümkün olup olmadığını belirlemektir.\nGirdi: liste uzunluğu, sayıların dizisi\n    >>> Is_Square(1, (int[]){9})\n    1\n*/\nint Is_Square(int length, int squares[])", "vi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nNhiệm vụ là xác định xem có thể lắp ráp các hình vuông gỗ từ n thùng,\nmỗi thùng chứa $a_i$ hình vuông với độ dài cạnh là 1, thành một hình vuông lớn hơn hay không.\nĐầu vào: độ dài của danh sách, mảng các số\n    >>> Is_Square(1, (int[]){9})\n    1\n*/\nint Is_Square(int length, int squares[])", "id": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nTugasnya adalah untuk menentukan apakah mungkin untuk merakit kotak kayu dari n ember,\ndi mana setiap ember berisi $a_i$ kotak dengan panjang sisi 1, menjadi satu kotak yang lebih besar.\nInput: panjang daftar, array angka\n    >>> Is_Square(1, (int[]){9})\n    1\n*/\nint Is_Square(int length, int squares[])", "ja": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nこのタスクは、n個のバケツから木製の正方形を組み立てることが可能かどうかを判断することです。\n各バケツには、1の辺の長さを持つ$a_i$個の正方形が含まれています。それらを1つの大きな正方形に組み立てます。\n入力: リストの長さ、数値の配列\n    >>> Is_Square(1, (int[]){9})\n    1\n*/\nint Is_Square(int length, int squares[])", "ko": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n작업은 n개의 버킷에서 각 버킷에 한 변의 길이가 1인 $a_i$ 개의 정사각형이 들어 있는 경우,\n이 정사각형들을 하나의 더 큰 정사각형으로 조립할 수 있는지 여부를 결정하는 것입니다.\n입력: 리스트의 길이, 숫자의 배열\n    >>> Is_Square(1, (int[]){9})\n    1\n*/\nint Is_Square(int length, int squares[])", "ml": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nപ്രത്യക്ഷമായുള്ള പ്രവൃത്തിയാണ് n ബക്കറ്റുകളിൽ നിന്ന് മരക്കട്ടകൾ ഒന്നിച്ച് ചേർത്ത് ഒരു വലിയ ചതുരം ഉണ്ടാക്കാൻ കഴിയുമോ എന്ന് നിർണ്ണയിക്കുക,\nഎവിടെ ഓരോ ബക്കറ്റിലും 1 നീളമുള്ള $a_i$ ചതുരങ്ങൾ അടങ്ങിയിരിക്കുന്നു, ഒരു വലിയ ചതുരത്തിൽ ചേർക്കാൻ.\nഇൻപുട്ട്: ലിസ്റ്റിന്റെ നീളം, സംഖ്യകളുടെ നിര\n    >>> Is_Square(1, (int[]){9})\n    1\n*/\nint Is_Square(int length, int squares[])", "fa": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nوظیفه این است که تعیین کنیم آیا ممکن است مربع‌های چوبی را از n سطل که هر کدام $a_i$ مربع با طول ضلع 1 دارند، به یک مربع بزرگ‌تر تبدیل کنیم.\nورودی: طول لیست، آرایه‌ای از اعداد\n    >>> Is_Square(1, (int[]){9})\n    1\n*/\nint Is_Square(int length, int squares[])"}, "canonical_solution": "{\n    long long sum = 0;\n    for (int i = 0; i < length; ++i) {\n        sum += squares[i]; // 求和\n    }\n    int root = (int)sqrt(sum);\n    return root * root == sum; // 是某个整数的平方\n}", "instruction": {"en": "int Is_Square(int length, int squares[])\n{\n    long long sum = 0;\n    for (int i = 0; i < length; ++i) {\n        sum += squares[i]; // 求和\n    }\n    int root = (int)sqrt(sum);\n    return root * root == sum; // 是某个整数的平方\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "sq": "int Is_Square(int length, int squares[])\n{\n    long long sum = 0;\n    for (int i = 0; i < length; ++i) {\n        sum += squares[i]; // 求和\n    }\n    int root = (int)sqrt(sum);\n    return root * root == sum; // 是某个整数的平方\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C në shqip duke përdorur maksimumi 500 karaktere.", "hy": "int Is_Square(int length, int squares[])\n{\n    long long sum = 0;\n    for (int i = 0; i < length; ++i) {\n        sum += squares[i]; // 求和\n    }\n    int root = (int)sqrt(sum);\n    return root * root == sum; // 是某个整数的平方\n}\n\nՏվեք C կոդի հակիրճ բնութագիրը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։", "bn": "int Is_Square(int length, int squares[])\n{\n    long long sum = 0;\n    for (int i = 0; i < length; ++i) {\n        sum += squares[i]; // 求和\n    }\n    int root = (int)sqrt(sum);\n    return root * root == sum; // 是某个整数的平方\n}\n\nসি কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।", "bg": "int Is_Square(int length, int squares[])\n{\n    long long sum = 0;\n    for (int i = 0; i < length; ++i) {\n        sum += squares[i]; // 求和\n    }\n    int root = (int)sqrt(sum);\n    return root * root == sum; // 是某个整数的平方\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, като използвате не повече от 500 знака.", "zh": "int Is_Square(int length, int squares[])\n{\n    long long sum = 0;\n    for (int i = 0; i < length; ++i) {\n        sum += squares[i]; // 求和\n    }\n    int root = (int)sqrt(sum);\n    return root * root == sum; // 是某个整数的平方\n}\n\n请为以下C代码提供一个简洁的中文自然语言描述（文档字符串），不超过500个字符。", "fr": "int Is_Square(int length, int squares[])\n{\n    long long sum = 0;\n    for (int i = 0; i < length; ++i) {\n        sum += squares[i]; // 求和\n    }\n    int root = (int)sqrt(sum);\n    return root * root == sum; // 是某个整数的平方\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.", "de": "int Is_Square(int length, int squares[])\n{\n    long long sum = 0;\n    for (int i = 0; i < length; ++i) {\n        sum += squares[i]; // 求和\n    }\n    int root = (int)sqrt(sum);\n    return root * root == sum; // 是某个整数的平方\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "int Is_Square(int length, int squares[])\n{\n    long long sum = 0;\n    for (int i = 0; i < length; ++i) {\n        sum += squares[i]; // 求和\n    }\n    int root = (int)sqrt(sum);\n    return root * root == sum; // 是某个整数的平方\n}\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar C a cikin Hausa, ba tare da wuce haruffa 500 ba.", "hi": "int Is_Square(int length, int squares[])\n{\n    long long sum = 0;\n    for (int i = 0; i < length; ++i) {\n        sum += squares[i]; // 求和\n    }\n    int root = (int)sqrt(sum);\n    return root * root == sum; // 是某个整数的平方\n}\n\nC कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "int Is_Square(int length, int squares[])\n{\n    long long sum = 0;\n    for (int i = 0; i < length; ++i) {\n        sum += squares[i]; // 求和\n    }\n    int root = (int)sqrt(sum);\n    return root * root == sum; // 是某个整数的平方\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben.", "es": "int Is_Square(int length, int squares[])\n{\n    long long sum = 0;\n    for (int i = 0; i < length; ++i) {\n        sum += squares[i]; // 求和\n    }\n    int root = (int)sqrt(sum);\n    return root * root == sum; // 是某个整数的平方\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando un máximo de 500 caracteres.", "arb": "int Is_Square(int length, int squares[])\n{\n    long long sum = 0;\n    for (int i = 0; i < length; ++i) {\n        sum += squares[i]; // 求和\n    }\n    int root = (int)sqrt(sum);\n    return root * root == sum; // 是某个整数的平方\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "int Is_Square(int length, int squares[])\n{\n    long long sum = 0;\n    for (int i = 0; i < length; ++i) {\n        sum += squares[i]; // 求和\n    }\n    int root = (int)sqrt(sum);\n    return root * root == sum; // 是某个整数的平方\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "int Is_Square(int length, int squares[])\n{\n    long long sum = 0;\n    for (int i = 0; i < length; ++i) {\n        sum += squares[i]; // 求和\n    }\n    int root = (int)sqrt(sum);\n    return root * root == sum; // 是某个整数的平方\n}\n\nC kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe olarak yazılmalıdır.", "vi": "int Is_Square(int length, int squares[])\n{\n    long long sum = 0;\n    for (int i = 0; i < length; ++i) {\n        sum += squares[i]; // 求和\n    }\n    int root = (int)sqrt(sum);\n    return root * root == sum; // 是某个整数的平方\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã C bằng tiếng Việt với tối đa 500 ký tự.", "id": "int Is_Square(int length, int squares[])\n{\n    long long sum = 0;\n    for (int i = 0; i < length; ++i) {\n        sum += squares[i]; // 求和\n    }\n    int root = (int)sqrt(sum);\n    return root * root == sum; // 是某个整数的平方\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode C dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "int Is_Square(int length, int squares[])\n{\n    long long sum = 0;\n    for (int i = 0; i < length; ++i) {\n        sum += squares[i]; // 求和\n    }\n    int root = (int)sqrt(sum);\n    return root * root == sum; // 是某个整数的平方\n}\n\nC コードの簡単な自然言語による説明 (docstring) を英語で最大 500 文字まで入力してください。", "ko": "int Is_Square(int length, int squares[])\n{\n    long long sum = 0;\n    for (int i = 0; i < length; ++i) {\n        sum += squares[i]; // 求和\n    }\n    int root = (int)sqrt(sum);\n    return root * root == sum; // 是某个整数的平方\n}\n\nC 코드의 기능을 설명하는 간결한 자연어 설명(docstring)을 한국어로 작성하세요. 최대 500자 이내로 작성하십시오.", "ml": "int Is_Square(int length, int squares[])\n{\n    long long sum = 0;\n    for (int i = 0; i < length; ++i) {\n        sum += squares[i]; // 求和\n    }\n    int root = (int)sqrt(sum);\n    return root * root == sum; // 是某个整数的平方\n}\n\nസീ കോഡിന് 500 അക്ഷരങ്ങൾക്കുള്ളിൽ മലയാളത്തിൽ ചുരുക്കമായ ഒരു സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) നൽകുക.", "fa": "int Is_Square(int length, int squares[])\n{\n    long long sum = 0;\n    for (int i = 0; i < length; ++i) {\n        sum += squares[i]; // 求和\n    }\n    int root = (int)sqrt(sum);\n    return root * root == sum; // 是某个整数的平方\n}\n\nتوضیح مختصر و طبیعی (docstring) از کد C را به زبان فارسی با حداکثر ۵۰۰ کاراکتر ارائه دهید."}, "level": "", "test": "int main() {\n    assert(Is_Square(1, (int[]){9}) == 1);\n    assert(Is_Square(2, (int[]){14, 2}) == 1);\n    assert(Is_Square(2, (int[]){7, 7}) == 0);\n    assert(Is_Square(7, (int[]){1, 2, 3, 4, 5, 6, 7}) == 0);\n    assert(Is_Square(6, (int[]){1, 3, 5, 7, 9, 11}) == 1);\n    assert(Is_Square(4, (int[]){2, 2, 2, 2}) == 0);\n\n    // Additional test cases\n    assert(Is_Square(3, (int[]){4, 5, 6}) == 0);\n    assert(Is_Square(4, (int[]){16, 9, 4, 1}) == 0);\n    assert(Is_Square(5, (int[]){1, 1, 1, 1, 1}) == 0);\n    assert(Is_Square(2, (int[]){25, 25}) == 0);\n    assert(Is_Square(3, (int[]){10, 10, 5}) == 1);\n\n    // printf(\"All tests passed!\\n\");\n    return 0;\n}", "entry_point": "Is_Square", "signature": "int Is_Square(int length, int squares[])", "docstring": {"en": "The task is to determine if it is possible to assemble the wooden squares from n buckets, where each bucket contains $a_i$ squares with a side length of 1, into a single larger square.\nInput: length of list, array of numbers\n    >>> Is_Square(1, (int[]){9})\n    1\n", "sq": "Detyra është të përcaktohet nëse është e mundur të montohen katrorët prej druri nga n kovë, ku secila kovë përmban $a_i$ katrorë me një gjatësi anësore prej 1, në një katror më të madh.\nHyrja: gjatësia e listës, vargu i numrave\n    >>> Is_Square(1, (int[]){9})\n    1", "hy": "Առաջադրանքը որոշելն է՝ արդյոք հնարավոր է հավաքել փայտե քառակուսիներ n դույլերից, որտեղ յուրաքանչյուր դույլ պարունակում է $a_i$ կողքի երկարությամբ 1 քառակուսի, մեկ ավելի մեծ քառակուսի մեջ:\nՄուտք: ցուցակի երկարությունը, թվերի զանգված\n    >>> Is_Square(1, (int[]){9})\n    1", "bn": "কাজটি হল নির্ধারণ করা সম্ভব কিনা n বালতি থেকে কাঠের বর্গক্ষেত্রগুলি একত্রিত করা, যেখানে প্রতিটি বালতিতে $a_i$ সংখ্যা 1 পার্শ্ব দৈর্ঘ্যের বর্গক্ষেত্র রয়েছে, একটি বড় বর্গক্ষেত্রে।\nInput: তালিকার দৈর্ঘ্য, সংখ্যার অ্যারে\n    >>> Is_Square(1, (int[]){9})\n    1", "bg": "Задачата е да се определи дали е възможно да се сглобят дървените квадрати от n кофи, където всяка кофа съдържа $a_i$ квадрати със страна с дължина 1, в един по-голям квадрат.\nВход: дължина на списъка, масив от числа\n    >>> Is_Square(1, (int[]){9})\n    1", "zh": "任务是确定是否可以从 n 个桶中组装木制正方形，其中每个桶包含 $a_i$ 个边长为 1 的正方形，组装成一个更大的正方形。\n输入：列表长度，数字数组\n    >>> Is_Square(1, (int[]){9})\n    1", "fr": "La tâche consiste à déterminer s'il est possible d'assembler les carrés en bois à partir de n seaux, où chaque seau contient $a_i$ carrés avec une longueur de côté de 1, en un seul carré plus grand.\nEntrée : longueur de la liste, tableau de nombres\n    >>> Is_Square(1, (int[]){9})\n    1", "de": "Die Aufgabe besteht darin, festzustellen, ob es möglich ist, die Holzquadrate aus n Eimern, wobei jeder Eimer $a_i$ Quadrate mit einer Seitenlänge von 1 enthält, zu einem einzigen größeren Quadrat zusammenzusetzen.\nEingabe: Länge der Liste, Zahlenarray\n    >>> Is_Square(1, (int[]){9})\n    1", "ha": "Manufar ita ce tantance ko yana yiwuwa a tara murabba'ai na katako daga kwanduna n, inda kowanne kwando ya ƙunshi $a_i$ murabba'ai tare da tsawon gefe 1, cikin babban murabba'i guda ɗaya.\nShigarwa: tsawon jerin, jerin lambobi\n    >>> Is_Square(1, (int[]){9})\n    1", "hi": "कार्य यह निर्धारित करना है कि क्या n बाल्टियों से लकड़ी के वर्गों को इकट्ठा करना संभव है, जहाँ प्रत्येक बाल्टी में $a_i$ वर्ग होते हैं जिनकी भुजा की लंबाई 1 है, एक बड़े वर्ग में।\n\nइनपुट: सूची की लंबाई, संख्याओं की श्रृंखला\n    >>> Is_Square(1, (int[]){9})\n    1", "hu": "A feladat annak meghatározása, hogy lehetséges-e a fa négyzeteket n vödörből, ahol minden vödör $a_i$ darab, 1 oldalhosszúságú négyzetet tartalmaz, egyetlen nagyobb négyzetté összeállítani.\nBemenet: lista hossza, számok tömbje\n    >>> Is_Square(1, (int[]){9})\n    1", "es": "La tarea es determinar si es posible ensamblar los cuadrados de madera de n cubos, donde cada cubo contiene $a_i$ cuadrados con un lado de longitud 1, en un solo cuadrado más grande.\nEntrada: longitud de la lista, array de números\n    >>> Is_Square(1, (int[]){9})\n    1", "arb": "المهمة هي تحديد ما إذا كان من الممكن تجميع المربعات الخشبية من n دلاء، حيث يحتوي كل دلو على $a_i$ مربعات بطول ضلع 1، في مربع أكبر واحد.\n\nمدخلات: طول القائمة، مصفوفة الأرقام\n    >>> Is_Square(1, (int[]){9})\n    1", "sw": "Kazi ni kuamua kama inawezekana kuunganisha miraba ya mbao kutoka kwenye ndoo n, ambapo kila ndoo ina $a_i$ miraba yenye urefu wa upande 1, kuwa mraba mmoja mkubwa zaidi.\nIngizo: urefu wa orodha, safu ya namba\n    >>> Is_Square(1, (int[]){9})\n    1", "tr": "Görev, her bir kovada kenar uzunluğu 1 olan $a_i$ kare bulunan n kovadan ahşap kareleri tek bir büyük kareye monte etmenin mümkün olup olmadığını belirlemektir.\nGirdi: liste uzunluğu, sayıların dizisi\n    >>> Is_Square(1, (int[]){9})\n    1", "vi": "Nhiệm vụ là xác định xem có thể lắp ráp các hình vuông gỗ từ n xô, trong đó mỗi xô chứa $a_i$ hình vuông với chiều dài cạnh là 1, thành một hình vuông lớn hơn duy nhất hay không.\nĐầu vào: độ dài của danh sách, mảng số\n    >>> Is_Square(1, (int[]){9})\n    1", "id": "Tugasnya adalah untuk menentukan apakah mungkin untuk merakit kotak kayu dari n ember, di mana setiap ember berisi $a_i$ kotak dengan panjang sisi 1, menjadi satu kotak yang lebih besar.\nInput: panjang daftar, array angka\n    >>> Is_Square(1, (int[]){9})\n    1", "ja": "このタスクは、n個のバケツから木製の正方形を組み立てることが可能かどうかを判断することです。\n各バケツには、1の辺の長さを持つ$a_i$個の正方形が含まれています。それらを1つの大きな正方形に組み立てます。 \nタスクは、各バケツに1の辺の長さを持つ$a_i$個の正方形が含まれているn個のバケツから、1つの大きな正方形を組み立てることが可能かどうかを判断することです。\n\nInput: length of list, array of numbers  \n入力: リストの長さ、数値の配列\n\n    >>> Is_Square(1, (int[]){9})\n    1", "ko": "작업은 각 양동이에 한 변의 길이가 1인 $a_i$ 개의 정사각형이 들어 있는 n개의 양동이에서 나무 정사각형을 단일 더 큰 정사각형으로 조립할 수 있는지 여부를 결정하는 것입니다.\n입력: 리스트의 길이, 숫자의 배열\n    >>> Is_Square(1, (int[]){9})\n    1", "ml": "പ്രത്യക്ഷമായുള്ള പ്രവൃത്തിയാണ് n ബക്കറ്റുകളിൽ നിന്ന് മരക്കട്ടകൾ ഒന്നിച്ച് ചേർത്ത് ഒരു വലിയ ചതുരം ഉണ്ടാക്കാൻ കഴിയുമോ എന്ന് നിർണ്ണയിക്കുക,\nഎവിടെ ഓരോ ബക്കറ്റിലും 1 നീളമുള്ള $a_i$ ചതുരങ്ങൾ അടങ്ങിയിരിക്കുന്നു, ഒരു വലിയ ചതുരത്തിൽ ചേർക്കാൻ.\nപ്രവർത്തനം n ബക്കറ്റുകളിൽ നിന്ന് മര ചതുരങ്ങൾ ഒന്നിച്ച് ചേർക്കാൻ കഴിയുമോ എന്ന് നിർണ്ണയിക്കുകയാണ്, ഓരോ ബക്കറ്റിലും 1 വശ നീളമുള്ള $a_i$ ചതുരങ്ങൾ അടങ്ങിയിരിക്കുന്നു, ഒരു വലിയ ചതുരത്തിലേക്ക്.\nInput: list ന്റെ നീളം, സംഖ്യകളുടെ നിര\n    >>> Is_Square(1, (int[]){9})\n    1", "fa": "وظیفه این است که تعیین کنیم آیا ممکن است مربع‌های چوبی را از n سطل که هر سطل شامل $a_i$ مربع با طول ضلع 1 است، به یک مربع بزرگتر تبدیل کنیم یا خیر.\nورودی: طول لیست، آرایه‌ای از اعداد\n    >>> Is_Square(1, (int[]){9})\n    1"}}
{"task_id": "C/22", "prompt": {"en": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nGiven integers c and d, where a + b = c and a * b = d, find and return the possible value of a (a <= b). If there are multiple groups, output the group with the smallest a.\n    Parameters:\n    - c (int): The sum of a and b.\n    - d (int): The product of a and b.\n\n    Returns:\n    Optional[int]: A possible value of a. Returns -1 if valid values do not exist,\n\\\n    >>> find_integers(7,11)\n    -1\n*/\nint find_integers(int c, int d)", "sq": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDuke pasur parasysh numrat e plotë c dhe d, ku a + b = c dhe a * b = d, gjeni dhe ktheni vlerën e mundshme të a (a <= b). Nëse ka grupe të shumta, shfaqni grupin me vlerën më të vogël të a.\n    Parametrat:\n    - c (int): Shuma e a dhe b.\n    - d (int): Produkti i a dhe b.\n\n    Kthen:\n    Optional[int]: Një vlerë e mundshme e a. Kthen -1 nëse vlerat e vlefshme nuk ekzistojnë,\n\\\n    >>> find_integers(7,11)\n    -1\n*/\nint find_integers(int c, int d)", "hy": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nՏրված են ամբողջ թվեր c և d, որտեղ a + b = c և a * b = d, գտնել և վերադարձնել a-ի հնարավոր արժեքը (a <= b): Եթե կան բազմաթիվ խմբեր, արտածել խումբը ամենափոքր a-ով:\n    Պարամետրեր:\n    - c (int): a-ի և b-ի գումարը:\n    - d (int): a-ի և b-ի արտադրյալը:\n\n    Վերադարձնում է:\n    Optional[int]: a-ի հնարավոր արժեքը: Վերադարձնում է -1, եթե վավեր արժեքներ չկան,\n\\\n    >>> find_integers(7,11)\n    -1\n*/\nint find_integers(int c, int d)", "bn": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nপ্রদত্ত পূর্ণসংখ্যা c এবং d, যেখানে a + b = c এবং a * b = d, a এর সম্ভাব্য মান খুঁজে বের করুন এবং ফেরত দিন (a <= b)। যদি একাধিক গ্রুপ থাকে, তবে সবচেয়ে ছোট a সহ গ্রুপটি আউটপুট করুন।\n    প্যারামিটার:\n    - c (int): a এবং b এর যোগফল।\n    - d (int): a এবং b এর গুণফল।\n\n    রিটার্ন:\n    Optional[int]: a এর একটি সম্ভাব্য মান। বৈধ মান বিদ্যমান না থাকলে -1 ফেরত দেয়,\n\\\n    >>> find_integers(7,11)\n    -1\n*/\nint find_integers(int c, int d)", "bg": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nДадени са цели числа c и d, където a + b = c и a * b = d, намерете и върнете възможната стойност на a (a <= b). Ако има множество групи, изведете групата с най-малката a.\n    Параметри:\n    - c (int): Сумата на a и b.\n    - d (int): Произведението на a и b.\n\n    Връща:\n    Optional[int]: Възможна стойност на a. Връща -1, ако не съществуват валидни стойности,\n\\\n    >>> find_integers(7,11)\n    -1\n*/\nint find_integers(int c, int d)", "zh": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n给定整数 c 和 d，其中 a + b = c 且 a * b = d，找到并返回 a 的可能值 (a <= b)。如果有多个组合，输出 a 最小的组合。\n    参数:\n    - c (int): a 和 b 的和。\n    - d (int): a 和 b 的积。\n\n    返回:\n    Optional[int]: a 的可能值。如果不存在有效值，则返回 -1。\n\n    >>> find_integers(7,11)\n    -1\n*/\nint find_integers(int c, int d)", "fr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nÉtant donnés les entiers c et d, où a + b = c et a * b = d, trouver et retourner la valeur possible de a (a <= b). S'il existe plusieurs groupes, afficher le groupe avec le plus petit a.\n    Paramètres :\n    - c (int) : La somme de a et b.\n    - d (int) : Le produit de a et b.\n\n    Renvoie :\n    Optional[int] : Une valeur possible de a. Renvoie -1 si des valeurs valides n'existent pas,\n\\\n    >>> find_integers(7,11)\n    -1\n*/\nint find_integers(int c, int d)", "de": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nGegeben sind ganze Zahlen c und d, wobei a + b = c und a * b = d. Finde und gib den möglichen Wert von a zurück (a <= b). Wenn es mehrere Gruppen gibt, gib die Gruppe mit dem kleinsten a aus.\n    Parameter:\n    - c (int): Die Summe von a und b.\n    - d (int): Das Produkt von a und b.\n\n    Rückgabe:\n    Optional[int]: Ein möglicher Wert von a. Gibt -1 zurück, wenn keine gültigen Werte existieren,\n\\\n    >>> find_integers(7,11)\n    -1\n*/\nint find_integers(int c, int d)", "ha": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nAn ba lambobi c da d, inda a + b = c kuma a * b = d, nemo kuma dawo da yiwuwar darajar a (a <= b). Idan akwai kungiyoyi da dama, fitar da kungiyar da ke da karamin a.\n    Sigogi:\n    - c (int): Jimillar a da b.\n    - d (int): Samfurin a da b.\n\n    Returns:\n    Optional[int]: Yiwuwar darajar a. Yana dawowa -1 idan babu ingantattun ƙimomi,\n\\\n    >>> find_integers(7,11)\n    -1\n*/\nint find_integers(int c, int d)", "hi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nदिए गए पूर्णांक c और d के लिए, जहाँ a + b = c और a * b = d, a का संभव मान खोजें और लौटाएँ (a <= b)। यदि कई समूह हैं, तो सबसे छोटे a वाले समूह को आउटपुट करें।\n    पैरामीटर्स:\n    - c (int): a और b का योग।\n    - d (int): a और b का गुणनफल।\n\n    रिटर्न्स:\n    Optional[int]: a का एक संभव मान। यदि मान्य मान मौजूद नहीं हैं, तो -1 लौटाता है।\n\n    >>> find_integers(7,11)\n    -1\n*/\nint find_integers(int c, int d)", "hu": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nAdottak a c és d egész számok, ahol a + b = c és a * b = d, találja meg és adja vissza a lehetséges a értéket (a <= b). Ha több csoport is van, adja vissza azt a csoportot, amelyikben a legkisebb az a.\n    Paraméterek:\n    - c (int): Az a és b összege.\n    - d (int): Az a és b szorzata.\n\n    Visszatérési érték:\n    Optional[int]: Egy lehetséges a érték. -1-et ad vissza, ha nem léteznek érvényes értékek.\n\n    >>> find_integers(7,11)\n    -1\n*/\nint find_integers(int c, int d)", "es": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDado los enteros c y d, donde a + b = c y a * b = d, encuentra y devuelve el valor posible de a (a <= b). Si hay múltiples grupos, muestra el grupo con el menor a.\n    Parámetros:\n    - c (int): La suma de a y b.\n    - d (int): El producto de a y b.\n\n    Devuelve:\n    Optional[int]: Un valor posible de a. Devuelve -1 si no existen valores válidos.\n\n    >>> find_integers(7,11)\n    -1\n*/\nint find_integers(int c, int d)", "arb": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nبالنظر إلى الأعداد الصحيحة c و d، حيث a + b = c و a * b = d، ابحث وأعد القيمة الممكنة لـ a (a <= b). إذا كانت هناك مجموعات متعددة، قم بإخراج المجموعة التي تحتوي على أصغر a.\n    المعاملات:\n    - c (int): مجموع a و b.\n    - d (int): حاصل ضرب a و b.\n\n    يعيد:\n    Optional[int]: قيمة ممكنة لـ a. يعيد -1 إذا لم تكن هناك قيم صالحة موجودة،\n\\\n    >>> find_integers(7,11)\n    -1\n*/\nint find_integers(int c, int d)", "sw": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nKwa kupewa nambari kamili c na d, ambapo a + b = c na a * b = d, pata na rudisha thamani inayowezekana ya a (a <= b). Ikiwa kuna makundi mengi, toa kundi lenye a ndogo zaidi.\n    Vigezo:\n    - c (int): Jumla ya a na b.\n    - d (int): Bidhaa ya a na b.\n\n    Inarudisha:\n    Optional[int]: Thamani inayowezekana ya a. Inarudisha -1 ikiwa thamani halali hazipo,\n\\\n    >>> find_integers(7,11)\n    -1\n*/\nint find_integers(int c, int d)", "tr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nVerilen tamsayılar c ve d için, burada a + b = c ve a * b = d, a'nın olası değerini bulun ve döndürün (a <= b). Birden fazla grup varsa, en küçük a'ya sahip grubu çıkışlayın.\n    Parametreler:\n    - c (int): a ve b'nin toplamı.\n    - d (int): a ve b'nin çarpımı.\n\n    Döndürür:\n    Optional[int]: a'nın olası bir değeri. Geçerli değerler yoksa -1 döndürür.\n\\\n    >>> find_integers(7,11)\n    -1\n*/\nint find_integers(int c, int d)", "vi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCho các số nguyên c và d, trong đó a + b = c và a * b = d, tìm và trả về giá trị có thể của a (a <= b). Nếu có nhiều nhóm, xuất nhóm có a nhỏ nhất.\n    Tham số:\n    - c (int): Tổng của a và b.\n    - d (int): Tích của a và b.\n\n    Trả về:\n    Optional[int]: Một giá trị có thể của a. Trả về -1 nếu không tồn tại giá trị hợp lệ,\n\\\n    >>> find_integers(7,11)\n    -1\n*/\nint find_integers(int c, int d)", "id": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDiberikan bilangan bulat c dan d, di mana a + b = c dan a * b = d, temukan dan kembalikan nilai yang mungkin dari a (a <= b). Jika ada beberapa kelompok, keluarkan kelompok dengan a terkecil.\n    Parameter:\n    - c (int): Jumlah dari a dan b.\n    - d (int): Hasil kali dari a dan b.\n\n    Mengembalikan:\n    Optional[int]: Nilai yang mungkin dari a. Mengembalikan -1 jika nilai yang valid tidak ada,\n\\\n    >>> find_integers(7,11)\n    -1\n*/\nint find_integers(int c, int d)", "ja": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n整数 c と d が与えられたとき、a + b = c および a * b = d となる a の可能な値を見つけて返します (a <= b)。複数のグループがある場合は、最小の a を持つグループを出力します。\n    パラメータ:\n    - c (int): a と b の合計。\n    - d (int): a と b の積。\n\n    戻り値:\n    Optional[int]: a の可能な値。 有効な値が存在しない場合は -1 を返します。\n\\\n    >>> find_integers(7,11)\n    -1\n*/\nint find_integers(int c, int d)\n", "ko": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n정수 c와 d가 주어졌을 때, 여기서 a + b = c이고 a * b = d, a의 가능한 값을 찾고 반환합니다 (a <= b). 여러 그룹이 있는 경우, a가 가장 작은 그룹을 출력합니다.\n    매개변수:\n    - c (int): a와 b의 합.\n    - d (int): a와 b의 곱.\n\n    반환:\n    Optional[int]: a의 가능한 값. 유효한 값이 존재하지 않으면 -1을 반환합니다.\n\\\n    >>> find_integers(7,11)\n    -1\n*/\nint find_integers(int c, int d)\n", "ml": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nഇൻറീജറുകൾ c, d എന്നിവ നൽകിയിരിക്കുന്നു, ഇവിടെയായി a + b = c കൂടാതെ a * b = d, a (a <= b) യുടെ സാധ്യമായ മൂല്യം കണ്ടെത്തി തിരികെ നൽകുക. നിരവധി ഗ്രൂപ്പുകൾ ഉണ്ടെങ്കിൽ, ഏറ്റവും ചെറിയ a ഉള്ള ഗ്രൂപ്പ് ഔട്ട്പുട്ട് ചെയ്യുക.\n    പാരാമീറ്ററുകൾ:\n    - c (int): a, b എന്നിവയുടെ തുക.\n    - d (int): a, b എന്നിവയുടെ ഗുണഫലം.\n\n    റിട്ടേൺസ്:\n    ഓപ്ഷണൽ[int]: a യുടെ സാധ്യമായ മൂല്യം. സാധുവായ മൂല്യങ്ങൾ നിലവിലില്ലെങ്കിൽ -1 റിട്ടേൺ ചെയ്യുന്നു,\n\\\n    >>> find_integers(7,11)\n    -1\n*/\nint find_integers(int c, int d)", "fa": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nاعداد صحیح c و d داده شده‌اند، که در آن a + b = c و a * b = d، مقدار ممکن a را پیدا کرده و برگردانید (a <= b). اگر گروه‌های متعددی وجود دارند، گروهی با کوچکترین a را خروجی دهید.\n    پارامترها:\n    - c (int): مجموع a و b.\n    - d (int): حاصل‌ضرب a و b.\n\n    بازگشت:\n    Optional[int]: مقدار ممکن a. اگر مقادیر معتبر وجود نداشته باشند، -1 را برمی‌گرداند.\n\\\n    >>> find_integers(7,11)\n    -1\n*/\nint find_integers(int c, int d)\n"}, "canonical_solution": "{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i;\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}", "instruction": {"en": "int find_integers(int c, int d)\n{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i;\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "sq": "int find_integers(int c, int d)\n{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i;\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrale (docstring) të kodit C në shqip duke përdorur maksimumi 500 karaktere.", "hy": "int find_integers(int c, int d)\n{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i;\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}\n\nՏվեք C կոդի հակիրճ բնութագրումը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "int find_integers(int c, int d)\n{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i;\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}\n\nসি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলা ভাষায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।", "bg": "int find_integers(int c, int d)\n{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i;\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, използвайки не повече от 500 знака.", "zh": "int find_integers(int c, int d)\n{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i;\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}\n\n请用不超过500个字符的中文，为以下C代码提供简洁的自然语言描述（文档字符串）。", "fr": "int find_integers(int c, int d)\n{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i;\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.", "de": "int find_integers(int c, int d)\n{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i;\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "int find_integers(int c, int d)\n{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i;\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar C a cikin Hausa ta amfani da haruffa 500 kacal.", "hi": "int find_integers(int c, int d)\n{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i;\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}\n\nC कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।", "hu": "int find_integers(int c, int d)\n{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i;\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben.", "es": "int find_integers(int c, int d)\n{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i;\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando como máximo 500 caracteres.", "arb": "int find_integers(int c, int d)\n{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i;\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "int find_integers(int c, int d)\n{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i;\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "int find_integers(int c, int d)\n{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i;\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}\n\nC kodunun işlevselliğini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe olarak yazılmalıdır.", "vi": "int find_integers(int c, int d)\n{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i;\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã C bằng tiếng Việt với tối đa 500 ký tự.", "id": "int find_integers(int c, int d)\n{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i;\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode C dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "int find_integers(int c, int d)\n{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i;\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}\n\nC コードの簡単な自然言語による説明 (docstring) を英語で最大 500 文字まで入力してください。", "ko": "int find_integers(int c, int d)\n{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i;\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}\n\nC 코드의 동작을 설명하는 간결한 자연어 설명(docstring)을 한국어로 작성하세요. 최대 500자까지 가능합니다.", "ml": "int find_integers(int c, int d)\n{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i;\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}\n\nസീ കോഡിന് 500 അക്ഷരങ്ങളിൽ കൂടുതൽ അല്ലാത്ത ഒരു സംക്ഷിപ്ത സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) മലയാളത്തിൽ നൽകുക.", "fa": "int find_integers(int c, int d)\n{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i;\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}\n\nتوضیح مختصر و طبیعی (docstring) از کد C به زبان فارسی ارائه دهید که حداکثر ۵۰۰ کاراکتر باشد."}, "level": "", "test": "int main() {\n    assert(find_integers(5, 6) == 2);\n    assert(find_integers(6, 9) == 3);\n    assert(find_integers(7, 12) == 3);\n    assert(find_integers(7, 11) == -1);\n    assert(find_integers(9, 8) == 1);\n    assert(find_integers(10, 25) == 5);\n    assert(find_integers(10000, 8765) == -1);\n\n    \n\n    return 0;\n}", "entry_point": "find_integers", "signature": "int find_integers(int c, int d)", "docstring": {"en": "Given integers c and d, where a + b = c and a * b = d, find and return the possible value of a (a <= b). If there are multiple groups, output the group with the smallest a.\n    Parameters:\n    - c (int): The sum of a and b.\n    - d (int): The product of a and b.\n\n    Returns:\n    Optional[int]: A possible value of a. Returns -1 if valid values do not exist,\n\n    >>> find_integers(7,11)\n    -1\n", "sq": "Duke pasur parasysh numrat e plotë c dhe d, ku a + b = c dhe a * b = d, gjeni dhe ktheni vlerën e mundshme të a (a <= b). Nëse ka grupe të shumta, jepni grupin me vlerën më të vogël të a.\n    \n    Parametrat:\n    - c (int): Shuma e a dhe b.\n    - d (int): Produkti i a dhe b.\n\n    Kthen:\n    Optional[int]: Një vlerë e mundshme e a. Kthen -1 nëse vlerat e vlefshme nuk ekzistojnë,\n\n    >>> find_integers(7,11)\n    -1", "hy": "Տրված են ամբողջ թվեր c և d, որտեղ a + b = c և a * b = d, գտնել և վերադարձնել a-ի հնարավոր արժեքը (a <= b): Եթե կան բազմաթիվ խմբեր, վերադարձնել այն խումբը, որտեղ a-ն ամենափոքրն է:\n    \n    Պարամետրեր:\n    - c (int): a-ի և b-ի գումարը:\n    - d (int): a-ի և b-ի արտադրյալը:\n\n    Վերադարձնում է:\n    Optional[int]: a-ի հնարավոր արժեքը: Վերադարձնում է -1, եթե վավեր արժեքներ չեն գոյություն ունենում,\n\n    >>> find_integers(7,11)\n    -1", "bn": "প্রদত্ত পূর্ণসংখ্যা c এবং d এর জন্য, যেখানে a + b = c এবং a * b = d, a এর সম্ভাব্য মান খুঁজে বের করুন এবং ফেরত দিন (a <= b)। যদি একাধিক গোষ্ঠী থাকে, তাহলে সবচেয়ে ছোট a সহ গোষ্ঠীটি আউটপুট করুন।\n    \n    Parameters:\n    - c (int): a এবং b এর যোগফল।\n    - d (int): a এবং b এর গুণফল।\n\n    Returns:\n    Optional[int]: a এর একটি সম্ভাব্য মান। বৈধ মান বিদ্যমান না থাকলে -1 ফেরত দেয়,\n\n    >>> find_integers(7,11)\n    -1", "bg": "Дадени са цели числа c и d, където a + b = c и a * b = d, намерете и върнете възможната стойност на a (a <= b). Ако има множество групи, изведете групата с най-малката a.\n    Параметри:\n    - c (int): Сумата на a и b.\n    - d (int): Произведението на a и b.\n\n    Връща:\n    Optional[int]: Възможна стойност на a. Връща -1, ако не съществуват валидни стойности.\n\n    >>> find_integers(7,11)\n    -1", "zh": "给定整数 c 和 d，其中 a + b = c 且 a * b = d，找出并返回可能的 a 的值（a <= b）。如果有多个组合，输出 a 最小的组合。\n    \n    参数:\n    - c (int): a 和 b 的和。\n    - d (int): a 和 b 的积。\n\n    返回:\n    Optional[int]: a 的可能值。如果不存在有效值，则返回 -1。\n\n    >>> find_integers(7,11)\n    -1", "fr": "Étant donné des entiers c et d, où a + b = c et a * b = d, trouver et retourner la valeur possible de a (a <= b). S'il y a plusieurs groupes, afficher le groupe avec le plus petit a.\n    Paramètres:\n    - c (int): La somme de a et b.\n    - d (int): Le produit de a et b.\n\n    Renvoie:\n    Optional[int]: Une valeur possible de a. Renvoie -1 si des valeurs valides n'existent pas,\n\n    >>> find_integers(7,11)\n    -1", "de": "Gegeben sind ganze Zahlen c und d, wobei a + b = c und a * b = d. Finde und gib den möglichen Wert von a zurück (a <= b). Wenn es mehrere Gruppen gibt, gib die Gruppe mit dem kleinsten a aus.\n    \n    Parameter:\n    - c (int): Die Summe von a und b.\n    - d (int): Das Produkt von a und b.\n\n    Rückgabe:\n    Optional[int]: Ein möglicher Wert von a. Gibt -1 zurück, wenn keine gültigen Werte existieren,\n\n    >>> find_integers(7,11)\n    -1", "ha": "An ba da lambobin c da d, inda a + b = c kuma a * b = d, nemo kuma dawo da yiwuwar ƙimar a (a <= b). Idan akwai rukuni da yawa, fitar da rukunin da ke da ƙaramin a.\n    \n    Sigogi:\n    - c (int): Jimillar a da b.\n    - d (int): Samfurin a da b.\n\n    Komawa:\n    Optional[int]: Yiwuwar ƙimar a. Yana dawowa -1 idan ƙimomi masu inganci ba su wanzu,\n\n    >>> find_integers(7,11)\n    -1", "hi": "दिए गए पूर्णांक c और d, जहाँ a + b = c और a * b = d, a का संभावित मान खोजें और लौटाएं (a <= b)। यदि कई समूह हैं, तो सबसे छोटे a वाले समूह को आउटपुट करें।\n    \n    पैरामीटर्स:\n    - c (int): a और b का योग।\n    - d (int): a और b का गुणनफल।\n\n    रिटर्न्स:\n    Optional[int]: a का एक संभावित मान। यदि मान्य मान मौजूद नहीं हैं तो -1 लौटाता है,\n\n    >>> find_integers(7,11)\n    -1", "hu": "Adott c és d egész számok, ahol a + b = c és a * b = d, találja meg és adja vissza a lehetséges a értéket (a <= b). Ha több csoport is van, adja vissza azt a csoportot, ahol a a legkisebb.\n    Paraméterek:\n    - c (int): a és b összege.\n    - d (int): a és b szorzata.\n\n    Visszatérési érték:\n    Optional[int]: a lehetséges a érték. -1-et ad vissza, ha nem léteznek érvényes értékek.\n\n    >>> find_integers(7,11)\n    -1", "es": "Dado los enteros c y d, donde a + b = c y a * b = d, encuentra y devuelve el valor posible de a (a <= b). Si hay múltiples grupos, devuelve el grupo con el menor a.\n    Parámetros:\n    - c (int): La suma de a y b.\n    - d (int): El producto de a y b.\n\n    Devuelve:\n    Optional[int]: Un valor posible de a. Devuelve -1 si no existen valores válidos.\n\n    >>> find_integers(7,11)\n    -1", "arb": "المعطى عددان صحيحان c و d، حيث أن a + b = c و a * b = d، ابحث وأرجع القيمة الممكنة لـ a (حيث a <= b). إذا كانت هناك مجموعات متعددة، قم بإخراج المجموعة ذات القيمة الأصغر لـ a.\n    المعطيات:\n    - c (int): مجموع a و b.\n    - d (int): حاصل ضرب a و b.\n\n    المخرجات:\n    Optional[int]: قيمة ممكنة لـ a. يرجع -1 إذا لم تكن هناك قيم صالحة موجودة.\n\n    >>> find_integers(7,11)\n    -1", "sw": "Given integers c and d, ambapo a + b = c na a * b = d, tafuta na rudisha thamani inayowezekana ya a (a <= b). Ikiwa kuna makundi mengi, toa kundi lenye a ndogo zaidi.\n    Parameters:\n    - c (int): Jumla ya a na b.\n    - d (int): Bidhaa ya a na b.\n\n    Returns:\n    Optional[int]: Thamani inayowezekana ya a. Inarudisha -1 ikiwa thamani halali hazipo,\n\n    >>> find_integers(7,11)\n    -1", "tr": "Verilen tamsayılar c ve d için, burada a + b = c ve a * b = d, a'nın olası değerini bulun ve döndürün (a <= b). Birden fazla grup varsa, en küçük a'ya sahip grubu çıktılayın.\n    Parametreler:\n    - c (int): a ve b'nin toplamı.\n    - d (int): a ve b'nin çarpımı.\n\n    Döndürür:\n    Optional[int]: a'nın olası bir değeri. Geçerli değerler yoksa -1 döner.\n\n    >>> find_integers(7,11)\n    -1", "vi": "Cho các số nguyên c và d, trong đó a + b = c và a * b = d, tìm và trả về giá trị có thể có của a (a <= b). Nếu có nhiều nhóm, xuất nhóm có a nhỏ nhất.\n    Tham số:\n    - c (int): Tổng của a và b.\n    - d (int): Tích của a và b.\n\n    Trả về:\n    Optional[int]: Một giá trị có thể có của a. Trả về -1 nếu không tồn tại giá trị hợp lệ,\n\n    >>> find_integers(7,11)\n    -1", "id": "Diberikan bilangan bulat c dan d, di mana a + b = c dan a * b = d, temukan dan kembalikan nilai a yang mungkin (a <= b). Jika ada beberapa kelompok, keluarkan kelompok dengan a terkecil.\n    \n    Parameter:\n    - c (int): Jumlah dari a dan b.\n    - d (int): Hasil kali dari a dan b.\n\n    Mengembalikan:\n    Optional[int]: Nilai a yang mungkin. Mengembalikan -1 jika nilai yang valid tidak ada,\n\n    >>> find_integers(7,11)\n    -1", "ja": "整数 c と d が与えられたとき、ここで a + b = c および a * b = d であるような a の可能な値を見つけて返します (a <= b)。複数のグループがある場合は、a が最小のグループを出力します。\n    パラメータ:\n    - c (int): a と b の合計。\n    - d (int): a と b の積。\n\n    戻り値:\n    Optional[int]: a の可能な値。 有効な値が存在しない場合は -1 を返します。\n\n    >>> find_integers(7,11)\n    -1", "ko": "정수 c와 d가 주어졌을 때, 여기서 a + b = c이고 a * b = d인 a의 가능한 값을 찾고 반환합니다 (a <= b). 여러 그룹이 있는 경우, a가 가장 작은 그룹을 출력합니다.\n    \n    매개변수:\n    - c (int): a와 b의 합.\n    - d (int): a와 b의 곱.\n\n    반환:\n    Optional[int]: a의 가능한 값. 유효한 값이 존재하지 않으면 -1을 반환합니다.\n\n    >>> find_integers(7,11)\n    -1", "ml": "ഇൻറീജറുകൾ c, d എന്നിവ നൽകിയിരിക്കുന്നു, ഇവിടെയായി a + b = c കൂടാതെ a * b = d, a (a <= b) യുടെ സാധ്യമായ മൂല്യം കണ്ടെത്തി തിരികെ നൽകുക. നിരവധി ഗ്രൂപ്പുകൾ ഉണ്ടെങ്കിൽ, ഏറ്റവും ചെറിയ a ഉള്ള ഗ്രൂപ്പ് ഔട്ട്പുട്ട് ചെയ്യുക.\n    \n    പാരാമീറ്ററുകൾ:\n    - c (int): a, b എന്നിവയുടെ ആകെക്കൂട്ടം.\n    - d (int): a, b എന്നിവയുടെ ഗുണഫലം.\n\n    മടക്കുന്നു:\n    Optional[int]: a യുടെ ഒരു സാധ്യമായ മൂല്യം. സാധുവായ മൂല്യങ്ങൾ നിലവിലില്ലെങ്കിൽ -1 മടക്കുന്നു,\n\n    >>> find_integers(7,11)\n    -1", "fa": "اعداد صحیح c و d داده شده‌اند، که در آن a + b = c و a * b = d، مقدار ممکن a را پیدا کرده و برگردانید (a <= b). اگر گروه‌های متعددی وجود دارند، گروهی با کوچکترین a را خروجی دهید.\n    پارامترها:\n    - c (int): مجموع a و b.\n    - d (int): حاصل‌ضرب a و b.\n\n    بازگشت:\n    Optional[int]: یک مقدار ممکن از a. اگر مقادیر معتبر وجود نداشته باشد، -1 برمی‌گرداند،\n\n    >>> find_integers(7,11)\n    -1"}}
{"task_id": "C/23", "prompt": {"en": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n/*\nCount the number of acute-angled triangles that can be formed by selecting any 3 edges out of a given set of edges.\n    \nArgs:\n- edges_count: The number of edges passed.\n- An arbitrary number of integer arguments representing the lengths of the edges.\n    \nReturns:\nint: The count of distinct acute-angled triangles that can be formed.\n    \nExamples:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n*/\nint count_acute_triangles(int edges_count, ...)", "sq": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n/*\nNumëron numrin e trekëndëshave me kënd të mprehtë që mund të formohen duke zgjedhur çdo 3 brinjë nga një grup i dhënë brinjësh.\n    \nArgumentet:\n- edges_count: Numri i brinjëve të dhëna.\n- Një numër arbitrar argumentesh të tipit integer që përfaqësojnë gjatësitë e brinjëve.\n    \nKthen:\nint: Numri i trekëndëshave të dallueshëm me kënd të mprehtë që mund të formohen.\n    \nShembuj:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n*/\nint count_acute_triangles(int edges_count, ...)", "hy": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n/*\nՀաշվել սուրանկյուն եռանկյունիների քանակը, որոնք կարող են կազմվել ընտրելով ցանկացած 3 կողերից տրված կողերի հավաքածուից:\n    \nԱրգումենտներ:\n- edges_count: Անցկացված կողերի քանակը:\n- Կողերի երկարությունները ներկայացնող ամբողջ թվային արգումենտների կամայական քանակ:\n    \nՎերադարձնում է:\nint: Տարբեր սուրանկյուն եռանկյունիների քանակը, որոնք կարող են կազմվել:\n    \nՕրինակներ:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n*/\nint count_acute_triangles(int edges_count, ...)", "bn": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n/*\nপ্রদত্ত প্রান্তের একটি সেট থেকে যেকোনো ৩টি প্রান্ত নির্বাচন করে কতগুলি তীক্ষ্ণ-কোণী ত্রিভুজ গঠন করা যেতে পারে তা গণনা করুন।\n    \nআর্গুমেন্টসমূহ:\n- edges_count: প্রেরিত প্রান্তের সংখ্যা।\n- প্রান্তের দৈর্ঘ্য উপস্থাপনকারী একটি ইচ্ছামত সংখ্যক পূর্ণসংখ্যা আর্গুমেন্ট।\n    \nফেরত দেয়:\nint: গঠিত হতে পারে এমন স্বতন্ত্র তীক্ষ্ণ-কোণী ত্রিভুজের সংখ্যা।\n    \nউদাহরণ:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n*/\nint count_acute_triangles(int edges_count, ...)", "bg": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n/*\nБрои броя на острите триъгълници, които могат да бъдат образувани чрез избиране на произволни 3 ръба от даден набор от ръбове.\n    \nАргументи:\n- edges_count: Броят на предадените ръбове.\n- Произволен брой цели числа, представляващи дължините на ръбовете.\n    \nВръща:\nint: Броят на различните остри триъгълници, които могат да бъдат образувани.\n    \nПримери:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n*/\nint count_acute_triangles(int edges_count, ...)", "zh": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n/*\n计算可以通过从给定的一组边中选择任意3条边形成的锐角三角形的数量。\n    \n参数：\n- edges_count: 传递的边的数量。\n- 任意数量的整数参数，表示边的长度。\n    \n返回：\nint: 可以形成的不同锐角三角形的数量。\n    \n示例：\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n*/\nint count_acute_triangles(int edges_count, ...)", "fr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n/*\nCompter le nombre de triangles aigus qui peuvent être formés en sélectionnant 3 arêtes parmi un ensemble donné d'arêtes.\n    \nArgs:\n- edges_count: Le nombre d'arêtes passées.\n- Un nombre arbitraire d'arguments entiers représentant les longueurs des arêtes.\n    \nReturns:\nint: Le nombre de triangles aigus distincts qui peuvent être formés.\n    \nExamples:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n*/\nint count_acute_triangles(int edges_count, ...)", "de": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n/*\nZählt die Anzahl der spitzwinkligen Dreiecke, die gebildet werden können, indem beliebige 3 Kanten aus einem gegebenen Satz von Kanten ausgewählt werden.\n    \nArgumente:\n- edges_count: Die Anzahl der übergebenen Kanten.\n- Eine beliebige Anzahl von ganzzahligen Argumenten, die die Längen der Kanten darstellen.\n    \nRückgabewert:\nint: Die Anzahl der verschiedenen spitzwinkligen Dreiecke, die gebildet werden können.\n    \nBeispiele:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n*/\nint count_acute_triangles(int edges_count, ...)", "ha": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n/*\nƘirga adadin kusurwoyi masu kaifi waɗanda za a iya samarwa ta hanyar zaɓar kowane gefuna 3 daga cikin wani saiti na gefuna da aka bayar.\n    \nArgs:\n- edges_count: Yawan gefuna da aka bayar.\n- Wani adadi na hujjojin lamba waɗanda ke wakiltar tsawon gefuna.\n    \nReturns:\nint: Adadin kusurwoyi masu kaifi daban-daban waɗanda za a iya samarwa.\n    \nMisalai:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n*/\nint count_acute_triangles(int edges_count, ...)", "hi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n/*\nदिए गए किनारों के सेट में से किसी भी 3 किनारों का चयन करके बनने वाले तीव्र कोणीय त्रिभुजों की संख्या गिनें।\n\nआर्ग्स:\n- edges_count: पास किए गए किनारों की संख्या।\n- किनारों की लंबाई का प्रतिनिधित्व करने वाले पूर्णांक तर्कों की एक मनमानी संख्या।\n\nवापसी:\nint: बनने वाले विशिष्ट तीव्र कोणीय त्रिभुजों की संख्या।\n\nउदाहरण:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n*/\nint count_acute_triangles(int edges_count, ...)", "hu": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n/*\nSzámolja meg a hegyesszögű háromszögek számát, amelyek a megadott élek halmazából bármely 3 él kiválasztásával képezhetők.\n    \nArgumentumok:\n- edges_count: Az átadott élek száma.\n- Tetszőleges számú egész típusú argumentum, amelyek az élek hosszát képviselik.\n    \nVisszatérési érték:\nint: Az alkotható különböző hegyesszögű háromszögek száma.\n    \nPéldák:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n*/\nint count_acute_triangles(int edges_count, ...)", "es": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n/*\nCuenta el número de triángulos acutángulos que se pueden formar seleccionando cualquier 3 bordes de un conjunto dado de bordes.\n    \nArgs:\n- edges_count: El número de bordes pasados.\n- Un número arbitrario de argumentos enteros que representan las longitudes de los bordes.\n    \nReturns:\nint: La cantidad de triángulos acutángulos distintos que se pueden formar.\n    \nExamples:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n*/\nint count_acute_triangles(int edges_count, ...)", "arb": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n/*\nاحسب عدد المثلثات الحادة الزاوية التي يمكن تشكيلها عن طريق اختيار أي 3 أضلاع من مجموعة معينة من الأضلاع.\n\nالمعطيات:\n- edges_count: عدد الأضلاع الممررة.\n- عدد تعسفي من المعطيات الصحيحة التي تمثل أطوال الأضلاع.\n\nالقيم المعادة:\nint: عدد المثلثات الحادة الزاوية المختلفة التي يمكن تشكيلها.\n\nأمثلة:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n*/\nint count_acute_triangles(int edges_count, ...)", "sw": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n/*\nHesabu idadi ya pembetatu zenye pembe kali ambazo zinaweza kuundwa kwa kuchagua kingo 3 zozote kutoka kwenye seti iliyotolewa ya kingo.\n\nArgs:\n- edges_count: Idadi ya kingo zilizopitishwa.\n- Idadi isiyo na mpangilio ya hoja za nambari nzima zinazowakilisha urefu wa kingo.\n\nReturns:\nint: Idadi ya pembetatu tofauti zenye pembe kali ambazo zinaweza kuundwa.\n\nExamples:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n*/\nint count_acute_triangles(int edges_count, ...)", "tr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n/*\nVerilen bir kenar kümesinden herhangi 3 kenar seçilerek oluşturulabilecek dar açılı üçgenlerin sayısını sayın.\n    \nArgümanlar:\n- edges_count: Geçilen kenarların sayısı.\n- Kenarların uzunluklarını temsil eden keyfi sayıda tamsayı argümanı.\n    \nDöndürür:\nint: Oluşturulabilecek farklı dar açılı üçgenlerin sayısı.\n    \nÖrnekler:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n*/\nint count_acute_triangles(int edges_count, ...)", "vi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n/*\nĐếm số lượng tam giác nhọn có thể được tạo thành bằng cách chọn bất kỳ 3 cạnh nào từ một tập hợp các cạnh cho trước.\n    \nTham số:\n- edges_count: Số lượng cạnh được truyền vào.\n- Một số lượng tùy ý các đối số kiểu nguyên đại diện cho độ dài của các cạnh.\n    \nTrả về:\nint: Số lượng tam giác nhọn khác nhau có thể được tạo thành.\n    \nVí dụ:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n*/\nint count_acute_triangles(int edges_count, ...)", "id": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n/*\nMenghitung jumlah segitiga lancip yang dapat dibentuk dengan memilih 3 sisi dari sekumpulan sisi yang diberikan.\n    \nArgumen:\n- edges_count: Jumlah sisi yang diberikan.\n- Sejumlah argumen bilangan bulat yang mewakili panjang sisi-sisi tersebut.\n    \nMengembalikan:\nint: Jumlah segitiga lancip yang berbeda yang dapat dibentuk.\n    \nContoh:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n*/\nint count_acute_triangles(int edges_count, ...)\n", "ja": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n/*\n与えられた辺の集合から任意の3辺を選択して形成できる鋭角三角形の数を数えます。\n    \n引数:\n- edges_count: 渡された辺の数。\n- 辺の長さを表す任意の数の整数引数。\n    \n戻り値:\nint: 形成できる異なる鋭角三角形の数。\n    \n例:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n*/\nint count_acute_triangles(int edges_count, ...)\n", "ko": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n/*\n주어진 변 집합에서 임의의 3개의 변을 선택하여 만들 수 있는 예각 삼각형의 개수를 셉니다.\n    \n매개변수:\n- edges_count: 전달된 변의 수.\n- 변의 길이를 나타내는 임의의 정수 인수.\n    \n반환:\nint: 만들 수 있는 서로 다른 예각 삼각형의 개수.\n    \n예시:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n*/\nint count_acute_triangles(int edges_count, ...)\n", "ml": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n/*\nനൽകിയിരിക്കുന്ന എഡ്ജുകളുടെ ഒരു സെറ്റിൽ നിന്ന് 3 എഡ്ജുകൾ തിരഞ്ഞെടുക്കുന്നതിലൂടെ രൂപപ്പെടുത്താവുന്ന മൂർച്ചയുള്ള കോണുകളുള്ള ത്രികോണങ്ങളുടെ എണ്ണം കണക്കാക്കുക.\n    \nആർഗ്യുമെന്റുകൾ:\n- edges_count: പാസ്സായ എഡ്ജുകളുടെ എണ്ണം.\n- എഡ്ജുകളുടെ നീളങ്ങളെ പ്രതിനിധീകരിക്കുന്ന ഏതെങ്കിലും എണ്ണം മുഴുവൻ സംഖ്യാ ആർഗ്യുമെന്റുകൾ.\n    \nമടക്കിക്കൊടുക്കുന്നു:\nint: രൂപപ്പെടുത്താവുന്ന വ്യത്യസ്തമായ മൂർച്ചയുള്ള കോണങ്ങളുള്ള ത്രികോണങ്ങളുടെ എണ്ണം.\n    \nഉദാഹരണങ്ങൾ:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n*/\nint count_acute_triangles(int edges_count, ...)", "fa": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n/*\nتعداد مثلث‌های تیزگوشه‌ای که می‌توان با انتخاب هر ۳ ضلع از مجموعه‌ای از اضلاع تشکیل داد را بشمارید.\n    \nآرگومان‌ها:\n- edges_count: تعداد اضلاع داده شده.\n- تعداد دلخواهی از آرگومان‌های صحیح که طول اضلاع را نشان می‌دهند.\n    \nبازگشت:\nint: تعداد مثلث‌های تیزگوشه‌ی متمایزی که می‌توان تشکیل داد.\n    \nمثال‌ها:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n*/\nint count_acute_triangles(int edges_count, ...)\n"}, "canonical_solution": "{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}", "instruction": {"en": "int count_acute_triangles(int edges_count, ...)\n{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "sq": "int count_acute_triangles(int edges_count, ...)\n{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrale (docstring) të kodit C në shqip duke përdorur maksimumi 500 karaktere.", "hy": "int count_acute_triangles(int edges_count, ...)\n{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}\n\nՏվեք C կոդի համառոտ բնութագիրը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "int count_acute_triangles(int edges_count, ...)\n{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}\n\nসি কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।", "bg": "int count_acute_triangles(int edges_count, ...)\n{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, използвайки най-много 500 знака.", "zh": "int count_acute_triangles(int edges_count, ...)\n{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}\n\n请用中文为以下C代码提供一个简洁的自然语言描述（文档字符串），字数不超过500个字符。", "fr": "int count_acute_triangles(int edges_count, ...)\n{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.", "de": "int count_acute_triangles(int edges_count, ...)\n{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "int count_acute_triangles(int edges_count, ...)\n{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}\n\nBa da takaitaccen bayani a cikin yare na halitta (docstring) na lambar C cikin Hausa ta amfani da haruffa 500 kawai.", "hi": "int count_acute_triangles(int edges_count, ...)\n{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}\n\nC कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "int count_acute_triangles(int edges_count, ...)\n{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben.", "es": "int count_acute_triangles(int edges_count, ...)\n{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando como máximo 500 caracteres.", "arb": "int count_acute_triangles(int edges_count, ...)\n{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "int count_acute_triangles(int edges_count, ...)\n{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "int count_acute_triangles(int edges_count, ...)\n{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}\n\nC kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, Türkçe dilinde ve en fazla 500 karakterle sınırlı olmalıdır.", "vi": "int count_acute_triangles(int edges_count, ...)\n{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã C bằng tiếng Việt, sử dụng tối đa 500 ký tự.", "id": "int count_acute_triangles(int edges_count, ...)\n{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode C dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "int count_acute_triangles(int edges_count, ...)\n{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}\n\n以下のCコードの簡潔な自然言語による説明（ドックストリング）を日本語で500文字以内で提供してください。", "ko": "int count_acute_triangles(int edges_count, ...)\n{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}\n\nC 코드의 동작을 설명하는 간결한 자연어 설명(docstring)을 한국어로 작성하되, 최대 500자 이내로 작성하세요.", "ml": "int count_acute_triangles(int edges_count, ...)\n{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}\n\nസിയിൽ നൽകിയിരിക്കുന്ന കോഡിന്റെ സംക്ഷിപ്തമായ സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) മലയാളത്തിൽ 500 അക്ഷരങ്ങൾക്കുള്ളിൽ നൽകുക.", "fa": "int count_acute_triangles(int edges_count, ...)\n{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}\n\nتوضیح مختصر و طبیعی (docstring) از کد C به زبان فارسی ارائه دهید که حداکثر ۵۰۰ کاراکتر باشد."}, "level": "", "test": "int main()\n{\n    assert(count_acute_triangles(4, 1, 1, 1, 1) == 4);\n    assert(count_acute_triangles(3, 1, 2, 3) == 0);\n    // Additional tests to ensure correctness\n    assert(count_acute_triangles(5, 3, 4, 5, 7, 10) == 0);\n    assert(count_acute_triangles(6, 6, 8, 10, 5, 5, 5) == 4);\n    return 0;\n}", "entry_point": "count_acute_triangles", "signature": "int count_acute_triangles(int edges_count, ...)", "docstring": {"en": "Count the number of acute-angled triangles that can be formed by selecting any 3 edges out of a given set of edges.\n\nArgs:\n- edges_count: The number of edges passed.\n- An arbitrary number of integer arguments representing the lengths of the edges.\n\nReturns:\nint: The count of distinct acute-angled triangles that can be formed.\n\nExamples:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n", "sq": "Numëroni numrin e trekëndëshave me kënd të mprehtë që mund të formohen duke zgjedhur çdo 3 brinjë nga një grup i dhënë brinjësh.\n\nArgumentet:\n- edges_count: Numri i brinjëve të dhëna.\n- Një numër i pacaktuar argumentesh të tipit integer që përfaqësojnë gjatësitë e brinjëve.\n\nKthen:\nint: Numri i trekëndëshave të dallueshëm me kënd të mprehtë që mund të formohen.\n\nShembuj:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4", "hy": "Սուր անկյուններով եռանկյունների քանակը հաշվել, որոնք կարող են կազմվել ընտրելով ցանկացած 3 կողմեր տրված կողմերի հավաքածուից:\n\nԱրգումենտներ:\n- edges_count: Անցած կողմերի քանակը:\n- Կողմերի երկարությունները ներկայացնող ամբողջ թվային կամայական քանակի արգումենտներ:\n\nՎերադարձնում է:\nint: Սուր անկյուններով տարբեր եռանկյունների քանակը, որոնք կարող են կազմվել:\n\nՕրինակներ:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4", "bn": "তীক্ষ্ণ-কোণ বিশিষ্ট ত্রিভুজের সংখ্যা গণনা করুন যা একটি প্রদত্ত প্রান্তের সেট থেকে যেকোনো 3 প্রান্ত নির্বাচন করে গঠন করা যেতে পারে।\n\nআর্গস:\n- edges_count: প্রদত্ত প্রান্তের সংখ্যা।\n- প্রান্তের দৈর্ঘ্য উপস্থাপনকারী একটি নির্বিচারে সংখ্যক পূর্ণসংখ্যা আর্গুমেন্ট।\n\nরিটার্নস:\nint: গঠন করা যেতে পারে এমন পৃথক তীক্ষ্ণ-কোণ বিশিষ্ট ত্রিভুজের সংখ্যা।\n\nউদাহরণ:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4", "bg": "Бройте броя на острите триъгълници, които могат да бъдат образувани чрез избиране на произволни 3 ръба от даден набор от ръбове.\n\nАргументи:\n- edges_count: Броят на предадените ръбове.\n- Произволен брой цели аргументи, представляващи дължините на ръбовете.\n\nВръща:\nint: Броят на различните остри триъгълници, които могат да бъдат образувани.\n\nПримери:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4", "zh": "计算可以通过从给定的一组边中选择任意3条边来形成的锐角三角形的数量。\n\n参数：\n- edges_count: 传递的边的数量。\n- 任意数量的整数参数，表示边的长度。\n\n返回：\nint: 可以形成的不同锐角三角形的数量。\n\n示例：\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4", "fr": "Compter le nombre de triangles acutangles qui peuvent être formés en sélectionnant n'importe quels 3 côtés parmi un ensemble donné de côtés.\n\nArgs:\n- edges_count: Le nombre de côtés passés.\n- Un nombre arbitraire d'arguments entiers représentant les longueurs des côtés.\n\nReturns:\nint: Le nombre de triangles acutangles distincts qui peuvent être formés.\n\nExamples:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4", "de": "Zähle die Anzahl der spitzwinkligen Dreiecke, die gebildet werden können, indem beliebige 3 Kanten aus einer gegebenen Menge von Kanten ausgewählt werden.\n\nArgumente:\n- edges_count: Die Anzahl der übergebenen Kanten.\n- Eine beliebige Anzahl von Ganzzahlargumenten, die die Längen der Kanten darstellen.\n\nRückgabewert:\nint: Die Anzahl der unterschiedlichen spitzwinkligen Dreiecke, die gebildet werden können.\n\nBeispiele:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4", "ha": "Count adadin kusurwoyi masu kaifi waɗanda za a iya ƙirƙira ta hanyar zaɓar kowane gefuna 3 daga cikin wani saitin gefuna da aka bayar.\n\nArgs:\n- edges_count: Adadin gefuna da aka wuce.\n- Yawan hujjojin lamba masu zaman kansu waɗanda ke wakiltar tsawon gefuna.\n\nReturns:\nint: Adadin kusurwoyi masu kaifi na musamman waɗanda za a iya ƙirƙira.\n\nExamples:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4", "hi": "तीक्ष्ण कोण वाले त्रिभुजों की संख्या गिनें जो दिए गए किनारों के सेट में से किसी भी 3 किनारों का चयन करके बनाए जा सकते हैं।\n\nआर्ग्स:\n- edges_count: पास किए गए किनारों की संख्या।\n- किनारों की लंबाई का प्रतिनिधित्व करने वाले पूर्णांक तर्कों की एक मनमानी संख्या।\n\nरिटर्न्स:\nint: विशिष्ट तीक्ष्ण कोण वाले त्रिभुजों की संख्या जो बनाई जा सकती है।\n\nउदाहरण:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4", "hu": "Számolja meg a hegyesszögű háromszögek számát, amelyek a megadott élek bármely 3 élének kiválasztásával képezhetők.\n\nArgs:\n- edges_count: Az átadott élek száma.\n- Tetszőleges számú egész számú argumentum, amelyek az élek hosszát képviselik.\n\nReturns:\nint: Az alkotható különböző hegyesszögű háromszögek száma.\n\nExamples:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4", "es": "Contar el número de triángulos acutángulos que se pueden formar seleccionando cualquier 3 lados de un conjunto dado de lados.\n\nArgs:\n- edges_count: El número de lados pasados.\n- Un número arbitrario de argumentos enteros que representan las longitudes de los lados.\n\nReturns:\nint: La cantidad de triángulos acutángulos distintos que se pueden formar.\n\nExamples:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4", "arb": "احسب عدد المثلثات الحادة الزوايا التي يمكن تشكيلها عن طريق اختيار أي 3 حواف من مجموعة الحواف المعطاة.\n\nالمعطيات:\n- edges_count: عدد الحواف الممررة.\n- عدد تعسفي من المعطيات الصحيحة التي تمثل أطوال الحواف.\n\nالقيم المعادة:\nint: عدد المثلثات الحادة الزوايا المميزة التي يمكن تشكيلها.\n\nأمثلة:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4", "sw": "Hesabu idadi ya pembetatu zenye pembe kali ambazo zinaweza kuundwa kwa kuchagua pande 3 zozote kutoka kwenye seti iliyotolewa ya pande.\n\nArgs:\n- edges_count: Idadi ya pande zilizopitishwa.\n- Idadi isiyo ya kawaida ya hoja za nambari nzima zinazowakilisha urefu wa pande.\n\nReturns:\nint: Idadi ya pembetatu tofauti zenye pembe kali ambazo zinaweza kuundwa.\n\nExamples:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4", "tr": "Verilen bir kenar kümesinden herhangi 3 kenar seçilerek oluşturulabilecek dik açılı üçgenlerin sayısını sayın.\n\nArgs:\n- edges_count: Geçilen kenarların sayısı.\n- Kenarların uzunluklarını temsil eden rastgele sayıda tamsayı argümanı.\n\nReturns:\nint: Oluşturulabilecek farklı dik açılı üçgenlerin sayısı.\n\nÖrnekler:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4", "vi": "Đếm số lượng tam giác nhọn có thể được tạo thành bằng cách chọn bất kỳ 3 cạnh nào từ một tập hợp các cạnh đã cho.\n\nTham số:\n- edges_count: Số lượng cạnh được truyền vào.\n- Một số lượng bất kỳ các đối số kiểu số nguyên đại diện cho độ dài của các cạnh.\n\nTrả về:\nint: Số lượng tam giác nhọn khác nhau có thể được tạo thành.\n\nVí dụ:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4", "id": "Hitung jumlah segitiga lancip yang dapat dibentuk dengan memilih 3 sisi dari sekumpulan sisi yang diberikan.\n\nArgs:\n- edges_count: Jumlah sisi yang diberikan.\n- Sejumlah argumen bilangan bulat yang mewakili panjang sisi-sisi tersebut.\n\nReturns:\nint: Jumlah segitiga lancip yang berbeda yang dapat dibentuk.\n\nExamples:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4", "ja": "与えられたエッジのセットから任意の3つのエッジを選択することによって形成できる鋭角三角形の数を数えます。\n\n引数:\n- edges_count: 渡されたエッジの数。\n- エッジの長さを表す任意の数の整数引数。\n\n返り値:\nint: 形成できる異なる鋭角三角形の数。\n\n例:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4", "ko": "주어진 모서리 집합에서 임의의 3개의 모서리를 선택하여 형성할 수 있는 예각 삼각형의 수를 계산합니다.\n\n인수:\n- edges_count: 전달된 모서리의 수.\n- 모서리의 길이를 나타내는 임의의 개수의 정수 인수.\n\n반환:\nint: 형성할 수 있는 고유한 예각 삼각형의 수.\n\n예제:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4", "ml": "നൽകിയിരിക്കുന്ന എഡ്ജുകളുടെ ഒരു സെറ്റിൽ നിന്ന് 3 എഡ്ജുകൾ തിരഞ്ഞെടുക്കുന്നതിലൂടെ രൂപപ്പെടുത്താവുന്ന മൂർച്ചയുള്ള കോണുകളുള്ള ത്രികോണങ്ങളുടെ എണ്ണം കണക്കാക്കുക.\n\nArgs:\n- edges_count: നൽകിയിരിക്കുന്ന വശങ്ങളുടെ എണ്ണം.\n- വശങ്ങളുടെ നീളങ്ങൾ പ്രതിനിധീകരിക്കുന്ന ഏത് സംഖ്യയിലുള്ള പൂർണ്ണസംഖ്യാ ആർഗുമെന്റുകളും.\n\nReturns:\nint: രൂപീകരിക്കാവുന്ന വ്യത്യസ്തമായ മൂർച്ചയുള്ള കോണുകളുള്ള ത്രികോണങ്ങളുടെ എണ്ണം.\n\nExamples:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4", "fa": "تعداد مثلث‌های تیزگوشه‌ای را که می‌توان با انتخاب هر 3 ضلع از مجموعه‌ای از اضلاع تشکیل داد، بشمارید.\n\nآرگومان‌ها:\n- edges_count: تعداد اضلاعی که ارائه شده‌اند.\n- تعداد دلخواهی از آرگومان‌های عدد صحیح که طول اضلاع را نشان می‌دهند.\n\nبازگشت:\nint: تعداد مثلث‌های تیزگوشه متمایزی که می‌توان تشکیل داد.\n\nمثال‌ها:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4"}}
{"task_id": "C/24", "prompt": {"en": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/*\nReads an integer and a character, then returns them as a formatted string separated by a comma.\nParameters:\n- integer_value (int): The input integer.\n- char_value (char): The input character.\nReturns:\n- char*: A string containing the integer and character separated by a comma.\n>>> process_integer_and_char(234,H)\n\t234,H\n*/\nchar* process_integer_and_char(int integer_value, char char_value)", "sq": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/*\nLexon një numër të plotë dhe një karakter, pastaj i kthen ato si një varg i formatuar i ndarë nga një presje.\nParametrat:\n- integer_value (int): Numri i plotë i dhënë si hyrje.\n- char_value (char): Karakteri i dhënë si hyrje.\nKthen:\n- char*: Një varg që përmban numrin e plotë dhe karakterin të ndarë nga një presje.\n>>> process_integer_and_char(234,H)\n\t234,H\n*/\nchar* process_integer_and_char(int integer_value, char char_value)", "hy": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/*\nԿարդում է ամբողջ թիվ և սիմվոլ, ապա վերադարձնում է դրանք որպես ձևաչափված տող, որոնք բաժանված են ստորակետով:\nՊարամետրեր:\n- integer_value (int): Մուտքային ամբողջ թիվը:\n- char_value (char): Մուտքային սիմվոլը:\nՎերադարձնում է:\n- char*: Տող, որը պարունակում է ամբողջ թիվը և սիմվոլը, բաժանված ստորակետով:\n>>> process_integer_and_char(234,H)\n\t234,H\n*/\nchar* process_integer_and_char(int integer_value, char char_value)", "bn": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/*\nএকটি পূর্ণসংখ্যা এবং একটি অক্ষর পড়ে, তারপর সেগুলোকে একটি কমা দ্বারা পৃথক করা ফরম্যাটেড স্ট্রিং হিসেবে ফেরত দেয়।\nপ্যারামিটার:\n- integer_value (int): ইনপুট পূর্ণসংখ্যা।\n- char_value (char): ইনপুট অক্ষর।\nফেরত দেয়:\n- char*: একটি স্ট্রিং যা পূর্ণসংখ্যা এবং অক্ষরকে একটি কমা দ্বারা পৃথক করে ধারণ করে।\n>>> process_integer_and_char(234,H)\n\t234,H\n*/\nchar* process_integer_and_char(int integer_value, char char_value)", "bg": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/*\nЧете цяло число и символ, след което ги връща като форматиран низ, разделен със запетая.\nПараметри:\n- integer_value (int): Входното цяло число.\n- char_value (char): Входният символ.\nВръща:\n- char*: Низ, съдържащ цялото число и символа, разделени със запетая.\n>>> process_integer_and_char(234,H)\n\t234,H\n*/\nchar* process_integer_and_char(int integer_value, char char_value)", "zh": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/*\n读取一个整数和一个字符，然后将它们作为用逗号分隔的格式化字符串返回。\n参数：\n- integer_value (int): 输入的整数。\n- char_value (char): 输入的字符。\n返回：\n- char*: 一个包含整数和字符并用逗号分隔的字符串。\n>>> process_integer_and_char(234,H)\n\t234,H\n*/\nchar* process_integer_and_char(int integer_value, char char_value)", "fr": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/*\nLit un entier et un caractère, puis les renvoie sous forme de chaîne formatée séparée par une virgule.\nParamètres :\n- integer_value (int) : L'entier d'entrée.\n- char_value (char) : Le caractère d'entrée.\nRenvoie :\n- char* : Une chaîne contenant l'entier et le caractère séparés par une virgule.\n>>> process_integer_and_char(234,H)\n\t234,H\n*/\nchar* process_integer_and_char(int integer_value, char char_value)", "de": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/*\nLiest eine ganze Zahl und ein Zeichen ein und gibt sie dann als formatierte Zeichenkette getrennt durch ein Komma zurück.\nParameter:\n- integer_value (int): Die Eingabe-Ganzzahl.\n- char_value (char): Das Eingabe-Zeichen.\nRückgabewert:\n- char*: Eine Zeichenkette, die die Ganzzahl und das Zeichen durch ein Komma getrennt enthält.\n>>> process_integer_and_char(234,H)\n\t234,H\n*/\nchar* process_integer_and_char(int integer_value, char char_value)", "ha": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/*\nKaranta lamba mai cikakken adadi da kuma harafi, sannan ya mayar da su a matsayin jeren haruffa da aka raba su da alamar kwalliya.\nSigogi:\n- integer_value (int): Lambar da aka shigar.\n- char_value (char): Harafin da aka shigar.\nDawowa:\n- char*: Jeren haruffa da ke dauke da lambar da harafin da aka raba su da alamar kwalliya.\n>>> process_integer_and_char(234,H)\n\t234,H\n*/\nchar* process_integer_and_char(int integer_value, char char_value)", "hi": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/*\nएक पूर्णांक और एक वर्ण पढ़ता है, फिर उन्हें एक स्वरूपित स्ट्रिंग के रूप में अल्पविराम से अलग करके लौटाता है।\nपैरामीटर्स:\n- integer_value (int): इनपुट पूर्णांक।\n- char_value (char): इनपुट वर्ण।\nवापसी:\n- char*: एक स्ट्रिंग जिसमें पूर्णांक और वर्ण अल्पविराम से अलग होकर होते हैं।\n>>> process_integer_and_char(234,H)\n\t234,H\n*/\nchar* process_integer_and_char(int integer_value, char char_value)", "hu": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/*\nBeolvas egy egész számot és egy karaktert, majd visszaadja őket egy formázott, vesszővel elválasztott karakterláncként.\nParaméterek:\n- integer_value (int): A bemeneti egész szám.\n- char_value (char): A bemeneti karakter.\nVisszatér:\n- char*: Egy karakterlánc, amely az egész számot és a karaktert vesszővel elválasztva tartalmazza.\n>>> process_integer_and_char(234,H)\n\t234,H\n*/\nchar* process_integer_and_char(int integer_value, char char_value)", "es": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/*\nLee un entero y un carácter, luego los devuelve como una cadena formateada separada por una coma.\nParámetros:\n- integer_value (int): El entero de entrada.\n- char_value (char): El carácter de entrada.\nDevuelve:\n- char*: Una cadena que contiene el entero y el carácter separados por una coma.\n>>> process_integer_and_char(234,H)\n\t234,H\n*/\nchar* process_integer_and_char(int integer_value, char char_value)", "arb": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/*\nيقرأ عددًا صحيحًا وحرفًا، ثم يعيدهما كسلسلة منسقة مفصولة بفاصلة.\nالمعطيات:\n- integer_value (int): العدد الصحيح المدخل.\n- char_value (char): الحرف المدخل.\nالإرجاع:\n- char*: سلسلة تحتوي على العدد الصحيح والحرف مفصولين بفاصلة.\n>>> process_integer_and_char(234,H)\n\t234,H\n*/\nchar* process_integer_and_char(int integer_value, char char_value)", "sw": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/*\nHusoma nambari nzima na herufi, kisha huzirudisha kama kamba iliyopangwa ikitenganishwa na koma.\nVigezo:\n- integer_value (int): Nambari nzima ya ingizo.\n- char_value (char): Herufi ya ingizo.\nInarudisha:\n- char*: Kamba inayojumuisha nambari nzima na herufi ikitenganishwa na koma.\n>>> process_integer_and_char(234,H)\n\t234,H\n*/\nchar* process_integer_and_char(int integer_value, char char_value)", "tr": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/*\nBir tamsayı ve bir karakter okur, ardından bunları virgülle ayrılmış biçimlendirilmiş bir dize olarak döndürür.\nParametreler:\n- integer_value (int): Girdi tamsayısı.\n- char_value (char): Girdi karakteri.\nDöndürür:\n- char*: Tamsayı ve karakteri virgülle ayrılmış olarak içeren bir dize.\n>>> process_integer_and_char(234,H)\n\t234,H\n*/\nchar* process_integer_and_char(int integer_value, char char_value)", "vi": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/*\nĐọc một số nguyên và một ký tự, sau đó trả về chúng dưới dạng một chuỗi định dạng được ngăn cách bởi dấu phẩy.\nTham số:\n- integer_value (int): Số nguyên đầu vào.\n- char_value (char): Ký tự đầu vào.\nTrả về:\n- char*: Một chuỗi chứa số nguyên và ký tự được ngăn cách bởi dấu phẩy.\n>>> process_integer_and_char(234,H)\n\t234,H\n*/\nchar* process_integer_and_char(int integer_value, char char_value)", "id": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/*\nMembaca sebuah bilangan bulat dan sebuah karakter, kemudian mengembalikannya sebagai string terformat yang dipisahkan oleh koma.\nParameter:\n- integer_value (int): Bilangan bulat yang diinput.\n- char_value (char): Karakter yang diinput.\nMengembalikan:\n- char*: Sebuah string yang berisi bilangan bulat dan karakter yang dipisahkan oleh koma.\n>>> process_integer_and_char(234,H)\n\t234,H\n*/\nchar* process_integer_and_char(int integer_value, char char_value)", "ja": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/*\n整数と文字を読み取り、それらをカンマで区切ったフォーマットされた文字列として返します。\nパラメータ:\n- integer_value (int): 入力整数。\n- char_value (char): 入力文字。\n戻り値:\n- char*: 整数と文字をカンマで区切った文字列。\n>>> process_integer_and_char(234,H)\n\t234,H\n*/\nchar* process_integer_and_char(int integer_value, char char_value)", "ko": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/*\n정수와 문자를 읽은 후 쉼표로 구분된 형식의 문자열로 반환합니다.\n매개변수:\n- integer_value (int): 입력 정수.\n- char_value (char): 입력 문자.\n반환값:\n- char*: 정수와 문자가 쉼표로 구분된 문자열.\n>>> process_integer_and_char(234,H)\n\t234,H\n*/\nchar* process_integer_and_char(int integer_value, char char_value)", "ml": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/*\nഒരു പൂർണ്ണസംഖ്യയും ഒരു അക്ഷരവും വായിച്ച് അവയെ കോമയാൽ വേർതിരിച്ച ഫോർമാറ്റ് ചെയ്ത സ്ട്രിംഗായി തിരികെ നൽകുന്നു.\nപാരാമീറ്ററുകൾ:\n- integer_value (int): ഇൻപുട്ട് പൂർണ്ണസംഖ്യ.\n- char_value (char): ഇൻപുട്ട് അക്ഷരം.\nമടക്കിനൽകുന്നത്:\n- char*: കോമയാൽ വേർതിരിച്ച പൂർണ്ണസംഖ്യയും അക്ഷരവും അടങ്ങിയ ഒരു സ്ട്രിംഗ്.\n>>> process_integer_and_char(234,H)\n\t234,H\n*/\nchar* process_integer_and_char(int integer_value, char char_value)", "fa": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/*\nیک عدد صحیح و یک کاراکتر را می‌خواند و سپس آن‌ها را به‌صورت یک رشته قالب‌بندی شده که با کاما جدا شده‌اند، برمی‌گرداند.\nپارامترها:\n- integer_value (int): عدد صحیح ورودی.\n- char_value (char): کاراکتر ورودی.\nبرمی‌گرداند:\n- char*: یک رشته که شامل عدد صحیح و کاراکتر است که با کاما جدا شده‌اند.\n>>> process_integer_and_char(234,H)\n\t234,H\n*/\nchar* process_integer_and_char(int integer_value, char char_value)"}, "canonical_solution": "{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}", "instruction": {"en": "char* process_integer_and_char(int integer_value, char char_value)\n{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "sq": "char* process_integer_and_char(int integer_value, char char_value)\n{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C në shqip duke përdorur maksimumi 500 karaktere.", "hy": "char* process_integer_and_char(int integer_value, char char_value)\n{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}\n\nՏրամադրել C կոդի հակիրճ բնութագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "char* process_integer_and_char(int integer_value, char char_value)\n{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}\n\nসি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।", "bg": "char* process_integer_and_char(int integer_value, char char_value)\n{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, като използвате не повече от 500 символа.", "zh": "char* process_integer_and_char(int integer_value, char char_value)\n{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}\n\n请用最多500个字符的中文对该C代码提供简洁的自然语言描述（文档字符串）。", "fr": "char* process_integer_and_char(int integer_value, char char_value)\n{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.", "de": "char* process_integer_and_char(int integer_value, char char_value)\n{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen.", "ha": "char* process_integer_and_char(int integer_value, char char_value)\n{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}\n\nBa da taƙaitaccen bayani a cikin yaren halitta (docstring) na lambar C a Hausa ta amfani da haruffa 500 kawai.", "hi": "char* process_integer_and_char(int integer_value, char char_value)\n{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}\n\nC कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "char* process_integer_and_char(int integer_value, char char_value)\n{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben.", "es": "char* process_integer_and_char(int integer_value, char char_value)\n{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando como máximo 500 caracteres.", "arb": "char* process_integer_and_char(int integer_value, char char_value)\n{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى، على ألا يتجاوز 500 حرف.", "sw": "char* process_integer_and_char(int integer_value, char char_value)\n{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "char* process_integer_and_char(int integer_value, char char_value)\n{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}\n\nC kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama en fazla 500 karakter olmalıdır.", "vi": "char* process_integer_and_char(int integer_value, char char_value)\n{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã C bằng tiếng Việt với tối đa 500 ký tự.", "id": "char* process_integer_and_char(int integer_value, char char_value)\n{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode C dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "char* process_integer_and_char(int integer_value, char char_value)\n{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}\n\nCコードの内容を簡潔に説明する自然言語の記述（ドックストリング）を日本語で500文字以内で提供してください。", "ko": "char* process_integer_and_char(int integer_value, char char_value)\n{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}\n\n다음 C 코드에 대한 간결한 자연어 설명(도크스트링)을 한국어로 500자 이내로 제공하세요.", "ml": "char* process_integer_and_char(int integer_value, char char_value)\n{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}\n\nസിയുടെ കോഡിന് 500 അക്ഷരങ്ങളിൽ കവിയാത്ത മലയാളത്തിൽ സംക്ഷിപ്തമായ സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) നൽകുക.", "fa": "char* process_integer_and_char(int integer_value, char char_value)\n{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}\n\nتوضیح مختصر و طبیعی (docstring) از کد C به زبان فارسی ارائه دهید که حداکثر ۵۰۰ کاراکتر باشد."}, "level": "", "test": "int main()\n{\n    // Test 1\n    char* output1 = process_integer_and_char(234, 'H');\n    assert(strcmp(output1, \"234,H\") == 0);\n    free(output1); // Don't forget to free the allocated memory\n\n    // Additional tests can be added here with different input values\n    // Test 2\n    char* output2 = process_integer_and_char(123, 'A');\n    assert(strcmp(output2, \"123,A\") == 0);\n    free(output2);\n\n    // Test 3\n    char* output3 = process_integer_and_char(0, 'Z');\n    assert(strcmp(output3, \"0,Z\") == 0);\n    free(output3);\n\n    return 0;\n}", "entry_point": "process_integer_and_char", "signature": "char* process_integer_and_char(int integer_value, char char_value)", "docstring": {"en": "Reads an integer and a character, then returns them as a formatted string separated by a comma.\nParameters:\n- integer_value (int): The input integer.\n- char_value (char): The input character.\nReturns:\n- char*: A string containing the integer and character separated by a comma.\n>>> process_integer_and_char(234,H)\n\t234,H\n", "sq": "Lexon një numër të plotë dhe një karakter, pastaj i kthen ato si një varg i formatuar i ndarë me një presje.\nParametrat:\n- integer_value (int): Numri i plotë i dhënë si hyrje.\n- char_value (char): Karakteri i dhënë si hyrje.\nKthen:\n- char*: Një varg që përmban numrin e plotë dhe karakterin të ndarë me një presje.\n>>> process_integer_and_char(234,H)\n\t234,H", "hy": "Կարդում է ամբողջ թիվ և սիմվոլ, ապա վերադարձնում է դրանք որպես ձևաչափված տող, որը բաժանված է ստորակետով:\nՊարամետրեր:\n- integer_value (int): Մուտքային ամբողջ թիվը։\n- char_value (char): Մուտքային սիմվոլը։\nՎերադարձնում է:\n- char*: Տող, որը պարունակում է ամբողջ թիվը և սիմվոլը, բաժանված ստորակետով։\n>>> process_integer_and_char(234,H)\n\t234,H", "bn": "একটি পূর্ণসংখ্যা এবং একটি অক্ষর পড়ে, তারপর সেগুলিকে একটি কমা দ্বারা পৃথক করা ফরম্যাট করা স্ট্রিং হিসাবে ফেরত দেয়।\nপ্যারামিটারসমূহ:\n- integer_value (int): ইনপুট পূর্ণসংখ্যা।\n- char_value (char): ইনপুট অক্ষর।\nফেরত দেয়:\n- char*: একটি স্ট্রিং যা পূর্ণসংখ্যা এবং অক্ষরকে একটি কমা দ্বারা পৃথক করে ধারণ করে।\n>>> process_integer_and_char(234,H)\n\t234,H", "bg": "Чете цяло число и символ, след което ги връща като форматиран низ, разделен със запетая.\nПараметри:\n- integer_value (int): Входното цяло число.\n- char_value (char): Входният символ.\nВръща:\n- char*: Низ, съдържащ цялото число и символа, разделени със запетая.\n>>> process_integer_and_char(234,H)\n\t234,H", "zh": "读取一个整数和一个字符，然后将它们作为用逗号分隔的格式化字符串返回。\n参数：\n- integer_value (int): 输入的整数。\n- char_value (char): 输入的字符。\n返回：\n- char*: 包含用逗号分隔的整数和字符的字符串。\n>>> process_integer_and_char(234,H)\n\t234,H", "fr": "Lit un entier et un caractère, puis les renvoie sous forme de chaîne formatée séparée par une virgule.\nParamètres :\n- integer_value (int) : L'entier d'entrée.\n- char_value (char) : Le caractère d'entrée.\nRenvoie :\n- char* : Une chaîne contenant l'entier et le caractère séparés par une virgule.\n>>> process_integer_and_char(234,H)\n\t234,H", "de": "Liest eine ganze Zahl und ein Zeichen ein und gibt sie als formatierten String, getrennt durch ein Komma, zurück.\nParameter:\n- integer_value (int): Die Eingabe-Ganzzahl.\n- char_value (char): Das Eingabe-Zeichen.\nRückgabewert:\n- char*: Ein String, der die ganze Zahl und das Zeichen durch ein Komma getrennt enthält.\n>>> process_integer_and_char(234,H)\n\t234,H", "ha": "Karanta wata lamba da wata alama, sannan ya mayar da su a matsayin wani tsari na rubutu da aka raba su da alama ta koma.\nSigogi:\n- integer_value (int): Lambar da aka shigar.\n- char_value (char): Alamar da aka shigar.\nDawowa:\n- char*: Wani tsari na rubutu da ke dauke da lambar da alamar da aka raba su da alama ta koma.\n>>> process_integer_and_char(234,H)\n\t234,H", "hi": "Reads an integer and a character, then returns them as a formatted string separated by a comma.  \nपैरामीटर्स:  \n- integer_value (int): इनपुट पूर्णांक।  \n- char_value (char): इनपुट अक्षर।  \nरिटर्न्स:  \n- char*: एक स्ट्रिंग जिसमें पूर्णांक और अक्षर अल्पविराम द्वारा अलग किए गए हैं।  \n>>> process_integer_and_char(234,H)  \n\t234,H  ", "hu": "Egész számot és karaktert olvas be, majd visszaadja őket egy formázott, vesszővel elválasztott sztringként.\nParaméterek:\n- integer_value (int): A bemeneti egész szám.\n- char_value (char): A bemeneti karakter.\nVisszatér:\n- char*: Egy sztring, amely az egész számot és a karaktert vesszővel elválasztva tartalmazza.\n>>> process_integer_and_char(234,H)\n\t234,H", "es": "Lee un entero y un carácter, luego los devuelve como una cadena formateada separada por una coma.\nParámetros:\n- integer_value (int): El entero de entrada.\n- char_value (char): El carácter de entrada.\nDevuelve:\n- char*: Una cadena que contiene el entero y el carácter separados por una coma.\n>>> process_integer_and_char(234,H)\n\t234,H", "arb": "يقرأ عددًا صحيحًا وحرفًا، ثم يعيدهما كسلسلة منسقة مفصولة بفاصلة. \nالمعلمات:\n- integer_value (int): العدد الصحيح المدخل.\n- char_value (char): الحرف المدخل.\nالقيم المعادة:\n- char*: سلسلة تحتوي على العدد الصحيح والحرف مفصولين بفاصلة.\n>>> process_integer_and_char(234,H)\n\t234,H", "sw": "Husoma nambari kamili na herufi, kisha inazirudisha kama kamba iliyopangwa iliyotenganishwa na koma.  \nVigezo:  \n- integer_value (int): Nambari kamili ya ingizo.  \n- char_value (char): Herufi ya ingizo.  \nInarudisha:  \n- char*: Kamba inayojumuisha nambari kamili na herufi iliyotenganishwa na koma.  \n>>> process_integer_and_char(234,H)  \n\t234,H  ", "tr": "Bir tam sayı ve bir karakter okur, ardından bunları virgülle ayrılmış biçimlendirilmiş bir dize olarak döndürür.\nParametreler:\n- integer_value (int): Girdi tam sayısı.\n- char_value (char): Girdi karakteri.\nDöndürülenler:\n- char*: Virgülle ayrılmış tam sayı ve karakter içeren bir dize.\n>>> process_integer_and_char(234,H)\n\t234,H", "vi": "Đọc một số nguyên và một ký tự, sau đó trả về chúng dưới dạng một chuỗi định dạng được ngăn cách bằng dấu phẩy.  \nTham số:  \n- integer_value (int): Số nguyên đầu vào.  \n- char_value (char): Ký tự đầu vào.  \nTrả về:  \n- char*: Một chuỗi chứa số nguyên và ký tự được ngăn cách bằng dấu phẩy.  \n>>> process_integer_and_char(234,H)  \n\t234,H  ", "id": "Membaca sebuah bilangan bulat dan sebuah karakter, kemudian mengembalikannya sebagai string yang diformat dipisahkan oleh koma.\nParameter:\n- integer_value (int): Bilangan bulat masukan.\n- char_value (char): Karakter masukan.\nMengembalikan:\n- char*: Sebuah string yang berisi bilangan bulat dan karakter dipisahkan oleh koma.\n>>> process_integer_and_char(234,H)\n\t234,H", "ja": "整数と文字を読み取り、それらをカンマで区切ったフォーマットされた文字列として返します。\nパラメータ:\n- integer_value (int): 入力される整数。\n- char_value (char): 入力される文字。\n戻り値:\n- char*: 整数と文字をカンマで区切った文字列。\n\n>>> process_integer_and_char(234,H)\n\t234,H", "ko": "정수와 문자를 읽고, 쉼표로 구분된 형식의 문자열로 반환합니다.  \n매개변수:  \n- integer_value (int): 입력 정수.  \n- char_value (char): 입력 문자.  \n반환:  \n- char*: 쉼표로 구분된 정수와 문자를 포함하는 문자열.  \n>>> process_integer_and_char(234,H)  \n\t234,H  ", "ml": "ഒരു പൂർണ്ണസംഖ്യയും ഒരു അക്ഷരവും വായിച്ച് അവയെ കോമയാൽ വേർതിരിച്ച ഫോർമാറ്റ് ചെയ്ത സ്ട്രിംഗായി തിരികെ നൽകുന്നു.  \nപാരാമീറ്ററുകൾ:  \n- integer_value (int): ഇൻപുട്ട് പൂർണ്ണസംഖ്യ.  \n- char_value (char): ഇൻപുട്ട് അക്ഷരം.  \nമടക്കുന്നു:  \n- char*: പൂർണ്ണസംഖ്യയും അക്ഷരവും കോമയാൽ വേർതിരിച്ചുള്ള ഒരു സ്ട്രിംഗ്.  \n>>> process_integer_and_char(234,H)  \n\t234,H  ", "fa": "یک عدد صحیح و یک کاراکتر را می‌خواند، سپس آن‌ها را به‌عنوان یک رشته قالب‌بندی شده که با کاما جدا شده‌اند، برمی‌گرداند.\nپارامترها:\n- integer_value (int): عدد صحیح ورودی.\n- char_value (char): کاراکتر ورودی.\nبرمی‌گرداند:\n- char*: یک رشته که شامل عدد صحیح و کاراکتر است و با کاما جدا شده‌اند.\n>>> process_integer_and_char(234,H)\n\t234,H"}}
{"task_id": "C/25", "prompt": {"en": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nShifts all characters by 5 positions in alphabetical order. Only letters are replaced, and all letters are in uppercase.\n​    Parameters:\n​    text (str): The input text to be processed.\n​\n​    Returns:\n​    str: The transformed text with characters shifted by 5 positions.\n\t>>> shift_characters(NS,BFW,,JAJSYX,TK,NRUTWYFSHJ,FWJ,YMJ,WJXZQY,TK,YWNANFQ,HFZXJX)\n\tIN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\n*/\nchar* shift_characters(char* text)", "sq": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nZhvendos të gjitha karakteret me 5 pozicione në rend alfabetik. Vetëm shkronjat zëvendësohen, dhe të gjitha shkronjat janë me shkronja të mëdha.\n​    Parametrat:\n​    text (str): Teksti hyrës që do të përpunohet.\n​\n​    Kthen:\n​    str: Teksti i transformuar me karaktere të zhvendosura me 5 pozicione.\n\t>>> shift_characters(NS,BFW,,JAJSYX,TK,NRUTWYFSHJ,FWJ,YMJ,WJXZQY,TK,YWNANFQ,HFZXJX)\n\tIN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\n*/\nchar* shift_characters(char* text)", "hy": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nՏեղափոխում է բոլոր տառերը 5 դիրքով այբբենական կարգով: Միայն տառերն են փոխարինվում, և բոլոր տառերը մեծատառ են:\n​    Պարամետրեր:\n​    text (str): Մուտքային տեքստը, որը պետք է մշակվի:\n​\n​    Վերադարձնում է:\n​    str: Փոխակերպված տեքստը՝ տառերը տեղափոխված 5 դիրքով:\n\t>>> shift_characters(NS,BFW,,JAJSYX,TK,NRUTWYFSHJ,FWJ,YMJ,WJXZQY,TK,YWNANFQ,HFZXJX)\n\tIN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\n*/\nchar* shift_characters(char* text)", "bn": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nসমস্ত অক্ষর বর্ণানুক্রমিক ক্রমে 5 অবস্থান দ্বারা স্থানান্তরিত হয়। শুধুমাত্র অক্ষরগুলি প্রতিস্থাপিত হয়, এবং সমস্ত অক্ষর বড় হাতের।\n​    প্যারামিটার:\n​    text (str): প্রক্রিয়াকরণের জন্য ইনপুট টেক্সট।\n\n​    রিটার্নস:\n​    str: পরিবর্তিত টেক্সট যা অক্ষরগুলি 5 অবস্থান দ্বারা স্থানান্তরিত হয়েছে।\n\t>>> shift_characters(NS,BFW,,JAJSYX,TK,NRUTWYFSHJ,FWJ,YMJ,WJXZQY,TK,YWNANFQ,HFZXJX)\n\tIN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\n*/\nchar* shift_characters(char* text)", "bg": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nИзмества всички символи с 5 позиции в азбучен ред. Само букви се заменят и всички букви са с главни букви.\n​    Параметри:\n​    text (str): Входният текст, който ще бъде обработен.\n​\n​    Връща:\n​    str: Преобразуваният текст със символи, изместени с 5 позиции.\n\t>>> shift_characters(NS,BFW,,JAJSYX,TK,NRUTWYFSHJ,FWJ,YMJ,WJXZQY,TK,YWNANFQ,HFZXJX)\n\tIN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\n*/\nchar* shift_characters(char* text)", "zh": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n将所有字符在字母顺序中移动5个位置。只有字母被替换，且所有字母均为大写。\n​    参数:\n​    text (str): 要处理的输入文本。\n​\n​    返回:\n​    str: 字符移动5个位置后的转换文本。\n\t>>> shift_characters(NS,BFW,,JAJSYX,TK,NRUTWYFSHJ,FWJ,YMJ,WJXZQY,TK,YWNANFQ,HFZXJX)\n\tIN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\n*/\nchar* shift_characters(char* text)", "fr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDécale tous les caractères de 5 positions dans l'ordre alphabétique. Seules les lettres sont remplacées, et toutes les lettres sont en majuscules.\n​    Paramètres :\n​    text (str) : Le texte d'entrée à traiter.\n​\n​    Renvoie :\n​    str : Le texte transformé avec les caractères décalés de 5 positions.\n\t>>> shift_characters(NS,BFW,,JAJSYX,TK,NRUTWYFSHJ,FWJ,YMJ,WJXZQY,TK,YWNANFQ,HFZXJX)\n\tIN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\n*/\nchar* shift_characters(char* text)", "de": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nVerschiebt alle Zeichen um 5 Positionen in alphabetischer Reihenfolge. Nur Buchstaben werden ersetzt, und alle Buchstaben sind in Großbuchstaben.\n​    Parameter:\n​    text (str): Der Eingabetext, der verarbeitet werden soll.\n​\n​    Rückgabe:\n​    str: Der transformierte Text mit um 5 Positionen verschobenen Zeichen.\n\t>>> shift_characters(NS,BFW,,JAJSYX,TK,NRUTWYFSHJ,FWJ,YMJ,WJXZQY,TK,YWNANFQ,HFZXJX)\n\tIN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\n*/\nchar* shift_characters(char* text)", "ha": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nMatsar da dukkan haruffa ta wurin matsayi 5 a cikin tsari na haruffa. Ana maye gurbin haruffa kawai, kuma duk haruffa suna cikin manyan baki.\n​    Sigogi:\n​    text (str): Rubutun shigarwa da za a sarrafa.\n​\n​    Komawa:\n​    str: Rubutun da aka canza tare da haruffa da aka matsar da su ta wurin matsayi 5.\n\t>>> shift_characters(NS,BFW,,JAJSYX,TK,NRUTWYFSHJ,FWJ,YMJ,WJXZQY,TK,YWNANFQ,HFZXJX)\n\tIN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\n*/", "hi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nसभी अक्षरों को वर्णमाला क्रम में 5 स्थानों से स्थानांतरित करता है। केवल अक्षरों को बदला जाता है, और सभी अक्षर बड़े अक्षरों में होते हैं।\n    पैरामीटर्स:\n    text (str): प्रोसेस किए जाने वाले इनपुट टेक्स्ट।\n\n    रिटर्न्स:\n    str: परिवर्तित टेक्स्ट जिसमें अक्षरों को 5 स्थानों से स्थानांतरित किया गया है।\n    >>> shift_characters(NS,BFW,,JAJSYX,TK,NRUTWYFSHJ,FWJ,YMJ,WJXZQY,TK,YWNANFQ,HFZXJX)\n    IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\n*/\nchar* shift_characters(char* text)", "hu": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nMinden karaktert 5 pozícióval eltol az ábécé sorrendjében. Csak a betűk kerülnek cserére, és minden betű nagybetűs.\n​    Paraméterek:\n​    text (str): A feldolgozandó bemeneti szöveg.\n​\n​    Visszatér:\n​    str: Az átalakított szöveg, amelynek karakterei 5 pozícióval eltolódtak.\n\t>>> shift_characters(NS,BFW,,JAJSYX,TK,NRUTWYFSHJ,FWJ,YMJ,WJXZQY,TK,YWNANFQ,HFZXJX)\n\tIN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\n*/\nchar* shift_characters(char* text)", "es": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDesplaza todos los caracteres 5 posiciones en orden alfabético. Solo se reemplazan letras, y todas las letras están en mayúsculas.\n​    Parámetros:\n​    text (str): El texto de entrada a procesar.\n​\n​    Retorna:\n​    str: El texto transformado con caracteres desplazados 5 posiciones.\n\t>>> shift_characters(NS,BFW,,JAJSYX,TK,NRUTWYFSHJ,FWJ,YMJ,WJXZQY,TK,YWNANFQ,HFZXJX)\n\tIN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\n*/\nchar* shift_characters(char* text)", "arb": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nيقوم بتحريك جميع الأحرف بمقدار 5 مواقع في الترتيب الأبجدي. يتم استبدال الأحرف فقط، وجميع الأحرف تكون بأحرف كبيرة.\n    المعلمات:\n    text (str): النص المدخل ليتم معالجته.\n    \n    يعيد:\n    str: النص المحول مع الأحرف المحركة بمقدار 5 مواقع.\n    >>> shift_characters(NS,BFW,,JAJSYX,TK,NRUTWYFSHJ,FWJ,YMJ,WJXZQY,TK,YWNANFQ,HFZXJX)\n    IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\n*/\nchar* shift_characters(char* text)", "sw": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nInasogeza herufi zote kwa nafasi 5 katika mpangilio wa alfabeti. Ni herufi pekee ndizo hubadilishwa, na herufi zote ni kubwa.\n​    Vigezo:\n​    text (str): Maandishi ya ingizo yanayopaswa kushughulikiwa.\n​\n​    Inarejesha:\n​    str: Maandishi yaliyobadilishwa na herufi zilizogeuzwa kwa nafasi 5.\n\t>>> shift_characters(NS,BFW,,JAJSYX,TK,NRUTWYFSHJ,FWJ,YMJ,WJXZQY,TK,YWNANFQ,HFZXJX)\n\tIN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\n*/\nchar* shift_characters(char* text)", "tr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nAlfabetik sırada tüm karakterleri 5 pozisyon kaydırır. Yalnızca harfler değiştirilir ve tüm harfler büyük harfle yazılır.\n​    Parametreler:\n​    text (str): İşlenecek giriş metni.\n​\n​    Döndürür:\n​    str: Karakterlerin 5 pozisyon kaydırıldığı dönüştürülmüş metin.\n\t>>> shift_characters(NS,BFW,,JAJSYX,TK,NRUTWYFSHJ,FWJ,YMJ,WJXZQY,TK,YWNANFQ,HFZXJX)\n\tIN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\n*/\nchar* shift_characters(char* text)", "vi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDịch chuyển tất cả các ký tự 5 vị trí trong thứ tự bảng chữ cái. Chỉ các chữ cái được thay thế, và tất cả các chữ cái đều ở dạng chữ hoa.\n​    Tham số:\n​    text (str): Văn bản đầu vào cần được xử lý.\n​\n​    Trả về:\n​    str: Văn bản đã được biến đổi với các ký tự dịch chuyển 5 vị trí.\n\t>>> shift_characters(NS,BFW,,JAJSYX,TK,NRUTWYFSHJ,FWJ,YMJ,WJXZQY,TK,YWNANFQ,HFZXJX)\n\tIN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\n*/\nchar* shift_characters(char* text)", "id": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nMenggeser semua karakter sebanyak 5 posisi dalam urutan alfabet. Hanya huruf yang diganti, dan semua huruf dalam huruf besar.\n    Parameter:\n    text (str): Teks masukan yang akan diproses.\n    \n    Mengembalikan:\n    str: Teks yang telah diubah dengan karakter digeser sebanyak 5 posisi.\n    >>> shift_characters(NS,BFW,,JAJSYX,TK,NRUTWYFSHJ,FWJ,YMJ,WJXZQY,TK,YWNANFQ,HFZXJX)\n    IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\n*/\nchar* shift_characters(char* text)\n", "ja": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nすべての文字をアルファベット順で5文字分シフトします。文字のみが置き換えられ、すべての文字は大文字です。\n    パラメータ:\n    text (str): 処理される入力テキスト。\n\n    戻り値:\n    str: 文字が5文字分シフトされた変換テキスト。\n    >>> shift_characters(NS,BFW,,JAJSYX,TK,NRUTWYFSHJ,FWJ,YMJ,WJXZQY,TK,YWNANFQ,HFZXJX)\n    IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\n*/\nchar* shift_characters(char* text)\n", "ko": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n알파벳 순서에서 모든 문자를 5자리씩 이동시킵니다. 문자만 교체되며, 모든 문자는 대문자입니다.\n​    매개변수:\n​    text (str): 처리할 입력 텍스트입니다.\n​\n​    반환:\n​    str: 문자가 5자리씩 이동된 변환된 텍스트입니다.\n\t>>> shift_characters(NS,BFW,,JAJSYX,TK,NRUTWYFSHJ,FWJ,YMJ,WJXZQY,TK,YWNANFQ,HFZXJX)\n\tIN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\n*/\nchar* shift_characters(char* text)\n", "ml": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nഎല്ലാ അക്ഷരങ്ങളും അക്ഷരമാല ക്രമത്തിൽ 5 സ്ഥാനങ്ങൾ മാറ്റുന്നു. അക്ഷരങ്ങൾ മാത്രമേ മാറ്റപ്പെടുകയുള്ളൂ, എല്ലാ അക്ഷരങ്ങളും വലുതായിരിക്കും.\n​    പാരാമീറ്ററുകൾ:\n​    text (str): പ്രോസസ്സ് ചെയ്യേണ്ട ഇൻപുട്ട് ടെക്സ്റ്റ്.\n​\n​    മടക്കുന്നു:\n​    str: 5 സ്ഥാനങ്ങൾ മാറ്റിയ അക്ഷരങ്ങളുള്ള പരിവർത്തിത ടെക്സ്റ്റ്.\n\t>>> shift_characters(NS,BFW,,JAJSYX,TK,NRUTWYFSHJ,FWJ,YMJ,WJXZQY,TK,YWNANFQ,HFZXJX)\n\tIN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\n*/\nchar* shift_characters(char* text)", "fa": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nتمام حروف را به اندازه 5 موقعیت در ترتیب حروف الفبا جابجا می‌کند. فقط حروف جایگزین می‌شوند و همه حروف به صورت حروف بزرگ هستند.\n​    پارامترها:\n​    text (str): متنی که باید پردازش شود.\n​\n​    بازگشت:\n​    str: متن تغییر یافته با حروف جابجا شده به اندازه 5 موقعیت.\n\t>>> shift_characters(NS,BFW,,JAJSYX,TK,NRUTWYFSHJ,FWJ,YMJ,WJXZQY,TK,YWNANFQ,HFZXJX)\n\tIN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\n*/\nchar* shift_characters(char* text)\n"}, "canonical_solution": "{\n\tsize_t len = strlen(text);\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}", "instruction": {"en": "char* shift_characters(char* text)\n{\n\tsize_t len = strlen(text);\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "sq": "char* shift_characters(char* text)\n{\n\tsize_t len = strlen(text);\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrale (docstring) të kodit C në shqip duke përdorur maksimumi 500 karaktere.", "hy": "char* shift_characters(char* text)\n{\n\tsize_t len = strlen(text);\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}\n\nՏվեք C կոդի հակիրճ բնութագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "char* shift_characters(char* text)\n{\n\tsize_t len = strlen(text);\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}\n\nসি কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।", "bg": "char* shift_characters(char* text)\n{\n\tsize_t len = strlen(text);\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, като използвате не повече от 500 знака.", "zh": "char* shift_characters(char* text)\n{\n\tsize_t len = strlen(text);\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}\n\n提供一段中文描述（文档字符串），简要说明该C代码的功能，限制在500个字符以内。", "fr": "char* shift_characters(char* text)\n{\n\tsize_t len = strlen(text);\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.", "de": "char* shift_characters(char* text)\n{\n\tsize_t len = strlen(text);\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "char* shift_characters(char* text)\n{\n\tsize_t len = strlen(text);\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar C a cikin Hausa ta amfani da haruffa 500 kawai.", "hi": "char* shift_characters(char* text)\n{\n\tsize_t len = strlen(text);\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}\n\nC कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "char* shift_characters(char* text)\n{\n\tsize_t len = strlen(text);\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben.", "es": "char* shift_characters(char* text)\n{\n\tsize_t len = strlen(text);\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando como máximo 500 caracteres.", "arb": "char* shift_characters(char* text)\n{\n\tsize_t len = strlen(text);\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "char* shift_characters(char* text)\n{\n\tsize_t len = strlen(text);\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "char* shift_characters(char* text)\n{\n\tsize_t len = strlen(text);\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}\n\nC kodunun işlevini açıklayan kısa bir doğal dil tanımı (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter içermelidir.", "vi": "char* shift_characters(char* text)\n{\n\tsize_t len = strlen(text);\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã C bằng tiếng Việt, sử dụng tối đa 500 ký tự.", "id": "char* shift_characters(char* text)\n{\n\tsize_t len = strlen(text);\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode C dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "char* shift_characters(char* text)\n{\n\tsize_t len = strlen(text);\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}\n\n以下のCコードに対する簡潔な自然言語による説明（ドックストリング）を日本語で500文字以内で提供してください。", "ko": "char* shift_characters(char* text)\n{\n\tsize_t len = strlen(text);\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}\n\nC 코드의 동작을 설명하는 간결한 자연어 설명(docstring)을 한국어로 작성하세요. 최대 500자 이내로 작성해야 합니다.", "ml": "char* shift_characters(char* text)\n{\n\tsize_t len = strlen(text);\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}\n\nസിയുടെ കോഡ് ഉപയോഗിച്ച് 500 അക്ഷരങ്ങൾക്കുള്ളിൽ മലയാളത്തിൽ സംക്ഷിപ്തമായ സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) നൽകുക.", "fa": "char* shift_characters(char* text)\n{\n\tsize_t len = strlen(text);\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}\n\nتوضیح مختصر و طبیعی (docstring) از کد C به زبان فارسی ارائه دهید که حداکثر ۵۰۰ کاراکتر باشد."}, "level": "", "test": "int main()\n{\n\tchar test1[] = \"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\";\n    char test2[] = \"N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ\";\n    char test3[] = \"IFSLJW PSTBX KZQQ BJQQ YMFY HFJXFW NX RTWJ IFSLJWTZX YMFS MJ\";\n\n    assert(strcmp(shift_characters(test1), \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\") == 0);\n    assert(strcmp(shift_characters(test2), \"I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME\") == 0);\n    assert(strcmp(shift_characters(test3), \"DANGER KNOWS FULL WELL THAT CAESAR IS MORE DANGEROUS THAN HE\") == 0);\n\treturn 0;\n}", "entry_point": "shift_characters", "signature": "char* shift_characters(char* text)", "docstring": {"en": "Shifts all characters by 5 positions in alphabetical order. Only letters are replaced, and all letters are in uppercase.\n​    Parameters:\n​    text (str): The input text to be processed.\n\n​    Returns:\n​    str: The transformed text with characters shifted by 5 positions.\n\t>>> shift_characters('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n\t'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n", "sq": "Zhvendos të gjitha shkronjat me 5 pozicione në rendin alfabetik. Vetëm shkronjat zëvendësohen, dhe të gjitha shkronjat janë me shkronja të mëdha.\n​    Parametrat:\n​    text (str): Teksti i hyrjes që do të përpunohet.\n\n​    Kthen:\n​    str: Teksti i transformuar me shkronja të zhvendosura me 5 pozicione.\n\t>>> shift_characters('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n\t'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'", "hy": "Տեղափոխում է բոլոր տառերը 5 դիրքով այբբենական կարգով։ Միայն տառերն են փոխարինվում, և բոլոր տառերը մեծատառ են։\n​    Պարամետրեր:\n​    text (str): Մուտքային տեքստը, որը պետք է մշակվի։\n\n​    Վերադարձնում է:\n​    str: Փոխակերպված տեքստը, որտեղ տառերը տեղափոխված են 5 դիրքով։\n\t>>> shift_characters('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n\t'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'", "bn": "বর্ণানুক্রমিক ক্রমে সমস্ত অক্ষরকে ৫ অবস্থানে স্থানান্তরিত করে। শুধুমাত্র অক্ষরগুলি প্রতিস্থাপিত হয়, এবং সমস্ত অক্ষর বড় হাতের।\n\n​    প্যারামিটার:\n​    text (str): প্রক্রিয়াকরণের জন্য ইনপুট টেক্সট।\n\n​    রিটার্নস:\n​    str: স্থানান্তরিত অক্ষর সহ পরিবর্তিত টেক্সট।\n\t>>> shift_characters('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n\t'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'", "bg": "Изместете всички символи с 5 позиции в азбучен ред. Само буквите се заменят и всички букви са с главни букви.\n​    Параметри:\n​    text (str): Входният текст, който ще бъде обработен.\n\n​    Връща:\n​    str: Преобразуваният текст със символи, изместени с 5 позиции.\n\t>>> shift_characters('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n\t'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'", "zh": "将所有字符在字母表中向后移动5个位置。只有字母会被替换，且所有字母都为大写。\n\n参数:\ntext (str): 要处理的输入文本。\n\n返回:\nstr: 字符被移动5个位置后的转换文本。\n>>> shift_characters('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'", "fr": "Décale tous les caractères de 5 positions dans l'ordre alphabétique. Seules les lettres sont remplacées, et toutes les lettres sont en majuscules.\n​    Paramètres:\n​    text (str): Le texte d'entrée à traiter.\n\n​    Renvoie:\n​    str: Le texte transformé avec les caractères décalés de 5 positions.\n\t>>> shift_characters('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n\t'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'", "de": "Verschiebt alle Zeichen um 5 Positionen in alphabetischer Reihenfolge. Nur Buchstaben werden ersetzt, und alle Buchstaben sind in Großbuchstaben.\n\n​    Parameter:\n​    text (str): Der Eingabetext, der verarbeitet werden soll.\n\n​    Rückgabe:\n​    str: Der transformierte Text mit um 5 Positionen verschobenen Zeichen.\n\t>>> shift_characters('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n\t'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'", "ha": "Canza duk haruffa ta wurin matsar da su wurare 5 a cikin tsarin haruffa. Ana maye gurbin haruffa kawai, kuma duk haruffa suna cikin manyan baki.\n​    Sigogi:\n​    text (str): Rubutun shigarwa da za a sarrafa.\n\n​    Komawa:\n​    str: Rubutun da aka canza tare da haruffa da aka matsar da su zuwa matsayi 5.\n\n\t>>> shift_characters('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n\t'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'", "hi": "सभी वर्णों को वर्णमाला क्रम में 5 स्थानों से स्थानांतरित करता है। केवल अक्षरों को बदला जाता है, और सभी अक्षर बड़े अक्षरों में होते हैं।\n\nParameters:\ntext (str): इनपुट पाठ जिसे संसाधित किया जाना है।\n\nReturns:\nstr: परिवर्तित पाठ जिसमें वर्ण 5 स्थानों से स्थानांतरित होते हैं।\n>>> shift_characters('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'", "hu": "Az összes karaktert 5 pozícióval eltolja az ábécében. Csak a betűk kerülnek cserére, és minden betű nagybetűs.\n\nParaméterek:\ntext (str): A feldolgozandó bemeneti szöveg.\n\nVisszatér:\nstr: Az átalakított szöveg, amelyben a karakterek 5 pozícióval eltolódtak.\n>>> shift_characters('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'", "es": "Desplaza todos los caracteres 5 posiciones en orden alfabético. Solo se reemplazan las letras, y todas las letras están en mayúsculas.\n​    Parámetros:\n​    text (str): El texto de entrada a ser procesado.\n\n​    Devuelve:\n​    str: El texto transformado con caracteres desplazados por 5 posiciones.\n\t>>> shift_characters('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n\t'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'", "arb": "ينقل جميع الأحرف بمقدار 5 مواقع في الترتيب الأبجدي. يتم استبدال الحروف فقط، وجميع الحروف تكون بأحرف كبيرة.\n\nالمعلمات:\ntext (str): النص المدخل ليتم معالجته.\n\nالقيم المعادة:\nstr: النص المحول مع الأحرف المنقولة بمقدار 5 مواقع.\n>>> shift_characters('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'", "sw": "Hubadilisha herufi zote kwa nafasi 5 katika mpangilio wa alfabeti. Ni herufi pekee ndizo hubadilishwa, na herufi zote ziko katika herufi kubwa.\n​    Vigezo:\n​    text (str): Maandishi ya kuingiza yatakayoshughulikiwa.\n\n​    Inarejesha:\n​    str: Maandishi yaliyobadilishwa na herufi zilizohamishwa kwa nafasi 5.\n\t>>> shift_characters('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n\t'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'", "tr": "Alfabetik sırada tüm karakterleri 5 pozisyon kaydırır. Yalnızca harfler değiştirilir ve tüm harfler büyük harfle yazılır.\n​    Parametreler:\n​    text (str): İşlenecek giriş metni.\n\n​    Döndürür:\n​    str: Karakterlerin 5 pozisyon kaydırıldığı dönüştürülmüş metin.\n\t>>> shift_characters('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n\t'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'", "vi": "Dịch chuyển tất cả các ký tự theo 5 vị trí trong thứ tự bảng chữ cái. Chỉ các chữ cái được thay thế, và tất cả các chữ cái đều ở dạng chữ hoa.\n​    Tham số:\n​    text (str): Văn bản đầu vào cần được xử lý.\n\n​    Trả về:\n​    str: Văn bản đã được biến đổi với các ký tự được dịch chuyển 5 vị trí.\n\t>>> shift_characters('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n\t'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'", "id": "Menggeser semua karakter sebanyak 5 posisi dalam urutan alfabet. Hanya huruf yang diganti, dan semua huruf dalam huruf besar.\n    Parameter:\n    text (str): Teks masukan yang akan diproses.\n\n    Mengembalikan:\n    str: Teks yang telah diubah dengan karakter digeser sebanyak 5 posisi.\n    >>> shift_characters('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n    'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'", "ja": "アルファベット順で全ての文字を5つの位置だけシフトします。文字のみが置き換えられ、全ての文字は大文字です。\n\n​    パラメータ:\n​    text (str): 処理される入力テキスト。\n\n​    戻り値:\n​    str: 文字が5つの位置だけシフトされた変換後のテキスト。\n\t>>> shift_characters('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n\t'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'", "ko": "알파벳 순서에서 모든 문자를 5자리 이동시킵니다. 문자만 대체되며, 모든 문자는 대문자입니다.\n    매개변수:\n    text (str): 처리할 입력 텍스트입니다.\n\n    반환:\n    str: 문자가 5자리 이동된 변환된 텍스트입니다.\n    >>> shift_characters('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n    'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'", "ml": "അക്ഷരമാല ക്രമത്തിൽ എല്ലാ അക്ഷരങ്ങളെയും 5 സ്ഥാനങ്ങൾ മാറ്റുന്നു. അക്ഷരങ്ങൾ മാത്രമേ മാറ്റപ്പെടുകയുള്ളൂ, എല്ലാ അക്ഷരങ്ങളും വലുതായിരിക്കും.\n    പാരാമീറ്ററുകൾ:\n    text (str): പ്രോസസ്സ് ചെയ്യേണ്ട ഇൻപുട്ട് ടെക്സ്റ്റ്.\n\n    റിട്ടേൺസ്:\n    str: 5 സ്ഥാനങ്ങൾ മാറ്റിയ അക്ഷരങ്ങളുള്ള പരിവർത്തിത ടെക്സ്റ്റ്.\n    >>> shift_characters('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n    'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'", "fa": "حروف را به اندازه ۵ موقعیت در ترتیب الفبایی جابجا می‌کند. تنها حروف جایگزین می‌شوند و همه حروف به صورت بزرگ هستند.\n​    پارامترها:\n​    text (str): متن ورودی که باید پردازش شود.\n\n​    بازگشت:\n​    str: متن تغییر یافته با حروف جابجا شده به اندازه ۵ موقعیت.\n\t>>> shift_characters('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n\t'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'"}}
{"task_id": "C/26", "prompt": {"en": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nClassify the integer x based on the following method:\nIf x is a single-digit number, x belongs to its own class.\nOtherwise, sum the digits of x, get a new x, and iterate until the class is determined.\nParameters:\n- x (char*): The integer to be classified.\n​    Returns:\n​    int: The class to which the integer x belongs.\n\t>>> classify_integer(24)\n\t6\n*/\nint classify_integer(char *x)", "sq": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nKlasifikoni numrin e plotë x bazuar në metodën e mëposhtme:\nNëse x është një numër njëshifror, x i përket klasës së vet.\nPërndryshe, mblidhni shifrat e x, merrni një x të ri dhe iteroni derisa klasa të përcaktohet.\nParametrat:\n- x (char*): Numri i plotë që do të klasifikohet.\n​    Kthen:\n​    int: Klasa në të cilën i përket numri i plotë x.\n\t>>> classify_integer(24)\n\t6\n*/\nint classify_integer(char *x)", "hy": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nԴասակարգել ամբողջ թիվը x-ը հետևյալ մեթոդով.\nԵթե x-ը միանիշ թիվ է, ապա x-ը պատկանում է իր սեփական դասին:\nՀակառակ դեպքում, գումարել x-ի թվանշանները, ստանալ նոր x և կրկնել, մինչև դասը որոշվի:\nՊարամետրեր:\n- x (char*): Դասակարգման ենթակա ամբողջ թիվը:\n​    Վերադարձնում է:\n​    int: Դասը, որին պատկանում է ամբողջ թիվը x-ը:\n\t>>> classify_integer(24)\n\t6\n*/\nint classify_integer(char *x)", "bn": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nনিম্নলিখিত পদ্ধতির ভিত্তিতে পূর্ণসংখ্যা x শ্রেণীবদ্ধ করুন:\nযদি x একটি এক অঙ্কের সংখ্যা হয়, তাহলে x তার নিজস্ব শ্রেণীতে অন্তর্ভুক্ত।\nঅন্যথায়, x এর অঙ্কগুলির যোগফল নিন, একটি নতুন x পান এবং শ্রেণী নির্ধারিত না হওয়া পর্যন্ত পুনরাবৃত্তি করুন।\nপ্যারামিটার:\n- x (char*): শ্রেণীবদ্ধ করার জন্য পূর্ণসংখ্যা।\n​    রিটার্নস:\n​    int: যে শ্রেণীতে পূর্ণসংখ্যা x অন্তর্ভুক্ত।\n\t>>> classify_integer(24)\n\t6\n*/\nint classify_integer(char *x)", "bg": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nКласифицирайте цялото число x въз основа на следния метод:\nАко x е едноцифрено число, x принадлежи към своя собствен клас.\nВ противен случай, съберете цифрите на x, получете ново x и итерайте, докато класът бъде определен.\nПараметри:\n- x (char*): Цялото число, което да бъде класифицирано.\n​    Връща:\n​    int: Класът, към който принадлежи цялото число x.\n\t>>> classify_integer(24)\n\t6\n*/\nint classify_integer(char *x)", "zh": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n根据以下方法对整数 x 进行分类：\n如果 x 是个位数，x 属于它自己的类别。\n否则，将 x 的各位数字相加，得到一个新的 x，并迭代直到确定类别。\n参数：\n- x (char*): 要分类的整数。\n    返回：\n    int: 整数 x 所属的类别。\n\t>>> classify_integer(24)\n\t6\n*/\nint classify_integer(char *x)", "fr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nClasser l'entier x selon la méthode suivante :\nSi x est un nombre à un seul chiffre, x appartient à sa propre classe.\nSinon, additionner les chiffres de x, obtenir un nouveau x, et itérer jusqu'à ce que la classe soit déterminée.\nParamètres :\n- x (char*): L'entier à classer.\n    Renvoie :\n    int : La classe à laquelle appartient l'entier x.\n\t>>> classify_integer(24)\n\t6\n*/\nint classify_integer(char *x)", "de": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nKlassifizieren Sie die ganze Zahl x basierend auf der folgenden Methode:\nWenn x eine einstellige Zahl ist, gehört x zu seiner eigenen Klasse.\nAndernfalls summieren Sie die Ziffern von x, erhalten ein neues x und iterieren, bis die Klasse bestimmt ist.\nParameter:\n- x (char*): Die zu klassifizierende ganze Zahl.\n​    Rückgabe:\n​    int: Die Klasse, zu der die ganze Zahl x gehört.\n\t>>> classify_integer(24)\n\t6\n*/\nint classify_integer(char *x)", "ha": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nRarraba lambar x bisa ga hanyar da ke gaba:\nIdan x lamba ce mai lamba guda ɗaya, x na cikin ajin sa.\nIn ba haka ba, tara lambobin x, sami sabon x, kuma maimaita har sai an tantance ajin.\nSigogi:\n- x (char*): Lambar da za a rarraba.\n​    Komawa:\n​    int: Aji da lambar x ke ciki.\n\t>>> classify_integer(24)\n\t6\n*/\nint classify_integer(char *x)", "hi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nनिम्नलिखित विधि के आधार पर पूर्णांक x को वर्गीकृत करें:\nयदि x एकल-अंकीय संख्या है, तो x अपने स्वयं के वर्ग से संबंधित है।\nअन्यथा, x के अंकों का योग करें, एक नया x प्राप्त करें, और तब तक पुनरावृत्ति करें जब तक कि वर्ग निर्धारित न हो जाए।\nपैरामीटर्स:\n- x (char*): वह पूर्णांक जिसे वर्गीकृत किया जाना है।\n    रिटर्न:\n    int: वह वर्ग जिसमें पूर्णांक x संबंधित है।\n\t>>> classify_integer(24)\n\t6\n*/\nint classify_integer(char *x)", "hu": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nOsztályozza az x egész számot a következő módszer alapján:\nHa x egyjegyű szám, akkor x a saját osztályába tartozik.\nEllenkező esetben összeadja x számjegyeit, kap egy új x-et, és iterál, amíg az osztály meg nem határozódik.\nParaméterek:\n- x (char*): Az osztályozandó egész szám.\n    Visszatérési érték:\n    int: Az osztály, amelyhez az x egész szám tartozik.\n\t>>> classify_integer(24)\n\t6\n*/\nint classify_integer(char *x)", "es": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nClasificar el entero x basado en el siguiente método:\nSi x es un número de un solo dígito, x pertenece a su propia clase.\nDe lo contrario, suma los dígitos de x, obtiene un nuevo x, e itera hasta que se determine la clase.\nParámetros:\n- x (char*): El entero a clasificar.\n    Devuelve:\n    int: La clase a la que pertenece el entero x.\n\t>>> classify_integer(24)\n\t6\n*/\nint classify_integer(char *x)", "arb": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nتصنيف العدد الصحيح x بناءً على الطريقة التالية:\nإذا كان x رقمًا مكونًا من رقم واحد، فإن x ينتمي إلى فئته الخاصة.\nخلاف ذلك، اجمع أرقام x، احصل على x جديد، وكرر حتى يتم تحديد الفئة.\nالمعلمات:\n- x (char*): العدد الصحيح الذي سيتم تصنيفه.\n    يعيد:\n    int: الفئة التي ينتمي إليها العدد الصحيح x.\n\t>>> classify_integer(24)\n\t6\n*/\nint classify_integer(char *x)", "sw": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nTambua nambari x kulingana na njia ifuatayo:\nIkiwa x ni nambari ya tarakimu moja, x ni ya darasa lake lenyewe.\nVinginevyo, jumlisha tarakimu za x, pata x mpya, na rudia hadi darasa litakapobainishwa.\nVigezo:\n- x (char*): Nambari ya kutambuliwa.\n​    Inarudisha:\n​    int: Darasa ambalo nambari x ni ya.\n\t>>> classify_integer(24)\n\t6\n*/\nint classify_integer(char *x)", "tr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nTam sayı x'i aşağıdaki yönteme göre sınıflandırın:\nEğer x tek basamaklı bir sayıysa, x kendi sınıfına aittir.\nAksi takdirde, x'in basamaklarını toplayın, yeni bir x elde edin ve sınıf belirlenene kadar yineleyin.\nParametreler:\n- x (char*): Sınıflandırılacak tam sayı.\n    Döndürür:\n    int: Tam sayı x'in ait olduğu sınıf.\n\t>>> classify_integer(24)\n\t6\n*/\nint classify_integer(char *x)", "vi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nPhân loại số nguyên x dựa trên phương pháp sau:\nNếu x là một số có một chữ số, x thuộc về lớp của chính nó.\nNgược lại, tổng các chữ số của x, lấy một x mới, và lặp lại cho đến khi lớp được xác định.\nTham số:\n- x (char*): Số nguyên cần được phân loại.\n    Trả về:\n    int: Lớp mà số nguyên x thuộc về.\n\t>>> classify_integer(24)\n\t6\n*/\nint classify_integer(char *x)", "id": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nKlasifikasikan bilangan bulat x berdasarkan metode berikut:\nJika x adalah angka satu digit, x termasuk dalam kelasnya sendiri.\nJika tidak, jumlahkan digit-digit dari x, dapatkan x baru, dan iterasi sampai kelas ditentukan.\nParameter:\n- x (char*): Bilangan bulat yang akan diklasifikasikan.\n​    Mengembalikan:\n​    int: Kelas di mana bilangan bulat x termasuk.\n\t>>> classify_integer(24)\n\t6\n*/\nint classify_integer(char *x)", "ja": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n整数 x を次の方法に基づいて分類します:\nx が一桁の数字である場合、x はそれ自身のクラスに属します。\nそれ以外の場合、x の桁を合計し、新しい x を取得し、クラスが決定されるまで繰り返します。\nパラメータ:\n- x (char*): 分類される整数。\n​    戻り値:\n​    int: 整数 x が属するクラス。\n\t>>> classify_integer(24)\n\t6\n*/\nint classify_integer(char *x)", "ko": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n정수 x를 다음 방법에 따라 분류합니다:\nx가 한 자리 숫자이면, x는 자신의 클래스에 속합니다.\n그렇지 않으면, x의 자릿수를 합산하여 새로운 x를 얻고, 클래스가 결정될 때까지 반복합니다.\n매개변수:\n- x (char*): 분류할 정수입니다.\n​    반환:\n​    int: 정수 x가 속하는 클래스입니다.\n\t>>> classify_integer(24)\n\t6\n*/\nint classify_integer(char *x)", "ml": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nഇനിപ്പറയുന്ന രീതിയിൽ പൂർണ്ണസംഖ്യ x നെ വർഗ്ഗീകരിക്കുക:\nx ഒറ്റ അക്ക സംഖ്യയായാൽ, x അതിന്റെ സ്വന്തം വർഗ്ഗത്തിൽ പെട്ടതാണ്.\nഇതല്ലെങ്കിൽ, x ന്റെ അക്കങ്ങളുടെ ആകെ കൂട്ടം എടുക്കുക, പുതിയ x ലഭിക്കുക, വർഗ്ഗം നിർണ്ണയിക്കുന്നതുവരെ ആവർത്തിക്കുക.\nപാരാമീറ്ററുകൾ:\n- x (char*): വർഗ്ഗീകരിക്കേണ്ട പൂർണ്ണസംഖ്യ.\n​    മടക്കുന്നു:\n​    int: പൂർണ്ണസംഖ്യ x പെട്ട വർഗ്ഗം.\n\t>>> classify_integer(24)\n\t6\n*/\nint classify_integer(char *x)", "fa": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nعدد صحیح x را بر اساس روش زیر طبقه‌بندی کنید:\nاگر x یک عدد یک‌رقمی باشد، x به کلاس خودش تعلق دارد.\nدر غیر این صورت، ارقام x را جمع کنید، یک x جدید بگیرید و تا زمانی که کلاس تعیین شود، تکرار کنید.\nپارامترها:\n- x (char*): عدد صحیحی که باید طبقه‌بندی شود.\n​    بازگشت:\n​    int: کلاسی که عدد صحیح x به آن تعلق دارد.\n\t>>> classify_integer(24)\n\t6\n*/\nint classify_integer(char *x)"}, "canonical_solution": "{\n\tint n = 0, i, a, t;\n    for (i = 0; i < strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}", "instruction": {"en": "int classify_integer(char *x)\n{\n\tint n = 0, i, a, t;\n    for (i = 0; i < strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "sq": "int classify_integer(char *x)\n{\n\tint n = 0, i, a, t;\n    for (i = 0; i < strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C në gjuhën shqipe duke përdorur maksimumi 500 karaktere.", "hy": "int classify_integer(char *x)\n{\n\tint n = 0, i, a, t;\n    for (i = 0; i < strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}\n\nՏվեք C կոդի հակիրճ բնութագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։", "bn": "int classify_integer(char *x)\n{\n\tint n = 0, i, a, t;\n    for (i = 0; i < strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}\n\nসি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।", "bg": "int classify_integer(char *x)\n{\n\tint n = 0, i, a, t;\n    for (i = 0; i < strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, използвайки най-много 500 знака.", "zh": "int classify_integer(char *x)\n{\n\tint n = 0, i, a, t;\n    for (i = 0; i < strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}\n\n请用中文为以下C代码提供简洁的自然语言描述（文档字符串），字数不超过500个字符。", "fr": "int classify_integer(char *x)\n{\n\tint n = 0, i, a, t;\n    for (i = 0; i < strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.", "de": "int classify_integer(char *x)\n{\n\tint n = 0, i, a, t;\n    for (i = 0; i < strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "int classify_integer(char *x)\n{\n\tint n = 0, i, a, t;\n    for (i = 0; i < strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}\n\nBa da takaitaccen bayanin yaren halitta (docstring) na lambar C a cikin Hausa ta amfani da haruffa 500 kawai.", "hi": "int classify_integer(char *x)\n{\n\tint n = 0, i, a, t;\n    for (i = 0; i < strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}\n\nC कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "int classify_integer(char *x)\n{\n\tint n = 0, i, a, t;\n    for (i = 0; i < strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben.", "es": "int classify_integer(char *x)\n{\n\tint n = 0, i, a, t;\n    for (i = 0; i < strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando como máximo 500 caracteres.", "arb": "int classify_integer(char *x)\n{\n\tint n = 0, i, a, t;\n    for (i = 0; i < strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.", "sw": "int classify_integer(char *x)\n{\n\tint n = 0, i, a, t;\n    for (i = 0; i < strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "int classify_integer(char *x)\n{\n\tint n = 0, i, a, t;\n    for (i = 0; i < strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}\n\nC kodunun işlevini açıklayan kısa bir doğal dil tanımı (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe olarak yazılmalıdır.", "vi": "int classify_integer(char *x)\n{\n\tint n = 0, i, a, t;\n    for (i = 0; i < strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã C bằng tiếng Việt với tối đa 500 ký tự.", "id": "int classify_integer(char *x)\n{\n\tint n = 0, i, a, t;\n    for (i = 0; i < strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode C tersebut dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "int classify_integer(char *x)\n{\n\tint n = 0, i, a, t;\n    for (i = 0; i < strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}\n\n以下のCコードの簡潔な自然言語による説明（ドックストリング）を日本語で500文字以内で提供してください。", "ko": "int classify_integer(char *x)\n{\n\tint n = 0, i, a, t;\n    for (i = 0; i < strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}\n\nC 코드에 대한 간결한 자연어 설명(도크스트링)을 한국어로 500자 이내로 제공하세요.", "ml": "int classify_integer(char *x)\n{\n\tint n = 0, i, a, t;\n    for (i = 0; i < strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}\n\nസീ കോഡിന്റെ ഡോക്സ്ട്രിംഗ് മലയാളത്തിൽ 500 അക്ഷരങ്ങൾക്കുള്ളിൽ ഉപയോഗിച്ച് സംക്ഷിപ്തമായ സ്വാഭാവിക ഭാഷാ വിവരണം നൽകുക.", "fa": "int classify_integer(char *x)\n{\n\tint n = 0, i, a, t;\n    for (i = 0; i < strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}\n\nتوضیح مختصر به زبان طبیعی (docstring) از کد C را به زبان فارسی با حداکثر ۵۰۰ کاراکتر ارائه دهید."}, "level": "", "test": "int main()\n{\n\tassert(classify_integer(\"24\") == 6);\n\tassert(classify_integer(\"39\") == 3);\n\tassert(classify_integer(\"123456789\") == 9);\n\tassert(classify_integer(\"123456789012345678901234567890\") == 9);\n\tassert(classify_integer(\"12345\") == 6);\n    assert(classify_integer(\"999999999\") == 9);\n    return 0;\n}", "entry_point": "classify_integer", "signature": "int classify_integer(char *x)", "docstring": {"en": "Classify the integer x based on the following method:\nIf x is a single-digit number, x belongs to its own class.\nOtherwise, sum the digits of x, get a new x, and iterate until the class is determined.\nParameters:\n- x (char*): The integer to be classified.\n\n    Returns:\n    int: The class to which the integer x belongs.\n\t>>> classify_integer(24)\n\t6\n", "sq": "Klasifikoni numrin e plotë x bazuar në metodën e mëposhtme: Nëse x është një numër me një shifër, x i përket klasës së vet. Përndryshe, mbledh shifrat e x, merr një x të ri dhe përsërit deri sa të përcaktohet klasa. Parametrat: - x (char*): Numri i plotë që do të klasifikohet.\n\n    Kthen:\n    int: Klasa së cilës i përket numri i plotë x.\n\t>>> classify_integer(24)\n\t6", "hy": "Դասակարգեք ամբողջ թիվ x-ը հետևյալ մեթոդով:\nԵթե x-ը միանիշ թիվ է, ապա x-ը պատկանում է իր սեփական դասին։\nՀակառակ դեպքում, գումարեք x-ի թվանշանները, ստացեք նոր x և կրկնեք, մինչև դասը որոշվի։  \nՊարամետրեր:  \n- x (char*): Դասակարգվող ամբողջ թիվը։  \n\n    Վերադարձնում է:  \n    int: Դասը, որին պատկանում է ամբողջ թիվը x։  \n\t>>> classify_integer(24)  \n\t6  ", "bn": "ইন্টিজার x নিম্নলিখিত পদ্ধতির ভিত্তিতে শ্রেণীবদ্ধ করুন:\nযদি x একটি এক অঙ্কের সংখ্যা হয়, তাহলে x তার নিজস্ব শ্রেণীতে অন্তর্ভুক্ত।\nঅন্যথায়, x এর অঙ্কগুলোর যোগফল নিন, একটি নতুন x পান, এবং শ্রেণী নির্ধারণ না হওয়া পর্যন্ত পুনরাবৃত্তি করুন।\nপ্যারামিটারসমূহ:\n- x (char*): শ্রেণীবদ্ধ করার জন্য ইন্টিজার।\n\n    রিটার্নস:\n    int: যে শ্রেণীতে ইন্টিজার x অন্তর্ভুক্ত।\n\t>>> classify_integer(24)\n\t6", "bg": "Класифицирайте цялото число x въз основа на следния метод:\nАко x е едноцифрено число, x принадлежи към своя собствен клас.\nВ противен случай, съберете цифрите на x, получете ново x и итерайте, докато класът бъде определен.\nПараметри:\n- x (char*): Цялото число, което ще бъде класифицирано.\n\n    Връща:\n    int: Класът, към който принадлежи цялото число x.\n\t>>> classify_integer(24)\n\t6", "zh": "根据以下方法对整数 x 进行分类：\n如果 x 是一位数，则 x 属于它自己的类。\n否则，将 x 的各位数字相加，得到一个新的 x，并迭代直到确定类。\n\n参数：\n- x (char*): 要分类的整数。\n\n    返回：\n    int: 整数 x 所属的类。\n\t>>> classify_integer(24)\n\t6", "fr": "Classifiez l'entier x selon la méthode suivante:\nSi x est un nombre à un chiffre, x appartient à sa propre classe.  \nSinon, additionnez les chiffres de x, obtenez un nouveau x, et itérez jusqu'à ce que la classe soit déterminée.  \nParamètres :  \n- x (char*) : L'entier à classer.\n\n    Renvoie :  \n    int : La classe à laquelle appartient l'entier x.  \n\t>>> classify_integer(24)\n\t6", "de": "Klassifizieren Sie die ganze Zahl x basierend auf der folgenden Methode:\nWenn x eine einstellige Zahl ist, gehört x zu seiner eigenen Klasse.\nAndernfalls summieren Sie die Ziffern von x, erhalten ein neues x und wiederholen den Vorgang, bis die Klasse bestimmt ist.\nParameter:\n- x (char*): Die zu klassifizierende ganze Zahl.\n\n    Rückgabewert:\n    int: Die Klasse, zu der die ganze Zahl x gehört.\n\t>>> classify_integer(24)\n\t6", "ha": "Rarraba lambar x bisa ga hanyar mai zuwa:\nIdan x lamba ce mai ɗigo ɗaya, x yana cikin ajin kansa. In ba haka ba, tara lambobin x, sami sabon x, kuma ci gaba da maimaitawa har sai an tantance ajin. Parameters: - x (char*): Lambar da za a tantance. Returns: int: Aji wanda lambar x take ciki. >>> classify_integer(24) 6", "hi": "पूर्णांक x को निम्नलिखित विधि के आधार पर वर्गीकृत करें:\nयदि x एक एकल-अंक संख्या है, तो x अपनी स्वयं की श्रेणी से संबंधित है।\nअन्यथा, x के अंकों का योग करें, एक नया x प्राप्त करें, और तब तक पुनरावृत्ति करें जब तक कि श्रेणी निर्धारित न हो जाए।\nParameters:\n- x (char*): वर्गीकृत करने के लिए पूर्णांक।\n\n    Returns:\n    int: वह श्रेणी जिससे पूर्णांक x संबंधित है।\n\t>>> classify_integer(24)\n\t6", "hu": "Osztályozza az x egész számot a következő módszer alapján:\nHa x egyjegyű szám, akkor x a saját osztályába tartozik.\nEgyébként összeadja x számjegyeit, kap egy új x-et, és iterál, amíg az osztály meg nem határozódik.\nParaméterek:\n- x (char*): Az osztályozandó egész szám.\n\n    Visszatér:\n    int: Az osztály, amelyhez az x egész szám tartozik.\n\t>>> classify_integer(24)\n\t6", "es": "Clasificar el entero x basado en el siguiente método:  \nSi x es un número de un solo dígito, x pertenece a su propia clase.  \nDe lo contrario, suma los dígitos de x, obtén un nuevo x, e itera hasta que se determine la clase.  \nParámetros:  \n- x (char*): El entero a clasificar.\n\n    Devuelve:  \n    int: La clase a la que pertenece el entero x.\n\t>>> classify_integer(24)\n\t6", "arb": "صنّف العدد الصحيح x بناءً على الطريقة التالية:\nإذا كان x رقمًا مكونًا من خانة واحدة، فإن x ينتمي إلى فئته الخاصة.\nوإلا، اجمع أرقام x، واحصل على x جديد، وكرر حتى يتم تحديد الفئة.\nالمعلمات:\n- x (char*): العدد الصحيح الذي سيتم تصنيفه.\n\n    العوائد:\n    int: الفئة التي ينتمي إليها العدد الصحيح x.\n\t>>> classify_integer(24)\n\t6", "sw": "Classify nambari x kulingana na njia ifuatayo:\nIkiwa x ni nambari ya tarakimu moja, x inahusiana na darasa lake lenyewe.\nVinginevyo, jumlisha tarakimu za x, pata x mpya, na rudia mpaka darasa litakapobainishwa.\nVigezo:\n- x (char*): Nambari ambayo inahitaji kuainishwa.\n\n    Inarudisha:\n    int: Darasa ambalo nambari x inahusiana.\n\t>>> classify_integer(24)\n\t6", "tr": "Tam sayı x'i aşağıdaki yönteme göre sınıflandırın:\nEğer x tek basamaklı bir sayıysa, x kendi sınıfına aittir.\nAksi takdirde, x'in basamaklarını toplayın, yeni bir x elde edin ve sınıf belirlenene kadar yineleyin.\nParametreler:\n- x (char*): Sınıflandırılacak tam sayı.\n\n    Döndürür:\n    int: Tam sayı x'in ait olduğu sınıf.\n\t>>> classify_integer(24)\n\t6", "vi": "Phân loại số nguyên x dựa trên phương pháp sau:\nNếu x là một số có một chữ số, x thuộc về lớp của chính nó.\nNgược lại, tổng các chữ số của x, lấy một x mới, và lặp lại cho đến khi xác định được lớp.\nTham số:\n- x (char*): Số nguyên cần được phân loại.\n\n    Trả về:\n    int: Lớp mà số nguyên x thuộc về.\n\t>>> classify_integer(24)\n\t6", "id": "Klasifikasikan bilangan bulat x berdasarkan metode berikut:\nJika x adalah angka satu digit, x termasuk dalam kelasnya sendiri.\nJika tidak, jumlahkan digit-digit x, dapatkan x baru, dan iterasi hingga kelas ditentukan.\nParameter:\n- x (char*): Bilangan bulat yang akan diklasifikasikan.\n\n    Mengembalikan:\n    int: Kelas di mana bilangan bulat x termasuk.\n\t>>> classify_integer(24)\n\t6", "ja": "整数 x を次の方法で分類します:\nx が一桁の数字の場合、x は自身のクラスに属します。\nそれ以外の場合、x の桁を合計し、新しい x を取得し、クラスが決定されるまで繰り返します。\nパラメータ:\n- x (char*): 分類される整数。\n\n    戻り値:\n    int: 整数 x が属するクラス。\n\t>>> classify_integer(24)\n\t6", "ko": "정수 x를 다음 방법에 따라 분류합니다:\nx가 한 자리 숫자이면, x는 자신의 클래스에 속합니다.\n그렇지 않으면, x의 각 자릿수를 더하여 새로운 x를 얻고, 클래스가 결정될 때까지 반복합니다.\n매개변수:\n- x (char*): 분류할 정수입니다.\n\n    반환값:\n    int: 정수 x가 속하는 클래스입니다.\n\t>>> classify_integer(24)\n\t6", "ml": "ഇനിപ്പറയുന്ന രീതിയിൽ പൂർണ്ണസംഖ്യ x ന്റെ വർഗ്ഗീകരണം ചെയ്യുക:\nx ഒറ്റ അക്ക സംഖ്യയായാൽ, x അതിന്റെ സ്വന്തം വർഗ്ഗത്തിൽപ്പെടുന്നു.\nഅല്ലെങ്കിൽ, x ന്റെ അക്കങ്ങൾ കൂട്ടിച്ചേർത്ത് ഒരു പുതിയ x നേടുക, വർഗ്ഗം നിർണ്ണയിക്കുന്നതുവരെ ആവർത്തിക്കുക.\nപാരാമീറ്ററുകൾ:\n- x (char*): വർഗ്ഗീകരിക്കേണ്ട പൂർണ്ണസംഖ്യ.\n\n    മടക്കുക:\n    int: പൂർണ്ണസംഖ്യ x ഏത് വർഗ്ഗത്തിൽപ്പെടുന്നു.\n\t>>> classify_integer(24)\n\t6", "fa": "عدد صحیح x را بر اساس روش زیر طبقه‌بندی کنید:\nاگر x یک عدد یک‌رقمی باشد، x به کلاس خودش تعلق دارد.\nدر غیر این صورت، ارقام x را جمع کنید، یک x جدید بگیرید و تا زمانی که کلاس تعیین شود، تکرار کنید.\nپارامترها:\n- x (char*): عدد صحیحی که باید طبقه‌بندی شود.\n\n    بازگشت:\n    int: کلاسی که عدد صحیح x به آن تعلق دارد.\n\t>>> classify_integer(24)\n\t6"}}
{"task_id": "C/27", "prompt": {"en": "#include <assert.h>\n#include <stdio.h>\n/*\nTransforms the case of a given letter.\n    Parameters:\n- letter (char): The input letter to be transformed.\n    Returns:\n- char: The letter with its case reversed. If the input is lowercase, it returns the uppercase version,\nand if the input is uppercase, it returns the lowercase version.\n    >>> transform_letter_case('b')\n    'Z'\n*/\nchar transform_letter_case(char letter);", "sq": "#include <assert.h>\n#include <stdio.h>\n/*\nTransformon rastin e një shkronje të dhënë.\n    Parametrat:\n- letter (char): Shkronja hyrëse që do të transformohet.\n    Kthen:\n- char: Shkronja me rastin e saj të kthyer. Nëse hyrja është me shkronja të vogla, kthen versionin me shkronja të mëdha,\ndhe nëse hyrja është me shkronja të mëdha, kthen versionin me shkronja të vogla.\n    >>> transform_letter_case('b')\n    'Z'\n*/\nchar transform_letter_case(char letter);", "hy": "#include <assert.h>\n#include <stdio.h>\n/*\nՓոխակերպում է տրված տառի ռեգիստրը։\n    Պարամետրեր:\n- letter (char): Մուտքային տառը, որը պետք է փոխակերպվի։\n    Վերադարձնում է:\n- char: Տառը՝ ռեգիստրը փոխված։ Եթե մուտքը փոքրատառ է, վերադարձնում է մեծատառ տարբերակը,\nիսկ եթե մուտքը մեծատառ է, վերադարձնում է փոքրատառ տարբերակը։\n    >>> transform_letter_case('b')\n    'Z'\n*/\nchar transform_letter_case(char letter);", "bn": "#include <assert.h>\n#include <stdio.h>\n/*\nএকটি প্রদত্ত অক্ষরের কেস পরিবর্তন করে।\n    প্যারামিটার:\n- letter (char): রূপান্তরিত হওয়ার জন্য ইনপুট অক্ষর।\n    রিটার্নস:\n- char: অক্ষরটি যার কেস বিপরীত হয়েছে। যদি ইনপুট ছোট হাতের হয়, এটি বড় হাতের সংস্করণ ফেরত দেয়,\nএবং যদি ইনপুট বড় হাতের হয়, এটি ছোট হাতের সংস্করণ ফেরত দেয়।\n    >>> transform_letter_case('b')\n    'Z'\n*/\nchar transform_letter_case(char letter);", "bg": "#include <assert.h>\n#include <stdio.h>\n/*\nПреобразува регистъра на дадена буква.\n    Параметри:\n- letter (char): Входната буква, която ще бъде преобразувана.\n    Връща:\n- char: Буквата с обърнат регистър. Ако входът е с малки букви, връща версията с главни букви,\nи ако входът е с главни букви, връща версията с малки букви.\n    >>> transform_letter_case('b')\n    'Z'\n*/\nchar transform_letter_case(char letter);", "zh": "#include <assert.h>\n#include <stdio.h>\n/*\n转换给定字母的大小写。\n    参数:\n- letter (char): 要转换的输入字母。\n    返回:\n- char: 大小写被反转的字母。如果输入是小写字母，则返回大写版本，\n如果输入是大写字母，则返回小写版本。\n    >>> transform_letter_case('b')\n    'Z'\n*/\nchar transform_letter_case(char letter);", "fr": "#include <assert.h>\n#include <stdio.h>\n/*\nTransforme la casse d'une lettre donnée.\n    Paramètres :\n- letter (char) : La lettre d'entrée à transformer.\n    Renvoie :\n- char : La lettre avec sa casse inversée. Si l'entrée est en minuscule, elle renvoie la version majuscule,\net si l'entrée est en majuscule, elle renvoie la version minuscule.\n    >>> transform_letter_case('b')\n    'Z'\n*/\nchar transform_letter_case(char letter);", "de": "#include <assert.h>\n#include <stdio.h>\n/*\nTransformiert die Groß-/Kleinschreibung eines gegebenen Buchstabens.\n    Parameter:\n- letter (char): Der Eingabebuchstabe, der transformiert werden soll.\n    Rückgabe:\n- char: Der Buchstabe mit umgekehrter Groß-/Kleinschreibung. Wenn die Eingabe klein geschrieben ist, wird die Großbuchstabenversion zurückgegeben,\nund wenn die Eingabe groß geschrieben ist, wird die Kleinbuchstabenversion zurückgegeben.\n    >>> transform_letter_case('b')\n    'Z'\n*/\nchar transform_letter_case(char letter);", "ha": "#include <assert.h>\n#include <stdio.h>\n/*\nCanza yanayin harafin da aka bayar.\n    Sigogi:\n- letter (char): Harafin shigarwa da za a canza.\n    Komawa:\n- char: Harafin tare da yanayinsa da aka juya. Idan shigarwar tana cikin ƙananan baƙaƙe, yana dawowa da babba,\nkuma idan shigarwar tana cikin babba, yana dawowa da ƙananan baƙaƙe.\n    >>> transform_letter_case('b')\n    'Z'\n*/\nchar transform_letter_case(char letter);", "hi": "#include <assert.h>\n#include <stdio.h>\n/*\nदिए गए अक्षर के मामले को बदलता है।\n    पैरामीटर:\n- letter (char): परिवर्तित होने वाला इनपुट अक्षर।\n    रिटर्न करता है:\n- char: अक्षर जिसका मामला उलट दिया गया है। यदि इनपुट लोअरकेस है, तो यह अपरकेस संस्करण लौटाता है,\nऔर यदि इनपुट अपरकेस है, तो यह लोअरकेस संस्करण लौटाता है।\n    >>> transform_letter_case('b')\n    'Z'\n*/\nchar transform_letter_case(char letter);", "hu": "#include <assert.h>\n#include <stdio.h>\n/*\nÁtalakítja egy adott betű esetét.\n    Paraméterek:\n- letter (char): Az átalakítandó bemeneti betű.\n    Visszatér:\n- char: A betű megfordított esettel. Ha a bemenet kisbetű, akkor a nagybetűs változatot adja vissza,\nés ha a bemenet nagybetű, akkor a kisbetűs változatot adja vissza.\n    >>> transform_letter_case('b')\n    'Z'\n*/\nchar transform_letter_case(char letter);", "es": "#include <assert.h>\n#include <stdio.h>\n/*\nTransforma el caso de una letra dada.\n    Parámetros:\n- letter (char): La letra de entrada a ser transformada.\n    Devuelve:\n- char: La letra con su caso invertido. Si la entrada es minúscula, devuelve la versión en mayúscula,\ny si la entrada es mayúscula, devuelve la versión en minúscula.\n    >>> transform_letter_case('b')\n    'Z'\n*/\nchar transform_letter_case(char letter);", "arb": "#include <assert.h>\n#include <stdio.h>\n/*\nتحول حالة حرف معين.\n    المعاملات:\n- letter (char): الحرف المدخل الذي سيتم تحويله.\n    يعيد:\n- char: الحرف مع عكس حالته. إذا كان المدخل بحروف صغيرة، فإنه يعيد النسخة الكبيرة،\nوإذا كان المدخل بحروف كبيرة، فإنه يعيد النسخة الصغيرة.\n    >>> transform_letter_case('b')\n    'Z'\n*/\nchar transform_letter_case(char letter);", "sw": "#include <assert.h>\n#include <stdio.h>\n/*\nHubadilisha herufi kubwa au ndogo ya herufi iliyotolewa.\n    Vigezo:\n- letter (char): Herufi ya kuingiza inayopaswa kubadilishwa.\n    Inarudisha:\n- char: Herufi ikiwa na herufi kubwa au ndogo imebadilishwa. Ikiwa ingizo ni herufi ndogo, inarudisha toleo la herufi kubwa,\nna ikiwa ingizo ni herufi kubwa, inarudisha toleo la herufi ndogo.\n    >>> transform_letter_case('b')\n    'Z'\n*/\nchar transform_letter_case(char letter);", "tr": "#include <assert.h>\n#include <stdio.h>\n/*\nVerilen bir harfin durumunu değiştirir.\n    Parametreler:\n- letter (char): Dönüştürülecek giriş harfi.\n    Döndürür:\n- char: Harfin durumu ters çevrilmiş hali. Eğer giriş küçük harfse, büyük harf versiyonunu döndürür,\nve eğer giriş büyük harfse, küçük harf versiyonunu döndürür.\n    >>> transform_letter_case('b')\n    'Z'\n*/\nchar transform_letter_case(char letter);", "vi": "#include <assert.h>\n#include <stdio.h>\n/*\nChuyển đổi chữ hoa/thường của một chữ cái cho trước.\n    Tham số:\n- letter (char): Chữ cái đầu vào cần được chuyển đổi.\n    Trả về:\n- char: Chữ cái với chữ hoa/thường được đảo ngược. Nếu đầu vào là chữ thường, nó trả về phiên bản chữ hoa,\nvà nếu đầu vào là chữ hoa, nó trả về phiên bản chữ thường.\n    >>> transform_letter_case('b')\n    'Z'\n*/\nchar transform_letter_case(char letter);", "id": "#include <assert.h>\n#include <stdio.h>\n/*\nMengubah huruf menjadi huruf dengan kasus yang berbeda.\n    Parameter:\n- letter (char): Huruf masukan yang akan diubah.\n    Mengembalikan:\n- char: Huruf dengan kasus yang dibalik. Jika masukan adalah huruf kecil, maka akan mengembalikan versi huruf besar,\ndan jika masukan adalah huruf besar, maka akan mengembalikan versi huruf kecil.\n    >>> transform_letter_case('b')\n    'Z'\n*/\nchar transform_letter_case(char letter);", "ja": "#include <assert.h>\n#include <stdio.h>\n/*\n与えられた文字の大文字小文字を変換します。\n    パラメータ:\n- letter (char): 変換する入力文字。\n    戻り値:\n- char: 大文字小文字が逆になった文字。入力が小文字の場合、大文字版を返し、\n入力が大文字の場合、小文字版を返します。\n    >>> transform_letter_case('b')\n    'Z'\n*/\nchar transform_letter_case(char letter);", "ko": "#include <assert.h>\n#include <stdio.h>\n/*\n주어진 문자의 대소문자를 변환합니다.\n    매개변수:\n- letter (char): 변환할 입력 문자입니다.\n    반환값:\n- char: 대소문자가 반전된 문자입니다. 입력이 소문자이면 대문자 버전을 반환하고,\n입력이 대문자이면 소문자 버전을 반환합니다.\n    >>> transform_letter_case('b')\n    'Z'\n*/\nchar transform_letter_case(char letter);", "ml": "#include <assert.h>\n#include <stdio.h>\n/*\nഒരു നൽകിയ അക്ഷരത്തിന്റെ കേസ് മാറ്റുന്നു.\n    പാരാമീറ്ററുകൾ:\n- letter (char): മാറ്റാൻ വേണ്ട ഇൻപുട്ട് അക്ഷരം.\n    മടക്കാൻ:\n- char: അക്ഷരം അതിന്റെ കേസ് മറിച്ചാണ് മടക്കുന്നത്. ഇൻപുട്ട് ചെറുതക്ഷരം ആണെങ്കിൽ, അത് വലിയക്ഷര രൂപം മടക്കുന്നു,\nമറ്റുമുള്ളത് വലിയക്ഷരം ആണെങ്കിൽ, അത് ചെറുതക്ഷര രൂപം മടക്കുന്നു.\n    >>> transform_letter_case('b')\n    'Z'\n*/\nchar transform_letter_case(char letter);", "fa": "#include <assert.h>\n#include <stdio.h>\n/*\nتبدیل حالت یک حرف داده شده.\n    پارامترها:\n- letter (char): حرف ورودی که باید تبدیل شود.\n    بازگشت:\n- char: حرف با حالت معکوس شده. اگر ورودی حروف کوچک باشد، نسخه بزرگ آن را برمی‌گرداند،\nو اگر ورودی حروف بزرگ باشد، نسخه کوچک آن را برمی‌گرداند.\n    >>> transform_letter_case('b')\n    'Z'\n*/\nchar transform_letter_case(char letter);"}, "canonical_solution": "char transform_letter_case(char letter) {\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    } else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}", "instruction": {"en": "char transform_letter_case(char letter)\nchar transform_letter_case(char letter) {\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    } else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "sq": "char transform_letter_case(char letter)\nchar transform_letter_case(char letter) {\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    } else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C në shqip duke përdorur maksimumi 500 karaktere.", "hy": "char transform_letter_case(char letter)\nchar transform_letter_case(char letter) {\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    } else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}\n\nՏվեք C կոդի հակիրճ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "char transform_letter_case(char letter)\nchar transform_letter_case(char letter) {\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    } else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}\n\nসি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হতে হবে।", "bg": "char transform_letter_case(char letter)\nchar transform_letter_case(char letter) {\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    } else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, използвайки не повече от 500 знака.", "zh": "char transform_letter_case(char letter)\nchar transform_letter_case(char letter) {\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    } else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}\n\n将以下 C 代码的功能用中文自然语言简洁描述（文档字符串），字数不超过 500 个字符。", "fr": "char transform_letter_case(char letter)\nchar transform_letter_case(char letter) {\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    } else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.", "de": "char transform_letter_case(char letter)\nchar transform_letter_case(char letter) {\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    } else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "char transform_letter_case(char letter)\nchar transform_letter_case(char letter) {\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    } else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar C cikin Hausa ta amfani da haruffa 500 kawai.", "hi": "char transform_letter_case(char letter)\nchar transform_letter_case(char letter) {\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    } else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}\n\nC कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रींग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "char transform_letter_case(char letter)\nchar transform_letter_case(char letter) {\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    } else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben.", "es": "char transform_letter_case(char letter)\nchar transform_letter_case(char letter) {\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    } else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando un máximo de 500 caracteres.", "arb": "char transform_letter_case(char letter)\nchar transform_letter_case(char letter) {\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    } else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "char transform_letter_case(char letter)\nchar transform_letter_case(char letter) {\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    } else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "char transform_letter_case(char letter)\nchar transform_letter_case(char letter) {\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    } else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}\n\nVerilen C kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda özlü bir doğal dil açıklaması (docstring) sağlayın.", "vi": "char transform_letter_case(char letter)\nchar transform_letter_case(char letter) {\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    } else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã C bằng tiếng Việt với tối đa 500 ký tự.", "id": "char transform_letter_case(char letter)\nchar transform_letter_case(char letter) {\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    } else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode C dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "char transform_letter_case(char letter)\nchar transform_letter_case(char letter) {\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    } else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}\n\nCコードの内容を日本語で簡潔に説明するドキュメンテーション文字列（docstring）を500文字以内で提供してください。", "ko": "char transform_letter_case(char letter)\nchar transform_letter_case(char letter) {\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    } else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}\n\nC 코드의 동작을 설명하는 간결한 자연어 설명(docstring)을 한국어로 작성하세요. 최대 500자 이내로 작성해야 합니다.", "ml": "char transform_letter_case(char letter)\nchar transform_letter_case(char letter) {\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    } else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}\n\nസീ കോഡിന് 500 അക്ഷരങ്ങളിൽ കവിയാതെയുള്ള സംക്ഷിപ്തമായ സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) മലയാളത്തിൽ നൽകുക.", "fa": "char transform_letter_case(char letter)\nchar transform_letter_case(char letter) {\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    } else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}\n\nتوضیح مختصر و طبیعی (docstring) از کد C به زبان فارسی ارائه دهید که حداکثر ۵۰۰ کاراکتر باشد."}, "level": "", "test": "int main() {\n    assert(transform_letter_case('b') == 'B');\n    assert(transform_letter_case('B') == 'b');\n\n    // Additional test cases\n    assert(transform_letter_case('z') == 'Z');\n    assert(transform_letter_case('Z') == 'z');\n    assert(transform_letter_case('m') == 'M');\n    assert(transform_letter_case('M') == 'm');\n    assert(transform_letter_case('1') == '1'); // Non-alphabetic, should be unchanged\n    assert(transform_letter_case('!') == '!'); // Non-alphabetic, should be unchanged\n    return 0;\n}", "entry_point": "transform_letter_case", "signature": "char transform_letter_case(char letter)", "docstring": {"en": "Transforms the case of a given letter.\n    Parameters:\n- letter (char): The input letter to be transformed.\n    Returns:\n- char: The letter with its case reversed. If the input is lowercase, it returns the uppercase version,\nand if the input is uppercase, it returns the lowercase version.\n    >>> transform_letter_case('b')\n    'Z'\n", "sq": "Transformon rastin e një shkronje të dhënë.\n    Parametrat:\n- letter (char): Shkronja hyrëse që do të transformohet.\n    Kthen:\n- char: Shkronja me rastin e saj të kthyer. Nëse hyrja është me shkronja të vogla, kthen versionin me shkronja të mëdha,\ndhe nëse hyrja është me shkronja të mëdha, kthen versionin me shkronja të vogla.\n    >>> transform_letter_case('b')\n    'Z'", "hy": "Փոխակերպում է տրված տառի ռեգիստրը։\n    Պարամետրեր:\n- letter (char): Մուտքային տառը, որը պետք է փոխակերպվի։\n    Վերադարձնում է:\n- char: Տառը՝ հակառակ ռեգիստրով։ Եթե մուտքը փոքրատառ է, վերադարձնում է մեծատառ տարբերակը,\nիսկ եթե մուտքը մեծատառ է, վերադարձնում է փոքրատառ տարբերակը։\n    >>> transform_letter_case('b')\n    'Z'", "bn": "একটি প্রদত্ত অক্ষরের কেস পরিবর্তন করে।\n    প্যারামিটার:\n- letter (char): পরিবর্তন করার জন্য ইনপুট অক্ষর।\n    Returns:\n- char: অক্ষরটি যার কেস উল্টানো হয়েছে। যদি ইনপুট ছোট হাতের হয়, এটি বড় হাতের সংস্করণ ফেরত দেয়,\nএবং যদি ইনপুট বড় হাতের হয়, এটি ছোট হাতের সংস্করণ ফেরত দেয়।\n    >>> transform_letter_case('b')\n    'Z'", "bg": "Преобразува регистъра на дадена буква.\n    Параметри:\n- letter (char): Входната буква, която ще бъде преобразувана.\n    Връща:\n- char: Буквата с обърнат регистър. Ако входът е с малки букви, връща версията с главни букви,\nи ако входът е с главни букви, връща версията с малки букви.\n    >>> transform_letter_case('b')\n    'Z'", "zh": "将给定字母的大小写转换。\n    参数:\n- letter (char): 要转换的输入字母。\n\n返回:\n- char: 大小写反转后的字母。如果输入为小写，则返回大写版本；如果输入为大写，则返回小写版本。\n\n    >>> transform_letter_case('b')\n    'Z'", "fr": "Transforme la casse d'une lettre donnée.\n    Paramètres:\n- letter (char): La lettre d'entrée à transformer.\n    Renvoie:\n- char: La lettre avec sa casse inversée. Si l'entrée est en minuscule, elle renvoie la version majuscule,\net si l'entrée est en majuscule, elle renvoie la version minuscule.\n    >>> transform_letter_case('b')\n    'Z'", "de": "Verändert die Groß-/Kleinschreibung eines gegebenen Buchstabens.\n    Parameter:\n- letter (char): Der Eingabebuchstabe, der transformiert werden soll.\n    Rückgabe:\n- char: Der Buchstabe mit umgekehrter Groß-/Kleinschreibung. Wenn die Eingabe klein geschrieben ist, wird die Großbuchstabenversion zurückgegeben, und wenn die Eingabe groß geschrieben ist, wird die Kleinbuchstabenversion zurückgegeben.\n    >>> transform_letter_case('b')\n    'Z'", "ha": "Canza yanayin harafin da aka bayar.\n    Sigogi:\n- letter (char): Harafin shigarwa da za a canza.\n    Returns:\n- char: Harafin tare da canza yanayin rubutunsa. Idan shigarwar tana cikin ƙananan haruffa, zai dawo da babbar harafi,\nkuma idan shigarwar tana cikin babbar haruffa, zai dawo da ƙananan harafi.\n    >>> transform_letter_case('b')\n    'Z'", "hi": "दिए गए अक्षर का केस बदलता है।\n    पैरामीटर्स:\n- letter (char): परिवर्तित होने वाला इनपुट अक्षर।\n    रिटर्न्स:\n- char: अक्षर जिसके केस को उल्टा कर दिया गया है। यदि इनपुट लोअरकेस है, तो यह अपरकेस संस्करण लौटाता है,\nऔर यदि इनपुट अपरकेस है, तो यह लोअरकेस संस्करण लौटाता है।\n    >>> transform_letter_case('b')\n    'Z'", "hu": "Átalakítja egy adott betű esetét.\n    Paraméterek:\n- letter (char): Az átalakítandó bemeneti betű.\n    Visszatér:\n- char: A betű az esetével megfordítva. Ha a bemenet kisbetűs, akkor a nagybetűs változatot adja vissza,\nés ha a bemenet nagybetűs, akkor a kisbetűs változatot adja vissza.\n    >>> transform_letter_case('b')\n    'Z'", "es": "Transforma el caso de una letra dada.\n    Parámetros:\n- letter (char): La letra de entrada a transformar.\n    Retorna:\n- char: La letra con su caso invertido. Si la entrada es minúscula, devuelve la versión mayúscula,\ny si la entrada es mayúscula, devuelve la versión minúscula.\n    >>> transform_letter_case('b')\n    'Z'", "arb": "يحول حالة حرف معين.\n    المعلمات:\n- letter (char): الحرف المدخل الذي سيتم تحويله.\n    يعيد:\n- char: الحرف مع حالته معكوسة. إذا كان المدخل بحروف صغيرة، يعيد النسخة بحروف كبيرة،\nوإذا كان المدخل بحروف كبيرة، يعيد النسخة بحروف صغيرة.\n    >>> transform_letter_case('b')\n    'Z'", "sw": "Hubadilisha herufi ya kesi iliyotolewa.\n\n    Vigezo:\n- letter (char): Herufi ya kuingiza inayopaswa kubadilishwa.\n\n    Inarudisha:\n- char: Herufi ikiwa na kesi yake imebadilishwa. Ikiwa ingizo ni herufi ndogo, inarudisha toleo la herufi kubwa,\nna ikiwa ingizo ni herufi kubwa, inarudisha toleo la herufi ndogo.\n\n    >>> transform_letter_case('b')\n    'Z'", "tr": "Verilen bir harfin durumunu dönüştürür.\n    Parametreler:\n- letter (char): Dönüştürülecek giriş harfi.\n    Döndürülenler:\n- char: Harfin durumu ters çevrilmiş hali. Eğer giriş küçük harfse, büyük harf versiyonunu döndürür,\nve eğer giriş büyük harfse, küçük harf versiyonunu döndürür.\n    >>> transform_letter_case('b')\n    'Z'", "vi": "Chuyển đổi chữ hoa/thường của một chữ cái đã cho.\n    Tham số:\n- letter (char): Chữ cái đầu vào cần được chuyển đổi.\n    Trả về:\n- char: Chữ cái với chữ hoa/thường được đảo ngược. Nếu đầu vào là chữ thường, nó trả về phiên bản chữ hoa,\nvà nếu đầu vào là chữ hoa, nó trả về phiên bản chữ thường.\n    >>> transform_letter_case('b')\n    'Z'", "id": "Mengubah huruf besar/kecil dari sebuah huruf yang diberikan.  \n    Parameter:  \n- letter (char): Huruf input yang akan diubah.  \n    Mengembalikan:  \n- char: Huruf dengan huruf besar/kecil yang dibalik. Jika input adalah huruf kecil, akan mengembalikan versi huruf besar, dan jika input adalah huruf besar, akan mengembalikan versi huruf kecil.  \n    >>> transform_letter_case('b')  \n    'Z'  ", "ja": "与えられた文字の大文字小文字を変換します。\n    引数:\n- letter (char): 変換する入力文字。\n    戻り値:\n- char: 大文字小文字が反転した文字。入力が小文字の場合、大文字版を返し、入力が大文字の場合、小文字版を返します。\n    >>> transform_letter_case('b')\n    'Z'", "ko": "주어진 문자의 대소문자를 변환합니다.\n    매개변수:\n- letter (char): 변환할 입력 문자입니다.\n    반환값:\n- char: 대소문자가 반전된 문자입니다. 입력이 소문자이면 대문자 버전을 반환하고, 입력이 대문자이면 소문자 버전을 반환합니다.\n    >>> transform_letter_case('b')\n    'Z'", "ml": "ഒരു നൽകിയ അക്ഷരത്തിന്റെ കേസ് മാറ്റുന്നു.\n    പാരാമീറ്ററുകൾ:\n- letter (char): മാറ്റം വരുത്തേണ്ട ഇൻപുട്ട് അക്ഷരം.\n    മടക്കം:\n- char: അക്ഷരത്തിന്റെ കേസ് മറിച്ചിരിക്കുന്നു. ഇൻപുട്ട് ലൊകേസായാൽ, അത് അപ്പർകേസ് പതിപ്പ് മടക്കമായി നൽകും,\nഅല്ലെങ്കിൽ ഇൻപുട്ട് അപ്പർകേസായാൽ, അത് ലൊകേസായി മടക്കമായി നൽകും.\n    >>> transform_letter_case('b')\n    'Z'", "fa": "تبدیل حالت یک حرف داده شده.\n    پارامترها:\n- letter (char): حرف ورودی که باید تبدیل شود.\n    بازگشت:\n- char: حرف با حالت معکوس شده. اگر ورودی با حروف کوچک باشد، نسخه بزرگ آن را برمی‌گرداند،\nو اگر ورودی با حروف بزرگ باشد، نسخه کوچک آن را برمی‌گرداند.\n    >>> transform_letter_case('b')\n    'Z'"}}
{"task_id": "C/28", "prompt": {"en": "#include <stdio.h>\n#include <assert.h>\n/*\nDisplay the ASCII information for a given character.\n​    Parameters:\n- character (char): The input character for which ASCII information is to be displayed.\n​    Returns:\n- int: corresponding ASCII code\n    >>> display_ascii_info('A')\n    65\n*/\nint display_ascii_info(char character)\n{", "sq": "#include <stdio.h>\n#include <assert.h>\n/*\nShfaq informacionin ASCII për një karakter të dhënë.\n​    Parametrat:\n- character (char): Karakteri i futur për të cilin informacioni ASCII do të shfaqet.\n​    Kthen:\n- int: kodi përkatës ASCII\n    >>> display_ascii_info('A')\n    65\n*/\nint display_ascii_info(char character)\n{", "hy": "#include <stdio.h>\n#include <assert.h>\n/*\nՑուցադրել ASCII տեղեկատվությունը տրված սիմվոլի համար։\n​    Պարամետրեր:\n- character (char): Մուտքային սիմվոլը, որի համար պետք է ցուցադրվի ASCII տեղեկատվությունը։\n​    Վերադարձնում է:\n- int: համապատասխան ASCII կոդը\n    >>> display_ascii_info('A')\n    65\n*/\nint display_ascii_info(char character)\n{", "bn": "#include <stdio.h>\n#include <assert.h>\n/*\nএকটি প্রদত্ত অক্ষরের জন্য ASCII তথ্য প্রদর্শন করুন।\n​    প্যারামিটার:\n- character (char): ইনপুট অক্ষর যার জন্য ASCII তথ্য প্রদর্শন করা হবে।\n​    রিটার্নস:\n- int: সংশ্লিষ্ট ASCII কোড\n    >>> display_ascii_info('A')\n    65\n*/\nint display_ascii_info(char character)\n{", "bg": "#include <stdio.h>\n#include <assert.h>\n/*\nПоказва ASCII информацията за даден символ.\n​    Параметри:\n- character (char): Входният символ, за който трябва да се покаже ASCII информация.\n​    Връща:\n- int: съответстващ ASCII код\n    >>> display_ascii_info('A')\n    65\n*/\nint display_ascii_info(char character)\n{", "zh": "#include <stdio.h>\n#include <assert.h>\n/*\n显示给定字符的ASCII信息。\n    参数:\n- character (char): 要显示ASCII信息的输入字符。\n    返回:\n- int: 对应的ASCII代码\n    >>> display_ascii_info('A')\n    65\n*/\nint display_ascii_info(char character)\n{", "fr": "#include <stdio.h>\n#include <assert.h>\n/*\nAfficher les informations ASCII pour un caractère donné.\n​    Paramètres :\n- character (char) : Le caractère d'entrée pour lequel les informations ASCII doivent être affichées.\n​    Renvoie :\n- int : code ASCII correspondant\n    >>> display_ascii_info('A')\n    65\n*/\nint display_ascii_info(char character)\n{", "de": "#include <stdio.h>\n#include <assert.h>\n/*\nZeigt die ASCII-Informationen für ein gegebenes Zeichen an.\n​    Parameter:\n- character (char): Das Eingabezeichen, für das die ASCII-Informationen angezeigt werden sollen.\n​    Rückgabewert:\n- int: entsprechender ASCII-Code\n    >>> display_ascii_info('A')\n    65\n*/\nint display_ascii_info(char character)\n{", "ha": "#include <stdio.h>\n#include <assert.h>\n/*\nNuna bayanin ASCII don wata alama da aka bayar.\n​    Sigogi:\n- character (char): Alamar shigarwa wadda za a nuna bayanin ASCII dinta.\n​    Komawa:\n- int: lambar ASCII da ta dace\n    >>> display_ascii_info('A')\n    65\n*/\nint display_ascii_info(char character)\n{", "hi": "#include <stdio.h>\n#include <assert.h>\n/*\nदिए गए वर्ण के लिए ASCII जानकारी प्रदर्शित करें।\n​    पैरामीटर्स:\n- character (char): वह इनपुट वर्ण जिसके लिए ASCII जानकारी प्रदर्शित की जानी है।\n​    रिटर्न्स:\n- int: संबंधित ASCII कोड\n    >>> display_ascii_info('A')\n    65\n*/\nint display_ascii_info(char character)\n{", "hu": "#include <stdio.h>\n#include <assert.h>\n/*\nMegjeleníti a megadott karakter ASCII információit.\n​    Paraméterek:\n- character (char): Az a bemeneti karakter, amelynek az ASCII információit meg kell jeleníteni.\n​    Visszatérési érték:\n- int: a megfelelő ASCII kód\n    >>> display_ascii_info('A')\n    65\n*/\nint display_ascii_info(char character)\n{", "es": "#include <stdio.h>\n#include <assert.h>\n/*\nMostrar la información ASCII para un carácter dado.\n​    Parámetros:\n- character (char): El carácter de entrada para el cual se mostrará la información ASCII.\n​    Devuelve:\n- int: código ASCII correspondiente\n    >>> display_ascii_info('A')\n    65\n*/\nint display_ascii_info(char character)\n{", "arb": "#include <stdio.h>\n#include <assert.h>\n/*\nعرض معلومات ASCII لحرف معين.\n​    المعلمات:\n- character (char): الحرف المدخل الذي سيتم عرض معلومات ASCII له.\n​    يعيد:\n- int: الكود ASCII المقابل\n    >>> display_ascii_info('A')\n    65\n*/\nint display_ascii_info(char character)\n{", "sw": "#include <stdio.h>\n#include <assert.h>\n/*\nOnyesha taarifa za ASCII kwa herufi iliyotolewa.\n​    Vigezo:\n- character (char): Herufi ya pembejeo ambayo taarifa za ASCII zinapaswa kuonyeshwa.\n​    Inarejesha:\n- int: msimbo wa ASCII unaolingana\n    >>> display_ascii_info('A')\n    65\n*/\nint display_ascii_info(char character)\n{", "tr": "#include <stdio.h>\n#include <assert.h>\n/*\nBelirtilen bir karakter için ASCII bilgisini göster.\n​    Parametreler:\n- character (char): ASCII bilgisinin gösterileceği giriş karakteri.\n​    Döndürür:\n- int: Karşılık gelen ASCII kodu\n    >>> display_ascii_info('A')\n    65\n*/\nint display_ascii_info(char character)\n{", "vi": "#include <stdio.h>\n#include <assert.h>\n/*\nHiển thị thông tin ASCII cho một ký tự cho trước.\n    Tham số:\n- character (char): Ký tự đầu vào mà thông tin ASCII cần được hiển thị.\n    Trả về:\n- int: mã ASCII tương ứng\n    >>> display_ascii_info('A')\n    65\n*/\nint display_ascii_info(char character)\n{", "id": "#include <stdio.h>\n#include <assert.h>\n/*\nMenampilkan informasi ASCII untuk karakter yang diberikan.\n    Parameter:\n- character (char): Karakter input yang informasinya akan ditampilkan.\n    Mengembalikan:\n- int: kode ASCII yang sesuai\n    >>> display_ascii_info('A')\n    65\n*/\nint display_ascii_info(char character)\n{", "ja": "#include <stdio.h>\n#include <assert.h>\n/*\n指定された文字のASCII情報を表示します。\n​    パラメータ:\n- character (char): ASCII情報を表示するための入力文字。\n​    戻り値:\n- int: 対応するASCIIコード\n    >>> display_ascii_info('A')\n    65\n*/\nint display_ascii_info(char character)\n{\n", "ko": "#include <stdio.h>\n#include <assert.h>\n/*\n주어진 문자에 대한 ASCII 정보를 표시합니다.\n​    매개변수:\n- character (char): ASCII 정보를 표시할 입력 문자입니다.\n​    반환:\n- int: 해당 ASCII 코드\n    >>> display_ascii_info('A')\n    65\n*/\nint display_ascii_info(char character)\n{", "ml": "#include <stdio.h>\n#include <assert.h>\n/*\nഒരു നൽകിയ അക്ഷരത്തിനായുള്ള ASCII വിവരങ്ങൾ പ്രദർശിപ്പിക്കുക.\n​    പാരാമീറ്ററുകൾ:\n- character (char): ASCII വിവരങ്ങൾ പ്രദർശിപ്പിക്കേണ്ട ഇൻപുട്ട് അക്ഷരം.\n​    മടക്കുന്നു:\n- int: അനുബന്ധ ASCII കോഡ്\n    >>> display_ascii_info('A')\n    65\n*/\nint display_ascii_info(char character)\n{", "fa": "#include <stdio.h>\n#include <assert.h>\n/*\nنمایش اطلاعات ASCII برای یک کاراکتر داده شده.\n​    پارامترها:\n- character (char): کاراکتر ورودی که اطلاعات ASCII آن باید نمایش داده شود.\n​    بازگشت:\n- int: کد ASCII مربوطه\n    >>> display_ascii_info('A')\n    65\n*/\nint display_ascii_info(char character)\n{"}, "canonical_solution": "return character;\n}", "instruction": {"en": "int display_ascii_info(char character)\nreturn character;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "sq": "int display_ascii_info(char character)\nreturn character;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C në shqip duke përdorur maksimumi 500 karaktere.", "hy": "int display_ascii_info(char character)\nreturn character;\n}\n\nՏվեք C կոդի հակիրճ բնութագրություն (docstring) հայերեն լեզվով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "int display_ascii_info(char character)\nreturn character;\n}\n\nসি কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হতে হবে।", "bg": "int display_ascii_info(char character)\nreturn character;\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, използвайки най-много 500 знака.", "zh": "int display_ascii_info(char character)\nreturn character;\n}\n\n请用不超过500个字符的中文，为以下C代码提供简洁的自然语言描述（文档字符串）。", "fr": "int display_ascii_info(char character)\nreturn character;\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.", "de": "int display_ascii_info(char character)\nreturn character;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "int display_ascii_info(char character)\nreturn character;\n}\n\nBa da takaitaccen bayani a cikin yaren halitta (docstring) na lambar C cikin Hausa ta amfani da haruffa 500 kacal.", "hi": "int display_ascii_info(char character)\nreturn character;\n}\n\nC कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "int display_ascii_info(char character)\nreturn character;\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben.", "es": "int display_ascii_info(char character)\nreturn character;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando un máximo de 500 caracteres.", "arb": "int display_ascii_info(char character)\nreturn character;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "int display_ascii_info(char character)\nreturn character;\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "int display_ascii_info(char character)\nreturn character;\n}\n\nC kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda bir doğal dil açıklaması (docstring) sağlayın.", "vi": "int display_ascii_info(char character)\nreturn character;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã C bằng tiếng Việt, không quá 500 ký tự.", "id": "int display_ascii_info(char character)\nreturn character;\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode C dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "int display_ascii_info(char character)\nreturn character;\n}\n\nCコードの内容を簡潔に説明する自然言語の記述（ドックストリング）を日本語で500文字以内で提供してください。", "ko": "int display_ascii_info(char character)\nreturn character;\n}\n\nC 코드에 대한 간결한 자연어 설명(docstring)을 한국어로 최대 500자 이내로 제공하세요.", "ml": "int display_ascii_info(char character)\nreturn character;\n}\n\nസിയുടെ കോഡ് ഉപയോഗിച്ച് 500 അക്ഷരങ്ങളിൽ കവിയാതെ മലയാളത്തിൽ സംക്ഷിപ്തമായ പ്രകൃതിദത്ത ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) നൽകുക.", "fa": "int display_ascii_info(char character)\nreturn character;\n}\n\nتوضیح مختصر و طبیعی (docstring) از کد C به زبان فارسی ارائه دهید که حداکثر ۵۰۰ کاراکتر باشد."}, "level": "", "test": "int main() {\n    assert(display_ascii_info('A') == 65);\n    assert(display_ascii_info('B') == 66); // Additional test case\n    assert(display_ascii_info('0') == 48); // Additional test case\n    assert(display_ascii_info(' ') == 32); // Additional test case\n    // printf(\"All tests passed.\\n\");\n    return 0;\n}", "entry_point": "display_ascii_info", "signature": "int display_ascii_info(char character)", "docstring": {"en": "Display the ASCII information for a given character.\n\n    Parameters:\n- character (char): The input character for which ASCII information is to be displayed.\n\n    Returns:\n- int: corresponding ASCII code\n    >>> display_ascii_info('A')\n    65\n", "sq": "Shfaq informacionin ASCII për një karakter të dhënë.\n\n    Parametra:\n- character (char): Karakteri i hyrjes për të cilin do të shfaqet informacioni ASCII.\n\n    Kthen:\n- int: kodi përkatës ASCII\n    >>> display_ascii_info('A')\n    65", "hy": "Տպել տրված սիմվոլի ASCII տեղեկատվությունը։\n\n    Պարամետրեր:\n- character (char): Մուտքային սիմվոլը, որի համար պետք է տպել ASCII տեղեկատվությունը։\n\n    Վերադարձնում է:\n- int: համապատասխան ASCII կոդը\n    >>> display_ascii_info('A')\n    65", "bn": "একটি প্রদত্ত অক্ষরের জন্য ASCII তথ্য প্রদর্শন করুন।\n\n    প্যারামিটারসমূহ:\n- character (char): ইনপুট অক্ষর যার জন্য ASCII তথ্য প্রদর্শন করা হবে।\n\n    Returns:\n- int: সংশ্লিষ্ট ASCII কোড\n    >>> display_ascii_info('A')\n    65", "bg": "Показва ASCII информацията за даден символ.\n\n    Параметри:\n- character (char): Входният символ, за който трябва да се покаже ASCII информацията.\n\n    Връща:\n- int: съответстващ ASCII код\n    >>> display_ascii_info('A')\n    65", "zh": "显示给定字符的ASCII信息。\n\n    参数：\n- character (char): 要显示其ASCII信息的输入字符。\n\n    返回：\n- int: 对应的ASCII码\n    >>> display_ascii_info('A')\n    65", "fr": "Afficher les informations ASCII pour un caractère donné.\n\n    Paramètres:\n- character (char): Le caractère d'entrée pour lequel les informations ASCII doivent être affichées.\n\n    Renvoie:\n- int: code ASCII correspondant\n    >>> display_ascii_info('A')\n    65", "de": "Zeige die ASCII-Informationen für ein gegebenes Zeichen an.\n\n    Parameter:\n- character (char): Das Eingabezeichen, für das die ASCII-Informationen angezeigt werden sollen.\n\n    Rückgabewerte:\n- int: entsprechender ASCII-Code\n    >>> display_ascii_info('A')\n    65", "ha": "Nuna bayanin ASCII don wata alama da aka bayar.\n\n    Sigogi:\n- character (char): Harafin shigarwa wanda za a nuna bayanin ASCII.\n\n    Dawowa:\n- int: lambar ASCII mai dacewa\n    >>> display_ascii_info('A')\n    65", "hi": "Display के लिए दिए गए वर्ण की ASCII जानकारी।\n\n    पैरामीटर्स:\n- character (char): वह इनपुट वर्ण जिसके लिए ASCII जानकारी प्रदर्शित की जानी है।\n\n    Returns:\n- int: संबंधित ASCII कोड\n    >>> display_ascii_info('A')\n    65", "hu": "Jelenítse meg egy adott karakter ASCII-információját.\n\n    Paraméterek:\n- character (char): Az a bemeneti karakter, amelynek az ASCII-információját meg kell jeleníteni.\n\n    Visszatér:\n- int: a megfelelő ASCII kód\n    >>> display_ascii_info('A')\n    65", "es": "Mostrar la información ASCII para un carácter dado.\n\n    Parámetros:\n- character (char): El carácter de entrada para el cual se mostrará la información ASCII.\n\n    Devuelve:\n- int: código ASCII correspondiente\n    >>> display_ascii_info('A')\n    65", "arb": "عرض معلومات ASCII للحرف المعطى.\n\n    المعلمات:\n- character (char): الحرف المدخل الذي سيتم عرض معلومات ASCII له.\n\n    يعيد:\n- int: رمز ASCII المقابل\n    >>> display_ascii_info('A')\n    65", "sw": "Onyesha taarifa za ASCII kwa herufi iliyotolewa.\n\n    Vigezo:\n- character (char): Herufi ya ingizo ambayo taarifa za ASCII zinapaswa kuonyeshwa.\n\n    Inarejesha:\n- int: nambari ya ASCII inayolingana\n    >>> display_ascii_info('A')\n    65", "tr": "Verilen bir karakter için ASCII bilgisini görüntüleyin.\n\n    Parametreler:\n- character (char): ASCII bilgisinin görüntüleneceği giriş karakteri.\n\n    Döndürülenler:\n- int: karşılık gelen ASCII kodu\n    >>> display_ascii_info('A')\n    65", "vi": "Hiển thị thông tin ASCII cho một ký tự cho trước.\n\n    Tham số:\n- character (char): Ký tự đầu vào mà thông tin ASCII cần được hiển thị.\n\n    Trả về:\n- int: mã ASCII tương ứng\n    >>> display_ascii_info('A')\n    65", "id": "Tampilkan informasi ASCII untuk karakter yang diberikan.\n\n    Parameter:\n- character (char): Karakter input yang informasinya akan ditampilkan dalam bentuk ASCII.\n\n    Mengembalikan:\n- int: kode ASCII yang sesuai\n    >>> display_ascii_info('A')\n    65", "ja": "与えられた文字のASCII情報を表示します。\n\n    パラメータ:\n- character (char): ASCII情報を表示するための入力文字。\n\n    戻り値:\n- int: 対応するASCIIコード\n    >>> display_ascii_info('A')\n    65", "ko": "주어진 문자에 대한 ASCII 정보를 표시합니다.\n\n    매개변수:\n- character (char): ASCII 정보를 표시할 입력 문자입니다.\n\n    반환값:\n- int: 해당 ASCII 코드\n    >>> display_ascii_info('A')\n    65", "ml": "ASCII വിവരങ്ങൾ നൽകിയ പ്രതീകത്തിനായി പ്രദർശിപ്പിക്കുക.\n\n    പാരാമീറ്ററുകൾ:\n- character (char): ASCII വിവരങ്ങൾ പ്രദർശിപ്പിക്കേണ്ട ഇൻപുട്ട് പ്രതീകം.\n\n    മടക്കുന്നു:\n- int: അനുബന്ധ ASCII കോഡ്\n    >>> display_ascii_info('A')\n    65", "fa": "نمایش اطلاعات ASCII برای یک کاراکتر داده شده.\n\n    پارامترها:\n- character (char): کاراکتر ورودی که اطلاعات ASCII برای آن نمایش داده می‌شود.\n\n    بازگشت:\n- int: کد ASCII متناظر\n    >>> display_ascii_info('A')\n    65"}}
{"task_id": "C/29", "prompt": {"en": "#include <assert.h> // Used for testing the function with assertions\n#include <math.h> // Not needed for this function\n#include <stdbool.h> // Not needed for this function\n#include <stdio.h> // Needed for input/output functions\n#include <string.h> // Not needed for this function\n/*\nEvaluate the grade for an input integer.\n    Parameters:\n- score (int): The integer score to be evaluated.\n    Returns:\n​​    char: The grade corresponding to the input score.\n​​         If the score is between 90 and 100 (inclusive), returns 'A'.\n​​         Otherwise, returns 'B'.\n>>> evaluate_integer_grade(90)\nA\n*/\nchar evaluate_integer_grade(int score)", "sq": "#include <assert.h> // Përdoret për të testuar funksionin me pohime\n#include <math.h> // Nuk nevojitet për këtë funksion\n#include <stdbool.h> // Nuk nevojitet për këtë funksion\n#include <stdio.h> // Nevojitet për funksionet e hyrje/dalje\n#include <string.h> // Nuk nevojitet për këtë funksion\n/*\nVlerëson notën për një numër të plotë hyrës.\n    Parametrat:\n- score (int): Nota e plotë që do të vlerësohet.\n    Kthen:\n​​    char: Nota që korrespondon me notën hyrëse.\n​​         Nëse nota është midis 90 dhe 100 (përfshirë), kthen 'A'.\n​​         Përndryshe, kthen 'B'.\n>>> evaluate_integer_grade(90)\nA\n*/\nchar evaluate_integer_grade(int score)", "hy": "#include <assert.h> // Օգտագործվում է ֆունկցիան ստուգելու համար հաստատումներով\n#include <math.h> // Անհրաժեշտ չէ այս ֆունկցիայի համար\n#include <stdbool.h> // Անհրաժեշտ չէ այս ֆունկցիայի համար\n#include <stdio.h> // Անհրաժեշտ է մուտք/ելքի ֆունկցիաների համար\n#include <string.h> // Անհրաժեշտ չէ այս ֆունկցիայի համար\n/*\nԳնահատել մուտքային ամբողջ թվի գնահատականը։\n    Պարամետրեր:\n- score (int): Գնահատվող ամբողջ թիվը։\n    Վերադարձնում է:\n​​    char: Մուտքային գնահատականին համապատասխան գնահատականը։\n​​         Եթե գնահատականը 90-ից 100 միջակայքում է (ներառյալ), վերադարձնում է 'A'։\n​​         Հակառակ դեպքում, վերադարձնում է 'B'։\n>>> evaluate_integer_grade(90)\nA\n*/\nchar evaluate_integer_grade(int score)", "bn": "#include <assert.h> // ফাংশনটি পরীক্ষার জন্য assertions ব্যবহার করা হয়\n#include <math.h> // এই ফাংশনের জন্য প্রয়োজন নেই\n#include <stdbool.h> // এই ফাংশনের জন্য প্রয়োজন নেই\n#include <stdio.h> // ইনপুট/আউটপুট ফাংশনের জন্য প্রয়োজন\n#include <string.h> // এই ফাংশনের জন্য প্রয়োজন নেই\n/*\nএকটি ইনপুট পূর্ণসংখ্যার জন্য গ্রেড মূল্যায়ন করুন।\n    প্যারামিটার:\n- score (int): মূল্যায়ন করার জন্য পূর্ণসংখ্যার স্কোর।\n    রিটার্ন:\n​​    char: ইনপুট স্কোরের সাথে সম্পর্কিত গ্রেড।\n​​         যদি স্কোর 90 এবং 100 এর মধ্যে (অন্তর্ভুক্ত) হয়, 'A' রিটার্ন করে।\n​​         অন্যথায়, 'B' রিটার্ন করে।\n>>> evaluate_integer_grade(90)\nA\n*/\nchar evaluate_integer_grade(int score)", "bg": "#include <assert.h> // Използва се за тестване на функцията с твърдения\n#include <math.h> // Не е необходимо за тази функция\n#include <stdbool.h> // Не е необходимо за тази функция\n#include <stdio.h> // Необходимо за входно/изходни функции\n#include <string.h> // Не е необходимо за тази функция\n/*\nОценете оценката за входящо цяло число.\n    Параметри:\n- score (int): Целочислената оценка, която трябва да бъде оценена.\n    Връща:\n​​    char: Оценката, съответстваща на входящата оценка.\n​​         Ако оценката е между 90 и 100 (включително), връща 'A'.\n​​         В противен случай връща 'B'.\n>>> evaluate_integer_grade(90)\nA\n*/\nchar evaluate_integer_grade(int score)", "zh": "#include <assert.h> // 用于使用断言测试函数\n#include <math.h> // 此函数不需要\n#include <stdbool.h> // 此函数不需要\n#include <stdio.h> // 需要用于输入/输出函数\n#include <string.h> // 此函数不需要\n/*\n评估输入整数的等级。\n    参数:\n- score (int): 要评估的整数分数。\n    返回:\n​​    char: 与输入分数对应的等级。\n​​         如果分数在90到100之间（包括90和100），返回 'A'。\n​​         否则，返回 'B'。\n>>> evaluate_integer_grade(90)\nA\n*/\nchar evaluate_integer_grade(int score)", "fr": "#include <assert.h> // Utilisé pour tester la fonction avec des assertions\n#include <math.h> // Pas nécessaire pour cette fonction\n#include <stdbool.h> // Pas nécessaire pour cette fonction\n#include <stdio.h> // Nécessaire pour les fonctions d'entrée/sortie\n#include <string.h> // Pas nécessaire pour cette fonction\n/*\nÉvaluer la note pour un entier en entrée.\n    Paramètres :\n- score (int) : Le score entier à évaluer.\n    Renvoie :\n​​    char : La note correspondant au score d'entrée.\n​​         Si le score est entre 90 et 100 (inclus), renvoie 'A'.\n​​         Sinon, renvoie 'B'.\n>>> evaluate_integer_grade(90)\nA\n*/\nchar evaluate_integer_grade(int score)", "de": "#include <assert.h> // Wird für das Testen der Funktion mit Assertions verwendet\n#include <math.h> // Nicht benötigt für diese Funktion\n#include <stdbool.h> // Nicht benötigt für diese Funktion\n#include <stdio.h> // Benötigt für Ein-/Ausgabefunktionen\n#include <string.h> // Nicht benötigt für diese Funktion\n/*\nBewertet die Note für eine Eingabe als Ganzzahl.\n    Parameter:\n- score (int): Die zu bewertende Ganzzahl.\n    Rückgabe:\n​​    char: Die Note, die der Eingabe entspricht.\n​​         Wenn der Score zwischen 90 und 100 (einschließlich) liegt, wird 'A' zurückgegeben.\n​​         Andernfalls wird 'B' zurückgegeben.\n>>> evaluate_integer_grade(90)\nA\n*/\nchar evaluate_integer_grade(int score)", "ha": "#include <assert.h> // Ana amfani da wannan don gwada aikin tare da tabbaci\n#include <math.h> // Ba a bukata don wannan aikin\n#include <stdbool.h> // Ba a bukata don wannan aikin\n#include <stdio.h> // Ana bukata don ayyukan shigarwa/fitarwa\n#include <string.h> // Ba a bukata don wannan aikin\n/*\nKimanta darajar wani cikakken lamba.\n    Sigogi:\n- score (int): Cikakken lambar da za a kimanta.\n    Komawa:\n​​    char: Darajar da ta dace da cikakken lambar da aka shigar.\n​​         Idan lambar tana tsakanin 90 da 100 (ciki har da), zai dawo da 'A'.\n​​         In ba haka ba, zai dawo da 'B'.\n>>> evaluate_integer_grade(90)\nA\n*/\nchar evaluate_integer_grade(int score)", "hi": "#include <assert.h> // assert के साथ फ़ंक्शन का परीक्षण करने के लिए उपयोग किया जाता है\n#include <math.h> // इस फ़ंक्शन के लिए आवश्यक नहीं है\n#include <stdbool.h> // इस फ़ंक्शन के लिए आवश्यक नहीं है\n#include <stdio.h> // इनपुट/आउटपुट फ़ंक्शंस के लिए आवश्यक है\n#include <string.h> // इस फ़ंक्शन के लिए आवश्यक नहीं है\n/*\nएक इनपुट पूर्णांक के लिए ग्रेड का मूल्यांकन करें।\n    पैरामीटर्स:\n- score (int): पूर्णांक स्कोर जिसका मूल्यांकन किया जाना है।\n    रिटर्न्स:\n​​    char: इनपुट स्कोर के अनुरूप ग्रेड।\n​​         यदि स्कोर 90 और 100 के बीच (समावेशी) है, तो 'A' लौटाता है।\n​​         अन्यथा, 'B' लौटाता है।\n>>> evaluate_integer_grade(90)\nA\n*/\nchar evaluate_integer_grade(int score)", "hu": "#include <assert.h> // A függvény teszteléséhez használt állításokhoz\n#include <math.h> // Erre a függvényre nincs szükség\n#include <stdbool.h> // Erre a függvényre nincs szükség\n#include <stdio.h> // Szükséges a bemeneti/kimeneti függvényekhez\n#include <string.h> // Erre a függvényre nincs szükség\n/*\nÉrtékeli a bemeneti egész szám osztályzatát.\n    Paraméterek:\n- score (int): Az értékelendő egész szám pontszám.\n    Visszatér:\n​​    char: Az osztályzat, amely megfelel a bemeneti pontszámnak.\n​​         Ha a pontszám 90 és 100 között van (beleértve), 'A'-t ad vissza.\n​​         Egyébként 'B'-t ad vissza.\n>>> evaluate_integer_grade(90)\nA\n*/\nchar evaluate_integer_grade(int score)", "es": "#include <assert.h> // Usado para probar la función con afirmaciones\n#include <math.h> // No necesario para esta función\n#include <stdbool.h> // No necesario para esta función\n#include <stdio.h> // Necesario para funciones de entrada/salida\n#include <string.h> // No necesario para esta función\n/*\nEvalúa la calificación para un entero de entrada.\n    Parámetros:\n- score (int): La puntuación entera a evaluar.\n    Devuelve:\n​​    char: La calificación correspondiente a la puntuación de entrada.\n​​         Si la puntuación está entre 90 y 100 (inclusive), devuelve 'A'.\n​​         De lo contrario, devuelve 'B'.\n>>> evaluate_integer_grade(90)\nA\n*/\nchar evaluate_integer_grade(int score)", "arb": "#include <assert.h> // مستخدم لاختبار الدالة باستخدام التأكيدات\n#include <math.h> // غير مطلوب لهذه الدالة\n#include <stdbool.h> // غير مطلوب لهذه الدالة\n#include <stdio.h> // مطلوب لوظائف الإدخال/الإخراج\n#include <string.h> // غير مطلوب لهذه الدالة\n/*\nتقييم الدرجة لعدد صحيح مدخل.\n    المعاملات:\n- score (int): الدرجة الصحيحة التي سيتم تقييمها.\n    يعيد:\n​​    char: الدرجة المقابلة للدرجة المدخلة.\n​​         إذا كانت الدرجة بين 90 و 100 (شاملة)، يعيد 'A'.\n​​         خلاف ذلك، يعيد 'B'.\n>>> evaluate_integer_grade(90)\nA\n*/\nchar evaluate_integer_grade(int score)", "sw": "#include <assert.h> // Inatumika kwa kupima kazi na uthibitisho\n#include <math.h> // Haitajiki kwa kazi hii\n#include <stdbool.h> // Haitajiki kwa kazi hii\n#include <stdio.h> // Inahitajika kwa kazi za ingizo/utoaji\n#include <string.h> // Haitajiki kwa kazi hii\n/*\nTambua alama kwa namba kamili ya ingizo.\n    Vigezo:\n- score (int): Alama ya namba kamili inayotakiwa kutambuliwa.\n    Inarejesha:\n​​    char: Alama inayolingana na alama ya ingizo.\n​​         Ikiwa alama iko kati ya 90 na 100 (ikiwemo), inarejesha 'A'.\n​​         Vinginevyo, inarejesha 'B'.\n>>> evaluate_integer_grade(90)\nA\n*/\nchar evaluate_integer_grade(int score)", "tr": "#include <assert.h> // Fonksiyonu test etmek için assert kullanılır\n#include <math.h> // Bu fonksiyon için gerekli değil\n#include <stdbool.h> // Bu fonksiyon için gerekli değil\n#include <stdio.h> // Girdi/çıktı fonksiyonları için gerekli\n#include <string.h> // Bu fonksiyon için gerekli değil\n/*\nBir tamsayı notunu değerlendir.\n    Parametreler:\n- score (int): Değerlendirilecek tamsayı notu.\n    Döndürür:\n​​    char: Girdi notuna karşılık gelen harf notu.\n​​         Eğer not 90 ile 100 arasında (dahil) ise, 'A' döndürür.\n​​         Aksi takdirde, 'B' döndürür.\n>>> evaluate_integer_grade(90)\nA\n*/\nchar evaluate_integer_grade(int score)", "vi": "#include <assert.h> // Được sử dụng để kiểm tra hàm với các khẳng định\n#include <math.h> // Không cần thiết cho hàm này\n#include <stdbool.h> // Không cần thiết cho hàm này\n#include <stdio.h> // Cần thiết cho các hàm nhập/xuất\n#include <string.h> // Không cần thiết cho hàm này\n/*\nĐánh giá điểm cho một số nguyên đầu vào.\n    Tham số:\n- score (int): Điểm số nguyên cần được đánh giá.\n    Trả về:\n​​    char: Điểm tương ứng với điểm số đầu vào.\n​​         Nếu điểm số nằm trong khoảng từ 90 đến 100 (bao gồm), trả về 'A'.\n​​         Ngược lại, trả về 'B'.\n>>> evaluate_integer_grade(90)\nA\n*/\nchar evaluate_integer_grade(int score)", "id": "#include <assert.h> // Digunakan untuk menguji fungsi dengan asersi\n#include <math.h> // Tidak diperlukan untuk fungsi ini\n#include <stdbool.h> // Tidak diperlukan untuk fungsi ini\n#include <stdio.h> // Diperlukan untuk fungsi input/output\n#include <string.h> // Tidak diperlukan untuk fungsi ini\n/*\nEvaluasi nilai untuk sebuah bilangan bulat masukan.\n    Parameter:\n- score (int): Skor bilangan bulat yang akan dievaluasi.\n    Mengembalikan:\n​​    char: Nilai yang sesuai dengan skor masukan.\n​​         Jika skor antara 90 dan 100 (inklusif), mengembalikan 'A'.\n​​         Jika tidak, mengembalikan 'B'.\n>>> evaluate_integer_grade(90)\nA\n*/\nchar evaluate_integer_grade(int score)", "ja": "#include <assert.h> // アサーションで関数をテストするために使用\n#include <math.h> // この関数には不要\n#include <stdbool.h> // この関数には不要\n#include <stdio.h> // 入出力関数に必要\n#include <string.h> // この関数には不要\n/*\n入力された整数の評価を行う。\n    パラメータ:\n- score (int): 評価する整数のスコア。\n    戻り値:\n​​    char: 入力スコアに対応する成績。\n​​         スコアが90から100の間（含む）の場合、'A'を返す。\n​​         それ以外の場合は、'B'を返す。\n>>> evaluate_integer_grade(90)\nA\n*/\nchar evaluate_integer_grade(int score)", "ko": "#include <assert.h> // 함수 테스트를 위한 어서션에 사용됨\n#include <math.h> // 이 함수에는 필요하지 않음\n#include <stdbool.h> // 이 함수에는 필요하지 않음\n#include <stdio.h> // 입출력 함수에 필요함\n#include <string.h> // 이 함수에는 필요하지 않음\n/*\n입력 정수에 대한 등급을 평가합니다.\n    매개변수:\n- score (int): 평가할 정수 점수입니다.\n    반환값:\n​​    char: 입력 점수에 해당하는 등급입니다.\n​​         점수가 90에서 100 사이(포함)일 경우 'A'를 반환합니다.\n​​         그렇지 않으면 'B'를 반환합니다.\n>>> evaluate_integer_grade(90)\nA\n*/\nchar evaluate_integer_grade(int score)", "ml": "#include <assert.h> // ഫംഗ്ഷനെ അസർഷനുകൾ ഉപയോഗിച്ച് പരീക്ഷിക്കാൻ ഉപയോഗിക്കുന്നു\n#include <math.h> // ഈ ഫംഗ്ഷനിന് ആവശ്യമില്ല\n#include <stdbool.h> // ഈ ഫംഗ്ഷനിന് ആവശ്യമില്ല\n#include <stdio.h> // ഇൻപുട്ട്/ഔട്ട്പുട്ട് ഫംഗ്ഷനുകൾക്കായി ആവശ്യമുണ്ട്\n#include <string.h> // ഈ ഫംഗ്ഷനിന് ആവശ്യമില്ല\n/*\nഒരു ഇൻപുട്ട് പൂർണ്ണസംഖ്യയുടെ ഗ്രേഡ് വിലയിരുത്തുക.\n    പാരാമീറ്ററുകൾ:\n- score (int): വിലയിരുത്തേണ്ട പൂർണ്ണസംഖ്യ സ്കോർ.\n    റിട്ടേൺസ്:\n​​    char: ഇൻപുട്ട് സ്കോറിന് അനുയോജ്യമായ ഗ്രേഡ്.\n​​         സ്കോർ 90നും 100നും ഇടയിൽ (ഉൾപ്പെടെ) ആണെങ്കിൽ, 'A' റിട്ടേൺ ചെയ്യും.\n​​         അല്ലെങ്കിൽ, 'B' റിട്ടേൺ ചെയ്യും.\n>>> evaluate_integer_grade(90)\nA\n*/\nchar evaluate_integer_grade(int score)", "fa": "#include <assert.h> // برای آزمایش تابع با استفاده از ادعاها استفاده می‌شود\n#include <math.h> // برای این تابع مورد نیاز نیست\n#include <stdbool.h> // برای این تابع مورد نیاز نیست\n#include <stdio.h> // برای توابع ورودی/خروجی مورد نیاز است\n#include <string.h> // برای این تابع مورد نیاز نیست\n/*\nنمره را برای یک عدد صحیح ورودی ارزیابی کنید.\n    پارامترها:\n- score (int): نمره صحیحی که باید ارزیابی شود.\n    بازگشت:\n​​    char: نمره‌ای که با نمره ورودی مطابقت دارد.\n​​         اگر نمره بین 90 و 100 (شامل) باشد، 'A' را برمی‌گرداند.\n​​         در غیر این صورت، 'B' را برمی‌گرداند.\n>>> evaluate_integer_grade(90)\nA\n*/\nchar evaluate_integer_grade(int score)"}, "canonical_solution": "{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}", "instruction": {"en": "char evaluate_integer_grade(int score)\n{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "sq": "char evaluate_integer_grade(int score)\n{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C në shqip duke përdorur maksimumi 500 karaktere.", "hy": "char evaluate_integer_grade(int score)\n{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}\n\nՏրամադրեք C կոդի հակիրճ բնութագրում (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "char evaluate_integer_grade(int score)\n{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}\n\nসি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।", "bg": "char evaluate_integer_grade(int score)\n{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, използвайки не повече от 500 знака.", "zh": "char evaluate_integer_grade(int score)\n{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}\n\n请用不超过500个字符的中文为以下C代码提供简洁的自然语言描述（文档字符串）。", "fr": "char evaluate_integer_grade(int score)\n{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.", "de": "char evaluate_integer_grade(int score)\n{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "char evaluate_integer_grade(int score)\n{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}\n\nBa da takaitaccen bayani a cikin harshen halitta (docstring) na lambar C a cikin Hausa ta amfani da haruffa 500 kacal.", "hi": "char evaluate_integer_grade(int score)\n{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}\n\nC कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।", "hu": "char evaluate_integer_grade(int score)\n{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben.", "es": "char evaluate_integer_grade(int score)\n{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando como máximo 500 caracteres.", "arb": "char evaluate_integer_grade(int score)\n{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "char evaluate_integer_grade(int score)\n{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "char evaluate_integer_grade(int score)\n{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}\n\nC kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter içermelidir.", "vi": "char evaluate_integer_grade(int score)\n{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã C bằng tiếng Việt với tối đa 500 ký tự.", "id": "char evaluate_integer_grade(int score)\n{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode C dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "char evaluate_integer_grade(int score)\n{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}\n\nCコードの内容を500文字以内で日本語の自然言語による説明（ドックストリング）を提供してください。", "ko": "char evaluate_integer_grade(int score)\n{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}\n\n다음 C 코드에 대한 간결한 자연어 설명(도크스트링)을 한국어로 500자 이내로 제공하세요.", "ml": "char evaluate_integer_grade(int score)\n{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}\n\nസീ കോഡിന്റെ ഡോക്സ്ട്രിംഗ് മലയാളത്തിൽ 500 അക്ഷരങ്ങളിൽ കവിയാതെയുള്ള സംക്ഷിപ്തമായ സ്വാഭാവിക ഭാഷാ വിവരണം നൽകുക.", "fa": "char evaluate_integer_grade(int score)\n{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}\n\nیک توضیح مختصر و طبیعی (docstring) از کد C به زبان فارسی ارائه دهید که حداکثر ۵۰۰ کاراکتر باشد."}, "level": "", "test": "int main() // Updated test function to reflect the correct usage of the evaluate_integer_grade function\n{\n    assert(evaluate_integer_grade(90) == 'A'); // Corrected the assertion to compare against character literals\n    assert(evaluate_integer_grade(89) == 'B'); // Additional test for a score less than 90\n    assert(evaluate_integer_grade(95) == 'A'); // Additional test within the 'A' range\n    assert(evaluate_integer_grade(100) == 'A'); // Additional test for the boundary condition\n    assert(evaluate_integer_grade(101) == 'B'); // Additional test for a score greater than 100\n\n    // Print \"All tests passed\" if all assertions hold true (optional)\n    // printf(\"All tests passed\\n\");\n\n    return 0;\n}", "entry_point": "evaluate_integer_grade", "signature": "char evaluate_integer_grade(int score)", "docstring": {"en": "Evaluate the grade for an input integer.\n    Parameters:\n- score (int): The integer score to be evaluated.\n    Returns:\n    char: The grade corresponding to the input score.\n    If the score is between 90 and 100 (inclusive), returns 'A'.\n    Otherwise, returns 'B'.\n>>> evaluate_integer_grade(90)\nA\n", "sq": "Vlerësoni notën për një numër të plotë hyrës.\n    Parametrat:\n- score (int): Rezultati i plotë që do të vlerësohet.\n    Kthen:\n    char: Nota që korrespondon me rezultatin hyrës.\n    Nëse rezultati është midis 90 dhe 100 (përfshirë), kthen 'A'.\n    Përndryshe, kthen 'B'.\n>>> evaluate_integer_grade(90)\nA", "hy": "Մուտքային ամբողջ թիվի գնահատականի գնահատում։  \n    Պարամետրեր:\n- score (int): Գնահատվող ամբողջ թիվը։\n    Վերադարձնում է:\n    char: Մուտքային գնահատականին համապատասխանող գնահատականը։\n    Եթե գնահատականը 90-ից 100 (ներառյալ) միջակայքում է, վերադարձնում է 'A'։  \n    Հակառակ դեպքում, վերադարձնում է 'B'։  \n>>> evaluate_integer_grade(90)\nA", "bn": "ইনপুট পূর্ণসংখ্যার জন্য গ্রেড মূল্যায়ন করুন।\n    Args:\n- score (int): মূল্যায়ন করার জন্য পূর্ণসংখ্যার স্কোর।\n    Returns:\n    char: ইনপুট স্কোরের সাথে সম্পর্কিত গ্রেড।\n    যদি স্কোর 90 এবং 100 এর মধ্যে হয় (অন্তর্ভুক্ত), তাহলে 'A' প্রদান করে।\n    অন্যথায়, 'B' প্রদান করে।\n>>> evaluate_integer_grade(90)\nA", "bg": "Оценете оценката за входящо цяло число.\n    Параметри:\n- score (int): Цялочислената оценка, която трябва да бъде оценена.\n    Връща:\n    char: Оценката, съответстваща на входящата оценка.\n    Ако оценката е между 90 и 100 (включително), връща 'A'.\n    В противен случай връща 'B'.\n>>> evaluate_integer_grade(90)\nA", "zh": "评估输入整数的等级。\n    参数:\n- score (int): 要评估的整数分数。\n    返回:\n    char: 与输入分数对应的等级。\n    如果分数在90到100之间（包括90和100），返回 'A'。\n    否则，返回 'B'。\n>>> evaluate_integer_grade(90)\nA", "fr": "Évaluer la note pour un entier en entrée.\n    Paramètres:\n- score (int): Le score entier à évaluer.\n    Renvoie:\n    char: La note correspondant au score d'entrée.\n    Si le score est entre 90 et 100 (inclus), renvoie 'A'.\n    Sinon, renvoie 'B'.\n>>> evaluate_integer_grade(90)\nA", "de": "Bewerten Sie die Note für eine eingegebene ganze Zahl.\n    Parameter:\n- score (int): Die zu bewertende ganze Zahl.\n    Rückgabewerte:\n    char: Die Note, die dem eingegebenen Score entspricht.\n    Wenn der Score zwischen 90 und 100 (einschließlich) liegt, wird 'A' zurückgegeben.\n    Andernfalls wird 'B' zurückgegeben.\n>>> evaluate_integer_grade(90)\nA", "ha": "Duba darajar don wani lamba mai shigarwa.\n    Sigogi:\n- score (int): Lambar maki da za a tantance.\n    Mayarwa:\n    char: Darajar da ta dace da maki da aka shigar.\n    Idan maki yana tsakanin 90 da 100 (ciki har da), yana mayar da 'A'.\n    In ba haka ba, yana mayar da 'B'.\n>>> evaluate_integer_grade(90)\nA", "hi": "इनपुट पूर्णांक के लिए ग्रेड का मूल्यांकन करें।\n    पैरामीटर्स:\n- score (int): मूल्यांकन के लिए पूर्णांक स्कोर।\n    Returns:\n    char: इनपुट स्कोर के अनुरूप ग्रेड।\n    यदि स्कोर 90 और 100 (समावेशी) के बीच है, तो 'A' लौटाता है।\n    अन्यथा, 'B' लौटाता है।\n>>> evaluate_integer_grade(90)\nA", "hu": "Értékeli a jegyet egy bemeneti egész számhoz.\n    Paraméterek:\n- score (int): Az értékelendő egész szám.\n    Visszatér:\n    char: A bemeneti pontszámnak megfelelő jegy.\n    Ha a pontszám 90 és 100 között van (beleértve), 'A'-t ad vissza.\n    Egyébként 'B'-t ad vissza.\n>>> evaluate_integer_grade(90)\nA", "es": "Evalúa la calificación para un número entero de entrada.\n    Parámetros:\n- score (int): La puntuación entera a evaluar.\n    Devuelve:\n    char: La calificación correspondiente a la puntuación de entrada.\n    Si la puntuación está entre 90 y 100 (inclusive), devuelve 'A'.\n    De lo contrario, devuelve 'B'.\n>>> evaluate_integer_grade(90)\nA", "arb": "تقييم الدرجة لعدد صحيح مدخل.\n    المعلمات:\n- score (int): الدرجة الصحيحة التي سيتم تقييمها.\n    يعيد:\n    char: الدرجة المقابلة للدرجة المدخلة.\n    إذا كانت الدرجة بين 90 و 100 (شاملة)، يعيد 'A'.\n    خلاف ذلك، يعيد 'B'.\n>>> evaluate_integer_grade(90)\nA", "sw": "Tathmini daraja kwa nambari kamili ya ingizo.\n    Vigezo:\n- score (int): Alama ya nambari kamili itakayopimwa.\n    Inarejesha:\n    char: Daraja linalolingana na alama ya ingizo.\n    Ikiwa alama iko kati ya 90 na 100 (ikijumuisha), inarejesha 'A'.\n    Vinginevyo, inarejesha 'B'.\n>>> evaluate_integer_grade(90)\nA", "tr": "Girdi tamsayısı için notu değerlendirir.\n    Parametreler:\n- score (int): Değerlendirilecek tamsayı puanı.\n    Döndürülenler:\n    char: Girdi puanına karşılık gelen not.\n    Eğer puan 90 ile 100 arasında (dahil) ise, 'A' döner.\n    Aksi takdirde, 'B' döner.\n>>> evaluate_integer_grade(90)\nA", "vi": "Đánh giá điểm cho một số nguyên đầu vào.  \n    Tham số:  \n- score (int): Điểm số nguyên cần được đánh giá.  \n    Trả về:  \n    char: Điểm tương ứng với điểm số đầu vào.  \n    Nếu điểm số nằm trong khoảng từ 90 đến 100 (bao gồm cả 90 và 100), trả về 'A'.  \n    Ngược lại, trả về 'B'.  \n>>> evaluate_integer_grade(90)  \nA  ", "id": "Evaluasi nilai untuk bilangan bulat masukan.\n    Parameter:\n- score (int): Skor bilangan bulat yang akan dievaluasi.\n    Mengembalikan:\n    char: Nilai yang sesuai dengan skor masukan.\n    Jika skor antara 90 dan 100 (inklusif), mengembalikan 'A'.\n    Jika tidak, mengembalikan 'B'.\n>>> evaluate_integer_grade(90)\nA", "ja": "入力された整数の評価を行います。\n    引数:\n- score (int): 評価する整数のスコア。\n    戻り値:\n    char: 入力スコアに対応する評価。\n    スコアが90から100の間（含む）の場合、'A'を返します。\n    それ以外の場合は、'B'を返します。\n>>> evaluate_integer_grade(90)\nA", "ko": "입력 정수에 대한 등급을 평가합니다.\n    매개변수:\n- score (int): 평가할 정수 점수입니다.\n    반환:\n    char: 입력 점수에 해당하는 등급입니다.\n    점수가 90에서 100 사이(포함)인 경우, 'A'를 반환합니다.\n    그렇지 않으면, 'B'를 반환합니다.\n>>> evaluate_integer_grade(90)\nA", "ml": "ഇൻപുട്ട് ഇന്റിജറിന് ഗ്രേഡ് വിലയിരുത്തുക.\n    പാരാമീറ്ററുകൾ:\n- score (int): വിലയിരുത്തേണ്ട ഇന്റിജർ സ്കോർ.\n    റിട്ടേൺസ്:\n    char: ഇൻപുട്ട് സ്കോറിന് അനുയോജ്യമായ ഗ്രേഡ്.\n    സ്കോർ 90നും 100നും ഇടയിൽ (ഉൾപ്പെടെ) ആണെങ്കിൽ, 'A' റിട്ടേൺ ചെയ്യും.\n    അല്ലെങ്കിൽ, 'B' റിട്ടേൺ ചെയ്യും.\n>>> evaluate_integer_grade(90)\nA", "fa": "ارزیابی نمره برای یک عدد صحیح ورودی.\n    پارامترها:\n- score (int): نمره صحیحی که باید ارزیابی شود.\n    بازگشت:\n    char: نمره‌ای که با نمره ورودی مطابقت دارد.\n    اگر نمره بین 90 و 100 (شامل) باشد، 'A' را برمی‌گرداند.\n    در غیر این صورت، 'B' را برمی‌گرداند.\n>>> evaluate_integer_grade(90)\nA"}}
{"task_id": "C/30", "prompt": {"en": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nChecks if a three-character string has exactly two characters that are the same.\n​\nArgs:\n    s (char array): The three-character string to be checked.\n​\nReturns:\n    str: Returns 'Yes' if the input has exactly two equal characters, otherwise 'No'.\n\t>>> check_two_equal_digits(112)\n\tYes\n*/\nconst char* check_two_equal_digits(const char s[4])", "sq": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nKontrollon nëse një varg me tre karaktere ka saktësisht dy karaktere që janë të njëjta.\n\nArgumentet:\n    s (varg karakteresh): Vargu me tre karaktere që do të kontrollohet.\n\nKthen:\n    str: Kthen 'Yes' nëse hyrja ka saktësisht dy karaktere të barabarta, përndryshe 'No'.\n\t>>> check_two_equal_digits(112)\n\tYes\n*/\nconst char* check_two_equal_digits(const char s[4])", "hy": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nՍտուգում է, արդյոք երեք նիշից բաղկացած տողում կա՞ն երկու նույնական նիշեր:\n​\nԱրձանագրություններ:\n    s (char զանգված): Երեք նիշից բաղկացած տողը, որը պետք է ստուգել:\n​\nՎերադարձնում է:\n    str: Վերադարձնում է 'Yes', եթե մուտքում կա երկու նույնական նիշ, հակառակ դեպքում՝ 'No':\n\t>>> check_two_equal_digits(112)\n\tYes\n*/\nconst char* check_two_equal_digits(const char s[4])", "bn": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nপরীক্ষা করে যে একটি তিন-অক্ষরের স্ট্রিং-এ ঠিক দুটি অক্ষর একই কিনা।\n\nআর্গুমেন্ট:\n    s (char array): তিন-অক্ষরের স্ট্রিং যা পরীক্ষা করা হবে।\n\nফেরত দেয়:\n    str: 'Yes' ফেরত দেয় যদি ইনপুটে ঠিক দুটি সমান অক্ষর থাকে, অন্যথায় 'No'।\n\t>>> check_two_equal_digits(112)\n\tYes\n*/\nconst char* check_two_equal_digits(const char s[4])", "bg": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nПроверява дали низ от три знака има точно два еднакви знака.\n​\nАргументи:\n    s (масив от символи): Низът от три знака, който ще бъде проверен.\n​\nВръща:\n    str: Връща 'Yes', ако входът има точно два еднакви знака, в противен случай 'No'.\n\t>>> check_two_equal_digits(112)\n\tYes\n*/\nconst char* check_two_equal_digits(const char s[4])", "zh": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n检查一个三字符的字符串是否恰好有两个字符相同。\n\n参数:\n    s (char array): 要检查的三字符字符串。\n\n返回:\n    str: 如果输入恰好有两个相同的字符，则返回 'Yes'，否则返回 'No'。\n\t>>> check_two_equal_digits(112)\n\tYes\n*/\nconst char* check_two_equal_digits(const char s[4])", "fr": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nVérifie si une chaîne de trois caractères a exactement deux caractères identiques.\n​\nArguments :\n    s (tableau de char) : La chaîne de trois caractères à vérifier.\n​\nRenvoie :\n    str : Renvoie 'Yes' si l'entrée a exactement deux caractères égaux, sinon 'No'.\n\t>>> check_two_equal_digits(112)\n\tYes\n*/\nconst char* check_two_equal_digits(const char s[4])", "de": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nPrüft, ob ein drei Zeichen langer String genau zwei gleiche Zeichen hat.\n\nArgumente:\n    s (char array): Der drei Zeichen lange String, der überprüft werden soll.\n\nRückgabewerte:\n    str: Gibt 'Yes' zurück, wenn der Eingabewert genau zwei gleiche Zeichen hat, ansonsten 'No'.\n\t>>> check_two_equal_digits(112)\n\tYes\n*/\nconst char* check_two_equal_digits(const char s[4])", "ha": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDuba idan kirtani mai haruffa uku yana da daidai haruffa biyu da suke daidai.\n​\nArgs:\n    s (char array): Kirtani mai haruffa uku da za a duba.\n​\nReturns:\n    str: Ya dawo da 'Yes' idan shigarwar tana da daidai haruffa biyu masu daidaito, in ba haka ba 'No'.\n\t>>> check_two_equal_digits(112)\n\tYes\n*/\nconst char* check_two_equal_digits(const char s[4])", "hi": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nजांचता है कि क्या तीन-अक्षर वाली स्ट्रिंग में ठीक दो अक्षर समान हैं।\n\nआर्ग्स:\n    s (char array): तीन-अक्षर वाली स्ट्रिंग जिसे जांचना है।\n\nरिटर्न्स:\n    str: 'Yes' लौटाता है यदि इनपुट में ठीक दो समान अक्षर हैं, अन्यथा 'No'।\n\t>>> check_two_equal_digits(112)\n\tYes\n*/\nconst char* check_two_equal_digits(const char s[4])", "hu": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nEllenőrzi, hogy egy három karakterből álló karakterláncban pontosan két azonos karakter van-e.\n\nArgumentumok:\n    s (karakter tömb): A három karakterből álló karakterlánc, amelyet ellenőrizni kell.\n\nVisszatér:\n    str: 'Yes'-t ad vissza, ha a bemenetben pontosan két egyenlő karakter van, különben 'No'-t.\n\t>>> check_two_equal_digits(112)\n\tYes\n*/\nconst char* check_two_equal_digits(const char s[4])", "es": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nVerifica si una cadena de tres caracteres tiene exactamente dos caracteres que son iguales.\n​\nArgs:\n    s (char array): La cadena de tres caracteres a verificar.\n​\nReturns:\n    str: Devuelve 'Yes' si la entrada tiene exactamente dos caracteres iguales, de lo contrario 'No'.\n\t>>> check_two_equal_digits(112)\n\tYes\n*/\nconst char* check_two_equal_digits(const char s[4])", "arb": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nيتحقق مما إذا كانت سلسلة مكونة من ثلاثة أحرف تحتوي على حرفين متطابقين بالضبط.\n\nالمعطيات:\n    s (مصفوفة char): السلسلة المكونة من ثلاثة أحرف التي سيتم التحقق منها.\n\nالقيم المعادة:\n    str: يعيد 'Yes' إذا كانت المدخلات تحتوي على حرفين متساويين بالضبط، وإلا يعيد 'No'.\n\t>>> check_two_equal_digits(112)\n\tYes\n*/\nconst char* check_two_equal_digits(const char s[4])", "sw": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nHukagua kama mfuatano wa herufi tatu una herufi mbili ambazo ni sawa kabisa.\n\nArgs:\n    s (char array): Mfuatano wa herufi tatu ambao unapaswa kukaguliwa.\n\nReturns:\n    str: Inarudisha 'Yes' ikiwa ingizo lina herufi mbili sawa kabisa, vinginevyo 'No'.\n\t>>> check_two_equal_digits(112)\n\tYes\n*/\nconst char* check_two_equal_digits(const char s[4])", "tr": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nÜç karakterli bir dizgede tam olarak iki karakterin aynı olup olmadığını kontrol eder.\n\nArgümanlar:\n    s (char dizi): Kontrol edilecek üç karakterli dizge.\n\nDöndürür:\n    str: Girdi tam olarak iki eşit karakter içeriyorsa 'Yes' döndürür, aksi takdirde 'No' döndürür.\n\t>>> check_two_equal_digits(112)\n\tYes\n*/\nconst char* check_two_equal_digits(const char s[4])", "vi": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nKiểm tra xem một chuỗi ba ký tự có chính xác hai ký tự giống nhau hay không.\n\nTham số:\n    s (mảng char): Chuỗi ba ký tự cần kiểm tra.\n\nTrả về:\n    str: Trả về 'Yes' nếu đầu vào có chính xác hai ký tự bằng nhau, ngược lại trả về 'No'.\n\t>>> check_two_equal_digits(112)\n\tYes\n*/\nconst char* check_two_equal_digits(const char s[4])", "id": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nMemeriksa apakah sebuah string tiga karakter memiliki tepat dua karakter yang sama.\n\nArgumen:\n    s (char array): String tiga karakter yang akan diperiksa.\n\nMengembalikan:\n    str: Mengembalikan 'Yes' jika input memiliki tepat dua karakter yang sama, jika tidak 'No'.\n\t>>> check_two_equal_digits(112)\n\tYes\n*/\nconst char* check_two_equal_digits(const char s[4])", "ja": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n3文字の文字列に、正確に2つの同じ文字があるかどうかを確認します。\n\n引数:\n    s (char array): チェックする3文字の文字列。\n\n戻り値:\n    str: 入力に正確に2つの等しい文字がある場合は 'Yes' を返し、それ以外の場合は 'No' を返します。\n\t>>> check_two_equal_digits(112)\n\tYes\n*/\nconst char* check_two_equal_digits(const char s[4])", "ko": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n세 글자로 이루어진 문자열에 정확히 두 개의 동일한 문자가 있는지 확인합니다.\n​\n인수:\n    s (char array): 확인할 세 글자로 이루어진 문자열입니다.\n​\n반환:\n    str: 입력에 정확히 두 개의 동일한 문자가 있으면 'Yes'를 반환하고, 그렇지 않으면 'No'를 반환합니다.\n\t>>> check_two_equal_digits(112)\n\tYes\n*/\nconst char* check_two_equal_digits(const char s[4])", "ml": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nഒരു മൂന്ന് അക്ഷരങ്ങളുടെ സ്ട്രിംഗിൽ കൃത്യമായി രണ്ട് അക്ഷരങ്ങൾ ഒരേപോലെയാണോ എന്ന് പരിശോധിക്കുന്നു.\n\nആർഗ്സ്:\n    s (char array): പരിശോധിക്കേണ്ട മൂന്ന് അക്ഷരങ്ങളുടെ സ്ട്രിംഗ്.\n\nമടക്കുന്നു:\n    str: ഇൻപുട്ടിൽ കൃത്യമായി രണ്ട് സമാന അക്ഷരങ്ങൾ ഉണ്ടെങ്കിൽ 'Yes' മടക്കുന്നു, അല്ലെങ്കിൽ 'No'.\n\t>>> check_two_equal_digits(112)\n\tYes\n*/\nconst char* check_two_equal_digits(const char s[4])", "fa": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nبررسی می‌کند که آیا یک رشته سه‌کاراکتری دقیقاً دو کاراکتر مشابه دارد یا خیر.\n\nآرگومان‌ها:\n    s (آرایه کاراکتر): رشته سه‌کاراکتری که باید بررسی شود.\n\nبازگشت:\n    str: 'Yes' را برمی‌گرداند اگر ورودی دقیقاً دو کاراکتر برابر داشته باشد، در غیر این صورت 'No'.\n\t>>> check_two_equal_digits(112)\n\tYes\n*/\nconst char* check_two_equal_digits(const char s[4])"}, "canonical_solution": "{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}", "instruction": {"en": "const char* check_two_equal_digits(const char s[4])\n{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "sq": "const char* check_two_equal_digits(const char s[4])\n{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C në shqip duke përdorur maksimumi 500 karaktere.", "hy": "const char* check_two_equal_digits(const char s[4])\n{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\nՏվեք C կոդի համառոտ բնական լեզվով նկարագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "const char* check_two_equal_digits(const char s[4])\n{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\nসি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।", "bg": "const char* check_two_equal_digits(const char s[4])\n{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, използвайки не повече от 500 знака.", "zh": "const char* check_two_equal_digits(const char s[4])\n{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\n请用中文为以下C代码提供简洁的自然语言描述（文档字符串），字数不超过500个字符。", "fr": "const char* check_two_equal_digits(const char s[4])\n{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.", "de": "const char* check_two_equal_digits(const char s[4])\n{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "const char* check_two_equal_digits(const char s[4])\n{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar C a cikin Hausa ta amfani da haruffa 500 ko kasa da haka.", "hi": "const char* check_two_equal_digits(const char s[4])\n{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\nC कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रींग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "const char* check_two_equal_digits(const char s[4])\n{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben.", "es": "const char* check_two_equal_digits(const char s[4])\n{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando como máximo 500 caracteres.", "arb": "const char* check_two_equal_digits(const char s[4])\n{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "const char* check_two_equal_digits(const char s[4])\n{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "const char* check_two_equal_digits(const char s[4])\n{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\nC kodunun işlevini açıklayan kısa bir doğal dil tanımı (docstring) sağlayın. Açıklama en fazla 500 karakter olmalıdır.", "vi": "const char* check_two_equal_digits(const char s[4])\n{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã C bằng tiếng Việt, sử dụng tối đa 500 ký tự.", "id": "const char* check_two_equal_digits(const char s[4])\n{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode C dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "const char* check_two_equal_digits(const char s[4])\n{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\nCコードの内容を日本語で簡潔に説明するドキュメンテーション文字列（docstring）を500文字以内で提供してください。", "ko": "const char* check_two_equal_digits(const char s[4])\n{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\nC 코드에 대한 간결한 자연어 설명(도크스트링)을 한국어로 최대 500자 이내로 제공하세요.", "ml": "const char* check_two_equal_digits(const char s[4])\n{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\nസിയുടെ കോഡ് ഉപയോഗിച്ച് 500 അക്ഷരങ്ങളിൽ കൂടുതൽ അല്ലാത്ത മലയാളത്തിൽ സംക്ഷിപ്തമായ സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) നൽകുക.", "fa": "const char* check_two_equal_digits(const char s[4])\n{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\nتوضیح مختصر و طبیعی (docstring) از کد C را به زبان فارسی با حداکثر ۵۰۰ کاراکتر ارائه دهید."}, "level": "", "test": "int main() {\n    // Testing the logic with various cases and using string comparison for assert.\n    assert(strcmp(check_two_equal_digits(\"112\"), \"Yes\") == 0);\n    assert(strcmp(check_two_equal_digits(\"123\"), \"No\") == 0);\n    assert(strcmp(check_two_equal_digits(\"232\"), \"Yes\") == 0);\n    assert(strcmp(check_two_equal_digits(\"444\"), \"No\") == 0); // All three characters are equal, not two.\n    assert(strcmp(check_two_equal_digits(\"121\"), \"Yes\") == 0);\n\n    // Additional test cases to cover more scenarios\n    assert(strcmp(check_two_equal_digits(\"787\"), \"Yes\") == 0);\n    assert(strcmp(check_two_equal_digits(\"999\"), \"No\") == 0); // All three characters are equal\n    assert(strcmp(check_two_equal_digits(\"890\"), \"No\") == 0);\n    assert(strcmp(check_two_equal_digits(\"556\"), \"Yes\") == 0);\n    assert(strcmp(check_two_equal_digits(\"353\"), \"Yes\") == 0); // No two characters are equal\n\n    \n    return 0;\n}", "entry_point": "check_two_equal_digits", "signature": "const char* check_two_equal_digits(const char s[4])", "docstring": {"en": "Checks if a three-character string has exactly two characters that are the same.\n\nArgs:\n    s (char array): The three-character string to be checked.\n\nReturns:\n    str: Returns 'Yes' if the input has exactly two equal characters, otherwise 'No'.\n    >>> check_two_equal_digits(112)\n    Yes\n", "sq": "Kontrollon nëse një varg me tre karaktere ka saktësisht dy karaktere që janë të njëjta.\n\nArgumentet:\n    s (varg karakteresh): Vargu me tre karaktere që do të kontrollohet.\n\nKthen:\n    str: Kthen 'Po' nëse inputi ka saktësisht dy karaktere të barabartë, përndryshe 'Jo'.\n    >>> check_two_equal_digits(112)\n    Po", "hy": "Ստուգում է, արդյոք երեք նիշից բաղկացած տողը ունի՞ ճիշտ երկու նույնական նիշ:\n\nԱրձագանքներ:\n    s (char array): Երեք նիշից բաղկացած տողը, որը պետք է ստուգվի:\n\nՎերադարձնում է:\n    str: Վերադարձնում է 'Yes', եթե մուտքագրումը ունի ճիշտ երկու հավասար նիշ, հակառակ դեպքում՝ 'No':\n    >>> check_two_equal_digits(112)\n    Yes", "bn": "তিন-অক্ষরের একটি স্ট্রিং-এ ঠিক দুটি অক্ষর একই আছে কিনা তা পরীক্ষা করে।\n\nআর্গস:\n    s (char array): তিন-অক্ষরের স্ট্রিং যা পরীক্ষা করা হবে।\n\nরিটার্নস:\n    str: 'Yes' রিটার্ন করে যদি ইনপুটে ঠিক দুটি সমান অক্ষর থাকে, অন্যথায় 'No'।\n    >>> check_two_equal_digits(112)\n    Yes", "bg": "Проверява дали низ от три знака има точно два еднакви знака.\n\nАргументи:\n    s (char array): Низът от три знака, който ще бъде проверен.\n\nВръща:\n    str: Връща 'Yes', ако входът има точно два еднакви знака, в противен случай 'No'.\n    >>> check_two_equal_digits(112)\n    Yes", "zh": "检查一个三字符字符串是否恰好有两个字符相同。\n\n参数：\n    s (char array): 要检查的三字符字符串。\n\n返回：\n    str: 如果输入恰好有两个相等的字符，则返回 'Yes'，否则返回 'No'。\n    >>> check_two_equal_digits(112)\n    Yes", "fr": "Vérifie si une chaîne de trois caractères a exactement deux caractères identiques.\n\nArgs:\n    s (char array): La chaîne de trois caractères à vérifier.\n\nReturns:\n    str: Renvoie 'Yes' si l'entrée a exactement deux caractères égaux, sinon 'No'.\n    >>> check_two_equal_digits(112)\n    Yes\n", "de": "Überprüft, ob ein dreistelliger String genau zwei gleiche Zeichen hat.\n\nArgs:\n    s (char array): Der dreistellige String, der überprüft werden soll.\n\nReturns:\n    str: Gibt 'Yes' zurück, wenn der Eingabewert genau zwei gleiche Zeichen hat, andernfalls 'No'.\n    >>> check_two_equal_digits(112)\n    Yes", "ha": "Duba idan wani igiyar haruffa mai haruffa uku yana daidai da haruffa biyu waɗanda suke daidai.\n\nArgs:\n    s (char array): Igiyar haruffa mai haruffa uku da za a duba.\n\nReturns:\n    str: Ya dawo da 'Yes' idan shigarwar tana daidai da haruffa biyu masu daidaituwa, in ba haka ba 'No'.\n    >>> check_two_equal_digits(112)\n    Yes", "hi": "तीन-अक्षरों की स्ट्रिंग में जाँच करता है कि क्या इसमें ठीक दो अक्षर समान हैं।\n\nआर्ग्स:\n    s (char array): तीन-अक्षरों की स्ट्रिंग जिसे जाँचना है।\n\nरिटर्न्स:\n    str: 'Yes' लौटाता है यदि इनपुट में ठीक दो समान अक्षर हैं, अन्यथा 'No'।\n    >>> check_two_equal_digits(112)\n    Yes", "hu": "Ellenőrzi, hogy egy három karakterből álló karakterláncban pontosan két azonos karakter van-e.\n\nArgs:\n    s (char array): A három karakterből álló karakterlánc, amelyet ellenőrizni kell.\n\nReturns:\n    str: 'Yes' értéket ad vissza, ha a bemenetben pontosan két egyenlő karakter van, különben 'No'.\n    >>> check_two_equal_digits(112)\n    Yes", "es": "Verifica si una cadena de tres caracteres tiene exactamente dos caracteres que son iguales.\n\nArgs:\n    s (char array): La cadena de tres caracteres a verificar.\n\nReturns:\n    str: Devuelve 'Yes' si la entrada tiene exactamente dos caracteres iguales, de lo contrario 'No'.\n    >>> check_two_equal_digits(112)\n    Yes", "arb": "يتحقق مما إذا كانت سلسلة مكونة من ثلاثة أحرف تحتوي على حرفين متطابقين بالضبط.\n\nArgs:\n    s (char array): سلسلة مكونة من ثلاثة أحرف للتحقق منها.\n\nالقيم المعادة:\n    str: تعيد 'Yes' إذا كان المدخل يحتوي على حرفين متساويين بالضبط، وإلا تعيد 'No'.\n    >>> check_two_equal_digits(112)\n    Yes", "sw": "Hukagua kama mfuatano wa herufi tatu una herufi mbili ambazo ni sawa kabisa.\n\nArgs:\n    s (char array): Mfuatano wa herufi tatu wa kukaguliwa.\n\nReturns:\n    str: Inarudisha 'Yes' ikiwa ingizo lina herufi mbili zilizo sawa kabisa, vinginevyo 'No'.\n    >>> check_two_equal_digits(112)\n    Yes", "tr": "Üç karakterli bir dizgede tam olarak iki karakterin aynı olup olmadığını kontrol eder.\n\nArgs:\n    s (char array): Kontrol edilecek üç karakterli dizge.\n\nReturns:\n    str: Girdi tam olarak iki eşit karaktere sahipse 'Yes' döner, aksi takdirde 'No' döner.\n    >>> check_two_equal_digits(112)\n    Yes", "vi": "Kiểm tra xem một chuỗi ba ký tự có chính xác hai ký tự giống nhau hay không.\n\nArgs:\n    s (char array): Chuỗi ba ký tự cần được kiểm tra.\n\nReturns:\n    str: Trả về 'Yes' nếu đầu vào có chính xác hai ký tự bằng nhau, ngược lại trả về 'No'.\n    >>> check_two_equal_digits(112)\n    Yes", "id": "Memeriksa apakah string tiga karakter memiliki tepat dua karakter yang sama.\n\nArgs:\n    s (char array): String tiga karakter yang akan diperiksa.\n\nReturns:\n    str: Mengembalikan 'Yes' jika input memiliki tepat dua karakter yang sama, jika tidak, 'No'.\n    >>> check_two_equal_digits(112)\n    Yes", "ja": "3文字の文字列に、正確に2つの同じ文字が含まれているかどうかを確認します。\n\n引数:\n    s (char array): チェックする3文字の文字列。\n\n戻り値:\n    str: 入力に正確に2つの等しい文字が含まれている場合は 'Yes' を返し、それ以外の場合は 'No' を返します。\n    >>> check_two_equal_digits(112)\n    Yes", "ko": "세 문자 문자열에 정확히 두 개의 동일한 문자가 있는지 확인합니다.\n\n인수:\n    s (char array): 확인할 세 문자 문자열입니다.\n\n반환:\n    str: 입력에 정확히 두 개의 동일한 문자가 있으면 'Yes'를 반환하고, 그렇지 않으면 'No'를 반환합니다.\n    >>> check_two_equal_digits(112)\n    Yes", "ml": "ഒരു മൂന്ന് അക്ഷരങ്ങളുള്ള സ്ട്രിംഗ് കൃത്യമായി രണ്ട് അക്ഷരങ്ങൾ ഒരേപോലെയാണോ എന്ന് പരിശോധിക്കുന്നു.\n\nആർഗ്സ്:\n    s (char array): പരിശോധിക്കേണ്ട മൂന്ന് അക്ഷരങ്ങളുള്ള സ്ട്രിംഗ്.\n\nമടക്കം:\n    str: ഇൻപുട്ടിൽ കൃത്യമായി രണ്ട് സമാനമായ അക്ഷരങ്ങൾ ഉണ്ടെങ്കിൽ 'Yes' മടക്കുന്നു, അല്ലെങ്കിൽ 'No'.\n    >>> check_two_equal_digits(112)\n    Yes", "fa": "بررسی می‌کند که آیا یک رشته سه‌کاراکتری دقیقاً دو کاراکتر مشابه دارد یا خیر.\n\nArgs:\n    s (char array): رشته سه‌کاراکتری که باید بررسی شود.\n\nReturns:\n    str: 'Yes' را برمی‌گرداند اگر ورودی دقیقاً دو کاراکتر برابر داشته باشد، در غیر این صورت 'No'.\n    >>> check_two_equal_digits(112)\n    Yes"}}
{"task_id": "C/31", "prompt": {"en": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nGiven a string consisting of lowercase English letters, in each round you can change one of the characters to another character. The question is: what is the minimum number of rounds needed to make the string composed of the same character?\nFor example:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0\n*/\nint minRoundsToSameChar(const char* s)", "sq": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDuke pasur një varg që përbëhet nga shkronja të vogla të anglishtes, në çdo raund mund të ndryshoni një nga karakteret në një karakter tjetër. Pyetja është: cili është numri minimal i raundeve të nevojshëm për ta bërë vargun të përbërë nga i njëjti karakter?\nPër shembull:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0\n*/\nint minRoundsToSameChar(const char* s)", "hy": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nՈւնենալով փոքրատառ անգլերեն տառերից բաղկացած տող, յուրաքանչյուր փուլում կարող եք փոխել տառերից մեկը մեկ այլ տառով: Հարցն է՝ ինչքա՞ն է նվազագույն փուլերի քանակը, որպեսզի տողը կազմված լինի նույն տառից:\nՕրինակ:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0\n*/\nint minRoundsToSameChar(const char* s)", "bn": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nএকটি স্ট্রিং দেওয়া আছে যা ছোট হাতের ইংরেজি অক্ষর নিয়ে গঠিত, প্রতিটি রাউন্ডে আপনি একটি অক্ষরকে অন্য অক্ষরে পরিবর্তন করতে পারেন। প্রশ্ন হল: স্ট্রিংটিকে একই অক্ষর দিয়ে গঠিত করতে ন্যূনতম কত রাউন্ড প্রয়োজন?\nউদাহরণস্বরূপ:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0\n*/\nint minRoundsToSameChar(const char* s)", "bg": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nДаден е низ, състоящ се от малки английски букви, като във всеки рунд можете да промените един от символите на друг символ. Въпросът е: какъв е минималният брой рундове, необходими, за да се направи низът съставен от един и същ символ?\nНапример:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0\n*/\nint minRoundsToSameChar(const char* s)", "zh": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\n给定一个由小写英文字母组成的字符串，每一轮你可以将其中一个字符更改为另一个字符。问题是：使字符串由相同字符组成所需的最少轮数是多少？\n例如：\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0\n*/\nint minRoundsToSameChar(const char* s)", "fr": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nÉtant donné une chaîne composée de lettres minuscules anglaises, à chaque tour, vous pouvez changer l'un des caractères en un autre caractère. La question est : quel est le nombre minimum de tours nécessaires pour que la chaîne soit composée du même caractère ?\nPar exemple :\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0\n*/\nint minRoundsToSameChar(const char* s)", "de": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nGegeben ist ein String, der aus Kleinbuchstaben des englischen Alphabets besteht. In jeder Runde kann man eines der Zeichen in ein anderes Zeichen ändern. Die Frage ist: Was ist die minimale Anzahl von Runden, die benötigt werden, um den String aus demselben Zeichen bestehen zu lassen?\nZum Beispiel:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0\n*/\nint minRoundsToSameChar(const char* s)", "ha": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nAn ba da wata ƙirtani mai ƙunshi ƙananan haruffan Ingilishi, a kowace zagaye za ka iya canza ɗaya daga cikin haruffan zuwa wani harafi. Tambayar ita ce: menene mafi ƙarancin adadin zagaye da ake buƙata don sanya ƙirtanin ya ƙunshi harafi ɗaya iri ɗaya?\nMisali:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0\n*/\nint minRoundsToSameChar(const char* s)", "hi": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nदिए गए स्ट्रिंग में छोटे अंग्रेजी अक्षरों का समावेश है, प्रत्येक राउंड में आप एक अक्षर को दूसरे अक्षर में बदल सकते हैं। प्रश्न यह है: स्ट्रिंग को एक ही अक्षर से मिलकर बनाने के लिए न्यूनतम कितने राउंड की आवश्यकता है?\nउदाहरण के लिए:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0\n*/\nint minRoundsToSameChar(const char* s)", "hu": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nAdott egy, kisbetűs angol betűkből álló karakterlánc, minden körben megváltoztathatsz egy karaktert egy másik karakterre. A kérdés az: mi a minimális körök száma, amely szükséges ahhoz, hogy a karakterlánc azonos karakterekből álljon?\nPéldául:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0\n*/\nint minRoundsToSameChar(const char* s)", "es": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDada una cadena que consiste en letras minúsculas del alfabeto inglés, en cada ronda puedes cambiar uno de los caracteres por otro carácter. La pregunta es: ¿cuál es el número mínimo de rondas necesarias para hacer que la cadena esté compuesta por el mismo carácter?\nPor ejemplo:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0\n*/\nint minRoundsToSameChar(const char* s)", "arb": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nبالنظر إلى سلسلة مكونة من أحرف إنجليزية صغيرة، في كل جولة يمكنك تغيير أحد الأحرف إلى حرف آخر. السؤال هو: ما هو الحد الأدنى لعدد الجولات اللازمة لجعل السلسلة مكونة من نفس الحرف؟\nعلى سبيل المثال:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0\n*/\nint minRoundsToSameChar(const char* s)", "sw": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nUkipiwa kamba inayojumuisha herufi ndogo za Kiingereza, katika kila raundi unaweza kubadilisha moja ya herufi kuwa herufi nyingine. Swali ni: ni idadi gani ndogo ya raundi zinazohitajika kufanya kamba iwe na herufi sawa?\nKwa mfano:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0\n*/\nint minRoundsToSameChar(const char* s)", "tr": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nKüçük harflerden oluşan bir dize verildiğinde, her turda karakterlerden birini başka bir karakterle değiştirebilirsiniz. Soru şu: Diziyi aynı karakterden oluşacak şekilde yapmak için gereken minimum tur sayısı nedir?\nÖrneğin:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0\n*/\nint minRoundsToSameChar(const char* s)", "vi": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCho một chuỗi bao gồm các chữ cái tiếng Anh viết thường, trong mỗi lượt bạn có thể thay đổi một trong các ký tự thành ký tự khác. Câu hỏi là: cần tối thiểu bao nhiêu lượt để làm cho chuỗi được tạo thành từ cùng một ký tự?\nVí dụ:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0\n*/\nint minRoundsToSameChar(const char* s)", "id": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDiberikan sebuah string yang terdiri dari huruf kecil bahasa Inggris, pada setiap putaran Anda dapat mengubah salah satu karakter menjadi karakter lain. Pertanyaannya adalah: berapa jumlah minimum putaran yang diperlukan untuk membuat string terdiri dari karakter yang sama?\nSebagai contoh:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0\n*/\nint minRoundsToSameChar(const char* s)", "ja": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\n小文字の英字からなる文字列が与えられたとき、各ラウンドで1つの文字を別の文字に変更できます。質問は、文字列を同じ文字で構成するために必要な最小ラウンド数は何ですか？\n例えば:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0\n*/\nint minRoundsToSameChar(const char* s)", "ko": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\n소문자 영어 문자로 구성된 문자열이 주어졌을 때, 각 라운드마다 하나의 문자를 다른 문자로 변경할 수 있습니다. 질문은: 문자열을 동일한 문자로 구성하기 위해 필요한 최소 라운드 수는 얼마입니까?\n예를 들어:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0\n*/\nint minRoundsToSameChar(const char* s)", "ml": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nചെറിയ ഇംഗ്ലീഷ് അക്ഷരങ്ങൾ അടങ്ങിയ ഒരു സ്ട്രിംഗ് നൽകിയിരിക്കുന്നു, ഓരോ റൗണ്ടിലും നിങ്ങൾക്ക് ഒരു അക്ഷരം മറ്റൊരു അക്ഷരമായി മാറ്റാൻ കഴിയും. ചോദ്യമിങ്ങനെ: സ്ട്രിംഗ് ഒരേ അക്ഷരത്തിൽ നിന്ന് രൂപപ്പെട്ടതാക്കാൻ ആവശ്യമായ കുറഞ്ഞ റൗണ്ടുകളുടെ എണ്ണം എത്ര?\nഉദാഹരണത്തിന്:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0\n*/\nint minRoundsToSameChar(const char* s)", "fa": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nبا توجه به یک رشته که شامل حروف کوچک انگلیسی است، در هر دور می‌توانید یکی از کاراکترها را به کاراکتر دیگری تغییر دهید. سوال این است: حداقل تعداد دورهایی که لازم است تا رشته از یک کاراکتر مشابه تشکیل شود چقدر است؟\nبرای مثال:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0\n*/\nint minRoundsToSameChar(const char* s)"}, "canonical_solution": "{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}", "instruction": {"en": "int minRoundsToSameChar(const char* s)\n{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "sq": "int minRoundsToSameChar(const char* s)\n{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrale (docstring) të kodit C në shqip duke përdorur maksimumi 500 karaktere.", "hy": "int minRoundsToSameChar(const char* s)\n{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}\n\nՏվեք C կոդի համառոտ բնական լեզվով նկարագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "int minRoundsToSameChar(const char* s)\n{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}\n\nসি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।", "bg": "int minRoundsToSameChar(const char* s)\n{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, използвайки не повече от 500 знака.", "zh": "int minRoundsToSameChar(const char* s)\n{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}\n\n请用中文为以下 C 代码提供一个简洁的自然语言描述（文档字符串），不超过 500 个字符。", "fr": "int minRoundsToSameChar(const char* s)\n{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.", "de": "int minRoundsToSameChar(const char* s)\n{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "int minRoundsToSameChar(const char* s)\n{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}\n\nBa da takaitaccen bayanin yanayi na dabi'a (docstring) na lambar C a cikin Hausa ta amfani da haruffa 500 kacal.", "hi": "int minRoundsToSameChar(const char* s)\n{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}\n\nC कोड का संक्षिप्त प्राकृतिक भाषा में विवरण (डॉकस्ट्रींग) हिंदी में 500 अक्षरों तक दें।", "hu": "int minRoundsToSameChar(const char* s)\n{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben.", "es": "int minRoundsToSameChar(const char* s)\n{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando como máximo 500 caracteres.", "arb": "int minRoundsToSameChar(const char* s)\n{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "int minRoundsToSameChar(const char* s)\n{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "int minRoundsToSameChar(const char* s)\n{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}\n\nC kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama en fazla 500 karakter olmalıdır.", "vi": "int minRoundsToSameChar(const char* s)\n{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã C bằng tiếng Việt với tối đa 500 ký tự.", "id": "int minRoundsToSameChar(const char* s)\n{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode C dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "int minRoundsToSameChar(const char* s)\n{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}\n\nCコードの内容を簡潔に説明する自然言語の記述（ドックストリング）を日本語で500文字以内で提供してください。", "ko": "int minRoundsToSameChar(const char* s)\n{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}\n\nC 코드에 대한 간결한 자연어 설명(docstring)을 한국어로 최대 500자 이내로 제공하세요.", "ml": "int minRoundsToSameChar(const char* s)\n{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}\n\nC കോഡിന്റെ സംഗ്രഹമായ ഒരു സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) മലയാളത്തിൽ 500 അക്ഷരങ്ങൾക്കുള്ളിൽ നൽകുക.", "fa": "int minRoundsToSameChar(const char* s)\n{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}\n\nتوضیح مختصر و طبیعی (docstring) از کد C به زبان فارسی ارائه دهید که حداکثر ۵۰۰ کاراکتر باشد."}, "level": "", "test": "int main() {\n    assert(minRoundsToSameChar(\"aab\") == 1);\n    assert(minRoundsToSameChar(\"abc\") == 2);\n    assert(minRoundsToSameChar(\"aaa\") == 0);\n    assert(minRoundsToSameChar(\"abab\") == 1);\n    assert(minRoundsToSameChar(\"zzzzz\") == 0);\n    return 0;\n}", "entry_point": "minRoundsToSameChar", "signature": "int minRoundsToSameChar(const char* s)", "docstring": {"en": "Given a string consisting of lowercase English letters, in each round you can change one of the characters to another character. The question is: what is the minimum number of rounds needed to make the string composed of the same character?\nFor example:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0\n", "sq": "Duke pasur një varg që përbëhet nga shkronja të vogla të anglishtes, në çdo raund mund të ndryshoni një nga karakteret në një karakter tjetër. Pyetja është: cili është numri minimal i raundeve të nevojshme për ta bërë vargun të përbërë nga i njëjti karakter?\nPër shembull:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0", "hy": "Տրված է փոքրատառ անգլերեն տառերից կազմված տող, յուրաքանչյուր փուլում դուք կարող եք փոխել տառերից մեկը մեկ այլ տառով: Հարցն այն է՝ ինչքա՞ն է նվազագույն փուլերի քանակը, որպեսզի տողը կազմված լինի նույն տառից:\nՕրինակ՝\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0", "bn": "একটি স্ট্রিং দেওয়া হয়েছে যা ছোট হাতের ইংরেজি অক্ষর নিয়ে গঠিত, প্রতিটি রাউন্ডে আপনি অক্ষরগুলোর মধ্যে একটি অন্য অক্ষরে পরিবর্তন করতে পারেন। প্রশ্ন হল: স্ট্রিংটিকে একই অক্ষর দিয়ে গঠিত করতে ন্যূনতম কত রাউন্ড প্রয়োজন?\nউদাহরণস্বরূপ:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0", "bg": "Даден е низ, състоящ се от малки английски букви, като във всеки рунд можете да промените един от символите на друг символ. Въпросът е: какъв е минималният брой рундове, необходими, за да се направи низът съставен от един и същ символ?\nНапример:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0", "zh": "给定一个由小写英文字母组成的字符串，在每一轮中，你可以将其中一个字符更改为另一个字符。问题是：使字符串由相同字符组成所需的最小轮数是多少？\n\n例如：\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0", "fr": "Étant donné une chaîne composée de lettres minuscules anglaises, à chaque tour, vous pouvez changer l'un des caractères en un autre caractère. La question est : quel est le nombre minimum de tours nécessaires pour que la chaîne soit composée du même caractère ?\nPar exemple :\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0", "de": "Gegeben ein String, der aus Kleinbuchstaben des englischen Alphabets besteht, können Sie in jeder Runde eines der Zeichen in ein anderes Zeichen ändern. Die Frage ist: Was ist die minimale Anzahl von Runden, die benötigt werden, um den String aus demselben Zeichen zu komponieren?\nZum Beispiel:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0", "ha": "An ba da wata ƙirari mai ƙunshe da ƙananan haruffan Ingilishi, a kowace zagaye za ka iya canza ɗaya daga cikin haruffan zuwa wani harafi. Tambayar ita ce: menene mafi ƙarancin adadin zagaye da ake buƙata don sanya ƙirarin ta ƙunshi harafi ɗaya?\nMisali:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0", "hi": "दिए गए स्ट्रिंग में छोटे अंग्रेजी अक्षरों से मिलकर बना है, प्रत्येक राउंड में आप एक अक्षर को दूसरे अक्षर में बदल सकते हैं। प्रश्न यह है: स्ट्रिंग को एक ही अक्षर से मिलकर बनाने के लिए न्यूनतम कितने राउंड की आवश्यकता है?\nउदाहरण के लिए:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0", "hu": "Adott egy kisbetűs angol betűkből álló karakterlánc, minden körben megváltoztathatsz egy karaktert egy másik karakterre. A kérdés az: mi a minimális körök száma ahhoz, hogy a karakterlánc ugyanabból a karakterből álljon?\nPéldául:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0", "es": "Dada una cadena compuesta por letras minúsculas del alfabeto inglés, en cada ronda puedes cambiar uno de los caracteres por otro carácter. La pregunta es: ¿cuál es el número mínimo de rondas necesarias para hacer que la cadena esté compuesta por el mismo carácter?\nPor ejemplo:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0", "arb": "بالنظر إلى سلسلة تتكون من أحرف إنجليزية صغيرة، في كل جولة يمكنك تغيير أحد الأحرف إلى حرف آخر. السؤال هو: ما هو الحد الأدنى لعدد الجولات اللازمة لجعل السلسلة مكونة من نفس الحرف؟\n\nعلى سبيل المثال:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0", "sw": "Kwa kupewa kamba inayojumuisha herufi ndogo za Kiingereza, katika kila raundi unaweza kubadilisha moja ya herufi kuwa herufi nyingine. Swali ni: ni idadi ndogo ya raundi ngapi zinazohitajika ili kufanya kamba iwe na herufi sawa?\n\nKwa mfano:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0", "tr": "Verilen bir küçük harflerden oluşan İngilizce harf dizisi için, her turda karakterlerden birini başka bir karaktere değiştirebilirsiniz. Soru şu: Diziyi aynı karakterden oluşacak şekilde yapmak için gereken minimum tur sayısı nedir?\nÖrneğin:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0", "vi": "Cho một chuỗi bao gồm các chữ cái tiếng Anh viết thường, trong mỗi vòng bạn có thể thay đổi một trong các ký tự thành ký tự khác. Câu hỏi là: cần tối thiểu bao nhiêu vòng để làm cho chuỗi được tạo thành từ cùng một ký tự?\nVí dụ:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0", "id": "Diberikan sebuah string yang terdiri dari huruf kecil bahasa Inggris, dalam setiap putaran Anda dapat mengubah salah satu karakter menjadi karakter lain. Pertanyaannya adalah: berapa jumlah putaran minimum yang diperlukan untuk membuat string terdiri dari karakter yang sama?\nSebagai contoh:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0", "ja": "小文字の英字からなる文字列が与えられたとき、各ラウンドで文字の1つを別の文字に変更することができます。質問は、文字列を同じ文字で構成するために必要な最小ラウンド数は何ですか？\n\n例えば：\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0", "ko": "주어진 문자열이 소문자 영어 문자로 구성되어 있을 때, 각 라운드마다 하나의 문자를 다른 문자로 변경할 수 있습니다. 질문은: 문자열을 동일한 문자로 구성되도록 만들기 위해 필요한 최소 라운드 수는 얼마입니까?\n\n예를 들어:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0", "ml": "ഒരു ചെറിയ ഇംഗ്ലീഷ് അക്ഷരങ്ങൾ ഉൾക്കൊള്ളുന്ന ഒരു സ്ട്രിംഗ് നൽകിയാൽ, ഓരോ റൗണ്ടിലും നിങ്ങൾക്ക് ഒരു അക്ഷരത്തെ മറ്റൊരു അക്ഷരമായി മാറ്റാം. സ്ട്രിംഗ് ഒരേ അക്ഷരത്തിൽ നിന്ന് രൂപപ്പെട്ടതാക്കാൻ ആവശ്യമായ കുറഞ്ഞ റൗണ്ടുകളുടെ എണ്ണം എത്രയാണ്?\nഉദാഹരണത്തിന്:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0", "fa": "با توجه به یک رشته که از حروف کوچک انگلیسی تشکیل شده است، در هر دور می‌توانید یکی از کاراکترها را به کاراکتر دیگری تغییر دهید. سوال این است: حداقل تعداد دورهایی که لازم است تا رشته از یک کاراکتر یکسان تشکیل شود چقدر است؟\nبرای مثال:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0"}}
{"task_id": "C/32", "prompt": {"en": "#include <assert.h>\n#include <stdio.h>\n/*\nGiven a sequence of n events, each occurring with a periodicity of a_i years, the problem is to find the year Y_n when the n-th event occurs, under the condition that the countdown for event i+1 can only commence in the year immediately following the occurrence of event i. \n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36\n*/\nint apocalypseYear(int n, int signs[])", "sq": "#include <assert.h>\n#include <stdio.h>\n/*\nDuke pasur një sekuencë prej n ngjarjesh, secila që ndodh me një periodicitet prej a_i vitesh, problemi është të gjendet viti Y_n kur ndodh ngjarja e n-të, nën kushtin që numërimi mbrapsht për ngjarjen i+1 mund të fillojë vetëm në vitin menjëherë pas ndodhjes së ngjarjes i. \n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36\n*/\nint apocalypseYear(int n, int signs[])", "hy": "#include <assert.h>\n#include <stdio.h>\n/*\nՈւնենալով n իրադարձությունների հաջորդականություն, որոնցից յուրաքանչյուրը տեղի է ունենում a_i տարիների պարբերականությամբ, խնդիրը կայանում է n-րդ իրադարձության տեղի ունենալու Y_n տարին գտնելու մեջ, այն պայմանով, որ i+1 իրադարձության հետհաշվարկը կարող է սկսվել միայն i իրադարձության տեղի ունենալուց անմիջապես հետո տարում։\n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36\n*/\nint apocalypseYear(int n, int signs[])", "bn": "#include <assert.h>\n#include <stdio.h>\n/*\nnটি ঘটনার একটি ক্রম দেওয়া হয়েছে, প্রতিটি a_i বছর পরপর ঘটে, সমস্যাটি হল Y_n বছরটি খুঁজে বের করা যখন n-তম ঘটনা ঘটে, এই শর্তে যে ঘটনা i+1 এর জন্য কাউন্টডাউন শুধুমাত্র ঘটনা i ঘটার পরের বছর শুরু হতে পারে।\n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36\n*/\nint apocalypseYear(int n, int signs[])", "bg": "#include <assert.h>\n#include <stdio.h>\n/*\nДадена е последователност от n събития, всяко от които се случва с периодичност от a_i години, проблемът е да се намери годината Y_n, когато n-тото събитие се случва, при условие че отброяването за събитие i+1 може да започне само в годината, непосредствено следваща след събитието i.\n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36\n*/\nint apocalypseYear(int n, int signs[])", "zh": "#include <assert.h>\n#include <stdio.h>\n/*\n给定一个由 n 个事件组成的序列，每个事件以 a_i 年的周期发生，问题是找出第 n 个事件发生的年份 Y_n，条件是事件 i+1 的倒计时只能在事件 i 发生的下一年开始。\n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36\n*/\nint apocalypseYear(int n, int signs[])", "fr": "#include <assert.h>\n#include <stdio.h>\n/*\nÉtant donné une séquence de n événements, chacun se produisant avec une périodicité de a_i années, le problème est de trouver l'année Y_n lorsque le n-ième événement se produit, sous la condition que le compte à rebours pour l'événement i+1 ne peut commencer que l'année suivant immédiatement l'occurrence de l'événement i. \n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36\n*/\nint apocalypseYear(int n, int signs[])", "de": "#include <assert.h>\n#include <stdio.h>\n/*\nGegeben eine Sequenz von n Ereignissen, die jeweils mit einer Periodizität von a_i Jahren auftreten, besteht das Problem darin, das Jahr Y_n zu finden, in dem das n-te Ereignis eintritt, unter der Bedingung, dass der Countdown für das Ereignis i+1 erst im Jahr unmittelbar nach dem Eintreten des Ereignisses i beginnen kann.\n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36\n*/\nint apocalypseYear(int n, int signs[])", "ha": "#include <assert.h>\n#include <stdio.h>\n/*\nAn ba da jerin abubuwan n, kowanne yana faruwa tare da maimaitawa na shekaru a_i, matsalar ita ce nemo shekarar Y_n lokacin da abin n-nth ya faru, a ƙarƙashin yanayin cewa ƙidayar lokaci don abin i+1 na iya farawa kawai a cikin shekarar da ke biye da faruwar abin i.\n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36\n*/\nint apocalypseYear(int n, int signs[])", "hi": "#include <assert.h>\n#include <stdio.h>\n/*\nदिए गए n घटनाओं की एक श्रृंखला में, प्रत्येक घटना a_i वर्षों की आवधिकता के साथ होती है, समस्या यह है कि वर्ष Y_n का पता लगाना है जब n-वीं घटना होती है, इस शर्त के तहत कि घटना i+1 की उलटी गिनती केवल घटना i के होने के तुरंत बाद के वर्ष में ही शुरू हो सकती है।\n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36\n*/\nint apocalypseYear(int n, int signs[])", "hu": "#include <assert.h>\n#include <stdio.h>\n/*\nAdott egy n eseményből álló sorozat, ahol mindegyik esemény a_i évenként fordul elő, a feladat az Y_n év megtalálása, amikor az n-edik esemény bekövetkezik, azzal a feltétellel, hogy az i+1-edik esemény visszaszámlálása csak az i-edik esemény bekövetkezését követő évben kezdődhet meg.\n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36\n*/\nint apocalypseYear(int n, int signs[])", "es": "#include <assert.h>\n#include <stdio.h>\n/*\nDada una secuencia de n eventos, cada uno ocurriendo con una periodicidad de a_i años, el problema es encontrar el año Y_n cuando ocurre el n-ésimo evento, bajo la condición de que la cuenta regresiva para el evento i+1 solo puede comenzar en el año inmediatamente posterior a la ocurrencia del evento i.\n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36\n*/\nint apocalypseYear(int n, int signs[])", "arb": "#include <assert.h>\n#include <stdio.h>\n/*\nبالنظر إلى سلسلة من الأحداث n، كل منها يحدث بشكل دوري كل a_i سنة، المشكلة هي إيجاد السنة Y_n عندما يحدث الحدث n، تحت شرط أن العد التنازلي للحدث i+1 يمكن أن يبدأ فقط في السنة التي تلي مباشرة حدوث الحدث i.\n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36\n*/\nint apocalypseYear(int n, int signs[])", "sw": "#include <assert.h>\n#include <stdio.h>\n/*\nIkizingatiwa mlolongo wa matukio n, kila moja likitokea kwa vipindi vya miaka a_i, tatizo ni kupata mwaka Y_n ambapo tukio la n linatokea, chini ya sharti kwamba kuhesabu kwa tukio i+1 kunaweza kuanza tu katika mwaka unaofuata mara tu baada ya tukio i kutokea. \n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36\n*/\nint apocalypseYear(int n, int signs[])", "tr": "#include <assert.h>\n#include <stdio.h>\n/*\nn olaydan oluşan bir dizi verildiğinde, her biri a_i yıl periyoduyla meydana gelen, problem n. olayın meydana geldiği Y_n yılını bulmaktır. Burada i+1. olayın geri sayımı, yalnızca i. olayın meydana gelmesinden hemen sonraki yılda başlayabilir.\n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36\n*/\nint apocalypseYear(int n, int signs[])", "vi": "#include <assert.h>\n#include <stdio.h>\n/*\nCho một dãy gồm n sự kiện, mỗi sự kiện xảy ra với chu kỳ a_i năm, vấn đề là tìm năm Y_n khi sự kiện thứ n xảy ra, với điều kiện rằng việc đếm ngược cho sự kiện i+1 chỉ có thể bắt đầu vào năm ngay sau khi sự kiện i xảy ra.\n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36\n*/\nint apocalypseYear(int n, int signs[])", "id": "#include <assert.h>\n#include <stdio.h>\n/*\nDiberikan sebuah urutan dari n kejadian, masing-masing terjadi dengan periodisitas a_i tahun, masalahnya adalah untuk menemukan tahun Y_n ketika kejadian ke-n terjadi, dengan kondisi bahwa hitungan mundur untuk kejadian i+1 hanya dapat dimulai pada tahun segera setelah kejadian i terjadi.\n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36\n*/\nint apocalypseYear(int n, int signs[])", "ja": "#include <assert.h>\n#include <stdio.h>\n/*\nn個のイベントのシーケンスが与えられ、それぞれがa_i年の周期で発生する場合、問題はn番目のイベントが発生する年Y_nを見つけることです。ただし、イベントi+1のカウントダウンは、イベントiが発生した直後の年にのみ開始できるという条件があります。\n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36\n*/\nint apocalypseYear(int n, int signs[])", "ko": "#include <assert.h>\n#include <stdio.h>\n/*\nn개의 사건이 주어졌을 때, 각각의 사건은 a_i년의 주기로 발생합니다. 문제는 n번째 사건이 발생하는 연도 Y_n을 찾는 것입니다. 조건은 사건 i+1의 카운트다운은 사건 i가 발생한 다음 해에만 시작할 수 있다는 것입니다.\n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36\n*/\nint apocalypseYear(int n, int signs[])", "ml": "#include <assert.h>\n#include <stdio.h>\n/*\nn സംഭവങ്ങളുടെ ഒരു പരമ്പര നൽകിയിരിക്കുന്നപ്പോൾ, ഓരോത് a_i വർഷങ്ങളുടെ കാലക്രമത്തിൽ സംഭവിക്കുന്നു, \nപ്രശ്നം n-മത്തെ സംഭവം സംഭവിക്കുന്ന Y_n വർഷം കണ്ടെത്തുന്നതാണ്, \nസാഹചര്യത്തിൽ, സംഭവം i+1 ന്റെ കൗണ്ട്ഡൗൺ, സംഭവം i സംഭവിക്കുന്ന വർഷത്തിന് തൊട്ടുപിന്നാലെ മാത്രമേ ആരംഭിക്കാവൂ. \n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36\n*/\nint apocalypseYear(int n, int signs[])", "fa": "#include <assert.h>\n#include <stdio.h>\n/*\nبا توجه به دنباله‌ای از n رویداد، که هر کدام با دوره تناوب a_i سال رخ می‌دهند، مسئله این است که سال Y_n را پیدا کنیم که در آن n-امین رویداد رخ می‌دهد، با این شرط که شمارش معکوس برای رویداد i+1 تنها می‌تواند در سال بلافاصله پس از وقوع رویداد i آغاز شود.\n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36\n*/\nint apocalypseYear(int n, int signs[])"}, "canonical_solution": "{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        int nextOccurrence = (year / period + 1) * period;\n        year = nextOccurrence;\n    }\n    return year;\n}", "instruction": {"en": "int apocalypseYear(int n, int signs[])\n{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        int nextOccurrence = (year / period + 1) * period;\n        year = nextOccurrence;\n    }\n    return year;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "sq": "int apocalypseYear(int n, int signs[])\n{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        int nextOccurrence = (year / period + 1) * period;\n        year = nextOccurrence;\n    }\n    return year;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C në shqip duke përdorur maksimumi 500 karaktere.", "hy": "int apocalypseYear(int n, int signs[])\n{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        int nextOccurrence = (year / period + 1) * period;\n        year = nextOccurrence;\n    }\n    return year;\n}\n\nՏվեք C կոդի կարճ բնութագրություն (docstring) հայերեն լեզվով՝ օգտագործելով առավելագույնը 500 նիշ։", "bn": "int apocalypseYear(int n, int signs[])\n{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        int nextOccurrence = (year / period + 1) * period;\n        year = nextOccurrence;\n    }\n    return year;\n}\n\nনিচের C কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।", "bg": "int apocalypseYear(int n, int signs[])\n{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        int nextOccurrence = (year / period + 1) * period;\n        year = nextOccurrence;\n    }\n    return year;\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, използвайки не повече от 500 знака.", "zh": "int apocalypseYear(int n, int signs[])\n{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        int nextOccurrence = (year / period + 1) * period;\n        year = nextOccurrence;\n    }\n    return year;\n}\n\n请用最多500个字符的中文为以下C代码提供简洁的自然语言描述（文档字符串）。", "fr": "int apocalypseYear(int n, int signs[])\n{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        int nextOccurrence = (year / period + 1) * period;\n        year = nextOccurrence;\n    }\n    return year;\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.", "de": "int apocalypseYear(int n, int signs[])\n{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        int nextOccurrence = (year / period + 1) * period;\n        year = nextOccurrence;\n    }\n    return year;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen.", "ha": "int apocalypseYear(int n, int signs[])\n{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        int nextOccurrence = (year / period + 1) * period;\n        year = nextOccurrence;\n    }\n    return year;\n}\n\nBa da takaitaccen bayani a cikin yaren halitta (docstring) na lambar C cikin Hausa ta amfani da haruffa 500 kawai.", "hi": "int apocalypseYear(int n, int signs[])\n{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        int nextOccurrence = (year / period + 1) * period;\n        year = nextOccurrence;\n    }\n    return year;\n}\n\nC कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "int apocalypseYear(int n, int signs[])\n{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        int nextOccurrence = (year / period + 1) * period;\n        year = nextOccurrence;\n    }\n    return year;\n}\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben.", "es": "int apocalypseYear(int n, int signs[])\n{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        int nextOccurrence = (year / period + 1) * period;\n        year = nextOccurrence;\n    }\n    return year;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando como máximo 500 caracteres.", "arb": "int apocalypseYear(int n, int signs[])\n{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        int nextOccurrence = (year / period + 1) * period;\n        year = nextOccurrence;\n    }\n    return year;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "int apocalypseYear(int n, int signs[])\n{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        int nextOccurrence = (year / period + 1) * period;\n        year = nextOccurrence;\n    }\n    return year;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "int apocalypseYear(int n, int signs[])\n{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        int nextOccurrence = (year / period + 1) * period;\n        year = nextOccurrence;\n    }\n    return year;\n}\n\nC kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda özlü bir doğal dil açıklaması (docstring) sağlayın.", "vi": "int apocalypseYear(int n, int signs[])\n{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        int nextOccurrence = (year / period + 1) * period;\n        year = nextOccurrence;\n    }\n    return year;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã C bằng tiếng Việt, sử dụng tối đa 500 ký tự.", "id": "int apocalypseYear(int n, int signs[])\n{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        int nextOccurrence = (year / period + 1) * period;\n        year = nextOccurrence;\n    }\n    return year;\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode C dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "int apocalypseYear(int n, int signs[])\n{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        int nextOccurrence = (year / period + 1) * period;\n        year = nextOccurrence;\n    }\n    return year;\n}\n\nCコードの内容を簡潔に説明する自然言語の記述（ドックストリング）を日本語で500文字以内で提供してください。", "ko": "int apocalypseYear(int n, int signs[])\n{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        int nextOccurrence = (year / period + 1) * period;\n        year = nextOccurrence;\n    }\n    return year;\n}\n\nC 코드의 동작을 설명하는 간결한 자연어 설명(docstring)을 한국어로 작성하세요. 최대 500자까지 가능합니다.", "ml": "int apocalypseYear(int n, int signs[])\n{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        int nextOccurrence = (year / period + 1) * period;\n        year = nextOccurrence;\n    }\n    return year;\n}\n\nസിയുടെ കോഡിന് 500 അക്ഷരങ്ങളിൽ കൂടാത്ത പ്രകൃതിദത്ത ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) മലയാളത്തിൽ നൽകുക.", "fa": "int apocalypseYear(int n, int signs[])\n{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        int nextOccurrence = (year / period + 1) * period;\n        year = nextOccurrence;\n    }\n    return year;\n}\n\nتوضیح مختصر و طبیعی (docstring) از کد C به زبان فارسی ارائه دهید که حداکثر ۵۰۰ کاراکتر باشد."}, "level": "", "test": "int main() {\n    assert(apocalypseYear(6, (int[]){3,2,4,5,9,18}) == 36);\n    assert(apocalypseYear(5, (int[]){1, 2,3,4,5}) == 5);\n    assert(apocalypseYear(5, (int[]){1,1,1,1,1}) == 5);\n    assert(apocalypseYear(6, (int[]){50,30,711,200,503,1006}) == 2012);\n    assert(apocalypseYear(2, (int[]){1, 2}) == 2);\n    assert(apocalypseYear(3, (int[]){3, 1, 2}) == 6);\n    assert(apocalypseYear(3, (int[]){2, 3, 4}) == 4);\n    assert(apocalypseYear(4, (int[]){1, 2, 3, 4}) == 4);\n    assert(apocalypseYear(4, (int[]){5, 7, 11, 13}) == 13);\n    assert(apocalypseYear(5, (int[]){2, 2, 2, 2, 2}) == 10);\n    assert(apocalypseYear(3, (int[]){6, 10, 15}) == 15);\n    assert(apocalypseYear(3, (int[]){4, 6, 14}) == 14);\n    assert(apocalypseYear(4, (int[]){50, 30, 711, 200}) == 800);\n    assert(apocalypseYear(6, (int[]){1, 1, 1, 1, 1, 1}) == 6);\n    assert(apocalypseYear(2, (int[]){1000000, 999999}) == 1999998);\n    return 0;\n}", "entry_point": "apocalypseYear", "signature": "int apocalypseYear(int n, int signs[])", "docstring": {"en": "Given a sequence of n events, each occurring with a periodicity of a_i years, the problem is to find the year Y_n when the n-th event occurs, under the condition that the countdown for event i+1 can only commence in the year immediately following the occurrence of event i. \n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36\n", "sq": "Duke pasur një sekuencë prej n ngjarjesh, secila që ndodh me një periodicitet prej a_i vitesh, problemi është të gjendet viti Y_n kur ndodh ngjarja e n-të, me kushtin që numërimi mbrapsht për ngjarjen i+1 mund të fillojë vetëm në vitin menjëherë pas ndodhjes së ngjarjes i.\n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36", "hy": "Տրված է n իրադարձությունների հաջորդականություն, որոնցից յուրաքանչյուրը տեղի է ունենում a_i տարիների պարբերականությամբ, խնդիրը գտնել Y_n տարին, երբ տեղի է ունենում n-րդ իրադարձությունը, այն պայմանով, որ իրադարձություն i+1-ի համար հետհաշվարկը կարող է սկսվել միայն իրադարձություն i-ի տեղի ունենալուց անմիջապես հետո։ \n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36", "bn": "প্রদত্ত nটি ঘটনার একটি ক্রমে, প্রতিটি ঘটনা a_i বছর পরপর ঘটে, সমস্যাটি হল n-তম ঘটনা যে বছর Y_n-এ ঘটে তা খুঁজে বের করা, এই শর্তে যে ঘটনা i+1 এর জন্য কাউন্টডাউন শুধুমাত্র ঘটনা i ঘটার পরবর্তী বছরেই শুরু হতে পারে। \n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36", "bg": "Дадена е последователност от n събития, всяко от които се случва с периодичност от a_i години, проблемът е да се намери годината Y_n, когато се случва n-тото събитие, при условие че отброяването за събитие i+1 може да започне само в годината непосредствено след настъпването на събитие i.\n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36", "zh": "给定一个由 n 个事件组成的序列，每个事件以 a_i 年的周期发生，问题是找到第 n 个事件发生的年份 Y_n，条件是事件 i+1 的倒计时只能在事件 i 发生后的下一年开始。", "fr": "Étant donné une séquence de n événements, chacun se produisant avec une périodicité de a_i années, le problème est de trouver l'année Y_n où le n-ième événement se produit, à condition que le compte à rebours pour l'événement i+1 ne puisse commencer que l'année suivant immédiatement la survenue de l'événement i.\n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36", "de": "Angenommen, es gibt eine Folge von n Ereignissen, die jeweils mit einer Periodizität von a_i Jahren auftreten, besteht das Problem darin, das Jahr Y_n zu finden, in dem das n-te Ereignis eintritt, unter der Bedingung, dass der Countdown für das Ereignis i+1 erst im Jahr unmittelbar nach dem Auftreten des Ereignisses i beginnen kann.\n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36", "ha": "An ba da jerin abubuwan n, kowanne yana faruwa tare da maimaitawa na a_i shekaru, matsalar ita ce gano shekarar Y_n lokacin da abin n-th ya faru, a ƙarƙashin yanayin cewa ƙidayar don abin i+1 na iya farawa kawai a cikin shekarar da ke biye da faruwar abin i. \n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36", "hi": "दिए गए n घटनाओं के अनुक्रम में, प्रत्येक घटना a_i वर्षों की आवधिकता के साथ होती है, समस्या यह है कि वर्ष Y_n का पता लगाना है जब n-वीं घटना होती है, इस शर्त के तहत कि घटना i+1 की उलटी गिनती केवल घटना i के घटित होने के तुरंत बाद वाले वर्ष में ही शुरू हो सकती है। \n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36", "hu": "Adott egy n eseményből álló sorozat, ahol mindegyik esemény a_i évenkénti periodicitással következik be, a feladat az Y_n év megtalálása, amikor az n-edik esemény bekövetkezik, azzal a feltétellel, hogy az i+1 esemény visszaszámlálása csak az i esemény bekövetkezését követő évben kezdődhet meg.\n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36", "es": "Dada una secuencia de n eventos, cada uno ocurriendo con una periodicidad de a_i años, el problema es encontrar el año Y_n cuando ocurre el n-ésimo evento, bajo la condición de que la cuenta regresiva para el evento i+1 solo puede comenzar en el año inmediatamente posterior a la ocurrencia del evento i.\n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36", "arb": "بالنظر إلى تسلسل من n أحداث، كل منها يحدث بتكرار دوري كل a_i سنة، فإن المشكلة هي إيجاد السنة Y_n عندما يحدث الحدث n، بشرط أن العد التنازلي للحدث i+1 يمكن أن يبدأ فقط في السنة التي تلي مباشرة حدوث الحدث i.\n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36", "sw": "Kwa kuzingatia mlolongo wa matukio n, kila moja likitokea kwa kipindi cha miaka a_i, tatizo ni kupata mwaka Y_n ambapo tukio la n linatokea, chini ya sharti kwamba kuhesabu kwa tukio i+1 kunaweza kuanza tu katika mwaka unaofuata mara baada ya tukio i kutokea.\n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36", "tr": "Verilen n olayından oluşan bir dizide, her biri a_i yıllık bir periyodiklikle meydana gelen olaylar için, n'inci olayın gerçekleştiği Y_n yılını bulma problemi, i+1 olayının geri sayımının yalnızca i olayının gerçekleştiği yılın hemen ardından başlayabileceği şartı altında çözülmelidir. \n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36", "vi": "Đưa ra một chuỗi gồm n sự kiện, mỗi sự kiện xảy ra với chu kỳ a_i năm, vấn đề là tìm năm Y_n khi sự kiện thứ n xảy ra, với điều kiện rằng đếm ngược cho sự kiện i+1 chỉ có thể bắt đầu vào năm ngay sau khi sự kiện i xảy ra.\n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36", "id": "Diberikan sebuah urutan dari n kejadian, masing-masing terjadi dengan periodisitas a_i tahun, masalahnya adalah menemukan tahun Y_n ketika kejadian ke-n terjadi, dengan kondisi bahwa hitungan mundur untuk kejadian i+1 hanya dapat dimulai pada tahun segera setelah kejadian i terjadi.\n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36", "ja": "n個のイベントのシーケンスが与えられ、それぞれがa_i年の周期で発生する場合、問題はn番目のイベントが発生する年Y_nを見つけることです。ただし、イベントi+1のカウントダウンは、イベントiが発生した直後の年にのみ開始できます。 \n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36", "ko": "주어진 n개의 사건 시퀀스에서 각각의 사건은 a_i 년 주기로 발생하며, 문제는 n번째 사건이 발생하는 연도 Y_n을 찾는 것입니다. 조건은 사건 i+1의 카운트다운은 사건 i가 발생한 직후의 연도에서만 시작될 수 있다는 것입니다.\n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36", "ml": "നൽകിയിരിക്കുന്ന n സംഭവങ്ങളുടെ ഒരു ശ്രേണിയിൽ, ഓരോന്നും a_i വർഷങ്ങളുടെ കാലക്രമത്തിൽ സംഭവിക്കുന്നു, n-ആം സംഭവം സംഭവിക്കുന്ന Y_n വർഷം കണ്ടെത്തുക എന്നതാണ് പ്രശ്നം. ഇതിൽ, സംഭവം i+1-ന്റെ കൗണ്ട്ഡൗൺ, സംഭവം i സംഭവിച്ച വർഷത്തിന് തൊട്ടുപിന്നാലെ മാത്രമേ ആരംഭിക്കാവൂ. \n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36", "fa": "با توجه به دنباله‌ای از n رویداد، که هر کدام با دوره تناوب a_i سال رخ می‌دهند، مسئله این است که سال Y_n را پیدا کنیم که در آن n-امین رویداد رخ می‌دهد، تحت این شرط که شمارش معکوس برای رویداد i+1 تنها می‌تواند در سال بلافاصله پس از وقوع رویداد i آغاز شود.\n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36"}}
{"task_id": "C/33", "prompt": {"en": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nThis problem introduces a new modulo operation, denoted by the symbol \"⊕\". When calculating x ⊕ y, if x is not a multiple of y, the result is the remainder of x divided by y. Otherwise, divide x by y repeatedly until x is no longer a multiple of y, denoting the final value as x'. Then the result is the remainder of x' divided by y. For example, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nGiven a prime number p, there will be several queries. For each query, an integer n is given, and you need to compute the value of n! ⊕ p, where n! is the factorial of n, i.e., the product of all positive integers less than or equal to n.\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)", "sq": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nKy problem prezanton një operacion të ri modulo, i shënuar me simbolin \"⊕\". Kur llogaritni x ⊕ y, nëse x nuk është shumëfish i y, rezultati është mbetja e x pjesëtuar me y. Përndryshe, ndani x me y vazhdimisht derisa x të mos jetë më shumëfish i y, duke e shënuar vlerën përfundimtare si x'. Pastaj rezultati është mbetja e x' pjesëtuar me y. Për shembull, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nDuke pasur një numër të plotë p, do të ketë disa kërkesa. Për çdo kërkesë, jepet një numër i plotë n, dhe ju duhet të llogaritni vlerën e n! ⊕ p, ku n! është faktoriali i n, dmth, prodhimi i të gjithë numrave të plotë pozitivë më të vegjël ose të barabartë me n.\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)", "hy": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nԱյս խնդիրը ներկայացնում է նոր մնացորդային գործողություն, որը նշվում է \"⊕\" նշանով: Երբ հաշվարկում ենք x ⊕ y, եթե x-ը y-ի բազմապատիկ չէ, արդյունքը x-ի y-ով բաժանման մնացորդն է: Հակառակ դեպքում, բաժանեք x-ը y-ի վրա կրկնակի, մինչև x-ը այլևս y-ի բազմապատիկ չլինի, և վերջնական արժեքը նշանակեք որպես x': Ապա արդյունքը x'-ի y-ով բաժանման մնացորդն է: Օրինակ, 4⊕5=4, 20⊕5=4, 100⊕5=4:\nՏրված է p պարզ թիվը, լինելու են մի քանի հարցումներ: Յուրաքանչյուր հարցման համար տրված է n ամբողջ թիվը, և դուք պետք է հաշվարկեք n! ⊕ p արժեքը, որտեղ n! n-ի ֆակտորիալն է, այսինքն՝ n-ից փոքր կամ հավասար բոլոր դրական ամբողջ թվերի արտադրյալը:\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)", "bn": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nএই সমস্যাটি একটি নতুন মডুলো অপারেশন পরিচয় করায়, যা \"⊕\" প্রতীকে চিহ্নিত। যখন x ⊕ y গণনা করা হয়, যদি x y এর গুণিতক না হয়, ফলাফল হবে x কে y দিয়ে ভাগ করলে যে অবশিষ্ট থাকে তা। অন্যথায়, x কে y দ্বারা বারবার ভাগ করুন যতক্ষণ না x আর y এর গুণিতক থাকে, চূড়ান্ত মানটিকে x' হিসাবে চিহ্নিত করুন। তারপর ফলাফল হবে x' কে y দিয়ে ভাগ করলে যে অবশিষ্ট থাকে তা। উদাহরণস্বরূপ, 4⊕5=4, 20⊕5=4, 100⊕5=4।\nএকটি মৌলিক সংখ্যা p দেওয়া আছে, এবং কিছু প্রশ্ন থাকবে। প্রতিটি প্রশ্নের জন্য, একটি পূর্ণসংখ্যা n দেওয়া থাকবে, এবং আপনাকে n! ⊕ p এর মান গণনা করতে হবে, যেখানে n! হল n এর ফ্যাক্টোরিয়াল, অর্থাৎ n এর চেয়ে ছোট বা সমান সমস্ত ধনাত্মক পূর্ণসংখ্যার গুণফল।\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)", "bg": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nТози проблем въвежда нова операция на модуло, обозначена със символа \"⊕\". Когато се изчислява x ⊕ y, ако x не е кратно на y, резултатът е остатъкът от x, разделен на y. В противен случай, разделяйте x на y многократно, докато x вече не е кратно на y, като обозначите крайната стойност като x'. Тогава резултатът е остатъкът от x', разделен на y. Например, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nДадено е просто число p, ще има няколко запитвания. За всяко запитване се дава цяло число n и трябва да изчислите стойността на n! ⊕ p, където n! е факториелът на n, т.е. произведението на всички положителни цели числа, по-малки или равни на n.\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)", "zh": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\n这个问题引入了一种新的模运算，用符号“⊕”表示。计算 x ⊕ y 时，如果 x 不是 y 的倍数，结果是 x 除以 y 的余数。否则，反复将 x 除以 y，直到 x 不再是 y 的倍数，记最终值为 x'。然后结果是 x' 除以 y 的余数。例如，4⊕5=4，20⊕5=4，100⊕5=4。\n给定一个素数 p，将有若干查询。对于每个查询，给定一个整数 n，你需要计算 n! ⊕ p 的值，其中 n! 是 n 的阶乘，即小于或等于 n 的所有正整数的乘积。\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)", "fr": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nCe problème introduit une nouvelle opération modulo, notée par le symbole \"⊕\". Lors du calcul de x ⊕ y, si x n'est pas un multiple de y, le résultat est le reste de x divisé par y. Sinon, divisez x par y de manière répétée jusqu'à ce que x ne soit plus un multiple de y, en notant la valeur finale comme x'. Ensuite, le résultat est le reste de x' divisé par y. Par exemple, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nÉtant donné un nombre premier p, il y aura plusieurs requêtes. Pour chaque requête, un entier n est donné, et vous devez calculer la valeur de n! ⊕ p, où n! est la factorielle de n, c'est-à-dire le produit de tous les entiers positifs inférieurs ou égaux à n.\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)", "de": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nDieses Problem führt eine neue Modulo-Operation ein, die durch das Symbol \"⊕\" bezeichnet wird. Beim Berechnen von x ⊕ y, wenn x kein Vielfaches von y ist, ist das Ergebnis der Rest von x geteilt durch y. Andernfalls wird x wiederholt durch y geteilt, bis x kein Vielfaches von y mehr ist, wobei der Endwert als x' bezeichnet wird. Dann ist das Ergebnis der Rest von x' geteilt durch y. Zum Beispiel, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nGegeben ist eine Primzahl p, es wird mehrere Anfragen geben. Für jede Anfrage wird eine ganze Zahl n gegeben, und Sie müssen den Wert von n! ⊕ p berechnen, wobei n! die Fakultät von n ist, d.h. das Produkt aller positiven ganzen Zahlen kleiner oder gleich n.\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)", "ha": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nWannan matsalar tana gabatar da wani sabon aiki na modulo, wanda aka nuna da alamar \"⊕\". Lokacin da ake lissafin x ⊕ y, idan x ba shi ne sau na y ba, sakamakon shi ne saura na x raba y. In ba haka ba, raba x da y akai-akai har sai x ba shi ne sau na y ba, ana nuna ƙimar ƙarshe a matsayin x'. Sannan sakamakon shi ne saura na x' raba y. Alal misali, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nAn ba da lamba mai lamba p, za a sami tambayoyi da yawa. Don kowace tambaya, an ba da lamba n, kuma kuna buƙatar lissafin ƙimar n! ⊕ p, inda n! shine factorial na n, wato, samfurin duk lambobin da suka fi n ƙasa ko daidai da n.\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)", "hi": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nयह समस्या एक नए माड्यूलो ऑपरेशन को प्रस्तुत करती है, जिसे \"⊕\" प्रतीक द्वारा दर्शाया गया है। जब x ⊕ y की गणना की जाती है, यदि x y का गुणज नहीं है, तो परिणाम x को y से विभाजित करने पर शेषफल होता है। अन्यथा, x को y से बार-बार विभाजित करें जब तक कि x अब y का गुणज न हो, अंतिम मान को x' के रूप में दर्शाते हुए। फिर परिणाम x' को y से विभाजित करने पर शेषफल होता है। उदाहरण के लिए, 4⊕5=4, 20⊕5=4, 100⊕5=4।\nएक अभाज्य संख्या p दी गई है, और कई क्वेरीज़ होंगी। प्रत्येक क्वेरी के लिए, एक पूर्णांक n दिया गया है, और आपको n! ⊕ p का मान निकालना है, जहाँ n! n का फैक्टोरियल है, यानी n से कम या बराबर सभी धनात्मक पूर्णांकों का गुणनफल।\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)", "hu": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nEz a probléma egy új modulo műveletet vezet be, amelyet a \"⊕\" szimbólum jelöl. Amikor az x ⊕ y-t számítjuk, ha x nem osztható y-nal, az eredmény x maradéka y-nal osztva. Ellenkező esetben osszuk el x-et y-nal ismételten, amíg x már nem osztható y-nal, és a végső értéket jelöljük x'-vel. Ekkor az eredmény x' maradéka y-nal osztva. Például, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nAdott egy prímszám p, és több lekérdezés lesz. Minden lekérdezéshez adott egy egész szám n, és ki kell számítani n! ⊕ p értékét, ahol n! az n faktoriálisa, azaz az összes n-nél kisebb vagy egyenlő pozitív egész szám szorzata.\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)", "es": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nEste problema introduce una nueva operación de módulo, denotada por el símbolo \"⊕\". Al calcular x ⊕ y, si x no es un múltiplo de y, el resultado es el resto de x dividido por y. De lo contrario, divide x por y repetidamente hasta que x ya no sea un múltiplo de y, denotando el valor final como x'. Entonces el resultado es el resto de x' dividido por y. Por ejemplo, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nDado un número primo p, habrá varias consultas. Para cada consulta, se da un número entero n, y necesitas calcular el valor de n! ⊕ p, donde n! es el factorial de n, es decir, el producto de todos los enteros positivos menores o iguales a n.\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)", "arb": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nهذه المشكلة تقدم عملية باقي جديدة، يرمز لها بالرمز \"⊕\". عند حساب x ⊕ y، إذا لم يكن x مضاعفًا لـ y، فإن النتيجة هي باقي قسمة x على y. خلاف ذلك، قم بقسمة x على y بشكل متكرر حتى لا يكون x مضاعفًا لـ y، مع تسمية القيمة النهائية x'. ثم تكون النتيجة هي باقي قسمة x' على y. على سبيل المثال، 4⊕5=4، 20⊕5=4، 100⊕5=4.\nمعطى عدد أولي p، سيكون هناك عدة استفسارات. لكل استفسار، يُعطى عدد صحيح n، وتحتاج إلى حساب قيمة n! ⊕ p، حيث n! هو مضروب n، أي حاصل ضرب جميع الأعداد الصحيحة الموجبة الأقل من أو تساوي n.\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)", "sw": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nTatizo hili linaanzisha operesheni mpya ya modulo, inayojulikana kwa alama \"⊕\". Wakati wa kuhesabu x ⊕ y, ikiwa x si kigezo cha y, matokeo ni baki ya x iliyogawanywa na y. Vinginevyo, gawanya x kwa y mara kwa mara hadi x isiwe tena kigezo cha y, ukionyesha thamani ya mwisho kama x'. Kisha matokeo ni baki ya x' iliyogawanywa na y. Kwa mfano, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nUkipata namba ya kwanza p, kutakuwa na maswali kadhaa. Kwa kila swali, namba nzima n inatolewa, na unahitaji kuhesabu thamani ya n! ⊕ p, ambapo n! ni factorial ya n, yaani, bidhaa ya namba zote chanya zilizo chini au sawa na n.\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)", "tr": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nBu problem, \"⊕\" sembolüyle gösterilen yeni bir modül işlemi tanıtır. x ⊕ y hesaplanırken, eğer x, y'nin katı değilse, sonuç x'in y'ye bölümünden kalan olur. Aksi takdirde, x y'nin katı olmayana kadar x'i y'ye tekrar tekrar bölün, son değeri x' olarak belirtin. Sonra sonuç, x' in y'ye bölümünden kalan olur. Örneğin, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nVerilen bir asal sayı p için birkaç sorgu olacaktır. Her sorgu için bir tamsayı n verilir ve n! ⊕ p değerini hesaplamanız gerekir, burada n! n'nin faktöriyelidir, yani n'ye eşit veya daha küçük olan tüm pozitif tamsayıların çarpımıdır.\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)", "vi": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nVấn đề này giới thiệu một phép toán modulo mới, được ký hiệu bằng biểu tượng \"⊕\". Khi tính toán x ⊕ y, nếu x không phải là bội số của y, kết quả là phần dư của x chia cho y. Ngược lại, chia x cho y liên tục cho đến khi x không còn là bội số của y, ký hiệu giá trị cuối cùng là x'. Sau đó kết quả là phần dư của x' chia cho y. Ví dụ, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nCho một số nguyên tố p, sẽ có một số truy vấn. Đối với mỗi truy vấn, một số nguyên n được cho, và bạn cần tính giá trị của n! ⊕ p, trong đó n! là giai thừa của n, tức là tích của tất cả các số nguyên dương nhỏ hơn hoặc bằng n.\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)", "id": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nMasalah ini memperkenalkan operasi modulo baru, yang dilambangkan dengan simbol \"⊕\". Ketika menghitung x ⊕ y, jika x bukan kelipatan dari y, hasilnya adalah sisa dari x dibagi dengan y. Jika tidak, bagi x dengan y berulang kali sampai x tidak lagi menjadi kelipatan dari y, menandai nilai akhir sebagai x'. Kemudian hasilnya adalah sisa dari x' dibagi dengan y. Sebagai contoh, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nDiberikan bilangan prima p, akan ada beberapa kueri. Untuk setiap kueri, diberikan bilangan bulat n, dan Anda perlu menghitung nilai dari n! ⊕ p, di mana n! adalah faktorial dari n, yaitu hasil kali dari semua bilangan bulat positif yang kurang dari atau sama dengan n.\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)", "ja": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nこの問題では、新しい剰余演算「⊕」が導入されています。x ⊕ yを計算する際、xがyの倍数でない場合、結果はxをyで割った余りです。そうでない場合、xをyで割り続け、xがもはやyの倍数でなくなるまで繰り返し、最終的な値をx'とします。その後、結果はx'をyで割った余りです。例えば、4⊕5=4, 20⊕5=4, 100⊕5=4です。\n素数pが与えられ、いくつかのクエリがあります。各クエリでは整数nが与えられ、n! ⊕ pの値を計算する必要があります。ここでn!はnの階乗、すなわちn以下のすべての正の整数の積です。\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)", "ko": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\n이 문제는 \"⊕\" 기호로 표시되는 새로운 모듈로 연산을 소개합니다. x ⊕ y를 계산할 때, x가 y의 배수가 아니라면 결과는 x를 y로 나눈 나머지입니다. 그렇지 않으면, x를 y로 반복적으로 나누어 x가 더 이상 y의 배수가 아닐 때까지 나누고, 최종 값을 x'로 나타냅니다. 그런 다음 결과는 x'를 y로 나눈 나머지입니다. 예를 들어, 4⊕5=4, 20⊕5=4, 100⊕5=4입니다.\n소수 p가 주어지면 여러 개의 쿼리가 있을 것입니다. 각 쿼리마다 정수 n이 주어지며, n! ⊕ p의 값을 계산해야 합니다. 여기서 n!은 n 이하의 모든 양의 정수의 곱인 팩토리얼입니다.\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)\n", "ml": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nഈ പ്രശ്നം \"⊕\" എന്ന ചിഹ്നം കൊണ്ട് സൂചിപ്പിക്കുന്ന ഒരു പുതിയ മോഡുലോ ഓപ്പറേഷൻ പരിചയപ്പെടുത്തുന്നു. x ⊕ y കണക്കാക്കുമ്പോൾ, x y-ന്റെ ഗുണിതമല്ലെങ്കിൽ, ഫലം x y-ൽ വിഭജിച്ച ശേഷമുള്ള ശേഷമാണ്. അല്ലെങ്കിൽ, x y-ൽ നിന്ന് ഗുണിതമല്ലാത്തതുവരെ x y-ൽ നിന്ന് ആവർത്തിച്ച് വിഭജിക്കുക, അന്തിമ മൂല്യം x' ആയി സൂചിപ്പിക്കുക. പിന്നീടുള്ള ഫലം x' y-ൽ വിഭജിച്ച ശേഷമുള്ള ശേഷമാണ്. ഉദാഹരണത്തിന്, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nഒരു പ്രധാന സംഖ്യ p നൽകിയാൽ, നിരവധി ചോദ്യങ്ങൾ ഉണ്ടാകും. ഓരോ ചോദ്യത്തിനും, ഒരു പൂർണ്ണസംഖ്യ n നൽകപ്പെടുന്നു, നിങ്ങൾ n! ⊕ p-ന്റെ മൂല്യം കണക്കാക്കണം, n! എന്നത് n-നേക്കാൾ ചെറിയ അല്ലെങ്കിൽ തുല്യമായ എല്ലാ ധനാത്മക പൂർണ്ണസംഖ്യകളുടെ ഗുണഫലമാണ്.\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)", "fa": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nاین مسئله یک عملیات جدید باقیمانده را معرفی می‌کند که با نماد \"⊕\" نشان داده می‌شود. هنگام محاسبه x ⊕ y، اگر x مضربی از y نباشد، نتیجه باقیمانده تقسیم x بر y است. در غیر این صورت، x را به طور مکرر بر y تقسیم کنید تا زمانی که x دیگر مضربی از y نباشد، مقدار نهایی را به عنوان x' نشان دهید. سپس نتیجه باقیمانده x' تقسیم بر y است. به عنوان مثال، 4⊕5=4، 20⊕5=4، 100⊕5=4.\nبا توجه به یک عدد اول p، چندین پرسش وجود خواهد داشت. برای هر پرسش، یک عدد صحیح n داده می‌شود و شما باید مقدار n! ⊕ p را محاسبه کنید، که در آن n! فاکتوریل n است، یعنی حاصل‌ضرب تمام اعداد صحیح مثبت کمتر یا مساوی n.\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)\n"}, "canonical_solution": "{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n    \n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}", "instruction": {"en": "unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)\n{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n    \n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "sq": "unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)\n{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n    \n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C në shqip duke përdorur maksimumi 500 karaktere.", "hy": "unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)\n{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n    \n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}\n\nՏվեք C կոդի հակիրճ բնութագրում (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)\n{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n    \n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}\n\nনিচের C কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।", "bg": "unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)\n{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n    \n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, използвайки не повече от 500 знака.", "zh": "unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)\n{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n    \n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}\n\n请用最多500个字符的中文对该C代码提供简洁的自然语言描述（文档字符串）。", "fr": "unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)\n{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n    \n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.", "de": "unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)\n{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n    \n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)\n{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n    \n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}\n\nBa da takaitaccen bayani a cikin yare na dabi'a (docstring) na lambar C cikin Hausa ta amfani da haruffa 500 ko kasa da haka.", "hi": "unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)\n{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n    \n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}\n\nC कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)\n{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n    \n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben.", "es": "unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)\n{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n    \n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando como máximo 500 caracteres.", "arb": "unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)\n{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n    \n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)\n{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n    \n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)\n{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n    \n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}\n\nVerilen C kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda özlü bir doğal dil açıklaması (docstring) sağlayın.", "vi": "unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)\n{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n    \n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã C bằng tiếng Việt, sử dụng tối đa 500 ký tự.", "id": "unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)\n{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n    \n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode C dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)\n{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n    \n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}\n\nCコードの内容を日本語で簡潔に説明するドキュメンテーションストリング（docstring）を500文字以内で提供してください。", "ko": "unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)\n{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n    \n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}\n\nC 코드의 동작을 설명하는 간결한 자연어 설명(docstring)을 한국어로 작성하세요. 최대 500자 이내로 작성해야 합니다.", "ml": "unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)\n{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n    \n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}\n\nC കോഡ് ഉപയോഗിച്ച് 500 അക്ഷരങ്ങളിൽ കൂടുതൽ അല്ലാത്ത രീതിയിൽ മലയാളത്തിൽ സംക്ഷിപ്തമായ ഒരു നാച്ചുറൽ ലാംഗ്വേജ് വിവരണം (ഡോക്സ്ട്രിംഗ്) നൽകുക.", "fa": "unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)\n{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n    \n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}\n\nتوضیح مختصر و طبیعی (docstring) از کد C به زبان فارسی ارائه دهید که حداکثر ۵۰۰ کاراکتر باشد."}, "level": "", "test": "int main() {\n    // Test cases\n    assert(newModuloFactorial(3, 7) == 6);\n    assert(newModuloFactorial(10, 3) == 1);\n    assert(newModuloFactorial(11, 7) == 4);\n    assert(newModuloFactorial(45, 7) == 1);\n    assert(newModuloFactorial(14, 7) == 2);\n    assert(newModuloFactorial(1919, 10007) == 3152);\n    assert(newModuloFactorial(810, 10007) == 3679);\n    assert(newModuloFactorial(3, 7) == 6);\n    assert(newModuloFactorial(10, 3) == 1);\n    assert(newModuloFactorial(1, 2) == 1);\n    assert(newModuloFactorial(5, 11) == 10);\n    assert(newModuloFactorial(6, 13) == 5);\n    assert(newModuloFactorial(8, 17) == 13);\n    assert(newModuloFactorial(15, 19) == 16);\n    assert(newModuloFactorial(21, 23) == 1);\n    assert(newModuloFactorial(30, 29) == 28);\n    assert(newModuloFactorial(100, 101) == 100);\n    return 0;\n}", "entry_point": "newModuloFactorial", "signature": "unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)", "docstring": {"en": "This problem introduces a new modulo operation, denoted by the symbol \"⊕\". When calculating x ⊕ y, if x is not a multiple of y, the result is the remainder of x divided by y. Otherwise, divide x by y repeatedly until x is no longer a multiple of y, denoting the final value as x'. Then the result is the remainder of x' divided by y. For example, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nGiven a prime number p, there will be several queries. For each query, an integer n is given, and you need to compute the value of n! ⊕ p, where n! is the factorial of n, i.e., the product of all positive integers less than or equal to n.\n    >>> newModuloFactorial(3, 7)\n    6\n", "sq": "Ky problem prezanton një operacion të ri modulo, i shënuar me simbolin \"⊕\". Kur llogaritni x ⊕ y, nëse x nuk është shumëfish i y, rezultati është mbetja e x e ndarë me y. Përndryshe, ndani x me y vazhdimisht derisa x të mos jetë më shumëfish i y, duke e shënuar vlerën përfundimtare si x'. Atëherë rezultati është mbetja e x' e ndarë me y. Për shembull, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nDuke pasur një numër të thjeshtë p, do të ketë disa pyetje. Për çdo pyetje, jepet një numër i plotë n, dhe ju duhet të llogaritni vlerën e n! ⊕ p, ku n! është faktoriali i n, dmth. prodhimi i të gjithë numrave të plotë pozitivë më të vegjël ose të barabartë me n.\n    >>> newModuloFactorial(3, 7)\n    6", "hy": "Այս խնդիրը ներկայացնում է նոր մնացորդային գործողություն, որը նշվում է \"⊕\" սիմվոլով: Երբ հաշվում ենք x ⊕ y, եթե x-ը y-ի բազմապատիկ չէ, արդյունքը x-ի բաժանումը y-ի մնացորդն է: Հակառակ դեպքում, բազմիցս բաժանում ենք x-ը y-ի վրա, մինչև x-ը այլևս y-ի բազմապատիկ չլինի, վերջնական արժեքը նշելով որպես x': Ապա արդյունքը x'-ի բաժանումը y-ի մնացորդն է: Օրինակ, 4⊕5=4, 20⊕5=4, 100⊕5=4:\nՏրված է p պարզ թիվը, և կլինեն մի քանի հարցումներ: Յուրաքանչյուր հարցման համար տրված է n ամբողջ թիվը, և դուք պետք է հաշվեք n! ⊕ p արժեքը, որտեղ n! n-ի ֆակտորիալն է, այսինքն՝ n-ից փոքր կամ հավասար բոլոր դրական ամբողջ թվերի արտադրյալը:\n    >>> newModuloFactorial(3, 7)\n    6", "bn": "এই সমস্যাটি একটি নতুন মডুলো অপারেশন পরিচয় করিয়ে দেয়, যা \"⊕\" প্রতীক দ্বারা চিহ্নিত। যখন x ⊕ y গণনা করা হয়, যদি x y এর গুণিতক না হয়, তাহলে ফলাফল হয় x কে y দিয়ে ভাগ করলে যে অবশিষ্ট থাকে। অন্যথায়, x কে y দিয়ে বারবার ভাগ করুন যতক্ষণ না x আর y এর গুণিতক থাকে, চূড়ান্ত মানটিকে x' হিসাবে চিহ্নিত করুন। তারপর ফলাফল হল x' কে y দিয়ে ভাগ করলে যে অবশিষ্ট থাকে। উদাহরণস্বরূপ, 4⊕5=4, 20⊕5=4, 100⊕5=4। একটি মৌলিক সংখ্যা p দেওয়া হলে, বেশ কয়েকটি প্রশ্ন থাকবে। প্রতিটি প্রশ্নের জন্য, একটি পূর্ণসংখ্যা n দেওয়া হয়, এবং আপনাকে n! ⊕ p এর মান গণনা করতে হবে, যেখানে n! হল n এর ফ্যাক্টোরিয়াল, অর্থাৎ n এর সমান বা তার চেয়ে ছোট সমস্ত ধনাত্মক পূর্ণসংখ্যার গুণফল।\n\n    >>> newModuloFactorial(3, 7)\n    6", "bg": "Този проблем въвежда нова операция за модуло, обозначена със символа \"⊕\". При изчисляване на x ⊕ y, ако x не е кратно на y, резултатът е остатъкът от x, разделен на y. В противен случай, разделяйте x на y многократно, докато x вече не е кратно на y, като отбелязвате крайната стойност като x'. Тогава резултатът е остатъкът от x', разделен на y. Например, 4⊕5=4, 20⊕5=4, 100⊕5=4. Дадено е просто число p, ще има няколко заявки. За всяка заявка е дадено цяло число n и трябва да изчислите стойността на n! ⊕ p, където n! е факториелът на n, т.е. произведението на всички положителни цели числа, по-малки или равни на n.\n    >>> newModuloFactorial(3, 7)\n    6", "zh": "这个问题引入了一种新的取模运算，用符号“⊕”表示。当计算 x ⊕ y 时，如果 x 不是 y 的倍数，结果是 x 除以 y 的余数。否则，反复将 x 除以 y，直到 x 不再是 y 的倍数，将最终值记为 x'。然后结果是 x' 除以 y 的余数。例如，4⊕5=4，20⊕5=4，100⊕5=4。\n给定一个素数 p，将会有若干查询。对于每个查询，给定一个整数 n，你需要计算 n! ⊕ p 的值，其中 n! 是 n 的阶乘，即小于或等于 n 的所有正整数的乘积。\n    >>> newModuloFactorial(3, 7)\n    6", "fr": "Ce problème introduit une nouvelle opération modulo, notée par le symbole \"⊕\". Lors du calcul de x ⊕ y, si x n'est pas un multiple de y, le résultat est le reste de x divisé par y. Sinon, divisez x par y de manière répétée jusqu'à ce que x ne soit plus un multiple de y, en désignant la valeur finale par x'. Ensuite, le résultat est le reste de x' divisé par y. Par exemple, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nÉtant donné un nombre premier p, il y aura plusieurs requêtes. Pour chaque requête, un entier n est donné, et vous devez calculer la valeur de n! ⊕ p, où n! est la factorielle de n, c'est-à-dire le produit de tous les entiers positifs inférieurs ou égaux à n.\n    >>> newModuloFactorial(3, 7)\n    6", "de": "Dieses Problem führt eine neue Modulo-Operation ein, die durch das Symbol \"⊕\" dargestellt wird. Bei der Berechnung von x ⊕ y, wenn x kein Vielfaches von y ist, ist das Ergebnis der Rest von x geteilt durch y. Andernfalls wird x wiederholt durch y geteilt, bis x kein Vielfaches von y mehr ist, wobei der endgültige Wert als x' bezeichnet wird. Dann ist das Ergebnis der Rest von x' geteilt durch y. Zum Beispiel, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nGegeben eine Primzahl p, wird es mehrere Anfragen geben. Für jede Anfrage wird eine ganze Zahl n gegeben, und Sie müssen den Wert von n! ⊕ p berechnen, wobei n! die Fakultät von n ist, d.h. das Produkt aller positiven ganzen Zahlen, die kleiner oder gleich n sind.\n    >>> newModuloFactorial(3, 7)\n    6", "ha": "Wannan matsalar tana gabatar da sabon aikin modulo, wanda aka nuna da alamar \"⊕\". Lokacin da ake lissafin x ⊕ y, idan x ba ya raba y ba tare da saura ba, sakamakon shine saura na x raba y. In ba haka ba, raba x da y akai-akai har sai x ba ya raba y ba tare da saura ba, ana nuna ƙimar ƙarshe a matsayin x'. Sannan sakamakon shine saura na x' raba y. Alal misali, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nAn ba da lambar farko p, za a sami tambayoyi da yawa. Domin kowace tambaya, an bayar da cikakken lamba n, kuma kuna buƙatar lissafin ƙimar n! ⊕ p, inda n! shine factorial na n, wato, samfurin duk lambobi masu kyau da suka fi ko daidai da n.\n\n    >>> newModuloFactorial(3, 7)\n    6", "hi": "यह समस्या एक नया माड्यूलो ऑपरेशन प्रस्तुत करती है, जिसे प्रतीक \"⊕\" द्वारा दर्शाया गया है। जब x ⊕ y की गणना की जाती है, यदि x, y का गुणज नहीं है, तो परिणाम x को y से विभाजित करने पर शेषफल होता है। अन्यथा, x को y से बार-बार विभाजित करें जब तक कि x अब y का गुणज न हो, अंतिम मान को x' के रूप में दर्शाते हुए। फिर परिणाम x' को y से विभाजित करने पर शेषफल होता है। उदाहरण के लिए, 4⊕5=4, 20⊕5=4, 100⊕5=4।\nएक अभाज्य संख्या p दी गई है, और कई क्वेरीज़ होंगी। प्रत्येक क्वेरी के लिए, एक पूर्णांक n दिया गया है, और आपको n! ⊕ p का मान गणना करना है, जहाँ n! n का फैक्टोरियल है, अर्थात n से कम या बराबर सभी धनात्मक पूर्णांकों का गुणनफल।\n\n    >>> newModuloFactorial(3, 7)\n    6", "hu": "Ez a probléma egy új modulo műveletet vezet be, amelyet a \"⊕\" szimbólum jelöl. Amikor az x ⊕ y értéket számítjuk, ha x nem osztható y-nal, az eredmény x maradéka y-nal osztva. Ellenkező esetben, osszuk el x-et y-nal ismételten, amíg x már nem osztható y-nal, és jelöljük a végső értéket x'-ként. Ekkor az eredmény x' maradéka y-nal osztva. Például, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nAdott egy prímszám p, és több lekérdezés lesz. Minden lekérdezéshez adott egy egész szám n, és ki kell számítani az n! ⊕ p értékét, ahol n! az n faktoriálisa, azaz az összes n-nél kisebb vagy egyenlő pozitív egész szám szorzata.\n    >>> newModuloFactorial(3, 7)\n    6", "es": "Este problema introduce una nueva operación de módulo, denotada por el símbolo \"⊕\". Al calcular x ⊕ y, si x no es un múltiplo de y, el resultado es el residuo de x dividido por y. De lo contrario, divide x por y repetidamente hasta que x ya no sea un múltiplo de y, denotando el valor final como x'. Entonces, el resultado es el residuo de x' dividido por y. Por ejemplo, 4⊕5=4, 20⊕5=4, 100⊕5=4. Dado un número primo p, habrá varias consultas. Para cada consulta, se da un número entero n, y necesitas calcular el valor de n! ⊕ p, donde n! es el factorial de n, es decir, el producto de todos los enteros positivos menores o iguales a n.\n    >>> newModuloFactorial(3, 7)\n    6", "arb": "هذه المشكلة تقدم عملية باقي جديدة، يرمز لها بالرمز \"⊕\". عند حساب x ⊕ y، إذا لم يكن x مضاعفًا لـ y، فإن النتيجة هي باقي قسمة x على y. أما إذا كان x مضاعفًا لـ y، فقم بقسمة x على y بشكل متكرر حتى لا يكون x مضاعفًا لـ y، واعتبر القيمة النهائية x'. ثم تكون النتيجة هي باقي قسمة x' على y. على سبيل المثال، 4⊕5=4، 20⊕5=4، 100⊕5=4. بالنظر إلى عدد أولي p، سيكون هناك عدة استفسارات. لكل استفسار، يُعطى عدد صحيح n، وتحتاج إلى حساب قيمة n! ⊕ p، حيث n! هو مضروب n، أي حاصل ضرب جميع الأعداد الصحيحة الموجبة الأقل من أو تساوي n.\n    >>> newModuloFactorial(3, 7)\n    6", "sw": "Tatizo hili linaanzisha operesheni mpya ya modulo, inayowakilishwa na alama \"⊕\". Wakati wa kuhesabu x ⊕ y, ikiwa x si kigezo cha y, matokeo ni mabaki ya x kugawanywa na y. Vinginevyo, gawanya x kwa y mara kwa mara hadi x isiwe tena kigezo cha y, ukionyesha thamani ya mwisho kama x'. Kisha matokeo ni mabaki ya x' kugawanywa na y. Kwa mfano, 4⊕5=4, 20⊕5=4, 100⊕5=4. Ukipewa nambari ya kwanza p, kutakuwa na maswali kadhaa. Kwa kila swali, nambari nzima n inatolewa, na unahitaji kuhesabu thamani ya n! ⊕ p, ambapo n! ni factorial ya n, yaani, bidhaa ya nambari zote chanya zilizo chini au sawa na n.\n    >>> newModuloFactorial(3, 7)\n    6", "tr": "Bu problem, \"⊕\" sembolü ile gösterilen yeni bir modül işlemi tanıtmaktadır. x ⊕ y hesaplanırken, eğer x, y'nin katı değilse, sonuç x'in y'ye bölünmesinden kalan değerdir. Aksi takdirde, x artık y'nin katı olmayana kadar x'i y'ye tekrar tekrar bölün, son değeri x' olarak belirtin. Sonra sonuç, x' in y'ye bölünmesinden kalan değerdir. Örneğin, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nVerilen bir asal sayı p için, birkaç sorgu olacaktır. Her sorgu için bir tamsayı n verilir ve n! ⊕ p değerini hesaplamanız gerekir; burada n!, n'ye eşit veya n'den küçük tüm pozitif tamsayıların çarpımıdır.\n    >>> newModuloFactorial(3, 7)\n    6", "vi": "Vấn đề này giới thiệu một phép toán modulo mới, được ký hiệu bằng biểu tượng \"⊕\". Khi tính x ⊕ y, nếu x không phải là bội số của y, kết quả là phần dư của x chia cho y. Ngược lại, chia x cho y liên tục cho đến khi x không còn là bội số của y, ký hiệu giá trị cuối cùng là x'. Sau đó kết quả là phần dư của x' chia cho y. Ví dụ, 4⊕5=4, 20⊕5=4, 100⊕5=4. Cho một số nguyên tố p, sẽ có một số truy vấn. Đối với mỗi truy vấn, một số nguyên n được cho, và bạn cần tính giá trị của n! ⊕ p, trong đó n! là giai thừa của n, tức là tích của tất cả các số nguyên dương nhỏ hơn hoặc bằng n.\n    >>> newModuloFactorial(3, 7)\n    6", "id": "Masalah ini memperkenalkan operasi modulo baru, yang dilambangkan dengan simbol \"⊕\". Ketika menghitung x ⊕ y, jika x bukan kelipatan dari y, hasilnya adalah sisa dari x dibagi y. Jika tidak, bagi x dengan y berulang kali sampai x tidak lagi menjadi kelipatan dari y, menandai nilai akhir sebagai x'. Kemudian hasilnya adalah sisa dari x' dibagi y. Sebagai contoh, 4⊕5=4, 20⊕5=4, 100⊕5=4. Diberikan sebuah bilangan prima p, akan ada beberapa kueri. Untuk setiap kueri, diberikan sebuah bilangan bulat n, dan Anda perlu menghitung nilai dari n! ⊕ p, di mana n! adalah faktorial dari n, yaitu hasil kali dari semua bilangan bulat positif yang kurang dari atau sama dengan n.\n    >>> newModuloFactorial(3, 7)\n    6", "ja": "この問題では、新しい剰余演算「⊕」を導入します。x ⊕ y を計算する際、x が y の倍数でない場合、結果は x を y で割った余りです。そうでない場合、x を y で割り続け、x が y の倍数でなくなるまで繰り返し、最終的な値を x' とします。その後、結果は x' を y で割った余りです。例えば、4⊕5=4、20⊕5=4、100⊕5=4。\n素数 p が与えられ、いくつかのクエリがあります。各クエリに対して、整数 n が与えられ、n! ⊕ p の値を計算する必要があります。ここで、n! は n の階乗であり、n 以下のすべての正の整数の積です。\n    >>> newModuloFactorial(3, 7)\n    6", "ko": "이 문제는 \"⊕\" 기호로 표시되는 새로운 모듈로 연산을 소개합니다. x ⊕ y를 계산할 때, 만약 x가 y의 배수가 아니라면 결과는 x를 y로 나눈 나머지입니다. 그렇지 않으면, x가 더 이상 y의 배수가 아닐 때까지 x를 y로 반복해서 나누고, 최종 값을 x'로 표시합니다. 그런 다음 결과는 x'를 y로 나눈 나머지입니다. 예를 들어, 4⊕5=4, 20⊕5=4, 100⊕5=4입니다.\n소수 p가 주어지면, 여러 쿼리가 있을 것입니다. 각 쿼리마다 정수 n이 주어지며, n! ⊕ p의 값을 계산해야 합니다. 여기서 n!은 n 이하의 모든 양의 정수의 곱인 팩토리얼입니다.\n    >>> newModuloFactorial(3, 7)\n    6", "ml": "ഈ പ്രശ്നം \"⊕\" എന്ന ചിഹ്നം ഉപയോഗിച്ച് പുതിയൊരു മോഡുലോ ഓപ്പറേഷൻ അവതരിപ്പിക്കുന്നു. x ⊕ y കണക്കാക്കുമ്പോൾ, x y-യുടെ ഗുണിതമല്ലെങ്കിൽ, ഫലം x y-ൽ വിഭജിച്ച ശേഷമുള്ള ശേഷമാണ്. അല്ലെങ്കിൽ, x y-ൽ നിന്ന് ഗുണിതമല്ലാതാകുന്നത് വരെ x y-ൽ വീണ്ടും വീണ്ടും വിഭജിക്കുക, അന്തിമ മൂല്യം x' ആയി സൂചിപ്പിക്കുക. തുടർന്ന് ഫലം x' y-ൽ വിഭജിച്ച ശേഷമുള്ള ശേഷമാണ്. ഉദാഹരണത്തിന്, 4⊕5=4, 20⊕5=4, 100⊕5=4. ഒരു പ്രധാന സംഖ്യ p നൽകിയാൽ, നിരവധി ക്വറിയുകൾ ഉണ്ടാകും. ഓരോ ക്വറിയിനും, ഒരു പൂർണ്ണസംഖ്യ n നൽകപ്പെടുന്നു, നിങ്ങൾ n! ⊕ p-യുടെ മൂല്യം കണക്കാക്കണം, n! എന്നത് n-നോ തുല്യമായോ അതിൽ താഴെയോ ഉള്ള എല്ലാ അനുക്രമ സംഖ്യകളുടെയും ഗുണിതമാണ്.\n    >>> newModuloFactorial(3, 7)\n    6", "fa": "این مسئله یک عملگر جدید باقیمانده، که با نماد \"⊕\" نشان داده می‌شود، معرفی می‌کند. هنگام محاسبه x ⊕ y، اگر x مضربی از y نباشد، نتیجه باقیمانده x تقسیم بر y است. در غیر این صورت، x را به طور مکرر بر y تقسیم کنید تا زمانی که x دیگر مضربی از y نباشد، و مقدار نهایی را به عنوان x' نشان دهید. سپس نتیجه باقیمانده x' تقسیم بر y است. برای مثال، 4⊕5=4، 20⊕5=4، 100⊕5=4.\nبا توجه به یک عدد اول p، چندین پرسش وجود خواهد داشت. برای هر پرسش، یک عدد صحیح n داده می‌شود و شما باید مقدار n! ⊕ p را محاسبه کنید، که در آن n! فاکتوریل n است، یعنی حاصل‌ضرب تمام اعداد صحیح مثبت کمتر یا مساوی n.\n    >>> newModuloFactorial(3, 7)\n    6"}}
{"task_id": "C/34", "prompt": {"en": "#include <stdio.h>\n#include <assert.h>\n/*\nYou are given an array a of n integers. You can perform at most one operation where you select three integers i, j, x (1 <= i <= j <= n) and replace all elements from a[i] to a[j] with x, at a cost of (j - i + 1).\nFind the minimum cost to make all elements in the array equal.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1\n*/\nint makeEqualAgain(int n, int a[])", "sq": "#include <stdio.h>\n#include <assert.h>\n/*\nJu jepet një varg a me n numra të plotë. Ju mund të kryeni maksimumi një operacion ku zgjidhni tre numra të plotë i, j, x (1 <= i <= j <= n) dhe zëvendësoni të gjitha elementet nga a[i] në a[j] me x, me një kosto prej (j - i + 1).\nGjeni koston minimale për t'i bërë të gjitha elementet në varg të barabarta.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1\n*/\nint makeEqualAgain(int n, int a[])", "hy": "#include <stdio.h>\n#include <assert.h>\n/*\nՁեզ տրված է n ամբողջ թվերի զանգված a։ Դուք կարող եք կատարել առավելագույնը մեկ գործողություն, որտեղ ընտրում եք երեք ամբողջ թվեր i, j, x (1 <= i <= j <= n) և փոխարինում եք a[i]-ից a[j] բոլոր տարրերը x-ով, արժեքով (j - i + 1):\nԳտեք նվազագույն արժեքը, որպեսզի բոլոր տարրերը զանգվածում դառնան հավասար:\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1\n*/\nint makeEqualAgain(int n, int a[])", "bn": "#include <stdio.h>\n#include <assert.h>\n/*\nতোমাকে n পূর্ণসংখ্যার একটি অ্যারে a দেওয়া হয়েছে। তুমি সর্বাধিক একটি অপারেশন করতে পার যেখানে তুমি তিনটি পূর্ণসংখ্যা i, j, x (1 <= i <= j <= n) নির্বাচন কর এবং a[i] থেকে a[j] পর্যন্ত সব উপাদানকে x দিয়ে প্রতিস্থাপন কর, যার খরচ (j - i + 1)।\nঅ্যারের সব উপাদান সমান করতে সর্বনিম্ন খরচ খুঁজে বের কর।\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1\n*/\nint makeEqualAgain(int n, int a[])", "bg": "#include <stdio.h>\n#include <assert.h>\n/*\nДаден е масив a от n цели числа. Можете да извършите най-много една операция, при която избирате три цели числа i, j, x (1 <= i <= j <= n) и заменяте всички елементи от a[i] до a[j] с x, на цена (j - i + 1).\nНамерете минималната цена, за да направите всички елементи в масива равни.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1\n*/\nint makeEqualAgain(int n, int a[])", "zh": "#include <stdio.h>\n#include <assert.h>\n/*\n给定一个由 n 个整数组成的数组 a。你可以执行最多一次操作，其中选择三个整数 i, j, x (1 <= i <= j <= n)，并将从 a[i] 到 a[j] 的所有元素替换为 x，代价为 (j - i + 1)。\n找到使数组中所有元素相等的最小代价。\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1\n*/\nint makeEqualAgain(int n, int a[])", "fr": "#include <stdio.h>\n#include <assert.h>\n/*\nOn vous donne un tableau a de n entiers. Vous pouvez effectuer au plus une opération où vous sélectionnez trois entiers i, j, x (1 <= i <= j <= n) et remplacez tous les éléments de a[i] à a[j] par x, à un coût de (j - i + 1).\nTrouvez le coût minimum pour rendre tous les éléments du tableau égaux.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1\n*/\nint makeEqualAgain(int n, int a[])", "de": "#include <stdio.h>\n#include <assert.h>\n/*\nSie haben ein Array a mit n ganzen Zahlen. Sie können höchstens eine Operation durchführen, bei der Sie drei ganze Zahlen i, j, x (1 <= i <= j <= n) auswählen und alle Elemente von a[i] bis a[j] mit x ersetzen, zu Kosten von (j - i + 1).\nFinden Sie die minimalen Kosten, um alle Elemente im Array gleich zu machen.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1\n*/\nint makeEqualAgain(int n, int a[])", "ha": "#include <stdio.h>\n#include <assert.h>\n/*\nAn ba ku wani tsari a na lambobi n. Kuna iya aiwatar da akalla aiki ɗaya inda kuka zaɓi lambobi uku i, j, x (1 <= i <= j <= n) kuma ku maye gurbin dukkan abubuwa daga a[i] zuwa a[j] da x, a kan farashin (j - i + 1).\nNemo mafi ƙarancin farashi don sanya duk abubuwan cikin jerin su zama daidai.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1\n*/\nint makeEqualAgain(int n, int a[])", "hi": "#include <stdio.h>\n#include <assert.h>\n/*\nआपको n पूर्णांकों की एक सरणी a दी गई है। आप अधिकतम एक ऑपरेशन कर सकते हैं जहां आप तीन पूर्णांक i, j, x (1 <= i <= j <= n) चुनते हैं और a[i] से a[j] तक के सभी तत्वों को x से बदलते हैं, जिसकी लागत (j - i + 1) होती है।\nसभी तत्वों को समान बनाने की न्यूनतम लागत खोजें।\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1\n*/\nint makeEqualAgain(int n, int a[])", "hu": "#include <stdio.h>\n#include <assert.h>\n/*\nAdott egy n egész számot tartalmazó tömb. Legfeljebb egy műveletet hajthatsz végre, ahol kiválasztasz három egész számot i, j, x (1 <= i <= j <= n), és az a[i]-től a[j]-ig terjedő összes elemet x-re cseréled, (j - i + 1) költséggel.\nTaláld meg a minimális költséget, hogy a tömb összes eleme egyenlő legyen.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1\n*/\nint makeEqualAgain(int n, int a[])", "es": "#include <stdio.h>\n#include <assert.h>\n/*\nSe te da un arreglo a de n enteros. Puedes realizar como máximo una operación donde seleccionas tres enteros i, j, x (1 <= i <= j <= n) y reemplazas todos los elementos de a[i] a a[j] con x, a un costo de (j - i + 1).\nEncuentra el costo mínimo para hacer que todos los elementos en el arreglo sean iguales.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1\n*/\nint makeEqualAgain(int n, int a[])", "arb": "#include <stdio.h>\n#include <assert.h>\n/*\nلديك مصفوفة a تحتوي على n عدد صحيح. يمكنك تنفيذ عملية واحدة على الأكثر حيث تختار ثلاثة أعداد صحيحة i، j، x (1 <= i <= j <= n) وتستبدل جميع العناصر من a[i] إلى a[j] بـ x، بتكلفة (j - i + 1).\nابحث عن الحد الأدنى للتكلفة لجعل جميع العناصر في المصفوفة متساوية.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1\n*/\nint makeEqualAgain(int n, int a[])", "sw": "#include <stdio.h>\n#include <assert.h>\n/*\nUmepewa safu a ya n nambari za mzima. Unaweza kufanya operesheni moja tu ambapo unachagua nambari tatu i, j, x (1 <= i <= j <= n) na kubadilisha vipengele vyote kutoka a[i] hadi a[j] na x, kwa gharama ya (j - i + 1).\nPata gharama ndogo zaidi ya kufanya vipengele vyote katika safu kuwa sawa.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1\n*/\nint makeEqualAgain(int n, int a[])", "tr": "#include <stdio.h>\n#include <assert.h>\n/*\nSize n olan bir tamsayı dizisi verilmektedir. En fazla bir işlem yaparak i, j, x (1 <= i <= j <= n) üç tamsayısını seçebilir ve a[i] ile a[j] arasındaki tüm elemanları x ile değiştirebilirsiniz, bu işlemin maliyeti (j - i + 1) olacaktır.\nDizideki tüm elemanları eşit yapmak için minimum maliyeti bulun.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1\n*/\nint makeEqualAgain(int n, int a[])", "vi": "#include <stdio.h>\n#include <assert.h>\n/*\nBạn được cho một mảng a gồm n số nguyên. Bạn có thể thực hiện tối đa một thao tác, trong đó bạn chọn ba số nguyên i, j, x (1 <= i <= j <= n) và thay thế tất cả các phần tử từ a[i] đến a[j] bằng x, với chi phí là (j - i + 1).\nTìm chi phí tối thiểu để làm cho tất cả các phần tử trong mảng bằng nhau.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1\n*/\nint makeEqualAgain(int n, int a[])", "id": "#include <stdio.h>\n#include <assert.h>\n/*\nAnda diberikan sebuah array a yang terdiri dari n bilangan bulat. Anda dapat melakukan paling banyak satu operasi di mana Anda memilih tiga bilangan bulat i, j, x (1 <= i <= j <= n) dan mengganti semua elemen dari a[i] hingga a[j] dengan x, dengan biaya (j - i + 1).\nTemukan biaya minimum untuk membuat semua elemen dalam array menjadi sama.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1\n*/\nint makeEqualAgain(int n, int a[])", "ja": "#include <stdio.h>\n#include <assert.h>\n/*\n配列 a が n 個の整数で与えられます。1 回だけ操作を行うことができ、3 つの整数 i, j, x (1 <= i <= j <= n) を選択し、a[i] から a[j] までのすべての要素を x に置き換えます。この操作のコストは (j - i + 1) です。\n配列内のすべての要素を等しくするための最小コストを求めてください。\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1\n*/\nint makeEqualAgain(int n, int a[])", "ko": "#include <stdio.h>\n#include <assert.h>\n/*\n정수 n개의 배열 a가 주어집니다. 최대 한 번의 연산을 수행할 수 있으며, 여기서 세 개의 정수 i, j, x (1 <= i <= j <= n)를 선택하고 a[i]부터 a[j]까지의 모든 요소를 x로 바꿉니다. 이때 비용은 (j - i + 1)입니다.\n배열의 모든 요소를 동일하게 만드는 최소 비용을 찾으세요.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1\n*/\nint makeEqualAgain(int n, int a[])", "ml": "#include <stdio.h>\n#include <assert.h>\n/*\nനിങ്ങൾക്ക് n പൂർണ്ണസംഖ്യകളുടെ ഒരു നിര a ലഭിച്ചിട്ടുണ്ട്. നിങ്ങൾക്ക് പരമാവധി ഒരു പ്രവർത്തനം നടത്താം, അവിടെ നിങ്ങൾ i, j, x (1 <= i <= j <= n) എന്ന മൂന്നു പൂർണ്ണസംഖ്യകളെ തിരഞ്ഞെടുക്കുകയും a[i] മുതൽ a[j] വരെയുള്ള എല്ലാ മൂല്യങ്ങളും x-നായി മാറ്റുകയും ചെയ്യാം, (j - i + 1) എന്ന ചെലവിൽ.\nഎല്ലാ മൂല്യങ്ങളും നിരയിൽ തുല്യമായിരിക്കാനുള്ള കുറഞ്ഞ ചെലവ് കണ്ടെത്തുക.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1\n*/\nint makeEqualAgain(int n, int a[])", "fa": "#include <stdio.h>\n#include <assert.h>\n/*\nشما یک آرایه a از n عدد صحیح دارید. شما می‌توانید حداکثر یک عملیات انجام دهید که در آن سه عدد صحیح i، j، x (1 <= i <= j <= n) را انتخاب کرده و تمام عناصر از a[i] تا a[j] را با x جایگزین کنید، با هزینه (j - i + 1).\nحداقل هزینه برای برابر کردن تمام عناصر در آرایه را پیدا کنید.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1\n*/\nint makeEqualAgain(int n, int a[])"}, "canonical_solution": "{\n    int p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}", "instruction": {"en": "int makeEqualAgain(int n, int a[])\n{\n    int p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "sq": "int makeEqualAgain(int n, int a[])\n{\n    int p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C në shqip duke përdorur maksimumi 500 karaktere.", "hy": "int makeEqualAgain(int n, int a[])\n{\n    int p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}\n\nՏվեք C կոդի հակիրճ բնութագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "int makeEqualAgain(int n, int a[])\n{\n    int p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}\n\nসি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।", "bg": "int makeEqualAgain(int n, int a[])\n{\n    int p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, използвайки не повече от 500 знака.", "zh": "int makeEqualAgain(int n, int a[])\n{\n    int p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}\n\n请用最多500个字符的中文，为以下C代码提供简明的自然语言描述（文档字符串）。", "fr": "int makeEqualAgain(int n, int a[])\n{\n    int p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.", "de": "int makeEqualAgain(int n, int a[])\n{\n    int p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "int makeEqualAgain(int n, int a[])\n{\n    int p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar C a cikin Hausa ta amfani da haruffa 500 kawai.", "hi": "int makeEqualAgain(int n, int a[])\n{\n    int p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}\n\nC कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "int makeEqualAgain(int n, int a[])\n{\n    int p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben.", "es": "int makeEqualAgain(int n, int a[])\n{\n    int p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando como máximo 500 caracteres.", "arb": "int makeEqualAgain(int n, int a[])\n{\n    int p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "int makeEqualAgain(int n, int a[])\n{\n    int p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}\n\nToa maelezo mafupi kwa lugha ya asili (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "int makeEqualAgain(int n, int a[])\n{\n    int p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}\n\nC kodunun işlevselliğini açıklayan en fazla 500 karakterlik Türkçe bir açıklama (docstring) sağlayın.", "vi": "int makeEqualAgain(int n, int a[])\n{\n    int p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã C bằng tiếng Việt với tối đa 500 ký tự.", "id": "int makeEqualAgain(int n, int a[])\n{\n    int p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode C dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "int makeEqualAgain(int n, int a[])\n{\n    int p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}\n\nC コードの簡単な自然言語による説明 (docstring) を英語で最大 500 文字まで入力してください。", "ko": "int makeEqualAgain(int n, int a[])\n{\n    int p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}\n\nC 코드에 대한 간결한 자연어 설명(docstring)을 한국어로 최대 500자 이내로 제공하세요.", "ml": "int makeEqualAgain(int n, int a[])\n{\n    int p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}\n\nസീ കോഡിന്റെ സംഗ്രഹമായ സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) മലയാളത്തിൽ 500 അക്ഷരങ്ങൾക്കുള്ളിൽ നൽകുക.", "fa": "int makeEqualAgain(int n, int a[])\n{\n    int p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}\n\nتوضیح مختصر و طبیعی (docstring) از کد C به زبان فارسی ارائه دهید که حداکثر ۵۰۰ کاراکتر باشد."}, "level": "", "test": "int main() {\n    int test1[] = {1, 2, 1};\n    int test2[] = {5, 5, 1, 5, 5};\n    int test3[] = {1, 1, 1, 1};\n    int test4[] = {2, 2, 2, 3, 2, 2};\n    int test5[] = {1};\n    int test6[] = {1, 2};\n    int test7[] = {1, 2, 2, 1};\n    int test8[] = {4, 4, 4, 3, 3, 4, 4};\n    int test9[] = {5, 4, 4, 4, 5, 5};\n    int test10[] = {1, 2, 1, 2, 1, 2, 1};\n    int a1[] = {1,2,3,4,5,1};\n    int a2[] = {1,1,1,1,1,1,1};\n    int a3[] = {8,8,8,1,2,8,8,8};\n    int a4[] = {1,2,3};\n    int a5[] = {4,3,2,7,1,1,3};\n    int a6[] = {9,9,2,9,2,5,5,5,3};\n    assert(makeEqualAgain(6, a1) == 4);\n    assert(makeEqualAgain(7, a2) == 0);\n    assert(makeEqualAgain(8, a3) == 2);\n    assert(makeEqualAgain(3, a4) == 2);\n    assert(makeEqualAgain(7, a5) == 6);\n    assert(makeEqualAgain(9, a6) == 7);\n\n    assert(makeEqualAgain(3, test1) == 1);\n    assert(makeEqualAgain(5, test2) == 1);\n    assert(makeEqualAgain(4, test3) == 0);\n    assert(makeEqualAgain(6, test4) == 1);\n    assert(makeEqualAgain(1, test5) == 0);\n    assert(makeEqualAgain(2, test6) == 1);\n    assert(makeEqualAgain(4, test7) == 2);\n    assert(makeEqualAgain(7, test8) == 2);\n    assert(makeEqualAgain(6, test9) == 3);\n    assert(makeEqualAgain(7, test10) == 5);\n\n    return 0;\n}", "entry_point": "makeEqualAgain", "signature": "int makeEqualAgain(int n, int a[])", "docstring": {"en": "You are given an array a of n integers. You can perform at most one operation where you select three integers i, j, x (1 <= i <= j <= n) and replace all elements from a[i] to a[j] with x, at a cost of (j - i + 1).\nFind the minimum cost to make all elements in the array equal.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1\n", "sq": "Ju jepet një varg a me n numra të plotë. Ju mund të kryeni maksimumi një operacion ku zgjidhni tre numra të plotë i, j, x (1 <= i <= j <= n) dhe zëvendësoni të gjitha elementet nga a[i] deri te a[j] me x, me një kosto prej (j - i + 1).\nGjeni koston minimale për të bërë të gjitha elementet në varg të barabarta.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1", "hy": "Ձեզ տրված է n ամբողջ թվերի զանգված a։ Դուք կարող եք կատարել առավելագույնը մեկ գործողություն, որտեղ ընտրում եք երեք ամբողջ թվեր i, j, x (1 <= i <= j <= n) և փոխարինում եք a[i]-ից a[j]-ը x-ով, արժեքով (j - i + 1): Գտեք նվազագույն արժեքը, որպեսզի զանգվածի բոլոր տարրերը հավասար լինեն:\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1", "bn": "আপনাকে n পূর্ণসংখ্যার একটি অ্যারে a দেওয়া হয়েছে। আপনি সর্বাধিক একটি অপারেশন করতে পারেন যেখানে আপনি তিনটি পূর্ণসংখ্যা i, j, x (1 <= i <= j <= n) নির্বাচন করেন এবং a[i] থেকে a[j] পর্যন্ত সমস্ত উপাদানকে x দিয়ে প্রতিস্থাপন করেন, যার খরচ (j - i + 1) হয়। অ্যারের সমস্ত উপাদান সমান করতে ন্যূনতম খরচ খুঁজে বের করুন।\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1", "bg": "Даден е масив a от n цели числа. Можете да извършите най-много една операция, при която избирате три цели числа i, j, x (1 <= i <= j <= n) и заменяте всички елементи от a[i] до a[j] с x, на цена (j - i + 1).\nНамерете минималната цена, за да направите всички елементи в масива равни.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1", "zh": "你有一个由 n 个整数组成的数组 a。你最多可以执行一次操作，其中你选择三个整数 i, j, x (1 <= i <= j <= n)，并将从 a[i] 到 a[j] 的所有元素替换为 x，代价为 (j - i + 1)。  \n找出使数组中所有元素相等的最小代价。\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1", "fr": "Vous avez un tableau a de n entiers. Vous pouvez effectuer au plus une opération où vous sélectionnez trois entiers i, j, x (1 <= i <= j <= n) et remplacez tous les éléments de a[i] à a[j] par x, à un coût de (j - i + 1).\nTrouvez le coût minimum pour rendre tous les éléments du tableau égaux.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1", "de": "Du hast ein Array a mit n ganzen Zahlen. Du kannst höchstens eine Operation ausführen, bei der du drei ganze Zahlen i, j, x (1 <= i <= j <= n) auswählst und alle Elemente von a[i] bis a[j] durch x ersetzt, zu Kosten von (j - i + 1).\nFinde die minimalen Kosten, um alle Elemente im Array gleich zu machen.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1", "ha": "An ba ku wani tsari a na lamba n integers. Kuna iya aiwatar da mafi yawan aiki daya inda kuka zaɓi lambobi uku i, j, x (1 <= i <= j <= n) kuma ku maye gurbin dukkan abubuwa daga a[i] zuwa a[j] da x, a kan farashi na (j - i + 1).\nNemo mafi ƙarancin kuɗi don sanya duk abubuwan a cikin tsari su zama daidai.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1", "hi": "आपको n पूर्णांकों के एक array a दिया गया है। आप अधिकतम एक ऑपरेशन कर सकते हैं जहाँ आप तीन पूर्णांक i, j, x (1 <= i <= j <= n) चुनते हैं और a[i] से a[j] तक के सभी तत्वों को x से बदलते हैं, जिसकी लागत (j - i + 1) होती है। सभी तत्वों को array में समान बनाने की न्यूनतम लागत खोजें।\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1", "hu": "Ön kap egy n egész számot tartalmazó tömböt, amelyet a-nak nevezünk. Legfeljebb egy műveletet hajthat végre, ahol kiválaszt három egész számot i, j, x (1 <= i <= j <= n), és az a[i]-től a[j]-ig terjedő összes elemet x-szel helyettesíti, (j - i + 1) költséggel. Találja meg a minimális költséget, hogy a tömb összes eleme egyenlő legyen.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1", "es": "Se te da un array a de n enteros. Puedes realizar como máximo una operación donde seleccionas tres enteros i, j, x (1 <= i <= j <= n) y reemplazas todos los elementos de a[i] a a[j] con x, a un costo de (j - i + 1). Encuentra el costo mínimo para hacer que todos los elementos en el array sean iguales.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1", "arb": "أنت مُعطى مصفوفة a تحتوي على n من الأعداد الصحيحة. يمكنك تنفيذ عملية واحدة على الأكثر حيث تختار ثلاثة أعداد صحيحة i، j، x (1 <= i <= j <= n) وتستبدل جميع العناصر من a[i] إلى a[j] بـ x، بتكلفة (j - i + 1). \nاعثر على الحد الأدنى للتكلفة لجعل جميع العناصر في المصفوفة متساوية.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1", "sw": "Umepewa safu a ya n nambari nzima. Unaweza kufanya operesheni moja tu ambapo unachagua nambari tatu i, j, x (1 <= i <= j <= n) na kubadilisha vipengele vyote kutoka a[i] hadi a[j] na x, kwa gharama ya (j - i + 1). \nPata gharama ndogo zaidi ya kufanya vipengele vyote katika safu kuwa sawa.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1", "tr": "Size n olan bir tamsayı dizisi a veriliyor. En fazla bir işlem gerçekleştirebilirsiniz; burada i, j, x (1 <= i <= j <= n) üç tamsayısını seçip a[i] ile a[j] arasındaki tüm elemanları x ile değiştirirsiniz ve bu işlem (j - i + 1) maliyetine sahiptir. Dizideki tüm elemanları eşit hale getirmek için minimum maliyeti bulun.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1", "vi": "Bạn được cung cấp một mảng a gồm n số nguyên. Bạn có thể thực hiện tối đa một thao tác, trong đó bạn chọn ba số nguyên i, j, x (1 <= i <= j <= n) và thay thế tất cả các phần tử từ a[i] đến a[j] bằng x, với chi phí là (j - i + 1). Tìm chi phí tối thiểu để làm cho tất cả các phần tử trong mảng bằng nhau.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1", "id": "Anda diberikan sebuah array a yang terdiri dari n bilangan bulat. Anda dapat melakukan paling banyak satu operasi di mana Anda memilih tiga bilangan bulat i, j, x (1 <= i <= j <= n) dan mengganti semua elemen dari a[i] hingga a[j] dengan x, dengan biaya sebesar (j - i + 1). Temukan biaya minimum untuk membuat semua elemen dalam array menjadi sama.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1", "ja": "配列 a が n 個の整数で与えられます。1 回だけ操作を行うことができ、3 つの整数 i, j, x (1 <= i <= j <= n) を選択し、a[i] から a[j] までのすべての要素を x に置き換えます。そのコストは (j - i + 1) です。\n配列内のすべての要素を等しくするための最小コストを求めます。\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1", "ko": "당신에게 n개의 정수로 구성된 배열 a가 주어집니다. 최대 한 번의 연산을 수행할 수 있으며, 여기서 세 개의 정수 i, j, x (1 <= i <= j <= n)를 선택하고 a[i]에서 a[j]까지의 모든 요소를 x로 대체합니다. 이때 비용은 (j - i + 1)입니다. 배열의 모든 요소를 같게 만드는 최소 비용을 찾으세요.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1", "ml": "നിങ്ങൾക്ക് n പൂർണ്ണസംഖ്യകളുടെ ഒരു നിര നൽകപ്പെടുന്നു. നിങ്ങൾക്ക് i, j, x (1 <= i <= j <= n) എന്ന മൂന്ന് പൂർണ്ണസംഖ്യകൾ തിരഞ്ഞെടുക്കുകയും a[i] മുതൽ a[j] വരെയുള്ള എല്ലാ ഘടകങ്ങളും x-ൽ മാറ്റിസ്ഥാപിക്കുകയും ചെയ്യാവുന്ന പരമാവധി ഒരു പ്രവർത്തനം നടത്താം, (j - i + 1) എന്ന ചെലവിൽ. നിരയിലെ എല്ലാ ഘടകങ്ങളും തുല്യമായിത്തീരാൻ കുറഞ്ഞ ചെലവ് കണ്ടെത്തുക.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1", "fa": "شما یک آرایه a شامل n عدد صحیح دارید. شما می‌توانید حداکثر یک عملیات انجام دهید که در آن سه عدد صحیح i، j، x (1 <= i <= j <= n) را انتخاب کرده و تمام عناصر از a[i] تا a[j] را با x جایگزین کنید، با هزینه (j - i + 1). حداقل هزینه برای برابر کردن تمام عناصر در آرایه را پیدا کنید.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1"}}
{"task_id": "C/35", "prompt": {"en": "#include <assert.h>\n#include <stdio.h>\n/*\nGiven a sequence of N piles of stones numbered from 1 to N, with each pile containing a positive number of stones, determine the winner of a game played by Charlie and Dan. Charlie goes first, and they take turns moving a positive number of stones from the leftmost non-empty pile to the adjacent right pile. The player who can only move stones in the last pile loses. Assuming both players use the best possible strategy, find out who will win the game.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"\n*/\nconst char* gameWinner(int n, int piles[])", "sq": "#include <assert.h>\n#include <stdio.h>\n/*\nDuke pasur një sekuencë prej N grumbuj gurësh të numëruar nga 1 deri në N, me secilin grumbull që përmban një numër pozitiv gurësh, përcaktoni fituesin e një loje të luajtur nga Charlie dhe Dan. Charlie fillon i pari, dhe ata marrin me radhë duke lëvizur një numër pozitiv gurësh nga grumbulli më i majtë jo-bosh në grumbullin ngjitur në të djathtë. Lojtari që mund të lëvizë gurë vetëm në grumbullin e fundit humbet. Duke supozuar se të dy lojtarët përdorin strategjinë më të mirë të mundshme, zbuloni se kush do të fitojë lojën.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"\n*/\nconst char* gameWinner(int n, int piles[])", "hy": "#include <assert.h>\n#include <stdio.h>\n/*\nՈւնենալով քարերի N կույտերից բաղկացած հաջորդականություն, որոնք համարակալված են 1-ից N, և յուրաքանչյուր կույտ պարունակում է քարերի դրական քանակ, որոշեք խաղի հաղթողին, որը խաղում են Չարլին և Դենը։ Չարլին առաջինն է խաղում, և նրանք հերթով տեղափոխում են քարերի դրական քանակություն ձախից ամենաառաջին ոչ դատարկ կույտից դեպի հարևան աջ կույտ։ Խաղացողը, որը կարող է միայն քարեր տեղափոխել վերջին կույտում, պարտվում է։ Ենթադրելով, որ երկու խաղացողներն էլ օգտագործում են հնարավոր լավագույն ռազմավարությունը, պարզեք, թե ով կհաղթի խաղը։\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"\n*/\nconst char* gameWinner(int n, int piles[])", "bn": "#include <assert.h>\n#include <stdio.h>\n/*\nএকটি N সংখ্যক পাথরের স্তূপের ক্রম দেওয়া হয়েছে, যা 1 থেকে N পর্যন্ত নম্বরযুক্ত, প্রতিটি স্তূপে একটি ধনাত্মক সংখ্যক পাথর রয়েছে, চার্লি এবং ড্যান দ্বারা খেলা একটি গেমের বিজয়ী নির্ধারণ করুন। চার্লি প্রথমে যায়, এবং তারা পালাক্রমে বামদিকের প্রথম খালি না হওয়া স্তূপ থেকে ডান পাশের সংলগ্ন স্তূপে একটি ধনাত্মক সংখ্যক পাথর সরায়। যে খেলোয়াড় কেবলমাত্র শেষ স্তূপে পাথর সরাতে পারে, সে হেরে যায়। ধরে নেওয়া হয় যে উভয় খেলোয়াড়ই সর্বোত্তম কৌশল ব্যবহার করে, খেলা কে জিতবে তা খুঁজে বের করুন।\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"\n*/\nconst char* gameWinner(int n, int piles[])", "bg": "#include <assert.h>\n#include <stdio.h>\n/*\nДадена е последователност от N купчини камъни, номерирани от 1 до N, като всяка купчина съдържа положителен брой камъни. Определете победителя в игра, играна от Чарли и Дан. Чарли започва пръв и те се редуват да преместват положителен брой камъни от най-лявата непразна купчина в съседната дясна купчина. Играчът, който може да премести камъни само в последната купчина, губи. Приемайки, че и двамата играчи използват най-добрата възможна стратегия, разберете кой ще спечели играта.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"\n*/\nconst char* gameWinner(int n, int piles[])", "zh": "#include <assert.h>\n#include <stdio.h>\n/*\n给定一个从1到N编号的N堆石头序列，每堆包含一个正数的石头，确定由Charlie和Dan进行的游戏的赢家。Charlie先开始，他们轮流将正数的石头从最左边的非空堆移动到相邻的右边堆。只能在最后一堆移动石头的玩家输掉比赛。假设两位玩家都使用最佳策略，找出谁将赢得比赛。\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"\n*/\nconst char* gameWinner(int n, int piles[])", "fr": "#include <assert.h>\n#include <stdio.h>\n/*\nÉtant donné une séquence de N tas de pierres numérotés de 1 à N, chaque tas contenant un nombre positif de pierres, déterminez le gagnant d'un jeu joué par Charlie et Dan. Charlie commence, et ils prennent à tour de rôle un nombre positif de pierres du tas le plus à gauche non vide pour les déplacer vers le tas adjacent à droite. Le joueur qui ne peut déplacer des pierres que dans le dernier tas perd. En supposant que les deux joueurs utilisent la meilleure stratégie possible, découvrez qui gagnera le jeu.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"\n*/\nconst char* gameWinner(int n, int piles[])", "de": "#include <assert.h>\n#include <stdio.h>\n/*\nGegeben eine Sequenz von N Steinhaufen, nummeriert von 1 bis N, wobei jeder Haufen eine positive Anzahl von Steinen enthält, bestimmen Sie den Gewinner eines Spiels, das von Charlie und Dan gespielt wird. Charlie beginnt, und sie wechseln sich ab, indem sie eine positive Anzahl von Steinen vom linken, nicht leeren Haufen zum benachbarten rechten Haufen bewegen. Der Spieler, der nur noch Steine im letzten Haufen bewegen kann, verliert. Angenommen, beide Spieler verwenden die bestmögliche Strategie, finden Sie heraus, wer das Spiel gewinnen wird.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"\n*/\nconst char* gameWinner(int n, int piles[])", "ha": "#include <assert.h>\n#include <stdio.h>\n/*\nAn ba da jerin N na tarin duwatsu da aka lamba daga 1 zuwa N, tare da kowace tarin dauke da adadin duwatsu masu kyau, tantance wanda zai ci wasa da Charlie da Dan suka buga. Charlie ne zai fara, kuma suna juyawa suna motsa adadin duwatsu masu kyau daga tarin da ba komai a hagu zuwa tarin da ke makwabta a dama. Dan wasan da zai iya motsa duwatsu a cikin tarin karshe kadai zai rasa. Ana tsammanin duka 'yan wasan suna amfani da mafi kyawun dabaru, gano wanda zai ci wasan.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"\n*/\nconst char* gameWinner(int n, int piles[])", "hi": "#include <assert.h>\n#include <stdio.h>\n/*\n1 से N तक क्रमांकित पत्थरों के N ढेरों की एक श्रृंखला दी गई है, जिसमें प्रत्येक ढेर में पत्थरों की एक सकारात्मक संख्या है, चार्ली और डैन द्वारा खेले गए एक खेल के विजेता का निर्धारण करें। चार्ली पहले जाता है, और वे बारी-बारी से बाईं ओर के सबसे पहले गैर-खाली ढेर से दाईं ओर के सटे हुए ढेर में पत्थरों की एक सकारात्मक संख्या को स्थानांतरित करते हैं। वह खिलाड़ी जो केवल अंतिम ढेर में पत्थरों को स्थानांतरित कर सकता है, हार जाता है। मान लें कि दोनों खिलाड़ी सबसे अच्छी संभव रणनीति का उपयोग करते हैं, यह पता लगाएं कि खेल कौन जीतेगा।\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"\n*/\nconst char* gameWinner(int n, int piles[])", "hu": "#include <assert.h>\n#include <stdio.h>\n/*\nAdott egy N halomból álló kőhalom sorozat, amelyeket 1-től N-ig számoztak, és mindegyik halom pozitív számú követ tartalmaz. Határozd meg, ki nyeri a játékot, amelyet Charlie és Dan játszanak. Charlie kezd, és felváltva mozgatnak pozitív számú követ a bal szélső nem üres halomból a szomszédos jobb halomba. Az a játékos veszít, aki csak az utolsó halomban tud követ mozgatni. Feltételezve, hogy mindkét játékos a lehető legjobb stratégiát alkalmazza, derítsd ki, ki fogja megnyerni a játékot.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"\n*/\nconst char* gameWinner(int n, int piles[])", "es": "#include <assert.h>\n#include <stdio.h>\n/*\nDada una secuencia de N pilas de piedras numeradas del 1 al N, con cada pila conteniendo un número positivo de piedras, determina el ganador de un juego jugado por Charlie y Dan. Charlie comienza primero, y se turnan moviendo un número positivo de piedras de la pila más a la izquierda no vacía a la pila adyacente a la derecha. El jugador que solo puede mover piedras en la última pila pierde. Suponiendo que ambos jugadores usan la mejor estrategia posible, averigua quién ganará el juego.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"\n*/\nconst char* gameWinner(int n, int piles[])", "arb": "#include <assert.h>\n#include <stdio.h>\n/*\nبالنظر إلى تسلسل من N كومة من الحجارة مرقمة من 1 إلى N، تحتوي كل كومة على عدد موجب من الحجارة، حدد الفائز في لعبة يلعبها تشارلي ودان. يبدأ تشارلي أولاً، ويتناوبون في نقل عدد موجب من الحجارة من الكومة اليسرى غير الفارغة إلى الكومة المجاورة على اليمين. اللاعب الذي لا يستطيع سوى نقل الحجارة في الكومة الأخيرة يخسر. بافتراض أن كلا اللاعبين يستخدمان أفضل استراتيجية ممكنة، اكتشف من سيفوز في اللعبة.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"\n*/\nconst char* gameWinner(int n, int piles[])", "sw": "#include <assert.h>\n#include <stdio.h>\n/*\nUkipiwa mlolongo wa mirundo N ya mawe yenye namba kutoka 1 hadi N, ambapo kila rundo lina idadi chanya ya mawe, amua mshindi wa mchezo unaochezwa na Charlie na Dan. Charlie huanza kwanza, na wanachukua zamu kuhamisha idadi chanya ya mawe kutoka kwenye rundo la kwanza lisilo tupu kwenda kwenye rundo la kulia lililo karibu. Mchezaji ambaye anaweza tu kuhamisha mawe kwenye rundo la mwisho anapoteza. Tukidhani wachezaji wote wanatumia mkakati bora zaidi, tafuta nani atashinda mchezo.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"\n*/\nconst char* gameWinner(int n, int piles[])", "tr": "#include <assert.h>\n#include <stdio.h>\n/*\n1'den N'e kadar numaralandırılmış N taş yığını dizisi verildiğinde, her yığın pozitif sayıda taş içerir, Charlie ve Dan tarafından oynanan bir oyunun kazananını belirleyin. Charlie ilk başlar ve sırayla en soldaki dolu olmayan yığından bitişik sağ yığına pozitif sayıda taş taşırlar. Sadece son yığındaki taşları hareket ettirebilen oyuncu kaybeder. Her iki oyuncunun da mümkün olan en iyi stratejiyi kullandığını varsayarak, oyunu kimin kazanacağını bulun.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"\n*/\nconst char* gameWinner(int n, int piles[])", "vi": "#include <assert.h>\n#include <stdio.h>\n/*\nCho một dãy N đống đá được đánh số từ 1 đến N, với mỗi đống chứa một số lượng đá dương, xác định người chiến thắng của trò chơi được chơi bởi Charlie và Dan. Charlie đi trước, và họ lần lượt di chuyển một số lượng đá dương từ đống không rỗng ngoài cùng bên trái sang đống liền kề bên phải. Người chơi chỉ có thể di chuyển đá trong đống cuối cùng sẽ thua. Giả sử cả hai người chơi đều sử dụng chiến lược tốt nhất có thể, tìm ra ai sẽ thắng trò chơi.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"\n*/\nconst char* gameWinner(int n, int piles[])", "id": "#include <assert.h>\n#include <stdio.h>\n/*\nDiberikan urutan N tumpukan batu yang diberi nomor dari 1 hingga N, dengan setiap tumpukan berisi sejumlah batu positif, tentukan pemenang dari permainan yang dimainkan oleh Charlie dan Dan. Charlie pergi lebih dulu, dan mereka bergantian memindahkan sejumlah batu positif dari tumpukan paling kiri yang tidak kosong ke tumpukan sebelah kanan. Pemain yang hanya bisa memindahkan batu di tumpukan terakhir kalah. Dengan asumsi kedua pemain menggunakan strategi terbaik, cari tahu siapa yang akan memenangkan permainan.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"\n*/\nconst char* gameWinner(int n, int piles[])", "ja": "#include <assert.h>\n#include <stdio.h>\n/*\nN個の石の山の列が1からNまで番号付けられており、それぞれの山には正の数の石が含まれています。チャーリーとダンがプレイするゲームの勝者を決定します。チャーリーが最初に行動し、彼らは交互に左端の空でない山から隣の右の山に正の数の石を移動します。最後の山でしか石を動かせないプレイヤーが負けます。両方のプレイヤーが最善の戦略を使用すると仮定して、誰がゲームに勝つかを見つけてください。\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"\n*/\nconst char* gameWinner(int n, int piles[])", "ko": "#include <assert.h>\n#include <stdio.h>\n/*\nN개의 돌무더기가 1부터 N까지 번호가 매겨져 있고, 각 무더기에는 양의 수의 돌이 들어 있습니다. Charlie와 Dan이 게임을 하는데, Charlie가 먼저 시작하고, 그들은 차례로 가장 왼쪽의 비어 있지 않은 무더기에서 인접한 오른쪽 무더기로 양의 수의 돌을 옮깁니다. 마지막 무더기에서만 돌을 옮길 수 있는 플레이어가 패배합니다. 두 플레이어가 모두 최선의 전략을 사용한다고 가정할 때, 누가 게임에서 이길지 알아내십시오.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"\n*/\nconst char* gameWinner(int n, int piles[])\n", "ml": "#include <assert.h>\n#include <stdio.h>\n/*\n1 മുതൽ N വരെ നമ്പർ ചെയ്ത N കൂമ്പാരങ്ങളിലായി കല്ലുകളുടെ ഒരു നിര നൽകിയിരിക്കുന്നു, ഓരോ കൂമ്പാരത്തിലും ഒരു പോസിറ്റീവ് എണ്ണം കല്ലുകൾ അടങ്ങിയിരിക്കുന്നു, ചാർളിയും ഡാനും കളിക്കുന്ന ഒരു കളിയുടെ വിജയിയെ നിർണ്ണയിക്കുക. ചാർളി ആദ്യം പോകുന്നു, അവർ ഇടതുവശത്തുള്ള ശൂന്യമല്ലാത്ത കൂമ്പാരത്തിൽ നിന്ന് സമീപമുള്ള വലതുവശത്തേക്ക് കല്ലുകൾ നീക്കുന്നു. അവസാന കൂമ്പാരത്തിൽ മാത്രമേ കല്ലുകൾ നീക്കാൻ കഴിയുന്ന കളിക്കാരൻ തോൽക്കും. ഇരുവരും മികച്ച തന്ത്രം ഉപയോഗിക്കുന്നുവെന്ന് കരുതുമ്പോൾ, ആരാണ് കളി ജയിക്കുക എന്ന് കണ്ടെത്തുക.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"\n*/\nconst char* gameWinner(int n, int piles[])", "fa": "#include <assert.h>\n#include <stdio.h>\n/*\nبا توجه به دنباله‌ای از N توده سنگ شماره‌گذاری شده از 1 تا N، که هر توده شامل تعداد مثبتی از سنگ‌ها است، برنده بازی انجام شده توسط چارلی و دن را تعیین کنید. چارلی اول می‌رود و آنها به نوبت تعداد مثبتی از سنگ‌ها را از توده غیرخالی سمت چپ به توده مجاور سمت راست منتقل می‌کنند. بازیکنی که فقط می‌تواند سنگ‌ها را در توده آخر حرکت دهد، می‌بازد. با فرض اینکه هر دو بازیکن از بهترین استراتژی ممکن استفاده می‌کنند، بفهمید چه کسی بازی را خواهد برد.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"\n*/\nconst char* gameWinner(int n, int piles[])\n"}, "canonical_solution": "{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}", "instruction": {"en": "const char* gameWinner(int n, int piles[])\n{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "sq": "const char* gameWinner(int n, int piles[])\n{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C në shqip duke përdorur maksimumi 500 karaktere.", "hy": "const char* gameWinner(int n, int piles[])\n{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}\n\nՏվեք C կոդի հակիրճ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "const char* gameWinner(int n, int piles[])\n{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}\n\nসি কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।", "bg": "const char* gameWinner(int n, int piles[])\n{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, използвайки не повече от 500 символа.", "zh": "const char* gameWinner(int n, int piles[])\n{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}\n\n请用最多500个字符的中文对该C代码提供简洁的自然语言描述（文档字符串）。", "fr": "const char* gameWinner(int n, int piles[])\n{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.", "de": "const char* gameWinner(int n, int piles[])\n{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen.", "ha": "const char* gameWinner(int n, int piles[])\n{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}\n\nBa da takaitaccen bayanin yanayi (docstring) na lambar C a cikin Hausa ta amfani da haruffa 500 ko ƙasa da haka.", "hi": "const char* gameWinner(int n, int piles[])\n{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}\n\nC कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।", "hu": "const char* gameWinner(int n, int piles[])\n{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben.", "es": "const char* gameWinner(int n, int piles[])\n{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando como máximo 500 caracteres.", "arb": "const char* gameWinner(int n, int piles[])\n{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "const char* gameWinner(int n, int piles[])\n{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "const char* gameWinner(int n, int piles[])\n{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}\n\nC kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama en fazla 500 karakter olmalıdır.", "vi": "const char* gameWinner(int n, int piles[])\n{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã C bằng tiếng Việt, sử dụng tối đa 500 ký tự.", "id": "const char* gameWinner(int n, int piles[])\n{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode C dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "const char* gameWinner(int n, int piles[])\n{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}\n\n以下のCコードの簡潔な自然言語による説明（ドキュメンテーション文字列）を、日本語で最大500文字以内で提供してください。", "ko": "const char* gameWinner(int n, int piles[])\n{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}\n\n다음 C 코드의 동작을 설명하는 간결한 자연어 설명(도크스트링)을 한국어로 작성하세요. 최대 500자까지 가능합니다.", "ml": "const char* gameWinner(int n, int piles[])\n{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}\n\nസിയിൽ നൽകിയിരിക്കുന്ന കോഡിന്റെ സംക്ഷിപ്തമായ സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) പരമാവധി 500 അക്ഷരങ്ങളിൽ മലയാളത്തിൽ നൽകുക.", "fa": "const char* gameWinner(int n, int piles[])\n{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}\n\nتوضیح مختصر و طبیعی (docstring) از کد C را به زبان فارسی با حداکثر ۵۰۰ کاراکتر ارائه دهید."}, "level": "", "test": "int main() {\n    int test1[] = {1, 2, 2};\n    int test2[] = {5, 5, 5, 5, 5};\n    int test3[] = {2, 1, 2};\n    int test4[] = {3, 3, 3, 3};\n    int test5[] = {1, 1};\n    int test6[] = {2, 1};\n    int test7[] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};\n    int test8[] = {2, 2, 2, 2, 2, 2, 2, 2, 2, 1};\n    int test9[] = {10, 10, 10, 10, 10, 10, 10, 10, 10, 10};\n    int test10[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n\n    assert(gameWinner(3, test1) == \"Dan\");\n    assert(gameWinner(5, test2) == \"Charlie\");\n    assert(gameWinner(3, test3) == \"Charlie\");\n    assert(gameWinner(4, test4) == \"Charlie\");\n    assert(gameWinner(2, test5) == \"Charlie\");\n    assert(gameWinner(2, test6) == \"Charlie\");\n    assert(gameWinner(11, test7) == \"Dan\");\n    assert(gameWinner(10, test8) == \"Charlie\");\n    assert(gameWinner(10, test9) == \"Charlie\");\n    assert(gameWinner(10, test10) == \"Dan\");\n\n    return 0;\n}", "entry_point": "gameWinner", "signature": "const char* gameWinner(int n, int piles[])", "docstring": {"en": "Given a sequence of N piles of stones numbered from 1 to N, with each pile containing a positive number of stones, determine the winner of a game played by Charlie and Dan. Charlie goes first, and they take turns moving a positive number of stones from the leftmost non-empty pile to the adjacent right pile. The player who can only move stones in the last pile loses. Assuming both players use the best possible strategy, find out who will win the game.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"\n", "sq": "Duke pasur një sekuencë prej N grumbuj gurësh të numëruar nga 1 deri në N, me secilin grumbull që përmban një numër pozitiv gurësh, përcaktoni fituesin e një loje të luajtur nga Charlie dhe Dan. Charlie fillon i pari, dhe ata marrin kthesa duke lëvizur një numër pozitiv gurësh nga grumbulli më i majtë jo bosh në grumbullin fqinj në të djathtë. Lojtari që mund të lëvizë gurë vetëm në grumbullin e fundit humbet. Duke supozuar se të dy lojtarët përdorin strategjinë më të mirë të mundshme, zbuloni se kush do të fitojë lojën.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"", "hy": "Տրված է N քարերի կույտերի հաջորդականություն, որոնք համարակալված են 1-ից N, և յուրաքանչյուր կույտ պարունակում է դրական քանակությամբ քարեր: Պարզել խաղի հաղթողին, որը խաղում են Չարլին և Դենը: Չարլին առաջինն է խաղում, և նրանք հերթով տեղափոխում են դրական քանակությամբ քարեր ձախից ամենաառաջին ոչ դատարկ կույտից դեպի հարակից աջ կույտ: Խաղացողը, ով կարող է միայն տեղափոխել քարերը վերջին կույտում, պարտվում է: Ենթադրելով, որ երկու խաղացողներն էլ օգտագործում են հնարավոր լավագույն ռազմավարությունը, պարզել, թե ով կհաղթի խաղը:\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"", "bn": "একটি N সংখ্যক পাথরের স্তূপের ক্রম দেওয়া হয়েছে, যেগুলি 1 থেকে N পর্যন্ত নম্বরযুক্ত, এবং প্রতিটি স্তূপে একটি ধনাত্মক সংখ্যক পাথর রয়েছে। চার্লি এবং ড্যান দ্বারা খেলা একটি গেমের বিজয়ী নির্ধারণ করুন। চার্লি প্রথমে যায়, এবং তারা পালাক্রমে বামদিকের প্রথম পূর্ণ স্তূপ থেকে ডানদিকে সংলগ্ন স্তূপে একটি ধনাত্মক সংখ্যক পাথর স্থানান্তর করে। যে খেলোয়াড় কেবলমাত্র শেষ স্তূপে পাথর স্থানান্তর করতে পারে, সে হেরে যায়। উভয় খেলোয়াড়ই সেরা সম্ভাব্য কৌশল ব্যবহার করে, খেলা কে জিতবে তা খুঁজে বের করুন।\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"", "bg": "Дадена е последователност от N купчини камъни, номерирани от 1 до N, като всяка купчина съдържа положителен брой камъни, определете победителя в игра, играна от Чарли и Дан. Чарли започва пръв и те се редуват да преместват положителен брой камъни от най-лявата непразна купчина към съседната дясна купчина. Играчът, който може да премести камъни само в последната купчина, губи. Приемайки, че и двамата играчи използват възможно най-добрата стратегия, разберете кой ще спечели играта.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"", "zh": "给定一个编号从1到N的石堆序列，每个石堆包含一个正数的石头，确定由Charlie和Dan进行的游戏的获胜者。Charlie先开始，他们轮流从最左边的非空石堆中移动一个正数的石头到相邻的右侧石堆。只能在最后一个石堆中移动石头的玩家输掉游戏。假设两位玩家都使用最佳策略，找出谁将赢得比赛。\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"", "fr": "Étant donné une séquence de N tas de pierres numérotés de 1 à N, chaque tas contenant un nombre positif de pierres, déterminez le gagnant d'un jeu joué par Charlie et Dan. Charlie commence, et ils jouent à tour de rôle en déplaçant un nombre positif de pierres du tas non vide le plus à gauche vers le tas adjacent à droite. Le joueur qui ne peut déplacer des pierres que dans le dernier tas perd. En supposant que les deux joueurs utilisent la meilleure stratégie possible, découvrez qui gagnera le jeu.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"", "de": "Angenommen, es gibt eine Sequenz von N Steinhaufen, die von 1 bis N nummeriert sind, wobei jeder Haufen eine positive Anzahl von Steinen enthält. Bestimmen Sie den Gewinner eines Spiels, das von Charlie und Dan gespielt wird. Charlie beginnt, und sie ziehen abwechselnd eine positive Anzahl von Steinen vom linken, nicht leeren Haufen zum benachbarten rechten Haufen. Der Spieler, der nur Steine im letzten Haufen bewegen kann, verliert. Angenommen, beide Spieler verwenden die bestmögliche Strategie, finden Sie heraus, wer das Spiel gewinnen wird.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"", "ha": "An ba da jerin N na tarin duwatsu da aka lamba daga 1 zuwa N, tare da kowanne tarin dauke da adadin duwatsu masu kyau, a tantance wanda zai ci wasa da Charlie da Dan suka yi. Charlie ne zai fara, kuma suna jujjuya motsa adadin duwatsu masu kyau daga tarin da ba komai a hagu zuwa tarin da ke makwabta a dama. Dan wasan da kawai zai iya motsa duwatsu a cikin tarin karshe zai rasa. Ana tsammanin duka 'yan wasan suna amfani da mafi kyawun dabaru, gano wanda zai ci wasan.\n\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"", "hi": "N पत्थरों के ढेरों के अनुक्रम को दिया गया है, जिन्हें 1 से N तक क्रमांकित किया गया है, जिसमें प्रत्येक ढेर में पत्थरों की एक सकारात्मक संख्या है। चार्ली और डैन द्वारा खेले गए एक खेल के विजेता का निर्धारण करें। चार्ली पहले जाता है, और वे बारी-बारी से बाईं ओर के सबसे पहले गैर-खाली ढेर से दाईं ओर के सटे हुए ढेर में पत्थरों की एक सकारात्मक संख्या को स्थानांतरित करते हैं। वह खिलाड़ी जो केवल अंतिम ढेर में पत्थरों को स्थानांतरित कर सकता है, हार जाता है। मान लें कि दोनों खिलाड़ी सर्वोत्तम संभव रणनीति का उपयोग करते हैं, यह पता करें कि खेल कौन जीतेगा।\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"", "hu": "Adott egy N kövekből álló halom sorozat, amelyeket 1-től N-ig számoztunk, és mindegyik halom pozitív számú követ tartalmaz. Határozd meg a Charlie és Dan által játszott játék győztesét. Charlie kezd, és felváltva mozgatnak egy pozitív számú követ a legbaloldalibb nem üres halomból a szomszédos jobb oldali halomba. Az a játékos veszít, aki csak az utolsó halomban tud köveket mozgatni. Feltételezve, hogy mindkét játékos a lehető legjobb stratégiát alkalmazza, derítsd ki, ki nyeri meg a játékot.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"", "es": "Dada una secuencia de N montones de piedras numerados del 1 al N, con cada montón conteniendo un número positivo de piedras, determina el ganador de un juego jugado por Charlie y Dan. Charlie va primero, y se turnan para mover un número positivo de piedras del montón no vacío más a la izquierda al montón adyacente a la derecha. El jugador que solo puede mover piedras en el último montón pierde. Suponiendo que ambos jugadores usan la mejor estrategia posible, averigua quién ganará el juego.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"", "arb": "بالنظر إلى تسلسل من N أكوام من الحجارة مرقمة من 1 إلى N، حيث تحتوي كل كومة على عدد موجب من الحجارة، حدد الفائز في لعبة يلعبها تشارلي ودان. يبدأ تشارلي أولاً، ويتناوبون في نقل عدد موجب من الحجارة من الكومة غير الفارغة الأكثر يسارًا إلى الكومة المجاورة على اليمين. اللاعب الذي يمكنه فقط نقل الحجارة في الكومة الأخيرة يخسر. بافتراض أن كلا اللاعبين يستخدمان أفضل استراتيجية ممكنة، اكتشف من سيفوز باللعبة.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"", "sw": "Kwa kuzingatia mlolongo wa marundo N ya mawe yaliyohesabiwa kutoka 1 hadi N, ambapo kila rundo lina idadi chanya ya mawe, bainisha mshindi wa mchezo unaochezwa na Charlie na Dan. Charlie huanza kwanza, na wanachukua zamu kuhamisha idadi chanya ya mawe kutoka kwenye rundo la kwanza lisilo tupu kwenda kwenye rundo la kulia lililo karibu. Mchezaji ambaye anaweza tu kuhamisha mawe kwenye rundo la mwisho anapoteza. Tukichukulia kwamba wachezaji wote wanatumia mkakati bora zaidi, tafuta ni nani atakayeshinda mchezo.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"", "tr": "Verilen 1'den N'ye kadar numaralandırılmış N taş yığını dizisinde, her yığın pozitif sayıda taş içerir, Charlie ve Dan tarafından oynanan bir oyunun kazananını belirleyin. Charlie ilk hamleyi yapar ve sırayla, soldaki en sol dolu yığından sağdaki bitişik yığına pozitif sayıda taş taşırlar. Sadece son yığındaki taşları hareket ettirebilen oyuncu kaybeder. Her iki oyuncunun da en iyi stratejiyi kullandığını varsayarak, oyunu kimin kazanacağını bulun.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"", "vi": "Cho một dãy N đống đá được đánh số từ 1 đến N, với mỗi đống chứa một số lượng đá dương, xác định người chiến thắng của trò chơi được chơi bởi Charlie và Dan. Charlie đi trước, và họ lần lượt di chuyển một số lượng đá dương từ đống không rỗng ngoài cùng bên trái sang đống liền kề bên phải. Người chơi chỉ có thể di chuyển đá trong đống cuối cùng sẽ thua. Giả sử cả hai người chơi đều sử dụng chiến lược tốt nhất có thể, hãy tìm ra ai sẽ thắng trò chơi.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"", "id": "Diberikan urutan N tumpukan batu bernomor dari 1 hingga N, dengan setiap tumpukan berisi sejumlah batu positif, tentukan pemenang dari permainan yang dimainkan oleh Charlie dan Dan. Charlie pergi lebih dulu, dan mereka bergiliran memindahkan sejumlah batu positif dari tumpukan paling kiri yang tidak kosong ke tumpukan kanan yang berdekatan. Pemain yang hanya dapat memindahkan batu di tumpukan terakhir kalah. Dengan asumsi kedua pemain menggunakan strategi terbaik yang mungkin, cari tahu siapa yang akan memenangkan permainan.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"", "ja": "石の山が1からNまで番号付けされたN個の山が与えられ、それぞれの山には正の数の石が含まれています。チャーリーとダンがプレイするゲームの勝者を決定します。チャーリーが最初に行動し、彼らは交互に左端の空でない山から隣接する右の山に正の数の石を移動させます。最後の山でしか石を移動できないプレイヤーが負けます。両方のプレイヤーが最善の戦略を使用すると仮定して、誰がゲームに勝つかを見つけてください。\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"", "ko": "돌무더기 N개의 시퀀스가 1부터 N까지 번호가 매겨져 있으며, 각 무더기에는 양의 개수의 돌이 들어 있습니다. Charlie와 Dan이 하는 게임의 승자를 결정하십시오. Charlie가 먼저 시작하며, 그들은 차례로 가장 왼쪽의 비어 있지 않은 무더기에서 인접한 오른쪽 무더기로 양의 개수의 돌을 옮깁니다. 마지막 무더기에서만 돌을 옮길 수 있는 플레이어가 패배합니다. 두 플레이어 모두 최상의 전략을 사용한다고 가정할 때, 누가 게임에서 이길지 알아보십시오.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"", "ml": "ഒരു മുതൽ N വരെ നമ്പർ ചെയ്ത N കൂമ്പാരങ്ങളിലായി കല്ലുകൾ ഉള്ള ഒരു നിര നൽകിയിരിക്കുന്നു, ഓരോ കൂമ്പാരത്തിലും കല്ലുകൾ പോസിറ്റീവ് സംഖ്യയിലുണ്ട്. ചാർളിയും ഡാനും കളിക്കുന്ന ഒരു കളിയുടെ വിജയിയെ നിർണ്ണയിക്കുക. ചാർളി ആദ്യം പോകുന്നു, അവർ മാറിമാറി ഇടത് വശത്തുള്ള ശൂന്യമല്ലാത്ത കൂമ്പാരത്തിൽ നിന്ന് സമീപമുള്ള വലത് കൂമ്പാരത്തിലേക്ക് പോസിറ്റീവ് സംഖ്യയിലുള്ള കല്ലുകൾ നീക്കുന്നു. അവസാന കൂമ്പാരത്തിൽ മാത്രം കല്ലുകൾ നീക്കാൻ കഴിയുന്ന കളിക്കാരൻ തോൽക്കും. ഇരുവരും ഏറ്റവും മികച്ച തന്ത്രം ഉപയോഗിക്കുന്നതായി കരുതുമ്പോൾ, ആരാണ് കളിയിൽ ജയിക്കുക എന്ന് കണ്ടെത്തുക.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"", "fa": "با توجه به دنباله‌ای از N توده سنگ شماره‌گذاری شده از 1 تا N، که هر توده حاوی تعداد مثبتی از سنگ‌هاست، برنده بازی که توسط چارلی و دن بازی می‌شود را تعیین کنید. چارلی اول حرکت می‌کند و آن‌ها به نوبت تعداد مثبتی از سنگ‌ها را از توده غیرخالی سمت چپ به توده مجاور سمت راست منتقل می‌کنند. بازیکنی که تنها می‌تواند سنگ‌ها را در توده آخر حرکت دهد، بازنده است. با فرض اینکه هر دو بازیکن از بهترین استراتژی ممکن استفاده می‌کنند، مشخص کنید چه کسی برنده بازی خواهد شد.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\""}}
{"task_id": "C/36", "prompt": {"en": "#include <assert.h>\n#include <stdio.h>\n/*\nGiven n doors arranged in a circle, the player starts in front of door 1. Each turn, the player can choose a number i and pay a cost C_i to move i steps to the right and then open the door at that position. It is guaranteed that C_i >= C_{i+1} for 1 <= i < n.\nThe task is to determine the minimum total cost required to open all doors.\n\nExample:\n    >>> minTotalCost(3, (1, 1, 1))\n    3\n*/\nlong long minTotalCost(int n, int *C)", "sq": "#include <assert.h>\n#include <stdio.h>\n/*\nDuke pasur parasysh n dyer të rregulluara në një rreth, lojtari fillon përballë derës 1. Çdo radhë, lojtari mund të zgjedhë një numër i dhe të paguajë një kosto C_i për të lëvizur i hapa djathtas dhe pastaj të hapë derën në atë pozicion. Është e garantuar që C_i >= C_{i+1} për 1 <= i < n.\nDetyra është të përcaktohet kostoja totale minimale e kërkuar për të hapur të gjitha dyert.\n\nShembull:\n    >>> minTotalCost(3, (1, 1, 1))\n    3\n*/\nlong long minTotalCost(int n, int *C)", "hy": "#include <assert.h>\n#include <stdio.h>\n/*\nՏրված է n դռներ, որոնք դասավորված են շրջանի մեջ, խաղացողը սկսում է դուռ 1-ի դիմաց: Յուրաքանչյուր քայլում խաղացողը կարող է ընտրել թիվ i և վճարել C_i արժեքը՝ i քայլ աջ շարժվելու և այդ դիրքում դուռը բացելու համար: Երաշխավորված է, որ C_i >= C_{i+1} 1 <= i < n-ի համար:\nԽնդիրը կայանում է որոշելու բոլոր դռները բացելու համար պահանջվող նվազագույն ընդհանուր արժեքը:\n\nՕրինակ:\n    >>> minTotalCost(3, (1, 1, 1))\n    3\n*/\nlong long minTotalCost(int n, int *C)", "bn": "#include <assert.h>\n#include <stdio.h>\n/*\nnটি দরজা একটি বৃত্তে সাজানো আছে, খেলোয়াড় দরজা 1 এর সামনে শুরু করে। প্রতিটি পালায়, খেলোয়াড় একটি সংখ্যা i বেছে নিতে পারে এবং i ধাপ ডানে সরতে এবং তারপর সেই অবস্থানের দরজা খুলতে C_i খরচ দিতে হয়। এটি নিশ্চিত যে C_i >= C_{i+1} যেখানে 1 <= i < n।\nসমস্ত দরজা খুলতে প্রয়োজনীয় সর্বনিম্ন মোট খরচ নির্ধারণ করার কাজ।\n\nউদাহরণ:\n    >>> minTotalCost(3, (1, 1, 1))\n    3\n*/\nlong long minTotalCost(int n, int *C)", "bg": "#include <assert.h>\n#include <stdio.h>\n/*\nДадени са n врати, подредени в кръг, играчът започва пред врата 1. Всеки ход играчът може да избере число i и да плати цена C_i, за да се премести i стъпки надясно и след това да отвори вратата на тази позиция. Гарантирано е, че C_i >= C_{i+1} за 1 <= i < n.\nЗадачата е да се определи минималната обща цена, необходима за отваряне на всички врати.\n\nПример:\n    >>> minTotalCost(3, (1, 1, 1))\n    3\n*/\nlong long minTotalCost(int n, int *C)", "zh": "#include <assert.h>\n#include <stdio.h>\n/*\n给定 n 扇门排列成一个圆圈，玩家从门1前面开始。每一回合，玩家可以选择一个数字 i 并支付一个代价 C_i 向右移动 i 步，然后打开当前位置的门。保证 C_i >= C_{i+1} 对于 1 <= i < n。\n任务是确定打开所有门所需的最小总成本。\n\n示例:\n    >>> minTotalCost(3, (1, 1, 1))\n    3\n*/\nlong long minTotalCost(int n, int *C)", "fr": "#include <assert.h>\n#include <stdio.h>\n/*\nÉtant donné n portes disposées en cercle, le joueur commence devant la porte 1. À chaque tour, le joueur peut choisir un nombre i et payer un coût C_i pour avancer de i pas vers la droite puis ouvrir la porte à cette position. Il est garanti que C_i >= C_{i+1} pour 1 <= i < n.\nLa tâche consiste à déterminer le coût total minimum requis pour ouvrir toutes les portes.\n\nExemple:\n    >>> minTotalCost(3, (1, 1, 1))\n    3\n*/\nlong long minTotalCost(int n, int *C)", "de": "#include <assert.h>\n#include <stdio.h>\n/*\nGegeben sind n Türen, die in einem Kreis angeordnet sind. Der Spieler beginnt vor Tür 1. In jedem Zug kann der Spieler eine Zahl i wählen und die Kosten C_i zahlen, um i Schritte nach rechts zu gehen und dann die Tür an dieser Position zu öffnen. Es ist garantiert, dass C_i >= C_{i+1} für 1 <= i < n.\nDie Aufgabe besteht darin, die minimalen Gesamtkosten zu bestimmen, die erforderlich sind, um alle Türen zu öffnen.\n\nBeispiel:\n    >>> minTotalCost(3, (1, 1, 1))\n    3\n*/\nlong long minTotalCost(int n, int *C)", "ha": "#include <assert.h>\n#include <stdio.h>\n/*\nAn ba da ƙofofi n da aka shirya a cikin da'ira, ɗan wasa yana farawa a gaban ƙofa ta 1. Kowace juyawa, ɗan wasan na iya zaɓar lamba i kuma ya biya farashi C_i don matsawa matakai i zuwa dama sannan ya buɗe ƙofar a wannan matsayi. An tabbatar da cewa C_i >= C_{i+1} don 1 <= i < n.\nAikin shine a tantance mafi ƙarancin jimlar kuɗi da ake buƙata don buɗe duk ƙofofin.\n\nMisali:\n    >>> minTotalCost(3, (1, 1, 1))\n    3\n*/\nlong long minTotalCost(int n, int *C)", "hi": "#include <assert.h>\n#include <stdio.h>\n/*\nदिए गए n दरवाजे एक वृत्त में व्यवस्थित हैं, खिलाड़ी दरवाजा 1 के सामने से शुरू करता है। प्रत्येक चाल में, खिलाड़ी एक संख्या i चुन सकता है और i कदम दाईं ओर जाने के लिए एक लागत C_i का भुगतान कर सकता है और फिर उस स्थिति पर दरवाजा खोल सकता है। यह गारंटी है कि C_i >= C_{i+1} के लिए 1 <= i < n।\nकार्य यह निर्धारित करना है कि सभी दरवाजे खोलने के लिए न्यूनतम कुल लागत कितनी होगी।\n\nउदाहरण:\n    >>> minTotalCost(3, (1, 1, 1))\n    3\n*/\nlong long minTotalCost(int n, int *C)", "hu": "#include <assert.h>\n#include <stdio.h>\n/*\nAdott n ajtó, amelyek körben vannak elrendezve, a játékos az 1-es ajtó előtt kezd. Minden körben a játékos választhat egy számot i, és fizet egy C_i költséget, hogy i lépést tegyen jobbra, majd kinyissa az ajtót azon a helyen. Garantált, hogy C_i >= C_{i+1} minden 1 <= i < n esetén.\nA feladat meghatározni a minimális összköltséget, amely szükséges az összes ajtó kinyitásához.\n\nPélda:\n    >>> minTotalCost(3, (1, 1, 1))\n    3\n*/\nlong long minTotalCost(int n, int *C)", "es": "#include <assert.h>\n#include <stdio.h>\n/*\nDado n puertas dispuestas en un círculo, el jugador comienza frente a la puerta 1. En cada turno, el jugador puede elegir un número i y pagar un costo C_i para moverse i pasos a la derecha y luego abrir la puerta en esa posición. Se garantiza que C_i >= C_{i+1} para 1 <= i < n.\nLa tarea es determinar el costo total mínimo requerido para abrir todas las puertas.\n\nEjemplo:\n    >>> minTotalCost(3, (1, 1, 1))\n    3\n*/\nlong long minTotalCost(int n, int *C)", "arb": "#include <assert.h>\n#include <stdio.h>\n/*\nمعطى n من الأبواب مرتبة في دائرة، يبدأ اللاعب أمام الباب 1. في كل دور، يمكن للاعب اختيار رقم i ودفع تكلفة C_i للتحرك i خطوات إلى اليمين ثم فتح الباب في ذلك الموقع. من المضمون أن C_i >= C_{i+1} لكل 1 <= i < n.\nالمهمة هي تحديد الحد الأدنى من التكلفة الإجمالية المطلوبة لفتح جميع الأبواب.\n\nمثال:\n    >>> minTotalCost(3, (1, 1, 1))\n    3\n*/\nlong long minTotalCost(int n, int *C)", "sw": "#include <assert.h>\n#include <stdio.h>\n/*\nUkipiwa milango n iliyopangwa kwa mduara, mchezaji anaanza mbele ya mlango wa 1. Kila zamu, mchezaji anaweza kuchagua nambari i na kulipa gharama C_i ili kusonga hatua i kwenda kulia na kisha kufungua mlango katika nafasi hiyo. Imethibitishwa kuwa C_i >= C_{i+1} kwa 1 <= i < n.\nKazi ni kuamua gharama ndogo kabisa inayohitajika kufungua milango yote.\n\nMfano:\n    >>> minTotalCost(3, (1, 1, 1))\n    3\n*/\nlong long minTotalCost(int n, int *C)", "tr": "#include <assert.h>\n#include <stdio.h>\n/*\nBir daire şeklinde düzenlenmiş n kapı verildiğinde, oyuncu 1 numaralı kapının önünde başlar. Her turda, oyuncu bir sayı i seçebilir ve i adım sağa hareket etmek için bir maliyet C_i ödeyebilir ve ardından o konumdaki kapıyı açabilir. C_i >= C_{i+1} olduğu garanti edilir, burada 1 <= i < n.\nGörev, tüm kapıları açmak için gereken minimum toplam maliyeti belirlemektir.\n\nÖrnek:\n    >>> minTotalCost(3, (1, 1, 1))\n    3\n*/\nlong long minTotalCost(int n, int *C)", "vi": "#include <assert.h>\n#include <stdio.h>\n/*\nCho n cánh cửa được sắp xếp thành một vòng tròn, người chơi bắt đầu trước cửa số 1. Mỗi lượt, người chơi có thể chọn một số i và trả một chi phí C_i để di chuyển i bước sang phải và sau đó mở cánh cửa tại vị trí đó. Đảm bảo rằng C_i >= C_{i+1} cho 1 <= i < n.\nNhiệm vụ là xác định tổng chi phí tối thiểu cần thiết để mở tất cả các cửa.\n\nVí dụ:\n    >>> minTotalCost(3, (1, 1, 1))\n    3\n*/\nlong long minTotalCost(int n, int *C)", "id": "#include <assert.h>\n#include <stdio.h>\n/*\nDiberikan n pintu yang diatur dalam lingkaran, pemain mulai di depan pintu 1. Setiap giliran, pemain dapat memilih angka i dan membayar biaya C_i untuk bergerak i langkah ke kanan dan kemudian membuka pintu di posisi tersebut. Dijamin bahwa C_i >= C_{i+1} untuk 1 <= i < n.\nTugasnya adalah menentukan total biaya minimum yang diperlukan untuk membuka semua pintu.\n\nContoh:\n    >>> minTotalCost(3, (1, 1, 1))\n    3\n*/\nlong long minTotalCost(int n, int *C)", "ja": "#include <assert.h>\n#include <stdio.h>\n/*\nn 個のドアが円形に配置されているとき、プレイヤーはドア 1 の前に立っています。各ターンで、プレイヤーは数 i を選び、コスト C_i を支払って右に i ステップ移動し、その位置のドアを開けることができます。1 <= i < n の場合、C_i >= C_{i+1} が保証されています。\nすべてのドアを開けるために必要な最小の総コストを求めるタスクです。\n\n例:\n    >>> minTotalCost(3, (1, 1, 1))\n    3\n*/\nlong long minTotalCost(int n, int *C)", "ko": "#include <assert.h>\n#include <stdio.h>\n/*\nn개의 문이 원형으로 배열되어 있을 때, 플레이어는 문 1 앞에서 시작합니다. 각 턴마다, 플레이어는 숫자 i를 선택하고 비용 C_i를 지불하여 오른쪽으로 i 걸음 이동한 후 해당 위치의 문을 엽니다. C_i >= C_{i+1}이 1 <= i < n에 대해 보장됩니다.\n모든 문을 여는 데 필요한 최소 총 비용을 결정하는 것이 과제입니다.\n\n예시:\n    >>> minTotalCost(3, (1, 1, 1))\n    3\n*/\nlong long minTotalCost(int n, int *C)", "ml": "#include <assert.h>\n#include <stdio.h>\n/*\nവൃത്താകൃതിയിൽ ക്രമീകരിച്ച n വാതിലുകൾ നൽകിയിരിക്കുന്നു, കളിക്കാരൻ വാതിൽ 1-ന്റെ മുൻപിൽ നിന്ന് ആരംഭിക്കുന്നു. ഓരോ തവണയും, കളിക്കാരൻ ഒരു സംഖ്യ i തിരഞ്ഞെടുക്കുകയും i ഘട്ടങ്ങൾ വലത്തേക്ക് നീങ്ങി ആ സ്ഥാനത്തെ വാതിൽ തുറക്കാൻ C_i ചെലവ് നൽകുകയും ചെയ്യാം. 1 <= i < n എന്നതിനായി C_i >= C_{i+1} എന്ന് ഉറപ്പാക്കുന്നു.\nഎല്ലാ വാതിലുകളും തുറക്കാൻ ആവശ്യമായ കുറഞ്ഞ മൊത്തം ചെലവ് നിർണയിക്കാനുള്ളതാണ് ഈ പ്രവർത്തനം.\n\nഉദാഹരണം:\n    >>> minTotalCost(3, (1, 1, 1))\n    3\n*/\nlong long minTotalCost(int n, int *C)", "fa": "#include <assert.h>\n#include <stdio.h>\n/*\nبا توجه به n در که به صورت دایره‌ای چیده شده‌اند، بازیکن در مقابل در شماره 1 شروع می‌کند. در هر نوبت، بازیکن می‌تواند یک عدد i انتخاب کند و هزینه C_i را بپردازد تا i گام به سمت راست حرکت کند و سپس در را در آن موقعیت باز کند. تضمین شده است که C_i >= C_{i+1} برای 1 <= i < n.\nوظیفه این است که حداقل هزینه کل مورد نیاز برای باز کردن همه درها را تعیین کنید.\n\nمثال:\n    >>> minTotalCost(3, (1, 1, 1))\n    3\n*/\nlong long minTotalCost(int n, int *C)"}, "canonical_solution": "{\n   return (long long)(C[n-2]) * (n - 1) + C[n-1];\n}", "instruction": {"en": "long long minTotalCost(int n, int *C)\n{\n   return (long long)(C[n-2]) * (n - 1) + C[n-1];\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "sq": "long long minTotalCost(int n, int *C)\n{\n   return (long long)(C[n-2]) * (n - 1) + C[n-1];\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C në shqip duke përdorur maksimumi 500 karaktere.", "hy": "long long minTotalCost(int n, int *C)\n{\n   return (long long)(C[n-2]) * (n - 1) + C[n-1];\n}\n\nՏվեք C կոդի համառոտ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։", "bn": "long long minTotalCost(int n, int *C)\n{\n   return (long long)(C[n-2]) * (n - 1) + C[n-1];\n}\n\nসি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।", "bg": "long long minTotalCost(int n, int *C)\n{\n   return (long long)(C[n-2]) * (n - 1) + C[n-1];\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, използвайки най-много 500 знака.", "zh": "long long minTotalCost(int n, int *C)\n{\n   return (long long)(C[n-2]) * (n - 1) + C[n-1];\n}\n\n请用最多500个字符的中文对该C代码提供简洁的自然语言描述（文档字符串）。", "fr": "long long minTotalCost(int n, int *C)\n{\n   return (long long)(C[n-2]) * (n - 1) + C[n-1];\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.", "de": "long long minTotalCost(int n, int *C)\n{\n   return (long long)(C[n-2]) * (n - 1) + C[n-1];\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen.", "ha": "long long minTotalCost(int n, int *C)\n{\n   return (long long)(C[n-2]) * (n - 1) + C[n-1];\n}\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar C a cikin Hausa ta amfani da haruffa 500 kacal.", "hi": "long long minTotalCost(int n, int *C)\n{\n   return (long long)(C[n-2]) * (n - 1) + C[n-1];\n}\n\nC कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "long long minTotalCost(int n, int *C)\n{\n   return (long long)(C[n-2]) * (n - 1) + C[n-1];\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben.", "es": "long long minTotalCost(int n, int *C)\n{\n   return (long long)(C[n-2]) * (n - 1) + C[n-1];\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando como máximo 500 caracteres.", "arb": "long long minTotalCost(int n, int *C)\n{\n   return (long long)(C[n-2]) * (n - 1) + C[n-1];\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "long long minTotalCost(int n, int *C)\n{\n   return (long long)(C[n-2]) * (n - 1) + C[n-1];\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "long long minTotalCost(int n, int *C)\n{\n   return (long long)(C[n-2]) * (n - 1) + C[n-1];\n}\n\nC kodunun işlevini açıklayan kısa bir doğal dil tanımı (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe olarak yazılmalıdır.", "vi": "long long minTotalCost(int n, int *C)\n{\n   return (long long)(C[n-2]) * (n - 1) + C[n-1];\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã C bằng tiếng Việt với tối đa 500 ký tự.", "id": "long long minTotalCost(int n, int *C)\n{\n   return (long long)(C[n-2]) * (n - 1) + C[n-1];\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode C dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "long long minTotalCost(int n, int *C)\n{\n   return (long long)(C[n-2]) * (n - 1) + C[n-1];\n}\n\nC コードの簡単な自然言語による説明 (docstring) を英語で最大 500 文字まで入力してください。", "ko": "long long minTotalCost(int n, int *C)\n{\n   return (long long)(C[n-2]) * (n - 1) + C[n-1];\n}\n\nC 코드의 동작을 설명하는 간결한 자연어 설명(docstring)을 한국어로 작성하세요. 최대 500자 이내로 작성해야 합니다.", "ml": "long long minTotalCost(int n, int *C)\n{\n   return (long long)(C[n-2]) * (n - 1) + C[n-1];\n}\n\nC കോഡിന്റെ സംഗ്രഹമായ സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) മലയാളത്തിൽ 500 അക്ഷരങ്ങൾക്കുള്ളിൽ നൽകുക.", "fa": "long long minTotalCost(int n, int *C)\n{\n   return (long long)(C[n-2]) * (n - 1) + C[n-1];\n}\n\nتوضیح مختصر و طبیعی (docstring) از کد C را به زبان فارسی با حداکثر ۵۰۰ کاراکتر ارائه دهید."}, "level": "", "test": "int main() {\n    int costs1[] = {4, 3, 3, 3, 3}; // 1-indexed array\n    assert(minTotalCost(5, costs1) == 15);\n\n    int costs2[] = {1, 1, 1};\n    assert(minTotalCost(3, costs2) == 3);\n\n    int costs3[] = {5, 4, 3, 2};\n    assert(minTotalCost(4, costs3) == 11);\n\n    int costs4[] = {100, 99, 98, 97};\n    assert(minTotalCost(4, costs4) == 391);\n\n    int costs5[] = {10, 9, 8, 7, 6, 5};\n    assert(minTotalCost(6, costs5) == 35);\n\n    int costs6[] = {2, 2, 2, 2, 2, 2, 2};\n    assert(minTotalCost(7, costs6) == 14);\n\n    int costs7[] = {9, 7, 7, 7, 7, 7, 7, 7};\n    assert(minTotalCost(8, costs7) == 56);\n\n    int costs8[] = {3, 2, 2, 2, 2, 2, 2, 2, 2};\n    assert(minTotalCost(9, costs8) == 18);\n\n    int costs9[] = {6, 5, 5, 5, 5, 5, 5, 5, 5, 5};\n    assert(minTotalCost(10, costs9) == 50);\n\n    int costs10[] = {8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};\n    assert(minTotalCost(11, costs10) == 11);\n\n    return 0;\n}", "entry_point": "minTotalCost", "signature": "long long minTotalCost(int n, int *C)", "docstring": {"en": "Given n doors arranged in a circle, the player starts in front of door 1. Each turn, the player can choose a number i and pay a cost C_i to move i steps to the right and then open the door at that position. It is guaranteed that C_i >= C_{i+1} for 1 <= i < n.\nThe task is to determine the minimum total cost required to open all doors.\n\nExample:\n    >>> minTotalCost(3, (1, 1, 1))\n    3\n", "sq": "Duke pasur n dyer të rregulluara në një rreth, lojtari fillon përballë derës 1. Çdo radhë, lojtari mund të zgjedhë një numër i dhe të paguajë një kosto C_i për të lëvizur i hapa djathtas dhe pastaj të hapë derën në atë pozicion. Është e garantuar që C_i >= C_{i+1} për 1 <= i < n.\nDetyra është të përcaktohet kostoja totale minimale e kërkuar për të hapur të gjitha dyert.\n\nShembull:\n    >>> minTotalCost(3, (1, 1, 1))\n    3", "hy": "Տրված են n դռներ, որոնք դասավորված են շրջանաձև, խաղացողը սկսում է դուռ 1-ի դիմաց: Յուրաքանչյուր քայլի ժամանակ խաղացողը կարող է ընտրել թիվ i և վճարել C_i արժեքը՝ i քայլ աջ շարժվելու և այն դիրքի դուռը բացելու համար: Երաշխավորված է, որ C_i >= C_{i+1} 1 <= i < n-ի համար:\nԽնդիրը կայանում է որոշել բոլոր դռները բացելու համար անհրաժեշտ նվազագույն ընդհանուր արժեքը:\n\nՕրինակ:\n    >>> minTotalCost(3, (1, 1, 1))\n    3", "bn": "nটি দরজা একটি বৃত্তে সাজানো আছে, খেলোয়াড় দরজা 1-এর সামনে থেকে শুরু করে। প্রতিটি পালায়, খেলোয়াড় একটি সংখ্যা i বেছে নিতে পারে এবং i ধাপ ডানদিকে যেতে C_i খরচ দিতে পারে এবং তারপর সেই অবস্থানের দরজা খুলতে পারে। এটি নিশ্চিত করা হয়েছে যে C_i >= C_{i+1} যেখানে 1 <= i < n। কাজটি হল সমস্ত দরজা খুলতে প্রয়োজনীয় সর্বনিম্ন মোট খরচ নির্ধারণ করা।\n\nউদাহরণ:\n    >>> minTotalCost(3, (1, 1, 1))\n    3", "bg": "Дадени са n врати, подредени в кръг, играчът започва пред врата 1. Всеки ход играчът може да избере число i и да плати цена C_i, за да се премести i стъпки надясно и след това да отвори вратата на тази позиция. Гарантирано е, че C_i >= C_{i+1} за 1 <= i < n. Задачата е да се определи минималната обща цена, необходима за отваряне на всички врати.\n\nПример:\n    >>> minTotalCost(3, (1, 1, 1))\n    3", "zh": "给定 n 个门按圆形排列，玩家从门 1 前开始。每一回合，玩家可以选择一个数字 i 并支付一个费用 C_i 向右移动 i 步，然后打开当前位置的门。保证 C_i >= C_{i+1} 对于 1 <= i < n。\n任务是确定打开所有门所需的最小总费用。\n\n示例：\n    >>> minTotalCost(3, (1, 1, 1))\n    3", "fr": "Étant donné n portes disposées en cercle, le joueur commence devant la porte 1. À chaque tour, le joueur peut choisir un nombre i et payer un coût C_i pour avancer de i pas vers la droite, puis ouvrir la porte à cette position. Il est garanti que C_i >= C_{i+1} pour 1 <= i < n.  \nLa tâche consiste à déterminer le coût total minimum nécessaire pour ouvrir toutes les portes.\n\nExemple :\n    >>> minTotalCost(3, (1, 1, 1))\n    3", "de": "Gegeben n Türen, die in einem Kreis angeordnet sind, beginnt der Spieler vor Tür 1. In jedem Zug kann der Spieler eine Zahl i wählen und einen Kosten C_i zahlen, um i Schritte nach rechts zu gehen und dann die Tür an dieser Position zu öffnen. Es ist garantiert, dass C_i >= C_{i+1} für 1 <= i < n.\nDie Aufgabe besteht darin, die minimalen Gesamtkosten zu bestimmen, die erforderlich sind, um alle Türen zu öffnen.\n\nBeispiel:\n    >>> minTotalCost(3, (1, 1, 1))\n    3", "ha": "An ba ƙofofi n da aka shirya a cikin da'ira, ɗan wasa yana farawa a gaban ƙofa ta 1. Kowace juyawa, ɗan wasa na iya zaɓar lamba i kuma ya biya kuɗi C_i don matsawa matakai i zuwa dama sannan ya buɗe ƙofar a wancan matsayi. Ana tabbatar da cewa C_i >= C_{i+1} don 1 <= i < n. Aikin shi ne a tantance mafi ƙarancin jimillar kuɗin da ake buƙata don buɗe duk ƙofofi.\n\nMisali:\n    >>> minTotalCost(3, (1, 1, 1))\n    3", "hi": "n दरवाजों को एक वृत्त में व्यवस्थित किया गया है, खिलाड़ी दरवाजा 1 के सामने से शुरू करता है। प्रत्येक चाल में, खिलाड़ी एक संख्या i चुन सकता है और i कदम दाईं ओर जाने के लिए एक लागत C_i का भुगतान कर सकता है और फिर उस स्थिति पर दरवाजा खोल सकता है। यह गारंटी है कि C_i >= C_{i+1} जहाँ 1 <= i < n। कार्य यह निर्धारित करना है कि सभी दरवाजे खोलने के लिए न्यूनतम कुल लागत क्या होगी।\n\nउदाहरण:\n    >>> minTotalCost(3, (1, 1, 1))\n    3", "hu": "Adott n ajtó, amelyek körben vannak elrendezve, a játékos az 1. ajtó előtt kezd. Minden körben a játékos választhat egy számot i, és fizet egy C_i költséget, hogy i lépést jobbra lépjen, majd kinyissa az ajtót az adott pozíción. Garantált, hogy C_i >= C_{i+1} minden 1 <= i < n esetén.\nA feladat az, hogy meghatározzuk a minimális összköltséget, amely szükséges az összes ajtó kinyitásához.\n\nPélda:\n    >>> minTotalCost(3, (1, 1, 1))\n    3", "es": "Dadas n puertas dispuestas en un círculo, el jugador comienza frente a la puerta 1. En cada turno, el jugador puede elegir un número i y pagar un costo C_i para moverse i pasos a la derecha y luego abrir la puerta en esa posición. Se garantiza que C_i >= C_{i+1} para 1 <= i < n. La tarea es determinar el costo total mínimo requerido para abrir todas las puertas.\n\nEjemplo:\n    >>> minTotalCost(3, (1, 1, 1))\n    3", "arb": "معطى n أبواب مرتبة في دائرة، يبدأ اللاعب أمام الباب 1. في كل دور، يمكن للاعب اختيار رقم i ودفع تكلفة C_i للتحرك i خطوات إلى اليمين ثم فتح الباب في ذلك الموقع. من المضمون أن C_i >= C_{i+1} لـ 1 <= i < n. المهمة هي تحديد الحد الأدنى للتكلفة الإجمالية المطلوبة لفتح جميع الأبواب.\n\nمثال:\n    >>> minTotalCost(3, (1, 1, 1))\n    3", "sw": "Kwa milango n iliyopangwa katika mduara, mchezaji anaanza mbele ya mlango wa 1. Kila zamu, mchezaji anaweza kuchagua namba i na kulipa gharama C_i ili kusonga hatua i kwenda kulia na kisha kufungua mlango katika nafasi hiyo. Inahakikishwa kuwa C_i >= C_{i+1} kwa 1 <= i < n. \nKazi ni kubaini gharama ndogo kabisa inayohitajika kufungua milango yote.\n\nMfano:\n    >>> minTotalCost(3, (1, 1, 1))\n    3", "tr": "Verilen n kapı bir daire şeklinde düzenlenmiştir, oyuncu 1 numaralı kapının önünde başlar. Her turda, oyuncu bir sayı i seçebilir ve i adım sağa hareket etmek ve ardından o konumdaki kapıyı açmak için bir maliyet C_i öder. C_i >= C_{i+1} olduğu garanti edilmektedir, burada 1 <= i < n.\nGörev, tüm kapıları açmak için gereken minimum toplam maliyeti belirlemektir.\n\nÖrnek:\n    >>> minTotalCost(3, (1, 1, 1))\n    3", "vi": "Cho n cánh cửa được sắp xếp thành vòng tròn, người chơi bắt đầu trước cửa số 1. Mỗi lượt, người chơi có thể chọn một số i và trả một chi phí C_i để di chuyển i bước sang phải và sau đó mở cánh cửa tại vị trí đó. Đảm bảo rằng C_i >= C_{i+1} cho 1 <= i < n. Nhiệm vụ là xác định tổng chi phí tối thiểu cần thiết để mở tất cả các cánh cửa.\n\nVí dụ:\n    >>> minTotalCost(3, (1, 1, 1))\n    3", "id": "Diberikan n pintu yang diatur dalam lingkaran, pemain mulai di depan pintu 1. Setiap giliran, pemain dapat memilih angka i dan membayar biaya C_i untuk bergerak i langkah ke kanan dan kemudian membuka pintu pada posisi tersebut. Dijamin bahwa C_i >= C_{i+1} untuk 1 <= i < n. Tugasnya adalah menentukan total biaya minimum yang diperlukan untuk membuka semua pintu.\n\nContoh:\n    >>> minTotalCost(3, (1, 1, 1))\n    3", "ja": "与えられた n 個のドアが円形に配置されており、プレイヤーはドア 1 の前に立っています。各ターンで、プレイヤーは数 i を選び、コスト C_i を支払って右に i ステップ移動し、その位置のドアを開けることができます。C_i >= C_{i+1} が 1 <= i < n の範囲で保証されています。\nタスクは、すべてのドアを開けるために必要な最小の総コストを求めることです。\n\n例:\n    >>> minTotalCost(3, (1, 1, 1))\n    3", "ko": "n개의 문이 원형으로 배열되어 있을 때, 플레이어는 문 1 앞에서 시작합니다. 각 턴마다 플레이어는 숫자 i를 선택하고 비용 C_i를 지불하여 오른쪽으로 i단계 이동한 다음 해당 위치의 문을 엽니다. C_i >= C_{i+1}이 1 <= i < n에 대해 보장됩니다.  \n모든 문을 여는 데 필요한 최소 총 비용을 결정하는 것이 과제입니다.\n\n예시:\n    >>> minTotalCost(3, (1, 1, 1))\n    3", "ml": "n വാതിലുകൾ ഒരു വൃത്തത്തിൽ ക്രമീകരിച്ചിരിക്കുന്നപ്പോൾ, കളിക്കാരൻ വാതിൽ 1-ന്റെ മുന്നിൽ നിന്ന് ആരംഭിക്കുന്നു. ഓരോ തവണയും, കളിക്കാരൻ ഒരു സംഖ്യ i തിരഞ്ഞെടുക്കുകയും i വലത്തേക്ക് ചുവടുകൾ നീക്കാൻ ചിലവ് C_i നൽകുകയും പിന്നീട് ആ സ്ഥാനത്തുള്ള വാതിൽ തുറക്കുകയും ചെയ്യാം. 1 <= i < n എന്നതിനായി C_i >= C_{i+1} എന്ന് ഉറപ്പാക്കുന്നു. എല്ലാ വാതിലുകളും തുറക്കുന്നതിനായി ആവശ്യമായ കുറഞ്ഞ മൊത്തം ചിലവ് നിർണയിക്കുകയാണ് ഈ പ്രവർത്തി.\n\nഉദാഹരണം:\n    >>> minTotalCost(3, (1, 1, 1))\n    3", "fa": "با توجه به n در که به صورت دایره‌ای چیده شده‌اند، بازیکن در مقابل در شماره 1 شروع می‌کند. در هر نوبت، بازیکن می‌تواند یک عدد i انتخاب کند و هزینه C_i را بپردازد تا i قدم به سمت راست حرکت کند و سپس در آن موقعیت در را باز کند. تضمین شده است که C_i >= C_{i+1} برای 1 <= i < n.\n\nوظیفه این است که حداقل هزینه کل مورد نیاز برای باز کردن همه درها را تعیین کنید.\n\nمثال:\n    >>> minTotalCost(3, (1, 1, 1))\n    3"}}
{"task_id": "C/37", "prompt": {"en": "#include <assert.h>\n#include <stdio.h>\n/*\nGiven a sequence of student IDs entering a classroom, where the IDs range from 0 to N-1, calculate the total number of handshakes that occur. Each student will shake hands with every student already in the classroom with a smaller ID number. The sequence represents the order in which students enter the classroom.\n\nExamples:\n    >>> countHandshakes(3, (2, 1, 0))\n    0\n*/\nlong long countHandshakes(int n, int order[])", "sq": "#include <assert.h>\n#include <stdio.h>\n/*\nDuke pasur një sekuencë të ID-ve të studentëve që hyjnë në një klasë, ku ID-të shkojnë nga 0 deri në N-1, llogaritni numrin total të shtrëngimeve të duarve që ndodhin. Çdo student do të shtrëngojë duart me çdo student që tashmë është në klasë me një numër ID më të vogël. Sekuenca përfaqëson rendin në të cilin studentët hyjnë në klasë.\n\nShembuj:\n    >>> countHandshakes(3, (2, 1, 0))\n    0\n*/\nlong long countHandshakes(int n, int order[])", "hy": "#include <assert.h>\n#include <stdio.h>\n/*\nՈւնենալով դասարան մուտք գործող ուսանողների ID-ների հաջորդականություն, որտեղ ID-ները տատանվում են 0-ից մինչև N-1, հաշվեք տեղի ունեցող ձեռքսեղմումների ընդհանուր քանակը։ Յուրաքանչյուր ուսանող ձեռք կսեղմի արդեն դասարանում գտնվող յուրաքանչյուր ուսանողի հետ, ում ID-ն ավելի փոքր է։ Հաջորդականությունը ներկայացնում է ուսանողների դասարան մուտք գործելու կարգը։\n\nՕրինակներ:\n    >>> countHandshakes(3, (2, 1, 0))\n    0\n*/\nlong long countHandshakes(int n, int order[])", "bn": "#include <assert.h>\n#include <stdio.h>\n/*\nশ্রেণীকক্ষে প্রবেশ করা ছাত্রদের আইডির একটি ক্রম দেওয়া হয়েছে, যেখানে আইডিগুলি 0 থেকে N-1 পর্যন্ত রয়েছে, মোট কতগুলি হ্যান্ডশেক হয় তা গণনা করুন। প্রতিটি ছাত্র ইতিমধ্যে শ্রেণীকক্ষে উপস্থিত প্রতিটি ছাত্রের সাথে হ্যান্ডশেক করবে যার আইডি নম্বর ছোট। ক্রমটি ছাত্রদের শ্রেণীকক্ষে প্রবেশের ক্রমকে উপস্থাপন করে।\n\nউদাহরণ:\n    >>> countHandshakes(3, (2, 1, 0))\n    0\n*/\nlong long countHandshakes(int n, int order[])", "bg": "#include <assert.h>\n#include <stdio.h>\n/*\nДадена е последователност от идентификатори на ученици, влизащи в класната стая, където идентификаторите варират от 0 до N-1, изчислете общия брой ръкостискания, които се случват. Всеки ученик ще се ръкува с всеки ученик, който вече е в класната стая с по-малък идентификатор. Последователността представлява реда, в който учениците влизат в класната стая.\n\nПримери:\n    >>> countHandshakes(3, (2, 1, 0))\n    0\n*/\nlong long countHandshakes(int n, int order[])", "zh": "#include <assert.h>\n#include <stdio.h>\n/*\n给定一个学生ID进入教室的序列，其中ID范围从0到N-1，计算发生的握手总数。每个学生将与教室中ID号较小的每个学生握手。序列表示学生进入教室的顺序。\n\n例子:\n    >>> countHandshakes(3, (2, 1, 0))\n    0\n*/\nlong long countHandshakes(int n, int order[])", "fr": "#include <assert.h>\n#include <stdio.h>\n/*\nÉtant donné une séquence d'ID d'étudiants entrant dans une salle de classe, où les ID vont de 0 à N-1, calculez le nombre total de poignées de main qui se produisent. Chaque étudiant serrera la main de chaque étudiant déjà dans la salle de classe avec un numéro d'ID plus petit. La séquence représente l'ordre dans lequel les étudiants entrent dans la salle de classe.\n\nExemples :\n    >>> countHandshakes(3, (2, 1, 0))\n    0\n*/\nlong long countHandshakes(int n, int order[])", "de": "#include <assert.h>\n#include <stdio.h>\n/*\nGegeben eine Sequenz von Studenten-IDs, die einen Klassenraum betreten, wobei die IDs von 0 bis N-1 reichen, berechne die Gesamtanzahl der stattfindenden Händedrücke. Jeder Student wird jedem Studenten, der sich bereits im Klassenraum befindet und eine kleinere ID-Nummer hat, die Hand schütteln. Die Sequenz repräsentiert die Reihenfolge, in der die Studenten den Klassenraum betreten.\n\nBeispiele:\n    >>> countHandshakes(3, (2, 1, 0))\n    0\n*/\nlong long countHandshakes(int n, int order[])", "ha": "#include <assert.h>\n#include <stdio.h>\n/*\nAn ba da jerin lambar ID ɗalibai da ke shiga aji, inda lambobin ID ke tsakanin 0 zuwa N-1, ƙididdige jimlar yawan musabaha da ke faruwa. Kowanne ɗalibi zai yi musabaha da kowanne ɗalibi da ke cikin aji wanda ke da lambar ID ƙasa da shi. Jerin yana wakiltar tsarin da ɗalibai ke shiga aji.\n\nMisalai:\n    >>> countHandshakes(3, (2, 1, 0))\n    0\n*/\nlong long countHandshakes(int n, int order[])", "hi": "#include <assert.h>\n#include <stdio.h>\n/*\nछात्र आईडी की एक अनुक्रमणा दी गई है जो एक कक्षा में प्रवेश कर रहे हैं, जहाँ आईडी 0 से N-1 तक होती हैं, कुल हैंडशेक की संख्या की गणना करें जो होती है। प्रत्येक छात्र उन सभी छात्रों से हाथ मिलाएगा जो पहले से ही कक्षा में हैं और जिनकी आईडी संख्या उससे छोटी है। अनुक्रमणा उस क्रम का प्रतिनिधित्व करती है जिसमें छात्र कक्षा में प्रवेश करते हैं।\n\nउदाहरण:\n    >>> countHandshakes(3, (2, 1, 0))\n    0\n*/\nlong long countHandshakes(int n, int order[])", "hu": "#include <assert.h>\n#include <stdio.h>\n/*\nAdott egy osztályterembe belépő diákok azonosítóinak sorozata, ahol az azonosítók 0-tól N-1-ig terjednek, számítsd ki a kézfogások teljes számát, amelyek megtörténnek. Minden diák kezet fog minden már a teremben lévő diákkal, akinek kisebb az azonosítója. A sorozat azt az sorrendet jelenti, amelyben a diákok belépnek az osztályterembe.\n\nPéldák:\n    >>> countHandshakes(3, (2, 1, 0))\n    0\n*/\nlong long countHandshakes(int n, int order[])", "es": "#include <assert.h>\n#include <stdio.h>\n/*\nDada una secuencia de IDs de estudiantes que entran a un aula, donde los IDs van de 0 a N-1, calcula el número total de apretones de manos que ocurren. Cada estudiante dará la mano a cada estudiante que ya esté en el aula con un número de ID menor. La secuencia representa el orden en que los estudiantes entran al aula.\n\nEjemplos:\n    >>> countHandshakes(3, (2, 1, 0))\n    0\n*/\nlong long countHandshakes(int n, int order[])", "arb": "#include <assert.h>\n#include <stdio.h>\n/*\nبالنظر إلى تسلسل معرفات الطلاب الذين يدخلون إلى الفصل، حيث تتراوح المعرفات من 0 إلى N-1، احسب العدد الإجمالي للمصافحات التي تحدث. كل طالب سيصافح كل طالب موجود بالفعل في الفصل برقم معرف أصغر. يمثل التسلسل الترتيب الذي يدخل به الطلاب إلى الفصل.\n\nأمثلة:\n    >>> countHandshakes(3, (2, 1, 0))\n    0\n*/\nlong long countHandshakes(int n, int order[])", "sw": "#include <assert.h>\n#include <stdio.h>\n/*\nKwa kuzingatia mlolongo wa vitambulisho vya wanafunzi wanaoingia darasani, ambapo vitambulisho vinatoka 0 hadi N-1, hesabu jumla ya mikono inayoshikana. Kila mwanafunzi atashikana mikono na kila mwanafunzi ambaye tayari yuko darasani na ana namba ndogo ya kitambulisho. Mlolongo unawakilisha mpangilio ambao wanafunzi wanaingia darasani.\n\nMifano:\n    >>> countHandshakes(3, (2, 1, 0))\n    0\n*/\nlong long countHandshakes(int n, int order[])", "tr": "#include <assert.h>\n#include <stdio.h>\n/*\nBir sınıfa giren öğrenci kimliklerinin bir dizisi verildiğinde, kimliklerin 0'dan N-1'e kadar değiştiği varsayılırsa, gerçekleşen toplam el sıkışma sayısını hesaplayın. Her öğrenci, sınıfta zaten bulunan ve daha küçük bir kimlik numarasına sahip her öğrenciyle el sıkışacaktır. Dizi, öğrencilerin sınıfa giriş sırasını temsil eder.\n\nÖrnekler:\n    >>> countHandshakes(3, (2, 1, 0))\n    0\n*/\nlong long countHandshakes(int n, int order[])", "vi": "#include <assert.h>\n#include <stdio.h>\n/*\nCho một dãy số ID của học sinh khi vào lớp học, trong đó các ID nằm trong khoảng từ 0 đến N-1, tính tổng số lần bắt tay xảy ra. Mỗi học sinh sẽ bắt tay với mọi học sinh đã có mặt trong lớp với số ID nhỏ hơn. Dãy số đại diện cho thứ tự mà học sinh vào lớp.\n\nVí dụ:\n    >>> countHandshakes(3, (2, 1, 0))\n    0\n*/\nlong long countHandshakes(int n, int order[])", "id": "#include <assert.h>\n#include <stdio.h>\n/*\nDiberikan urutan ID siswa yang memasuki kelas, di mana ID berkisar dari 0 hingga N-1, hitung total jumlah jabat tangan yang terjadi. Setiap siswa akan berjabat tangan dengan setiap siswa yang sudah ada di kelas dengan nomor ID yang lebih kecil. Urutan tersebut mewakili urutan di mana siswa memasuki kelas.\n\nContoh:\n    >>> countHandshakes(3, (2, 1, 0))\n    0\n*/\nlong long countHandshakes(int n, int order[])", "ja": "#include <assert.h>\n#include <stdio.h>\n/*\n教室に入る学生IDのシーケンスが与えられたとき、IDは0からN-1の範囲で、発生する握手の総数を計算します。各学生は、教室にすでにいる自分より小さいID番号のすべての学生と握手をします。このシーケンスは、学生が教室に入る順序を表しています。\n\n例:\n    >>> countHandshakes(3, (2, 1, 0))\n    0\n*/\nlong long countHandshakes(int n, int order[])", "ko": "#include <assert.h>\n#include <stdio.h>\n/*\n학생들이 교실에 들어오는 순서가 주어졌을 때, 학생 ID는 0부터 N-1까지의 범위를 가집니다. 발생하는 총 악수의 수를 계산하세요. 각 학생은 이미 교실에 있는 자신보다 작은 ID 번호를 가진 모든 학생과 악수를 합니다. 이 순서는 학생들이 교실에 들어오는 순서를 나타냅니다.\n\n예시:\n    >>> countHandshakes(3, (2, 1, 0))\n    0\n*/\nlong long countHandshakes(int n, int order[])", "ml": "#include <assert.h>\n#include <stdio.h>\n/*\nക്ലാസ്‌റൂമിലേക്ക് പ്രവേശിക്കുന്ന വിദ്യാർത്ഥികളുടെ ഐഡികളുടെ ഒരു ക്രമം നൽകിയിരിക്കുന്നു, ഇവിടെ ഐഡികൾ 0 മുതൽ N-1 വരെയാണ്. ഉണ്ടാകുന്ന ആകെ കൈകുലുക്കലുകളുടെ എണ്ണം കണക്കാക്കുക. ഓരോ വിദ്യാർത്ഥിയും ക്ലാസ്‌റൂമിൽ ഇതിനകം ചെറിയ ഐഡി നമ്പറുള്ള എല്ലാ വിദ്യാർത്ഥികളുമായും കൈകുലുക്കും. ഈ ക്രമം വിദ്യാർത്ഥികൾ ക്ലാസ്‌റൂമിലേക്ക് പ്രവേശിക്കുന്ന ക്രമത്തെ പ്രതിനിധീകരിക്കുന്നു.\n\nഉദാഹരണങ്ങൾ:\n    >>> countHandshakes(3, (2, 1, 0))\n    0\n*/\nlong long countHandshakes(int n, int order[])", "fa": "#include <assert.h>\n#include <stdio.h>\n/*\nبا توجه به دنباله‌ای از شناسه‌های دانش‌آموزانی که وارد کلاس می‌شوند، که شناسه‌ها از 0 تا N-1 می‌باشند، تعداد کل دست دادن‌هایی که رخ می‌دهد را محاسبه کنید. هر دانش‌آموز با هر دانش‌آموزی که قبلاً با شناسه کوچکتر در کلاس حضور دارد دست می‌دهد. دنباله نشان‌دهنده ترتیب ورود دانش‌آموزان به کلاس است.\n\nمثال‌ها:\n    >>> countHandshakes(3, (2, 1, 0))\n    0\n*/\nlong long countHandshakes(int n, int order[])"}, "canonical_solution": "{\n    long long ans = 0;\n    int tr[10000] = {0}; // N should be defined as a constant representing the maximum possible value of n\n    for (int i = 0; i < 10000; ++i) {\n        tr[i] = 0;\n    }\n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n    return ans;\n}", "instruction": {"en": "long long countHandshakes(int n, int order[])\n{\n    long long ans = 0;\n    int tr[10000] = {0}; // N should be defined as a constant representing the maximum possible value of n\n    for (int i = 0; i < 10000; ++i) {\n        tr[i] = 0;\n    }\n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n    return ans;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "sq": "long long countHandshakes(int n, int order[])\n{\n    long long ans = 0;\n    int tr[10000] = {0}; // N should be defined as a constant representing the maximum possible value of n\n    for (int i = 0; i < 10000; ++i) {\n        tr[i] = 0;\n    }\n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n    return ans;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C në shqip duke përdorur maksimumi 500 karaktere.", "hy": "long long countHandshakes(int n, int order[])\n{\n    long long ans = 0;\n    int tr[10000] = {0}; // N should be defined as a constant representing the maximum possible value of n\n    for (int i = 0; i < 10000; ++i) {\n        tr[i] = 0;\n    }\n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n    return ans;\n}\n\nՏվեք C կոդի համառոտ բնութագրությունը (docstring) հայերեն լեզվով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "long long countHandshakes(int n, int order[])\n{\n    long long ans = 0;\n    int tr[10000] = {0}; // N should be defined as a constant representing the maximum possible value of n\n    for (int i = 0; i < 10000; ++i) {\n        tr[i] = 0;\n    }\n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n    return ans;\n}\n\nনিচে দেওয়া C কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।", "bg": "long long countHandshakes(int n, int order[])\n{\n    long long ans = 0;\n    int tr[10000] = {0}; // N should be defined as a constant representing the maximum possible value of n\n    for (int i = 0; i < 10000; ++i) {\n        tr[i] = 0;\n    }\n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n    return ans;\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, използвайки най-много 500 знака.", "zh": "long long countHandshakes(int n, int order[])\n{\n    long long ans = 0;\n    int tr[10000] = {0}; // N should be defined as a constant representing the maximum possible value of n\n    for (int i = 0; i < 10000; ++i) {\n        tr[i] = 0;\n    }\n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n    return ans;\n}\n\n请用最多500个字符的中文对该C代码提供简洁的自然语言描述（文档字符串）。", "fr": "long long countHandshakes(int n, int order[])\n{\n    long long ans = 0;\n    int tr[10000] = {0}; // N should be defined as a constant representing the maximum possible value of n\n    for (int i = 0; i < 10000; ++i) {\n        tr[i] = 0;\n    }\n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n    return ans;\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.", "de": "long long countHandshakes(int n, int order[])\n{\n    long long ans = 0;\n    int tr[10000] = {0}; // N should be defined as a constant representing the maximum possible value of n\n    for (int i = 0; i < 10000; ++i) {\n        tr[i] = 0;\n    }\n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n    return ans;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "long long countHandshakes(int n, int order[])\n{\n    long long ans = 0;\n    int tr[10000] = {0}; // N should be defined as a constant representing the maximum possible value of n\n    for (int i = 0; i < 10000; ++i) {\n        tr[i] = 0;\n    }\n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n    return ans;\n}\n\nBa da takaitaccen bayanin yaren halitta (docstring) na lambar C cikin Hausa ta amfani da haruffa 500 kawai.", "hi": "long long countHandshakes(int n, int order[])\n{\n    long long ans = 0;\n    int tr[10000] = {0}; // N should be defined as a constant representing the maximum possible value of n\n    for (int i = 0; i < 10000; ++i) {\n        tr[i] = 0;\n    }\n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n    return ans;\n}\n\nC कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "long long countHandshakes(int n, int order[])\n{\n    long long ans = 0;\n    int tr[10000] = {0}; // N should be defined as a constant representing the maximum possible value of n\n    for (int i = 0; i < 10000; ++i) {\n        tr[i] = 0;\n    }\n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n    return ans;\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a C kódról magyar nyelven, legfeljebb 500 karakterben.", "es": "long long countHandshakes(int n, int order[])\n{\n    long long ans = 0;\n    int tr[10000] = {0}; // N should be defined as a constant representing the maximum possible value of n\n    for (int i = 0; i < 10000; ++i) {\n        tr[i] = 0;\n    }\n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n    return ans;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando como máximo 500 caracteres.", "arb": "long long countHandshakes(int n, int order[])\n{\n    long long ans = 0;\n    int tr[10000] = {0}; // N should be defined as a constant representing the maximum possible value of n\n    for (int i = 0; i < 10000; ++i) {\n        tr[i] = 0;\n    }\n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n    return ans;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "long long countHandshakes(int n, int order[])\n{\n    long long ans = 0;\n    int tr[10000] = {0}; // N should be defined as a constant representing the maximum possible value of n\n    for (int i = 0; i < 10000; ++i) {\n        tr[i] = 0;\n    }\n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n    return ans;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "long long countHandshakes(int n, int order[])\n{\n    long long ans = 0;\n    int tr[10000] = {0}; // N should be defined as a constant representing the maximum possible value of n\n    for (int i = 0; i < 10000; ++i) {\n        tr[i] = 0;\n    }\n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n    return ans;\n}\n\nC kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda özlü bir doğal dil açıklaması (docstring) sağlayın.", "vi": "long long countHandshakes(int n, int order[])\n{\n    long long ans = 0;\n    int tr[10000] = {0}; // N should be defined as a constant representing the maximum possible value of n\n    for (int i = 0; i < 10000; ++i) {\n        tr[i] = 0;\n    }\n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n    return ans;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã C bằng tiếng Việt với tối đa 500 ký tự.", "id": "long long countHandshakes(int n, int order[])\n{\n    long long ans = 0;\n    int tr[10000] = {0}; // N should be defined as a constant representing the maximum possible value of n\n    for (int i = 0; i < 10000; ++i) {\n        tr[i] = 0;\n    }\n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n    return ans;\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode C dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "long long countHandshakes(int n, int order[])\n{\n    long long ans = 0;\n    int tr[10000] = {0}; // N should be defined as a constant representing the maximum possible value of n\n    for (int i = 0; i < 10000; ++i) {\n        tr[i] = 0;\n    }\n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n    return ans;\n}\n\nCコードの内容を日本語で簡潔に説明するドキュメンテーション文字列（ドックストリング）を500文字以内で提供してください。", "ko": "long long countHandshakes(int n, int order[])\n{\n    long long ans = 0;\n    int tr[10000] = {0}; // N should be defined as a constant representing the maximum possible value of n\n    for (int i = 0; i < 10000; ++i) {\n        tr[i] = 0;\n    }\n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n    return ans;\n}\n\nC 코드에 대한 간결한 자연어 설명(docstring)을 한국어로 최대 500자 이내로 제공하세요.", "ml": "long long countHandshakes(int n, int order[])\n{\n    long long ans = 0;\n    int tr[10000] = {0}; // N should be defined as a constant representing the maximum possible value of n\n    for (int i = 0; i < 10000; ++i) {\n        tr[i] = 0;\n    }\n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n    return ans;\n}\n\nസിയുടെ കോഡിന് 500 അക്ഷരങ്ങളിൽ കവിയാത്ത മലയാളത്തിൽ സംക്ഷിപ്തമായ സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) നൽകുക.", "fa": "long long countHandshakes(int n, int order[])\n{\n    long long ans = 0;\n    int tr[10000] = {0}; // N should be defined as a constant representing the maximum possible value of n\n    for (int i = 0; i < 10000; ++i) {\n        tr[i] = 0;\n    }\n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n    return ans;\n}\n\nیک توضیح مختصر و طبیعی (docstring) از کد C به زبان فارسی ارائه دهید که حداکثر ۵۰۰ کاراکتر باشد."}, "level": "", "test": "int main() {\n    int or1[] = {2, 1, 3, 0};\n    assert(countHandshakes(4, or1) == 2);\n    int or2[] = {0, 1, 2, 3, 4, 5};\n    assert(countHandshakes(6, or2) == 15);\n    int order1[] = {1, 2, 0};\n    assert(countHandshakes(3, order1) == 1);\n\n    int order2[] = {3, 2, 1, 0};\n    assert(countHandshakes(4, order2) == 0);\n\n    int order3[] = {0, 1, 2, 3};\n    assert(countHandshakes(4, order3) == 6);\n\n    int order4[] = {5, 4, 3, 2, 1, 0};\n    assert(countHandshakes(6, order4) == 0);\n\n    int order5[] = {0, 2, 1, 3};\n    assert(countHandshakes(4, order5) == 5);\n\n    int order6[] = {3, 1, 4, 2, 0};\n    assert(countHandshakes(5, order6) == 3);\n\n    int order7[] = {1, 0, 3, 2};\n    assert(countHandshakes(4, order7) == 4);\n\n    int order8[] = {2, 0, 1};\n    assert(countHandshakes(3, order8) == 1);\n\n    int order9[] = {1, 3, 0, 2, 4};\n    assert(countHandshakes(5, order9) == 7);\n\n    int order10[] = {4, 3, 2, 1, 0};\n    assert(countHandshakes(5, order10) == 0);\n\n    return 0;\n}", "entry_point": "countHandshakes", "signature": "long long countHandshakes(int n, int order[])", "docstring": {"en": "Given a sequence of student IDs entering a classroom, where the IDs range from 0 to N-1, calculate the total number of handshakes that occur. Each student will shake hands with every student already in the classroom with a smaller ID number. The sequence represents the order in which students enter the classroom.\n\nExamples:\n    >>> countHandshakes(3, (2, 1, 0))\n    0\n", "sq": "Duke pasur një sekuencë të ID-ve të studentëve që hyjnë në klasë, ku ID-të variojnë nga 0 deri në N-1, llogaritni numrin total të shtrëngimeve të duarve që ndodhin. Çdo student do të shtrëngojë duart me çdo student që tashmë është në klasë me një numër ID më të vogël. Sekuenca përfaqëson rendin në të cilin studentët hyjnë në klasë.\n\nShembuj:\n    >>> countHandshakes(3, (2, 1, 0))\n    0", "hy": "Տրված է ուսանողների ID-ների հաջորդականություն, որոնք մտնում են դասարան, որտեղ ID-ները տատանվում են 0-ից մինչև N-1, հաշվարկել ընդհանուր ձեռքսեղմումների քանակը, որոնք տեղի են ունենում։ Յուրաքանչյուր ուսանող ձեռք կսեղմի արդեն իսկ դասարանում գտնվող յուրաքանչյուր ուսանողի հետ, որի ID-ն ավելի փոքր է։ Հաջորդականությունը ներկայացնում է ուսանողների դասարան մտնելու կարգը։\n\nՕրինակներ:\n    >>> countHandshakes(3, (2, 1, 0))\n    0", "bn": "শ্রেণীকক্ষে প্রবেশ করা ছাত্রদের আইডির একটি ক্রম দেওয়া হয়েছে, যেখানে আইডিগুলি 0 থেকে N-1 পর্যন্ত বিস্তৃত। মোট কতগুলি হ্যান্ডশেক হয় তা গণনা করুন। প্রতিটি ছাত্র তার থেকে ছোট আইডি নম্বর সহ ইতিমধ্যে শ্রেণীকক্ষে থাকা প্রতিটি ছাত্রের সাথে হ্যান্ডশেক করবে। ক্রমটি ছাত্রদের শ্রেণীকক্ষে প্রবেশের ক্রমকে উপস্থাপন করে।\n\nউদাহরণ:\n    >>> countHandshakes(3, (2, 1, 0))\n    0", "bg": "Дадена е последователност от студентски идентификационни номера, които влизат в класната стая, където идентификационните номера варират от 0 до N-1, изчислете общия брой ръкостискания, които се случват. Всеки студент ще се ръкува с всеки студент, който вече е в класната стая с по-малък идентификационен номер. Последователността представлява реда, по който студентите влизат в класната стая.\n\nПримери:\n    >>> countHandshakes(3, (2, 1, 0))\n    0", "zh": "给定一个进入教室的学生ID序列，其中ID范围从0到N-1，计算发生的握手总数。每个学生将与教室中已经存在的ID号较小的每个学生握手。序列表示学生进入教室的顺序。\n\n示例：\n    >>> countHandshakes(3, (2, 1, 0))\n    0", "fr": "Étant donné une séquence d'IDs d'étudiants entrant dans une salle de classe, où les IDs vont de 0 à N-1, calculez le nombre total de poignées de main qui se produisent. Chaque étudiant serrera la main de chaque étudiant déjà dans la salle de classe avec un numéro d'ID plus petit. La séquence représente l'ordre dans lequel les étudiants entrent dans la salle de classe.\n\nExemples :\n    >>> countHandshakes(3, (2, 1, 0))\n    0\n", "de": "Gegeben ist eine Sequenz von Schüler-IDs, die ein Klassenzimmer betreten, wobei die IDs von 0 bis N-1 reichen. Berechnen Sie die Gesamtanzahl der stattfindenden Händedrucke. Jeder Schüler wird mit jedem Schüler, der sich bereits im Klassenzimmer befindet und eine kleinere ID-Nummer hat, die Hand schütteln. Die Sequenz repräsentiert die Reihenfolge, in der die Schüler das Klassenzimmer betreten.\n\nBeispiele:\n    >>> countHandshakes(3, (2, 1, 0))\n    0", "ha": "An ba da jerin lambobin dalibai da ke shiga aji, inda lambobin ID ke tsakanin 0 zuwa N-1, a lissafta jimillar yawan gaisuwar hannu da ke faruwa. Kowanne dalibi zai yi gaisuwar hannu da kowane dalibi da ke a cikin aji wanda ke da ƙaramin lamba. Jerin yana wakiltar tsarin da dalibai ke shiga aji.\n\nMisalai:\n    >>> countHandshakes(3, (2, 1, 0))\n    0", "hi": "छात्र आईडी के अनुक्रम को ध्यान में रखते हुए जो एक कक्षा में प्रवेश कर रहे हैं, जहाँ आईडी 0 से N-1 तक होती हैं, कुल हैंडशेक की संख्या की गणना करें। प्रत्येक छात्र उन सभी छात्रों से हाथ मिलाएगा जो पहले से छोटे आईडी नंबर के साथ कक्षा में हैं। अनुक्रम उस क्रम का प्रतिनिधित्व करता है जिसमें छात्र कक्षा में प्रवेश करते हैं।\n\nउदाहरण:\n    >>> countHandshakes(3, (2, 1, 0))\n    0", "hu": "Adott egy tanulói azonosítók sorozata, akik belépnek egy tanterembe, ahol az azonosítók 0-tól N-1-ig terjednek, számítsd ki a kézfogások teljes számát, amelyek megtörténnek. Minden diák kezet fog minden már a tanteremben lévő diákkal, akinek kisebb az azonosító száma. A sorozat azt az sorrendet képviseli, amelyben a diákok belépnek a tanterembe.\n\nPéldák:\n    >>> countHandshakes(3, (2, 1, 0))\n    0", "es": "Dada una secuencia de identificaciones de estudiantes que ingresan a un aula, donde las identificaciones varían de 0 a N-1, calcule el número total de apretones de manos que ocurren. Cada estudiante estrechará la mano con cada estudiante que ya esté en el aula con un número de identificación menor. La secuencia representa el orden en que los estudiantes ingresan al aula.\n\nEjemplos:\n    >>> countHandshakes(3, (2, 1, 0))\n    0", "arb": "بالنظر إلى تسلسل معرفات الطلاب الذين يدخلون الفصل، حيث تتراوح المعرفات من 0 إلى N-1، احسب العدد الإجمالي للمصافحات التي تحدث. كل طالب سوف يصافح كل طالب موجود بالفعل في الفصل بمعرف أصغر. يمثل التسلسل ترتيب دخول الطلاب إلى الفصل.\n\nأمثلة:\n    >>> countHandshakes(3, (2, 1, 0))\n    0", "sw": "Given a sequence of student IDs entering a classroom, where the IDs range from 0 to N-1, calculate the total number of handshakes that occur. Kila mwanafunzi atapiga mikono na kila mwanafunzi tayari ndani ya darasa mwenye namba ya ID ndogo. Mfuatano unawakilisha mpangilio ambao wanafunzi wanaingia darasani.\n\nMifano:\n    >>> countHandshakes(3, (2, 1, 0))\n    0", "tr": "Verilen bir sınıfa giren öğrenci kimlik numaralarının sıralamasına göre, gerçekleşen toplam tokalaşma sayısını hesaplayın. Kimlik numaraları 0'dan N-1'e kadar olan her öğrenci, sınıfta kendisinden daha küçük kimlik numarasına sahip olan her öğrenciyle tokalaşacaktır. Sıralama, öğrencilerin sınıfa giriş sırasını temsil eder.\n\nÖrnekler:\n    >>> countHandshakes(3, (2, 1, 0))\n    0", "vi": "Cho một dãy số ID sinh viên khi vào lớp học, trong đó các ID có phạm vi từ 0 đến N-1, tính tổng số lần bắt tay xảy ra. Mỗi sinh viên sẽ bắt tay với mọi sinh viên đã có mặt trong lớp với số ID nhỏ hơn. Dãy số đại diện cho thứ tự mà các sinh viên vào lớp.\n\nVí dụ:\n    >>> countHandshakes(3, (2, 1, 0))\n    0", "id": "Diberikan urutan ID siswa yang memasuki ruang kelas, di mana ID berkisar dari 0 hingga N-1, hitung jumlah total jabat tangan yang terjadi. Setiap siswa akan berjabat tangan dengan setiap siswa yang sudah ada di ruang kelas dengan nomor ID yang lebih kecil. Urutan tersebut mewakili urutan di mana siswa memasuki ruang kelas.\n\nContoh:\n    >>> countHandshakes(3, (2, 1, 0))\n    0", "ja": "学生IDのシーケンスが教室に入る順序で与えられたとき、発生する握手の総数を計算します。IDは0からN-1の範囲です。各学生は、教室にすでにいる自分より小さいID番号のすべての学生と握手をします。このシーケンスは、学生が教室に入る順序を表しています。\n\n例:\n    >>> countHandshakes(3, (2, 1, 0))\n    0", "ko": "학생 ID가 0부터 N-1까지인 학생들이 교실에 들어오는 순서가 주어졌을 때, 발생하는 총 악수 횟수를 계산합니다. 각 학생은 이미 교실에 있는 자신보다 작은 ID 번호를 가진 모든 학생과 악수를 합니다. 이 순서는 학생들이 교실에 들어오는 순서를 나타냅니다.\n\n예시:\n    >>> countHandshakes(3, (2, 1, 0))\n    0", "ml": "ഒരു ക്ലാസ് മുറിയിലേക്ക് പ്രവേശിക്കുന്ന വിദ്യാർത്ഥികളുടെ ഐഡി ക്രമം നൽകിയാൽ, 0 മുതൽ N-1 വരെയുള്ള ഐഡികൾ, ഉണ്ടാകുന്ന ആകെ കൈകുലുക്കലുകളുടെ എണ്ണം കണക്കാക്കുക. ഓരോ വിദ്യാർത്ഥിയും ക്ലാസ് മുറിയിൽ ഇതിനകം ചെറുതായ ഐഡി നമ്പർ ഉള്ള എല്ലാ വിദ്യാർത്ഥികളുമായും കൈകുലുക്കും. ഈ ക്രമം വിദ്യാർത്ഥികൾ ക്ലാസ് മുറിയിലേക്ക് പ്രവേശിക്കുന്ന ക്രമത്തെ പ്രതിനിധീകരിക്കുന്നു.\n\nഉദാഹരണങ്ങൾ:\n    >>> countHandshakes(3, (2, 1, 0))\n    0", "fa": "با توجه به دنباله‌ای از شناسه‌های دانش‌آموزانی که وارد کلاس می‌شوند، که شناسه‌ها از 0 تا N-1 می‌باشند، تعداد کل دست دادن‌هایی که رخ می‌دهد را محاسبه کنید. هر دانش‌آموز با هر دانش‌آموزی که قبلاً با شناسه کوچکتر در کلاس حضور دارد دست می‌دهد. دنباله نشان‌دهنده ترتیب ورود دانش‌آموزان به کلاس است.\n\nمثال‌ها:\n    >>> countHandshakes(3, (2, 1, 0))\n    0"}}
{"task_id": "C/38", "prompt": {"en": "#include <assert.h>\n#include <stdio.h>\n/*\nGiven n positive integers representing the count of each number from 1 to n, \nfind the maximum sum of the mode (most frequent element) for all prefixes of \na sequence constructed from these numbers. The mode is the largest number among \nthe most frequent elements in a sequence.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    A sequence that reaches its maximum value is (3,2,3,1,2,2).\n*/\nlong long maxModeSum(int n, const int* counts)", "sq": "#include <assert.h>\n#include <stdio.h>\n/*\nDuke pasur n numra të plotë pozitivë që përfaqësojnë numrin e secilit numër nga 1 deri në n,\ngjeni shumën maksimale të modës (elementi më i shpeshtë) për të gjitha prefikset e\nnjë sekuence të ndërtuar nga këta numra. Moda është numri më i madh ndër\nelementet më të shpeshta në një sekuencë.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    Një sekuencë që arrin vlerën e saj maksimale është (3,2,3,1,2,2).\n*/\nlong long maxModeSum(int n, const int* counts)", "hy": "#include <assert.h>\n#include <stdio.h>\n/*\nՏրված են n դրական ամբողջ թվեր, որոնք ներկայացնում են 1-ից n թվերի քանակը, \nգտնել մոդայի (ամենահաճախ հանդիպող տարր) առավելագույն գումարը բոլոր նախածանցների \nհամար, որոնք կազմված են այս թվերից: Մոդան հաջորդականության ամենահաճախ հանդիպող \nտարրերի մեջ ամենամեծ թիվն է:\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    Հաջորդականություն, որը հասնում է իր առավելագույն արժեքին, (3,2,3,1,2,2) է:\n*/\nlong long maxModeSum(int n, const int* counts)", "bn": "#include <assert.h>\n#include <stdio.h>\n/*\nপ্রতিটি সংখ্যা 1 থেকে n পর্যন্ত গণনা প্রতিনিধিত্বকারী n টি ধনাত্মক পূর্ণসংখ্যা দেওয়া হয়েছে,\nএই সংখ্যাগুলি থেকে গঠিত একটি ক্রমের সমস্ত উপসর্গের জন্য মোডের (সবচেয়ে ঘন ঘন উপাদান) সর্বাধিক \nযোগফল খুঁজে বের করুন। মোড হল একটি ক্রমের সবচেয়ে ঘন ঘন উপাদানগুলির মধ্যে বৃহত্তম সংখ্যা।\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    একটি ক্রম যা তার সর্বাধিক মানে পৌঁছায় তা হল (3,2,3,1,2,2)।\n*/\nlong long maxModeSum(int n, const int* counts)", "bg": "#include <assert.h>\n#include <stdio.h>\n/*\nДадени са n положителни цели числа, представляващи броя на всяко число от 1 до n,\nнамерете максималната сума на модата (най-често срещания елемент) за всички префикси на\nпоследователност, съставена от тези числа. Модата е най-голямото число сред\nнай-често срещаните елементи в последователност.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    Последователност, която достига максималната си стойност, е (3,2,3,1,2,2).\n*/\nlong long maxModeSum(int n, const int* counts)", "zh": "#include <assert.h>\n#include <stdio.h>\n/*\n给定 n 个正整数，表示从 1 到 n 的每个数字的计数，\n找到从这些数字构造的序列的所有前缀的众数（最频繁元素）的最大和。\n众数是序列中最频繁元素中最大的数字。\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    达到其最大值的序列是 (3,2,3,1,2,2)。\n*/\nlong long maxModeSum(int n, const int* counts)", "fr": "#include <assert.h>\n#include <stdio.h>\n/*\nÉtant donné n entiers positifs représentant le nombre de chaque nombre de 1 à n,\ntrouvez la somme maximale de la mode (élément le plus fréquent) pour tous les préfixes d'une\nséquence construite à partir de ces nombres. La mode est le plus grand nombre parmi\nles éléments les plus fréquents dans une séquence.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    Une séquence qui atteint sa valeur maximale est (3,2,3,1,2,2).\n*/\nlong long maxModeSum(int n, const int* counts)", "de": "#include <assert.h>\n#include <stdio.h>\n/*\nGegeben sind n positive ganze Zahlen, die die Anzahl jedes Zahlentyps von 1 bis n darstellen. \nFinde die maximale Summe des Modus (häufigstes Element) für alle Präfixe einer Sequenz, \ndie aus diesen Zahlen konstruiert wurde. Der Modus ist die größte Zahl unter den \nhäufigsten Elementen in einer Sequenz.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    Eine Sequenz, die ihren Maximalwert erreicht, ist (3,2,3,1,2,2).\n*/\nlong long maxModeSum(int n, const int* counts)", "ha": "#include <assert.h>\n#include <stdio.h>\n/*\nAn ba da n lambobi masu kyau waɗanda ke wakiltar adadin kowace lamba daga 1 zuwa n,\nnemo mafi girman jimlar yanayin (abu mafi yawan faruwa) don dukkanin farkon\njerin da aka gina daga waɗannan lambobin. Yanayin shine mafi girman lamba tsakanin\nmafi yawan abubuwa a cikin jerin.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    Jerin da ya kai darajarsa mafi girma shine (3,2,3,1,2,2).\n*/\nlong long maxModeSum(int n, const int* counts)", "hi": "#include <assert.h>\n#include <stdio.h>\n/*\nदिए गए n धनात्मक पूर्णांक जो 1 से n तक प्रत्येक संख्या की गिनती का प्रतिनिधित्व करते हैं,\nइन संख्याओं से निर्मित अनुक्रम के सभी उपसर्गों के लिए मोड (सबसे अधिक बार आने वाला तत्व) का अधिकतम योग खोजें।\nमोड अनुक्रम में सबसे अधिक बार आने वाले तत्वों में सबसे बड़ी संख्या है।\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    एक अनुक्रम जो अपने अधिकतम मान तक पहुंचता है वह है (3,2,3,1,2,2)।\n*/\nlong long maxModeSum(int n, const int* counts)", "hu": "#include <assert.h>\n#include <stdio.h>\n/*\nAdott n pozitív egész szám, amelyek az 1-től n-ig terjedő számok előfordulási számát jelölik,\ntaláld meg a módusz (leggyakrabban előforduló elem) maximális összegét a\nezekből a számokból felépített sorozat minden prefixére. A módusz a legnagyobb szám a\nsorozat leggyakoribb elemei között.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    Egy sorozat, amely eléri a maximális értékét: (3,2,3,1,2,2).\n*/\nlong long maxModeSum(int n, const int* counts)", "es": "#include <assert.h>\n#include <stdio.h>\n/*\nDado n enteros positivos que representan la cantidad de cada número de 1 a n,\nencuentra la suma máxima del modo (elemento más frecuente) para todos los prefijos de \nuna secuencia construida a partir de estos números. El modo es el número más grande entre \nlos elementos más frecuentes en una secuencia.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    Una secuencia que alcanza su valor máximo es (3,2,3,1,2,2).\n*/\nlong long maxModeSum(int n, const int* counts)", "arb": "#include <assert.h>\n#include <stdio.h>\n/*\nمعطى n عدد صحيح موجب يمثل عدد كل رقم من 1 إلى n،\nابحث عن الحد الأقصى لمجموع النمط (العنصر الأكثر تكرارًا) لجميع البادئات\nلسلسلة مُنشأة من هذه الأرقام. النمط هو أكبر عدد بين\nالعناصر الأكثر تكرارًا في سلسلة.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    سلسلة تصل إلى قيمتها القصوى هي (3,2,3,1,2,2).\n*/\nlong long maxModeSum(int n, const int* counts)", "sw": "#include <assert.h>\n#include <stdio.h>\n/*\nUkipiwa n nambari chanya zinazowakilisha idadi ya kila nambari kutoka 1 hadi n,\ntafuta jumla ya juu zaidi ya modi (kipengele kinachojitokeza mara nyingi zaidi) kwa viambishi vyote vya\nmlolongo ulioundwa kutoka kwa hizi nambari. Modi ni nambari kubwa zaidi kati ya\nvipengele vinavyojitokeza mara nyingi zaidi katika mlolongo.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    Mlolongo unaofikia thamani yake ya juu zaidi ni (3,2,3,1,2,2).\n*/\nlong long maxModeSum(int n, const int* counts)", "tr": "#include <assert.h>\n#include <stdio.h>\n/*\n1'den n'e kadar olan her sayının sayısını temsil eden n pozitif tamsayı verildiğinde,\nbu sayılardan oluşturulan bir dizinin tüm ön ekleri için modun (en sık görülen eleman) \nmaksimum toplamını bulun. Mod, bir dizideki en sık görülen elemanlar arasında \nen büyük sayıdır.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    Maksimum değerine ulaşan bir dizi (3,2,3,1,2,2) şeklindedir.\n*/\nlong long maxModeSum(int n, const int* counts)", "vi": "#include <assert.h>\n#include <stdio.h>\n/*\nCho n số nguyên dương đại diện cho số lượng của mỗi số từ 1 đến n,\ntìm tổng lớn nhất của mode (phần tử xuất hiện nhiều nhất) cho tất cả các tiền tố của\nmột dãy được tạo từ các số này. Mode là số lớn nhất trong số các phần tử xuất hiện nhiều nhất trong một dãy.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    Một dãy đạt giá trị tối đa là (3,2,3,1,2,2).\n*/\nlong long maxModeSum(int n, const int* counts)", "id": "#include <assert.h>\n#include <stdio.h>\n/*\nDiberikan n bilangan bulat positif yang mewakili jumlah masing-masing angka dari 1 hingga n,\ntemukan jumlah maksimum dari modus (elemen yang paling sering muncul) untuk semua awalan dari\nsebuah urutan yang dibentuk dari angka-angka ini. Modus adalah angka terbesar di antara\nelemen yang paling sering muncul dalam sebuah urutan.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    Sebuah urutan yang mencapai nilai maksimumnya adalah (3,2,3,1,2,2).\n*/\nlong long maxModeSum(int n, const int* counts)\n", "ja": "#include <assert.h>\n#include <stdio.h>\n/*\nn 個の正の整数が与えられ、それぞれが 1 から n までの数の出現回数を表しています。\nこれらの数から構成されるシーケンスのすべての接頭辞に対して、モード（最頻出要素）の最大合計を見つけます。\nモードは、シーケンス内の最頻出要素の中で最大の数です。\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    最大値に達するシーケンスは (3,2,3,1,2,2) です。\n*/\nlong long maxModeSum(int n, const int* counts)", "ko": "#include <assert.h>\n#include <stdio.h>\n/*\nn개의 양의 정수가 주어졌을 때, 1부터 n까지의 각 숫자의 개수를 나타내며, \n이 숫자들로 구성된 시퀀스의 모든 접두사에 대한 최빈값(가장 빈번한 요소)의 최대 합을 찾습니다. \n최빈값은 시퀀스에서 가장 빈번한 요소 중 가장 큰 숫자입니다.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    최대값에 도달하는 시퀀스는 (3,2,3,1,2,2)입니다.\n*/\nlong long maxModeSum(int n, const int* counts)\n", "ml": "#include <assert.h>\n#include <stdio.h>\n/*\n1 മുതൽ n വരെ ഓരോ സംഖ്യയുടെ എണ്ണത്തെ പ്രതിനിധീകരിക്കുന്ന n അനുകൂല സംഖ്യകൾ നൽകിയാൽ, \nഈ സംഖ്യകളിൽ നിന്ന് നിർമ്മിച്ച ഒരു ശ്രേണിയുടെ എല്ലാ മുൻഗാമികളുടെയും മോഡ് (ഏറ്റവും അധികം ആവർത്തിക്കുന്ന ഘടകം) \nപരമാവധി തുക കണ്ടെത്തുക. ഒരു ശ്രേണിയിലെ ഏറ്റവും അധികം ആവർത്തിക്കുന്ന ഘടകങ്ങളിൽ ഏറ്റവും വലിയ സംഖ്യയാണ് മോഡ്.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    പരമാവധി മൂല്യത്തെ എത്തുന്ന ഒരു ശ്രേണി (3,2,3,1,2,2) ആണ്.\n*/\nlong long maxModeSum(int n, const int* counts)", "fa": "#include <assert.h>\n#include <stdio.h>\n/*\nبا توجه به n عدد صحیح مثبت که نشان‌دهنده تعداد هر عدد از 1 تا n هستند، \nبیشترین مجموع مد (عنصر پرتکرار) را برای تمام پیشوندهای \nیک دنباله ساخته شده از این اعداد پیدا کنید. مد بزرگترین عدد در میان \nعناصر پرتکرار در یک دنباله است.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    دنباله‌ای که به بیشترین مقدار خود می‌رسد (3,2,3,1,2,2) است.\n*/\nlong long maxModeSum(int n, const int* counts)\n"}, "canonical_solution": "{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}", "instruction": {"en": "long long maxModeSum(int n, const int* counts)\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "sq": "long long maxModeSum(int n, const int* counts)\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrale (docstring) të kodit C në shqip duke përdorur maksimumi 500 karaktere.", "hy": "long long maxModeSum(int n, const int* counts)\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}\n\nՏվեք C կոդի համառոտ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "long long maxModeSum(int n, const int* counts)\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}\n\nসি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।", "bg": "long long maxModeSum(int n, const int* counts)\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, използвайки най-много 500 знака.", "zh": "long long maxModeSum(int n, const int* counts)\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}\n\n请用不超过500个字符的中文为以下C代码提供简洁的自然语言描述（文档字符串）。", "fr": "long long maxModeSum(int n, const int* counts)\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.", "de": "long long maxModeSum(int n, const int* counts)\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "long long maxModeSum(int n, const int* counts)\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}\n\nBa da takaitaccen bayanin yaren halitta (docstring) na lambar C cikin Hausa ta amfani da haruffa 500 kacal.", "hi": "long long maxModeSum(int n, const int* counts)\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}\n\nC कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "long long maxModeSum(int n, const int* counts)\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben.", "es": "long long maxModeSum(int n, const int* counts)\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando como máximo 500 caracteres.", "arb": "long long maxModeSum(int n, const int* counts)\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "long long maxModeSum(int n, const int* counts)\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "long long maxModeSum(int n, const int* counts)\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}\n\nC kodunun işlevini açıklayan en fazla 500 karakterlik kısa bir doğal dil açıklaması (docstring) sağlayın.", "vi": "long long maxModeSum(int n, const int* counts)\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã C bằng tiếng Việt với tối đa 500 ký tự.", "id": "long long maxModeSum(int n, const int* counts)\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode C dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "long long maxModeSum(int n, const int* counts)\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}\n\nCコードの内容を簡潔に説明する自然言語の記述（ドックストリング）を日本語で500文字以内で提供してください。", "ko": "long long maxModeSum(int n, const int* counts)\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}\n\nC 코드의 동작을 설명하는 간결한 자연어 설명(docstring)을 한국어로 작성하세요. 최대 500자까지 가능합니다.", "ml": "long long maxModeSum(int n, const int* counts)\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}\n\nസീ കോഡിന്റെ മലയാളത്തിൽ പരമാവധി 500 അക്ഷരങ്ങളിൽ ഒരു സംക്ഷിപ്ത സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) നൽകുക.", "fa": "long long maxModeSum(int n, const int* counts)\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}\n\nیک توضیح مختصر به زبان طبیعی (docstring) از کد C به زبان فارسی ارائه دهید که حداکثر ۵۰۰ کاراکتر باشد."}, "level": "", "test": "int main() {\n    assert(maxModeSum(3, (int[]){1, 3, 2}) == 17);\n    assert(maxModeSum(4, (int[]){4, 1, 2, 3}) == 37);\n    assert(maxModeSum(2, (int[]){1, 1}) == 4);\n    assert(maxModeSum(5, (int[]){1, 2, 3, 4, 5}) == 75);\n    assert(maxModeSum(1, (int[]){100000}) == 100000);\n    assert(maxModeSum(5, (int[]){5, 3, 2, 4, 1}) == 62);\n    assert(maxModeSum(3, (int[]){100000, 100000, 100000}) == 900000);\n    assert(maxModeSum(3, (int[]){2, 2, 5}) == 27);\n    assert(maxModeSum(4, (int[]){4, 4, 4, 4}) == 64);\n    assert(maxModeSum(6, (int[]){1, 2, 3, 4, 5, 6}) == 126);\n    assert(maxModeSum(3, (int[]){3, 1, 2}) == 16);\n    return 0;\n}", "entry_point": "maxModeSum", "signature": "long long maxModeSum(int n, const int* counts)", "docstring": {"en": "Given n positive integers representing the count of each number from 1 to n, \nfind the maximum sum of the mode (most frequent element) for all prefixes of \na sequence constructed from these numbers. The mode is the largest number among \nthe most frequent elements in a sequence.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    A sequence that reaches its maximum value is (3,2,3,1,2,2).\n", "sq": "Duke pasur n numra të plotë pozitivë që përfaqësojnë numrin e çdo numri nga 1 deri në n, \ngjeni shumën maksimale të modës (elementi më i shpeshtë) për të gjitha prefikset e \nnjë sekuence të ndërtuar nga këta numra. Moda është numri më i madh ndër elementët më të shpeshtë në një sekuencë.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    Një sekuencë që arrin vlerën e saj maksimale është (3,2,3,1,2,2).", "hy": "Տրված են n դրական ամբողջ թվեր, որոնք ներկայացնում են 1-ից n թվերի քանակը, \nգտնել մոդայի (ամենահաճախ հանդիպող տարր) առավելագույն գումարը բոլոր նախածանցների համար \nայդ թվերից կազմված հաջորդականության։ Մոդան ամենամեծ թիվն է հաջորդականության \nամենահաճախ հանդիպող տարրերի մեջ։\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    Հաջորդականություն, որը հասնում է իր առավելագույն արժեքին, (3,2,3,1,2,2) է։", "bn": "প্রতিটি সংখ্যা 1 থেকে n পর্যন্ত গণনা প্রতিনিধিত্বকারী nটি ধনাত্মক পূর্ণসংখ্যা দেওয়া হয়েছে, \nএই সংখ্যাগুলি থেকে নির্মিত একটি ক্রমের সমস্ত উপসর্গের জন্য মোডের (সবচেয়ে ঘন ঘন উপাদান) সর্বাধিক যোগফল খুঁজে বের করুন। \nমোড হল একটি ক্রমের সবচেয়ে ঘন ঘন উপাদানগুলির মধ্যে বৃহত্তম সংখ্যা।\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    একটি ক্রম যা তার সর্বাধিক মানে পৌঁছায় তা হল (3,2,3,1,2,2)।", "bg": "Дадени са n положителни цели числа, представляващи броя на всяко число от 1 до n, намерете максималната сума на модата (най-често срещания елемент) за всички префикси на последователност, конструирана от тези числа. Модата е най-голямото число сред най-често срещаните елементи в последователност.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    Последователност, която достига максималната си стойност, е (3,2,3,1,2,2).", "zh": "给定 n 个正整数，表示从 1 到 n 的每个数字的计数，找到从这些数字构造的序列的所有前缀的众数（最频繁元素）的最大和。众数是序列中最频繁元素中最大的数字。\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    达到最大值的序列是 (3,2,3,1,2,2)。", "fr": "Étant donné n entiers positifs représentant le compte de chaque nombre de 1 à n, trouvez la somme maximale de la mode (élément le plus fréquent) pour tous les préfixes d'une séquence construite à partir de ces nombres. La mode est le plus grand nombre parmi les éléments les plus fréquents dans une séquence.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    Une séquence qui atteint sa valeur maximale est (3,2,3,1,2,2).", "de": "Gegeben sind n positive ganze Zahlen, die die Anzahl jedes einzelnen Wertes von 1 bis n darstellen. \nFinden Sie die maximale Summe des Modus (häufigstes Element) für alle Präfixe einer Sequenz, die aus diesen Zahlen konstruiert wurde. Der Modus ist die größte Zahl unter den häufigsten Elementen in einer Sequenz.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    Eine Sequenz, die ihren maximalen Wert erreicht, ist (3,2,3,1,2,2).", "ha": "An bayar da n lambobi masu kyau waɗanda ke wakiltar adadin kowace lamba daga 1 zuwa n, \nnemo mafi girman jimlar yanayin (abin da aka fi samu) don dukkan farkon jerin \nda aka gina daga waɗannan lambobin. Yanayin shine mafi girman lamba tsakanin \nabin da aka fi samu a cikin jerin.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    Wani jerin da ya kai matsakaicin ƙimar sa shine (3,2,3,1,2,2).", "hi": "दिए गए n धनात्मक पूर्णांक जो 1 से n तक प्रत्येक संख्या की गिनती का प्रतिनिधित्व करते हैं, अनुक्रम के सभी उपसर्गों के लिए मोड (सबसे अधिक बार आने वाला तत्व) के अधिकतम योग को खोजें जो इन संख्याओं से निर्मित होता है। मोड अनुक्रम में सबसे अधिक बार आने वाले तत्वों में सबसे बड़ा संख्या है।\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    एक अनुक्रम जो अपनी अधिकतम मान तक पहुँचता है वह है (3,2,3,1,2,2)।", "hu": "Adott n pozitív egész szám, amelyek az 1-től n-ig terjedő számok számosságát képviselik. \nTalálja meg a maximális összegét a módusznak (leggyakrabban előforduló elem) az összes prefixre \negy ezekből a számokból felépített sorozat esetén. A módusz a legnagyobb szám a sorozat leggyakrabban előforduló elemei között.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    Egy sorozat, amely eléri a maximális értékét: (3,2,3,1,2,2).", "es": "Dado n enteros positivos que representan la cantidad de cada número de 1 a n, \nencuentra la suma máxima del modo (elemento más frecuente) para todos los prefijos de \nuna secuencia construida a partir de estos números. El modo es el número más grande entre \nlos elementos más frecuentes en una secuencia.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    Una secuencia que alcanza su valor máximo es (3,2,3,1,2,2).", "arb": "نظرًا لوجود n من الأعداد الصحيحة الموجبة التي تمثل عدد كل رقم من 1 إلى n، \nابحث عن الحد الأقصى لمجموع النمط (العنصر الأكثر تكرارًا) لجميع البادئات \nلسلسلة مبنية من هذه الأرقام. النمط هو أكبر رقم بين العناصر الأكثر تكرارًا في سلسلة.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    سلسلة تصل إلى قيمتها القصوى هي (3,2,3,1,2,2).", "sw": "Ukipatiwa n nambari chanya zinazowakilisha idadi ya kila nambari kutoka 1 hadi n, \ntafuta jumla ya juu zaidi ya modi (kipengele kinachojitokeza mara nyingi zaidi) kwa awamu zote za \nmlolongo ulioundwa kutoka kwa nambari hizi. Modi ni nambari kubwa zaidi kati ya \nvipengele vinavyojitokeza mara nyingi zaidi katika mlolongo.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    Mlolongo unaofikia thamani yake ya juu zaidi ni (3,2,3,1,2,2).", "tr": "Verilen n pozitif tamsayı, 1'den n'ye kadar olan her sayının sayısını temsil eder, \nbu sayılardan oluşturulan bir dizinin tüm önekleri için modun (en sık görülen eleman) maksimum toplamını bulun. \nMod, bir dizideki en sık görülen elemanlar arasında en büyük sayıdır.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    Maksimum değerine ulaşan bir dizi (3,2,3,1,2,2) şeklindedir.", "vi": "Cho n số nguyên dương đại diện cho số lượng của mỗi số từ 1 đến n, tìm tổng lớn nhất của mode (phần tử xuất hiện nhiều nhất) cho tất cả các tiền tố của một dãy được tạo thành từ các số này. Mode là số lớn nhất trong số các phần tử xuất hiện nhiều nhất trong một dãy.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    Một dãy đạt giá trị tối đa là (3,2,3,1,2,2).", "id": "Diberikan n bilangan bulat positif yang mewakili jumlah masing-masing angka dari 1 hingga n, \ntemukan jumlah maksimum dari modus (elemen yang paling sering muncul) untuk semua awalan dari \nsebuah urutan yang dibangun dari angka-angka ini. Modus adalah angka terbesar di antara \nelemen-elemen yang paling sering muncul dalam sebuah urutan.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    Sebuah urutan yang mencapai nilai maksimumnya adalah (3,2,3,1,2,2).", "ja": "与えられた n 個の正の整数は、1 から n までの各数のカウントを表しています。これらの数から構成されるシーケンスのすべてのプレフィックスに対して、モード（最頻出要素）の最大合計を見つけます。モードは、シーケンス内の最頻出要素の中で最大の数です。\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    最大値に達するシーケンスは (3,2,3,1,2,2) です。", "ko": "주어진 n개의 양의 정수는 1부터 n까지의 각 숫자의 개수를 나타냅니다. \n이 숫자들로 구성된 시퀀스의 모든 접두사의 최빈값(가장 빈번한 요소)의 최대 합을 찾으세요. \n최빈값은 시퀀스에서 가장 빈번한 요소 중 가장 큰 숫자입니다.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    최대값에 도달하는 시퀀스는 (3,2,3,1,2,2)입니다.", "ml": "1 മുതൽ n വരെ ഓരോ സംഖ്യയുടെ എണ്ണത്തെ പ്രതിനിധീകരിക്കുന്ന n അനുകൂല സംഖ്യകൾ നൽകിയാൽ, \nഈ സംഖ്യകളിൽ നിന്ന് നിർമ്മിച്ച ഒരു ശ്രേണിയുടെ എല്ലാ മുൻഗാമികളുടെയും മോഡ് (ഏറ്റവും അധികം ആവർത്തിക്കുന്ന ഘടകം) \nപരമാവധി തുക കണ്ടെത്തുക. ഒരു ശ്രേണിയിലെ ഏറ്റവും അധികം ആവർത്തിക്കുന്ന ഘടകങ്ങളിൽ ഏറ്റവും വലിയ സംഖ്യയാണ് മോഡ്.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    ഏറ്റവും കൂടുതൽ മൂല്യത്തിൽ എത്തുന്ന ഒരു നിര (3,2,3,1,2,2) ആണ്.", "fa": "با توجه به n عدد صحیح مثبت که نشان‌دهنده تعداد هر عدد از 1 تا n هستند، \nبیشترین مجموع مد (عنصر پرتکرار) برای تمام پیشوندهای \nیک دنباله ساخته شده از این اعداد را پیدا کنید. مد بزرگترین عدد در میان \nعناصر پرتکرار در یک دنباله است.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    دنباله‌ای که به بیشترین مقدار خود می‌رسد (3,2,3,1,2,2) است."}}
{"task_id": "C/39", "prompt": {"en": "#include <assert.h>\n#include <stdio.h>\n/*\nGiven an array A of integers, the task is to calculate the sum of the XOR of all subarrays.\nA subarray is defined by a pair of indices (L, R) such that 1 <= L <= R <= n, where n is the size of the array.\nThe XOR sum of a subarray is the result of XORing all elements from L to R.\nThe final result is the sum of the XOR sums for all possible subarrays.\n\nExample cases:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39\n*/\nlong long sumOfXorSubarrays(int A[], int n)", "sq": "#include <assert.h>\n#include <stdio.h>\n/*\nDuke pasur një varg A të numrave të plotë, detyra është të llogaritet shuma e XOR-it të të gjitha nënvargjeve.\nNjë nënvarg është i përcaktuar nga një palë indeksesh (L, R) të tilla që 1 <= L <= R <= n, ku n është madhësia e vargut.\nShuma e XOR-it të një nënvargu është rezultati i XOR-it të të gjithë elementeve nga L në R.\nRezultati përfundimtar është shuma e shumave XOR për të gjitha nënvargjet e mundshme.\n\nRastet e shembullit:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39\n*/\nlong long sumOfXorSubarrays(int A[], int n)", "hy": "#include <assert.h>\n#include <stdio.h>\n/*\nՏրված է ամբողջ թվերի A զանգվածը, խնդիրն է հաշվարկել բոլոր ենթազանգվածների XOR-ի գումարը:\nԵնթազանգվածը սահմանվում է (L, R) ինդեքսների զույգով, այնպես որ 1 <= L <= R <= n, որտեղ n-ը զանգվածի չափն է:\nԵնթազանգվածի XOR-ի գումարը L-ից R բոլոր տարրերի XOR-ի արդյունքն է:\nՎերջնական արդյունքը բոլոր հնարավոր ենթազանգվածների համար XOR գումարների գումարն է:\n\nՕրինակ դեպքեր:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39\n*/\nlong long sumOfXorSubarrays(int A[], int n)", "bn": "#include <assert.h>\n#include <stdio.h>\n/*\nএকটি পূর্ণসংখ্যার অ্যারে A দেওয়া হয়েছে, কাজটি হল সমস্ত উপঅ্যারের XOR এর যোগফল গণনা করা।\nএকটি উপঅ্যারে একটি জোড়া সূচক (L, R) দ্বারা সংজ্ঞায়িত করা হয় যেখানে 1 <= L <= R <= n, যেখানে n হল অ্যারের আকার।\nএকটি উপঅ্যারের XOR যোগফল হল L থেকে R পর্যন্ত সমস্ত উপাদানের XOR এর ফলাফল।\nচূড়ান্ত ফলাফল হল সমস্ত সম্ভাব্য উপঅ্যারের জন্য XOR যোগফলের যোগফল।\n\nউদাহরণ কেস:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39\n*/\nlong long sumOfXorSubarrays(int A[], int n)", "bg": "#include <assert.h>\n#include <stdio.h>\n/*\nДаден е масив A от цели числа, задачата е да се изчисли сумата на XOR на всички подмасиви.\nПодмасив се определя от двойка индекси (L, R), такива че 1 <= L <= R <= n, където n е размерът на масива.\nXOR сумата на подмасив е резултатът от XOR на всички елементи от L до R.\nКрайният резултат е сумата от XOR сумите за всички възможни подмасиви.\n\nПримерни случаи:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39\n*/\nlong long sumOfXorSubarrays(int A[], int n)", "zh": "#include <assert.h>\n#include <stdio.h>\n/*\n给定一个整数数组A，任务是计算所有子数组的异或和的总和。\n子数组由一对索引(L, R)定义，其中1 <= L <= R <= n，n是数组的大小。\n子数组的异或和是从L到R的所有元素进行异或运算的结果。\n最终结果是所有可能子数组的异或和的总和。\n\n示例案例：\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39\n*/\nlong long sumOfXorSubarrays(int A[], int n)", "fr": "#include <assert.h>\n#include <stdio.h>\n/*\nÉtant donné un tableau A d'entiers, la tâche consiste à calculer la somme du XOR de tous les sous-tableaux.\nUn sous-tableau est défini par une paire d'indices (L, R) telle que 1 <= L <= R <= n, où n est la taille du tableau.\nLa somme XOR d'un sous-tableau est le résultat du XOR de tous les éléments de L à R.\nLe résultat final est la somme des sommes XOR pour tous les sous-tableaux possibles.\n\nExemples de cas :\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39\n*/\nlong long sumOfXorSubarrays(int A[], int n)", "de": "#include <assert.h>\n#include <stdio.h>\n/*\nGegeben ein Array A von ganzen Zahlen, besteht die Aufgabe darin, die Summe des XOR aller Teilarrays zu berechnen.\nEin Teilarray wird durch ein Paar von Indizes (L, R) definiert, so dass 1 <= L <= R <= n, wobei n die Größe des Arrays ist.\nDie XOR-Summe eines Teilarrays ist das Ergebnis des XORs aller Elemente von L bis R.\nDas Endergebnis ist die Summe der XOR-Summen für alle möglichen Teilarrays.\n\nBeispielhafte Fälle:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39\n*/\nlong long sumOfXorSubarrays(int A[], int n)", "ha": "#include <assert.h>\n#include <stdio.h>\n/*\nAn ba da wani tsari A na lambobin cikakke, aikin shi ne a ƙididdige jimillar XOR na dukkan ƙananan tsaruka.\nAna ayyana ƙaramin tsari ta hanyar ma'aurata na alamomin (L, R) inda 1 <= L <= R <= n, inda n shine girman tsari.\nJimillar XOR na ƙaramin tsari ita ce sakamakon XORing dukkan abubuwa daga L zuwa R.\nSakamakon ƙarshe shi ne jimillar XOR sums don dukkan yiwuwar ƙananan tsaruka.\n\nMisalan shari'o'i:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39\n*/\nlong long sumOfXorSubarrays(int A[], int n)", "hi": "#include <assert.h>\n#include <stdio.h>\n/*\nदिए गए पूर्णांकों की एक सरणी A के लिए, कार्य सभी उपसरणियों के XOR का योग गणना करना है।\nएक उपसरणी को (L, R) सूचकांक की एक जोड़ी द्वारा परिभाषित किया जाता है, जहाँ 1 <= L <= R <= n, जहाँ n सरणी का आकार है।\nएक उपसरणी का XOR योग L से R तक के सभी तत्वों का XOR करने का परिणाम है।\nअंतिम परिणाम सभी संभावित उपसरणियों के लिए XOR योगों का योग है।\n\nउदाहरण मामले:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39\n*/\nlong long sumOfXorSubarrays(int A[], int n)", "hu": "#include <assert.h>\n#include <stdio.h>\n/*\nAdott egy A egész számokat tartalmazó tömb, a feladat az összes részhalmaz XOR összegének kiszámítása.\nEgy részhalmazt egy (L, R) indexpár határoz meg, ahol 1 <= L <= R <= n, ahol n a tömb mérete.\nEgy részhalmaz XOR összege az eredmény, amelyet az L-től R-ig terjedő összes elem XOR-olásával kapunk.\nA végső eredmény az összes lehetséges részhalmaz XOR összegeinek összege.\n\nPélda esetek:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39\n*/\nlong long sumOfXorSubarrays(int A[], int n)", "es": "#include <assert.h>\n#include <stdio.h>\n/*\nDado un array A de enteros, la tarea es calcular la suma del XOR de todos los subarrays.\nUn subarray se define por un par de índices (L, R) tal que 1 <= L <= R <= n, donde n es el tamaño del array.\nLa suma XOR de un subarray es el resultado de aplicar XOR a todos los elementos desde L hasta R.\nEl resultado final es la suma de las sumas XOR para todos los subarrays posibles.\n\nCasos de ejemplo:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39\n*/\nlong long sumOfXorSubarrays(int A[], int n)", "arb": "#include <assert.h>\n#include <stdio.h>\n/*\nبالنظر إلى مصفوفة A من الأعداد الصحيحة، المهمة هي حساب مجموع XOR لجميع المقاطع الفرعية.\nيتم تعريف المقطع الفرعي بواسطة زوج من الفهارس (L, R) بحيث 1 <= L <= R <= n، حيث n هو حجم المصفوفة.\nمجموع XOR للمقطع الفرعي هو نتيجة XOR لجميع العناصر من L إلى R.\nالنتيجة النهائية هي مجموع نتائج XOR لجميع المقاطع الفرعية الممكنة.\n\nحالات المثال:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39\n*/\nlong long sumOfXorSubarrays(int A[], int n)", "sw": "#include <assert.h>\n#include <stdio.h>\n/*\nUkipiwa safu A ya nambari za mzima, kazi ni kuhesabu jumla ya XOR ya sehemu zote ndogo.\nSehemu ndogo inafafanuliwa na jozi ya fahirisi (L, R) ambapo 1 <= L <= R <= n, ambapo n ni ukubwa wa safu.\nJumla ya XOR ya sehemu ndogo ni matokeo ya XOR ya vipengele vyote kutoka L hadi R.\nMatokeo ya mwisho ni jumla ya XOR kwa sehemu ndogo zote zinazowezekana.\n\nMifano ya kesi:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39\n*/\nlong long sumOfXorSubarrays(int A[], int n)", "tr": "#include <assert.h>\n#include <stdio.h>\n/*\nBir tamsayı dizisi A verildiğinde, görev tüm alt dizilerin XOR toplamını hesaplamaktır.\nBir alt dizi, 1 <= L <= R <= n olacak şekilde (L, R) indeks çifti ile tanımlanır, burada n dizinin boyutudur.\nBir alt dizinin XOR toplamı, L'den R'ye kadar olan tüm elemanların XOR işlemi sonucudur.\nSonuç, tüm olası alt dizilerin XOR toplamlarının toplamıdır.\n\nÖrnek durumlar:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39\n*/\nlong long sumOfXorSubarrays(int A[], int n)", "vi": "#include <assert.h>\n#include <stdio.h>\n/*\nCho một mảng A gồm các số nguyên, nhiệm vụ là tính tổng của XOR của tất cả các mảng con.\nMột mảng con được định nghĩa bởi một cặp chỉ số (L, R) sao cho 1 <= L <= R <= n, trong đó n là kích thước của mảng.\nTổng XOR của một mảng con là kết quả của việc XOR tất cả các phần tử từ L đến R.\nKết quả cuối cùng là tổng của các tổng XOR cho tất cả các mảng con có thể.\n\nCác trường hợp ví dụ:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39\n*/\nlong long sumOfXorSubarrays(int A[], int n)", "id": "#include <assert.h>\n#include <stdio.h>\n/*\nDiberikan sebuah array A yang berisi bilangan bulat, tugasnya adalah menghitung jumlah XOR dari semua subarray.\nSebuah subarray didefinisikan oleh sepasang indeks (L, R) sehingga 1 <= L <= R <= n, di mana n adalah ukuran array.\nJumlah XOR dari sebuah subarray adalah hasil dari operasi XOR semua elemen dari L hingga R.\nHasil akhirnya adalah jumlah dari semua hasil XOR untuk semua subarray yang mungkin.\n\nContoh kasus:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39\n*/\nlong long sumOfXorSubarrays(int A[], int n)", "ja": "#include <assert.h>\n#include <stdio.h>\n/*\n整数の配列 A が与えられたとき、すべての部分配列の XOR の合計を計算することが課題です。\n部分配列は、1 <= L <= R <= n であるインデックスのペア (L, R) によって定義されます。ここで、n は配列のサイズです。\n部分配列の XOR 合計は、L から R までのすべての要素を XOR した結果です。\n最終結果は、可能なすべての部分配列の XOR 合計の合計です。\n\n例:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39\n*/\nlong long sumOfXorSubarrays(int A[], int n)", "ko": "#include <assert.h>\n#include <stdio.h>\n/*\n정수 배열 A가 주어졌을 때, 모든 부분 배열의 XOR 합을 계산하는 작업입니다.\n부분 배열은 인덱스 쌍 (L, R)에 의해 정의되며, 여기서 1 <= L <= R <= n이고, n은 배열의 크기입니다.\n부분 배열의 XOR 합은 L에서 R까지의 모든 요소를 XOR한 결과입니다.\n최종 결과는 가능한 모든 부분 배열에 대한 XOR 합의 합입니다.\n\n예시 사례:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39\n*/\nlong long sumOfXorSubarrays(int A[], int n)", "ml": "#include <assert.h>\n#include <stdio.h>\n/*\nഒരു പൂർണ്ണസംഖ്യകളുടെ നിരയായ A നൽകിയാൽ, എല്ലാ ഉപനിരകളുടെയും XOR യുടെ മൊത്തം കണക്കാക്കുകയാണ് പ്രവർത്തനം.\nഒരു ഉപനിര (L, R) എന്ന സൂചികകളുടെ ജോഡിയാൽ നിർവചിക്കപ്പെടുന്നു, 1 <= L <= R <= n, ഇവിടെ n ആണ് നിരയുടെ വലിപ്പം.\nഒരു ഉപനിരയുടെ XOR മൊത്തം L മുതൽ R വരെയുള്ള എല്ലാ മൂല്യങ്ങളും XOR ചെയ്യുന്നതിന്റെ ഫലമാണ്.\nഅവസാന ഫലം എല്ലാ സാധ്യതയുള്ള ഉപനിരകളുടെയും XOR മൊത്തങ്ങളുടെ മൊത്തമാണ്.\n\nഉദാഹരണ കേസുകൾ:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39\n*/\nlong long sumOfXorSubarrays(int A[], int n)", "fa": "#include <assert.h>\n#include <stdio.h>\n/*\nبا توجه به آرایه‌ای A از اعداد صحیح، وظیفه محاسبه مجموع XOR تمام زیرآرایه‌ها است.\nیک زیرآرایه با یک جفت شاخص (L, R) تعریف می‌شود به طوری که 1 <= L <= R <= n، که n اندازه آرایه است.\nمجموع XOR یک زیرآرایه نتیجه‌ی XOR کردن تمام عناصر از L تا R است.\nنتیجه نهایی مجموع مقادیر XOR برای تمام زیرآرایه‌های ممکن است.\n\nنمونه موارد:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39\n*/\nlong long sumOfXorSubarrays(int A[], int n)"}, "canonical_solution": "{\n    long long q[100010] = {0}, w[100010][2] = {{0}}, ans = 0;\n    for (int i = 1; i <= n; i++) q[i] = q[i - 1] ^ A[i - 1];\n    for (int i = 0; i <= n; i++)\n        for (int j = 20; j >= 0; j--)\n            w[j][(q[i] >> j) & 1]++;\n    for (int i = 0; i <= 20; i++)\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    return ans;\n}", "instruction": {"en": "long long sumOfXorSubarrays(int A[], int n)\n{\n    long long q[100010] = {0}, w[100010][2] = {{0}}, ans = 0;\n    for (int i = 1; i <= n; i++) q[i] = q[i - 1] ^ A[i - 1];\n    for (int i = 0; i <= n; i++)\n        for (int j = 20; j >= 0; j--)\n            w[j][(q[i] >> j) & 1]++;\n    for (int i = 0; i <= 20; i++)\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    return ans;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "sq": "long long sumOfXorSubarrays(int A[], int n)\n{\n    long long q[100010] = {0}, w[100010][2] = {{0}}, ans = 0;\n    for (int i = 1; i <= n; i++) q[i] = q[i - 1] ^ A[i - 1];\n    for (int i = 0; i <= n; i++)\n        for (int j = 20; j >= 0; j--)\n            w[j][(q[i] >> j) & 1]++;\n    for (int i = 0; i <= 20; i++)\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    return ans;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C në shqip duke përdorur maksimumi 500 karaktere.", "hy": "long long sumOfXorSubarrays(int A[], int n)\n{\n    long long q[100010] = {0}, w[100010][2] = {{0}}, ans = 0;\n    for (int i = 1; i <= n; i++) q[i] = q[i - 1] ^ A[i - 1];\n    for (int i = 0; i <= n; i++)\n        for (int j = 20; j >= 0; j--)\n            w[j][(q[i] >> j) & 1]++;\n    for (int i = 0; i <= 20; i++)\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    return ans;\n}\n\nՏվեք C կոդի հակիրճ բնութագրումը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "long long sumOfXorSubarrays(int A[], int n)\n{\n    long long q[100010] = {0}, w[100010][2] = {{0}}, ans = 0;\n    for (int i = 1; i <= n; i++) q[i] = q[i - 1] ^ A[i - 1];\n    for (int i = 0; i <= n; i++)\n        for (int j = 20; j >= 0; j--)\n            w[j][(q[i] >> j) & 1]++;\n    for (int i = 0; i <= 20; i++)\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    return ans;\n}\n\nসি কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।", "bg": "long long sumOfXorSubarrays(int A[], int n)\n{\n    long long q[100010] = {0}, w[100010][2] = {{0}}, ans = 0;\n    for (int i = 1; i <= n; i++) q[i] = q[i - 1] ^ A[i - 1];\n    for (int i = 0; i <= n; i++)\n        for (int j = 20; j >= 0; j--)\n            w[j][(q[i] >> j) & 1]++;\n    for (int i = 0; i <= 20; i++)\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    return ans;\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, използвайки най-много 500 знака.", "zh": "long long sumOfXorSubarrays(int A[], int n)\n{\n    long long q[100010] = {0}, w[100010][2] = {{0}}, ans = 0;\n    for (int i = 1; i <= n; i++) q[i] = q[i - 1] ^ A[i - 1];\n    for (int i = 0; i <= n; i++)\n        for (int j = 20; j >= 0; j--)\n            w[j][(q[i] >> j) & 1]++;\n    for (int i = 0; i <= 20; i++)\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    return ans;\n}\n\n请用最多500个字符的中文对该C代码提供简洁的自然语言描述（文档字符串）。", "fr": "long long sumOfXorSubarrays(int A[], int n)\n{\n    long long q[100010] = {0}, w[100010][2] = {{0}}, ans = 0;\n    for (int i = 1; i <= n; i++) q[i] = q[i - 1] ^ A[i - 1];\n    for (int i = 0; i <= n; i++)\n        for (int j = 20; j >= 0; j--)\n            w[j][(q[i] >> j) & 1]++;\n    for (int i = 0; i <= 20; i++)\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    return ans;\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.", "de": "long long sumOfXorSubarrays(int A[], int n)\n{\n    long long q[100010] = {0}, w[100010][2] = {{0}}, ans = 0;\n    for (int i = 1; i <= n; i++) q[i] = q[i - 1] ^ A[i - 1];\n    for (int i = 0; i <= n; i++)\n        for (int j = 20; j >= 0; j--)\n            w[j][(q[i] >> j) & 1]++;\n    for (int i = 0; i <= 20; i++)\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    return ans;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen.", "ha": "long long sumOfXorSubarrays(int A[], int n)\n{\n    long long q[100010] = {0}, w[100010][2] = {{0}}, ans = 0;\n    for (int i = 1; i <= n; i++) q[i] = q[i - 1] ^ A[i - 1];\n    for (int i = 0; i <= n; i++)\n        for (int j = 20; j >= 0; j--)\n            w[j][(q[i] >> j) & 1]++;\n    for (int i = 0; i <= 20; i++)\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    return ans;\n}\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar C a cikin Hausa ta amfani da haruffa 500 kacal.", "hi": "long long sumOfXorSubarrays(int A[], int n)\n{\n    long long q[100010] = {0}, w[100010][2] = {{0}}, ans = 0;\n    for (int i = 1; i <= n; i++) q[i] = q[i - 1] ^ A[i - 1];\n    for (int i = 0; i <= n; i++)\n        for (int j = 20; j >= 0; j--)\n            w[j][(q[i] >> j) & 1]++;\n    for (int i = 0; i <= 20; i++)\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    return ans;\n}\n\nC कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "long long sumOfXorSubarrays(int A[], int n)\n{\n    long long q[100010] = {0}, w[100010][2] = {{0}}, ans = 0;\n    for (int i = 1; i <= n; i++) q[i] = q[i - 1] ^ A[i - 1];\n    for (int i = 0; i <= n; i++)\n        for (int j = 20; j >= 0; j--)\n            w[j][(q[i] >> j) & 1]++;\n    for (int i = 0; i <= 20; i++)\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    return ans;\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben.", "es": "long long sumOfXorSubarrays(int A[], int n)\n{\n    long long q[100010] = {0}, w[100010][2] = {{0}}, ans = 0;\n    for (int i = 1; i <= n; i++) q[i] = q[i - 1] ^ A[i - 1];\n    for (int i = 0; i <= n; i++)\n        for (int j = 20; j >= 0; j--)\n            w[j][(q[i] >> j) & 1]++;\n    for (int i = 0; i <= 20; i++)\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    return ans;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando como máximo 500 caracteres.", "arb": "long long sumOfXorSubarrays(int A[], int n)\n{\n    long long q[100010] = {0}, w[100010][2] = {{0}}, ans = 0;\n    for (int i = 1; i <= n; i++) q[i] = q[i - 1] ^ A[i - 1];\n    for (int i = 0; i <= n; i++)\n        for (int j = 20; j >= 0; j--)\n            w[j][(q[i] >> j) & 1]++;\n    for (int i = 0; i <= 20; i++)\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    return ans;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "long long sumOfXorSubarrays(int A[], int n)\n{\n    long long q[100010] = {0}, w[100010][2] = {{0}}, ans = 0;\n    for (int i = 1; i <= n; i++) q[i] = q[i - 1] ^ A[i - 1];\n    for (int i = 0; i <= n; i++)\n        for (int j = 20; j >= 0; j--)\n            w[j][(q[i] >> j) & 1]++;\n    for (int i = 0; i <= 20; i++)\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    return ans;\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "long long sumOfXorSubarrays(int A[], int n)\n{\n    long long q[100010] = {0}, w[100010][2] = {{0}}, ans = 0;\n    for (int i = 1; i <= n; i++) q[i] = q[i - 1] ^ A[i - 1];\n    for (int i = 0; i <= n; i++)\n        for (int j = 20; j >= 0; j--)\n            w[j][(q[i] >> j) & 1]++;\n    for (int i = 0; i <= 20; i++)\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    return ans;\n}\n\nC kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe olarak yazılmalıdır.", "vi": "long long sumOfXorSubarrays(int A[], int n)\n{\n    long long q[100010] = {0}, w[100010][2] = {{0}}, ans = 0;\n    for (int i = 1; i <= n; i++) q[i] = q[i - 1] ^ A[i - 1];\n    for (int i = 0; i <= n; i++)\n        for (int j = 20; j >= 0; j--)\n            w[j][(q[i] >> j) & 1]++;\n    for (int i = 0; i <= 20; i++)\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    return ans;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã C bằng tiếng Việt, không quá 500 ký tự.", "id": "long long sumOfXorSubarrays(int A[], int n)\n{\n    long long q[100010] = {0}, w[100010][2] = {{0}}, ans = 0;\n    for (int i = 1; i <= n; i++) q[i] = q[i - 1] ^ A[i - 1];\n    for (int i = 0; i <= n; i++)\n        for (int j = 20; j >= 0; j--)\n            w[j][(q[i] >> j) & 1]++;\n    for (int i = 0; i <= 20; i++)\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    return ans;\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode C dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "long long sumOfXorSubarrays(int A[], int n)\n{\n    long long q[100010] = {0}, w[100010][2] = {{0}}, ans = 0;\n    for (int i = 1; i <= n; i++) q[i] = q[i - 1] ^ A[i - 1];\n    for (int i = 0; i <= n; i++)\n        for (int j = 20; j >= 0; j--)\n            w[j][(q[i] >> j) & 1]++;\n    for (int i = 0; i <= 20; i++)\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    return ans;\n}\n\nCコードの内容を日本語で簡潔に説明するドキュメンテーションストリング（docstring）を500文字以内で提供してください。", "ko": "long long sumOfXorSubarrays(int A[], int n)\n{\n    long long q[100010] = {0}, w[100010][2] = {{0}}, ans = 0;\n    for (int i = 1; i <= n; i++) q[i] = q[i - 1] ^ A[i - 1];\n    for (int i = 0; i <= n; i++)\n        for (int j = 20; j >= 0; j--)\n            w[j][(q[i] >> j) & 1]++;\n    for (int i = 0; i <= 20; i++)\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    return ans;\n}\n\nC 코드에 대한 간결한 자연어 설명(문서 문자열)을 한국어로 최대 500자 이내로 제공하세요.", "ml": "long long sumOfXorSubarrays(int A[], int n)\n{\n    long long q[100010] = {0}, w[100010][2] = {{0}}, ans = 0;\n    for (int i = 1; i <= n; i++) q[i] = q[i - 1] ^ A[i - 1];\n    for (int i = 0; i <= n; i++)\n        for (int j = 20; j >= 0; j--)\n            w[j][(q[i] >> j) & 1]++;\n    for (int i = 0; i <= 20; i++)\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    return ans;\n}\n\nC കോഡ് ഉപയോഗിച്ച് 500 അക്ഷരങ്ങളിൽ കൂടുതൽ അല്ലാത്ത വിധത്തിൽ മലയാളത്തിൽ സംക്ഷിപ്തമായ ഒരു സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) നൽകുക.", "fa": "long long sumOfXorSubarrays(int A[], int n)\n{\n    long long q[100010] = {0}, w[100010][2] = {{0}}, ans = 0;\n    for (int i = 1; i <= n; i++) q[i] = q[i - 1] ^ A[i - 1];\n    for (int i = 0; i <= n; i++)\n        for (int j = 20; j >= 0; j--)\n            w[j][(q[i] >> j) & 1]++;\n    for (int i = 0; i <= 20; i++)\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    return ans;\n}\n\nیک توضیح مختصر به زبان طبیعی (docstring) از کد C به زبان فارسی ارائه دهید که حداکثر ۵۰۰ کاراکتر باشد."}, "level": "", "test": "int main() {\n    int test[] = {1,2, 3, 4, 5};\n    assert(sumOfXorSubarrays(test, 5) == 39);\n    int test1[] = {1, 1, 1};\n    assert(sumOfXorSubarrays(test1, 3) == 4);\n    \n    int test2[] = {2, 3, 1};\n    assert(sumOfXorSubarrays(test2, 3) == 9);\n    \n    int test3[] = {4, 5, 7, 9};\n    assert(sumOfXorSubarrays(test3, 4) == 74);\n    \n    int test4[] = {0, 0, 0, 0};\n    assert(sumOfXorSubarrays(test4, 4) == 0);\n    \n    int test5[] = {8, 8, 8, 8, 8};\n    assert(sumOfXorSubarrays(test5, 5) == 72);\n    \n    int test6[] = {3, 6, 9, 12, 15};\n    assert(sumOfXorSubarrays(test6, 5) == 125);\n    \n    int test7[] = {10, 20, 30, 40, 50};\n    assert(sumOfXorSubarrays(test7, 5) == 390);\n    \n    int test8[] = {16, 16, 16, 16, 16, 16};\n    assert(sumOfXorSubarrays(test8, 6) == 192);\n    \n    int test9[] = {1, 3, 5, 7, 9, 11, 13};\n    assert(sumOfXorSubarrays(test9, 7) == 192);\n    \n    int test10[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n    assert(sumOfXorSubarrays(test10, 10) == 218);\n    \n    return 0;\n}", "entry_point": "sumOfXorSubarrays", "signature": "long long sumOfXorSubarrays(int A[], int n)", "docstring": {"en": "Given an array A of integers, the task is to calculate the sum of the XOR of all subarrays.\nA subarray is defined by a pair of indices (L, R) such that 1 <= L <= R <= n, where n is the size of the array.\nThe XOR sum of a subarray is the result of XORing all elements from L to R.\nThe final result is the sum of the XOR sums for all possible subarrays.\n\nExample cases:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39\n", "sq": "Duke pasur një varg A të numrave të plotë, detyra është të llogaritet shuma e XOR-it të të gjitha nënvargjeve.\nNjë nënvarg përcaktohet nga një çift indeksesh (L, R) të tilla që 1 <= L <= R <= n, ku n është madhësia e vargut.\nShuma XOR e një nënvargu është rezultati i XOR-it të të gjithë elementeve nga L deri në R.\nRezultati përfundimtar është shuma e shumave XOR për të gjitha nënvargjet e mundshme.\n\nRastet e shembullit:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39", "hy": "Տրված է ամբողջ թվերի A զանգվածը, խնդիրը բոլոր ենթազանգվածների XOR-ի գումարը հաշվարկելն է:\nԵնթազանգվածը սահմանվում է (L, R) ինդեքսների զույգով, այնպես որ 1 <= L <= R <= n, որտեղ n-ը զանգվածի չափն է:\nԵնթազանգվածի XOR-ի գումարը L-ից R բոլոր տարրերի XOR-ի արդյունքն է:\nՎերջնական արդյունքը բոլոր հնարավոր ենթազանգվածների XOR-ի գումարների գումարն է:\n\nՕրինակ դեպքեր:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39", "bn": "একটি পূর্ণসংখ্যার অ্যারে A দেওয়া হয়েছে, কাজটি হল সমস্ত উপঅ্যারের XOR এর যোগফল গণনা করা।\nএকটি উপঅ্যারে একটি জোড়া সূচক (L, R) দ্বারা সংজ্ঞায়িত করা হয় যেখানে 1 <= L <= R <= n, যেখানে n হল অ্যারের আকার।\nএকটি উপঅ্যারের XOR যোগফল হল L থেকে R পর্যন্ত সমস্ত উপাদানের XOR এর ফলাফল।\nচূড়ান্ত ফলাফল হল সমস্ত সম্ভাব্য উপঅ্যারের জন্য XOR যোগফলের যোগফল।\n\nউদাহরণ কেস:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39", "bg": "Даден е масив A от цели числа, задачата е да се изчисли сумата от XOR на всички подмасиви. Подмасив се дефинира чрез двойка индекси (L, R), така че 1 <= L <= R <= n, където n е размерът на масива. XOR сумата на подмасив е резултатът от XOR на всички елементи от L до R. Крайният резултат е сумата от XOR сумите за всички възможни подмасиви.\n\nПримерни случаи:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39", "zh": "给定一个整数数组 A，任务是计算所有子数组的异或和之和。  \n子数组由一对索引 (L, R) 定义，其中 1 <= L <= R <= n，n 是数组的大小。  \n子数组的异或和是从 L 到 R 的所有元素的异或结果。  \n最终结果是所有可能子数组的异或和之和。\n\n示例案例：\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39", "fr": "Étant donné un tableau A d'entiers, la tâche consiste à calculer la somme du XOR de tous les sous-tableaux.  \nUn sous-tableau est défini par une paire d'indices (L, R) telle que 1 <= L <= R <= n, où n est la taille du tableau.  \nLa somme XOR d'un sous-tableau est le résultat du XOR de tous les éléments de L à R.  \nLe résultat final est la somme des sommes XOR pour tous les sous-tableaux possibles.\n\nCas d'exemple:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39", "de": "Gegeben ein Array A von ganzen Zahlen, besteht die Aufgabe darin, die Summe des XOR aller Teilarrays zu berechnen. Ein Teilarray wird durch ein Paar von Indizes (L, R) definiert, so dass 1 <= L <= R <= n, wobei n die Größe des Arrays ist. Die XOR-Summe eines Teilarrays ist das Ergebnis des XORs aller Elemente von L bis R. Das Endergebnis ist die Summe der XOR-Summen für alle möglichen Teilarrays.\n\nBeispiel Fälle:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39", "ha": "An ba da jerin A na lambobin cikakke, aikin shi ne lissafin jimillar XOR na dukkan ƙananan jerin.\nAna ayyana ƙaramin jeri ta hanyar ma'aurata na alamomi (L, R) ta yadda 1 <= L <= R <= n, inda n shine girman jerin.\nJimillar XOR na ƙaramin jeri shine sakamakon XORing dukkan abubuwa daga L zuwa R.\nSakamakon ƙarshe shine jimillar jimillan XOR don dukkan yiwuwar ƙananan jerin.\n\nMisalan lamura:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39", "hi": "दिए गए पूर्णांकों के एक array A के लिए, कार्य सभी उप-समुच्चयों के XOR का योग गणना करना है। एक उप-समुच्चय को (L, R) सूचकांकों की एक जोड़ी द्वारा परिभाषित किया जाता है, जिससे 1 <= L <= R <= n, जहाँ n array का आकार है। एक उप-समुच्चय का XOR योग L से R तक के सभी तत्वों का XOR करने का परिणाम है। अंतिम परिणाम सभी संभव उप-समुच्चयों के लिए XOR योगों का योग है।\n\nउदाहरण मामले:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39", "hu": "Adott egy A egész számokat tartalmazó tömb, a feladat az összes részhalmaz XOR összegének kiszámítása.\nEgy részhalmazt egy (L, R) indexpár határoz meg, ahol 1 <= L <= R <= n, ahol n a tömb mérete.\nEgy részhalmaz XOR összege az L-től R-ig terjedő elemek XOR-olásának eredménye.\nA végső eredmény az összes lehetséges részhalmaz XOR összegeinek összege.\n\nPélda esetek:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39", "es": "Dado un array A de enteros, la tarea es calcular la suma del XOR de todos los subarrays.  \nUn subarray se define por un par de índices (L, R) tal que 1 <= L <= R <= n, donde n es el tamaño del array.  \nLa suma XOR de un subarray es el resultado de aplicar XOR a todos los elementos desde L hasta R.  \nEl resultado final es la suma de las sumas XOR para todos los subarrays posibles.\n\nCasos de ejemplo:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39", "arb": "معطى مصفوفة A من الأعداد الصحيحة، المهمة هي حساب مجموع XOR لجميع القطع الفرعية.\nيتم تعريف القطعة الفرعية بواسطة زوج من الفهارس (L, R) بحيث 1 <= L <= R <= n، حيث n هو حجم المصفوفة.\nمجموع XOR للقطعة الفرعية هو نتيجة XOR لجميع العناصر من L إلى R.\nالنتيجة النهائية هي مجموع نتائج XOR لجميع القطع الفرعية الممكنة.\n\nأمثلة الحالات:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39", "sw": "Kwa kupewa safu A ya nambari za mzima, kazi ni kuhesabu jumla ya XOR ya sehemu ndogo zote za safu hiyo. \nSehemu ndogo ya safu inafafanuliwa na jozi ya faharasa (L, R) ambapo 1 <= L <= R <= n, ambapo n ni ukubwa wa safu. \nJumla ya XOR ya sehemu ndogo ya safu ni matokeo ya kufanya XOR kwa vipengele vyote kutoka L hadi R. \nMatokeo ya mwisho ni jumla ya jumla za XOR kwa sehemu ndogo zote zinazowezekana.\n\nMifano ya kesi:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39", "tr": "Verilen bir tamsayı dizisi A için, tüm alt dizilerin XOR toplamını hesaplama görevi.\nBir alt dizi, (L, R) indeks çifti ile tanımlanır ve burada 1 <= L <= R <= n, n dizinin boyutudur.\nBir alt dizinin XOR toplamı, L'den R'ye kadar olan tüm elemanların XOR işlemi sonucudur.\nSonuç, tüm olası alt dizilerin XOR toplamlarının toplamıdır.\n\nÖrnek durumlar:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39", "vi": "Cho một mảng A gồm các số nguyên, nhiệm vụ là tính tổng của XOR của tất cả các mảng con.  \nMột mảng con được định nghĩa bởi một cặp chỉ số (L, R) sao cho 1 <= L <= R <= n, trong đó n là kích thước của mảng.  \nTổng XOR của một mảng con là kết quả của việc XOR tất cả các phần tử từ L đến R.  \nKết quả cuối cùng là tổng của các tổng XOR cho tất cả các mảng con có thể.  \n\nCác trường hợp ví dụ:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39", "id": "Diberikan sebuah array A dari bilangan bulat, tugasnya adalah menghitung jumlah dari XOR semua subarray.  \nSebuah subarray didefinisikan oleh sepasang indeks (L, R) sedemikian rupa sehingga 1 <= L <= R <= n, di mana n adalah ukuran array.  \nJumlah XOR dari sebuah subarray adalah hasil dari XOR semua elemen dari L hingga R.  \nHasil akhirnya adalah jumlah dari semua jumlah XOR untuk semua subarray yang mungkin.\n\nContoh kasus:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39", "ja": "整数の配列 A が与えられたとき、すべての部分配列の XOR の合計を計算することが課題です。\n部分配列は、配列のサイズを n としたとき、1 <= L <= R <= n を満たすインデックスのペア (L, R) によって定義されます。\n部分配列の XOR 合計は、L から R までのすべての要素を XOR した結果です。\n最終的な結果は、可能なすべての部分配列の XOR 合計の合計です。\n\n例:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39", "ko": "정수 배열 A가 주어졌을 때, 모든 부분 배열의 XOR 합을 계산하는 작업입니다. 부분 배열은 인덱스 쌍 (L, R)에 의해 정의되며, 여기서 1 <= L <= R <= n이고, n은 배열의 크기입니다. 부분 배열의 XOR 합은 L에서 R까지의 모든 요소를 XOR한 결과입니다. 최종 결과는 가능한 모든 부분 배열에 대한 XOR 합의 합입니다.\n\n예제 경우:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39", "ml": "Integer കളുടെ ഒരു നിരയായ A ലഭിച്ചാൽ, എല്ലാ ഉപനിരകളുടെയും XOR ന്റെ മൊത്തം കൂട്ടം കണക്കാക്കുക എന്നതാണ് ഈ പ്രവർത്തിയുടെ ലക്ഷ്യം. ഒരു ഉപനിരയെ (L, R) എന്ന സൂചികകളുടെ ഒരു ജോഡി കൊണ്ട് നിർവ്വചിക്കുന്നു, ഇവിടെ 1 <= L <= R <= n, n ആണ് നിരയുടെ വലിപ്പം. ഒരു ഉപനിരയുടെ XOR കൂട്ടം L മുതൽ R വരെ ഉള്ള എല്ലാ മൂല്യങ്ങളും XOR ചെയ്യുന്നതിന്റെ ഫലമാണ്. എല്ലാ സാധ്യതയുള്ള ഉപനിരകളുടെയും XOR കൂട്ടങ്ങളുടെ മൊത്തം ഫലമാണ് അന്തിമ ഫലം.\n\nഉദാഹരണ കേസുകൾ:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39", "fa": "با توجه به آرایه A از اعداد صحیح، وظیفه این است که مجموع XOR تمام زیرآرایه‌ها را محاسبه کنیم.  \nیک زیرآرایه با یک جفت شاخص (L, R) تعریف می‌شود به طوری که 1 <= L <= R <= n، که n اندازه آرایه است.  \nمجموع XOR یک زیرآرایه نتیجه XOR کردن تمام عناصر از L تا R است.  \nنتیجه نهایی مجموع مقادیر XOR برای تمام زیرآرایه‌های ممکن است.\n\nموارد مثال:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39"}}
{"task_id": "C/40", "prompt": {"en": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n/*\nGiven two positive integers n and k, find the number of positive integers x, where 1 <= x <= n, that can be expressed as x = a^b with a and b being positive integers and b >= k.\nDifferent legal representations of the same number are counted only once.\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nint countPowerNumbers(int n, int k)", "sq": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n/*\nDuke pasur dy numra të plotë pozitivë n dhe k, gjeni numrin e numrave të plotë pozitivë x, ku 1 <= x <= n, që mund të shprehen si x = a^b me a dhe b që janë numra të plotë pozitivë dhe b >= k.\nPërfaqësimet e ndryshme të ligjshme të të njëjtit numër numërohen vetëm një herë.\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nint countPowerNumbers(int n, int k)", "hy": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n/*\nՏրված են n և k դրական ամբողջ թվերը, գտնել դրական ամբողջ թվերի քանակը x, որտեղ 1 <= x <= n, որոնք կարող են արտահայտվել որպես x = a^b, որտեղ a և b դրական ամբողջ թվեր են և b >= k:\nՆույն թվի տարբեր օրինական ներկայացումները հաշվում են միայն մեկ անգամ:\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nint countPowerNumbers(int n, int k)", "bn": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n/*\nদুটি ধনাত্মক পূর্ণসংখ্যা n এবং k দেওয়া আছে, ধনাত্মক পূর্ণসংখ্যা x-এর সংখ্যা খুঁজে বের করুন, যেখানে 1 <= x <= n, যা x = a^b আকারে প্রকাশ করা যায় এবং a এবং b ধনাত্মক পূর্ণসংখ্যা এবং b >= k।\nএকই সংখ্যার বিভিন্ন বৈধ উপস্থাপনাকে শুধুমাত্র একবার গণনা করা হয়।\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nint countPowerNumbers(int n, int k)", "bg": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n/*\nДадени са две положителни цели числа n и k, намерете броя на положителните цели числа x, където 1 <= x <= n, които могат да бъдат изразени като x = a^b с a и b, които са положителни цели числа и b >= k.\nРазличните легални представяния на едно и също число се броят само веднъж.\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nint countPowerNumbers(int n, int k)", "zh": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n/*\n给定两个正整数 n 和 k，找到满足 1 <= x <= n 的正整数 x 的数量，使得 x 可以表示为 x = a^b，其中 a 和 b 是正整数且 b >= k。\n同一个数字的不同合法表示只计数一次。\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nint countPowerNumbers(int n, int k)", "fr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n/*\nÉtant donné deux entiers positifs n et k, trouvez le nombre d'entiers positifs x, où 1 <= x <= n, qui peuvent être exprimés comme x = a^b avec a et b étant des entiers positifs et b >= k.\nLes différentes représentations légales du même nombre sont comptées une seule fois.\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nint countPowerNumbers(int n, int k)", "de": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n/*\nGegeben zwei positive ganze Zahlen n und k, finde die Anzahl der positiven ganzen Zahlen x, wobei 1 <= x <= n, die als x = a^b ausgedrückt werden können, wobei a und b positive ganze Zahlen sind und b >= k.\nVerschiedene zulässige Darstellungen derselben Zahl werden nur einmal gezählt.\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nint countPowerNumbers(int n, int k)", "ha": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n/*\nAn ba lambobi masu kyau guda biyu n da k, nemo adadin lambobi masu kyau x, inda 1 <= x <= n, waɗanda za a iya bayyana su a matsayin x = a^b tare da a da b suna kasancewa lambobi masu kyau kuma b >= k.\nAna ƙidaya wakilcin doka daban-daban na lamba ɗaya sau ɗaya kawai.\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nint countPowerNumbers(int n, int k)", "hi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n/*\nदो धनात्मक पूर्णांक n और k दिए गए हैं, उन धनात्मक पूर्णांकों x की संख्या ज्ञात करें, जहाँ 1 <= x <= n, जिन्हें x = a^b के रूप में व्यक्त किया जा सकता है, जहाँ a और b धनात्मक पूर्णांक हैं और b >= k है।\nएक ही संख्या के विभिन्न वैध अभ्यावेदन को केवल एक बार गिना जाता है।\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nint countPowerNumbers(int n, int k)", "hu": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n/*\nKét pozitív egész szám, n és k esetén, találjuk meg azon pozitív egész számok x számát, ahol 1 <= x <= n, és amelyek kifejezhetők x = a^b formában, ahol a és b pozitív egész számok és b >= k.\nUgyanazon szám különböző érvényes ábrázolásai csak egyszer számítanak.\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nint countPowerNumbers(int n, int k)", "es": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n/*\nDado dos enteros positivos n y k, encuentra el número de enteros positivos x, donde 1 <= x <= n, que pueden expresarse como x = a^b con a y b siendo enteros positivos y b >= k.\nDiferentes representaciones legales del mismo número se cuentan solo una vez.\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nint countPowerNumbers(int n, int k)", "arb": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n/*\nبالنظر إلى عددين صحيحين موجبين n و k، جد عدد الأعداد الصحيحة الموجبة x، حيث 1 <= x <= n، التي يمكن التعبير عنها كـ x = a^b مع كون a و b عددين صحيحين موجبين و b >= k.\nيتم احتساب التمثيلات القانونية المختلفة لنفس الرقم مرة واحدة فقط.\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nint countPowerNumbers(int n, int k)", "sw": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n/*\nUkipiwa nambari mbili nzima chanya n na k, pata idadi ya nambari chanya x, ambapo 1 <= x <= n, ambazo zinaweza kuonyeshwa kama x = a^b huku a na b wakiwa nambari nzima chanya na b >= k.\nMwakilishi tofauti halali wa nambari sawa huhesabiwa mara moja tu.\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nint countPowerNumbers(int n, int k)", "tr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n/*\nİki pozitif tam sayı n ve k verildiğinde, 1 <= x <= n aralığında, x = a^b şeklinde ifade edilebilen pozitif tam sayı x'lerin sayısını bulun. Burada a ve b pozitif tam sayılar ve b >= k.\nAynı sayının farklı yasal temsilleri yalnızca bir kez sayılır.\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nint countPowerNumbers(int n, int k)", "vi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n/*\nCho hai số nguyên dương n và k, tìm số lượng số nguyên dương x, với 1 <= x <= n, có thể được biểu diễn dưới dạng x = a^b với a và b là các số nguyên dương và b >= k.\nCác biểu diễn hợp lệ khác nhau của cùng một số chỉ được đếm một lần.\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nint countPowerNumbers(int n, int k)", "id": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n/*\nDiberikan dua bilangan bulat positif n dan k, temukan jumlah bilangan bulat positif x, di mana 1 <= x <= n, yang dapat dinyatakan sebagai x = a^b dengan a dan b adalah bilangan bulat positif dan b >= k.\nRepresentasi legal yang berbeda dari angka yang sama hanya dihitung sekali.\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nint countPowerNumbers(int n, int k)", "ja": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n/*\n2つの正の整数nとkが与えられたとき、1 <= x <= nの範囲で、x = a^bとして表現できる正の整数xの数を求めます。ただし、aとbは正の整数であり、b >= kです。\n同じ数の異なる合法的な表現は一度だけカウントされます。\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nint countPowerNumbers(int n, int k)", "ko": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n/*\n두 개의 양의 정수 n과 k가 주어졌을 때, 1 <= x <= n 범위의 양의 정수 x 중에서 x = a^b 형태로 표현될 수 있는 수의 개수를 찾으시오. 여기서 a와 b는 양의 정수이며 b >= k입니다.\n같은 수의 다른 합법적인 표현은 한 번만 계산됩니다.\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nint countPowerNumbers(int n, int k)", "ml": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n/*\nരണ്ട് പോസിറ്റീവ് ഇന്റിജറുകൾ n, k എന്നിവ നൽകിയാൽ, 1 <= x <= n എന്നതിനുള്ള പോസിറ്റീവ് ഇന്റിജറുകൾ x എത്രയാണെന്ന് കണ്ടെത്തുക, അവ x = a^b എന്ന രൂപത്തിൽ പ്രകടിപ്പിക്കാവുന്നതാണ്, ഇവിടെ a, b പോസിറ്റീവ് ഇന്റിജറുകളാണ്, b >= k.\nഅതേ സംഖ്യയുടെ വ്യത്യസ്ത നിയമാനുസൃത പ്രതിനിധാനങ്ങൾ ഒരിക്കൽ മാത്രം എണ്ണപ്പെടുന്നു.\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nint countPowerNumbers(int n, int k)", "fa": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n/*\nبا داشتن دو عدد صحیح مثبت n و k، تعداد اعداد صحیح مثبت x را بیابید، به طوری که 1 <= x <= n، که می‌توان آن را به صورت x = a^b بیان کرد که a و b اعداد صحیح مثبت هستند و b >= k.\nنمایش‌های قانونی مختلف از یک عدد مشابه فقط یک بار شمارش می‌شوند.\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nint countPowerNumbers(int n, int k)"}, "canonical_solution": "{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += (int)sqrt(n) - x;\n    }\n    free(mp);\n    return count;\n}", "instruction": {"en": "int countPowerNumbers(int n, int k)\n{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += (int)sqrt(n) - x;\n    }\n    free(mp);\n    return count;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "sq": "int countPowerNumbers(int n, int k)\n{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += (int)sqrt(n) - x;\n    }\n    free(mp);\n    return count;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C në gjuhën shqipe duke përdorur maksimumi 500 karaktere.", "hy": "int countPowerNumbers(int n, int k)\n{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += (int)sqrt(n) - x;\n    }\n    free(mp);\n    return count;\n}\n\nՏվեք C կոդի հակիրճ բնութագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։", "bn": "int countPowerNumbers(int n, int k)\n{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += (int)sqrt(n) - x;\n    }\n    free(mp);\n    return count;\n}\n\nসি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।", "bg": "int countPowerNumbers(int n, int k)\n{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += (int)sqrt(n) - x;\n    }\n    free(mp);\n    return count;\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, използвайки не повече от 500 знака.", "zh": "int countPowerNumbers(int n, int k)\n{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += (int)sqrt(n) - x;\n    }\n    free(mp);\n    return count;\n}\n\n请用不超过500个字符的中文，为以下C代码提供简洁的自然语言描述（文档字符串）。", "fr": "int countPowerNumbers(int n, int k)\n{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += (int)sqrt(n) - x;\n    }\n    free(mp);\n    return count;\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.", "de": "int countPowerNumbers(int n, int k)\n{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += (int)sqrt(n) - x;\n    }\n    free(mp);\n    return count;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen.", "ha": "int countPowerNumbers(int n, int k)\n{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += (int)sqrt(n) - x;\n    }\n    free(mp);\n    return count;\n}\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar C cikin Hausa ta amfani da haruffa 500 ko ƙasa da haka.", "hi": "int countPowerNumbers(int n, int k)\n{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += (int)sqrt(n) - x;\n    }\n    free(mp);\n    return count;\n}\n\nC कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।", "hu": "int countPowerNumbers(int n, int k)\n{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += (int)sqrt(n) - x;\n    }\n    free(mp);\n    return count;\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben.", "es": "int countPowerNumbers(int n, int k)\n{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += (int)sqrt(n) - x;\n    }\n    free(mp);\n    return count;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando como máximo 500 caracteres.", "arb": "int countPowerNumbers(int n, int k)\n{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += (int)sqrt(n) - x;\n    }\n    free(mp);\n    return count;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "int countPowerNumbers(int n, int k)\n{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += (int)sqrt(n) - x;\n    }\n    free(mp);\n    return count;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "int countPowerNumbers(int n, int k)\n{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += (int)sqrt(n) - x;\n    }\n    free(mp);\n    return count;\n}\n\nC kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe olarak yazılmalıdır.", "vi": "int countPowerNumbers(int n, int k)\n{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += (int)sqrt(n) - x;\n    }\n    free(mp);\n    return count;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã C bằng tiếng Việt, sử dụng tối đa 500 ký tự.", "id": "int countPowerNumbers(int n, int k)\n{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += (int)sqrt(n) - x;\n    }\n    free(mp);\n    return count;\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode C dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "int countPowerNumbers(int n, int k)\n{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += (int)sqrt(n) - x;\n    }\n    free(mp);\n    return count;\n}\n\nCコードの内容を500文字以内で日本語の自然言語による説明（ドックストリング）を提供してください。", "ko": "int countPowerNumbers(int n, int k)\n{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += (int)sqrt(n) - x;\n    }\n    free(mp);\n    return count;\n}\n\nC 코드의 동작을 설명하는 간결한 자연어 설명(docstring)을 한국어로 작성하되, 최대 500자 이내로 작성하세요.", "ml": "int countPowerNumbers(int n, int k)\n{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += (int)sqrt(n) - x;\n    }\n    free(mp);\n    return count;\n}\n\nസിയുടെ കോഡ്‌ക്ക് 500 അക്ഷരങ്ങളിൽ കവിയാത്ത മലയാളത്തിൽ സംക്ഷിപ്തമായ ഒരു സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) നൽകുക.", "fa": "int countPowerNumbers(int n, int k)\n{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += (int)sqrt(n) - x;\n    }\n    free(mp);\n    return count;\n}\n\nتوضیح مختصر و طبیعی (docstring) از کد C را به زبان فارسی با حداکثر ۵۰۰ کاراکتر ارائه دهید."}, "level": "", "test": "int main() {\n    assert(countPowerNumbers(99, 1) == 99);\n    assert(countPowerNumbers(99, 3) == 7);\n    assert(countPowerNumbers(99, 2) == 12);\n    assert(countPowerNumbers(10, 1) == 10);\n    assert(countPowerNumbers(10, 2) == 4);\n    assert(countPowerNumbers(500, 1) == 500);\n    assert(countPowerNumbers(500, 2) == 30);\n    assert(countPowerNumbers(500, 3) == 13);\n    assert(countPowerNumbers(1000, 1) == 1000);\n    assert(countPowerNumbers(1000, 2) == 41);\n    assert(countPowerNumbers(1000, 3) == 17);\n    assert(countPowerNumbers(1000, 93) == 1);\n    assert(countPowerNumbers(50, 2) == 10);\n    assert(countPowerNumbers(50, 3) == 5);\n    assert(countPowerNumbers(2, 3) == 1);\n    return 0;\n}", "entry_point": "countPowerNumbers", "signature": "int countPowerNumbers(int n, int k)", "docstring": {"en": "Given two positive integers n and k, find the number of positive integers x, where 1 <= x <= n, that can be expressed as x = a^b with a and b being positive integers and b >= k.\nDifferent legal representations of the same number are counted only once.\n    >>> countPowerNumbers(99, 1)\n    99\n", "sq": "Duke pasur dy numra të plotë pozitivë n dhe k, gjeni numrin e numrave të plotë pozitivë x, ku 1 <= x <= n, që mund të shprehen si x = a^b me a dhe b që janë numra të plotë pozitivë dhe b >= k. Përfaqësimet e ndryshme ligjore të të njëjtit numër numërohen vetëm një herë.\n    >>> countPowerNumbers(99, 1)\n    99", "hy": "Տրված երկու դրական ամբողջ թիվ n և k, գտնել դրական ամբողջ թվերի x քանակը, որտեղ 1 <= x <= n, որոնք կարող են արտահայտվել որպես x = a^b, որտեղ a և b դրական ամբողջ թվեր են և b >= k:\nՆույն թվի տարբեր օրինական ներկայացումները հաշվում են միայն մեկ անգամ:\n    >>> countPowerNumbers(99, 1)\n    99", "bn": "দুটি ধনাত্মক পূর্ণসংখ্যা n এবং k দেওয়া আছে, ধনাত্মক পূর্ণসংখ্যা x-এর সংখ্যা খুঁজে বের করুন, যেখানে 1 <= x <= n, যা x = a^b হিসাবে প্রকাশ করা যায় যেখানে a এবং b ধনাত্মক পূর্ণসংখ্যা এবং b >= k। একই সংখ্যার বিভিন্ন বৈধ উপস্থাপনাগুলি কেবল একবার গণনা করা হয়।\n    >>> countPowerNumbers(99, 1)\n    99", "bg": "Дадени са две положителни цели числа n и k, намерете броя на положителните цели числа x, където 1 <= x <= n, които могат да бъдат изразени като x = a^b с a и b като положителни цели числа и b >= k. Различните легални представяния на едно и също число се броят само веднъж.\n    >>> countPowerNumbers(99, 1)\n    99", "zh": "给定两个正整数 n 和 k，找到多少个正整数 x，其中 1 <= x <= n，可以表示为 x = a^b，其中 a 和 b 是正整数且 b >= k。相同数字的不同合法表示仅计算一次。\n    >>> countPowerNumbers(99, 1)\n    99", "fr": "Étant donnés deux entiers positifs n et k, trouvez le nombre d'entiers positifs x, où 1 <= x <= n, qui peuvent être exprimés comme x = a^b avec a et b étant des entiers positifs et b >= k.\nDifférentes représentations légales du même nombre sont comptées une seule fois.\n    >>> countPowerNumbers(99, 1)\n    99", "de": "Gegeben zwei positive ganze Zahlen n und k, finde die Anzahl der positiven ganzen Zahlen x, wobei 1 <= x <= n, die als x = a^b ausgedrückt werden können, wobei a und b positive ganze Zahlen sind und b >= k.\nVerschiedene zulässige Darstellungen derselben Zahl werden nur einmal gezählt.\n    >>> countPowerNumbers(99, 1)\n    99", "ha": "An ba lambobi biyu masu kyau n da k, nemo yawan lambobi masu kyau x, inda 1 <= x <= n, waɗanda za a iya bayyana su da x = a^b tare da a da b suna kasancewa lambobi masu kyau kuma b >= k. Ana ƙidaya wakilcin doka daban-daban na lamba ɗaya sau ɗaya kawai.\n    >>> countPowerNumbers(99, 1)\n    99", "hi": "दो सकारात्मक पूर्णांक n और k दिए गए हैं, उन सकारात्मक पूर्णांकों x की संख्या ज्ञात करें, जहाँ 1 <= x <= n, जिन्हें x = a^b के रूप में व्यक्त किया जा सकता है जहाँ a और b सकारात्मक पूर्णांक हैं और b >= k है। एक ही संख्या के विभिन्न वैध अभ्यावेदन को केवल एक बार गिना जाता है।\n    >>> countPowerNumbers(99, 1)\n    99", "hu": "Két pozitív egész szám, n és k esetén, találja meg azon pozitív egész számok x számát, ahol 1 <= x <= n, amelyek kifejezhetők x = a^b alakban, ahol a és b pozitív egész számok és b >= k.\nUgyanazon szám különböző jogszerű ábrázolásai csak egyszer számítanak.\n    >>> countPowerNumbers(99, 1)\n    99", "es": "Dado dos enteros positivos n y k, encuentra el número de enteros positivos x, donde 1 <= x <= n, que pueden expresarse como x = a^b con a y b siendo enteros positivos y b >= k.\nDiferentes representaciones legales del mismo número se cuentan solo una vez.\n    >>> countPowerNumbers(99, 1)\n    99", "arb": "معطى عددان صحيحان موجبان n و k، ابحث عن عدد الأعداد الصحيحة الموجبة x، حيث 1 <= x <= n، التي يمكن التعبير عنها كـ x = a^b مع كون a و b عددين صحيحين موجبين و b >= k. يتم احتساب التمثيلات القانونية المختلفة لنفس الرقم مرة واحدة فقط.\n    >>> countPowerNumbers(99, 1)\n    99", "sw": "Ukipewa nambari mbili chanya n na k, pata idadi ya nambari chanya x, ambapo 1 <= x <= n, ambazo zinaweza kuonyeshwa kama x = a^b huku a na b wakiwa nambari chanya na b >= k. Uwakilishi tofauti halali wa nambari sawa huhesabiwa mara moja tu.\n    >>> countPowerNumbers(99, 1)\n    99", "tr": "İki pozitif tamsayı n ve k verildiğinde, 1 <= x <= n aralığında x = a^b şeklinde ifade edilebilen pozitif tamsayı x sayısını bulun, burada a ve b pozitif tamsayılardır ve b >= k'dır. Aynı sayının farklı yasal temsilleri yalnızca bir kez sayılır.\n    >>> countPowerNumbers(99, 1)\n    99", "vi": "Cho hai số nguyên dương n và k, tìm số lượng số nguyên dương x, với 1 <= x <= n, có thể được biểu diễn dưới dạng x = a^b với a và b là các số nguyên dương và b >= k. Các biểu diễn hợp lệ khác nhau của cùng một số chỉ được đếm một lần.  \n    >>> countPowerNumbers(99, 1)  \n    99  ", "id": "Diberikan dua bilangan bulat positif n dan k, temukan jumlah bilangan bulat positif x, di mana 1 <= x <= n, yang dapat dinyatakan sebagai x = a^b dengan a dan b adalah bilangan bulat positif dan b >= k. Representasi legal yang berbeda dari angka yang sama hanya dihitung sekali.\n    >>> countPowerNumbers(99, 1)\n    99", "ja": "2つの正の整数 n と k が与えられたとき、1 <= x <= n の範囲で、x = a^b として表現できる正の整数 x の数を求めます。ただし、a と b は正の整数であり、b >= k です。\n同じ数の異なる合法的な表現は一度だけカウントされます。\n    >>> countPowerNumbers(99, 1)\n    99", "ko": "두 개의 양의 정수 n과 k가 주어졌을 때, 1 <= x <= n 범위 내에서 x = a^b로 표현될 수 있는 양의 정수 x의 개수를 찾습니다. 여기서 a와 b는 양의 정수이고 b >= k입니다. 같은 숫자의 서로 다른 합법적인 표현은 한 번만 계산됩니다.\n    >>> countPowerNumbers(99, 1)\n    99", "ml": "രണ്ട് പോസിറ്റീവ് പൂർണ്ണസംഖ്യകൾ n, k എന്നിവ നൽകിയാൽ, 1 <= x <= n എന്ന അവസ്ഥയിൽ, x = a^b എന്ന രൂപത്തിൽ പ്രകടിപ്പിക്കാവുന്ന പോസിറ്റീവ് പൂർണ്ണസംഖ്യകളുടെ എണ്ണം കണ്ടെത്തുക, ഇവിടെ a, b എന്നിവ പോസിറ്റീവ് പൂർണ്ണസംഖ്യകളാണ്, കൂടാതെ b >= k ആണ്. \nഒരേ സംഖ്യയുടെ വ്യത്യസ്ത നിയമപരമായ പ്രതിനിധാനങ്ങൾ ഒറ്റത്തവണ മാത്രമേ എണ്ണപ്പെടൂ.\n\n    >>> countPowerNumbers(99, 1)\n    99", "fa": "با توجه به دو عدد صحیح مثبت n و k، تعداد اعداد صحیح مثبت x را پیدا کنید، به طوری که 1 <= x <= n، که می‌توان آن‌ها را به صورت x = a^b بیان کرد، با این شرط که a و b اعداد صحیح مثبت باشند و b >= k.\nنمایش‌های قانونی مختلف از یک عدد مشابه فقط یک بار شمارش می‌شوند.\n    >>> countPowerNumbers(99, 1)\n    99"}}
{"task_id": "C/41", "prompt": {"en": "#include <stdio.h>\n#include <assert.h>\n/*\nGiven three integers n, m, and k, find the number of sequences consisting of n '(' and m ')', such that the longest balanced subsequence is of length 2 * k. The result should be calculated modulo 1,000,000,007 (10^9 + 7).\n\nFor example:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)", "sq": "#include <stdio.h>\n#include <assert.h>\n/*\nDuke pasur tre numra të plotë n, m, dhe k, gjeni numrin e sekuencave që përbëhen nga n '(' dhe m ')', të tilla që nënsekuenca më e gjatë e balancuar është me gjatësi 2 * k. Rezultati duhet të llogaritet modulo 1,000,000,007 (10^9 + 7).\n\nPër shembull:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)", "hy": "#include <stdio.h>\n#include <assert.h>\n/*\nՈւնենալով երեք ամբողջ թիվ n, m և k, գտնել n '(' և m ')' բաղկացած հաջորդականությունների քանակը, այնպես, որ ամենաերկար հավասարակշռված ենթահաջորդականությունը լինի 2 * k երկարությամբ: Արդյունքը պետք է հաշվարկվի 1,000,000,007 (10^9 + 7) մոդուլով:\n\nՕրինակ:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)", "bn": "#include <stdio.h>\n#include <assert.h>\n/*\nতিনটি পূর্ণসংখ্যা n, m, এবং k দেওয়া আছে, n '(' এবং m ')' নিয়ে গঠিত সিকোয়েন্সের সংখ্যা খুঁজে বের করুন, যাতে দীর্ঘতম ব্যালেন্সড উপসিকোয়েন্সের দৈর্ঘ্য 2 * k হয়। ফলাফলটি 1,000,000,007 (10^9 + 7) দ্বারা মডুলোতে গণনা করা উচিত।\n\nউদাহরণ:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)", "bg": "#include <stdio.h>\n#include <assert.h>\n/*\nДадени са три цели числа n, m и k, намерете броя на последователностите, състоящи се от n '(' и m ')', така че най-дългата балансирана подредица да е с дължина 2 * k. Резултатът трябва да бъде изчислен по модул 1,000,000,007 (10^9 + 7).\n\nНапример:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)", "zh": "#include <stdio.h>\n#include <assert.h>\n/*\n给定三个整数 n, m 和 k，找到由 n 个 '(' 和 m 个 ')' 组成的序列的数量，使得最长的平衡子序列的长度为 2 * k。结果应以 1,000,000,007 (10^9 + 7) 为模计算。\n\n例如:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)", "fr": "#include <stdio.h>\n#include <assert.h>\n/*\nÉtant donné trois entiers n, m, et k, trouvez le nombre de séquences consistant en n '(' et m ')', telles que la plus longue sous-séquence équilibrée soit de longueur 2 * k. Le résultat doit être calculé modulo 1,000,000,007 (10^9 + 7).\n\nPar exemple :\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)", "de": "#include <stdio.h>\n#include <assert.h>\n/*\nGegeben sind drei ganze Zahlen n, m und k. Finde die Anzahl der Sequenzen, die aus n '(' und m ')' bestehen, sodass die längste balancierte Teilsequenz die Länge 2 * k hat. Das Ergebnis sollte modulo 1.000.000.007 (10^9 + 7) berechnet werden.\n\nZum Beispiel:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)", "ha": "#include <stdio.h>\n#include <assert.h>\n/*\nAn ba lambobi guda uku n, m, da k, nemo yawan jerin lambobi da suka ƙunshi n '(' da m ')', ta yadda mafi tsawon subsequence mai daidaito yana da tsawon 2 * k. Sakamakon ya kamata a ƙididdige shi modulo 1,000,000,007 (10^9 + 7).\n\nMisali:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)", "hi": "#include <stdio.h>\n#include <assert.h>\n/*\nदिए गए तीन पूर्णांक n, m, और k के लिए, उन अनुक्रमों की संख्या खोजें जो n '(' और m ')' से बने होते हैं, ताकि सबसे लंबा संतुलित उप-अनुक्रम 2 * k लंबाई का हो। परिणाम को 1,000,000,007 (10^9 + 7) के मापांक में गणना की जानी चाहिए।\n\nउदाहरण के लिए:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)", "hu": "#include <stdio.h>\n#include <assert.h>\n/*\nAdott három egész szám: n, m és k. Meg kell találni azon sorozatok számát, amelyek n '(' és m ')' karakterből állnak, úgy, hogy a leghosszabb kiegyensúlyozott részszekvencia hossza 2 * k. Az eredményt 1,000,000,007 (10^9 + 7) modulo szerint kell kiszámítani.\n\nPéldául:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)", "es": "#include <stdio.h>\n#include <assert.h>\n/*\nDado tres enteros n, m, y k, encuentra el número de secuencias que consisten en n '(' y m ')', tal que la subsecuencia balanceada más larga tiene una longitud de 2 * k. El resultado debe calcularse módulo 1,000,000,007 (10^9 + 7).\n\nPor ejemplo:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)", "arb": "#include <stdio.h>\n#include <assert.h>\n/*\nمعطى ثلاثة أعداد صحيحة n و m و k، قم بإيجاد عدد التتابعات المكونة من n '(' و m ')', بحيث يكون أطول تتابع متوازن بطول 2 * k. يجب حساب النتيجة بتطبيق باقي القسمة على 1,000,000,007 (10^9 + 7).\n\nعلى سبيل المثال:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)", "sw": "#include <stdio.h>\n#include <assert.h>\n/*\nUkipewa nambari tatu n, m, na k, pata idadi ya mlolongo unaojumuisha n '(' na m ')', ili kwamba mlolongo mrefu zaidi ulio sawa una urefu wa 2 * k. Matokeo yanapaswa kuhesabiwa kwa modulo 1,000,000,007 (10^9 + 7).\n\nKwa mfano:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)", "tr": "#include <stdio.h>\n#include <assert.h>\n/*\nÜç tamsayı n, m ve k verildiğinde, n '(' ve m ')' karakterlerinden oluşan dizilerin sayısını bulun, böylece en uzun dengeli alt dizi uzunluğu 2 * k olur. Sonuç, 1,000,000,007 (10^9 + 7) ile mod alınarak hesaplanmalıdır.\n\nÖrneğin:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)", "vi": "#include <stdio.h>\n#include <assert.h>\n/*\nCho ba số nguyên n, m và k, tìm số lượng dãy gồm n '(' và m ')', sao cho dãy con cân bằng dài nhất có độ dài là 2 * k. Kết quả cần được tính theo modulo 1,000,000,007 (10^9 + 7).\n\nVí dụ:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)", "id": "#include <stdio.h>\n#include <assert.h>\n/*\nDiberikan tiga bilangan bulat n, m, dan k, temukan jumlah urutan yang terdiri dari n '(' dan m ')', sedemikian rupa sehingga subsekuens seimbang terpanjang memiliki panjang 2 * k. Hasilnya harus dihitung dalam modulo 1,000,000,007 (10^9 + 7).\n\nSebagai contoh:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)", "ja": "#include <stdio.h>\n#include <assert.h>\n/*\n3つの整数 n, m, k が与えられたとき、n 個の '(' と m 個の ')' からなるシーケンスのうち、最も長いバランスの取れた部分シーケンスが長さ 2 * k であるものの数を求めます。結果は 1,000,000,007 (10^9 + 7) で計算する必要があります。\n\n例えば:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)", "ko": "#include <stdio.h>\n#include <assert.h>\n/*\n세 개의 정수 n, m, k가 주어졌을 때, n개의 '('와 m개의 ')'로 구성된 시퀀스 중에서 가장 긴 균형 잡힌 부분 시퀀스의 길이가 2 * k인 경우의 수를 찾으시오. 결과는 1,000,000,007 (10^9 + 7)로 나눈 나머지로 계산해야 합니다.\n\n예를 들어:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)", "ml": "#include <stdio.h>\n#include <assert.h>\n/*\nമൂന്ന് പൂർണ്ണസംഖ്യകൾ n, m, k എന്നിവ നൽകിയാൽ, n '(' മുകളിൽ m ')' അടങ്ങിയ സീക്വൻസുകളുടെ എണ്ണം കണ്ടെത്തുക, അങ്ങനെ ഏറ്റവും നീളമുള്ള ബാലൻസ്ഡ് സബ്‌സീക്വൻസ് 2 * k നീളമുള്ളതായിരിക്കും. ഫലം 1,000,000,007 (10^9 + 7) മോഡുലോയിൽ കണക്കാക്കണം.\n\nഉദാഹരണത്തിന്:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)", "fa": "#include <stdio.h>\n#include <assert.h>\n/*\nسه عدد صحیح n، m و k داده شده است، تعداد دنباله‌هایی را پیدا کنید که از n '(' و m ')' تشکیل شده‌اند، به طوری که طولانی‌ترین زیر دنباله متوازن دارای طول 2 * k باشد. نتیجه باید به پیمانه 1,000,000,007 (10^9 + 7) محاسبه شود.\n\nبرای مثال:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)"}, "canonical_solution": "{\n    const long long P = 1e9 + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}", "instruction": {"en": "long long countBalancedSubsequences(long long n, long long m, long long k)\n{\n    const long long P = 1e9 + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "sq": "long long countBalancedSubsequences(long long n, long long m, long long k)\n{\n    const long long P = 1e9 + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C në shqip duke përdorur maksimumi 500 karaktere.", "hy": "long long countBalancedSubsequences(long long n, long long m, long long k)\n{\n    const long long P = 1e9 + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}\n\nՏվեք C կոդի հակիրճ բնութագրումը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։", "bn": "long long countBalancedSubsequences(long long n, long long m, long long k)\n{\n    const long long P = 1e9 + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}\n\nসি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।", "bg": "long long countBalancedSubsequences(long long n, long long m, long long k)\n{\n    const long long P = 1e9 + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, използвайки най-много 500 знака.", "zh": "long long countBalancedSubsequences(long long n, long long m, long long k)\n{\n    const long long P = 1e9 + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}\n\n请用中文为以下C代码提供简洁的自然语言描述（文档字符串），不超过500个字符。", "fr": "long long countBalancedSubsequences(long long n, long long m, long long k)\n{\n    const long long P = 1e9 + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.", "de": "long long countBalancedSubsequences(long long n, long long m, long long k)\n{\n    const long long P = 1e9 + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "long long countBalancedSubsequences(long long n, long long m, long long k)\n{\n    const long long P = 1e9 + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}\n\nBa da takaitaccen bayanin yaren halitta (docstring) na lambar C cikin Hausa ta amfani da haruffa 500 kacal.", "hi": "long long countBalancedSubsequences(long long n, long long m, long long k)\n{\n    const long long P = 1e9 + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}\n\nC कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "long long countBalancedSubsequences(long long n, long long m, long long k)\n{\n    const long long P = 1e9 + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben.", "es": "long long countBalancedSubsequences(long long n, long long m, long long k)\n{\n    const long long P = 1e9 + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando como máximo 500 caracteres.", "arb": "long long countBalancedSubsequences(long long n, long long m, long long k)\n{\n    const long long P = 1e9 + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "long long countBalancedSubsequences(long long n, long long m, long long k)\n{\n    const long long P = 1e9 + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "long long countBalancedSubsequences(long long n, long long m, long long k)\n{\n    const long long P = 1e9 + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}\n\nC kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda, Türkçe bir açıklama (docstring) sağlayın.", "vi": "long long countBalancedSubsequences(long long n, long long m, long long k)\n{\n    const long long P = 1e9 + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã C bằng tiếng Việt, sử dụng tối đa 500 ký tự.", "id": "long long countBalancedSubsequences(long long n, long long m, long long k)\n{\n    const long long P = 1e9 + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode C dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "long long countBalancedSubsequences(long long n, long long m, long long k)\n{\n    const long long P = 1e9 + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}\n\n以下のCコードの簡潔な自然言語による説明（ドックストリング）を日本語で500文字以内で提供してください。", "ko": "long long countBalancedSubsequences(long long n, long long m, long long k)\n{\n    const long long P = 1e9 + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}\n\n다음 C 코드의 동작을 설명하는 간결한 자연어 설명(도크스트링)을 한국어로 제공하세요. 최대 500자까지 가능합니다.", "ml": "long long countBalancedSubsequences(long long n, long long m, long long k)\n{\n    const long long P = 1e9 + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}\n\nസിയുടെ കോഡിന് 500 അക്ഷരങ്ങൾക്കുള്ളിൽ മലയാളത്തിൽ സംക്ഷിപ്തമായ ഒരു സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) നൽകുക.", "fa": "long long countBalancedSubsequences(long long n, long long m, long long k)\n{\n    const long long P = 1e9 + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}\n\nتوضیح مختصر و طبیعی (docstring) از کد C را به زبان فارسی با حداکثر ۵۰۰ کاراکتر ارائه دهید."}, "level": "", "test": "int main() {\n    assert(countBalancedSubsequences(2, 2, 2) == 2);\n    assert(countBalancedSubsequences(3, 2, 3) == 0);\n    assert(countBalancedSubsequences(3, 2, 1) == 4);\n    assert(countBalancedSubsequences(4, 3, 2) == 14);\n    assert(countBalancedSubsequences(5, 5, 2) == 35);\n    assert(countBalancedSubsequences(6, 1, 1) == 6);\n    assert(countBalancedSubsequences(1, 6, 1) == 6);\n    assert(countBalancedSubsequences(7, 2, 2) == 27);\n    assert(countBalancedSubsequences(8, 3, 3) == 110);\n    assert(countBalancedSubsequences(10, 10, 5) == 10659);\n    assert(countBalancedSubsequences(20, 20, 10) == 574221648);\n    assert(countBalancedSubsequences(2000, 2000, 1000) == 854104531);\n    assert(countBalancedSubsequences(2000, 1999, 1000) == 334874485);\n    assert(countBalancedSubsequences(2000, 2000, 1999) == 259428024);\n    return 0;\n}", "entry_point": "countBalancedSubsequences", "signature": "long long countBalancedSubsequences(long long n, long long m, long long k)", "docstring": {"en": "Given three integers n, m, and k, find the number of sequences consisting of n '(' and m ')', such that the longest balanced subsequence is of length 2 * k. The result should be calculated modulo 1,000,000,007 (10^9 + 7).\n\nFor example:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n", "sq": "Duke pasur tre numra të plotë n, m, dhe k, gjeni numrin e sekuencave që përbëhen nga n '(' dhe m ')', të tilla që nënpasuesi më i gjatë i balancuar është me gjatësi 2 * k. Rezultati duhet të llogaritet modulo 1,000,000,007 (10^9 + 7).\n\nPër shembull:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2", "hy": "Երեք ամբողջ թիվ n, m և k ունենալով, գտնել n '(' և m ')' բաղկացած հաջորդականությունների քանակը, այնպես, որ ամենաերկար հավասարակշռված ենթահաջորդականությունը լինի 2 * k երկարությամբ։ Արդյունքը պետք է հաշվարկվի 1,000,000,007 (10^9 + 7) մոդուլով։\n\nՕրինակ:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2", "bn": "তিনটি পূর্ণসংখ্যা n, m, এবং k দেওয়া হয়েছে, n '(' এবং m ')' নিয়ে গঠিত এমন কতগুলি সিকোয়েন্স আছে তা খুঁজে বের করুন, যাতে দীর্ঘতম ব্যালেন্সড উপসিকোয়েন্সের দৈর্ঘ্য 2 * k হয়। ফলাফলটি 1,000,000,007 (10^9 + 7) দ্বারা মডুলোতে গণনা করা উচিত।\n\nউদাহরণস্বরূপ:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2", "bg": "Дадени са три цели числа n, m и k, намерете броя на последователностите, състоящи се от n '(' и m ')', така че най-дългата балансирана подредена последователност да е с дължина 2 * k. Резултатът трябва да бъде изчислен по модул 1,000,000,007 (10^9 + 7).\n\nНапример:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2", "zh": "给定三个整数 n, m 和 k，找出由 n 个 '(' 和 m 个 ')' 组成的序列的数量，使得最长平衡子序列的长度为 2 * k。结果应取模 1,000,000,007 (10^9 + 7)。\n\n例如：\n    >>> countBalancedSubsequences(2, 2, 2)\n    2", "fr": "Étant donné trois entiers n, m et k, trouvez le nombre de séquences constituées de n '(' et m ')', de telle sorte que la plus longue sous-séquence équilibrée soit de longueur 2 * k. Le résultat doit être calculé modulo 1,000,000,007 (10^9 + 7).\n\nPar exemple :\n    >>> countBalancedSubsequences(2, 2, 2)\n    2", "de": "Gegeben drei ganze Zahlen n, m und k, finde die Anzahl der Sequenzen, die aus n '(' und m ')' bestehen, so dass die längste ausgeglichene Teilsequenz die Länge 2 * k hat. Das Ergebnis sollte modulo 1,000,000,007 (10^9 + 7) berechnet werden.\n\nZum Beispiel:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2", "ha": "An ba integers guda uku n, m, da k, nemo yawan jerin lambobi da suka ƙunshi n '(' da m ')', ta yadda mafi tsawon jerin lambobi masu daidaito yana da tsawon 2 * k. Sakamakon ya kamata a ƙididdige shi modulo 1,000,000,007 (10^9 + 7).\n\nMisali:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2", "hi": "तीन पूर्णांक n, m, और k दिए गए हैं, n '(' और m ')' से बनी अनुक्रमों की संख्या खोजें, ताकि सबसे लंबा संतुलित उप-अनुक्रम 2 * k लंबाई का हो। परिणाम को 1,000,000,007 (10^9 + 7) से मापांकित करके गणना की जानी चाहिए।\n\nउदाहरण के लिए:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2", "hu": "Három egész szám, n, m és k megadása esetén találja meg azon sorozatok számát, amelyek n '(' és m ')' karakterből állnak, úgy, hogy a leghosszabb kiegyensúlyozott részszekvencia hossza 2 * k. Az eredményt 1,000,000,007 (10^9 + 7) modulo szerint kell kiszámítani.\n\nPéldául:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2", "es": "Dado tres enteros n, m y k, encuentra el número de secuencias que consisten en n '(' y m ')', tal que la subsecuencia balanceada más larga sea de longitud 2 * k. El resultado debe ser calculado módulo 1,000,000,007 (10^9 + 7).\n\nPor ejemplo:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2", "arb": "إعطاء ثلاثة أعداد صحيحة n، m، و k، ابحث عن عدد التتابعات المكونة من n '(' و m ')', بحيث يكون أطول تتابع متوازن بطول 2 * k. يجب حساب النتيجة بتطبيق المودولو 1,000,000,007 (10^9 + 7).\n\nعلى سبيل المثال:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2", "sw": "Kwa kupewa nambari tatu za mzima n, m, na k, tafuta idadi ya mlolongo unaojumuisha n '(' na m ')', ili kwamba mlolongo mrefu zaidi ulio sawa una urefu wa 2 * k. Matokeo yanapaswa kuhesabiwa kwa moduli 1,000,000,007 (10^9 + 7).\n\nKwa mfano:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2", "tr": "Üç tamsayı n, m ve k verildiğinde, n '(' ve m ')' karakterlerinden oluşan dizilerin sayısını bulun, öyle ki en uzun dengeli alt dizi uzunluğu 2 * k olsun. Sonuç, 1,000,000,007 (10^9 + 7) ile mod alınarak hesaplanmalıdır.\n\nÖrneğin:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2", "vi": "Cho ba số nguyên n, m và k, tìm số lượng dãy bao gồm n dấu '(' và m dấu ')', sao cho dãy con cân bằng dài nhất có độ dài là 2 * k. Kết quả cần được tính theo modulo 1,000,000,007 (10^9 + 7).\n\nVí dụ:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2", "id": "Diberikan tiga bilangan bulat n, m, dan k, temukan jumlah urutan yang terdiri dari n '(' dan m ')', sedemikian rupa sehingga subsekuens seimbang terpanjang memiliki panjang 2 * k. Hasilnya harus dihitung modulo 1,000,000,007 (10^9 + 7).\n\nSebagai contoh:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2", "ja": "3つの整数 n、m、および k が与えられたとき、n 個の '(' と m 個の ')' からなるシーケンスのうち、最も長いバランスの取れた部分シーケンスの長さが 2 * k であるものの数を求めます。結果は 1,000,000,007 (10^9 + 7) での剰余として計算されるべきです。\n\n例:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2", "ko": "세 개의 정수 n, m, k가 주어졌을 때, n개의 '('와 m개의 ')'로 구성된 시퀀스 중 가장 긴 균형 잡힌 부분 시퀀스의 길이가 2 * k인 경우의 수를 찾으십시오. 결과는 1,000,000,007 (10^9 + 7)로 나눈 나머지로 계산되어야 합니다.\n\n예를 들어:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2", "ml": "മൂന്ന് പൂർണ്ണസംഖ്യകൾ n, m, k എന്നിവ നൽകിയാൽ, n '(' കൂടാതെ m ')' ഉൾപ്പെടുന്ന പരമ്പരകളുടെ എണ്ണം കണ്ടെത്തുക, അങ്ങനെ ഏറ്റവും നീളം കൂടിയ ബാലൻസ്ഡ് ഉപക്രമം 2 * k നീളമുള്ളതായിരിക്കും. ഫലം 1,000,000,007 (10^9 + 7) മോഡുലോ ആയി കണക്കാക്കണം.\n\nഉദാഹരണത്തിന്:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2", "fa": "با توجه به سه عدد صحیح n، m و k، تعداد دنباله‌هایی را بیابید که شامل n '(' و m ')' هستند، به‌گونه‌ای که طولانی‌ترین زیر دنباله متوازن دارای طول 2 * k باشد. نتیجه باید به‌صورت پیمانه‌ای با 1,000,000,007 (10^9 + 7) محاسبه شود.\n\nبرای مثال:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2"}}
{"task_id": "C/42", "prompt": {"en": "#include <stdio.h>\n#include <assert.h>\n/*\nGiven a rectangle paper of size n x m placed on a plane Cartesian coordinate system with its bottom-left corner at (0,0) and top-right corner at (n,m), \nyou need to calculate the expected number of operations to cut the paper such that the remaining area is less than k. \nIn each operation, a line is randomly chosen that is parallel to the axes, passes through points with integer coordinates, and cuts through (not just touching the edge) the paper. The bottom or right part of the paper along this line is then discarded.\nThe answer should be modulo 10^9+7.\n\nFor example:\n    >>> expectedCuts(3, 3, 4)\n    3\n*/\nlong long expectedCuts(int n, int m, long long k)", "sq": "#include <stdio.h>\n#include <assert.h>\n/*\nDuke pasur një letër drejtkëndëshe me madhësi n x m të vendosur në një sistem koordinativ kartezian të planit me këndin e poshtëm të majtë në (0,0) dhe këndin e sipërm të djathtë në (n,m),\nduhet të llogaritni numrin e pritur të operacioneve për të prerë letrën në mënyrë që sipërfaqja e mbetur të jetë më pak se k.\nNë secilën operacion, zgjidhet rastësisht një vijë që është paralele me boshtet, kalon nëpër pika me koordinata të plota, dhe pret (jo vetëm prek buzën) letrën. Pjesa e poshtme ose e djathtë e letrës përgjatë kësaj vije pastaj hidhet poshtë.\nPërgjigjja duhet të jetë modulo 10^9+7.\n\nPër shembull:\n    >>> expectedCuts(3, 3, 4)\n    3\n*/\nlong long expectedCuts(int n, int m, long long k)", "hy": "#include <stdio.h>\n#include <assert.h>\n/*\nՏրված է n x m չափսի ուղղանկյուն թուղթ, որը տեղադրված է հարթության դեկարտյան կոորդինատային համակարգում՝ իր ներքևի ձախ անկյունը (0,0) կետում և վերևի աջ անկյունը (n,m) կետում,\nպետք է հաշվարկել սպասվող գործողությունների քանակը, որպեսզի կտրենք թուղթը այնպես, որ մնացած մակերեսը լինի փոքր քան k:\nՅուրաքանչյուր գործողության ժամանակ պատահականորեն ընտրվում է գիծ, որը զուգահեռ է առանցքներին, անցնում է ամբողջ թվային կոորդինատներով կետերով և կտրում է թուղթը (ոչ միայն շոշափում է եզրը): Թղթի այս գծի երկայնքով ներքևի կամ աջ հատվածը ապա հեռացվում է:\nՊատասխանը պետք է լինի 10^9+7 մոդուլով:\n\nՕրինակ:\n    >>> expectedCuts(3, 3, 4)\n    3\n*/\nlong long expectedCuts(int n, int m, long long k)", "bn": "#include <stdio.h>\n#include <assert.h>\n/*\nএকটি আয়তাকার কাগজের টুকরো যার আকার n x m, একটি সমতল কার্টেসিয়ান স্থানাঙ্ক পদ্ধতিতে রাখা হয়েছে যার নিচের-বাম কোণ (0,0) এবং উপরের-ডান কোণ (n,m) এ অবস্থিত, \nতোমাকে অপারেশনগুলোর প্রত্যাশিত সংখ্যা গণনা করতে হবে যাতে কাগজের অবশিষ্ট এলাকা k এর চেয়ে কম হয়। \nপ্রতিটি অপারেশনে, একটি লাইন এলোমেলোভাবে নির্বাচিত হয় যা অক্ষের সাথে সমান্তরাল, পূর্ণসংখ্যা স্থানাঙ্ক সহ পয়েন্টগুলির মধ্য দিয়ে যায় এবং কাগজের মধ্য দিয়ে কেটে যায় (শুধু প্রান্ত স্পর্শ নয়)। এই লাইনের সাথে বরাবর কাগজের নিচের বা ডান অংশটি তারপর বাতিল করা হয়।\nউত্তরটি 10^9+7 মডুলোতে হওয়া উচিত।\n\nউদাহরণস্বরূপ:\n    >>> expectedCuts(3, 3, 4)\n    3\n*/\nlong long expectedCuts(int n, int m, long long k)", "bg": "#include <stdio.h>\n#include <assert.h>\n/*\nДаден е правоъгълен лист хартия с размер n x m, разположен в равнинна декартова координатна система с долен ляв ъгъл в (0,0) и горен десен ъгъл в (n,m),\nтрябва да изчислите очаквания брой операции за изрязване на хартията така, че останалата площ да е по-малка от k.\nПри всяка операция се избира произволна линия, която е успоредна на осите, минава през точки с цели координати и пресича (не само докосва ръба) хартията. Долната или дясната част на хартията по тази линия след това се изхвърля.\nОтговорът трябва да бъде модуло 10^9+7.\n\nНапример:\n    >>> expectedCuts(3, 3, 4)\n    3\n*/\nlong long expectedCuts(int n, int m, long long k)", "zh": "#include <stdio.h>\n#include <assert.h>\n/*\n给定一个大小为 n x m 的矩形纸张，放置在平面直角坐标系中，其左下角在 (0,0) 处，右上角在 (n,m) 处，\n你需要计算切割纸张的期望操作次数，使得剩余面积小于 k。\n在每次操作中，随机选择一条与坐标轴平行的线，该线通过整数坐标的点，并切割（不仅仅是触碰边缘）纸张。然后沿着这条线丢弃纸张的底部或右侧部分。\n答案应对 10^9+7 取模。\n\n例如：\n    >>> expectedCuts(3, 3, 4)\n    3\n*/\nlong long expectedCuts(int n, int m, long long k)", "fr": "#include <stdio.h>\n#include <assert.h>\n/*\nÉtant donné un papier rectangulaire de taille n x m placé sur un système de coordonnées cartésien plan avec son coin inférieur gauche à (0,0) et son coin supérieur droit à (n,m),\nvous devez calculer le nombre attendu d'opérations pour couper le papier de sorte que la surface restante soit inférieure à k.\nÀ chaque opération, une ligne est choisie aléatoirement, parallèle aux axes, passant par des points avec des coordonnées entières, et coupant (non pas juste touchant le bord) le papier. La partie inférieure ou droite du papier le long de cette ligne est alors éliminée.\nLa réponse doit être modulo 10^9+7.\n\nPar exemple :\n    >>> expectedCuts(3, 3, 4)\n    3\n*/\nlong long expectedCuts(int n, int m, long long k)", "de": "#include <stdio.h>\n#include <assert.h>\n/*\nGegeben ist ein rechteckiges Papier der Größe n x m, das in einem kartesischen Koordinatensystem platziert ist, mit seiner unteren linken Ecke bei (0,0) und der oberen rechten Ecke bei (n,m).\nSie müssen die erwartete Anzahl von Operationen berechnen, um das Papier so zu schneiden, dass die verbleibende Fläche kleiner als k ist.\nBei jeder Operation wird eine Linie zufällig gewählt, die parallel zu den Achsen verläuft, durch Punkte mit ganzzahligen Koordinaten geht und das Papier durchschneidet (nicht nur die Kante berührt). Der untere oder rechte Teil des Papiers entlang dieser Linie wird dann verworfen.\nDie Antwort sollte modulo 10^9+7 sein.\n\nZum Beispiel:\n    >>> expectedCuts(3, 3, 4)\n    3\n*/\nlong long expectedCuts(int n, int m, long long k)", "ha": "#include <stdio.h>\n#include <assert.h>\n/*\nAn ba takarda rectangle mai girman n x m da aka sanya a kan tsarin daidaitawar Cartesian na jirgin sama tare da kusurwar ƙasa-hagu a (0,0) da kusurwar sama-dama a (n,m),\nkana buƙatar lissafin adadin ayyukan da ake tsammani don yanke takardar don haka yankin da ya rage ya zama ƙasa da k.\nA kowane aiki, ana zaɓar layi da bazuwar wanda yake daidai da ginshiƙai, yana wucewa ta wuraren da ke da daidaitattun lambobi, kuma yana yanke (ba kawai taɓa gefen ba) takardar. Ana watsar da ɓangaren ƙasa ko dama na takardar tare da wannan layin.\nAmsar ya kamata ta zama modulo 10^9+7.\n\nMisali:\n    >>> expectedCuts(3, 3, 4)\n    3\n*/\nlong long expectedCuts(int n, int m, long long k)", "hi": "#include <stdio.h>\n#include <assert.h>\n/*\nदिए गए एक आयताकार कागज का आकार n x m है, जो एक समतल कार्टेशियन निर्देशांक प्रणाली पर रखा गया है, जिसकी निचली-बाईं कोने पर (0,0) और ऊपरी-दाईं कोने पर (n,m) है। \nआपको उन ऑपरेशनों की अपेक्षित संख्या की गणना करनी है ताकि कागज का शेष क्षेत्रफल k से कम हो जाए। \nप्रत्येक ऑपरेशन में, एक रेखा को यादृच्छिक रूप से चुना जाता है जो अक्षों के समानांतर होती है, पूर्णांक निर्देशांक वाले बिंदुओं से गुजरती है, और कागज को काटती है (सिर्फ किनारे को छूने के अलावा)। इस रेखा के साथ कागज के निचले या दाएँ भाग को फिर हटा दिया जाता है।\nउत्तर को 10^9+7 के मापांक में होना चाहिए।\n\nउदाहरण के लिए:\n    >>> expectedCuts(3, 3, 4)\n    3\n*/\nlong long expectedCuts(int n, int m, long long k)", "hu": "#include <stdio.h>\n#include <assert.h>\n/*\nAdott egy n x m méretű téglalap alakú papír, amely a síkbeli Descartes-koordináta-rendszerben helyezkedik el úgy, hogy az alsó-bal sarka a (0,0) pontban van, a jobb-felső sarka pedig az (n,m) pontban,\nki kell számítania a várt műveletek számát, hogy a papír maradék területe kisebb legyen, mint k.\nMinden művelet során véletlenszerűen választanak egy vonalat, amely párhuzamos a tengelyekkel, egész koordinátájú pontokon halad át, és átvágja (nem csak érinti a szélét) a papírt. A papír ezen vonal mentén lévő alsó vagy jobb részét elvetik.\nA válasznak 10^9+7 modulo szerint kell lennie.\n\nPéldául:\n    >>> expectedCuts(3, 3, 4)\n    3\n*/\nlong long expectedCuts(int n, int m, long long k)", "es": "#include <stdio.h>\n#include <assert.h>\n/*\nDado un papel rectangular de tamaño n x m colocado en un sistema de coordenadas Cartesianas en un plano con su esquina inferior izquierda en (0,0) y la esquina superior derecha en (n,m),\nnecesitas calcular el número esperado de operaciones para cortar el papel de tal manera que el área restante sea menor que k.\nEn cada operación, se elige aleatoriamente una línea que es paralela a los ejes, pasa por puntos con coordenadas enteras y corta (no solo toca el borde) el papel. La parte inferior o derecha del papel a lo largo de esta línea se descarta.\nLa respuesta debe ser módulo 10^9+7.\n\nPor ejemplo:\n    >>> expectedCuts(3, 3, 4)\n    3\n*/\nlong long expectedCuts(int n, int m, long long k)", "arb": "#include <stdio.h>\n#include <assert.h>\n/*\nمعطى ورقة مستطيلة بحجم n x m موضوعة على نظام إحداثيات ديكارتي مستوي مع وجود زاويتها السفلية اليسرى عند (0,0) والزاوية العلوية اليمنى عند (n,m)، \nتحتاج إلى حساب العدد المتوقع من العمليات لقطع الورقة بحيث تكون المساحة المتبقية أقل من k. \nفي كل عملية، يتم اختيار خط عشوائي موازٍ للمحاور، يمر عبر نقاط ذات إحداثيات صحيحة، ويقطع (وليس فقط يلامس الحافة) الورقة. ثم يتم التخلص من الجزء السفلي أو الأيمن من الورقة على طول هذا الخط.\nيجب أن تكون الإجابة موديولو 10^9+7.\n\nعلى سبيل المثال:\n    >>> expectedCuts(3, 3, 4)\n    3\n*/\nlong long expectedCuts(int n, int m, long long k)", "sw": "#include <stdio.h>\n#include <assert.h>\n/*\nUkipiwa karatasi ya mstatili ya ukubwa n x m iliyowekwa kwenye mfumo wa kuratibu wa Cartesian kwenye ndege na kona yake ya chini-kushoto iko kwenye (0,0) na kona ya juu-kulia iko kwenye (n,m), \nunahitaji kuhesabu idadi inayotarajiwa ya operesheni za kukata karatasi ili eneo lililobaki liwe chini ya k. \nKatika kila operesheni, mstari unachaguliwa kwa nasibu ambao ni sambamba na mhimili, unapita kwenye pointi zenye kuratibu za namba nzima, na unakata (sio kugusa tu ukingo) karatasi. Sehemu ya chini au ya kulia ya karatasi kando ya mstari huu kisha hutupwa.\nJibu linapaswa kuwa modulo 10^9+7.\n\nKwa mfano:\n    >>> expectedCuts(3, 3, 4)\n    3\n*/\nlong long expectedCuts(int n, int m, long long k)", "tr": "#include <stdio.h>\n#include <assert.h>\n/*\nn x m boyutunda bir dikdörtgen kağıt, alt-sol köşesi (0,0) ve üst-sağ köşesi (n,m) olan bir düzlem Kartezyen koordinat sistemine yerleştirilmiştir. \nKağıdı kesmek için gereken beklenen işlem sayısını hesaplamanız gerekiyor, böylece kalan alan k'dan küçük olur. \nHer işlemde, eksenlere paralel olan, tam sayı koordinatlarına sahip noktalardan geçen ve kağıdı kesen (sadece kenara dokunmayan) bir çizgi rastgele seçilir. Bu çizgi boyunca kağıdın alt veya sağ kısmı atılır.\nCevap 10^9+7 modunda olmalıdır.\n\nÖrneğin:\n    >>> expectedCuts(3, 3, 4)\n    3\n*/\nlong long expectedCuts(int n, int m, long long k)", "vi": "#include <stdio.h>\n#include <assert.h>\n/*\nCho một tờ giấy hình chữ nhật kích thước n x m đặt trên hệ tọa độ phẳng Đề-các với góc dưới bên trái tại (0,0) và góc trên bên phải tại (n,m),\nbạn cần tính số lượng thao tác kỳ vọng để cắt tờ giấy sao cho diện tích còn lại nhỏ hơn k.\nTrong mỗi thao tác, một đường thẳng được chọn ngẫu nhiên song song với các trục, đi qua các điểm có tọa độ nguyên, và cắt qua (không chỉ chạm vào cạnh) tờ giấy. Phần dưới hoặc bên phải của tờ giấy dọc theo đường này sau đó bị loại bỏ.\nCâu trả lời cần lấy modulo 10^9+7.\n\nVí dụ:\n    >>> expectedCuts(3, 3, 4)\n    3\n*/\nlong long expectedCuts(int n, int m, long long k)", "id": "#include <stdio.h>\n#include <assert.h>\n/*\nDiberikan selembar kertas berbentuk persegi panjang berukuran n x m yang ditempatkan pada sistem koordinat Kartesius dengan sudut kiri bawah di (0,0) dan sudut kanan atas di (n,m),\nAnda perlu menghitung jumlah operasi yang diharapkan untuk memotong kertas sehingga area yang tersisa kurang dari k.\nDalam setiap operasi, sebuah garis dipilih secara acak yang sejajar dengan sumbu, melewati titik dengan koordinat integer, dan memotong (bukan hanya menyentuh tepi) kertas tersebut. Bagian bawah atau kanan dari kertas sepanjang garis ini kemudian dibuang.\nJawabannya harus dalam modulo 10^9+7.\n\nSebagai contoh:\n    >>> expectedCuts(3, 3, 4)\n    3\n*/\nlong long expectedCuts(int n, int m, long long k)\n", "ja": "#include <stdio.h>\n#include <assert.h>\n/*\nサイズ n x m の長方形の紙が、平面直交座標系上に左下の角が (0,0)、右上の角が (n,m) に配置されています。\n残りの面積が k 未満になるように紙を切るための操作の期待値を計算する必要があります。\n各操作では、軸に平行で、整数座標を持つ点を通過し、紙を切断する（ただし、端に触れるだけではない）線がランダムに選ばれます。この線に沿った紙の下または右の部分が破棄されます。\n答えは 10^9+7 での剰余として出力されるべきです。\n\n例えば:\n    >>> expectedCuts(3, 3, 4)\n    3\n*/\nlong long expectedCuts(int n, int m, long long k)", "ko": "#include <stdio.h>\n#include <assert.h>\n/*\n크기가 n x m인 직사각형 종이가 평면 직교 좌표계에 놓여 있으며, 왼쪽 아래 모서리가 (0,0)에 있고 오른쪽 위 모서리가 (n,m)에 있습니다.\n남은 면적이 k보다 작아지도록 종이를 자르는 작업의 기대 횟수를 계산해야 합니다.\n각 작업에서는 축에 평행하고 정수 좌표를 지나는 선이 무작위로 선택되어 종이를 자릅니다(단순히 가장자리에 닿는 것이 아님). 그런 다음 이 선을 따라 종이의 아래쪽 또는 오른쪽 부분이 버려집니다.\n답은 10^9+7로 나눈 나머지여야 합니다.\n\n예를 들어:\n    >>> expectedCuts(3, 3, 4)\n    3\n*/\nlong long expectedCuts(int n, int m, long long k)\n", "ml": "#include <stdio.h>\n#include <assert.h>\n/*\nഒരു n x m വലുപ്പമുള്ള ചതുരശ്രക്കടലാസ്സ് ഒരു പ്ലെയിൻ കാർട്ടീഷ്യൻ കോഓർഡിനേറ്റ് സിസ്റ്റത്തിൽ (0,0) എന്നിടത്ത് താഴത്തെ ഇടത് കോർണറും (n,m) എന്നിടത്ത് മുകളിലെ വലത് കോർണറും ഉള്ളതായി നൽകിയിരിക്കുന്നു, \nബാക്കി വരുന്ന വിസ്തീർണം k-ൽ കുറവായിരിക്കാനുള്ള പ്രവർത്തനങ്ങളുടെ പ്രതീക്ഷിത സംഖ്യ കണക്കാക്കണം. \nഓരോ പ്രവർത്തനത്തിലും, അച്ചുതണ്ടുകളോട് സമാന്തരമായ, പൂർണ്ണസംഖ്യാ കോഓർഡിനേറ്റുകളുള്ള ബിന്ദുക്കളിലൂടെ കടന്നുപോകുന്ന ഒരു വരി യാദൃച്ഛികമായി തിരഞ്ഞെടുക്കപ്പെടുന്നു, \nഅത് കടലാസ്സിനെ (വരമ്പ് മാത്രം സ്പർശിക്കുന്നതല്ല) മുറിക്കുന്നു. ഈ വരിയോടൊപ്പം കടലാസ്സിന്റെ താഴത്തെ അല്ലെങ്കിൽ വലത് ഭാഗം പിന്നീട് ഉപേക്ഷിക്കുന്നു.\nഉത്തരം 10^9+7 മോഡുലോ ആയിരിക്കണം.\n\nഉദാഹരണത്തിന്:\n    >>> expectedCuts(3, 3, 4)\n    3\n*/\nlong long expectedCuts(int n, int m, long long k)", "fa": "#include <stdio.h>\n#include <assert.h>\n/*\nبا توجه به یک کاغذ مستطیلی به ابعاد n x m که در یک سیستم مختصات دکارتی صفحه قرار دارد و گوشه پایین-چپ آن در نقطه (0,0) و گوشه بالا-راست آن در نقطه (n,m) قرار دارد،\nشما باید تعداد عملیات مورد انتظار برای برش کاغذ را محاسبه کنید به طوری که مساحت باقی‌مانده کمتر از k باشد.\nدر هر عملیات، یک خط به صورت تصادفی انتخاب می‌شود که موازی با محور‌ها است، از نقاط با مختصات صحیح عبور می‌کند و از کاغذ عبور می‌کند (نه فقط لبه را لمس کند). سپس قسمت پایین یا راست کاغذ در طول این خط دور انداخته می‌شود.\nپاسخ باید به صورت مدولوی 10^9+7 باشد.\n\nبرای مثال:\n    >>> expectedCuts(3, 3, 4)\n    3\n*/\nlong long expectedCuts(int n, int m, long long k)\n"}, "canonical_solution": "{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n    if (k > (long long)n * m) {\n        return 0;\n    }\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}", "instruction": {"en": "long long expectedCuts(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n    if (k > (long long)n * m) {\n        return 0;\n    }\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "sq": "long long expectedCuts(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n    if (k > (long long)n * m) {\n        return 0;\n    }\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C në gjuhën shqipe duke përdorur maksimumi 500 karaktere.", "hy": "long long expectedCuts(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n    if (k > (long long)n * m) {\n        return 0;\n    }\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}\n\nՏվեք C կոդի համառոտ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։", "bn": "long long expectedCuts(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n    if (k > (long long)n * m) {\n        return 0;\n    }\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}\n\nসি কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।", "bg": "long long expectedCuts(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n    if (k > (long long)n * m) {\n        return 0;\n    }\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}\n\nПредоставете кратко описание на C кода на естествен език (докстринг) на български, използвайки не повече от 500 знака.", "zh": "long long expectedCuts(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n    if (k > (long long)n * m) {\n        return 0;\n    }\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}\n\n请用最多500个字符的中文对该C代码提供简洁的自然语言描述（文档字符串）。", "fr": "long long expectedCuts(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n    if (k > (long long)n * m) {\n        return 0;\n    }\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.", "de": "long long expectedCuts(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n    if (k > (long long)n * m) {\n        return 0;\n    }\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "long long expectedCuts(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n    if (k > (long long)n * m) {\n        return 0;\n    }\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}\n\nBa da takaitaccen bayani a cikin yare na halitta (docstring) na lambar C a cikin Hausa ta amfani da haruffa 500 ko kasa da haka.", "hi": "long long expectedCuts(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n    if (k > (long long)n * m) {\n        return 0;\n    }\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}\n\nC कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "long long expectedCuts(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n    if (k > (long long)n * m) {\n        return 0;\n    }\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben.", "es": "long long expectedCuts(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n    if (k > (long long)n * m) {\n        return 0;\n    }\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando como máximo 500 caracteres.", "arb": "long long expectedCuts(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n    if (k > (long long)n * m) {\n        return 0;\n    }\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى، على ألا يتجاوز 500 حرف.", "sw": "long long expectedCuts(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n    if (k > (long long)n * m) {\n        return 0;\n    }\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "long long expectedCuts(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n    if (k > (long long)n * m) {\n        return 0;\n    }\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}\n\nC kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe olarak yazılmalıdır.", "vi": "long long expectedCuts(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n    if (k > (long long)n * m) {\n        return 0;\n    }\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã C bằng tiếng Việt với tối đa 500 ký tự.", "id": "long long expectedCuts(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n    if (k > (long long)n * m) {\n        return 0;\n    }\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode C dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "long long expectedCuts(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n    if (k > (long long)n * m) {\n        return 0;\n    }\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}\n\nCコードの内容を日本語で簡潔に説明するドキュメンテーション文字列（docstring）を500文字以内で提供してください。", "ko": "long long expectedCuts(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n    if (k > (long long)n * m) {\n        return 0;\n    }\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}\n\nC 코드의 동작을 설명하는 간결한 자연어 설명(docstring)을 한국어로 작성하세요. 최대 500자 이내로 작성해야 합니다.", "ml": "long long expectedCuts(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n    if (k > (long long)n * m) {\n        return 0;\n    }\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}\n\nസീ കോഡിന്റെ മലയാളത്തിലുള്ള വിവരണം (ഡോക്സ്ട്രിംഗ്) പരമാവധി 500 അക്ഷരങ്ങൾ ഉപയോഗിച്ച് നൽകുക.", "fa": "long long expectedCuts(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n    if (k > (long long)n * m) {\n        return 0;\n    }\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}\n\nتوضیح مختصر و طبیعی (docstring) از کد C به زبان فارسی با حداکثر ۵۰۰ کاراکتر ارائه دهید."}, "level": "", "test": "int main() {\n    assert(expectedCuts(2, 4, 10) == 0);\n    assert(expectedCuts(2, 4, 8) == 1);\n    assert(expectedCuts(2, 4, 2) == 833333342);\n    assert(expectedCuts(2, 4, 6) == 250000003);\n    assert(expectedCuts(3, 3, 4) == 666666673);\n    assert(expectedCuts(5, 5, 12) == 666666673);\n    assert(expectedCuts(6, 7, 20) == 722222229);\n    assert(expectedCuts(8, 8, 30) == 72727275);\n    assert(expectedCuts(10, 10, 50) == 714285721);\n    assert(expectedCuts(1, 10, 5) == 945634929);\n    assert(expectedCuts(10, 1, 5) == 945634929);\n    return 0;\n}", "entry_point": "expectedCuts", "signature": "long long expectedCuts(int n, int m, long long k)", "docstring": {"en": "Given a rectangle paper of size n x m placed on a plane Cartesian coordinate system with its bottom-left corner at (0,0) and top-right corner at (n,m), \nyou need to calculate the expected number of operations to cut the paper such that the remaining area is less than k. \nIn each operation, a line is randomly chosen that is parallel to the axes, passes through points with integer coordinates, and cuts through (not just touching the edge) the paper. The bottom or right part of the paper along this line is then discarded.\nThe answer should be modulo 10^9+7.\n\nFor example:\n    >>> expectedCuts(3, 3, 4)\n    3\n", "sq": "Duke pasur një letër drejtkëndore me madhësi n x m të vendosur në një sistem koordinativ Kartesian të planit me këndin e poshtëm të majtë në (0,0) dhe këndin e sipërm të djathtë në (n,m), ju duhet të llogaritni numrin e pritshëm të operacioneve për të prerë letrën në mënyrë që sipërfaqja e mbetur të jetë më pak se k. Në çdo operacion, një vijë zgjidhet rastësisht që është paralele me boshtet, kalon nëpër pika me koordinata të plota, dhe pret (jo vetëm prek buzën) letrën. Pjesa e poshtme ose e djathtë e letrës përgjatë kësaj vije pastaj hidhet poshtë. Përgjigjja duhet të jetë modulo 10^9+7.\n\nPër shembull:\n    >>> expectedCuts(3, 3, 4)\n    3", "hy": "Տրված է n x m չափսի ուղղանկյուն թուղթ, որը տեղադրված է հարթ Cartesian համակարգում՝ իր ներքևի ձախ անկյունը (0,0) կետում և վերևի աջ անկյունը (n,m) կետում, \nանհրաժեշտ է հաշվել գործողությունների սպասվող քանակը, որպեսզի թղթի մնացած մակերեսը լինի փոքր k-ից։ \nՅուրաքանչյուր գործողության ժամանակ պատահականորեն ընտրվում է գիծ, որը զուգահեռ է առանցքներին, անցնում է ամբողջ թվային կոորդինատներով կետերով և կտրում է թուղթը (ոչ միայն շոշափում է եզրը)։ Գծի երկայնքով թղթի ներքևի կամ աջ մասը ապա հեռացվում է։\nՊատասխանը պետք է լինի 10^9+7 մոդուլով։\n\nՕրինակ:\n    >>> expectedCuts(3, 3, 4)\n    3", "bn": "একটি আয়তাকার কাগজের আকার n x m একটি সমতল কার্টেসিয়ান স্থানাঙ্ক পদ্ধতিতে রাখা হয়েছে যার নিচের-বাম কোণ (0,0) এবং উপরের-ডান কোণ (n,m) এ অবস্থিত, \nআপনাকে কাগজটি কাটার প্রত্যাশিত সংখ্যক অপারেশন গণনা করতে হবে যাতে অবশিষ্ট ক্ষেত্রফল k এর চেয়ে কম হয়। \nপ্রতিটি অপারেশনে, একটি লাইন এলোমেলোভাবে বেছে নেওয়া হয় যা অক্ষের সমান্তরাল, পূর্ণসংখ্যা স্থানাঙ্ক সহ বিন্দুগুলির মধ্য দিয়ে যায় এবং কাগজের মধ্য দিয়ে কেটে যায় (শুধুমাত্র প্রান্ত স্পর্শ করে না)। এই লাইনের বরাবর কাগজের নিচের বা ডান অংশটি তারপর বাতিল করা হয়।\nউত্তরটি 10^9+7 দ্বারা মডুলো হতে হবে।\n\nউদাহরণস্বরূপ:\n    >>> expectedCuts(3, 3, 4)\n    3", "bg": "Даден е правоъгълен лист хартия с размер n x m, разположен в равнинна декартова координатна система с долен ляв ъгъл в (0,0) и горен десен ъгъл в (n,m), трябва да изчислите очаквания брой операции за рязане на хартията така, че останалата площ да е по-малка от k. \nПри всяка операция се избира произволна линия, която е успоредна на осите, минава през точки с цели координати и пресича (не само докосва ръба) хартията. Долната или дясната част на хартията по тази линия след това се изхвърля.\nОтговорът трябва да бъде модул 10^9+7.\n\nНапример:\n    >>> expectedCuts(3, 3, 4)\n    3", "zh": "给定一个大小为 n x m 的矩形纸张，放置在平面直角坐标系中，其左下角位于 (0,0)，右上角位于 (n,m)，\n您需要计算切割纸张的期望操作次数，使得剩余面积小于 k。\n在每次操作中，随机选择一条与坐标轴平行的线，该线通过具有整数坐标的点，并切割（不仅仅是接触边缘）纸张。然后沿着这条线丢弃纸张的底部或右侧部分。\n答案应为模 10^9+7。\n\n例如：\n    >>> expectedCuts(3, 3, 4)\n    3", "fr": "Étant donné un papier rectangulaire de taille n x m placé sur un système de coordonnées cartésiennes avec son coin inférieur gauche à (0,0) et son coin supérieur droit à (n,m), vous devez calculer le nombre attendu d'opérations pour couper le papier de sorte que la surface restante soit inférieure à k. \nÀ chaque opération, une ligne est choisie au hasard, parallèle aux axes, passant par des points avec des coordonnées entières, et coupe (ne se contente pas de toucher le bord) le papier. La partie inférieure ou droite du papier le long de cette ligne est ensuite jetée.\nLa réponse doit être modulo 10^9+7.\n\nPar exemple :\n    >>> expectedCuts(3, 3, 4)\n    3", "de": "Gegeben ist ein rechteckiges Papier der Größe n x m, das in einem kartesischen Koordinatensystem auf einer Ebene liegt, mit seiner unteren linken Ecke bei (0,0) und der oberen rechten Ecke bei (n,m). \nSie müssen die erwartete Anzahl von Operationen berechnen, um das Papier so zu schneiden, dass die verbleibende Fläche kleiner als k ist. \nBei jeder Operation wird eine Linie zufällig gewählt, die parallel zu den Achsen verläuft, durch Punkte mit ganzzahligen Koordinaten geht und das Papier durchschneidet (nicht nur den Rand berührt). Der untere oder rechte Teil des Papiers entlang dieser Linie wird dann verworfen.\nDie Antwort sollte modulo 10^9+7 sein.\n\nBeispiel:\n    >>> expectedCuts(3, 3, 4)\n    3", "ha": "An ba takarda mai siffar rectangle mai girman n x m wanda aka sanya a kan tsarin daidaitawa na Cartesian tare da kusurwar ƙasa-hagu a (0,0) da kusurwar sama-dama a (n,m), \nkana buƙatar ƙididdige yawan ayyukan da ake tsammani don yanke takardar ta yadda yankin da ya rage ya kasance ƙasa da k. \nA kowane aiki, ana zaɓar layi da bazuwar wanda yake daidai da ginshiƙai, yana wucewa ta wuraren da ke da daidaitattun lambobi, kuma yana yanke (ba kawai taɓa gefen ba) takardar. Ana watsar da ɓangaren ƙasa ko dama na takardar tare da wannan layin.\nAmsar ya kamata ta kasance modulo 10^9+7.\n\nMisali:\n    >>> expectedCuts(3, 3, 4)\n    3", "hi": "दी गई एक आयताकार कागज की शीट का आकार n x m है, जो एक समतल कार्टेशियन निर्देशांक प्रणाली पर रखा गया है, जिसकी निचली-बाईं कोने का स्थान (0,0) और ऊपरी-दाईं कोने का स्थान (n,m) है। \nआपको यह गणना करनी है कि कागज को काटने के लिए अपेक्षित संचालन की संख्या कितनी होगी ताकि शेष क्षेत्रफल k से कम हो जाए। \nप्रत्येक संचालन में, एक रेखा को यादृच्छिक रूप से चुना जाता है जो अक्षों के समानांतर होती है, पूर्णांक निर्देशांक वाले बिंदुओं से गुजरती है, और कागज को काटती है (सिर्फ किनारे को छूने वाली नहीं)। इस रेखा के साथ कागज के निचले या दाईं हिस्से को फिर त्याग दिया जाता है।\nउत्तर 10^9+7 के मापांक में होना चाहिए।\n\nउदाहरण के लिए:\n    >>> expectedCuts(3, 3, 4)\n    3", "hu": "Adott egy n x m méretű téglalap alakú papír, amely a derékszögű koordináta-rendszer síkján helyezkedik el, az alsó-bal sarka a (0,0) pontban, a felső-jobb sarka pedig az (n,m) pontban van. \nKi kell számítani a várható műveletek számát, hogy a papírt úgy vágjuk fel, hogy a megmaradó terület kisebb legyen, mint k. \nMinden művelet során véletlenszerűen választunk egy vonalat, amely párhuzamos a tengelyekkel, egész koordinátájú pontokon halad át, és átvágja (nem csak érinti a szélét) a papírt. A papír ezen vonal mentén lévő alsó vagy jobb részét eldobjuk.\nA válasznak 10^9+7 modulo szerint kell lennie.\n\nPéldául:\n    >>> expectedCuts(3, 3, 4)\n    3", "es": "Dado un papel rectangular de tamaño n x m colocado en un sistema de coordenadas cartesianas en un plano con su esquina inferior izquierda en (0,0) y la esquina superior derecha en (n,m), necesitas calcular el número esperado de operaciones para cortar el papel de tal manera que el área restante sea menor que k. En cada operación, se elige aleatoriamente una línea que es paralela a los ejes, pasa por puntos con coordenadas enteras, y corta (no solo toca el borde) el papel. La parte inferior o derecha del papel a lo largo de esta línea se descarta. La respuesta debe ser módulo 10^9+7.\n\nPor ejemplo:\n    >>> expectedCuts(3, 3, 4)\n    3", "arb": "معطى ورقة مستطيلة بحجم n x m موضوعة على نظام إحداثيات ديكارتي مستوي مع زاويتها السفلية اليسرى عند (0,0) وزاويتها العلوية اليمنى عند (n,m)، تحتاج إلى حساب العدد المتوقع من العمليات لقطع الورقة بحيث تكون المساحة المتبقية أقل من k. في كل عملية، يتم اختيار خط عشوائي موازٍ للمحاور، يمر عبر نقاط ذات إحداثيات صحيحة، ويقطع (وليس فقط يلامس الحافة) الورقة. يتم بعد ذلك التخلص من الجزء السفلي أو الأيمن من الورقة على طول هذا الخط. يجب أن تكون الإجابة بتقسيم الباقي على 10^9+7.\n\nعلى سبيل المثال:\n    >>> expectedCuts(3, 3, 4)\n    3", "sw": "Kwa kuzingatia karatasi ya mstatili yenye ukubwa wa n x m iliyowekwa kwenye mfumo wa kuratibu wa Cartesian kwenye ndege na kona yake ya chini-kushoto iko kwenye (0,0) na kona ya juu-kulia iko kwenye (n,m), unahitaji kuhesabu idadi inayotarajiwa ya operesheni za kukata karatasi ili eneo lililobaki liwe chini ya k. Katika kila operesheni, mstari unachaguliwa kwa nasibu ambao ni sambamba na mhimili, unapita kupitia pointi zenye kuratibu za nambari kamili, na unakata (si kugusa tu ukingo) karatasi. Sehemu ya chini au ya kulia ya karatasi kando ya mstari huu kisha hutupwa. Jibu linapaswa kuwa modulo 10^9+7.\n\nKwa mfano:\n    >>> expectedCuts(3, 3, 4)\n    3", "tr": "Verilen bir dikdörtgen kağıt, n x m boyutlarında olup, düzlem Kartezyen koordinat sisteminde sol alt köşesi (0,0) ve sağ üst köşesi (n,m) olacak şekilde yerleştirilmiştir. \nKağıdın kalan alanının k'dan küçük olması için gereken beklenen işlem sayısını hesaplamanız gerekmektedir. \nHer işlemde, eksenlere paralel olan, tam sayı koordinatlarına sahip noktalardan geçen ve kağıdı kesen (sadece kenara dokunmayan) bir çizgi rastgele seçilir. Bu çizgi boyunca kağıdın alt veya sağ kısmı atılır.\nCevap, 10^9+7 ile mod alınmalıdır.\n\nÖrneğin:\n    >>> expectedCuts(3, 3, 4)\n    3", "vi": "Cho một tờ giấy hình chữ nhật kích thước n x m được đặt trên hệ tọa độ Đề-các phẳng với góc dưới bên trái tại (0,0) và góc trên bên phải tại (n,m), bạn cần tính số lượng kỳ vọng các thao tác để cắt giấy sao cho diện tích còn lại nhỏ hơn k. Trong mỗi thao tác, một đường thẳng được chọn ngẫu nhiên song song với các trục, đi qua các điểm có tọa độ nguyên và cắt qua (không chỉ chạm vào cạnh) tờ giấy. Phần dưới hoặc bên phải của tờ giấy dọc theo đường này sau đó bị loại bỏ. Câu trả lời nên được tính theo modulo 10^9+7.\n\nVí dụ:\n    >>> expectedCuts(3, 3, 4)\n    3", "id": "Diberikan selembar kertas persegi panjang berukuran n x m yang ditempatkan pada sistem koordinat Kartesius dengan sudut kiri bawah di (0,0) dan sudut kanan atas di (n,m), Anda perlu menghitung jumlah operasi yang diharapkan untuk memotong kertas sehingga area yang tersisa kurang dari k. Dalam setiap operasi, sebuah garis dipilih secara acak yang sejajar dengan sumbu, melewati titik-titik dengan koordinat bilangan bulat, dan memotong (bukan hanya menyentuh tepi) kertas. Bagian bawah atau kanan dari kertas sepanjang garis ini kemudian dibuang. Jawabannya harus dalam modulo 10^9+7.\n\nSebagai contoh:\n    >>> expectedCuts(3, 3, 4)\n    3", "ja": "与えられたサイズ n x m の長方形の紙が、平面直交座標系上に配置されており、その左下の角が (0,0)、右上の角が (n,m) にあります。この紙を切って残りの面積が k 未満になるまでの操作の期待回数を計算する必要があります。各操作では、軸に平行で、整数座標を持つ点を通り、紙を切断する（ただし、単に端に触れるだけではない）線がランダムに選ばれます。この線に沿った紙の下部または右側がその後破棄されます。\n答えは 10^9+7 での剰余として返す必要があります。\n\n例えば:\n    >>> expectedCuts(3, 3, 4)\n    3", "ko": "주어진 크기가 n x m인 직사각형 종이가 평면 직교 좌표계에 놓여 있으며, 그 왼쪽 아래 모서리가 (0,0)에 있고 오른쪽 위 모서리가 (n,m)에 있습니다. \n남은 면적이 k보다 작아지도록 종이를 자르는 작업의 예상 횟수를 계산해야 합니다. \n각 작업에서, 축에 평행하고 정수 좌표를 가지는 점을 통과하며 종이를 자르는 (단순히 가장자리를 만지는 것이 아님) 선이 무작위로 선택됩니다. 그런 다음 이 선을 따라 종이의 아래쪽 또는 오른쪽 부분이 버려집니다.\n답은 10^9+7로 나눈 나머지여야 합니다.\n\n예를 들어:\n    >>> expectedCuts(3, 3, 4)\n    3", "ml": "നിർദ്ദേശിച്ചിരിക്കുന്ന n x m വലുപ്പമുള്ള ഒരു ചതുരശ്ര കാഗിതം (0,0) എന്ന കോണിൽ നിന്ന് (n,m) എന്ന കോണിൽ വരെ ഒരു പ്ലെയിൻ കാർട്ടീഷ്യൻ കോഓർഡിനേറ്റ് സിസ്റ്റത്തിൽ സ്ഥാപിച്ചിരിക്കുന്നതാണെങ്കിൽ, ശേഷിക്കുന്ന വിസ്തീർണം k-ൽ കുറവായിരിക്കാനായി കാഗിതം മുറിക്കാൻ ആവശ്യമായ പ്രതീക്ഷിക്കുന്ന പ്രവർത്തനങ്ങളുടെ എണ്ണം കണക്കാക്കേണ്ടതുണ്ട്. ഓരോ പ്രവർത്തനത്തിലും, അച്ചുതണ്ടുകളോട് സമാന്തരമായി, പൂർണ്ണസംഖ്യ കോഓർഡിനേറ്റുകളുള്ള ബിന്ദുക്കളിലൂടെ കടന്നുപോകുന്ന ഒരു വരി യാദൃശ്ചികമായി തിരഞ്ഞെടുക്കപ്പെടുന്നു, ഇത് കാഗിതത്തെ (അറ്റത്ത് മാത്രം സ്പർശിക്കുന്നത് അല്ല) മുറിക്കുന്നു. ഈ വരിയോടൊപ്പം കാഗിതത്തിന്റെ അടിഭാഗം അല്ലെങ്കിൽ വലതുഭാഗം പിന്നീട് ഉപേക്ഷിക്കുന്നു. ഉത്തരം 10^9+7 ന്റെ മോഡുലോ ആയിരിക്കണം.\n\nഉദാഹരണത്തിന്:\n    >>> expectedCuts(3, 3, 4)\n    3", "fa": "با توجه به یک کاغذ مستطیلی به اندازه n x m که در یک سیستم مختصات دکارتی صفحه قرار دارد و گوشه پایین-چپ آن در (0,0) و گوشه بالا-راست آن در (n,m) است، \nشما باید تعداد مورد انتظار عملیات‌ها را برای بریدن کاغذ به گونه‌ای که مساحت باقی‌مانده کمتر از k باشد، محاسبه کنید. \nدر هر عملیات، یک خط به صورت تصادفی انتخاب می‌شود که موازی با محور‌ها است، از نقاط با مختصات صحیح عبور می‌کند و از کاغذ عبور می‌کند (نه فقط لبه را لمس کند). سپس قسمت پایین یا راست کاغذ در امتداد این خط دور انداخته می‌شود.\nپاسخ باید به صورت مدولوی 10^9+7 باشد.\n\nبرای مثال:\n    >>> expectedCuts(3, 3, 4)\n    3"}}
{"task_id": "C/43", "prompt": {"en": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n/*\nGiven a permutation q of n elements and an integer k, find the number of permutations p of n elements such that f(p) = q, where f(p) is the lexicographically smallest permutation that can be obtained by dividing p into exactly k non-empty contiguous segments and sorting each segment(that is, choose $ k-1 $ breakpoints $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, and divide it into $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). The result should be modulo 998244353.\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])", "sq": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n/*\nDuke pasur një permutacion q të n elementeve dhe një numër të plotë k, gjeni numrin e permutacioneve p të n elementeve të tilla që f(p) = q, ku f(p) është permutacioni më i vogël leksikografik që mund të merret duke ndarë p në saktësisht k segmente të pandara dhe duke renditur secilin segment (domethënë, zgjidhni $ k-1 $ pika ndarëse $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, dhe ndajeni në $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). Rezultati duhet të jetë modulo 998244353.\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])", "hy": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n/*\nՏրված է n տարրերի q փոխատեղումը և k ամբողջ թիվը, գտնել n տարրերի p փոխատեղումների քանակը, այնպես, որ f(p) = q, որտեղ f(p)-ն ամենափոքր լեքսիկոգրաֆիկ փոխատեղումն է, որը կարելի է ստանալ p-ն բաժանելով հենց k ոչ դատարկ հարակից հատվածների և դասավորելով յուրաքանչյուր հատվածը (այսինքն, ընտրել $ k-1 $ կոտրման կետեր $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, և բաժանել այն $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $): Արդյունքը պետք է լինի 998244353 մոդուլով:\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])", "bn": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n/*\nn উপাদানের একটি permutation q এবং একটি পূর্ণসংখ্যা k দেওয়া আছে, n উপাদানের কতগুলি permutation p আছে তা খুঁজে বের করুন যাতে f(p) = q হয়, যেখানে f(p) হল lexicographically ক্ষুদ্রতম permutation যা ঠিক k টি non-empty contiguous segment এ p কে ভাগ করে এবং প্রতিটি segment sort করে পাওয়া যেতে পারে (অর্থাৎ, $ k-1 $ breakpoints $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $ নির্বাচন করুন, এবং এটিকে $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $ এ ভাগ করুন)। ফলাফলটি 998244353 দ্বারা modulo করা উচিত।\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])", "bg": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n/*\nДадена е пермутация q от n елемента и цяло число k, намерете броя на пермутациите p от n елемента, такива че f(p) = q, където f(p) е лексикографски най-малката пермутация, която може да се получи, като се раздели p на точно k непразни съседни сегмента и се сортира всеки сегмент (т.е. изберете $ k-1 $ точки на прекъсване $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, и го разделете на $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). Резултатът трябва да бъде модуло 998244353.\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])", "zh": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n/*\n给定一个由 n 个元素组成的排列 q 和一个整数 k，找到 n 个元素的排列 p 的数量，使得 f(p) = q，其中 f(p) 是通过将 p 分成恰好 k 个非空连续段并对每个段进行排序可以获得的字典序最小的排列（即，选择 $ k-1 $ 个断点 $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $，并将其分为 $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $）。结果应对 998244353 取模。\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])", "fr": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n/*\nÉtant donné une permutation q de n éléments et un entier k, trouver le nombre de permutations p de n éléments telles que f(p) = q, où f(p) est la plus petite permutation lexicographique qui peut être obtenue en divisant p en exactement k segments contigus non vides et en triant chaque segment (c'est-à-dire, choisir $ k-1 $ points de rupture $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, et le diviser en $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). Le résultat doit être modulo 998244353.\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])", "de": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n/*\nGegeben eine Permutation q von n Elementen und eine ganze Zahl k, finde die Anzahl der Permutationen p von n Elementen, so dass f(p) = q, wobei f(p) die lexikographisch kleinste Permutation ist, die durch das Aufteilen von p in genau k nicht-leere zusammenhängende Segmente und das Sortieren jedes Segments erhalten werden kann (das heißt, wähle $ k-1 $ Trennpunkte $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, und teile es in $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). Das Ergebnis sollte modulo 998244353 sein.\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])", "ha": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n/*\nAn ba da wata permutation q na abubuwa n da kuma wani lamba k, nemo yawan permutations p na abubuwa n irin haka f(p) = q, inda f(p) shine permutation mafi ƙaranci a cikin tsarin lexicographically wanda za a iya samu ta hanyar raba p zuwa daidai k sassa masu cike da abubuwa kuma a jera kowane sashe (wato, zaɓi $ k-1 $ wuraren tsayawa $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, kuma raba shi zuwa $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). Sakamakon ya zama modulo 998244353.\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])", "hi": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n/*\nदिए गए n तत्वों के एक क्रमचय q और एक पूर्णांक k के लिए, n तत्वों के क्रमचयों की संख्या खोजें p ताकि f(p) = q, जहाँ f(p) वह शब्दकोशीय रूप से सबसे छोटा क्रमचय है जो p को ठीक k गैर-खाली संलग्न खंडों में विभाजित करके और प्रत्येक खंड को क्रमबद्ध करके प्राप्त किया जा सकता है (अर्थात, $ k-1 $ ब्रेकपॉइंट चुनें $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, और इसे $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $ में विभाजित करें)। परिणाम को 998244353 से मापांकित किया जाना चाहिए।\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])", "hu": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n/*\nEgy n elemű q permutáció és egy egész szám k esetén találjuk meg azon n elemű p permutációk számát, amelyekre f(p) = q, ahol f(p) a lexikografikusan legkisebb permutáció, amelyet úgy kapunk, hogy p-t pontosan k nem üres, összefüggő szegmensre osztjuk és minden szegmenst sorba rendezünk (azaz válasszuk ki a $ k-1 $ töréspontokat $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, és osszuk fel $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $ részekre). Az eredményt 998244353-mal vett maradékként kell megadni.\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])", "es": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n/*\nDada una permutación q de n elementos y un entero k, encuentra el número de permutaciones p de n elementos tal que f(p) = q, donde f(p) es la permutación lexicográficamente más pequeña que se puede obtener dividiendo p en exactamente k segmentos contiguos no vacíos y ordenando cada segmento (es decir, elige $ k-1 $ puntos de ruptura $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, y divídelo en $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). El resultado debe ser módulo 998244353.\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])", "arb": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n/*\nبالنظر إلى تبديل q من n عنصرًا وعدد صحيح k، ابحث عن عدد التبديلات p من n عنصرًا بحيث يكون f(p) = q، حيث أن f(p) هو التبديل الأصغر لغويًا الذي يمكن الحصول عليه عن طريق تقسيم p إلى k مقاطع متجاورة غير فارغة بالضبط وترتيب كل مقطع (أي، اختر $ k-1 $ نقاط توقف $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $، وقسمها إلى $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). يجب أن تكون النتيجة موديولو 998244353.\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])", "sw": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n/*\nIkizingatiwa permutation q ya vipengele n na nambari k, pata idadi ya permutations p ya vipengele n kama f(p) = q, ambapo f(p) ni permutation ndogo zaidi kwa mpangilio wa lexicographically ambayo inaweza kupatikana kwa kugawanya p katika sehemu k zisizo tupu zinazofuatana na kupanga kila sehemu (yaani, chagua $ k-1 $ alama za kuvunja $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, na igawanye katika $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). Matokeo yanapaswa kuwa modulo 998244353.\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])", "tr": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n/*\nn elemanlı bir q permütasyonu ve bir tamsayı k verildiğinde, f(p) = q olacak şekilde n elemanlı kaç tane p permütasyonu olduğunu bulun, burada f(p), p'yi tam olarak k boş olmayan ardışık segmente bölerek ve her segmenti sıralayarak elde edilebilecek sözlük sırasına göre en küçük permütasyondur (yani, $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $ olacak şekilde $ k-1 $ kırılma noktası seçin ve bunu $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $ olarak bölün). Sonuç 998244353 ile mod alınmalıdır.\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])", "vi": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n/*\nCho một hoán vị q của n phần tử và một số nguyên k, tìm số lượng hoán vị p của n phần tử sao cho f(p) = q, trong đó f(p) là hoán vị nhỏ nhất theo thứ tự từ điển có thể thu được bằng cách chia p thành chính xác k đoạn liên tiếp không rỗng và sắp xếp từng đoạn (tức là, chọn $ k-1 $ điểm ngắt $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, và chia nó thành $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). Kết quả phải được lấy modulo 998244353.\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])", "id": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n/*\nDiberikan sebuah permutasi q dari n elemen dan sebuah bilangan bulat k, temukan jumlah permutasi p dari n elemen sedemikian rupa sehingga f(p) = q, di mana f(p) adalah permutasi terkecil secara leksikografis yang dapat diperoleh dengan membagi p menjadi tepat k segmen kontigu yang tidak kosong dan mengurutkan setiap segmen (yaitu, pilih $ k-1 $ titik putus $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, dan bagi menjadi $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). Hasilnya harus dalam modulo 998244353.\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])\n", "ja": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n/*\nn個の要素の順列qと整数kが与えられたとき、f(p) = qとなるn個の要素の順列pの数を求めます。ここで、f(p)はpをちょうどk個の空でない連続したセグメントに分割し、各セグメントをソートすることで得られる辞書順で最小の順列です（つまり、$ k-1 $個のブレークポイント$ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $を選び、$ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $に分割します）。結果は998244353で割った余りとします。\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])", "ko": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n/*\nn개의 요소로 구성된 순열 q와 정수 k가 주어졌을 때, f(p) = q를 만족하는 n개의 요소로 구성된 순열 p의 개수를 찾으시오. 여기서 f(p)는 p를 정확히 k개의 비어 있지 않은 연속된 구간으로 나누고 각 구간을 정렬하여 얻을 수 있는 사전식으로 가장 작은 순열입니다(즉, $ k-1 $개의 분할점을 선택하여 $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $을 만족하고, 이를 $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $으로 나누는 것입니다). 결과는 998244353로 나눈 나머지여야 합니다.\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])\n", "ml": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n/*\nn ഘടകങ്ങളുടെ ഒരു permutation q ഉം ഒരു പൂർണ്ണസംഖ്യ k ഉം നൽകിയാൽ, n ഘടകങ്ങളുടെ permutation p കളുടെ എണ്ണം കണ്ടെത്തുക, അങ്ങനെ f(p) = q, ഇവിടെ f(p)正് കൃത്യമായി k ശൂന്യമല്ലാത്ത തുടർച്ചയായ വിഭാഗങ്ങളായി p നെ വിഭജിച്ച് ഓരോ വിഭാഗവും ക്രമീകരിച്ച് ലഭിക്കാവുന്ന ലെക്സികോഗ്രാഫിക്കായി ഏറ്റവും ചെറിയ permutation ആണ് (അത്, $ k-1 $ ബ്രേക്ക്പോയിന്റുകൾ $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $ തിരഞ്ഞെടുക്കുക, അത് $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $ ആയി വിഭജിക്കുക). ഫലം 998244353 ന്റെ മോഡുലോ ആയിരിക്കണം.\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])", "fa": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n/*\nبا توجه به یک جایگشت q از n عنصر و یک عدد صحیح k، تعداد جایگشت‌های p از n عنصر را پیدا کنید به طوری که f(p) = q، که در آن f(p) کوچکترین جایگشت لغت‌نامه‌ای است که می‌تواند با تقسیم p به دقیقا k بخش متوالی غیر خالی و مرتب‌سازی هر بخش به دست آید (یعنی، $ k-1 $ نقاط شکست $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $ را انتخاب کنید و آن را به $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $ تقسیم کنید). نتیجه باید به پیمانه 998244353 باشد.\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])\n"}, "canonical_solution": "{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i ^ m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}", "instruction": {"en": "int countPermutations(int n, int k, int qq[])\n{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i ^ m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "sq": "int countPermutations(int n, int k, int qq[])\n{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i ^ m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C në shqip duke përdorur maksimumi 500 karaktere.", "hy": "int countPermutations(int n, int k, int qq[])\n{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i ^ m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}\n\nՏվեք C կոդի հակիրճ բնութագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "int countPermutations(int n, int k, int qq[])\n{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i ^ m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}\n\nনিচের C কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।", "bg": "int countPermutations(int n, int k, int qq[])\n{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i ^ m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, използвайки най-много 500 знака.", "zh": "int countPermutations(int n, int k, int qq[])\n{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i ^ m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}\n\n请用不超过500个字符的中文，为以下C代码提供简洁的自然语言描述（文档字符串）。", "fr": "int countPermutations(int n, int k, int qq[])\n{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i ^ m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.", "de": "int countPermutations(int n, int k, int qq[])\n{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i ^ m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen.", "ha": "int countPermutations(int n, int k, int qq[])\n{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i ^ m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}\n\nBa da takaitaccen bayani a cikin yaren halitta (docstring) na lambar C cikin Hausa, ba tare da wuce haruffa 500 ba.", "hi": "int countPermutations(int n, int k, int qq[])\n{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i ^ m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}\n\nC कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "int countPermutations(int n, int k, int qq[])\n{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i ^ m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakter felhasználásával.", "es": "int countPermutations(int n, int k, int qq[])\n{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i ^ m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando como máximo 500 caracteres.", "arb": "int countPermutations(int n, int k, int qq[])\n{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i ^ m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى، باستخدام 500 حرف كحد أقصى.", "sw": "int countPermutations(int n, int k, int qq[])\n{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i ^ m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "int countPermutations(int n, int k, int qq[])\n{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i ^ m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}\n\nC kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter kullanılmalıdır.", "vi": "int countPermutations(int n, int k, int qq[])\n{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i ^ m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã C bằng tiếng Việt, sử dụng tối đa 500 ký tự.", "id": "int countPermutations(int n, int k, int qq[])\n{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i ^ m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode C tersebut dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "int countPermutations(int n, int k, int qq[])\n{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i ^ m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}\n\nC コードの簡単な自然言語による説明 (docstring) を英語で最大 500 文字まで入力してください。", "ko": "int countPermutations(int n, int k, int qq[])\n{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i ^ m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}\n\nC 코드에 대한 간결한 자연어 설명(도크스트링)을 한국어로 최대 500자 이내로 제공하세요.", "ml": "int countPermutations(int n, int k, int qq[])\n{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i ^ m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}\n\nസിഎ കോഡിന്റെ സംക്ഷിപ്തമായ സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) പരമാവധി 500 അക്ഷരങ്ങളിൽ മലയാളത്തിൽ നൽകുക.", "fa": "int countPermutations(int n, int k, int qq[])\n{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i ^ m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}\n\nیک توضیح مختصر به زبان طبیعی (docstring) از کد C به زبان فارسی ارائه دهید که حداکثر ۵۰۰ کاراکتر باشد."}, "level": "", "test": "int main() {\n    int q1[] = {1, 2};\n    assert(countPermutations(2, 1, q1) == 2);\n\n    int q2[] = {3, 1, 2};\n    assert(countPermutations(3, 3, q2) == 1);\n\n    int q3[] = {1, 2, 3, 6, 5, 4};\n    assert(countPermutations(6, 3, q3) == 13);\n\n    int q4[] = {1, 2, 3, 4, 5, 6};\n    assert(countPermutations(6, 1, q4) == 720);\n\n    int q5[] = {1, 2, 5, 3, 4, 5};\n    assert(countPermutations(6, 3, q5) == 0);\n\n    int q6[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n    assert(countPermutations(9, 9, q6) == 1);\n\n    int q7[] = {1, 2, 3, 4, 5, 6, 7, 9, 8};\n    assert(countPermutations(9, 2, q7) == 29093);\n    return 0;}", "entry_point": "countPermutations", "signature": "int countPermutations(int n, int k, int qq[])", "docstring": {"en": "Given a permutation q of n elements and an integer k, find the number of permutations p of n elements such that f(p) = q, where f(p) is the lexicographically smallest permutation that can be obtained by dividing p into exactly k non-empty contiguous segments and sorting each segment(that is, choose $ k-1 $ breakpoints $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, and divide it into $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). The result should be modulo 998244353.\n    >>> countPermutations(2, 1, [1, 2])\n    2\n", "sq": "Duke pasur një permutacion q të n elementeve dhe një numër të plotë k, gjeni numrin e permutacioneve p të n elementeve të tilla që f(p) = q, ku f(p) është permutacioni më i vogël leksikografik që mund të merret duke ndarë p në saktësisht k segmente të pandara dhe duke renditur secilin segment (kjo është, zgjidhni $ k-1 $ pika ndarëse $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, dhe ndajeni në $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). Rezultati duhet të jetë modulo 998244353.\n    >>> countPermutations(2, 1, [1, 2])\n    2", "hy": "Տրված է n տարրերի q փոխատեղումը և k ամբողջ թիվը, գտնել n տարրերի p փոխատեղումների քանակը, այնպես, որ f(p) = q, որտեղ f(p)-ն լեքսիկոգրաֆիկորեն ամենափոքր փոխատեղումն է, որը կարելի է ստանալ p-ն ճշգրիտ k ոչ դատարկ հարակից հատվածների բաժանելով և յուրաքանչյուր հատվածը դասավորելով (այսինքն, ընտրել $ k-1 $ բաժանման կետեր $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, և բաժանել այն $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $): Արդյունքը պետք է լինի 998244353 մոդուլով:\n    >>> countPermutations(2, 1, [1, 2])\n    2", "bn": "একটি n উপাদানের পারমুটেশন q এবং একটি পূর্ণসংখ্যা k দেওয়া আছে, এমন n উপাদানের পারমুটেশন p-এর সংখ্যা খুঁজে বের করুন যাতে f(p) = q হয়, যেখানে f(p) হল লেক্সিকোগ্রাফিকভাবে সবচেয়ে ছোট পারমুটেশন যা p কে ঠিক k টি খালি নয় এমন ধারাবাহিক সেগমেন্টে ভাগ করে এবং প্রতিটি সেগমেন্টকে সাজিয়ে পাওয়া যায় (অর্থাৎ, $ k-1 $ ব্রেকপয়েন্ট $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $ নির্বাচন করুন এবং এটিকে $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $ এ ভাগ করুন)। ফলাফলটি 998244353 দ্বারা মডুলো করা উচিত।\n    >>> countPermutations(2, 1, [1, 2])\n    2", "bg": "Дадена е пермутация q от n елемента и цяло число k, намерете броя на пермутациите p от n елемента, такива че f(p) = q, където f(p) е лексикографски най-малката пермутация, която може да бъде получена чрез разделяне на p на точно k непразни съседни сегмента и сортиране на всеки сегмент (т.е. изберете $ k-1 $ точки на прекъсване $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, и го разделете на $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). Резултатът трябва да бъде модуло 998244353.\n    >>> countPermutations(2, 1, [1, 2])\n    2", "zh": "给定一个由 n 个元素组成的排列 q 和一个整数 k，找出 n 个元素的排列 p 的数量，使得 f(p) = q，其中 f(p) 是通过将 p 精确地划分为 k 个非空连续段并对每个段进行排序后可以获得的字典序最小的排列（即，选择 $ k-1 $ 个断点 $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $，并将其划分为 $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $）。结果应对 998244353 取模。\n    >>> countPermutations(2, 1, [1, 2])\n    2", "fr": "Étant donné une permutation q de n éléments et un entier k, trouvez le nombre de permutations p de n éléments telles que f(p) = q, où f(p) est la permutation lexicographiquement la plus petite qui peut être obtenue en divisant p en exactement k segments contigus non vides et en triant chaque segment (c'est-à-dire, choisir $ k-1 $ points de rupture $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, et le diviser en $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). Le résultat doit être modulo 998244353.\n    >>> countPermutations(2, 1, [1, 2])\n    2", "de": "Gegeben eine Permutation q von n Elementen und eine ganze Zahl k, finde die Anzahl der Permutationen p von n Elementen, so dass f(p) = q, wobei f(p) die lexikographisch kleinste Permutation ist, die erhalten werden kann, indem p in genau k nicht-leere zusammenhängende Segmente unterteilt und jedes Segment sortiert wird (das heißt, wähle $ k-1 $ Trennpunkte $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, und teile es in $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). Das Ergebnis sollte modulo 998244353 sein.\n    >>> countPermutations(2, 1, [1, 2])\n    2", "ha": "An ba da wata permutation q na abubuwa n da kuma wani lamba k, nemo yawan permutations p na abubuwa n da suke cika f(p) = q, inda f(p) shine permutation mafi ƙarancin lexicographically wanda za a iya samu ta hanyar raba p zuwa k daidai baƙaƙen sassa masu ɗorewa kuma a tsara kowane sashe (wato, zaɓi $ k-1 $ wuraren tsagewa $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, kuma raba shi zuwa $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). Sakamakon ya zama modulo 998244353.\n    >>> countPermutations(2, 1, [1, 2])\n    2", "hi": "दी गई n तत्वों की एक क्रमचय q और एक पूर्णांक k के लिए, n तत्वों की उन क्रमचयों की संख्या खोजें जिनके लिए f(p) = q है, जहाँ f(p) वह शब्दकोशानुसार सबसे छोटी क्रमचय है जो p को ठीक k गैर-खाली संलग्न खंडों में विभाजित करके और प्रत्येक खंड को क्रमबद्ध करके प्राप्त की जा सकती है (अर्थात, $ k-1 $ ब्रेकपॉइंट्स $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $ चुनें, और इसे $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $ में विभाजित करें)। परिणाम 998244353 के मापांक में होना चाहिए।\n    >>> countPermutations(2, 1, [1, 2])\n    2", "hu": "Adott egy q permutáció n elemről és egy k egész szám, keresse meg az n elemű p permutációk számát úgy, hogy f(p) = q, ahol f(p) az a lexikográfiailag legkisebb permutáció, amelyet úgy lehet megkapni, hogy p-t pontosan k nem üres, összefüggő szegmensre osztjuk, és minden szegmenst rendezünk (azaz válasszunk $ k-1 $ töréspontot $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, és osszuk fel $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $ részekre). Az eredménynek 998244353-mal vett maradéka legyen.\n    >>> countPermutations(2, 1, [1, 2])\n    2", "es": "Dada una permutación q de n elementos y un entero k, encuentra el número de permutaciones p de n elementos tal que f(p) = q, donde f(p) es la permutación lexicográficamente más pequeña que se puede obtener dividiendo p en exactamente k segmentos contiguos no vacíos y ordenando cada segmento (es decir, elige $ k-1 $ puntos de ruptura $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, y divídelo en $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). El resultado debe ser módulo 998244353.\n    >>> countPermutations(2, 1, [1, 2])\n    2", "arb": "معطى ترتيب q من n عنصرًا وعدد صحيح k، ابحث عن عدد الترتيبات p من n عنصرًا بحيث f(p) = q، حيث f(p) هو الترتيب الأصغر لغويًا الذي يمكن الحصول عليه عن طريق تقسيم p إلى k مقاطع متجاورة غير فارغة بالضبط وترتيب كل مقطع (أي اختيار $ k-1 $ نقاط توقف $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $، وتقسيمها إلى $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). يجب أن تكون النتيجة مودولو 998244353.\n    >>> countPermutations(2, 1, [1, 2])\n    2", "sw": "Given a permutation q of n elements and an integer k, find the number of permutations p of n elements such that f(p) = q, where f(p) is the lexicographically smallest permutation that can be obtained by dividing p into exactly k non-empty contiguous segments and sorting each segment(that is, choose $ k-1 $ breakpoints $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, and divide it into $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). The result should be modulo 998244353.\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\nArgs:\n    n: Idadi ya vipengele katika permutation.\n    k: Idadi ya sehemu zisizo tupu za mfululizo.\n    q: Permutation inayolengwa ya vipengele n.\n\nReturns:\n    Idadi ya permutations p za vipengele n kama ilivyoelezwa, moduli 998244353.\n\nExamples:\n    >>> countPermutations(3, 2, [1, 3, 2])\n    1", "tr": "Verilen n elemanlı bir q permütasyonu ve bir k tam sayısı için, f(p) = q olacak şekilde n elemanlı kaç tane p permütasyonu olduğunu bulun. Burada f(p), p'yi tam olarak k tane boş olmayan ardışık segmente bölüp her segmenti sıralayarak elde edilebilecek sözlük sırasına göre en küçük permütasyondur (yani, $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $ olacak şekilde $ k-1 $ tane kırılma noktası seçin ve bunu $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $ olarak bölün). Sonuç 998244353 ile mod alınmalıdır.\n    >>> countPermutations(2, 1, [1, 2])\n    2", "vi": "Given a permutation q của n phần tử và một số nguyên k, tìm số lượng hoán vị p của n phần tử sao cho f(p) = q, trong đó f(p) là hoán vị nhỏ nhất theo thứ tự từ điển có thể thu được bằng cách chia p thành chính xác k đoạn liên tiếp không rỗng và sắp xếp từng đoạn (tức là, chọn $ k-1 $ điểm ngắt $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, và chia nó thành $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). Kết quả nên được lấy modulo 998244353.\n    >>> countPermutations(2, 1, [1, 2])\n    2", "id": "Diberikan sebuah permutasi q dari n elemen dan sebuah bilangan bulat k, temukan jumlah permutasi p dari n elemen sedemikian rupa sehingga f(p) = q, di mana f(p) adalah permutasi terkecil secara leksikografis yang dapat diperoleh dengan membagi p menjadi tepat k segmen kontigu tidak kosong dan mengurutkan setiap segmen (yaitu, pilih $ k-1 $ titik putus $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, dan bagi menjadi $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). Hasilnya harus dalam modulo 998244353.\n    >>> countPermutations(2, 1, [1, 2])\n    2", "ja": "与えられた n 要素の順列 q と整数 k に対して、f(p) = q となる n 要素の順列 p の数を求めます。ここで f(p) は、p を正確に k 個の非空の連続したセグメントに分割し、各セグメントをソートすることで得られる辞書順で最小の順列です（つまり、$ k-1 $ 個のブレークポイント $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $ を選び、$ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $ に分割します）。結果は 998244353 でのモジュロとします。\n    >>> countPermutations(2, 1, [1, 2])\n    2", "ko": "주어진 n 요소의 순열 q와 정수 k가 있을 때, n 요소의 순열 p 중에서 f(p) = q가 되는 순열의 수를 찾으시오. 여기서 f(p)는 p를 정확히 k개의 비어 있지 않은 연속된 구간으로 나누고 각 구간을 정렬하여 얻을 수 있는 사전식으로 가장 작은 순열입니다(즉, $ k-1 $개의 분할점 $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $을 선택하고, 이를 $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $으로 나눕니다). 결과는 998244353로 나눈 나머지여야 합니다.\n    >>> countPermutations(2, 1, [1, 2])\n    2", "ml": "നൽകിയിരിക്കുന്ന n ഘടകങ്ങളുടെ ഒരു ക്രമീകരണവും ഒരു പൂർണ്ണസംഖ്യ kയും ഉപയോഗിച്ച്, n ഘടകങ്ങളുടെ ക്രമീകരണങ്ങളുടെ എണ്ണം കണ്ടെത്തുക, അങ്ങനെ f(p) = q, f(p) എന്നത് കൃത്യമായി k ശൂന്യമല്ലാത്ത തുടർച്ചയായ വിഭാഗങ്ങളായി p വിഭജിച്ച് ഓരോ വിഭാഗവും ക്രമീകരിച്ച് ലഭിക്കാവുന്ന ലെക്സിക്കോഗ്രാഫിക്കായി ഏറ്റവും ചെറിയ ക്രമീകരണമാണ് (അഥവാ, $ k-1 $ ബ്രേക്ക്പോയിന്റുകൾ $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $ തിരഞ്ഞെടുക്കുക, അതിനെ $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $ ആയി വിഭജിക്കുക). ഫലം 998244353 ന്റെ മോഡുലോ ആയിരിക്കണം.\n    >>> countPermutations(2, 1, [1, 2])\n    2", "fa": "با توجه به یک جایگشت q از n عنصر و یک عدد صحیح k، تعداد جایگشت‌های p از n عنصر را پیدا کنید به طوری که f(p) = q، که در آن f(p) کوچکترین جایگشت به ترتیب لغوی است که می‌توان با تقسیم p به دقیقا k بخش متوالی غیر خالی و مرتب‌سازی هر بخش به دست آورد (یعنی، $ k-1 $ نقطه شکست $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $ را انتخاب کنید و آن را به $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $ تقسیم کنید). نتیجه باید به صورت مدولوی 998244353 باشد.\n    >>> countPermutations(2, 1, [1, 2])\n    2"}}
{"task_id": "C/44", "prompt": {"en": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nGiven an array of n distinct integers representing the heights of Kira's friends, \nfind the number of ways to choose a triplet (a, b, c) such that the greatest common divisor (GCD) \nof the maximum and minimum values of the triplet is 1.\n    >>> countTriplets([1, 5, 7])\n    1\n*/\nint countTriplets(int heights[], int n)", "sq": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nDuke pasur një varg prej n numrash të plotë të dallueshëm që përfaqësojnë lartësitë e miqve të Kirës, \ngjeni numrin e mënyrave për të zgjedhur një treshe (a, b, c) të tillë që faktori më i madh i përbashkët (GCD) \ni vlerave maksimale dhe minimale të treshes të jetë 1.\n    >>> countTriplets([1, 5, 7])\n    1\n*/\nint countTriplets(int heights[], int n)", "hy": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nՏրված է n տարբեր ամբողջ թվերից բաղկացած զանգված, որը ներկայացնում է Կիրայի ընկերների բարձրությունները,\nգտնել եռյակ (a, b, c) ընտրելու եղանակների քանակը այնպես, որ եռյակի առավելագույն և նվազագույն արժեքների \nամենամեծ ընդհանուր բաժանարարը (GCD) լինի 1:\n    >>> countTriplets([1, 5, 7])\n    1\n*/\nint countTriplets(int heights[], int n)", "bn": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nকিরার বন্ধুদের উচ্চতা উপস্থাপনকারী n টি ভিন্ন পূর্ণসংখ্যার একটি অ্যারে দেওয়া হয়েছে,\nতিনটি (a, b, c) বেছে নেওয়ার উপায়ের সংখ্যা খুঁজুন যাতে ট্রিপলেটের সর্বাধিক এবং সর্বনিম্ন মানের \nমহানতম সাধারণ বিভাজক (GCD) 1 হয়।\n    >>> countTriplets([1, 5, 7])\n    1\n*/\nint countTriplets(int heights[], int n)", "bg": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nДаден е масив от n различни цели числа, представляващи височините на приятелите на Кира,\nнамерете броя на начините да изберете тройка (a, b, c) така, че най-големият общ делител (НОД)\nна максималната и минималната стойност на тройката да е 1.\n    >>> countTriplets([1, 5, 7])\n    1\n*/\nint countTriplets(int heights[], int n)", "zh": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\n给定一个由 n 个不同整数组成的数组，表示 Kira 朋友的身高，\n找出选择一个三元组 (a, b, c) 的方法数，使得该三元组的最大值和最小值的最大公约数 (GCD) 为 1。\n    >>> countTriplets([1, 5, 7])\n    1\n*/\nint countTriplets(int heights[], int n)", "fr": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nÉtant donné un tableau de n entiers distincts représentant les hauteurs des amis de Kira,\ntrouver le nombre de façons de choisir un triplet (a, b, c) tel que le plus grand diviseur commun (PGCD)\ndes valeurs maximale et minimale du triplet soit 1.\n    >>> countTriplets([1, 5, 7])\n    1\n*/\nint countTriplets(int heights[], int n)", "de": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nGegeben ein Array von n verschiedenen ganzen Zahlen, die die Größen von Kiras Freunden darstellen,\nfinde die Anzahl der Möglichkeiten, ein Tripel (a, b, c) zu wählen, so dass der größte gemeinsame Teiler (GCD)\nder maximalen und minimalen Werte des Tripels 1 ist.\n    >>> countTriplets([1, 5, 7])\n    1\n*/\nint countTriplets(int heights[], int n)", "ha": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nAn ba da wani tsari na lambobi daban-daban n da ke wakiltar tsayin abokan Kira,\nnemo yawan hanyoyin zaɓar triplet (a, b, c) ta yadda mafi girman mai raba kowa da kowa (GCD)\nna mafi girma da ƙananan ƙimomi na triplet shine 1.\n    >>> countTriplets([1, 5, 7])\n    1\n*/\nint countTriplets(int heights[], int n)", "hi": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nकिरा के दोस्तों की ऊंचाइयों का प्रतिनिधित्व करने वाले n विभिन्न पूर्णांकों की एक array दी गई है,\nऐसे त्रिक (a, b, c) को चुनने के तरीकों की संख्या खोजें ताकि त्रिक के अधिकतम और न्यूनतम मानों का महत्तम समापवर्तक (GCD) 1 हो।\n    >>> countTriplets([1, 5, 7])\n    1\n*/\nint countTriplets(int heights[], int n)", "hu": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nAdott egy tömb n különböző egész számmal, amelyek Kira barátainak magasságát képviselik,\ntalálja meg, hányféleképpen lehet kiválasztani egy hármast (a, b, c) úgy, hogy a hármas \nmaximumának és minimumának legnagyobb közös osztója (GCD) 1 legyen.\n    >>> countTriplets([1, 5, 7])\n    1\n*/\nint countTriplets(int heights[], int n)", "es": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nDado un arreglo de n enteros distintos que representan las alturas de los amigos de Kira,\nencuentra el número de formas de elegir un triplete (a, b, c) tal que el máximo común divisor (GCD)\nde los valores máximo y mínimo del triplete sea 1.\n    >>> countTriplets([1, 5, 7])\n    1\n*/\nint countTriplets(int heights[], int n)", "arb": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nبالنظر إلى مصفوفة تحتوي على n عدد صحيح مميز تمثل ارتفاعات أصدقاء كيرا،\nابحث عن عدد الطرق لاختيار ثلاثية (a, b, c) بحيث يكون القاسم المشترك الأكبر (GCD)\nللقيمتين العظمى والصغرى للثلاثية هو 1.\n    >>> countTriplets([1, 5, 7])\n    1\n*/\nint countTriplets(int heights[], int n)", "sw": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nUkipiwa safu ya n ya nambari za kipekee zinazoashiria urefu wa marafiki wa Kira,\npata idadi ya njia za kuchagua tatu (a, b, c) ili kwamba mgawanyiko mkubwa zaidi wa kawaida (GCD)\nwa thamani za juu na za chini za tatu ni 1.\n    >>> countTriplets([1, 5, 7])\n    1\n*/\nint countTriplets(int heights[], int n)", "tr": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nKira'nın arkadaşlarının yüksekliklerini temsil eden n farklı tam sayıdan oluşan bir dizi verildiğinde,\nbir üçlü (a, b, c) seçmenin kaç yolu olduğunu bulun, öyle ki üçlünün maksimum ve minimum değerlerinin\nen büyük ortak böleni (GCD) 1 olsun.\n    >>> countTriplets([1, 5, 7])\n    1\n*/\nint countTriplets(int heights[], int n)", "vi": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nCho một mảng gồm n số nguyên khác nhau đại diện cho chiều cao của bạn bè Kira,\ntìm số cách chọn một bộ ba (a, b, c) sao cho ước số chung lớn nhất (GCD)\ncủa giá trị lớn nhất và nhỏ nhất của bộ ba là 1.\n    >>> countTriplets([1, 5, 7])\n    1\n*/\nint countTriplets(int heights[], int n)", "id": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nDiberikan sebuah array dari n bilangan bulat berbeda yang mewakili tinggi teman-teman Kira, \ntemukan jumlah cara untuk memilih triplet (a, b, c) sedemikian rupa sehingga pembagi terbesar (GCD) \ndari nilai maksimum dan minimum dari triplet tersebut adalah 1.\n    >>> countTriplets([1, 5, 7])\n    1\n*/\nint countTriplets(int heights[], int n)", "ja": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nKiraの友人の身長を表すn個の異なる整数の配列が与えられたとき、\n3つ組 (a, b, c) を選ぶ方法の数を見つけてください。ここで、3つ組の最大値と最小値の最大公約数 (GCD) が1である。\n    >>> countTriplets([1, 5, 7])\n    1\n*/\nint countTriplets(int heights[], int n)", "ko": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nKira의 친구들의 높이를 나타내는 n개의 서로 다른 정수 배열이 주어졌을 때, \n삼중항 (a, b, c)을 선택하는 방법의 수를 찾으시오. 이때, 삼중항의 최대값과 최소값의 최대 공약수(GCD)가 1이어야 합니다.\n    >>> countTriplets([1, 5, 7])\n    1\n*/\nint countTriplets(int heights[], int n)", "ml": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nകിരയുടെ സുഹൃത്തുക്കളുടെ ഉയരങ്ങളെ പ്രതിനിധീകരിക്കുന്ന n വ്യത്യസ്ത പൂർണ്ണസംഖ്യകളുള്ള ഒരു നിര നൽകിയിരിക്കുന്നു,\nട്രിപ്പ്ലെറ്റ് (a, b, c) തിരഞ്ഞെടുക്കാനുള്ള മാർഗങ്ങളുടെ എണ്ണം കണ്ടെത്തുക, അങ്ങനെ ട്രിപ്പ്ലെറ്റിന്റെ പരമാവധി \nമിനിമം മൂല്യങ്ങളുടെ മഹത്തായ പൊതുഹര (GCD) 1 ആണ്.\n    >>> countTriplets([1, 5, 7])\n    1\n*/\nint countTriplets(int heights[], int n)", "fa": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nبا توجه به آرایه‌ای از n عدد صحیح متمایز که نشان‌دهنده قد دوستان کیرا هستند،\nتعداد روش‌های انتخاب یک سه‌تایی (a, b, c) را پیدا کنید به‌طوری‌که بزرگترین مقسوم‌علیه مشترک (GCD)\nبیشترین و کمترین مقادیر سه‌تایی برابر با 1 باشد.\n    >>> countTriplets([1, 5, 7])\n    1\n*/\nint countTriplets(int heights[], int n)"}, "canonical_solution": "{\n    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = (heights[i] < heights[j]) ? ((heights[i] < heights[k]) ? heights[i] : heights[k]) : ((heights[j] < heights[k]) ? heights[j] : heights[k]);\n                int maxVal = (heights[i] > heights[j]) ? ((heights[i] > heights[k]) ? heights[i] : heights[k]) : ((heights[j] > heights[k]) ? heights[j] : heights[k]);\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}", "instruction": {"en": "int countTriplets(int heights[], int n)\n{\n    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = (heights[i] < heights[j]) ? ((heights[i] < heights[k]) ? heights[i] : heights[k]) : ((heights[j] < heights[k]) ? heights[j] : heights[k]);\n                int maxVal = (heights[i] > heights[j]) ? ((heights[i] > heights[k]) ? heights[i] : heights[k]) : ((heights[j] > heights[k]) ? heights[j] : heights[k]);\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "sq": "int countTriplets(int heights[], int n)\n{\n    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = (heights[i] < heights[j]) ? ((heights[i] < heights[k]) ? heights[i] : heights[k]) : ((heights[j] < heights[k]) ? heights[j] : heights[k]);\n                int maxVal = (heights[i] > heights[j]) ? ((heights[i] > heights[k]) ? heights[i] : heights[k]) : ((heights[j] > heights[k]) ? heights[j] : heights[k]);\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C në shqip duke përdorur maksimumi 500 karaktere.", "hy": "int countTriplets(int heights[], int n)\n{\n    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = (heights[i] < heights[j]) ? ((heights[i] < heights[k]) ? heights[i] : heights[k]) : ((heights[j] < heights[k]) ? heights[j] : heights[k]);\n                int maxVal = (heights[i] > heights[j]) ? ((heights[i] > heights[k]) ? heights[i] : heights[k]) : ((heights[j] > heights[k]) ? heights[j] : heights[k]);\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\nՏվեք C կոդի հակիրճ բնութագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։", "bn": "int countTriplets(int heights[], int n)\n{\n    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = (heights[i] < heights[j]) ? ((heights[i] < heights[k]) ? heights[i] : heights[k]) : ((heights[j] < heights[k]) ? heights[j] : heights[k]);\n                int maxVal = (heights[i] > heights[j]) ? ((heights[i] > heights[k]) ? heights[i] : heights[k]) : ((heights[j] > heights[k]) ? heights[j] : heights[k]);\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\nসি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।", "bg": "int countTriplets(int heights[], int n)\n{\n    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = (heights[i] < heights[j]) ? ((heights[i] < heights[k]) ? heights[i] : heights[k]) : ((heights[j] < heights[k]) ? heights[j] : heights[k]);\n                int maxVal = (heights[i] > heights[j]) ? ((heights[i] > heights[k]) ? heights[i] : heights[k]) : ((heights[j] > heights[k]) ? heights[j] : heights[k]);\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\nПредоставете кратко описание на C кода на естествен език на български, използвайки не повече от 500 знака.", "zh": "int countTriplets(int heights[], int n)\n{\n    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = (heights[i] < heights[j]) ? ((heights[i] < heights[k]) ? heights[i] : heights[k]) : ((heights[j] < heights[k]) ? heights[j] : heights[k]);\n                int maxVal = (heights[i] > heights[j]) ? ((heights[i] > heights[k]) ? heights[i] : heights[k]) : ((heights[j] > heights[k]) ? heights[j] : heights[k]);\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\n请用不超过500个字符的中文，为以下C代码提供简洁的自然语言描述（文档字符串）。", "fr": "int countTriplets(int heights[], int n)\n{\n    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = (heights[i] < heights[j]) ? ((heights[i] < heights[k]) ? heights[i] : heights[k]) : ((heights[j] < heights[k]) ? heights[j] : heights[k]);\n                int maxVal = (heights[i] > heights[j]) ? ((heights[i] > heights[k]) ? heights[i] : heights[k]) : ((heights[j] > heights[k]) ? heights[j] : heights[k]);\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.", "de": "int countTriplets(int heights[], int n)\n{\n    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = (heights[i] < heights[j]) ? ((heights[i] < heights[k]) ? heights[i] : heights[k]) : ((heights[j] < heights[k]) ? heights[j] : heights[k]);\n                int maxVal = (heights[i] > heights[j]) ? ((heights[i] > heights[k]) ? heights[i] : heights[k]) : ((heights[j] > heights[k]) ? heights[j] : heights[k]);\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "int countTriplets(int heights[], int n)\n{\n    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = (heights[i] < heights[j]) ? ((heights[i] < heights[k]) ? heights[i] : heights[k]) : ((heights[j] < heights[k]) ? heights[j] : heights[k]);\n                int maxVal = (heights[i] > heights[j]) ? ((heights[i] > heights[k]) ? heights[i] : heights[k]) : ((heights[j] > heights[k]) ? heights[j] : heights[k]);\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\nBayar da takaitaccen bayanin harshen dabi'a (docstring) na lambar C cikin harshen Hausa ta amfani da haruffa 500 kacal.", "hi": "int countTriplets(int heights[], int n)\n{\n    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = (heights[i] < heights[j]) ? ((heights[i] < heights[k]) ? heights[i] : heights[k]) : ((heights[j] < heights[k]) ? heights[j] : heights[k]);\n                int maxVal = (heights[i] > heights[j]) ? ((heights[i] > heights[k]) ? heights[i] : heights[k]) : ((heights[j] > heights[k]) ? heights[j] : heights[k]);\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\nC कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "int countTriplets(int heights[], int n)\n{\n    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = (heights[i] < heights[j]) ? ((heights[i] < heights[k]) ? heights[i] : heights[k]) : ((heights[j] < heights[k]) ? heights[j] : heights[k]);\n                int maxVal = (heights[i] > heights[j]) ? ((heights[i] > heights[k]) ? heights[i] : heights[k]) : ((heights[j] > heights[k]) ? heights[j] : heights[k]);\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben.", "es": "int countTriplets(int heights[], int n)\n{\n    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = (heights[i] < heights[j]) ? ((heights[i] < heights[k]) ? heights[i] : heights[k]) : ((heights[j] < heights[k]) ? heights[j] : heights[k]);\n                int maxVal = (heights[i] > heights[j]) ? ((heights[i] > heights[k]) ? heights[i] : heights[k]) : ((heights[j] > heights[k]) ? heights[j] : heights[k]);\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando como máximo 500 caracteres.", "arb": "int countTriplets(int heights[], int n)\n{\n    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = (heights[i] < heights[j]) ? ((heights[i] < heights[k]) ? heights[i] : heights[k]) : ((heights[j] < heights[k]) ? heights[j] : heights[k]);\n                int maxVal = (heights[i] > heights[j]) ? ((heights[i] > heights[k]) ? heights[i] : heights[k]) : ((heights[j] > heights[k]) ? heights[j] : heights[k]);\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "int countTriplets(int heights[], int n)\n{\n    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = (heights[i] < heights[j]) ? ((heights[i] < heights[k]) ? heights[i] : heights[k]) : ((heights[j] < heights[k]) ? heights[j] : heights[k]);\n                int maxVal = (heights[i] > heights[j]) ? ((heights[i] > heights[k]) ? heights[i] : heights[k]) : ((heights[j] > heights[k]) ? heights[j] : heights[k]);\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "int countTriplets(int heights[], int n)\n{\n    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = (heights[i] < heights[j]) ? ((heights[i] < heights[k]) ? heights[i] : heights[k]) : ((heights[j] < heights[k]) ? heights[j] : heights[k]);\n                int maxVal = (heights[i] > heights[j]) ? ((heights[i] > heights[k]) ? heights[i] : heights[k]) : ((heights[j] > heights[k]) ? heights[j] : heights[k]);\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\nC kodunun işlevini açıklayan kısa bir doğal dil tanımı (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter kullanılmalıdır.", "vi": "int countTriplets(int heights[], int n)\n{\n    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = (heights[i] < heights[j]) ? ((heights[i] < heights[k]) ? heights[i] : heights[k]) : ((heights[j] < heights[k]) ? heights[j] : heights[k]);\n                int maxVal = (heights[i] > heights[j]) ? ((heights[i] > heights[k]) ? heights[i] : heights[k]) : ((heights[j] > heights[k]) ? heights[j] : heights[k]);\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã C bằng tiếng Việt, không quá 500 ký tự.", "id": "int countTriplets(int heights[], int n)\n{\n    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = (heights[i] < heights[j]) ? ((heights[i] < heights[k]) ? heights[i] : heights[k]) : ((heights[j] < heights[k]) ? heights[j] : heights[k]);\n                int maxVal = (heights[i] > heights[j]) ? ((heights[i] > heights[k]) ? heights[i] : heights[k]) : ((heights[j] > heights[k]) ? heights[j] : heights[k]);\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode C dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "int countTriplets(int heights[], int n)\n{\n    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = (heights[i] < heights[j]) ? ((heights[i] < heights[k]) ? heights[i] : heights[k]) : ((heights[j] < heights[k]) ? heights[j] : heights[k]);\n                int maxVal = (heights[i] > heights[j]) ? ((heights[i] > heights[k]) ? heights[i] : heights[k]) : ((heights[j] > heights[k]) ? heights[j] : heights[k]);\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\nC コードの簡単な自然言語による説明 (docstring) を英語で最大 500 文字まで入力してください。", "ko": "int countTriplets(int heights[], int n)\n{\n    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = (heights[i] < heights[j]) ? ((heights[i] < heights[k]) ? heights[i] : heights[k]) : ((heights[j] < heights[k]) ? heights[j] : heights[k]);\n                int maxVal = (heights[i] > heights[j]) ? ((heights[i] > heights[k]) ? heights[i] : heights[k]) : ((heights[j] > heights[k]) ? heights[j] : heights[k]);\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\n다음 C 코드에 대한 간결한 자연어 설명(도크스트링)을 한국어로 500자 이내로 제공하세요.", "ml": "int countTriplets(int heights[], int n)\n{\n    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = (heights[i] < heights[j]) ? ((heights[i] < heights[k]) ? heights[i] : heights[k]) : ((heights[j] < heights[k]) ? heights[j] : heights[k]);\n                int maxVal = (heights[i] > heights[j]) ? ((heights[i] > heights[k]) ? heights[i] : heights[k]) : ((heights[j] > heights[k]) ? heights[j] : heights[k]);\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\nസീ കോഡിന്റെ ഡോക്സ്ട്രിംഗ് മലയാളത്തിൽ 500 അക്ഷരങ്ങൾക്കുള്ളിൽ ഉപയോഗിച്ച് സംക്ഷിപ്തമായ സ്വാഭാവിക ഭാഷാ വിവരണം നൽകുക.", "fa": "int countTriplets(int heights[], int n)\n{\n    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = (heights[i] < heights[j]) ? ((heights[i] < heights[k]) ? heights[i] : heights[k]) : ((heights[j] < heights[k]) ? heights[j] : heights[k]);\n                int maxVal = (heights[i] > heights[j]) ? ((heights[i] > heights[k]) ? heights[i] : heights[k]) : ((heights[j] > heights[k]) ? heights[j] : heights[k]);\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\nتوضیح مختصر و طبیعی (docstring) از کد C به زبان فارسی ارائه دهید که حداکثر ۵۰۰ کاراکتر باشد."}, "level": "", "test": "int main() {\n    int heights1[] = {1, 5, 7};\n    assert(countTriplets(heights1, 3) == 1);\n\n    int heights2[] = {1, 6, 2, 3};\n    assert(countTriplets(heights2, 4) == 3);\n\n    int heights3[] = {16, 4, 8, 2};\n    assert(countTriplets(heights3, 4) == 0);\n\n    int heights4[] = {10, 1, 6, 7, 9, 8, 4, 3, 5, 2};\n    assert(countTriplets(heights4, 10) == 77);\n\n    int heights5[] = {4, 5, 9, 11, 14};\n    assert(countTriplets(heights5, 5) == 7);\n\n    int heights6[] = {15, 10, 6, 9, 7, 3, 12, 8, 11, 1, 2};\n    assert(countTriplets(heights6, 11) == 104);\n\n    int heights7[] = {3, 7, 11, 13};\n    assert(countTriplets(heights7, 4) == 4);\n\n    int heights8[] = {5, 12, 13, 17, 19};\n    assert(countTriplets(heights8, 5) == 10);\n\n    int heights9[] = {2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12};\n    assert(countTriplets(heights9, 11) == 87);\n\n    int heights10[] = {1, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17};\n    assert(countTriplets(heights10, 11) == 122);\n\n    return 0;\n}", "entry_point": "countTriplets", "signature": "int countTriplets(int heights[], int n)", "docstring": {"en": "Given an array of n distinct integers representing the heights of Kira's friends, find the number of ways to choose a triplet (a, b, c) such that the greatest common divisor (GCD) of the maximum and minimum values of the triplet is 1.\n    >>> countTriplets([1, 5, 7])\n    1\n", "sq": "Duke pasur një varg prej n numrash të plotë të dallueshëm që përfaqësojnë lartësitë e miqve të Kirës, gjeni numrin e mënyrave për të zgjedhur një treshe (a, b, c) të tillë që faktori më i madh i përbashkët (GCD) i vlerave maksimale dhe minimale të treshes të jetë 1.\n    >>> countTriplets([1, 5, 7])\n    1", "hy": "Տրված է n տարբեր ամբողջ թվերից կազմված զանգված, որը ներկայացնում է Կիրայի ընկերների բարձրությունները, գտնել, թե քանի եղանակով կարելի է ընտրել եռյակ (a, b, c) այնպես, որ եռյակի առավելագույն և նվազագույն արժեքների մեծագույն ընդհանուր բաժանարարը (GCD) լինի 1:\n    >>> countTriplets([1, 5, 7])\n    1", "bn": "একটি n সংখ্যক স্বতন্ত্র পূর্ণসংখ্যার অ্যারে দেওয়া হয়েছে যা কিরার বন্ধুদের উচ্চতা উপস্থাপন করে, এমন একটি ত্রয়ী (a, b, c) বেছে নেওয়ার উপায়ের সংখ্যা খুঁজে বের করুন যাতে ত্রয়ীর সর্বাধিক এবং সর্বনিম্ন মানের গ্রেটেস্ট কমন ডিভাইজর (GCD) 1 হয়।\n    >>> countTriplets([1, 5, 7])\n    1", "bg": "Даден е масив от n различни цели числа, представляващи височините на приятелите на Кира. Намерете броя на начините да изберете тройка (a, b, c), така че най-големият общ делител (НОД) на максималната и минималната стойност на тройката да е 1.\n    >>> countTriplets([1, 5, 7])\n    1", "zh": "给定一个由 n 个不同整数组成的数组，表示 Kira 的朋友的身高，找出选择一个三元组 (a, b, c) 的方法数，使得该三元组的最大值和最小值的最大公约数 (GCD) 为 1。\n    >>> countTriplets([1, 5, 7])\n    1", "fr": "Étant donné un tableau de n entiers distincts représentant les hauteurs des amis de Kira, trouvez le nombre de façons de choisir un triplet (a, b, c) tel que le plus grand commun diviseur (PGCD) des valeurs maximale et minimale du triplet soit 1.\n    >>> countTriplets([1, 5, 7])\n    1", "de": "Gegeben ein Array von n verschiedenen ganzen Zahlen, die die Höhen von Kiras Freunden darstellen, finde die Anzahl der Möglichkeiten, ein Tripel (a, b, c) so zu wählen, dass der größte gemeinsame Teiler (GCD) der maximalen und minimalen Werte des Tripels 1 ist.\n    >>> countTriplets([1, 5, 7])\n    1", "ha": "An ba da wani tsari na lambobi daban-daban n da ke wakiltar tsayin abokan Kira, nemo adadin hanyoyin zaɓar triplet (a, b, c) ta yadda babbar mai raba kowa da kowa (GCD) na mafi girma da mafi ƙarancin ƙimar triplet ɗin ya zama 1.\n    >>> countTriplets([1, 5, 7])\n    1", "hi": "n अद्वितीय पूर्णांकों की एक array दी गई है जो कि Kira के दोस्तों की ऊंचाई का प्रतिनिधित्व करती है, उन तरीकों की संख्या खोजें जिनसे एक triplet (a, b, c) चुना जा सके ताकि triplet के अधिकतम और न्यूनतम मानों का सबसे बड़ा सामान्य भाजक (GCD) 1 हो।\n    >>> countTriplets([1, 5, 7])\n    1", "hu": "Adott egy tömb n különböző egész számmal, amelyek Kira barátainak magasságát jelképezik, meg kell találni, hányféleképpen lehet kiválasztani egy hármast (a, b, c) úgy, hogy a hármas maximumának és minimumának legnagyobb közös osztója (GCD) 1 legyen.\n    >>> countTriplets([1, 5, 7])\n    1", "es": "Dado un array de n enteros distintos que representan las alturas de los amigos de Kira, encuentra el número de formas de elegir un triplete (a, b, c) tal que el máximo común divisor (MCD) de los valores máximo y mínimo del triplete sea 1.\n    >>> countTriplets([1, 5, 7])\n    1", "arb": "نظرًا لمصفوفة تحتوي على n من الأعداد الصحيحة المميزة التي تمثل أطوال أصدقاء كيرا، ابحث عن عدد الطرق لاختيار ثلاثي (a, b, c) بحيث يكون القاسم المشترك الأكبر (GCD) للقيمتين العظمى والصغرى في الثلاثي هو 1.\n    >>> countTriplets([1, 5, 7])\n    1", "sw": "Kwa kupewa safu ya nambari tofauti za n ambazo zinawakilisha urefu wa marafiki wa Kira, pata idadi ya njia za kuchagua tatu (a, b, c) ambapo mgawanyiko mkuu wa kawaida (GCD) wa thamani ya juu na ya chini ya tatu hiyo ni 1.\n    >>> countTriplets([1, 5, 7])\n    1", "tr": "Verilen bir dizi n farklı tam sayıdan oluşan ve Kira'nın arkadaşlarının boylarını temsil eden, maksimum ve minimum değerlerinin en büyük ortak böleni (GCD) 1 olan bir üçlü (a, b, c) seçmenin kaç yolu olduğunu bulun.\n    >>> countTriplets([1, 5, 7])\n    1", "vi": "Cho một mảng gồm n số nguyên khác nhau đại diện cho chiều cao của bạn bè Kira, tìm số cách chọn một bộ ba (a, b, c) sao cho ước số chung lớn nhất (GCD) của giá trị lớn nhất và nhỏ nhất của bộ ba là 1.\n    >>> countTriplets([1, 5, 7])\n    1", "id": "Diberikan sebuah array dari n bilangan bulat yang berbeda yang mewakili tinggi teman-teman Kira, temukan jumlah cara untuk memilih triplet (a, b, c) sedemikian rupa sehingga pembagi bersama terbesar (GCD) dari nilai maksimum dan minimum dari triplet tersebut adalah 1.\n    >>> countTriplets([1, 5, 7])\n    1", "ja": "配列として与えられた n 個の異なる整数は、キラの友人たちの身長を表しています。この中から 3 つ組 (a, b, c) を選ぶ方法の数を求めます。選んだ 3 つ組の最大値と最小値の最大公約数 (GCD) が 1 である必要があります。\n    >>> countTriplets([1, 5, 7])\n    1", "ko": "주어진 n개의 서로 다른 정수 배열은 Kira의 친구들의 키를 나타냅니다. 최대값과 최소값의 최대공약수(GCD)가 1인 삼중항 (a, b, c)을 선택하는 방법의 수를 찾으십시오.\n    >>> countTriplets([1, 5, 7])\n    1", "ml": "കിരയുടെ സുഹൃത്തുക്കളുടെ ഉയരങ്ങളെ പ്രതിനിധീകരിക്കുന്ന n വ്യത്യസ്ത പൂർണ്ണസംഖ്യകളുള്ള ഒരു നിര നൽകിയിരിക്കുന്നു,\nട്രിപ്പ്ലെറ്റ് (a, b, c) തിരഞ്ഞെടുക്കാനുള്ള മാർഗങ്ങളുടെ എണ്ണം കണ്ടെത്തുക, അങ്ങനെ ട്രിപ്പ്ലെറ്റിന്റെ പരമാവധി \nമിനിമം മൂല്യങ്ങളുടെ മഹത്തായ പൊതുഹര (GCD) 1 ആണ്.  \n    >>> countTriplets([1, 5, 7])\n    1", "fa": "با توجه به یک آرایه از n عدد صحیح متمایز که نشان‌دهنده ارتفاع دوستان کیرا هستند، تعداد راه‌های انتخاب یک سه‌تایی (a, b, c) را بیابید به‌طوری‌که بزرگ‌ترین مقسوم‌علیه مشترک (GCD) مقادیر حداکثر و حداقل سه‌تایی برابر با 1 باشد.\n    >>> countTriplets([1, 5, 7])\n    1"}}
{"task_id": "C/45", "prompt": {"en": "#include <stdio.h>\n#include <assert.h>\n/*\nYou are given a 1 by n pixel image, where each pixel has a color represented by an integer. You can perform an operation where you pick a color and change all connected pixels of the same color to the chosen color. Two pixels are connected if they are adjacent and have the same color. Find the minimum number of operations required to make all pixels the same color.\n\nNote: For each color, there are at most 20 pixels of that color.\n\nExamples:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2\n*/\nint minOperations(int n, int* pixels)", "sq": "#include <stdio.h>\n#include <assert.h>\n/*\nJu jepet një imazh 1 me n pikselë, ku secili piksel ka një ngjyrë të përfaqësuar nga një numër i plotë. Ju mund të kryeni një operacion ku zgjidhni një ngjyrë dhe ndryshoni të gjithë pikselët e lidhur të së njëjtës ngjyrë në ngjyrën e zgjedhur. Dy pikselë janë të lidhur nëse janë ngjitur dhe kanë të njëjtën ngjyrë. Gjeni numrin minimal të operacioneve të nevojshme për të bërë që të gjithë pikselët të kenë të njëjtën ngjyrë.\n\nShënim: Për çdo ngjyrë, ka maksimumi 20 pikselë të asaj ngjyre.\n\nShembuj:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2\n*/\nint minOperations(int n, int* pixels)", "hy": "#include <stdio.h>\n#include <assert.h>\n/*\nՁեզ տրված է 1x n պիքսել պատկեր, որտեղ յուրաքանչյուր պիքսել ունի գույն, որը ներկայացված է ամբողջ թվով։ Դուք կարող եք կատարել գործողություն, որտեղ ընտրում եք գույն և փոխում նույն գույնի բոլոր միացված պիքսելները ընտրված գույնով։ Երկու պիքսելներ միացված են, եթե նրանք հարակից են և ունեն նույն գույնը։ Գտեք նվազագույն գործողությունների քանակը, որը պահանջվում է բոլոր պիքսելները նույն գույնի դարձնելու համար։\n\nՆշում: Յուրաքանչյուր գույնի համար առավելագույնը 20 պիքսել կա այդ գույնի։\n\nՕրինակներ:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2\n*/\nint minOperations(int n, int* pixels)", "bn": "#include <stdio.h>\n#include <assert.h>\n/*\nআপনাকে একটি 1 বাই n পিক্সেল ইমেজ দেওয়া হয়েছে, যেখানে প্রতিটি পিক্সেলের একটি রঙ রয়েছে যা একটি পূর্ণসংখ্যা দ্বারা প্রতিনিধিত্ব করা হয়। আপনি একটি অপারেশন সম্পাদন করতে পারেন যেখানে আপনি একটি রঙ বেছে নেন এবং একই রঙের সমস্ত সংযুক্ত পিক্সেলগুলি নির্বাচিত রঙে পরিবর্তন করেন। দুটি পিক্সেল সংযুক্ত থাকে যদি তারা সংলগ্ন হয় এবং একই রঙের হয়। সমস্ত পিক্সেলকে একই রঙে পরিবর্তন করতে প্রয়োজনীয় সর্বনিম্ন সংখ্যক অপারেশন খুঁজে বের করুন।\n\nদ্রষ্টব্য: প্রতিটি রঙের জন্য, সেই রঙের সর্বাধিক 20টি পিক্সেল রয়েছে।\n\nউদাহরণ:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2\n*/\nint minOperations(int n, int* pixels)", "bg": "#include <stdio.h>\n#include <assert.h>\n/*\nДадено е изображение с размер 1 на n пиксела, където всеки пиксел има цвят, представен от цяло число. Можете да извършите операция, при която избирате цвят и променяте всички свързани пиксели със същия цвят на избрания цвят. Два пиксела са свързани, ако са съседни и имат същия цвят. Намерете минималния брой операции, необходими, за да направите всички пиксели с един и същ цвят.\n\nЗабележка: За всеки цвят има най-много 20 пиксела от този цвят.\n\nПримери:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2\n*/\nint minOperations(int n, int* pixels)", "zh": "#include <stdio.h>\n#include <assert.h>\n/*\n给定一个 1 x n 像素图像，其中每个像素的颜色由一个整数表示。你可以执行一个操作，选择一种颜色并将所有连接的同色像素更改为所选颜色。如果两个像素相邻且颜色相同，则它们是连接的。找出使所有像素颜色相同所需的最小操作次数。\n\n注意：对于每种颜色，最多有 20 个该颜色的像素。\n\n例子:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2\n*/\nint minOperations(int n, int* pixels)", "fr": "#include <stdio.h>\n#include <assert.h>\n/*\nVous avez une image de 1 par n pixels, où chaque pixel a une couleur représentée par un entier. Vous pouvez effectuer une opération où vous choisissez une couleur et changez tous les pixels connectés de la même couleur en la couleur choisie. Deux pixels sont connectés s'ils sont adjacents et ont la même couleur. Trouvez le nombre minimum d'opérations nécessaires pour rendre tous les pixels de la même couleur.\n\nRemarque : Pour chaque couleur, il y a au plus 20 pixels de cette couleur.\n\nExemples :\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2\n*/\nint minOperations(int n, int* pixels)", "de": "#include <stdio.h>\n#include <assert.h>\n/*\nSie haben ein 1 mal n Pixel-Bild, wobei jedes Pixel eine Farbe hat, die durch eine ganze Zahl dargestellt wird. Sie können eine Operation durchführen, bei der Sie eine Farbe auswählen und alle verbundenen Pixel derselben Farbe in die gewählte Farbe ändern. Zwei Pixel sind verbunden, wenn sie benachbart sind und die gleiche Farbe haben. Finden Sie die minimale Anzahl von Operationen, die erforderlich sind, um alle Pixel in die gleiche Farbe zu ändern.\n\nHinweis: Für jede Farbe gibt es höchstens 20 Pixel dieser Farbe.\n\nBeispiele:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2\n*/\nint minOperations(int n, int* pixels)", "ha": "#include <stdio.h>\n#include <assert.h>\n/*\nAn ba ku hoton pixel 1 ta n, inda kowane pixel yana da launi da aka wakilta da lamba. Kuna iya aiwatar da aiki inda kuka zaɓi launi kuma ku canza duk pixels masu alaƙa na launi ɗaya zuwa launi da aka zaɓa. Ana haɗa pixels biyu idan suna kusa kuma suna da launi ɗaya. Nemo mafi ƙarancin adadin ayyuka da ake buƙata don sanya duk pixels su zama launi ɗaya.\n\nLura: Don kowane launi, akwai a kalla pixels 20 na wannan launi.\n\nMisalai:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2\n*/\nint minOperations(int n, int* pixels)", "hi": "#include <stdio.h>\n#include <assert.h>\n/*\nआपको एक 1 बाय n पिक्सेल छवि दी गई है, जहाँ प्रत्येक पिक्सेल का रंग एक पूर्णांक द्वारा दर्शाया गया है। आप एक ऑपरेशन कर सकते हैं जहाँ आप एक रंग चुनते हैं और उसी रंग के सभी जुड़े पिक्सेल को चुने गए रंग में बदल देते हैं। दो पिक्सेल जुड़े होते हैं यदि वे आसन्न होते हैं और उनका रंग समान होता है। सभी पिक्सेल को एक ही रंग में बनाने के लिए आवश्यक न्यूनतम ऑपरेशनों की संख्या खोजें।\n\nनोट: प्रत्येक रंग के लिए, उस रंग के अधिकतम 20 पिक्सेल होते हैं।\n\nउदाहरण:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2\n*/\nint minOperations(int n, int* pixels)", "hu": "#include <stdio.h>\n#include <assert.h>\n/*\nEgy 1 x n pixeles képet kapunk, ahol minden pixel színét egy egész szám képviseli. Végrehajthat egy műveletet, amely során kiválaszt egy színt, és az összes összekapcsolt, azonos színű pixelt a kiválasztott színre változtatja. Két pixel akkor van összekapcsolva, ha szomszédosak és azonos színűek. Keresse meg a minimális műveletszámot, amely szükséges ahhoz, hogy az összes pixel azonos színű legyen.\n\nMegjegyzés: Minden színhez legfeljebb 20 pixel tartozik.\n\nPéldák:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2\n*/\nint minOperations(int n, int* pixels)", "es": "#include <stdio.h>\n#include <assert.h>\n/*\nSe te da una imagen de 1 por n píxeles, donde cada píxel tiene un color representado por un entero. Puedes realizar una operación donde eliges un color y cambias todos los píxeles conectados del mismo color al color elegido. Dos píxeles están conectados si son adyacentes y tienen el mismo color. Encuentra el número mínimo de operaciones requeridas para hacer que todos los píxeles sean del mismo color.\n\nNota: Para cada color, hay como máximo 20 píxeles de ese color.\n\nEjemplos:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2\n*/\nint minOperations(int n, int* pixels)", "arb": "#include <stdio.h>\n#include <assert.h>\n/*\nلديك صورة مكونة من 1 في n بكسل، حيث يتم تمثيل كل بكسل بلون يمثل برقم صحيح. يمكنك تنفيذ عملية حيث تختار لونًا وتغير جميع البكسلات المتصلة من نفس اللون إلى اللون المختار. يعتبر البكسلان متصلان إذا كانا متجاورين ولهما نفس اللون. ابحث عن الحد الأدنى لعدد العمليات المطلوبة لجعل جميع البكسلات بنفس اللون.\n\nملاحظة: لكل لون، هناك بحد أقصى 20 بكسل من ذلك اللون.\n\nأمثلة:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2\n*/\nint minOperations(int n, int* pixels)", "sw": "#include <stdio.h>\n#include <assert.h>\n/*\nUmepewa picha ya pikseli 1 kwa n, ambapo kila pikseli ina rangi inayowakilishwa na nambari. Unaweza kufanya operesheni ambapo unachagua rangi na kubadilisha pikseli zote zilizounganishwa za rangi sawa kuwa rangi iliyochaguliwa. Pikseli mbili zimeunganishwa ikiwa ziko karibu na zina rangi sawa. Pata idadi ndogo ya operesheni zinazohitajika kufanya pikseli zote kuwa na rangi sawa.\n\nKumbuka: Kwa kila rangi, kuna pikseli zisizozidi 20 za rangi hiyo.\n\nMifano:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2\n*/\nint minOperations(int n, int* pixels)", "tr": "#include <stdio.h>\n#include <assert.h>\n/*\n1'e n piksel boyutunda bir görüntü verilir, burada her piksel bir tamsayı ile temsil edilen bir renge sahiptir. Bir renk seçip aynı renkteki tüm bağlı pikselleri seçilen renge değiştirebileceğiniz bir işlem gerçekleştirebilirsiniz. İki piksel, bitişik ve aynı renkte olduklarında bağlı kabul edilir. Tüm pikselleri aynı renge getirmek için gereken minimum işlem sayısını bulun.\n\nNot: Her renk için en fazla 20 piksel vardır.\n\nÖrnekler:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2\n*/\nint minOperations(int n, int* pixels)", "vi": "#include <stdio.h>\n#include <assert.h>\n/*\nBạn được cung cấp một hình ảnh 1 x n pixel, trong đó mỗi pixel có một màu được biểu diễn bằng một số nguyên. Bạn có thể thực hiện một thao tác trong đó bạn chọn một màu và thay đổi tất cả các pixel kết nối có cùng màu thành màu đã chọn. Hai pixel được kết nối nếu chúng liền kề và có cùng màu. Tìm số lượng thao tác tối thiểu cần thiết để làm cho tất cả các pixel có cùng màu.\n\nLưu ý: Đối với mỗi màu, có tối đa 20 pixel của màu đó.\n\nVí dụ:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2\n*/\nint minOperations(int n, int* pixels)", "id": "#include <stdio.h>\n#include <assert.h>\n/*\nAnda diberikan gambar 1 kali n piksel, di mana setiap piksel memiliki warna yang diwakili oleh sebuah bilangan bulat. Anda dapat melakukan operasi di mana Anda memilih sebuah warna dan mengubah semua piksel yang terhubung dengan warna yang sama menjadi warna yang dipilih. Dua piksel terhubung jika mereka bersebelahan dan memiliki warna yang sama. Temukan jumlah operasi minimum yang diperlukan untuk membuat semua piksel memiliki warna yang sama.\n\nCatatan: Untuk setiap warna, ada paling banyak 20 piksel dengan warna tersebut.\n\nContoh:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2\n*/\nint minOperations(int n, int* pixels)", "ja": "#include <stdio.h>\n#include <assert.h>\n/*\n1行nピクセルの画像が与えられ、各ピクセルは整数で表される色を持っています。色を選んで、同じ色の接続されたすべてのピクセルを選んだ色に変更する操作を行うことができます。2つのピクセルは、隣接していて同じ色である場合に接続されています。すべてのピクセルを同じ色にするために必要な最小の操作回数を求めてください。\n\n注意: 各色について、その色のピクセルは最大で20個です。\n\n例:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2\n*/\nint minOperations(int n, int* pixels)", "ko": "#include <stdio.h>\n#include <assert.h>\n/*\n1 by n 픽셀 이미지가 주어집니다. 각 픽셀은 정수로 표현된 색상을 가지고 있습니다. 색상을 선택하고 동일한 색상의 연결된 모든 픽셀을 선택한 색상으로 변경하는 작업을 수행할 수 있습니다. 두 픽셀은 인접하고 동일한 색상을 가질 때 연결됩니다. 모든 픽셀을 동일한 색상으로 만들기 위해 필요한 최소 작업 수를 찾으세요.\n\n참고: 각 색상에 대해 최대 20개의 픽셀이 있습니다.\n\n예시:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2\n*/\nint minOperations(int n, int* pixels)\n", "ml": "#include <stdio.h>\n#include <assert.h>\n/*\nനിങ്ങൾക്ക് 1 by n പിക്‌സൽ ഇമേജ് നൽകിയിരിക്കുന്നു, ഇവിടെ ഓരോ പിക്‌സലിനും ഒരു പൂർണ്ണസംഖ്യയാൽ പ്രതിനിധീകരിക്കുന്ന ഒരു നിറമുണ്ട്. നിങ്ങൾക്ക് ഒരു നിറം തിരഞ്ഞെടുക്കുകയും അതേ നിറത്തിലുള്ള എല്ലാ ബന്ധിപ്പിച്ച പിക്‌സലുകളും തിരഞ്ഞെടുക്കപ്പെട്ട നിറത്തിലേക്ക് മാറ്റുകയും ചെയ്യുന്ന ഒരു ഓപ്പറേഷൻ നടത്താൻ കഴിയും. രണ്ട് പിക്‌സലുകൾ ബന്ധിപ്പിച്ചിരിക്കുന്നു എന്നത് അവർ ചേർന്ന് നിന്നാൽ മാത്രമേയുള്ളൂ, കൂടാതെ അവയ്ക്ക് ഒരേ നിറം ഉണ്ടായിരിക്കണം. എല്ലാ പിക്‌സലുകൾക്കും ഒരേ നിറം ഉണ്ടാക്കാൻ ആവശ്യമായ ഓപ്പറേഷനുകളുടെ കുറഞ്ഞ എണ്ണം കണ്ടെത്തുക.\n\nകുറിപ്പ്: ഓരോ നിറത്തിനും ആ നിറത്തിലുള്ള പരമാവധി 20 പിക്‌സലുകൾ മാത്രമേയുള്ളൂ.\n\nഉദാഹരണങ്ങൾ:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2\n*/\nint minOperations(int n, int* pixels)", "fa": "#include <stdio.h>\n#include <assert.h>\n/*\nبه شما یک تصویر 1 در n پیکسلی داده شده است، که هر پیکسل دارای رنگی است که با یک عدد صحیح نمایش داده می‌شود. شما می‌توانید عملیاتی انجام دهید که در آن یک رنگ را انتخاب کرده و تمام پیکسل‌های متصل با همان رنگ را به رنگ انتخاب شده تغییر دهید. دو پیکسل متصل هستند اگر مجاور باشند و رنگ یکسانی داشته باشند. حداقل تعداد عملیات مورد نیاز برای یکسان کردن رنگ تمام پیکسل‌ها را پیدا کنید.\n\nتوجه: برای هر رنگ، حداکثر 20 پیکسل از آن رنگ وجود دارد.\n\nمثال‌ها:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2\n*/\nint minOperations(int n, int* pixels)"}, "canonical_solution": "{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}", "instruction": {"en": "int minOperations(int n, int* pixels)\n{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "sq": "int minOperations(int n, int* pixels)\n{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C në shqip duke përdorur maksimumi 500 karaktere.", "hy": "int minOperations(int n, int* pixels)\n{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}\n\nՏվեք C կոդի հակիրճ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "int minOperations(int n, int* pixels)\n{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}\n\nসি কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলা ভাষায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।", "bg": "int minOperations(int n, int* pixels)\n{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, използвайки не повече от 500 знака.", "zh": "int minOperations(int n, int* pixels)\n{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}\n\n请用最多500个字符的中文对该C代码提供简洁的自然语言描述（文档字符串）。", "fr": "int minOperations(int n, int* pixels)\n{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.", "de": "int minOperations(int n, int* pixels)\n{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen.", "ha": "int minOperations(int n, int* pixels)\n{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}\n\nBa da taƙaitaccen bayanin harshen halitta (docstring) na lambar C a cikin Hausa ta amfani da haruffa 500 kawai.", "hi": "int minOperations(int n, int* pixels)\n{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}\n\nदिए गए C कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "int minOperations(int n, int* pixels)\n{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben.", "es": "int minOperations(int n, int* pixels)\n{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando como máximo 500 caracteres.", "arb": "int minOperations(int n, int* pixels)\n{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.", "sw": "int minOperations(int n, int* pixels)\n{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "int minOperations(int n, int* pixels)\n{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}\n\nC kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe olarak yazılmalıdır.", "vi": "int minOperations(int n, int* pixels)\n{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã C bằng tiếng Việt, sử dụng tối đa 500 ký tự.", "id": "int minOperations(int n, int* pixels)\n{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode C dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "int minOperations(int n, int* pixels)\n{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}\n\n以下のCコードに対する簡潔な自然言語による説明（ドックストリング）を日本語で500文字以内で提供してください。", "ko": "int minOperations(int n, int* pixels)\n{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}\n\n다음 C 코드의 동작을 설명하는 간결한 자연어 설명(docstring)을 한국어로 500자 이내로 작성하세요.", "ml": "int minOperations(int n, int* pixels)\n{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}\n\nസീ കോഡിന്റെ ഡോക്സ്ട്രിംഗ് മലയാളത്തിൽ 500 അക്ഷരങ്ങളിൽ കൂടാതെയുള്ള സംക്ഷിപ്തമായ സ്വാഭാവിക ഭാഷാ വിവരണം നൽകുക.", "fa": "int minOperations(int n, int* pixels)\n{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}\n\nیک توضیح مختصر به زبان طبیعی (docstring) از کد C به زبان فارسی ارائه دهید که حداکثر ۵۰۰ کاراکتر باشد."}, "level": "", "test": "int main() {\n    assert(minOperations(5, (int[]){1, 2, 3, 2, 1}) == 2);\n    assert(minOperations(4, (int[]){1, 1, 2, 2}) == 1);\n    assert(minOperations(5, (int[]){1, 2, 1, 4, 2}) == 3);\n    assert(minOperations(5, (int[]){5, 5, 5, 5, 5}) == 0);\n    assert(minOperations(6, (int[]){1, 1, 1, 2, 2, 2}) == 1);\n    assert(minOperations(7, (int[]){1, 3, 3, 3, 2, 2, 2}) == 2);\n    assert(minOperations(8, (int[]){4, 4, 4, 4, 3, 3, 3, 3}) == 1);\n    assert(minOperations(9, (int[]){1, 2, 3, 4, 5, 6, 7, 8, 9}) == 8);\n    assert(minOperations(10, (int[]){1, 2, 1, 2, 1, 2, 1, 2, 1, 2}) == 5);\n    assert(minOperations(3, (int[]){3, 3, 3}) == 0);\n    assert(minOperations(4, (int[]){2, 1, 1, 2}) == 1);\n    return 0;\n}", "entry_point": "minOperations", "signature": "int minOperations(int n, int* pixels)", "docstring": {"en": "You are given a 1 by n pixel image, where each pixel has a color represented by an integer. You can perform an operation where you pick a color and change all connected pixels of the same color to the chosen color. Two pixels are connected if they are adjacent and have the same color. Find the minimum number of operations required to make all pixels the same color.\n\nNote: For each color, there are at most 20 pixels of that color.\n\nExamples:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2\n", "sq": "Ju jepet një imazh me përmasa 1 me n pikselë, ku secili piksel ka një ngjyrë të përfaqësuar nga një numër i plotë. Ju mund të kryeni një operacion ku zgjidhni një ngjyrë dhe ndryshoni të gjithë pikselët e lidhur të së njëjtës ngjyrë në ngjyrën e zgjedhur. Dy pikselë janë të lidhur nëse janë ngjitur dhe kanë të njëjtën ngjyrë. Gjeni numrin minimal të operacioneve të kërkuara për të bërë që të gjithë pikselët të kenë të njëjtën ngjyrë.\n\nShënim: Për çdo ngjyrë, ka maksimumi 20 pikselë të asaj ngjyre.\n\nShembuj:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2", "hy": "Դուք ունեք 1x n պիքսել պատկեր, որտեղ յուրաքանչյուր պիքսել ունի գույն, որը ներկայացված է ամբողջ թվով: Դուք կարող եք կատարել գործողություն, որտեղ ընտրում եք գույն և փոխում նույն գույնի բոլոր միացված պիքսելները ընտրված գույնով: Երկու պիքսելներ միացված են, եթե նրանք հարևան են և ունեն նույն գույնը: Գտեք նվազագույն գործողությունների քանակը, որը պահանջվում է բոլոր պիքսելները նույն գույնի դարձնելու համար:\n\nՆշում: Յուրաքանչյուր գույնի համար առավելագույնը 20 պիքսել կա այդ գույնից:\n\nՕրինակներ:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2", "bn": "আপনাকে একটি 1 বাই n পিক্সেল চিত্র দেওয়া হয়েছে, যেখানে প্রতিটি পিক্সেলের একটি রঙ একটি পূর্ণসংখ্যা দ্বারা উপস্থাপিত হয়। আপনি একটি অপারেশন সম্পাদন করতে পারেন যেখানে আপনি একটি রঙ বেছে নেন এবং একই রঙের সমস্ত সংযুক্ত পিক্সেল নির্বাচিত রঙে পরিবর্তন করেন। দুটি পিক্সেল সংযুক্ত থাকে যদি তারা সংলগ্ন হয় এবং একই রঙের হয়। সমস্ত পিক্সেল একই রঙের করতে প্রয়োজনীয় সর্বনিম্ন সংখ্যক অপারেশন খুঁজে বের করুন।\n\nবিঃদ্রঃ: প্রতিটি রঙের জন্য, সেই রঙের সর্বাধিক ২০টি পিক্সেল রয়েছে।\n\nউদাহরণ:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2", "bg": "Дадено е изображение с размер 1 на n пиксела, където всеки пиксел има цвят, представен с цяло число. Можете да извършите операция, при която избирате цвят и променяте всички свързани пиксели със същия цвят на избрания цвят. Два пиксела са свързани, ако са съседни и имат същия цвят. Намерете минималния брой операции, необходими, за да направите всички пиксели с един и същ цвят.\n\nЗабележка: За всеки цвят има най-много 20 пиксела от този цвят.\n\nПримери:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2", "zh": "您有一个 1 x n 像素的图像，其中每个像素的颜色由一个整数表示。您可以执行一个操作，选择一种颜色并将所有相连的相同颜色的像素更改为所选颜色。如果两个像素相邻并且具有相同的颜色，则它们是相连的。找出使所有像素变为相同颜色所需的最小操作次数。\n\n注意：对于每种颜色，最多有 20 个该颜色的像素。\n\n示例：\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2", "fr": "Vous avez une image de 1 par n pixels, où chaque pixel a une couleur représentée par un entier. Vous pouvez effectuer une opération où vous choisissez une couleur et changez tous les pixels connectés de la même couleur en la couleur choisie. Deux pixels sont connectés s'ils sont adjacents et ont la même couleur. Trouvez le nombre minimum d'opérations nécessaires pour que tous les pixels aient la même couleur.\n\nRemarque : Pour chaque couleur, il y a au plus 20 pixels de cette couleur.\n\nExemples :\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2", "de": "Du hast ein 1 mal n Pixel-Bild, wobei jeder Pixel eine durch eine ganze Zahl dargestellte Farbe hat. Du kannst eine Operation durchführen, bei der du eine Farbe auswählst und alle verbundenen Pixel derselben Farbe in die gewählte Farbe änderst. Zwei Pixel sind verbunden, wenn sie benachbart sind und dieselbe Farbe haben. Finde die minimale Anzahl von Operationen, die erforderlich sind, um alle Pixel in dieselbe Farbe zu bringen.\n\nHinweis: Für jede Farbe gibt es höchstens 20 Pixel dieser Farbe.\n\nBeispiele:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2\n", "ha": "An ba ku hoton pixel 1 ta n, inda kowanne pixel ke da launi da aka wakilta da lamba. Kuna iya aiwatar da aiki inda kuka zaɓi launi kuma ku canza duk pixels masu alaƙa na launi ɗaya zuwa launin da aka zaɓa. Ana haɗa pixels biyu idan suna kusa kuma suna da launi ɗaya. Nemo mafi ƙarancin adadin ayyuka da ake buƙata don sanya duk pixels su zama launi ɗaya.\n\nLura: Ga kowanne launi, akwai a kalla pixels 20 na wannan launi.\n\nMisalai:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2", "hi": "आपको 1 बाय n पिक्सेल की छवि दी गई है, जहाँ प्रत्येक पिक्सेल का रंग एक पूर्णांक द्वारा दर्शाया गया है। आप एक ऑपरेशन कर सकते हैं जिसमें आप एक रंग चुनते हैं और उसी रंग के सभी जुड़े हुए पिक्सेल को चुने हुए रंग में बदल देते हैं। दो पिक्सेल जुड़े हुए होते हैं यदि वे आसन्न होते हैं और उनका रंग समान होता है। सभी पिक्सेल को एक ही रंग का बनाने के लिए आवश्यक न्यूनतम ऑपरेशनों की संख्या ज्ञात करें।\n\nनोट: प्रत्येक रंग के लिए, उस रंग के अधिकतम 20 पिक्सेल होते हैं।\n\nउदाहरण:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2", "hu": "Önnek adott egy 1 x n pixeles kép, ahol minden pixel színe egy egész számmal van reprezentálva. Végezhet egy olyan műveletet, ahol kiválaszt egy színt, és az összes összekapcsolt, azonos színű pixelt a kiválasztott színre változtatja. Két pixel akkor van összekapcsolva, ha szomszédosak és azonos színűek. Találja meg a minimális műveletek számát, amely szükséges ahhoz, hogy az összes pixel azonos színű legyen.\n\nMegjegyzés: Minden színhez legfeljebb 20 pixel tartozik.\n\nPéldák:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2", "es": "Se te da una imagen de 1 por n píxeles, donde cada píxel tiene un color representado por un entero. Puedes realizar una operación en la que eliges un color y cambias todos los píxeles conectados del mismo color al color elegido. Dos píxeles están conectados si son adyacentes y tienen el mismo color. Encuentra el número mínimo de operaciones necesarias para hacer que todos los píxeles sean del mismo color.\n\nNota: Para cada color, hay como máximo 20 píxeles de ese color.\n\nEjemplos:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2", "arb": "أنت لديك صورة مكونة من 1 في n بكسل، حيث كل بكسل له لون ممثل بعدد صحيح. يمكنك تنفيذ عملية حيث تختار لونًا وتغير جميع البكسلات المتصلة من نفس اللون إلى اللون المختار. يُعتبر البكسلان متصلين إذا كانا متجاورين ولهما نفس اللون. اعثر على الحد الأدنى لعدد العمليات المطلوبة لجعل جميع البكسلات بنفس اللون.\n\nملاحظة: لكل لون، هناك بحد أقصى 20 بكسل من ذلك اللون.\n\nأمثلة:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2", "sw": "Unapewa picha ya pikseli 1 kwa n, ambapo kila pikseli ina rangi inayowakilishwa na nambari kamili. Unaweza kufanya operesheni ambapo unachagua rangi na kubadilisha pikseli zote zilizounganishwa za rangi sawa kuwa rangi iliyochaguliwa. Pikseli mbili zimeunganishwa ikiwa ziko karibu na zina rangi sawa. Tafuta idadi ndogo ya operesheni zinazohitajika kufanya pikseli zote ziwe na rangi sawa.\n\nKumbuka: Kwa kila rangi, kuna pikseli zisizozidi 20 za rangi hiyo.\n\nMifano:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2", "tr": "1'e n piksel boyutunda bir görüntü veriliyor ve her piksel bir tamsayı ile temsil edilen bir renge sahip. Bir renk seçip aynı renkteki tüm bağlı pikselleri seçilen renge değiştirebileceğiniz bir işlem gerçekleştirebilirsiniz. İki piksel, bitişik ve aynı renkte ise bağlı kabul edilir. Tüm pikselleri aynı renkte yapmak için gereken minimum işlem sayısını bulun.\n\nNot: Her renk için en fazla 20 piksel vardır.\n\nÖrnekler:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2", "vi": "Bạn được cung cấp một hình ảnh 1 x n pixel, trong đó mỗi pixel có một màu được biểu diễn bằng một số nguyên. Bạn có thể thực hiện một thao tác trong đó bạn chọn một màu và thay đổi tất cả các pixel kết nối có cùng màu thành màu đã chọn. Hai pixel được kết nối nếu chúng liền kề và có cùng màu. Tìm số lượng thao tác tối thiểu cần thiết để làm cho tất cả các pixel có cùng màu.\n\nLưu ý: Đối với mỗi màu, có tối đa 20 pixel của màu đó.\n\nVí dụ:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2\n", "id": "Anda diberikan gambar 1 kali n piksel, di mana setiap piksel memiliki warna yang diwakili oleh sebuah bilangan bulat. Anda dapat melakukan operasi di mana Anda memilih sebuah warna dan mengubah semua piksel yang terhubung dengan warna yang sama menjadi warna yang dipilih. Dua piksel terhubung jika mereka berdekatan dan memiliki warna yang sama. Temukan jumlah operasi minimum yang diperlukan untuk membuat semua piksel memiliki warna yang sama.\n\nCatatan: Untuk setiap warna, terdapat paling banyak 20 piksel dengan warna tersebut.\n\nContoh:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2", "ja": "1行nピクセルの画像が与えられます。各ピクセルは整数で表される色を持っています。ある色を選び、同じ色のすべての連結したピクセルを選んだ色に変更する操作を行うことができます。2つのピクセルは、隣接していて同じ色である場合に連結しています。すべてのピクセルを同じ色にするために必要な最小の操作回数を求めてください。\n\n注意: 各色について、その色のピクセルは最大で20個です。\n\n例:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2", "ko": "1 x n 픽셀 이미지가 주어지며, 각 픽셀은 정수로 표현된 색상을 가지고 있습니다. 색상을 선택하여 동일한 색상의 연결된 모든 픽셀을 선택한 색상으로 변경하는 작업을 수행할 수 있습니다. 두 픽셀이 연결되어 있다는 것은 인접해 있고 동일한 색상을 가지고 있다는 것을 의미합니다. 모든 픽셀을 동일한 색상으로 만드는 데 필요한 최소 작업 수를 찾으십시오.\n\n참고: 각 색상에 대해 최대 20개의 픽셀이 존재할 수 있습니다.\n\n예시:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2", "ml": "നിങ്ങൾക്ക് 1 by n പിക്‌സൽ ഇമേജ് നൽകിയിരിക്കുന്നു, ഇവിടെ ഓരോ പിക്‌സലിനും ഒരു പൂർണ്ണസംഖ്യയാൽ പ്രതിനിധീകരിക്കുന്ന ഒരു നിറമുണ്ട്. നിങ്ങൾക്ക് ഒരു നിറം തിരഞ്ഞെടുക്കുകയും അതേ നിറത്തിലുള്ള എല്ലാ ബന്ധിപ്പിച്ച പിക്‌സലുകളും തിരഞ്ഞെടുക്കപ്പെട്ട നിറത്തിലേക്ക് മാറ്റുകയും ചെയ്യുന്ന ഒരു ഓപ്പറേഷൻ നടത്താൻ കഴിയും. രണ്ട് പിക്‌സലുകൾ ബന്ധിപ്പിച്ചിരിക്കുന്നു എന്നത് അവർ ചേർന്ന് നിന്നാൽ മാത്രമേയുള്ളൂ, കൂടാതെ അവയ്ക്ക് ഒരേ നിറം ഉണ്ടായിരിക്കണം. എല്ലാ പിക്‌സലുകൾക്കും ഒരേ നിറം ഉണ്ടാക്കാൻ ആവശ്യമായ ഓപ്പറേഷനുകളുടെ കുറഞ്ഞ എണ്ണം കണ്ടെത്തുക.\n\nകുറിപ്പ്: ഓരോ നിറത്തിനും ആ നിറത്തിലുള്ള പരമാവധി 20 പിക്‌സലുകൾ മാത്രമേയുള്ളൂ.\n\nനിങ്ങൾക്ക് 1 by n പിക്സൽ ചിത്രം ലഭിച്ചിരിക്കുന്നു, ഇവിടെ ഓരോ പിക്സലിനും ഒരു പൂർണ്ണസംഖ്യയാൽ പ്രതിനിധാനം ചെയ്യുന്ന ഒരു നിറമുണ്ട്. നിങ്ങൾക്ക് ഒരു നിറം തിരഞ്ഞെടുക്കുകയും, അതേ നിറമുള്ള എല്ലാ ബന്ധിപ്പിച്ച പിക്സലുകളും തിരഞ്ഞെടുക്കപ്പെട്ട നിറത്തിലേക്ക് മാറ്റുകയും ചെയ്യുന്ന ഒരു പ്രവർത്തനം നടത്താൻ കഴിയും. രണ്ട് പിക്സലുകൾ ബന്ധിപ്പിച്ചിരിക്കുന്നു എന്നത് അവർ ചേർന്നിരിക്കുന്നതും ഒരേ നിറമുള്ളതുമാണ്. എല്ലാ പിക്സലുകളും ഒരേ നിറമാക്കാൻ ആവശ്യമായ കുറഞ്ഞ പ്രവർത്തനങ്ങളുടെ എണ്ണം കണ്ടെത്തുക.\n\nശ്രദ്ധിക്കുക: ഓരോ നിറത്തിനും ആ നിറത്തിലുള്ള പരമാവധി 20 പിക്സലുകൾ മാത്രമേയുള്ളൂ.\n\nഉദാഹരണങ്ങൾ:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2", "fa": "شما یک تصویر ۱ در n پیکسلی دارید که هر پیکسل دارای رنگی است که با یک عدد صحیح نمایش داده می‌شود. شما می‌توانید عملیاتی انجام دهید که در آن یک رنگ انتخاب کرده و تمام پیکسل‌های متصل با همان رنگ را به رنگ انتخاب شده تغییر دهید. دو پیکسل زمانی متصل هستند که مجاور باشند و رنگ یکسانی داشته باشند. حداقل تعداد عملیات مورد نیاز برای یکسان کردن رنگ تمام پیکسل‌ها را پیدا کنید.\n\nتوجه: برای هر رنگ، حداکثر ۲۰ پیکسل از آن رنگ وجود دارد.\n\nمثال‌ها:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2"}}
{"task_id": "C/46", "prompt": {"en": "#include <assert.h>\n#include <stdio.h>\n/*\nGiven an integer n, write a function to compute the sum of all numbers from 1 to n that are multiples of either 3 or 5. If a number is a multiple of both 3 and 5, it should only be counted once.\nFor example:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)\n*/\nint sumOfMultiples(int n)", "sq": "#include <assert.h>\n#include <stdio.h>\n/*\nDuke pasur një numër të plotë n, shkruani një funksion për të llogaritur shumën e të gjitha numrave nga 1 deri në n që janë shumëfish i 3 ose 5. Nëse një numër është shumëfish i të dyjave 3 dhe 5, ai duhet të numërohet vetëm një herë.\nPër shembull:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)\n*/\nint sumOfMultiples(int n)", "hy": "#include <assert.h>\n#include <stdio.h>\n/*\nՏրված է ամբողջ թիվ n, գրեք ֆունկցիա՝ հաշվելու համար 1-ից n բոլոր այն թվերի գումարը, որոնք բազմապատիկ են 3-ի կամ 5-ի։ Եթե թիվը բազմապատիկ է և՛ 3-ի, և՛ 5-ի, այն պետք է հաշվի առնվի միայն մեկ անգամ։\nՕրինակ:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)\n*/\nint sumOfMultiples(int n)", "bn": "#include <assert.h>\n#include <stdio.h>\n/*\nএকটি পূর্ণসংখ্যা n দেওয়া হলে, ১ থেকে n পর্যন্ত সমস্ত সংখ্যার যোগফল গণনা করার জন্য একটি ফাংশন লিখুন যা ৩ বা ৫ এর গুণিতক। যদি কোনো সংখ্যা ৩ এবং ৫ উভয়েরই গুণিতক হয়, তবে এটি কেবল একবার গণনা করা উচিত।\nউদাহরণস্বরূপ:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)\n*/\nint sumOfMultiples(int n)", "bg": "#include <assert.h>\n#include <stdio.h>\n/*\nДадено е цяло число n, напишете функция за изчисляване на сумата на всички числа от 1 до n, които са кратни на 3 или 5. Ако едно число е кратно и на 3, и на 5, то трябва да бъде преброено само веднъж.\nНапример:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)\n*/\nint sumOfMultiples(int n)", "zh": "#include <assert.h>\n#include <stdio.h>\n/*\n给定一个整数 n，编写一个函数来计算从 1 到 n 之间所有是 3 或 5 的倍数的数字之和。如果一个数字同时是 3 和 5 的倍数，则只计算一次。\n例如：\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)\n*/\nint sumOfMultiples(int n)", "fr": "#include <assert.h>\n#include <stdio.h>\n/*\nÉtant donné un entier n, écrivez une fonction pour calculer la somme de tous les nombres de 1 à n qui sont des multiples de 3 ou 5. Si un nombre est un multiple à la fois de 3 et 5, il ne doit être compté qu'une seule fois.\nPar exemple :\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)\n*/\nint sumOfMultiples(int n)", "de": "#include <assert.h>\n#include <stdio.h>\n/*\nGegeben eine ganze Zahl n, schreiben Sie eine Funktion, um die Summe aller Zahlen von 1 bis n zu berechnen, die Vielfache von entweder 3 oder 5 sind. Wenn eine Zahl ein Vielfaches von sowohl 3 als auch 5 ist, sollte sie nur einmal gezählt werden.\nZum Beispiel:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)\n*/\nint sumOfMultiples(int n)", "ha": "#include <assert.h>\n#include <stdio.h>\n/*\nAn ba da wani lamba n, rubuta wata aiki don lissafin jumlar dukkan lambobi daga 1 zuwa n waɗanda suke masu yawa na 3 ko 5. Idan lamba tana da yawa na duka 3 da 5, ya kamata a ƙidaya ta sau ɗaya kawai.\nMisali:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)\n*/\nint sumOfMultiples(int n)", "hi": "#include <assert.h>\n#include <stdio.h>\n/*\nदिए गए पूर्णांक n के लिए, एक फ़ंक्शन लिखें जो 1 से n तक के उन सभी संख्याओं का योग गणना करे जो या तो 3 या 5 के गुणज हैं। यदि कोई संख्या 3 और 5 दोनों का गुणज है, तो उसे केवल एक बार गिना जाना चाहिए।\nउदाहरण के लिए:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)\n*/\nint sumOfMultiples(int n)", "hu": "#include <assert.h>\n#include <stdio.h>\n/*\nAdott egy egész szám n, írj egy függvényt, amely kiszámítja az összes 1-től n-ig terjedő szám összegét, amelyek 3 vagy 5 többszörösei. Ha egy szám 3-nak és 5-nek is többszöröse, akkor csak egyszer kell számolni.\nPéldául:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)\n*/\nint sumOfMultiples(int n)", "es": "#include <assert.h>\n#include <stdio.h>\n/*\nDado un entero n, escribe una función para calcular la suma de todos los números desde 1 hasta n que son múltiplos de 3 o 5. Si un número es múltiplo de ambos, 3 y 5, debe contarse solo una vez.\nPor ejemplo:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)\n*/\nint sumOfMultiples(int n)", "arb": "#include <assert.h>\n#include <stdio.h>\n/*\nمُعطى عدد صحيح n، اكتب دالة لحساب مجموع جميع الأرقام من 1 إلى n التي هي مضاعفات لـ 3 أو 5. إذا كان الرقم مضاعفًا لكل من 3 و 5، يجب أن يُحسب مرة واحدة فقط.\nعلى سبيل المثال:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)\n*/\nint sumOfMultiples(int n)", "sw": "#include <assert.h>\n#include <stdio.h>\n/*\nUkipiwa nambari nzima n, andika kazi ya kuhesabu jumla ya nambari zote kutoka 1 hadi n ambazo ni maradufu ya 3 au 5. Ikiwa nambari ni maradufu ya 3 na 5, inapaswa kuhesabiwa mara moja tu.\nKwa mfano:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)\n*/\nint sumOfMultiples(int n)", "tr": "#include <assert.h>\n#include <stdio.h>\n/*\nVerilen bir tamsayı n için, 1'den n'ye kadar olan ve 3 veya 5'in katı olan tüm sayıların toplamını hesaplayan bir fonksiyon yazın. Bir sayı hem 3 hem de 5'in katıysa, yalnızca bir kez sayılmalıdır.\nÖrneğin:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)\n*/\nint sumOfMultiples(int n)", "vi": "#include <assert.h>\n#include <stdio.h>\n/*\nCho một số nguyên n, viết một hàm để tính tổng của tất cả các số từ 1 đến n mà là bội số của 3 hoặc 5. Nếu một số là bội số của cả 3 và 5, nó chỉ nên được tính một lần.\nVí dụ:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)\n*/\nint sumOfMultiples(int n)", "id": "#include <assert.h>\n#include <stdio.h>\n/*\nDiberikan sebuah bilangan bulat n, tulislah sebuah fungsi untuk menghitung jumlah semua angka dari 1 hingga n yang merupakan kelipatan dari 3 atau 5. Jika sebuah angka merupakan kelipatan dari 3 dan 5, maka angka tersebut hanya dihitung satu kali.\nSebagai contoh:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)\n*/\nint sumOfMultiples(int n)", "ja": "#include <assert.h>\n#include <stdio.h>\n/*\n整数 n が与えられたとき、3 または 5 の倍数である 1 から n までのすべての数の合計を計算する関数を書いてください。ある数が 3 と 5 の両方の倍数である場合、それは一度だけカウントされるべきです。\n例えば:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)\n*/\nint sumOfMultiples(int n)", "ko": "#include <assert.h>\n#include <stdio.h>\n/*\n정수 n이 주어질 때, 1부터 n까지의 숫자 중 3 또는 5의 배수인 모든 숫자의 합을 계산하는 함수를 작성하세요. 숫자가 3과 5의 공배수인 경우에는 한 번만 계산해야 합니다.\n예를 들어:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)\n*/\nint sumOfMultiples(int n)", "ml": "#include <assert.h>\n#include <stdio.h>\n/*\nഒരു പൂർണ്ണസംഖ്യ n നൽകിയാൽ, 3 അല്ലെങ്കിൽ 5 ന്റെ ഗുണിതകങ്ങൾ ആയ 1 മുതൽ n വരെ ഉള്ള എല്ലാ സംഖ്യകളുടെയും മൊത്തം കണക്കാക്കാൻ ഒരു ഫങ്ഷൻ എഴുതുക. ഒരു സംഖ്യ 3 ന്റെയും 5 ന്റെയും ഗുണിതകം ആണെങ്കിൽ, അത് ഒരിക്കൽ മാത്രം എണ്ണണം.\nഉദാഹരണത്തിന്:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)\n*/\nint sumOfMultiples(int n)", "fa": "#include <assert.h>\n#include <stdio.h>\n/*\nبا توجه به یک عدد صحیح n، یک تابع بنویسید که مجموع تمام اعداد از 1 تا n را که مضربی از 3 یا 5 هستند محاسبه کند. اگر عددی مضربی از هر دو 3 و 5 باشد، باید فقط یک بار شمارش شود.\nبرای مثال:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)\n*/\nint sumOfMultiples(int n)"}, "canonical_solution": "{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}", "instruction": {"en": "int sumOfMultiples(int n)\n{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "sq": "int sumOfMultiples(int n)\n{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C në shqip duke përdorur maksimumi 500 karaktere.", "hy": "int sumOfMultiples(int n)\n{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nՏվեք C կոդի համառոտ բնական լեզվով նկարագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "int sumOfMultiples(int n)\n{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nসি কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।", "bg": "int sumOfMultiples(int n)\n{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, като използвате не повече от 500 знака.", "zh": "int sumOfMultiples(int n)\n{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\n请用最多500个字符的中文对该C代码提供简洁的自然语言描述（文档字符串）。", "fr": "int sumOfMultiples(int n)\n{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.", "de": "int sumOfMultiples(int n)\n{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen.", "ha": "int sumOfMultiples(int n)\n{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nBa da takaitaccen bayani a cikin yare na halitta (docstring) na lambar C a cikin Hausa ta amfani da haruffa 500 kacal.", "hi": "int sumOfMultiples(int n)\n{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nदिए गए C कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।", "hu": "int sumOfMultiples(int n)\n{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben.", "es": "int sumOfMultiples(int n)\n{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando un máximo de 500 caracteres.", "arb": "int sumOfMultiples(int n)\n{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "int sumOfMultiples(int n)\n{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "int sumOfMultiples(int n)\n{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nC kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter kullanılmalıdır.", "vi": "int sumOfMultiples(int n)\n{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã C bằng tiếng Việt, sử dụng tối đa 500 ký tự.", "id": "int sumOfMultiples(int n)\n{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode C dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "int sumOfMultiples(int n)\n{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nCP コードの簡単な自然言語による説明 (docstring) を英語で最大 500 文字まで入力してください。", "ko": "int sumOfMultiples(int n)\n{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nC 코드에 대한 간결한 자연어 설명(도크스트링)을 한국어로 최대 500자 이내로 제공하세요.", "ml": "int sumOfMultiples(int n)\n{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nസീ കോഡിന്റെ ഡോക്സ്ട്രിംഗ് മലയാളത്തിൽ 500 അക്ഷരങ്ങളിൽ കൂടുതൽ അല്ലാത്ത തരത്തിൽ സംക്ഷിപ്തമായ പ്രകൃതിദത്ത ഭാഷാ വിവരണം നൽകുക.", "fa": "int sumOfMultiples(int n)\n{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nتوضیح مختصر و طبیعی (docstring) از کد C به زبان فارسی ارائه دهید که حداکثر ۵۰۰ کاراکتر باشد."}, "level": "", "test": "int main()\n{\n    assert(sumOfMultiples(10) == 33);\n    assert(sumOfMultiples(15) == 60);\n    assert(sumOfMultiples(20) == 98);\n    assert(sumOfMultiples(5) == 8);\n    assert(sumOfMultiples(3) == 3);\n    assert(sumOfMultiples(6) == 14);\n    assert(sumOfMultiples(9) == 23);\n    assert(sumOfMultiples(12) == 45);\n    assert(sumOfMultiples(17) == 60);\n    assert(sumOfMultiples(21) == 119);\n    assert(sumOfMultiples(25) == 168);\n    return 0;\n}", "entry_point": "sumOfMultiples", "signature": "int sumOfMultiples(int n)", "docstring": {"en": "Given an integer n, write a function to compute the sum of all numbers from 1 to n that are multiples of either 3 or 5. If a number is a multiple of both 3 and 5, it should only be counted once.\nFor example:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)\n", "sq": "Duke pasur një numër të plotë n, shkruani një funksion për të llogaritur shumën e të gjitha numrave nga 1 deri në n që janë shumëfish i 3 ose 5. Nëse një numër është shumëfish i të dyve 3 dhe 5, ai duhet të numërohet vetëm një herë.\nPër shembull:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)", "hy": "Տրված է n ամբողջ թիվը, գրեք ֆունկցիա՝ հաշվելու համար 1-ից մինչև n բոլոր այն թվերի գումարը, որոնք բազմապատիկ են 3-ի կամ 5-ի։ Եթե թիվը բազմապատիկ է և՛ 3-ի, և՛ 5-ի, այն պետք է հաշվել միայն մեկ անգամ։\nՕրինակ՝\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)", "bn": "একটি পূর্ণসংখ্যা n দেওয়া হলে, ১ থেকে n পর্যন্ত সমস্ত সংখ্যার যোগফল গণনা করার জন্য একটি ফাংশন লিখুন যা ৩ বা ৫ এর গুণিতক। যদি কোনো সংখ্যা ৩ এবং ৫ উভয়ের গুণিতক হয়, তবে এটি কেবল একবার গণনা করা উচিত।\nউদাহরণস্বরূপ:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)", "bg": "Дадено е цяло число n, напишете функция за изчисляване на сумата на всички числа от 1 до n, които са кратни на 3 или 5. Ако едно число е кратно и на 3, и на 5, то трябва да бъде преброено само веднъж.\nНапример:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)", "zh": "给定一个整数 n，编写一个函数来计算从 1 到 n 之间所有是 3 或 5 的倍数的数字之和。如果一个数字同时是 3 和 5 的倍数，则它只应被计算一次。\n\n例如：\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)", "fr": "Étant donné un entier n, écrivez une fonction pour calculer la somme de tous les nombres de 1 à n qui sont des multiples de 3 ou 5. Si un nombre est un multiple à la fois de 3 et de 5, il ne doit être compté qu'une seule fois.  \nPar exemple :  \n    >>> sumOfMultiples(10)  \n    33 // (3 + 5 + 6 + 9 + 10)  ", "de": "Geben Sie eine ganze Zahl n an, und schreiben Sie eine Funktion, um die Summe aller Zahlen von 1 bis n zu berechnen, die Vielfache von entweder 3 oder 5 sind. Wenn eine Zahl ein Vielfaches von sowohl 3 als auch 5 ist, sollte sie nur einmal gezählt werden.\nZum Beispiel:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)", "ha": "An ba da wani cikakken lamba n, rubuta wata aiki don lissafin jimillar dukkan lambobi daga 1 zuwa n waɗanda suke masu yawa na ko dai 3 ko 5. Idan wata lamba tana da yawa na duka 3 da 5, ya kamata a ƙidaya ta sau ɗaya kawai.\nMisali:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)", "hi": "दिए गए पूर्णांक n के लिए, एक फ़ंक्शन लिखें जो 1 से n तक के उन सभी संख्याओं का योग गणना करे जो या तो 3 या 5 के गुणज हैं। यदि कोई संख्या 3 और 5 दोनों का गुणज है, तो उसे केवल एक बार गिना जाना चाहिए। \nउदाहरण के लिए:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)", "hu": "Adott egy egész szám n, írj egy függvényt, amely kiszámítja az összes 1-től n-ig terjedő szám összegét, amelyek 3 vagy 5 többszörösei. Ha egy szám mind a 3, mind az 5 többszöröse, akkor csak egyszer kell számolni.\nPéldául:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)", "es": "Dado un entero n, escribe una función para calcular la suma de todos los números desde 1 hasta n que son múltiplos de 3 o 5. Si un número es múltiplo de ambos 3 y 5, solo debe contarse una vez.\nPor ejemplo:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)", "arb": "بالنظر إلى عدد صحيح n، اكتب دالة لحساب مجموع جميع الأرقام من 1 إلى n التي هي مضاعفات لـ 3 أو 5. إذا كان الرقم مضاعفًا لكل من 3 و 5، فيجب احتسابه مرة واحدة فقط.\nعلى سبيل المثال:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)", "sw": "Ikizingatiwa nambari nzima n, andika kazi ya kuhesabu jumla ya nambari zote kutoka 1 hadi n ambazo ni maradufu ya 3 au 5. Ikiwa nambari ni maradufu ya 3 na 5, inapaswa kuhesabiwa mara moja tu.\nKwa mfano:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)", "tr": "Verilen bir tam sayı n için, 1'den n'e kadar olan ve 3 veya 5'in katı olan tüm sayıların toplamını hesaplayan bir fonksiyon yazın. Bir sayı hem 3 hem de 5'in katıysa, yalnızca bir kez sayılmalıdır.\nÖrneğin:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)", "vi": "Cho một số nguyên n, viết một hàm để tính tổng của tất cả các số từ 1 đến n mà là bội số của 3 hoặc 5. Nếu một số là bội số của cả 3 và 5, nó chỉ nên được tính một lần.\nVí dụ:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)", "id": "Diberikan sebuah bilangan bulat n, tulis sebuah fungsi untuk menghitung jumlah semua angka dari 1 hingga n yang merupakan kelipatan dari 3 atau 5. Jika sebuah angka merupakan kelipatan dari 3 dan 5, angka tersebut hanya dihitung sekali.\nSebagai contoh:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)", "ja": "整数 n が与えられたとき、3 または 5 の倍数である 1 から n までのすべての数の合計を計算する関数を書いてください。ある数が 3 と 5 の両方の倍数である場合、それは一度だけカウントされるべきです。\n例えば:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)", "ko": "정수 n이 주어졌을 때, 1부터 n까지의 숫자 중 3 또는 5의 배수인 모든 숫자의 합을 계산하는 함수를 작성하세요. 숫자가 3과 5의 공배수인 경우에는 한 번만 계산되어야 합니다.\n예를 들어:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)", "ml": "ഒരു പൂർണ്ണസംഖ്യ n നൽകിയാൽ, 3 അല്ലെങ്കിൽ 5 ന്റെ ഗുണിതകങ്ങൾ ആയ 1 മുതൽ n വരെ ഉള്ള എല്ലാ സംഖ്യകളുടെയും തുക കണക്കാക്കാൻ ഒരു ഫങ്ഷൻ എഴുതുക. ഒരു സംഖ്യ 3 ന്റെയും 5 ന്റെയും ഗുണിതകം ആണെങ്കിൽ, അത് ഒരിക്കൽ മാത്രം എണ്ണണം. \nഉദാഹരണത്തിന്:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)", "fa": "با توجه به یک عدد صحیح n، یک تابع بنویسید که مجموع تمام اعداد از 1 تا n که مضرب 3 یا 5 هستند را محاسبه کند. اگر عددی مضرب هر دو 3 و 5 باشد، باید فقط یک بار شمارش شود.\nبرای مثال:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)"}}
{"task_id": "C/47", "prompt": {"en": "#include <assert.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDetermine if a given string is a palindrome. A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward (ignoring spaces, punctuation, and capitalization).\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false\n*/\nbool isPalindrome(const char* str);", "sq": "#include <assert.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nPërcaktoni nëse një varg i dhënë është një palindrom. Një palindrom është një fjalë, frazë, numër, ose sekuencë tjetër karakteresh që lexohet njësoj përpara dhe prapa (duke injoruar hapësirat, shenjat e pikësimit dhe shkronjat e mëdha).\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false\n*/\nbool isPalindrome(const char* str);", "hy": "#include <assert.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nՈրոշել՝ արդյոք տրված տողը պալինդրոմ է։ Պալինդրոմը բառ է, արտահայտություն, թիվ կամ այլ նիշերի հաջորդականություն, որը կարդացվում է նույն կերպ առաջ և հետ (անտեսելով բացատները, կետադրությունը և մեծատառերը):\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false\n*/\nbool isPalindrome(const char* str);", "bn": "#include <assert.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nনির্ধারণ করুন একটি প্রদত্ত স্ট্রিং প্যালিনড্রোম কিনা। একটি প্যালিনড্রোম হল একটি শব্দ, বাক্যাংশ, সংখ্যা বা অন্য কোনো অক্ষরের ক্রম যা সামনের দিকে এবং পিছনের দিকে একইভাবে পড়ে (স্পেস, যতিচিহ্ন এবং বড় হাতের অক্ষর উপেক্ষা করে)।\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false\n*/\nbool isPalindrome(const char* str);", "bg": "#include <assert.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nОпределете дали даден низ е палиндром. Палиндром е дума, фраза, число или друга последователност от символи, която се чете еднакво напред и назад (като се игнорират интервали, пунктуация и главни букви).\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false\n*/\nbool isPalindrome(const char* str);", "zh": "#include <assert.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n确定给定的字符串是否为回文。回文是指正着读和反着读都相同的单词、短语、数字或其他字符序列（忽略空格、标点和大小写）。\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false\n*/\nbool isPalindrome(const char* str);", "fr": "#include <assert.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDéterminer si une chaîne donnée est un palindrome. Un palindrome est un mot, une phrase, un nombre ou une autre séquence de caractères qui se lit de la même manière de l'avant vers l'arrière et de l'arrière vers l'avant (en ignorant les espaces, la ponctuation et les majuscules).\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false\n*/\nbool isPalindrome(const char* str);", "de": "#include <assert.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nBestimmen, ob ein gegebener String ein Palindrom ist. Ein Palindrom ist ein Wort, ein Satz, eine Zahl oder eine andere Zeichenfolge, die vorwärts und rückwärts gleich gelesen wird (unter Ignorierung von Leerzeichen, Satzzeichen und Groß-/Kleinschreibung).\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false\n*/\nbool isPalindrome(const char* str);", "ha": "#include <assert.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nKafa ko wani kirtani da aka bayar palindrome ne. Palindrome kalma ce, jimla, lamba, ko wata jerin haruffa da ke karantawa iri ɗaya gaba da baya (ba tare da la'akari da sarari, rubutu, da babban ba).\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false\n*/\nbool isPalindrome(const char* str);", "hi": "#include <assert.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nनिर्धारित करें कि दिया गया स्ट्रिंग एक पालिंड्रोम है या नहीं। एक पालिंड्रोम एक शब्द, वाक्यांश, संख्या, या अन्य वर्णों का अनुक्रम है जो आगे और पीछे से समान रूप से पढ़ा जाता है (स्पेस, विराम चिह्न, और बड़े अक्षरों की अनदेखी करते हुए)।\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false\n*/\nbool isPalindrome(const char* str);", "hu": "#include <assert.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nHatározza meg, hogy egy adott sztring palindróm-e. A palindróm olyan szó, kifejezés, szám vagy más karakterek sorozata, amely előre és hátrafelé olvasva is ugyanaz (figyelmen kívül hagyva a szóközöket, írásjeleket és a nagybetűket).\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false\n*/\nbool isPalindrome(const char* str);", "es": "#include <assert.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDeterminar si una cadena dada es un palíndromo. Un palíndromo es una palabra, frase, número u otra secuencia de caracteres que se lee igual de adelante hacia atrás (ignorando espacios, puntuación y mayúsculas).\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false\n*/\nbool isPalindrome(const char* str);", "arb": "#include <assert.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nتحديد ما إذا كانت سلسلة معينة هي جملة مقلوبة. الجملة المقلوبة هي كلمة أو عبارة أو رقم أو تسلسل آخر من الأحرف التي تُقرأ بنفس الطريقة من الأمام إلى الخلف (مع تجاهل المسافات وعلامات الترقيم والحروف الكبيرة).\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false\n*/\nbool isPalindrome(const char* str);", "sw": "#include <assert.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nTambua kama kamba iliyotolewa ni palindrome. Palindrome ni neno, kifungu, namba, au mlolongo mwingine wa herufi ambao unasomwa sawa mbele na nyuma (kupuuza nafasi, alama za uakifishaji, na herufi kubwa).\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false\n*/\nbool isPalindrome(const char* str);", "tr": "#include <assert.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nVerilen bir dizgenin palindrom olup olmadığını belirleyin. Palindrom, ileri ve geri okunduğunda aynı olan (boşluklar, noktalama işaretleri ve büyük/küçük harf farkı göz ardı edilerek) bir kelime, ifade, sayı veya diğer karakter dizisidir.\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false\n*/\nbool isPalindrome(const char* str);", "vi": "#include <assert.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nXác định xem một chuỗi cho trước có phải là palindrome hay không. Palindrome là một từ, cụm từ, số, hoặc một chuỗi ký tự khác mà khi đọc xuôi hay ngược đều giống nhau (bỏ qua khoảng trắng, dấu câu và chữ hoa chữ thường).\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false\n*/\nbool isPalindrome(const char* str);", "id": "#include <assert.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nMenentukan apakah string yang diberikan adalah palindrom. Palindrom adalah kata, frasa, angka, atau urutan karakter lain yang dibaca sama maju dan mundur (mengabaikan spasi, tanda baca, dan kapitalisasi).\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false\n*/\nbool isPalindrome(const char* str);", "ja": "#include <assert.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n与えられた文字列が回文かどうかを判断します。回文とは、前から読んでも後ろから読んでも同じになる単語、フレーズ、数字、または他の文字の並びのことです（スペース、句読点、大文字小文字は無視します）。\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false\n*/\nbool isPalindrome(const char* str);", "ko": "#include <assert.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n주어진 문자열이 회문인지 확인합니다. 회문은 앞뒤로 읽어도 동일한 단어, 구, 숫자 또는 다른 문자 시퀀스를 말합니다 (공백, 구두점 및 대소문자는 무시합니다).\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false\n*/\nbool isPalindrome(const char* str);", "ml": "#include <assert.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nഒരു നൽകിയ സ്ട്രിംഗ് പലിൻഡ്രോമാണോ എന്ന് നിർണ്ണയിക്കുക. ഒരു പലിൻഡ്രോം എന്നത് ഒരു വാക്ക്, വാചകം, സംഖ്യ, അല്ലെങ്കിൽ മറ്റേതെങ്കിലും പ്രതീകങ്ങളുടെ ശ്രേണി ആണ്, അത് മുന്നോട്ടും പിന്നോട്ടും ഒരേ പോലെ വായിക്കപ്പെടുന്നു (വിരാമചിഹ്നങ്ങൾ, പങ്ക്ച്വേഷൻ, ക്യാപിറ്റലൈസേഷൻ എന്നിവ അവഗണിക്കുന്നു).\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false\n*/\nbool isPalindrome(const char* str);", "fa": "#include <assert.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nتعیین کنید که آیا یک رشته داده شده یک پالیندروم است یا خیر. پالیندروم کلمه، عبارت، عدد یا دنباله‌ای از کاراکترها است که به همان صورت از جلو به عقب و از عقب به جلو خوانده می‌شود (با نادیده گرفتن فاصله‌ها، علائم نگارشی و حروف بزرگ و کوچک).\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false\n*/\nbool isPalindrome(const char* str);"}, "canonical_solution": "bool isPalindrome(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}", "instruction": {"en": "bool isPalindrome(const char* str)\nbool isPalindrome(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "sq": "bool isPalindrome(const char* str)\nbool isPalindrome(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C në shqip duke përdorur maksimumi 500 karaktere.", "hy": "bool isPalindrome(const char* str)\nbool isPalindrome(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}\n\nՏվեք C կոդի հակիրճ բնութագիրը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "bool isPalindrome(const char* str)\nbool isPalindrome(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}\n\nসি কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলা ভাষায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।", "bg": "bool isPalindrome(const char* str)\nbool isPalindrome(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, използвайки не повече от 500 знака.", "zh": "bool isPalindrome(const char* str)\nbool isPalindrome(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}\n\n请用中文为以下C代码提供简明的自然语言描述（文档字符串），字数不超过500个字符。", "fr": "bool isPalindrome(const char* str)\nbool isPalindrome(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.", "de": "bool isPalindrome(const char* str)\nbool isPalindrome(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "bool isPalindrome(const char* str)\nbool isPalindrome(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}\n\nBa da taƙaitaccen bayanin yare na halitta (docstring) na lambar C cikin Hausa ta amfani da haruffa 500 ko ƙasa da haka.", "hi": "bool isPalindrome(const char* str)\nbool isPalindrome(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}\n\nC कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "bool isPalindrome(const char* str)\nbool isPalindrome(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben.", "es": "bool isPalindrome(const char* str)\nbool isPalindrome(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando como máximo 500 caracteres.", "arb": "bool isPalindrome(const char* str)\nbool isPalindrome(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.", "sw": "bool isPalindrome(const char* str)\nbool isPalindrome(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "bool isPalindrome(const char* str)\nbool isPalindrome(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}\n\nC kodunun işlevini açıklayan kısa bir doğal dil tanımı (docstring) sağlayın. Açıklama, Türkçe olarak en fazla 500 karakter kullanılacak şekilde olmalıdır.", "vi": "bool isPalindrome(const char* str)\nbool isPalindrome(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã C bằng tiếng Việt với tối đa 500 ký tự.", "id": "bool isPalindrome(const char* str)\nbool isPalindrome(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode C dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "bool isPalindrome(const char* str)\nbool isPalindrome(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}\n\nCコードの内容を日本語で簡潔に説明するドキュメンテーションストリング（docstring）を、最大500文字で提供してください。", "ko": "bool isPalindrome(const char* str)\nbool isPalindrome(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}\n\nC 코드에 대한 간결한 자연어 설명(docstring)을 한국어로 최대 500자 이내로 제공하세요.", "ml": "bool isPalindrome(const char* str)\nbool isPalindrome(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}\n\nസീ കോഡിന്റെ ഡോക്സ്ട്രിംഗ് മലയാളത്തിൽ 500 അക്ഷരങ്ങളിൽ കവിയാതെയുള്ള സംക്ഷിപ്തമായ സ്വാഭാവിക ഭാഷാ വിവരണം നൽകുക.", "fa": "bool isPalindrome(const char* str)\nbool isPalindrome(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}\n\nیک توضیح مختصر به زبان طبیعی (docstring) از کد C به زبان فارسی ارائه دهید که حداکثر ۵۰۰ کاراکتر باشد."}, "level": "", "test": "int main()\n{\n    assert(isPalindrome(\"A man a plan a canal Panama\") == true);\n    assert(isPalindrome(\"No lemon, no melon\") == true);\n    assert(isPalindrome(\"Was it a car or a cat I saw\") == true);\n    assert(isPalindrome(\"Madam, in Eden, I'm Adam\") == true);\n    assert(isPalindrome(\"Never odd or even\") == true);\n    assert(isPalindrome(\"Eva, can I see bees in a cave\") == true);\n    assert(isPalindrome(\"hello\") == false);\n    assert(isPalindrome(\"GitHub\") == false);\n    assert(isPalindrome(\"programming\") == false);\n    \n    return 0;\n}", "entry_point": "isPalindrome", "signature": "bool isPalindrome(const char* str)", "docstring": {"en": "Determine if a given string is a palindrome. A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward (ignoring spaces, punctuation, and capitalization).\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false\n", "sq": "Përcaktoni nëse një varg i dhënë është një palindrom. Një palindrom është një fjalë, frazë, numër, ose një sekuencë tjetër karakteresh që lexohet njësoj përpara dhe prapa (duke injoruar hapësirat, shenjat e pikësimit dhe shkronjat e mëdha).\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false", "hy": "Որոշել, արդյոք տրված տողը պալինդրոմ է: Պալինդրոմը բառ է, արտահայտություն, թիվ կամ այլ նիշերի հաջորդականություն, որը նույնն է կարդացվում առաջ և հետ (անտեսելով բացատները, կետադրությունը և մեծատառերը):\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false", "bn": "একটি প্রদত্ত স্ট্রিং প্যালিনড্রোম কিনা তা নির্ধারণ করুন। একটি প্যালিনড্রোম হল একটি শব্দ, বাক্যাংশ, সংখ্যা বা অন্যান্য অক্ষরগুলির ক্রম যা সামনের এবং পিছনের দিক থেকে একইভাবে পড়ে (স্পেস, বিরামচিহ্ন এবং বড় হাতের অক্ষর উপেক্ষা করে)।\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false", "bg": "Определете дали даден низ е палиндром. Палиндром е дума, фраза, число или друга последователност от символи, която се чете еднакво напред и назад (като се игнорират интервали, пунктуация и главни букви).\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false", "zh": "确定给定的字符串是否为回文。回文是指无论正向还是反向读取都相同的单词、短语、数字或其他字符序列（忽略空格、标点和大小写）。\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false", "fr": "Déterminer si une chaîne donnée est un palindrome. Un palindrome est un mot, une phrase, un nombre ou une autre séquence de caractères qui se lit de la même manière à l'endroit et à l'envers (en ignorant les espaces, la ponctuation et la capitalisation).\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false", "de": "Bestimmen Sie, ob ein gegebener String ein Palindrom ist. Ein Palindrom ist ein Wort, ein Satz, eine Zahl oder eine andere Zeichenfolge, die vorwärts und rückwärts gleich gelesen wird (unter Ignorierung von Leerzeichen, Interpunktion und Groß-/Kleinschreibung).\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false", "ha": "Gano idan wata kirtani da aka bayar palindrome ce. Palindrome kalma ce, jimla, lamba, ko wata jerin haruffa da ake karantawa iri ɗaya a gaba da baya (ba tare da la'akari da sarari, alamar rubutu, da manyan haruffa ba).\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false", "hi": "दिया गया स्ट्रिंग एक पालिंड्रोम है या नहीं, यह निर्धारित करें। एक पालिंड्रोम एक शब्द, वाक्यांश, संख्या, या अन्य वर्णों का अनुक्रम होता है जो आगे और पीछे से एक जैसा पढ़ा जाता है (स्पेस, विराम चिह्न, और बड़े/छोटे अक्षरों की अनदेखी करते हुए)।\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false", "hu": "Határozza meg, hogy egy adott karakterlánc palindróm-e. A palindróm olyan szó, kifejezés, szám vagy más karakterek sorozata, amely előre és hátrafelé olvasva is ugyanaz (figyelmen kívül hagyva a szóközöket, írásjeleket és a nagybetűket).\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false", "es": "Determinar si una cadena dada es un palíndromo. Un palíndromo es una palabra, frase, número u otra secuencia de caracteres que se lee igual de adelante hacia atrás (ignorando espacios, puntuación y capitalización).\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false", "arb": "تحديد ما إذا كانت سلسلة معينة هي كلمة متطابقة عند قراءتها من الأمام والخلف. الكلمة المتطابقة هي كلمة، أو عبارة، أو رقم، أو تسلسل آخر من الأحرف التي تُقرأ بنفس الطريقة سواء من الأمام أو الخلف (مع تجاهل المسافات، وعلامات الترقيم، والحروف الكبيرة والصغيرة).\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false", "sw": "Amua ikiwa kamba iliyotolewa ni palindrome. Palindrome ni neno, kifungu, nambari, au mlolongo mwingine wa herufi ambao unasomwa sawa mbele na nyuma (kupuuza nafasi, alama za uakifishaji, na herufi kubwa na ndogo).\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false", "tr": "Verilen bir dizgenin palindrom olup olmadığını belirleyin. Palindrom, ileri ve geri okunduğunda aynı olan (boşluklar, noktalama işaretleri ve büyük/küçük harf farkı göz ardı edilerek) bir kelime, ifade, sayı veya diğer karakter dizisidir.\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false", "vi": "Xác định xem một chuỗi cho trước có phải là một chuỗi palindrome hay không. Một chuỗi palindrome là một từ, cụm từ, số, hoặc một dãy ký tự khác mà đọc xuôi hay ngược đều giống nhau (bỏ qua khoảng trắng, dấu câu, và phân biệt chữ hoa chữ thường).\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false", "id": "Tentukan apakah string yang diberikan adalah palindrom. Palindrom adalah kata, frasa, angka, atau urutan karakter lainnya yang dibaca sama maju dan mundur (mengabaikan spasi, tanda baca, dan kapitalisasi).\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false", "ja": "与えられた文字列が回文かどうかを判断します。回文とは、前から読んでも後ろから読んでも同じになる単語、フレーズ、数字、または他の文字列のことです（スペース、句読点、大文字小文字は無視します）。\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false", "ko": "주어진 문자열이 회문인지 확인합니다. 회문은 앞뒤로 읽어도 동일한 단어, 구, 숫자 또는 다른 문자 시퀀스를 말합니다 (공백, 구두점 및 대소문자를 무시합니다).\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false", "ml": "ഒരു നൽകിയ സ്ട്രിംഗ് പാലിൻഡ്രോം ആണോ എന്ന് നിർണ്ണയിക്കുക. പാലിൻഡ്രോം എന്നത് ഒരു വാക്ക്, വാചകം, സംഖ്യ, അല്ലെങ്കിൽ മറ്റേതെങ്കിലും അക്ഷരങ്ങളുടെ നിരയാണ്, അത് മുന്നോട്ടും പിന്നോട്ടും ഒരേ പോലെ വായിക്കപ്പെടുന്നു (വിരാമചിഹ്നങ്ങളും വലുതും ചെറുതുമായ അക്ഷരങ്ങളും അവഗണിക്കുന്നു).\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false", "fa": "تعیین کنید که آیا یک رشته داده شده یک پالیندروم است یا خیر. یک پالیندروم کلمه، عبارت، عدد یا دنباله دیگری از کاراکترها است که از جلو و عقب به همان صورت خوانده می‌شود (با نادیده گرفتن فاصله‌ها، علائم نگارشی و حروف بزرگ و کوچک).\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false"}}
{"task_id": "C/48", "prompt": {"en": "#include <assert.h>\n#include <stdio.h>\n/*\nGiven a non-negative integer num, repeatedly add all its digits until the result has only one digit.\nFor example:\n    >>> addDigits(38)\n    2\n    Because 3 + 8 = 11, and 1 + 1 = 2. Since 2 has only one digit, 2 is the result.\n*/\nint addDigits(int num)", "sq": "#include <assert.h>\n#include <stdio.h>\n/*\nDuke pasur një numër të plotë jo-negativ num, shtoni përsëri të gjitha shifrat e tij derisa rezultati të ketë vetëm një shifër.\nPër shembull:\n    >>> addDigits(38)\n    2\n    Sepse 3 + 8 = 11, dhe 1 + 1 = 2. Meqenëse 2 ka vetëm një shifër, 2 është rezultati.\n*/\nint addDigits(int num)", "hy": "#include <assert.h>\n#include <stdio.h>\n/*\nՏրված է ոչ բացասական ամբողջ թիվ num, բազմիցս գումարեք նրա բոլոր թվանշանները, մինչև արդյունքը կունենա միայն մեկ թվանշան:\nՕրինակ:\n    >>> addDigits(38)\n    2\n    Քանի որ 3 + 8 = 11, և 1 + 1 = 2։ Քանի որ 2-ն ունի միայն մեկ թվանշան, 2-ն է արդյունքը։\n*/\nint addDigits(int num)", "bn": "#include <assert.h>\n#include <stdio.h>\n/*\nএকটি অ-ঋণাত্মক পূর্ণসংখ্যা num দেওয়া হয়েছে, তার সমস্ত অঙ্ক বারবার যোগ করুন যতক্ষণ না ফলাফলটি শুধুমাত্র এক অঙ্কের হয়।\nউদাহরণস্বরূপ:\n    >>> addDigits(38)\n    2\n    কারণ 3 + 8 = 11, এবং 1 + 1 = 2। যেহেতু 2-এর শুধুমাত্র এক অঙ্ক রয়েছে, 2 হল ফলাফল।\n*/\nint addDigits(int num)", "bg": "#include <assert.h>\n#include <stdio.h>\n/*\nДадено е неотрицателно цяло число num, многократно събирайте всичките му цифри, докато резултатът не стане едноцифрено число.\nНапример:\n    >>> addDigits(38)\n    2\n    Защото 3 + 8 = 11, и 1 + 1 = 2. Тъй като 2 е едноцифрено число, 2 е резултатът.\n*/\nint addDigits(int num)", "zh": "#include <assert.h>\n#include <stdio.h>\n/*\n给定一个非负整数 num，重复将所有位数相加，直到结果只有一位数字。\n例如：\n    >>> addDigits(38)\n    2\n    因为 3 + 8 = 11，1 + 1 = 2。由于 2 只有一位数字，所以结果是 2。\n*/\nint addDigits(int num)", "fr": "#include <assert.h>\n#include <stdio.h>\n/*\nÉtant donné un entier non négatif num, ajoutez de manière répétée tous ses chiffres jusqu'à ce que le résultat n'ait qu'un seul chiffre.\nPar exemple :\n    >>> addDigits(38)\n    2\n    Parce que 3 + 8 = 11, et 1 + 1 = 2. Puisque 2 n'a qu'un seul chiffre, 2 est le résultat.\n*/\nint addDigits(int num)", "de": "#include <assert.h>\n#include <stdio.h>\n/*\nGegeben eine nicht-negative ganze Zahl num, addiere wiederholt alle ihre Ziffern, bis das Ergebnis nur noch eine Ziffer hat.\nZum Beispiel:\n    >>> addDigits(38)\n    2\n    Weil 3 + 8 = 11, und 1 + 1 = 2. Da 2 nur eine Ziffer hat, ist 2 das Ergebnis.\n*/\nint addDigits(int num)", "ha": "#include <assert.h>\n#include <stdio.h>\n/*\nAn ba da wani lamba mara kyau num, a ci gaba da ƙara duk lambobinsa har sai sakamakon yana da lamba ɗaya kawai.\nMisali:\n    >>> addDigits(38)\n    2\n    Domin 3 + 8 = 11, kuma 1 + 1 = 2. Tun da 2 yana da lamba ɗaya kawai, 2 shine sakamakon.\n*/\nint addDigits(int num)", "hi": "#include <assert.h>\n#include <stdio.h>\n/*\nदिया गया एक गैर-ऋणात्मक पूर्णांक num, इसकी सभी अंकों को बार-बार जोड़ें जब तक कि परिणाम में केवल एक अंक न हो।\nउदाहरण के लिए:\n    >>> addDigits(38)\n    2\n    क्योंकि 3 + 8 = 11, और 1 + 1 = 2। चूंकि 2 में केवल एक अंक है, 2 परिणाम है।\n*/\nint addDigits(int num)", "hu": "#include <assert.h>\n#include <stdio.h>\n/*\nAdott egy nem negatív egész szám, ismételten add össze az összes számjegyét, amíg az eredmény csak egy számjegyből áll.\nPéldául:\n    >>> addDigits(38)\n    2\n    Mert 3 + 8 = 11, és 1 + 1 = 2. Mivel a 2 csak egy számjegyből áll, 2 az eredmény.\n*/\nint addDigits(int num)", "es": "#include <assert.h>\n#include <stdio.h>\n/*\nDado un número entero no negativo num, suma repetidamente todos sus dígitos hasta que el resultado tenga solo un dígito.\nPor ejemplo:\n    >>> addDigits(38)\n    2\n    Porque 3 + 8 = 11, y 1 + 1 = 2. Dado que 2 tiene solo un dígito, 2 es el resultado.\n*/\nint addDigits(int num)", "arb": "#include <assert.h>\n#include <stdio.h>\n/*\nمعطى عدد صحيح غير سالب num، اجمع جميع أرقامه بشكل متكرر حتى يكون الناتج رقمًا واحدًا فقط.\nعلى سبيل المثال:\n    >>> addDigits(38)\n    2\n    لأن 3 + 8 = 11، و 1 + 1 = 2. بما أن 2 هو رقم واحد فقط، فإن 2 هو الناتج.\n*/\nint addDigits(int num)", "sw": "#include <assert.h>\n#include <stdio.h>\n/*\nUkipewa nambari isiyo hasi num, ongeza mara kwa mara tarakimu zake zote hadi matokeo yawe na tarakimu moja tu.\nKwa mfano:\n    >>> addDigits(38)\n    2\n    Kwa sababu 3 + 8 = 11, na 1 + 1 = 2. Kwa kuwa 2 ina tarakimu moja tu, 2 ndiyo matokeo.\n*/\nint addDigits(int num)", "tr": "#include <assert.h>\n#include <stdio.h>\n/*\nVerilen negatif olmayan bir tamsayı num için, sonucu tek bir basamak kalana kadar tüm basamaklarını tekrar tekrar toplayın.\nÖrneğin:\n    >>> addDigits(38)\n    2\n    Çünkü 3 + 8 = 11 ve 1 + 1 = 2. 2 yalnızca bir basamak içerdiğinden, sonuç 2'dir.\n*/\nint addDigits(int num)", "vi": "#include <assert.h>\n#include <stdio.h>\n/*\nCho một số nguyên không âm num, liên tục cộng tất cả các chữ số của nó cho đến khi kết quả chỉ còn một chữ số.\nVí dụ:\n    >>> addDigits(38)\n    2\n    Bởi vì 3 + 8 = 11, và 1 + 1 = 2. Vì 2 chỉ có một chữ số, 2 là kết quả.\n*/\nint addDigits(int num)", "id": "#include <assert.h>\n#include <stdio.h>\n/*\nDiberikan bilangan bulat non-negatif num, tambahkan semua digitnya berulang kali hingga hasilnya hanya memiliki satu digit.\nSebagai contoh:\n    >>> addDigits(38)\n    2\n    Karena 3 + 8 = 11, dan 1 + 1 = 2. Karena 2 hanya memiliki satu digit, 2 adalah hasilnya.\n*/\nint addDigits(int num)", "ja": "#include <assert.h>\n#include <stdio.h>\n/*\n非負整数 num が与えられたとき、その結果が一桁になるまで全ての桁を繰り返し加算します。\n例えば:\n    >>> addDigits(38)\n    2\n    なぜなら 3 + 8 = 11 で、1 + 1 = 2 だからです。2 は一桁なので、2 が結果です。\n*/\nint addDigits(int num)", "ko": "#include <assert.h>\n#include <stdio.h>\n/*\n비음수가 아닌 정수 num이 주어졌을 때, 그 자리 수를 반복적으로 더하여 결과가 한 자리 수가 될 때까지 계속합니다.\n예를 들어:\n    >>> addDigits(38)\n    2\n    3 + 8 = 11이고, 1 + 1 = 2입니다. 2는 한 자리 수이므로, 2가 결과입니다.\n*/\nint addDigits(int num)", "ml": "#include <assert.h>\n#include <stdio.h>\n/*\nഒരു നെഗറ്റീവ് അല്ലാത്ത പൂർണ്ണസംഖ്യ നൽകിയാൽ, ഫലം ഒരു അക്കമാത്രം ഉള്ളതാകുന്നത് വരെ അതിന്റെ എല്ലാ അക്കങ്ങളും ആവർത്തിച്ച് കൂട്ടുക.\nഉദാഹരണത്തിന്:\n    >>> addDigits(38)\n    2\n    കാരണം 3 + 8 = 11, ഒപ്പം 1 + 1 = 2. 2-ന് ഒരു അക്കമാത്രം ഉള്ളതിനാൽ, 2 ആണ് ഫലം.\n*/\nint addDigits(int num)", "fa": "#include <assert.h>\n#include <stdio.h>\n/*\nبا توجه به یک عدد صحیح غیر منفی num، به طور مکرر تمام ارقام آن را اضافه کنید تا زمانی که نتیجه فقط یک رقم داشته باشد.\nبرای مثال:\n    >>> addDigits(38)\n    2\n    زیرا 3 + 8 = 11، و 1 + 1 = 2. از آنجا که 2 فقط یک رقم دارد، 2 نتیجه است.\n*/\nint addDigits(int num)"}, "canonical_solution": "{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}", "instruction": {"en": "int addDigits(int num)\n{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "sq": "int addDigits(int num)\n{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C në gjuhën shqipe duke përdorur maksimumi 500 karaktere.", "hy": "int addDigits(int num)\n{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}\n\nՏրամադրեք C կոդի համառոտ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "int addDigits(int num)\n{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}\n\nসি কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।", "bg": "int addDigits(int num)\n{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, използвайки най-много 500 знака.", "zh": "int addDigits(int num)\n{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}\n\n请用不超过500个字符的中文，为以下C代码提供简洁的自然语言描述（文档字符串）。", "fr": "int addDigits(int num)\n{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.", "de": "int addDigits(int num)\n{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "int addDigits(int num)\n{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}\n\nBa da takaitaccen bayani a cikin yaren halitta (docstring) na lambar C a cikin Hausa ta amfani da haruffa 500 kawai.", "hi": "int addDigits(int num)\n{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}\n\nदिए गए C कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "int addDigits(int num)\n{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben.", "es": "int addDigits(int num)\n{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando como máximo 500 caracteres.", "arb": "int addDigits(int num)\n{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشيفرة البرمجية المكتوبة بلغة C باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "int addDigits(int num)\n{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "int addDigits(int num)\n{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}\n\nC kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama en fazla 500 karakter olmalıdır.", "vi": "int addDigits(int num)\n{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã C bằng tiếng Việt với tối đa 500 ký tự.", "id": "int addDigits(int num)\n{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode C dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "int addDigits(int num)\n{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}\n\nCコードの内容を日本語で簡潔に説明するドキュメンテーション文字列（docstring）を500文字以内で提供してください。", "ko": "int addDigits(int num)\n{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}\n\nC 코드의 동작을 설명하는 간결한 자연어 설명(docstring)을 최대 500자 이내로 한국어로 제공하세요.", "ml": "int addDigits(int num)\n{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}\n\nC കോഡിന്റെ സംഗ്രഹമായ സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) മലയാളത്തിൽ 500 അക്ഷരങ്ങളിൽ കവിയാതെ നൽകുക.", "fa": "int addDigits(int num)\n{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}\n\nیک توضیح مختصر به زبان طبیعی (docstring) از کد C به زبان فارسی ارائه دهید که حداکثر ۵۰۰ کاراکتر باشد."}, "level": "", "test": "int main() {\n    assert(addDigits(38) == 2);\n    assert(addDigits(0) == 0);\n    assert(addDigits(9) == 9);\n    assert(addDigits(123) == 6);\n    assert(addDigits(456) == 6);\n    assert(addDigits(9999) == 9);\n    assert(addDigits(100) == 1);\n    assert(addDigits(1010) == 2);\n    assert(addDigits(1234) == 1);\n    assert(addDigits(9876) == 3);\n    assert(addDigits(199) == 1);\n    return 0;\n}", "entry_point": "addDigits", "signature": "int addDigits(int num)", "docstring": {"en": "Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.\nFor example:\n    >>> addDigits(38)\n    2\n    Because 3 + 8 = 11, and 1 + 1 = 2. Since 2 has only one digit, 2 is the result.", "sq": "Duke pasur një numër të plotë jo-negativ num, shtoni përsëri të gjitha shifrat e tij derisa rezultati të ketë vetëm një shifër.\nPër shembull:\n    >>> addDigits(38)\n    2\n    Sepse 3 + 8 = 11, dhe 1 + 1 = 2. Meqenëse 2 ka vetëm një shifër, 2 është rezultati.", "hy": "Տրված է ոչ բացասական ամբողջ թիվ num, բազմիցս գումարեք նրա բոլոր թվանշանները, մինչև արդյունքը կունենա միայն մեկ թվանշան։\nՕրինակ՝\n    >>> addDigits(38)\n    2\n    Քանի որ 3 + 8 = 11, և 1 + 1 = 2։ Քանի որ 2-ն ունի միայն մեկ թվանշան, 2-ն է արդյունքը։", "bn": "একটি অ-ঋণাত্মক পূর্ণসংখ্যা num দেওয়া হলে, ফলাফল এক অঙ্কের না হওয়া পর্যন্ত এর সমস্ত অঙ্ক বারবার যোগ করুন। \nউদাহরণস্বরূপ:\n    >>> addDigits(38)\n    2\n    কারণ 3 + 8 = 11, এবং 1 + 1 = 2। যেহেতু 2 এর মাত্র এক অঙ্ক আছে, তাই 2 হল ফলাফল।", "bg": "Като се даде неотрицателно цяло число num, повтаряйте събирането на всичките му цифри, докато резултатът не остане само с една цифра.\nНапример:\n    >>> addDigits(38)\n    2\n    Защото 3 + 8 = 11, и 1 + 1 = 2. Тъй като 2 има само една цифра, 2 е резултатът.", "zh": "给定一个非负整数 num，重复相加它的所有数字，直到结果只有一位数字。\n\n例如：\n    >>> addDigits(38)\n    2\n    因为 3 + 8 = 11，且 1 + 1 = 2。由于 2 只有一位数字，所以结果是 2。", "fr": "Étant donné un entier non négatif num, additionnez de manière répétée tous ses chiffres jusqu'à ce que le résultat n'ait qu'un seul chiffre.\nPar exemple :\n    >>> addDigits(38)\n    2\n    Parce que 3 + 8 = 11, et 1 + 1 = 2. Comme 2 n'a qu'un seul chiffre, 2 est le résultat.", "de": "Einen nicht-negativen Integer num gegeben, addiere wiederholt alle seine Ziffern, bis das Ergebnis nur noch eine Ziffer hat.\nZum Beispiel:\n    >>> addDigits(38)\n    2\n    Weil 3 + 8 = 11, und 1 + 1 = 2. Da 2 nur eine Ziffer hat, ist 2 das Ergebnis.", "ha": "An ba da wani lamba mara tabbatacce num, a ci gaba da ƙara duk lambobinsa har sai sakamakon yana da lamba ɗaya kawai. \n\nMisali:\n    >>> addDigits(38)\n    2\n    Domin 3 + 8 = 11, kuma 1 + 1 = 2. Tun da 2 yana da lamba ɗaya kawai, 2 shine sakamakon.", "hi": "गैर-ऋणात्मक पूर्णांक num को दिया गया है, इसके सभी अंकों को बार-बार जोड़ें जब तक कि परिणाम में केवल एक अंक न रह जाए।\nउदाहरण के लिए:\n    >>> addDigits(38)\n    2\n    क्योंकि 3 + 8 = 11, और 1 + 1 = 2। चूंकि 2 में केवल एक अंक है, 2 परिणाम है।", "hu": "Adott egy nemnegatív egész szám, num, ismételten add össze az összes számjegyét, amíg az eredménynek csak egy számjegye lesz.  \nPéldául:  \n    >>> addDigits(38)  \n    2  \n    Mert 3 + 8 = 11, és 1 + 1 = 2. Mivel a 2-nek csak egy számjegye van, 2 az eredmény.", "es": "Dado un número entero no negativo num, suma repetidamente todos sus dígitos hasta que el resultado tenga solo un dígito.\nPor ejemplo:\n    >>> addDigits(38)\n    2\n    Porque 3 + 8 = 11, y 1 + 1 = 2. Dado que 2 tiene solo un dígito, 2 es el resultado.", "arb": "إعطاء عدد صحيح غير سالب num، قم بإضافة جميع أرقامه بشكل متكرر حتى يكون الناتج رقماً واحداً فقط.\nعلى سبيل المثال:\n    >>> addDigits(38)\n    2\n    لأن 3 + 8 = 11، و 1 + 1 = 2. بما أن 2 هو رقم واحد فقط، فإن 2 هو الناتج.", "sw": "Ukipiwa nambari isiyo hasi num, ongeza mara kwa mara tarakimu zake zote hadi matokeo yawe na tarakimu moja tu. Kwa mfano:\n    >>> addDigits(38)\n    2\n    Kwa sababu 3 + 8 = 11, na 1 + 1 = 2. Kwa kuwa 2 ina tarakimu moja tu, 2 ndiyo matokeo.", "tr": "Verilen bir negatif olmayan tam sayı num için, sonucu yalnızca bir basamak kalana kadar tüm basamaklarını tekrar tekrar toplayın.  \nÖrneğin:  \n    >>> addDigits(38)  \n    2  \n    Çünkü 3 + 8 = 11 ve 1 + 1 = 2. 2 yalnızca bir basamak olduğundan, sonuç 2'dir.", "vi": "Cho một số nguyên không âm num, liên tục cộng tất cả các chữ số của nó cho đến khi kết quả chỉ còn một chữ số.  \nVí dụ:  \n    >>> addDigits(38)  \n    2  \n    Bởi vì 3 + 8 = 11, và 1 + 1 = 2. Vì 2 chỉ có một chữ số, 2 là kết quả.", "id": "Diberikan bilangan bulat non-negatif num, tambahkan semua digitnya berulang kali hingga hasilnya hanya memiliki satu digit.\nSebagai contoh:\n    >>> addDigits(38)\n    2\n    Karena 3 + 8 = 11, dan 1 + 1 = 2. Karena 2 hanya memiliki satu digit, 2 adalah hasilnya.", "ja": "非負整数 num が与えられたとき、その桁をすべて繰り返し加算して、結果が一桁になるまで続けます。\n\n例:\n    >>> addDigits(38)\n    2\n    なぜなら 3 + 8 = 11 であり、1 + 1 = 2 だからです。2 は一桁なので、結果は 2 です。", "ko": "주어진 비음수 정수 num에 대해, 그 숫자의 모든 자릿수를 반복적으로 더하여 결과가 한 자리 숫자가 될 때까지 계속합니다.\n예를 들어:\n    >>> addDigits(38)\n    2\n    왜냐하면 3 + 8 = 11이고, 1 + 1 = 2이기 때문입니다. 2는 한 자리 숫자이므로, 2가 결과입니다.", "ml": "നൽകിയിരിക്കുന്ന ഒരു നെഗറ്റീവ് അല്ലാത്ത പൂർണ്ണസംഖ്യ num ന്റെ എല്ലാ അക്കങ്ങളും ആവർത്തിച്ച് കൂട്ടുക, ഫലത്തിൽ ഒരു അക്കം മാത്രമുള്ളതുവരെ.\n\nഉദാഹരണത്തിന്:\n    >>> addDigits(38)\n    2\n    കാരണം 3 + 8 = 11, കൂടാതെ 1 + 1 = 2. 2 ന് ഒരു അക്കം മാത്രമേയുള്ളൂ, അതിനാൽ ഫലം 2 ആണ്.", "fa": "با توجه به یک عدد صحیح غیرمنفی num، به طور مکرر تمام ارقام آن را اضافه کنید تا زمانی که نتیجه تنها یک رقم داشته باشد.\nبرای مثال:\n    >>> addDigits(38)\n    2\n    زیرا 3 + 8 = 11، و 1 + 1 = 2. از آنجا که 2 تنها یک رقم دارد، 2 نتیجه است."}}
{"task_id": "C/49", "prompt": {"en": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nYou are playing a game called Nim. In this game, you start with a pile of n stones, and you and your opponent take turns to remove 1 to 3 stones from the pile. The one who removes the last stone wins the game. Given the number of stones n, determine if you can win the game if both you and your opponent play optimally.\nNote: You always take the first turn.\n\nHere are some cases:\n    >>> canWinNim(1)\n    true\n*/\nbool canWinNim(int n);", "sq": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nJu po luani një lojë të quajtur Nim. Në këtë lojë, ju filloni me një grumbull prej n gurësh, dhe ju dhe kundërshtari juaj merrni me radhë për të hequr 1 deri në 3 gurë nga grumbulli. Ai që heq gurin e fundit fiton lojën. Duke pasur parasysh numrin e gurëve n, përcaktoni nëse mund të fitoni lojën nëse si ju ashtu edhe kundërshtari juaj luani në mënyrë optimale.\nShënim: Ju gjithmonë luani të parët.\n\nKëtu janë disa raste:\n    >>> canWinNim(1)\n    true\n*/\nbool canWinNim(int n);", "hy": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nԴուք խաղում եք Nim կոչվող խաղը։ Այս խաղում դուք սկսում եք n քարերով կույտից, և դուք և ձեր մրցակիցը հերթով հեռացնում եք 1-ից 3 քար կույտից։ Նա, ով հեռացնում է վերջին քարը, հաղթում է խաղը։ Տրված է քարերի քանակը n, որոշեք՝ արդյոք դուք կարող եք հաղթել խաղը, եթե դուք և ձեր մրցակիցը խաղում եք օպտիմալ կերպով։\nՆշում. Դուք միշտ առաջինն եք խաղում։\n\nԱհա որոշ դեպքեր.\n    >>> canWinNim(1)\n    true\n*/\nbool canWinNim(int n);", "bn": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nতুমি একটি গেম খেলছো যার নাম নিম। এই গেমে, তুমি n পাথর দিয়ে শুরু করো, এবং তুমি ও তোমার প্রতিদ্বন্দ্বী পালাক্রমে ১ থেকে ৩টি পাথর সরাতে পারো। যে শেষ পাথরটি সরাবে সে গেমটি জিতবে। পাথরের সংখ্যা n দেওয়া আছে, যদি তুমি ও তোমার প্রতিদ্বন্দ্বী উভয়ই সর্বোত্তমভাবে খেলে তবে তুমি গেমটি জিততে পারবে কিনা তা নির্ধারণ করো।\nনোট: তুমি সর্বদা প্রথম পালা নাও।\n\nকিছু উদাহরণ:\n    >>> canWinNim(1)\n    true\n*/\nbool canWinNim(int n);", "bg": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nВие играете игра, наречена Nim. В тази игра започвате с купчина от n камъка, и вие и вашият противник се редувате да премахвате от 1 до 3 камъка от купчината. Този, който премахне последния камък, печели играта. Даден е броят на камъните n, определете дали можете да спечелите играта, ако и вие, и вашият противник играете оптимално.\nЗабележка: Винаги вие правите първия ход.\n\nЕто някои случаи:\n    >>> canWinNim(1)\n    true\n*/\nbool canWinNim(int n);", "zh": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\n你正在玩一个叫做 Nim 的游戏。在这个游戏中，你从一堆 n 个石头开始，你和你的对手轮流从堆中移除 1 到 3 个石头。移除最后一个石头的人赢得游戏。给定石头的数量 n，判断如果你和你的对手都采取最优策略，你是否可以赢得游戏。\n注意：你总是先手。\n\n以下是一些情况：\n    >>> canWinNim(1)\n    true\n*/\nbool canWinNim(int n);", "fr": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nVous jouez à un jeu appelé Nim. Dans ce jeu, vous commencez avec un tas de n pierres, et vous et votre adversaire prenez à tour de rôle entre 1 et 3 pierres du tas. Celui qui enlève la dernière pierre gagne la partie. Étant donné le nombre de pierres n, déterminez si vous pouvez gagner la partie si vous et votre adversaire jouez de manière optimale.\nRemarque : Vous prenez toujours le premier tour.\n\nVoici quelques cas :\n    >>> canWinNim(1)\n    true\n*/\nbool canWinNim(int n);", "de": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nDu spielst ein Spiel namens Nim. In diesem Spiel beginnst du mit einem Haufen von n Steinen, und du und dein Gegner wechseln euch ab, um 1 bis 3 Steine aus dem Haufen zu entfernen. Derjenige, der den letzten Stein entfernt, gewinnt das Spiel. Angesichts der Anzahl der Steine n, bestimme, ob du das Spiel gewinnen kannst, wenn sowohl du als auch dein Gegner optimal spielen.\nHinweis: Du bist immer der Erste, der an der Reihe ist.\n\nHier sind einige Fälle:\n    >>> canWinNim(1)\n    true\n*/\nbool canWinNim(int n);", "ha": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nKana kunna wani wasa da ake kira Nim. A cikin wannan wasa, ka fara da tarin duwatsu n, kai da abokin hamayyarka kuna juyawa don cire duwatsu 1 zuwa 3 daga tarin. Wanda ya cire dutse na karshe shi ne ya ci wasan. An ba da adadin duwatsu n, tabbatar idan za ka iya cin nasara idan kai da abokin hamayyarka kuna wasa da hikima.\nLura: Kai ne kake fara wasa.\n\nGa wasu lokuta:\n    >>> canWinNim(1)\n    true\n*/\nbool canWinNim(int n);", "hi": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nआप एक खेल खेल रहे हैं जिसे निम कहा जाता है। इस खेल में, आप n पत्थरों के ढेर से शुरू करते हैं, और आप और आपका प्रतिद्वंद्वी बारी-बारी से ढेर से 1 से 3 पत्थर हटाते हैं। जो अंतिम पत्थर हटाता है वह खेल जीतता है। दिए गए पत्थरों की संख्या n के आधार पर, यह निर्धारित करें कि क्या आप खेल जीत सकते हैं यदि आप और आपका प्रतिद्वंद्वी दोनों ही सर्वोत्तम तरीके से खेलते हैं।\nनोट: आप हमेशा पहली बारी लेते हैं।\n\nयहाँ कुछ उदाहरण हैं:\n    >>> canWinNim(1)\n    true\n*/\nbool canWinNim(int n);", "hu": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nEgy Nim nevű játékot játszol. Ebben a játékban egy halom n kővel kezdesz, és te és az ellenfeled felváltva távolítotok el 1-3 követ a halomból. Az nyer, aki az utolsó követ eltávolítja. Adott a kövek száma n, határozd meg, hogy megnyerheted-e a játékot, ha mind te, mind az ellenfeled optimálisan játszik.\nMegjegyzés: Mindig te kezded az első lépést.\n\nÍme néhány eset:\n    >>> canWinNim(1)\n    true\n*/\nbool canWinNim(int n);", "es": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nEstás jugando un juego llamado Nim. En este juego, comienzas con una pila de n piedras, y tú y tu oponente se turnan para quitar de 1 a 3 piedras de la pila. Quien quite la última piedra gana el juego. Dado el número de piedras n, determina si puedes ganar el juego si tanto tú como tu oponente juegan de manera óptima.\nNota: Siempre tomas el primer turno.\n\nAquí hay algunos casos:\n    >>> canWinNim(1)\n    true\n*/\nbool canWinNim(int n);", "arb": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nأنت تلعب لعبة تسمى نيم. في هذه اللعبة، تبدأ بكومة من n من الحجارة، وأنت وخصمك تتناوبان على إزالة 1 إلى 3 حجارة من الكومة. الشخص الذي يزيل الحجر الأخير يفوز باللعبة. بالنظر إلى عدد الحجارة n، حدد ما إذا كان بإمكانك الفوز باللعبة إذا لعبت أنت وخصمك بشكل مثالي.\nملاحظة: أنت دائمًا تأخذ الدور الأول.\n\nإليك بعض الحالات:\n    >>> canWinNim(1)\n    true\n*/\nbool canWinNim(int n);", "sw": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nUnacheza mchezo unaoitwa Nim. Katika mchezo huu, unaanza na rundo la mawe n, na wewe na mpinzani wako mnapokezana kuondoa mawe 1 hadi 3 kutoka kwenye rundo. Yule anayeondoa jiwe la mwisho anashinda mchezo. Ukipewa idadi ya mawe n, amua kama unaweza kushinda mchezo ikiwa wewe na mpinzani wako mnaweza kucheza kwa ustadi.\nKumbuka: Daima unachukua zamu ya kwanza.\n\nHapa kuna baadhi ya kesi:\n    >>> canWinNim(1)\n    true\n*/\nbool canWinNim(int n);", "tr": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nNim adında bir oyun oynuyorsunuz. Bu oyunda, n taşlık bir yığınla başlarsınız ve siz ve rakibiniz sırayla yığından 1 ila 3 taş çıkarırsınız. Son taşı çıkaran oyunu kazanır. Taş sayısı n verildiğinde, hem siz hem de rakibiniz optimal oynarsa oyunu kazanıp kazanamayacağınızı belirleyin.\nNot: Her zaman ilk hamleyi siz yaparsınız.\n\nİşte bazı durumlar:\n    >>> canWinNim(1)\n    true\n*/\nbool canWinNim(int n);", "vi": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nBạn đang chơi một trò chơi gọi là Nim. Trong trò chơi này, bạn bắt đầu với một đống n viên đá, và bạn cùng đối thủ lần lượt lấy từ 1 đến 3 viên đá ra khỏi đống. Người lấy viên đá cuối cùng sẽ thắng trò chơi. Cho số viên đá n, xác định xem bạn có thể thắng trò chơi nếu cả bạn và đối thủ đều chơi tối ưu hay không.\nLưu ý: Bạn luôn là người đi trước.\n\nDưới đây là một số trường hợp:\n    >>> canWinNim(1)\n    true\n*/\nbool canWinNim(int n);", "id": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nAnda sedang bermain permainan bernama Nim. Dalam permainan ini, Anda mulai dengan sebuah tumpukan batu berjumlah n, dan Anda serta lawan Anda bergiliran untuk mengambil 1 hingga 3 batu dari tumpukan. Orang yang mengambil batu terakhir memenangkan permainan. Diberikan jumlah batu n, tentukan apakah Anda bisa memenangkan permainan jika Anda dan lawan Anda bermain secara optimal.\nCatatan: Anda selalu mengambil giliran pertama.\n\nBerikut adalah beberapa kasus:\n    >>> canWinNim(1)\n    true\n*/\nbool canWinNim(int n);", "ja": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nあなたはニムというゲームをプレイしています。このゲームでは、n個の石の山から始め、あなたと対戦相手が交互に1から3個の石を山から取り除きます。最後の石を取り除いた人がゲームに勝ちます。石の数nが与えられたとき、あなたと対戦相手が最適にプレイした場合にゲームに勝てるかどうかを判断してください。\n注意: あなたは常に最初のターンを取ります。\n\nいくつかのケースを示します:\n    >>> canWinNim(1)\n    true\n*/\nbool canWinNim(int n);", "ko": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\n당신은 Nim이라는 게임을 하고 있습니다. 이 게임에서, 당신은 n개의 돌무더기로 시작하고, 당신과 상대방은 번갈아 가며 돌무더기에서 1개에서 3개의 돌을 제거합니다. 마지막 돌을 제거하는 사람이 게임에서 승리합니다. 돌의 수 n이 주어졌을 때, 당신과 상대방이 최적으로 플레이할 경우 당신이 게임에서 승리할 수 있는지를 결정하세요.\n참고: 당신이 항상 첫 번째 턴을 가집니다.\n\n다음은 몇 가지 사례입니다:\n    >>> canWinNim(1)\n    true\n*/\nbool canWinNim(int n);", "ml": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nനിങ്ങൾ നിം എന്നൊരു ഗെയിം കളിക്കുകയാണ്. ഈ ഗെയിമിൽ, നിങ്ങൾ n കല്ലുകളുള്ള ഒരു കൂമ്പാരം കൊണ്ട് തുടങ്ങുന്നു, നിങ്ങൾക്കും നിങ്ങളുടെ എതിരാളിക്കും കൂമ്പാരത്തിൽ നിന്ന് 1 മുതൽ 3 വരെ കല്ലുകൾ നീക്കം ചെയ്യാൻ കഴിയുന്നു. അവസാനത്തെ കല്ല് നീക്കം ചെയ്യുന്നവൻ ഗെയിം ജയിക്കും. കല്ലുകളുടെ എണ്ണം n നൽകിയാൽ, നിങ്ങൾക്കും നിങ്ങളുടെ എതിരാളിക്കും മികച്ച രീതിയിൽ കളിക്കുമ്പോൾ നിങ്ങൾക്ക് ഗെയിം ജയിക്കാനാകുമോ എന്ന് നിർണ്ണയിക്കുക.\nശ്രദ്ധിക്കുക: നിങ്ങൾ എപ്പോഴും ആദ്യമായി കളിക്കും.\n\nഇവിടെ ചില കേസുകൾ ഉണ്ട്:\n    >>> canWinNim(1)\n    true\n*/\nbool canWinNim(int n);", "fa": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nشما در حال بازی به نام نیم هستید. در این بازی، شما با یک توده از n سنگ شروع می‌کنید و شما و حریف‌تان به نوبت 1 تا 3 سنگ از توده برمی‌دارید. کسی که آخرین سنگ را برمی‌دارد، برنده بازی است. با توجه به تعداد سنگ‌ها n، تعیین کنید که آیا می‌توانید برنده بازی شوید اگر هر دو شما و حریف‌تان بهینه بازی کنید.\nتوجه: شما همیشه اولین نوبت را دارید.\n\nدر اینجا برخی از موارد وجود دارد:\n    >>> canWinNim(1)\n    true\n*/\nbool canWinNim(int n);"}, "canonical_solution": "bool canWinNim(int n) {\n    return n % 4 != 0;\n}", "instruction": {"en": "bool canWinNim(int n)\nbool canWinNim(int n) {\n    return n % 4 != 0;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "sq": "bool canWinNim(int n)\nbool canWinNim(int n) {\n    return n % 4 != 0;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C në shqip duke përdorur maksimumi 500 karaktere.", "hy": "bool canWinNim(int n)\nbool canWinNim(int n) {\n    return n % 4 != 0;\n}\n\nՏվեք C կոդի հակիրճ բնութագրումը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "bool canWinNim(int n)\nbool canWinNim(int n) {\n    return n % 4 != 0;\n}\n\nসি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।", "bg": "bool canWinNim(int n)\nbool canWinNim(int n) {\n    return n % 4 != 0;\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, като използвате не повече от 500 знака.", "zh": "bool canWinNim(int n)\nbool canWinNim(int n) {\n    return n % 4 != 0;\n}\n\n请用最多500个字符的中文对该C代码提供简洁的自然语言描述（文档字符串）。", "fr": "bool canWinNim(int n)\nbool canWinNim(int n) {\n    return n % 4 != 0;\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.", "de": "bool canWinNim(int n)\nbool canWinNim(int n) {\n    return n % 4 != 0;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "bool canWinNim(int n)\nbool canWinNim(int n) {\n    return n % 4 != 0;\n}\n\nBa da takaitaccen bayani a cikin yare na halitta (docstring) na lambar C cikin Hausa ta amfani da haruffa 500 kacal.", "hi": "bool canWinNim(int n)\nbool canWinNim(int n) {\n    return n % 4 != 0;\n}\n\nC कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।", "hu": "bool canWinNim(int n)\nbool canWinNim(int n) {\n    return n % 4 != 0;\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben.", "es": "bool canWinNim(int n)\nbool canWinNim(int n) {\n    return n % 4 != 0;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando como máximo 500 caracteres.", "arb": "bool canWinNim(int n)\nbool canWinNim(int n) {\n    return n % 4 != 0;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "bool canWinNim(int n)\nbool canWinNim(int n) {\n    return n % 4 != 0;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "bool canWinNim(int n)\nbool canWinNim(int n) {\n    return n % 4 != 0;\n}\n\nC kodunun işlevselliğini açıklayan kısa bir doğal dil tanımı (docstring) sağlayın. Açıklama 500 karakteri geçmemelidir.", "vi": "bool canWinNim(int n)\nbool canWinNim(int n) {\n    return n % 4 != 0;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã C bằng tiếng Việt, sử dụng tối đa 500 ký tự.", "id": "bool canWinNim(int n)\nbool canWinNim(int n) {\n    return n % 4 != 0;\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode C dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "bool canWinNim(int n)\nbool canWinNim(int n) {\n    return n % 4 != 0;\n}\n\nCコードの内容を簡潔に説明する自然言語の記述（ドックストリング）を日本語で500文字以内で提供してください。", "ko": "bool canWinNim(int n)\nbool canWinNim(int n) {\n    return n % 4 != 0;\n}\n\nC 코드에 대한 간결한 자연어 설명(docstring)을 한국어로 500자 이내로 제공하세요.", "ml": "bool canWinNim(int n)\nbool canWinNim(int n) {\n    return n % 4 != 0;\n}\n\nസീ കോഡിന് 500 അക്ഷരങ്ങളിൽ കവിയാതെയുള്ള ഒരു സംക്ഷിപ്ത സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) മലയാളത്തിൽ നൽകുക.", "fa": "bool canWinNim(int n)\nbool canWinNim(int n) {\n    return n % 4 != 0;\n}\n\nتوضیح مختصر و طبیعی (docstring) از کد C به زبان فارسی ارائه دهید که حداکثر ۵۰۰ کاراکتر باشد."}, "level": "", "test": "int main() {\n    assert(canWinNim(1) == true);\n    assert(canWinNim(2) == true);\n    assert(canWinNim(3) == true);\n    assert(canWinNim(4) == false);\n    assert(canWinNim(5) == true);\n    assert(canWinNim(6) == true);\n    assert(canWinNim(7) == true);\n    assert(canWinNim(8) == false);\n    assert(canWinNim(9) == true);\n    assert(canWinNim(10) == true);\n    assert(canWinNim(11) == true);\n    assert(canWinNim(12) == false);\n    assert(canWinNim(13) == true);\n    assert(canWinNim(14) == true);\n    assert(canWinNim(15) == true);\n    assert(canWinNim(16) == false);\n    assert(canWinNim(17) == true);\n    assert(canWinNim(18) == true);\n    assert(canWinNim(19) == true);\n    assert(canWinNim(20) == false);\n    return 0;\n}", "entry_point": "canWinNim", "signature": "bool canWinNim(int n)", "docstring": {"en": "You are playing a game called Nim. In this game, you start with a pile of n stones, and you and your opponent take turns to remove 1 to 3 stones from the pile. The one who removes the last stone wins the game. Given the number of stones n, determine if you can win the game if both you and your opponent play optimally.\nNote: You always take the first turn.\n\nHere are some cases:\n    >>> canWinNim(1)\n    true\n", "sq": "Ju po luani një lojë të quajtur Nim. Në këtë lojë, ju filloni me një grumbull prej n gurësh, dhe ju dhe kundërshtari juaj merrni me radhë për të hequr 1 deri në 3 gurë nga grumbulli. Ai që heq gurin e fundit fiton lojën. Duke pasur parasysh numrin e gurëve n, përcaktoni nëse mund të fitoni lojën nëse si ju ashtu edhe kundërshtari juaj luani në mënyrë optimale.\nShënim: Ju gjithmonë merrni kthesën e parë.\n\nKëtu janë disa raste:\n    >>> canWinNim(1)\n    true", "hy": "Դուք խաղում եք Nim կոչվող խաղը։ Այս խաղում դուք սկսում եք n քարերով կույտից, և դուք ու ձեր հակառակորդը հերթով հանում եք 1-ից 3 քար կույտից։ Նա, ով կհանի վերջին քարը, հաղթում է խաղը։ Տրված է քարերի քանակը՝ n, որոշեք՝ արդյոք դուք կարող եք հաղթել խաղը, եթե դուք և ձեր հակառակորդը խաղում եք օպտիմալ կերպով։\nՆշում: Դուք միշտ առաջինն եք խաղում։\n\nԱհա որոշ դեպքեր.\n    >>> canWinNim(1)\n    true", "bn": "আপনি একটি গেম খেলছেন যার নাম নিম। এই গেমে, আপনি n সংখ্যক পাথর দিয়ে শুরু করেন, এবং আপনি এবং আপনার প্রতিপক্ষ পালাক্রমে ১ থেকে ৩টি পাথর স্তূপ থেকে সরিয়ে নেন। যে ব্যক্তি শেষ পাথরটি সরায় সে গেমটি জেতে। প্রদত্ত পাথরের সংখ্যা n, নির্ধারণ করুন আপনি গেমটি জিততে পারবেন কিনা যদি আপনি এবং আপনার প্রতিপক্ষ উভয়ই সর্বোত্তমভাবে খেলেন।\nদ্রষ্টব্য: আপনি সর্বদা প্রথম পালা নেন।\n\nকিছু উদাহরণ এখানে দেওয়া হল:\n    >>> canWinNim(1)\n    true", "bg": "Играете игра, наречена Nim. В тази игра започвате с купчина от n камъка и вие и вашият противник се редувате да премахвате от 1 до 3 камъка от купчината. Този, който премахне последния камък, печели играта. Като се има предвид броят на камъните n, определете дали можете да спечелите играта, ако и вие, и вашият противник играете оптимално. \nЗабележка: Винаги вие правите първия ход.\n\nЕто някои случаи:\n    >>> canWinNim(1)\n    true", "zh": "你正在玩一个叫做 Nim 的游戏。在这个游戏中，你从一堆 n 个石头开始，你和你的对手轮流从堆中移除 1 到 3 个石头。移除最后一个石头的人赢得游戏。给定石头的数量 n，判断如果你和你的对手都以最佳方式进行游戏，你是否能赢得比赛。\n注意：你总是先手。\n\n以下是一些情况：\n    >>> canWinNim(1)\n    true", "fr": "Vous jouez à un jeu appelé Nim. Dans ce jeu, vous commencez avec un tas de n pierres, et vous et votre adversaire prenez à tour de rôle de 1 à 3 pierres du tas. Celui qui enlève la dernière pierre gagne la partie. Étant donné le nombre de pierres n, déterminez si vous pouvez gagner la partie si vous et votre adversaire jouez de manière optimale.  \nRemarque : Vous jouez toujours en premier.\n\nVoici quelques cas :\n    >>> canWinNim(1)\n    true", "de": "Du spielst ein Spiel namens Nim. In diesem Spiel beginnst du mit einem Haufen von n Steinen, und du und dein Gegner wechseln euch ab, um 1 bis 3 Steine aus dem Haufen zu entfernen. Derjenige, der den letzten Stein entfernt, gewinnt das Spiel. Angesichts der Anzahl der Steine n, bestimme, ob du das Spiel gewinnen kannst, wenn sowohl du als auch dein Gegner optimal spielen.\nHinweis: Du bist immer der Erste, der an der Reihe ist.\n\nHier sind einige Fälle:\n    >>> canWinNim(1)\n    true", "ha": "Kana wasa mai suna Nim. A cikin wannan wasa, ka fara da tarin duwatsu n, kai da abokin hamayyarka kuna juyawa don cire 1 zuwa 3 duwatsu daga tarin. Wanda ya cire dutse na ƙarshe shi ne zai ci wasan. An ba da adadin duwatsu n, tantance idan za ka iya cin wasan idan kai da abokin hamayyarka kuna wasa da hikima.\nLura: Kai ne kullum ke fara wasa.\n\nGa wasu lokuta:\n    >>> canWinNim(1)\n    true", "hi": "आप एक खेल खेल रहे हैं जिसे निम कहा जाता है। इस खेल में, आप n पत्थरों के ढेर से शुरू करते हैं, और आप और आपका प्रतिद्वंद्वी बारी-बारी से ढेर से 1 से 3 पत्थर हटाते हैं। जो अंतिम पत्थर हटाता है वह खेल जीतता है। दिए गए पत्थरों की संख्या n के आधार पर, यह निर्धारित करें कि क्या आप खेल जीत सकते हैं यदि आप और आपका प्रतिद्वंद्वी दोनों इष्टतम रूप से खेलते हैं। \nध्यान दें: आप हमेशा पहली बारी लेते हैं।\n\nयहाँ कुछ मामले हैं:\n    >>> canWinNim(1)\n    true", "hu": "Egy Nim nevű játékot játszol. Ebben a játékban egy halom n kővel kezdesz, és te valamint az ellenfeled felváltva távolítotok el 1-től 3-ig terjedő számú követ a halomból. Az nyer, aki az utolsó követ eltávolítja. Adott a kövek száma n, határozd meg, hogy meg tudod-e nyerni a játékot, ha mind te, mind az ellenfeled optimálisan játszik. Megjegyzés: Mindig te kezded az első lépést.\n\nÍme néhány eset:\n    >>> canWinNim(1)\n    true", "es": "Estás jugando un juego llamado Nim. En este juego, comienzas con un montón de n piedras, y tú y tu oponente se turnan para quitar de 1 a 3 piedras del montón. El que quite la última piedra gana el juego. Dado el número de piedras n, determina si puedes ganar el juego si tanto tú como tu oponente juegan de manera óptima.  \nNota: Siempre tomas el primer turno.\n\nAquí hay algunos casos:\n    >>> canWinNim(1)\n    true", "arb": "أنت تلعب لعبة تسمى نيم. في هذه اللعبة، تبدأ بكومة من n من الحجارة، وأنت وخصمك تتناوبان على إزالة 1 إلى 3 حجارة من الكومة. الشخص الذي يزيل الحجر الأخير يفوز باللعبة. بالنظر إلى عدد الحجارة n، حدد ما إذا كان بإمكانك الفوز باللعبة إذا لعبت أنت وخصمك بشكل مثالي. \nملاحظة: أنت دائمًا تأخذ الدور الأول.\n\nإليك بعض الحالات:\n    >>> canWinNim(1)\n    true", "sw": "Unacheza mchezo unaoitwa Nim. Katika mchezo huu, unaanza na rundo la mawe n, na wewe na mpinzani wako mnachukua zamu kuondoa mawe 1 hadi 3 kutoka kwenye rundo. Yule anayeondoa jiwe la mwisho anashinda mchezo. Ukipewa idadi ya mawe n, amua kama unaweza kushinda mchezo ikiwa wewe na mpinzani wako mna cheza kwa ustadi.\nKumbuka: Daima unachukua zamu ya kwanza.\n\nHapa kuna baadhi ya kesi:\n    >>> canWinNim(1)\n    true", "tr": "Nim adlı bir oyun oynuyorsunuz. Bu oyunda, n taşlık bir yığınla başlarsınız ve siz ve rakibiniz sırayla yığından 1 ila 3 taş çıkarırsınız. Son taşı çıkaran oyunu kazanır. Taş sayısı n verildiğinde, hem siz hem de rakibiniz en iyi şekilde oynarsa oyunu kazanıp kazanamayacağınızı belirleyin. \nNot: Her zaman ilk hamleyi siz yaparsınız.\n\nİşte bazı durumlar:\n    >>> canWinNim(1)\n    true", "vi": "Bạn đang chơi một trò chơi có tên là Nim. Trong trò chơi này, bạn bắt đầu với một đống gồm n viên đá, và bạn cùng đối thủ lần lượt lấy đi từ 1 đến 3 viên đá từ đống đó. Người nào lấy viên đá cuối cùng sẽ thắng trò chơi. Cho số lượng viên đá n, xác định xem bạn có thể thắng trò chơi hay không nếu cả bạn và đối thủ đều chơi tối ưu.\nLưu ý: Bạn luôn đi trước.\n\nDưới đây là một số trường hợp:\n    >>> canWinNim(1)\n    true", "id": "Anda sedang bermain permainan bernama Nim. Dalam permainan ini, Anda memulai dengan tumpukan n batu, dan Anda serta lawan Anda bergantian untuk mengambil 1 hingga 3 batu dari tumpukan. Orang yang mengambil batu terakhir memenangkan permainan. Diberikan jumlah batu n, tentukan apakah Anda bisa memenangkan permainan jika Anda dan lawan Anda bermain secara optimal. \nCatatan: Anda selalu mengambil giliran pertama.\n\nBerikut adalah beberapa kasus:\n    >>> canWinNim(1)\n    true", "ja": "あなたはNimというゲームをプレイしています。このゲームでは、n個の石の山から始め、あなたと対戦相手が交互に1から3個の石を山から取り除きます。最後の石を取り除いた人がゲームに勝ちます。石の数nが与えられたとき、あなたと対戦相手が最適にプレイした場合に、あなたがゲームに勝てるかどうかを判断します。\n注意: あなたは常に最初のターンを取ります。\n\nいくつかのケースを示します:\n    >>> canWinNim(1)\n    true", "ko": "당신은 Nim이라는 게임을 하고 있습니다. 이 게임에서, 당신은 n개의 돌무더기로 시작하고, 당신과 상대방은 번갈아 가며 돌무더기에서 1개에서 3개의 돌을 제거합니다. 마지막 돌을 제거하는 사람이 게임에서 승리합니다. 돌의 수 n이 주어졌을 때, 당신과 상대방이 최적으로 플레이할 경우 당신이 게임에서 이길 수 있는지 결정하십시오.\n참고: 당신은 항상 첫 번째 턴을 가집니다.\n\n다음은 몇 가지 경우입니다:\n    >>> canWinNim(1)\n    true", "ml": "നിങ്ങൾ നിം എന്നൊരു ഗെയിം കളിക്കുന്നു. ഈ ഗെയിമിൽ, നിങ്ങൾ n കല്ലുകൾ ഉള്ള ഒരു കൂമ്പാരം കൊണ്ട് ആരംഭിക്കുന്നു, നിങ്ങൾക്കും നിങ്ങളുടെ എതിരാളിക്കും കൂമ്പാരത്തിൽ നിന്ന് 1 മുതൽ 3 വരെ കല്ലുകൾ നീക്കം ചെയ്യാനുള്ള അവസരം ലഭിക്കുന്നു. അവസാന കല്ല് നീക്കം ചെയ്യുന്നവൻ ഗെയിം ജയിക്കും. കല്ലുകളുടെ എണ്ണം n നൽകിയാൽ, നിങ്ങൾക്കും നിങ്ങളുടെ എതിരാളിക്കും മികച്ച രീതിയിൽ കളിച്ചാൽ നിങ്ങൾക്ക് ഗെയിം ജയിക്കാനാകുമോ എന്ന് നിർണ്ണയിക്കുക. കുറിപ്പ്: നിങ്ങൾ എപ്പോഴും ആദ്യമായി കളിക്കും.\n\nഇവിടെ ചില കേസുകൾ ഉണ്ട്:\n    >>> canWinNim(1)\n    true", "fa": "شما در حال بازی به نام Nim هستید. در این بازی، شما با یک توده n سنگ شروع می‌کنید و شما و حریف‌تان به نوبت 1 تا 3 سنگ از توده برمی‌دارید. کسی که آخرین سنگ را بردارد، بازی را می‌برد. با توجه به تعداد سنگ‌ها n، تعیین کنید که آیا می‌توانید بازی را ببرید اگر هم شما و هم حریف‌تان بهینه بازی کنید.\nتوجه: شما همیشه نوبت اول را دارید.\n\nدر اینجا چند مورد وجود دارد:\n    >>> canWinNim(1)\n    true"}}
{"task_id": "C/50", "prompt": {"en": "#include <assert.h>\n#include <stdio.h>\n/*\nGiven two integers a and b, return the sum if the sum is even, or return the product of a and b if the sum is odd.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10\n*/\nint evenSumOrOddProduct(int a, int b);", "sq": "#include <assert.h>\n#include <stdio.h>\n/*\nDuke pasur dy numra të plotë a dhe b, kthejeni shumën nëse shuma është çift, ose kthejeni prodhimin e a dhe b nëse shuma është tek.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10\n*/\nint evenSumOrOddProduct(int a, int b);", "hy": "#include <assert.h>\n#include <stdio.h>\n/*\nՏրված է երկու ամբողջ թիվ a և b, վերադարձնել գումարը, եթե գումարը զույգ է, կամ վերադարձնել a և b արտադրյալը, եթե գումարը կենտ է։\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10\n*/\nint evenSumOrOddProduct(int a, int b);", "bn": "#include <assert.h>\n#include <stdio.h>\n/*\nদুটি পূর্ণসংখ্যা a এবং b দেওয়া হলে, যোগফলটি জোড় হলে যোগফল ফেরত দিন, অথবা যদি যোগফলটি বিজোড় হয় তবে a এবং b এর গুণফল ফেরত দিন।\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10\n*/\nint evenSumOrOddProduct(int a, int b);", "bg": "#include <assert.h>\n#include <stdio.h>\n/*\nДадени са две цели числа a и b, върнете сумата, ако сумата е четна, или върнете произведението на a и b, ако сумата е нечетна.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10\n*/\nint evenSumOrOddProduct(int a, int b);", "zh": "#include <assert.h>\n#include <stdio.h>\n/*\n给定两个整数 a 和 b，如果它们的和是偶数则返回和，如果和是奇数则返回 a 和 b 的乘积。\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10\n*/\nint evenSumOrOddProduct(int a, int b);", "fr": "#include <assert.h>\n#include <stdio.h>\n/*\nÉtant donné deux entiers a et b, retourner la somme si la somme est paire, ou retourner le produit de a et b si la somme est impaire.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10\n*/\nint evenSumOrOddProduct(int a, int b);", "de": "#include <assert.h>\n#include <stdio.h>\n/*\nGegeben zwei ganze Zahlen a und b, gib die Summe zurück, wenn die Summe gerade ist, oder gib das Produkt von a und b zurück, wenn die Summe ungerade ist.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10\n*/\nint evenSumOrOddProduct(int a, int b);", "ha": "#include <assert.h>\n#include <stdio.h>\n/*\nAn ba da lambobi guda biyu a da b, a mayar da jumlar idan jumlar ta zama lamba mai mafarin biyu, ko kuma a mayar da samfurin a da b idan jumlar ta zama lamba mai mafarin daya.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10\n*/\nint evenSumOrOddProduct(int a, int b);", "hi": "#include <assert.h>\n#include <stdio.h>\n/*\nदिए गए दो पूर्णांक a और b, यदि योग सम है तो योग लौटाएं, या यदि योग विषम है तो a और b का गुणनफल लौटाएं।\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10\n*/\nint evenSumOrOddProduct(int a, int b);", "hu": "#include <assert.h>\n#include <stdio.h>\n/*\nKét egész szám, a és b esetén térj vissza az összeggel, ha az összeg páros, vagy térj vissza a és b szorzatával, ha az összeg páratlan.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10\n*/\nint evenSumOrOddProduct(int a, int b);", "es": "#include <assert.h>\n#include <stdio.h>\n/*\nDado dos enteros a y b, devuelve la suma si la suma es par, o devuelve el producto de a y b si la suma es impar.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10\n*/\nint evenSumOrOddProduct(int a, int b);", "arb": "#include <assert.h>\n#include <stdio.h>\n/*\nمعطى عددين صحيحين a و b، أعد المجموع إذا كان المجموع زوجياً، أو أعد حاصل ضرب a و b إذا كان المجموع فردياً.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10\n*/\nint evenSumOrOddProduct(int a, int b);", "sw": "#include <assert.h>\n#include <stdio.h>\n/*\nUkipokea nambari mbili nzima a na b, rudisha jumla ikiwa jumla ni shufwa, au rudisha bidhaa ya a na b ikiwa jumla ni witiri.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10\n*/\nint evenSumOrOddProduct(int a, int b);", "tr": "#include <assert.h>\n#include <stdio.h>\n/*\nVerilen iki tamsayı a ve b için, toplam çift ise toplamı döndürün, toplam tek ise a ve b'nin çarpımını döndürün.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10\n*/\nint evenSumOrOddProduct(int a, int b);", "vi": "#include <assert.h>\n#include <stdio.h>\n/*\nCho hai số nguyên a và b, trả về tổng nếu tổng là số chẵn, hoặc trả về tích của a và b nếu tổng là số lẻ.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10\n*/\nint evenSumOrOddProduct(int a, int b);", "id": "#include <assert.h>\n#include <stdio.h>\n/*\nDiberikan dua bilangan bulat a dan b, kembalikan jumlahnya jika jumlahnya genap, atau kembalikan hasil kali dari a dan b jika jumlahnya ganjil.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10\n*/\nint evenSumOrOddProduct(int a, int b);", "ja": "#include <assert.h>\n#include <stdio.h>\n/*\n2つの整数aとbが与えられたとき、合計が偶数であればその合計を返し、合計が奇数であればaとbの積を返します。\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10\n*/\nint evenSumOrOddProduct(int a, int b);", "ko": "#include <assert.h>\n#include <stdio.h>\n/*\n두 정수 a와 b가 주어졌을 때, 합이 짝수이면 합을 반환하고, 합이 홀수이면 a와 b의 곱을 반환합니다.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10\n*/\nint evenSumOrOddProduct(int a, int b);", "ml": "#include <assert.h>\n#include <stdio.h>\n/*\nരണ്ട് പൂർണ്ണസംഖ്യകൾ a, b എന്നിവ നൽകിയാൽ, തുക സമവായിരുന്നാൽ തുക മടക്കിയയയ്ക്കുക, അല്ലെങ്കിൽ തുക ഒറ്റയായാൽ a, b എന്നിവയുടെ ഗുണഫലം മടക്കിയയയ്ക്കുക.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10\n*/\nint evenSumOrOddProduct(int a, int b);", "fa": "#include <assert.h>\n#include <stdio.h>\n/*\nدو عدد صحیح a و b داده شده است، اگر مجموع آنها زوج باشد، مجموع را برگردانید، یا اگر مجموع فرد باشد، حاصل‌ضرب a و b را برگردانید.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10\n*/\nint evenSumOrOddProduct(int a, int b);"}, "canonical_solution": "int evenSumOrOddProduct(int a, int b) {\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}", "instruction": {"en": "int evenSumOrOddProduct(int a, int b)\nint evenSumOrOddProduct(int a, int b) {\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "sq": "int evenSumOrOddProduct(int a, int b)\nint evenSumOrOddProduct(int a, int b) {\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C në shqip duke përdorur maksimumi 500 karaktere.", "hy": "int evenSumOrOddProduct(int a, int b)\nint evenSumOrOddProduct(int a, int b) {\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}\n\nՏրամադրեք C կոդի համառոտ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "int evenSumOrOddProduct(int a, int b)\nint evenSumOrOddProduct(int a, int b) {\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}\n\nনিচের C কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।", "bg": "int evenSumOrOddProduct(int a, int b)\nint evenSumOrOddProduct(int a, int b) {\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}\n\nПредоставете кратко описание на C кода на естествен език на български, използвайки най-много 500 знака.", "zh": "int evenSumOrOddProduct(int a, int b)\nint evenSumOrOddProduct(int a, int b) {\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}\n\n请用最多500个字符的中文对该C代码提供简洁的自然语言描述（文档字符串）。", "fr": "int evenSumOrOddProduct(int a, int b)\nint evenSumOrOddProduct(int a, int b) {\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.", "de": "int evenSumOrOddProduct(int a, int b)\nint evenSumOrOddProduct(int a, int b) {\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen.", "ha": "int evenSumOrOddProduct(int a, int b)\nint evenSumOrOddProduct(int a, int b) {\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar C a cikin Hausa ta amfani da haruffa 500 kawai.", "hi": "int evenSumOrOddProduct(int a, int b)\nint evenSumOrOddProduct(int a, int b) {\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}\n\nनिम्नलिखित C कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "int evenSumOrOddProduct(int a, int b)\nint evenSumOrOddProduct(int a, int b) {\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben.", "es": "int evenSumOrOddProduct(int a, int b)\nint evenSumOrOddProduct(int a, int b) {\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando como máximo 500 caracteres.", "arb": "int evenSumOrOddProduct(int a, int b)\nint evenSumOrOddProduct(int a, int b) {\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}\n\nقم بتوفير وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.", "sw": "int evenSumOrOddProduct(int a, int b)\nint evenSumOrOddProduct(int a, int b) {\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "int evenSumOrOddProduct(int a, int b)\nint evenSumOrOddProduct(int a, int b) {\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}\n\nC kodunun işlevini açıklayan kısa bir doğal dil tanımı (docstring) sağlayın. Açıklama en fazla 500 karakter olmalıdır.", "vi": "int evenSumOrOddProduct(int a, int b)\nint evenSumOrOddProduct(int a, int b) {\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã C bằng tiếng Việt, sử dụng tối đa 500 ký tự.", "id": "int evenSumOrOddProduct(int a, int b)\nint evenSumOrOddProduct(int a, int b) {\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode C dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "int evenSumOrOddProduct(int a, int b)\nint evenSumOrOddProduct(int a, int b) {\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}\n\nCコードの内容を簡潔な自然言語で説明する日本語のドキュメンテーション文字列を、最大500文字で提供してください。", "ko": "int evenSumOrOddProduct(int a, int b)\nint evenSumOrOddProduct(int a, int b) {\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}\n\nC 코드의 동작을 설명하는 간결한 자연어 설명(docstring)을 한국어로 작성하세요. 최대 500자 이내로 작성해야 합니다.", "ml": "int evenSumOrOddProduct(int a, int b)\nint evenSumOrOddProduct(int a, int b) {\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}\n\nസിയി കോഡിന് 500 അക്ഷരങ്ങൾക്കുള്ളിൽ മലയാളത്തിൽ സംക്ഷിപ്തമായ ഒരു സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) നൽകുക.", "fa": "int evenSumOrOddProduct(int a, int b)\nint evenSumOrOddProduct(int a, int b) {\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}\n\nتوضیح مختصر و طبیعی (docstring) از کد C را به زبان فارسی با حداکثر ۵۰۰ کاراکتر ارائه دهید."}, "level": "", "test": "int main() {\n    assert(evenSumOrOddProduct(2, 3) == 6);\n    assert(evenSumOrOddProduct(5, 5) == 10);\n    assert(evenSumOrOddProduct(1, 1) == 2);\n    assert(evenSumOrOddProduct(0, 0) == 0);\n    assert(evenSumOrOddProduct(-1, -1) == -2);\n    assert(evenSumOrOddProduct(100, 200) == 300);\n    assert(evenSumOrOddProduct(3, 4) == 12);\n    assert(evenSumOrOddProduct(-5, 5) == 0);\n    assert(evenSumOrOddProduct(7, 8) == 56);\n    assert(evenSumOrOddProduct(9, 10) == 90);\n    assert(evenSumOrOddProduct(11, 14) == 154);\n    return 0;\n}", "entry_point": "evenSumOrOddProduct", "signature": "int evenSumOrOddProduct(int a, int b)", "docstring": {"en": "Given two integers a and b, return the sum if the sum is even, or return the product of a and b if the sum is odd.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10\n", "sq": "Duke pasur dy numra të plotë a dhe b, kthejeni shumën nëse shuma është çift, ose kthejeni produktin e a dhe b nëse shuma është tek.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10", "hy": "Տրված երկու ամբողջ թիվ a և b, վերադարձնել գումարը, եթե գումարը զույգ է, կամ վերադարձնել a և b արտադրյալը, եթե գումարը կենտ է։", "bn": "দুটি পূর্ণসংখ্যা a এবং b দেওয়া হলে, যদি যোগফলটি জোড় হয় তবে যোগফলটি ফেরত দিন, অথবা যদি যোগফলটি বিজোড় হয় তবে a এবং b এর গুণফল ফেরত দিন।  \n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10", "bg": "Дадени са две цели числа a и b, върнете сумата, ако сумата е четна, или върнете произведението на a и b, ако сумата е нечетна.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10", "zh": "给定两个整数 a 和 b，如果它们的和是偶数，则返回和；如果和是奇数，则返回 a 和 b 的乘积。\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10", "fr": "Étant donné deux entiers a et b, retourner la somme si la somme est paire, ou retourner le produit de a et b si la somme est impaire.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10", "de": "Gegeben zwei ganze Zahlen a und b, gib die Summe zurück, wenn die Summe gerade ist, oder gib das Produkt von a und b zurück, wenn die Summe ungerade ist.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10", "ha": "An ba da lambobi guda biyu a da b, dawo da jumlar idan jumlar tana da lamba mai ma'ana, ko kuma dawo da samfurin a da b idan jumlar tana da lamba marar ma'ana.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10", "hi": "दो पूर्णांक a और b दिए गए हैं, यदि योग सम है तो योग लौटाएँ, या यदि योग विषम है तो a और b का गुणनफल लौटाएँ।\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10", "hu": "Két egész szám, a és b esetén add vissza az összeget, ha az összeg páros, vagy add vissza a és b szorzatát, ha az összeg páratlan.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10", "es": "Dado dos enteros a y b, devuelve la suma si la suma es par, o devuelve el producto de a y b si la suma es impar.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10", "arb": "بالنظر إلى عددين صحيحين a و b، قم بإرجاع المجموع إذا كان المجموع زوجيًا، أو قم بإرجاع حاصل ضرب a و b إذا كان المجموع فرديًا.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10", "sw": "Ukipewa namba mbili nzima a na b, rudisha jumla ikiwa jumla ni namba shufwa, au rudisha bidhaa ya a na b ikiwa jumla ni namba witiri.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10", "tr": "Verilen iki tamsayı a ve b için, toplam çift ise toplamı döndürün, toplam tek ise a ve b'nin çarpımını döndürün.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10", "vi": "Cho hai số nguyên a và b, trả về tổng nếu tổng là số chẵn, hoặc trả về tích của a và b nếu tổng là số lẻ.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10", "id": "Diberikan dua bilangan bulat a dan b, kembalikan jumlahnya jika jumlah tersebut genap, atau kembalikan hasil kali dari a dan b jika jumlahnya ganjil.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10", "ja": "2つの整数aとbが与えられたとき、合計が偶数であれば合計を返し、合計が奇数であればaとbの積を返します。\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10", "ko": "두 정수 a와 b가 주어졌을 때, 합이 짝수이면 합을 반환하고, 합이 홀수이면 a와 b의 곱을 반환합니다.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10", "ml": "രണ്ട് പൂർണ്ണസംഖ്യകളായ a, b എന്നിവ നൽകിയാൽ, തുക സമവായിരുന്നാൽ തുക മടക്കുക, അല്ലെങ്കിൽ തുക ഒറ്റയായാൽ a, b എന്നിവയുടെ ഗുണഫലം മടക്കുക.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10", "fa": "دو عدد صحیح a و b داده شده است، مجموع را برگردانید اگر مجموع زوج باشد، یا حاصل‌ضرب a و b را برگردانید اگر مجموع فرد باشد.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10"}}
