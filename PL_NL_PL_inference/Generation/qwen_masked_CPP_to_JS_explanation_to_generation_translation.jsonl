{"task_id": "JavaScript/1", "prompt": {"en": "// return \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"\nfunction f_1()", "sq": "// kthen \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"\nfunction f_1()", "hy": "// վերադարձնել \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"\nfunction f_1()", "bn": "// \"Hello, Mass-McEval: massively scaled multilingual code evaluation\" ফেরত দিন\nfunction f_1()", "bg": "// връща \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"\nfunction f_1()", "zh": "// 返回 \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"\nfunction f_1()", "fr": "// renvoie \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"\nfunction f_1()", "de": "// Rückgabe \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"\nfunction f_1()", "ha": "// dawo da \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"\nfunction f_1()", "hi": "// \"Hello, Mass-McEval: massively scaled multilingual code evaluation\" लौटाएं\nfunction f_1()", "hu": "// adja vissza a \"Hello, Mass-McEval: massively scaled multilingual code evaluation\" értéket\nfunction f_1()", "es": "// devuelve \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"\nfunction f_1()", "arb": "// إرجاع \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"\nfunction f_1()", "sw": "// rudisha \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"\nfunction f_1()", "tr": "// \"Hello, Mass-McEval: massively scaled multilingual code evaluation\" döndür\nfunction f_1()", "vi": "// trả về \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"\nfunction f_1()", "id": "// mengembalikan \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"\nfunction f_1()", "ja": "// \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"を返す\nfunction f_1()", "ko": "// \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"을 반환합니다.\nfunction f_1()", "ml": "// \"Hello, Mass-McEval: massively scaled multilingual code evaluation\" എന്നത് തിരികെ നൽകുക\nfunction f_1()", "fa": "// بازگرداندن \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"\nfunction f_1()"}, "canonical_solution": "{\n    return \"Hello, Mass-McEval: massively scaled multilingual code evaluation\";\n}", "instruction": {"en": "Write a JavaScript function `function f_1()` to solve the following problem:\nreturn \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "sq": "Shkruani një funksion JavaScript `function f_1()` për të zgjidhur problemin në vijim: kthe \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "hy": "Գրեք JavaScript ֆունկցիա `function f_1()` հետևյալ խնդիրը լուծելու համար:  \nվերադարձնել \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "bn": "একটি জাভাস্ক্রিপ্ট ফাংশন `function f_1()` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য: \"Hello, Mass-McEval: massively scaled multilingual code evaluation\" রিটার্ন করুন", "bg": "Напишете JavaScript функция `function f_1()` за решаване на следния проблем:  \nвръща \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "zh": "编写一个 JavaScript 函数 `function f_1()` 来解决以下问题：  \n返回 \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "fr": "Écrire une fonction JavaScript `function f_1()` pour résoudre le problème suivant :  \nretourner \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "de": "Schreiben Sie eine JavaScript-Funktion `function f_1()`, um das folgende Problem zu lösen:  \nreturn \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "ha": "Rubuta wani aikin JavaScript `function f_1()` don warware matsalar mai zuwa:  \nmayar da \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "hi": "एक JavaScript फ़ंक्शन `function f_1()` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:  \n\"Hello, Mass-McEval: massively scaled multilingual code evaluation\" लौटाएं", "hu": "Írj egy JavaScript függvényt `function f_1()` a következő probléma megoldására:  \nvisszatér \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "es": "Escribe una función de JavaScript `function f_1()` para resolver el siguiente problema:  \ndevuelve \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "arb": "اكتب دالة JavaScript `function f_1()` لحل المشكلة التالية:  \nإرجاع \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "sw": "Andika kazi ya JavaScript `function f_1()` kutatua tatizo lifuatalo:  \nrudisha \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "tr": "Bir JavaScript fonksiyonu `function f_1()` yazın ve aşağıdaki problemi çözün:\n\"Hello, Mass-McEval: massively scaled multilingual code evaluation\" döndürün", "vi": "Viết một hàm JavaScript `function f_1()` để giải quyết vấn đề sau:  \ntrả về \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "id": "Tulis sebuah fungsi JavaScript `function f_1()` untuk menyelesaikan masalah berikut:  \nmengembalikan \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "ja": "JavaScript関数`function f_1()`を作成して、次の問題を解決してください:  \n\"Hello, Mass-McEval: massively scaled multilingual code evaluation\"を返します", "ko": "JavaScript 함수를 작성하세요 `function f_1()` 다음 문제를 해결하기 위해:  \n\"Hello, Mass-McEval: massively scaled multilingual code evaluation\"을 반환하세요.", "ml": "ഒരു ജാവാസ്ക്രിപ്റ്റ് ഫംഗ്ഷൻ എഴുതുക `function f_1()` ഈ പ്രശ്നം പരിഹരിക്കാൻ: return \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "fa": "یک تابع جاوااسکریپت بنویسید `function f_1()` برای حل مشکل زیر:  \nreturn \"Hello, Mass-McEval: massively scaled multilingual code evaluation\""}, "level": "easy", "test": "(() => {\n    console.assert(f_1() === \"Hello, Mass-McEval: massively scaled multilingual code evaluation\");\n})();", "entry_point": "f_1", "signature": "function f_1()", "docstring": {"en": "return \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "sq": "Kthe \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "hy": "Վերադարձնել \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "bn": "\"Hello, Mass-McEval: massively scaled multilingual code evaluation\" ফেরত দিন", "bg": "Върни \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "zh": "返回 \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "fr": "Retourne \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "de": "Gibt \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "ha": "Mayar da \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "hi": "\"Hello, Mass-McEval: massively scaled multilingual code evaluation\" लौटाएं", "hu": "Adja vissza a \"Hello, Mass-McEval: massively scaled multilingual code evaluation\" szöveget.", "es": "Devuelve \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "arb": "إرجاع \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "sw": "Rudisha \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "tr": " \"Hello, Mass-McEval: massively scaled multilingual code evaluation\" döndür", "vi": "Trả về \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "id": "Mengembalikan \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "ja": "\"Hello, Mass-McEval: massively scaled multilingual code evaluation\" を返します", "ko": "\"Hello, Mass-McEval: massively scaled multilingual code evaluation\"을 반환합니다.", "ml": "\"Hello, Mass-McEval: massively scaled multilingual code evaluation\" തിരികെ നൽകുക", "fa": "بازگرداندن \"Hello, Mass-McEval: massively scaled multilingual code evaluation\""}}
{"task_id": "JavaScript/2", "prompt": {"en": "/**\n * Calculate the area of a triangle given its three sides.\n * \n * @param {number} a - Length of side 'a'.\n * @param {number} b - Length of side 'b'.\n * @param {number} c - Length of side 'c'.\n * @returns {string|number} If the provided sides form a triangle, return the calculated area with 2 decimal places. Otherwise, return -1.\n * Example:\n *  f_2(3, 5, 4) // returns 6\n */\nfunction f_2(a, b, c)", "sq": "/**\n * Llogarit sipërfaqen e një trekëndëshi duke dhënë tre anët e tij.\n * \n * @param {number} a - Gjatësia e anës 'a'.\n * @param {number} b - Gjatësia e anës 'b'.\n * @param {number} c - Gjatësia e anës 'c'.\n * @returns {string|number} Nëse anët e dhëna formojnë një trekëndësh, kthen sipërfaqen e llogaritur me 2 shifra dhjetore. Përndryshe, kthen -1.\n * Shembull:\n *  f_2(3, 5, 4) // kthen 6\n */\nfunction f_2(a, b, c)", "hy": "/**\n * Հաշվել եռանկյան մակերեսը՝ հաշվի առնելով նրա երեք կողմերը։\n * \n * @param {number} a - 'a' կողմի երկարությունը։\n * @param {number} b - 'b' կողմի երկարությունը։\n * @param {number} c - 'c' կողմի երկարությունը։\n * @returns {string|number} Եթե տրված կողմերը կազմում են եռանկյուն, վերադարձնել հաշվարկված մակերեսը՝ 2 տասնորդական թվանշաններով։ Հակառակ դեպքում վերադարձնել -1։\n * Օրինակ:\n *  f_2(3, 5, 4) // վերադարձնում է 6\n */\nfunction f_2(a, b, c)", "bn": "/**\n * একটি ত্রিভুজের তিনটি বাহু দেওয়া থাকলে তার ক্ষেত্রফল গণনা করুন।\n * \n * @param {number} a - 'a' বাহুর দৈর্ঘ্য।\n * @param {number} b - 'b' বাহুর দৈর্ঘ্য।\n * @param {number} c - 'c' বাহুর দৈর্ঘ্য।\n * @returns {string|number} যদি প্রদত্ত বাহুগুলি একটি ত্রিভুজ গঠন করে, তবে 2 দশমিক স্থান সহ গণনা করা ক্ষেত্রফল ফেরত দিন। অন্যথায়, -1 ফেরত দিন।\n * Example:\n *  f_2(3, 5, 4) // returns 6\n */\nfunction f_2(a, b, c)", "bg": "/**\n * Изчислява площта на триъгълник, като се дадат неговите три страни.\n * \n * @param {number} a - Дължина на страната 'a'.\n * @param {number} b - Дължина на страната 'b'.\n * @param {number} c - Дължина на страната 'c'.\n * @returns {string|number} Ако дадените страни образуват триъгълник, връща изчислената площ с 2 десетични знака. В противен случай връща -1.\n * Пример:\n *  f_2(3, 5, 4) // връща 6\n */\nfunction f_2(a, b, c)", "zh": "/**\n * 计算给定三边的三角形面积。\n * \n * @param {number} a - 边 'a' 的长度。\n * @param {number} b - 边 'b' 的长度。\n * @param {number} c - 边 'c' 的长度。\n * @returns {string|number} 如果提供的边能构成三角形，返回计算出的面积，保留两位小数。否则，返回 -1。\n * 示例:\n *  f_2(3, 5, 4) // 返回 6\n */\nfunction f_2(a, b, c)", "fr": "/**\n * Calculer l'aire d'un triangle donné ses trois côtés.\n * \n * @param {number} a - Longueur du côté 'a'.\n * @param {number} b - Longueur du côté 'b'.\n * @param {number} c - Longueur du côté 'c'.\n * @returns {string|number} Si les côtés fournis forment un triangle, retourne l'aire calculée avec 2 décimales. Sinon, retourne -1.\n * Exemple:\n *  f_2(3, 5, 4) // returns 6\n */\nfunction f_2(a, b, c)", "de": "/**\n * Berechnet die Fläche eines Dreiecks, gegeben durch seine drei Seiten.\n * \n * @param {number} a - Länge der Seite 'a'.\n * @param {number} b - Länge der Seite 'b'.\n * @param {number} c - Länge der Seite 'c'.\n * @returns {string|number} Wenn die angegebenen Seiten ein Dreieck bilden, wird die berechnete Fläche mit 2 Dezimalstellen zurückgegeben. Andernfalls wird -1 zurückgegeben.\n * Beispiel:\n *  f_2(3, 5, 4) // gibt 6 zurück\n */\nfunction f_2(a, b, c)", "ha": "/**\n * Lissafin yankin wani alwatika idan aka ba da tsawon sassa uku.\n * \n * @param {number} a - Tsawon gefen 'a'.\n * @param {number} b - Tsawon gefen 'b'.\n * @param {number} c - Tsawon gefen 'c'.\n * @returns {string|number} Idan sassan da aka bayar sun kafa alwatika, dawo da yankin da aka lissafa tare da wuraren goma biyu. In ba haka ba, dawo da -1.\n * Misali:\n *  f_2(3, 5, 4) // ya dawo da 6\n */\nfunction f_2(a, b, c)", "hi": "/**\n * दिए गए तीन भुजाओं के आधार पर त्रिभुज का क्षेत्रफल गणना करें।\n * \n * @param {number} a - भुजा 'a' की लंबाई।\n * @param {number} b - भुजा 'b' की लंबाई।\n * @param {number} c - भुजा 'c' की लंबाई।\n * @returns {string|number} यदि दी गई भुजाएँ एक त्रिभुज बनाती हैं, तो 2 दशमलव स्थानों के साथ गणना किया गया क्षेत्रफल लौटाएं। अन्यथा, -1 लौटाएं।\n * Example:\n *  f_2(3, 5, 4) // returns 6\n */\nfunction f_2(a, b, c)", "hu": "/**\n * Számítsa ki egy háromszög területét a három oldalának megadásával.\n * \n * @param {number} a - Az 'a' oldal hossza.\n * @param {number} b - A 'b' oldal hossza.\n * @param {number} c - A 'c' oldal hossza.\n * @returns {string|number} Ha a megadott oldalak háromszöget alkotnak, adja vissza a kiszámított területet 2 tizedesjegy pontossággal. Ellenkező esetben adja vissza -1-et.\n * Példa:\n *  f_2(3, 5, 4) // visszaadja 6\n */\nfunction f_2(a, b, c)", "es": "/**\n * Calcular el área de un triángulo dados sus tres lados.\n * \n * @param {number} a - Longitud del lado 'a'.\n * @param {number} b - Longitud del lado 'b'.\n * @param {number} c - Longitud del lado 'c'.\n * @returns {string|number} Si los lados proporcionados forman un triángulo, devuelve el área calculada con 2 decimales. De lo contrario, devuelve -1.\n * Ejemplo:\n *  f_2(3, 5, 4) // devuelve 6\n */\nfunction f_2(a, b, c)", "arb": "/**\n * حساب مساحة المثلث المعطى أضلاعه الثلاثة.\n * \n * @param {number} a - طول الضلع 'a'.\n * @param {number} b - طول الضلع 'b'.\n * @param {number} c - طول الضلع 'c'.\n * @returns {string|number} إذا كانت الأضلاع المقدمة تشكل مثلثاً، يتم إرجاع المساحة المحسوبة مع منزلتين عشريتين. خلاف ذلك، يتم إرجاع -1.\n * مثال :\n *  f_2(3, 5, 4) // يعيد 6\n */\nfunction f_2(a, b, c)", "sw": "/**\n * Hesabu eneo la pembetatu ukizingatia pande zake tatu.\n * \n * @param {number} a - Urefu wa upande 'a'.\n * @param {number} b - Urefu wa upande 'b'.\n * @param {number} c - Urefu wa upande 'c'.\n * @returns {string|number} Ikiwa pande zilizotolewa zinaunda pembetatu, rudisha eneo lililohesabiwa na sehemu 2 za desimali. Vinginevyo, rudisha -1.\n * Mfano:\n *  f_2(3, 5, 4) // inarudisha 6\n */\nfunction f_2(a, b, c)", "tr": "/**\n * Üç kenarı verilen bir üçgenin alanını hesaplayın.\n * \n * @param {number} a - 'a' kenarının uzunluğu.\n * @param {number} b - 'b' kenarının uzunluğu.\n * @param {number} c - 'c' kenarının uzunluğu.\n * @returns {string|number} Verilen kenarlar bir üçgen oluşturuyorsa, hesaplanan alanı 2 ondalık basamakla döndürün. Aksi takdirde, -1 döndürün.\n * Örnek:\n *  f_2(3, 5, 4) // 6 döndürür\n */\nfunction f_2(a, b, c)", "vi": "/**\n * Tính diện tích của một tam giác khi biết độ dài ba cạnh của nó.\n * \n * @param {number} a - Độ dài của cạnh 'a'.\n * @param {number} b - Độ dài của cạnh 'b'.\n * @param {number} c - Độ dài của cạnh 'c'.\n * @returns {string|number} Nếu các cạnh được cung cấp tạo thành một tam giác, trả về diện tích đã tính với 2 chữ số thập phân. Ngược lại, trả về -1.\n * Ví dụ:\n *  f_2(3, 5, 4) // trả về 6\n */\nfunction f_2(a, b, c)", "id": "/**\n * Hitung luas segitiga berdasarkan tiga sisinya.\n * \n * @param {number} a - Panjang sisi 'a'.\n * @param {number} b - Panjang sisi 'b'.\n * @param {number} c - Panjang sisi 'c'.\n * @returns {string|number} Jika sisi yang diberikan membentuk segitiga, kembalikan luas yang dihitung dengan 2 tempat desimal. Jika tidak, kembalikan -1.\n * Contoh:\n *  f_2(3, 5, 4) // mengembalikan 6\n */\nfunction f_2(a, b, c)", "ja": "/**\n * 3辺が与えられた三角形の面積を計算します。\n * \n * @param {number} a - 辺 'a' の長さ。\n * @param {number} b - 辺 'b' の長さ。\n * @param {number} c - 辺 'c' の長さ。\n * @returns {string|number} 与えられた辺が三角形を形成する場合、計算された面積を小数点以下2桁で返します。それ以外の場合は -1 を返します。\n * 例:\n *  f_2(3, 5, 4) // 6 を返します\n */\nfunction f_2(a, b, c)", "ko": "/**\n * 주어진 세 변의 길이를 통해 삼각형의 넓이를 계산합니다.\n * \n * @param {number} a - 변 'a'의 길이.\n * @param {number} b - 변 'b'의 길이.\n * @param {number} c - 변 'c'의 길이.\n * @returns {string|number} 주어진 변들이 삼각형을 형성하면, 계산된 넓이를 소수점 두 자리로 반환합니다. 그렇지 않으면 -1을 반환합니다.\n * Example:\n *  f_2(3, 5, 4) // returns 6\n */\nfunction f_2(a, b, c)", "ml": "/**\n * ഒരു ത്രികോണത്തിന്റെ മൂന്നു വശങ്ങൾ നൽകിയാൽ അതിന്റെ വിസ്തീർണ്ണം കണക്കാക്കുക.\n * \n * @param {number} a - വശം 'a'യുടെ നീളം.\n * @param {number} b - വശം 'b'യുടെ നീളം.\n * @param {number} c - വശം 'c'യുടെ നീളം.\n * @returns {string|number} നൽകിയ വശങ്ങൾ ഒരു ത്രികോണം രൂപീകരിക്കുന്നുവെങ്കിൽ, കണക്കാക്കിയ വിസ്തീർണ്ണം 2 ദശാംശസ്ഥാനം സഹിതം മടക്കിക്കൊടുക്കുക. അല്ലാത്തപക്ഷം, -1 മടക്കിക്കൊടുക്കുക.\n * Example:\n *  f_2(3, 5, 4) // returns 6\n */\nfunction f_2(a, b, c)", "fa": "/**\n * محاسبه مساحت یک مثلث با توجه به سه ضلع آن.\n * \n * @param {number} a - طول ضلع 'a'.\n * @param {number} b - طول ضلع 'b'.\n * @param {number} c - طول ضلع 'c'.\n * @returns {string|number} اگر اضلاع داده شده یک مثلث تشکیل دهند، مساحت محاسبه شده را با 2 رقم اعشار برمی‌گرداند. در غیر این صورت، -1 را برمی‌گرداند.\n * Example:\n *  f_2(3, 5, 4) // returns 6\n */\nfunction f_2(a, b, c)"}, "canonical_solution": "{\n    if (a + b > c && a + c > b && b + c > a) {\n        let s = (a + b + c) / 2.0;\n        return Number(Math.sqrt(s * (s - a) * (s - b) * (s - c)).toFixed(2));\n    } else {\n        return -1; // Use a special value to indicate not a triangle\n    }\n}", "instruction": {"en": "Write a JavaScript function `function f_2(a, b, c)` to solve the following problem:\nCalculate the area of a triangle given its three sides.\n\nParameters:\n- a (number): Length of side 'a'.\n- b (number): Length of side 'b'.\n- c (number): Length of side 'c'.\n\nReturns:\n- string|number: If the provided sides form a triangle, return the calculated area with 2 decimal places. Otherwise, return -1.\nExample:\n f_2(3, 5, 4) // returns 6\n", "sq": "Shkruani një funksion JavaScript `function f_2(a, b, c)` për të zgjidhur problemin e mëposhtëm:\nLlogaritni sipërfaqen e një trekëndëshi duke pasur parasysh tre anët e tij.\n\nParametrat:\n- a (numër): Gjatësia e anës 'a'.\n- b (numër): Gjatësia e anës 'b'.\n- c (numër): Gjatësia e anës 'c'.\n\nKthen:\n- string|numër: Nëse anët e dhëna formojnë një trekëndësh, kthen sipërfaqen e llogaritur me 2 shifra dhjetore. Përndryshe, kthen -1.\nShembull:\n f_2(3, 5, 4) // kthen 6", "hy": "Գրեք JavaScript ֆունկցիա `function f_2(a, b, c)` հետևյալ խնդիրը լուծելու համար:\nՀաշվեք եռանկյան մակերեսը՝ հաշվի առնելով նրա երեք կողմերը։\n\nՊարամետրեր:\n- a (number): 'a' կողմի երկարությունը։\n- b (number): 'b' կողմի երկարությունը։\n- c (number): 'c' կողմի երկարությունը։\n\nՎերադարձնում է:\n- string|number: Եթե տրված կողմերը կազմում են եռանկյուն, վերադարձնում է հաշվարկված մակերեսը՝ 2 տասնորդական թվանշանով։ Հակառակ դեպքում վերադարձնում է -1։\nՕրինակ:\n f_2(3, 5, 4) // վերադարձնում է 6", "bn": "একটি জাভাস্ক্রিপ্ট ফাংশন `function f_2(a, b, c)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএর তিনটি বাহু দেওয়া থাকলে একটি ত্রিভুজের ক্ষেত্রফল গণনা করুন।\n\nপ্যারামিটারসমূহ:\n- a (number): 'a' বাহুর দৈর্ঘ্য।\n- b (number): 'b' বাহুর দৈর্ঘ্য।\n- c (number): 'c' বাহুর দৈর্ঘ্য।\n\nফেরত দেয়:\n- string|number: যদি প্রদত্ত বাহুগুলি একটি ত্রিভুজ গঠন করে, তবে 2 দশমিক স্থান সহ গণনা করা ক্ষেত্রফল ফেরত দিন। অন্যথায়, -1 ফেরত দিন।\nউদাহরণ:\n f_2(3, 5, 4) // 6 ফেরত দেয়", "bg": "Напишете JavaScript функция `function f_2(a, b, c)`, за да решите следния проблем:\nИзчислете лицето на триъгълник, дадени неговите три страни.\n\nПараметри:\n- a (number): Дължина на страна 'a'.\n- b (number): Дължина на страна 'b'.\n- c (number): Дължина на страна 'c'.\n\nВръща:\n- string|number: Ако предоставените страни образуват триъгълник, върнете изчисленото лице с 2 десетични знака. В противен случай върнете -1.\nПример:\n f_2(3, 5, 4) // връща 6", "zh": "编写一个 JavaScript 函数 `function f_2(a, b, c)` 来解决以下问题：\n计算给定三边的三角形面积。\n\n参数：\n- a (number): 边 'a' 的长度。\n- b (number): 边 'b' 的长度。\n- c (number): 边 'c' 的长度。\n\n返回：\n- string|number: 如果提供的边能构成一个三角形，返回计算出的面积，保留两位小数。否则，返回 -1。\n示例：\n f_2(3, 5, 4) // 返回 6", "fr": "Écrire une fonction JavaScript `function f_2(a, b, c)` pour résoudre le problème suivant :  \nCalculer l'aire d'un triangle donné ses trois côtés.\n\nParamètres :\n- a (number): Longueur du côté 'a'.\n- b (number): Longueur du côté 'b'.\n- c (number): Longueur du côté 'c'.\n\nRenvoie :\n- string|number: Si les côtés fournis forment un triangle, renvoie l'aire calculée avec 2 décimales. Sinon, renvoie -1.\nExemple :\n f_2(3, 5, 4) // returns 6", "de": "Schreiben Sie eine JavaScript-Funktion `function f_2(a, b, c)`, um das folgende Problem zu lösen:\nBerechnen Sie die Fläche eines Dreiecks, gegeben seine drei Seiten.\n\nParameter:\n- a (number): Länge der Seite 'a'.\n- b (number): Länge der Seite 'b'.\n- c (number): Länge der Seite 'c'.\n\nRückgabewerte:\n- string|number: Wenn die angegebenen Seiten ein Dreieck bilden, geben Sie die berechnete Fläche mit 2 Dezimalstellen zurück. Andernfalls geben Sie -1 zurück.\nBeispiel:\n f_2(3, 5, 4) // gibt 6 zurück", "ha": "Rubuta wani aikin JavaScript `function f_2(a, b, c)` don warware matsalar mai zuwa:\nƘididdige yanki na wani alwatika idan aka ba shi gefensa uku.\n\nSigogi:\n- a (number): Tsawon gefen 'a'.\n- b (number): Tsawon gefen 'b'.\n- c (number): Tsawon gefen 'c'.\n\nDawowa:\n- string|number: Idan gefen da aka bayar sun samar da alwatika, dawo da yankin da aka ƙididdige tare da wurare biyu na adadi. In ba haka ba, dawo da -1.\nMisali:\n f_2(3, 5, 4) // returns 6", "hi": "`function f_2(a, b, c)` निम्नलिखित समस्या को हल करने के लिए:\nइसके तीन भुजाओं के दिए गए लंबाई के आधार पर एक त्रिभुज का क्षेत्रफल गणना करें।\n\nपैरामीटर्स:\n- a (number): भुजा 'a' की लंबाई।\n- b (number): भुजा 'b' की लंबाई।\n- c (number): भुजा 'c' की लंबाई।\n\nवापसी मान:\n- string|number: यदि दी गई भुजाएँ एक त्रिभुज बनाती हैं, तो 2 दशमलव स्थानों के साथ गणना किया गया क्षेत्रफल लौटाएं। अन्यथा, -1 लौटाएं।\nउदाहरण:\n f_2(3, 5, 4) // 6 लौटाता है", "hu": "Írj egy JavaScript függvényt `function f_2(a, b, c)` a következő probléma megoldására:\nSzámítsd ki egy háromszög területét a három oldalának ismeretében.\n\nParaméterek:\n- a (szám): Az 'a' oldal hossza.\n- b (szám): A 'b' oldal hossza.\n- c (szám): A 'c' oldal hossza.\n\nVisszatérési érték:\n- string|szám: Ha a megadott oldalak háromszöget alkotnak, térj vissza a kiszámított területtel 2 tizedesjegyre kerekítve. Ellenkező esetben térj vissza -1 értékkel.\nPélda:\n f_2(3, 5, 4) // visszatérési érték 6", "es": "Escribe una función de JavaScript `function f_2(a, b, c)` para resolver el siguiente problema:\nCalcular el área de un triángulo dados sus tres lados.\n\nParámetros:\n- a (number): Longitud del lado 'a'.\n- b (number): Longitud del lado 'b'.\n- c (number): Longitud del lado 'c'.\n\nDevuelve:\n- string|number: Si los lados proporcionados forman un triángulo, devuelve el área calculada con 2 decimales. De lo contrario, devuelve -1.\nEjemplo:\n f_2(3, 5, 4) // devuelve 6", "arb": "اكتب دالة JavaScript `function f_2(a, b, c)` لحل المشكلة التالية:\nاحسب مساحة مثلث معطى أضلاعه الثلاثة.\n\nالمعطيات:\n- a (number): طول الضلع 'a'.\n- b (number): طول الضلع 'b'.\n- c (number): طول الضلع 'c'.\n\nالقيم المعادة:\n- string|number: إذا كانت الأضلاع المعطاة تشكل مثلثًا، أعد المساحة المحسوبة بدقتين عشريتين. خلاف ذلك، أعد -1.\nمثال:\n f_2(3, 5, 4) // يعيد 6", "sw": "Andika kazi ya JavaScript `function f_2(a, b, c)` kutatua tatizo lifuatalo:\nHesabu eneo la pembetatu ukizingatia pande zake tatu.\n\nVigezo:\n- a (number): Urefu wa upande 'a'.\n- b (number): Urefu wa upande 'b'.\n- c (number): Urefu wa upande 'c'.\n\nInarejesha:\n- string|number: Ikiwa pande zilizotolewa zinaunda pembetatu, rudisha eneo lililohesabiwa na sehemu 2 za desimali. Vinginevyo, rudisha -1.\nMfano:\n f_2(3, 5, 4) // inarejesha 6", "tr": "Bir JavaScript fonksiyonu `function f_2(a, b, c)` yazın:\nÜç kenarı verilen bir üçgenin alanını hesaplayın.\n\nParametreler:\n- a (number): 'a' kenarının uzunluğu.\n- b (number): 'b' kenarının uzunluğu.\n- c (number): 'c' kenarının uzunluğu.\n\nDöndürülenler:\n- string|number: Eğer verilen kenarlar bir üçgen oluşturuyorsa, hesaplanan alanı 2 ondalık basamakla döndürün. Aksi takdirde, -1 döndürün.\nÖrnek:\n f_2(3, 5, 4) // 6 döndürür", "vi": "Viết một hàm JavaScript `function f_2(a, b, c)` để giải quyết vấn đề sau:\nTính diện tích của một tam giác khi biết ba cạnh của nó.\n\nTham số:\n- a (number): Chiều dài của cạnh 'a'.\n- b (number): Chiều dài của cạnh 'b'.\n- c (number): Chiều dài của cạnh 'c'.\n\nTrả về:\n- string|number: Nếu các cạnh được cung cấp tạo thành một tam giác, trả về diện tích đã tính với 2 chữ số thập phân. Nếu không, trả về -1.\nVí dụ:\n f_2(3, 5, 4) // trả về 6", "id": "Tulis sebuah fungsi JavaScript `function f_2(a, b, c)` untuk menyelesaikan masalah berikut:\nHitung luas segitiga yang diberikan tiga sisinya.\n\nParameter:\n- a (number): Panjang sisi 'a'.\n- b (number): Panjang sisi 'b'.\n- c (number): Panjang sisi 'c'.\n\nMengembalikan:\n- string|number: Jika sisi yang diberikan membentuk segitiga, kembalikan luas yang dihitung dengan 2 tempat desimal. Jika tidak, kembalikan -1.\nContoh:\n f_2(3, 5, 4) // mengembalikan 6", "ja": "JavaScript関数`function f_2(a, b, c)`を作成して、次の問題を解決してください:\n与えられた3辺から三角形の面積を計算します。\n\nパラメータ:\n- a (number): 辺'a'の長さ。\n- b (number): 辺'b'の長さ。\n- c (number): 辺'c'の長さ。\n\n戻り値:\n- string|number: 提供された辺が三角形を形成する場合、計算された面積を小数点以下2桁で返します。それ以外の場合は-1を返します。\n例:\n f_2(3, 5, 4) // returns 6", "ko": "JavaScript 함수를 작성하십시오 `function f_2(a, b, c)` 다음 문제를 해결하기 위해:\n세 변이 주어진 삼각형의 넓이를 계산하십시오.\n\n매개변수:\n- a (number): 변 'a'의 길이.\n- b (number): 변 'b'의 길이.\n- c (number): 변 'c'의 길이.\n\n반환값:\n- string|number: 제공된 변들이 삼각형을 형성하면, 계산된 넓이를 소수점 둘째 자리까지 반환합니다. 그렇지 않으면 -1을 반환합니다.\n예시:\n f_2(3, 5, 4) // returns 6", "ml": "ഒരു ജാവാസ്ക്രിപ്റ്റ് ഫംഗ്ഷൻ `function f_2(a, b, c)` എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nതന്റെ മൂന്നു വശങ്ങളും നൽകിയിരിക്കുന്ന ഒരു ത്രികോണത്തിന്റെ വിസ്തീർണ്ണം കണക്കാക്കുക.\n\nപാരാമീറ്ററുകൾ:\n- a (number): 'a' എന്ന വശത്തിന്റെ നീളം.\n- b (number): 'b' എന്ന വശത്തിന്റെ നീളം.\n- c (number): 'c' എന്ന വശത്തിന്റെ നീളം.\n\nമടക്കുക:\n- string|number: നൽകിയിരിക്കുന്ന വശങ്ങൾ ഒരു ത്രികോണം രൂപീകരിക്കുന്നുവെങ്കിൽ, കണക്കാക്കിയ വിസ്തീർണ്ണം 2 ദശാംശസ്ഥാനം സഹിതം മടക്കുക. അല്ലെങ്കിൽ, -1 മടക്കുക.\nഉദാഹരണം:\n f_2(3, 5, 4) // 6 മടക്കുന്നു", "fa": "یک تابع جاوااسکریپت `function f_2(a, b, c)` بنویسید تا مسئله زیر را حل کند:\nمساحت یک مثلث را با توجه به سه ضلع آن محاسبه کنید.\n\nپارامترها:\n- a (number): طول ضلع 'a'.\n- b (number): طول ضلع 'b'.\n- c (number): طول ضلع 'c'.\n\nبازگشتی:\n- string|number: اگر اضلاع ارائه شده یک مثلث تشکیل دهند، مساحت محاسبه شده را با 2 رقم اعشار برگردانید. در غیر این صورت، -1 را برگردانید.\nمثال:\n f_2(3, 5, 4) // returns 6"}, "level": "easy", "test": "const testf_2 = () => {\n    // Triangle with sides 3, 5, 4 should return area 6\n    console.assert(Math.abs(f_2(3, 5, 4) - 6) < 1e-6);\n\n    // Not a triangle with sides 1, 1, 4 should return -1\n    console.assert(f_2(1, 1, 4) === -1);\n\n    // Triangle with sides 7, 24, 25 should return area 84\n    console.assert(Math.abs(f_2(7, 24, 25) - 84) < 1e-6);\n\n    // Triangle with sides 10.5, 6.2, 7.3 should return a correct area within precision range\n    console.assert(Math.abs(f_2(10.5, 6.2, 7.3) - 22.15) < 1e-6);\n\n    // console.log(\"All tests passed successfully.\");\n};\n\ntestf_2();", "entry_point": "f_2", "signature": "function f_2(a, b, c)", "docstring": {"en": "Calculate the area of a triangle given its three sides.\n\nParameters:\n- a (number): Length of side 'a'.\n- b (number): Length of side 'b'.\n- c (number): Length of side 'c'.\n\nReturns:\n- string|number: If the provided sides form a triangle, return the calculated area with 2 decimal places. Otherwise, return -1.\nExample:\n f_2(3, 5, 4) // returns 6\n", "sq": "Llogaritni sipërfaqen e një trekëndëshi duke pasur parasysh tre anët e tij.\n\nParametrat:\n- a (numër): Gjatësia e anës 'a'.\n- b (numër): Gjatësia e anës 'b'.\n- c (numër): Gjatësia e anës 'c'.\n\nKthen:\n- string|numër: Nëse anët e dhëna formojnë një trekëndësh, kthejeni sipërfaqen e llogaritur me 2 shifra dhjetore. Përndryshe, kthe -1.\nShembull:\n f_2(3, 5, 4) // kthen 6", "hy": "Հաշվարկել եռանկյան մակերեսը՝ հաշվի առնելով նրա երեք կողմերը։\n\nՊարամետրեր:\n- a (թիվ): 'a' կողմի երկարությունը։\n- b (թիվ): 'b' կողմի երկարությունը։\n- c (թիվ): 'c' կողմի երկարությունը։\n\nՎերադարձնում է:\n- string|number: Եթե տրված կողմերը կազմում են եռանկյուն, վերադարձնում է հաշվարկված մակերեսը՝ 2 տասնորդական թվանշաններով։ Հակառակ դեպքում վերադարձնում է -1։\nՕրինակ:\n f_2(3, 5, 4) // վերադարձնում է 6", "bn": "ত্রিভুজের তিন বাহুর দৈর্ঘ্য প্রদান করে তার ক্ষেত্রফল গণনা করুন।\n\nপ্যারামিটারসমূহ:\n- a (number): 'a' বাহুর দৈর্ঘ্য।\n- b (number): 'b' বাহুর দৈর্ঘ্য।\n- c (number): 'c' বাহুর দৈর্ঘ্য।\n\nফেরত দেয়:\n- string|number: যদি প্রদত্ত বাহুগুলি একটি ত্রিভুজ গঠন করে, তবে গণনা করা ক্ষেত্রফল ২ দশমিক স্থান সহ ফেরত দিন। অন্যথায়, -1 ফেরত দিন।\nউদাহরণ:\n f_2(3, 5, 4) // 6 ফেরত দেয়", "bg": "Изчислете лицето на триъгълник, дадени неговите три страни.\n\nПараметри:\n- a (number): Дължина на страна 'a'.\n- b (number): Дължина на страна 'b'.\n- c (number): Дължина на страна 'c'.\n\nВръща:\n- string|number: Ако предоставените страни образуват триъгълник, връща изчисленото лице с 2 знака след десетичната запетая. В противен случай връща -1.\nПример:\n f_2(3, 5, 4) // връща 6", "zh": "计算给定三边的三角形面积。\n\n参数:\n- a (number): 边 'a' 的长度。\n- b (number): 边 'b' 的长度。\n- c (number): 边 'c' 的长度。\n\n返回:\n- string|number: 如果提供的边能构成三角形，返回计算出的面积，保留两位小数。否则，返回 -1。\n示例:\n f_2(3, 5, 4) // 返回 6", "fr": "Calculer l'aire d'un triangle donné ses trois côtés.\n\nParamètres:\n- a (nombre): Longueur du côté 'a'.\n- b (nombre): Longueur du côté 'b'.\n- c (nombre): Longueur du côté 'c'.\n\nRenvoie:\n- string|nombre: Si les côtés fournis forment un triangle, renvoie l'aire calculée avec 2 décimales. Sinon, renvoie -1.\nExemple:\n f_2(3, 5, 4) // renvoie 6", "de": "Berechnen Sie die Fläche eines Dreiecks, gegeben durch seine drei Seiten.\n\nParameter:\n- a (number): Länge der Seite 'a'.\n- b (number): Länge der Seite 'b'.\n- c (number): Länge der Seite 'c'.\n\nRückgabewerte:\n- string|number: Wenn die angegebenen Seiten ein Dreieck bilden, geben Sie die berechnete Fläche mit 2 Dezimalstellen zurück. Andernfalls wird -1 zurückgegeben.\nBeispiel:\n f_2(3, 5, 4) // gibt 6 zurück", "ha": "Lissafin yankin wani alwatika idan aka ba da tsawon sassa uku.\n\nSigogi:\n- a (namba): Tsawon gefen 'a'.\n- b (namba): Tsawon gefen 'b'.\n- c (namba): Tsawon gefen 'c'.\n\nDawowa:\n- string|namba: Idan gefen da aka bayar sun samar da alwatika, dawo da yankin da aka lissafa tare da wurare biyu na adadi mai lamba. In ba haka ba, dawo da -1.\nMisali:\n f_2(3, 5, 4) // returns 6", "hi": "त्रिभुज के तीन भुजाओं के आधार पर उसका क्षेत्रफल गणना करें।\n\nपैरामीटर्स:\n- a (संख्या): भुजा 'a' की लंबाई।\n- b (संख्या): भुजा 'b' की लंबाई।\n- c (संख्या): भुजा 'c' की लंबाई।\n\nरिटर्न्स:\n- string|number: यदि दी गई भुजाएँ एक त्रिभुज बनाती हैं, तो 2 दशमलव स्थानों के साथ गणना किया गया क्षेत्रफल लौटाएं। अन्यथा, -1 लौटाएं।\nउदाहरण:\n f_2(3, 5, 4) // 6 लौटाता है", "hu": "Számítsa ki egy háromszög területét a három oldalának megadásával.\n\nParaméterek:\n- a (szám): Az 'a' oldal hossza.\n- b (szám): A 'b' oldal hossza.\n- c (szám): A 'c' oldal hossza.\n\nVisszatérési érték:\n- string|szám: Ha a megadott oldalak háromszöget alkotnak, adja vissza a kiszámított területet 2 tizedesjegy pontossággal. Ellenkező esetben adja vissza a -1 értéket.\nPélda:\n f_2(3, 5, 4) // visszaadja 6", "es": "Calcular el área de un triángulo dados sus tres lados.\n\nParámetros:\n- a (número): Longitud del lado 'a'.\n- b (número): Longitud del lado 'b'.\n- c (número): Longitud del lado 'c'.\n\nDevuelve:\n- string|número: Si los lados proporcionados forman un triángulo, devuelve el área calculada con 2 decimales. De lo contrario, devuelve -1.\nEjemplo:\n f_2(3, 5, 4) // devuelve 6", "arb": "احسب مساحة المثلث المعطى أضلاعه الثلاثة.\n\nالمعلمات:\n- a (number): طول الضلع 'a'.\n- b (number): طول الضلع 'b'.\n- c (number): طول الضلع 'c'.\n\nالقيم المعادة:\n- string|number: إذا كانت الأضلاع المقدمة تشكل مثلثًا، يتم إرجاع المساحة المحسوبة بدقتين عشريتين. خلاف ذلك، يتم إرجاع -1.\n\nمثال:\n f_2(3, 5, 4) // يعيد 6", "sw": "Hesabu eneo la pembetatu ukizingatia pande zake tatu.\n\nVigezo:\n- a (nambari): Urefu wa upande 'a'.\n- b (nambari): Urefu wa upande 'b'.\n- c (nambari): Urefu wa upande 'c'.\n\nRudisha:\n- string|nambari: Ikiwa pande zilizotolewa zinaunda pembetatu, rudisha eneo lililohesabiwa na sehemu 2 za desimali. Vinginevyo, rudisha -1.\nMfano:\n f_2(3, 5, 4) // inarudisha 6", "tr": "Üç kenarı verilen bir üçgenin alanını hesaplayın.\n\nParametreler:\n- a (number): 'a' kenarının uzunluğu.\n- b (number): 'b' kenarının uzunluğu.\n- c (number): 'c' kenarının uzunluğu.\n\nDöndürülenler:\n- string|number: Eğer verilen kenarlar bir üçgen oluşturuyorsa, hesaplanan alanı 2 ondalık basamakla döndürün. Aksi takdirde, -1 döndürün.\nÖrnek:\n f_2(3, 5, 4) // 6 döndürür", "vi": "Tính diện tích của một tam giác khi biết ba cạnh của nó.\n\nTham số:\n- a (number): Độ dài của cạnh 'a'.\n- b (number): Độ dài của cạnh 'b'.\n- c (number): Độ dài của cạnh 'c'.\n\nTrả về:\n- string|number: Nếu các cạnh được cung cấp tạo thành một tam giác, trả về diện tích đã tính với 2 chữ số thập phân. Ngược lại, trả về -1.\nVí dụ:\n f_2(3, 5, 4) // trả về 6", "id": "Hitung luas segitiga berdasarkan tiga sisinya.\n\nParameter:\n- a (number): Panjang sisi 'a'.\n- b (number): Panjang sisi 'b'.\n- c (number): Panjang sisi 'c'.\n\nMengembalikan:\n- string|number: Jika sisi yang diberikan membentuk segitiga, kembalikan luas yang dihitung dengan 2 tempat desimal. Jika tidak, kembalikan -1.\nContoh:\n f_2(3, 5, 4) // mengembalikan 6", "ja": "三辺が与えられた三角形の面積を計算します。\n\nパラメータ:\n- a (number): 辺 'a' の長さ。\n- b (number): 辺 'b' の長さ。\n- c (number): 辺 'c' の長さ。\n\n戻り値:\n- string|number: 提供された辺が三角形を形成する場合、計算された面積を小数点以下2桁で返します。それ以外の場合は、-1を返します。\n例:\n f_2(3, 5, 4) // returns 6", "ko": "삼각형의 세 변이 주어졌을 때, 삼각형의 면적을 계산합니다.\n\n매개변수:\n- a (number): 변 'a'의 길이.\n- b (number): 변 'b'의 길이.\n- c (number): 변 'c'의 길이.\n\n반환값:\n- string|number: 주어진 변들이 삼각형을 형성하면, 계산된 면적을 소수점 둘째 자리까지 반환합니다. 그렇지 않으면 -1을 반환합니다.\n예제:\n f_2(3, 5, 4) // 6 반환", "ml": "ത്രികോണത്തിന്റെ മൂന്നു വശങ്ങൾ നൽകിയാൽ അതിന്റെ വിസ്തീർണ്ണം കണക്കാക്കുക.\n\nപാരാമീറ്ററുകൾ:\n- a (number): 'a' വശത്തിന്റെ നീളം.\n- b (number): 'b' വശത്തിന്റെ നീളം.\n- c (number): 'c' വശത്തിന്റെ നീളം.\n\nമടക്കം:\n- string|number: നൽകിയ വശങ്ങൾ ത്രികോണം രൂപീകരിക്കുന്നുവെങ്കിൽ, കണക്കാക്കിയ വിസ്തീർണ്ണം 2 ദശാംശ സ്ഥാനങ്ങളോടെ മടക്കം ചെയ്യുക. അല്ലെങ്കിൽ, -1 മടക്കം ചെയ്യുക.\nഉദാഹരണം:\n f_2(3, 5, 4) // 6 മടക്കം ചെയ്യുന്നു", "fa": "محاسبه مساحت یک مثلث با توجه به سه ضلع آن.\n\nپارامترها:\n- a (عدد): طول ضلع 'a'.\n- b (عدد): طول ضلع 'b'.\n- c (عدد): طول ضلع 'c'.\n\nبازگشت:\n- رشته|عدد: اگر اضلاع داده شده یک مثلث تشکیل دهند، مساحت محاسبه شده با دو رقم اعشار برگردانده می‌شود. در غیر این صورت، -1 برگردانده می‌شود.\nمثال:\n f_2(3, 5, 4) // 6 را برمی‌گرداند"}}
{"task_id": "JavaScript/3", "prompt": {"en": "/**\n * Calculate the value of the function for a given input.\n * \n * Parameters:\n * - x (number): Input value for the function.\n * \n * Returns:\n * - string: If x is not in the defined domain, returns \"Not define\".\n * Otherwise, returns the calculated function value as a string rounded to 5 decimal places.\n * \n * Function Definitions:\n * - For 0 <= x < 10: y = cos(x + 3.0)\n * - For 10 <= x < 20: y = (cos(x + 7.5))^2\n * - For 20 <= x < 30: y = (cos(x + 4.0))^4\n * \n * Examples:\n * f_3(40); // \"Not define\"\n */\nconst f_3 = (x) => {", "sq": "/**\n * Llogarit vlerën e funksionit për një hyrje të dhënë.\n * \n * Parametrat:\n * - x (numër): Vlera hyrëse për funksionin.\n * \n * Kthen:\n * - string: Nëse x nuk është në domenin e përcaktuar, kthen \"Not define\".\n * Përndryshe, kthen vlerën e llogaritur të funksionit si një string i rrumbullakosur në 5 shifra dhjetore.\n * \n * Përkufizimet e Funksionit:\n * - Për 0 <= x < 10: y = cos(x + 3.0)\n * - Për 10 <= x < 20: y = (cos(x + 7.5))^2\n * - Për 20 <= x < 30: y = (cos(x + 4.0))^4\n * \n * Shembuj:\n * f_3(40); // \"Not define\"\n */\nconst f_3 = (x) => {", "hy": "/**\n * Հաշվարկել ֆունկցիայի արժեքը տրված մուտքային արժեքի համար։\n * \n * Պարամետրեր:\n * - x (թիվ): Ֆունկցիայի մուտքային արժեքը։\n * \n * Վերադարձնում է:\n * - string: Եթե x-ը սահմանված դաշտում չէ, վերադարձնում է \"Not define\"։\n * Հակառակ դեպքում, վերադարձնում է հաշվարկված ֆունկցիայի արժեքը որպես տող, կլորացված մինչև 5 տասնորդական։\n * \n * Ֆունկցիայի սահմանումներ:\n * - 0 <= x < 10: y = cos(x + 3.0)\n * - 10 <= x < 20: y = (cos(x + 7.5))^2\n * - 20 <= x < 30: y = (cos(x + 4.0))^4\n * \n * Օրինակներ:\n * f_3(40); // \"Not define\"\n */\nconst f_3 = (x) => {", "bn": "/**\n * প্রদত্ত ইনপুটের জন্য ফাংশনের মান গণনা করুন।\n * \n * প্যারামিটার:\n * - x (সংখ্যা): ফাংশনের জন্য ইনপুট মান।\n * \n * রিটার্নস:\n * - string: যদি x সংজ্ঞায়িত ডোমেইনে না থাকে, তাহলে \"Not define\" রিটার্ন করে।\n * অন্যথায়, গণনা করা ফাংশনের মান একটি স্ট্রিং হিসেবে 5 দশমিক স্থানে রাউন্ড করে রিটার্ন করে।\n * \n * ফাংশন সংজ্ঞা:\n * - 0 <= x < 10 এর জন্য: y = cos(x + 3.0)\n * - 10 <= x < 20 এর জন্য: y = (cos(x + 7.5))^2\n * - 20 <= x < 30 এর জন্য: y = (cos(x + 4.0))^4\n * \n * উদাহরণ:\n * f_3(40); // \"Not define\"\n */\nconst f_3 = (x) => {", "bg": "/**\n * Изчислява стойността на функцията за даден вход.\n * \n * Параметри:\n * - x (number): Входна стойност за функцията.\n * \n * Връща:\n * - string: Ако x не е в определения домейн, връща \"Not define\".\n * В противен случай, връща изчислената стойност на функцията като низ, закръглена до 5 десетични знака.\n * \n * Определения на функцията:\n * - За 0 <= x < 10: y = cos(x + 3.0)\n * - За 10 <= x < 20: y = (cos(x + 7.5))^2\n * - За 20 <= x < 30: y = (cos(x + 4.0))^4\n * \n * Примери:\n * f_3(40); // \"Not define\"\n */\nconst f_3 = (x) => {", "zh": "/**\n * 计算给定输入的函数值。\n * \n * 参数:\n * - x (number): 函数的输入值。\n * \n * 返回:\n * - string: 如果 x 不在定义域中，返回 \"Not define\"。\n * 否则，返回计算后的函数值，结果为保留5位小数的字符串。\n * \n * 函数定义:\n * - 对于 0 <= x < 10: y = cos(x + 3.0)\n * - 对于 10 <= x < 20: y = (cos(x + 7.5))^2\n * - 对于 20 <= x < 30: y = (cos(x + 4.0))^4\n * \n * 示例:\n * f_3(40); // \"Not define\"\n */\nconst f_3 = (x) => {", "fr": "/**\n * Calculer la valeur de la fonction pour une entrée donnée.\n * \n * Paramètres:\n * - x (nombre): Valeur d'entrée pour la fonction.\n * \n * Renvoie:\n * - string: Si x n'est pas dans le domaine défini, renvoie \"Not define\".\n * Sinon, renvoie la valeur calculée de la fonction sous forme de chaîne arrondie à 5 décimales.\n * \n * Définitions de la fonction:\n * - Pour 0 <= x < 10: y = cos(x + 3.0)\n * - Pour 10 <= x < 20: y = (cos(x + 7.5))^2\n * - Pour 20 <= x < 30: y = (cos(x + 4.0))^4\n * \n * Exemples:\n * f_3(40); // \"Not define\"\n */\nconst f_3 = (x) => {", "de": "/**\n * Berechnet den Wert der Funktion für eine gegebene Eingabe.\n * \n * Parameter:\n * - x (number): Eingabewert für die Funktion.\n * \n * Rückgabewerte:\n * - string: Wenn x nicht im definierten Bereich liegt, wird \"Not define\" zurückgegeben.\n * Andernfalls wird der berechnete Funktionswert als String auf 5 Dezimalstellen gerundet zurückgegeben.\n * \n * Funktionsdefinitionen:\n * - Für 0 <= x < 10: y = cos(x + 3.0)\n * - Für 10 <= x < 20: y = (cos(x + 7.5))^2\n * - Für 20 <= x < 30: y = (cos(x + 4.0))^4\n * \n * Beispiele:\n * f_3(40); // \"Not define\"\n */\nconst f_3 = (x) => {", "ha": "/**\n * Lissafa ƙimar aikin don wani shigarwa da aka bayar.\n * \n * Sigogi:\n * - x (lamba): Ƙimar shigarwa don aikin.\n * \n * Mayarwa:\n * - string: Idan x ba ya cikin yankin da aka ayyana, yana mayar da \"Not define\".\n * In ba haka ba, yana mayar da ƙimar aikin da aka lissafa a matsayin kirtani da aka zagaye zuwa wurare 5 na goma.\n * \n * Ƙayyadaddun Ayyuka:\n * - Don 0 <= x < 10: y = cos(x + 3.0)\n * - Don 10 <= x < 20: y = (cos(x + 7.5))^2\n * - Don 20 <= x < 30: y = (cos(x + 4.0))^4\n * \n * Misalai:\n * f_3(40); // \"Not define\"\n */\nconst f_3 = (x) => {", "hi": "/**\n * दिए गए इनपुट के लिए फ़ंक्शन का मान गणना करें।\n * \n * पैरामीटर्स:\n * - x (संख्या): फ़ंक्शन के लिए इनपुट मान।\n * \n * रिटर्न करता है:\n * - स्ट्रिंग: यदि x परिभाषित डोमेन में नहीं है, तो \"Not define\" लौटाता है।\n * अन्यथा, गणना किए गए फ़ंक्शन मान को 5 दशमलव स्थानों तक राउंड करके स्ट्रिंग के रूप में लौटाता है।\n * \n * फ़ंक्शन परिभाषाएँ:\n * - 0 <= x < 10 के लिए: y = cos(x + 3.0)\n * - 10 <= x < 20 के लिए: y = (cos(x + 7.5))^2\n * - 20 <= x < 30 के लिए: y = (cos(x + 4.0))^4\n * \n * उदाहरण:\n * f_3(40); // \"Not define\"\n */", "hu": "/**\n * Számítsa ki a függvény értékét egy adott bemenetre.\n * \n * Paraméterek:\n * - x (szám): A függvény bemeneti értéke.\n * \n * Visszatér:\n * - string: Ha x nincs a meghatározott tartományban, \"Not define\" értéket ad vissza.\n * Ellenkező esetben visszaadja a számított függvényértéket sztringként, 5 tizedesjegyre kerekítve.\n * \n * Függvénydefiníciók:\n * - Ha 0 <= x < 10: y = cos(x + 3.0)\n * - Ha 10 <= x < 20: y = (cos(x + 7.5))^2\n * - Ha 20 <= x < 30: y = (cos(x + 4.0))^4\n * \n * Példák:\n * f_3(40); // \"Not define\"\n */\nconst f_3 = (x) => {", "es": "/**\n * Calcular el valor de la función para una entrada dada.\n * \n * Parámetros:\n * - x (número): Valor de entrada para la función.\n * \n * Retorna:\n * - string: Si x no está en el dominio definido, retorna \"Not define\".\n * De lo contrario, retorna el valor calculado de la función como una cadena redondeada a 5 decimales.\n * \n * Definiciones de la función:\n * - Para 0 <= x < 10: y = cos(x + 3.0)\n * - Para 10 <= x < 20: y = (cos(x + 7.5))^2\n * - Para 20 <= x < 30: y = (cos(x + 4.0))^4\n * \n * Ejemplos:\n * f_3(40); // \"Not define\"\n */\nconst f_3 = (x) => {", "arb": "/**\n * حساب قيمة الدالة لمدخل معين.\n * \n * المعلمات:\n * - x (رقم): قيمة المدخل للدالة.\n * \n * يعيد:\n * - سلسلة: إذا لم يكن x في النطاق المحدد، يعيد \"Not define\".\n * خلاف ذلك، يعيد قيمة الدالة المحسوبة كسلسلة مقربة إلى 5 منازل عشرية.\n * \n * تعريفات الدوال:\n * - لـ 0 <= x < 10: y = cos(x + 3.0)\n * - لـ 10 <= x < 20: y = (cos(x + 7.5))^2\n * - لـ 20 <= x < 30: y = (cos(x + 4.0))^4\n * \n * أمثلة:\n * f_3(40); // \"Not define\"\n */\nconst f_3 = (x) => {", "sw": "/**\n * Hesabu thamani ya kazi kwa ingizo lililopewa.\n * \n * Vigezo:\n * - x (nambari): Thamani ya ingizo kwa kazi.\n * \n * Inarudisha:\n * - string: Ikiwa x haipo katika kikoa kilichobainishwa, inarudisha \"Not define\".\n * Vinginevyo, inarudisha thamani ya kazi iliyohesabiwa kama string iliyokatwa hadi sehemu 5 za desimali.\n * \n * Ufafanuzi wa Kazi:\n * - Kwa 0 <= x < 10: y = cos(x + 3.0)\n * - Kwa 10 <= x < 20: y = (cos(x + 7.5))^2\n * - Kwa 20 <= x < 30: y = (cos(x + 4.0))^4\n * \n * Mifano:\n * f_3(40); // \"Not define\"\n */\nconst f_3 = (x) => {", "tr": "/**\n * Belirtilen bir giriş için fonksiyonun değerini hesapla.\n * \n * Parametreler:\n * - x (sayı): Fonksiyon için giriş değeri.\n * \n * Döndürür:\n * - string: Eğer x tanımlı alanda değilse, \"Not define\" döndürür.\n * Aksi takdirde, hesaplanan fonksiyon değerini 5 ondalık basamağa yuvarlanmış bir string olarak döndürür.\n * \n * Fonksiyon Tanımları:\n * - 0 <= x < 10 için: y = cos(x + 3.0)\n * - 10 <= x < 20 için: y = (cos(x + 7.5))^2\n * - 20 <= x < 30 için: y = (cos(x + 4.0))^4\n * \n * Örnekler:\n * f_3(40); // \"Not define\"\n */\nconst f_3 = (x) => {", "vi": "/**\n * Tính giá trị của hàm cho một đầu vào đã cho.\n * \n * Tham số:\n * - x (number): Giá trị đầu vào cho hàm.\n * \n * Trả về:\n * - string: Nếu x không nằm trong miền xác định, trả về \"Not define\".\n * Nếu không, trả về giá trị hàm đã tính dưới dạng chuỗi được làm tròn đến 5 chữ số thập phân.\n * \n * Định nghĩa Hàm:\n * - Với 0 <= x < 10: y = cos(x + 3.0)\n * - Với 10 <= x < 20: y = (cos(x + 7.5))^2\n * - Với 20 <= x < 30: y = (cos(x + 4.0))^4\n * \n * Ví dụ:\n * f_3(40); // \"Not define\"\n */\nconst f_3 = (x) => {", "id": "/**\n * Hitung nilai fungsi untuk input yang diberikan.\n * \n * Parameter:\n * - x (number): Nilai input untuk fungsi.\n * \n * Mengembalikan:\n * - string: Jika x tidak dalam domain yang ditentukan, mengembalikan \"Not define\".\n * Jika tidak, mengembalikan nilai fungsi yang dihitung sebagai string yang dibulatkan hingga 5 tempat desimal.\n * \n * Definisi Fungsi:\n * - Untuk 0 <= x < 10: y = cos(x + 3.0)\n * - Untuk 10 <= x < 20: y = (cos(x + 7.5))^2\n * - Untuk 20 <= x < 30: y = (cos(x + 4.0))^4\n * \n * Contoh:\n * f_3(40); // \"Not define\"\n */\nconst f_3 = (x) => {", "ja": "/**\n * 指定された入力に対する関数の値を計算します。\n * \n * パラメータ:\n * - x (number): 関数の入力値。\n * \n * 戻り値:\n * - string: xが定義された領域にない場合は \"Not define\" を返します。\n * それ以外の場合は、計算された関数の値を小数点以下5桁に丸めた文字列を返します。\n * \n * 関数定義:\n * - 0 <= x < 10 の場合: y = cos(x + 3.0)\n * - 10 <= x < 20 の場合: y = (cos(x + 7.5))^2\n * - 20 <= x < 30 の場合: y = (cos(x + 4.0))^4\n * \n * 例:\n * f_3(40); // \"Not define\"\n */\nconst f_3 = (x) => {", "ko": "/**\n * 주어진 입력에 대한 함수의 값을 계산합니다.\n * \n * 매개변수:\n * - x (number): 함수에 대한 입력 값.\n * \n * 반환값:\n * - string: x가 정의된 도메인에 없으면 \"Not define\"을 반환합니다.\n * 그렇지 않으면, 계산된 함수 값을 소수점 5자리로 반올림하여 문자열로 반환합니다.\n * \n * 함수 정의:\n * - 0 <= x < 10: y = cos(x + 3.0)\n * - 10 <= x < 20: y = (cos(x + 7.5))^2\n * - 20 <= x < 30: y = (cos(x + 4.0))^4\n * \n * 예시:\n * f_3(40); // \"Not define\"\n */\nconst f_3 = (x) => {", "ml": "/**\n * നൽകിയ ഇൻപുട്ടിനായി ഫംഗ്ഷന്റെ മൂല്യം കണക്കാക്കുക.\n * \n * പാരാമീറ്ററുകൾ:\n * - x (number): ഫംഗ്ഷനായി ഇൻപുട്ട് മൂല്യം.\n * \n * തിരികെ നൽകുന്നത്:\n * - string: x നിർവചിച്ചിരിക്കുന്ന ഡൊമെയിനിൽ ഇല്ലെങ്കിൽ, \"Not define\" തിരികെ നൽകുന്നു.\n * അല്ലെങ്കിൽ, 5 ദശാംശ സ്ഥാനങ്ങൾ വരെ വൃത്താകൃതിയിലുള്ള ഒരു സ്ട്രിംഗായി കണക്കാക്കിയ ഫംഗ്ഷൻ മൂല്യം തിരികെ നൽകുന്നു.\n * \n * ഫംഗ്ഷൻ നിർവചനങ്ങൾ:\n * - 0 <= x < 10: y = cos(x + 3.0)\n * - 10 <= x < 20: y = (cos(x + 7.5))^2\n * - 20 <= x < 30: y = (cos(x + 4.0))^4\n * \n * ഉദാഹരണങ്ങൾ:\n * f_3(40); // \"Not define\"\n */\nconst f_3 = (x) => {", "fa": "/**\n * محاسبه مقدار تابع برای یک ورودی مشخص.\n * \n * پارامترها:\n * - x (number): مقدار ورودی برای تابع.\n * \n * بازگشت:\n * - string: اگر x در دامنه تعریف شده نباشد، \"Not define\" را برمی‌گرداند.\n * در غیر این صورت، مقدار محاسبه شده تابع را به صورت رشته‌ای که به 5 رقم اعشار گرد شده است، برمی‌گرداند.\n * \n * تعریف‌های تابع:\n * - برای 0 <= x < 10: y = cos(x + 3.0)\n * - برای 10 <= x < 20: y = (cos(x + 7.5))^2\n * - برای 20 <= x < 30: y = (cos(x + 4.0))^4\n * \n * مثال‌ها:\n * f_3(40); // \"Not define\"\n */\nconst f_3 = (x) => {"}, "canonical_solution": "if (0 <= x && x < 10) {\n        return Math.cos(x + 3.0).toFixed(5);\n    } else if (10 <= x && x < 20) {\n        return Math.pow(Math.cos(x + 7.5), 2).toFixed(5);\n    } else if (20 <= x && x < 30) {\n        return Math.pow(Math.cos(x + 4.0), 4).toFixed(5);\n    } else {\n        return \"Not define\";\n    }\n};", "instruction": {"en": "Write a JavaScript function `const f_3 = (x)` to solve the following problem:\nCalculate the value of the function for a given input.\n\nParameters:\n- x (number): Input value for the function.\n\nReturns:\n- string: If x is not in the defined domain, returns \"Not define\".\nOtherwise, returns the calculated function value as a string rounded to 5 decimal places.\n\nFunction Definitions:\n- For 0 <= x < 10: y = cos(x + 3.0)\n- For 10 <= x < 20: y = (cos(x + 7.5))^2\n- For 20 <= x < 30: y = (cos(x + 4.0))^4\n\nExamples:\nf_3(40); // \"Not define\"\n", "sq": "Shkruani një funksion JavaScript `const f_3 = (x)` për të zgjidhur problemin e mëposhtëm:  \nLlogaritni vlerën e funksionit për një hyrje të dhënë.\n\nParametrat:\n- x (numër): Vlera e hyrjes për funksionin.\n\nKthen:\n- string: Nëse x nuk është në domenin e përcaktuar, kthen \"Not define\".  \nPërndryshe, kthen vlerën e llogaritur të funksionit si një string i rrumbullakosur në 5 vende dhjetore.\n\nPërkufizimet e Funksionit:\n- Për 0 <= x < 10: y = cos(x + 3.0)\n- Për 10 <= x < 20: y = (cos(x + 7.5))^2\n- Për 20 <= x < 30: y = (cos(x + 4.0))^4\n\nShembuj:\nf_3(40); // \"Not define\"", "hy": "Գրեք JavaScript ֆունկցիա `const f_3 = (x)` հետևյալ խնդիրը լուծելու համար:\nՀաշվեք ֆունկցիայի արժեքը տրված մուտքային արժեքի համար։\n\nՊարամետրեր:\n- x (number): Մուտքային արժեք ֆունկցիայի համար։\n\nՎերադարձնում է:\n- string: Եթե x-ը սահմանված տիրույթում չէ, վերադարձնում է \"Not define\"։\nՀակառակ դեպքում, վերադարձնում է հաշվարկված ֆունկցիայի արժեքը որպես տող, կլորացված մինչև 5 տասնորդական թվանշան։\n\nՖունկցիայի սահմանումներ:\n- 0 <= x < 10: y = cos(x + 3.0)\n- 10 <= x < 20: y = (cos(x + 7.5))^2\n- 20 <= x < 30: y = (cos(x + 4.0))^4\n\nՕրինակներ:\nf_3(40); // \"Not define\"", "bn": "একটি জাভাস্ক্রিপ্ট ফাংশন `const f_3 = (x)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি প্রদত্ত ইনপুটের জন্য ফাংশনের মান গণনা করুন।\n\nপ্যারামিটারসমূহ:\n- x (number): ফাংশনের জন্য ইনপুট মান।\n\nরিটার্নস:\n- string: যদি x সংজ্ঞায়িত ডোমেইনে না থাকে, তাহলে \"Not define\" রিটার্ন করে।\nঅন্যথায়, গণনা করা ফাংশনের মান একটি স্ট্রিং হিসাবে ৫ দশমিক স্থান পর্যন্ত রাউন্ড করে রিটার্ন করে।\n\nফাংশনের সংজ্ঞা:\n- 0 <= x < 10 এর জন্য: y = cos(x + 3.0)\n- 10 <= x < 20 এর জন্য: y = (cos(x + 7.5))^2\n- 20 <= x < 30 এর জন্য: y = (cos(x + 4.0))^4\n\nউদাহরণসমূহ:\nf_3(40); // \"Not define\"", "bg": "Напишете JavaScript функция `const f_3 = (x)`, за да решите следния проблем:\nИзчислете стойността на функцията за даден вход.\n\nПараметри:\n- x (number): Входна стойност за функцията.\n\nВръща:\n- string: Ако x не е в определения домейн, връща \"Not define\".\nВ противен случай връща изчислената стойност на функцията като низ, закръглена до 5 знака след десетичната запетая.\n\nОпределения на функцията:\n- За 0 <= x < 10: y = cos(x + 3.0)\n- За 10 <= x < 20: y = (cos(x + 7.5))^2\n- За 20 <= x < 30: y = (cos(x + 4.0))^4\n\nПримери:\nf_3(40); // \"Not define\"", "zh": "编写一个 JavaScript 函数 `const f_3 = (x)` 来解决以下问题：  \n计算给定输入的函数值。\n\n参数：\n- x (number): 函数的输入值。\n\n返回：\n- string: 如果 x 不在定义域内，返回 \"Not define\"。  \n否则，返回计算后的函数值，结果为字符串并四舍五入到小数点后 5 位。\n\n函数定义：\n- 对于 0 <= x < 10: y = cos(x + 3.0)\n- 对于 10 <= x < 20: y = (cos(x + 7.5))^2\n- 对于 20 <= x < 30: y = (cos(x + 4.0))^4\n\n示例：\nf_3(40); // \"Not define\"", "fr": "Écrire une fonction JavaScript `const f_3 = (x)` pour résoudre le problème suivant :\nCalculer la valeur de la fonction pour une entrée donnée.\n\nParamètres :\n- x (number) : Valeur d'entrée pour la fonction.\n\nRenvoie :\n- string : Si x n'est pas dans le domaine défini, renvoie \"Not define\".\nSinon, renvoie la valeur calculée de la fonction sous forme de chaîne arrondie à 5 décimales.\n\nDéfinitions de la fonction :\n- Pour 0 <= x < 10 : y = cos(x + 3.0)\n- Pour 10 <= x < 20 : y = (cos(x + 7.5))^2\n- Pour 20 <= x < 30 : y = (cos(x + 4.0))^4\n\nExemples :\nf_3(40); // \"Not define\"", "de": "Schreiben Sie eine JavaScript-Funktion `const f_3 = (x)`, um das folgende Problem zu lösen:\nBerechnen Sie den Wert der Funktion für eine gegebene Eingabe.\n\nParameter:\n- x (number): Eingabewert für die Funktion.\n\nGibt zurück:\n- string: Wenn x nicht im definierten Bereich liegt, gibt \"Not define\" zurück.\nAndernfalls gibt den berechneten Funktionswert als String gerundet auf 5 Dezimalstellen zurück.\n\nFunktionsdefinitionen:\n- Für 0 <= x < 10: y = cos(x + 3.0)\n- Für 10 <= x < 20: y = (cos(x + 7.5))^2\n- Für 20 <= x < 30: y = (cos(x + 4.0))^4\n\nBeispiele:\nf_3(40); // \"Not define\"", "ha": "Rubuta wani aikin JavaScript `const f_3 = (x)` don warware matsalar mai zuwa:\nLissafa ƙimar aikin don wani shigarwa da aka bayar.\n\nSigogi:\n- x (number): Ƙimar shigarwa don aikin.\n\nMayarwa:\n- string: Idan x ba ya cikin kewayon da aka ayyana, yana mayar da \"Not define\".\nIn ba haka ba, yana mayar da ƙimar aikin da aka lissafa a matsayin kirtani mai zagaye zuwa wurare 5 na goma.\n\nMa'anar Aiki:\n- Don 0 <= x < 10: y = cos(x + 3.0)\n- Don 10 <= x < 20: y = (cos(x + 7.5))^2\n- Don 20 <= x < 30: y = (cos(x + 4.0))^4\n\nMisalai:\nf_3(40); // \"Not define\"", "hi": "`const f_3 = (x)` नामक एक JavaScript फ़ंक्शन लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए इनपुट के लिए फ़ंक्शन का मान गणना करें।\n\nपैरामीटर्स:\n- x (number): फ़ंक्शन के लिए इनपुट मान।\n\nवापसी:\n- string: यदि x परिभाषित डोमेन में नहीं है, तो \"Not define\" लौटाता है।\nअन्यथा, गणना किए गए फ़ंक्शन मान को एक स्ट्रिंग के रूप में 5 दशमलव स्थानों तक राउंड करके लौटाता है।\n\nफ़ंक्शन परिभाषाएँ:\n- 0 <= x < 10 के लिए: y = cos(x + 3.0)\n- 10 <= x < 20 के लिए: y = (cos(x + 7.5))^2\n- 20 <= x < 30 के लिए: y = (cos(x + 4.0))^4\n\nउदाहरण:\nf_3(40); // \"Not define\"", "hu": "Írj egy JavaScript függvényt `const f_3 = (x)` a következő probléma megoldására:\nSzámítsd ki a függvény értékét egy adott bemenetre.\n\nParaméterek:\n- x (szám): A függvény bemeneti értéke.\n\nVisszatérési érték:\n- string: Ha x nincs a meghatározott tartományban, akkor \"Not define\" értéket ad vissza.\nEgyébként a kiszámított függvényértéket adja vissza stringként, 5 tizedesjegyre kerekítve.\n\nFüggvény definíciók:\n- Ha 0 <= x < 10: y = cos(x + 3.0)\n- Ha 10 <= x < 20: y = (cos(x + 7.5))^2\n- Ha 20 <= x < 30: y = (cos(x + 4.0))^4\n\nPéldák:\nf_3(40); // \"Not define\"", "es": "Escribe una función de JavaScript `const f_3 = (x)` para resolver el siguiente problema:\nCalcula el valor de la función para una entrada dada.\n\nParámetros:\n- x (número): Valor de entrada para la función.\n\nDevuelve:\n- string: Si x no está en el dominio definido, devuelve \"Not define\".\nDe lo contrario, devuelve el valor calculado de la función como una cadena redondeada a 5 decimales.\n\nDefiniciones de la función:\n- Para 0 <= x < 10: y = cos(x + 3.0)\n- Para 10 <= x < 20: y = (cos(x + 7.5))^2\n- Para 20 <= x < 30: y = (cos(x + 4.0))^4\n\nEjemplos:\nf_3(40); // \"Not define\"", "arb": "اكتب دالة JavaScript `const f_3 = (x)` لحل المشكلة التالية:\nاحسب قيمة الدالة لإدخال معين.\n\nالمعلمات:\n- x (number): قيمة الإدخال للدالة.\n\nالإرجاع:\n- string: إذا لم يكن x في النطاق المحدد، يُرجع \"Not define\".\nوإلا، يُرجع قيمة الدالة المحسوبة كسلسلة نصية مقربة إلى 5 منازل عشرية.\n\nتعريفات الدالة:\n- لـ 0 <= x < 10: y = cos(x + 3.0)\n- لـ 10 <= x < 20: y = (cos(x + 7.5))^2\n- لـ 20 <= x < 30: y = (cos(x + 4.0))^4\n\nأمثلة:\nf_3(40); // \"Not define\"", "sw": "Andika kazi ya JavaScript `const f_3 = (x)` kutatua tatizo lifuatalo:\nHesabu thamani ya kazi kwa ingizo lililotolewa.\n\nVigezo:\n- x (nambari): Thamani ya ingizo kwa kazi.\n\nRudisha:\n- string: Ikiwa x haipo katika kikoa kilichobainishwa, rudisha \"Not define\".\nVinginevyo, rudisha thamani ya kazi iliyohesabiwa kama string iliyokatwa hadi sehemu 5 za desimali.\n\nUfafanuzi wa Kazi:\n- Kwa 0 <= x < 10: y = cos(x + 3.0)\n- Kwa 10 <= x < 20: y = (cos(x + 7.5))^2\n- Kwa 20 <= x < 30: y = (cos(x + 4.0))^4\n\nMifano:\nf_3(40); // \"Not define\"", "tr": "Bir JavaScript fonksiyonu `const f_3 = (x)` yazın ve aşağıdaki problemi çözün:\nBelirtilen bir giriş için fonksiyonun değerini hesaplayın.\n\nParametreler:\n- x (number): Fonksiyon için giriş değeri.\n\nDöndürülenler:\n- string: Eğer x tanımlı alanda değilse, \"Not define\" döner.\nAksi takdirde, hesaplanan fonksiyon değerini 5 ondalık basamağa yuvarlanmış bir string olarak döner.\n\nFonksiyon Tanımları:\n- 0 <= x < 10 için: y = cos(x + 3.0)\n- 10 <= x < 20 için: y = (cos(x + 7.5))^2\n- 20 <= x < 30 için: y = (cos(x + 4.0))^4\n\nÖrnekler:\nf_3(40); // \"Not define\"", "vi": "Viết một hàm JavaScript `const f_3 = (x)` để giải quyết vấn đề sau:\nTính giá trị của hàm cho một đầu vào đã cho.\n\nTham số:\n- x (number): Giá trị đầu vào cho hàm.\n\nTrả về:\n- string: Nếu x không nằm trong miền xác định, trả về \"Not define\".\nNếu không, trả về giá trị hàm đã tính dưới dạng chuỗi được làm tròn đến 5 chữ số thập phân.\n\nĐịnh nghĩa hàm:\n- Đối với 0 <= x < 10: y = cos(x + 3.0)\n- Đối với 10 <= x < 20: y = (cos(x + 7.5))^2\n- Đối với 20 <= x < 30: y = (cos(x + 4.0))^4\n\nVí dụ:\nf_3(40); // \"Not define\"", "id": "Tulis sebuah fungsi JavaScript `const f_3 = (x)` untuk menyelesaikan masalah berikut:\nHitung nilai fungsi untuk input yang diberikan.\n\nParameter:\n- x (number): Nilai input untuk fungsi.\n\nMengembalikan:\n- string: Jika x tidak dalam domain yang ditentukan, mengembalikan \"Not define\".\nJika tidak, mengembalikan nilai fungsi yang dihitung sebagai string yang dibulatkan hingga 5 tempat desimal.\n\nDefinisi Fungsi:\n- Untuk 0 <= x < 10: y = cos(x + 3.0)\n- Untuk 10 <= x < 20: y = (cos(x + 7.5))^2\n- Untuk 20 <= x < 30: y = (cos(x + 4.0))^4\n\nContoh:\nf_3(40); // \"Not define\"", "ja": "次の問題を解くためのJavaScript関数 `const f_3 = (x)` を作成してください:\n与えられた入力に対して関数の値を計算します。\n\nパラメータ:\n- x (number): 関数の入力値。\n\n戻り値:\n- string: xが定義域にない場合は \"Not define\" を返します。\nそれ以外の場合は、計算された関数の値を小数点以下5桁に丸めた文字列として返します。\n\n関数定義:\n- 0 <= x < 10 の場合: y = cos(x + 3.0)\n- 10 <= x < 20 の場合: y = (cos(x + 7.5))^2\n- 20 <= x < 30 の場合: y = (cos(x + 4.0))^4\n\n例:\nf_3(40); // \"Not define\"", "ko": "JavaScript 함수를 작성하세요 `const f_3 = (x)` 다음 문제를 해결하기 위해:\n주어진 입력에 대한 함수의 값을 계산합니다.\n\n매개변수:\n- x (number): 함수에 대한 입력 값.\n\n반환:\n- string: x가 정의된 도메인에 없으면, \"Not define\"을 반환합니다.\n그렇지 않으면, 계산된 함수 값을 소수점 5자리로 반올림하여 문자열로 반환합니다.\n\n함수 정의:\n- 0 <= x < 10: y = cos(x + 3.0)\n- 10 <= x < 20: y = (cos(x + 7.5))^2\n- 20 <= x < 30: y = (cos(x + 4.0))^4\n\n예시:\nf_3(40); // \"Not define\"", "ml": "`const f_3 = (x)` എന്ന ജാവാസ്ക്രിപ്റ്റ് ഫംഗ്ഷൻ എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nനൽകിയിരിക്കുന്ന ഇൻപുട്ടിനായി ഫംഗ്ഷന്റെ മൂല്യം കണക്കാക്കുക.\n\nപാരാമീറ്ററുകൾ:\n- x (number): ഫംഗ്ഷന്റെ ഇൻപുട്ട് മൂല്യം.\n\nമടക്കുന്നു:\n- string: x നിർവചിച്ചിരിക്കുന്ന ഡൊമെയിനിൽ ഇല്ലെങ്കിൽ, \"Not define\" മടക്കുന്നു.\nഇല്ലെങ്കിൽ, കണക്കാക്കിയ ഫംഗ്ഷൻ മൂല്യം 5 ദശാംശ സ്ഥാനങ്ങളിൽ വട്ടമിട്ട ഒരു സ്ട്രിംഗായി മടക്കുന്നു.\n\nഫംഗ്ഷൻ നിർവചനങ്ങൾ:\n- 0 <= x < 10: y = cos(x + 3.0)\n- 10 <= x < 20: y = (cos(x + 7.5))^2\n- 20 <= x < 30: y = (cos(x + 4.0))^4\n\nഉദാഹരണങ്ങൾ:\nf_3(40); // \"Not define\"", "fa": "یک تابع جاوااسکریپت `const f_3 = (x)` بنویسید تا مسئله زیر را حل کند:\nمقدار تابع را برای یک ورودی مشخص محاسبه کنید.\n\nپارامترها:\n- x (number): مقدار ورودی برای تابع.\n\nبازگشت:\n- string: اگر x در دامنه تعریف شده نباشد، \"Not define\" را برمی‌گرداند.\nدر غیر این صورت، مقدار محاسبه شده تابع را به صورت رشته‌ای با گرد کردن به 5 رقم اعشار برمی‌گرداند.\n\nتعاریف تابع:\n- برای 0 <= x < 10: y = cos(x + 3.0)\n- برای 10 <= x < 20: y = (cos(x + 7.5))^2\n- برای 20 <= x < 30: y = (cos(x + 4.0))^4\n\nمثال‌ها:\nf_3(40); // \"Not define\""}, "level": "easy", "test": "const testf_3 = () => {\n    console.assert(f_3(40) === \"Not define\", \"Test case 40 failed\");\n    console.assert(f_3(5) === \"-0.14550\", \"Test case 5 failed\");\n    console.assert(f_3(15) === \"0.76266\", \"Test case 15 failed\");\n    console.assert(f_3(25) === \"0.31314\", \"Test case 25 failed\");\n    console.assert(f_3(-1) === \"Not define\", \"Test case -1 failed\");\n}\n\ntestf_3();", "entry_point": "f_3", "signature": "const f_3 = (x)", "docstring": {"en": "Calculate the value of the function for a given input.\n\nParameters:\n- x (number): Input value for the function.\n\nReturns:\n- string: If x is not in the defined domain, returns \"Not define\".\nOtherwise, returns the calculated function value as a string rounded to 5 decimal places.\n\nFunction Definitions:\n- For 0 <= x < 10: y = cos(x + 3.0)\n- For 10 <= x < 20: y = (cos(x + 7.5))^2\n- For 20 <= x < 30: y = (cos(x + 4.0))^4\n\nExamples:\nf_3(40); // \"Not define\"\n", "sq": "Llogarit vlerën e funksionit për një hyrje të dhënë.\n\nParametrat:\n- x (numër): Vlera e hyrjes për funksionin.\n\nKthen:\n- string: Nëse x nuk është në domenin e përcaktuar, kthen \"Not define\".\nPërndryshe, kthen vlerën e llogaritur të funksionit si një string i rrumbullakosur në 5 vende dhjetore.\n\nPërkufizimet e Funksionit:\n- Për 0 <= x < 10: y = cos(x + 3.0)\n- Për 10 <= x < 20: y = (cos(x + 7.5))^2\n- Për 20 <= x < 30: y = (cos(x + 4.0))^4\n\nShembuj:\nf_3(40); // \"Not define\"", "hy": "Հաշվել ֆունկցիայի արժեքը տրված մուտքային արժեքի համար։\n\nՊարամետրեր:\n- x (թիվ): Մուտքային արժեք ֆունկցիայի համար։\n\nՎերադարձնում է:\n- string: Եթե x-ն սահմանված տիրույթում չէ, վերադարձնում է \"Not define\"։\nՀակառակ դեպքում, վերադարձնում է հաշվարկված ֆունկցիայի արժեքը որպես տող՝ կլորացված մինչև 5 տասնորդական նշան։\n\nՖունկցիայի սահմանումներ:\n- 0 <= x < 10: y = cos(x + 3.0)\n- 10 <= x < 20: y = (cos(x + 7.5))^2\n- 20 <= x < 30: y = (cos(x + 4.0))^4\n\nՕրինակներ:\nf_3(40); // \"Not define\"", "bn": "প্রদত্ত ইনপুটের জন্য ফাংশনের মান গণনা করুন।\n\nপ্যারামিটারসমূহ:\n- x (সংখ্যা): ফাংশনের জন্য ইনপুট মান।\n\nরিটার্নস:\n- string: যদি x সংজ্ঞায়িত ডোমেইনে না থাকে, \"Not define\" রিটার্ন করে। অন্যথায়, গণনা করা ফাংশনের মান একটি স্ট্রিং হিসাবে রিটার্ন করে যা 5 দশমিক স্থান পর্যন্ত রাউন্ড করা হয়।\n\nফাংশন সংজ্ঞাসমূহ:\n- 0 <= x < 10 এর জন্য: y = cos(x + 3.0)\n- 10 <= x < 20 এর জন্য: y = (cos(x + 7.5))^2\n- 20 <= x < 30 এর জন্য: y = (cos(x + 4.0))^4\n\nউদাহরণসমূহ:\nf_3(40); // \"Not define\"", "bg": "Изчислява стойността на функцията за даден вход.\n\nПараметри:\n- x (number): Входна стойност за функцията.\n\nВръща:\n- string: Ако x не е в определения домейн, връща \"Not define\".\nВ противен случай, връща изчислената стойност на функцията като низ, закръглена до 5 десетични знака.\n\nДефиниции на функцията:\n- За 0 <= x < 10: y = cos(x + 3.0)\n- За 10 <= x < 20: y = (cos(x + 7.5))^2\n- За 20 <= x < 30: y = (cos(x + 4.0))^4\n\nПримери:\nf_3(40); // \"Not define\"", "zh": "计算给定输入的函数值。\n\n参数：\n- x (number): 函数的输入值。\n\n返回：\n- string: 如果 x 不在定义域内，返回 \"Not define\"。\n  否则，返回计算后的函数值，结果为保留 5 位小数的字符串。\n\n函数定义：\n- 对于 0 <= x < 10: y = cos(x + 3.0)\n- 对于 10 <= x < 20: y = (cos(x + 7.5))^2\n- 对于 20 <= x < 30: y = (cos(x + 4.0))^4\n\n示例：\nf_3(40); // \"Not define\"", "fr": "Calculer la valeur de la fonction pour une entrée donnée.\n\nParamètres:\n- x (nombre): Valeur d'entrée pour la fonction.\n\nRenvoie:\n- string: Si x n'est pas dans le domaine défini, renvoie \"Not define\".\nSinon, renvoie la valeur calculée de la fonction sous forme de chaîne arrondie à 5 décimales.\n\nDéfinitions de la fonction:\n- Pour 0 <= x < 10: y = cos(x + 3.0)\n- Pour 10 <= x < 20: y = (cos(x + 7.5))^2\n- Pour 20 <= x < 30: y = (cos(x + 4.0))^4\n\nExemples:\nf_3(40); // \"Not define\"", "de": "Berechne den Wert der Funktion für eine gegebene Eingabe.\n\nParameter:\n- x (number): Eingabewert für die Funktion.\n\nRückgabewerte:\n- string: Wenn x nicht im definierten Bereich liegt, wird \"Not define\" zurückgegeben.\nAndernfalls wird der berechnete Funktionswert als String auf 5 Dezimalstellen gerundet zurückgegeben.\n\nFunktionsdefinitionen:\n- Für 0 <= x < 10: y = cos(x + 3.0)\n- Für 10 <= x < 20: y = (cos(x + 7.5))^2\n- Für 20 <= x < 30: y = (cos(x + 4.0))^4\n\nBeispiele:\nf_3(40); // \"Not define\"", "ha": "Lissafa ƙimar aikin don wani shigarwa da aka bayar.\n\nSigogi:\n- x (namba): Darajar shigarwa don aikin.\n\nDawowa:\n- string: Idan x ba ya cikin kewayon da aka ayyana, yana dawowa \"Not define\".\nIn ba haka ba, yana dawowa da darajar aikin da aka lissafa a matsayin string da aka zagaye zuwa wurare 5 na decimal.\n\nMa'anar Aiki:\n- Don 0 <= x < 10: y = cos(x + 3.0)\n- Don 10 <= x < 20: y = (cos(x + 7.5))^2\n- Don 20 <= x < 30: y = (cos(x + 4.0))^4\n\nMisalai:\nf_3(40); // \"Not define\"", "hi": "दिए गए इनपुट के लिए फ़ंक्शन का मान गणना करें।\n\nपैरामीटर्स:\n- x (संख्या): फ़ंक्शन के लिए इनपुट मान।\n\nवापसी:\n- string: यदि x परिभाषित डोमेन में नहीं है, तो \"Not define\" लौटाता है।\nअन्यथा, गणना की गई फ़ंक्शन का मान एक स्ट्रिंग के रूप में लौटाता है, जो 5 दशमलव स्थानों तक गोल है।\n\nफ़ंक्शन परिभाषाएँ:\n- 0 <= x < 10 के लिए: y = cos(x + 3.0)\n- 10 <= x < 20 के लिए: y = (cos(x + 7.5))^2\n- 20 <= x < 30 के लिए: y = (cos(x + 4.0))^4\n\nउदाहरण:\nf_3(40); // \"Not define\"", "hu": "Számítsa ki a függvény értékét egy adott bemenetre.\n\nParaméterek:\n- x (szám): A függvény bemeneti értéke.\n\nVisszatérési érték:\n- string: Ha x nincs a meghatározott tartományban, \"Not define\" értéket ad vissza.\nEgyébként a kiszámított függvényértéket adja vissza, 5 tizedesjegyre kerekítve, stringként.\n\nFüggvénydefiníciók:\n- Ha 0 <= x < 10: y = cos(x + 3.0)\n- Ha 10 <= x < 20: y = (cos(x + 7.5))^2\n- Ha 20 <= x < 30: y = (cos(x + 4.0))^4\n\nPéldák:\nf_3(40); // \"Not define\"", "es": "Calcular el valor de la función para una entrada dada.\n\nParámetros:\n- x (número): Valor de entrada para la función.\n\nDevuelve:\n- string: Si x no está en el dominio definido, devuelve \"Not define\".\nDe lo contrario, devuelve el valor calculado de la función como una cadena redondeada a 5 decimales.\n\nDefiniciones de Funciones:\n- Para 0 <= x < 10: y = cos(x + 3.0)\n- Para 10 <= x < 20: y = (cos(x + 7.5))^2\n- Para 20 <= x < 30: y = (cos(x + 4.0))^4\n\nEjemplos:\nf_3(40); // \"Not define\"", "arb": "احسب قيمة الدالة لمُدخل مُعطى.\n\nالمعلمات:\n- x (رقم): قيمة الإدخال للدالة.\n\nالقيم المُعادة:\n- سلسلة نصية: إذا لم تكن x في النطاق المحدد، تُعاد \"غير معرف\".\nبخلاف ذلك، تُعاد قيمة الدالة المحسوبة كسلسلة نصية مقربة إلى 5 منازل عشرية.\n\nتعريفات الدوال:\n- لـ 0 <= x < 10: y = cos(x + 3.0)\n- لـ 10 <= x < 20: y = (cos(x + 7.5))^2\n- لـ 20 <= x < 30: y = (cos(x + 4.0))^4\n\nأمثلة:\nf_3(40); // \"غير معرف\"", "sw": "Hesabu thamani ya kazi kwa pembejeo iliyotolewa.\n\nVigezo:\n- x (nambari): Thamani ya pembejeo kwa kazi.\n\nInarejesha:\n- kamba: Ikiwa x haiko kwenye kikoa kilichobainishwa, inarejesha \"Not define\".\nVinginevyo, inarejesha thamani ya kazi iliyohesabiwa kama kamba iliyokatwa hadi sehemu 5 za desimali.\n\nUfafanuzi wa Kazi:\n- Kwa 0 <= x < 10: y = cos(x + 3.0)\n- Kwa 10 <= x < 20: y = (cos(x + 7.5))^2\n- Kwa 20 <= x < 30: y = (cos(x + 4.0))^4\n\nMifano:\nf_3(40); // \"Not define\"", "tr": "Verilen bir giriş için fonksiyonun değerini hesaplayın.\n\nParametreler:\n- x (sayı): Fonksiyon için giriş değeri.\n\nDöndürür:\n- string: Eğer x tanımlı alanda değilse, \"Not define\" döndürür.\nAksi takdirde, hesaplanan fonksiyon değerini 5 ondalık basamağa yuvarlanmış bir string olarak döndürür.\n\nFonksiyon Tanımları:\n- 0 <= x < 10 için: y = cos(x + 3.0)\n- 10 <= x < 20 için: y = (cos(x + 7.5))^2\n- 20 <= x < 30 için: y = (cos(x + 4.0))^4\n\nÖrnekler:\nf_3(40); // \"Not define\"", "vi": "Tính giá trị của hàm cho một đầu vào cho trước.\n\nTham số:\n- x (number): Giá trị đầu vào cho hàm.\n\nTrả về:\n- string: Nếu x không nằm trong miền xác định, trả về \"Not define\".\nNgược lại, trả về giá trị hàm đã tính dưới dạng chuỗi được làm tròn đến 5 chữ số thập phân.\n\nĐịnh nghĩa hàm:\n- Với 0 <= x < 10: y = cos(x + 3.0)\n- Với 10 <= x < 20: y = (cos(x + 7.5))^2\n- Với 20 <= x < 30: y = (cos(x + 4.0))^4\n\nVí dụ:\nf_3(40); // \"Not define\"", "id": "Hitung nilai fungsi untuk input yang diberikan.\n\nParameter:\n- x (number): Nilai input untuk fungsi.\n\nMengembalikan:\n- string: Jika x tidak dalam domain yang ditentukan, mengembalikan \"Not define\".\nJika tidak, mengembalikan nilai fungsi yang dihitung sebagai string yang dibulatkan hingga 5 tempat desimal.\n\nDefinisi Fungsi:\n- Untuk 0 <= x < 10: y = cos(x + 3.0)\n- Untuk 10 <= x < 20: y = (cos(x + 7.5))^2\n- Untuk 20 <= x < 30: y = (cos(x + 4.0))^4\n\nContoh:\nf_3(40); // \"Not define\"", "ja": "関数の値を指定された入力に対して計算します。\n\n引数:\n- x (number): 関数への入力値。\n\n戻り値:\n- string: x が定義された範囲にない場合は \"Not define\" を返します。\nそれ以外の場合は、計算された関数の値を小数点以下5桁に丸めた文字列を返します。\n\n関数定義:\n- 0 <= x < 10 の場合: y = cos(x + 3.0)\n- 10 <= x < 20 の場合: y = (cos(x + 7.5))^2\n- 20 <= x < 30 の場合: y = (cos(x + 4.0))^4\n\n例:\nf_3(40); // \"Not define\"", "ko": "주어진 입력에 대한 함수의 값을 계산합니다.\n\n매개변수:\n- x (number): 함수의 입력 값.\n\n반환:\n- string: x가 정의된 도메인에 없으면 \"Not define\"을 반환합니다.\n그렇지 않으면, 계산된 함수 값을 소수점 5자리로 반올림하여 문자열로 반환합니다.\n\n함수 정의:\n- 0 <= x < 10: y = cos(x + 3.0)\n- 10 <= x < 20: y = (cos(x + 7.5))^2\n- 20 <= x < 30: y = (cos(x + 4.0))^4\n\n예시:\nf_3(40); // \"Not define\"", "ml": "നൽകിയ ഇൻപുട്ടിനായി ഫംഗ്ഷന്റെ മൂല്യം കണക്കാക്കുക.\n\nപാരാമീറ്ററുകൾ:\n- x (number): ഫംഗ്ഷനിലേക്കുള്ള ഇൻപുട്ട് മൂല്യം.\n\nമടക്കങ്ങൾ:\n- string: x നിർവ്വചിച്ചിരിക്കുന്ന ഡൊമെയ്‌നിൽ ഇല്ലെങ്കിൽ, \"Not define\" മടക്കുന്നു.\nഅല്ലെങ്കിൽ, കൃത്യമായ 5 ദശാംശ സ്ഥാനങ്ങളിൽ വൃത്തമാക്കിയ ഫംഗ്ഷൻ മൂല്യം ഒരു സ്ട്രിംഗായി മടക്കുന്നു.\n\nഫംഗ്ഷൻ നിർവ്വചനങ്ങൾ:\n- 0 <= x < 10: y = cos(x + 3.0)\n- 10 <= x < 20: y = (cos(x + 7.5))^2\n- 20 <= x < 30: y = (cos(x + 4.0))^4\n\nഉദാഹരണങ്ങൾ:\nf_3(40); // \"Not define\"", "fa": "محاسبه مقدار تابع برای یک ورودی مشخص.\n\nپارامترها:\n- x (عدد): مقدار ورودی برای تابع.\n\nبازگشت:\n- رشته: اگر x در دامنه تعریف شده نباشد، \"Not define\" را برمی‌گرداند.\nدر غیر این صورت، مقدار محاسبه شده تابع را به صورت رشته‌ای با گرد کردن به 5 رقم اعشار برمی‌گرداند.\n\nتعاریف تابع:\n- برای 0 <= x < 10: y = cos(x + 3.0)\n- برای 10 <= x < 20: y = (cos(x + 7.5))^2\n- برای 20 <= x < 30: y = (cos(x + 4.0))^4\n\nمثال‌ها:\nf_3(40); // \"Not define\""}}
{"task_id": "JavaScript/4", "prompt": {"en": "/**\n * Find the maximum and minimum of three distinct integers.\n *\n * Parameters:\n * a (number): The first integer.\n * b (number): The second integer.\n * c (number): The third integer.\n *\n * Returns:\n * Object: An object with properties 'max' and 'min'.\n *\n * Example call:\n * const result = f_4(1, 2, 3);\n * console.assert(result.max === 3 && result.min === 1);\n */\nfunction f_4(a, b, c)", "sq": "/**\n * Gjeni maksimumin dhe minimumin e tre numrave të plotë të ndryshëm.\n *\n * Parametrat:\n * a (numër): Numri i parë i plotë.\n * b (numër): Numri i dytë i plotë.\n * c (numër): Numri i tretë i plotë.\n *\n * Kthen:\n * Objekt: Një objekt me pronat 'max' dhe 'min'.\n *\n * Shembull thirrjeje:\n * const result = f_4(1, 2, 3);\n * console.assert(result.max === 3 && result.min === 1);\n */\nfunction f_4(a, b, c)", "hy": "/**\n * Գտնել երեք տարբեր ամբողջ թվերի առավելագույնն ու նվազագույնը։\n *\n * Պարամետրեր:\n * a (number): Առաջին ամբողջ թիվը։\n * b (number): Երկրորդ ամբողջ թիվը։\n * c (number): Երրորդ ամբողջ թիվը։\n *\n * Վերադարձնում է:\n * Object: Օբյեկտ՝ 'max' և 'min' հատկություններով։\n *\n * Օրինակ կանչ:\n * const result = f_4(1, 2, 3);\n * console.assert(result.max === 3 && result.min === 1);\n */\nfunction f_4(a, b, c)", "bn": "/**\n * তিনটি ভিন্ন পূর্ণসংখ্যার মধ্যে সর্বাধিক এবং সর্বনিম্ন খুঁজে বের করুন।\n *\n * প্যারামিটার:\n * a (number): প্রথম পূর্ণসংখ্যা।\n * b (number): দ্বিতীয় পূর্ণসংখ্যা।\n * c (number): তৃতীয় পূর্ণসংখ্যা।\n *\n * রিটার্নস:\n * অবজেক্ট: 'max' এবং 'min' প্রপার্টি সহ একটি অবজেক্ট।\n *\n * উদাহরণ কল:\n * const result = f_4(1, 2, 3);\n * console.assert(result.max === 3 && result.min === 1);\n */\nfunction f_4(a, b, c)", "bg": "/**\n * Намерете максимума и минимума на три различни цели числа.\n *\n * Параметри:\n * a (number): Първото цяло число.\n * b (number): Второто цяло число.\n * c (number): Третото цяло число.\n *\n * Връща:\n * Object: Обект със свойства 'max' и 'min'.\n *\n * Пример за извикване:\n * const result = f_4(1, 2, 3);\n * console.assert(result.max === 3 && result.min === 1);\n */\nfunction f_4(a, b, c)", "zh": "/**\n * 找到三个不同整数的最大值和最小值。\n *\n * 参数:\n * a (number): 第一个整数。\n * b (number): 第二个整数。\n * c (number): 第三个整数。\n *\n * 返回:\n * Object: 一个包含 'max' 和 'min' 属性的对象。\n *\n * 示例调用:\n * const result = f_4(1, 2, 3);\n * console.assert(result.max === 3 && result.min === 1);\n */\nfunction f_4(a, b, c)", "fr": "/**\n * Trouver le maximum et le minimum de trois entiers distincts.\n *\n * Paramètres :\n * a (nombre) : Le premier entier.\n * b (nombre) : Le deuxième entier.\n * c (nombre) : Le troisième entier.\n *\n * Renvoie :\n * Objet : Un objet avec les propriétés 'max' et 'min'.\n *\n * Exemple d'appel :\n * const result = f_4(1, 2, 3);\n * console.assert(result.max === 3 && result.min === 1);\n */\nfunction f_4(a, b, c)", "de": "/**\n * Finde das Maximum und Minimum von drei verschiedenen ganzen Zahlen.\n *\n * Parameter:\n * a (number): Die erste ganze Zahl.\n * b (number): Die zweite ganze Zahl.\n * c (number): Die dritte ganze Zahl.\n *\n * Rückgabe:\n * Objekt: Ein Objekt mit den Eigenschaften 'max' und 'min'.\n *\n * Beispielaufruf:\n * const result = f_4(1, 2, 3);\n * console.assert(result.max === 3 && result.min === 1);\n */\nfunction f_4(a, b, c)", "ha": "/**\n * Nemo mafi girma da mafi ƙanƙanta daga cikin lambobi guda uku daban-daban.\n *\n * Sigogi:\n * a (lamba): Lamba ta farko.\n * b (lamba): Lamba ta biyu.\n * c (lamba): Lamba ta uku.\n *\n * Komawa:\n * Abu: Abu tare da dukiyoyi 'max' da 'min'.\n *\n * Misali kira:\n * const result = f_4(1, 2, 3);\n * console.assert(result.max === 3 && result.min === 1);\n */\nfunction f_4(a, b, c)", "hi": "/**\n * तीन भिन्न पूर्णांकों का अधिकतम और न्यूनतम मान खोजें।\n *\n * पैरामीटर्स:\n * a (number): पहला पूर्णांक।\n * b (number): दूसरा पूर्णांक।\n * c (number): तीसरा पूर्णांक।\n *\n * रिटर्न:\n * Object: एक ऑब्जेक्ट जिसमें 'max' और 'min' गुण होते हैं।\n *\n * उदाहरण कॉल:\n * const result = f_4(1, 2, 3);\n * console.assert(result.max === 3 && result.min === 1);\n */\nfunction f_4(a, b, c)", "hu": "/**\n * Három különböző egész szám maximumának és minimumának meghatározása.\n *\n * Paraméterek:\n * a (szám): Az első egész szám.\n * b (szám): A második egész szám.\n * c (szám): A harmadik egész szám.\n *\n * Visszatérési érték:\n * Objektum: Egy objektum 'max' és 'min' tulajdonságokkal.\n *\n * Példa hívás:\n * const result = f_4(1, 2, 3);\n * console.assert(result.max === 3 && result.min === 1);\n */\nfunction f_4(a, b, c)", "es": "/**\n * Encuentra el máximo y el mínimo de tres enteros distintos.\n *\n * Parámetros:\n * a (number): El primer entero.\n * b (number): El segundo entero.\n * c (number): El tercer entero.\n *\n * Devuelve:\n * Object: Un objeto con propiedades 'max' y 'min'.\n *\n * Ejemplo de llamada:\n * const result = f_4(1, 2, 3);\n * console.assert(result.max === 3 && result.min === 1);\n */\nfunction f_4(a, b, c)", "arb": "/**\n * إيجاد القيمة العظمى والصغرى لثلاثة أعداد صحيحة مختلفة.\n *\n * المعاملات:\n * a (number): العدد الصحيح الأول.\n * b (number): العدد الصحيح الثاني.\n * c (number): العدد الصحيح الثالث.\n *\n * يعيد:\n * Object: كائن يحتوي على خصائص 'max' و 'min'.\n *\n * مثال على الاستدعاء:\n * const result = f_4(1, 2, 3);\n * console.assert(result.max === 3 && result.min === 1);\n */\nfunction f_4(a, b, c)", "sw": "/**\n * Pata kubwa na ndogo kati ya nambari tatu tofauti.\n *\n * Vigezo:\n * a (nambari): Nambari ya kwanza.\n * b (nambari): Nambari ya pili.\n * c (nambari): Nambari ya tatu.\n *\n * Inarudisha:\n * Kitu: Kitu chenye sifa 'max' na 'min'.\n *\n * Mfano wa kupiga simu:\n * const result = f_4(1, 2, 3);\n * console.assert(result.max === 3 && result.min === 1);\n */\nfunction f_4(a, b, c)", "tr": "/**\n * Üç farklı tam sayının maksimum ve minimumunu bulun.\n *\n * Parametreler:\n * a (sayı): Birinci tam sayı.\n * b (sayı): İkinci tam sayı.\n * c (sayı): Üçüncü tam sayı.\n *\n * Döndürür:\n * Nesne: 'max' ve 'min' özelliklerine sahip bir nesne.\n *\n * Örnek çağrı:\n * const result = f_4(1, 2, 3);\n * console.assert(result.max === 3 && result.min === 1);\n */\nfunction f_4(a, b, c)", "vi": "/**\n * Tìm giá trị lớn nhất và nhỏ nhất của ba số nguyên khác nhau.\n *\n * Tham số:\n * a (number): Số nguyên thứ nhất.\n * b (number): Số nguyên thứ hai.\n * c (number): Số nguyên thứ ba.\n *\n * Trả về:\n * Object: Một đối tượng với các thuộc tính 'max' và 'min'.\n *\n * Ví dụ gọi:\n * const result = f_4(1, 2, 3);\n * console.assert(result.max === 3 && result.min === 1);\n */\nfunction f_4(a, b, c)", "id": "/**\n * Menemukan nilai maksimum dan minimum dari tiga bilangan bulat yang berbeda.\n *\n * Parameter:\n * a (number): Bilangan bulat pertama.\n * b (number): Bilangan bulat kedua.\n * c (number): Bilangan bulat ketiga.\n *\n * Mengembalikan:\n * Object: Sebuah objek dengan properti 'max' dan 'min'.\n *\n * Contoh pemanggilan:\n * const result = f_4(1, 2, 3);\n * console.assert(result.max === 3 && result.min === 1);\n */\nfunction f_4(a, b, c)", "ja": "/**\n * 3つの異なる整数の最大値と最小値を見つけます。\n *\n * パラメータ:\n * a (number): 最初の整数。\n * b (number): 2番目の整数。\n * c (number): 3番目の整数。\n *\n * 戻り値:\n * Object: 'max'と'min'のプロパティを持つオブジェクト。\n *\n * 呼び出し例:\n * const result = f_4(1, 2, 3);\n * console.assert(result.max === 3 && result.min === 1);\n */\nfunction f_4(a, b, c)", "ko": "/**\n * 세 개의 서로 다른 정수의 최대값과 최소값을 찾습니다.\n *\n * 매개변수:\n * a (number): 첫 번째 정수.\n * b (number): 두 번째 정수.\n * c (number): 세 번째 정수.\n *\n * 반환값:\n * Object: 'max'와 'min' 속성을 가진 객체.\n *\n * 예시 호출:\n * const result = f_4(1, 2, 3);\n * console.assert(result.max === 3 && result.min === 1);\n */\nfunction f_4(a, b, c)", "ml": "/**\n * മൂന്ന് വ്യത്യസ്തമായ പൂർണ്ണസംഖ്യകളുടെ പരമാവധിയും കുറഞ്ഞതും കണ്ടെത്തുക.\n *\n * പാരാമീറ്ററുകൾ:\n * a (number): ആദ്യ പൂർണ്ണസംഖ്യ.\n * b (number): രണ്ടാം പൂർണ്ണസംഖ്യ.\n * c (number): മൂന്നാം പൂർണ്ണസംഖ്യ.\n *\n * മടക്കുന്നു:\n * Object: 'max' and 'min' എന്ന ഗുണങ്ങളുള്ള ഒരു ഓബ്ജക്റ്റ്.\n *\n * ഉദാഹരണ വിളി:\n * const result = f_4(1, 2, 3);\n * console.assert(result.max === 3 && result.min === 1);\n */\nfunction f_4(a, b, c)", "fa": "/**\n * حداکثر و حداقل سه عدد صحیح متمایز را پیدا کنید.\n *\n * پارامترها:\n * a (number): عدد صحیح اول.\n * b (number): عدد صحیح دوم.\n * c (number): عدد صحیح سوم.\n *\n * بازگشت:\n * Object: یک شیء با ویژگی‌های 'max' و 'min'.\n *\n * مثال فراخوانی:\n * const result = f_4(1, 2, 3);\n * console.assert(result.max === 3 && result.min === 1);\n */\nfunction f_4(a, b, c)"}, "canonical_solution": "{\n    let max, min;\n    \n    if (a > b) {\n        if (a > c) {\n            max = a;\n            min = (b < c) ? b : c;\n        } else {\n            max = c;\n            min = b;\n        }\n    } else {\n        if (b > c) {\n            max = b;\n            min = (a < c) ? a : c;\n        } else {\n            max = c;\n            min = a;\n        }\n    }\n\n    return { max, min };\n}", "instruction": {"en": "Write a JavaScript function `function f_4(a, b, c)` to solve the following problem:\nFind the maximum and minimum of three distinct integers.\n\nParameters:\n- a (number): The first integer.\n- b (number): The second integer.\n- c (number): The third integer.\n\nReturns:\n- Object: An object with properties 'max' and 'min'.\n\nExample call:\nconst result = f_4(1, 2, 3);\nconsole.assert(result.max === 3 && result.min === 1);", "sq": "Shkruani një funksion JavaScript `function f_4(a, b, c)` për të zgjidhur problemin e mëposhtëm:\nGjeni maksimumin dhe minimumin e tre numrave të plotë të ndryshëm.\n\nParametrat:\n- a (numër): Numri i parë i plotë.\n- b (numër): Numri i dytë i plotë.\n- c (numër): Numri i tretë i plotë.\n\nKthen:\n- Objekt: Një objekt me pronat 'max' dhe 'min'.\n\nShembull thirrjeje:\nconst result = f_4(1, 2, 3);\nconsole.assert(result.max === 3 && result.min === 1);", "hy": "Գրեք JavaScript ֆունկցիա `function f_4(a, b, c)` հետևյալ խնդիրը լուծելու համար:\nԳտնել երեք տարբեր ամբողջ թվերի առավելագույնն ու նվազագույնը։\n\nՊարամետրեր:\n- a (number): Առաջին ամբողջ թիվը։\n- b (number): Երկրորդ ամբողջ թիվը։\n- c (number): Երրորդ ամբողջ թիվը։\n\nՎերադարձնում է:\n- Object: Օբյեկտ, որը պարունակում է 'max' և 'min' հատկությունները։\n\nՕրինակ կանչ:\nconst result = f_4(1, 2, 3);\nconsole.assert(result.max === 3 && result.min === 1);", "bn": "একটি JavaScript ফাংশন `function f_4(a, b, c)` লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\nতিনটি পৃথক পূর্ণসংখ্যার সর্বাধিক এবং সর্বনিম্ন খুঁজুন।\n\nপ্যারামিটারসমূহ:\n- a (number): প্রথম পূর্ণসংখ্যা।\n- b (number): দ্বিতীয় পূর্ণসংখ্যা।\n- c (number): তৃতীয় পূর্ণসংখ্যা।\n\nফেরত:\n- Object: একটি অবজেক্ট যার প্রপার্টি 'max' এবং 'min'।\n\nউদাহরণ কল:\nconst result = f_4(1, 2, 3);\nconsole.assert(result.max === 3 && result.min === 1);", "bg": "Напишете JavaScript функция `function f_4(a, b, c)` за решаване на следния проблем:\nНамерете максимума и минимума на три различни цели числа.\n\nПараметри:\n- a (number): Първото цяло число.\n- b (number): Второто цяло число.\n- c (number): Третото цяло число.\n\nВръща:\n- Обект: Обект със свойства 'max' и 'min'.\n\nПримерно извикване:\nconst result = f_4(1, 2, 3);\nconsole.assert(result.max === 3 && result.min === 1);", "zh": "编写一个 JavaScript 函数 `function f_4(a, b, c)` 来解决以下问题：\n找出三个不同整数的最大值和最小值。\n\n参数：\n- a (number): 第一个整数。\n- b (number): 第二个整数。\n- c (number): 第三个整数。\n\n返回：\n- Object: 一个包含 'max' 和 'min' 属性的对象。\n\n示例调用：\nconst result = f_4(1, 2, 3);\nconsole.assert(result.max === 3 && result.min === 1);", "fr": "Écrire une fonction JavaScript `function f_4(a, b, c)` pour résoudre le problème suivant :  \nTrouver le maximum et le minimum de trois entiers distincts.\n\nParamètres :\n- a (number): Le premier entier.\n- b (number): Le deuxième entier.\n- c (number): Le troisième entier.\n\nRenvoie :\n- Object: Un objet avec les propriétés 'max' et 'min'.\n\nExemple d'appel :\nconst result = f_4(1, 2, 3);\nconsole.assert(result.max === 3 && result.min === 1);", "de": "Schreiben Sie eine JavaScript-Funktion `function f_4(a, b, c)`, um das folgende Problem zu lösen:\nFinden Sie das Maximum und Minimum von drei verschiedenen ganzen Zahlen.\n\nParameter:\n- a (number): Die erste ganze Zahl.\n- b (number): Die zweite ganze Zahl.\n- c (number): Die dritte ganze Zahl.\n\nRückgabewert:\n- Objekt: Ein Objekt mit den Eigenschaften 'max' und 'min'.\n\nBeispielaufruf:\nconst result = f_4(1, 2, 3);\nconsole.assert(result.max === 3 && result.min === 1);", "ha": "Rubuta wani aikin JavaScript `function f_4(a, b, c)` don warware matsalar mai zuwa:\nNemo mafi girma da mafi ƙanƙanta daga cikin lambobi guda uku masu banbanci.\n\nSigogi:\n- a (number): Lamba ta farko.\n- b (number): Lamba ta biyu.\n- c (number): Lamba ta uku.\n\nKomawa:\n- Object: Wani abu tare da kaddarorin 'max' da 'min'.\n\nMisalin kira:\nconst result = f_4(1, 2, 3);\nconsole.assert(result.max === 3 && result.min === 1);", "hi": "एक जावास्क्रिप्ट फ़ंक्शन `function f_4(a, b, c)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nतीन भिन्न पूर्णांकों का अधिकतम और न्यूनतम मान खोजें।\n\nपैरामीटर्स:\n- a (number): पहला पूर्णांक।\n- b (number): दूसरा पूर्णांक।\n- c (number): तीसरा पूर्णांक।\n\nवापसी मान:\n- Object: एक ऑब्जेक्ट जिसमें 'max' और 'min' गुण होते हैं।\n\nउदाहरण कॉल:\nconst result = f_4(1, 2, 3);\nconsole.assert(result.max === 3 && result.min === 1);", "hu": "Írj egy JavaScript függvényt `function f_4(a, b, c)` a következő probléma megoldására:\nTaláld meg három különböző egész szám maximumát és minimumát.\n\nParaméterek:\n- a (number): Az első egész szám.\n- b (number): A második egész szám.\n- c (number): A harmadik egész szám.\n\nVisszatérési érték:\n- Object: Egy objektum 'max' és 'min' tulajdonságokkal.\n\nPélda hívás:\nconst result = f_4(1, 2, 3);\nconsole.assert(result.max === 3 && result.min === 1);", "es": "Escribe una función de JavaScript `function f_4(a, b, c)` para resolver el siguiente problema:\nEncuentra el máximo y el mínimo de tres enteros distintos.\n\nParámetros:\n- a (number): El primer entero.\n- b (number): El segundo entero.\n- c (number): El tercer entero.\n\nDevuelve:\n- Object: Un objeto con las propiedades 'max' y 'min'.\n\nEjemplo de llamada:\nconst result = f_4(1, 2, 3);\nconsole.assert(result.max === 3 && result.min === 1);", "arb": "اكتب دالة JavaScript `function f_4(a, b, c)` لحل المشكلة التالية:\nابحث عن القيمة القصوى والدنيا لثلاثة أعداد صحيحة مميزة.\n\nالمعلمات:\n- a (number): العدد الصحيح الأول.\n- b (number): العدد الصحيح الثاني.\n- c (number): العدد الصحيح الثالث.\n\nالإرجاع:\n- Object: كائن يحتوي على الخصائص 'max' و 'min'.\n\nمثال على الاستدعاء:\nconst result = f_4(1, 2, 3);\nconsole.assert(result.max === 3 && result.min === 1);", "sw": "Andika kazi ya JavaScript `function f_4(a, b, c)` kutatua tatizo lifuatalo:\nPata kiwango cha juu na cha chini cha nambari tatu tofauti za mzima.\n\nVigezo:\n- a (nambari): Nambari ya kwanza ya mzima.\n- b (nambari): Nambari ya pili ya mzima.\n- c (nambari): Nambari ya tatu ya mzima.\n\nInarudisha:\n- Kitu: Kitu chenye mali 'max' na 'min'.\n\nMfano wa kupiga simu:\nconst result = f_4(1, 2, 3);\nconsole.assert(result.max === 3 && result.min === 1);", "tr": "Bir JavaScript fonksiyonu `function f_4(a, b, c)` yazın ve aşağıdaki problemi çözün:\nÜç farklı tam sayının maksimum ve minimumunu bulun.\n\nParametreler:\n- a (number): Birinci tam sayı.\n- b (number): İkinci tam sayı.\n- c (number): Üçüncü tam sayı.\n\nDöndürür:\n- Object: 'max' ve 'min' özelliklerine sahip bir nesne.\n\nÖrnek çağrı:\nconst result = f_4(1, 2, 3);\nconsole.assert(result.max === 3 && result.min === 1);", "vi": "Viết một hàm JavaScript `function f_4(a, b, c)` để giải quyết vấn đề sau:\nTìm giá trị lớn nhất và nhỏ nhất của ba số nguyên khác nhau.\n\nTham số:\n- a (number): Số nguyên thứ nhất.\n- b (number): Số nguyên thứ hai.\n- c (number): Số nguyên thứ ba.\n\nTrả về:\n- Object: Một đối tượng với các thuộc tính 'max' và 'min'.\n\nVí dụ gọi:\nconst result = f_4(1, 2, 3);\nconsole.assert(result.max === 3 && result.min === 1);", "id": "Tulis sebuah fungsi JavaScript `function f_4(a, b, c)` untuk menyelesaikan masalah berikut:\nTemukan nilai maksimum dan minimum dari tiga bilangan bulat yang berbeda.\n\nParameter:\n- a (number): Bilangan bulat pertama.\n- b (number): Bilangan bulat kedua.\n- c (number): Bilangan bulat ketiga.\n\nMengembalikan:\n- Object: Sebuah objek dengan properti 'max' dan 'min'.\n\nContoh pemanggilan:\nconst result = f_4(1, 2, 3);\nconsole.assert(result.max === 3 && result.min === 1);", "ja": "JavaScript関数 `function f_4(a, b, c)` を作成して、次の問題を解決してください:\n3つの異なる整数の最大値と最小値を見つける。\n\nパラメータ:\n- a (number): 最初の整数。\n- b (number): 2番目の整数。\n- c (number): 3番目の整数。\n\n戻り値:\n- Object: 'max' と 'min' プロパティを持つオブジェクト。\n\n例の呼び出し:\nconst result = f_4(1, 2, 3);\nconsole.assert(result.max === 3 && result.min === 1);", "ko": "JavaScript 함수를 작성하세요 `function f_4(a, b, c)` 다음 문제를 해결하기 위해:\n세 개의 서로 다른 정수의 최대값과 최소값을 찾으세요.\n\n매개변수:\n- a (number): 첫 번째 정수.\n- b (number): 두 번째 정수.\n- c (number): 세 번째 정수.\n\n반환값:\n- Object: 'max'와 'min' 속성을 가진 객체.\n\n예시 호출:\nconst result = f_4(1, 2, 3);\nconsole.assert(result.max === 3 && result.min === 1);", "ml": "`function f_4(a, b, c)` എന്ന JavaScript ഫംഗ്ഷൻ എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കുന്നതിന്:  \nമൂന്ന് വ്യത്യസ്തമായ പൂർണ്ണസംഖ്യകളുടെ പരമാവധിയും കുറഞ്ഞതും കണ്ടെത്തുക.\n\nപാരാമീറ്ററുകൾ:\n- a (number): ആദ്യ പൂർണ്ണസംഖ്യ.\n- b (number): രണ്ടാം പൂർണ്ണസംഖ്യ.\n- c (number): മൂന്നാം പൂർണ്ണസംഖ്യ.\n\nമടക്കുക:\n- Object: 'max' and 'min' എന്ന പ്രോപ്പർട്ടികൾ ഉള്ള ഒരു ഒബ്ജക്റ്റ്.\n\nഉദാഹരണ കോൾ:\nconst result = f_4(1, 2, 3);\nconsole.assert(result.max === 3 && result.min === 1);", "fa": "یک تابع جاوااسکریپت `function f_4(a, b, c)` بنویسید تا مسئله زیر را حل کند:\nحداکثر و حداقل سه عدد صحیح متمایز را پیدا کنید.\n\nپارامترها:\n- a (number): عدد صحیح اول.\n- b (number): عدد صحیح دوم.\n- c (number): عدد صحیح سوم.\n\nبازگشتی:\n- Object: یک شیء با ویژگی‌های 'max' و 'min'.\n\nمثال فراخوانی:\nconst result = f_4(1, 2, 3);\nconsole.assert(result.max === 3 && result.min === 1);"}, "level": "middle", "test": "function testf_4() {\n    let result = f_4(1, 2, 3);\n    console.assert(result.max === 3 && result.min === 1);\n\n    // Additional tests\n    result = f_4(5, 3, 4);\n    console.assert(result.max === 5 && result.min === 3);\n\n    result = f_4(10, -2, 7);\n    console.assert(result.max === 10 && result.min === -2);\n\n    result = f_4(-1, -3, -2);\n    console.assert(result.max === -1 && result.min === -3);\n}\n\ntestf_4();", "entry_point": "f_4", "signature": "function f_4(a, b, c)", "docstring": {"en": "Find the maximum and minimum of three distinct integers.\n\nParameters:\n- a (number): The first integer.\n- b (number): The second integer.\n- c (number): The third integer.\n\nReturns:\n- Object: An object with properties 'max' and 'min'.\n\nExample call:\nconst result = f_4(1, 2, 3);\nconsole.assert(result.max === 3 && result.min === 1);", "sq": "Gjeni maksimumin dhe minimumin e tre numrave të plotë të ndryshëm.\n\nParametrat:\n- a (numër): Numri i parë i plotë.\n- b (numër): Numri i dytë i plotë.\n- c (numër): Numri i tretë i plotë.\n\nKthen:\n- Objekt: Një objekt me pronat 'max' dhe 'min'.\n\nShembull thirrjeje:\nconst result = f_4(1, 2, 3);\nconsole.assert(result.max === 3 && result.min === 1);", "hy": "Գտնել երեք տարբեր ամբողջ թվերի առավելագույնն ու նվազագույնը։\n\nՊարամետրեր՝\n- a (number): Առաջին ամբողջ թիվը։\n- b (number): Երկրորդ ամբողջ թիվը։\n- c (number): Երրորդ ամբողջ թիվը։\n\nՎերադարձնում է՝\n- Object: Օբյեկտ, որը պարունակում է 'max' և 'min' հատկությունները։\n\nՕրինակ կանչ՝\nconst result = f_4(1, 2, 3);\nconsole.assert(result.max === 3 && result.min === 1);", "bn": "তিনটি ভিন্ন পূর্ণসংখ্যার মধ্যে সর্বাধিক এবং সর্বনিম্ন খুঁজে বের করুন।\n\nপ্যারামিটারসমূহ:\n- a (number): প্রথম পূর্ণসংখ্যা।\n- b (number): দ্বিতীয় পূর্ণসংখ্যা।\n- c (number): তৃতীয় পূর্ণসংখ্যা।\n\nরিটার্নস:\n- অবজেক্ট: একটি অবজেক্ট যার প্রপার্টি 'max' এবং 'min'।\n\nউদাহরণ কল:\nconst result = f_4(1, 2, 3);\nconsole.assert(result.max === 3 && result.min === 1);", "bg": "Намерете максимума и минимума на три различни цели числа.\n\nПараметри:\n- a (number): Първото цяло число.\n- b (number): Второто цяло число.\n- c (number): Третото цяло число.\n\nВръща:\n- Object: Обект със свойства 'max' и 'min'.\n\nПример за извикване:\nconst result = f_4(1, 2, 3);\nconsole.assert(result.max === 3 && result.min === 1);", "zh": "找出三个不同整数的最大值和最小值。\n\n参数：\n- a (number): 第一个整数。\n- b (number): 第二个整数。\n- c (number): 第三个整数。\n\n返回：\n- Object: 一个包含属性 'max' 和 'min' 的对象。\n\n示例调用：\nconst result = f_4(1, 2, 3);\nconsole.assert(result.max === 3 && result.min === 1);", "fr": "Trouver le maximum et le minimum de trois entiers distincts.\n\nParamètres:\n- a (nombre): Le premier entier.\n- b (nombre): Le deuxième entier.\n- c (nombre): Le troisième entier.\n\nRenvoie:\n- Objet: Un objet avec les propriétés 'max' et 'min'.\n\nExemple d'appel:\nconst result = f_4(1, 2, 3);\nconsole.assert(result.max === 3 && result.min === 1);", "de": "Finde das Maximum und Minimum von drei verschiedenen ganzen Zahlen.\n\nParameter:\n- a (number): Die erste ganze Zahl.\n- b (number): Die zweite ganze Zahl.\n- c (number): Die dritte ganze Zahl.\n\nRückgabewert:\n- Objekt: Ein Objekt mit den Eigenschaften 'max' und 'min'.\n\nBeispielaufruf:\nconst result = f_4(1, 2, 3);\nconsole.assert(result.max === 3 && result.min === 1);", "ha": "Nemo mafi girma da mafi ƙanƙanta daga cikin lambobi guda uku daban-daban.\n\nSigogi:\n- a (number): Lamba na farko.\n- b (number): Lamba na biyu.\n- c (number): Lamba na uku.\n\nDawowa:\n- Abu: Abu tare da kaddarorin 'max' da 'min'.\n\nMisalin kira:\nconst result = f_4(1, 2, 3);\nconsole.assert(result.max === 3 && result.min === 1);", "hi": "तीन भिन्न पूर्णांकों का अधिकतम और न्यूनतम मान खोजें।\n\nपैरामीटर्स:\n- a (संख्या): पहला पूर्णांक।\n- b (संख्या): दूसरा पूर्णांक।\n- c (संख्या): तीसरा पूर्णांक।\n\nवापसी:\n- वस्तु: एक वस्तु जिसमें 'max' और 'min' गुण होते हैं।\n\nउदाहरण कॉल:\nconst result = f_4(1, 2, 3);\nconsole.assert(result.max === 3 && result.min === 1);", "hu": "Három különböző egész szám maximumának és minimumának meghatározása.\n\nParaméterek:\n- a (szám): Az első egész szám.\n- b (szám): A második egész szám.\n- c (szám): A harmadik egész szám.\n\nVisszatérési érték:\n- Objektum: Egy objektum 'max' és 'min' tulajdonságokkal.\n\nPélda hívás:\nconst result = f_4(1, 2, 3);\nconsole.assert(result.max === 3 && result.min === 1);", "es": "Encontrar el máximo y el mínimo de tres enteros distintos.\n\nParámetros:\n- a (número): El primer entero.\n- b (número): El segundo entero.\n- c (número): El tercer entero.\n\nDevuelve:\n- Objeto: Un objeto con las propiedades 'max' y 'min'.\n\nEjemplo de llamada:\nconst result = f_4(1, 2, 3);\nconsole.assert(result.max === 3 && result.min === 1);", "arb": "إيجاد القيمة القصوى والدنيا لثلاثة أعداد صحيحة مميزة.\n\nالمعلمات:\n- a (رقم): العدد الصحيح الأول.\n- b (رقم): العدد الصحيح الثاني.\n- c (رقم): العدد الصحيح الثالث.\n\nالقيم المعادة:\n- كائن: كائن يحتوي على الخصائص 'max' و 'min'.\n\nمثال على الاستدعاء:\nconst result = f_4(1, 2, 3);\nconsole.assert(result.max === 3 && result.min === 1);", "sw": "Pata kubwa zaidi na ndogo zaidi ya nambari tatu tofauti.\n\nVigezo:\n- a (nambari): Nambari ya kwanza.\n- b (nambari): Nambari ya pili.\n- c (nambari): Nambari ya tatu.\n\nRudisha:\n- Kitu: Kitu chenye sifa 'max' na 'min'.\n\nMfano wa kupiga:\nconst result = f_4(1, 2, 3);\nconsole.assert(result.max === 3 && result.min === 1);", "tr": "Üç farklı tam sayının maksimum ve minimumunu bulun.\n\nParametreler:\n- a (sayı): Birinci tam sayı.\n- b (sayı): İkinci tam sayı.\n- c (sayı): Üçüncü tam sayı.\n\nDöndürülenler:\n- Nesne: 'max' ve 'min' özelliklerine sahip bir nesne.\n\nÖrnek çağrı:\nconst result = f_4(1, 2, 3);\nconsole.assert(result.max === 3 && result.min === 1);", "vi": "Tìm giá trị lớn nhất và nhỏ nhất của ba số nguyên khác nhau.\n\nTham số:\n- a (number): Số nguyên thứ nhất.\n- b (number): Số nguyên thứ hai.\n- c (number): Số nguyên thứ ba.\n\nTrả về:\n- Object: Một đối tượng với các thuộc tính 'max' và 'min'.\n\nVí dụ gọi:\nconst result = f_4(1, 2, 3);\nconsole.assert(result.max === 3 && result.min === 1);", "id": "Temukan nilai maksimum dan minimum dari tiga bilangan bulat yang berbeda.\n\nParameter:\n- a (number): Bilangan bulat pertama.\n- b (number): Bilangan bulat kedua.\n- c (number): Bilangan bulat ketiga.\n\nMengembalikan:\n- Object: Sebuah objek dengan properti 'max' dan 'min'.\n\nContoh pemanggilan:\nconst result = f_4(1, 2, 3);\nconsole.assert(result.max === 3 && result.min === 1);", "ja": "3つの異なる整数の最大値と最小値を見つけます。\n\n引数:\n- a (number): 最初の整数。\n- b (number): 2番目の整数。\n- c (number): 3番目の整数。\n\n戻り値:\n- Object: 'max'と'min'のプロパティを持つオブジェクト。\n\n例:\nconst result = f_4(1, 2, 3);\nconsole.assert(result.max === 3 && result.min === 1);", "ko": "세 개의 서로 다른 정수의 최대값과 최소값을 찾습니다.\n\n매개변수:\n- a (number): 첫 번째 정수.\n- b (number): 두 번째 정수.\n- c (number): 세 번째 정수.\n\n반환값:\n- Object: 'max'와 'min' 속성을 가진 객체.\n\n예제 호출:\nconst result = f_4(1, 2, 3);\nconsole.assert(result.max === 3 && result.min === 1);", "ml": "മൂന്ന് വ്യത്യസ്തമായ പൂർണ്ണസംഖ്യകളുടെ പരമാവധിയും കുറഞ്ഞതും കണ്ടെത്തുക.\n\nപാരാമീറ്ററുകൾ:\n- a (number): ആദ്യത്തെ പൂർണ്ണസംഖ്യ.\n- b (number): രണ്ടാമത്തെ പൂർണ്ണസംഖ്യ.\n- c (number): മൂന്നാമത്തെ പൂർണ്ണസംഖ്യ.\n\nമടങ്ങിവരവ്:\n- Object: 'max' and 'min' എന്ന ഗുണങ്ങളുള്ള ഒരു ഓബ്ജക്റ്റ്.\n\nഉദാഹരണ കോൾ:\nconst result = f_4(1, 2, 3);\nconsole.assert(result.max === 3 && result.min === 1);", "fa": "حداکثر و حداقل سه عدد صحیح متمایز را پیدا کنید.\n\nپارامترها:\n- a (number): عدد صحیح اول.\n- b (number): عدد صحیح دوم.\n- c (number): عدد صحیح سوم.\n\nبازگشتی:\n- Object: یک شیء با ویژگی‌های 'max' و 'min'.\n\nمثال فراخوانی:\nconst result = f_4(1, 2, 3);\nconsole.assert(result.max === 3 && result.min === 1);"}}
{"task_id": "JavaScript/5", "prompt": {"en": "/**\n * Calculate the distance between two points A (xa, ya) and B (xb, yb).\n *\n * Parameters:\n * - xa (number): x-coordinate of point A.\n * - ya (number): y-coordinate of point A.\n * - xb (number): x-coordinate of point B.\n * - yb (number): y-coordinate of point B.\n *\n * Returns:\n * number: The distance between points A and B.\n * Example usage:\n * console.log(f_5(0,0,3,4)); // Expected output: 5\n */\nfunction f_5(xa, ya, xb, yb)", "sq": "/**\n * Llogarit distancën midis dy pikave A (xa, ya) dhe B (xb, yb).\n *\n * Parametrat:\n * - xa (numër): koordinata x e pikës A.\n * - ya (numër): koordinata y e pikës A.\n * - xb (numër): koordinata x e pikës B.\n * - yb (numër): koordinata y e pikës B.\n *\n * Kthen:\n * numër: Distanca midis pikave A dhe B.\n * Shembull përdorimi:\n * console.log(f_5(0,0,3,4)); // Rezultati i pritur: 5\n */\nfunction f_5(xa, ya, xb, yb)", "hy": "/**\n * Հաշվել հեռավորությունը երկու կետերի A (xa, ya) և B (xb, yb) միջև։\n *\n * Պարամետրեր:\n * - xa (թիվ): A կետի x-կոորդինատը։\n * - ya (թիվ): A կետի y-կոորդինատը։\n * - xb (թիվ): B կետի x-կոորդինատը։\n * - yb (թիվ): B կետի y-կոորդինատը։\n *\n * Վերադարձնում է:\n * թիվ: Հեռավորությունը A և B կետերի միջև։\n * Օգտագործման օրինակ:\n * console.log(f_5(0,0,3,4)); // Սպասվող արդյունք: 5\n */\nfunction f_5(xa, ya, xb, yb)", "bn": "/**\n * দুটি বিন্দু A (xa, ya) এবং B (xb, yb) এর মধ্যে দূরত্ব নির্ণয় করুন।\n *\n * প্যারামিটারসমূহ:\n * - xa (number): বিন্দু A এর x-সমন্বয়।\n * - ya (number): বিন্দু A এর y-সমন্বয়।\n * - xb (number): বিন্দু B এর x-সমন্বয়।\n * - yb (number): বিন্দু B এর y-সমন্বয়।\n *\n * রিটার্ন করে:\n * number: বিন্দু A এবং B এর মধ্যে দূরত্ব।\n * উদাহরণ ব্যবহার:\n * console.log(f_5(0,0,3,4)); // প্রত্যাশিত আউটপুট: 5\n */\nfunction f_5(xa, ya, xb, yb)", "bg": "/**\n * Изчислява разстоянието между две точки A (xa, ya) и B (xb, yb).\n *\n * Параметри:\n * - xa (number): x-координата на точка A.\n * - ya (number): y-координата на точка A.\n * - xb (number): x-координата на точка B.\n * - yb (number): y-координата на точка B.\n *\n * Връща:\n * number: Разстоянието между точките A и B.\n * Пример за използване:\n * console.log(f_5(0,0,3,4)); // Очакван резултат: 5\n */\nfunction f_5(xa, ya, xb, yb)", "zh": "/**\n * 计算两点 A (xa, ya) 和 B (xb, yb) 之间的距离。\n *\n * 参数:\n * - xa (number): 点 A 的 x 坐标。\n * - ya (number): 点 A 的 y 坐标。\n * - xb (number): 点 B 的 x 坐标。\n * - yb (number): 点 B 的 y 坐标。\n *\n * 返回:\n * number: 点 A 和 B 之间的距离。\n * 示例用法:\n * console.log(f_5(0,0,3,4)); // 预期输出: 5\n */\nfunction f_5(xa, ya, xb, yb)", "fr": "/**\n * Calculer la distance entre deux points A (xa, ya) et B (xb, yb).\n *\n * Paramètres :\n * - xa (nombre) : coordonnée x du point A.\n * - ya (nombre) : coordonnée y du point A.\n * - xb (nombre) : coordonnée x du point B.\n * - yb (nombre) : coordonnée y du point B.\n *\n * Renvoie :\n * nombre : La distance entre les points A et B.\n * Exemple d'utilisation :\n * console.log(f_5(0,0,3,4)); // Résultat attendu : 5\n */\nfunction f_5(xa, ya, xb, yb)", "de": "/**\n * Berechnet die Entfernung zwischen zwei Punkten A (xa, ya) und B (xb, yb).\n *\n * Parameter:\n * - xa (number): x-Koordinate des Punktes A.\n * - ya (number): y-Koordinate des Punktes A.\n * - xb (number): x-Koordinate des Punktes B.\n * - yb (number): y-Koordinate des Punktes B.\n *\n * Rückgabewert:\n * number: Die Entfernung zwischen den Punkten A und B.\n * Beispielverwendung:\n * console.log(f_5(0,0,3,4)); // Erwartete Ausgabe: 5\n */\nfunction f_5(xa, ya, xb, yb)", "ha": "/**\n * Lissafin nisan tsakanin maki biyu A (xa, ya) da B (xb, yb).\n *\n * Sigogi:\n * - xa (lamba): x-daftarin maki A.\n * - ya (lamba): y-daftarin maki A.\n * - xb (lamba): x-daftarin maki B.\n * - yb (lamba): y-daftarin maki B.\n *\n * Komawa:\n * lamba: Nisan tsakanin maki A da B.\n * Misalin amfani:\n * console.log(f_5(0,0,3,4)); // Fitar da ake tsammani: 5\n */\nfunction f_5(xa, ya, xb, yb)", "hi": "/**\n * दो बिंदुओं A (xa, ya) और B (xb, yb) के बीच की दूरी की गणना करें।\n *\n * पैरामीटर्स:\n * - xa (number): बिंदु A का x-निर्देशांक।\n * - ya (number): बिंदु A का y-निर्देशांक।\n * - xb (number): बिंदु B का x-निर्देशांक।\n * - yb (number): बिंदु B का y-निर्देशांक।\n *\n * रिटर्न करता है:\n * number: बिंदुओं A और B के बीच की दूरी।\n * उदाहरण उपयोग:\n * console.log(f_5(0,0,3,4)); // अपेक्षित आउटपुट: 5\n */\nfunction f_5(xa, ya, xb, yb)", "hu": "/**\n * Számítsa ki a távolságot két pont, A (xa, ya) és B (xb, yb) között.\n *\n * Paraméterek:\n * - xa (szám): A pont x-koordinátája.\n * - ya (szám): A pont y-koordinátája.\n * - xb (szám): B pont x-koordinátája.\n * - yb (szám): B pont y-koordinátája.\n *\n * Visszatér:\n * szám: A és B pontok közötti távolság.\n * Példa használat:\n * console.log(f_5(0,0,3,4)); // Várt kimenet: 5\n */\nfunction f_5(xa, ya, xb, yb)", "es": "/**\n * Calcular la distancia entre dos puntos A (xa, ya) y B (xb, yb).\n *\n * Parámetros:\n * - xa (número): coordenada x del punto A.\n * - ya (número): coordenada y del punto A.\n * - xb (número): coordenada x del punto B.\n * - yb (número): coordenada y del punto B.\n *\n * Devuelve:\n * número: La distancia entre los puntos A y B.\n * Ejemplo de uso:\n * console.log(f_5(0,0,3,4)); // Salida esperada: 5\n */\nfunction f_5(xa, ya, xb, yb)", "arb": "/**\n * حساب المسافة بين نقطتين A (xa, ya) و B (xb, yb).\n *\n * المعاملات:\n * - xa (number): الإحداثي السيني للنقطة A.\n * - ya (number): الإحداثي الصادي للنقطة A.\n * - xb (number): الإحداثي السيني للنقطة B.\n * - yb (number): الإحداثي الصادي للنقطة B.\n *\n * العوائد:\n * number: المسافة بين النقطتين A و B.\n * مثال على الاستخدام:\n * console.log(f_5(0,0,3,4)); // المخرج المتوقع: 5\n */\nfunction f_5(xa, ya, xb, yb)", "sw": "/**\n * Kuhesabu umbali kati ya pointi mbili A (xa, ya) na B (xb, yb).\n *\n * Vigezo:\n * - xa (nambari): x-kiwianishi cha pointi A.\n * - ya (nambari): y-kiwianishi cha pointi A.\n * - xb (nambari): x-kiwianishi cha pointi B.\n * - yb (nambari): y-kiwianishi cha pointi B.\n *\n * Inarejesha:\n * nambari: Umbali kati ya pointi A na B.\n * Mfano wa matumizi:\n * console.log(f_5(0,0,3,4)); // Matokeo yanayotarajiwa: 5\n */\nfunction f_5(xa, ya, xb, yb)", "tr": "/**\n * A (xa, ya) ve B (xb, yb) noktaları arasındaki mesafeyi hesaplayın.\n *\n * Parametreler:\n * - xa (number): A noktasının x-koordinatı.\n * - ya (number): A noktasının y-koordinatı.\n * - xb (number): B noktasının x-koordinatı.\n * - yb (number): B noktasının y-koordinatı.\n *\n * Döndürür:\n * number: A ve B noktaları arasındaki mesafe.\n * Örnek kullanım:\n * console.log(f_5(0,0,3,4)); // Beklenen çıktı: 5\n */\nfunction f_5(xa, ya, xb, yb)", "vi": "/**\n * Tính khoảng cách giữa hai điểm A (xa, ya) và B (xb, yb).\n *\n * Tham số:\n * - xa (number): tọa độ x của điểm A.\n * - ya (number): tọa độ y của điểm A.\n * - xb (number): tọa độ x của điểm B.\n * - yb (number): tọa độ y của điểm B.\n *\n * Trả về:\n * number: Khoảng cách giữa điểm A và B.\n * Ví dụ sử dụng:\n * console.log(f_5(0,0,3,4)); // Kết quả mong đợi: 5\n */\nfunction f_5(xa, ya, xb, yb)", "id": "/**\n * Menghitung jarak antara dua titik A (xa, ya) dan B (xb, yb).\n *\n * Parameter:\n * - xa (number): koordinat x dari titik A.\n * - ya (number): koordinat y dari titik A.\n * - xb (number): koordinat x dari titik B.\n * - yb (number): koordinat y dari titik B.\n *\n * Mengembalikan:\n * number: Jarak antara titik A dan B.\n * Contoh penggunaan:\n * console.log(f_5(0,0,3,4)); // Output yang diharapkan: 5\n */\nfunction f_5(xa, ya, xb, yb)", "ja": "/**\n * 2点A (xa, ya) と B (xb, yb) の間の距離を計算します。\n *\n * パラメータ:\n * - xa (number): 点Aのx座標。\n * - ya (number): 点Aのy座標。\n * - xb (number): 点Bのx座標。\n * - yb (number): 点Bのy座標。\n *\n * 戻り値:\n * number: 点Aと点Bの間の距離。\n * 使用例:\n * console.log(f_5(0,0,3,4)); // 期待される出力: 5\n */\nfunction f_5(xa, ya, xb, yb)", "ko": "/**\n * 두 점 A (xa, ya)와 B (xb, yb) 사이의 거리를 계산합니다.\n *\n * 매개변수:\n * - xa (number): 점 A의 x-좌표.\n * - ya (number): 점 A의 y-좌표.\n * - xb (number): 점 B의 x-좌표.\n * - yb (number): 점 B의 y-좌표.\n *\n * 반환값:\n * number: 점 A와 B 사이의 거리.\n * 사용 예:\n * console.log(f_5(0,0,3,4)); // 예상 출력: 5\n */\nfunction f_5(xa, ya, xb, yb)", "ml": "/**\n * A (xa, ya)യും B (xb, yb)യും ആയ രണ്ടു ബിന്ദുക്കൾക്കിടയിലെ ദൂരം കണക്കാക്കുക.\n *\n * പാരാമീറ്ററുകൾ:\n * - xa (number): A ബിന്ദുവിന്റെ x-കോഓർഡിനേറ്റ്.\n * - ya (number): A ബിന്ദുവിന്റെ y-കോഓർഡിനേറ്റ്.\n * - xb (number): B ബിന്ദുവിന്റെ x-കോഓർഡിനേറ്റ്.\n * - yb (number): B ബിന്ദുവിന്റെ y-കോഓർഡിനേറ്റ്.\n *\n * റിട്ടേൺസ്:\n * number: A, B ബിന്ദുക്കൾക്കിടയിലെ ദൂരം.\n * ഉദാഹരണ ഉപയോഗം:\n * console.log(f_5(0,0,3,4)); // പ്രതീക്ഷിച്ച ഔട്ട്പുട്ട്: 5\n */\nfunction f_5(xa, ya, xb, yb)", "fa": "/**\n * محاسبه فاصله بین دو نقطه A (xa, ya) و B (xb, yb).\n *\n * پارامترها:\n * - xa (number): مختصات x نقطه A.\n * - ya (number): مختصات y نقطه A.\n * - xb (number): مختصات x نقطه B.\n * - yb (number): مختصات y نقطه B.\n *\n * بازگشت:\n * number: فاصله بین نقاط A و B.\n * مثال استفاده:\n * console.log(f_5(0,0,3,4)); // خروجی مورد انتظار: 5\n */\nfunction f_5(xa, ya, xb, yb)"}, "canonical_solution": "{\n    return Math.sqrt(Math.pow(xa - xb, 2) + Math.pow(ya - yb, 2));\n}", "instruction": {"en": "Write a JavaScript function `function f_5(xa, ya, xb, yb)` to solve the following problem:\nCalculate the distance between two points A (xa, ya) and B (xb, yb).\n\nParameters:\n- xa (number): x-coordinate of point A.\n- ya (number): y-coordinate of point A.\n- xb (number): x-coordinate of point B.\n- yb (number): y-coordinate of point B.\n\nReturns:\nnumber: The distance between points A and B.\nExample usage:\nconsole.log(f_5(0,0,3,4)); // Expected output: 5\n", "sq": "Shkruani një funksion JavaScript `function f_5(xa, ya, xb, yb)` për të zgjidhur problemin e mëposhtëm:\nLlogarit distancën midis dy pikave A (xa, ya) dhe B (xb, yb).\n\nParametrat:\n- xa (number): koordinata x e pikës A.\n- ya (number): koordinata y e pikës A.\n- xb (number): koordinata x e pikës B.\n- yb (number): koordinata y e pikës B.\n\nKthen:\nnumber: Distanca midis pikave A dhe B.\nShembull përdorimi:\nconsole.log(f_5(0,0,3,4)); // Rezultati i pritur: 5", "hy": "Գրեք JavaScript ֆունկցիա `function f_5(xa, ya, xb, yb)` հետևյալ խնդիրը լուծելու համար:\nՀաշվեք հեռավորությունը երկու կետերի միջև՝ A (xa, ya) և B (xb, yb):\n\nՊարամետրեր:\n- xa (number): A կետի x-կոորդինատը։\n- ya (number): A կետի y-կոորդինատը։\n- xb (number): B կետի x-կոորդինատը։\n- yb (number): B կետի y-կոորդինատը։\n\nՎերադարձնում է:\nnumber: Հեռավորությունը A և B կետերի միջև։\nՕրինակ օգտագործում:\nconsole.log(f_5(0,0,3,4)); // Սպասվող արդյունք: 5", "bn": "একটি জাভাস্ক্রিপ্ট ফাংশন `function f_5(xa, ya, xb, yb)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nদুটি বিন্দু A (xa, ya) এবং B (xb, yb) এর মধ্যে দূরত্ব গণনা করুন।\n\nপ্যারামিটারসমূহ:\n- xa (number): বিন্দু A এর x-সমন্বয়।\n- ya (number): বিন্দু A এর y-সমন্বয়।\n- xb (number): বিন্দু B এর x-সমন্বয়।\n- yb (number): বিন্দু B এর y-সমন্বয়।\n\nফেরত দিবে:\nnumber: বিন্দু A এবং B এর মধ্যে দূরত্ব।\nউদাহরণ ব্যবহার:\nconsole.log(f_5(0,0,3,4)); // প্রত্যাশিত আউটপুট: 5", "bg": "Напишете JavaScript функция `function f_5(xa, ya, xb, yb)` за решаване на следния проблем:\nИзчислете разстоянието между две точки A (xa, ya) и B (xb, yb).\n\nПараметри:\n- xa (number): x-координата на точка A.\n- ya (number): y-координата на точка A.\n- xb (number): x-координата на точка B.\n- yb (number): y-координата на точка B.\n\nВръща:\nnumber: Разстоянието между точките A и B.\nПример за използване:\nconsole.log(f_5(0,0,3,4)); // Очакван резултат: 5", "zh": "编写一个 JavaScript 函数 `function f_5(xa, ya, xb, yb)` 来解决以下问题：  \n计算两点 A (xa, ya) 和 B (xb, yb) 之间的距离。\n\n参数：\n- xa (number): 点 A 的 x 坐标。\n- ya (number): 点 A 的 y 坐标。\n- xb (number): 点 B 的 x 坐标。\n- yb (number): 点 B 的 y 坐标。\n\n返回：\nnumber: 点 A 和 B 之间的距离。\n示例用法：\nconsole.log(f_5(0,0,3,4)); // 预期输出: 5", "fr": "Écrire une fonction JavaScript `function f_5(xa, ya, xb, yb)` pour résoudre le problème suivant :  \nCalculer la distance entre deux points A (xa, ya) et B (xb, yb).\n\nParamètres :\n- xa (number): coordonnée x du point A.\n- ya (number): coordonnée y du point A.\n- xb (number): coordonnée x du point B.\n- yb (number): coordonnée y du point B.\n\nRenvoie :\nnumber: La distance entre les points A et B.  \nExemple d'utilisation :\nconsole.log(f_5(0,0,3,4)); // Expected output: 5", "de": "Schreiben Sie eine JavaScript-Funktion `function f_5(xa, ya, xb, yb)`, um das folgende Problem zu lösen:\nBerechnen Sie die Entfernung zwischen zwei Punkten A (xa, ya) und B (xb, yb).\n\nParameter:\n- xa (number): x-Koordinate des Punktes A.\n- ya (number): y-Koordinate des Punktes A.\n- xb (number): x-Koordinate des Punktes B.\n- yb (number): y-Koordinate des Punktes B.\n\nRückgabewert:\nnumber: Die Entfernung zwischen den Punkten A und B.\nBeispielverwendung:\nconsole.log(f_5(0,0,3,4)); // Erwartete Ausgabe: 5", "ha": "Rubuta wani aikin JavaScript `function f_5(xa, ya, xb, yb)` don warware matsalar mai zuwa:\nLissafa nisan tsakanin maki biyu A (xa, ya) da B (xb, yb).\n\nSigogi:\n- xa (number): x-aji na maki A.\n- ya (number): y-aji na maki A.\n- xb (number): x-aji na maki B.\n- yb (number): y-aji na maki B.\n\nDawowa:\nnumber: Nisan tsakanin maki A da B.\nMisalin amfani:\nconsole.log(f_5(0,0,3,4)); // Ana tsammanin fitarwa: 5", "hi": "JavaScript फ़ंक्शन `function f_5(xa, ya, xb, yb)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदो बिंदुओं A (xa, ya) और B (xb, yb) के बीच की दूरी की गणना करें।\n\nपैरामीटर्स:\n- xa (number): बिंदु A का x-निर्देशांक।\n- ya (number): बिंदु A का y-निर्देशांक।\n- xb (number): बिंदु B का x-निर्देशांक।\n- yb (number): बिंदु B का y-निर्देशांक।\n\nवापसी:\nnumber: बिंदुओं A और B के बीच की दूरी।\nउदाहरण उपयोग:\nconsole.log(f_5(0,0,3,4)); // Expected output: 5", "hu": "Írj egy JavaScript függvényt `function f_5(xa, ya, xb, yb)` a következő probléma megoldására:\nSzámítsd ki a távolságot két pont, A (xa, ya) és B (xb, yb) között.\n\nParaméterek:\n- xa (number): A pont x-koordinátája.\n- ya (number): A pont y-koordinátája.\n- xb (number): B pont x-koordinátája.\n- yb (number): B pont y-koordinátája.\n\nVisszatérési érték:\nnumber: Az A és B pontok közötti távolság.\nPélda használat:\nconsole.log(f_5(0,0,3,4)); // Várt kimenet: 5", "es": "Escribe una función de JavaScript `function f_5(xa, ya, xb, yb)` para resolver el siguiente problema:\nCalcular la distancia entre dos puntos A (xa, ya) y B (xb, yb).\n\nParámetros:\n- xa (number): coordenada x del punto A.\n- ya (number): coordenada y del punto A.\n- xb (number): coordenada x del punto B.\n- yb (number): coordenada y del punto B.\n\nDevuelve:\nnumber: La distancia entre los puntos A y B.\nEjemplo de uso:\nconsole.log(f_5(0,0,3,4)); // Salida esperada: 5", "arb": "اكتب دالة JavaScript `function f_5(xa, ya, xb, yb)` لحل المشكلة التالية:\nاحسب المسافة بين نقطتين A (xa, ya) و B (xb, yb).\n\nالمعطيات:\n- xa (number): الإحداثي السيني للنقطة A.\n- ya (number): الإحداثي الصادي للنقطة A.\n- xb (number): الإحداثي السيني للنقطة B.\n- yb (number): الإحداثي الصادي للنقطة B.\n\nالقيم المعادة:\nnumber: المسافة بين النقطتين A و B.\nمثال على الاستخدام:\nconsole.log(f_5(0,0,3,4)); // المخرج المتوقع: 5", "sw": "Andika kazi ya JavaScript `function f_5(xa, ya, xb, yb)` kutatua tatizo lifuatalo: \nHesabu umbali kati ya pointi mbili A (xa, ya) na B (xb, yb).\n\nVigezo:\n- xa (nambari): x-kiwianishi cha pointi A.\n- ya (nambari): y-kiwianishi cha pointi A.\n- xb (nambari): x-kiwianishi cha pointi B.\n- yb (nambari): y-kiwianishi cha pointi B.\n\nInarudisha:\nnambari: Umbali kati ya pointi A na B.\nMfano wa matumizi:\nconsole.log(f_5(0,0,3,4)); // Matokeo yanayotarajiwa: 5", "tr": "Bir JavaScript fonksiyonu `function f_5(xa, ya, xb, yb)` yazın ve aşağıdaki problemi çözün:\nİki nokta A (xa, ya) ve B (xb, yb) arasındaki mesafeyi hesaplayın.\n\nParametreler:\n- xa (number): A noktasının x-koordinatı.\n- ya (number): A noktasının y-koordinatı.\n- xb (number): B noktasının x-koordinatı.\n- yb (number): B noktasının y-koordinatı.\n\nDöndürür:\nnumber: A ve B noktaları arasındaki mesafe.\nÖrnek kullanım:\nconsole.log(f_5(0,0,3,4)); // Beklenen çıktı: 5", "vi": "Viết một hàm JavaScript `function f_5(xa, ya, xb, yb)` để giải quyết vấn đề sau:\nTính khoảng cách giữa hai điểm A (xa, ya) và B (xb, yb).\n\nTham số:\n- xa (number): tọa độ x của điểm A.\n- ya (number): tọa độ y của điểm A.\n- xb (number): tọa độ x của điểm B.\n- yb (number): tọa độ y của điểm B.\n\nTrả về:\nnumber: Khoảng cách giữa hai điểm A và B.\nVí dụ sử dụng:\nconsole.log(f_5(0,0,3,4)); // Kết quả mong đợi: 5", "id": "Tulis sebuah fungsi JavaScript `function f_5(xa, ya, xb, yb)` untuk menyelesaikan masalah berikut:\nHitung jarak antara dua titik A (xa, ya) dan B (xb, yb).\n\nParameter:\n- xa (number): koordinat x dari titik A.\n- ya (number): koordinat y dari titik A.\n- xb (number): koordinat x dari titik B.\n- yb (number): koordinat y dari titik B.\n\nMengembalikan:\nnumber: Jarak antara titik A dan B.\nContoh penggunaan:\nconsole.log(f_5(0,0,3,4)); // Output yang diharapkan: 5", "ja": "JavaScript関数`function f_5(xa, ya, xb, yb)`を作成して、次の問題を解決してください:\n2つの点A (xa, ya)とB (xb, yb)の間の距離を計算します。\n\nパラメータ:\n- xa (number): 点Aのx座標。\n- ya (number): 点Aのy座標。\n- xb (number): 点Bのx座標。\n- yb (number): 点Bのy座標。\n\n戻り値:\nnumber: 点AとBの間の距離。\n使用例:\nconsole.log(f_5(0,0,3,4)); // 期待される出力: 5", "ko": "JavaScript 함수를 작성하세요 `function f_5(xa, ya, xb, yb)` 다음 문제를 해결하기 위해:\n두 점 A (xa, ya)와 B (xb, yb) 사이의 거리를 계산합니다.\n\n매개변수:\n- xa (number): 점 A의 x-좌표.\n- ya (number): 점 A의 y-좌표.\n- xb (number): 점 B의 x-좌표.\n- yb (number): 점 B의 y-좌표.\n\n반환값:\nnumber: 점 A와 B 사이의 거리.\n사용 예:\nconsole.log(f_5(0,0,3,4)); // 예상 출력: 5", "ml": "ഒരു ജാവാസ്ക്രിപ്റ്റ് ഫംഗ്ഷൻ `function f_5(xa, ya, xb, yb)` എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nരണ്ടു പോയിന്റുകൾ A (xa, ya) and B (xb, yb) തമ്മിലുള്ള ദൂരമനക്കുക.\n\nപാരാമീറ്ററുകൾ:\n- xa (number): പോയിന്റ് A യുടെ x-കോഓർഡിനേറ്റ്.\n- ya (number): പോയിന്റ് A യുടെ y-കോഓർഡിനേറ്റ്.\n- xb (number): പോയിന്റ് B യുടെ x-കോഓർഡിനേറ്റ്.\n- yb (number): പോയിന്റ് B യുടെ y-കോഓർഡിനേറ്റ്.\n\nമടക്കുന്നു:\nnumber: പോയിന്റുകൾ A and B തമ്മിലുള്ള ദൂരം.\nഉദാഹരണ ഉപയോഗം:\nconsole.log(f_5(0,0,3,4)); // പ്രതീക്ഷിക്കുന്ന output: 5", "fa": "یک تابع جاوااسکریپت `function f_5(xa, ya, xb, yb)` بنویسید تا مسئله زیر را حل کند:\nفاصله بین دو نقطه A (xa, ya) و B (xb, yb) را محاسبه کنید.\n\nپارامترها:\n- xa (number): مختصات x نقطه A.\n- ya (number): مختصات y نقطه A.\n- xb (number): مختصات x نقطه B.\n- yb (number): مختصات y نقطه B.\n\nبازگشت:\nnumber: فاصله بین نقاط A و B.\nمثال استفاده:\nconsole.log(f_5(0,0,3,4)); // خروجی مورد انتظار: 5"}, "level": "easy", "test": "const testf_5 = () => {\n    console.assert(Math.abs(f_5(0, 0, 3, 4) - 5) < 1e-6);\n    console.assert(Math.abs(f_5(0, 0, 0, 0) - 0) < 1e-6);\n    console.assert(Math.abs(f_5(-1, -1, 2, 2) - 4.242640687) < 1e-6);\n    console.assert(Math.abs(f_5(1.5, 3.9, 4.2, -1.1) - 5.68243) < 1e-6);\n    // console.log(\"All test cases passed!\");\n}\n\ntestf_5();", "entry_point": "f_5", "signature": "function f_5(xa, ya, xb, yb)", "docstring": {"en": "Calculate the distance between two points A (xa, ya) and B (xb, yb).\n\nParameters:\n- xa (number): x-coordinate of point A.\n- ya (number): y-coordinate of point A.\n- xb (number): x-coordinate of point B.\n- yb (number): y-coordinate of point B.\n\nReturns:\nnumber: The distance between points A and B.\nExample usage:\nconsole.log(f_5(0,0,3,4)); // Expected output: 5\n", "sq": "Llogarit distancën midis dy pikave A (xa, ya) dhe B (xb, yb).\n\nParametrat:\n- xa (numër): koordinata x e pikës A.\n- ya (numër): koordinata y e pikës A.\n- xb (numër): koordinata x e pikës B.\n- yb (numër): koordinata y e pikës B.\n\nKthen:\nnumër: Distanca midis pikave A dhe B.\nShembull përdorimi:\nconsole.log(f_5(0,0,3,4)); // Rezultati i pritur: 5", "hy": "Հաշվել երկու կետերի A (xa, ya) և B (xb, yb) միջև հեռավորությունը։\n\nՊարամետրեր:\n- xa (թիվ): A կետի x-կոորդինատը։\n- ya (թիվ): A կետի y-կոորդինատը։\n- xb (թիվ): B կետի x-կոորդինատը։\n- yb (թիվ): B կետի y-կոորդինատը։\n\nՎերադարձնում է:\nթիվ: A և B կետերի միջև հեռավորությունը։\nՕրինակ օգտագործում:\nconsole.log(f_5(0,0,3,4)); // Սպասվող արդյունք: 5", "bn": "দুটি বিন্দু A (xa, ya) এবং B (xb, yb) এর মধ্যে দূরত্ব নির্ণয় করুন।\n\nপ্যারামিটারসমূহ:\n- xa (number): বিন্দু A এর x-অক্ষাংশ।\n- ya (number): বিন্দু A এর y-অক্ষাংশ।\n- xb (number): বিন্দু B এর x-অক্ষাংশ।\n- yb (number): বিন্দু B এর y-অক্ষাংশ।\n\nরিটার্নস:\nnumber: বিন্দু A এবং B এর মধ্যবর্তী দূরত্ব।\nউদাহরণ ব্যবহার:\nconsole.log(f_5(0,0,3,4)); // প্রত্যাশিত আউটপুট: 5", "bg": "Изчислете разстоянието между две точки A (xa, ya) и B (xb, yb).\n\nПараметри:\n- xa (number): x-координата на точка A.\n- ya (number): y-координата на точка A.\n- xb (number): x-координата на точка B.\n- yb (number): y-координата на точка B.\n\nВръща:\nnumber: Разстоянието между точките A и B.\nПример за използване:\nconsole.log(f_5(0,0,3,4)); // Очакван резултат: 5", "zh": "计算两点 A (xa, ya) 和 B (xb, yb) 之间的距离。\n\n参数：\n- xa (number): 点 A 的 x 坐标。\n- ya (number): 点 A 的 y 坐标。\n- xb (number): 点 B 的 x 坐标。\n- yb (number): 点 B 的 y 坐标。\n\n返回：\nnumber: 点 A 和 B 之间的距离。\n示例用法：\nconsole.log(f_5(0,0,3,4)); // 预期输出: 5", "fr": "Calculer la distance entre deux points A (xa, ya) et B (xb, yb).\n\nParamètres:\n- xa (nombre): coordonnée x du point A.\n- ya (nombre): coordonnée y du point A.\n- xb (nombre): coordonnée x du point B.\n- yb (nombre): coordonnée y du point B.\n\nRenvoie:\nnombre: La distance entre les points A et B.\nExemple d'utilisation:\nconsole.log(f_5(0,0,3,4)); // Résultat attendu: 5", "de": "Berechnen Sie die Entfernung zwischen zwei Punkten A (xa, ya) und B (xb, yb).\n\nParameter:\n- xa (number): x-Koordinate des Punktes A.\n- ya (number): y-Koordinate des Punktes A.\n- xb (number): x-Koordinate des Punktes B.\n- yb (number): y-Koordinate des Punktes B.\n\nRückgabewert:\nnumber: Die Entfernung zwischen den Punkten A und B.\nBeispielverwendung:\nconsole.log(f_5(0,0,3,4)); // Erwartete Ausgabe: 5", "ha": "Lissafin nisan tsakanin maki biyu A (xa, ya) da B (xb, yb).\n\nSigogi:\n- xa (number): x-da'irar maki A.\n- ya (number): y-da'irar maki A.\n- xb (number): x-da'irar maki B.\n- yb (number): y-da'irar maki B.\n\nDawowa:\nnumber: Nisan tsakanin maki A da B.\nMisalin amfani:\nconsole.log(f_5(0,0,3,4)); // Fitar da ake tsammani: 5", "hi": "दो बिंदुओं A (xa, ya) और B (xb, yb) के बीच की दूरी की गणना करें।\n\nपैरामीटर्स:\n- xa (संख्या): बिंदु A का x-निर्देशांक।\n- ya (संख्या): बिंदु A का y-निर्देशांक।\n- xb (संख्या): बिंदु B का x-निर्देशांक।\n- yb (संख्या): बिंदु B का y-निर्देशांक।\n\nवापसी:\nसंख्या: बिंदु A और B के बीच की दूरी।\nउदाहरण उपयोग:\nconsole.log(f_5(0,0,3,4)); // अपेक्षित आउटपुट: 5", "hu": "Számítsa ki a távolságot két pont, A (xa, ya) és B (xb, yb) között.\n\nParaméterek:\n- xa (szám): A pont x-koordinátája.\n- ya (szám): A pont y-koordinátája.\n- xb (szám): B pont x-koordinátája.\n- yb (szám): B pont y-koordinátája.\n\nVisszatérési érték:\nszám: Az A és B pontok közötti távolság.\nPélda használat:\nconsole.log(f_5(0,0,3,4)); // Várt kimenet: 5", "es": "Calcular la distancia entre dos puntos A (xa, ya) y B (xb, yb).\n\nParámetros:\n- xa (número): coordenada x del punto A.\n- ya (número): coordenada y del punto A.\n- xb (número): coordenada x del punto B.\n- yb (número): coordenada y del punto B.\n\nDevuelve:\nnúmero: La distancia entre los puntos A y B.\nEjemplo de uso:\nconsole.log(f_5(0,0,3,4)); // Salida esperada: 5", "arb": "احسب المسافة بين نقطتين A (xa, ya) و B (xb, yb).\n\nالمعلمات:\n- xa (number): الإحداثي السيني للنقطة A.\n- ya (number): الإحداثي الصادي للنقطة A.\n- xb (number): الإحداثي السيني للنقطة B.\n- yb (number): الإحداثي الصادي للنقطة B.\n\nالقيم المعادة:\nnumber: المسافة بين النقطتين A و B.\nمثال على الاستخدام:\nconsole.log(f_5(0,0,3,4)); // المخرج المتوقع: 5", "sw": "Hesabu umbali kati ya pointi mbili A (xa, ya) na B (xb, yb).\n\nVigezo:\n- xa (nambari): x-kiwianishi cha pointi A.\n- ya (nambari): y-kiwianishi cha pointi A.\n- xb (nambari): x-kiwianishi cha pointi B.\n- yb (nambari): y-kiwianishi cha pointi B.\n\nInarejesha:\nnambari: Umbali kati ya pointi A na B.\nMfano wa matumizi:\nconsole.log(f_5(0,0,3,4)); // Matokeo yanayotarajiwa: 5", "tr": "İki nokta A (xa, ya) ve B (xb, yb) arasındaki mesafeyi hesaplayın.\n\nParametreler:\n- xa (number): A noktasının x-koordinatı.\n- ya (number): A noktasının y-koordinatı.\n- xb (number): B noktasının x-koordinatı.\n- yb (number): B noktasının y-koordinatı.\n\nDöndürülenler:\nnumber: A ve B noktaları arasındaki mesafe.\nÖrnek kullanım:\nconsole.log(f_5(0,0,3,4)); // Beklenen çıktı: 5", "vi": "Tính khoảng cách giữa hai điểm A (xa, ya) và B (xb, yb).\n\nTham số:\n- xa (number): tọa độ x của điểm A.\n- ya (number): tọa độ y của điểm A.\n- xb (number): tọa độ x của điểm B.\n- yb (number): tọa độ y của điểm B.\n\nTrả về:\nnumber: Khoảng cách giữa điểm A và B.\nVí dụ sử dụng:\nconsole.log(f_5(0,0,3,4)); // Kết quả mong đợi: 5", "id": "Hitung jarak antara dua titik A (xa, ya) dan B (xb, yb).\n\nParameter:\n- xa (number): koordinat x dari titik A.\n- ya (number): koordinat y dari titik A.\n- xb (number): koordinat x dari titik B.\n- yb (number): koordinat y dari titik B.\n\nMengembalikan:\nnumber: Jarak antara titik A dan B.\nContoh penggunaan:\nconsole.log(f_5(0,0,3,4)); // Output yang diharapkan: 5", "ja": "2点A (xa, ya) とB (xb, yb) の距離を計算します。\n\nパラメータ:\n- xa (number): 点Aのx座標。\n- ya (number): 点Aのy座標。\n- xb (number): 点Bのx座標。\n- yb (number): 点Bのy座標。\n\n戻り値:\nnumber: 点AとBの間の距離。\n\n使用例:\nconsole.log(f_5(0,0,3,4)); // 期待される出力: 5", "ko": "두 점 A (xa, ya)와 B (xb, yb) 사이의 거리를 계산합니다.\n\n매개변수:\n- xa (number): 점 A의 x-좌표.\n- ya (number): 점 A의 y-좌표.\n- xb (number): 점 B의 x-좌표.\n- yb (number): 점 B의 y-좌표.\n\n반환값:\nnumber: 점 A와 B 사이의 거리.\n사용 예:\nconsole.log(f_5(0,0,3,4)); // 예상 출력: 5", "ml": "രണ്ടു ബിന്ദുക്കൾ A (xa, ya) കൂടാതെ B (xb, yb) തമ്മിലുള്ള ദൂരം കണക്കാക്കുക.\n\nപാരാമീറ്ററുകൾ:\n- xa (number): A ബിന്ദുവിന്റെ x-കോഓർഡിനേറ്റ്.\n- ya (number): A ബിന്ദുവിന്റെ y-കോഓർഡിനേറ്റ്.\n- xb (number): B ബിന്ദുവിന്റെ x-കോഓർഡിനേറ്റ്.\n- yb (number): B ബിന്ദുവിന്റെ y-കോഓർഡിനേറ്റ്.\n\nമടങ്ങിവരവ്:\nnumber: A, B ബിന്ദുക്കൾ തമ്മിലുള്ള ദൂരം.\nഉദാഹരണ ഉപയോഗം:\nconsole.log(f_5(0,0,3,4)); // പ്രതീക്ഷിക്കുന്ന ഔട്ട്പുട്ട്: 5", "fa": "محاسبه فاصله بین دو نقطه A (xa, ya) و B (xb, yb).\n\nپارامترها:\n- xa (number): مختصات x نقطه A.\n- ya (number): مختصات y نقطه A.\n- xb (number): مختصات x نقطه B.\n- yb (number): مختصات y نقطه B.\n\nبازگشت:\nnumber: فاصله بین نقاط A و B.\nمثال استفاده:\nconsole.log(f_5(0,0,3,4)); // خروجی مورد انتظار: 5"}}
{"task_id": "JavaScript/6", "prompt": {"en": "/**\n * Find the factorial of N and take the modulo 10007 of the result.\n * \n * Parameters:\n * - N (number): A non-negative integer representing the input value (N <= 10000).\n * \n * Returns:\n * - number: The result after taking the modulo 10007 of the factorial of N.\n * \n * Examples:\n * f_6(1) returns 1\n */\nfunction f_6(n)", "sq": "/**\n * Gjeni faktorialin e N dhe merrni modulo 10007 të rezultatit.\n * \n * Parametrat:\n * - N (numër): Një numër i plotë jo-negativ që përfaqëson vlerën hyrëse (N <= 10000).\n * \n * Kthen:\n * - numër: Rezultati pas marrjes së modulo 10007 të faktorialit të N.\n * \n * Shembuj:\n * f_6(1) kthen 1\n */\nfunction f_6(n)", "hy": "/**\n * Գտնել N-ի ֆակտորիալը և վերցնել արդյունքի 10007 մոդուլը։\n * \n * Պարամետրեր:\n * - N (թիվ): Ոչ բացասական ամբողջ թիվ, որը ներկայացնում է մուտքային արժեքը (N <= 10000)։\n * \n * Վերադարձնում է:\n * - թիվ: Արդյունքը N-ի ֆակտորիալի 10007 մոդուլը վերցնելուց հետո։\n * \n * Օրինակներ:\n * f_6(1) վերադարձնում է 1\n */\nfunction f_6(n)", "bn": "/**\n * N এর ফ্যাক্টোরিয়াল খুঁজে বের করুন এবং ফলাফলের 10007 এর মডুলো নিন।\n * \n * প্যারামিটার:\n * - N (সংখ্যা): একটি অ-ঋণাত্মক পূর্ণসংখ্যা যা ইনপুট মানকে উপস্থাপন করে (N <= 10000)।\n * \n * রিটার্নস:\n * - সংখ্যা: N এর ফ্যাক্টোরিয়ালের 10007 এর মডুলো নেওয়ার পরের ফলাফল।\n * \n * উদাহরণ:\n * f_6(1) 1 রিটার্ন করে\n */\nfunction f_6(n)", "bg": "/**\n * Намерете факториела на N и вземете модуло 10007 от резултата.\n * \n * Параметри:\n * - N (number): Ненегативно цяло число, представляващо входната стойност (N <= 10000).\n * \n * Връща:\n * - number: Резултатът след вземане на модуло 10007 от факториела на N.\n * \n * Примери:\n * f_6(1) връща 1\n */\nfunction f_6(n)", "zh": "/**\n * 找出N的阶乘并对结果取模10007。\n * \n * 参数:\n * - N (number): 一个非负整数，表示输入值 (N <= 10000)。\n * \n * 返回:\n * - number: N的阶乘对10007取模后的结果。\n * \n * 示例:\n * f_6(1) 返回 1\n */\nfunction f_6(n)", "fr": "/**\n * Trouver la factorielle de N et prendre le modulo 10007 du résultat.\n * \n * Paramètres:\n * - N (nombre): Un entier non négatif représentant la valeur d'entrée (N <= 10000).\n * \n * Renvoie:\n * - nombre: Le résultat après avoir pris le modulo 10007 de la factorielle de N.\n * \n * Exemples:\n * f_6(1) returns 1\n */\nfunction f_6(n)", "de": "/**\n * Finde die Fakultät von N und berechne das Modulo 10007 des Ergebnisses.\n * \n * Parameter:\n * - N (number): Eine nicht-negative ganze Zahl, die den Eingabewert darstellt (N <= 10000).\n * \n * Rückgabewerte:\n * - number: Das Ergebnis nach der Berechnung des Modulo 10007 der Fakultät von N.\n * \n * Beispiele:\n * f_6(1) gibt 1 zurück\n */\nfunction f_6(n)", "ha": "/**\n * Nemo factorial na N kuma ka ɗauki modulo 10007 na sakamakon.\n * \n * Sigogi:\n * - N (lamba): Lamba maras kyau mai wakiltar ƙimar shigarwa (N <= 10000).\n * \n * Komawa:\n * - lamba: Sakamakon bayan ɗaukar modulo 10007 na factorial na N.\n * \n * Misalai:\n * f_6(1) returns 1\n */\nfunction f_6(n)", "hi": "/**\n * N का फैक्टोरियल खोजें और परिणाम का 10007 से माड्यूलो लें।\n * \n * पैरामीटर्स:\n * - N (संख्या): इनपुट मान का प्रतिनिधित्व करने वाला एक गैर-ऋणात्मक पूर्णांक (N <= 10000)।\n * \n * रिटर्न्स:\n * - संख्या: N के फैक्टोरियल का 10007 से माड्यूलो लेने के बाद का परिणाम।\n * \n * उदाहरण:\n * f_6(1) 1 लौटाता है\n */\nfunction f_6(n)", "hu": "/**\n * Találd meg N faktoriálisát, és vedd az eredmény 10007-es modulóját.\n * \n * Paraméterek:\n * - N (szám): Egy nem negatív egész szám, amely a bemeneti értéket jelöli (N <= 10000).\n * \n * Visszatér:\n * - szám: Az N faktoriálisának 10007-es modulójának eredménye.\n * \n * Példák:\n * f_6(1) visszaadja 1\n */\nfunction f_6(n)", "es": "/**\n * Encuentra el factorial de N y toma el módulo 10007 del resultado.\n * \n * Parámetros:\n * - N (number): Un entero no negativo que representa el valor de entrada (N <= 10000).\n * \n * Devuelve:\n * - number: El resultado después de tomar el módulo 10007 del factorial de N.\n * \n * Ejemplos:\n * f_6(1) devuelve 1\n */\nfunction f_6(n)", "arb": "/**\n * إيجاد مضروب N وأخذ باقي القسمة 10007 من النتيجة.\n * \n * المعاملات:\n * - N (عدد): عدد صحيح غير سالب يمثل قيمة الإدخال (N <= 10000).\n * \n * يعيد:\n * - عدد: النتيجة بعد أخذ باقي القسمة 10007 من مضروب N.\n * \n * أمثلة:\n * f_6(1) يعيد 1\n */\nfunction f_6(n)", "sw": "/**\n * Pata faktoria ya N na chukua modulo 10007 ya matokeo.\n * \n * Vigezo:\n * - N (nambari): Nambari isiyo hasi inayowakilisha thamani ya ingizo (N <= 10000).\n * \n * Inarudisha:\n * - nambari: Matokeo baada ya kuchukua modulo 10007 ya faktoria ya N.\n * \n * Mifano:\n * f_6(1) inarudisha 1\n */\nfunction f_6(n)", "tr": "/**\n * N'in faktöriyelini bulun ve sonucu 10007 ile mod alın.\n * \n * Parametreler:\n * - N (number): Giriş değerini temsil eden negatif olmayan bir tam sayı (N <= 10000).\n * \n * Döndürür:\n * - number: N'in faktöriyelinin 10007 ile modunun alınmasından sonra elde edilen sonuç.\n * \n * Örnekler:\n * f_6(1) 1 döndürür\n */\nfunction f_6(n)", "vi": "/**\n * Tìm giai thừa của N và lấy modulo 10007 của kết quả.\n * \n * Tham số:\n * - N (number): Một số nguyên không âm đại diện cho giá trị đầu vào (N <= 10000).\n * \n * Trả về:\n * - number: Kết quả sau khi lấy modulo 10007 của giai thừa của N.\n * \n * Ví dụ:\n * f_6(1) trả về 1\n */\nfunction f_6(n)", "id": "/**\n * Temukan faktorial dari N dan ambil hasil modulo 10007.\n * \n * Parameter:\n * - N (number): Sebuah bilangan bulat non-negatif yang mewakili nilai input (N <= 10000).\n * \n * Mengembalikan:\n * - number: Hasil setelah mengambil modulo 10007 dari faktorial N.\n * \n * Contoh:\n * f_6(1) mengembalikan 1\n */\nfunction f_6(n)", "ja": "/**\n * Nの階乗を計算し、その結果を10007で割った余りを求めます。\n * \n * パラメータ:\n * - N (number): 入力値を表す非負整数 (N <= 10000)。\n * \n * 戻り値:\n * - number: Nの階乗を10007で割った余りの結果。\n * \n * 例:\n * f_6(1) は 1 を返します\n */\nfunction f_6(n)", "ko": "/**\n * N의 팩토리얼을 구하고 그 결과를 10007로 나눈 나머지를 구합니다.\n * \n * 매개변수:\n * - N (number): 입력 값을 나타내는 0 이상의 정수 (N <= 10000).\n * \n * 반환값:\n * - number: N의 팩토리얼을 10007로 나눈 나머지 결과.\n * \n * 예시:\n * f_6(1) returns 1\n */\nfunction f_6(n)", "ml": "/**\n * N ന്റെ ഫാക്ടോറിയൽ കണ്ടെത്തി ഫലം 10007 ന്റെ മോഡുലോ എടുക്കുക.\n * \n * പാരാമീറ്ററുകൾ:\n * - N (number): ഇൻപുട്ട് മൂല്യം പ്രതിനിധീകരിക്കുന്ന ഒരു നെഗറ്റീവ് അല്ലാത്ത പൂർണ്ണസംഖ്യ (N <= 10000).\n * \n * മടക്കുന്നു:\n * - number: N ന്റെ ഫാക്ടോറിയലിന്റെ 10007 ന്റെ മോഡുലോ എടുത്ത后的 ഫലം.\n * \n * ഉദാഹരണങ്ങൾ:\n * f_6(1) 1 മടക്കുന്നു\n */\nfunction f_6(n)", "fa": "/**\n * فاکتوریل N را پیدا کرده و باقیمانده تقسیم آن بر 10007 را محاسبه کنید.\n * \n * پارامترها:\n * - N (number): یک عدد صحیح غیرمنفی که نمایانگر مقدار ورودی است (N <= 10000).\n * \n * بازگشت:\n * - number: نتیجه پس از گرفتن باقیمانده تقسیم فاکتوریل N بر 10007.\n * \n * مثال‌ها:\n * f_6(1) returns 1\n */\nfunction f_6(n)"}, "canonical_solution": "{\n    // An array to store the precomputed factorial modulo results\n    const MOD = 10007;\n    let factorials = new Array(10001);\n    factorials[0] = factorials[1] = 1; // factorial(0) = factorial(1) = 1\n\n    // Precompute the factorials modulo 10007 for integers up to 10000\n    for (let i = 2; i <= 10000; i++) {\n        factorials[i] = (factorials[i - 1] * i) % MOD;\n    }\n\n    return factorials[n];\n}", "instruction": {"en": "Write a JavaScript function `function f_6(n)` to solve the following problem:\nFind the factorial of N and take the modulo 10007 of the result.\n\nParameters:\n- N (number): A non-negative integer representing the input value (N <= 10000).\n\nReturns:\n- number: The result after taking the modulo 10007 of the factorial of N.\n\nExamples:\nf_6(1) returns 1\n", "sq": "Shkruani një funksion JavaScript `function f_6(n)` për të zgjidhur problemin në vijim:  \nGjeni faktorielin e N dhe merrni modulo 10007 të rezultatit.\n\nParametrat:\n- N (numër): Një numër i plotë jo-negativ që përfaqëson vlerën hyrëse (N <= 10000).\n\nKthen:\n- numër: Rezultati pasi të merret modulo 10007 i faktorielit të N.\n\nShembuj:\nf_6(1) kthen 1", "hy": "Գրեք JavaScript ֆունկցիա `function f_6(n)` հետևյալ խնդիրը լուծելու համար:\nԳտնել N-ի ֆակտորիալը և արդյունքը վերցնել 10007 մոդուլո:\n\nՊարամետրեր:\n- N (number): Ոչ բացասական ամբողջ թիվ, որը ներկայացնում է մուտքային արժեքը (N <= 10000):\n\nՎերադարձնում է:\n- number: Արդյունքը, երբ վերցվում է N-ի ֆակտորիալի 10007 մոդուլոն:\n\nՕրինակներ:\nf_6(1) վերադարձնում է 1", "bn": "একটি জাভাস্ক্রিপ্ট ফাংশন `function f_6(n)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nN এর ফ্যাক্টোরিয়াল খুঁজুন এবং ফলাফলের 10007 এর মডুলো নিন।\n\nপ্যারামিটারসমূহ:\n- N (সংখ্যা): একটি অ-ঋণাত্মক পূর্ণসংখ্যা যা ইনপুট মানকে উপস্থাপন করে (N <= 10000)।\n\nফেরত দেয়:\n- সংখ্যা: N এর ফ্যাক্টোরিয়ালের 10007 এর মডুলো নেওয়ার পরের ফলাফল।\n\nউদাহরণসমূহ:\nf_6(1) 1 ফেরত দেয়", "bg": "Напишете JavaScript функция `function f_6(n)`, за да решите следния проблем:  \nНамерете факториела на N и вземете модул 10007 от резултата.\n\nПараметри:\n- N (number): Ненегативно цяло число, представляващо входната стойност (N <= 10000).\n\nВръща:\n- number: Резултатът след вземане на модул 10007 от факториела на N.\n\nПримери:  \nf_6(1) връща 1", "zh": "编写一个 JavaScript 函数 `function f_6(n)` 来解决以下问题：  \n求 N 的阶乘并取结果的 10007 模。\n\n参数：\n- N (number): 表示输入值的非负整数 (N <= 10000)。\n\n返回：\n- number: N 的阶乘取 10007 模后的结果。\n\n示例：\nf_6(1) 返回 1", "fr": "Écrire une fonction JavaScript `function f_6(n)` pour résoudre le problème suivant :  \nTrouver la factorielle de N et prendre le modulo 10007 du résultat.\n\nParamètres :  \n- N (number) : Un entier non négatif représentant la valeur d'entrée (N <= 10000).\n\nRenvoie :  \n- number : Le résultat après avoir pris le modulo 10007 de la factorielle de N.\n\nExemples :  \nf_6(1) renvoie 1", "de": "Schreiben Sie eine JavaScript-Funktion `function f_6(n)`, um das folgende Problem zu lösen:  \nFinden Sie die Fakultät von N und nehmen Sie das Modulo 10007 des Ergebnisses.\n\nParameter:\n- N (number): Eine nicht-negative ganze Zahl, die den Eingabewert darstellt (N <= 10000).\n\nRückgabewerte:\n- number: Das Ergebnis nach der Modulo-Operation 10007 der Fakultät von N.\n\nBeispiele:\nf_6(1) gibt 1 zurück", "ha": "Rubuta aikin JavaScript `function f_6(n)` don warware matsalar mai zuwa:  \nNemo factorial na N kuma ɗauki modulo 10007 na sakamakon.\n\nSigogi:\n- N (number): Lamba mai kyau wanda ke wakiltar ƙimar shigarwa (N <= 10000).\n\nDawowa:\n- number: Sakamakon bayan ɗaukar modulo 10007 na factorial na N.\n\nMisalai:\nf_6(1) returns 1", "hi": "JavaScript फ़ंक्शन `function f_6(n)` लिखें ताकि निम्नलिखित समस्या का समाधान हो सके:\nN का फैक्टोरियल खोजें और परिणाम का 10007 से मॉड्यूलो लें।\n\nपैरामीटर्स:\n- N (संख्या): एक गैर-ऋणात्मक पूर्णांक जो इनपुट मान का प्रतिनिधित्व करता है (N <= 10000)।\n\nवापसी मान:\n- संख्या: N के फैक्टोरियल का 10007 से मॉड्यूलो लेने के बाद का परिणाम।\n\nउदाहरण:\nf_6(1) 1 लौटाता है", "hu": "Írj egy JavaScript függvényt `function f_6(n)` a következő probléma megoldására:  \nTaláld meg N faktoriálisát, és vedd az eredmény 10007-es modulóját.\n\nParaméterek:\n- N (szám): Egy nem negatív egész szám, amely a bemeneti értéket jelképezi (N <= 10000).\n\nVisszatérési érték:\n- szám: Az eredmény, miután a faktoriális 10007-es modulóját vettük.\n\nPéldák:\nf_6(1) visszaadja 1", "es": "Escribe una función de JavaScript `function f_6(n)` para resolver el siguiente problema:  \nEncuentra el factorial de N y toma el módulo 10007 del resultado.\n\nParámetros:\n- N (number): Un entero no negativo que representa el valor de entrada (N <= 10000).\n\nDevuelve:\n- number: El resultado después de tomar el módulo 10007 del factorial de N.\n\nEjemplos:\nf_6(1) devuelve 1", "arb": "اكتب دالة JavaScript `function f_6(n)` لحل المشكلة التالية:\nابحث عن مضروب N وخذ باقي القسمة 10007 من النتيجة.\n\nالمعطيات:\n- N (عدد): عدد صحيح غير سالب يمثل قيمة الإدخال (N <= 10000).\n\nالقيم المعادة:\n- عدد: النتيجة بعد أخذ باقي القسمة 10007 من مضروب N.\n\nأمثلة:\nf_6(1) يعيد 1", "sw": "Andika kazi ya JavaScript `function f_6(n)` kutatua tatizo lifuatalo: Tafuta faktoria ya N na chukua modulo 10007 ya matokeo.\n\nVigezo:\n- N (number): Nambari isiyo hasi inayowakilisha thamani ya ingizo (N <= 10000).\n\nInarudisha:\n- number: Matokeo baada ya kuchukua modulo 10007 ya faktoria ya N.\n\nMifano:\nf_6(1) inarudisha 1", "tr": "Bir JavaScript fonksiyonu `function f_6(n)` yazın ve aşağıdaki problemi çözün:\nN'in faktöriyelini bulun ve sonucun 10007 modunu alın.\n\nParametreler:\n- N (number): Girdi değerini temsil eden negatif olmayan bir tam sayı (N <= 10000).\n\nDöndürür:\n- number: N'in faktöriyelinin 10007 modunu aldıktan sonra elde edilen sonuç.\n\nÖrnekler:\nf_6(1) 1 döndürür", "vi": "Viết một hàm JavaScript `function f_6(n)` để giải quyết vấn đề sau:  \nTìm giai thừa của N và lấy phần dư 10007 của kết quả.\n\nTham số:  \n- N (number): Một số nguyên không âm đại diện cho giá trị đầu vào (N <= 10000).\n\nTrả về:  \n- number: Kết quả sau khi lấy phần dư 10007 của giai thừa của N.\n\nVí dụ:  \nf_6(1) trả về 1", "id": "Tulis sebuah fungsi JavaScript `function f_6(n)` untuk menyelesaikan masalah berikut:\nTemukan faktorial dari N dan ambil hasil modulo 10007.\n\nParameter:\n- N (number): Sebuah bilangan bulat non-negatif yang mewakili nilai input (N <= 10000).\n\nMengembalikan:\n- number: Hasil setelah mengambil modulo 10007 dari faktorial N.\n\nContoh:\nf_6(1) mengembalikan 1", "ja": "JavaScript関数`function f_6(n)`を作成して、次の問題を解決してください。  \nNの階乗を求め、その結果の10007での剰余を取ります。\n\nパラメータ:\n- N (number): 入力値を表す非負整数 (N <= 10000)。\n\n戻り値:\n- number: Nの階乗の10007での剰余を取った結果。\n\n例:\nf_6(1) は1を返します。", "ko": "JavaScript 함수 `function f_6(n)`를 작성하여 다음 문제를 해결하십시오:\nN의 팩토리얼을 구하고 결과의 10007 모듈로를 구하십시오.\n\n매개변수:\n- N (number): 입력 값을 나타내는 0 이상의 정수 (N <= 10000).\n\n반환값:\n- number: N의 팩토리얼에 10007 모듈로를 적용한 결과.\n\n예시:\nf_6(1) returns 1", "ml": "ഒരു ജാവാസ്ക്രിപ്റ്റ് ഫംഗ്ഷൻ എഴുതുക `function f_6(n)` ഈ പ്രശ്നം പരിഹരിക്കാൻ:\nN ന്റെ ഫാക്ടോറിയൽ കണ്ടെത്തി ഫലത്തിന്റെ 10007 ലെ മോഡുലോ എടുക്കുക.\n\nParameters:\n- N (number): ഇൻപുട്ട് മൂല്യം പ്രതിനിധീകരിക്കുന്ന ഒരു അനോൺ-നെഗറ്റീവ് പൂർണ്ണസംഖ്യ (N <= 10000).\n\nReturns:\n- number: N ന്റെ ഫാക്ടോറിയലിന്റെ 10007 ലെ മോഡുലോ എടുത്ത后的 ഫലം.\n\nExamples:\nf_6(1) returns 1", "fa": "یک تابع جاوااسکریپت `function f_6(n)` بنویسید تا مسئله‌ی زیر را حل کند:\nفاکتوریل N را پیدا کنید و باقیمانده‌ی تقسیم نتیجه بر 10007 را محاسبه کنید.\n\nپارامترها:\n- N (عدد): یک عدد صحیح غیرمنفی که مقدار ورودی را نشان می‌دهد (N <= 10000).\n\nبازگشت:\n- عدد: نتیجه پس از گرفتن باقیمانده‌ی تقسیم فاکتوریل N بر 10007.\n\nمثال‌ها:\nf_6(1) مقدار 1 را برمی‌گرداند"}, "level": "middle", "test": "const testf_6 = () => {\n    console.assert(f_6(0) === 1, \"Expected factorial of 0 modulo 10007 is 1\");\n    console.assert(f_6(1) === 1, \"Expected factorial of 1 modulo 10007 is 1\");\n    console.assert(f_6(2) === 2, \"Expected factorial of 2 modulo 10007 is 2\");\n    console.assert(f_6(3) === 6, \"Expected factorial of 3 modulo 10007 is 6\");\n    console.assert(f_6(4) === 24, \"Expected factorial of 4 modulo 10007 is 24\");\n    console.assert(f_6(10) === 6266, \"Expected factorial of 10 modulo 10007 is 6266\");\n    console.assert(f_6(10000) === 6991, \"Expected factorial of 10000 modulo 10007 is 6991\");\n\n    // console.log(\"All tests passed.\");\n}\n\ntestf_6();", "entry_point": "f_6", "signature": "function f_6(n)", "docstring": {"en": "Find the factorial of N and take the modulo 10007 of the result.\n\nParameters:\n- N (number): A non-negative integer representing the input value (N <= 10000).\n\nReturns:\n- number: The result after taking the modulo 10007 of the factorial of N.\n\nExamples:\nf_6(1) returns 1\n", "sq": "Gjeni faktorialin e N dhe merrni modulo 10007 të rezultatit.\n\nParametrat:\n- N (numër): Një numër i plotë jo-negativ që përfaqëson vlerën hyrëse (N <= 10000).\n\nKthen:\n- numër: Rezultati pasi të merret modulo 10007 i faktorialit të N.\n\nShembuj:\nf_6(1) kthen 1", "hy": "Գտնել N-ի ֆակտորիալը և արդյունքը վերցնել 10007 մոդուլով։\n\nՊարամետրեր:\n- N (number): Ոչ բացասական ամբողջ թիվ, որը ներկայացնում է մուտքային արժեքը (N <= 10000)։\n\nՎերադարձնում է:\n- number: Արդյունքը N-ի ֆակտորիալը 10007 մոդուլով վերցնելուց հետո։\n\nՕրինակներ:\nf_6(1) վերադարձնում է 1", "bn": "N এর ফ্যাক্টোরিয়াল খুঁজে বের করুন এবং ফলাফলের 10007 এর মডুলো নিন।\n\nপ্যারামিটার:\n- N (number): একটি অ-ঋণাত্মক পূর্ণসংখ্যা যা ইনপুট মানকে উপস্থাপন করে (N <= 10000)।\n\nরিটার্নস:\n- number: N এর ফ্যাক্টোরিয়াল থেকে 10007 এর মডুলো নেওয়ার পর ফলাফল।\n\nউদাহরণ:\nf_6(1) returns 1", "bg": "Намерете факториела на N и вземете модуло 10007 от резултата.\n\nПараметри:\n- N (number): Ненегативно цяло число, представляващо входната стойност (N <= 10000).\n\nВръща:\n- number: Резултатът след вземане на модуло 10007 от факториела на N.\n\nПримери:\nf_6(1) връща 1", "zh": "计算N的阶乘，并对结果取模10007。\n\n参数：\n- N (number): 一个非负整数，表示输入值 (N <= 10000)。\n\n返回：\n- number: 对N的阶乘取模10007后的结果。\n\n示例：\nf_6(1) 返回 1", "fr": "Trouver la factorielle de N et prendre le modulo 10007 du résultat.\n\nParamètres:\n- N (nombre): Un entier non négatif représentant la valeur d'entrée (N <= 10000).\n\nRenvoie:\n- nombre: Le résultat après avoir pris le modulo 10007 de la factorielle de N.\n\nExemples:\nf_6(1) renvoie 1", "de": "Finde die Fakultät von N und berechne das Modulo 10007 des Ergebnisses.\n\nParameter:\n- N (number): Eine nicht-negative ganze Zahl, die den Eingabewert darstellt (N <= 10000).\n\nRückgabewert:\n- number: Das Ergebnis nach der Berechnung des Modulo 10007 der Fakultät von N.\n\nBeispiele:\nf_6(1) gibt 1 zurück", "ha": "Nemo factorial na N kuma ka ɗauki modulo 10007 na sakamakon.\n\nSigogi:\n- N (number): Lamba mara kyau wadda ke wakiltar ƙimar shigarwa (N <= 10000).\n\nDawowa:\n- number: Sakamakon bayan ɗaukar modulo 10007 na factorial na N.\n\nMisalai:\nf_6(1) returns 1", "hi": "N का फैक्टरियल खोजें और परिणाम का 10007 से माड्यूलो लें।\n\nपैरामीटर्स:\n- N (number): एक गैर-ऋणात्मक पूर्णांक जो इनपुट मान का प्रतिनिधित्व करता है (N <= 10000)।\n\nरिटर्न्स:\n- number: N के फैक्टरियल का 10007 से माड्यूलो लेने के बाद का परिणाम।\n\nउदाहरण:\nf_6(1) returns 1", "hu": "Találd meg N faktoriálisát, és vedd az eredmény 10007-es modulóját.\n\nParaméterek:\n- N (szám): Egy nem negatív egész szám, amely az input értéket képviseli (N <= 10000).\n\nVisszatér:\n- szám: Az N faktoriálisa 10007-es maradékának eredménye.\n\nPéldák:\nf_6(1) returns 1", "es": "Encontrar el factorial de N y tomar el módulo 10007 del resultado.\n\nParámetros:\n- N (number): Un entero no negativo que representa el valor de entrada (N <= 10000).\n\nDevuelve:\n- number: El resultado después de tomar el módulo 10007 del factorial de N.\n\nEjemplos:\nf_6(1) devuelve 1", "arb": "احسب مضروب N وخذ باقي القسمة 10007 من النتيجة.\n\nالمعطيات:\n- N (عدد): عدد صحيح غير سالب يمثل قيمة الإدخال (N <= 10000).\n\nالقيم المعادة:\n- عدد: النتيجة بعد أخذ باقي القسمة 10007 من مضروب N.\n\nأمثلة:\nf_6(1) يعيد 1", "sw": "Tafuta faktoria ya N na chukua modulo 10007 ya matokeo.\n\nVigezo:\n- N (number): Nambari isiyo hasi inayowakilisha thamani ya ingizo (N <= 10000).\n\nInarejesha:\n- number: Matokeo baada ya kuchukua modulo 10007 ya factorial ya N.\n\nMifano:\nf_6(1) inarejesha 1", "tr": "N'in faktöriyelini bulun ve sonucun 10007 modunu alın.\n\nParametreler:\n- N (number): Girdi değerini temsil eden negatif olmayan bir tamsayı (N <= 10000).\n\nDöndürür:\n- number: N faktöriyelinin 10007 ile modülüsünün alınmasından sonra elde edilen sonuç.\n\nÖrnekler:\nf_6(1) 1 döndürür", "vi": "Tìm giai thừa của N và lấy phần dư 10007 của kết quả.\n\nTham số:\n- N (number): Một số nguyên không âm đại diện cho giá trị đầu vào (N <= 10000).\n\nTrả về:\n- number: Kết quả sau khi lấy phần dư 10007 của giai thừa của N.\n\nVí dụ:\nf_6(1) trả về 1", "id": "Temukan faktorial dari N dan ambil modulo 10007 dari hasilnya.\n\nParameter:\n- N (number): Sebuah bilangan bulat non-negatif yang mewakili nilai input (N <= 10000).\n\nMengembalikan:\n- number: Hasil setelah mengambil modulo 10007 dari faktorial N.\n\nContoh:\nf_6(1) mengembalikan 1", "ja": "Nの階乗を求め、その結果の10007の剰余を取ります。\n\n引数:\n- N (number): 入力値を表す非負整数 (N <= 10000)。\n\n戻り値:\n- number: Nの階乗の10007の剰余を取った結果。\n\n例:\nf_6(1) は 1 を返します。", "ko": "N의 팩토리얼을 구하고 그 결과를 10007로 나눈 나머지를 구합니다.\n\n매개변수:\n- N (number): 입력 값을 나타내는 0 이상의 정수 (N <= 10000).\n\n반환:\n- number: N의 팩토리얼에 10007로 나눈 나머지를 취한 결과.\n\n예시:\nf_6(1) returns 1", "ml": "N ന്റെ ഫാക്ടോറിയൽ കണ്ടെത്തി ഫലം 10007 ന്റെ മോഡുലോ എടുക്കുക.\n\nParameters:\n- N (number): ഇൻപുട്ട് മൂല്യം പ്രതിനിധീകരിക്കുന്ന ഒരു നെഗറ്റീവ് അല്ലാത്ത പൂർണ്ണസംഖ്യ (N <= 10000).\n\nReturns:\n- number: Nന്റെ ഫാക്ടോറിയലിന്റെ മോഡുലോ 10007 എടുത്ത后的 ഫലം.\n\nExamples:\nf_6(1) returns 1", "fa": "پیدا کردن فاکتوریل N و گرفتن باقی‌مانده تقسیم بر 10007 از نتیجه.\n\nپارامترها:\n- N (number): یک عدد صحیح غیرمنفی که مقدار ورودی را نشان می‌دهد (N <= 10000).\n\nبرمی‌گرداند:\n- number: نتیجه پس از گرفتن باقی‌مانده تقسیم بر 10007 از فاکتوریل N.\n\nمثال‌ها:\nf_6(1) returns 1"}}
{"task_id": "JavaScript/7", "prompt": {"en": "// No direct imports are needed in JavaScript as we are not using any specific external libraries for this code\n/**\n * Calculate the area of a triangle given its base and height.\n * Parameters:\n * - base (number): The base length of the triangle.\n * - height (number): The height of the triangle.\n * Returns:\n * float: The calculated area of the triangle, rounded to one decimal place.\n * Examples:\n * f_7(1,2) returns 1.0\n */\nconst f_7 = (base, height) =>", "sq": "// Nuk ka nevojë për importe direkte në JavaScript pasi nuk po përdorim ndonjë bibliotekë specifike të jashtme për këtë kod\n/**\n * Llogarit sipërfaqen e një trekëndëshi duke pasur bazën dhe lartësinë e tij.\n * Parametrat:\n * - base (numër): Gjatësia e bazës së trekëndëshit.\n * - height (numër): Lartësia e trekëndëshit.\n * Kthen:\n * float: Sipërfaqja e llogaritur e trekëndëshit, e rrumbullakosur në një vend dhjetor.\n * Shembuj:\n * f_7(1,2) kthen 1.0\n */", "hy": "// JavaScript-ում ուղղակի ներմուծումներ անհրաժեշտ չեն, քանի որ այս կոդի համար հատուկ արտաքին գրադարաններ չենք օգտագործում\n/**\n * Հաշվել եռանկյան մակերեսը՝ հաշվի առնելով նրա հիմքը և բարձրությունը։\n * Պարամետրեր:\n * - base (number): Եռանկյան հիմքի երկարությունը։\n * - height (number): Եռանկյան բարձրությունը։\n * Վերադարձնում է:\n * float: Եռանկյան հաշվարկված մակերեսը՝ կլորացված մինչև մեկ տասնորդական։\n * Օրինակներ:\n * f_7(1,2) վերադարձնում է 1.0\n */\nconst f_7 = (base, height) =>", "bn": "// এই কোডের জন্য আমরা কোনো নির্দিষ্ট বাহ্যিক লাইব্রেরি ব্যবহার করছি না বলে জাভাস্ক্রিপ্টে সরাসরি কোনো ইমপোর্টের প্রয়োজন নেই\n/**\n * একটি ত্রিভুজের ভিত্তি এবং উচ্চতা দেওয়া হলে এর ক্ষেত্রফল গণনা করুন।\n * প্যারামিটারসমূহ:\n * - base (number): ত্রিভুজের ভিত্তির দৈর্ঘ্য।\n * - height (number): ত্রিভুজের উচ্চতা।\n * রিটার্নস:\n * float: ত্রিভুজের গণনা করা ক্ষেত্রফল, এক দশমিক স্থানে রাউন্ড করা।\n * উদাহরণ:\n * f_7(1,2) 1.0 রিটার্ন করে\n */", "bg": "// Не са необходими директни импорти в JavaScript, тъй като не използваме никакви специфични външни библиотеки за този код\n/**\n * Изчислява площта на триъгълник, дадени неговата основа и височина.\n * Параметри:\n * - base (number): Дължината на основата на триъгълника.\n * - height (number): Височината на триъгълника.\n * Връща:\n * float: Изчислената площ на триъгълника, закръглена до едно десетично място.\n * Примери:\n * f_7(1,2) връща 1.0\n */", "zh": "// 在JavaScript中不需要直接导入，因为我们没有使用任何特定的外部库\n/**\n * 计算给定底边和高的三角形面积。\n * 参数：\n * - base (number): 三角形的底边长度。\n * - height (number): 三角形的高度。\n * 返回：\n * float: 计算出的三角形面积，四舍五入到小数点后一位。\n * 示例：\n * f_7(1,2) 返回 1.0\n */", "fr": "// Aucune importation directe n'est nécessaire en JavaScript car nous n'utilisons pas de bibliothèques externes spécifiques pour ce code\n/**\n * Calculer l'aire d'un triangle donné sa base et sa hauteur.\n * Paramètres :\n * - base (number): La longueur de la base du triangle.\n * - height (number): La hauteur du triangle.\n * Retourne :\n * float: L'aire calculée du triangle, arrondie à une décimale.\n * Exemples :\n * f_7(1,2) returns 1.0\n */", "de": "// Keine direkten Importe in JavaScript erforderlich, da wir keine spezifischen externen Bibliotheken für diesen Code verwenden\n/**\n * Berechnet die Fläche eines Dreiecks anhand seiner Basis und Höhe.\n * Parameter:\n * - base (number): Die Basislänge des Dreiecks.\n * - height (number): Die Höhe des Dreiecks.\n * Rückgabewert:\n * float: Die berechnete Fläche des Dreiecks, auf eine Dezimalstelle gerundet.\n * Beispiele:\n * f_7(1,2) gibt 1.0 zurück\n */", "ha": "// Babu buƙatar shigo da kai tsaye a JavaScript saboda ba ma amfani da kowane takamaiman ɗakunan karatu na waje don wannan lambar\n/**\n * Lissafa yanki na alwatika la'akari da ginshiƙi da tsayinsa.\n * Sigogi:\n * - base (number): Tsawon ginshiƙin alwatika.\n * - height (number): Tsayin alwatika.\n * Returns:\n * float: An lissafa yanki na alwatika, an zagaye zuwa wuri ɗaya na ɗigon goma.\n * Misalai:\n * f_7(1,2) returns 1.0\n */", "hi": "// इस कोड के लिए किसी विशेष बाहरी लाइब्रेरी का उपयोग नहीं कर रहे हैं इसलिए JavaScript में सीधे आयात की आवश्यकता नहीं है\n/**\n * दिए गए आधार और ऊंचाई के साथ त्रिभुज का क्षेत्रफल गणना करें।\n * पैरामीटर:\n * - base (number): त्रिभुज की आधार लंबाई।\n * - height (number): त्रिभुज की ऊंचाई।\n * रिटर्न करता है:\n * float: त्रिभुज के क्षेत्रफल की गणना, एक दशमलव स्थान तक गोल की गई।\n * उदाहरण:\n * f_7(1,2) 1.0 लौटाता है\n */", "hu": "// Nincs szükség közvetlen importokra a JavaScriptben, mivel nem használunk semmilyen speciális külső könyvtárat ehhez a kódhoz\n/**\n * Számítsa ki egy háromszög területét az alapja és a magassága alapján.\n * Paraméterek:\n * - base (number): A háromszög alapjának hossza.\n * - height (number): A háromszög magassága.\n * Visszatér:\n * float: A háromszög kiszámított területe, egy tizedesjegyre kerekítve.\n * Példák:\n * f_7(1,2) visszaadja 1.0\n */", "es": "// No se necesitan importaciones directas en JavaScript ya que no estamos utilizando ninguna biblioteca externa específica para este código\n/**\n * Calcular el área de un triángulo dado su base y altura.\n * Parámetros:\n * - base (número): La longitud de la base del triángulo.\n * - height (número): La altura del triángulo.\n * Devuelve:\n * float: El área calculada del triángulo, redondeada a un decimal.\n * Ejemplos:\n * f_7(1,2) devuelve 1.0\n */\nconst f_7 = (base, height) =>", "arb": "// لا حاجة لاستيرادات مباشرة في JavaScript حيث أننا لا نستخدم أي مكتبات خارجية محددة لهذا الكود\n/**\n * حساب مساحة المثلث المعطى قاعدته وارتفاعه.\n * المعاملات:\n * - base (number): طول قاعدة المثلث.\n * - height (number): ارتفاع المثلث.\n * يعيد:\n * float: المساحة المحسوبة للمثلث، مقربة إلى منزلة عشرية واحدة.\n * أمثلة:\n * f_7(1,2) يعيد 1.0\n */\nconst f_7 = (base, height) =>", "sw": "// Hakuna uingizaji wa moja kwa moja unahitajika katika JavaScript kwani hatutumii maktaba yoyote maalum ya nje kwa msimbo huu\n/**\n * Kuhesabu eneo la pembetatu ukizingatia msingi wake na urefu.\n * Vigezo:\n * - base (nambari): Urefu wa msingi wa pembetatu.\n * - height (nambari): Urefu wa pembetatu.\n * Inarudisha:\n * float: Eneo lililohesabiwa la pembetatu, limezungushwa hadi sehemu moja ya desimali.\n * Mifano:\n * f_7(1,2) inarudisha 1.0\n */\nconst f_7 = (base, height) =>", "tr": "// Bu kod için belirli bir harici kütüphane kullanmadığımız için JavaScript'te doğrudan ithalat gerekmez\n/**\n * Tabanı ve yüksekliği verilen bir üçgenin alanını hesaplayın.\n * Parametreler:\n * - base (number): Üçgenin taban uzunluğu.\n * - height (number): Üçgenin yüksekliği.\n * Döndürür:\n * float: Hesaplanan üçgen alanı, bir ondalık basamağa yuvarlanmış olarak.\n * Örnekler:\n * f_7(1,2) 1.0 döndürür\n */\nconst f_7 = (base, height) =>", "vi": "// Không cần nhập trực tiếp trong JavaScript vì chúng ta không sử dụng bất kỳ thư viện bên ngoài cụ thể nào cho mã này\n/**\n * Tính diện tích của một tam giác dựa trên đáy và chiều cao của nó.\n * Tham số:\n * - base (number): Chiều dài đáy của tam giác.\n * - height (number): Chiều cao của tam giác.\n * Trả về:\n * float: Diện tích được tính của tam giác, làm tròn đến một chữ số thập phân.\n * Ví dụ:\n * f_7(1,2) trả về 1.0\n */\nconst f_7 = (base, height) =>", "id": "// Tidak diperlukan impor langsung dalam JavaScript karena kita tidak menggunakan pustaka eksternal khusus untuk kode ini\n/**\n * Menghitung luas segitiga berdasarkan alas dan tingginya.\n * Parameter:\n * - base (number): Panjang alas segitiga.\n * - height (number): Tinggi segitiga.\n * Mengembalikan:\n * float: Luas segitiga yang dihitung, dibulatkan ke satu tempat desimal.\n * Contoh:\n * f_7(1,2) mengembalikan 1.0\n */\nconst f_7 = (base, height) =>", "ja": "// このコードでは特定の外部ライブラリを使用していないため、JavaScriptで直接インポートする必要はありません\n/**\n * 三角形の底辺と高さを与えられたときの面積を計算します。\n * パラメータ:\n * - base (number): 三角形の底辺の長さ。\n * - height (number): 三角形の高さ。\n * 戻り値:\n * float: 計算された三角形の面積を小数点以下1桁に丸めたもの。\n * 例:\n * f_7(1,2) は 1.0 を返します\n */\nconst f_7 = (base, height) =>", "ko": "// 이 코드에서는 특정 외부 라이브러리를 사용하지 않으므로 JavaScript에서 직접적인 import는 필요하지 않습니다.\n/**\n * 주어진 밑변과 높이를 통해 삼각형의 면적을 계산합니다.\n * 매개변수:\n * - base (number): 삼각형의 밑변 길이.\n * - height (number): 삼각형의 높이.\n * 반환값:\n * float: 소수점 첫째 자리까지 반올림된, 계산된 삼각형의 면적.\n * 예시:\n * f_7(1,2) returns 1.0\n */\nconst f_7 = (base, height) =>", "ml": "// ഈ കോഡിനായി നമുക്ക് യാതൊരു പ്രത്യേക ബാഹ്യ ലൈബ്രറികളും ഉപയോഗിക്കുന്നില്ലാത്തതിനാൽ JavaScript-ൽ നേരിട്ടുള്ള ഇറക്കുമതികൾ ആവശ്യമില്ല\n/**\n * ഒരു ത്രികോണത്തിന്റെ അടിസ്ഥാനവും ഉയരവും നൽകിയാൽ അതിന്റെ വിസ്തീർണ്ണം കണക്കാക്കുക.\n * പാരാമീറ്ററുകൾ:\n * - base (number): ത്രികോണത്തിന്റെ അടിസ്ഥാന ദൈർഘ്യം.\n * - height (number): ത്രികോണത്തിന്റെ ഉയരം.\n * മടക്കുക:\n * float: ഒരു ദശാംശ സ്ഥാനം വരെ വട്ടമിട്ട് കണക്കാക്കിയ ത്രികോണത്തിന്റെ വിസ്തീർണ്ണം.\n * ഉദാഹരണങ്ങൾ:\n * f_7(1,2) 1.0 മടക്കുന്നു\n */\nconst f_7 = (base, height) =>", "fa": "// نیازی به وارد کردن مستقیم در جاوااسکریپت نیست زیرا ما از هیچ کتابخانه خارجی خاصی برای این کد استفاده نمی‌کنیم\n/**\n * محاسبه مساحت یک مثلث با توجه به پایه و ارتفاع آن.\n * پارامترها:\n * - base (number): طول پایه مثلث.\n * - height (number): ارتفاع مثلث.\n * بازگشت:\n * float: مساحت محاسبه شده مثلث، گرد شده به یک رقم اعشار.\n * مثال‌ها:\n * f_7(1,2) returns 1.0\n */\nconst f_7 = (base, height) =>"}, "canonical_solution": "{\n    return (base * height) / 2.0; // The formula for the area of a triangle is (base * height) / 2\n};", "instruction": {"en": "Write a JavaScript function `const f_7 = (base, height)` to solve the following problem:\nCalculate the area of a triangle given its base and height.\nParameters:\n- base (number): The base length of the triangle.\n- height (number): The height of the triangle.\nReturns:\nfloat: The calculated area of the triangle, rounded to one decimal place.\nExamples:\nf_7(1,2) returns 1.0", "sq": "Shkruani një funksion JavaScript `const f_7 = (base, height)` për të zgjidhur problemin e mëposhtëm:  \nLlogaritni sipërfaqen e një trekëndëshi duke pasur bazën dhe lartësinë e tij.  \nParametrat:  \n- base (number): Gjatësia e bazës së trekëndëshit.  \n- height (number): Lartësia e trekëndëshit.  \nKthen:  \nfloat: Sipërfaqja e llogaritur e trekëndëshit, e rrumbullakosur në një vend dhjetor.  \nShembuj:  \nf_7(1,2) kthen 1.0  ", "hy": "Գրեք JavaScript ֆունկցիա `const f_7 = (base, height)` հետևյալ խնդիրը լուծելու համար:\nՀաշվեք եռանկյան մակերեսը՝ հաշվի առնելով դրա հիմքը և բարձրությունը:\nՊարամետրեր:\n- base (number): Եռանկյան հիմքի երկարությունը:\n- height (number): Եռանկյան բարձրությունը:\nՎերադարձնում է:\nfloat: Եռանկյան հաշվարկված մակերեսը, կլորացված մինչև մեկ տասնորդական:\nՕրինակներ:\nf_7(1,2) returns 1.0", "bn": "একটি জাভাস্ক্রিপ্ট ফাংশন `const f_7 = (base, height)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএর ভিত্তি এবং উচ্চতা দেওয়া একটি ত্রিভুজের ক্ষেত্রফল গণনা করুন।\nপ্যারামিটারসমূহ:\n- base (number): ত্রিভুজের ভিত্তির দৈর্ঘ্য।\n- height (number): ত্রিভুজের উচ্চতা।\nফেরত দেয়:\nfloat: ত্রিভুজের গণনা করা ক্ষেত্রফল, এক দশমিক স্থানে গোলাকার।\nউদাহরণসমূহ:\nf_7(1,2) ফেরত দেয় 1.0", "bg": "Напишете JavaScript функция `const f_7 = (base, height)`, за да решите следния проблем:  \nИзчислете площта на триъгълник, като се даде неговата основа и височина.  \nПараметри:  \n- base (number): Дължината на основата на триъгълника.  \n- height (number): Височината на триъгълника.  \nВръща:  \nfloat: Изчислената площ на триъгълника, закръглена до един десетичен знак.  \nПримери:  \nf_7(1,2) връща 1.0", "zh": "编写一个 JavaScript 函数 `const f_7 = (base, height)` 来解决以下问题：  \n计算给定底边和高的三角形的面积。  \n参数：  \n- base (number): 三角形的底边长度。  \n- height (number): 三角形的高度。  \n返回：  \nfloat: 计算出的三角形面积，四舍五入到小数点后一位。  \n示例：  \nf_7(1,2) 返回 1.0", "fr": "Écrire une fonction JavaScript `const f_7 = (base, height)` pour résoudre le problème suivant :  \nCalculer l'aire d'un triangle donné sa base et sa hauteur.  \nParamètres :  \n- base (number): La longueur de la base du triangle.  \n- height (number): La hauteur du triangle.  \nRenvoie :  \nfloat: L'aire calculée du triangle, arrondie à une décimale.  \nExemples :  \nf_7(1,2) returns 1.0  ", "de": "Schreiben Sie eine JavaScript-Funktion `const f_7 = (base, height)`, um das folgende Problem zu lösen:\nBerechnen Sie die Fläche eines Dreiecks, gegeben seine Basis und Höhe.\nParameter:\n- base (number): Die Basislänge des Dreiecks.\n- height (number): Die Höhe des Dreiecks.\nRückgabewert:\nfloat: Die berechnete Fläche des Dreiecks, gerundet auf eine Dezimalstelle.\nBeispiele:\nf_7(1,2) returns 1.0", "ha": "Rubuta aikin JavaScript `const f_7 = (base, height)` don warware matsalar mai zuwa:\nƘididdige yanki na alwatika idan aka ba da tushe da tsawo.\nSigogi:\n- base (number): Tsawon tushe na alwatika.\n- height (number): Tsawon alwatika.\nYa dawo:\nfloat: Yankin da aka ƙididdige na alwatika, an zagaye zuwa wuri ɗaya na goma.\nMisalai:\nf_7(1,2) returns 1.0", "hi": "JavaScript फ़ंक्शन `const f_7 = (base, height)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nत्रिभुज का क्षेत्रफल उसकी आधार और ऊँचाई के आधार पर गणना करें।\nपैरामीटर्स:\n- base (number): त्रिभुज की आधार लंबाई।\n- height (number): त्रिभुज की ऊँचाई।\nवापसी:\nfloat: त्रिभुज का गणना किया गया क्षेत्रफल, एक दशमलव स्थान तक गोल किया गया।\nउदाहरण:\nf_7(1,2) 1.0 लौटाता है।", "hu": "Írj egy JavaScript függvényt `const f_7 = (base, height)` a következő probléma megoldására:\nSzámítsd ki egy háromszög területét az alapja és magassága alapján.\nParaméterek:\n- base (number): A háromszög alapjának hossza.\n- height (number): A háromszög magassága.\nVisszatérési érték:\nfloat: A háromszög kiszámított területe, egy tizedesjegyre kerekítve.\nPéldák:\nf_7(1,2) visszaadja 1.0", "es": "Escribe una función de JavaScript `const f_7 = (base, height)` para resolver el siguiente problema:\nCalcular el área de un triángulo dado su base y altura.\nParámetros:\n- base (number): La longitud de la base del triángulo.\n- height (number): La altura del triángulo.\nDevuelve:\nfloat: El área calculada del triángulo, redondeada a un decimal.\nEjemplos:\nf_7(1,2) devuelve 1.0", "arb": "اكتب دالة JavaScript `const f_7 = (base, height)` لحل المشكلة التالية:\nحساب مساحة المثلث المعطى قاعدته وارتفاعه.\nالمعطيات:\n- base (number): طول قاعدة المثلث.\n- height (number): ارتفاع المثلث.\nالإرجاع:\nfloat: المساحة المحسوبة للمثلث، مقربة إلى مكان عشري واحد.\nأمثلة:\nf_7(1,2) يعيد 1.0", "sw": "Andika kazi ya JavaScript `const f_7 = (base, height)` kutatua tatizo lifuatalo:\nHesabu eneo la pembetatu ukitumia msingi wake na urefu.\nVigezo:\n- base (number): Urefu wa msingi wa pembetatu.\n- height (number): Urefu wa pembetatu.\nInarejesha:\nfloat: Eneo lililohesabiwa la pembetatu, limezungushwa hadi sehemu moja ya desimali.\nMifano:\nf_7(1,2) inarejesha 1.0", "tr": "Bir JavaScript fonksiyonu `const f_7 = (base, height)` yazın:\nÜçgenin taban uzunluğu ve yüksekliği verildiğinde alanını hesaplayın.\nParametreler:\n- base (number): Üçgenin taban uzunluğu.\n- height (number): Üçgenin yüksekliği.\nDöndürür:\nfloat: Hesaplanan üçgen alanı, bir ondalık basamağa yuvarlanmış.\nÖrnekler:\nf_7(1,2) 1.0 döndürür", "vi": "Viết một hàm JavaScript `const f_7 = (base, height)` để giải quyết vấn đề sau:  \nTính diện tích của một tam giác khi biết đáy và chiều cao của nó.  \nTham số:  \n- base (number): Chiều dài đáy của tam giác.  \n- height (number): Chiều cao của tam giác.  \nTrả về:  \nfloat: Diện tích đã tính của tam giác, làm tròn đến một chữ số thập phân.  \nVí dụ:  \nf_7(1,2) trả về 1.0  ", "id": "Tulis fungsi JavaScript `const f_7 = (base, height)` untuk menyelesaikan masalah berikut:\nHitung luas segitiga yang diberikan alas dan tingginya.\nParameter:\n- base (number): Panjang alas segitiga.\n- height (number): Tinggi segitiga.\nMengembalikan:\nfloat: Luas segitiga yang dihitung, dibulatkan ke satu tempat desimal.\nContoh:\nf_7(1,2) mengembalikan 1.0", "ja": "JavaScript関数 `const f_7 = (base, height)` を作成して、次の問題を解決してください:\n三角形の底辺と高さが与えられたときの面積を計算します。\nパラメータ:\n- base (number): 三角形の底辺の長さ。\n- height (number): 三角形の高さ。\n戻り値:\nfloat: 計算された三角形の面積を小数点以下1桁に丸めた値。\n例:\nf_7(1,2) は 1.0 を返します。", "ko": "`const f_7 = (base, height)` 함수를 작성하여 다음 문제를 해결하십시오:\n삼각형의 밑변과 높이가 주어졌을 때, 삼각형의 넓이를 계산하십시오.\n매개변수:\n- base (number): 삼각형의 밑변 길이.\n- height (number): 삼각형의 높이.\n반환값:\nfloat: 소수점 한 자리까지 반올림된 삼각형의 계산된 넓이.\n예시:\nf_7(1,2) returns 1.0", "ml": "ഒരു ജാവാസ്ക്രിപ്റ്റ് ഫങ്ഷൻ `const f_7 = (base, height)` എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:  \nഒരു ത്രികോണത്തിന്റെ അടിസ്ഥാനവും ഉയരവും നൽകിയാൽ അതിന്റെ വിസ്തീർണം കണക്കാക്കുക.  \nപാരാമീറ്ററുകൾ:  \n- base (number): ത്രികോണത്തിന്റെ അടിസ്ഥാനത്തിന്റെ നീളം.  \n- height (number): ത്രികോണത്തിന്റെ ഉയരം.  \nമടക്കം:  \nfloat: കണക്കാക്കിയ ത്രികോണത്തിന്റെ വിസ്തീർണം, ഒരു ദശാംശ സ്ഥാനം വരെ വട്ടമിടുക.  \nഉദാഹരണങ്ങൾ:  \nf_7(1,2) 1.0 മടക്കുന്നു", "fa": "یک تابع جاوا اسکریپت `const f_7 = (base, height)` بنویسید تا مسئله زیر را حل کند:\nمساحت یک مثلث را با توجه به قاعده و ارتفاع آن محاسبه کنید.\nپارامترها:\n- base (number): طول قاعده مثلث.\n- height (number): ارتفاع مثلث.\nبرمی‌گرداند:\nfloat: مساحت محاسبه شده مثلث، گرد شده به یک رقم اعشار.\nمثال‌ها:\nf_7(1,2) returns 1.0"}, "level": "easy", "test": "const testf_7 = () => {\n    const epsilon = 1e-6;\n    console.assert(Math.abs(f_7(1, 2) - 1.0) < epsilon);\n    console.assert(Math.abs(f_7(3, 4) - 6.0) < epsilon);\n    console.assert(Math.abs(f_7(5, 8) - 20.0) < epsilon);\n    console.assert(Math.abs(f_7(7, 3) - 10.5) < epsilon);\n    console.assert(Math.abs(f_7(10, 10) - 50.0) < epsilon);\n    \n    // console.log(\"All tests passed.\");\n};\n\ntestf_7();", "entry_point": "f_7", "signature": "const f_7 = (base, height)", "docstring": {"en": "Calculate the area of a triangle given its base and height.\nParameters:\n- base (number): The base length of the triangle.\n- height (number): The height of the triangle.\nReturns:\nfloat: The calculated area of the triangle, rounded to one decimal place.\nExamples:\nf_7(1,2) returns 1.0", "sq": "Llogarit sipërfaqen e një trekëndëshi duke pasur bazën dhe lartësinë e tij.\nParametrat:\n- base (numër): Gjatësia e bazës së trekëndëshit.\n- height (numër): Lartësia e trekëndëshit.\nKthen:\nfloat: Sipërfaqja e llogaritur e trekëndëshit, e rrumbullakosur në një vend dhjetor.\nShembuj:\nf_7(1,2) kthen 1.0", "hy": "Եռանկյան մակերեսը հաշվարկել՝ հաշվի առնելով նրա հիմքը և բարձրությունը:\nՊարամետրեր:\n- base (number): Եռանկյան հիմքի երկարությունը:\n- height (number): Եռանկյան բարձրությունը:\nՎերադարձնում է:\nfloat: Եռանկյան հաշվարկված մակերեսը, կլորացված մինչև մեկ տասնորդական:\nՕրինակներ:\nf_7(1,2) վերադարձնում է 1.0", "bn": "ত্রিভুজের ভিত্তি এবং উচ্চতা দেওয়া থাকলে এর ক্ষেত্রফল গণনা করুন।\nপ্যারামিটারসমূহ:\n- base (number): ত্রিভুজের ভিত্তির দৈর্ঘ্য।\n- height (number): ত্রিভুজের উচ্চতা।\nফেরত দেয়:\nfloat: ত্রিভুজের গণনা করা ক্ষেত্রফল, এক দশমিক স্থান পর্যন্ত গোলাকার।\nউদাহরণসমূহ:\nf_7(1,2) 1.0 ফেরত দেয়", "bg": "Изчислява площта на триъгълник, дадени неговата основа и височина.\nПараметри:\n- base (number): Дължината на основата на триъгълника.\n- height (number): Височината на триъгълника.\nВръща:\nfloat: Изчислената площ на триъгълника, закръглена до едно десетично място.\nПримери:\nf_7(1,2) връща 1.0", "zh": "计算给定底边和高的三角形面积。\n参数：\n- base (number): 三角形的底边长度。\n- height (number): 三角形的高度。\n返回：\nfloat: 计算出的三角形面积，四舍五入到小数点后一位。\n示例：\nf_7(1,2) 返回 1.0", "fr": "Calculer l'aire d'un triangle donné sa base et sa hauteur.\nParamètres:\n- base (nombre): La longueur de la base du triangle.\n- height (nombre): La hauteur du triangle.\nRenvoie:\nfloat: L'aire calculée du triangle, arrondie à un chiffre après la virgule.\nExemples:\nf_7(1,2) renvoie 1.0", "de": "Berechne die Fläche eines Dreiecks anhand seiner Basis und Höhe.\nParameter:\n- base (number): Die Basislänge des Dreiecks.\n- height (number): Die Höhe des Dreiecks.\nRückgabewert:\nfloat: Die berechnete Fläche des Dreiecks, auf eine Dezimalstelle gerundet.\nBeispiele:\nf_7(1,2) gibt 1.0 zurück", "ha": "Babu buƙatar shigo da kai tsaye a JavaScript saboda ba ma amfani da kowane takamaiman ɗakunan karatu na waje don wannan lambar\nSigogi:\n- base (number): Tsawon tushe na alwatika.\n- height (number): Tsawon tsawo na alwatika.\nDawowa:\nfloat: An lissafa yankin alwatika, an zagaye zuwa wurin goma daya.\nMisalai:\nf_7(1,2) returns 1.0", "hi": "त्रिभुज का क्षेत्रफल इसकी आधार और ऊँचाई के आधार पर गणना करें।\nपैरामीटर्स:\n- base (संख्या): त्रिभुज की आधार लंबाई।\n- height (संख्या): त्रिभुज की ऊँचाई।\nवापसी:\nfloat: त्रिभुज का गणना किया गया क्षेत्रफल, एक दशमलव स्थान तक गोल किया गया।\nउदाहरण:\nf_7(1,2) 1.0 लौटाता है।", "hu": "Számítsa ki egy háromszög területét az alapja és magassága alapján.\nParaméterek:\n- base (szám): A háromszög alapjának hossza.\n- height (szám): A háromszög magassága.\nVisszatérési érték:\nfloat: A háromszög kiszámított területe, egy tizedesjegyre kerekítve.\nPéldák:\nf_7(1,2) visszaadja 1.0", "es": "Calcular el área de un triángulo dado su base y altura.\nParámetros:\n- base (number): La longitud de la base del triángulo.\n- height (number): La altura del triángulo.\nDevuelve:\nfloat: El área calculada del triángulo, redondeada a un decimal.\nEjemplos:\nf_7(1,2) devuelve 1.0", "arb": "احسب مساحة المثلث بناءً على قاعدته وارتفاعه.\nالمعلمات:\n- base (number): طول قاعدة المثلث.\n- height (number): ارتفاع المثلث.\nالقيم المعادة:\nfloat: المساحة المحسوبة للمثلث، مقربة إلى منزلة عشرية واحدة.\nأمثلة:\nf_7(1,2) يعيد 1.0", "sw": "Hesabu eneo la pembetatu ukitumia msingi wake na urefu.\nVigezo:\n- base (number): Urefu wa msingi wa pembetatu.\n- height (number): Urefu wa pembetatu.\nInarejesha:\nfloat: Eneo lililohesabiwa la pembetatu, limezungushwa hadi sehemu moja ya desimali.\nMifano:\nf_7(1,2) inarejesha 1.0", "tr": "Üçgenin tabanı ve yüksekliği verildiğinde alanını hesaplayın.\nParametreler:\n- base (number): Üçgenin taban uzunluğu.\n- height (number): Üçgenin yüksekliği.\nDöndürülen:\nfloat: Üçgenin hesaplanan alanı, bir ondalık basamağa yuvarlanmış.\nÖrnekler:\nf_7(1,2) 1.0 döndürür", "vi": "Tính diện tích của một tam giác dựa trên đáy và chiều cao của nó.  \nTham số:  \n- base (number): Chiều dài đáy của tam giác.  \n- height (number): Chiều cao của tam giác.  \nTrả về:  \nfloat: Diện tích đã tính của tam giác, làm tròn đến một chữ số thập phân.  \nVí dụ:  \nf_7(1,2) trả về 1.0  ", "id": "Hitung luas segitiga berdasarkan alas dan tingginya.\nParameter:\n- base (number): Panjang alas segitiga.\n- height (number): Tinggi segitiga.\nMengembalikan:\nfloat: Luas segitiga yang dihitung, dibulatkan ke satu tempat desimal.\nContoh:\nf_7(1,2) mengembalikan 1.0", "ja": "三角形の底辺と高さが与えられたときの面積を計算します。  \n引数:  \n- base (number): 三角形の底辺の長さ。  \n- height (number): 三角形の高さ。  \n戻り値:  \nfloat: 計算された三角形の面積を小数点以下1桁に丸めたもの。  \n例:  \nf_7(1,2) は 1.0 を返します。", "ko": "삼각형의 밑변과 높이가 주어졌을 때, 삼각형의 면적을 계산합니다.\n매개변수:\n- base (number): 삼각형의 밑변 길이.\n- height (number): 삼각형의 높이.\n반환값:\nfloat: 소수점 첫째 자리까지 반올림된 삼각형의 계산된 면적.\n예시:\nf_7(1,2) returns 1.0", "ml": "ത്രികോണത്തിന്റെ അടിസ്ഥാനവും ഉയരവും നൽകിയാൽ അതിന്റെ വിസ്തീർണ്ണം കണക്കാക്കുക.\nപാരാമീറ്ററുകൾ:\n- base (number): ത്രികോണത്തിന്റെ അടിസ്ഥാനത്തിന്റെ നീളം.\n- height (number): ത്രികോണത്തിന്റെ ഉയരം.\nമടക്കം:\nfloat: ഒരു ദശാംശ സ്ഥാനത്തേക്ക് വട്ടമിട്ട ത്രികോണത്തിന്റെ കണക്കാക്കിയ വിസ്തീർണ്ണം.\nഉദാഹരണങ്ങൾ:\nf_7(1,2) 1.0 മടക്കുന്നു", "fa": "محاسبه مساحت یک مثلث با توجه به قاعده و ارتفاع آن.\nپارامترها:\n- base (number): طول قاعده مثلث.\n- height (number): ارتفاع مثلث.\nبازگشت:\nfloat: مساحت محاسبه‌شده مثلث، گرد شده به یک رقم اعشار.\nمثال‌ها:\nf_7(1,2) بازمی‌گرداند 1.0"}}
{"task_id": "JavaScript/8", "prompt": {"en": "/**\n * Calculate the Hamming distance between two integers in their binary representation.\n *\n * Parameters:\n * - x: The first positive integer (x <= 1,000,000,000).\n * - y: The second positive integer (y <= 1,000,000,000).\n *\n * Returns:\n * The Hamming distance between x and y, i.e., the number of bits that need to be\n * flipped to transform x into y.\n * \n * Examples:\n * f_8(1, 2) // returns 2\n */\nfunction f_8(x, y)", "sq": "/**\n * Llogarit distancën Hamming midis dy numrave të plotë në përfaqësimin e tyre binar.\n *\n * Parametrat:\n * - x: Numri i parë pozitiv (x <= 1,000,000,000).\n * - y: Numri i dytë pozitiv (y <= 1,000,000,000).\n *\n * Kthen:\n * Distanca Hamming midis x dhe y, dmth, numri i bitëve që duhet të ndryshohen\n * për të transformuar x në y.\n * \n * Shembuj:\n * f_8(1, 2) // kthen 2\n */\nfunction f_8(x, y)", "hy": "/**\n * Հաշվել Հեմինգի հեռավորությունը երկու ամբողջ թվերի միջև իրենց բինար ներկայացման մեջ։\n *\n * Պարամետրեր:\n * - x: Առաջին դրական ամբողջ թիվը (x <= 1,000,000,000)։\n * - y: Երկրորդ դրական ամբողջ թիվը (y <= 1,000,000,000)։\n *\n * Վերադարձնում է:\n * Հեմինգի հեռավորությունը x-ի և y-ի միջև, այսինքն՝ բիթերի քանակը, որոնք պետք է\n * փոխվեն x-ը y-ի վերածելու համար։\n * \n * Օրինակներ:\n * f_8(1, 2) // վերադարձնում է 2\n */\nfunction f_8(x, y)", "bn": "/**\n * দুটি পূর্ণসংখ্যার বাইনারি উপস্থাপনার মধ্যে হ্যামিং দূরত্ব গণনা করুন।\n *\n * প্যারামিটার:\n * - x: প্রথম ধনাত্মক পূর্ণসংখ্যা (x <= 1,000,000,000)।\n * - y: দ্বিতীয় ধনাত্মক পূর্ণসংখ্যা (y <= 1,000,000,000)।\n *\n * রিটার্ন:\n * x এবং y এর মধ্যে হ্যামিং দূরত্ব, অর্থাৎ x কে y তে রূপান্তর করতে যে সংখ্যক বিট\n * উল্টাতে হবে।\n * \n * উদাহরণ:\n * f_8(1, 2) // 2 রিটার্ন করে\n */\nfunction f_8(x, y)", "bg": "/**\n * Изчислява разстоянието на Хаминг между две цели числа в тяхното двоично представяне.\n *\n * Параметри:\n * - x: Първото положително цяло число (x <= 1,000,000,000).\n * - y: Второто положително цяло число (y <= 1,000,000,000).\n *\n * Връща:\n * Разстоянието на Хаминг между x и y, т.е. броят на битовете, които трябва да бъдат\n * обърнати, за да се трансформира x в y.\n * \n * Примери:\n * f_8(1, 2) // връща 2\n */\nfunction f_8(x, y)", "zh": "/**\n * 计算两个整数在其二进制表示中的汉明距离。\n *\n * 参数:\n * - x: 第一个正整数 (x <= 1,000,000,000)。\n * - y: 第二个正整数 (y <= 1,000,000,000)。\n *\n * 返回:\n * x 和 y 之间的汉明距离，即需要翻转的位数以将 x 转换为 y。\n * \n * 示例:\n * f_8(1, 2) // 返回 2\n */\nfunction f_8(x, y)", "fr": "/**\n * Calculer la distance de Hamming entre deux entiers dans leur représentation binaire.\n *\n * Paramètres :\n * - x : Le premier entier positif (x <= 1,000,000,000).\n * - y : Le deuxième entier positif (y <= 1,000,000,000).\n *\n * Renvoie :\n * La distance de Hamming entre x et y, c'est-à-dire le nombre de bits qui doivent être\n * inversés pour transformer x en y.\n * \n * Exemples :\n * f_8(1, 2) // returns 2\n */\nfunction f_8(x, y)", "de": "/**\n * Berechne die Hamming-Distanz zwischen zwei ganzen Zahlen in ihrer Binärdarstellung.\n *\n * Parameter:\n * - x: Die erste positive ganze Zahl (x <= 1,000,000,000).\n * - y: Die zweite positive ganze Zahl (y <= 1,000,000,000).\n *\n * Rückgabewert:\n * Die Hamming-Distanz zwischen x und y, d.h., die Anzahl der Bits, die umgekippt werden müssen,\n * um x in y zu transformieren.\n * \n * Beispiele:\n * f_8(1, 2) // gibt 2 zurück\n */\nfunction f_8(x, y)", "ha": "/**\n * Lissafa tazara ta Hamming tsakanin lambobi biyu a cikin wakilarsu ta binary.\n *\n * Sigogi:\n * - x: Lamba ta farko mai kyau (x <= 1,000,000,000).\n * - y: Lamba ta biyu mai kyau (y <= 1,000,000,000).\n *\n * Komawa:\n * Tazara ta Hamming tsakanin x da y, wato, adadin bits da ake bukata\n * a juya don canza x zuwa y.\n * \n * Misalai:\n * f_8(1, 2) // yana dawowa 2\n */\nfunction f_8(x, y)", "hi": "/**\n * दो पूर्णांकों के द्विआधारी रूप में हैमिंग दूरी की गणना करें।\n *\n * पैरामीटर:\n * - x: पहला धनात्मक पूर्णांक (x <= 1,000,000,000)।\n * - y: दूसरा धनात्मक पूर्णांक (y <= 1,000,000,000)।\n *\n * रिटर्न करता है:\n * x और y के बीच की हैमिंग दूरी, अर्थात्, x को y में बदलने के लिए जिन बिट्स को पलटना आवश्यक है उनकी संख्या।\n * \n * उदाहरण:\n * f_8(1, 2) // 2 लौटाता है\n */\nfunction f_8(x, y)", "hu": "/**\n * Számítsa ki a Hamming-távolságot két egész szám bináris ábrázolása között.\n *\n * Paraméterek:\n * - x: Az első pozitív egész szám (x <= 1,000,000,000).\n * - y: A második pozitív egész szám (y <= 1,000,000,000).\n *\n * Visszatér:\n * A Hamming-távolság x és y között, azaz a bitek száma, amelyeket meg kell\n * fordítani ahhoz, hogy x-ből y-t kapjunk.\n * \n * Példák:\n * f_8(1, 2) // visszaadja 2\n */\nfunction f_8(x, y)", "es": "/**\n * Calcular la distancia de Hamming entre dos enteros en su representación binaria.\n *\n * Parámetros:\n * - x: El primer entero positivo (x <= 1,000,000,000).\n * - y: El segundo entero positivo (y <= 1,000,000,000).\n *\n * Devuelve:\n * La distancia de Hamming entre x e y, es decir, el número de bits que deben ser\n * cambiados para transformar x en y.\n * \n * Ejemplos:\n * f_8(1, 2) // devuelve 2\n */\nfunction f_8(x, y)", "arb": "/**\n * حساب مسافة هامنج بين عددين صحيحين في تمثيلهما الثنائي.\n *\n * المعاملات:\n * - x: العدد الصحيح الأول الموجب (x <= 1,000,000,000).\n * - y: العدد الصحيح الثاني الموجب (y <= 1,000,000,000).\n *\n * يعيد:\n * مسافة هامنج بين x و y، أي عدد البتات التي تحتاج إلى\n * قلبها لتحويل x إلى y.\n * \n * أمثلة:\n * f_8(1, 2) // يعيد 2\n */\nfunction f_8(x, y)", "sw": "/**\n * Hesabu umbali wa Hamming kati ya nambari mbili katika uwakilishi wao wa binary.\n *\n * Vigezo:\n * - x: Nambari ya kwanza chanya (x <= 1,000,000,000).\n * - y: Nambari ya pili chanya (y <= 1,000,000,000).\n *\n * Inarejesha:\n * Umbali wa Hamming kati ya x na y, yaani, idadi ya biti zinazohitaji\n * kubadilishwa ili kubadilisha x kuwa y.\n * \n * Mifano:\n * f_8(1, 2) // inarejesha 2\n */\nfunction f_8(x, y)", "tr": "/**\n * İki tam sayının ikili gösterimlerinde Hamming mesafesini hesapla.\n *\n * Parametreler:\n * - x: İlk pozitif tam sayı (x <= 1,000,000,000).\n * - y: İkinci pozitif tam sayı (y <= 1,000,000,000).\n *\n * Döndürür:\n * x ve y arasındaki Hamming mesafesi, yani x'i y'ye dönüştürmek için\n * çevrilmesi gereken bit sayısı.\n * \n * Örnekler:\n * f_8(1, 2) // 2 döndürür\n */\nfunction f_8(x, y)", "vi": "/**\n * Tính khoảng cách Hamming giữa hai số nguyên trong biểu diễn nhị phân của chúng.\n *\n * Tham số:\n * - x: Số nguyên dương thứ nhất (x <= 1,000,000,000).\n * - y: Số nguyên dương thứ hai (y <= 1,000,000,000).\n *\n * Trả về:\n * Khoảng cách Hamming giữa x và y, tức là số bit cần phải\n * lật để biến đổi x thành y.\n * \n * Ví dụ:\n * f_8(1, 2) // trả về 2\n */\nfunction f_8(x, y)", "id": "/**\n * Menghitung jarak Hamming antara dua bilangan bulat dalam representasi biner mereka.\n *\n * Parameter:\n * - x: Bilangan bulat positif pertama (x <= 1,000,000,000).\n * - y: Bilangan bulat positif kedua (y <= 1,000,000,000).\n *\n * Mengembalikan:\n * Jarak Hamming antara x dan y, yaitu jumlah bit yang perlu dibalik untuk mengubah x menjadi y.\n * \n * Contoh:\n * f_8(1, 2) // mengembalikan 2\n */\nfunction f_8(x, y)", "ja": "/**\n * 2つの整数の2進数表現におけるハミング距離を計算します。\n *\n * パラメータ:\n * - x: 最初の正の整数 (x <= 1,000,000,000)。\n * - y: 2番目の正の整数 (y <= 1,000,000,000)。\n *\n * 戻り値:\n * xとyの間のハミング距離、つまりxをyに変換するために反転する必要があるビットの数。\n * \n * 例:\n * f_8(1, 2) // returns 2\n */\nfunction f_8(x, y)", "ko": "/**\n * 두 정수를 이진 표현으로 변환했을 때의 해밍 거리(Hamming distance)를 계산합니다.\n *\n * 매개변수:\n * - x: 첫 번째 양의 정수 (x <= 1,000,000,000).\n * - y: 두 번째 양의 정수 (y <= 1,000,000,000).\n *\n * 반환값:\n * x와 y 사이의 해밍 거리, 즉 x를 y로 변환하기 위해 뒤집어야 하는 비트의 수를 반환합니다.\n * \n * 예시:\n * f_8(1, 2) // returns 2\n */\nfunction f_8(x, y)", "ml": "/**\n * രണ്ട് പൂർണ്ണസംഖ്യകളുടെ ബൈനറി പ്രതിനിധാനത്തിൽ ഹാമിംഗ് ദൂരം കണക്കാക്കുക.\n *\n * പാരാമീറ്ററുകൾ:\n * - x: ആദ്യത്തെ പോസിറ്റീവ് പൂർണ്ണസംഖ്യ (x <= 1,000,000,000).\n * - y: രണ്ടാം പോസിറ്റീവ് പൂർണ്ണസംഖ്യ (y <= 1,000,000,000).\n *\n * തിരികെ നൽകുന്നു:\n * x നെ y ആക്കാൻ മാറ്റേണ്ട ബിറ്റുകളുടെ എണ്ണം, അഥവാ x യും y യും തമ്മിലുള്ള ഹാമിംഗ് ദൂരം.\n * \n * ഉദാഹരണങ്ങൾ:\n * f_8(1, 2) // 2 തിരികെ നൽകുന്നു\n */\nfunction f_8(x, y)", "fa": "/**\n * محاسبه فاصله همینگ بین دو عدد صحیح در نمایش باینری آن‌ها.\n *\n * پارامترها:\n * - x: عدد صحیح اول (x <= 1,000,000,000).\n * - y: عدد صحیح دوم (y <= 1,000,000,000).\n *\n * بازگشت:\n * فاصله همینگ بین x و y، یعنی تعداد بیت‌هایی که باید تغییر کنند تا x به y تبدیل شود.\n * \n * مثال‌ها:\n * f_8(1, 2) // بازگشت 2\n */\nfunction f_8(x, y)"}, "canonical_solution": "{\n    let distance = 0;\n    let xorResult = x ^ y; // XOR x and y to get a number where set bits are the differences\n\n    // Count the number of bits set in xorResult\n    while (xorResult) {\n        distance += xorResult & 1; // Increment distance if the last bit is set\n        xorResult >>= 1; // Shift right by one bit to check the next bit\n    }\n\n    return distance;\n}", "instruction": {"en": "Write a JavaScript function `function f_8(x, y)` to solve the following problem:\nCalculate the Hamming distance between two integers in their binary representation.\n\nParameters:\n- x: The first positive integer (x <= 1,000,000,000).\n- y: The second positive integer (y <= 1,000,000,000).\n\nReturns:\n- The Hamming distance between x and y, i.e., the number of bits that need to be\nflipped to transform x into y.\n\nExamples:\n- f_8(1, 2) // returns 2\n", "sq": "Shkruani një funksion JavaScript `function f_8(x, y)` për të zgjidhur problemin e mëposhtëm:  \nLlogaritni distancën Hamming midis dy numrave të plotë në përfaqësimin e tyre binar.\n\nParametrat:\n- x: Numri i parë pozitiv (x <= 1,000,000,000).\n- y: Numri i dytë pozitiv (y <= 1,000,000,000).\n\nKthen:\n- Distanca Hamming midis x dhe y, dmth, numri i biteve që duhet të\nndryshohen për të transformuar x në y.\n\nShembuj:\n- f_8(1, 2) // kthen 2", "hy": "Գրեք JavaScript ֆունկցիա `function f_8(x, y)` հետևյալ խնդիրը լուծելու համար:\nՀաշվեք Հեմինգի հեռավորությունը երկու ամբողջ թվերի միջև նրանց բինար ներկայացման մեջ:\n\nՊարամետրեր:\n- x: Առաջին դրական ամբողջ թիվը (x <= 1,000,000,000):\n- y: Երկրորդ դրական ամբողջ թիվը (y <= 1,000,000,000):\n\nՎերադարձնում է:\n- Հեմինգի հեռավորությունը x և y միջև, այսինքն՝ այն բիթերի քանակը, որոնք պետք է\nփոխվեն x-ը y դարձնելու համար:\n\nՕրինակներ:\n- f_8(1, 2) // վերադարձնում է 2", "bn": "একটি JavaScript ফাংশন `function f_8(x, y)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nদুটি পূর্ণসংখ্যার বাইনারি উপস্থাপনায় হ্যামিং দূরত্ব গণনা করুন।\n\nপ্যারামিটারসমূহ:\n- x: প্রথম ধনাত্মক পূর্ণসংখ্যা (x <= 1,000,000,000)।\n- y: দ্বিতীয় ধনাত্মক পূর্ণসংখ্যা (y <= 1,000,000,000)।\n\nরিটার্নস:\n- x এবং y এর মধ্যে হ্যামিং দূরত্ব, অর্থাৎ x কে y তে রূপান্তর করতে যে সংখ্যক বিট পরিবর্তন করতে হবে।\n\nউদাহরণসমূহ:\n- f_8(1, 2) // 2 রিটার্ন করে", "bg": "Напишете JavaScript функция `function f_8(x, y)`, за да решите следния проблем:  \nИзчислете разстоянието на Хаминг между две цели числа в тяхното двоично представяне.\n\nПараметри:\n- x: Първото положително цяло число (x <= 1,000,000,000).\n- y: Второто положително цяло число (y <= 1,000,000,000).\n\nВръща:\n- Разстоянието на Хаминг между x и y, т.е. броят на битовете, които трябва да бъдат променени, за да се трансформира x в y.\n\nПримери:\n- f_8(1, 2) // връща 2", "zh": "编写一个 JavaScript 函数 `function f_8(x, y)` 来解决以下问题：  \n计算两个整数在其二进制表示中的汉明距离。\n\n参数：\n- x: 第一个正整数 (x <= 1,000,000,000)。\n- y: 第二个正整数 (y <= 1,000,000,000)。\n\n返回：\n- x 和 y 之间的汉明距离，即需要翻转的位数以将 x 转换为 y。\n\n示例：\n- f_8(1, 2) // returns 2", "fr": "Écrire une fonction JavaScript `function f_8(x, y)` pour résoudre le problème suivant :  \nCalculer la distance de Hamming entre deux entiers dans leur représentation binaire.\n\nParamètres :\n- x : Le premier entier positif (x <= 1,000,000,000).\n- y : Le deuxième entier positif (y <= 1,000,000,000).\n\nRenvoie :\n- La distance de Hamming entre x et y, c'est-à-dire le nombre de bits qui doivent être\ninversés pour transformer x en y.\n\nExemples :\n- f_8(1, 2) // renvoie 2", "de": "Schreiben Sie eine JavaScript-Funktion `function f_8(x, y)`, um das folgende Problem zu lösen:\nBerechnen Sie den Hamming-Abstand zwischen zwei ganzen Zahlen in ihrer Binärdarstellung.\n\nParameter:\n- x: Die erste positive ganze Zahl (x <= 1,000,000,000).\n- y: Die zweite positive ganze Zahl (y <= 1,000,000,000).\n\nRückgabewert:\n- Der Hamming-Abstand zwischen x und y, d.h. die Anzahl der Bits, die umgekehrt werden müssen, um x in y zu transformieren.\n\nBeispiele:\n- f_8(1, 2) // gibt 2 zurück", "ha": "Rubuta aikin JavaScript `function f_8(x, y)` don warware matsalar mai zuwa:  \nLissafa nisan Hamming tsakanin lambobi biyu a cikin wakilarsu ta binary.\n\nSigogi:\n- x: Lamba ta farko mai kyau (x <= 1,000,000,000).\n- y: Lamba ta biyu mai kyau (y <= 1,000,000,000).\n\nDawowa:\n- Nisan Hamming tsakanin x da y, wato, adadin bits da ake buƙatar\na jujjuya don canza x zuwa y.\n\nMisalai:\n- f_8(1, 2) // returns 2", "hi": "एक JavaScript फ़ंक्शन `function f_8(x, y)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदो पूर्णांकों के बीच उनके बाइनरी प्रतिनिधित्व में हैमिंग दूरी की गणना करें।\n\nपैरामीटर्स:\n- x: पहला धनात्मक पूर्णांक (x <= 1,000,000,000)।\n- y: दूसरा धनात्मक पूर्णांक (y <= 1,000,000,000)।\n\nवापसी:\n- x और y के बीच की हैमिंग दूरी, अर्थात्, x को y में बदलने के लिए जितने बिट्स को फ्लिप करने की आवश्यकता है।\n\nउदाहरण:\n- f_8(1, 2) // 2 लौटाता है", "hu": "Írj egy JavaScript függvényt `function f_8(x, y)` a következő probléma megoldására:\nSzámítsd ki a Hamming-távolságot két egész szám bináris ábrázolása között.\n\nParaméterek:\n- x: Az első pozitív egész szám (x <= 1,000,000,000).\n- y: A második pozitív egész szám (y <= 1,000,000,000).\n\nVisszatérési érték:\n- A Hamming-távolság x és y között, azaz a bitek száma, amelyeket meg kell\nváltoztatni ahhoz, hogy x-ből y-t kapjunk.\n\nPéldák:\n- f_8(1, 2) // returns 2", "es": "Escribe una función de JavaScript `function f_8(x, y)` para resolver el siguiente problema:\nCalcular la distancia de Hamming entre dos enteros en su representación binaria.\n\nParámetros:\n- x: El primer entero positivo (x <= 1,000,000,000).\n- y: El segundo entero positivo (y <= 1,000,000,000).\n\nDevuelve:\n- La distancia de Hamming entre x e y, es decir, el número de bits que necesitan ser\ncambiados para transformar x en y.\n\nEjemplos:\n- f_8(1, 2) // devuelve 2", "arb": "اكتب دالة JavaScript `function f_8(x, y)` لحل المشكلة التالية:\nاحسب مسافة هامنج بين عددين صحيحين في تمثيلهما الثنائي.\n\nالمعطيات:\n- x: العدد الصحيح الأول الموجب (x <= 1,000,000,000).\n- y: العدد الصحيح الثاني الموجب (y <= 1,000,000,000).\n\nالقيم المعادة:\n- مسافة هامنج بين x و y، أي عدد البتات التي تحتاج إلى\nتغيير لتحويل x إلى y.\n\nأمثلة:\n- f_8(1, 2) // يعيد 2", "sw": "Andika kazi ya JavaScript `function f_8(x, y)` kutatua tatizo lifuatalo: \nHesabu umbali wa Hamming kati ya nambari mbili katika uwakilishi wao wa binary.\n\nVigezo:\n- x: Nambari ya kwanza chanya (x <= 1,000,000,000).\n- y: Nambari ya pili chanya (y <= 1,000,000,000).\n\nInarudisha:\n- Umbali wa Hamming kati ya x na y, yaani, idadi ya biti zinazohitajika kubadilishwa ili kubadilisha x kuwa y.\n\nMifano:\n- f_8(1, 2) // inarudisha 2", "tr": "Bir JavaScript fonksiyonu `function f_8(x, y)` yazın ve aşağıdaki problemi çözün:\nİki tam sayının ikili gösterimlerinde Hamming mesafesini hesaplayın.\n\nParametreler:\n- x: İlk pozitif tam sayı (x <= 1,000,000,000).\n- y: İkinci pozitif tam sayı (y <= 1,000,000,000).\n\nDöndürür:\n- x ve y arasındaki Hamming mesafesi, yani x'i y'ye dönüştürmek için çevrilmesi gereken bit sayısı.\n\nÖrnekler:\n- f_8(1, 2) // 2 döndürür", "vi": "Viết một hàm JavaScript `function f_8(x, y)` để giải quyết vấn đề sau:\nTính khoảng cách Hamming giữa hai số nguyên trong dạng biểu diễn nhị phân của chúng.\n\nTham số:\n- x: Số nguyên dương thứ nhất (x <= 1,000,000,000).\n- y: Số nguyên dương thứ hai (y <= 1,000,000,000).\n\nTrả về:\n- Khoảng cách Hamming giữa x và y, tức là số bit cần phải lật để biến đổi x thành y.\n\nVí dụ:\n- f_8(1, 2) // trả về 2", "id": "Tulis sebuah fungsi JavaScript `function f_8(x, y)` untuk menyelesaikan masalah berikut:\nHitung jarak Hamming antara dua bilangan bulat dalam representasi biner mereka.\n\nParameter:\n- x: Bilangan bulat positif pertama (x <= 1,000,000,000).\n- y: Bilangan bulat positif kedua (y <= 1,000,000,000).\n\nMengembalikan:\n- Jarak Hamming antara x dan y, yaitu jumlah bit yang perlu dibalik untuk mengubah x menjadi y.\n\nContoh:\n- f_8(1, 2) // mengembalikan 2", "ja": "JavaScript関数`function f_8(x, y)`を作成して、次の問題を解決してください:\n2つの整数の2進数表現におけるハミング距離を計算します。\n\nパラメータ:\n- x: 最初の正の整数 (x <= 1,000,000,000)。\n- y: 2番目の正の整数 (y <= 1,000,000,000)。\n\n戻り値:\n- xとyのハミング距離、すなわちxをyに変換するために反転する必要があるビットの数。\n\n例:\n- f_8(1, 2) // returns 2", "ko": "JavaScript 함수를 작성하세요 `function f_8(x, y)` 다음 문제를 해결하기 위해:\n두 정수의 이진 표현에서 해밍 거리를 계산합니다.\n\n매개변수:\n- x: 첫 번째 양의 정수 (x <= 1,000,000,000).\n- y: 두 번째 양의 정수 (y <= 1,000,000,000).\n\n반환값:\n- x와 y 사이의 해밍 거리, 즉 x를 y로 변환하기 위해 뒤집어야 하는 비트의 수입니다.\n\n예시:\n- f_8(1, 2) // returns 2", "ml": "ഒരു ജാവാസ്ക്രിപ്റ്റ് ഫംഗ്ഷൻ `function f_8(x, y)` എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nരണ്ടു പൂർണ്ണസംഖ്യകളുടെ ബൈനറി പ്രതിനിധാനത്തിലെ ഹാമ്മിംഗ് ദൂരമനക്കുക.\n\nപാരാമീറ്ററുകൾ:\n- x: ആദ്യത്തെ പോസിറ്റീവ് പൂർണ്ണസംഖ്യ (x <= 1,000,000,000).\n- y: രണ്ടാം പോസിറ്റീവ് പൂർണ്ണസംഖ്യ (y <= 1,000,000,000).\n\nമടക്കം:\n- x നെ y ആക്കാൻ എത്ര ബിറ്റുകൾ മാറ്റേണ്ടതുണ്ടെന്ന്, അതായത്, x നും y നും ഇടയിലെ ഹാമ്മിംഗ് ദൂരം.\n\nഉദാഹരണങ്ങൾ:\n- f_8(1, 2) // 2 മടക്കം ചെയ്യുന്നു", "fa": "یک تابع جاوااسکریپت `function f_8(x, y)` بنویسید تا مسئله زیر را حل کند:\nفاصله همینگ بین دو عدد صحیح در نمایش دودویی آنها را محاسبه کنید.\n\nپارامترها:\n- x: اولین عدد صحیح مثبت (x <= 1,000,000,000).\n- y: دومین عدد صحیح مثبت (y <= 1,000,000,000).\n\nبازگشت:\n- فاصله همینگ بین x و y، یعنی تعداد بیت‌هایی که باید تغییر کنند تا x به y تبدیل شود.\n\nمثال‌ها:\n- f_8(1, 2) // مقدار 2 را برمی‌گرداند"}, "level": "middle", "test": "const testf_8 = () => {\n    console.assert(f_8(1, 2) === 2, \"01 and 10 have 2 different bits\");\n    console.assert(f_8(4, 7) === 2, \"100 and 111 have 2 different bits\");\n    console.assert(f_8(25, 30) === 3, \"11001 and 11110 have 3 different bits\");\n    console.assert(f_8(0, 0) === 0, \"Same numbers have 0 different bits\");\n    console.assert(f_8(0xFFFFFFF, 0x0000000) === 28,\n                   \"Max unsigned int and 0 have 28 different bits\");\n}\n\n// Run the test function\ntestf_8();", "entry_point": "f_8", "signature": "function f_8(x, y)", "docstring": {"en": "Calculate the Hamming distance between two integers in their binary representation.\n\nParameters:\n- x: The first positive integer (x <= 1,000,000,000).\n- y: The second positive integer (y <= 1,000,000,000).\n\nReturns:\n- The Hamming distance between x and y, i.e., the number of bits that need to be\nflipped to transform x into y.\n\nExamples:\n- f_8(1, 2) // returns 2\n", "sq": "Llogarit distancën Hamming midis dy numrave të plotë në përfaqësimin e tyre binar.\n\nParametrat:\n- x: Numri i parë i plotë pozitiv (x <= 1,000,000,000).\n- y: Numri i dytë i plotë pozitiv (y <= 1,000,000,000).\n\nKthen:\n- Distanca Hamming midis x dhe y, dmth, numri i biteve që duhet të ndryshohen për të transformuar x në y.\n\nShembuj:\n- f_8(1, 2) // kthen 2", "hy": "Հաշվել Հեմինգի հեռավորությունը երկու ամբողջ թվերի միջև իրենց երկբայնային ներկայացման մեջ։\n\nՊարամետրեր՝\n- x: Առաջին դրական ամբողջ թիվը (x <= 1,000,000,000)։\n- y: Երկրորդ դրական ամբողջ թիվը (y <= 1,000,000,000)։\n\nՎերադարձնում է՝\n- Հեմինգի հեռավորությունը x-ի և y-ի միջև, այսինքն՝ բիթերի քանակը, որոնք պետք է\nփոխվեն x-ը y-ի վերածելու համար։\n\nՕրինակներ՝\n- f_8(1, 2) // վերադարձնում է 2", "bn": "দুটি পূর্ণসংখ্যার বাইনারি উপস্থাপনার মধ্যে হ্যামিং দূরত্ব গণনা করুন।\n\nপ্যারামিটারসমূহ:\n- x: প্রথম ধনাত্মক পূর্ণসংখ্যা (x <= 1,000,000,000)।\n- y: দ্বিতীয় ধনাত্মক পূর্ণসংখ্যা (y <= 1,000,000,000)।\n\nরিটার্নস:\n- x এবং y এর মধ্যে হ্যামিং দূরত্ব, অর্থাৎ x কে y তে রূপান্তর করতে যে সংখ্যক বিট পরিবর্তন করতে হবে।\n\nউদাহরণসমূহ:\n- f_8(1, 2) // 2 রিটার্ন করে", "bg": "Изчислете разстоянието на Хаминг между две цели числа в тяхното двоично представяне.\n\nПараметри:\n- x: Първото положително цяло число (x <= 1,000,000,000).\n- y: Второто положително цяло число (y <= 1,000,000,000).\n\nВръща:\n- Разстоянието на Хаминг между x и y, т.е. броят на битовете, които трябва да бъдат\nпроменени, за да се трансформира x в y.\n\nПримери:\n- f_8(1, 2) // връща 2", "zh": "计算两个整数在其二进制表示中的汉明距离。\n\n参数:\n- x: 第一个正整数 (x <= 1,000,000,000)。\n- y: 第二个正整数 (y <= 1,000,000,000)。\n\n返回:\n- x 和 y 之间的汉明距离，即将 x 转换为 y 所需翻转的位数。\n\n示例:\n- f_8(1, 2) // 返回 2", "fr": "Calculer la distance de Hamming entre deux entiers dans leur représentation binaire.\n\nParamètres:\n- x: Le premier entier positif (x <= 1,000,000,000).\n- y: Le deuxième entier positif (y <= 1,000,000,000).\n\nRenvoie:\n- La distance de Hamming entre x et y, c'est-à-dire le nombre de bits qui doivent être\n  inversés pour transformer x en y.\n\nExemples:\n- f_8(1, 2) // renvoie 2", "de": "Berechne die Hamming-Distanz zwischen zwei ganzen Zahlen in ihrer Binärdarstellung.\n\nParameter:\n- x: Die erste positive ganze Zahl (x <= 1,000,000,000).\n- y: Die zweite positive ganze Zahl (y <= 1,000,000,000).\n\nRückgabewert:\n- Die Hamming-Distanz zwischen x und y, d.h., die Anzahl der Bits, die umgekehrt werden müssen, um x in y zu transformieren.\n\nBeispiele:\n- f_8(1, 2) // gibt 2 zurück", "ha": "Lissafa tazara ta Hamming tsakanin lambobi biyu a cikin wakilarsu ta binary.\n\nParameters:\n- x: Lamba ta farko mai kyau (x <= 1,000,000,000).\n- y: Lamba ta biyu mai kyau (y <= 1,000,000,000).\n\nReturns:\n- Hamming distance tsakanin x da y, wato, adadin bits da ake bukata a\njuya don canza x zuwa y.\n\nExamples:\n- f_8(1, 2) // returns 2", "hi": "दो पूर्णांकों के द्विआधारी रूपांतरण में हैमिंग दूरी की गणना करें।\n\nपैरामीटर्स:\n- x: पहला धनात्मक पूर्णांक (x <= 1,000,000,000)।\n- y: दूसरा धनात्मक पूर्णांक (y <= 1,000,000,000)।\n\nवापसी:\n- x और y के बीच हैमिंग दूरी, अर्थात् x को y में बदलने के लिए जितने बिट्स को पलटना आवश्यक है।\n\nउदाहरण:\n- f_8(1, 2) // 2 लौटाता है", "hu": "Számítsa ki a Hamming-távolságot két egész szám bináris ábrázolása között.\n\nParaméterek:\n- x: Az első pozitív egész szám (x <= 1,000,000,000).\n- y: A második pozitív egész szám (y <= 1,000,000,000).\n\nVisszatérési érték:\n- A Hamming-távolság x és y között, azaz hány bitet kell megváltoztatni ahhoz, hogy x-ből y-t kapjunk.\n\nPéldák:\n- f_8(1, 2) // visszaadja 2", "es": "Calcular la distancia de Hamming entre dos enteros en su representación binaria.\n\nParámetros:\n- x: El primer entero positivo (x <= 1,000,000,000).\n- y: El segundo entero positivo (y <= 1,000,000,000).\n\nDevuelve:\n- La distancia de Hamming entre x e y, es decir, el número de bits que deben ser\ncambiados para transformar x en y.\n\nEjemplos:\n- f_8(1, 2) // devuelve 2", "arb": "احسب مسافة هامنج بين عددين صحيحين في تمثيلهما الثنائي.\n\nالمعلمات:\n- x: العدد الصحيح الأول الموجب (x <= 1,000,000,000).\n- y: العدد الصحيح الثاني الموجب (y <= 1,000,000,000).\n\nالقيم المعادة:\n- مسافة هامنج بين x و y، أي عدد البتات التي تحتاج إلى\nتغيير لتحويل x إلى y.\n\nأمثلة:\n- f_8(1, 2) // يعيد 2", "sw": "Hesabu umbali wa Hamming kati ya nambari mbili katika uwakilishi wao wa binary.\n\nVigezo:\n- x: Nambari ya kwanza chanya (x <= 1,000,000,000).\n- y: Nambari ya pili chanya (y <= 1,000,000,000).\n\nRudisha:\n- Umbali wa Hamming kati ya x na y, yaani, idadi ya biti zinazohitajika\nkubadilishwa ili kubadilisha x kuwa y.\n\nMifano:\n- f_8(1, 2) // inarudisha 2", "tr": "İkili gösterimlerinde iki tamsayı arasındaki Hamming mesafesini hesaplayın.\n\nParametreler:\n- x: İlk pozitif tamsayı (x <= 1,000,000,000).\n- y: İkinci pozitif tamsayı (y <= 1,000,000,000).\n\nDöndürür:\n- x ve y arasındaki Hamming mesafesi, yani x'i y'ye dönüştürmek için çevrilmesi gereken bit sayısı.\n\nÖrnekler:\n- f_8(1, 2) // 2 döndürür", "vi": "Tính khoảng cách Hamming giữa hai số nguyên trong biểu diễn nhị phân của chúng.\n\nTham số:\n- x: Số nguyên dương thứ nhất (x <= 1,000,000,000).\n- y: Số nguyên dương thứ hai (y <= 1,000,000,000).\n\nTrả về:\n- Khoảng cách Hamming giữa x và y, tức là số bit cần phải thay đổi để biến đổi x thành y.\n\nVí dụ:\n- f_8(1, 2) // trả về 2", "id": "Hitung jarak Hamming antara dua bilangan bulat dalam representasi biner mereka.\n\nParameter:\n- x: Bilangan bulat positif pertama (x <= 1,000,000,000).\n- y: Bilangan bulat positif kedua (y <= 1,000,000,000).\n\nMengembalikan:\n- Jarak Hamming antara x dan y, yaitu jumlah bit yang perlu dibalik untuk mengubah x menjadi y.\n\nContoh:\n- f_8(1, 2) // mengembalikan 2", "ja": "2つの整数の2進数表現におけるハミング距離を計算します。\n\n引数:\n- x: 最初の正の整数 (x <= 1,000,000,000)。\n- y: 2番目の正の整数 (y <= 1,000,000,000)。\n\n戻り値:\n- xとyのハミング距離、つまりxをyに変換するために反転する必要があるビットの数。\n\n例:\n- f_8(1, 2) // 2を返します。", "ko": "이진 표현에서 두 정수 사이의 해밍 거리 계산.\n\n매개변수:\n- x: 첫 번째 양의 정수 (x <= 1,000,000,000).\n- y: 두 번째 양의 정수 (y <= 1,000,000,000).\n\n반환값:\n- x와 y 사이의 해밍 거리, 즉 x를 y로 변환하기 위해 뒤집어야 하는 비트의 수.\n\n예제:\n- f_8(1, 2) // 2를 반환합니다.", "ml": "രണ്ട് പൂർണ്ണസംഖ്യകളുടെ ബൈനറി പ്രതിനിധാനത്തിൽ ഹാമിംഗ് ദൂരം കണക്കാക്കുക.\n\nപാരാമീറ്ററുകൾ:\n- x: ആദ്യത്തെ പോസിറ്റീവ് പൂർണ്ണസംഖ്യ (x <= 1,000,000,000).\n- y: രണ്ടാമത്തെ പോസിറ്റീവ് പൂർണ്ണസംഖ്യ (y <= 1,000,000,000).\n\nമടക്കങ്ങൾ:\n- x നെ y ആക്കാൻ മാറ്റേണ്ട ബിറ്റുകളുടെ എണ്ണം, അതായത്, x, y എന്നിവയുടെ ഹാമ്മിംഗ് ദൂരം.\n\nഉദാഹരണങ്ങൾ:\n- f_8(1, 2) // 2 മടക്കങ്ങൾ\n", "fa": "محاسبه فاصله همینگ بین دو عدد صحیح در نمایش دودویی آنها.\n\nپارامترها:\n- x: اولین عدد صحیح مثبت (x <= 1,000,000,000).\n- y: دومین عدد صحیح مثبت (y <= 1,000,000,000).\n\nبازگشت:\n- فاصله همینگ بین x و y، یعنی تعداد بیت‌هایی که باید تغییر کنند تا x به y تبدیل شود.\n\nمثال‌ها:\n- f_8(1, 2) // بازگشت 2"}}
{"task_id": "JavaScript/9", "prompt": {"en": "/**\n * Count the number of odd integers in a given list of numbers.\n *\n * @param {number} count - The count of numbers to evaluate.\n * @param {...number} nums - A sequence of integers.\n * @returns {number} The count of odd numbers in the input list.\n * @example\n * f_9(5, 1, 4, 3, 2, 5) // returns 3\n */\nfunction f_9(count, ...nums)", "sq": "/**\n * Numëron numrin e numrave tek në një listë të dhënë numrash.\n *\n * @param {number} count - Numri i numrave për t'u vlerësuar.\n * @param {...number} nums - Një sekuencë e numrave të plotë.\n * @returns {number} Numri i numrave tek në listën e dhënë.\n * @example\n * f_9(5, 1, 4, 3, 2, 5) // returns 3\n */\nfunction f_9(count, ...nums)", "hy": "/**\n * Հաշվել տրված թվերի ցուցակում կենտ ամբողջ թվերի քանակը:\n *\n * @param {number} count - Գնահատման ենթակա թվերի քանակը:\n * @param {...number} nums - Ամբողջ թվերի հաջորդականություն:\n * @returns {number} Մուտքային ցուցակում գտնվող կենտ թվերի քանակը:\n * @example\n * f_9(5, 1, 4, 3, 2, 5) // returns 3\n */\nfunction f_9(count, ...nums)", "bn": "/**\n * প্রদত্ত সংখ্যার তালিকায় কতগুলি বিজোড় পূর্ণসংখ্যা আছে তা গণনা করুন।\n *\n * @param {number} count - মূল্যায়নের জন্য সংখ্যার সংখ্যা।\n * @param {...number} nums - পূর্ণসংখ্যার একটি ক্রম।\n * @returns {number} ইনপুট তালিকায় বিজোড় সংখ্যার সংখ্যা।\n * @example\n * f_9(5, 1, 4, 3, 2, 5) // 3 প্রদান করে\n */\nfunction f_9(count, ...nums)", "bg": "/**\n * Пребройте броя на нечетните цели числа в даден списък от числа.\n *\n * @param {number} count - Броят на числата за оценка.\n * @param {...number} nums - Последователност от цели числа.\n * @returns {number} Броят на нечетните числа в входния списък.\n * @example\n * f_9(5, 1, 4, 3, 2, 5) // returns 3\n */\nfunction f_9(count, ...nums)", "zh": "/**\n * 计算给定数字列表中奇数的数量。\n *\n * @param {number} count - 要评估的数字数量。\n * @param {...number} nums - 一系列整数。\n * @returns {number} 输入列表中奇数的数量。\n * @example\n * f_9(5, 1, 4, 3, 2, 5) // returns 3\n */\nfunction f_9(count, ...nums)", "fr": "/**\n * Compter le nombre d'entiers impairs dans une liste donnée de nombres.\n *\n * @param {number} count - Le nombre de nombres à évaluer.\n * @param {...number} nums - Une séquence d'entiers.\n * @returns {number} Le nombre de nombres impairs dans la liste d'entrée.\n * @example\n * f_9(5, 1, 4, 3, 2, 5) // returns 3\n */\nfunction f_9(count, ...nums)", "de": "/**\n * Zählt die Anzahl der ungeraden Ganzzahlen in einer gegebenen Liste von Zahlen.\n *\n * @param {number} count - Die Anzahl der zu bewertenden Zahlen.\n * @param {...number} nums - Eine Sequenz von Ganzzahlen.\n * @returns {number} Die Anzahl der ungeraden Zahlen in der Eingabeliste.\n * @example\n * f_9(5, 1, 4, 3, 2, 5) // returns 3\n */\nfunction f_9(count, ...nums)", "ha": "/**\n * Ƙirga adadin lambobin da ba su daidai ba a cikin jerin lambobi da aka bayar.\n *\n * @param {number} count - Adadin lambobin da za a tantance.\n * @param {...number} nums - Jeri na lambobi.\n * @returns {number} Adadin lambobin da ba su daidai ba a cikin jerin shigarwa.\n * @example\n * f_9(5, 1, 4, 3, 2, 5) // returns 3\n */\nfunction f_9(count, ...nums)", "hi": "/**\n * दिए गए संख्याओं की सूची में विषम पूर्णांकों की संख्या गिनें।\n *\n * @param {number} count - मूल्यांकन करने के लिए संख्याओं की गिनती।\n * @param {...number} nums - पूर्णांकों का अनुक्रम।\n * @returns {number} इनपुट सूची में विषम संख्याओं की गिनती।\n * @example\n * f_9(5, 1, 4, 3, 2, 5) // returns 3\n */\nfunction f_9(count, ...nums)", "hu": "/**\n * Számolja meg a páratlan egész számok számát egy adott számok listájában.\n *\n * @param {number} count - Az értékelendő számok száma.\n * @param {...number} nums - Egész számok sorozata.\n * @returns {number} A bemeneti listában található páratlan számok száma.\n * @example\n * f_9(5, 1, 4, 3, 2, 5) // returns 3\n */\nfunction f_9(count, ...nums)", "es": "/**\n * Contar el número de enteros impares en una lista dada de números.\n *\n * @param {number} count - La cantidad de números a evaluar.\n * @param {...number} nums - Una secuencia de enteros.\n * @returns {number} La cantidad de números impares en la lista de entrada.\n * @example\n * f_9(5, 1, 4, 3, 2, 5) // devuelve 3\n */\nfunction f_9(count, ...nums)", "arb": "/**\n * احسب عدد الأعداد الفردية في قائمة معينة من الأرقام.\n *\n * @param {number} count - عدد الأرقام لتقييمها.\n * @param {...number} nums - سلسلة من الأعداد الصحيحة.\n * @returns {number} عدد الأعداد الفردية في قائمة الإدخال.\n * @example\n * f_9(5, 1, 4, 3, 2, 5) // يعيد 3\n */\nfunction f_9(count, ...nums)", "sw": "/**\n * Hesabu idadi ya namba zisizo za kawaida katika orodha iliyotolewa ya namba.\n *\n * @param {number} count - Idadi ya namba za kutathmini.\n * @param {...number} nums - Mfululizo wa namba za mzima.\n * @returns {number} Idadi ya namba zisizo za kawaida katika orodha ya pembejeo.\n * @example\n * f_9(5, 1, 4, 3, 2, 5) // inarejesha 3\n */\nfunction f_9(count, ...nums)", "tr": "/**\n * Verilen bir sayı listesindeki tek tam sayıların sayısını hesapla.\n *\n * @param {number} count - Değerlendirilecek sayıların sayısı.\n * @param {...number} nums - Bir dizi tam sayı.\n * @returns {number} Girdi listesindeki tek sayıların sayısı.\n * @example\n * f_9(5, 1, 4, 3, 2, 5) // 3 döndürür\n */\nfunction f_9(count, ...nums)", "vi": "/**\n * Đếm số lượng số nguyên lẻ trong một danh sách số đã cho.\n *\n * @param {number} count - Số lượng số cần đánh giá.\n * @param {...number} nums - Một dãy số nguyên.\n * @returns {number} Số lượng số lẻ trong danh sách đầu vào.\n * @example\n * f_9(5, 1, 4, 3, 2, 5) // trả về 3\n */\nfunction f_9(count, ...nums)", "id": "/**\n * Hitung jumlah bilangan ganjil dalam daftar angka yang diberikan.\n *\n * @param {number} count - Jumlah angka yang akan dievaluasi.\n * @param {...number} nums - Urutan bilangan bulat.\n * @returns {number} Jumlah bilangan ganjil dalam daftar input.\n * @example\n * f_9(5, 1, 4, 3, 2, 5) // mengembalikan 3\n */\nfunction f_9(count, ...nums)", "ja": "/**\n * 与えられた数値のリスト内の奇数の数を数えます。\n *\n * @param {number} count - 評価する数値の数。\n * @param {...number} nums - 整数のシーケンス。\n * @returns {number} 入力リスト内の奇数の数。\n * @example\n * f_9(5, 1, 4, 3, 2, 5) // returns 3\n */\nfunction f_9(count, ...nums)", "ko": "/**\n * 주어진 숫자 목록에서 홀수 정수의 개수를 셉니다.\n *\n * @param {number} count - 평가할 숫자의 개수입니다.\n * @param {...number} nums - 정수의 시퀀스입니다.\n * @returns {number} 입력 목록에서 홀수의 개수입니다.\n * @example\n * f_9(5, 1, 4, 3, 2, 5) // returns 3\n */\nfunction f_9(count, ...nums)", "ml": "/**\n * നൽകിയ ഒരു ലിസ്റ്റിലെ ഒറ്റ സംഖ്യകൾ എണ്ണുക.\n *\n * @param {number} count - വിലയിരുത്തേണ്ട സംഖ്യകളുടെ എണ്ണം.\n * @param {...number} nums - ഒരു സംഖ്യകളുടെ ശ്രേണി.\n * @returns {number} ഇൻപുട്ട് ലിസ്റ്റിലെ ഒറ്റ സംഖ്യകളുടെ എണ്ണം.\n * @example\n * f_9(5, 1, 4, 3, 2, 5) // returns 3\n */\nfunction f_9(count, ...nums)", "fa": "/**\n * تعداد اعداد فرد در یک لیست از اعداد داده شده را بشمارید.\n *\n * @param {number} count - تعداد اعدادی که باید ارزیابی شوند.\n * @param {...number} nums - دنباله‌ای از اعداد صحیح.\n * @returns {number} تعداد اعداد فرد در لیست ورودی.\n * @example\n * f_9(5, 1, 4, 3, 2, 5) // returns 3\n */\nfunction f_9(count, ...nums)"}, "canonical_solution": "{\n    let ans = 0;\n    for (let i = 0; i < count; i++) {\n        if (nums[i] % 2 !== 0) {\n            ans++;\n        }\n    }\n    return ans;\n}", "instruction": {"en": "Write a JavaScript function `function f_9(count, ...nums)` to solve the following problem:\nCount the number of odd integers in a given list of numbers.\n\nParameters:\n@param {number} count - The count of numbers to evaluate.\n@param {...number} nums - A sequence of integers.\n\nReturns:\n@returns {number} The count of odd numbers in the input list.\n\nExample:\n@example\n f_9(5, 1, 4, 3, 2, 5) // returns 3", "sq": "Shkruani një funksion JavaScript `function f_9(count, ...nums)` për të zgjidhur problemin e mëposhtëm:\nNumëroni numrin e numrave tek në një listë të dhënë numrash.\n\nParametrat:\n@param {number} count - Numri i numrave për t'u vlerësuar.\n@param {...number} nums - Një sekuencë e numrave të plotë.\n\nKthen:\n@returns {number} Numri i numrave tek në listën e hyrjes.\n\nShembull:\n@example\n f_9(5, 1, 4, 3, 2, 5) // kthen 3", "hy": "Գրեք JavaScript ֆունկցիա `function f_9(count, ...nums)` հետևյալ խնդիրը լուծելու համար:\nՀաշվել տրված թվերի ցանկում կենտ ամբողջ թվերի քանակը։\n\nՊարամետրեր:\n@param {number} count - Գնահատվող թվերի քանակը։\n@param {...number} nums - Ամբողջ թվերի հաջորդականություն։\n\nՎերադարձնում է:\n@returns {number} Մուտքային ցանկում կենտ թվերի քանակը։\n\nՕրինակ:\n@example\n f_9(5, 1, 4, 3, 2, 5) // վերադարձնում է 3", "bn": "একটি জাভাস্ক্রিপ্ট ফাংশন `function f_9(count, ...nums)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nপ্রদত্ত সংখ্যার তালিকায় বিজোড় পূর্ণসংখ্যার সংখ্যা গণনা করুন।\n\nপ্যারামিটারসমূহ:\n@param {number} count - মূল্যায়ন করার জন্য সংখ্যার সংখ্যা।\n@param {...number} nums - পূর্ণসংখ্যার একটি ক্রম।\n\nফেরত দেয়:\n@returns {number} ইনপুট তালিকায় বিজোড় সংখ্যার সংখ্যা।\n\nউদাহরণ:\n@example\n f_9(5, 1, 4, 3, 2, 5) // 3 ফেরত দেয়", "bg": "Напишете JavaScript функция `function f_9(count, ...nums)` за решаване на следния проблем:\nПребройте броя на нечетните цели числа в даден списък от числа.\n\nПараметри:\n@param {number} count - Броят на числата за оценка.\n@param {...number} nums - Последователност от цели числа.\n\nВръща:\n@returns {number} Броят на нечетните числа в списъка с входни данни.\n\nПример:\n@example\n f_9(5, 1, 4, 3, 2, 5) // връща 3", "zh": "编写一个 JavaScript 函数 `function f_9(count, ...nums)` 来解决以下问题：\n统计给定数字列表中奇数的数量。\n\n参数：\n@param {number} count - 要评估的数字数量。\n@param {...number} nums - 一系列整数。\n\n返回：\n@returns {number} 输入列表中奇数的数量。\n\n示例：\n@example\n f_9(5, 1, 4, 3, 2, 5) // returns 3", "fr": "Écrire une fonction JavaScript `function f_9(count, ...nums)` pour résoudre le problème suivant :  \nCompter le nombre d'entiers impairs dans une liste donnée de nombres.\n\nParamètres :  \n@param {number} count - Le nombre de nombres à évaluer.  \n@param {...number} nums - Une séquence d'entiers.\n\nRenvoie :  \n@returns {number} Le nombre de nombres impairs dans la liste d'entrée.\n\nExemple :  \n@example  \n f_9(5, 1, 4, 3, 2, 5) // returns 3", "de": "Schreiben Sie eine JavaScript-Funktion `function f_9(count, ...nums)`, um das folgende Problem zu lösen:\nZählen Sie die Anzahl der ungeraden ganzen Zahlen in einer gegebenen Liste von Zahlen.\n\nParameter:\n@param {number} count - Die Anzahl der zu bewertenden Zahlen.\n@param {...number} nums - Eine Sequenz von ganzen Zahlen.\n\nRückgabe:\n@returns {number} Die Anzahl der ungeraden Zahlen in der Eingabeliste.\n\nBeispiel:\n@example\n f_9(5, 1, 4, 3, 2, 5) // gibt 3 zurück", "ha": "Rubuta aikin JavaScript `function f_9(count, ...nums)` don magance matsalar mai zuwa:\nƘididdige yawan lambobin tsaka-tsaki a cikin jerin lambobi da aka bayar.\n\nSigogi:\n@param {number} count - Yawan lambobin da za a tantance.\n@param {...number} nums - Jeri na lambobi tsaka-tsaki.\n\nDawowa:\n@returns {number} Yawan lambobin tsaka-tsaki a cikin jerin shigarwa.\n\nMisali:\n@example\n f_9(5, 1, 4, 3, 2, 5) // returns 3", "hi": "`function f_9(count, ...nums)` निम्नलिखित समस्या को हल करने के लिए:\nदिए गए संख्याओं की सूची में विषम पूर्णांकों की संख्या गिनें।\n\nपैरामीटर्स:\n@param {number} count - मूल्यांकन करने के लिए संख्याओं की गिनती।\n@param {...number} nums - पूर्णांकों का अनुक्रम।\n\nवापसी:\n@returns {number} इनपुट सूची में विषम संख्याओं की गिनती।\n\nउदाहरण:\n@example\n f_9(5, 1, 4, 3, 2, 5) // returns 3", "hu": "Írj egy JavaScript függvényt `function f_9(count, ...nums)` a következő probléma megoldására:\nSzámold meg a páratlan egész számok számát egy adott számok listájában.\n\nParaméterek:\n@param {number} count - Az értékelendő számok száma.\n@param {...number} nums - Egész számok sorozata.\n\nVisszatér:\n@returns {number} A páratlan számok száma a bemeneti listában.\n\nPélda:\n@example\n f_9(5, 1, 4, 3, 2, 5) // returns 3", "es": "Escribe una función de JavaScript `function f_9(count, ...nums)` para resolver el siguiente problema:\nCuenta el número de enteros impares en una lista dada de números.\n\nParámetros:\n@param {number} count - La cantidad de números a evaluar.\n@param {...number} nums - Una secuencia de enteros.\n\nDevuelve:\n@returns {number} La cantidad de números impares en la lista de entrada.\n\nEjemplo:\n@example\n f_9(5, 1, 4, 3, 2, 5) // devuelve 3", "arb": "اكتب دالة JavaScript `function f_9(count, ...nums)` لحل المشكلة التالية:\nعد عدد الأعداد الفردية في قائمة معينة من الأرقام.\n\nالمعلمات:\n@param {number} count - عدد الأرقام لتقييمها.\n@param {...number} nums - تسلسل من الأعداد الصحيحة.\n\nالقيم المعادة:\n@returns {number} عدد الأعداد الفردية في قائمة الإدخال.\n\nمثال:\n@example\n f_9(5, 1, 4, 3, 2, 5) // يعيد 3", "sw": "Andika kazi ya JavaScript `function f_9(count, ...nums)` kutatua tatizo lifuatalo:\nHesabu idadi ya nambari zisizogawanyika kwa mbili katika orodha iliyotolewa ya nambari.\n\nVigezo:\n@param {number} count - Idadi ya nambari za kutathmini.\n@param {...number} nums - Mlolongo wa nambari nzima.\n\nInarejesha:\n@returns {number} Idadi ya nambari zisizogawanyika kwa mbili katika orodha ya pembejeo.\n\nMfano:\n@example\n f_9(5, 1, 4, 3, 2, 5) // inarejesha 3", "tr": "Bir JavaScript fonksiyonu `function f_9(count, ...nums)` yazın ve aşağıdaki problemi çözün:\nVerilen bir sayı listesindeki tek sayıların sayısını hesaplayın.\n\nParametreler:\n@param {number} count - Değerlendirilecek sayıların sayısı.\n@param {...number} nums - Bir dizi tam sayı.\n\nDöndürür:\n@returns {number} Girdi listesindeki tek sayıların sayısı.\n\nÖrnek:\n@example\n f_9(5, 1, 4, 3, 2, 5) // 3 döndürür", "vi": "Viết một hàm JavaScript `function f_9(count, ...nums)` để giải quyết vấn đề sau:\nĐếm số lượng số nguyên lẻ trong một danh sách số đã cho.\n\nTham số:\n@param {number} count - Số lượng số cần đánh giá.\n@param {...number} nums - Một dãy các số nguyên.\n\nTrả về:\n@returns {number} Số lượng số lẻ trong danh sách đầu vào.\n\nVí dụ:\n@example\n f_9(5, 1, 4, 3, 2, 5) // trả về 3", "id": "Tulis sebuah fungsi JavaScript `function f_9(count, ...nums)` untuk menyelesaikan masalah berikut:\nHitung jumlah bilangan bulat ganjil dalam daftar angka yang diberikan.\n\nParameter:\n@param {number} count - Jumlah angka yang akan dievaluasi.\n@param {...number} nums - Sekumpulan bilangan bulat.\n\nMengembalikan:\n@returns {number} Jumlah bilangan ganjil dalam daftar input.\n\nContoh:\n@example\n f_9(5, 1, 4, 3, 2, 5) // returns 3", "ja": "JavaScript関数 `function f_9(count, ...nums)` を作成して、次の問題を解決してください:\n与えられた数値のリスト内の奇数の整数の数を数えます。\n\nパラメータ:\n@param {number} count - 評価する数値の数。\n@param {...number} nums - 整数のシーケンス。\n\n戻り値:\n@returns {number} 入力リスト内の奇数の数。\n\n例:\n@example\n f_9(5, 1, 4, 3, 2, 5) // returns 3", "ko": "JavaScript 함수를 작성하세요 `function f_9(count, ...nums)` 다음 문제를 해결하기 위해:\n주어진 숫자 목록에서 홀수 정수의 개수를 세십시오.\n\n매개변수:\n@param {number} count - 평가할 숫자의 개수.\n@param {...number} nums - 정수의 시퀀스.\n\n반환값:\n@returns {number} 입력 목록에서 홀수의 개수.\n\n예시:\n@example\n f_9(5, 1, 4, 3, 2, 5) // returns 3", "ml": "`function f_9(count, ...nums)` എന്ന ജാവാസ്ക്രിപ്റ്റ് ഫംഗ്ഷൻ എഴുതുക താഴെ നൽകിയിരിക്കുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nനൽകിയിരിക്കുന്ന സംഖ്യകളുടെ പട്ടികയിൽ വിചിത്രമായ പൂർണ്ണസംഖ്യകളുടെ എണ്ണം എണ്ണുക.\n\nപാരാമീറ്ററുകൾ:\n@param {number} count - വിലയിരുത്താനുള്ള സംഖ്യകളുടെ എണ്ണം.\n@param {...number} nums - പൂർണ്ണസംഖ്യകളുടെ ഒരു നിര.\n\nമടക്കിക്കൊടുക്കുന്നു:\n@returns {number} ഇൻപുട്ട് ലിസ്റ്റിലുള്ള വിചിത്ര സംഖ്യകളുടെ എണ്ണം.\n\nഉദാഹരണം:\n@example\n f_9(5, 1, 4, 3, 2, 5) // 3 മടക്കിക്കൊടുക്കുന്നു", "fa": "یک تابع جاوااسکریپت `function f_9(count, ...nums)` بنویسید تا مسئله زیر را حل کند:\nتعداد اعداد صحیح فرد را در یک لیست داده شده از اعداد بشمارید.\n\nپارامترها:\n@param {number} count - تعداد اعدادی که باید ارزیابی شوند.\n@param {...number} nums - یک دنباله از اعداد صحیح.\n\nبازگشت:\n@returns {number} تعداد اعداد فرد در لیست ورودی.\n\nمثال:\n@example\n f_9(5, 1, 4, 3, 2, 5) // returns 3"}, "level": "easy", "test": "const testf_9 = () => {\n    console.assert(f_9(5, 1, 4, 3, 2, 5) === 3, \"Test 1 failed\");\n    console.assert(f_9(4, 2, 2, 0, 0) === 0, \"Test 2 failed\");\n    console.assert(f_9(6, 7, 7, 8, 1, 9, 10) === 4, \"Test 3 failed\"); // Additional Test Sample\n    // console.log(\"All tests passed!\");\n}\n\ntestf_9();", "entry_point": "f_9", "signature": "function f_9(count, ...nums)", "docstring": {"en": "Count the number of odd integers in a given list of numbers.\n\nParameters:\n@param {number} count - The count of numbers to evaluate.\n@param {...number} nums - A sequence of integers.\n\nReturns:\n@returns {number} The count of odd numbers in the input list.\n\nExample:\n@example\n f_9(5, 1, 4, 3, 2, 5) // returns 3", "sq": "Numëroni numrin e numrave tek në një listë të dhënë numrash.\n\nParametrat:\n@param {number} count - Numri i numrave për të vlerësuar.\n@param {...number} nums - Një sekuencë e numrave të plotë.\n\nKthen:\n@returns {number} Numri i numrave tek në listën e dhënë si hyrje.\n\nShembull:\n@example\n f_9(5, 1, 4, 3, 2, 5) // kthen 3", "hy": "Հաշվել տրված թվերի ցանկում կենտ ամբողջ թվերի քանակը։\n\nՊարամետրեր՝\n@param {number} count - Թվերի քանակը, որոնք պետք է գնահատել։\n@param {...number} nums - Ամբողջ թվերի հաջորդականություն։\n\nՎերադարձնում է՝\n@returns {number} Կենտ թվերի քանակը մուտքագրված ցանկում։\n\nՕրինակ՝\n@example\n f_9(5, 1, 4, 3, 2, 5) // վերադարձնում է 3", "bn": "অদ্ভুত পূর্ণসংখ্যার সংখ্যা নির্ণয় করুন একটি প্রদত্ত সংখ্যার তালিকায়।\n\nপ্যারামিটারসমূহ:\n@param {number} count - মূল্যায়ন করার জন্য সংখ্যার সংখ্যা।\n@param {...number} nums - পূর্ণসংখ্যার একটি ক্রম।\n\nফেরত দেয়:\n@returns {number} ইনপুট তালিকায় অদ্ভুত সংখ্যার সংখ্যা।\n\nউদাহরণ:\n@example\n f_9(5, 1, 4, 3, 2, 5) // 3 ফেরত দেয়", "bg": "Бройте броя на нечетните цели числа в даден списък от числа.\n\nПараметри:\n@param {number} count - Броят на числата за оценка.\n@param {...number} nums - Последователност от цели числа.\n\nВръща:\n@returns {number} Броят на нечетните числа в входния списък.\n\nПример:\n@example\n f_9(5, 1, 4, 3, 2, 5) // връща 3", "zh": "计算给定数字列表中奇数的数量。\n\n参数：\n@param {number} count - 要评估的数字数量。\n@param {...number} nums - 整数序列。\n\n返回：\n@returns {number} 输入列表中奇数的数量。\n\n示例：\n@example\n f_9(5, 1, 4, 3, 2, 5) // returns 3", "fr": "Compter le nombre d'entiers impairs dans une liste donnée de nombres.\n\nParamètres:\n@param {number} count - Le nombre de nombres à évaluer.\n@param {...number} nums - Une séquence d'entiers.\n\nRenvoie:\n@returns {number} Le nombre de nombres impairs dans la liste d'entrée.\n\nExemple:\n@example\n f_9(5, 1, 4, 3, 2, 5) // renvoie 3", "de": "Zähle die Anzahl der ungeraden ganzen Zahlen in einer gegebenen Liste von Zahlen.\n\nParameter:\n@param {number} count - Die Anzahl der zu bewertenden Zahlen.\n@param {...number} nums - Eine Folge von ganzen Zahlen.\n\nRückgabewerte:\n@returns {number} Die Anzahl der ungeraden Zahlen in der Eingabeliste.\n\nBeispiel:\n@example\n f_9(5, 1, 4, 3, 2, 5) // gibt 3 zurück", "ha": "Ƙirga adadin lambobin da ba su daidai ba a cikin jerin lambobi da aka bayar.\n\nParameters:\n@param {number} count - Adadin lambobin da za a tantance.\n@param {...number} nums - Jeri na lambobi masu cikakken lamba.\n\nReturns:\n@returns {number} Yawan lambobin da ba su daidai ba a cikin jerin shigarwa.\n\nExample:\n@example\n f_9(5, 1, 4, 3, 2, 5) // returns 3", "hi": "दी गई संख्याओं की सूची में विषम पूर्णांकों की संख्या गिनें।\n\nपैरामीटर्स:\n@param {number} count - मूल्यांकन करने के लिए संख्याओं की गिनती।\n@param {...number} nums - पूर्णांकों का अनुक्रम।\n\nवापसी:\n@returns {number} इनपुट सूची में विषम संख्याओं की गिनती।\n\nउदाहरण:\n@example\n f_9(5, 1, 4, 3, 2, 5) // 3 लौटाता है", "hu": "Számolja meg a páratlan egész számok számát egy adott számok listájában.\n\nParaméterek:\n@param {number} count - Az értékelendő számok száma.\n@param {...number} nums - Egész számok sorozata.\n\nVisszatérési érték:\n@returns {number} A bemeneti listában található páratlan számok száma.\n\nPélda:\n@example\n f_9(5, 1, 4, 3, 2, 5) // visszaadja a 3-at", "es": "Cuenta el número de enteros impares en una lista dada de números.\n\nParámetros:\n@param {number} count - La cantidad de números a evaluar.\n@param {...number} nums - Una secuencia de enteros.\n\nDevuelve:\n@returns {number} La cantidad de números impares en la lista de entrada.\n\nEjemplo:\n@example\n f_9(5, 1, 4, 3, 2, 5) // devuelve 3", "arb": "احسب عدد الأعداد الفردية في قائمة معينة من الأرقام.\n\nالمعلمات:\n@param {number} count - عدد الأرقام لتقييمها.\n@param {...number} nums - تسلسل من الأعداد الصحيحة.\n\nالقيم المعادة:\n@returns {number} عدد الأعداد الفردية في قائمة الإدخال.\n\nمثال:\n@example\n f_9(5, 1, 4, 3, 2, 5) // يعيد 3", "sw": "Hesabu idadi ya nambari zisizo za kawaida katika orodha iliyotolewa ya nambari.\n\nVigezo:\n@param {number} count - Idadi ya nambari za kutathmini.\n@param {...number} nums - Mlolongo wa nambari nzima.\n\nInarudisha:\n@returns {number} Idadi ya nambari zisizo za kawaida katika orodha ya ingizo.\n\nMfano:\n@example\n f_9(5, 1, 4, 3, 2, 5) // inarudisha 3", "tr": "Verilen bir sayı listesindeki tek sayıların sayısını hesaplayın.\n\nParametreler:\n@param {number} count - Değerlendirilecek sayıların sayısı.\n@param {...number} nums - Bir dizi tam sayı.\n\nDöndürülenler:\n@returns {number} Girdi listesindeki tek sayıların sayısı.\n\nÖrnek:\n@example\n f_9(5, 1, 4, 3, 2, 5) // 3 döndürür", "vi": "Đếm số lượng số nguyên lẻ trong một danh sách số đã cho.\n\nTham số:\n@param {number} count - Số lượng số cần đánh giá.\n@param {...number} nums - Một dãy các số nguyên.\n\nTrả về:\n@returns {number} Số lượng số lẻ trong danh sách đầu vào.\n\nVí dụ:\n@example\n f_9(5, 1, 4, 3, 2, 5) // trả về 3", "id": "Hitung jumlah bilangan bulat ganjil dalam daftar angka yang diberikan.\n\nParameter:\n@param {number} count - Jumlah angka yang akan dievaluasi.\n@param {...number} nums - Urutan bilangan bulat.\n\nMengembalikan:\n@returns {number} Jumlah bilangan ganjil dalam daftar input.\n\nContoh:\n@example\n f_9(5, 1, 4, 3, 2, 5) // mengembalikan 3", "ja": "与えられた数値のリスト内の奇数の整数の数を数える。\n\nパラメータ:\n@param {number} count - 評価する数のカウント。\n@param {...number} nums - 整数のシーケンス。\n\n戻り値:\n@returns {number} 入力リスト内の奇数の数。\n\n例:\n@example\n f_9(5, 1, 4, 3, 2, 5) // returns 3", "ko": "주어진 숫자 목록에서 홀수 정수의 개수를 셉니다.\n\n매개변수:\n@param {number} count - 평가할 숫자의 개수입니다.\n@param {...number} nums - 정수의 시퀀스입니다.\n\n반환값:\n@returns {number} 입력 목록에서 홀수의 개수입니다.\n\n예제:\n@example\n f_9(5, 1, 4, 3, 2, 5) // returns 3", "ml": "ദിയ്ക്കപ്പെട്ട സംഖ്യകളുടെ പട്ടികയിൽ എത്ര ഒറ്റ സംഖ്യകളുണ്ടെന്ന് എണ്ണുക.\n\nപരാമീറ്ററുകൾ:\n@param {number} count - വിലയിരുത്തേണ്ട സംഖ്യകളുടെ എണ്ണം.\n@param {...number} nums - പൂർണ്ണസംഖ്യകളുടെ ഒരു നിര.\n\nമടക്കങ്ങൾ:\n@returns {number} ഇൻപുട്ട് പട്ടികയിൽ ഒറ്റ സംഖ്യകളുടെ എണ്ണം.\n\nഉദാഹരണം:\n@example\n f_9(5, 1, 4, 3, 2, 5) // 3 മടക്കുന്നു", "fa": "تعداد اعداد فرد در یک لیست داده شده از اعداد را بشمارید.\n\nپارامترها:\n@param {number} count - تعداد اعدادی که باید ارزیابی شوند.\n@param {...number} nums - یک دنباله از اعداد صحیح.\n\nبازگشت:\n@returns {number} تعداد اعداد فرد در لیست ورودی.\n\nمثال:\n@example\n f_9(5, 1, 4, 3, 2, 5) // returns 3"}}
{"task_id": "JavaScript/10", "prompt": {"en": "/**\n * Calculate the sum of even numbers in a given list.\n * Parameters:\n * - numbers (Array): An array of integers.\n * - size (Number): The size of the array.\n * Returns:\n *   Number: The sum of even numbers in the input array.\n * Example usage:\n *   f_10([1, 4, 3, 2, 5], 5)  // returns 6\n */\nfunction f_10(numbers, size)", "sq": "/**\n * Llogarit shumën e numrave çift në një listë të dhënë.\n * Parametrat:\n * - numbers (Array): Një varg me numra të plotë.\n * - size (Number): Madhësia e vargut.\n * Kthen:\n *   Number: Shuma e numrave çift në vargun e dhënë.\n * Shembull përdorimi:\n *   f_10([1, 4, 3, 2, 5], 5)  // kthen 6\n */\nfunction f_10(numbers, size)", "hy": "/**\n * Հաշվել տրված ցուցակի զույգ թվերի գումարը:\n * Պարամետրեր:\n * - numbers (Array): Ամբողջ թվերի զանգված:\n * - size (Number): Զանգվածի չափը:\n * Վերադարձնում է:\n *   Number: Մուտքային զանգվածի զույգ թվերի գումարը:\n * Օրինակ օգտագործում:\n *   f_10([1, 4, 3, 2, 5], 5)  // վերադարձնում է 6\n */\nfunction f_10(numbers, size)", "bn": "/**\n * প্রদত্ত তালিকায় জোড় সংখ্যাগুলির যোগফল গণনা করুন।\n * প্যারামিটারসমূহ:\n * - numbers (Array): পূর্ণসংখ্যার একটি অ্যারে।\n * - size (Number): অ্যারের আকার।\n * রিটার্নস:\n *   Number: ইনপুট অ্যারেতে জোড় সংখ্যাগুলির যোগফল।\n * উদাহরণ ব্যবহার:\n *   f_10([1, 4, 3, 2, 5], 5)  // 6 রিটার্ন করে\n */\nfunction f_10(numbers, size)", "bg": "/**\n * Изчислява сумата на четните числа в даден списък.\n * Параметри:\n * - numbers (Array): Масив от цели числа.\n * - size (Number): Размерът на масива.\n * Връща:\n *   Number: Сумата на четните числа в входния масив.\n * Пример за използване:\n *   f_10([1, 4, 3, 2, 5], 5)  // връща 6\n */\nfunction f_10(numbers, size)", "zh": "/**\n * 计算给定列表中偶数的和。\n * 参数:\n * - numbers (Array): 整数数组。\n * - size (Number): 数组的大小。\n * 返回:\n *   Number: 输入数组中偶数的和。\n * 示例用法:\n *   f_10([1, 4, 3, 2, 5], 5)  // 返回 6\n */\nfunction f_10(numbers, size)", "fr": "/**\n * Calculer la somme des nombres pairs dans une liste donnée.\n * Paramètres :\n * - numbers (Array) : Un tableau d'entiers.\n * - size (Number) : La taille du tableau.\n * Renvoie :\n *   Number : La somme des nombres pairs dans le tableau d'entrée.\n * Exemple d'utilisation :\n *   f_10([1, 4, 3, 2, 5], 5)  // renvoie 6\n */\nfunction f_10(numbers, size)", "de": "/**\n * Berechne die Summe der geraden Zahlen in einer gegebenen Liste.\n * Parameter:\n * - numbers (Array): Ein Array von ganzen Zahlen.\n * - size (Number): Die Größe des Arrays.\n * Rückgabe:\n *   Number: Die Summe der geraden Zahlen im Eingabearray.\n * Beispielverwendung:\n *   f_10([1, 4, 3, 2, 5], 5)  // gibt 6 zurück\n */\nfunction f_10(numbers, size)", "ha": "/**\n * Lissafa jimillar lambobin da ke daidai a cikin jerin da aka bayar.\n * Sigogi:\n * - numbers (Array): Wani jeri na lambobi.\n * - size (Number): Girman jerin.\n * Komawa:\n *   Number: Jimillar lambobin da ke daidai a cikin jerin shigarwa.\n * Misalin amfani:\n *   f_10([1, 4, 3, 2, 5], 5)  // yana dawowa 6\n */\nfunction f_10(numbers, size)", "hi": "/**\n * दिए गए सूची में सम संख्याओं का योग गणना करें।\n * पैरामीटर्स:\n * - numbers (Array): पूर्णांकों की एक array।\n * - size (Number): array का आकार।\n * रिटर्न करता है:\n *   Number: इनपुट array में सम संख्याओं का योग।\n * उदाहरण उपयोग:\n *   f_10([1, 4, 3, 2, 5], 5)  // 6 लौटाता है\n */\nfunction f_10(numbers, size)", "hu": "/**\n * Számítsa ki a páros számok összegét egy adott listában.\n * Paraméterek:\n * - numbers (Array): Egész számokat tartalmazó tömb.\n * - size (Number): A tömb mérete.\n * Visszatér:\n *   Number: A bemeneti tömbben található páros számok összege.\n * Példa használat:\n *   f_10([1, 4, 3, 2, 5], 5)  // visszaadja: 6\n */\nfunction f_10(numbers, size)", "es": "/**\n * Calcular la suma de los números pares en una lista dada.\n * Parámetros:\n * - numbers (Array): Un array de enteros.\n * - size (Number): El tamaño del array.\n * Devuelve:\n *   Number: La suma de los números pares en el array de entrada.\n * Ejemplo de uso:\n *   f_10([1, 4, 3, 2, 5], 5)  // devuelve 6\n */\nfunction f_10(numbers, size)", "arb": "/**\n * احسب مجموع الأعداد الزوجية في قائمة معينة.\n * المعلمات:\n * - numbers (Array): مصفوفة من الأعداد الصحيحة.\n * - size (Number): حجم المصفوفة.\n * يعيد:\n *   Number: مجموع الأعداد الزوجية في المصفوفة المدخلة.\n * مثال على الاستخدام:\n *   f_10([1, 4, 3, 2, 5], 5)  // يعيد 6\n */\nfunction f_10(numbers, size)", "sw": "/**\n * Hesabu jumla ya namba shufwa katika orodha iliyotolewa.\n * Vigezo:\n * - numbers (Array): Orodha ya nambari za mzima.\n * - size (Number): Ukubwa wa orodha.\n * Inarudisha:\n *   Number: Jumla ya namba shufwa katika orodha ya ingizo.\n * Mfano wa matumizi:\n *   f_10([1, 4, 3, 2, 5], 5)  // inarudisha 6\n */\nfunction f_10(numbers, size)", "tr": "/**\n * Verilen bir listedeki çift sayıların toplamını hesapla.\n * Parametreler:\n * - numbers (Array): Bir tamsayı dizisi.\n * - size (Number): Dizinin boyutu.\n * Döndürür:\n *   Number: Girdi dizisindeki çift sayıların toplamı.\n * Örnek kullanım:\n *   f_10([1, 4, 3, 2, 5], 5)  // 6 döndürür\n */\nfunction f_10(numbers, size)", "vi": "/**\n * Tính tổng các số chẵn trong một danh sách cho trước.\n * Tham số:\n * - numbers (Array): Một mảng các số nguyên.\n * - size (Number): Kích thước của mảng.\n * Trả về:\n *   Number: Tổng các số chẵn trong mảng đầu vào.\n * Ví dụ sử dụng:\n *   f_10([1, 4, 3, 2, 5], 5)  // trả về 6\n */\nfunction f_10(numbers, size)", "id": "/**\n * Hitung jumlah bilangan genap dalam daftar yang diberikan.\n * Parameter:\n * - numbers (Array): Sebuah array dari bilangan bulat.\n * - size (Number): Ukuran dari array.\n * Mengembalikan:\n *   Number: Jumlah bilangan genap dalam array input.\n * Contoh penggunaan:\n *   f_10([1, 4, 3, 2, 5], 5)  // mengembalikan 6\n */\nfunction f_10(numbers, size)", "ja": "/**\n * 指定されたリスト内の偶数の合計を計算します。\n * パラメータ:\n * - numbers (Array): 整数の配列。\n * - size (Number): 配列のサイズ。\n * 戻り値:\n *   Number: 入力配列内の偶数の合計。\n * 使用例:\n *   f_10([1, 4, 3, 2, 5], 5)  // 6を返します\n */\nfunction f_10(numbers, size)", "ko": "/**\n * 주어진 리스트에서 짝수의 합을 계산합니다.\n * 매개변수:\n * - numbers (Array): 정수의 배열.\n * - size (Number): 배열의 크기.\n * 반환값:\n *   Number: 입력 배열에서 짝수의 합.\n * 사용 예:\n *   f_10([1, 4, 3, 2, 5], 5)  // 6을 반환합니다\n */\nfunction f_10(numbers, size)", "ml": "/**\n * നൽകിയ ലിസ്റ്റിലെ സമവായ സംഖ്യകളുടെ മൊത്തം കണക്കാക്കുക.\n * പാരാമീറ്ററുകൾ:\n * - numbers (Array): ഒരു പദങ്ങളുടെ നിര.\n * - size (Number): നിരയുടെ വലുപ്പം.\n * മടക്കുന്നു:\n *   Number: ഇൻപുട്ട് നിരയിലെ സമവായ സംഖ്യകളുടെ മൊത്തം.\n * ഉദാഹരണ ഉപയോഗം:\n *   f_10([1, 4, 3, 2, 5], 5)  // 6 മടക്കുന്നു\n */\nfunction f_10(numbers, size)", "fa": "/**\n * محاسبه مجموع اعداد زوج در یک لیست داده شده.\n * پارامترها:\n * - numbers (Array): یک آرایه از اعداد صحیح.\n * - size (Number): اندازه آرایه.\n * بازگشت:\n *   Number: مجموع اعداد زوج در آرایه ورودی.\n * مثال استفاده:\n *   f_10([1, 4, 3, 2, 5], 5)  // 6 را برمی‌گرداند\n */\nfunction f_10(numbers, size)"}, "canonical_solution": "{\n    let ans = 0;\n    for (let i = 0; i < size; i++) {\n        if (numbers[i] % 2 === 0) { // Only sum the even numbers\n            ans += numbers[i];\n        }\n    }\n    return ans;\n}", "instruction": {"en": "Write a JavaScript function `function f_10(numbers, size)` to solve the following problem:\nCalculate the sum of even numbers in a given list.\nParameters:\n- numbers (Array): An array of integers.\n- size (Number): The size of the array.\nReturns:\n  Number: The sum of even numbers in the input array.\nExample usage:\n  f_10([1, 4, 3, 2, 5], 5)  // returns 6\n", "sq": "Shkruani një funksion JavaScript `function f_10(numbers, size)` për të zgjidhur problemin e mëposhtëm:\nLlogaritni shumën e numrave çift në një listë të dhënë.\nParametrat:\n- numbers (Array): Një varg me numra të plotë.\n- size (Number): Madhësia e vargut.\nKthen:\n  Number: Shuma e numrave çift në vargun hyrës.\nShembull përdorimi:\n  f_10([1, 4, 3, 2, 5], 5)  // kthen 6", "hy": "Գրեք JavaScript ֆունկցիա `function f_10(numbers, size)` հետևյալ խնդիրը լուծելու համար:\nՀաշվեք տրված ցուցակի զույգ թվերի գումարը։\nՊարամետրեր:\n- numbers (Array): Թվերի զանգված։\n- size (Number): Զանգվածի չափը։\nՎերադարձնում է:\n  Number: Մուտքային զանգվածի զույգ թվերի գումարը։\nՕրինակ օգտագործում:\n  f_10([1, 4, 3, 2, 5], 5)  // վերադարձնում է 6", "bn": "একটি জাভাস্ক্রিপ্ট ফাংশন `function f_10(numbers, size)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nপ্রদত্ত তালিকায় জোড় সংখ্যাগুলির যোগফল গণনা করুন।\nপ্যারামিটারসমূহ:\n- numbers (Array): পূর্ণসংখ্যার একটি অ্যারে।\n- size (Number): অ্যারের আকার।\nফেরত দেয়:\n  Number: ইনপুট অ্যারের জোড় সংখ্যাগুলির যোগফল।\nউদাহরণ ব্যবহার:\n  f_10([1, 4, 3, 2, 5], 5)  // 6 ফেরত দেয়", "bg": "Напишете JavaScript функция `function f_10(numbers, size)` за решаване на следния проблем:  \nИзчислете сумата на четните числа в даден списък.  \nПараметри:  \n- numbers (Array): Масив от цели числа.  \n- size (Number): Размерът на масива.  \nВръща:  \n  Number: Сумата на четните числа в входния масив.  \nПример за използване:  \n  f_10([1, 4, 3, 2, 5], 5)  // връща 6  ", "zh": "编写一个 JavaScript 函数 `function f_10(numbers, size)` 来解决以下问题：\n计算给定列表中偶数的和。\n参数：\n- numbers (Array): 一个整数数组。\n- size (Number): 数组的大小。\n返回：\n  Number: 输入数组中偶数的和。\n示例用法：\n  f_10([1, 4, 3, 2, 5], 5)  // 返回 6", "fr": "Écrire une fonction JavaScript `function f_10(numbers, size)` pour résoudre le problème suivant :  \nCalculer la somme des nombres pairs dans une liste donnée.  \nParamètres :  \n- numbers (Array) : Un tableau d'entiers.  \n- size (Number) : La taille du tableau.  \nRenvoie :  \n  Number : La somme des nombres pairs dans le tableau d'entrée.  \nExemple d'utilisation :  \n  f_10([1, 4, 3, 2, 5], 5)  // renvoie 6  ", "de": "Schreiben Sie eine JavaScript-Funktion `function f_10(numbers, size)`, um das folgende Problem zu lösen:\nBerechnen Sie die Summe der geraden Zahlen in einer gegebenen Liste.\nParameter:\n- numbers (Array): Ein Array von ganzen Zahlen.\n- size (Number): Die Größe des Arrays.\nRückgabe:\n  Number: Die Summe der geraden Zahlen im Eingabearray.\nBeispielverwendung:\n  f_10([1, 4, 3, 2, 5], 5)  // gibt 6 zurück", "ha": "Rubuta aikin JavaScript `function f_10(numbers, size)` don warware matsalar mai zuwa:\nLissafa jimillar lambobin da suke lamba biyu-biyu a cikin jerin da aka bayar.\nSigogi:\n- numbers (Array): Jeri na lambobi masu cikakken lamba.\n- size (Number): Girman jerin.\nYa dawo:\n  Number: Jimillar lambobin da suke lamba biyu-biyu a cikin jerin shigarwa.\nMisalin amfani:\n  f_10([1, 4, 3, 2, 5], 5)  // ya dawo 6", "hi": "`function f_10(numbers, size)` को हल करने के लिए एक जावास्क्रिप्ट फ़ंक्शन लिखें:\nदिए गए सूची में सम संख्याओं का योग गणना करें।\nपैरामीटर्स:\n- numbers (Array): पूर्णांकों की एक सरणी।\n- size (Number): सरणी का आकार।\nरिटर्न करता है:\n  Number: इनपुट सरणी में सम संख्याओं का योग।\nउदाहरण उपयोग:\n  f_10([1, 4, 3, 2, 5], 5)  // returns 6", "hu": "Írj egy JavaScript függvényt `function f_10(numbers, size)` a következő probléma megoldására:\nSzámítsd ki a páros számok összegét egy adott listában.\nParaméterek:\n- numbers (Array): Egész számok tömbje.\n- size (Number): A tömb mérete.\nVisszatérési érték:\n  Number: A bemeneti tömbben lévő páros számok összege.\nPélda használat:\n  f_10([1, 4, 3, 2, 5], 5)  // visszaadja: 6", "es": "Escribe una función de JavaScript `function f_10(numbers, size)` para resolver el siguiente problema:\nCalcular la suma de los números pares en una lista dada.\nParámetros:\n- numbers (Array): Un array de enteros.\n- size (Number): El tamaño del array.\nDevuelve:\n  Number: La suma de los números pares en el array de entrada.\nEjemplo de uso:\n  f_10([1, 4, 3, 2, 5], 5)  // devuelve 6", "arb": "اكتب دالة JavaScript `function f_10(numbers, size)` لحل المشكلة التالية:\nاحسب مجموع الأعداد الزوجية في قائمة معينة.\nالمعطيات:\n- numbers (Array): مصفوفة من الأعداد الصحيحة.\n- size (Number): حجم المصفوفة.\nالقيم المعادة:\n  Number: مجموع الأعداد الزوجية في المصفوفة المدخلة.\nمثال على الاستخدام:\n  f_10([1, 4, 3, 2, 5], 5)  // يعيد 6", "sw": "Andika kazi ya JavaScript `function f_10(numbers, size)` kutatua tatizo lifuatalo:\nHesabu jumla ya namba shufwa katika orodha iliyotolewa.\nVigezo:\n- numbers (Array): Orodha ya namba nzima.\n- size (Number): Ukubwa wa orodha.\nInarudisha:\n  Number: Jumla ya namba shufwa katika orodha ya ingizo.\nMfano wa matumizi:\n  f_10([1, 4, 3, 2, 5], 5)  // inarudisha 6", "tr": "Bir JavaScript fonksiyonu `function f_10(numbers, size)` yazın:\nVerilen bir listedeki çift sayıların toplamını hesaplayın.\nParametreler:\n- numbers (Array): Bir tamsayı dizisi.\n- size (Number): Dizinin boyutu.\nDöndürür:\n  Number: Girdi dizisindeki çift sayıların toplamı.\nÖrnek kullanım:\n  f_10([1, 4, 3, 2, 5], 5)  // 6 döndürür", "vi": "Viết một hàm JavaScript `function f_10(numbers, size)` để giải quyết vấn đề sau:\nTính tổng của các số chẵn trong một danh sách cho trước.\nTham số:\n- numbers (Array): Một mảng các số nguyên.\n- size (Number): Kích thước của mảng.\nTrả về:\n  Number: Tổng của các số chẵn trong mảng đầu vào.\nVí dụ sử dụng:\n  f_10([1, 4, 3, 2, 5], 5)  // trả về 6", "id": "Tulis sebuah fungsi JavaScript `function f_10(numbers, size)` untuk menyelesaikan masalah berikut:\nHitung jumlah angka genap dalam daftar yang diberikan.\nParameter:\n- numbers (Array): Sebuah array dari bilangan bulat.\n- size (Number): Ukuran dari array.\nMengembalikan:\n  Number: Jumlah angka genap dalam array masukan.\nContoh penggunaan:\n  f_10([1, 4, 3, 2, 5], 5)  // mengembalikan 6", "ja": "JavaScript関数 `function f_10(numbers, size)` を作成して、次の問題を解決してください:\n与えられたリストの偶数の合計を計算します。\nパラメータ:\n- numbers (Array): 整数の配列。\n- size (Number): 配列のサイズ。\n戻り値:\n  Number: 入力配列内の偶数の合計。\n使用例:\n  f_10([1, 4, 3, 2, 5], 5)  // 6を返します。", "ko": "JavaScript 함수를 작성하십시오 `function f_10(numbers, size)` 다음 문제를 해결하기 위해:\n주어진 리스트에서 짝수의 합을 계산하십시오.\n매개변수:\n- numbers (Array): 정수 배열.\n- size (Number): 배열의 크기.\n반환값:\n  Number: 입력 배열에서 짝수의 합.\n사용 예:\n  f_10([1, 4, 3, 2, 5], 5)  // 6 반환", "ml": "`function f_10(numbers, size)` എന്ന ജാവാസ്ക്രിപ്റ്റ് ഫംഗ്ഷൻ എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nനൽകിയിരിക്കുന്ന പട്ടികയിലെ സമസംഖ്യകളുടെ മൊത്തം കണക്കാക്കുക.\nപാരാമീറ്ററുകൾ:\n- numbers (Array): പൂർണ്ണസംഖ്യകളുടെ ഒരു അറേ.\n- size (Number): അറേയുടെ വലിപ്പം.\nമടക്കുന്നു:\n  Number: ഇൻപുട്ട് അറേയിലെ സമസംഖ്യകളുടെ മൊത്തം.\nഉദാഹരണ ഉപയോഗം:\n  f_10([1, 4, 3, 2, 5], 5)  // 6 മടക്കുന്നു", "fa": "یک تابع جاوااسکریپت `function f_10(numbers, size)` بنویسید تا مسئله‌ی زیر را حل کند:\nمجموع اعداد زوج در یک لیست داده شده را محاسبه کنید.\nپارامترها:\n- numbers (Array): یک آرایه از اعداد صحیح.\n- size (Number): اندازه‌ی آرایه.\nبرمی‌گرداند:\n  Number: مجموع اعداد زوج در آرایه ورودی.\nمثال استفاده:\n  f_10([1, 4, 3, 2, 5], 5)  // returns 6"}, "level": "easy", "test": "const testf_10 = () => {\n    console.assert(f_10([1, 4, 3, 2, 5], 5) === 6);\n    console.assert(f_10([2, 2, 0, 0], 4) === 4);\n    console.assert(f_10([7, 11, 19], 3) === 0); // Should return 0 because there are no even numbers\n    console.assert(f_10([12, 14, 16, 18, 20], 5) === (12 + 14 + 16 + 18 + 20));\n\n    // console.log(\"All tests passed successfully.\");\n}\n\ntestf_10();", "entry_point": "f_10", "signature": "function f_10(numbers, size)", "docstring": {"en": "Calculate the sum of even numbers in a given list.\nParameters:\n- numbers (Array): An array of integers.\n- size (Number): The size of the array.\nReturns:\n  Number: The sum of even numbers in the input array.\nExample usage:\n  f_10([1, 4, 3, 2, 5], 5)  // returns 6\n", "sq": "Llogarit shumën e numrave çift në një listë të dhënë.  \nParametrat:  \n- numbers (Array): Një varg me numra të plotë.  \n- size (Number): Madhësia e vargut.  \nKthen:  \n  Number: Shuma e numrave çift në vargun hyrës.  \nShembull përdorimi:  \n  f_10([1, 4, 3, 2, 5], 5)  // kthen 6  ", "hy": "Հաշվարկել տրված ցուցակի զույգ թվերի գումարը։  \nՊարամետրեր:  \n- numbers (Array): Ամբողջ թվերի զանգված։  \n- size (Number): Զանգվածի չափը։  \nՎերադարձնում է:  \n  Number: Մուտքային զանգվածի զույգ թվերի գումարը։  \nՕրինակ օգտագործում:  \n  f_10([1, 4, 3, 2, 5], 5)  // վերադարձնում է 6  ", "bn": "একটি প্রদত্ত তালিকার জোড় সংখ্যাগুলির যোগফল গণনা করুন।\nপ্যারামিটারসমূহ:\n- numbers (Array): পূর্ণসংখ্যার একটি অ্যারে।\n- size (Number): অ্যারের আকার।\nফেরত দেয়:\n  Number: ইনপুট অ্যারের জোড় সংখ্যাগুলির যোগফল।\nউদাহরণ ব্যবহার:\n  f_10([1, 4, 3, 2, 5], 5)  // 6 ফেরত দেয়", "bg": "Изчислява сумата на четните числа в даден списък.\nПараметри:\n- numbers (Array): Масив от цели числа.\n- size (Number): Размерът на масива.\nВръща:\n  Number: Сумата на четните числа в входния масив.\nПример за използване:\n  f_10([1, 4, 3, 2, 5], 5)  // връща 6", "zh": "计算给定列表中偶数的和。\n参数：\n- numbers (Array): 整数数组。\n- size (Number): 数组的大小。\n返回：\n  Number: 输入数组中偶数的和。\n示例用法：\n  f_10([1, 4, 3, 2, 5], 5)  // 返回 6", "fr": "Calculer la somme des nombres pairs dans une liste donnée.\nParamètres :\n- numbers (Array) : Un tableau d'entiers.\n- size (Number) : La taille du tableau.\nRenvoie :\n  Number : La somme des nombres pairs dans le tableau d'entrée.\nExemple d'utilisation :\n  f_10([1, 4, 3, 2, 5], 5)  // renvoie 6", "de": "Berechnen Sie die Summe der geraden Zahlen in einer gegebenen Liste.\nParameter:\n- numbers (Array): Ein Array von ganzen Zahlen.\n- size (Number): Die Größe des Arrays.\nRückgabewert:\n  Number: Die Summe der geraden Zahlen im Eingabearray.\nBeispielverwendung:\n  f_10([1, 4, 3, 2, 5], 5)  // gibt 6 zurück", "ha": "Ƙididdige jimillar lambobin da suka kasance ma'aurata a cikin jerin da aka bayar.\nSigogi:\n- numbers (Array): Jeri na lambobin tsintsiya.\n- size (Number): Girman jerin.\nDawowa:\n  Number: Jimillar lambobin ma'aurata a cikin jerin shigarwa.\nMisalin amfani:\n  f_10([1, 4, 3, 2, 5], 5)  // yana dawowa 6", "hi": "दिए गए सूची में सम संख्या का योग गणना करें।\nपैरामीटर्स:\n- numbers (Array): पूर्णांकों की एक श्रृंखला।\n- size (Number): श्रृंखला का आकार।\nरिटर्न:\n  Number: इनपुट श्रृंखला में सम संख्याओं का योग।\nउदाहरण उपयोग:\n  f_10([1, 4, 3, 2, 5], 5)  // 6 लौटाता है", "hu": "Számítsa ki a páros számok összegét egy adott listában.  \nParaméterek:  \n- numbers (Array): Egész számok tömbje.  \n- size (Number): A tömb mérete.  \nVisszatér:  \n  Number: A bemeneti tömbben található páros számok összege.  \nPélda használat:  \n  f_10([1, 4, 3, 2, 5], 5)  // visszaadja: 6  ", "es": "Calcular la suma de los números pares en una lista dada.\nParámetros:\n- numbers (Array): Un arreglo de enteros.\n- size (Number): El tamaño del arreglo.\nDevuelve:\n  Number: La suma de los números pares en el arreglo de entrada.\nEjemplo de uso:\n  f_10([1, 4, 3, 2, 5], 5)  // devuelve 6", "arb": "احسب مجموع الأعداد الزوجية في قائمة معينة.  \nالمعلمات:  \n- numbers (Array): مصفوفة من الأعداد الصحيحة.  \n- size (Number): حجم المصفوفة.  \nالقيم المعادة:  \n  Number: مجموع الأعداد الزوجية في المصفوفة المدخلة.  \nمثال على الاستخدام:  \n  f_10([1, 4, 3, 2, 5], 5)  // يعيد 6  ", "sw": "Hesabu jumla ya namba shufwa katika orodha iliyotolewa.  \nVigezo:  \n- numbers (Array): Orodha ya namba nzima.  \n- size (Number): Ukubwa wa orodha.  \nInarejesha:  \n  Number: Jumla ya namba shufwa katika orodha ya pembejeo.  \nMfano wa matumizi:  \n  f_10([1, 4, 3, 2, 5], 5)  // inarejesha 6  ", "tr": "Verilen bir listedeki çift sayıların toplamını hesaplayın.  \nParametreler:  \n- numbers (Dizi): Bir tamsayı dizisi.  \n- size (Sayı): Dizinin boyutu.  \nDöndürülen:  \n  Sayı: Girdi dizisindeki çift sayıların toplamı.  \nÖrnek kullanım:  \n  f_10([1, 4, 3, 2, 5], 5)  // 6 döndürür  ", "vi": "Tính tổng các số chẵn trong một danh sách cho trước.\nTham số:\n- numbers (Array): Một mảng các số nguyên.\n- size (Number): Kích thước của mảng.\nTrả về:\n  Number: Tổng các số chẵn trong mảng đầu vào.\nVí dụ sử dụng:\n  f_10([1, 4, 3, 2, 5], 5)  // trả về 6", "id": "Hitung jumlah bilangan genap dalam daftar yang diberikan.  \nParameter:  \n- numbers (Array): Sebuah array dari bilangan bulat.  \n- size (Number): Ukuran dari array.  \nMengembalikan:  \n  Number: Jumlah dari bilangan genap dalam array input.  \nContoh penggunaan:  \n  f_10([1, 4, 3, 2, 5], 5)  // mengembalikan 6  ", "ja": "偶数の合計を計算します。\n\n引数:\n- numbers (Array): 整数の配列。\n- size (Number): 配列のサイズ。\n\n戻り値:\n  Number: 入力配列内の偶数の合計。\n\n使用例:\n  f_10([1, 4, 3, 2, 5], 5)  // 6を返します。", "ko": "주어진 리스트에서 짝수의 합을 계산합니다.  \n매개변수:  \n- numbers (Array): 정수 배열입니다.  \n- size (Number): 배열의 크기입니다.  \n반환값:  \n  Number: 입력 배열에서 짝수의 합입니다.  \n사용 예:  \n  f_10([1, 4, 3, 2, 5], 5)  // 6을 반환합니다.  ", "ml": "നൽകിയ ലിസ്റ്റിലെ സമ സംഖ്യകളുടെ മൊത്തം കണക്കാക്കുക.\nപാരാമീറ്ററുകൾ:\n- numbers (Array): പൂർണ്ണസംഖ്യകളുടെ ഒരു നിര.\n- size (Number): നിരയുടെ വലിപ്പം.\nമടക്കുക:\n  Number: ഇൻപുട്ട് നിരയിലെ സമ സംഖ്യകളുടെ മൊത്തം.\nഉദാഹരണ ഉപയോഗം:\n  f_10([1, 4, 3, 2, 5], 5)  // 6 മടക്കുന്നു", "fa": "محاسبه مجموع اعداد زوج در یک لیست داده شده.\n\nپارامترها:\n- numbers (Array): یک آرایه از اعداد صحیح.\n- size (Number): اندازه آرایه.\n\nبازگشت:\n  Number: مجموع اعداد زوج در آرایه ورودی.\n\nمثال استفاده:\n  f_10([1, 4, 3, 2, 5], 5)  // مقدار 6 را برمی‌گرداند."}}
{"task_id": "JavaScript/11", "prompt": {"en": "// No import is necessary as we're not using any modules or libraries\n/**\n * Determine if two closed intervals intersect.\n * \n * @param {number} a - Start of the first closed interval, must satisfy 0 <= a <= b <= 1000.\n * @param {number} b - End of the first closed interval, must satisfy 0 <= a <= b <= 1000.\n * @param {number} c - Start of the second closed interval, must satisfy 0 <= c <= d <= 1000.\n * @param {number} d - End of the second closed interval, must satisfy 0 <= c <= d <= 1000.\n * @returns {number} 1 if the intervals intersect, 0 otherwise.\n */\nfunction f_11(a, b, c, d)", "sq": "// Nuk është e nevojshme të importoni pasi nuk po përdorim asnjë modul ose bibliotekë\n/**\n * Përcaktoni nëse dy intervale të mbyllura ndërpriten.\n * \n * @param {number} a - Fillimi i intervalit të parë të mbyllur, duhet të plotësojë 0 <= a <= b <= 1000.\n * @param {number} b - Fundi i intervalit të parë të mbyllur, duhet të plotësojë 0 <= a <= b <= 1000.\n * @param {number} c - Fillimi i intervalit të dytë të mbyllur, duhet të plotësojë 0 <= c <= d <= 1000.\n * @param {number} d - Fundi i intervalit të dytë të mbyllur, duhet të plotësojë 0 <= c <= d <= 1000.\n * @returns {number} 1 nëse intervalet ndërpriten, 0 përndryshe.\n */", "hy": "// Ոչ մի ներմուծում անհրաժեշտ չէ, քանի որ մենք չենք օգտագործում որևէ մոդուլ կամ գրադարան\n/**\n * Որոշել՝ արդյոք երկու փակ միջակայքեր հատվում են։\n * \n * @param {number} a - Առաջին փակ միջակայքի սկիզբը, պետք է բավարարի 0 <= a <= b <= 1000։\n * @param {number} b - Առաջին փակ միջակայքի վերջը, պետք է բավարարի 0 <= a <= b <= 1000։\n * @param {number} c - Երկրորդ փակ միջակայքի սկիզբը, պետք է բավարարի 0 <= c <= d <= 1000։\n * @param {number} d - Երկրորդ փակ միջակայքի վերջը, պետք է բավարարի 0 <= c <= d <= 1000։\n * @returns {number} 1 եթե միջակայքերը հատվում են, 0՝ հակառակ դեպքում։\n */", "bn": "// কোনো ইম্পোর্ট প্রয়োজন নেই কারণ আমরা কোনো মডিউল বা লাইব্রেরি ব্যবহার করছি না\n/**\n * নির্ধারণ করুন দুটি বন্ধ ইন্টারভাল ছেদ করে কিনা।\n * \n * @param {number} a - প্রথম বন্ধ ইন্টারভালের শুরু, অবশ্যই 0 <= a <= b <= 1000 শর্ত পূরণ করতে হবে।\n * @param {number} b - প্রথম বন্ধ ইন্টারভালের শেষ, অবশ্যই 0 <= a <= b <= 1000 শর্ত পূরণ করতে হবে।\n * @param {number} c - দ্বিতীয় বন্ধ ইন্টারভালের শুরু, অবশ্যই 0 <= c <= d <= 1000 শর্ত পূরণ করতে হবে।\n * @param {number} d - দ্বিতীয় বন্ধ ইন্টারভালের শেষ, অবশ্যই 0 <= c <= d <= 1000 শর্ত পূরণ করতে হবে।\n * @returns {number} ইন্টারভালগুলি ছেদ করলে 1, অন্যথায় 0।\n */", "bg": "// Няма нужда от импортиране, тъй като не използваме никакви модули или библиотеки\n/**\n * Определя дали два затворени интервала се пресичат.\n * \n * @param {number} a - Начало на първия затворен интервал, трябва да удовлетворява 0 <= a <= b <= 1000.\n * @param {number} b - Край на първия затворен интервал, трябва да удовлетворява 0 <= a <= b <= 1000.\n * @param {number} c - Начало на втория затворен интервал, трябва да удовлетворява 0 <= c <= d <= 1000.\n * @param {number} d - Край на втория затворен интервал, трябва да удовлетворява 0 <= c <= d <= 1000.\n * @returns {number} 1 ако интервалите се пресичат, 0 в противен случай.\n */", "zh": "// 不需要导入，因为我们不使用任何模块或库\n/**\n * 判断两个闭区间是否相交。\n * \n * @param {number} a - 第一个闭区间的起始，必须满足 0 <= a <= b <= 1000。\n * @param {number} b - 第一个闭区间的结束，必须满足 0 <= a <= b <= 1000。\n * @param {number} c - 第二个闭区间的起始，必须满足 0 <= c <= d <= 1000。\n * @param {number} d - 第二个闭区间的结束，必须满足 0 <= c <= d <= 1000。\n * @returns {number} 如果区间相交返回 1，否则返回 0。\n */", "fr": "// Aucun import n'est nécessaire car nous n'utilisons aucun module ou bibliothèque\n/**\n * Déterminer si deux intervalles fermés s'intersectent.\n * \n * @param {number} a - Début du premier intervalle fermé, doit satisfaire 0 <= a <= b <= 1000.\n * @param {number} b - Fin du premier intervalle fermé, doit satisfaire 0 <= a <= b <= 1000.\n * @param {number} c - Début du deuxième intervalle fermé, doit satisfaire 0 <= c <= d <= 1000.\n * @param {number} d - Fin du deuxième intervalle fermé, doit satisfaire 0 <= c <= d <= 1000.\n * @returns {number} 1 si les intervalles s'intersectent, 0 sinon.\n */", "de": "// Kein Import ist notwendig, da wir keine Module oder Bibliotheken verwenden\n/**\n * Bestimmen, ob zwei geschlossene Intervalle sich überschneiden.\n * \n * @param {number} a - Anfang des ersten geschlossenen Intervalls, muss 0 <= a <= b <= 1000 erfüllen.\n * @param {number} b - Ende des ersten geschlossenen Intervalls, muss 0 <= a <= b <= 1000 erfüllen.\n * @param {number} c - Anfang des zweiten geschlossenen Intervalls, muss 0 <= c <= d <= 1000 erfüllen.\n * @param {number} d - Ende des zweiten geschlossenen Intervalls, muss 0 <= c <= d <= 1000 erfüllen.\n * @returns {number} 1, wenn die Intervalle sich überschneiden, 0 andernfalls.\n */\nfunction f_11(a, b, c, d)", "ha": "// Babu buƙatar shigo da wani abu domin ba ma amfani da kowanne modules ko libraries\n/**\n * Tantance idan tsaka-tsakin rufe guda biyu suna haɗuwa.\n * \n * @param {number} a - Farko na tsaka-tsakin rufe na farko, dole ne ya cika 0 <= a <= b <= 1000.\n * @param {number} b - Ƙarshe na tsaka-tsakin rufe na farko, dole ne ya cika 0 <= a <= b <= 1000.\n * @param {number} c - Farko na tsaka-tsakin rufe na biyu, dole ne ya cika 0 <= c <= d <= 1000.\n * @param {number} d - Ƙarshe na tsaka-tsakin rufe na biyu, dole ne ya cika 0 <= c <= d <= 1000.\n * @returns {number} 1 idan tsaka-tsakin suna haɗuwa, 0 in ba haka ba.\n */", "hi": "// किसी आयात की आवश्यकता नहीं है क्योंकि हम कोई मॉड्यूल या लाइब्रेरी उपयोग नहीं कर रहे हैं\n/**\n * निर्धारित करें कि क्या दो बंद अंतराल एक-दूसरे को काटते हैं।\n * \n * @param {number} a - पहले बंद अंतराल की शुरुआत, 0 <= a <= b <= 1000 को संतुष्ट करना चाहिए।\n * @param {number} b - पहले बंद अंतराल का अंत, 0 <= a <= b <= 1000 को संतुष्ट करना चाहिए।\n * @param {number} c - दूसरे बंद अंतराल की शुरुआत, 0 <= c <= d <= 1000 को संतुष्ट करना चाहिए।\n * @param {number} d - दूसरे बंद अंतराल का अंत, 0 <= c <= d <= 1000 को संतुष्ट करना चाहिए।\n * @returns {number} 1 यदि अंतराल एक-दूसरे को काटते हैं, अन्यथा 0।\n */", "hu": "// Nincs szükség importálásra, mivel nem használunk semmilyen modult vagy könyvtárat\n/**\n * Határozza meg, hogy két zárt intervallum metszi-e egymást.\n * \n * @param {number} a - Az első zárt intervallum kezdete, teljesítenie kell a 0 <= a <= b <= 1000 feltételt.\n * @param {number} b - Az első zárt intervallum vége, teljesítenie kell a 0 <= a <= b <= 1000 feltételt.\n * @param {number} c - A második zárt intervallum kezdete, teljesítenie kell a 0 <= c <= d <= 1000 feltételt.\n * @param {number} d - A második zárt intervallum vége, teljesítenie kell a 0 <= c <= d <= 1000 feltételt.\n * @returns {number} 1, ha az intervallumok metszik egymást, különben 0.\n */", "es": "// No es necesario importar ya que no estamos usando ningún módulo o biblioteca\n/**\n * Determinar si dos intervalos cerrados se intersectan.\n * \n * @param {number} a - Inicio del primer intervalo cerrado, debe satisfacer 0 <= a <= b <= 1000.\n * @param {number} b - Fin del primer intervalo cerrado, debe satisfacer 0 <= a <= b <= 1000.\n * @param {number} c - Inicio del segundo intervalo cerrado, debe satisfacer 0 <= c <= d <= 1000.\n * @param {number} d - Fin del segundo intervalo cerrado, debe satisfacer 0 <= c <= d <= 1000.\n * @returns {number} 1 si los intervalos se intersectan, 0 en caso contrario.\n */\nfunction f_11(a, b, c, d)", "arb": "// لا حاجة للاستيراد لأننا لا نستخدم أي وحدات أو مكتبات\n/**\n * تحديد ما إذا كان هناك تقاطع بين فترتين مغلقتين.\n * \n * @param {number} a - بداية الفترة المغلقة الأولى، يجب أن تحقق 0 <= a <= b <= 1000.\n * @param {number} b - نهاية الفترة المغلقة الأولى، يجب أن تحقق 0 <= a <= b <= 1000.\n * @param {number} c - بداية الفترة المغلقة الثانية، يجب أن تحقق 0 <= c <= d <= 1000.\n * @param {number} d - نهاية الفترة المغلقة الثانية، يجب أن تحقق 0 <= c <= d <= 1000.\n * @returns {number} 1 إذا كانت الفترات تتقاطع، 0 إذا لم تتقاطع.\n */\nfunction f_11(a, b, c, d)", "sw": "// Hakuna uingizaji unaohitajika kwani hatutumii moduli au maktaba\n/**\n * Kuamua kama vipindi viwili vilivyofungwa vinakatana.\n * \n * @param {number} a - Mwanzo wa kipindi cha kwanza kilichofungwa, lazima itimize 0 <= a <= b <= 1000.\n * @param {number} b - Mwisho wa kipindi cha kwanza kilichofungwa, lazima itimize 0 <= a <= b <= 1000.\n * @param {number} c - Mwanzo wa kipindi cha pili kilichofungwa, lazima itimize 0 <= c <= d <= 1000.\n * @param {number} d - Mwisho wa kipindi cha pili kilichofungwa, lazima itimize 0 <= c <= d <= 1000.\n * @returns {number} 1 ikiwa vipindi vinakatana, 0 vinginevyo.\n */\nfunction f_11(a, b, c, d)", "tr": "// Herhangi bir modül veya kütüphane kullanmadığımız için ithalat gerekli değil\n/**\n * İki kapalı aralığın kesişip kesişmediğini belirleyin.\n * \n * @param {number} a - İlk kapalı aralığın başlangıcı, 0 <= a <= b <= 1000 şartını sağlamalıdır.\n * @param {number} b - İlk kapalı aralığın sonu, 0 <= a <= b <= 1000 şartını sağlamalıdır.\n * @param {number} c - İkinci kapalı aralığın başlangıcı, 0 <= c <= d <= 1000 şartını sağlamalıdır.\n * @param {number} d - İkinci kapalı aralığın sonu, 0 <= c <= d <= 1000 şartını sağlamalıdır.\n * @returns {number} Aralıklar kesişiyorsa 1, aksi takdirde 0 döner.\n */\nfunction f_11(a, b, c, d)", "vi": "// Không cần import vì chúng ta không sử dụng bất kỳ module hay thư viện nào\n/**\n * Xác định xem hai khoảng đóng có giao nhau hay không.\n * \n * @param {number} a - Điểm bắt đầu của khoảng đóng thứ nhất, phải thỏa mãn 0 <= a <= b <= 1000.\n * @param {number} b - Điểm kết thúc của khoảng đóng thứ nhất, phải thỏa mãn 0 <= a <= b <= 1000.\n * @param {number} c - Điểm bắt đầu của khoảng đóng thứ hai, phải thỏa mãn 0 <= c <= d <= 1000.\n * @param {number} d - Điểm kết thúc của khoảng đóng thứ hai, phải thỏa mãn 0 <= c <= d <= 1000.\n * @returns {number} 1 nếu các khoảng giao nhau, 0 nếu không.\n */\nfunction f_11(a, b, c, d)", "id": "// Tidak perlu impor karena kita tidak menggunakan modul atau pustaka apa pun\n/**\n * Tentukan apakah dua interval tertutup saling berpotongan.\n * \n * @param {number} a - Awal dari interval tertutup pertama, harus memenuhi 0 <= a <= b <= 1000.\n * @param {number} b - Akhir dari interval tertutup pertama, harus memenuhi 0 <= a <= b <= 1000.\n * @param {number} c - Awal dari interval tertutup kedua, harus memenuhi 0 <= c <= d <= 1000.\n * @param {number} d - Akhir dari interval tertutup kedua, harus memenuhi 0 <= c <= d <= 1000.\n * @returns {number} 1 jika interval berpotongan, 0 jika tidak.\n */\nfunction f_11(a, b, c, d)", "ja": "// モジュールやライブラリを使用していないため、インポートは必要ありません\n/**\n * 2つの閉区間が交差するかどうかを判定します。\n * \n * @param {number} a - 最初の閉区間の開始、0 <= a <= b <= 1000 を満たす必要があります。\n * @param {number} b - 最初の閉区間の終了、0 <= a <= b <= 1000 を満たす必要があります。\n * @param {number} c - 2番目の閉区間の開始、0 <= c <= d <= 1000 を満たす必要があります。\n * @param {number} d - 2番目の閉区間の終了、0 <= c <= d <= 1000 を満たす必要があります。\n * @returns {number} 区間が交差する場合は1を、そうでない場合は0を返します。\n */\nfunction f_11(a, b, c, d)", "ko": "// 모듈이나 라이브러리를 사용하지 않으므로 import는 필요하지 않습니다.\n/**\n * 두 닫힌 구간이 교차하는지 확인합니다.\n * \n * @param {number} a - 첫 번째 닫힌 구간의 시작, 0 <= a <= b <= 1000을 만족해야 합니다.\n * @param {number} b - 첫 번째 닫힌 구간의 끝, 0 <= a <= b <= 1000을 만족해야 합니다.\n * @param {number} c - 두 번째 닫힌 구간의 시작, 0 <= c <= d <= 1000을 만족해야 합니다.\n * @param {number} d - 두 번째 닫힌 구간의 끝, 0 <= c <= d <= 1000을 만족해야 합니다.\n * @returns {number} 구간이 교차하면 1을, 그렇지 않으면 0을 반환합니다.\n */\nfunction f_11(a, b, c, d)", "ml": "// ഏതെങ്കിലും മോഡ്യൂളുകളോ ലൈബ്രറികളോ ഉപയോഗിക്കുന്നില്ലാത്തതിനാൽ ഇറക്കുമതി ആവശ്യമില്ല\n/**\n * രണ്ട് അടച്ച ഇടവേളകൾ തമ്മിൽ മുറുകിയിട്ടുണ്ടോ എന്ന് നിർണയിക്കുക.\n * \n * @param {number} a - ആദ്യ അടച്ച ഇടവേളയുടെ ആരംഭം, 0 <= a <= b <= 1000 എന്ന വ്യവസ്ഥ പാലിക്കണം.\n * @param {number} b - ആദ്യ അടച്ച ഇടവേളയുടെ അവസാനം, 0 <= a <= b <= 1000 എന്ന വ്യവസ്ഥ പാലിക്കണം.\n * @param {number} c - രണ്ടാം അടച്ച ഇടവേളയുടെ ആരംഭം, 0 <= c <= d <= 1000 എന്ന വ്യവസ്ഥ പാലിക്കണം.\n * @param {number} d - രണ്ടാം അടച്ച ഇടവേളയുടെ അവസാനം, 0 <= c <= d <= 1000 എന്ന വ്യവസ്ഥ പാലിക്കണം.\n * @returns {number} ഇടവേളകൾ മുറുകിയിട്ടുണ്ടെങ്കിൽ 1, അല്ലാത്തപക്ഷം 0.\n */\nfunction f_11(a, b, c, d)", "fa": "// نیازی به وارد کردن نیست زیرا ما از هیچ ماژول یا کتابخانه ای استفاده نمی کنیم\n/**\n * تعیین کنید که آیا دو بازه بسته با هم تلاقی دارند یا خیر.\n * \n * @param {number} a - شروع اولین بازه بسته، باید شرط 0 <= a <= b <= 1000 را برآورده کند.\n * @param {number} b - پایان اولین بازه بسته، باید شرط 0 <= a <= b <= 1000 را برآورده کند.\n * @param {number} c - شروع دومین بازه بسته، باید شرط 0 <= c <= d <= 1000 را برآورده کند.\n * @param {number} d - پایان دومین بازه بسته، باید شرط 0 <= c <= d <= 1000 را برآورده کند.\n * @returns {number} 1 اگر بازه‌ها تلاقی دارند، در غیر این صورت 0.\n */\nfunction f_11(a, b, c, d)"}, "canonical_solution": "{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}", "instruction": {"en": "Write a JavaScript function `function f_11(a, b, c, d)` to solve the following problem:\nDetermine if two closed intervals intersect.\n\n@param {number} a - Start of the first closed interval, must satisfy 0 <= a <= b <= 1000.\n@param {number} b - End of the first closed interval, must satisfy 0 <= a <= b <= 1000.\n@param {number} c - Start of the second closed interval, must satisfy 0 <= c <= d <= 1000.\n@param {number} d - End of the second closed interval, must satisfy 0 <= c <= d <= 1000.\n@returns {number} 1 if the intervals intersect, 0 otherwise.\n", "sq": "Shkruani një funksion JavaScript `function f_11(a, b, c, d)` për të zgjidhur problemin e mëposhtëm:\nPërcaktoni nëse dy intervale të mbyllura ndërpriten.\n\n@param {number} a - Fillimi i intervalit të parë të mbyllur, duhet të plotësojë 0 <= a <= b <= 1000.\n@param {number} b - Fundi i intervalit të parë të mbyllur, duhet të plotësojë 0 <= a <= b <= 1000.\n@param {number} c - Fillimi i intervalit të dytë të mbyllur, duhet të plotësojë 0 <= c <= d <= 1000.\n@param {number} d - Fundi i intervalit të dytë të mbyllur, duhet të plotësojë 0 <= c <= d <= 1000.\n@returns {number} 1 nëse intervalet ndërpriten, 0 përndryshe.", "hy": "Գրեք JavaScript ֆունկցիա `function f_11(a, b, c, d)` հետևյալ խնդիրը լուծելու համար:\nՈրոշեք, արդյոք երկու փակ միջակայքերը հատվում են:\n\n@param {number} a - Առաջին փակ միջակայքի սկիզբը, պետք է բավարարի 0 <= a <= b <= 1000.\n@param {number} b - Առաջին փակ միջակայքի վերջը, պետք է բավարարի 0 <= a <= b <= 1000.\n@param {number} c - Երկրորդ փակ միջակայքի սկիզբը, պետք է բավարարի 0 <= c <= d <= 1000.\n@param {number} d - Երկրորդ փակ միջակայքի վերջը, պետք է բավարարի 0 <= c <= d <= 1000.\n@returns {number} 1 եթե միջակայքերը հատվում են, 0՝ հակառակ դեպքում.", "bn": "একটি জাভাস্ক্রিপ্ট ফাংশন `function f_11(a, b, c, d)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nদুইটি বন্ধ ইন্টারভাল পরস্পরকে অতিক্রম করে কিনা তা নির্ধারণ করুন।\n\n@param {number} a - প্রথম বন্ধ ইন্টারভালের শুরু, 0 <= a <= b <= 1000 শর্তটি পূরণ করতে হবে।\n@param {number} b - প্রথম বন্ধ ইন্টারভালের শেষ, 0 <= a <= b <= 1000 শর্তটি পূরণ করতে হবে।\n@param {number} c - দ্বিতীয় বন্ধ ইন্টারভালের শুরু, 0 <= c <= d <= 1000 শর্তটি পূরণ করতে হবে।\n@param {number} d - দ্বিতীয় বন্ধ ইন্টারভালের শেষ, 0 <= c <= d <= 1000 শর্তটি পূরণ করতে হবে।\n@returns {number} ইন্টারভালগুলি অতিক্রম করলে 1, অন্যথায় 0।", "bg": "Напишете JavaScript функция `function f_11(a, b, c, d)` за решаване на следния проблем:  \nОпределете дали два затворени интервала се пресичат.\n\n@param {number} a - Начало на първия затворен интервал, трябва да удовлетворява 0 <= a <= b <= 1000.\n@param {number} b - Край на първия затворен интервал, трябва да удовлетворява 0 <= a <= b <= 1000.\n@param {number} c - Начало на втория затворен интервал, трябва да удовлетворява 0 <= c <= d <= 1000.\n@param {number} d - Край на втория затворен интервал, трябва да удовлетворява 0 <= c <= d <= 1000.\n@returns {number} 1 ако интервалите се пресичат, 0 в противен случай.", "zh": "编写一个 JavaScript 函数 `function f_11(a, b, c, d)` 来解决以下问题：\n确定两个闭区间是否相交。\n\n@param {number} a - 第一个闭区间的起始，必须满足 0 <= a <= b <= 1000。\n@param {number} b - 第一个闭区间的结束，必须满足 0 <= a <= b <= 1000。\n@param {number} c - 第二个闭区间的起始，必须满足 0 <= c <= d <= 1000。\n@param {number} d - 第二个闭区间的结束，必须满足 0 <= c <= d <= 1000。\n@returns {number} 如果区间相交返回 1，否则返回 0。", "fr": "Écrire une fonction JavaScript `function f_11(a, b, c, d)` pour résoudre le problème suivant :\nDéterminer si deux intervalles fermés s'intersectent.\n\n@param {number} a - Début du premier intervalle fermé, doit satisfaire 0 <= a <= b <= 1000.\n@param {number} b - Fin du premier intervalle fermé, doit satisfaire 0 <= a <= b <= 1000.\n@param {number} c - Début du deuxième intervalle fermé, doit satisfaire 0 <= c <= d <= 1000.\n@param {number} d - Fin du deuxième intervalle fermé, doit satisfaire 0 <= c <= d <= 1000.\n@returns {number} 1 si les intervalles s'intersectent, 0 sinon.", "de": "Schreiben Sie eine JavaScript-Funktion `function f_11(a, b, c, d)`, um das folgende Problem zu lösen:\nBestimmen Sie, ob zwei geschlossene Intervalle sich überschneiden.\n\n@param {number} a - Anfang des ersten geschlossenen Intervalls, muss 0 <= a <= b <= 1000 erfüllen.\n@param {number} b - Ende des ersten geschlossenen Intervalls, muss 0 <= a <= b <= 1000 erfüllen.\n@param {number} c - Anfang des zweiten geschlossenen Intervalls, muss 0 <= c <= d <= 1000 erfüllen.\n@param {number} d - Ende des zweiten geschlossenen Intervalls, muss 0 <= c <= d <= 1000 erfüllen.\n@returns {number} 1, wenn die Intervalle sich überschneiden, 0 andernfalls.", "ha": "Rubuta wani aikin JavaScript `function f_11(a, b, c, d)` don warware matsalar mai zuwa:\nGano idan tsaka-tsakin rufe guda biyu suna haɗuwa.\n\n@param {number} a - Farkon tsaka-tsakin rufe na farko, dole ne ya cika 0 <= a <= b <= 1000.\n@param {number} b - Ƙarshen tsaka-tsakin rufe na farko, dole ne ya cika 0 <= a <= b <= 1000.\n@param {number} c - Farkon tsaka-tsakin rufe na biyu, dole ne ya cika 0 <= c <= d <= 1000.\n@param {number} d - Ƙarshen tsaka-tsakin rufe na biyu, dole ne ya cika 0 <= c <= d <= 1000.\n@returns {number} 1 idan tsaka-tsakin suna haɗuwa, 0 in ba haka ba.", "hi": "एक JavaScript फ़ंक्शन `function f_11(a, b, c, d)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nनिर्धारित करें कि दो बंद अंतराल एक-दूसरे को काटते हैं या नहीं।\n\n@param {number} a - पहले बंद अंतराल की शुरुआत, इसे 0 <= a <= b <= 1000 को संतुष्ट करना चाहिए।\n@param {number} b - पहले बंद अंतराल का अंत, इसे 0 <= a <= b <= 1000 को संतुष्ट करना चाहिए।\n@param {number} c - दूसरे बंद अंतराल की शुरुआत, इसे 0 <= c <= d <= 1000 को संतुष्ट करना चाहिए।\n@param {number} d - दूसरे बंद अंतराल का अंत, इसे 0 <= c <= d <= 1000 को संतुष्ट करना चाहिए।\n@returns {number} 1 यदि अंतराल एक-दूसरे को काटते हैं, अन्यथा 0।", "hu": "Írj egy JavaScript függvényt `function f_11(a, b, c, d)` a következő probléma megoldására:\nHatározd meg, hogy két zárt intervallum metszi-e egymást.\n\n@param {number} a - Az első zárt intervallum kezdete, meg kell felelnie a 0 <= a <= b <= 1000 feltételnek.\n@param {number} b - Az első zárt intervallum vége, meg kell felelnie a 0 <= a <= b <= 1000 feltételnek.\n@param {number} c - A második zárt intervallum kezdete, meg kell felelnie a 0 <= c <= d <= 1000 feltételnek.\n@param {number} d - A második zárt intervallum vége, meg kell felelnie a 0 <= c <= d <= 1000 feltételnek.\n@returns {number} 1, ha az intervallumok metszik egymást, 0 különben.", "es": "Escribe una función de JavaScript `function f_11(a, b, c, d)` para resolver el siguiente problema:\nDeterminar si dos intervalos cerrados se intersectan.\n\n@param {number} a - Inicio del primer intervalo cerrado, debe satisfacer 0 <= a <= b <= 1000.\n@param {number} b - Fin del primer intervalo cerrado, debe satisfacer 0 <= a <= b <= 1000.\n@param {number} c - Inicio del segundo intervalo cerrado, debe satisfacer 0 <= c <= d <= 1000.\n@param {number} d - Fin del segundo intervalo cerrado, debe satisfacer 0 <= c <= d <= 1000.\n@returns {number} 1 si los intervalos se intersectan, 0 en caso contrario.", "arb": "اكتب دالة JavaScript `function f_11(a, b, c, d)` لحل المشكلة التالية:\nتحديد ما إذا كانت فترتان مغلقتان تتقاطعان.\n\n@param {number} a - بداية الفترة المغلقة الأولى، يجب أن تحقق 0 <= a <= b <= 1000.\n@param {number} b - نهاية الفترة المغلقة الأولى، يجب أن تحقق 0 <= a <= b <= 1000.\n@param {number} c - بداية الفترة المغلقة الثانية، يجب أن تحقق 0 <= c <= d <= 1000.\n@param {number} d - نهاية الفترة المغلقة الثانية، يجب أن تحقق 0 <= c <= d <= 1000.\n@returns {number} 1 إذا كانت الفترات تتقاطع، 0 خلاف ذلك.", "sw": "Andika kazi ya JavaScript `function f_11(a, b, c, d)` kutatua tatizo lifuatalo:  \nTambua kama vipindi viwili vilivyofungwa vinakatana.\n\n@param {number} a - Mwanzo wa kipindi cha kwanza kilichofungwa, lazima kitimize 0 <= a <= b <= 1000.\n@param {number} b - Mwisho wa kipindi cha kwanza kilichofungwa, lazima kitimize 0 <= a <= b <= 1000.\n@param {number} c - Mwanzo wa kipindi cha pili kilichofungwa, lazima kitimize 0 <= c <= d <= 1000.\n@param {number} d - Mwisho wa kipindi cha pili kilichofungwa, lazima kitimize 0 <= c <= d <= 1000.\n@returns {number} 1 ikiwa vipindi vinakatana, 0 vinginevyo.", "tr": "Bir JavaScript fonksiyonu `function f_11(a, b, c, d)` yazın ve aşağıdaki problemi çözün:\nİki kapalı aralığın kesişip kesişmediğini belirleyin.\n\n@param {number} a - İlk kapalı aralığın başlangıcı, 0 <= a <= b <= 1000 koşulunu sağlamalıdır.\n@param {number} b - İlk kapalı aralığın sonu, 0 <= a <= b <= 1000 koşulunu sağlamalıdır.\n@param {number} c - İkinci kapalı aralığın başlangıcı, 0 <= c <= d <= 1000 koşulunu sağlamalıdır.\n@param {number} d - İkinci kapalı aralığın sonu, 0 <= c <= d <= 1000 koşulunu sağlamalıdır.\n@returns {number} Aralıklar kesişiyorsa 1, aksi takdirde 0 döner.", "vi": "Viết một hàm JavaScript `function f_11(a, b, c, d)` để giải quyết vấn đề sau:\nXác định xem hai đoạn đóng có giao nhau hay không.\n\n@param {number} a - Điểm bắt đầu của đoạn đóng thứ nhất, phải thỏa mãn 0 <= a <= b <= 1000.\n@param {number} b - Điểm kết thúc của đoạn đóng thứ nhất, phải thỏa mãn 0 <= a <= b <= 1000.\n@param {number} c - Điểm bắt đầu của đoạn đóng thứ hai, phải thỏa mãn 0 <= c <= d <= 1000.\n@param {number} d - Điểm kết thúc của đoạn đóng thứ hai, phải thỏa mãn 0 <= c <= d <= 1000.\n@returns {number} 1 nếu các đoạn giao nhau, 0 nếu không.", "id": "Tulis sebuah fungsi JavaScript `function f_11(a, b, c, d)` untuk menyelesaikan masalah berikut:\nMenentukan apakah dua interval tertutup saling berpotongan.\n\n@param {number} a - Awal dari interval tertutup pertama, harus memenuhi 0 <= a <= b <= 1000.\n@param {number} b - Akhir dari interval tertutup pertama, harus memenuhi 0 <= a <= b <= 1000.\n@param {number} c - Awal dari interval tertutup kedua, harus memenuhi 0 <= c <= d <= 1000.\n@param {number} d - Akhir dari interval tertutup kedua, harus memenuhi 0 <= c <= d <= 1000.\n@returns {number} 1 jika interval berpotongan, 0 sebaliknya.", "ja": "JavaScript関数 `function f_11(a, b, c, d)` を作成して、次の問題を解決してください:\n2つの閉区間が交差しているかどうかを判定します。\n\n@param {number} a - 最初の閉区間の開始、0 <= a <= b <= 1000を満たす必要があります。\n@param {number} b - 最初の閉区間の終了、0 <= a <= b <= 1000を満たす必要があります。\n@param {number} c - 2番目の閉区間の開始、0 <= c <= d <= 1000を満たす必要があります。\n@param {number} d - 2番目の閉区間の終了、0 <= c <= d <= 1000を満たす必要があります。\n@returns {number} 区間が交差している場合は1、そうでない場合は0を返します。", "ko": "JavaScript 함수를 작성하세요 `function f_11(a, b, c, d)` 다음 문제를 해결하기 위해:\n두 닫힌 구간이 교차하는지 여부를 결정합니다.\n\n@param {number} a - 첫 번째 닫힌 구간의 시작, 0 <= a <= b <= 1000을 만족해야 합니다.\n@param {number} b - 첫 번째 닫힌 구간의 끝, 0 <= a <= b <= 1000을 만족해야 합니다.\n@param {number} c - 두 번째 닫힌 구간의 시작, 0 <= c <= d <= 1000을 만족해야 합니다.\n@param {number} d - 두 번째 닫힌 구간의 끝, 0 <= c <= d <= 1000을 만족해야 합니다.\n@returns {number} 구간이 교차하면 1, 그렇지 않으면 0을 반환합니다.", "ml": "`function f_11(a, b, c, d)` എന്ന ജാവാസ്ക്രിപ്റ്റ് ഫങ്ഷൻ എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nരണ്ട് അടഞ്ഞ ഇടവേളകൾ തമ്മിൽ മുട്ടുന്നുണ്ടോ എന്ന് നിർണ്ണയിക്കുക.\n\n@param {number} a - ആദ്യത്തെ അടഞ്ഞ ഇടവേളയുടെ ആരംഭം, 0 <= a <= b <= 1000 എന്ന വ്യവസ്ഥ പാലിക്കണം.\n@param {number} b - ആദ്യത്തെ അടഞ്ഞ ഇടവേളയുടെ അവസാനം, 0 <= a <= b <= 1000 എന്ന വ്യവസ്ഥ പാലിക്കണം.\n@param {number} c - രണ്ടാം അടഞ്ഞ ഇടവേളയുടെ ആരംഭം, 0 <= c <= d <= 1000 എന്ന വ്യവസ്ഥ പാലിക്കണം.\n@param {number} d - രണ്ടാം അടഞ്ഞ ഇടവേളയുടെ അവസാനം, 0 <= c <= d <= 1000 എന്ന വ്യവസ്ഥ പാലിക്കണം.\n@returns {number} ഇടവേളകൾ മുട്ടുന്നുണ്ടെങ്കിൽ 1, അല്ലെങ്കിൽ 0.", "fa": "یک تابع جاوااسکریپت `function f_11(a, b, c, d)` بنویسید تا مسئله زیر را حل کند:\nتعیین کنید که آیا دو بازه بسته با هم تلاقی دارند یا خیر.\n\n@param {number} a - شروع اولین بازه بسته، باید شرط 0 <= a <= b <= 1000 را برآورده کند.\n@param {number} b - پایان اولین بازه بسته، باید شرط 0 <= a <= b <= 1000 را برآورده کند.\n@param {number} c - شروع دومین بازه بسته، باید شرط 0 <= c <= d <= 1000 را برآورده کند.\n@param {number} d - پایان دومین بازه بسته، باید شرط 0 <= c <= d <= 1000 را برآورده کند.\n@returns {number} 1 اگر بازه‌ها تلاقی دارند، در غیر این صورت 0."}, "level": "easy", "test": "const testf_11 = () => {\n    console.assert(f_11(1, 1, 1, 2) === 1);\n    console.assert(f_11(3, 5, 2, 6) === 1);\n    console.assert(f_11(3, 5, 4, 7) === 1);\n    console.assert(f_11(3, 5, 6, 7) === 0);\n    // Additional test cases\n    console.assert(f_11(0, 0, 0, 0) === 1);\n    console.assert(f_11(1, 3, 2, 4) === 1);\n    console.assert(f_11(1, 3, 4, 6) === 0);\n    console.assert(f_11(10, 20, 20, 30) === 1);\n    console.assert(f_11(10, 20, 21, 30) === 0);\n\n    // console.log(\"All tests passed.\");\n}\n\ntestf_11();", "entry_point": "f_11", "signature": "function f_11(a, b, c, d)", "docstring": {"en": "Determine if two closed intervals intersect.\n\n@param {number} a - Start of the first closed interval, must satisfy 0 <= a <= b <= 1000.\n@param {number} b - End of the first closed interval, must satisfy 0 <= a <= b <= 1000.\n@param {number} c - Start of the second closed interval, must satisfy 0 <= c <= d <= 1000.\n@param {number} d - End of the second closed interval, must satisfy 0 <= c <= d <= 1000.\n@returns {number} 1 if the intervals intersect, 0 otherwise.\n", "sq": "Përcaktoni nëse dy intervale të mbyllura ndërpriten.\n\n@param {number} a - Fillimi i intervalit të parë të mbyllur, duhet të plotësojë 0 <= a <= b <= 1000.\n@param {number} b - Fundi i intervalit të parë të mbyllur, duhet të plotësojë 0 <= a <= b <= 1000.\n@param {number} c - Fillimi i intervalit të dytë të mbyllur, duhet të plotësojë 0 <= c <= d <= 1000.\n@param {number} d - Fundi i intervalit të dytë të mbyllur, duhet të plotësojë 0 <= c <= d <= 1000.\n@returns {number} 1 nëse intervalet ndërpriten, 0 përndryshe.", "hy": "Որոշեք, արդյոք երկու փակ միջակայքերը հատվում են:\n\n@param {number} a - Առաջին փակ միջակայքի սկիզբը, պետք է բավարարի 0 <= a <= b <= 1000։\n@param {number} b - Առաջին փակ միջակայքի վերջը, պետք է բավարարի 0 <= a <= b <= 1000։\n@param {number} c - Երկրորդ փակ միջակայքի սկիզբը, պետք է բավարարի 0 <= c <= d <= 1000։\n@param {number} d - Երկրորդ փակ միջակայքի վերջը, պետք է բավարարի 0 <= c <= d <= 1000։\n@returns {number} 1, եթե միջակայքերը հատվում են, 0՝ հակառակ դեպքում։", "bn": "দুইটি বন্ধ ইন্টারভাল পরস্পরকে অতিক্রম করে কিনা তা নির্ধারণ করুন।\n\n@param {number} a - প্রথম বন্ধ ইন্টারভালের শুরু, অবশ্যই 0 <= a <= b <= 1000 শর্ত পূরণ করতে হবে।\n@param {number} b - প্রথম বন্ধ ইন্টারভালের শেষ, অবশ্যই 0 <= a <= b <= 1000 শর্ত পূরণ করতে হবে।\n@param {number} c - দ্বিতীয় বন্ধ ইন্টারভালের শুরু, অবশ্যই 0 <= c <= d <= 1000 শর্ত পূরণ করতে হবে।\n@param {number} d - দ্বিতীয় বন্ধ ইন্টারভালের শেষ, অবশ্যই 0 <= c <= d <= 1000 শর্ত পূরণ করতে হবে।\n@returns {number} 1 যদি ইন্টারভালগুলি ছেদ করে, অন্যথায় 0।", "bg": "Определете дали два затворени интервала се пресичат.\n\n@param {number} a - Начало на първия затворен интервал, трябва да удовлетворява 0 <= a <= b <= 1000.\n@param {number} b - Край на първия затворен интервал, трябва да удовлетворява 0 <= a <= b <= 1000.\n@param {number} c - Начало на втория затворен интервал, трябва да удовлетворява 0 <= c <= d <= 1000.\n@param {number} d - Край на втория затворен интервал, трябва да удовлетворява 0 <= c <= d <= 1000.\n@returns {number} 1 ако интервалите се пресичат, 0 в противен случай.", "zh": "确定两个闭区间是否相交。\n\n@param {number} a - 第一个闭区间的起始，必须满足 0 <= a <= b <= 1000。\n@param {number} b - 第一个闭区间的结束，必须满足 0 <= a <= b <= 1000。\n@param {number} c - 第二个闭区间的起始，必须满足 0 <= c <= d <= 1000。\n@param {number} d - 第二个闭区间的结束，必须满足 0 <= c <= d <= 1000。\n@returns {number} 如果区间相交返回 1，否则返回 0。", "fr": "Déterminer si deux intervalles fermés s'intersectent.\n\n@param {number} a - Début du premier intervalle fermé, doit satisfaire 0 <= a <= b <= 1000.\n@param {number} b - Fin du premier intervalle fermé, doit satisfaire 0 <= a <= b <= 1000.\n@param {number} c - Début du second intervalle fermé, doit satisfaire 0 <= c <= d <= 1000.\n@param {number} d - Fin du second intervalle fermé, doit satisfaire 0 <= c <= d <= 1000.\n@returns {number} 1 si les intervalles s'intersectent, 0 sinon.", "de": "Bestimmen, ob zwei geschlossene Intervalle sich überschneiden.\n\n@param {number} a - Anfang des ersten geschlossenen Intervalls, muss 0 <= a <= b <= 1000 erfüllen.\n@param {number} b - Ende des ersten geschlossenen Intervalls, muss 0 <= a <= b <= 1000 erfüllen.\n@param {number} c - Anfang des zweiten geschlossenen Intervalls, muss 0 <= c <= d <= 1000 erfüllen.\n@param {number} d - Ende des zweiten geschlossenen Intervalls, muss 0 <= c <= d <= 1000 erfüllen.\n@returns {number} 1, wenn die Intervalle sich überschneiden, 0 andernfalls.", "ha": "Gano idan tsaka-tsakin rufe guda biyu suna haɗuwa.\n\n@param {number} a - Farko na farkon rufe tazara, dole ne ya cika 0 <= a <= b <= 1000.\n@param {number} b - Ƙarshe na farkon rufe tazara, dole ne ya cika 0 <= a <= b <= 1000.\n@param {number} c - Farko na na biyu rufe tazara, dole ne ya cika 0 <= c <= d <= 1000.\n@param {number} d - Ƙarshe na na biyu rufe tazara, dole ne ya cika 0 <= c <= d <= 1000.\n@returns {number} 1 idan tazarar suna haɗuwa, 0 in ba haka ba.", "hi": "निर्धारित करें कि दो बंद अंतराल एक-दूसरे को काटते हैं या नहीं।\n\n@param {number} a - पहले बंद अंतराल की शुरुआत, 0 <= a <= b <= 1000 को संतुष्ट करना चाहिए।\n@param {number} b - पहले बंद अंतराल का अंत, 0 <= a <= b <= 1000 को संतुष्ट करना चाहिए।\n@param {number} c - दूसरे बंद अंतराल की शुरुआत, 0 <= c <= d <= 1000 को संतुष्ट करना चाहिए।\n@param {number} d - दूसरे बंद अंतराल का अंत, 0 <= c <= d <= 1000 को संतुष्ट करना चाहिए।\n@returns {number} 1 अगर अंतराल एक-दूसरे को काटते हैं, अन्यथा 0।", "hu": "Határozd meg, hogy két zárt intervallum metszi-e egymást.\n\n@param {number} a - Az első zárt intervallum kezdete, teljesítenie kell a 0 <= a <= b <= 1000 feltételt.\n@param {number} b - Az első zárt intervallum vége, teljesítenie kell a 0 <= a <= b <= 1000 feltételt.\n@param {number} c - A második zárt intervallum kezdete, teljesítenie kell a 0 <= c <= d <= 1000 feltételt.\n@param {number} d - A második zárt intervallum vége, teljesítenie kell a 0 <= c <= d <= 1000 feltételt.\n@returns {number} 1, ha az intervallumok metszik egymást, különben 0.", "es": "Determinar si dos intervalos cerrados se intersectan.\n\n@param {number} a - Inicio del primer intervalo cerrado, debe satisfacer 0 <= a <= b <= 1000.\n@param {number} b - Fin del primer intervalo cerrado, debe satisfacer 0 <= a <= b <= 1000.\n@param {number} c - Inicio del segundo intervalo cerrado, debe satisfacer 0 <= c <= d <= 1000.\n@param {number} d - Fin del segundo intervalo cerrado, debe satisfacer 0 <= c <= d <= 1000.\n@returns {number} 1 si los intervalos se intersectan, 0 en caso contrario.", "arb": "تحديد ما إذا كانت فترتان مغلقتان تتقاطعان.\n\n@param {number} a - بداية الفترة المغلقة الأولى، يجب أن تحقق 0 <= a <= b <= 1000.\n@param {number} b - نهاية الفترة المغلقة الأولى، يجب أن تحقق 0 <= a <= b <= 1000.\n@param {number} c - بداية الفترة المغلقة الثانية، يجب أن تحقق 0 <= c <= d <= 1000.\n@param {number} d - نهاية الفترة المغلقة الثانية، يجب أن تحقق 0 <= c <= d <= 1000.\n@returns {number} 1 إذا كانت الفترات تتقاطع، 0 خلاف ذلك.", "sw": "Tambua kama vipindi viwili vilivyofungwa vinakatana.\n\n@param {number} a - Mwanzo wa kipengele cha kwanza kilichofungwa, lazima itimize 0 <= a <= b <= 1000.\n@param {number} b - Mwisho wa kipengele cha kwanza kilichofungwa, lazima itimize 0 <= a <= b <= 1000.\n@param {number} c - Mwanzo wa kipengele cha pili kilichofungwa, lazima itimize 0 <= c <= d <= 1000.\n@param {number} d - Mwisho wa kipengele cha pili kilichofungwa, lazima itimize 0 <= c <= d <= 1000.\n@returns {number} 1 ikiwa vipengele vinaingiliana, 0 vinginevyo.", "tr": "İki kapalı aralığın kesişip kesişmediğini belirleyin.\n\n@param {number} a - İlk kapalı aralığın başlangıcı, 0 <= a <= b <= 1000 koşulunu sağlamalıdır.\n@param {number} b - İlk kapalı aralığın sonu, 0 <= a <= b <= 1000 koşulunu sağlamalıdır.\n@param {number} c - İkinci kapalı aralığın başlangıcı, 0 <= c <= d <= 1000 koşulunu sağlamalıdır.\n@param {number} d - İkinci kapalı aralığın sonu, 0 <= c <= d <= 1000 koşulunu sağlamalıdır.\n@returns {number} Aralıklar kesişiyorsa 1, aksi takdirde 0.", "vi": "Xác định xem hai khoảng đóng có giao nhau hay không.\n\n@param {number} a - Điểm bắt đầu của khoảng đóng thứ nhất, phải thỏa mãn 0 <= a <= b <= 1000.\n@param {number} b - Điểm kết thúc của khoảng đóng thứ nhất, phải thỏa mãn 0 <= a <= b <= 1000.\n@param {number} c - Điểm bắt đầu của khoảng đóng thứ hai, phải thỏa mãn 0 <= c <= d <= 1000.\n@param {number} d - Điểm kết thúc của khoảng đóng thứ hai, phải thỏa mãn 0 <= c <= d <= 1000.\n@returns {number} 1 nếu các khoảng giao nhau, 0 nếu không.", "id": "Determine apakah dua interval tertutup berpotongan.\n\n@param {number} a - Awal dari interval tertutup pertama, harus memenuhi 0 <= a <= b <= 1000.\n@param {number} b - Akhir dari interval tertutup pertama, harus memenuhi 0 <= a <= b <= 1000.\n@param {number} c - Awal dari interval tertutup kedua, harus memenuhi 0 <= c <= d <= 1000.\n@param {number} d - Akhir dari interval tertutup kedua, harus memenuhi 0 <= c <= d <= 1000.\n@returns {number} 1 jika interval berpotongan, 0 jika tidak.", "ja": "2つの閉区間が交差するかどうかを判断します。\n\n@param {number} a - 最初の閉区間の開始、0 <= a <= b <= 1000を満たす必要があります。\n@param {number} b - 最初の閉区間の終了、0 <= a <= b <= 1000を満たす必要があります。\n@param {number} c - 2番目の閉区間の開始、0 <= c <= d <= 1000を満たす必要があります。\n@param {number} d - 2番目の閉区間の終了、0 <= c <= d <= 1000を満たす必要があります。\n@returns {number} 区間が交差する場合は1、そうでない場合は0を返します。", "ko": "두 닫힌 구간이 교차하는지 여부를 결정합니다.\n\n@param {number} a - 첫 번째 닫힌 구간의 시작, 0 <= a <= b <= 1000을 만족해야 합니다.\n@param {number} b - 첫 번째 닫힌 구간의 끝, 0 <= a <= b <= 1000을 만족해야 합니다.\n@param {number} c - 두 번째 닫힌 구간의 시작, 0 <= c <= d <= 1000을 만족해야 합니다.\n@param {number} d - 두 번째 닫힌 구간의 끝, 0 <= c <= d <= 1000을 만족해야 합니다.\n@returns {number} 구간이 교차하면 1을 반환하고, 그렇지 않으면 0을 반환합니다.", "ml": "രണ്ട് അടച്ച ഇടവേളകൾ തമ്മിൽ മുറുകിയിട്ടുണ്ടോ എന്ന് നിർണയിക്കുക.\n\n@param {number} a - ആദ്യ അടച്ച ഇടവേളയുടെ ആരംഭം, 0 <= a <= b <= 1000 എന്ന വ്യവസ്ഥ പാലിക്കണം.\n@param {number} b - ആദ്യ അടച്ച ഇടവേളയുടെ അവസാന, 0 <= a <= b <= 1000 എന്ന വ്യവസ്ഥ പാലിക്കണം.\n@param {number} c - രണ്ടാം അടച്ച ഇടവേളയുടെ ആരംഭം, 0 <= c <= d <= 1000 എന്ന വ്യവസ്ഥ പാലിക്കണം.\n@param {number} d - രണ്ടാം അടച്ച ഇടവേളയുടെ അവസാന, 0 <= c <= d <= 1000 എന്ന വ്യവസ്ഥ പാലിക്കണം.\n@returns {number} ഇടവേളകൾ തമ്മിൽ മുട്ടിയാൽ 1, അല്ലെങ്കിൽ 0.", "fa": "تعیین کنید که آیا دو بازه بسته با هم تلاقی دارند یا خیر.\n\n@param {number} a - شروع اولین بازه بسته، باید شرط 0 <= a <= b <= 1000 را برآورده کند.\n@param {number} b - پایان اولین بازه بسته، باید شرط 0 <= a <= b <= 1000 را برآورده کند.\n@param {number} c - شروع دومین بازه بسته، باید شرط 0 <= c <= d <= 1000 را برآورده کند.\n@param {number} d - پایان دومین بازه بسته، باید شرط 0 <= c <= d <= 1000 را برآورده کند.\n@returns {number} 1 اگر بازه‌ها تداخل داشته باشند، در غیر این صورت 0."}}
{"task_id": "JavaScript/12", "prompt": {"en": "/**\n * Given three digits a, b, and c, where two of them are equal and the third is different,\n * this function finds and returns the value that occurs exactly once.\n * Examples:\n * f_12(0, 0, 1) // returns 1\n * f_12(4, 3, 4) // returns 3\n */\nfunction f_12(a, b, c)", "sq": "/**\n * Duke pasur parasysh tre shifra a, b, dhe c, ku dy prej tyre janë të barabartë dhe i treti është i ndryshëm,\n * kjo funksion gjen dhe kthen vlerën që ndodh saktësisht një herë.\n * Shembuj:\n * f_12(0, 0, 1) // kthen 1\n * f_12(4, 3, 4) // kthen 3\n */\nfunction f_12(a, b, c)", "hy": "/**\n * Տրված են երեք թվանշան a, b և c, որտեղ երկուսը հավասար են, իսկ երրորդը՝ տարբեր,\n * այս ֆունկցիան գտնում և վերադարձնում է այն արժեքը, որը հանդիպում է միայն մեկ անգամ։\n * Օրինակներ:\n * f_12(0, 0, 1) // վերադարձնում է 1\n * f_12(4, 3, 4) // վերադարձնում է 3\n */\nfunction f_12(a, b, c)", "bn": "/**\n * প্রদত্ত তিনটি সংখ্যা a, b, এবং c, যেখানে দুটি সংখ্যা সমান এবং তৃতীয়টি ভিন্ন,\n * এই ফাংশনটি সেই মানটি খুঁজে বের করে এবং ফেরত দেয় যা ঠিক একবার ঘটে।\n * উদাহরণ:\n * f_12(0, 0, 1) // 1 ফেরত দেয়\n * f_12(4, 3, 4) // 3 ফেরত দেয়\n */\nfunction f_12(a, b, c)", "bg": "/**\n * Дадени са три цифри a, b и c, където две от тях са равни, а третата е различна,\n * тази функция намира и връща стойността, която се среща точно веднъж.\n * Примери:\n * f_12(0, 0, 1) // връща 1\n * f_12(4, 3, 4) // връща 3\n */\nfunction f_12(a, b, c)", "zh": "/**\n * 给定三个数字 a, b 和 c，其中两个相等，第三个不同，\n * 此函数查找并返回只出现一次的值。\n * 示例:\n * f_12(0, 0, 1) // 返回 1\n * f_12(4, 3, 4) // 返回 3\n */\nfunction f_12(a, b, c)", "fr": "/**\n * Étant donné trois chiffres a, b et c, où deux d'entre eux sont égaux et le troisième est différent,\n * cette fonction trouve et renvoie la valeur qui apparaît exactement une fois.\n * Exemples :\n * f_12(0, 0, 1) // renvoie 1\n * f_12(4, 3, 4) // renvoie 3\n */\nfunction f_12(a, b, c)", "de": "/**\n * Gegeben sind drei Ziffern a, b und c, wobei zwei von ihnen gleich sind und die dritte unterschiedlich ist,\n * diese Funktion findet und gibt den Wert zurück, der genau einmal vorkommt.\n * Beispiele:\n * f_12(0, 0, 1) // gibt 1 zurück\n * f_12(4, 3, 4) // gibt 3 zurück\n */\nfunction f_12(a, b, c)", "ha": "/**\n * An ba lambobi guda uku a, b, da c, inda biyu daga cikinsu suke daidai kuma na uku ya bambanta,\n * wannan aikin yana gano kuma ya dawo da ƙimar da ta faru sau ɗaya kawai.\n * Misalai:\n * f_12(0, 0, 1) // returns 1\n * f_12(4, 3, 4) // returns 3\n */\nfunction f_12(a, b, c)", "hi": "/**\n * दिए गए तीन अंक a, b, और c, जहाँ इनमें से दो समान हैं और तीसरा अलग है,\n * यह फ़ंक्शन उस मान को ढूंढता और लौटाता है जो केवल एक बार होता है।\n * उदाहरण:\n * f_12(0, 0, 1) // 1 लौटाता है\n * f_12(4, 3, 4) // 3 लौटाता है\n */\nfunction f_12(a, b, c)", "hu": "/**\n * Adott három számjegy: a, b és c, ahol kettő közülük egyenlő, és a harmadik eltérő,\n * ez a függvény megkeresi és visszaadja azt az értéket, amely pontosan egyszer fordul elő.\n * Példák:\n * f_12(0, 0, 1) // visszaadja 1\n * f_12(4, 3, 4) // visszaadja 3\n */\nfunction f_12(a, b, c)", "es": "/**\n * Dado tres dígitos a, b y c, donde dos de ellos son iguales y el tercero es diferente,\n * esta función encuentra y devuelve el valor que ocurre exactamente una vez.\n * Ejemplos:\n * f_12(0, 0, 1) // devuelve 1\n * f_12(4, 3, 4) // devuelve 3\n */\nfunction f_12(a, b, c)", "arb": "/**\n * بالنظر إلى ثلاثة أرقام a و b و c، حيث أن اثنين منهما متساويان والثالث مختلف،\n * تقوم هذه الدالة بإيجاد وإرجاع القيمة التي تحدث مرة واحدة فقط.\n * أمثلة:\n * f_12(0, 0, 1) // يعيد 1\n * f_12(4, 3, 4) // يعيد 3\n */\nfunction f_12(a, b, c)", "sw": "/**\n * Kwa kuzingatia tarakimu tatu a, b, na c, ambapo mbili kati ya hizo ni sawa na ya tatu ni tofauti,\n * kazi hii inapata na kurudisha thamani inayotokea mara moja tu.\n * Mifano:\n * f_12(0, 0, 1) // inarudisha 1\n * f_12(4, 3, 4) // inarudisha 3\n */\nfunction f_12(a, b, c)", "tr": "/**\n * Üç basamaklı a, b ve c verildiğinde, bunlardan ikisi eşit ve üçüncüsü farklıdır,\n * bu fonksiyon tam olarak bir kez geçen değeri bulur ve döndürür.\n * Örnekler:\n * f_12(0, 0, 1) // 1 döndürür\n * f_12(4, 3, 4) // 3 döndürür\n */\nfunction f_12(a, b, c)", "vi": "/**\n * Cho ba chữ số a, b và c, trong đó hai số bằng nhau và số thứ ba khác,\n * hàm này tìm và trả về giá trị xuất hiện chính xác một lần.\n * Ví dụ:\n * f_12(0, 0, 1) // trả về 1\n * f_12(4, 3, 4) // trả về 3\n */\nfunction f_12(a, b, c)", "id": "/**\n * Diberikan tiga digit a, b, dan c, di mana dua di antaranya sama dan yang ketiga berbeda,\n * fungsi ini menemukan dan mengembalikan nilai yang muncul tepat sekali.\n * Contoh:\n * f_12(0, 0, 1) // mengembalikan 1\n * f_12(4, 3, 4) // mengembalikan 3\n */\nfunction f_12(a, b, c)", "ja": "/**\n * 3つの数字a、b、cが与えられたとき、そのうち2つは等しく、もう1つは異なります。\n * この関数は、1回だけ出現する値を見つけて返します。\n * 例:\n * f_12(0, 0, 1) // returns 1\n * f_12(4, 3, 4) // returns 3\n */\nfunction f_12(a, b, c)", "ko": "/**\n * 세 자리 숫자 a, b, c가 주어졌을 때, 그 중 두 숫자는 같고 하나는 다릅니다.\n * 이 함수는 정확히 한 번만 나타나는 값을 찾아 반환합니다.\n * 예시:\n * f_12(0, 0, 1) // 1을 반환\n * f_12(4, 3, 4) // 3을 반환\n */\nfunction f_12(a, b, c)", "ml": "/**\n * മൂന്ന് അക്കങ്ങൾ a, b, c നൽകിയിരിക്കുന്നു, ഇവയിൽ രണ്ടെണ്ണം തുല്യമാണ്, മൂന്നാമത്തേത് വ്യത്യസ്തമാണ്,\n * ഈ ഫംഗ്ഷൻ ഒരിക്കൽ മാത്രം സംഭവിക്കുന്ന മൂല്യം കണ്ടെത്തി തിരിച്ചുനൽകുന്നു.\n * ഉദാഹരണങ്ങൾ:\n * f_12(0, 0, 1) // 1 തിരികെ നൽകുന്നു\n * f_12(4, 3, 4) // 3 തിരികെ നൽകുന്നു\n */\nfunction f_12(a, b, c)", "fa": "/**\n * با داشتن سه رقم a، b و c، که دو تای آنها برابر و سومی متفاوت است،\n * این تابع مقداری را که دقیقاً یک بار ظاهر می‌شود پیدا کرده و برمی‌گرداند.\n * مثال‌ها:\n * f_12(0, 0, 1) // مقدار 1 را برمی‌گرداند\n * f_12(4, 3, 4) // مقدار 3 را برمی‌گرداند\n */\nfunction f_12(a, b, c)"}, "canonical_solution": "{\n    if (a === b) {\n        return c;\n    } else if (a === c) {\n        return b;\n    } else {\n        return a;\n    }\n}", "instruction": {"en": "Write a JavaScript function `function f_12(a, b, c)` to solve the following problem:\nGiven three digits a, b, and c, where two of them are equal and the third is different,\nthis function finds and returns the value that occurs exactly once.\nExamples:\nf_12(0, 0, 1) // returns 1\nf_12(4, 3, 4) // returns 3\n", "sq": "Shkruani një funksion JavaScript `function f_12(a, b, c)` për të zgjidhur problemin në vijim:  \nDuke pasur parasysh tre shifra a, b, dhe c, ku dy prej tyre janë të barabarta dhe e treta është e ndryshme,  \nky funksion gjen dhe kthen vlerën që ndodh saktësisht një herë.  \nShembuj:  \nf_12(0, 0, 1) // kthen 1  \nf_12(4, 3, 4) // kthen 3  ", "hy": "Գրեք JavaScript ֆունկցիա `function f_12(a, b, c)`՝ լուծելու հետևյալ խնդիրը: \nԵրեք թվանշանների `a`, `b` և `c` տրված են, որտեղ երկուսը հավասար են, իսկ երրորդը՝ տարբեր, \nայս ֆունկցիան գտնում և վերադարձնում է այն արժեքը, որը հանդիպում է միայն մեկ անգամ: \nՕրինակներ:\nf_12(0, 0, 1) // վերադարձնում է 1\nf_12(4, 3, 4) // վերադարձնում է 3", "bn": "একটি JavaScript ফাংশন `function f_12(a, b, c)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nতিনটি সংখ্যা a, b, এবং c দেওয়া হয়েছে, যেখানে দুটি সংখ্যা সমান এবং তৃতীয়টি ভিন্ন,\nএই ফাংশনটি সেই মানটি খুঁজে বের করে এবং ফেরত দেয় যা ঠিক একবার ঘটে।\nউদাহরণ:\nf_12(0, 0, 1) // returns 1\nf_12(4, 3, 4) // returns 3", "bg": "Напишете JavaScript функция `function f_12(a, b, c)` за решаване на следния проблем:  \nДадени са три цифри a, b и c, където две от тях са равни, а третата е различна,  \nтази функция намира и връща стойността, която се среща точно веднъж.  \nПримери:  \nf_12(0, 0, 1) // връща 1  \nf_12(4, 3, 4) // връща 3  ", "zh": "编写一个 JavaScript 函数 `function f_12(a, b, c)` 来解决以下问题：  \n给定三个数字 a, b 和 c，其中两个是相等的，第三个是不同的，  \n此函数查找并返回只出现一次的值。  \n示例：  \nf_12(0, 0, 1) // returns 1  \nf_12(4, 3, 4) // returns 3  ", "fr": "Écrire une fonction JavaScript `function f_12(a, b, c)` pour résoudre le problème suivant :  \nÉtant donné trois chiffres a, b et c, où deux d'entre eux sont égaux et le troisième est différent,  \ncette fonction trouve et renvoie la valeur qui apparaît exactement une fois.  \nExemples :  \nf_12(0, 0, 1) // renvoie 1  \nf_12(4, 3, 4) // renvoie 3  ", "de": "Schreiben Sie eine JavaScript-Funktion `function f_12(a, b, c)`, um das folgende Problem zu lösen:\nGegeben sind drei Ziffern a, b und c, wobei zwei von ihnen gleich sind und die dritte unterschiedlich ist,\ndiese Funktion findet und gibt den Wert zurück, der genau einmal vorkommt.\nBeispiele:\nf_12(0, 0, 1) // gibt 1 zurück\nf_12(4, 3, 4) // gibt 3 zurück", "ha": "Rubuta aikin JavaScript `function f_12(a, b, c)` don warware matsalar mai zuwa:\nAn ba da lambobi guda uku a, b, da c, inda biyu daga cikinsu suke daidai kuma na uku ya bambanta,\nwannan aikin yana nemo kuma yana dawo da ƙimar da ta bayyana sau ɗaya kawai.\nMisalai:\nf_12(0, 0, 1) // yana dawowa 1\nf_12(4, 3, 4) // yana dawowa 3", "hi": "एक JavaScript फ़ंक्शन `function f_12(a, b, c)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए तीन अंक a, b, और c, जहाँ उनमें से दो समान हैं और तीसरा अलग है,\nयह फ़ंक्शन उस मान को खोजता है और लौटाता है जो केवल एक बार होता है।\nउदाहरण:\nf_12(0, 0, 1) // 1 लौटाता है\nf_12(4, 3, 4) // 3 लौटाता है", "hu": "Írj egy JavaScript függvényt `function f_12(a, b, c)` a következő probléma megoldására:\nAdott három számjegy, a, b és c, ahol kettő közülük egyenlő, és a harmadik különbözik,\nez a függvény megkeresi és visszaadja azt az értéket, amely pontosan egyszer fordul elő.\nPéldák:\nf_12(0, 0, 1) // visszaadja 1\nf_12(4, 3, 4) // visszaadja 3", "es": "Escribe una función de JavaScript `function f_12(a, b, c)` para resolver el siguiente problema:  \nDado tres dígitos a, b y c, donde dos de ellos son iguales y el tercero es diferente,  \nesta función encuentra y devuelve el valor que ocurre exactamente una vez.  \nEjemplos:  \nf_12(0, 0, 1) // devuelve 1  \nf_12(4, 3, 4) // devuelve 3  ", "arb": "اكتب دالة JavaScript `function f_12(a, b, c)` لحل المشكلة التالية:\nمعطى ثلاثة أرقام a، b، و c، حيث أن اثنين منهما متساويان والثالث مختلف،\nتقوم هذه الدالة بإيجاد وإرجاع القيمة التي تظهر مرة واحدة فقط.\nأمثلة:\nf_12(0, 0, 1) // يعيد 1\nf_12(4, 3, 4) // يعيد 3", "sw": "Andika kazi ya JavaScript `function f_12(a, b, c)` kutatua tatizo lifuatalo:  \nUkipewa tarakimu tatu a, b, na c, ambapo mbili kati ya hizo ni sawa na ya tatu ni tofauti,  \nkazi hii inapata na kurudisha thamani inayotokea mara moja tu.  \nMifano:  \nf_12(0, 0, 1) // inarudisha 1  \nf_12(4, 3, 4) // inarudisha 3  ", "tr": "Bir JavaScript fonksiyonu `function f_12(a, b, c)` yazın ve aşağıdaki problemi çözün:\nÜç rakam verildiğinde a, b ve c, bunlardan ikisi eşit ve üçüncüsü farklı olduğunda,\nbu fonksiyon tam olarak bir kez meydana gelen değeri bulur ve döndürür.\nÖrnekler:\nf_12(0, 0, 1) // 1 döndürür\nf_12(4, 3, 4) // 3 döndürür", "vi": "Viết một hàm JavaScript `function f_12(a, b, c)` để giải quyết vấn đề sau:  \nCho ba chữ số a, b và c, trong đó hai số bằng nhau và số thứ ba khác biệt,  \nhàm này tìm và trả về giá trị xuất hiện đúng một lần.  \nVí dụ:  \nf_12(0, 0, 1) // trả về 1  \nf_12(4, 3, 4) // trả về 3  ", "id": "Tulis sebuah fungsi JavaScript `function f_12(a, b, c)` untuk menyelesaikan masalah berikut:\nDiberikan tiga digit a, b, dan c, di mana dua di antaranya sama dan yang ketiga berbeda,\nfungsi ini menemukan dan mengembalikan nilai yang muncul tepat sekali.\nContoh:\nf_12(0, 0, 1) // mengembalikan 1\nf_12(4, 3, 4) // mengembalikan 3", "ja": "以下の問題を解くためのJavaScript関数 `function f_12(a, b, c)` を作成してください:\n3つの数字 a, b, c が与えられたとき、そのうち2つは等しく、1つだけ異なります。\nこの関数は、1回だけ現れる値を見つけて返します。\n例:\nf_12(0, 0, 1) // returns 1\nf_12(4, 3, 4) // returns 3", "ko": "JavaScript 함수를 작성하세요 `function f_12(a, b, c)` 다음 문제를 해결하기 위해:\n세 개의 숫자 a, b, c가 주어졌을 때, 그 중 두 개는 같고 하나는 다릅니다. \n이 함수는 정확히 한 번만 나타나는 값을 찾아서 반환합니다.\n예시:\nf_12(0, 0, 1) // returns 1\nf_12(4, 3, 4) // returns 3", "ml": "ഒരു ജാവാസ്ക്രിപ്റ്റ് ഫംഗ്ഷൻ `function f_12(a, b, c)` എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nമൂന്ന് അക്കങ്ങൾ a, b, c നൽകിയിരിക്കുന്നു, ഇവയിൽ രണ്ടെണ്ണം തുല്യമാണ്, മൂന്നാമത്തേത് വ്യത്യസ്തമാണ്,\nഈ ഫംഗ്ഷൻ ഒരിക്കൽ മാത്രം സംഭവിക്കുന്ന മൂല്യം കണ്ടെത്തി മടക്കിവരുത്തുന്നു.\nഉദാഹരണങ്ങൾ:\nf_12(0, 0, 1) // 1 മടക്കിവരുത്തുന്നു\nf_12(4, 3, 4) // 3 മടക്കിവരുത്തുന്നു", "fa": "یک تابع جاوااسکریپت `function f_12(a, b, c)` بنویسید تا مسئله زیر را حل کند:\nبا توجه به سه رقم a، b و c، که دو تای آنها برابر و سومی متفاوت است،\nاین تابع مقداری را که دقیقا یک بار اتفاق می‌افتد پیدا کرده و برمی‌گرداند.\nمثال‌ها:\nf_12(0, 0, 1) // مقدار 1 را برمی‌گرداند\nf_12(4, 3, 4) // مقدار 3 را برمی‌گرداند"}, "level": "easy", "test": "const testf_12 = () => {\n    console.assert(f_12(2, 7, 2) === 7, 'Test with 2, 7, 2 failed');\n    console.assert(f_12(3, 2, 2) === 3, 'Test with 3, 2, 2 failed');\n    console.assert(f_12(5, 5, 1) === 1, 'Test with 5, 5, 1 failed');\n    console.assert(f_12(500000000, 3, 500000000) === 3, 'Test with 500000000, 3, 500000000 failed');\n    console.assert(f_12(500000000, 500000000, 3) === 3, 'Test with 500000000, 500000000, 3 failed');\n};\n\ntestf_12();", "entry_point": "f_12", "signature": "function f_12(a, b, c)", "docstring": {"en": "Given three digits a, b, and c, where two of them are equal and the third is different,\nthis function finds and returns the value that occurs exactly once.\nExamples:\nf_12(0, 0, 1) // returns 1\nf_12(4, 3, 4) // returns 3\n", "sq": "Duke pasur tre shifra a, b, dhe c, ku dy prej tyre janë të barabartë dhe i treti është i ndryshëm, kjo funksion gjen dhe kthen vlerën që ndodh saktësisht një herë.\nShembuj:\nf_12(0, 0, 1) // kthen 1\nf_12(4, 3, 4) // kthen 3", "hy": "Երեք թվանշանների `a`, `b` և `c` դեպքում, որտեղ երկուսը հավասար են, իսկ երրորդը՝ տարբեր,  \nայս ֆունկցիան գտնում և վերադարձնում է այն արժեքը, որը հանդիպում է միայն մեկ անգամ։  \nՕրինակներ:  \nf_12(0, 0, 1) // վերադարձնում է 1  \nf_12(4, 3, 4) // վերադարձնում է 3  ", "bn": "তিনটি সংখ্যা a, b, এবং c দেওয়া আছে, যেখানে এদের মধ্যে দুটি সমান এবং তৃতীয়টি ভিন্ন,\nএই ফাংশনটি সেই মানটি খুঁজে বের করে এবং ফেরত দেয় যা ঠিক একবার ঘটে।\nউদাহরণ:\nf_12(0, 0, 1) // 1 ফেরত দেয়\nf_12(4, 3, 4) // 3 ফেরত দেয়", "bg": "Дадени са три цифри a, b и c, където две от тях са равни, а третата е различна, тази функция намира и връща стойността, която се среща точно веднъж.\nПримери:\nf_12(0, 0, 1) // връща 1\nf_12(4, 3, 4) // връща 3", "zh": "给定三个数字 a、b 和 c，其中两个相等，第三个不同，  \n此函数查找并返回仅出现一次的值。  \n示例：  \nf_12(0, 0, 1) // 返回 1  \nf_12(4, 3, 4) // 返回 3  ", "fr": "Étant donné trois chiffres a, b et c, où deux d'entre eux sont égaux et le troisième est différent, cette fonction trouve et renvoie la valeur qui apparaît exactement une fois.\nExemples :\nf_12(0, 0, 1) // renvoie 1\nf_12(4, 3, 4) // renvoie 3", "de": "Gegeben drei Ziffern a, b und c, von denen zwei gleich sind und die dritte unterschiedlich ist, \nfindet und gibt diese Funktion den Wert zurück, der genau einmal vorkommt.\nBeispiele:\nf_12(0, 0, 1) // gibt 1 zurück\nf_12(4, 3, 4) // gibt 3 zurück", "ha": "An ba da lambobi uku a, b, da c, inda biyu daga cikinsu suke daidai kuma na uku ya bambanta,\nwannan aikin yana gano kuma yana dawowa da ƙimar da ta bayyana sau ɗaya kawai.\nMisalai:\nf_12(0, 0, 1) // yana dawowa 1\nf_12(4, 3, 4) // yana dawowa 3", "hi": "तीन अंक a, b, और c दिए गए हैं, जहाँ इनमें से दो समान हैं और तीसरा भिन्न है, \nयह फ़ंक्शन उस मान को खोजता और लौटाता है जो केवल एक बार आता है।\nउदाहरण:\nf_12(0, 0, 1) // 1 लौटाता है\nf_12(4, 3, 4) // 3 लौटाता है", "hu": "Három számjegy, a, b és c esetén, ahol kettő közülük egyenlő és a harmadik eltérő, ez a függvény megkeresi és visszaadja azt az értéket, amely pontosan egyszer fordul elő.\nPéldák:\nf_12(0, 0, 1) // visszaadja: 1\nf_12(4, 3, 4) // visszaadja: 3", "es": "Dado tres dígitos a, b y c, donde dos de ellos son iguales y el tercero es diferente, esta función encuentra y devuelve el valor que ocurre exactamente una vez.\nEjemplos:\nf_12(0, 0, 1) // devuelve 1\nf_12(4, 3, 4) // devuelve 3", "arb": "بالنظر إلى ثلاثة أرقام a و b و c، حيث أن اثنين منهما متساويان والثالث مختلف، تقوم هذه الدالة بالعثور على القيمة التي تظهر مرة واحدة فقط وإعادتها.\nأمثلة:\nf_12(0, 0, 1) // يعيد 1\nf_12(4, 3, 4) // يعيد 3", "sw": "Kwa kupewa tarakimu tatu a, b, na c, ambapo mbili kati ya hizo ni sawa na ya tatu ni tofauti, \nkazi hii inatafuta na kurudisha thamani inayotokea mara moja tu.\nMifano:\nf_12(0, 0, 1) // inarudisha 1\nf_12(4, 3, 4) // inarudisha 3", "tr": "Üç basamaklı a, b ve c verildiğinde, bunlardan ikisi eşit ve üçüncüsü farklıdır, bu fonksiyon tam olarak bir kez ortaya çıkan değeri bulur ve döndürür.\nÖrnekler:\nf_12(0, 0, 1) // 1 döndürür\nf_12(4, 3, 4) // 3 döndürür", "vi": "Được cho ba chữ số a, b và c, trong đó hai số bằng nhau và số thứ ba khác biệt, hàm này tìm và trả về giá trị xuất hiện chính xác một lần.\n\nVí dụ:\nf_12(0, 0, 1) // trả về 1\nf_12(4, 3, 4) // trả về 3", "id": "Diberikan tiga digit a, b, dan c, di mana dua di antaranya sama dan yang ketiga berbeda, fungsi ini menemukan dan mengembalikan nilai yang muncul tepat sekali.\nContoh:\nf_12(0, 0, 1) // mengembalikan 1\nf_12(4, 3, 4) // mengembalikan 3", "ja": "3つの数字a、b、cが与えられたとき、2つは等しく、1つは異なる。この関数は、ちょうど1回だけ出現する値を見つけて返します。\n\n例:\nf_12(0, 0, 1) // 1を返します\nf_12(4, 3, 4) // 3を返します", "ko": "세 개의 숫자 a, b, c가 주어졌을 때, 그 중 두 개는 같고 나머지 하나는 다릅니다.  \n이 함수는 정확히 한 번만 나타나는 값을 찾아서 반환합니다.  \n예제:  \nf_12(0, 0, 1) // 1을 반환  \nf_12(4, 3, 4) // 3을 반환  ", "ml": "മൂന്ന് അക്കങ്ങൾ a, b, c എന്നിവ നൽകിയിരിക്കുന്നു, ഇവയിൽ രണ്ടെണ്ണം തുല്യമാണ്, മൂന്നാമത്തേത് വ്യത്യസ്തമാണ്, \nഈ ഫംഗ്ഷൻ ഒരിക്കൽ മാത്രമേ സംഭവിക്കുന്ന മൂല്യം കണ്ടെത്തി മടക്കിവരുത്തും.\nഉദാഹരണങ്ങൾ:\nf_12(0, 0, 1) // 1 മടക്കിവരുത്തും\nf_12(4, 3, 4) // 3 മടക്കിവരുത്തും", "fa": "با توجه به سه رقم a، b و c، که دو تای آن‌ها برابر و سومی متفاوت است،  \nاین تابع مقداری را که دقیقاً یک بار رخ می‌دهد پیدا کرده و برمی‌گرداند.  \nمثال‌ها:  \nf_12(0, 0, 1) // مقدار 1 را برمی‌گرداند  \nf_12(4, 3, 4) // مقدار 3 را برمی‌گرداند  "}}
{"task_id": "JavaScript/13", "prompt": {"en": "/**\n * Calculate the total score for a student based on the scores in different subjects.\n * @param {number} score1 - The score in the first subject.\n * @param {number} score2 - The score in the second subject.\n * @param {number} score3 - The score in the third subject.\n * @param {number} score4 - The score in the fourth subject.\n * @param {number} score5 - The score in the fifth subject.\n * @returns {number} The total score obtained by summing up the scores in all subjects.\n * @example\n * f_13(100, 100, 100, 100, 100); // returns 500\n */\nfunction f_13(score1, score2, score3, score4, score5)", "sq": "/**\n * Llogarit totalin e pikëve për një student bazuar në pikët në lëndë të ndryshme.\n * @param {number} score1 - Pikët në lëndën e parë.\n * @param {number} score2 - Pikët në lëndën e dytë.\n * @param {number} score3 - Pikët në lëndën e tretë.\n * @param {number} score4 - Pikët në lëndën e katërt.\n * @param {number} score5 - Pikët në lëndën e pestë.\n * @returns {number} Totali i pikëve të marra duke mbledhur pikët në të gjitha lëndët.\n * @example\n * f_13(100, 100, 100, 100, 100); // returns 500\n */\nfunction f_13(score1, score2, score3, score4, score5)", "hy": "/**\n * Հաշվել ուսանողի ընդհանուր միավորը տարբեր առարկաներում ստացված միավորների հիման վրա։\n * @param {number} score1 - Առաջին առարկայի միավորը։\n * @param {number} score2 - Երկրորդ առարկայի միավորը։\n * @param {number} score3 - Երրորդ առարկայի միավորը։\n * @param {number} score4 - Չորրորդ առարկայի միավորը։\n * @param {number} score5 - Հինգերորդ առարկայի միավորը։\n * @returns {number} Ընդհանուր միավորը, որը ստացվում է բոլոր առարկաների միավորների գումարումով։\n * @example\n * f_13(100, 100, 100, 100, 100); // returns 500\n */\nfunction f_13(score1, score2, score3, score4, score5)", "bn": "/**\n * বিভিন্ন বিষয়ে প্রাপ্ত নম্বরের ভিত্তিতে একজন শিক্ষার্থীর মোট স্কোর গণনা করুন।\n * @param {number} score1 - প্রথম বিষয়ের নম্বর।\n * @param {number} score2 - দ্বিতীয় বিষয়ের নম্বর।\n * @param {number} score3 - তৃতীয় বিষয়ের নম্বর।\n * @param {number} score4 - চতুর্থ বিষয়ের নম্বর।\n * @param {number} score5 - পঞ্চম বিষয়ের নম্বর।\n * @returns {number} সব বিষয়ের নম্বর যোগ করে প্রাপ্ত মোট স্কোর।\n * @example\n * f_13(100, 100, 100, 100, 100); // returns 500\n */\nfunction f_13(score1, score2, score3, score4, score5)", "bg": "/**\n * Изчислява общия резултат за студент въз основа на резултатите в различни предмети.\n * @param {number} score1 - Резултатът в първия предмет.\n * @param {number} score2 - Резултатът във втория предмет.\n * @param {number} score3 - Резултатът в третия предмет.\n * @param {number} score4 - Резултатът в четвъртия предмет.\n * @param {number} score5 - Резултатът в петия предмет.\n * @returns {number} Общият резултат, получен чрез събиране на резултатите във всички предмети.\n * @example\n * f_13(100, 100, 100, 100, 100); // returns 500\n */\nfunction f_13(score1, score2, score3, score4, score5)", "zh": "/**\n * 计算学生在不同科目中的总分。\n * @param {number} score1 - 第一科目的分数。\n * @param {number} score2 - 第二科目的分数。\n * @param {number} score3 - 第三科目的分数。\n * @param {number} score4 - 第四科目的分数。\n * @param {number} score5 - 第五科目的分数。\n * @returns {number} 通过将所有科目的分数相加获得的总分。\n * @example\n * f_13(100, 100, 100, 100, 100); // returns 500\n */\nfunction f_13(score1, score2, score3, score4, score5)", "fr": "/**\n * Calculer le score total pour un étudiant basé sur les scores dans différentes matières.\n * @param {number} score1 - Le score dans la première matière.\n * @param {number} score2 - Le score dans la deuxième matière.\n * @param {number} score3 - Le score dans la troisième matière.\n * @param {number} score4 - Le score dans la quatrième matière.\n * @param {number} score5 - Le score dans la cinquième matière.\n * @returns {number} Le score total obtenu en additionnant les scores dans toutes les matières.\n * @example\n * f_13(100, 100, 100, 100, 100); // returns 500\n */\nfunction f_13(score1, score2, score3, score4, score5)", "de": "/**\n * Berechne die Gesamtpunktzahl für einen Schüler basierend auf den Punkten in verschiedenen Fächern.\n * @param {number} score1 - Die Punktzahl im ersten Fach.\n * @param {number} score2 - Die Punktzahl im zweiten Fach.\n * @param {number} score3 - Die Punktzahl im dritten Fach.\n * @param {number} score4 - Die Punktzahl im vierten Fach.\n * @param {number} score5 - Die Punktzahl im fünften Fach.\n * @returns {number} Die Gesamtpunktzahl, die durch das Addieren der Punkte in allen Fächern erzielt wird.\n * @example\n * f_13(100, 100, 100, 100, 100); // returns 500\n */\nfunction f_13(score1, score2, score3, score4, score5)", "ha": "/**\n * Lissafa jimillar maki ga ɗalibi bisa ga maki a fannoni daban-daban.\n * @param {number} score1 - Maki a fanni na farko.\n * @param {number} score2 - Maki a fanni na biyu.\n * @param {number} score3 - Maki a fanni na uku.\n * @param {number} score4 - Maki a fanni na huɗu.\n * @param {number} score5 - Maki a fanni na biyar.\n * @returns {number} Jimillar maki da aka samu ta hanyar tara maki a dukkan fannoni.\n * @example\n * f_13(100, 100, 100, 100, 100); // returns 500\n */\nfunction f_13(score1, score2, score3, score4, score5)", "hi": "/**\n * विभिन्न विषयों में अंकों के आधार पर एक छात्र के लिए कुल अंक की गणना करें।\n * @param {number} score1 - पहले विषय में अंक।\n * @param {number} score2 - दूसरे विषय में अंक।\n * @param {number} score3 - तीसरे विषय में अंक।\n * @param {number} score4 - चौथे विषय में अंक।\n * @param {number} score5 - पांचवें विषय में अंक।\n * @returns {number} सभी विषयों में अंकों को जोड़कर प्राप्त कुल अंक।\n * @example\n * f_13(100, 100, 100, 100, 100); // returns 500\n */\nfunction f_13(score1, score2, score3, score4, score5)", "hu": "/**\n * Számítsa ki a diák összpontszámát a különböző tantárgyakban elért pontszámok alapján.\n * @param {number} score1 - Az első tantárgy pontszáma.\n * @param {number} score2 - A második tantárgy pontszáma.\n * @param {number} score3 - A harmadik tantárgy pontszáma.\n * @param {number} score4 - A negyedik tantárgy pontszáma.\n * @param {number} score5 - Az ötödik tantárgy pontszáma.\n * @returns {number} Az összpontszám, amelyet az összes tantárgy pontszámának összeadásával kapunk.\n * @example\n * f_13(100, 100, 100, 100, 100); // returns 500\n */\nfunction f_13(score1, score2, score3, score4, score5)", "es": "/**\n * Calcular la puntuación total para un estudiante basado en las puntuaciones en diferentes materias.\n * @param {number} score1 - La puntuación en la primera materia.\n * @param {number} score2 - La puntuación en la segunda materia.\n * @param {number} score3 - La puntuación en la tercera materia.\n * @param {number} score4 - La puntuación en la cuarta materia.\n * @param {number} score5 - La puntuación en la quinta materia.\n * @returns {number} La puntuación total obtenida sumando las puntuaciones en todas las materias.\n * @example\n * f_13(100, 100, 100, 100, 100); // devuelve 500\n */\nfunction f_13(score1, score2, score3, score4, score5)", "arb": "/**\n * حساب المجموع الكلي للدرجات لطالب بناءً على الدرجات في مواد مختلفة.\n * @param {number} score1 - الدرجة في المادة الأولى.\n * @param {number} score2 - الدرجة في المادة الثانية.\n * @param {number} score3 - الدرجة في المادة الثالثة.\n * @param {number} score4 - الدرجة في المادة الرابعة.\n * @param {number} score5 - الدرجة في المادة الخامسة.\n * @returns {number} المجموع الكلي للدرجات المحصل عليه بجمع الدرجات في جميع المواد.\n * @example\n * f_13(100, 100, 100, 100, 100); // يعيد 500\n */\nfunction f_13(score1, score2, score3, score4, score5)", "sw": "/**\n * Hesabu jumla ya alama kwa mwanafunzi kulingana na alama katika masomo tofauti.\n * @param {number} score1 - Alama katika somo la kwanza.\n * @param {number} score2 - Alama katika somo la pili.\n * @param {number} score3 - Alama katika somo la tatu.\n * @param {number} score4 - Alama katika somo la nne.\n * @param {number} score5 - Alama katika somo la tano.\n * @returns {number} Jumla ya alama iliyopatikana kwa kujumlisha alama katika masomo yote.\n * @example\n * f_13(100, 100, 100, 100, 100); // inarejesha 500\n */\nfunction f_13(score1, score2, score3, score4, score5)", "tr": "/**\n * Farklı derslerdeki puanlara dayalı olarak bir öğrencinin toplam puanını hesaplayın.\n * @param {number} score1 - İlk dersteki puan.\n * @param {number} score2 - İkinci dersteki puan.\n * @param {number} score3 - Üçüncü dersteki puan.\n * @param {number} score4 - Dördüncü dersteki puan.\n * @param {number} score5 - Beşinci dersteki puan.\n * @returns {number} Tüm derslerdeki puanların toplanmasıyla elde edilen toplam puan.\n * @example\n * f_13(100, 100, 100, 100, 100); // 500 döndürür\n */\nfunction f_13(score1, score2, score3, score4, score5)", "vi": "/**\n * Tính tổng điểm cho một học sinh dựa trên điểm số trong các môn học khác nhau.\n * @param {number} score1 - Điểm số trong môn học thứ nhất.\n * @param {number} score2 - Điểm số trong môn học thứ hai.\n * @param {number} score3 - Điểm số trong môn học thứ ba.\n * @param {number} score4 - Điểm số trong môn học thứ tư.\n * @param {number} score5 - Điểm số trong môn học thứ năm.\n * @returns {number} Tổng điểm đạt được bằng cách cộng các điểm số trong tất cả các môn học.\n * @example\n * f_13(100, 100, 100, 100, 100); // trả về 500\n */\nfunction f_13(score1, score2, score3, score4, score5)", "id": "/**\n * Hitung total skor untuk seorang siswa berdasarkan skor dalam berbagai mata pelajaran.\n * @param {number} score1 - Skor dalam mata pelajaran pertama.\n * @param {number} score2 - Skor dalam mata pelajaran kedua.\n * @param {number} score3 - Skor dalam mata pelajaran ketiga.\n * @param {number} score4 - Skor dalam mata pelajaran keempat.\n * @param {number} score5 - Skor dalam mata pelajaran kelima.\n * @returns {number} Total skor yang diperoleh dengan menjumlahkan skor dalam semua mata pelajaran.\n * @example\n * f_13(100, 100, 100, 100, 100); // returns 500\n */\nfunction f_13(score1, score2, score3, score4, score5)", "ja": "/**\n * 異なる科目のスコアに基づいて学生の総合得点を計算します。\n * @param {number} score1 - 最初の科目のスコア。\n * @param {number} score2 - 2番目の科目のスコア。\n * @param {number} score3 - 3番目の科目のスコア。\n * @param {number} score4 - 4番目の科目のスコア。\n * @param {number} score5 - 5番目の科目のスコア。\n * @returns {number} すべての科目のスコアを合計して得られる総合得点。\n * @example\n * f_13(100, 100, 100, 100, 100); // returns 500\n */\nfunction f_13(score1, score2, score3, score4, score5)", "ko": "/**\n * 학생의 총 점수를 다양한 과목의 점수를 기반으로 계산합니다.\n * @param {number} score1 - 첫 번째 과목의 점수.\n * @param {number} score2 - 두 번째 과목의 점수.\n * @param {number} score3 - 세 번째 과목의 점수.\n * @param {number} score4 - 네 번째 과목의 점수.\n * @param {number} score5 - 다섯 번째 과목의 점수.\n * @returns {number} 모든 과목의 점수를 합산하여 얻은 총 점수.\n * @example\n * f_13(100, 100, 100, 100, 100); // returns 500\n */\nfunction f_13(score1, score2, score3, score4, score5)", "ml": "/**\n * വിവിധ വിഷയങ്ങളിലെ സ്കോറുകൾ അടിസ്ഥാനമാക്കി ഒരു വിദ്യാർത്ഥിയുടെ മൊത്തം സ്കോർ കണക്കാക്കുക.\n * @param {number} score1 - ആദ്യ വിഷയത്തിലെ സ്കോർ.\n * @param {number} score2 - രണ്ടാം വിഷയത്തിലെ സ്കോർ.\n * @param {number} score3 - മൂന്നാം വിഷയത്തിലെ സ്കോർ.\n * @param {number} score4 - നാലാം വിഷയത്തിലെ സ്കോർ.\n * @param {number} score5 - അഞ്ചാം വിഷയത്തിലെ സ്കോർ.\n * @returns {number} എല്ലാ വിഷയങ്ങളിലെ സ്കോറുകൾ കൂട്ടിച്ചേർത്തു ലഭിക്കുന്ന മൊത്തം സ്കോർ.\n * @example\n * f_13(100, 100, 100, 100, 100); // returns 500\n */\nfunction f_13(score1, score2, score3, score4, score5)", "fa": "/**\n * محاسبه امتیاز کل برای یک دانش‌آموز بر اساس امتیازات در موضوعات مختلف.\n * @param {number} score1 - امتیاز در موضوع اول.\n * @param {number} score2 - امتیاز در موضوع دوم.\n * @param {number} score3 - امتیاز در موضوع سوم.\n * @param {number} score4 - امتیاز در موضوع چهارم.\n * @param {number} score5 - امتیاز در موضوع پنجم.\n * @returns {number} امتیاز کل به‌دست‌آمده با جمع‌کردن امتیازات در تمام موضوعات.\n * @example\n * f_13(100, 100, 100, 100, 100); // بازگشت 500\n */\nfunction f_13(score1, score2, score3, score4, score5)"}, "canonical_solution": "{\n    return score1 + score2 + score3 + score4 + score5;\n}", "instruction": {"en": "Write a JavaScript function `function f_13(score1, score2, score3, score4, score5)` to solve the following problem:\nCalculate the total score for a student based on the scores in different subjects.\n@param {number} score1 - The score in the first subject.\n@param {number} score2 - The score in the second subject.\n@param {number} score3 - The score in the third subject.\n@param {number} score4 - The score in the fourth subject.\n@param {number} score5 - The score in the fifth subject.\n@returns {number} The total score obtained by summing up the scores in all subjects.\n@example\nf_13(100, 100, 100, 100, 100); // returns 500\n", "sq": "Shkruani një funksion JavaScript `function f_13(score1, score2, score3, score4, score5)` për të zgjidhur problemin e mëposhtëm:\nLlogaritni totalin e pikëve për një student bazuar në pikët në lëndë të ndryshme.\n@param {number} score1 - Pikët në lëndën e parë.\n@param {number} score2 - Pikët në lëndën e dytë.\n@param {number} score3 - Pikët në lëndën e tretë.\n@param {number} score4 - Pikët në lëndën e katërt.\n@param {number} score5 - Pikët në lëndën e pestë.\n@returns {number} Totali i pikëve të marra duke mbledhur pikët në të gjitha lëndët.\n@example\nf_13(100, 100, 100, 100, 100); // returns 500", "hy": "Գրեք JavaScript ֆունկցիա `function f_13(score1, score2, score3, score4, score5)` հետևյալ խնդիրը լուծելու համար:\nՀաշվեք ուսանողի ընդհանուր միավորը տարբեր առարկաներում ստացված միավորների հիման վրա։\n@param {number} score1 - Առաջին առարկայում ստացված միավորը։\n@param {number} score2 - Երկրորդ առարկայում ստացված միավորը։\n@param {number} score3 - Երրորդ առարկայում ստացված միավորը։\n@param {number} score4 - Չորրորդ առարկայում ստացված միավորը։\n@param {number} score5 - Հինգերորդ առարկայում ստացված միավորը։\n@returns {number} Ընդհանուր միավորը, որը ստացվում է բոլոր առարկաներում ստացված միավորների գումարով։\n@example\nf_13(100, 100, 100, 100, 100); // returns 500", "bn": "একটি JavaScript ফাংশন `function f_13(score1, score2, score3, score4, score5)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nবিভিন্ন বিষয়ের স্কোরের উপর ভিত্তি করে একজন ছাত্রের মোট স্কোর গণনা করুন।\n@param {number} score1 - প্রথম বিষয়ের স্কোর।\n@param {number} score2 - দ্বিতীয় বিষয়ের স্কোর।\n@param {number} score3 - তৃতীয় বিষয়ের স্কোর।\n@param {number} score4 - চতুর্থ বিষয়ের স্কোর।\n@param {number} score5 - পঞ্চম বিষয়ের স্কোর।\n@returns {number} সমস্ত বিষয়ের স্কোর যোগ করে প্রাপ্ত মোট স্কোর।\n@example\nf_13(100, 100, 100, 100, 100); // returns 500", "bg": "Напишете JavaScript функция `function f_13(score1, score2, score3, score4, score5)` за решаване на следния проблем:\nИзчислете общия резултат за ученик въз основа на резултатите в различни предмети.\n@param {number} score1 - Резултатът в първия предмет.\n@param {number} score2 - Резултатът във втория предмет.\n@param {number} score3 - Резултатът в третия предмет.\n@param {number} score4 - Резултатът в четвъртия предмет.\n@param {number} score5 - Резултатът в петия предмет.\n@returns {number} Общият резултат, получен чрез сумиране на резултатите във всички предмети.\n@example\nf_13(100, 100, 100, 100, 100); // returns 500", "zh": "编写一个 JavaScript 函数 `function f_13(score1, score2, score3, score4, score5)` 来解决以下问题：\n计算学生在不同科目中的总分。\n@param {number} score1 - 第一科目的分数。\n@param {number} score2 - 第二科目的分数。\n@param {number} score3 - 第三科目的分数。\n@param {number} score4 - 第四科目的分数。\n@param {number} score5 - 第五科目的分数。\n@returns {number} 通过将所有科目的分数相加获得的总分。\n@example\nf_13(100, 100, 100, 100, 100); // returns 500", "fr": "Écrire une fonction JavaScript `function f_13(score1, score2, score3, score4, score5)` pour résoudre le problème suivant :  \nCalculer le score total pour un étudiant basé sur les scores dans différentes matières.  \n@param {number} score1 - Le score dans la première matière.  \n@param {number} score2 - Le score dans la deuxième matière.  \n@param {number} score3 - Le score dans la troisième matière.  \n@param {number} score4 - Le score dans la quatrième matière.  \n@param {number} score5 - Le score dans la cinquième matière.  \n@returns {number} Le score total obtenu en additionnant les scores dans toutes les matières.  \n@example  \nf_13(100, 100, 100, 100, 100); // returns 500  ", "de": "Schreiben Sie eine JavaScript-Funktion `function f_13(score1, score2, score3, score4, score5)`, um das folgende Problem zu lösen:\nBerechnen Sie die Gesamtpunktzahl für einen Schüler basierend auf den Punktzahlen in verschiedenen Fächern.\n@param {number} score1 - Die Punktzahl im ersten Fach.\n@param {number} score2 - Die Punktzahl im zweiten Fach.\n@param {number} score3 - Die Punktzahl im dritten Fach.\n@param {number} score4 - Die Punktzahl im vierten Fach.\n@param {number} score5 - Die Punktzahl im fünften Fach.\n@returns {number} Die Gesamtpunktzahl, die durch das Summieren der Punktzahlen in allen Fächern erzielt wird.\n@example\nf_13(100, 100, 100, 100, 100); // returns 500", "ha": "Rubuta wani aikin JavaScript `function f_13(score1, score2, score3, score4, score5)` don warware matsalar mai zuwa:  \nƘididdige jimillar maki ga ɗalibi bisa ga maki a fannoni daban-daban.  \n@param {number} score1 - Maki a fanni na farko.  \n@param {number} score2 - Maki a fanni na biyu.  \n@param {number} score3 - Maki a fanni na uku.  \n@param {number} score4 - Maki a fanni na huɗu.  \n@param {number} score5 - Maki a fanni na biyar.  \n@returns {number} Jimillar maki da aka samu ta hanyar tara maki a dukkan fannoni.  \n@example  \nf_13(100, 100, 100, 100, 100); // returns 500  ", "hi": "JavaScript फ़ंक्शन `function f_13(score1, score2, score3, score4, score5)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nविभिन्न विषयों में प्राप्त अंकों के आधार पर एक छात्र का कुल स्कोर गणना करें।\n@param {number} score1 - पहले विषय में प्राप्त अंक।\n@param {number} score2 - दूसरे विषय में प्राप्त अंक।\n@param {number} score3 - तीसरे विषय में प्राप्त अंक।\n@param {number} score4 - चौथे विषय में प्राप्त अंक।\n@param {number} score5 - पाँचवे विषय में प्राप्त अंक।\n@returns {number} सभी विषयों में प्राप्त अंकों को जोड़कर प्राप्त कुल स्कोर।\n@example\nf_13(100, 100, 100, 100, 100); // returns 500", "hu": "Írj egy JavaScript függvényt `function f_13(score1, score2, score3, score4, score5)` a következő probléma megoldására:\nSzámítsd ki a diák összpontszámát a különböző tantárgyakban elért pontszámok alapján.\n@param {number} score1 - Az első tantárgy pontszáma.\n@param {number} score2 - A második tantárgy pontszáma.\n@param {number} score3 - A harmadik tantárgy pontszáma.\n@param {number} score4 - A negyedik tantárgy pontszáma.\n@param {number} score5 - Az ötödik tantárgy pontszáma.\n@returns {number} Az összpontszám, amelyet a tantárgyak pontszámainak összeadásával kapunk.\n@example\nf_13(100, 100, 100, 100, 100); // returns 500", "es": "Escribe una función de JavaScript `function f_13(score1, score2, score3, score4, score5)` para resolver el siguiente problema:\nCalcular la puntuación total de un estudiante basada en las puntuaciones en diferentes materias.\n@param {number} score1 - La puntuación en la primera materia.\n@param {number} score2 - La puntuación en la segunda materia.\n@param {number} score3 - La puntuación en la tercera materia.\n@param {number} score4 - La puntuación en la cuarta materia.\n@param {number} score5 - La puntuación en la quinta materia.\n@returns {number} La puntuación total obtenida al sumar las puntuaciones en todas las materias.\n@example\nf_13(100, 100, 100, 100, 100); // devuelve 500", "arb": "اكتب دالة JavaScript `function f_13(score1, score2, score3, score4, score5)` لحل المشكلة التالية:\nاحسب المجموع الكلي للدرجات لطالب بناءً على الدرجات في مواد مختلفة.\n@param {number} score1 - الدرجة في المادة الأولى.\n@param {number} score2 - الدرجة في المادة الثانية.\n@param {number} score3 - الدرجة في المادة الثالثة.\n@param {number} score4 - الدرجة في المادة الرابعة.\n@param {number} score5 - الدرجة في المادة الخامسة.\n@returns {number} المجموع الكلي للدرجات المحصل عليه بجمع الدرجات في جميع المواد.\n@example\nf_13(100, 100, 100, 100, 100); // يعيد 500", "sw": "Andika kazi ya JavaScript `function f_13(score1, score2, score3, score4, score5)` kutatua tatizo lifuatalo:\nHesabu jumla ya alama kwa mwanafunzi kulingana na alama katika masomo tofauti.\n@param {number} score1 - Alama katika somo la kwanza.\n@param {number} score2 - Alama katika somo la pili.\n@param {number} score3 - Alama katika somo la tatu.\n@param {number} score4 - Alama katika somo la nne.\n@param {number} score5 - Alama katika somo la tano.\n@returns {number} Jumla ya alama iliyopatikana kwa kujumlisha alama katika masomo yote.\n@example\nf_13(100, 100, 100, 100, 100); // inarejesha 500", "tr": "Bir JavaScript fonksiyonu `function f_13(score1, score2, score3, score4, score5)` yazın ve aşağıdaki problemi çözün:\nFarklı derslerdeki puanlara göre bir öğrencinin toplam puanını hesaplayın.\n@param {number} score1 - İlk dersteki puan.\n@param {number} score2 - İkinci dersteki puan.\n@param {number} score3 - Üçüncü dersteki puan.\n@param {number} score4 - Dördüncü dersteki puan.\n@param {number} score5 - Beşinci dersteki puan.\n@returns {number} Tüm derslerdeki puanların toplanmasıyla elde edilen toplam puan.\n@example\nf_13(100, 100, 100, 100, 100); // 500 döndürür.", "vi": "Viết một hàm JavaScript `function f_13(score1, score2, score3, score4, score5)` để giải quyết vấn đề sau:\nTính tổng điểm cho một học sinh dựa trên điểm số trong các môn học khác nhau.\n@param {number} score1 - Điểm số trong môn học thứ nhất.\n@param {number} score2 - Điểm số trong môn học thứ hai.\n@param {number} score3 - Điểm số trong môn học thứ ba.\n@param {number} score4 - Điểm số trong môn học thứ tư.\n@param {number} score5 - Điểm số trong môn học thứ năm.\n@returns {number} Tổng điểm đạt được bằng cách cộng các điểm số trong tất cả các môn học.\n@example\nf_13(100, 100, 100, 100, 100); // trả về 500", "id": "Tulis sebuah fungsi JavaScript `function f_13(score1, score2, score3, score4, score5)` untuk menyelesaikan masalah berikut:\nHitung total skor untuk seorang siswa berdasarkan skor dalam berbagai mata pelajaran.\n@param {number} score1 - Skor dalam mata pelajaran pertama.\n@param {number} score2 - Skor dalam mata pelajaran kedua.\n@param {number} score3 - Skor dalam mata pelajaran ketiga.\n@param {number} score4 - Skor dalam mata pelajaran keempat.\n@param {number} score5 - Skor dalam mata pelajaran kelima.\n@returns {number} Total skor yang diperoleh dengan menjumlahkan skor dalam semua mata pelajaran.\n@example\nf_13(100, 100, 100, 100, 100); // returns 500", "ja": "JavaScript関数 `function f_13(score1, score2, score3, score4, score5)` を作成して、次の問題を解決してください:\n異なる科目のスコアに基づいて学生の合計スコアを計算します。\n@param {number} score1 - 最初の科目のスコア。\n@param {number} score2 - 2番目の科目のスコア。\n@param {number} score3 - 3番目の科目のスコア。\n@param {number} score4 - 4番目の科目のスコア。\n@param {number} score5 - 5番目の科目のスコア。\n@returns {number} すべての科目のスコアを合計することによって得られる合計スコア。\n@example\nf_13(100, 100, 100, 100, 100); // returns 500", "ko": "다음 문제를 해결하기 위해 JavaScript 함수를 작성하세요: `function f_13(score1, score2, score3, score4, score5)`\n다양한 과목의 점수를 기반으로 학생의 총점을 계산합니다.\n@param {number} score1 - 첫 번째 과목의 점수입니다.\n@param {number} score2 - 두 번째 과목의 점수입니다.\n@param {number} score3 - 세 번째 과목의 점수입니다.\n@param {number} score4 - 네 번째 과목의 점수입니다.\n@param {number} score5 - 다섯 번째 과목의 점수입니다.\n@returns {number} 모든 과목의 점수를 합산하여 얻은 총점입니다.\n@example\nf_13(100, 100, 100, 100, 100); // returns 500", "ml": "ഒരു ജാവാസ്ക്രിപ്റ്റ് ഫംഗ്ഷൻ `function f_13(score1, score2, score3, score4, score5)` എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nവിഭിന്ന വിഷയങ്ങളിലെ സ്കോറുകൾ അടിസ്ഥാനമാക്കി ഒരു വിദ്യാർത്ഥിയുടെ ആകെ സ്കോർ കണക്കാക്കുക.\n@param {number} score1 - ആദ്യ വിഷയത്തിലെ സ്കോർ.\n@param {number} score2 - രണ്ടാം വിഷയത്തിലെ സ്കോർ.\n@param {number} score3 - മൂന്നാം വിഷയത്തിലെ സ്കോർ.\n@param {number} score4 - നാലാം വിഷയത്തിലെ സ്കോർ.\n@param {number} score5 - അഞ്ചാം വിഷയത്തിലെ സ്കോർ.\n@returns {number} എല്ലാ വിഷയങ്ങളിലെ സ്കോറുകൾ കൂട്ടിച്ചേർത്ത് ലഭിക്കുന്ന ആകെ സ്കോർ.\n@example\nf_13(100, 100, 100, 100, 100); // returns 500", "fa": "یک تابع جاوااسکریپت `function f_13(score1, score2, score3, score4, score5)` بنویسید تا مسئله زیر را حل کند:\nمحاسبه نمره کل برای یک دانش‌آموز بر اساس نمرات در موضوعات مختلف.\n@param {number} score1 - نمره در موضوع اول.\n@param {number} score2 - نمره در موضوع دوم.\n@param {number} score3 - نمره در موضوع سوم.\n@param {number} score4 - نمره در موضوع چهارم.\n@param {number} score5 - نمره در موضوع پنجم.\n@returns {number} نمره کل به‌دست‌آمده با جمع کردن نمرات در تمام موضوعات.\n@example\nf_13(100, 100, 100, 100, 100); // returns 500"}, "level": "easy", "test": "function testf_13() {\n    console.assert(f_13(100, 100, 100, 100, 100) === 500, 'Test failed: Expected 500 for all 100 scores');\n    console.assert(f_13(0, 0, 0, 0, 0) === 0, 'Test failed: Expected 0 for all 0 scores');\n    console.assert(f_13(20, 30, 40, 10, 50) === 150, 'Test failed: Expected 150 for mixed scores');\n    console.assert(f_13(23, 45, 67, 89, 12) === 236, 'Test failed: Expected 236 for mixed scores');\n    console.assert(f_13(5, 5, 5, 5, 5) === 25, 'Test failed: Expected 25 for all 5 scores');\n}\n\ntestf_13(); // Running the test function to validate our code", "entry_point": "f_13", "signature": "function f_13(score1, score2, score3, score4, score5)", "docstring": {"en": "Calculate the total score for a student based on the scores in different subjects.\n@param {number} score1 - The score in the first subject.\n@param {number} score2 - The score in the second subject.\n@param {number} score3 - The score in the third subject.\n@param {number} score4 - The score in the fourth subject.\n@param {number} score5 - The score in the fifth subject.\n@returns {number} The total score obtained by summing up the scores in all subjects.\n@example\nf_13(100, 100, 100, 100, 100); // returns 500\n", "sq": "Llogaritni rezultatin total për një student bazuar në rezultatet në lëndë të ndryshme.\n@param {number} score1 - Rezultati në lëndën e parë.\n@param {number} score2 - Rezultati në lëndën e dytë.\n@param {number} score3 - Rezultati në lëndën e tretë.\n@param {number} score4 - Rezultati në lëndën e katërt.\n@param {number} score5 - Rezultati në lëndën e pestë.\n@returns {number} Rezultati total i marrë duke mbledhur rezultatet në të gjitha lëndët.\n@example\nf_13(100, 100, 100, 100, 100); // returns 500", "hy": "Հաշվել ուսանողի ընդհանուր միավորը տարբեր առարկաներում ստացած միավորների հիման վրա:\n@param {number} score1 - Առաջին առարկայի միավորը:\n@param {number} score2 - Երկրորդ առարկայի միավորը:\n@param {number} score3 - Երրորդ առարկայի միավորը:\n@param {number} score4 - Չորրորդ առարկայի միավորը:\n@param {number} score5 - Հինգերորդ առարկայի միավորը:\n@returns {number} Ընդհանուր միավորը, որը ստացվում է բոլոր առարկաների միավորների գումարով:\n@example\nf_13(100, 100, 100, 100, 100); // returns 500", "bn": "বিভিন্ন বিষয়ে প্রাপ্ত নম্বরের ভিত্তিতে একজন শিক্ষার্থীর মোট স্কোর গণনা করুন।\n@param {number} score1 - প্রথম বিষয়ের স্কোর।\n@param {number} score2 - দ্বিতীয় বিষয়ের স্কোর।\n@param {number} score3 - তৃতীয় বিষয়ের স্কোর।\n@param {number} score4 - চতুর্থ বিষয়ের স্কোর।\n@param {number} score5 - পঞ্চম বিষয়ের স্কোর।\n@returns {number} সমস্ত বিষয়ের স্কোর যোগ করে প্রাপ্ত মোট স্কোর।\n@example\nf_13(100, 100, 100, 100, 100); // returns 500", "bg": "Изчислява общия резултат за студент въз основа на резултатите в различни предмети.\n@param {number} score1 - Резултатът в първия предмет.\n@param {number} score2 - Резултатът във втория предмет.\n@param {number} score3 - Резултатът в третия предмет.\n@param {number} score4 - Резултатът в четвъртия предмет.\n@param {number} score5 - Резултатът в петия предмет.\n@returns {number} Общият резултат, получен чрез сумиране на резултатите във всички предмети.\n@example\nf_13(100, 100, 100, 100, 100); // returns 500", "zh": "计算学生在不同科目中的总分。  \n@param {number} score1 - 第一科目的分数。  \n@param {number} score2 - 第二科目的分数。  \n@param {number} score3 - 第三科目的分数。  \n@param {number} score4 - 第四科目的分数。  \n@param {number} score5 - 第五科目的分数。  \n@returns {number} 通过将所有科目的分数相加获得的总分。  \n@example  \nf_13(100, 100, 100, 100, 100); // returns 500  ", "fr": "Calculer le score total pour un étudiant basé sur les scores dans différentes matières.\n@param {number} score1 - Le score dans la première matière.\n@param {number} score2 - Le score dans la deuxième matière.\n@param {number} score3 - Le score dans la troisième matière.\n@param {number} score4 - Le score dans la quatrième matière.\n@param {number} score5 - Le score dans la cinquième matière.\n@returns {number} Le score total obtenu en additionnant les scores dans toutes les matières.\n@example\nf_13(100, 100, 100, 100, 100); // returns 500", "de": "Berechnen Sie die Gesamtpunktzahl für einen Schüler basierend auf den Punkten in verschiedenen Fächern.\n@param {number} score1 - Die Punktzahl im ersten Fach.\n@param {number} score2 - Die Punktzahl im zweiten Fach.\n@param {number} score3 - Die Punktzahl im dritten Fach.\n@param {number} score4 - Die Punktzahl im vierten Fach.\n@param {number} score5 - Die Punktzahl im fünften Fach.\n@returns {number} Die Gesamtpunktzahl, die durch Summieren der Punkte in allen Fächern erzielt wird.\n@example\nf_13(100, 100, 100, 100, 100); // returns 500", "ha": "Lissafa jimillar maki ga ɗalibi bisa ga maki a fannoni daban-daban.\n@param {number} score1 - Makasudin a fannin farko.\n@param {number} score2 - Makasudin a fannin na biyu.\n@param {number} score3 - Makasudin a fannin na uku.\n@param {number} score4 - Makasudin a fannin na hudu.\n@param {number} score5 - Makasudin a fannin na biyar.\n@returns {number} Jimillar maki da aka samu ta hanyar tara maki a dukkan fannoni.\n@example\nf_13(100, 100, 100, 100, 100); // returns 500", "hi": "विभिन्न विषयों में अंकों के आधार पर एक छात्र के लिए कुल अंक की गणना करें।\n@param {number} score1 - पहले विषय में प्राप्त अंक।\n@param {number} score2 - दूसरे विषय में प्राप्त अंक।\n@param {number} score3 - तीसरे विषय में प्राप्त अंक।\n@param {number} score4 - चौथे विषय में प्राप्त अंक।\n@param {number} score5 - पांचवें विषय में प्राप्त अंक।\n@returns {number} सभी विषयों में प्राप्त अंकों को जोड़कर प्राप्त कुल अंक।\n@example\nf_13(100, 100, 100, 100, 100); // returns 500", "hu": "Számítsa ki a diák összpontszámát a különböző tantárgyakban elért pontszámok alapján.\n@param {number} score1 - Az első tantárgy pontszáma.\n@param {number} score2 - A második tantárgy pontszáma.\n@param {number} score3 - A harmadik tantárgy pontszáma.\n@param {number} score4 - A negyedik tantárgy pontszáma.\n@param {number} score5 - Az ötödik tantárgy pontszáma.\n@returns {number} Az összpontszám, amelyet az összes tantárgy pontszámainak összeadásával kapunk.\n@example\nf_13(100, 100, 100, 100, 100); // returns 500", "es": "Calcular la puntuación total para un estudiante basada en las puntuaciones en diferentes materias.\n@param {number} score1 - La puntuación en la primera materia.\n@param {number} score2 - La puntuación en la segunda materia.\n@param {number} score3 - La puntuación en la tercera materia.\n@param {number} score4 - La puntuación en la cuarta materia.\n@param {number} score5 - La puntuación en la quinta materia.\n@returns {number} La puntuación total obtenida sumando las puntuaciones en todas las materias.\n@example\nf_13(100, 100, 100, 100, 100); // devuelve 500", "arb": "احسب إجمالي الدرجات لطالب بناءً على الدرجات في مواد مختلفة.\n@param {number} score1 - الدرجة في المادة الأولى.\n@param {number} score2 - الدرجة في المادة الثانية.\n@param {number} score3 - الدرجة في المادة الثالثة.\n@param {number} score4 - الدرجة في المادة الرابعة.\n@param {number} score5 - الدرجة في المادة الخامسة.\n@returns {number} إجمالي الدرجات المحصل عليها من خلال جمع الدرجات في جميع المواد.\n@example\nf_13(100, 100, 100, 100, 100); // يعيد 500", "sw": "Hesabu jumla ya alama kwa mwanafunzi kulingana na alama katika masomo tofauti.\n@param {number} score1 - Alama katika somo la kwanza.\n@param {number} score2 - Alama katika somo la pili.\n@param {number} score3 - Alama katika somo la tatu.\n@param {number} score4 - Alama katika somo la nne.\n@param {number} score5 - Alama katika somo la tano.\n@returns {number} Jumla ya alama iliyopatikana kwa kujumlisha alama katika masomo yote.\n@example\nf_13(100, 100, 100, 100, 100); // inarejesha 500", "tr": "Farklı derslerdeki puanlara göre bir öğrencinin toplam puanını hesaplayın.\\n@param {number} score1 - İlk dersteki puan.\n@param {number} score2 - İkinci dersteki puan.\n@param {number} score3 - Üçüncü dersteki puan.\n@param {number} score4 - Dördüncü dersteki puan.\n@param {number} score5 - Beşinci dersteki puan.\n@returns {number} Tüm derslerdeki puanların toplanmasıyla elde edilen toplam puan.\n@example\nf_13(100, 100, 100, 100, 100); // 500 döndürür", "vi": "Tính tổng điểm cho một học sinh dựa trên điểm số trong các môn học khác nhau.\n@param {number} score1 - Điểm số trong môn học đầu tiên.\n@param {number} score2 - Điểm số trong môn học thứ hai.\n@param {number} score3 - Điểm số trong môn học thứ ba.\n@param {number} score4 - Điểm số trong môn học thứ tư.\n@param {number} score5 - Điểm số trong môn học thứ năm.\n@returns {number} Tổng điểm đạt được bằng cách cộng điểm số trong tất cả các môn học.\n@example\nf_13(100, 100, 100, 100, 100); // 500 trả về", "id": "Hitung total skor untuk seorang siswa berdasarkan skor dalam berbagai mata pelajaran.\n@param {number} score1 - Skor dalam mata pelajaran pertama.\n@param {number} score2 - Skor dalam mata pelajaran kedua.\n@param {number} score3 - Skor dalam mata pelajaran ketiga.\n@param {number} score4 - Skor dalam mata pelajaran keempat.\n@param {number} score5 - Skor dalam mata pelajaran kelima.\n@returns {number} Total skor yang diperoleh dengan menjumlahkan skor dalam semua mata pelajaran.\n@example\nf_13(100, 100, 100, 100, 100); // returns 500", "ja": "異なる科目のスコアに基づいて学生の合計スコアを計算します。\n@param {number} score1 - 最初の科目のスコア。\n@param {number} score2 - 2番目の科目のスコア。\n@param {number} score3 - 3番目の科目のスコア。\n@param {number} score4 - 4番目の科目のスコア。\n@param {number} score5 - 5番目の科目のスコア。\n@returns {number} すべての科目のスコアを合計して得られる合計スコア。\n@example\nf_13(100, 100, 100, 100, 100); // returns 500", "ko": "학생의 다양한 과목 점수를 기반으로 총 점수를 계산합니다.\n@param {number} score1 - 첫 번째 과목의 점수입니다.\n@param {number} score2 - 두 번째 과목의 점수입니다.\n@param {number} score3 - 세 번째 과목의 점수입니다.\n@param {number} score4 - 네 번째 과목의 점수입니다.\n@param {number} score5 - 다섯 번째 과목의 점수입니다.\n@returns {number} 모든 과목의 점수를 합산하여 얻은 총 점수입니다.\n@example\nf_13(100, 100, 100, 100, 100); // returns 500", "ml": "വിവിധ വിഷയങ്ങളിലെ സ്കോറുകൾ അടിസ്ഥാനമാക്കി ഒരു വിദ്യാർത്ഥിയുടെ മൊത്തം സ്കോർ കണക്കാക്കുക.\n@param {number} score1 - ആദ്യ വിഷയത്തിലെ സ്കോർ.  \n@param {number} score2 - രണ്ടാം വിഷയത്തിലെ സ്കോർ.  \n@param {number} score3 - മൂന്നാം വിഷയത്തിലെ സ്കോർ.  \n@param {number} score4 - നാലാം വിഷയത്തിലെ സ്കോർ.  \n@param {number} score5 - അഞ്ചാം വിഷയത്തിലെ സ്കോർ.  \n@returns {number} എല്ലാ വിഷയങ്ങളിലുമുള്ള സ്കോറുകൾ കൂട്ടിച്ചേർത്തു ലഭിക്കുന്ന മൊത്തം സ്കോർ.  \n@example  \nf_13(100, 100, 100, 100, 100); // returns 500  ", "fa": "محاسبه امتیاز کل برای یک دانش‌آموز بر اساس امتیازات در موضوعات مختلف.\n@param {number} score1 - امتیاز در موضوع اول.\n@param {number} score2 - امتیاز در موضوع دوم.\n@param {number} score3 - امتیاز در موضوع سوم.\n@param {number} score4 - امتیاز در موضوع چهارم.\n@param {number} score5 - امتیاز در موضوع پنجم.\n@returns {number} امتیاز کل به‌دست‌آمده با جمع کردن امتیازات در همه موضوعات.\n@example\nf_13(100, 100, 100, 100, 100); // returns 500"}}
{"task_id": "JavaScript/14", "prompt": {"en": "/**\n * Decode a series of numbers to reveal the pattern and understand the actual values\n * each digit represents. The patterns are as follows:\n * 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n *\n * @param {string} dataStr - A string representing a series of numbers.\n *                           The length does not exceed 100 characters.\n * @return {number} The result corresponding to each data string as per the pattern.\n *\n * Example usage:\n * console.assert(f_14(\"0000\") === 4);\n */\nfunction f_14(dataStr)", "sq": "/**\n * Dekodoni një seri numrash për të zbuluar modelin dhe për të kuptuar vlerat aktuale\n * që përfaqëson secila shifër. Modelet janë si më poshtë:\n * 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n *\n * @param {string} dataStr - Një varg që përfaqëson një seri numrash.\n *                           Gjatësia nuk tejkalon 100 karaktere.\n * @return {number} Rezultati që korrespondon me secilin varg të dhënash sipas modelit.\n *\n * Shembull përdorimi:\n * console.assert(f_14(\"0000\") === 4);\n */\nfunction f_14(dataStr)", "hy": "/**\n * Վերծանել թվերի շարք՝ բացահայտելու համար նախշը և հասկանալու իրական արժեքները,\n * որոնք ներկայացնում է յուրաքանչյուր թվանշան։ Նախշերը հետևյալն են՝\n * 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4։\n *\n * @param {string} dataStr - Թվերի շարքը ներկայացնող տող։\n *                           Երկարությունը չի գերազանցում 100 նիշը։\n * @return {number} Արդյունքը, որը համապատասխանում է յուրաքանչյուր տվյալ տողի նախշին։\n *\n * Օրինակ օգտագործում՝\n * console.assert(f_14(\"0000\") === 4);\n */", "bn": "/**\n * সংখ্যার একটি সিরিজ ডিকোড করে প্যাটার্ন উন্মোচন করুন এবং প্রতিটি অঙ্ক প্রকৃতপক্ষে কোন মানগুলি উপস্থাপন করে তা বুঝুন।\n * প্যাটার্নগুলি নিম্নরূপ:\n * 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n *\n * @param {string} dataStr - একটি স্ট্রিং যা সংখ্যার একটি সিরিজ উপস্থাপন করে।\n *                           দৈর্ঘ্য 100 অক্ষরের বেশি নয়।\n * @return {number} প্রতিটি ডেটা স্ট্রিংয়ের সাথে প্যাটার্ন অনুযায়ী সংশ্লিষ্ট ফলাফল।\n *\n * উদাহরণ ব্যবহার:\n * console.assert(f_14(\"0000\") === 4);\n */", "bg": "/**\n * Декодирайте серия от числа, за да разкриете модела и да разберете действителните стойности,\n * които всяка цифра представлява. Моделите са както следва:\n * 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n *\n * @param {string} dataStr - Низ, представляващ серия от числа.\n *                           Дължината не надвишава 100 символа.\n * @return {number} Резултатът, съответстващ на всеки низ от данни според модела.\n *\n * Пример за използване:\n * console.assert(f_14(\"0000\") === 4);\n */", "zh": "/**\n * 解码一系列数字以揭示模式并理解每个数字实际代表的值。模式如下：\n * 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4。\n *\n * @param {string} dataStr - 表示一系列数字的字符串。\n *                           长度不超过100个字符。\n * @return {number} 根据模式对应每个数据字符串的结果。\n *\n * 示例用法:\n * console.assert(f_14(\"0000\") === 4);\n */", "fr": "/**\n * Décoder une série de chiffres pour révéler le motif et comprendre les valeurs réelles\n * que chaque chiffre représente. Les motifs sont les suivants :\n * 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n *\n * @param {string} dataStr - Une chaîne représentant une série de chiffres.\n *                           La longueur ne dépasse pas 100 caractères.\n * @return {number} Le résultat correspondant à chaque chaîne de données selon le motif.\n *\n * Exemple d'utilisation :\n * console.assert(f_14(\"0000\") === 4);\n */", "de": "/**\n * Dekodiere eine Reihe von Zahlen, um das Muster zu erkennen und die tatsächlichen Werte zu verstehen,\n * die jede Ziffer darstellt. Die Muster sind wie folgt:\n * 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n *\n * @param {string} dataStr - Ein String, der eine Reihe von Zahlen darstellt.\n *                           Die Länge überschreitet nicht 100 Zeichen.\n * @return {number} Das Ergebnis, das jedem Datenstring gemäß dem Muster entspricht.\n *\n * Beispielverwendung:\n * console.assert(f_14(\"0000\") === 4);\n */\nfunction f_14(dataStr)", "ha": "/**\n * Fassar da jerin lambobi don bayyana tsarin kuma fahimtar ainihin ƙimar\n * kowace lamba ke wakilta. Tsarin suna kamar haka:\n * 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n *\n * @param {string} dataStr - Wani kirtani da ke wakiltar jerin lambobi.\n *                           Tsawon ba ya wuce haruffa 100.\n * @return {number} Sakamakon da ya dace da kowanne kirtani na bayanai bisa tsarin.\n *\n * Misalin amfani:\n * console.assert(f_14(\"0000\") === 4);\n */\nfunction f_14(dataStr)", "hi": "/**\n * संख्याओं की एक श्रृंखला को डिकोड करें ताकि पैटर्न का पता चल सके और समझ सकें कि प्रत्येक अंक का वास्तविक मूल्य क्या है।\n * पैटर्न इस प्रकार हैं:\n * 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n *\n * @param {string} dataStr - एक स्ट्रिंग जो संख्याओं की एक श्रृंखला का प्रतिनिधित्व करती है।\n *                           लंबाई 100 वर्णों से अधिक नहीं है।\n * @return {number} पैटर्न के अनुसार प्रत्येक डेटा स्ट्रिंग के अनुरूप परिणाम।\n *\n * उदाहरण उपयोग:\n * console.assert(f_14(\"0000\") === 4);\n */\nfunction f_14(dataStr)", "hu": "/**\n * Dekódolja a számok sorozatát, hogy feltárja a mintát és megértse, hogy az egyes számjegyek\n * valójában milyen értékeket képviselnek. A minták a következők:\n * 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n *\n * @param {string} dataStr - Egy karakterlánc, amely számok sorozatát képviseli.\n *                           A hossza nem haladja meg a 100 karaktert.\n * @return {number} Az eredmény, amely megfelel az egyes adatkarakterláncoknak a minta szerint.\n *\n * Példa használat:\n * console.assert(f_14(\"0000\") === 4);\n */\nfunction f_14(dataStr)", "es": "/**\n * Decodificar una serie de números para revelar el patrón y entender los valores reales\n * que representa cada dígito. Los patrones son los siguientes:\n * 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n *\n * @param {string} dataStr - Una cadena que representa una serie de números.\n *                           La longitud no excede los 100 caracteres.\n * @return {number} El resultado correspondiente a cada cadena de datos según el patrón.\n *\n * Ejemplo de uso:\n * console.assert(f_14(\"0000\") === 4);\n */\nfunction f_14(dataStr)", "arb": "/**\n * فك سلسلة من الأرقام للكشف عن النمط وفهم القيم الفعلية\n * التي يمثلها كل رقم. الأنماط هي كما يلي:\n * 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n *\n * @param {string} dataStr - سلسلة تمثل سلسلة من الأرقام.\n *                           الطول لا يتجاوز 100 حرف.\n * @return {number} النتيجة المقابلة لكل سلسلة بيانات وفقًا للنمط.\n *\n * مثال على الاستخدام:\n * console.assert(f_14(\"0000\") === 4);\n */\nfunction f_14(dataStr)", "sw": "/**\n * Fafanua mfululizo wa nambari ili kufichua muundo na kuelewa thamani halisi\n * kila tarakimu inawakilisha. Mifumo ni kama ifuatavyo:\n * 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n *\n * @param {string} dataStr - Kamba inayowakilisha mfululizo wa nambari.\n *                           Urefu hauzidi herufi 100.\n * @return {number} Matokeo yanayolingana na kila kamba ya data kulingana na muundo.\n *\n * Mfano wa matumizi:\n * console.assert(f_14(\"0000\") === 4);\n */\nfunction f_14(dataStr)", "tr": "/**\n * Bir dizi sayıyı çözerek deseni ortaya çıkarın ve her bir rakamın\n * temsil ettiği gerçek değerleri anlayın. Desenler aşağıdaki gibidir:\n * 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n *\n * @param {string} dataStr - Bir dizi sayıyı temsil eden bir dize.\n *                           Uzunluğu 100 karakteri geçmez.\n * @return {number} Desene göre her bir veri dizisine karşılık gelen sonuç.\n *\n * Örnek kullanım:\n * console.assert(f_14(\"0000\") === 4);\n */\nfunction f_14(dataStr)", "vi": "/**\n * Giải mã một chuỗi số để tiết lộ mẫu và hiểu các giá trị thực tế\n * mà mỗi chữ số đại diện. Các mẫu như sau:\n * 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n *\n * @param {string} dataStr - Một chuỗi đại diện cho một loạt các số.\n *                           Độ dài không vượt quá 100 ký tự.\n * @return {number} Kết quả tương ứng với mỗi chuỗi dữ liệu theo mẫu.\n *\n * Ví dụ sử dụng:\n * console.assert(f_14(\"0000\") === 4);\n */\nfunction f_14(dataStr)", "id": "/**\n * Menguraikan serangkaian angka untuk mengungkap pola dan memahami nilai sebenarnya\n * yang diwakili oleh setiap digit. Pola-pola tersebut adalah sebagai berikut:\n * 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n *\n * @param {string} dataStr - Sebuah string yang mewakili serangkaian angka.\n *                           Panjangnya tidak melebihi 100 karakter.\n * @return {number} Hasil yang sesuai dengan setiap string data sesuai pola.\n *\n * Contoh penggunaan:\n * console.assert(f_14(\"0000\") === 4);\n */\nfunction f_14(dataStr)", "ja": "/**\n * 一連の数字をデコードしてパターンを明らかにし、それぞれの桁が表す実際の値を理解します。\n * パターンは以下の通りです:\n * 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n *\n * @param {string} dataStr - 数字の列を表す文字列。\n *                           長さは100文字を超えません。\n * @return {number} パターンに従って各データ文字列に対応する結果。\n *\n * 使用例:\n * console.assert(f_14(\"0000\") === 4);\n */\nfunction f_14(dataStr)", "ko": "/**\n * 일련의 숫자를 디코딩하여 패턴을 밝히고 각 숫자가 나타내는 실제 값을 이해합니다.\n * 패턴은 다음과 같습니다:\n * 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n *\n * @param {string} dataStr - 숫자 시리즈를 나타내는 문자열입니다.\n *                           길이는 100자를 초과하지 않습니다.\n * @return {number} 패턴에 따라 각 데이터 문자열에 해당하는 결과입니다.\n *\n * 사용 예:\n * console.assert(f_14(\"0000\") === 4);\n */\nfunction f_14(dataStr)", "ml": "/**\n * സംഖ്യകളുടെ ഒരു ശ്രേണി ഡികോഡ് ചെയ്ത് മാതൃക വെളിപ്പെടുത്തുകയും ഓരോ അക്കവും പ്രതിനിധീകരിക്കുന്ന യഥാർത്ഥ മൂല്യങ്ങൾ മനസ്സിലാക്കുകയും ചെയ്യുക.\n * മാതൃകകൾ ചുവടെപ്പറയുന്നവയാണ്:\n * 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n *\n * @param {string} dataStr - സംഖ്യകളുടെ ഒരു ശ്രേണി പ്രതിനിധീകരിക്കുന്ന ഒരു സ്ട്രിംഗ്.\n *                           നീളം 100 അക്ഷരങ്ങളെ കവിയുന്നില്ല.\n * @return {number} മാതൃകപ്രകാരം ഓരോ ഡാറ്റ സ്ട്രിംഗിനും അനുയോജ്യമായ ഫലമാണ്.\n *\n * ഉദാഹരണ ഉപയോഗം:\n * console.assert(f_14(\"0000\") === 4);\n */\nfunction f_14(dataStr)", "fa": "/**\n * رمزگشایی یک سری اعداد برای آشکارسازی الگو و درک مقادیر واقعی\n * که هر رقم نشان می‌دهد. الگوها به شرح زیر هستند:\n * 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n *\n * @param {string} dataStr - یک رشته که نمایانگر یک سری اعداد است.\n *                           طول آن از 100 کاراکتر تجاوز نمی‌کند.\n * @return {number} نتیجه‌ای که مطابق با هر رشته داده بر اساس الگو است.\n *\n * مثال استفاده:\n * console.assert(f_14(\"0000\") === 4);\n */\nfunction f_14(dataStr)"}, "canonical_solution": "{\n    // Mapping values as per the given pattern\n    const a = [1, 0, 0, 0, 1, 0, 1, 0, 2, 1];\n    let ans = 0;\n    for (let i = 0; i < dataStr.length; i++) {\n        ans += a[dataStr[i] - '0']; // Subtracting '0' to convert char to actual number\n    }\n    return ans;\n}", "instruction": {"en": "Write a JavaScript function `function f_14(dataStr)` to solve the following problem:\nDecode a series of numbers to reveal the pattern and understand the actual values each digit represents. The patterns are as follows: 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n\nParameters:\n- dataStr (string): A string representing a series of numbers. The length does not exceed 100 characters.\n\nReturns:\n- number: The result corresponding to each data string as per the pattern.\n\nExample usage:\nconsole.assert(f_14(\"0000\") === 4);", "sq": "Shkruani një funksion JavaScript `function f_14(dataStr)` për të zgjidhur problemin e mëposhtëm:\nDekodoni një seri numrash për të zbuluar modelin dhe për të kuptuar vlerat reale që përfaqëson secila shifër. Modelet janë si më poshtë: 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n\nParametrat:\n- dataStr (string): Një varg që përfaqëson një seri numrash. Gjatësia nuk i kalon 100 karaktere.\n\nKthen:\n- numër: Rezultati që korrespondon me secilin varg të dhënash sipas modelit.\n\nShembull përdorimi:\nconsole.assert(f_14(\"0000\") === 4);", "hy": "Գրեք JavaScript ֆունկցիա `function f_14(dataStr)` հետևյալ խնդիրը լուծելու համար:\nՎերծանել թվերի շարք՝ բացահայտելու համար նախշը և հասկանալու համար, թե ինչ արժեքներ են ներկայացնում յուրաքանչյուր թվանշան: Նախշերը հետևյալն են՝ 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4։\n\nՊարամետրեր:\n- dataStr (string): Տող, որը ներկայացնում է թվերի շարք: Երկարությունը չի գերազանցում 100 նիշը:\n\nՎերադարձնում է:\n- number: Արդյունքը, որը համապատասխանում է յուրաքանչյուր տվյալ տողին ըստ նախշի:\n\nՕրինակ օգտագործում:\nconsole.assert(f_14(\"0000\") === 4);", "bn": "একটি জাভাস্ক্রিপ্ট ফাংশন `function f_14(dataStr)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nসংখ্যার একটি সিরিজ ডিকোড করুন প্যাটার্ন প্রকাশ করার জন্য এবং প্রতিটি অঙ্ক আসলে কী মান উপস্থাপন করে তা বোঝার জন্য। প্যাটার্নগুলি নিম্নরূপ: 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4।\n\nপ্যারামিটারসমূহ:\n- dataStr (string): একটি স্ট্রিং যা সংখ্যার একটি সিরিজ উপস্থাপন করে। দৈর্ঘ্য 100 অক্ষরের বেশি নয়।\n\nরিটার্নস:\n- number: প্রতিটি ডেটা স্ট্রিং অনুযায়ী প্যাটার্নের ফলাফল।\n\nউদাহরণ ব্যবহার:\nconsole.assert(f_14(\"0000\") === 4);", "bg": "Напишете функция на JavaScript `function f_14(dataStr)`, за да решите следния проблем:\nДекодирайте серия от числа, за да разкриете шаблона и да разберете действителните стойности, които представлява всяка цифра. Шаблоните са както следва: 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n\nПараметри:\n- dataStr (string): Низ, представляващ серия от числа. Дължината не надвишава 100 знака.\n\nВръща:\n- number: Резултатът, съответстващ на всеки низ от данни според шаблона.\n\nПример за използване:\nconsole.assert(f_14(\"0000\") === 4);", "zh": "编写一个 JavaScript 函数 `function f_14(dataStr)` 来解决以下问题：\n解码一系列数字以揭示模式并理解每个数字代表的实际值。模式如下：0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4。\n\n参数：\n- dataStr (string): 一个表示一系列数字的字符串。长度不超过 100 个字符。\n\n返回：\n- number: 根据模式对应于每个数据字符串的结果。\n\n示例用法：\nconsole.assert(f_14(\"0000\") === 4);", "fr": "Écrire une fonction JavaScript `function f_14(dataStr)` pour résoudre le problème suivant :\nDécoder une série de chiffres pour révéler le motif et comprendre les valeurs réelles que chaque chiffre représente. Les motifs sont les suivants : 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n\nParamètres :\n- dataStr (string) : Une chaîne représentant une série de chiffres. La longueur ne dépasse pas 100 caractères.\n\nRenvoie :\n- number : Le résultat correspondant à chaque chaîne de données selon le motif.\n\nExemple d'utilisation :\nconsole.assert(f_14(\"0000\") === 4);", "de": "Schreiben Sie eine JavaScript-Funktion `function f_14(dataStr)`, um das folgende Problem zu lösen:\nDekodieren Sie eine Serie von Zahlen, um das Muster zu erkennen und die tatsächlichen Werte zu verstehen, die jede Ziffer darstellt. Die Muster sind wie folgt: 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n\nParameter:\n- dataStr (string): Ein String, der eine Serie von Zahlen darstellt. Die Länge überschreitet nicht 100 Zeichen.\n\nRückgabewert:\n- number: Das Ergebnis, das der jeweiligen Datenzeichenfolge gemäß dem Muster entspricht.\n\nBeispielverwendung:\nconsole.assert(f_14(\"0000\") === 4);", "ha": "Rubuta wani aikin JavaScript `function f_14(dataStr)` don warware matsalar mai zuwa:\nFassara jerin lambobi don bayyana tsarin kuma fahimtar ainihin ƙimar kowace lamba da aka wakilta. Tsarin sune kamar haka: 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n\nSigogi:\n- dataStr (string): Wani kirtani da ke wakiltar jerin lambobi. Tsawon ba zai wuce haruffa 100 ba.\n\nDawowa:\n- number: Sakamakon da ya dace da kowane kirtani na bayanai bisa tsarin.\n\nMisalin amfani:\nconsole.assert(f_14(\"0000\") === 4);", "hi": "`function f_14(dataStr)` फ़ंक्शन लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nसंख्याओं की एक श्रृंखला को डिकोड करें ताकि पैटर्न का पता चल सके और समझ सकें कि प्रत्येक अंक का वास्तविक मान क्या दर्शाता है। पैटर्न निम्नलिखित हैं: 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4।\n\nपैरामीटर्स:\n- dataStr (string): संख्याओं की एक श्रृंखला का प्रतिनिधित्व करने वाला एक स्ट्रिंग। लंबाई 100 वर्णों से अधिक नहीं है।\n\nवापसी:\n- number: पैटर्न के अनुसार प्रत्येक डेटा स्ट्रिंग के अनुरूप परिणाम।\n\nउदाहरण उपयोग:\nconsole.assert(f_14(\"0000\") === 4);", "hu": "Írj egy JavaScript függvényt `function f_14(dataStr)` a következő probléma megoldására:  \nDekódolj egy számsorozatot, hogy felfedd a mintát és megértsd, hogy az egyes számjegyek valójában mit képviselnek. A minták a következők: 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n\nParaméterek:\n- dataStr (string): Egy számsorozatot reprezentáló karakterlánc. A hossza nem haladja meg a 100 karaktert.\n\nVisszatérési érték:\n- number: Az eredmény, amely megfelel az egyes adatkarakterláncoknak a minta szerint.\n\nPélda használat:\nconsole.assert(f_14(\"0000\") === 4);", "es": "Escribe una función de JavaScript `function f_14(dataStr)` para resolver el siguiente problema:\nDecodifica una serie de números para revelar el patrón y entender los valores reales que representa cada dígito. Los patrones son los siguientes: 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n\nParámetros:\n- dataStr (string): Una cadena que representa una serie de números. La longitud no excede los 100 caracteres.\n\nDevuelve:\n- number: El resultado correspondiente a cada cadena de datos según el patrón.\n\nEjemplo de uso:\nconsole.assert(f_14(\"0000\") === 4);", "arb": "اكتب دالة JavaScript `function f_14(dataStr)` لحل المشكلة التالية:\nفك تشفير سلسلة من الأرقام للكشف عن النمط وفهم القيم الفعلية التي يمثلها كل رقم. الأنماط هي كما يلي: 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n\nالمعطيات:\n- dataStr (string): سلسلة تمثل سلسلة من الأرقام. الطول لا يتجاوز 100 حرف.\n\nالإرجاع:\n- number: النتيجة المقابلة لكل سلسلة بيانات وفقًا للنمط.\n\nمثال على الاستخدام:\nconsole.assert(f_14(\"0000\") === 4);", "sw": "Andika kazi ya JavaScript `function f_14(dataStr)` kutatua tatizo lifuatalo:\nFasiri mfululizo wa nambari ili kufichua muundo na kuelewa thamani halisi ambayo kila tarakimu inawakilisha. Mifumo ni kama ifuatavyo: 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n\nVigezo:\n- dataStr (string): Kamba inayowakilisha mfululizo wa nambari. Urefu hauzidi herufi 100.\n\nInarudisha:\n- number: Matokeo yanayolingana na kila kamba ya data kulingana na muundo.\n\nMfano wa matumizi:\nconsole.assert(f_14(\"0000\") === 4);", "tr": "Bir JavaScript fonksiyonu `function f_14(dataStr)` yazın ve aşağıdaki problemi çözün:\nBir dizi numarayı çözerek deseni ortaya çıkarın ve her bir rakamın temsil ettiği gerçek değerleri anlayın. Desenler aşağıdaki gibidir: 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n\nParametreler:\n- dataStr (string): Bir dizi numarayı temsil eden bir string. Uzunluğu 100 karakteri geçmez.\n\nDöndürür:\n- number: Desene göre her bir veri dizesine karşılık gelen sonuç.\n\nÖrnek kullanım:\nconsole.assert(f_14(\"0000\") === 4);", "vi": "Viết một hàm JavaScript `function f_14(dataStr)` để giải quyết vấn đề sau:\nGiải mã một chuỗi số để tiết lộ mẫu và hiểu các giá trị thực tế mà mỗi chữ số đại diện. Các mẫu là như sau: 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n\nTham số:\n- dataStr (string): Một chuỗi đại diện cho một loạt các số. Độ dài không vượt quá 100 ký tự.\n\nTrả về:\n- number: Kết quả tương ứng với mỗi chuỗi dữ liệu theo mẫu.\n\nVí dụ sử dụng:\nconsole.assert(f_14(\"0000\") === 4);", "id": "Tulis sebuah fungsi JavaScript `function f_14(dataStr)` untuk menyelesaikan masalah berikut:\nDekode serangkaian angka untuk mengungkap pola dan memahami nilai sebenarnya yang diwakili oleh setiap digit. Pola-pola tersebut adalah sebagai berikut: 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n\nParameter:\n- dataStr (string): Sebuah string yang mewakili serangkaian angka. Panjangnya tidak melebihi 100 karakter.\n\nMengembalikan:\n- number: Hasil yang sesuai dengan setiap string data sesuai pola.\n\nContoh penggunaan:\nconsole.assert(f_14(\"0000\") === 4);", "ja": "JavaScript関数 `function f_14(dataStr)` を作成して、次の問題を解決してください:\n数字のシリーズをデコードしてパターンを明らかにし、各桁が表す実際の値を理解します。パターンは次の通りです: 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4。\n\nパラメータ:\n- dataStr (string): 一連の数字を表す文字列。長さは100文字を超えません。\n\n戻り値:\n- number: パターンに従って各データ文字列に対応する結果。\n\n使用例:\nconsole.assert(f_14(\"0000\") === 4);", "ko": "JavaScript 함수 `function f_14(dataStr)`를 작성하여 다음 문제를 해결하십시오:\n일련의 숫자를 디코드하여 패턴을 밝히고 각 숫자가 나타내는 실제 값을 이해하십시오. 패턴은 다음과 같습니다: 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n\n매개변수:\n- dataStr (string): 숫자 시리즈를 나타내는 문자열입니다. 길이는 100자를 초과하지 않습니다.\n\n반환값:\n- number: 패턴에 따라 각 데이터 문자열에 해당하는 결과입니다.\n\n사용 예:\nconsole.assert(f_14(\"0000\") === 4);", "ml": "`function f_14(dataStr)` എന്ന ജാവാസ്ക്രിപ്റ്റ് ഫങ്ഷൻ എഴുതുക താഴെ കൊടുത്തിരിക്കുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nസംഖ്യകളുടെ ഒരു ശ്രേണി ഡികോഡ് ചെയ്ത് മാതൃക വെളിപ്പെടുത്തുകയും ഓരോ അക്കവും പ്രതിനിധീകരിക്കുന്ന യഥാർത്ഥ മൂല്യങ്ങൾ മനസ്സിലാക്കുകയും ചെയ്യുക. മാതൃകകൾ ചുവടെ കൊടുത്തിരിക്കുന്നു: 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n\nപാരാമീറ്ററുകൾ:\n- dataStr (string): ഒരു സംഖ്യകളുടെ ശ്രേണിയെ പ്രതിനിധീകരിക്കുന്ന ഒരു സ്ട്രിംഗ്. നീളം 100 പ്രതീകങ്ങളെ കവിയില്ല.\n\nമടക്കുക:\n- number: മാതൃക അനുസരിച്ച് ഓരോ ഡാറ്റ സ്ട്രിംഗിനും അനുയോജ്യമായ ഫലം.\n\nഉദാഹരണ ഉപയോഗം:\nconsole.assert(f_14(\"0000\") === 4);", "fa": "یک تابع جاوااسکریپت `function f_14(dataStr)` بنویسید تا مسئله زیر را حل کند:\nیک سری از اعداد را رمزگشایی کنید تا الگو را آشکار کرده و مقادیر واقعی که هر رقم نشان می‌دهد را درک کنید. الگوها به شرح زیر هستند: 0000=4، 8888=8، 1234=1، 5678=3، 9012=2، 1357=0، 2468=4.\n\nپارامترها:\n- dataStr (string): یک رشته که نشان‌دهنده یک سری از اعداد است. طول آن از 100 کاراکتر تجاوز نمی‌کند.\n\nبازگشت:\n- number: نتیجه‌ای که با توجه به الگو برای هر رشته داده‌ای مطابقت دارد.\n\nمثال استفاده:\nconsole.assert(f_14(\"0000\") === 4);"}, "level": "easy", "test": "function testf_14() {\n    console.assert(f_14(\"0000\") === 4, \"Test 0000 failed\");\n    console.assert(f_14(\"8888\") === 8, \"Test 8888 failed\");\n    console.assert(f_14(\"1234\") === 1, \"Test 1234 failed\");\n    console.assert(f_14(\"5678\") === 3, \"Test 5678 failed\");\n    console.assert(f_14(\"9012\") === 2, \"Test 9012 failed\");\n    console.assert(f_14(\"1357\") === 0, \"Test 1357 failed\");\n    console.assert(f_14(\"2468\") === 4, \"Test 2468 failed\");\n\n    // Additional test samples\n    console.assert(f_14(\"9999\") === 4, \"Test 9999 failed\");\n    console.assert(f_14(\"1111\") === 0, \"Test 1111 failed\");\n    console.assert(f_14(\"2222\") === 0, \"Test 2222 failed\");\n    console.assert(f_14(\"3333\") === 0, \"Test 3333 failed\");\n    console.assert(f_14(\"4444\") === 4, \"Test 4444 failed\");\n    console.assert(f_14(\"5555\") === 0, \"Test 5555 failed\");\n    console.assert(f_14(\"6666\") === 4, \"Test 6666 failed\");\n    console.assert(f_14(\"7777\") === 0, \"Test 7777 failed\");\n    console.assert(f_14(\"0001\") === 3, \"Test 0001 failed\");\n    console.assert(f_14(\"2301\") === 1, \"Test 2301 failed\");\n}\n\ntestf_14();", "entry_point": "f_14", "signature": "function f_14(dataStr)", "docstring": {"en": "Decode a series of numbers to reveal the pattern and understand the actual values each digit represents. The patterns are as follows: 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n\nParameters:\n- dataStr (string): A string representing a series of numbers. The length does not exceed 100 characters.\n\nReturns:\n- number: The result corresponding to each data string as per the pattern.\n\nExample usage:\nconsole.assert(f_14(\"0000\") === 4);", "sq": "Dekodo një seri numrash për të zbuluar modelin dhe për të kuptuar vlerat aktuale që përfaqëson secili shifër. Modelet janë si më poshtë: 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n\nParametrat:\n- dataStr (string): Një varg që përfaqëson një seri numrash. Gjatësia nuk i kalon 100 karaktere.\n\nKthen:\n- number: Rezultati që korrespondon me secilin varg të dhënash sipas modelit.\n\nShembull përdorimi:\nconsole.assert(f_14(\"0000\") === 4);", "hy": "Թվերի շարք վերծանեք՝ բացահայտելու համար օրինաչափությունը և հասկանալու համար, թե իրականում ինչ արժեքներ են ներկայացնում յուրաքանչյուր թվանշան: Օրինաչափությունները հետևյալն են՝ 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4։\n\nՊարամետրեր:\n- dataStr (string): Թվերի շարքը ներկայացնող տող։ Երկարությունը չի գերազանցում 100 նիշը։\n\nՎերադարձնում է:\n- number: Արդյունքը, որը համապատասխանում է յուրաքանչյուր տվյալ տողի՝ ըստ օրինաչափության։\n\nՕրինակ օգտագործում:\nconsole.assert(f_14(\"0000\") === 4);", "bn": "সংখ্যার একটি সিরিজ ডিকোড করুন প্যাটার্ন প্রকাশ করার জন্য এবং প্রতিটি অঙ্ক আসলে কী মান উপস্থাপন করে তা বোঝার জন্য। প্যাটার্নগুলি নিম্নরূপ: 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4।\n\nপ্যারামিটারসমূহ:\n- dataStr (string): সংখ্যার একটি সিরিজকে উপস্থাপনকারী একটি স্ট্রিং। দৈর্ঘ্য 100 অক্ষরের বেশি নয়।\n\nরিটার্নস:\n- number: প্রতিটি ডেটা স্ট্রিংয়ের জন্য প্যাটার্ন অনুযায়ী ফলাফল।\n\nউদাহরণ ব্যবহার:\nconsole.assert(f_14(\"0000\") === 4);", "bg": "Декодирайте серия от числа, за да разкриете модела и да разберете действителните стойности, които всяка цифра представлява. Моделите са както следва: 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n\nПараметри:\n- dataStr (string): Низ, представляващ серия от числа. Дължината не надвишава 100 символа.\n\nВръща:\n- number: Резултатът, съответстващ на всеки низ от данни според модела.\n\nПример за използване:\nconsole.assert(f_14(\"0000\") === 4);", "zh": "解码一系列数字以揭示模式并理解每个数字代表的实际值。模式如下：0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4。\n\n参数：\n- dataStr (string): 表示一系列数字的字符串。长度不超过100个字符。\n\n返回：\n- number: 根据模式对应每个数据字符串的结果。\n\n示例用法：\nconsole.assert(f_14(\"0000\") === 4);", "fr": "Décoder une série de chiffres pour révéler le motif et comprendre les valeurs réelles que chaque chiffre représente. Les motifs sont les suivants : 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n\nParamètres :\n- dataStr (string): Une chaîne représentant une série de chiffres. La longueur ne dépasse pas 100 caractères.\n\nRenvoie :\n- number: Le résultat correspondant à chaque chaîne de données selon le motif.\n\nExemple d'utilisation :\nconsole.assert(f_14(\"0000\") === 4);", "de": "Dekodiere eine Serie von Zahlen, um das Muster zu erkennen und die tatsächlichen Werte zu verstehen, die jede Ziffer darstellt. Die Muster sind wie folgt: 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n\nParameter:\n- dataStr (string): Ein String, der eine Serie von Zahlen darstellt. Die Länge überschreitet nicht 100 Zeichen.\n\nRückgabewert:\n- number: Das Ergebnis, das der jeweiligen Datenreihe gemäß dem Muster entspricht.\n\nBeispielverwendung:\nconsole.assert(f_14(\"0000\") === 4);", "ha": "Fassara jerin lambobi don bayyana tsarin kuma fahimtar ainihin ƙimar kowace lamba da aka wakilta. Tsarin suna kamar haka: 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n\nSigogi:\n- dataStr (string): Wani kirtani da ke wakiltar jerin lambobi. Tsawon ba ya wuce haruffa 100.\n\nDawowa:\n- number: Sakamakon da ya dace da kowanne kirtani na bayanai bisa tsarin.\n\nMisalin amfani:\nconsole.assert(f_14(\"0000\") === 4);", "hi": "संख्याओं की एक श्रृंखला को डिकोड करें ताकि पैटर्न का पता चल सके और समझ सकें कि प्रत्येक अंक का वास्तविक मान क्या दर्शाता है। पैटर्न इस प्रकार हैं: 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n\nपैरामीटर्स:\n- dataStr (string): एक स्ट्रिंग जो संख्याओं की एक श्रृंखला का प्रतिनिधित्व करती है। लंबाई 100 वर्णों से अधिक नहीं होती है।\n\nरिटर्न:\n- number: पैटर्न के अनुसार प्रत्येक डेटा स्ट्रिंग के अनुरूप परिणाम।\n\nउदाहरण उपयोग:\nconsole.assert(f_14(\"0000\") === 4);", "hu": "Dekódoljon egy számok sorozatát, hogy felfedje a mintát és megértse, hogy az egyes számjegyek valójában milyen értékeket képviselnek. A minták a következők: 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n\nParaméterek:\n- dataStr (string): Egy számok sorozatát reprezentáló karakterlánc. A hossza nem haladja meg a 100 karaktert.\n\nVisszatérési érték:\n- number: Az eredmény, amely megfelel az egyes adatkarakterláncoknak a minta szerint.\n\nPélda használat:\nconsole.assert(f_14(\"0000\") === 4);", "es": "Decodificar una serie de números para revelar el patrón y entender los valores reales que representa cada dígito. Los patrones son los siguientes: 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n\nParámetros:\n- dataStr (string): Una cadena que representa una serie de números. La longitud no excede los 100 caracteres.\n\nDevuelve:\n- number: El resultado correspondiente a cada cadena de datos según el patrón.\n\nEjemplo de uso:\nconsole.assert(f_14(\"0000\") === 4);", "arb": "فك سلسلة من الأرقام للكشف عن النمط وفهم القيم الفعلية التي يمثلها كل رقم. الأنماط هي كما يلي: 0000=4، 8888=8، 1234=1، 5678=3، 9012=2، 1357=0، 2468=4.\n\nالمعطيات:\n- dataStr (string): سلسلة تمثل مجموعة من الأرقام. الطول لا يتجاوز 100 حرف.\n\nالقيم المعادة:\n- number: النتيجة المقابلة لكل سلسلة بيانات وفقًا للنمط.\n\nمثال على الاستخدام:\nconsole.assert(f_14(\"0000\") === 4);", "sw": "Fasiri mfululizo wa nambari ili kufichua muundo na kuelewa thamani halisi ambayo kila tarakimu inawakilisha. Mifumo ni kama ifuatavyo: 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n\nVigezo:\n- dataStr (string): Kamba inayowakilisha mfululizo wa nambari. Urefu hauzidi herufi 100.\n\nInarejesha:\n- number: Matokeo yanayolingana na kila kamba ya data kulingana na muundo.\n\nMfano wa matumizi:\nconsole.assert(f_14(\"0000\") === 4);", "tr": "Decode bir dizi sayıyı, deseni ortaya çıkarmak ve her bir rakamın temsil ettiği gerçek değerleri anlamak için çöz. Desenler aşağıdaki gibidir: 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n\nParametreler:\n- dataStr (string): Bir dizi sayıyı temsil eden bir dize. Uzunluğu 100 karakteri geçmez.\n\nDöndürür:\n- number: Desene göre her bir veri dizisine karşılık gelen sonuç.\n\nÖrnek kullanım:\nconsole.assert(f_14(\"0000\") === 4);", "vi": "Giải mã một chuỗi số để tiết lộ mẫu và hiểu các giá trị thực mà mỗi chữ số đại diện. Các mẫu như sau: 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n\nTham số:\n- dataStr (string): Một chuỗi đại diện cho một chuỗi số. Độ dài không vượt quá 100 ký tự.\n\nTrả về:\n- number: Kết quả tương ứng với mỗi chuỗi dữ liệu theo mẫu.\n\nVí dụ sử dụng:\nconsole.assert(f_14(\"0000\") === 4);", "id": "Decode serangkaian angka untuk mengungkap pola dan memahami nilai sebenarnya yang diwakili setiap digit. Pola-pola tersebut adalah sebagai berikut: 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n\nParameter:\n- dataStr (string): Sebuah string yang mewakili serangkaian angka. Panjangnya tidak melebihi 100 karakter.\n\nMengembalikan:\n- number: Hasil yang sesuai dengan setiap string data sesuai dengan pola.\n\nContoh penggunaan:\nconsole.assert(f_14(\"0000\") === 4);", "ja": "数字の一連をデコードしてパターンを明らかにし、各桁が表す実際の値を理解します。パターンは次の通りです: 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4。\n\n引数:\n- dataStr (string): 数字の一連を表す文字列。長さは100文字を超えません。\n\n戻り値:\n- number: パターンに従って各データ文字列に対応する結果。\n\n使用例:\nconsole.assert(f_14(\"0000\") === 4);", "ko": "숫자 시리즈를 해독하여 패턴을 밝히고 각 숫자가 나타내는 실제 값을 이해합니다. 패턴은 다음과 같습니다: 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n\n매개변수:\n- dataStr (string): 숫자 시리즈를 나타내는 문자열입니다. 길이는 100자를 초과하지 않습니다.\n\n반환:\n- number: 패턴에 따라 각 데이터 문자열에 해당하는 결과입니다.\n\n사용 예:\nconsole.assert(f_14(\"0000\") === 4);", "ml": "സംഖ്യകളുടെ ഒരു ശ്രേണി ഡികോഡ് ചെയ്ത് മാതൃക വെളിപ്പെടുത്തുകയും ഓരോ അക്കവും പ്രതിനിധീകരിക്കുന്ന യഥാർത്ഥ മൂല്യങ്ങൾ മനസ്സിലാക്കുകയും ചെയ്യുക.\n * മാതൃകകൾ ചുവടെപ്പറയുന്നവയാണ്:\n * 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n\nപാരാമീറ്ററുകൾ:\n- dataStr (string): ഒരു സംഖ്യകളുടെ ശ്രേണിയെ പ്രതിനിധീകരിക്കുന്ന ഒരു സ്ട്രിംഗ്. നീളം 100 പ്രതീകങ്ങളെ കവിയില്ല.\n\nമടക്കുന്നു:\n- number: പാറ്റേൺ അനുസരിച്ച് ഓരോ ഡാറ്റ സ്ട്രിംഗിനും അനുബന്ധിക്കുന്ന ഫലവും.\n\nഉദാഹരണ ഉപയോഗം:\nconsole.assert(f_14(\"0000\") === 4);", "fa": "رمزگشایی یک سری اعداد برای آشکارسازی الگو و درک مقادیر واقعی\n * که هر رقم نشان می‌دهد. الگوها به شرح زیر هستند:\n * 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n\nپارامترها:\n- dataStr (رشته): رشته‌ای که یک سری از اعداد را نشان می‌دهد. طول آن از 100 کاراکتر تجاوز نمی‌کند.\n\nبازگشت:\n- عدد: نتیجه‌ای که مطابق با هر رشته داده بر اساس الگو است.\n\nمثال استفاده:\nconsole.assert(f_14(\"0000\") === 4);"}}
{"task_id": "JavaScript/15", "prompt": {"en": "// No need to import modules in JavaScript like in C\n/**\n * Counts the number of different coloring methods for n squares with m colors,\n * considering the requirement that adjacent squares and the first/last squares\n * must have different colors.\n * @param {number} n - The number of squares.\n * @param {number} m - The number of colors.\n * @return {number} The count of different coloring methods satisfying the conditions,\n *                  result is modulo 1000003.\n * Example:\n * f_15(1,1) // 1\n * f_15(2,3) // 6\n */\nfunction f_15(n, m)", "sq": "// Nuk ka nevojë të importohen module në JavaScript si në C\n/**\n * Numëron numrin e metodave të ndryshme të ngjyrosjes për n katrorë me m ngjyra,\n * duke marrë parasysh kërkesën që katrorët ngjitur dhe katrorët e parë/fundit\n * duhet të kenë ngjyra të ndryshme.\n * @param {number} n - Numri i katrorëve.\n * @param {number} m - Numri i ngjyrave.\n * @return {number} Numri i metodave të ndryshme të ngjyrosjes që plotësojnë kushtet,\n *                  rezultati është modulo 1000003.\n * Shembull:\n * f_15(1,1) // 1\n * f_15(2,3) // 6\n */\nfunction f_15(n, m)", "hy": "// JavaScript-ում անհրաժեշտ չէ մոդուլներ ներմուծել ինչպես C-ում\n/**\n * Հաշվում է n քառակուսիների համար տարբեր ներկման մեթոդների քանակը m գույներով,\n * հաշվի առնելով այն պահանջը, որ հարակից քառակուսիները և առաջին/վերջին քառակուսիները\n * պետք է ունենան տարբեր գույներ։\n * @param {number} n - Քառակուսիների քանակը։\n * @param {number} m - Գույների քանակը։\n * @return {number} Տարբեր ներկման մեթոդների քանակը, որոնք բավարարում են պայմաններին,\n *                  արդյունքը մոդուլ 1000003։\n * Օրինակ:\n * f_15(1,1) // 1\n * f_15(2,3) // 6\n */\nfunction f_15(n, m)", "bn": "// জাভাস্ক্রিপ্টে সি এর মতো মডিউল আমদানি করার প্রয়োজন নেই\n/**\n * n টি বর্গক্ষেত্র এবং m টি রঙের জন্য বিভিন্ন রঙ করার পদ্ধতির সংখ্যা গণনা করে,\n * শর্তটি বিবেচনা করে যে সংলগ্ন বর্গক্ষেত্র এবং প্রথম/শেষ বর্গক্ষেত্রের রঙ ভিন্ন হতে হবে।\n * @param {number} n - বর্গক্ষেত্রের সংখ্যা।\n * @param {number} m - রঙের সংখ্যা।\n * @return {number} শর্তগুলি পূরণ করে এমন বিভিন্ন রঙ করার পদ্ধতির সংখ্যা,\n *                  ফলাফল 1000003 দ্বারা মডুলো।\n * উদাহরণ:\n * f_15(1,1) // 1\n * f_15(2,3) // 6\n */\nfunction f_15(n, m)", "bg": "// Няма нужда от импортиране на модули в JavaScript както в C\n/**\n * Брои броя на различните методи за оцветяване на n квадрата с m цвята,\n * като се взема предвид изискването съседните квадрати и първият/последният квадрат\n * да имат различни цветове.\n * @param {number} n - Броят на квадратите.\n * @param {number} m - Броят на цветовете.\n * @return {number} Броят на различните методи за оцветяване, които удовлетворяват условията,\n *                  резултатът е модуло 1000003.\n * Пример:\n * f_15(1,1) // 1\n * f_15(2,3) // 6\n */", "zh": "// 不需要像在 C 中那样在 JavaScript 中导入模块\n/**\n * 计算使用 m 种颜色对 n 个方块进行不同着色的方法数，\n * 考虑到相邻方块和第一个/最后一个方块必须有不同颜色的要求。\n * @param {number} n - 方块的数量。\n * @param {number} m - 颜色的数量。\n * @return {number} 满足条件的不同着色方法的数量，\n *                  结果取模 1000003。\n * 示例:\n * f_15(1,1) // 1\n * f_15(2,3) // 6\n */\nfunction f_15(n, m)", "fr": "// Pas besoin d'importer des modules en JavaScript comme en C\n/**\n * Compte le nombre de méthodes de coloration différentes pour n carrés avec m couleurs,\n * en considérant l'exigence que les carrés adjacents et les premiers/derniers carrés\n * doivent avoir des couleurs différentes.\n * @param {number} n - Le nombre de carrés.\n * @param {number} m - Le nombre de couleurs.\n * @return {number} Le compte des différentes méthodes de coloration satisfaisant les conditions,\n *                  le résultat est modulo 1000003.\n * Exemple:\n * f_15(1,1) // 1\n * f_15(2,3) // 6\n */\nfunction f_15(n, m)", "de": "// Kein Bedarf, Module in JavaScript wie in C zu importieren\n/**\n * Zählt die Anzahl der verschiedenen Färbemethoden für n Quadrate mit m Farben,\n * unter Berücksichtigung der Anforderung, dass benachbarte Quadrate und die ersten/letzten Quadrate\n * unterschiedliche Farben haben müssen.\n * @param {number} n - Die Anzahl der Quadrate.\n * @param {number} m - Die Anzahl der Farben.\n * @return {number} Die Anzahl der verschiedenen Färbemethoden, die die Bedingungen erfüllen,\n *                  Ergebnis ist modulo 1000003.\n * Beispiel:\n * f_15(1,1) // 1\n * f_15(2,3) // 6\n */\nfunction f_15(n, m)", "ha": "// Babu buƙatar shigo da modules a JavaScript kamar yadda ake yi a C\n/**\n * Yana ƙidaya adadin hanyoyin canza launi daban-daban don murabba'i n tare da launuka m,\n * la'akari da buƙatar cewa murabba'i masu makwabtaka da murabba'i na farko/na ƙarshe\n * dole ne su kasance da launuka daban-daban.\n * @param {number} n - Yawan murabba'ai.\n * @param {number} m - Yawan launuka.\n * @return {number} Adadin hanyoyin canza launi daban-daban da suka cika sharuɗɗan,\n *                  sakamakon yana modulo 1000003.\n * Misali:\n * f_15(1,1) // 1\n * f_15(2,3) // 6\n */\nfunction f_15(n, m)", "hi": "// JavaScript में C की तरह मॉड्यूल आयात करने की आवश्यकता नहीं है\n/**\n * n वर्गों के लिए m रंगों के विभिन्न रंगाई तरीकों की संख्या गिनता है,\n * इस आवश्यकता को ध्यान में रखते हुए कि आसन्न वर्गों और पहले/अंतिम वर्गों के\n * रंग अलग-अलग होने चाहिए।\n * @param {number} n - वर्गों की संख्या।\n * @param {number} m - रंगों की संख्या।\n * @return {number} विभिन्न रंगाई तरीकों की संख्या जो शर्तों को संतुष्ट करती है,\n *                  परिणाम 1000003 के माड्यूलो में है।\n * उदाहरण:\n * f_15(1,1) // 1\n * f_15(2,3) // 6\n */", "hu": "// Nincs szükség modulok importálására JavaScriptben, mint C-ben\n/**\n * Megszámolja a különböző színezési módszerek számát n négyzetre m színnel,\n * figyelembe véve azt a követelményt, hogy a szomszédos négyzetek és az első/utolsó négyzetek\n * különböző színűek legyenek.\n * @param {number} n - A négyzetek száma.\n * @param {number} m - A színek száma.\n * @return {number} A különböző színezési módszerek száma, amelyek megfelelnek a feltételeknek,\n *                  az eredmény modulo 1000003.\n * Példa:\n * f_15(1,1) // 1\n * f_15(2,3) // 6\n */", "es": "// No es necesario importar módulos en JavaScript como en C\n/**\n * Cuenta el número de diferentes métodos de coloreado para n cuadrados con m colores,\n * considerando el requisito de que los cuadrados adyacentes y los primeros/últimos cuadrados\n * deben tener colores diferentes.\n * @param {number} n - El número de cuadrados.\n * @param {number} m - El número de colores.\n * @return {number} El conteo de diferentes métodos de coloreado que satisfacen las condiciones,\n *                  el resultado es módulo 1000003.\n * Ejemplo:\n * f_15(1,1) // 1\n * f_15(2,3) // 6\n */\nfunction f_15(n, m)", "arb": "// لا حاجة لاستيراد الوحدات في JavaScript كما في C\n/**\n * يحسب عدد طرق التلوين المختلفة لـ n من المربعات باستخدام m من الألوان،\n * مع مراعاة الشرط بأن المربعات المتجاورة والمربعات الأولى/الأخيرة\n * يجب أن تكون بألوان مختلفة.\n * @param {number} n - عدد المربعات.\n * @param {number} m - عدد الألوان.\n * @return {number} عدد طرق التلوين المختلفة التي تلبي الشروط،\n *                  النتيجة هي باقي القسمة على 1000003.\n * مثال:\n * f_15(1,1) // 1\n * f_15(2,3) // 6\n */\nfunction f_15(n, m)", "sw": "// Hakuna haja ya kuingiza moduli katika JavaScript kama ilivyo katika C\n/**\n * Inahesabu idadi ya mbinu tofauti za kupaka rangi mraba n kwa rangi m,\n * ikizingatia sharti kwamba miraba iliyo karibu na miraba ya kwanza/ya mwisho\n * lazima iwe na rangi tofauti.\n * @param {number} n - Idadi ya miraba.\n * @param {number} m - Idadi ya rangi.\n * @return {number} Idadi ya mbinu tofauti za kupaka rangi zinazokidhi masharti,\n *                  matokeo ni modulo 1000003.\n * Mfano:\n * f_15(1,1) // 1\n * f_15(2,3) // 6\n */\nfunction f_15(n, m)", "tr": "// JavaScript'te C'deki gibi modülleri içe aktarmaya gerek yok\n/**\n * n kare için m renk ile farklı boyama yöntemlerinin sayısını sayar,\n * bitişik karelerin ve ilk/son karelerin farklı renklere sahip olma gereksinimini dikkate alarak.\n * @param {number} n - Karelerin sayısı.\n * @param {number} m - Renklerin sayısı.\n * @return {number} Koşulları karşılayan farklı boyama yöntemlerinin sayısı,\n *                  sonuç 1000003 ile mod alınır.\n * Örnek:\n * f_15(1,1) // 1\n * f_15(2,3) // 6\n */\nfunction f_15(n, m)", "vi": "// Không cần nhập các mô-đun trong JavaScript như trong C\n/**\n * Đếm số lượng phương pháp tô màu khác nhau cho n ô vuông với m màu,\n * xem xét yêu cầu rằng các ô vuông liền kề và ô đầu/cuối\n * phải có màu khác nhau.\n * @param {number} n - Số lượng ô vuông.\n * @param {number} m - Số lượng màu.\n * @return {number} Số lượng phương pháp tô màu khác nhau thỏa mãn các điều kiện,\n *                  kết quả là modulo 1000003.\n * Ví dụ:\n * f_15(1,1) // 1\n * f_15(2,3) // 6\n */\nfunction f_15(n, m)", "id": "// Tidak perlu mengimpor modul dalam JavaScript seperti di C\n/**\n * Menghitung jumlah metode pewarnaan berbeda untuk n kotak dengan m warna,\n * dengan mempertimbangkan persyaratan bahwa kotak yang bersebelahan dan kotak pertama/terakhir\n * harus memiliki warna yang berbeda.\n * @param {number} n - Jumlah kotak.\n * @param {number} m - Jumlah warna.\n * @return {number} Jumlah metode pewarnaan berbeda yang memenuhi kondisi,\n *                  hasil adalah modulo 1000003.\n * Contoh:\n * f_15(1,1) // 1\n * f_15(2,3) // 6\n */\nfunction f_15(n, m)", "ja": "// JavaScriptではCのようにモジュールをインポートする必要はありません\n/**\n * n個の正方形をm色で塗る異なる方法の数を数えます。\n * 隣接する正方形および最初/最後の正方形が異なる色である必要があるという条件を考慮します。\n * @param {number} n - 正方形の数。\n * @param {number} m - 色の数。\n * @return {number} 条件を満たす異なる塗り方の数、結果は1000003でのモジュロです。\n * 例:\n * f_15(1,1) // 1\n * f_15(2,3) // 6\n */\nfunction f_15(n, m)", "ko": "// JavaScript에서는 C처럼 모듈을 가져올 필요가 없습니다.\n/**\n * n개의 사각형을 m개의 색상으로 칠하는 서로 다른 방법의 수를 계산합니다.\n * 인접한 사각형과 첫 번째/마지막 사각형이 다른 색상이어야 한다는 요구 사항을 고려합니다.\n * @param {number} n - 사각형의 수.\n * @param {number} m - 색상의 수.\n * @return {number} 조건을 만족하는 서로 다른 색칠 방법의 수,\n *                  결과는 1000003으로 나눈 나머지입니다.\n * 예시:\n * f_15(1,1) // 1\n * f_15(2,3) // 6\n */\nfunction f_15(n, m)", "ml": "// C ലെ പോലെ JavaScript ൽ മോഡ്യൂളുകൾ ഇറക്കുമതി ചെയ്യേണ്ടതില്ല\n/**\n * n ചതുരങ്ങൾ m നിറങ്ങളുമായി വ്യത്യസ്തമായ നിറങ്ങൾ നൽകുന്ന രീതികളുടെ എണ്ണം എണ്ണുന്നു,\n * ചേർന്നിരിക്കുന്ന ചതുരങ്ങൾക്കും ആദ്യ/അവസാന ചതുരങ്ങൾക്കും വ്യത്യസ്ത നിറങ്ങൾ വേണം എന്ന ആവശ്യം പരിഗണിച്ച്.\n * @param {number} n - ചതുരങ്ങളുടെ എണ്ണം.\n * @param {number} m - നിറങ്ങളുടെ എണ്ണം.\n * @return {number} വ്യത്യസ്തമായ നിറങ്ങൾ നൽകുന്ന രീതികളുടെ എണ്ണം, \n *                  ഫലം 1000003 ന്റെ മോഡുലോ ആണ്.\n * ഉദാഹരണം:\n * f_15(1,1) // 1\n * f_15(2,3) // 6\n */\nfunction f_15(n, m)", "fa": "// نیازی به وارد کردن ماژول‌ها در جاوااسکریپت مانند C نیست\n/**\n * تعداد روش‌های مختلف رنگ‌آمیزی برای n مربع با m رنگ را محاسبه می‌کند،\n * با در نظر گرفتن این که مربع‌های مجاور و مربع‌های اول/آخر باید رنگ‌های متفاوتی داشته باشند.\n * @param {number} n - تعداد مربع‌ها.\n * @param {number} m - تعداد رنگ‌ها.\n * @return {number} تعداد روش‌های مختلف رنگ‌آمیزی که شرایط را برآورده می‌کنند،\n *                  نتیجه به پیمانه 1000003 است.\n * مثال:\n * f_15(1,1) // 1\n * f_15(2,3) // 6\n */\nfunction f_15(n, m)"}, "canonical_solution": "{\n    const MOD = 1000003;\n    let f = new Array(1111); // Array to store results\n    if (n === 1) return m;\n    if (n === 2) return (m * (m - 1)) % MOD;\n\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = (m * (m - 1)) % MOD;\n    // Formula derived from the given gold.c code\n    f[3] = (f[2] * (m - 2)) % MOD;\n\n    for (let i = 4; i <= n; i++) {\n        f[i] = ((f[i - 1] * (m - 2)) % MOD +\n                (f[i - 2] * (m - 1)) % MOD) % MOD;\n    }\n    return f[n];\n}", "instruction": {"en": "Write a JavaScript function `function f_15(n, m)` to solve the following problem:\nCounts the number of different coloring methods for n squares with m colors,\nconsidering the requirement that adjacent squares and the first/last squares\nmust have different colors.\nParameters:\n- n (number): The number of squares.\n- m (number): The number of colors.\nReturns:\n- number: The count of different coloring methods satisfying the conditions,\n           result is modulo 1000003.\nExample:\n- f_15(1,1) // 1\n- f_15(2,3) // 6", "sq": "Shkruani një funksion JavaScript `function f_15(n, m)` për të zgjidhur problemin në vijim:\nNumëron numrin e metodave të ndryshme të ngjyrosjes për n katrorë me m ngjyra,\nduke konsideruar kërkesën që katrorët ngjitur dhe katrorët e parë/fundit\nduhet të kenë ngjyra të ndryshme.\nParametrat:\n- n (numër): Numri i katrorëve.\n- m (numër): Numri i ngjyrave.\nKthen:\n- numër: Numri i metodave të ndryshme të ngjyrosjes që plotësojnë kushtet,\n           rezultati është modulo 1000003.\nShembull:\n- f_15(1,1) // 1\n- f_15(2,3) // 6", "hy": "Գրեք JavaScript ֆունկցիա `function f_15(n, m)` հետևյալ խնդիրը լուծելու համար:\nՀաշվում է n քառակուսիների տարբեր գունավորման մեթոդների քանակը m գույներով,\nհաշվի առնելով այն պահանջը, որ հարակից քառակուսիները և առաջին/վերջին քառակուսիները\nպետք է ունենան տարբեր գույներ:\nՊարամետրեր:\n- n (թիվ): Քառակուսիների քանակը:\n- m (թիվ): Գույների քանակը:\nՎերադարձնում է:\n- թիվ: Տարբեր գունավորման մեթոդների քանակը, որոնք բավարարում են պայմաններին,\n           արդյունքը մոդուլո 1000003:\nՕրինակ:\n- f_15(1,1) // 1\n- f_15(2,3) // 6", "bn": "একটি জাভাস্ক্রিপ্ট ফাংশন `function f_15(n, m)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nn টি বর্গক্ষেত্রের জন্য m টি রঙের বিভিন্ন রঙ করার পদ্ধতির সংখ্যা গণনা করে,\nপ্রতিবেশী বর্গক্ষেত্র এবং প্রথম/শেষ বর্গক্ষেত্রের রঙ ভিন্ন হওয়ার প্রয়োজনীয়তা বিবেচনা করে।\nপ্যারামিটারসমূহ:\n- n (number): বর্গক্ষেত্রের সংখ্যা।\n- m (number): রঙের সংখ্যা।\nফেরত দেয়:\n- number: বিভিন্ন রঙ করার পদ্ধতির সংখ্যা যা শর্তগুলি পূরণ করে,\n           ফলাফল 1000003 দ্বারা মডুলো।\nউদাহরণ:\n- f_15(1,1) // 1\n- f_15(2,3) // 6", "bg": "Напишете JavaScript функция `function f_15(n, m)` за решаване на следния проблем:\nБрои броя на различните методи за оцветяване на n квадрата с m цвята,\nкато се взема предвид изискването съседните квадрати и първият/последният квадрат\nда имат различни цветове.\nПараметри:\n- n (number): Броят на квадратите.\n- m (number): Броят на цветовете.\nВръща:\n- number: Броят на различните методи за оцветяване, които удовлетворяват условията,\n           резултатът е модуло 1000003.\nПример:\n- f_15(1,1) // 1\n- f_15(2,3) // 6", "zh": "编写一个 JavaScript 函数 `function f_15(n, m)` 来解决以下问题：\n计算使用 m 种颜色对 n 个方块进行不同着色的方法数，\n考虑到相邻方块以及第一个/最后一个方块必须具有不同颜色的要求。\n参数：\n- n (number): 方块的数量。\n- m (number): 颜色的数量。\n返回：\n- number: 满足条件的不同着色方法的数量，结果取模 1000003。\n示例：\n- f_15(1,1) // 1\n- f_15(2,3) // 6", "fr": "Écrire une fonction JavaScript `function f_15(n, m)` pour résoudre le problème suivant :\nCompte le nombre de méthodes de coloration différentes pour n carrés avec m couleurs,\nen considérant l'exigence que les carrés adjacents et les premiers/derniers carrés\ndoivent avoir des couleurs différentes.\nParamètres :\n- n (nombre) : Le nombre de carrés.\n- m (nombre) : Le nombre de couleurs.\nRenvoie :\n- nombre : Le compte des différentes méthodes de coloration satisfaisant les conditions,\n           le résultat est modulo 1000003.\nExemple :\n- f_15(1,1) // 1\n- f_15(2,3) // 6", "de": "Schreiben Sie eine JavaScript-Funktion `function f_15(n, m)`, um das folgende Problem zu lösen:\nZählt die Anzahl der verschiedenen Färbemethoden für n Quadrate mit m Farben,\nunter Berücksichtigung der Anforderung, dass benachbarte Quadrate und die ersten/letzten Quadrate\nunterschiedliche Farben haben müssen.\nParameter:\n- n (number): Die Anzahl der Quadrate.\n- m (number): Die Anzahl der Farben.\nRückgabe:\n- number: Die Anzahl der verschiedenen Färbemethoden, die die Bedingungen erfüllen,\n           das Ergebnis ist modulo 1000003.\nBeispiel:\n- f_15(1,1) // 1\n- f_15(2,3) // 6", "ha": "Rubuta wani aikin JavaScript `function f_15(n, m)` don warware matsalar mai zuwa:\nYana ƙidaya yawan hanyoyin launi daban-daban don murabba'i n tare da launuka m,\nla'akari da buƙatar cewa murabba'i masu makwabtaka da murabba'i na farko/karshe\ndole ne su sami launuka daban-daban.\nSigogi:\n- n (namba): Yawan murabba'ai.\n- m (namba): Yawan launuka.\nMayarwa:\n- namba: Adadin hanyoyin launi daban-daban da suka cika sharuɗɗan,\n           sakamakon yana modulo 1000003.\nMisali:\n- f_15(1,1) // 1\n- f_15(2,3) // 6", "hi": "JavaScript फ़ंक्शन `function f_15(n, m)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nn वर्गों के लिए m रंगों के विभिन्न रंगने के तरीकों की गिनती करता है,\nइस आवश्यकता को ध्यान में रखते हुए कि आसन्न वर्गों और पहले/अंतिम वर्गों के रंग अलग-अलग होने चाहिए।\nपैरामीटर्स:\n- n (संख्या): वर्गों की संख्या।\n- m (संख्या): रंगों की संख्या।\nवापसी:\n- संख्या: विभिन्न रंगने के तरीकों की गिनती जो शर्तों को संतुष्ट करती है,\n           परिणाम 1000003 से मॉड्यूलो है।\nउदाहरण:\n- f_15(1,1) // 1\n- f_15(2,3) // 6", "hu": "Írj egy JavaScript függvényt `function f_15(n, m)`, hogy megoldja a következő problémát:\nMegszámolja az n négyzet m színnel történő különböző színezési módszereit, figyelembe véve azt a követelményt, hogy a szomszédos négyzetek és az első/utolsó négyzetek különböző színűek legyenek.\nParaméterek:\n- n (szám): A négyzetek száma.\n- m (szám): A színek száma.\nVisszatér:\n- szám: A feltételeknek megfelelő különböző színezési módszerek száma, az eredmény modulo 1000003.\nPélda:\n- f_15(1,1) // 1\n- f_15(2,3) // 6", "es": "Escribe una función de JavaScript `function f_15(n, m)` para resolver el siguiente problema:\nCuenta el número de diferentes métodos de coloreo para n cuadrados con m colores,\nconsiderando el requisito de que los cuadrados adyacentes y los primeros/últimos cuadrados\ndeben tener colores diferentes.\nParámetros:\n- n (número): El número de cuadrados.\n- m (número): El número de colores.\nDevuelve:\n- número: El conteo de diferentes métodos de coloreo que satisfacen las condiciones,\n           el resultado es módulo 1000003.\nEjemplo:\n- f_15(1,1) // 1\n- f_15(2,3) // 6", "arb": "اكتب دالة JavaScript `function f_15(n, m)` لحل المشكلة التالية:\nتحسب عدد طرق التلوين المختلفة لـ n من المربعات باستخدام m من الألوان،\nمع مراعاة الشرط الذي ينص على أن المربعات المتجاورة والمربعات الأولى/الأخيرة\nيجب أن تكون بألوان مختلفة.\nالمعطيات:\n- n (عدد): عدد المربعات.\n- m (عدد): عدد الألوان.\nالإرجاع:\n- عدد: عدد طرق التلوين المختلفة التي تلبي الشروط،\n  النتيجة تكون موديولو 1000003.\nمثال:\n- f_15(1,1) // 1\n- f_15(2,3) // 6", "sw": "Andika kazi ya JavaScript `function f_15(n, m)` kutatua tatizo lifuatalo:\nHesabu idadi ya mbinu tofauti za kupaka rangi kwa miraba n na rangi m,\nukizingatia hitaji kwamba miraba iliyo karibu na miraba ya kwanza/ya mwisho\nlazima iwe na rangi tofauti.\nVigezo:\n- n (nambari): Idadi ya miraba.\n- m (nambari): Idadi ya rangi.\nInarudisha:\n- nambari: Idadi ya mbinu tofauti za kupaka rangi zinazokidhi masharti,\n           matokeo ni modulo 1000003.\nMfano:\n- f_15(1,1) // 1\n- f_15(2,3) // 6", "tr": "Bir JavaScript fonksiyonu `function f_15(n, m)` yazın:\nn kareyi m renkle boyamak için farklı yöntemlerin sayısını sayar,\nbitişik kareler ve ilk/son karelerin farklı renklere sahip olması gerektiği\nşartını dikkate alarak.\nParametreler:\n- n (sayı): Karelerin sayısı.\n- m (sayı): Renklerin sayısı.\nDöndürür:\n- sayı: Şartları karşılayan farklı boyama yöntemlerinin sayısı,\n          sonuç 1000003 ile mod alınır.\nÖrnek:\n- f_15(1,1) // 1\n- f_15(2,3) // 6", "vi": "Viết một hàm JavaScript `function f_15(n, m)` để giải quyết vấn đề sau:\nĐếm số lượng phương pháp tô màu khác nhau cho n ô vuông với m màu,\nxem xét yêu cầu rằng các ô vuông liền kề và ô vuông đầu/cuối\nphải có màu khác nhau.\nTham số:\n- n (number): Số lượng ô vuông.\n- m (number): Số lượng màu sắc.\nTrả về:\n- number: Số lượng phương pháp tô màu khác nhau thỏa mãn các điều kiện,\n           kết quả là modulo 1000003.\nVí dụ:\n- f_15(1,1) // 1\n- f_15(2,3) // 6", "id": "Tulis sebuah fungsi JavaScript `function f_15(n, m)` untuk menyelesaikan masalah berikut:\nMenghitung jumlah metode pewarnaan berbeda untuk n kotak dengan m warna,\ndengan mempertimbangkan persyaratan bahwa kotak yang bersebelahan dan kotak pertama/terakhir\nharus memiliki warna yang berbeda.\nParameter:\n- n (number): Jumlah kotak.\n- m (number): Jumlah warna.\nMengembalikan:\n- number: Jumlah metode pewarnaan berbeda yang memenuhi kondisi,\n           hasilnya adalah modulo 1000003.\nContoh:\n- f_15(1,1) // 1\n- f_15(2,3) // 6", "ja": "JavaScript関数 `function f_15(n, m)` を作成して、次の問題を解決してください:\nn個の正方形をm色で塗る異なる方法の数を数えます。\n隣接する正方形と最初/最後の正方形が異なる色でなければならないという要件を考慮します。\nパラメータ:\n- n (number): 正方形の数。\n- m (number): 色の数。\n戻り値:\n- number: 条件を満たす異なる塗り方の数、結果は1000003での剰余です。\n例:\n- f_15(1,1) // 1\n- f_15(2,3) // 6", "ko": "JavaScript 함수를 작성하세요 `function f_15(n, m)` 다음 문제를 해결하기 위해:\nn개의 정사각형과 m개의 색상에 대해 서로 다른 색칠 방법의 수를 계산합니다,\n인접한 정사각형과 첫 번째/마지막 정사각형이 다른 색상을 가져야 한다는 요구 사항을 고려합니다.\n매개변수:\n- n (number): 정사각형의 수.\n- m (number): 색상의 수.\n반환값:\n- number: 조건을 만족하는 서로 다른 색칠 방법의 수를 반환하며,\n           결과는 1000003으로 나눈 나머지입니다.\n예시:\n- f_15(1,1) // 1\n- f_15(2,3) // 6", "ml": "JavaScript ഫംഗ്ഷൻ `function f_15(n, m)` എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nn ചതുരങ്ങൾക്കും m നിറങ്ങൾക്കും വ്യത്യസ്തമായ നിറപ്പെടുത്തൽ രീതികളുടെ എണ്ണം എണ്ണുക,\nആദ്യ/അവസാന ചതുരങ്ങൾക്കും ചേർന്ന ചതുരങ്ങൾക്കും വ്യത്യസ്ത നിറങ്ങൾ വേണം എന്ന ആവശ്യം പരിഗണിച്ച്.\nപാരാമീറ്ററുകൾ:\n- n (number): ചതുരങ്ങളുടെ എണ്ണം.\n- m (number): നിറങ്ങളുടെ എണ്ണം.\nമടക്കം:\n- number: നിബന്ധനകൾ പാലിക്കുന്ന വ്യത്യസ്ത നിറപ്പെടുത്തൽ രീതികളുടെ എണ്ണം,\n           ഫലം 1000003 നു മോഡുലോ ആണ്.\nഉദാഹരണം:\n- f_15(1,1) // 1\n- f_15(2,3) // 6", "fa": "یک تابع جاوااسکریپت `function f_15(n, m)` بنویسید تا مسئله زیر را حل کند:\nتعداد روش‌های مختلف رنگ‌آمیزی برای n مربع با m رنگ را می‌شمارد،\nبا در نظر گرفتن این شرط که مربع‌های مجاور و مربع‌های اول/آخر\nباید رنگ‌های متفاوتی داشته باشند.\nپارامترها:\n- n (عدد): تعداد مربع‌ها.\n- m (عدد): تعداد رنگ‌ها.\nبازگشتی:\n- عدد: تعداد روش‌های مختلف رنگ‌آمیزی که شرایط را برآورده می‌کند،\n  نتیجه به پیمانه 1000003 است.\nمثال:\n- f_15(1,1) // 1\n- f_15(2,3) // 6"}, "level": "middle", "test": "(function testf_15() {\n    console.assert(f_15(1, 1) === 1, 'Test case 1 failed');\n    console.assert(f_15(2, 2) === 2, 'Test case 2 failed');\n    console.assert(f_15(3, 3) === 6, 'Test case 3 failed');\n    console.assert(f_15(4, 2) === 2, 'Test case 4 failed');\n    // For large numbers like 1000, 10 in JavaScript sometimes it might not be possible \n    // to directly assert the expected result since it is not provided in the original code.\n    console.assert(f_15(2, 3) === 6, 'Test case 5 failed');\n    console.assert(f_15(1000, 1000) === 67911, 'Test case 6 failed');\n    console.assert(f_15(999, 66) === 501817, 'Test case 7 failed');\n    console.assert(f_15(5, 3) === 30, 'Test case 8 failed');\n    \n    // console.log(\"All tests passed!\");\n})();", "entry_point": "f_15", "signature": "function f_15(n, m)", "docstring": {"en": "Counts the number of different coloring methods for n squares with m colors,\nconsidering the requirement that adjacent squares and the first/last squares\nmust have different colors.\nParameters:\n- n (number): The number of squares.\n- m (number): The number of colors.\nReturns:\n- number: The count of different coloring methods satisfying the conditions,\n           result is modulo 1000003.\nExample:\n- f_15(1,1) // 1\n- f_15(2,3) // 6", "sq": "Llogarit numrin e metodave të ndryshme të ngjyrosjes për n katrorë me m ngjyra, duke marrë parasysh kërkesën që katrorët ngjitur dhe katrorët e parë/fundit duhet të kenë ngjyra të ndryshme.\n\nParametrat:\n- n (numër): Numri i katrorëve.\n- m (numër): Numri i ngjyrave.\n\nKthen:\n- numër: Numri i metodave të ndryshme të ngjyrosjes që plotësojnë kushtet, rezultati është modulo 1000003.\n\nShembull:\n- f_15(1,1) // 1\n- f_15(2,3) // 6", "hy": "Հաշվում է n քառակուսիների տարբեր գունավորման մեթոդների քանակը m գույներով՝ հաշվի առնելով այն պահանջը, որ հարակից քառակուսիները և առաջին/վերջին քառակուսիները պետք է ունենան տարբեր գույներ։  \nՊարամետրեր:  \n- n (թիվ): Քառակուսիների քանակը։  \n- m (թիվ): Գույների քանակը։  \nՎերադարձնում է:  \n- թիվ: Տարբեր գունավորման մեթոդների քանակը, որոնք բավարարում են պայմաններին, արդյունքը՝ 1000003 մոդուլով։  \nՕրինակ:  \n- f_15(1,1) // 1  \n- f_15(2,3) // 6  ", "bn": "nটি বর্গক্ষেত্রের জন্য mটি রঙের বিভিন্ন রঙ করার পদ্ধতির সংখ্যা গণনা করে,\nযেখানে শর্ত হল যে সংলগ্ন বর্গক্ষেত্র এবং প্রথম/শেষ বর্গক্ষেত্রের রঙ ভিন্ন হতে হবে।\nপ্যারামিটারসমূহ:\n- n (number): বর্গক্ষেত্রের সংখ্যা।\n- m (number): রঙের সংখ্যা।\nফেরত দেয়:\n- number: শর্তগুলি পূরণ করে এমন বিভিন্ন রঙ করার পদ্ধতির সংখ্যা,\n           ফলাফল 1000003 দ্বারা মডুলো।\nউদাহরণ:\n- f_15(1,1) // 1\n- f_15(2,3) // 6", "bg": "Брои броя на различните методи за оцветяване на n квадрата с m цвята, като се има предвид изискването съседните квадрати и първият/последният квадрат да са с различни цветове.\nПараметри:\n- n (number): Броят на квадратите.\n- m (number): Броят на цветовете.\nВръща:\n- number: Броят на различните методи за оцветяване, които удовлетворяват условията,\n           резултатът е модуло 1000003.\nПример:\n- f_15(1,1) // 1\n- f_15(2,3) // 6", "zh": "计算使用 m 种颜色对 n 个方块进行不同着色的方法数，考虑到相邻方块以及首尾方块必须具有不同颜色的要求。\n\n参数：\n- n (number): 方块的数量。\n- m (number): 颜色的数量。\n\n返回：\n- number: 满足条件的不同着色方法的数量，结果取模 1000003。\n\n示例：\n- f_15(1,1) // 1\n- f_15(2,3) // 6", "fr": "Compte le nombre de méthodes de coloration différentes pour n carrés avec m couleurs, en tenant compte de l'exigence que les carrés adjacents et les premiers/derniers carrés doivent avoir des couleurs différentes.\n\nParamètres:\n- n (nombre): Le nombre de carrés.\n- m (nombre): Le nombre de couleurs.\n\nRenvoie:\n- nombre: Le compte des différentes méthodes de coloration satisfaisant les conditions, le résultat est modulo 1000003.\n\nExemple:\n- f_15(1,1) // 1\n- f_15(2,3) // 6", "de": "Zählt die Anzahl der verschiedenen Färbemethoden für n Quadrate mit m Farben,\nunter Berücksichtigung der Anforderung, dass benachbarte Quadrate und die ersten/letzten Quadrate\nunterschiedliche Farben haben müssen.\nParameter:\n- n (number): Die Anzahl der Quadrate.\n- m (number): Die Anzahl der Farben.\nRückgabewert:\n- number: Die Anzahl der verschiedenen Färbemethoden, die die Bedingungen erfüllen,\n           das Ergebnis ist modulo 1000003.\nBeispiel:\n- f_15(1,1) // 1\n- f_15(2,3) // 6", "ha": "Yana ƙididdige adadin hanyoyin canza launi daban-daban don murabba'ai n tare da launuka m, la'akari da buƙatar cewa murabba'ai masu makwabtaka da murabba'ai na farko/na ƙarshe dole ne su sami launuka daban-daban. \n\nSigogi:\n- n (number): Yawan murabba'ai.\n- m (number): Yawan launuka.\n\nYana dawowa:\n- number: Adadin hanyoyin canza launi daban-daban da suka cika sharuɗɗan, sakamakon yana modulo 1000003.\n\nMisali:\n- f_15(1,1) // 1\n- f_15(2,3) // 6", "hi": "गिनती करता है कि n वर्गों के लिए m रंगों के कितने विभिन्न रंगाई विधियाँ हैं, इस आवश्यकता को ध्यान में रखते हुए कि आसन्न वर्गों और पहले/अंतिम वर्गों के रंग अलग-अलग होने चाहिए।\n\nपैरामीटर्स:\n- n (संख्या): वर्गों की संख्या।\n- m (संख्या): रंगों की संख्या।\n\nवापसी:\n- संख्या: विभिन्न रंगाई विधियों की गिनती जो शर्तों को संतुष्ट करती हैं, परिणाम 1000003 से मॉड्यूलो है।\n\nउदाहरण:\n- f_15(1,1) // 1\n- f_15(2,3) // 6", "hu": "Számolja meg az n négyzet különböző színezési módszereinek számát m színnel, figyelembe véve azt a követelményt, hogy a szomszédos négyzetek és az első/utolsó négyzetek különböző színűek legyenek.\nParaméterek:\n- n (szám): A négyzetek száma.\n- m (szám): A színek száma.\nVisszatér:\n- szám: A feltételeknek megfelelő különböző színezési módszerek száma, az eredmény modulo 1000003.\nPélda:\n- f_15(1,1) // 1\n- f_15(2,3) // 6", "es": "Cuenta el número de diferentes métodos de coloreado para n cuadrados con m colores, considerando el requisito de que los cuadrados adyacentes y los primeros/últimos cuadrados deben tener colores diferentes.\n\nParámetros:\n- n (number): El número de cuadrados.\n- m (number): El número de colores.\n\nDevuelve:\n- number: La cuenta de diferentes métodos de coloreado que satisfacen las condiciones, el resultado es módulo 1000003.\n\nEjemplo:\n- f_15(1,1) // 1\n- f_15(2,3) // 6", "arb": "يحسب عدد طرق التلوين المختلفة لمربعات n باستخدام m من الألوان، مع الأخذ في الاعتبار الشرط الذي ينص على أن المربعات المتجاورة والمربعات الأولى/الأخيرة يجب أن تكون بألوان مختلفة.\n\nالمعطيات:\n- n (عدد): عدد المربعات.\n- m (عدد): عدد الألوان.\n\nالقيم المعادة:\n- عدد: عدد طرق التلوين المختلفة التي تفي بالشروط، النتيجة هي باقي القسمة على 1000003.\n\nمثال:\n- f_15(1,1) // 1\n- f_15(2,3) // 6", "sw": "Hesabu idadi ya mbinu tofauti za kupaka rangi kwa miraba n na rangi m,\nukizingatia sharti kwamba miraba iliyo karibu na miraba ya kwanza/ya mwisho\nlazima iwe na rangi tofauti.\nVigezo:\n- n (nambari): Idadi ya miraba.\n- m (nambari): Idadi ya rangi.\nInarejesha:\n- nambari: Idadi ya mbinu tofauti za kupaka rangi zinazokidhi masharti,\n           matokeo ni modulo 1000003.\nMfano:\n- f_15(1,1) // 1\n- f_15(2,3) // 6", "tr": "n kareyi m renkle boyamak için farklı boyama yöntemlerinin sayısını sayar,\nbitişik kareler ve ilk/son karelerin farklı renklere sahip olması gerektiği\nşartını dikkate alarak.\nParametreler:\n- n (sayı): Karelerin sayısı.\n- m (sayı): Renklerin sayısı.\nDöndürür:\n- sayı: Koşulları karşılayan farklı boyama yöntemlerinin sayısı,\n         sonuç 1000003 ile mod alınmıştır.\nÖrnek:\n- f_15(1,1) // 1\n- f_15(2,3) // 6", "vi": "Đếm số lượng phương pháp tô màu khác nhau cho n ô vuông với m màu, xem xét yêu cầu rằng các ô vuông liền kề và ô đầu/cuối phải có màu khác nhau.\n\nTham số:\n- n (number): Số lượng ô vuông.\n- m (number): Số lượng màu.\n\nTrả về:\n- number: Số lượng phương pháp tô màu khác nhau thỏa mãn các điều kiện, kết quả là modulo 1000003.\n\nVí dụ:\n- f_15(1,1) // 1\n- f_15(2,3) // 6", "id": "Menghitung jumlah metode pewarnaan yang berbeda untuk n kotak dengan m warna, dengan mempertimbangkan persyaratan bahwa kotak yang berdekatan dan kotak pertama/terakhir harus memiliki warna yang berbeda.\n\nParameter:\n- n (number): Jumlah kotak.\n- m (number): Jumlah warna.\n\nMengembalikan:\n- number: Jumlah metode pewarnaan berbeda yang memenuhi kondisi, hasilnya adalah modulo 1000003.\n\nContoh:\n- f_15(1,1) // 1\n- f_15(2,3) // 6", "ja": "n個の正方形をm色で塗り分ける方法の数を数えます。隣接する正方形および最初と最後の正方形は異なる色でなければならないという条件を考慮します。\n\n引数:\n- n (number): 正方形の数。\n- m (number): 色の数。\n\n戻り値:\n- number: 条件を満たす異なる塗り分け方法の数。結果は1000003での剰余です。\n\n例:\n- f_15(1,1) // 1\n- f_15(2,3) // 6", "ko": "n개의 정사각형을 m개의 색상으로 색칠하는 서로 다른 방법의 수를 계산합니다. 인접한 정사각형과 첫 번째/마지막 정사각형이 다른 색상이어야 한다는 요구 사항을 고려합니다.\n\n매개변수:\n- n (number): 정사각형의 수.\n- m (number): 색상의 수.\n\n반환:\n- number: 조건을 만족하는 서로 다른 색칠 방법의 수, 결과는 1000003으로 나눈 나머지입니다.\n\n예제:\n- f_15(1,1) // 1\n- f_15(2,3) // 6", "ml": "n ചതുരങ്ങൾ m നിറങ്ങളുമായി വ്യത്യസ്തമായ നിറപ്പെടുത്തൽ രീതികളുടെ എണ്ണം എണ്ണുന്നു, ചേർന്നിരിക്കുന്ന ചതുരങ്ങൾക്കും ആദ്യ/അവസാന ചതുരങ്ങൾക്കും വ്യത്യസ്ത നിറങ്ങൾ വേണം എന്ന ആവശ്യകത പരിഗണിച്ച്. \nപാരാമീറ്ററുകൾ:\n- n (number): ചതുരങ്ങളുടെ എണ്ണം.\n- m (number): നിറങ്ങളുടെ എണ്ണം.\nമടക്കം:\n- number: നിബന്ധനകൾ നിറവേറ്റുന്ന വ്യത്യസ്ത നിറപ്പെടുത്തൽ രീതികളുടെ എണ്ണം, ഫലം 1000003-ൽ മോഡുലോ ആണ്.\nഉദാഹരണം:\n- f_15(1,1) // 1\n- f_15(2,3) // 6", "fa": "تعداد روش‌های مختلف رنگ‌آمیزی برای n مربع با m رنگ را محاسبه می‌کند،\nبا در نظر گرفتن این شرط که مربع‌های مجاور و مربع‌های اول/آخر باید رنگ‌های متفاوتی داشته باشند.\n\nپارامترها:\n- n (number): تعداد مربع‌ها.\n- m (number): تعداد رنگ‌ها.\n\nبازگشت:\n- number: تعداد روش‌های مختلف رنگ‌آمیزی که شرایط را برآورده می‌کنند،\n           نتیجه به صورت مدولوی 1000003 است.\n\nمثال:\n- f_15(1,1) // 1\n- f_15(2,3) // 6"}}
{"task_id": "JavaScript/16", "prompt": {"en": "/**\n * Count the number of valid coin toss sequences with no consecutive heads in n tosses.\n *\n * Parameters:\n * - n (int): The number of coin tosses.\n *\n * Returns:\n *     Number: The count of valid sequences.\n *\n * Examples:\n *     f_16(1)\n *     // returns 2\n */\nconst f_16 = (n) =>", "sq": "/**\n * Numëron numrin e sekuencave të vlefshme të hedhjeve të monedhës pa koka të njëpasnjëshme në n hedhje.\n *\n * Parametrat:\n * - n (int): Numri i hedhjeve të monedhës.\n *\n * Kthen:\n *     Numër: Numri i sekuencave të vlefshme.\n *\n * Shembuj:\n *     f_16(1)\n *     // kthen 2\n */\nconst f_16 = (n) =>", "hy": "/**\n * Հաշվել վավեր մետաղադրամի նետումների հաջորդականությունների քանակը, որտեղ n նետումների ընթացքում չկա հաջորդական «գլուխ»։\n *\n * Պարամետրեր:\n * - n (int): Մետաղադրամի նետումների քանակը։\n *\n * Վերադարձնում է:\n *     Number: Վավեր հաջորդականությունների քանակը։\n *\n * Օրինակներ:\n *     f_16(1)\n *     // վերադարձնում է 2\n */\nconst f_16 = (n) =>", "bn": "/**\n * n টসের মধ্যে কোনো পরপর হেড না থাকা বৈধ কয়েন টস সিকোয়েন্সের সংখ্যা গণনা করুন।\n *\n * প্যারামিটার:\n * - n (int): কয়েন টসের সংখ্যা।\n *\n * রিটার্নস:\n *     সংখ্যা: বৈধ সিকোয়েন্সের সংখ্যা।\n *\n * উদাহরণ:\n *     f_16(1)\n *     // রিটার্ন করে 2\n */\nconst f_16 = (n) =>", "bg": "/**\n * Пребройте броя на валидните последователности от хвърляния на монета без последователни ези в n хвърляния.\n *\n * Параметри:\n * - n (int): Броят на хвърлянията на монетата.\n *\n * Връща:\n *     Number: Броят на валидните последователности.\n *\n * Примери:\n *     f_16(1)\n *     // връща 2\n */\nconst f_16 = (n) =>", "zh": "/**\n * 计算在 n 次投掷中没有连续正面的有效投掷序列的数量。\n *\n * 参数:\n * - n (int): 投掷硬币的次数。\n *\n * 返回:\n *     Number: 有效序列的数量。\n *\n * 示例:\n *     f_16(1)\n *     // 返回 2\n */\nconst f_16 = (n) =>", "fr": "/**\n * Compter le nombre de séquences de lancers de pièce valides sans faces consécutives dans n lancers.\n *\n * Paramètres:\n * - n (int): Le nombre de lancers de pièce.\n *\n * Retourne:\n *     Number: Le compte des séquences valides.\n *\n * Exemples:\n *     f_16(1)\n *     // returns 2\n */\nconst f_16 = (n) =>", "de": "/**\n * Zählt die Anzahl der gültigen Münzwurfsequenzen ohne aufeinanderfolgende Köpfe in n Würfen.\n *\n * Parameter:\n * - n (int): Die Anzahl der Münzwürfe.\n *\n * Rückgabewert:\n *     Number: Die Anzahl der gültigen Sequenzen.\n *\n * Beispiele:\n *     f_16(1)\n *     // gibt 2 zurück\n */\nconst f_16 = (n) =>", "ha": "/**\n * Ƙirga adadin jerin jefa tsabar kudi masu inganci ba tare da kai biyu a jere ba a cikin jefa n.\n *\n * Sigogi:\n * - n (int): Yawan jefa tsabar kudi.\n *\n * Komawa:\n *     Number: Adadin jerin masu inganci.\n *\n * Misalai:\n *     f_16(1)\n *     // yana dawowa 2\n */\nconst f_16 = (n) =>", "hi": "/**\n * n उछालों में कोई लगातार हेड्स नहीं होने वाले वैध सिक्का उछाल अनुक्रमों की संख्या गिनें।\n *\n * पैरामीटर्स:\n * - n (int): सिक्का उछालों की संख्या।\n *\n * रिटर्न करता है:\n *     संख्या: वैध अनुक्रमों की गिनती।\n *\n * उदाहरण:\n *     f_16(1)\n *     // 2 लौटाता है\n */\nconst f_16 = (n) =>", "hu": "/**\n * Számolja meg az érvényes pénzfeldobás sorozatok számát, ahol nincs egymást követő fej az n dobásban.\n *\n * Paraméterek:\n * - n (int): A pénzfeldobások száma.\n *\n * Visszatér:\n *     Szám: Az érvényes sorozatok száma.\n *\n * Példák:\n *     f_16(1)\n *     // visszaadja 2\n */\nconst f_16 = (n) =>", "es": "/**\n * Contar el número de secuencias válidas de lanzamientos de monedas sin caras consecutivas en n lanzamientos.\n *\n * Parámetros:\n * - n (int): El número de lanzamientos de monedas.\n *\n * Devuelve:\n *     Número: El conteo de secuencias válidas.\n *\n * Ejemplos:\n *     f_16(1)\n *     // devuelve 2\n */\nconst f_16 = (n) =>", "arb": "/**\n * احسب عدد تسلسلات رمي العملة الصحيحة بدون رؤوس متتالية في n رميات.\n *\n * المعلمات:\n * - n (int): عدد رميات العملة.\n *\n * يعيد:\n *     Number: عدد التسلسلات الصحيحة.\n *\n * أمثلة:\n *     f_16(1)\n *     // يعيد 2\n */\nconst f_16 = (n) =>", "sw": "/**\n * Hesabu idadi ya mfuatano halali wa kurusha sarafu bila vichwa mfululizo katika kurusha sarafu n.\n *\n * Vigezo:\n * - n (int): Idadi ya kurusha sarafu.\n *\n * Inarudisha:\n *     Nambari: Hesabu ya mfuatano halali.\n *\n * Mifano:\n *     f_16(1)\n *     // inarudisha 2\n */\nconst f_16 = (n) =>", "tr": "/**\n * Ardışık yazı gelmeyen geçerli madeni para atış dizilerinin sayısını n atışta sayın.\n *\n * Parametreler:\n * - n (int): Madeni para atışlarının sayısı.\n *\n * Döndürür:\n *     Sayı: Geçerli dizilerin sayısı.\n *\n * Örnekler:\n *     f_16(1)\n *     // 2 döndürür\n */\nconst f_16 = (n) =>", "vi": "/**\n * Đếm số lượng dãy tung đồng xu hợp lệ mà không có hai mặt ngửa liên tiếp trong n lần tung.\n *\n * Tham số:\n * - n (int): Số lần tung đồng xu.\n *\n * Trả về:\n *     Number: Số lượng dãy hợp lệ.\n *\n * Ví dụ:\n *     f_16(1)\n *     // trả về 2\n */\nconst f_16 = (n) =>", "id": "/**\n * Hitung jumlah urutan lemparan koin yang valid tanpa kepala berturut-turut dalam n lemparan.\n *\n * Parameter:\n * - n (int): Jumlah lemparan koin.\n *\n * Mengembalikan:\n *     Number: Jumlah urutan yang valid.\n *\n * Contoh:\n *     f_16(1)\n *     // mengembalikan 2\n */\nconst f_16 = (n) =>", "ja": "/**\n * n回のコイントスで連続する表がない有効なコイントスのシーケンスの数を数えます。\n *\n * パラメータ:\n * - n (int): コイントスの回数。\n *\n * 戻り値:\n *     Number: 有効なシーケンスの数。\n *\n * 例:\n *     f_16(1)\n *     // 2を返します\n */\nconst f_16 = (n) =>", "ko": "/**\n * 연속된 앞면이 없는 n번의 동전 던지기에서 유효한 동전 던지기 시퀀스의 수를 계산합니다.\n *\n * 매개변수:\n * - n (int): 동전 던지기의 횟수.\n *\n * 반환값:\n *     Number: 유효한 시퀀스의 수.\n *\n * 예시:\n *     f_16(1)\n *     // returns 2\n */\nconst f_16 = (n) =>", "ml": "/**\n * n തവണ എറിയുമ്പോൾ തുടർച്ചയായ തലകളില്ലാത്ത സാധുവായ നാണയ എറിയൽ ക്രമങ്ങളുടെ എണ്ണം എണ്ണുക.\n *\n * പാരാമീറ്ററുകൾ:\n * - n (int): നാണയം എറിയുന്ന തവണകളുടെ എണ്ണം.\n *\n * മടക്കുന്നു:\n *     Number: സാധുവായ ക്രമങ്ങളുടെ എണ്ണം.\n *\n * ഉദാഹരണങ്ങൾ:\n *     f_16(1)\n *     // 2 മടക്കുന്നു\n */\nconst f_16 = (n) =>", "fa": "/**\n * تعداد دنباله‌های معتبر پرتاب سکه را که در آن‌ها هیچ دو شیر متوالی وجود ندارد، در n پرتاب بشمارید.\n *\n * پارامترها:\n * - n (int): تعداد پرتاب‌های سکه.\n *\n * بازگشت:\n *     Number: تعداد دنباله‌های معتبر.\n *\n * مثال‌ها:\n *     f_16(1)\n *     // برمی‌گرداند 2\n */\nconst f_16 = (n) =>"}, "canonical_solution": "{\n    const a = Array.from({ length: n + 1 }, () => Array(2).fill(0));\n    a[1][0] = a[1][1] = 1;\n    \n    for (let i = 2; i <= n; i++) {\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n    \n    return a[n][0] + a[n][1];\n};", "instruction": {"en": "Write a JavaScript function `const f_16 = (n)` to solve the following problem:\nCount the number of valid coin toss sequences with no consecutive heads in n tosses.\n\nParameters:\n- n (int): The number of coin tosses.\n\nReturns:\n    Number: The count of valid sequences.\n\nExamples:\n    f_16(1)\n    // returns 2\n", "sq": "Shkruani një funksion JavaScript `const f_16 = (n)` për të zgjidhur problemin në vijim: Numëroni numrin e sekuencave të vlefshme të hedhjeve të monedhës pa koka radhazi në n hedhje.\n\nParametrat:\n- n (int): Numri i hedhjeve të monedhës.\n\nKthen:\n    Numri: Numri i sekuencave të vlefshme.\n\nShembuj:\n    f_16(1)\n    // kthen 2", "hy": "Գրեք JavaScript ֆունկցիա `const f_16 = (n)` հետևյալ խնդիրը լուծելու համար:\nՀաշվեք վավեր մետաղադրամի նետման հաջորդականությունների քանակը առանց հաջորդական գլխիկների n նետումներում:\n\nՊարամետրեր:\n- n (int): Մետաղադրամի նետումների քանակը։\n\nՎերադարձնում է:\n    Number: Վավեր հաջորդականությունների քանակը։\n\nՕրինակներ:\n    f_16(1)\n    // returns 2", "bn": "একটি জাভাস্ক্রিপ্ট ফাংশন `const f_16 = (n)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nn বার টসের মধ্যে কোন পরপর হেড না থাকা বৈধ কয়েন টস সিকোয়েন্সের সংখ্যা গণনা করুন।\n\nপ্যারামিটারসমূহ:\n- n (int): কয়েন টসের সংখ্যা।\n\nরিটার্নস:\n    সংখ্যা: বৈধ সিকোয়েন্সের সংখ্যা।\n\nউদাহরণসমূহ:\n    f_16(1)\n    // রিটার্ন করে 2", "bg": "Напишете функция на JavaScript `const f_16 = (n)`, за да решите следния проблем:  \nПребройте броя на валидните последователности от хвърляния на монета без последователни ези в n хвърляния.\n\nПараметри:  \n- n (int): Броят на хвърлянията на монета.\n\nВръща:  \n    Number: Броят на валидните последователности.\n\nПримери:  \n    f_16(1)  \n    // връща 2", "zh": "编写一个 JavaScript 函数 `const f_16 = (n)` 来解决以下问题：  \n计算在 n 次投掷中没有连续正面的有效投掷序列的数量。\n\n参数：\n- n (int): 投掷硬币的次数。\n\n返回：\n    Number: 有效序列的数量。\n\n示例：\n    f_16(1)\n    // 返回 2", "fr": "Écrire une fonction JavaScript `const f_16 = (n)` pour résoudre le problème suivant :  \nCompter le nombre de séquences de lancers de pièce valides sans têtes consécutives dans n lancers.\n\nParamètres :  \n- n (int) : Le nombre de lancers de pièce.\n\nRenvoie :  \n    Number : Le compte des séquences valides.\n\nExemples :  \n    f_16(1)  \n    // renvoie 2  ", "de": "Schreiben Sie eine JavaScript-Funktion `const f_16 = (n)`, um das folgende Problem zu lösen:  \nZählen Sie die Anzahl der gültigen Münzwurfsequenzen ohne aufeinanderfolgende Köpfe in n Würfen.\n\nParameter:\n- n (int): Die Anzahl der Münzwürfe.\n\nRückgabewert:\n    Number: Die Anzahl der gültigen Sequenzen.\n\nBeispiele:\n    f_16(1)\n    // gibt 2 zurück", "ha": "Rubuta aikin JavaScript `const f_16 = (n)` don warware matsalar mai zuwa:  \nƘididdige adadin sahihan jerin jefa tsabar kudi ba tare da kai biyu a jere ba a cikin jefa n.\n\nSigogi:\n- n (int): Yawan jefa tsabar kudi.\n\nDawowa:\n    Number: Adadin sahihan jerin.\n\nMisalai:\n    f_16(1)\n    // ya dawo da 2", "hi": "JavaScript फ़ंक्शन `const f_16 = (n)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nn बार सिक्का उछालने पर कोई लगातार हेड्स न होने वाले मान्य सिक्का उछाल अनुक्रमों की संख्या गिनें।\n\nपैरामीटर्स:\n- n (int): सिक्का उछालने की संख्या।\n\nरिटर्न करता है:\n    संख्या: मान्य अनुक्रमों की गिनती।\n\nउदाहरण:\n    f_16(1)\n    // returns 2", "hu": "Írj egy JavaScript függvényt `const f_16 = (n)` a következő probléma megoldására:  \nSzámold meg az érvényes pénzfeldobás sorozatok számát, ahol nincs két egymást követő fej n dobás esetén.\n\nParaméterek:\n- n (int): A pénzfeldobások száma.\n\nVisszatér:\n    Szám: Az érvényes sorozatok száma.\n\nPéldák:\n    f_16(1)\n    // visszatér 2\n", "es": "Escribe una función de JavaScript `const f_16 = (n)` para resolver el siguiente problema:\nCuenta el número de secuencias válidas de lanzamientos de moneda sin caras consecutivas en n lanzamientos.\n\nParámetros:\n- n (int): El número de lanzamientos de moneda.\n\nDevuelve:\n    Número: La cuenta de secuencias válidas.\n\nEjemplos:\n    f_16(1)\n    // devuelve 2", "arb": "اكتب دالة JavaScript `const f_16 = (n)` لحل المشكلة التالية:\nاحسب عدد تسلسلات رمي العملة الصحيحة التي لا تحتوي على رؤوس متتالية في n من الرميات.\n\nالمعطيات:\n- n (int): عدد رميات العملة.\n\nالقيم المعادة:\n    Number: عدد التسلسلات الصحيحة.\n\nأمثلة:\n    f_16(1)\n    // يعيد 2", "sw": "Andika kazi ya JavaScript `const f_16 = (n)` kutatua tatizo lifuatalo: \nHesabu idadi ya mfuatano sahihi wa kurusha sarafu bila vichwa mfululizo katika kurusha sarafu n.\n\nVigezo:\n- n (int): Idadi ya kurusha sarafu.\n\nRudisha:\n    Nambari: Idadi ya mfuatano sahihi.\n\nMifano:\n    f_16(1)\n    // inarudisha 2", "tr": "Bir JavaScript fonksiyonu `const f_16 = (n)` yazın ve aşağıdaki problemi çözün:\nn atışında ardışık yazı gelmeyen geçerli yazı-tura dizilerinin sayısını sayın.\n\nParametreler:\n- n (int): Yazı-tura atışlarının sayısı.\n\nDöndürür:\n    Number: Geçerli dizilerin sayısı.\n\nÖrnekler:\n    f_16(1)\n    // 2 döndürür", "vi": "Viết một hàm JavaScript `const f_16 = (n)` để giải quyết vấn đề sau:\nĐếm số lượng chuỗi tung đồng xu hợp lệ mà không có hai mặt ngửa liên tiếp trong n lần tung.\n\nTham số:\n- n (int): Số lần tung đồng xu.\n\nTrả về:\n    Number: Số lượng chuỗi hợp lệ.\n\nVí dụ:\n    f_16(1)\n    // trả về 2", "id": "Tulis sebuah fungsi JavaScript `const f_16 = (n)` untuk menyelesaikan masalah berikut:\nHitung jumlah urutan lemparan koin yang valid tanpa kepala berturut-turut dalam n lemparan.\n\nParameter:\n- n (int): Jumlah lemparan koin.\n\nMengembalikan:\n    Number: Jumlah urutan yang valid.\n\nContoh:\n    f_16(1)\n    // mengembalikan 2", "ja": "次の問題を解決するためのJavaScript関数 `const f_16 = (n)` を作成してください。  \nn回のコイントスで連続する表がない有効なコイントスのシーケンスの数を数えます。\n\nパラメータ:\n- n (int): コイントスの回数。\n\n戻り値:\n    Number: 有効なシーケンスの数。\n\n例:\n    f_16(1)\n    // returns 2", "ko": "JavaScript 함수를 작성하세요 `const f_16 = (n)` 다음 문제를 해결하기 위해:\nn번의 던지기에서 연속된 앞면이 없는 유효한 동전 던지기 시퀀스의 수를 세세요.\n\n매개변수:\n- n (int): 동전 던지기의 수.\n\n반환값:\n    Number: 유효한 시퀀스의 수.\n\n예시:\n    f_16(1)\n    // returns 2", "ml": "`const f_16 = (n)` എന്ന ജാവാസ്ക്രിപ്റ്റ് ഫംഗ്ഷൻ എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:  \nn തവണ തലയോട്ടി എറിയുമ്പോൾ തുടർച്ചയായ തലകൾ ഇല്ലാത്ത സാധുവായ തലയോട്ടി എറിയൽ ക്രമങ്ങളുടെ എണ്ണം എണ്ണുക.\n\nപരാമീറ്ററുകൾ:\n- n (int): തലയോട്ടി എറിയലുകളുടെ എണ്ണം.\n\nമടക്കം:\n    Number: സാധുവായ ക്രമങ്ങളുടെ എണ്ണം.\n\nഉദാഹരണങ്ങൾ:\n    f_16(1)\n    // 2 മടക്കം ചെയ്യുന്നു", "fa": "یک تابع جاوااسکریپت `const f_16 = (n)` بنویسید تا مسئله زیر را حل کند:\nتعداد دنباله‌های معتبر پرتاب سکه را که در آن‌ها هیچ دو شیر متوالی وجود ندارد در n پرتاب بشمارید.\n\nپارامترها:\n- n (int): تعداد پرتاب‌های سکه.\n\nبرمی‌گرداند:\n    Number: تعداد دنباله‌های معتبر.\n\nمثال‌ها:\n    f_16(1)\n    // برمی‌گرداند 2"}, "level": "easy", "test": "const testf_16 = () => {\n    console.assert(f_16(1) === 2);\n    console.assert(f_16(2) === 3);\n    console.assert(f_16(3) === 5);\n    console.assert(f_16(4) === 8);\n    console.assert(f_16(5) === 13);\n    // Additional tests\n    console.assert(f_16(40) === 267914296);\n    console.assert(f_16(39) === 165580141);\n    console.assert(f_16(38) === 102334155);\n    // console.log(\"All tests passed!\");\n};\n\ntestf_16();", "entry_point": "f_16", "signature": "const f_16 = (n)", "docstring": {"en": "Count the number of valid coin toss sequences with no consecutive heads in n tosses.\n\nParameters:\n- n (int): The number of coin tosses.\n\nReturns:\n    Number: The count of valid sequences.\n\nExamples:\n    f_16(1)\n    // returns 2\n", "sq": "Numëroni numrin e sekuencave të vlefshme të hedhjeve të monedhës pa koka të njëpasnjëshme në n hedhje.\n\nParametrat:\n- n (int): Numri i hedhjeve të monedhës.\n\nKthen:\n    Numër: Numri i sekuencave të vlefshme.\n\nShembuj:\n    f_16(1)\n    // kthen 2", "hy": "Հաշվել վավեր մետաղադրամի նետումների հաջորդականությունների քանակը, որտեղ n նետումների ընթացքում չկան հաջորդական գլուխներ:\n\nՊարամետրեր:\n- n (int): Մետաղադրամի նետումների քանակը:\n\nՎերադարձնում է:\n    Number: Վավեր հաջորդականությունների քանակը:\n\nՕրինակներ:\n    f_16(1)\n    // վերադարձնում է 2", "bn": "n টসের মধ্যে কোন পরপর হেড না থাকা বৈধ কয়েন টস সিকোয়েন্সের সংখ্যা গণনা করুন।\n\nপ্যারামিটারসমূহ:\n- n (int): কয়েন টসের সংখ্যা।\n\nফেরত দেয়:\n    সংখ্যা: বৈধ সিকোয়েন্সের সংখ্যা।\n\nউদাহরণসমূহ:\n    f_16(1)\n    // 2 ফেরত দেয়", "bg": "Бройте броя на валидните последователности от хвърляния на монета без последователни ези в n хвърляния.\n\nПараметри:\n- n (int): Броят на хвърлянията на монетата.\n\nВръща:\n    Number: Броят на валидните последователности.\n\nПримери:\n    f_16(1)\n    // връща 2", "zh": "计算在 n 次投掷中没有连续正面的有效硬币投掷序列的数量。\n\n参数:\n- n (int): 硬币投掷的次数。\n\n返回:\n    Number: 有效序列的数量。\n\n示例:\n    f_16(1)\n    // 返回 2", "fr": "Compter le nombre de séquences de lancers de pièce valides sans faces consécutives dans n lancers.\n\nParamètres:\n- n (int): Le nombre de lancers de pièce.\n\nRenvoie:\n    Number: Le compte des séquences valides.\n\nExemples:\n    f_16(1)\n    // renvoie 2", "de": "Zähle die Anzahl der gültigen Münzwurfsequenzen ohne aufeinanderfolgende Köpfe in n Würfen.\n\nParameter:\n- n (int): Die Anzahl der Münzwürfe.\n\nRückgabe:\n    Number: Die Anzahl der gültigen Sequenzen.\n\nBeispiele:\n    f_16(1)\n    // gibt 2 zurück", "ha": "Ƙirga adadin jerin jefa tsabar kudi masu inganci ba tare da kai biyu a jere ba a cikin jefa n.\n\nSigogi:\n- n (int): Yawan jefa tsabar kudi.\n\nDawowa:\n    Number: Adadin sahihan jerin.\n\nMisalai:\n    f_16(1)\n    // returns 2", "hi": "n टॉस में बिना लगातार हेड्स के वैध सिक्का उछाल अनुक्रमों की संख्या गिनें।\n\nपैरामीटर्स:\n- n (int): सिक्का उछाल की संख्या।\n\nवापसी:\n    संख्या: वैध अनुक्रमों की गिनती।\n\nउदाहरण:\n    f_16(1)\n    // 2 लौटाता है", "hu": "Számolja meg az érvényes pénzfeldobás sorozatok számát, ahol n dobás során nincs egymást követő fej.\n\nParaméterek:\n- n (int): A pénzfeldobások száma.\n\nVisszatér:\n    Number: Az érvényes sorozatok száma.\n\nPéldák:\n    f_16(1)\n    // visszaadja 2", "es": "Cuenta el número de secuencias válidas de lanzamientos de moneda sin caras consecutivas en n lanzamientos.\n\nParámetros:\n- n (int): El número de lanzamientos de moneda.\n\nDevuelve:\n    Número: El conteo de secuencias válidas.\n\nEjemplos:\n    f_16(1)\n    // devuelve 2", "arb": "احسب عدد تسلسلات رمي العملة الصحيحة بدون رؤوس متتالية في n رميات.\n\nالمعلمات:\n- n (int): عدد رميات العملة.\n\nالعوائد:\n    Number: عدد التسلسلات الصحيحة.\n\nأمثلة:\n    f_16(1)\n    // يعيد 2", "sw": "Hesabu idadi ya mfuatano halali wa kurusha sarafu bila vichwa vinavyofuatana katika kurusha sarafu n.\n\nVigezo:\n- n (int): Idadi ya kurusha sarafu.\n\nInarejesha:\n    Nambari: Idadi ya mfuatano halali.\n\nMifano:\n    f_16(1)\n    // inarejesha 2", "tr": "n atışında ardışık yazı olmayan geçerli madeni para atış dizilerinin sayısını sayın.\n\nParametreler:\n- n (int): Madeni para atışlarının sayısı.\n\nDöndürür:\n    Sayı: Geçerli dizilerin sayısı.\n\nÖrnekler:\n    f_16(1)\n    // 2 döndürür", "vi": "Đếm số lượng chuỗi tung đồng xu hợp lệ mà không có hai mặt ngửa liên tiếp trong n lần tung.\n\nTham số:\n- n (int): Số lần tung đồng xu.\n\nTrả về:\n    Number: Số lượng chuỗi hợp lệ.\n\nVí dụ:\n    f_16(1)\n    // trả về 2", "id": "Hitung jumlah urutan lemparan koin yang valid tanpa kepala berturut-turut dalam n lemparan.\n\nParameter:\n- n (int): Jumlah lemparan koin.\n\nMengembalikan:\n    Number: Jumlah urutan yang valid.\n\nContoh:\n    f_16(1)\n    // mengembalikan 2", "ja": "n回のコイントスで連続する表がない有効なコイントスのシーケンスの数を数えます。\n\nパラメータ:\n- n (int): コイントスの回数。\n\n戻り値:\n    Number: 有効なシーケンスの数。\n\n例:\n    f_16(1)\n    // 2を返します。", "ko": "n번의 동전 던지기에서 연속된 앞면이 없는 유효한 동전 던지기 시퀀스의 수를 계산합니다.\n\n매개변수:\n- n (int): 동전 던지기의 횟수.\n\n반환:\n    Number: 유효한 시퀀스의 수.\n\n예제:\n    f_16(1)\n    // 2를 반환합니다.", "ml": "n തവണ എറിയുമ്പോൾ തുടർച്ചയായ തലകൾ ഇല്ലാത്ത സാധുവായ നാണയ എറിയൽ ക്രമങ്ങളുടെ എണ്ണം എണ്ണുക.\n\nപാരാമീറ്ററുകൾ:\n- n (int): നാണയ എറിയലുകളുടെ എണ്ണം.\n\nമടക്കം ചെയ്യുന്നത്:\n    Number: സാധുവായ ക്രമങ്ങളുടെ എണ്ണം.\n\nഉദാഹരണങ്ങൾ:\n    f_16(1)\n    // 2 മടക്കം ചെയ്യുന്നു", "fa": "تعداد دنباله‌های معتبر پرتاب سکه را بدون شیرهای متوالی در n پرتاب بشمارید.\n\nپارامترها:\n- n (int): تعداد پرتاب‌های سکه.\n\nبازگشت:\n    Number: تعداد دنباله‌های معتبر.\n\nمثال‌ها:\n    f_16(1)\n    // returns 2"}}
{"task_id": "JavaScript/17", "prompt": {"en": "/**\n * Find the length of the longest consecutive sequence of 1s in the binary \n * representation of a non-negative integer.\n *\n * @param {number} n - A non-negative integer (0 ≤ n ≤ 2^64 - 1).\n * @returns {number} The length of the longest consecutive sequence of 1s in \n *                   the binary representation of the given integer.\n * \n * Examples:\n * f_17(7) === 3\n * f_17(13) === 2\n */\nfunction f_17(n)", "sq": "/**\n * Gjeni gjatësinë e sekuencës më të gjatë të njëshave radhazi në përfaqësimin \n * binar të një numri jo-negativ.\n *\n * @param {number} n - Një numër jo-negativ (0 ≤ n ≤ 2^64 - 1).\n * @returns {number} Gjatësia e sekuencës më të gjatë të njëshave radhazi në \n *                   përfaqësimin binar të numrit të dhënë.\n * \n * Shembuj:\n * f_17(7) === 3\n * f_17(13) === 2\n */\nfunction f_17(n)", "hy": "/**\n * Գտնել ամենաերկար հաջորդական 1-երի երկարությունը ոչ բացասական ամբողջ թվի \n * երկբայական ներկայացման մեջ:\n *\n * @param {number} n - Ոչ բացասական ամբողջ թիվ (0 ≤ n ≤ 2^64 - 1):\n * @returns {number} Ամենաերկար հաջորդական 1-երի երկարությունը տրված թվի \n *                   երկբայական ներկայացման մեջ:\n * \n * Օրինակներ:\n * f_17(7) === 3\n * f_17(13) === 2\n */\nfunction f_17(n)", "bn": "/**\n * একটি অ-ঋণাত্মক পূর্ণসংখ্যার বাইনারি উপস্থাপনার মধ্যে 1 এর দীর্ঘতম ক্রমিক \n * ক্রমের দৈর্ঘ্য খুঁজে বের করুন।\n *\n * @param {number} n - একটি অ-ঋণাত্মক পূর্ণসংখ্যা (0 ≤ n ≤ 2^64 - 1)।\n * @returns {number} প্রদত্ত পূর্ণসংখ্যার বাইনারি উপস্থাপনার মধ্যে 1 এর \n *                   দীর্ঘতম ক্রমিক ক্রমের দৈর্ঘ্য।\n * \n * উদাহরণ:\n * f_17(7) === 3\n * f_17(13) === 2\n */\nfunction f_17(n)", "bg": "/**\n * Намерете дължината на най-дългата последователност от 1 в двоичното \n * представяне на неотрицателно цяло число.\n *\n * @param {number} n - Неотрицателно цяло число (0 ≤ n ≤ 2^64 - 1).\n * @returns {number} Дължината на най-дългата последователност от 1 в \n *                   двоичното представяне на даденото цяло число.\n * \n * Примери:\n * f_17(7) === 3\n * f_17(13) === 2\n */\nfunction f_17(n)", "zh": "/**\n * 找到非负整数的二进制表示中最长连续1序列的长度。\n *\n * @param {number} n - 一个非负整数 (0 ≤ n ≤ 2^64 - 1)。\n * @returns {number} 给定整数的二进制表示中最长连续1序列的长度。\n * \n * 例子:\n * f_17(7) === 3\n * f_17(13) === 2\n */\nfunction f_17(n)", "fr": "/**\n * Trouver la longueur de la plus longue séquence consécutive de 1s dans la \n * représentation binaire d'un entier non négatif.\n *\n * @param {number} n - Un entier non négatif (0 ≤ n ≤ 2^64 - 1).\n * @returns {number} La longueur de la plus longue séquence consécutive de 1s \n *                   dans la représentation binaire de l'entier donné.\n * \n * Exemples :\n * f_17(7) === 3\n * f_17(13) === 2\n */\nfunction f_17(n)", "de": "/**\n * Finde die Länge der längsten aufeinanderfolgenden Sequenz von 1en in der \n * Binärdarstellung einer nicht-negativen ganzen Zahl.\n *\n * @param {number} n - Eine nicht-negative ganze Zahl (0 ≤ n ≤ 2^64 - 1).\n * @returns {number} Die Länge der längsten aufeinanderfolgenden Sequenz von 1en in \n *                   der Binärdarstellung der gegebenen Zahl.\n * \n * Beispiele:\n * f_17(7) === 3\n * f_17(13) === 2\n */\nfunction f_17(n)", "ha": "/**\n * Nemo tsawon jerin lambobi 1 mafi tsawo a cikin wakilcin binary \n * na lamba maras kyau.\n *\n * @param {number} n - Lamba maras kyau (0 ≤ n ≤ 2^64 - 1).\n * @returns {number} Tsawon jerin lambobi 1 mafi tsawo a cikin \n *                   wakilcin binary na lambar da aka bayar.\n * \n * Misalai:\n * f_17(7) === 3\n * f_17(13) === 2\n */\nfunction f_17(n)", "hi": "/**\n * एक गैर-ऋणात्मक पूर्णांक के द्विआधारी \n * प्रतिनिधित्व में 1s के सबसे लंबे अनुक्रम की लंबाई खोजें।\n *\n * @param {number} n - एक गैर-ऋणात्मक पूर्णांक (0 ≤ n ≤ 2^64 - 1)।\n * @returns {number} दिए गए पूर्णांक के द्विआधारी प्रतिनिधित्व में \n *                   1s के सबसे लंबे अनुक्रम की लंबाई।\n * \n * उदाहरण:\n * f_17(7) === 3\n * f_17(13) === 2\n */\nfunction f_17(n)", "hu": "/**\n * Határozza meg a leghosszabb egymást követő 1-es sorozat hosszát egy nem negatív egész szám bináris \n * ábrázolásában.\n *\n * @param {number} n - Egy nem negatív egész szám (0 ≤ n ≤ 2^64 - 1).\n * @returns {number} A leghosszabb egymást követő 1-es sorozat hossza a \n *                   megadott egész szám bináris ábrázolásában.\n * \n * Példák:\n * f_17(7) === 3\n * f_17(13) === 2\n */\nfunction f_17(n)", "es": "/**\n * Encuentra la longitud de la secuencia consecutiva más larga de 1s en la \n * representación binaria de un entero no negativo.\n *\n * @param {number} n - Un entero no negativo (0 ≤ n ≤ 2^64 - 1).\n * @returns {number} La longitud de la secuencia consecutiva más larga de 1s en \n *                   la representación binaria del entero dado.\n * \n * Ejemplos:\n * f_17(7) === 3\n * f_17(13) === 2\n */\nfunction f_17(n)", "arb": "/**\n * إيجاد طول أطول تسلسل متتابع من الأرقام 1 في التمثيل الثنائي لعدد صحيح غير سالب.\n *\n * @param {number} n - عدد صحيح غير سالب (0 ≤ n ≤ 2^64 - 1).\n * @returns {number} طول أطول تسلسل متتابع من الأرقام 1 في التمثيل الثنائي \n *                   للعدد الصحيح المعطى.\n * \n * أمثلة:\n * f_17(7) === 3\n * f_17(13) === 2\n */\nfunction f_17(n)", "sw": "/**\n * Pata urefu wa mlolongo mrefu zaidi wa 1s mfululizo katika uwakilishi wa \n * binary wa nambari isiyo hasi.\n *\n * @param {number} n - Nambari isiyo hasi (0 ≤ n ≤ 2^64 - 1).\n * @returns {number} Urefu wa mlolongo mrefu zaidi wa 1s mfululizo katika \n *                   uwakilishi wa binary wa nambari iliyotolewa.\n * \n * Mifano:\n * f_17(7) === 3\n * f_17(13) === 2\n */\nfunction f_17(n)", "tr": "/**\n * Negatif olmayan bir tam sayının ikili gösteriminde ardışık 1'lerin \n * en uzun dizisinin uzunluğunu bulun.\n *\n * @param {number} n - Negatif olmayan bir tam sayı (0 ≤ n ≤ 2^64 - 1).\n * @returns {number} Verilen tam sayının ikili gösteriminde ardışık 1'lerin \n *                   en uzun dizisinin uzunluğu.\n * \n * Örnekler:\n * f_17(7) === 3\n * f_17(13) === 2\n */\nfunction f_17(n)", "vi": "/**\n * Tìm độ dài của dãy liên tiếp dài nhất của các số 1 trong biểu diễn nhị phân \n * của một số nguyên không âm.\n *\n * @param {number} n - Một số nguyên không âm (0 ≤ n ≤ 2^64 - 1).\n * @returns {number} Độ dài của dãy liên tiếp dài nhất của các số 1 trong \n *                   biểu diễn nhị phân của số nguyên đã cho.\n * \n * Ví dụ:\n * f_17(7) === 3\n * f_17(13) === 2\n */\nfunction f_17(n)", "id": "/**\n * Menemukan panjang urutan terpanjang dari angka 1 yang berurutan dalam \n * representasi biner dari bilangan bulat non-negatif.\n *\n * @param {number} n - Bilangan bulat non-negatif (0 ≤ n ≤ 2^64 - 1).\n * @returns {number} Panjang urutan terpanjang dari angka 1 yang berurutan \n *                   dalam representasi biner dari bilangan bulat yang diberikan.\n * \n * Contoh:\n * f_17(7) === 3\n * f_17(13) === 2\n */\nfunction f_17(n)", "ja": "/**\n * 非負整数の2進数表現における1の最長連続シーケンスの長さを見つけます。\n *\n * @param {number} n - 非負整数 (0 ≤ n ≤ 2^64 - 1)。\n * @returns {number} 与えられた整数の2進数表現における1の最長連続シーケンスの長さ。\n * \n * 例:\n * f_17(7) === 3\n * f_17(13) === 2\n */\nfunction f_17(n)", "ko": "/**\n * 비음수 정수의 이진 표현에서 1의 가장 긴 연속 시퀀스의 길이를 찾습니다.\n *\n * @param {number} n - 비음수 정수 (0 ≤ n ≤ 2^64 - 1).\n * @returns {number} 주어진 정수의 이진 표현에서 1의 가장 긴 연속 시퀀스의 길이.\n * \n * 예시:\n * f_17(7) === 3\n * f_17(13) === 2\n */\nfunction f_17(n)", "ml": "/**\n * ഒരു അസാധാരണമല്ലാത്ത പൂർണ്ണസംഖ്യയുടെ ബൈനറി പ്രതിനിധാനത്തിൽ \n * ഏറ്റവും നീളമുള്ള അനന്തരമായ 1 കളുടെ ശ്രേണിയുടെ നീളം കണ്ടെത്തുക.\n *\n * @param {number} n - ഒരു അസാധാരണമല്ലാത്ത പൂർണ്ണസംഖ്യ (0 ≤ n ≤ 2^64 - 1).\n * @returns {number} നൽകിയിരിക്കുന്ന പൂർണ്ണസംഖ്യയുടെ ബൈനറി പ്രതിനിധാനത്തിൽ \n *                   ഏറ്റവും നീളമുള്ള അനന്തരമായ 1 കളുടെ ശ്രേണിയുടെ നീളം.\n * \n * ഉദാഹരണങ്ങൾ:\n * f_17(7) === 3\n * f_17(13) === 2\n */\nfunction f_17(n)", "fa": "/**\n * طول بلندترین دنباله متوالی از 1ها را در نمایش باینری یک عدد صحیح غیرمنفی پیدا کنید.\n *\n * @param {number} n - یک عدد صحیح غیرمنفی (0 ≤ n ≤ 2^64 - 1).\n * @returns {number} طول بلندترین دنباله متوالی از 1ها در \n *                   نمایش باینری عدد داده شده.\n * \n * Examples:\n * f_17(7) === 3\n * f_17(13) === 2\n */\nfunction f_17(n)"}, "canonical_solution": "{\n    let max = 0;\n    let ans = 0;\n    while (n) {\n        if (n & 1)\n            ans++;\n        else {\n            if (ans > max)\n                max = ans;\n            ans = 0;\n        }\n        n >>>= 1;\n    }\n    if (ans > max)\n        max = ans;\n    return max;\n}", "instruction": {"en": "Write a JavaScript function `function f_17(n)` to solve the following problem:\nFind the length of the longest consecutive sequence of 1s in the binary representation of a non-negative integer.\n\nParameters:\n@param {number} n - A non-negative integer (0 ≤ n ≤ 2^64 - 1).\n\nReturns:\n@returns {number} The length of the longest consecutive sequence of 1s in the binary representation of the given integer.\n\nExamples:\nf_17(7) === 3\nf_17(13) === 2\n", "sq": "Shkruani një funksion JavaScript `function f_17(n)` për të zgjidhur problemin e mëposhtëm:  \nGjeni gjatësinë e sekuencës më të gjatë të njëshave të njëpasnjëshme në paraqitjen binare të një numri të plotë jo-negativ.\n\nParametrat:  \n@param {number} n - Një numër i plotë jo-negativ (0 ≤ n ≤ 2^64 - 1).\n\nKthen:  \n@returns {number} Gjatësia e sekuencës më të gjatë të njëshave të njëpasnjëshme në paraqitjen binare të numrit të dhënë.\n\nShembuj:  \nf_17(7) === 3  \nf_17(13) === 2  ", "hy": "Գրեք JavaScript ֆունկցիա `function f_17(n)` հետևյալ խնդիրը լուծելու համար:\nԳտեք ամենաերկար հաջորդական 1-երի հաջորդականության երկարությունը ոչ բացասական ամբողջ թվի բինար ներկայացման մեջ:\n\nՊարամետրեր:\n@param {number} n - Ոչ բացասական ամբողջ թիվ (0 ≤ n ≤ 2^64 - 1):\n\nՎերադարձնում է:\n@returns {number} Տրված ամբողջ թվի բինար ներկայացման մեջ ամենաերկար հաջորդական 1-երի հաջորդականության երկարությունը:\n\nՕրինակներ:\nf_17(7) === 3\nf_17(13) === 2", "bn": "একটি JavaScript ফাংশন `function f_17(n)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি অ-ঋণাত্মক পূর্ণসংখ্যার বাইনারি উপস্থাপনার মধ্যে 1 এর দীর্ঘতম ক্রমিক অনুক্রমের দৈর্ঘ্য খুঁজে বের করুন।\n\nপ্যারামিটারসমূহ:\n@param {number} n - একটি অ-ঋণাত্মক পূর্ণসংখ্যা (0 ≤ n ≤ 2^64 - 1)।\n\nফেরত দেয়:\n@returns {number} প্রদত্ত পূর্ণসংখ্যার বাইনারি উপস্থাপনার মধ্যে 1 এর দীর্ঘতম ক্রমিক অনুক্রমের দৈর্ঘ্য।\n\nউদাহরণসমূহ:\nf_17(7) === 3\nf_17(13) === 2", "bg": "Напишете JavaScript функция `function f_17(n)`, за да решите следния проблем:  \nНамерете дължината на най-дългата последователна поредица от 1-ци в двоичното представяне на неотрицателно цяло число.\n\nПараметри:\n@param {number} n - Неотрицателно цяло число (0 ≤ n ≤ 2^64 - 1).\n\nВръща:\n@returns {number} Дължината на най-дългата последователна поредица от 1-ци в двоичното представяне на даденото цяло число.\n\nПримери:\nf_17(7) === 3  \nf_17(13) === 2  ", "zh": "编写一个 JavaScript 函数 `function f_17(n)` 来解决以下问题：  \n在一个非负整数的二进制表示中，找到最长连续1序列的长度。\n\n参数：  \n@param {number} n - 一个非负整数 (0 ≤ n ≤ 2^64 - 1)。\n\n返回：  \n@returns {number} 给定整数的二进制表示中最长连续1序列的长度。\n\n示例：  \nf_17(7) === 3  \nf_17(13) === 2  ", "fr": "Écrire une fonction JavaScript `function f_17(n)` pour résoudre le problème suivant :  \nTrouver la longueur de la plus longue séquence consécutive de 1 dans la représentation binaire d'un entier non négatif.\n\nParamètres :  \n@param {number} n - Un entier non négatif (0 ≤ n ≤ 2^64 - 1).\n\nRenvoie :  \n@returns {number} La longueur de la plus longue séquence consécutive de 1 dans la représentation binaire de l'entier donné.\n\nExemples :  \nf_17(7) === 3  \nf_17(13) === 2  ", "de": "Schreiben Sie eine JavaScript-Funktion `function f_17(n)`, um das folgende Problem zu lösen:\nFinden Sie die Länge der längsten aufeinanderfolgenden Sequenz von 1en in der Binärdarstellung einer nicht-negativen ganzen Zahl.\n\nParameter:\n@param {number} n - Eine nicht-negative ganze Zahl (0 ≤ n ≤ 2^64 - 1).\n\nRückgabewert:\n@returns {number} Die Länge der längsten aufeinanderfolgenden Sequenz von 1en in der Binärdarstellung der gegebenen Zahl.\n\nBeispiele:\nf_17(7) === 3\nf_17(13) === 2", "ha": "Rubuta aikin JavaScript `function f_17(n)` don warware matsalar mai zuwa:  \nNemo tsawon jere mafi tsawo na 1s a cikin wakilcin binary na lamba mara kyau.\n\nSigogi:  \n@param {number} n - Lamba mara kyau (0 ≤ n ≤ 2^64 - 1).\n\nMayarwa:  \n@returns {number} Tsawon jere mafi tsawo na 1s a cikin wakilcin binary na lambar da aka bayar.\n\nMisalai:  \nf_17(7) === 3  \nf_17(13) === 2  ", "hi": "एक जावास्क्रिप्ट फ़ंक्शन `function f_17(n)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nएक गैर-ऋणात्मक पूर्णांक के बाइनरी प्रतिनिधित्व में 1s के सबसे लंबे अनुक्रम की लंबाई खोजें।\n\nपैरामीटर्स:\n@param {number} n - एक गैर-ऋणात्मक पूर्णांक (0 ≤ n ≤ 2^64 - 1)।\n\nवापसी:\n@returns {number} दिए गए पूर्णांक के बाइनरी प्रतिनिधित्व में 1s के सबसे लंबे अनुक्रम की लंबाई।\n\nउदाहरण:\nf_17(7) === 3\nf_17(13) === 2", "hu": "Írj egy JavaScript függvényt `function f_17(n)` a következő probléma megoldására:\nTaláld meg a leghosszabb egymást követő 1-esek sorozatának hosszát egy nem negatív egész szám bináris ábrázolásában.\n\nParaméterek:\n@param {number} n - Egy nem negatív egész szám (0 ≤ n ≤ 2^64 - 1).\n\nVisszatér:\n@returns {number} A leghosszabb egymást követő 1-esek sorozatának hossza a megadott egész szám bináris ábrázolásában.\n\nPéldák:\nf_17(7) === 3\nf_17(13) === 2", "es": "Escribe una función de JavaScript `function f_17(n)` para resolver el siguiente problema:\nEncuentra la longitud de la secuencia consecutiva más larga de 1s en la representación binaria de un entero no negativo.\n\nParámetros:\n@param {number} n - Un entero no negativo (0 ≤ n ≤ 2^64 - 1).\n\nDevuelve:\n@returns {number} La longitud de la secuencia consecutiva más larga de 1s en la representación binaria del entero dado.\n\nEjemplos:\nf_17(7) === 3\nf_17(13) === 2", "arb": "اكتب دالة JavaScript `function f_17(n)` لحل المشكلة التالية:\nاعثر على طول أطول تسلسل متتابع من الأرقام 1 في التمثيل الثنائي لعدد صحيح غير سالب.\n\nالمعطيات:\n@param {number} n - عدد صحيح غير سالب (0 ≤ n ≤ 2^64 - 1).\n\nالقيم المعادة:\n@returns {number} طول أطول تسلسل متتابع من الأرقام 1 في التمثيل الثنائي للعدد المعطى.\n\nأمثلة:\nf_17(7) === 3\nf_17(13) === 2", "sw": "Andika kazi ya JavaScript `function f_17(n)` kutatua tatizo lifuatalo:\nPata urefu wa mlolongo mrefu zaidi wa 1 mfululizo katika uwakilishi wa binary wa nambari isiyo hasi.\n\nVigezo:\n@param {number} n - Nambari isiyo hasi (0 ≤ n ≤ 2^64 - 1).\n\nInarudisha:\n@returns {number} Urefu wa mlolongo mrefu zaidi wa 1 mfululizo katika uwakilishi wa binary wa nambari iliyopewa.\n\nMifano:\nf_17(7) === 3\nf_17(13) === 2", "tr": "Bir JavaScript fonksiyonu `function f_17(n)` yazın ve aşağıdaki problemi çözün:\nBir negatif olmayan tamsayının ikili gösteriminde en uzun ardışık 1 dizisinin uzunluğunu bulun.\n\nParametreler:\n@param {number} n - Negatif olmayan bir tamsayı (0 ≤ n ≤ 2^64 - 1).\n\nDöndürür:\n@returns {number} Verilen tamsayının ikili gösteriminde en uzun ardışık 1 dizisinin uzunluğu.\n\nÖrnekler:\nf_17(7) === 3\nf_17(13) === 2", "vi": "Viết một hàm JavaScript `function f_17(n)` để giải quyết vấn đề sau:\nTìm độ dài của dãy liên tiếp dài nhất của các số 1 trong biểu diễn nhị phân của một số nguyên không âm.\n\nTham số:\n@param {number} n - Một số nguyên không âm (0 ≤ n ≤ 2^64 - 1).\n\nTrả về:\n@returns {number} Độ dài của dãy liên tiếp dài nhất của các số 1 trong biểu diễn nhị phân của số nguyên đã cho.\n\nVí dụ:\nf_17(7) === 3\nf_17(13) === 2", "id": "Tulis sebuah fungsi JavaScript `function f_17(n)` untuk menyelesaikan masalah berikut:\nTemukan panjang urutan terpanjang dari 1s berturut-turut dalam representasi biner dari bilangan bulat non-negatif.\n\nParameter:\n@param {number} n - Sebuah bilangan bulat non-negatif (0 ≤ n ≤ 2^64 - 1).\n\nMengembalikan:\n@returns {number} Panjang urutan terpanjang dari 1s berturut-turut dalam representasi biner dari bilangan bulat yang diberikan.\n\nContoh:\nf_17(7) === 3\nf_17(13) === 2", "ja": "JavaScript関数`function f_17(n)`を作成して、次の問題を解決してください:\n非負整数の2進数表現における1の連続したシーケンスの最長の長さを見つけてください。\n\nパラメータ:\n@param {number} n - 非負整数 (0 ≤ n ≤ 2^64 - 1)。\n\n戻り値:\n@returns {number} 与えられた整数の2進数表現における1の連続したシーケンスの最長の長さ。\n\n例:\nf_17(7) === 3\nf_17(13) === 2", "ko": "JavaScript 함수를 작성하십시오 `function f_17(n)` 다음 문제를 해결하기 위해:\n비음수 정수의 이진 표현에서 1의 가장 긴 연속 시퀀스의 길이를 찾으십시오.\n\n매개변수:\n@param {number} n - 비음수 정수 (0 ≤ n ≤ 2^64 - 1).\n\n반환:\n@returns {number} 주어진 정수의 이진 표현에서 1의 가장 긴 연속 시퀀스의 길이.\n\n예시:\nf_17(7) === 3\nf_17(13) === 2", "ml": "`function f_17(n)` എന്ന ജാവാസ്ക്രിപ്റ്റ് ഫംഗ്ഷൻ എഴുതുക താഴെ കാണിച്ചിരിക്കുന്ന പ്രശ്നം പരിഹരിക്കാൻ:  \nഒരു അഹിതകരമായ പൂർണ്ണസംഖ്യയുടെ ബൈനറി പ്രതിനിധാനത്തിൽ ഏറ്റവും നീളമേറിയ അനന്തരമായ 1കളുടെ ശ്രേണിയുടെ നീളം കണ്ടെത്തുക.\n\nപാരാമീറ്ററുകൾ:\n@param {number} n - ഒരു അഹിതകരമായ പൂർണ്ണസംഖ്യ (0 ≤ n ≤ 2^64 - 1).\n\nമടക്കിക്കൊടുക്കുന്നു:\n@returns {number} നൽകിയിരിക്കുന്ന പൂർണ്ണസംഖ്യയുടെ ബൈനറി പ്രതിനിധാനത്തിൽ ഏറ്റവും നീളമേറിയ അനന്തരമായ 1കളുടെ ശ്രേണിയുടെ നീളം.\n\nഉദാഹരണങ്ങൾ:\nf_17(7) === 3\nf_17(13) === 2", "fa": "یک تابع جاوااسکریپت `function f_17(n)` بنویسید تا مسئله زیر را حل کند:\nطول بلندترین دنباله متوالی از 1ها در نمایش باینری یک عدد صحیح غیرمنفی را پیدا کنید.\n\nپارامترها:\n@param {number} n - یک عدد صحیح غیرمنفی (0 ≤ n ≤ 2^64 - 1).\n\nبازگشت:\n@returns {number} طول بلندترین دنباله متوالی از 1ها در نمایش باینری عدد داده شده.\n\nمثال‌ها:\nf_17(7) === 3\nf_17(13) === 2"}, "level": "easy", "test": "const testf_17 = () => {\n    console.assert(f_17(7) === 3, \"Test with n = 7\");\n    console.assert(f_17(13) === 2, \"Test with n = 13\");\n    console.assert(f_17(12345) === 3, \"Test with n = 12345\");\n    console.assert(f_17(0b11011101111) === 4, \"Test with n = 0b11011101111\");\n    console.assert(f_17(0xFFFFFFFF) === 32, \"Test with n = 0xFFFFFFFF\");\n    console.assert(f_17(0) === 0, \"Test with n = 0\");\n\n    // console.log(\"All tests passed!\");\n}\n\ntestf_17();", "entry_point": "f_17", "signature": "function f_17(n)", "docstring": {"en": "Find the length of the longest consecutive sequence of 1s in the binary representation of a non-negative integer.\n\nParameters:\n@param {number} n - A non-negative integer (0 ≤ n ≤ 2^64 - 1).\n\nReturns:\n@returns {number} The length of the longest consecutive sequence of 1s in the binary representation of the given integer.\n\nExamples:\nf_17(7) === 3\nf_17(13) === 2\n", "sq": "Gjeni gjatësinë e sekuencës më të gjatë të njëshave radhazi në përfaqësimin binar të një numri jo-negativ.\n\nParametrat:\n@param {number} n - Një numër jo-negativ (0 ≤ n ≤ 2^64 - 1).\n\nKthen:\n@returns {number} Gjatësia e sekuencës më të gjatë të njëshave radhazi në përfaqësimin binar të numrit të dhënë.\n\nShembuj:\nf_17(7) === 3\nf_17(13) === 2", "hy": "Գտնել ամենաերկար հաջորդական 1-երի երկարությունը ոչ բացասական ամբողջ թվի երկբայական ներկայացման մեջ։\n\nՊարամետրեր:\n@param {number} n - Ոչ բացասական ամբողջ թիվ (0 ≤ n ≤ 2^64 - 1)։\n\nՎերադարձնում է:\n@returns {number} Տրված ամբողջ թվի երկբայական ներկայացման մեջ ամենաերկար հաջորդական 1-երի երկարությունը։\n\nՕրինակներ:\nf_17(7) === 3\nf_17(13) === 2", "bn": "একটি অ-ঋণাত্মক পূর্ণসংখ্যার বাইনারি উপস্থাপনার মধ্যে 1 এর দীর্ঘতম ক্রমিক অনুক্রমের দৈর্ঘ্য খুঁজে বের করুন।\n\nপ্যারামিটারসমূহ:\n@param {number} n - একটি অ-ঋণাত্মক পূর্ণসংখ্যা (0 ≤ n ≤ 2^64 - 1)।\n\nফেরত দেয়:\n@returns {number} প্রদত্ত পূর্ণসংখ্যার বাইনারি উপস্থাপনায় 1 এর দীর্ঘতম ধারাবাহিক ক্রমের দৈর্ঘ্য।\n\nউদাহরণসমূহ:\nf_17(7) === 3\nf_17(13) === 2", "bg": "Намерете дължината на най-дългата последователна поредица от 1-ци в двоичното представяне на неотрицателно цяло число.\n\nПараметри:\n@param {number} n - Неотрицателно цяло число (0 ≤ n ≤ 2^64 - 1).\n\nВръща:\n@returns {number} Дължината на най-дългата последователна поредица от 1-ци в двоичното представяне на даденото число.\n\nПримери:\nf_17(7) === 3\nf_17(13) === 2", "zh": "找到非负整数的二进制表示中最长连续1序列的长度。\n\n参数：\n@param {number} n - 一个非负整数 (0 ≤ n ≤ 2^64 - 1)。\n\n返回：\n@returns {number} 给定整数的二进制表示中最长连续1序列的长度。\n\n示例：\nf_17(7) === 3\nf_17(13) === 2", "fr": "Trouver la longueur de la plus longue séquence consécutive de 1 dans la représentation binaire d'un entier non négatif.\n\nParamètres:\n@param {number} n - Un entier non négatif (0 ≤ n ≤ 2^64 - 1).\n\nRenvoie:\n@returns {number} La longueur de la plus longue séquence consécutive de 1 dans la représentation binaire de l'entier donné.\n\nExemples:\nf_17(7) === 3\nf_17(13) === 2", "de": "Finde die Länge der längsten aufeinanderfolgenden Sequenz von 1en in der binären Darstellung einer nicht-negativen ganzen Zahl.\n\nParameter:\n@param {number} n - Eine nicht-negative ganze Zahl (0 ≤ n ≤ 2^64 - 1).\n\nRückgabewert:\n@returns {number} Die Länge der längsten aufeinanderfolgenden Sequenz von 1en in der binären Darstellung der gegebenen Zahl.\n\nBeispiele:\nf_17(7) === 3\nf_17(13) === 2", "ha": "Nemo tsawon jere mafi tsawo na 1s a cikin wakilcin binary na lamba mara kyau.\n\nSigogi:\n@param {number} n - Wani lamba mara kyau (0 ≤ n ≤ 2^64 - 1).\n\nDawowa:\n@returns {number} Tsawon jerin 1s mafi tsawo a cikin wakilcin binary na lambar da aka bayar.\n\nMisalai:\nf_17(7) === 3\nf_17(13) === 2", "hi": "एक गैर-ऋणात्मक पूर्णांक के बाइनरी प्रतिनिधित्व में 1s के सबसे लंबे अनुक्रम की लंबाई खोजें।\n\nपैरामीटर्स:\n@param {number} n - एक गैर-ऋणात्मक पूर्णांक (0 ≤ n ≤ 2^64 - 1)।\n\nवापसी:\n@returns {number} दिए गए पूर्णांक के बाइनरी प्रतिनिधित्व में 1s के सबसे लंबे अनुक्रम की लंबाई।\n\nउदाहरण:\nf_17(7) === 3\nf_17(13) === 2", "hu": "Keresse meg a leghosszabb egymást követő 1-es sorozat hosszát egy nem negatív egész szám bináris ábrázolásában.\n\nParaméterek:\n@param {number} n - Egy nem negatív egész szám (0 ≤ n ≤ 2^64 - 1).\n\nVisszatérési érték:\n@returns {number} A leghosszabb egymást követő 1-es sorozat hossza a megadott egész szám bináris ábrázolásában.\n\nPéldák:\nf_17(7) === 3\nf_17(13) === 2", "es": "Encuentra la longitud de la secuencia consecutiva más larga de 1s en la representación binaria de un número entero no negativo.\n\nParámetros:\n@param {number} n - Un número entero no negativo (0 ≤ n ≤ 2^64 - 1).\n\nDevuelve:\n@returns {number} La longitud de la secuencia consecutiva más larga de 1s en la representación binaria del número entero dado.\n\nEjemplos:\nf_17(7) === 3\nf_17(13) === 2", "arb": "ابحث عن طول أطول تسلسل متتابع من الأرقام 1 في التمثيل الثنائي لعدد صحيح غير سالب.\n\nالمعلمات:\n@param {number} n - عدد صحيح غير سالب (0 ≤ n ≤ 2^64 - 1).\n\nالقيم المعادة:\n@returns {number} طول أطول تسلسل متتابع من الأرقام 1 في التمثيل الثنائي للعدد الصحيح المعطى.\n\nأمثلة:\nf_17(7) === 3\nf_17(13) === 2", "sw": "Tafuta urefu wa mlolongo mrefu zaidi wa 1 mfululizo katika uwakilishi wa binary wa nambari isiyo hasi.\n\nVigezo:\n@param {number} n - Nambari isiyo hasi (0 ≤ n ≤ 2^64 - 1).\n\nInarejesha:\n@returns {number} Urefu wa mlolongo mrefu zaidi wa 1 mfululizo katika uwakilishi wa binary wa nambari iliyotolewa.\n\nMifano:\nf_17(7) === 3\nf_17(13) === 2", "tr": "Bir negatif olmayan tamsayının ikili gösteriminde en uzun ardışık 1 dizisinin uzunluğunu bulun.\n\nParametreler:\n@param {number} n - Negatif olmayan bir tam sayı (0 ≤ n ≤ 2^64 - 1).\n\nDöndürülenler:\n@returns {number} Verilen tam sayının ikili gösterimindeki en uzun ardışık 1 dizisinin uzunluğu.\n\nÖrnekler:\nf_17(7) === 3\nf_17(13) === 2", "vi": "Tìm độ dài của dãy liên tiếp dài nhất của các số 1 trong biểu diễn nhị phân của một số nguyên không âm.\n\nTham số:\n@param {number} n - Một số nguyên không âm (0 ≤ n ≤ 2^64 - 1).\n\nTrả về:\n@returns {number} Độ dài của dãy liên tiếp dài nhất của các số 1 trong biểu diễn nhị phân của số nguyên đã cho.\n\nVí dụ:\nf_17(7) === 3\nf_17(13) === 2", "id": "Temukan panjang dari urutan 1s terpanjang yang berurutan dalam representasi biner dari sebuah bilangan bulat non-negatif.\n\nParameter:\n@param {number} n - Sebuah bilangan bulat non-negatif (0 ≤ n ≤ 2^64 - 1).\n\nMengembalikan:\n@returns {number} Panjang dari urutan 1s terpanjang yang berurutan dalam representasi biner dari bilangan bulat yang diberikan.\n\nContoh:\nf_17(7) === 3\nf_17(13) === 2", "ja": "非負整数の2進数表現における1の最長連続シーケンスの長さを見つけます。\n\nパラメータ:\n@param {number} n - 非負整数 (0 ≤ n ≤ 2^64 - 1)。\n\n戻り値:\n@returns {number} 与えられた整数の2進数表現における1の最長連続シーケンスの長さ。\n\n例:\nf_17(7) === 3\nf_17(13) === 2", "ko": "비음수 정수의 이진 표현에서 1의 가장 긴 연속 시퀀스의 길이를 찾습니다.\n\n매개변수:\n@param {number} n - 0 이상의 정수 (0 ≤ n ≤ 2^64 - 1).\n\n반환값:\n@returns {number} 주어진 정수의 이진 표현에서 가장 긴 연속된 1의 시퀀스의 길이.\n\n예시:\nf_17(7) === 3\nf_17(13) === 2", "ml": "ഒരു അസാധാരണമല്ലാത്ത പൂർണ്ണസംഖ്യയുടെ ബൈനറി പ്രതിനിധാനത്തിൽ \n\nParameters:\n@param {number} n - ഒരു നെഗറ്റീവ് അല്ലാത്ത പൂർണ്ണസംഖ്യ (0 ≤ n ≤ 2^64 - 1).\n\nReturns:\n@returns {number} നൽകിയിരിക്കുന്ന പൂർണ്ണസംഖ്യയുടെ ബൈനറി പ്രതിനിധാനത്തിലെ ഏറ്റവും നീളമുള്ള തുടർച്ചയായ 1കളുടെ ശ്രേണിയുടെ നീളം.\n\nExamples:\nf_17(7) === 3\nf_17(13) === 2", "fa": "طول بلندترین دنباله متوالی از 1ها در نمایش باینری یک عدد صحیح غیرمنفی را پیدا کنید.\n\nپارامترها:\n@param {number} n - یک عدد صحیح غیرمنفی (0 ≤ n ≤ 2^64 - 1).\n\nبازگشت:\n@returns {number} طول بلندترین دنباله متوالی از 1ها در نمایش باینری عدد داده شده.\n\nمثال‌ها:\nf_17(7) === 3\nf_17(13) === 2"}}
{"task_id": "JavaScript/18", "prompt": {"en": "/**\n * Creates an ID by combining two strings in a specific manner.\n * Parameters:\n * - word1 (string): The first string to be used in the ID.\n * - word2 (string): The second string to be used in the ID.\n * Returns:\n * string: A divine ID formed by reversing every other character of the second \n *         string and combining it with the first string.\n * Example usage:\n *   f_18('fish','cat') // returns 'ftiasch'\n *   f_18('icpc','acm') // returns 'imccpac'\n */\nfunction f_18(word1, word2)", "sq": "/**\n * Krijon një ID duke kombinuar dy vargje në një mënyrë specifike.\n * Parametrat:\n * - word1 (string): Vargu i parë që do të përdoret në ID.\n * - word2 (string): Vargu i dytë që do të përdoret në ID.\n * Kthen:\n * string: Një ID hyjnore e formuar duke përmbysur çdo karakter tjetër të vargut të dytë\n *         dhe duke e kombinuar atë me vargun e parë.\n * Shembull përdorimi:\n *   f_18('fish','cat') // kthen 'ftiasch'\n *   f_18('icpc','acm') // kthen 'imccpac'\n */\nfunction f_18(word1, word2)", "hy": "/**\n * Ստեղծում է ID՝ երկու տողերը հատուկ ձևով համակցելով։\n * Պարամետրեր:\n * - word1 (string): Առաջին տողը, որը օգտագործվելու է ID-ում։\n * - word2 (string): Երկրորդ տողը, որը օգտագործվելու է ID-ում։\n * Վերադարձնում է:\n * string: Աստվածային ID, որը կազմվում է երկրորդ տողի ամեն երկրորդ նիշը շրջելով \n *         և այն առաջին տողի հետ համակցելով։\n * Օրինակ օգտագործում:\n *   f_18('fish','cat') // վերադարձնում է 'ftiasch'\n *   f_18('icpc','acm') // վերադարձնում է 'imccpac'\n */\nfunction f_18(word1, word2)", "bn": "/**\n * দুটি স্ট্রিংকে একটি নির্দিষ্ট পদ্ধতিতে একত্রিত করে একটি আইডি তৈরি করে।\n * প্যারামিটার:\n * - word1 (string): প্রথম স্ট্রিং যা আইডিতে ব্যবহৃত হবে।\n * - word2 (string): দ্বিতীয় স্ট্রিং যা আইডিতে ব্যবহৃত হবে।\n * রিটার্ন:\n * string: দ্বিতীয় স্ট্রিংয়ের প্রতিটি বিকল্প অক্ষর উল্টে দিয়ে এবং প্রথম স্ট্রিংয়ের সাথে \n *         একত্রিত করে একটি অনন্য আইডি তৈরি করে।\n * উদাহরণ ব্যবহার:\n *   f_18('fish','cat') // 'ftiasch' রিটার্ন করে\n *   f_18('icpc','acm') // 'imccpac' রিটার্ন করে\n */\nfunction f_18(word1, word2)", "bg": "/**\n * Създава ID, като комбинира два низа по специфичен начин.\n * Параметри:\n * - word1 (string): Първият низ, който ще се използва в ID.\n * - word2 (string): Вторият низ, който ще се използва в ID.\n * Връща:\n * string: Божествено ID, образувано чрез обръщане на всеки втори символ на втория \n *         низ и комбинирането му с първия низ.\n * Пример за използване:\n *   f_18('fish','cat') // връща 'ftiasch'\n *   f_18('icpc','acm') // връща 'imccpac'\n */\nfunction f_18(word1, word2)", "zh": "/**\n * 通过以特定方式组合两个字符串来创建一个ID。\n * 参数：\n * - word1 (string): 用于ID的第一个字符串。\n * - word2 (string): 用于ID的第二个字符串。\n * 返回：\n * string: 一个神圣的ID，通过反转第二个字符串的每隔一个字符并将其与第一个字符串结合而成。\n * 示例用法：\n *   f_18('fish','cat') // 返回 'ftiasch'\n *   f_18('icpc','acm') // 返回 'imccpac'\n */\nfunction f_18(word1, word2)", "fr": "/**\n * Crée un ID en combinant deux chaînes d'une manière spécifique.\n * Paramètres:\n * - word1 (string): La première chaîne à utiliser dans l'ID.\n * - word2 (string): La deuxième chaîne à utiliser dans l'ID.\n * Renvoie:\n * string: Un ID divin formé en inversant chaque autre caractère de la deuxième \n *         chaîne et en le combinant avec la première chaîne.\n * Exemple d'utilisation:\n *   f_18('fish','cat') // returns 'ftiasch'\n *   f_18('icpc','acm') // returns 'imccpac'\n */\nfunction f_18(word1, word2)", "de": "/**\n * Erstellt eine ID, indem zwei Zeichenfolgen auf eine bestimmte Weise kombiniert werden.\n * Parameter:\n * - word1 (string): Die erste Zeichenfolge, die in der ID verwendet werden soll.\n * - word2 (string): Die zweite Zeichenfolge, die in der ID verwendet werden soll.\n * Rückgabe:\n * string: Eine göttliche ID, die gebildet wird, indem jeder zweite Buchstabe der zweiten \n *         Zeichenfolge umgekehrt und mit der ersten Zeichenfolge kombiniert wird.\n * Beispielverwendung:\n *   f_18('fish','cat') // gibt 'ftiasch' zurück\n *   f_18('icpc','acm') // gibt 'imccpac' zurück\n */\nfunction f_18(word1, word2)", "ha": "/**\n * Yana ƙirƙirar ID ta hanyar haɗa kirtani biyu a cikin wata hanya ta musamman.\n * Sigogi:\n * - word1 (string): Kirtani na farko da za a yi amfani da shi a cikin ID.\n * - word2 (string): Kirtani na biyu da za a yi amfani da shi a cikin ID.\n * Yana dawowa:\n * string: Wani ID mai ban mamaki da aka samar ta hanyar juyar da kowanne harafi na biyu na kirtani na biyu \n *         da haɗa shi da kirtani na farko.\n * Misalin amfani:\n *   f_18('fish','cat') // yana dawowa 'ftiasch'\n *   f_18('icpc','acm') // yana dawowa 'imccpac'\n */\nfunction f_18(word1, word2)", "hi": "/**\n * दो स्ट्रिंग्स को एक विशिष्ट तरीके से जोड़कर एक आईडी बनाता है।\n * पैरामीटर्स:\n * - word1 (string): आईडी में उपयोग की जाने वाली पहली स्ट्रिंग।\n * - word2 (string): आईडी में उपयोग की जाने वाली दूसरी स्ट्रिंग।\n * रिटर्न करता है:\n * string: एक दिव्य आईडी जो दूसरी स्ट्रिंग के हर दूसरे अक्षर को उलटकर \n *         और इसे पहली स्ट्रिंग के साथ जोड़कर बनती है।\n * उदाहरण उपयोग:\n *   f_18('fish','cat') // 'ftiasch' लौटाता है\n *   f_18('icpc','acm') // 'imccpac' लौटाता है\n */\nfunction f_18(word1, word2)", "hu": "/**\n * Létrehoz egy azonosítót két sztring speciális módon történő kombinálásával.\n * Paraméterek:\n * - word1 (string): Az első sztring, amelyet az azonosítóban használunk.\n * - word2 (string): A második sztring, amelyet az azonosítóban használunk.\n * Visszatér:\n * string: Egy isteni azonosító, amelyet a második sztring minden második \n *         karakterének megfordításával és az első sztringgel való kombinálásával hozunk létre.\n * Példa használat:\n *   f_18('fish','cat') // visszaadja 'ftiasch'\n *   f_18('icpc','acm') // visszaadja 'imccpac'\n */\nfunction f_18(word1, word2)", "es": "/**\n * Crea un ID combinando dos cadenas de una manera específica.\n * Parámetros:\n * - word1 (string): La primera cadena a ser utilizada en el ID.\n * - word2 (string): La segunda cadena a ser utilizada en el ID.\n * Devuelve:\n * string: Un ID divino formado al invertir cada otro carácter de la segunda \n *         cadena y combinándolo con la primera cadena.\n * Ejemplo de uso:\n *   f_18('fish','cat') // devuelve 'ftiasch'\n *   f_18('icpc','acm') // devuelve 'imccpac'\n */\nfunction f_18(word1, word2)", "arb": "/**\n * ينشئ معرفًا عن طريق دمج سلسلتين بطريقة محددة.\n * المعاملات:\n * - word1 (string): السلسلة الأولى التي سيتم استخدامها في المعرف.\n * - word2 (string): السلسلة الثانية التي سيتم استخدامها في المعرف.\n * يعيد:\n * string: معرف فريد يتم تشكيله عن طريق عكس كل حرف آخر من السلسلة الثانية \n *         ودمجه مع السلسلة الأولى.\n * مثال على الاستخدام:\n *   f_18('fish','cat') // يعيد 'ftiasch'\n *   f_18('icpc','acm') // يعيد 'imccpac'\n */\nfunction f_18(word1, word2)", "sw": "/**\n * Huunda kitambulisho kwa kuchanganya mistari miwili kwa njia maalum.\n * Vigezo:\n * - word1 (string): Mstari wa kwanza utakaotumika kwenye kitambulisho.\n * - word2 (string): Mstari wa pili utakaotumika kwenye kitambulisho.\n * Inarudisha:\n * string: Kitambulisho cha kipekee kinachoundwa kwa kurudisha kila herufi nyingine ya \n *         mstari wa pili na kuichanganya na mstari wa kwanza.\n * Mfano wa matumizi:\n *   f_18('fish','cat') // inarudisha 'ftiasch'\n *   f_18('icpc','acm') // inarudisha 'imccpac'\n */\nfunction f_18(word1, word2)", "tr": "/**\n * İki dizeyi belirli bir şekilde birleştirerek bir kimlik oluşturur.\n * Parametreler:\n * - word1 (string): Kimlikte kullanılacak ilk dize.\n * - word2 (string): Kimlikte kullanılacak ikinci dize.\n * Döndürür:\n * string: İkinci dizenin her iki karakterini ters çevirerek ve birinci dizeyle \n *         birleştirerek oluşturulan ilahi bir kimlik.\n * Örnek kullanım:\n *   f_18('fish','cat') // 'ftiasch' döndürür\n *   f_18('icpc','acm') // 'imccpac' döndürür\n */\nfunction f_18(word1, word2)", "vi": "/**\n * Tạo một ID bằng cách kết hợp hai chuỗi theo một cách cụ thể.\n * Tham số:\n * - word1 (string): Chuỗi đầu tiên được sử dụng trong ID.\n * - word2 (string): Chuỗi thứ hai được sử dụng trong ID.\n * Trả về:\n * string: Một ID đặc biệt được tạo bằng cách đảo ngược mỗi ký tự khác của chuỗi thứ hai \n *         và kết hợp với chuỗi đầu tiên.\n * Ví dụ sử dụng:\n *   f_18('fish','cat') // trả về 'ftiasch'\n *   f_18('icpc','acm') // trả về 'imccpac'\n */\nfunction f_18(word1, word2)", "id": "/**\n * Membuat ID dengan menggabungkan dua string dengan cara tertentu.\n * Parameter:\n * - word1 (string): String pertama yang akan digunakan dalam ID.\n * - word2 (string): String kedua yang akan digunakan dalam ID.\n * Mengembalikan:\n * string: ID yang dibentuk dengan membalik setiap karakter kedua dari string kedua \n *         dan menggabungkannya dengan string pertama.\n * Contoh penggunaan:\n *   f_18('fish','cat') // mengembalikan 'ftiasch'\n *   f_18('icpc','acm') // mengembalikan 'imccpac'\n */\nfunction f_18(word1, word2)", "ja": "/**\n * 2つの文字列を特定の方法で組み合わせてIDを作成します。\n * パラメータ:\n * - word1 (string): IDに使用する最初の文字列。\n * - word2 (string): IDに使用する2番目の文字列。\n * 戻り値:\n * string: 2番目の文字列の1文字おきに反転させたものを最初の文字列と組み合わせて形成された神聖なID。\n * 使用例:\n *   f_18('fish','cat') // returns 'ftiasch'\n *   f_18('icpc','acm') // returns 'imccpac'\n */\nfunction f_18(word1, word2)", "ko": "/**\n * 두 문자열을 특정 방식으로 결합하여 ID를 생성합니다.\n * 매개변수:\n * - word1 (string): ID에 사용할 첫 번째 문자열입니다.\n * - word2 (string): ID에 사용할 두 번째 문자열입니다.\n * 반환값:\n * string: 두 번째 문자열의 모든 다른 문자를 뒤집고 첫 번째 문자열과 결합하여 형성된 신성한 ID입니다.\n * 사용 예:\n *   f_18('fish','cat') // 'ftiasch'를 반환합니다\n *   f_18('icpc','acm') // 'imccpac'를 반환합니다\n */\nfunction f_18(word1, word2)", "ml": "/**\n * രണ്ട് സ്ട്രിംഗുകൾ പ്രത്യേക രീതിയിൽ ചേർത്ത് ഒരു ഐഡി സൃഷ്ടിക്കുന്നു.\n * പാരാമീറ്ററുകൾ:\n * - word1 (string): ഐഡിയിൽ ഉപയോഗിക്കാൻ ഉള്ള ആദ്യത്തെ സ്ട്രിംഗ്.\n * - word2 (string): ഐഡിയിൽ ഉപയോഗിക്കാൻ ഉള്ള രണ്ടാം സ്ട്രിംഗ്.\n * റിട്ടേൺസ്:\n * string: രണ്ടാം സ്ട്രിംഗിന്റെ ഓരോ മറ്റൊരു അക്ഷരവും മറിച്ച് ആദ്യത്തെ സ്ട്രിംഗുമായി \n *         ചേർത്ത് രൂപീകരിച്ച ഒരു ദിവ്യമായ ഐഡി.\n * ഉദാഹരണ ഉപയോഗം:\n *   f_18('fish','cat') // 'ftiasch' റിട്ടേൺ ചെയ്യുന്നു\n *   f_18('icpc','acm') // 'imccpac' റിട്ടേൺ ചെയ്യുന്നു\n */\nfunction f_18(word1, word2)", "fa": "/**\n * ایجاد یک شناسه با ترکیب دو رشته به روش خاص.\n * پارامترها:\n * - word1 (string): اولین رشته‌ای که در شناسه استفاده می‌شود.\n * - word2 (string): دومین رشته‌ای که در شناسه استفاده می‌شود.\n * بازگشت:\n * string: یک شناسه خاص که با معکوس کردن هر کاراکتر دوم از رشته دوم \n *         و ترکیب آن با رشته اول تشکیل می‌شود.\n * مثال استفاده:\n *   f_18('fish','cat') // بازگشت 'ftiasch'\n *   f_18('icpc','acm') // بازگشت 'imccpac'\n */\nfunction f_18(word1, word2)"}, "canonical_solution": "{\n    let id = '';\n    for (let i = 0, k = 0, j = word2.length - 1; i < word1.length + word2.length; i++) {\n        if (i % 2 === 0) {\n            id += word1.charAt(k++); // Take character from word1\n        } else {\n            id += word2.charAt(j--); // Take character from word2 in reverse\n        }\n    }\n    return id;\n}", "instruction": {"en": "Write a JavaScript function `function f_18(word1, word2)` to solve the following problem:\nCreates an ID by combining two strings in a specific manner.\nParameters:\n- word1 (string): The first string to be used in the ID.\n- word2 (string): The second string to be used in the ID.\nReturns:\nstring: A divine ID formed by reversing every other character of the second string and combining it with the first string.\nExample usage:\n  f_18('fish','cat') // returns 'ftiasch'\n  f_18('icpc','acm') // returns 'imccpac'\n", "sq": "Shkruani një funksion JavaScript `function f_18(word1, word2)` për të zgjidhur problemin e mëposhtëm:\nKrijon një ID duke kombinuar dy vargje në një mënyrë specifike.\nParametrat:\n- word1 (string): Vargu i parë që do të përdoret në ID.\n- word2 (string): Vargu i dytë që do të përdoret në ID.\nKthen:\nstring: Një ID hyjnore e formuar duke kthyer mbrapsht çdo karakter tjetër të vargut të dytë dhe duke e kombinuar me vargun e parë.\nShembull përdorimi:\n  f_18('fish','cat') // kthen 'ftiasch'\n  f_18('icpc','acm') // kthen 'imccpac'", "hy": "Գրեք JavaScript ֆունկցիա `function f_18(word1, word2)` հետևյալ խնդիրը լուծելու համար:\nՍտեղծում է ID՝ երկու տողերը հատուկ ձևով համադրելով:\nՊարամետրեր:\n- word1 (string): Առաջին տողը, որը օգտագործվելու է ID-ում:\n- word2 (string): Երկրորդ տողը, որը օգտագործվելու է ID-ում:\nՎերադարձնում է:\nstring: Աստվածային ID, որը ձևավորվում է երկրորդ տողի յուրաքանչյուր երկրորդ սիմվոլը շրջելով և այն առաջին տողի հետ համադրելով:\nՕրինակ օգտագործում:\n  f_18('fish','cat') // վերադարձնում է 'ftiasch'\n  f_18('icpc','acm') // վերադարձնում է 'imccpac'", "bn": "একটি JavaScript ফাংশন `function f_18(word1, word2)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nদুটি স্ট্রিংকে একটি নির্দিষ্ট পদ্ধতিতে একত্রিত করে একটি আইডি তৈরি করে।\nপ্যারামিটারসমূহ:\n- word1 (string): আইডিতে ব্যবহৃত প্রথম স্ট্রিং।\n- word2 (string): আইডিতে ব্যবহৃত দ্বিতীয় স্ট্রিং।\nরিটার্ন করে:\nstring: দ্বিতীয় স্ট্রিংয়ের প্রতিটি বিকল্প অক্ষর উল্টে দিয়ে এবং প্রথম স্ট্রিংয়ের সাথে একত্রিত করে একটি অনন্য আইডি তৈরি করে।\nউদাহরণ ব্যবহার:\n  f_18('fish','cat') // 'ftiasch' রিটার্ন করে\n  f_18('icpc','acm') // 'imccpac' রিটার্ন করে", "bg": "Напишете функция на JavaScript `function f_18(word1, word2)` за решаване на следния проблем:\nСъздава ID, като комбинира два низа по специфичен начин.\nПараметри:\n- word1 (string): Първият низ, който ще бъде използван в ID.\n- word2 (string): Вторият низ, който ще бъде използван в ID.\nВръща:\nstring: Божествено ID, образувано чрез обръщане на всеки втори символ на втория низ и комбинирането му с първия низ.\nПример за използване:\n  f_18('fish','cat') // връща 'ftiasch'\n  f_18('icpc','acm') // връща 'imccpac'", "zh": "编写一个 JavaScript 函数 `function f_18(word1, word2)` 来解决以下问题：\n通过以特定方式组合两个字符串来创建一个 ID。\n参数：\n- word1 (string): 用于 ID 的第一个字符串。\n- word2 (string): 用于 ID 的第二个字符串。\n返回：\nstring: 一个神圣的 ID，通过反转第二个字符串的每隔一个字符并将其与第一个字符串组合而成。\n示例用法：\n  f_18('fish','cat') // returns 'ftiasch'\n  f_18('icpc','acm') // returns 'imccpac'", "fr": "Écrire une fonction JavaScript `function f_18(word1, word2)` pour résoudre le problème suivant :\nCrée un identifiant en combinant deux chaînes d'une manière spécifique.\nParamètres :\n- word1 (string) : La première chaîne à utiliser dans l'identifiant.\n- word2 (string) : La deuxième chaîne à utiliser dans l'identifiant.\nRenvoie :\nstring : Un identifiant divin formé en inversant chaque autre caractère de la deuxième chaîne et en le combinant avec la première chaîne.\nExemple d'utilisation :\n  f_18('fish','cat') // returns 'ftiasch'\n  f_18('icpc','acm') // returns 'imccpac'", "de": "Schreiben Sie eine JavaScript-Funktion `function f_18(word1, word2)`, um das folgende Problem zu lösen:\nErstellt eine ID, indem zwei Zeichenfolgen auf eine bestimmte Weise kombiniert werden.\nParameter:\n- word1 (string): Die erste Zeichenfolge, die in der ID verwendet werden soll.\n- word2 (string): Die zweite Zeichenfolge, die in der ID verwendet werden soll.\nGibt zurück:\nstring: Eine göttliche ID, die gebildet wird, indem jeder zweite Buchstabe der zweiten Zeichenfolge umgekehrt und mit der ersten Zeichenfolge kombiniert wird.\nBeispielverwendung:\n  f_18('fish','cat') // gibt 'ftiasch' zurück\n  f_18('icpc','acm') // gibt 'imccpac' zurück", "ha": "Rubuta wani aikin JavaScript `function f_18(word1, word2)` don magance matsalar mai zuwa:\nYana ƙirƙirar ID ta hanyar haɗa kirtani biyu a cikin wata hanya ta musamman.\nSigogi:\n- word1 (string): Kirtani na farko da za a yi amfani da shi a cikin ID.\n- word2 (string): Kirtani na biyu da za a yi amfani da shi a cikin ID.\nYana dawowa:\nstring: Wani ID mai ban mamaki da aka kafa ta hanyar juyar da kowanne harafi na biyu na kirtani na biyu da haɗa shi da kirtani na farko.\nMisalin amfani:\n  f_18('fish','cat') // returns 'ftiasch'\n  f_18('icpc','acm') // returns 'imccpac'", "hi": "एक जावास्क्रिप्ट फ़ंक्शन `function f_18(word1, word2)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदो स्ट्रिंग्स को एक विशिष्ट तरीके से मिलाकर एक आईडी बनाता है।\nपैरामीटर्स:\n- word1 (string): आईडी में उपयोग की जाने वाली पहली स्ट्रिंग।\n- word2 (string): आईडी में उपयोग की जाने वाली दूसरी स्ट्रिंग।\nरिटर्न करता है:\nstring: एक दिव्य आईडी जो दूसरी स्ट्रिंग के हर दूसरे अक्षर को उलटकर और इसे पहली स्ट्रिंग के साथ मिलाकर बनाई जाती है।\nउदाहरण उपयोग:\n  f_18('fish','cat') // 'ftiasch' लौटाता है\n  f_18('icpc','acm') // 'imccpac' लौटाता है", "hu": "Írj egy JavaScript függvényt `function f_18(word1, word2)` a következő probléma megoldására:\nLétrehoz egy azonosítót két string speciális módon történő kombinálásával.\nParaméterek:\n- word1 (string): Az első string, amelyet az azonosítóban használunk.\n- word2 (string): A második string, amelyet az azonosítóban használunk.\nVisszatérési érték:\nstring: Egy isteni azonosító, amely a második string minden második karakterének megfordításával és az első stringgel való kombinálásával jön létre.\nPélda használat:\n  f_18('fish','cat') // returns 'ftiasch'\n  f_18('icpc','acm') // returns 'imccpac'", "es": "Escribe una función de JavaScript `function f_18(word1, word2)` para resolver el siguiente problema:\nCrea un ID combinando dos cadenas de una manera específica.\nParámetros:\n- word1 (string): La primera cadena que se utilizará en el ID.\n- word2 (string): La segunda cadena que se utilizará en el ID.\nDevuelve:\nstring: Un ID divino formado al invertir cada otro carácter de la segunda cadena y combinándolo con la primera cadena.\nEjemplo de uso:\n  f_18('fish','cat') // devuelve 'ftiasch'\n  f_18('icpc','acm') // devuelve 'imccpac'", "arb": "اكتب دالة JavaScript `function f_18(word1, word2)` لحل المشكلة التالية:\nتقوم بإنشاء معرف عن طريق دمج سلسلتين نصيتين بطريقة محددة.\nالمعلمات:\n- word1 (string): السلسلة النصية الأولى التي سيتم استخدامها في المعرف.\n- word2 (string): السلسلة النصية الثانية التي سيتم استخدامها في المعرف.\nالقيمة المعادة:\nstring: معرف مميز يتم تكوينه عن طريق عكس كل حرف آخر من السلسلة النصية الثانية ودمجه مع السلسلة النصية الأولى.\nمثال على الاستخدام:\n  f_18('fish','cat') // يعيد 'ftiasch'\n  f_18('icpc','acm') // يعيد 'imccpac'", "sw": "Andika kazi ya JavaScript `function f_18(word1, word2)` kutatua tatizo lifuatalo:\nInaunda kitambulisho kwa kuchanganya mistari miwili kwa namna maalum.\nVigezo:\n- word1 (string): Mstari wa kwanza utakaotumika katika kitambulisho.\n- word2 (string): Mstari wa pili utakaotumika katika kitambulisho.\nInarudisha:\nstring: Kitambulisho cha kipekee kinachoundwa kwa kubadilisha mpangilio wa kila herufi nyingine ya mstari wa pili na kuuchanganya na mstari wa kwanza.\nMfano wa matumizi:\n  f_18('fish','cat') // inarudisha 'ftiasch'\n  f_18('icpc','acm') // inarudisha 'imccpac'", "tr": "Bir JavaScript fonksiyonu `function f_18(word1, word2)` yazın:\nBelirli bir şekilde iki dizeyi birleştirerek bir ID oluşturur.\nParametreler:\n- word1 (string): ID'de kullanılacak ilk dize.\n- word2 (string): ID'de kullanılacak ikinci dize.\nDöndürür:\nstring: İkinci dizenin her iki karakterini ters çevirerek ve birinci dize ile birleştirerek oluşturulan ilahi bir ID.\nÖrnek kullanım:\n  f_18('fish','cat') // 'ftiasch' döndürür\n  f_18('icpc','acm') // 'imccpac' döndürür", "vi": "Viết một hàm JavaScript `function f_18(word1, word2)` để giải quyết vấn đề sau:\nTạo một ID bằng cách kết hợp hai chuỗi theo một cách cụ thể.\nTham số:\n- word1 (string): Chuỗi đầu tiên được sử dụng trong ID.\n- word2 (string): Chuỗi thứ hai được sử dụng trong ID.\nTrả về:\nstring: Một ID đặc biệt được tạo bằng cách đảo ngược mỗi ký tự khác của chuỗi thứ hai và kết hợp nó với chuỗi đầu tiên.\nVí dụ sử dụng:\n  f_18('fish','cat') // trả về 'ftiasch'\n  f_18('icpc','acm') // trả về 'imccpac'", "id": "Buatlah fungsi JavaScript `function f_18(word1, word2)` untuk menyelesaikan masalah berikut:\nMembuat ID dengan menggabungkan dua string dengan cara tertentu.\nParameter:\n- word1 (string): String pertama yang akan digunakan dalam ID.\n- word2 (string): String kedua yang akan digunakan dalam ID.\nMengembalikan:\nstring: ID yang dibentuk dengan membalik setiap karakter kedua dari string kedua dan menggabungkannya dengan string pertama.\nContoh penggunaan:\n  f_18('fish','cat') // mengembalikan 'ftiasch'\n  f_18('icpc','acm') // mengembalikan 'imccpac'", "ja": "JavaScript関数`function f_18(word1, word2)`を作成して、次の問題を解決してください:\n特定の方法で2つの文字列を組み合わせてIDを作成します。\nパラメータ:\n- word1 (string): IDに使用する最初の文字列。\n- word2 (string): IDに使用する2番目の文字列。\n戻り値:\nstring: 2番目の文字列の1文字おきに反転させたものを最初の文字列と組み合わせて形成された神聖なID。\n使用例:\n  f_18('fish','cat') // 'ftiasch'を返します\n  f_18('icpc','acm') // 'imccpac'を返します", "ko": "JavaScript 함수를 작성하세요 `function f_18(word1, word2)` 다음 문제를 해결하기 위해:\n특정 방식으로 두 문자열을 결합하여 ID를 생성합니다.\n매개변수:\n- word1 (string): ID에 사용될 첫 번째 문자열.\n- word2 (string): ID에 사용될 두 번째 문자열.\n반환값:\nstring: 두 번째 문자열의 모든 다른 문자를 뒤집고 첫 번째 문자열과 결합하여 형성된 신성한 ID.\n사용 예:\n  f_18('fish','cat') // returns 'ftiasch'\n  f_18('icpc','acm') // returns 'imccpac'", "ml": "`function f_18(word1, word2)` എന്ന ജാവാസ്ക്രിപ്റ്റ് ഫംഗ്ഷൻ എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nരണ്ടു സ്ട്രിംഗുകൾ ഒരു പ്രത്യേക രീതിയിൽ ചേർത്ത് ഒരു ഐഡി സൃഷ്ടിക്കുന്നു.\nപാരാമീറ്ററുകൾ:\n- word1 (string): ഐഡിയിൽ ഉപയോഗിക്കാൻ ഉള്ള ആദ്യത്തെ സ്ട്രിംഗ്.\n- word2 (string): ഐഡിയിൽ ഉപയോഗിക്കാൻ ഉള്ള രണ്ടാമത്തെ സ്ട്രിംഗ്.\nമടക്കം:\nstring: രണ്ടാമത്തെ സ്ട്രിംഗിന്റെ ഓരോ മറ്റൊരു അക്ഷരവും മറിച്ച് ആദ്യം സ്ട്രിംഗുമായി ചേർത്ത് രൂപപ്പെടുത്തിയ ഒരു ദിവ്യമായ ഐഡി.\nഉദാഹരണ ഉപയോഗം:\n  f_18('fish','cat') // 'ftiasch' മടക്കം ചെയ്യുന്നു\n  f_18('icpc','acm') // 'imccpac' മടക്കം ചെയ്യുന്നു", "fa": "یک تابع جاوااسکریپت `function f_18(word1, word2)` بنویسید تا مسئله زیر را حل کند:\nیک شناسه با ترکیب دو رشته به روش خاصی ایجاد می‌کند.\nپارامترها:\n- word1 (string): اولین رشته‌ای که در شناسه استفاده می‌شود.\n- word2 (string): دومین رشته‌ای که در شناسه استفاده می‌شود.\nبرمی‌گرداند:\nstring: یک شناسه منحصر به فرد که با معکوس کردن هر کاراکتر دیگر از رشته دوم و ترکیب آن با رشته اول تشکیل شده است.\nمثال استفاده:\n  f_18('fish','cat') // برمی‌گرداند 'ftiasch'\n  f_18('icpc','acm') // برمی‌گرداند 'imccpac'"}, "level": "easy", "test": "function testf_18() {\n    // console.log(f_18(\"fish\", \"cat\"))\n    console.assert(f_18(\"fish\", \"cat\") === \"ftiasch\", 'Test failed: f_18(\"fish\", \"cat\") should be \"ftiasch\"');\n    console.assert(f_18(\"icpc\", \"acm\") === \"imccpac\", 'Test failed: f_18(\"icpc\", \"acm\") should be \"imccpac\"');\n    console.assert(f_18(\"oo\", \"w\") === \"owo\", 'Test failed: f_18(\"oo\", \"w\") should be \"owo\"');\n    console.assert(f_18(\"hello\", \"world\") === \"hdellrloow\", 'Test failed: f_18(\"hello\", \"world\") should be \"hdellrloow\"');\n    console.assert(f_18(\"abc\", \"def\") === \"afbecd\", 'Test failed: f_18(\"abc\", \"def\") should be \"afbecd\"');\n    console.assert(f_18(\"buaanb\", \"nbbuaa\") === \"bauaauabnbbn\", 'Test failed: f_18(\"buaanb\", \"nbbuaa\") should be \"bauaauabnbbn\"');\n    console.assert(f_18(\"xtuisgood\", \"ilovextu\") === \"xuttuxiesvgooloid\", 'Test failed: f_18(\"xtuisgood\", \"ilovextu\") should be \"xuttuxiesvgooloid\"');\n}\n\ntestf_18();", "entry_point": "f_18", "signature": "function f_18(word1, word2)", "docstring": {"en": "Creates an ID by combining two strings in a specific manner.\nParameters:\n- word1 (string): The first string to be used in the ID.\n- word2 (string): The second string to be used in the ID.\nReturns:\nstring: A divine ID formed by reversing every other character of the second string and combining it with the first string.\nExample usage:\n  f_18('fish','cat') // returns 'ftiasch'\n  f_18('icpc','acm') // returns 'imccpac'\n", "sq": "Krijon një ID duke kombinuar dy vargje në një mënyrë specifike.\nParametrat:\n- word1 (string): Vargu i parë që do të përdoret në ID.\n- word2 (string): Vargu i dytë që do të përdoret në ID.\nKthen:\nstring: Një ID hyjnore e formuar duke përmbysur çdo karakter tjetër të vargut të dytë dhe duke e kombinuar atë me vargun e parë.\nShembull përdorimi:\n  f_18('fish','cat') // kthen 'ftiasch'\n  f_18('icpc','acm') // kthen 'imccpac'", "hy": "Ստեղծում է ID՝ երկու տողերը հատուկ ձևով համադրելով։  \nՊարամետրեր:  \n- word1 (string): Առաջին տողը, որը կօգտագործվի ID-ում։  \n- word2 (string): Երկրորդ տողը, որը կօգտագործվի ID-ում։  \nՎերադարձնում է:  \nstring: Աստվածային ID, որը ձևավորվում է երկրորդ տողի յուրաքանչյուր երկրորդ նիշը շրջելով և այն առաջին տողի հետ համադրելով։  \nՕրինակ օգտագործում:  \n  f_18('fish','cat') // վերադարձնում է 'ftiasch'  \n  f_18('icpc','acm') // վերադարձնում է 'imccpac'  ", "bn": "দুটি স্ট্রিংকে একটি নির্দিষ্ট পদ্ধতিতে একত্রিত করে একটি আইডি তৈরি করে।  \nপ্যারামিটারসমূহ:  \n- word1 (string): ID তৈরিতে ব্যবহৃত প্রথম স্ট্রিং।  \n- word2 (string): ID তৈরিতে ব্যবহৃত দ্বিতীয় স্ট্রিং।  \nরিটার্নস:  \nstring: একটি অনন্য ID যা দ্বিতীয় স্ট্রিংয়ের প্রতিটি বিকল্প অক্ষর উল্টিয়ে এবং প্রথম স্ট্রিংয়ের সাথে মিলিয়ে তৈরি হয়।  \nব্যবহারের উদাহরণ:  \n  f_18('fish','cat') // returns 'ftiasch'  \n  f_18('icpc','acm') // returns 'imccpac'  ", "bg": "Създава ID, като комбинира два низа по специфичен начин.\nПараметри:\n- word1 (string): Първият низ, който ще се използва в ID.\n- word2 (string): Вторият низ, който ще се използва в ID.\nВръща:\nstring: Божествен ID, образуван чрез обръщане на всеки втори символ от втория низ и комбинирането му с първия низ.\nПример за използване:\n  f_18('fish','cat') // връща 'ftiasch'\n  f_18('icpc','acm') // връща 'imccpac'", "zh": "通过以特定方式组合两个字符串来创建一个ID。\n\n参数:\n- word1 (string): 用于ID的第一个字符串。\n- word2 (string): 用于ID的第二个字符串。\n\n返回:\nstring: 一个神奇的ID，通过反转第二个字符串的每隔一个字符并将其与第一个字符串组合而成。\n\n示例用法:\n  f_18('fish','cat') // 返回 'ftiasch'\n  f_18('icpc','acm') // 返回 'imccpac'", "fr": "Crée un ID en combinant deux chaînes de manière spécifique.\nParamètres :\n- word1 (string): La première chaîne à utiliser dans l'ID.\n- word2 (string): La deuxième chaîne à utiliser dans l'ID.\nRenvoie :\nstring: Un ID divin formé en inversant chaque autre caractère de la deuxième chaîne et en le combinant avec la première chaîne.\nExemple d'utilisation :\n  f_18('fish','cat') // renvoie 'ftiasch'\n  f_18('icpc','acm') // renvoie 'imccpac'", "de": "Erstellt eine ID, indem zwei Zeichenfolgen auf eine bestimmte Weise kombiniert werden.\nParameter:\n- word1 (string): Die erste Zeichenfolge, die in der ID verwendet wird.\n- word2 (string): Die zweite Zeichenfolge, die in der ID verwendet wird.\nRückgabewert:\nstring: Eine göttliche ID, die durch das Umkehren jedes zweiten Zeichens der zweiten Zeichenfolge gebildet und mit der ersten Zeichenfolge kombiniert wird.\nBeispielverwendung:\n  f_18('fish','cat') // gibt 'ftiasch' zurück\n  f_18('icpc','acm') // gibt 'imccpac' zurück", "ha": "Yana ƙirƙirar ID ta hanyar haɗa kirtani biyu a cikin wata hanya ta musamman.  \nSigogi:  \n- word1 (string): Kalmomin farko da za a yi amfani da su a cikin ID.  \n- word2 (string): Kalmomin na biyu da za a yi amfani da su a cikin ID.  \nDawowa:  \nstring: Wani ID mai ban mamaki da aka samar ta hanyar juyar da kowanne harafi na biyu na kalmomin na biyu sannan a haɗa shi da kalmomin farko.  \nMisalin amfani:  \n  f_18('fish','cat') // returns 'ftiasch'  \n  f_18('icpc','acm') // returns 'imccpac'  ", "hi": "दो स्ट्रिंग्स को एक विशिष्ट तरीके से जोड़कर एक आईडी बनाता है।  \nमापदंड:  \n- word1 (string): ID में उपयोग के लिए पहला स्ट्रिंग।  \n- word2 (string): ID में उपयोग के लिए दूसरा स्ट्रिंग।  \nवापसी:  \nstring: एक दिव्य ID जो दूसरे स्ट्रिंग के हर दूसरे अक्षर को उलट कर और पहले स्ट्रिंग के साथ जोड़ कर बनाई जाती है।  \nउदाहरण उपयोग:  \n  f_18('fish','cat') // 'ftiasch' लौटाता है  \n  f_18('icpc','acm') // 'imccpac' लौटाता है  ", "hu": "Létrehoz egy azonosítót két karakterlánc speciális módon történő kombinálásával.\nParaméterek:\n- word1 (string): Az első karakterlánc, amelyet az azonosítóban használunk.\n- word2 (string): A második karakterlánc, amelyet az azonosítóban használunk.\nVisszatérési érték:\nstring: Egy isteni azonosító, amelyet a második karakterlánc minden második karakterének megfordításával és az első karakterlánccal való kombinálásával hozunk létre.\nPélda használat:\n  f_18('fish','cat') // visszatér 'ftiasch'\n  f_18('icpc','acm') // visszatér 'imccpac'", "es": "Crea un ID combinando dos cadenas de una manera específica.\nParámetros:\n- word1 (string): La primera cadena a ser utilizada en el ID.\n- word2 (string): La segunda cadena a ser utilizada en el ID.\nDevuelve:\nstring: Un ID divino formado al invertir cada otro carácter de la segunda cadena y combinándolo con la primera cadena.\nEjemplo de uso:\n  f_18('fish','cat') // devuelve 'ftiasch'\n  f_18('icpc','acm') // devuelve 'imccpac'", "arb": "ينشئ معرفًا عن طريق دمج سلسلتين نصيتين بطريقة محددة.\nالمعلمات:\n- word1 (string): السلسلة النصية الأولى التي سيتم استخدامها في المعرف.\n- word2 (string): السلسلة النصية الثانية التي سيتم استخدامها في المعرف.\nالقيم المعادة:\nstring: معرف فريد يتكون من عكس كل حرف آخر من السلسلة النصية الثانية ودمجه مع السلسلة النصية الأولى.\nمثال على الاستخدام:\n  f_18('fish','cat') // يعيد 'ftiasch'\n  f_18('icpc','acm') // يعيد 'imccpac'", "sw": "Inaunda kitambulisho kwa kuchanganya mistari miwili kwa njia maalum.\nVigezo:\n- word1 (string): Mstari wa kwanza utakaotumika katika kitambulisho.\n- word2 (string): Mstari wa pili utakaotumika katika kitambulisho.\nInarudisha:\nstring: Kitambulisho cha kipekee kinachoundwa kwa kubadilisha mpangilio wa kila herufi nyingine ya mstari wa pili na kuuchanganya na mstari wa kwanza.\nMfano wa matumizi:\n  f_18('fish','cat') // inarudisha 'ftiasch'\n  f_18('icpc','acm') // inarudisha 'imccpac'", "tr": "Belirli bir şekilde iki dizeyi birleştirerek bir ID oluşturur.\nParametreler:\n- word1 (string): Kimlikte kullanılacak ilk dize.\n- word2 (string): Kimlikte kullanılacak ikinci dize.\nDöndürülen:\nstring: İkinci dizenin her iki karakterini ters çevirerek ve birinci dizeyle birleştirerek oluşturulan ilahi bir kimlik.\nÖrnek kullanım:\n  f_18('fish','cat') // 'ftiasch' döndürür\n  f_18('icpc','acm') // 'imccpac' döndürür", "vi": "Tạo một ID bằng cách kết hợp hai chuỗi theo một cách cụ thể.  \nTham số:  \n- word1 (string): Chuỗi đầu tiên được sử dụng trong ID.  \n- word2 (string): Chuỗi thứ hai được sử dụng trong ID.  \nTrả về:  \nstring: Một ID thần thánh được tạo bằng cách đảo ngược mỗi ký tự khác của chuỗi thứ hai và kết hợp với chuỗi đầu tiên.  \nVí dụ sử dụng:  \n  f_18('fish','cat') // trả về 'ftiasch'  \n  f_18('icpc','acm') // trả về 'imccpac'  ", "id": "Membuat ID dengan menggabungkan dua string dengan cara tertentu.  \nParameter:  \n- word1 (string): String pertama yang akan digunakan dalam ID.  \n- word2 (string): String kedua yang akan digunakan dalam ID.  \nMengembalikan:  \nstring: ID yang dibentuk dengan membalik setiap karakter kedua dari string kedua dan menggabungkannya dengan string pertama.  \nContoh penggunaan:  \n  f_18('fish','cat') // mengembalikan 'ftiasch'  \n  f_18('icpc','acm') // mengembalikan 'imccpac'  ", "ja": "特定の方法で2つの文字列を組み合わせてIDを作成します。\n引数:\n- word1 (string): IDで使用する最初の文字列。\n- word2 (string): IDで使用する2番目の文字列。\n戻り値:\nstring: 2番目の文字列の1文字おきに反転させたものを最初の文字列と組み合わせて形成された神聖なID。\n使用例:\n  f_18('fish','cat') // 'ftiasch'を返します\n  f_18('icpc','acm') // 'imccpac'を返します", "ko": "특정 방식으로 두 문자열을 결합하여 ID를 생성합니다.  \n매개변수:  \n- word1 (string): ID에 사용될 첫 번째 문자열입니다.  \n- word2 (string): ID에 사용될 두 번째 문자열입니다.  \n반환값:  \nstring: 두 번째 문자열의 모든 다른 문자를 뒤집고 첫 번째 문자열과 결합하여 형성된 신성한 ID입니다.  \n사용 예:  \n  f_18('fish','cat') // 'ftiasch'를 반환합니다.  \n  f_18('icpc','acm') // 'imccpac'를 반환합니다.  ", "ml": "രണ്ട് സ്ട്രിംഗുകൾ പ്രത്യേക രീതിയിൽ ചേർത്ത് ഒരു ഐഡി സൃഷ്ടിക്കുന്നു.  \nപാരാമീറ്ററുകൾ:  \n- word1 (string): ID-ൽ ഉപയോഗിക്കുന്ന ആദ്യത്തെ സ്ട്രിംഗ്.  \n- word2 (string): ID-ൽ ഉപയോഗിക്കുന്ന രണ്ടാമത്തെ സ്ട്രിംഗ്.  \nമടക്കം:  \nstring: രണ്ടാമത്തെ സ്ട്രിംഗിന്റെ ഓരോ മറ്റൊരു അക്ഷരവും മറിച്ചും ആദ്യത്തെ സ്ട്രിംഗുമായി ചേർത്ത് രൂപീകരിച്ച ഒരു ദിവ്യമായ ID.  \nഉദാഹരണ ഉപയോഗം:  \n  f_18('fish','cat') // 'ftiasch' മടക്കം ചെയ്യുന്നു  \n  f_18('icpc','acm') // 'imccpac' മടക്കം ചെയ്യുന്നു  ", "fa": "ایجاد یک شناسه با ترکیب دو رشته به روش خاص.  \nپارامترها:  \n- word1 (string): اولین رشته‌ای که در شناسه استفاده می‌شود.  \n- word2 (string): دومین رشته‌ای که در شناسه استفاده می‌شود.  \nبازگشت:  \nstring: یک شناسه خاص که با معکوس کردن هر کاراکتر دیگر از رشته دوم و ترکیب آن با رشته اول تشکیل می‌شود.  \nمثال استفاده:  \n  f_18('fish','cat') // returns 'ftiasch'  \n  f_18('icpc','acm') // returns 'imccpac'  "}}
{"task_id": "JavaScript/19", "prompt": {"en": "/**\n * Count the number of different permutation schemes for a binary string of length n,\n * where the number of '1's is m and the number of '0's is n - m.\n *\n * @param {number} n - Length of the binary string.\n * @param {number} m - Number of '1's in the binary string.\n *\n * @returns {number} The total number of different permutation schemes.\n */\nfunction f_19(n, m)", "sq": "/**\n * Numëron numrin e skemave të ndryshme të permutimit për një varg binar me gjatësi n,\n * ku numri i '1'-ve është m dhe numri i '0'-ve është n - m.\n *\n * @param {number} n - Gjatësia e vargut binar.\n * @param {number} m - Numri i '1'-ve në vargun binar.\n *\n * @returns {number} Numri total i skemave të ndryshme të permutimit.\n */\nfunction f_19(n, m)", "hy": "/**\n * Հաշվել տարբեր տեղաշարժման սխեմաների քանակը երկբայական տողի համար, որի երկարությունը n է,\n * որտեղ '1'-երի քանակը m է, իսկ '0'-երի քանակը n - m է:\n *\n * @param {number} n - Երկբայական տողի երկարությունը:\n * @param {number} m - '1'-երի քանակը երկբայական տողի մեջ:\n *\n * @returns {number} Տարբեր տեղաշարժման սխեմաների ընդհանուր քանակը:\n */\nfunction f_19(n, m)", "bn": "/**\n * একটি বাইনারি স্ট্রিংয়ের জন্য বিভিন্ন বিন্যাস স্কিমের সংখ্যা গণনা করুন যার দৈর্ঘ্য n,\n * যেখানে '1' এর সংখ্যা m এবং '0' এর সংখ্যা n - m।\n *\n * @param {number} n - বাইনারি স্ট্রিংয়ের দৈর্ঘ্য।\n * @param {number} m - বাইনারি স্ট্রিংয়ে '1' এর সংখ্যা।\n *\n * @returns {number} বিভিন্ন বিন্যাস স্কিমের মোট সংখ্যা।\n */\nfunction f_19(n, m)", "bg": "/**\n * Пребройте броя на различните схеми на пермутации за двоична низ с дължина n,\n * където броят на '1'-ците е m, а броят на '0'-ците е n - m.\n *\n * @param {number} n - Дължина на двоичната низ.\n * @param {number} m - Брой на '1'-ците в двоичната низ.\n *\n * @returns {number} Общият брой на различните схеми на пермутации.\n */\nfunction f_19(n, m)", "zh": "/**\n * 计算长度为 n 的二进制字符串的不同排列方案数量，\n * 其中 '1' 的数量为 m，'0' 的数量为 n - m。\n *\n * @param {number} n - 二进制字符串的长度。\n * @param {number} m - 二进制字符串中 '1' 的数量。\n *\n * @returns {number} 不同排列方案的总数量。\n */\nfunction f_19(n, m)", "fr": "/**\n * Compter le nombre de différents schémas de permutation pour une chaîne binaire de longueur n,\n * où le nombre de '1' est m et le nombre de '0' est n - m.\n *\n * @param {number} n - Longueur de la chaîne binaire.\n * @param {number} m - Nombre de '1' dans la chaîne binaire.\n *\n * @returns {number} Le nombre total de différents schémas de permutation.\n */\nfunction f_19(n, m)", "de": "/**\n * Zähle die Anzahl der verschiedenen Permutationsschemata für einen Binärstring der Länge n,\n * wobei die Anzahl der '1's m ist und die Anzahl der '0's n - m ist.\n *\n * @param {number} n - Länge des Binärstrings.\n * @param {number} m - Anzahl der '1's im Binärstring.\n *\n * @returns {number} Die Gesamtanzahl der verschiedenen Permutationsschemata.\n */\nfunction f_19(n, m)", "ha": "/**\n * Ƙididdige yawan tsarin permutation daban-daban don igiyar binary mai tsawon n,\n * inda adadin '1's shine m kuma adadin '0's shine n - m.\n *\n * @param {number} n - Tsawon igiyar binary.\n * @param {number} m - Adadin '1's a cikin igiyar binary.\n *\n * @returns {number} Jimillar yawan tsarin permutation daban-daban.\n */\nfunction f_19(n, m)", "hi": "/**\n * एक बाइनरी स्ट्रिंग की लंबाई n के लिए विभिन्न क्रमपरिवर्तन योजनाओं की संख्या गिनें,\n * जहाँ '1's की संख्या m है और '0's की संख्या n - m है।\n *\n * @param {number} n - बाइनरी स्ट्रिंग की लंबाई।\n * @param {number} m - बाइनरी स्ट्रिंग में '1's की संख्या।\n *\n * @returns {number} विभिन्न क्रमपरिवर्तन योजनाओं की कुल संख्या।\n */\nfunction f_19(n, m)", "hu": "/**\n * Számolja meg a különböző permutációs sémák számát egy n hosszúságú bináris karakterlánc esetén,\n * ahol az '1'-ek száma m, és a '0'-ék száma n - m.\n *\n * @param {number} n - A bináris karakterlánc hossza.\n * @param {number} m - Az '1'-ek száma a bináris karakterláncban.\n *\n * @returns {number} A különböző permutációs sémák összesített száma.\n */\nfunction f_19(n, m)", "es": "/**\n * Cuenta el número de diferentes esquemas de permutación para una cadena binaria de longitud n,\n * donde el número de '1's es m y el número de '0's es n - m.\n *\n * @param {number} n - Longitud de la cadena binaria.\n * @param {number} m - Número de '1's en la cadena binaria.\n *\n * @returns {number} El número total de diferentes esquemas de permutación.\n */\nfunction f_19(n, m)", "arb": "/**\n * احسب عدد مخططات التبديل المختلفة لسلسلة ثنائية بطول n،\n * حيث يكون عدد '1's هو m وعدد '0's هو n - m.\n *\n * @param {number} n - طول السلسلة الثنائية.\n * @param {number} m - عدد '1's في السلسلة الثنائية.\n *\n * @returns {number} العدد الإجمالي لمخططات التبديل المختلفة.\n */\nfunction f_19(n, m)", "sw": "/**\n * Hesabu idadi ya mipangilio tofauti ya mfuatano wa tarakimu mbili wa urefu n,\n * ambapo idadi ya '1's ni m na idadi ya '0's ni n - m.\n *\n * @param {number} n - Urefu wa mfuatano wa tarakimu mbili.\n * @param {number} m - Idadi ya '1's katika mfuatano wa tarakimu mbili.\n *\n * @returns {number} Jumla ya idadi ya mipangilio tofauti.\n */\nfunction f_19(n, m)", "tr": "/**\n * Uzunluğu n olan bir ikili dizgi için, '1'lerin sayısının m ve '0'ların sayısının n - m olduğu\n * farklı permütasyon şemalarının sayısını hesaplayın.\n *\n * @param {number} n - İkili dizginin uzunluğu.\n * @param {number} m - İkili dizgideki '1'lerin sayısı.\n *\n * @returns {number} Farklı permütasyon şemalarının toplam sayısı.\n */\nfunction f_19(n, m)", "vi": "/**\n * Đếm số lượng các sơ đồ hoán vị khác nhau cho một chuỗi nhị phân có độ dài n,\n * trong đó số lượng '1' là m và số lượng '0' là n - m.\n *\n * @param {number} n - Độ dài của chuỗi nhị phân.\n * @param {number} m - Số lượng '1' trong chuỗi nhị phân.\n *\n * @returns {number} Tổng số lượng các sơ đồ hoán vị khác nhau.\n */\nfunction f_19(n, m)", "id": "/**\n * Hitung jumlah skema permutasi berbeda untuk string biner dengan panjang n,\n * di mana jumlah '1' adalah m dan jumlah '0' adalah n - m.\n *\n * @param {number} n - Panjang dari string biner.\n * @param {number} m - Jumlah '1' dalam string biner.\n *\n * @returns {number} Jumlah total skema permutasi berbeda.\n */\nfunction f_19(n, m)", "ja": "/**\n * 長さ n のバイナリ文字列に対する異なる順列スキームの数を数えます。\n * ここで、'1' の数は m で、'0' の数は n - m です。\n *\n * @param {number} n - バイナリ文字列の長さ。\n * @param {number} m - バイナリ文字列内の '1' の数。\n *\n * @returns {number} 異なる順列スキームの総数。\n */\nfunction f_19(n, m)", "ko": "/**\n * 길이가 n인 이진 문자열에 대해, '1'의 개수가 m이고 '0'의 개수가 n - m인 경우의 서로 다른 순열의 수를 계산합니다.\n *\n * @param {number} n - 이진 문자열의 길이.\n * @param {number} m - 이진 문자열에서 '1'의 개수.\n *\n * @returns {number} 서로 다른 순열의 총 수.\n */\nfunction f_19(n, m)", "ml": "/**\n * നീളമുള്ള ബൈനറി സ്ട്രിംഗിന് വ്യത്യസ്തമായ പെർമ്യൂട്ടേഷൻ സ്കീമുകളുടെ എണ്ണം എണ്ണുക n,\n * ഇവിടെ '1' കളുടെ എണ്ണം m ആണ്, '0' കളുടെ എണ്ണം n - m ആണ്.\n *\n * @param {number} n - ബൈനറി സ്ട്രിംഗിന്റെ നീളം.\n * @param {number} m - ബൈനറി സ്ട്രിംഗിലെ '1' കളുടെ എണ്ണം.\n *\n * @returns {number} വ്യത്യസ്തമായ പെർമ്യൂട്ടേഷൻ സ്കീമുകളുടെ മൊത്തം എണ്ണം.\n */\nfunction f_19(n, m)", "fa": "/**\n * تعداد طرح‌های مختلف جایگشت برای یک رشته باینری با طول n را بشمارید،\n * که تعداد '1'ها برابر با m و تعداد '0'ها برابر با n - m است.\n *\n * @param {number} n - طول رشته باینری.\n * @param {number} m - تعداد '1'ها در رشته باینری.\n *\n * @returns {number} تعداد کل طرح‌های مختلف جایگشت.\n */\nfunction f_19(n, m)"}, "canonical_solution": "{\n    let factorial = 1;\n    let i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    let numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    let denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    let denominator2 = factorial; // ((n-m)/2)!\n\n    // Check for edge cases\n    if ((n + m) % 2 === 1) {\n        return 0;\n    } else if (n === m) {\n        return 1;\n    } else {\n        // Calculating the number of permutations using the factorial values\n        return Math.round(numerator / denominator1 / denominator2);\n    }\n}", "instruction": {"en": "Write a JavaScript function `function f_19(n, m)` to solve the following problem:\nCount the number of different permutation schemes for a binary string of length n, where the number of '1's is m and the number of '0's is n - m.\n\nParameters:\n@param {number} n - Length of the binary string.\n@param {number} m - Number of '1's in the binary string.\n\nReturns:\n@returns {number} The total number of different permutation schemes.", "sq": "Shkruani një funksion JavaScript `function f_19(n, m)` për të zgjidhur problemin e mëposhtëm:\nNumëroni numrin e skemave të ndryshme të permutimit për një varg binar me gjatësi n, ku numri i '1'-ve është m dhe numri i '0'-ve është n - m.\n\nParametrat:\n@param {number} n - Gjatësia e vargut binar.\n@param {number} m - Numri i '1'-ve në vargun binar.\n\nKthen:\n@returns {number} Numri total i skemave të ndryshme të permutimit.", "hy": "Գրեք JavaScript ֆունկցիա `function f_19(n, m)` հետևյալ խնդիրը լուծելու համար:\nՀաշվեք տարբեր տեղաբաշխման սխեմաների քանակը երկբայնային տողի համար, որի երկարությունը n է, որտեղ '1'-երի քանակը m է և '0'-երի քանակը n - m է։\n\nՊարամետրեր:\n@param {number} n - Երկբայնային տողի երկարությունը։\n@param {number} m - '1'-երի քանակը երկբայնային տողում։\n\nՎերադարձնում է:\n@returns {number} Տարբեր տեղաբաշխման սխեմաների ընդհանուր քանակը։", "bn": "একটি JavaScript ফাংশন `function f_19(n, m)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি বাইনারি স্ট্রিংয়ের বিভিন্ন বিন্যাস প্রকল্পের সংখ্যা গণনা করুন যার দৈর্ঘ্য n, যেখানে '1' এর সংখ্যা m এবং '0' এর সংখ্যা n - m।\n\nপ্যারামিটারসমূহ:\n@param {number} n - বাইনারি স্ট্রিংয়ের দৈর্ঘ্য।\n@param {number} m - বাইনারি স্ট্রিংয়ে '1' এর সংখ্যা।\n\nরিটার্নস:\n@returns {number} বিভিন্ন বিন্যাস প্রকল্পের মোট সংখ্যা।", "bg": "Напишете JavaScript функция `function f_19(n, m)` за решаване на следния проблем:\nПребройте броя на различните схеми на пермутации за двоична низ с дължина n, където броят на '1'-ците е m и броят на '0'-ите е n - m.\n\nПараметри:\n@param {number} n - Дължина на двоичния низ.\n@param {number} m - Брой на '1'-ците в двоичния низ.\n\nВръща:\n@returns {number} Общият брой на различните схеми на пермутации.", "zh": "编写一个 JavaScript 函数 `function f_19(n, m)` 来解决以下问题：\n计算长度为 n 的二进制字符串中，不同排列方案的数量，其中 '1' 的数量为 m，'0' 的数量为 n - m。\n\n参数：\n@param {number} n - 二进制字符串的长度。\n@param {number} m - 二进制字符串中 '1' 的数量。\n\n返回：\n@returns {number} 不同排列方案的总数。", "fr": "Écrire une fonction JavaScript `function f_19(n, m)` pour résoudre le problème suivant :\nCompter le nombre de différents schémas de permutation pour une chaîne binaire de longueur n, où le nombre de '1' est m et le nombre de '0' est n - m.\n\nParamètres :\n@param {number} n - Longueur de la chaîne binaire.\n@param {number} m - Nombre de '1' dans la chaîne binaire.\n\nRetourne :\n@returns {number} Le nombre total de différents schémas de permutation.", "de": "Schreiben Sie eine JavaScript-Funktion `function f_19(n, m)`, um das folgende Problem zu lösen:\nZählen Sie die Anzahl der verschiedenen Permutationsschemata für einen Binärstring der Länge n, wobei die Anzahl der '1's m und die Anzahl der '0's n - m ist.\n\nParameter:\n@param {number} n - Länge des Binärstrings.\n@param {number} m - Anzahl der '1's im Binärstring.\n\nRückgabe:\n@returns {number} Die Gesamtanzahl der verschiedenen Permutationsschemata.", "ha": "Rubuta aikin JavaScript `function f_19(n, m)` don warware matsalar mai zuwa:  \nƘididdige adadin tsarin permutation daban-daban don igiyar binary mai tsawon n, inda adadin '1's shine m kuma adadin '0's shine n - m.\n\nSigogi:\n@param {number} n - Tsawon igiyar binary.\n@param {number} m - Adadin '1's a cikin igiyar binary.\n\nDawowa:\n@returns {number} Jimillar adadin tsarin permutation daban-daban.", "hi": "JavaScript फ़ंक्शन `function f_19(n, m)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nलंबाई n की एक बाइनरी स्ट्रिंग के लिए विभिन्न क्रमपरिवर्तन योजनाओं की संख्या गिनें, जहाँ '1's की संख्या m है और '0's की संख्या n - m है।\n\nपैरामीटर्स:\n@param {number} n - बाइनरी स्ट्रिंग की लंबाई।\n@param {number} m - बाइनरी स्ट्रिंग में '1's की संख्या।\n\nवापसी:\n@returns {number} विभिन्न क्रमपरिवर्तन योजनाओं की कुल संख्या।", "hu": "Írj egy JavaScript függvényt `function f_19(n, m)` a következő probléma megoldására:\nSzámold meg a különböző permutációs sémák számát egy n hosszúságú bináris karakterláncra, ahol az '1'-ek száma m és a '0'-k száma n - m.\n\nParaméterek:\n@param {number} n - A bináris karakterlánc hossza.\n@param {number} m - Az '1'-ek száma a bináris karakterláncban.\n\nVisszatérési érték:\n@returns {number} A különböző permutációs sémák teljes száma.", "es": "Escribe una función de JavaScript `function f_19(n, m)` para resolver el siguiente problema:\nCuenta el número de diferentes esquemas de permutación para una cadena binaria de longitud n, donde el número de '1's es m y el número de '0's es n - m.\n\nParámetros:\n@param {number} n - Longitud de la cadena binaria.\n@param {number} m - Número de '1's en la cadena binaria.\n\nDevuelve:\n@returns {number} El número total de diferentes esquemas de permutación.", "arb": "اكتب دالة JavaScript `function f_19(n, m)` لحل المشكلة التالية:\nاحسب عدد مخططات التبديل المختلفة لسلسلة ثنائية بطول n، حيث يكون عدد '1's هو m وعدد '0's هو n - m.\n\nالمعلمات:\n@param {number} n - طول السلسلة الثنائية.\n@param {number} m - عدد '1's في السلسلة الثنائية.\n\nالإرجاع:\n@returns {number} إجمالي عدد مخططات التبديل المختلفة.", "sw": "Andika kazi ya JavaScript `function f_19(n, m)` kutatua tatizo lifuatalo:\nHesabu idadi ya mipango tofauti ya mpangilio kwa kamba ya binary yenye urefu n, ambapo idadi ya '1' ni m na idadi ya '0' ni n - m.\n\nVigezo:\n@param {number} n - Urefu wa kamba ya binary.\n@param {number} m - Idadi ya '1' katika kamba ya binary.\n\nInarudisha:\n@returns {number} Jumla ya idadi ya mipango tofauti ya mpangilio.", "tr": "Bir JavaScript fonksiyonu `function f_19(n, m)` yazın ve aşağıdaki problemi çözün:\nUzunluğu n olan bir ikili dizge için, '1'lerin sayısının m ve '0'ların sayısının n - m olduğu farklı permütasyon şemalarının sayısını sayın.\n\nParametreler:\n@param {number} n - İkili dizgenin uzunluğu.\n@param {number} m - İkili dizgedeki '1'lerin sayısı.\n\nDöndürür:\n@returns {number} Farklı permütasyon şemalarının toplam sayısı.", "vi": "Viết một hàm JavaScript `function f_19(n, m)` để giải quyết vấn đề sau:\nĐếm số lượng các sơ đồ hoán vị khác nhau cho một chuỗi nhị phân có độ dài n, trong đó số lượng '1' là m và số lượng '0' là n - m.\n\nTham số:\n@param {number} n - Độ dài của chuỗi nhị phân.\n@param {number} m - Số lượng '1' trong chuỗi nhị phân.\n\nTrả về:\n@returns {number} Tổng số các sơ đồ hoán vị khác nhau.", "id": "Tulis sebuah fungsi JavaScript `function f_19(n, m)` untuk menyelesaikan masalah berikut:\nHitung jumlah skema permutasi berbeda untuk sebuah string biner dengan panjang n, di mana jumlah '1' adalah m dan jumlah '0' adalah n - m.\n\nParameter:\n@param {number} n - Panjang dari string biner.\n@param {number} m - Jumlah '1' dalam string biner.\n\nMengembalikan:\n@returns {number} Jumlah total skema permutasi yang berbeda.", "ja": "JavaScript関数 `function f_19(n, m)` を作成して、次の問題を解決してください:\n長さnの2進文字列において、'1'の数がmであり、'0'の数がn - mである場合の異なる順列スキームの数を数えます。\n\nパラメータ:\n@param {number} n - 2進文字列の長さ。\n@param {number} m - 2進文字列内の'1'の数。\n\n戻り値:\n@returns {number} 異なる順列スキームの総数。", "ko": "JavaScript 함수를 작성하세요 `function f_19(n, m)` 다음 문제를 해결하기 위해:\n길이가 n인 이진 문자열에서 '1'의 개수가 m이고 '0'의 개수가 n - m일 때, 서로 다른 순열 방식의 수를 계산합니다.\n\n매개변수:\n@param {number} n - 이진 문자열의 길이.\n@param {number} m - 이진 문자열에서 '1'의 개수.\n\n반환값:\n@returns {number} 서로 다른 순열 방식의 총 개수.", "ml": "JavaScript ഫംഗ്ഷൻ `function f_19(n, m)` എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nനീളം n ആയ ബൈനറി സ്ട്രിങ്ങിന്, '1' കളുടെ എണ്ണം m ആയും '0' കളുടെ എണ്ണം n - m ആയും ഉള്ള വ്യത്യസ്ത പെർമ്യൂട്ടേഷൻ സ്കീമുകളുടെ എണ്ണം എണ്ണുക.\n\nപാരാമീറ്ററുകൾ:\n@param {number} n - ബൈനറി സ്ട്രിങ്ങിന്റെ നീളം.\n@param {number} m - ബൈനറി സ്ട്രിങ്ങിലെ '1' കളുടെ എണ്ണം.\n\nമടക്കിക്കൊടുക്കുന്നു:\n@returns {number} വ്യത്യസ്ത പെർമ്യൂട്ടേഷൻ സ്കീമുകളുടെ മൊത്തം എണ്ണം.", "fa": "یک تابع جاوااسکریپت `function f_19(n, m)` بنویسید تا مسئله زیر را حل کند:\nتعداد طرح‌های مختلف جایگشت برای یک رشته باینری با طول n را بشمارید، جایی که تعداد '1'ها برابر با m و تعداد '0'ها برابر با n - m است.\n\nپارامترها:\n@param {number} n - طول رشته باینری.\n@param {number} m - تعداد '1'ها در رشته باینری.\n\nبازگشت:\n@returns {number} تعداد کل طرح‌های مختلف جایگشت."}, "level": "hard", "test": "function testf_19() {\n    console.assert(f_19(2, 0) === 2);\n    console.assert(f_19(2, 1) === 0);\n    console.assert(f_19(3, 0) === 0);\n    console.assert(f_19(3, 1) === 3);\n    console.assert(f_19(3, 2) === 0);\n    console.assert(f_19(30, 2) === 145422675);\n    console.assert(f_19(4, 2) === 4);\n    console.assert(f_19(5, 5) === 1);\n    console.assert(f_19(33, 17) === 13884156);\n    console.assert(f_19(1000, 1000) === 1);\n    // Add more test cases if necessary\n}\n\ntestf_19();", "entry_point": "f_19", "signature": "function f_19(n, m)", "docstring": {"en": "Count the number of different permutation schemes for a binary string of length n, where the number of '1's is m and the number of '0's is n - m.\n\nParameters:\n@param {number} n - Length of the binary string.\n@param {number} m - Number of '1's in the binary string.\n\nReturns:\n@returns {number} The total number of different permutation schemes.", "sq": "Numëroni numrin e skemave të ndryshme të permutimit për një varg binar me gjatësi n, ku numri i '1'-ve është m dhe numri i '0'-ve është n - m.\n\nParametrat:\n@param {number} n - Gjatësia e vargut binar.\n@param {number} m - Numri i '1'-ve në vargun binar.\n\nKthen:\n@returns {number} Numri total i skemave të ndryshme të permutimit.", "hy": "Հաշվել տարբեր փոխարկման սխեմաների քանակը երկբայնային տողի համար, որի երկարությունը n է, որտեղ '1'-երի քանակը m է, իսկ '0'-երի քանակը n - m է։\n\nՊարամետրեր:\n@param {number} n - Երկբայնային տողի երկարությունը։\n@param {number} m - '1'-երի քանակը երկբայնային տողի մեջ։\n\nՎերադարձնում է:\n@returns {number} Տարբեր փոխարկման սխեմաների ընդհանուր քանակը։", "bn": "বাইনারি স্ট্রিংয়ের দৈর্ঘ্য n এর জন্য বিভিন্ন বিন্যাস প্রকল্পের সংখ্যা গণনা করুন, যেখানে '1' এর সংখ্যা m এবং '0' এর সংখ্যা n - m।\n\nপ্যারামিটার:\n@param {number} n - বাইনারি স্ট্রিংয়ের দৈর্ঘ্য।\n@param {number} m - বাইনারি স্ট্রিংয়ে '1' এর সংখ্যা।\n\nফেরত দেয়:\n@returns {number} বিভিন্ন বিন্যাস প্রকল্পের মোট সংখ্যা।", "bg": "Бройте броя на различните схеми на пермутации за двоична верига с дължина n, където броят на '1'-ците е m и броят на '0'-ците е n - m.\n\nПараметри:\n@param {number} n - Дължина на двоичната верига.\n@param {number} m - Брой на '1'-ците в двоичната верига.\n\nВръща:\n@returns {number} Общият брой на различните схеми на пермутации.", "zh": "计算长度为 n 的二进制字符串的不同排列方案数量，其中 '1' 的数量为 m，'0' 的数量为 n - m。\n\n参数：\n@param {number} n - 二进制字符串的长度。\n@param {number} m - 二进制字符串中 '1' 的数量。\n\n返回：\n@returns {number} 不同排列方案的总数量。", "fr": "Comptez le nombre de différents schémas de permutation pour une chaîne binaire de longueur n, où le nombre de '1' est m et le nombre de '0' est n - m.\n\nParamètres:\n@param {number} n - Longueur de la chaîne binaire.\n@param {number} m - Nombre de '1' dans la chaîne binaire.\n\nRenvoie:\n@returns {number} Le nombre total de différents schémas de permutation.", "de": "Zähle die Anzahl der verschiedenen Permutationsschemata für einen Binärstring der Länge n, wobei die Anzahl der '1's m ist und die Anzahl der '0's n - m ist.\n\nParameter:\n@param {number} n - Länge des Binärstrings.\n@param {number} m - Anzahl der '1's im Binärstring.\n\nRückgabewert:\n@returns {number} Die Gesamtanzahl der verschiedenen Permutationsschemata.", "ha": "Ƙirga yawan tsarin permutation daban-daban don igiyar binary mai tsawon n, inda adadin '1's shi ne m kuma adadin '0's shi ne n - m.\n\nSigogi:\n@param {number} n - Tsawon igiyar binary.\n@param {number} m - Yawan '1's a cikin igiyar binary.\n\nKomawa:\n@returns {number} Jimillar yawan tsarin permutation daban-daban.", "hi": "बाइनरी स्ट्रिंग की लंबाई n के लिए विभिन्न क्रमपरिवर्तन योजनाओं की संख्या गिनें, जहाँ '1's की संख्या m है और '0's की संख्या n - m है।\n\nपैरामीटर्स:\n@param {number} n - बाइनरी स्ट्रिंग की लंबाई।\n@param {number} m - बाइनरी स्ट्रिंग में '1's की संख्या।\n\nवापसी:\n@returns {number} विभिन्न क्रमपरिवर्तन योजनाओं की कुल संख्या।", "hu": "Számolja meg a különböző permutációs sémák számát egy n hosszúságú bináris karakterláncra, ahol az '1'-ek száma m, és a '0'-k száma n - m.\n\nParaméterek:\n@param {number} n - A bináris karakterlánc hossza.\n@param {number} m - Az '1'-ek száma a bináris karakterláncban.\n\nVisszatér:\n@returns {number} A különböző permutációs sémák teljes száma.", "es": "Cuenta el número de diferentes esquemas de permutación para una cadena binaria de longitud n, donde el número de '1's es m y el número de '0's es n - m.\n\nParámetros:\n@param {number} n - Longitud de la cadena binaria.\n@param {number} m - Número de '1's en la cadena binaria.\n\nDevuelve:\n@returns {number} El número total de diferentes esquemas de permutación.", "arb": "احسب عدد مخططات التبديل المختلفة لسلسلة ثنائية بطول n، حيث يكون عدد '1's هو m وعدد '0's هو n - m.\n\nالمعلمات:\n@param {number} n - طول السلسلة الثنائية.\n@param {number} m - عدد '1's في السلسلة الثنائية.\n\nالقيم المعادة:\n@returns {number} العدد الإجمالي لمخططات التبديل المختلفة.", "sw": "Hesabu idadi ya mipango tofauti ya mpangilio kwa kamba ya binary yenye urefu n, ambapo idadi ya '1's ni m na idadi ya '0's ni n - m.\n\nVigezo:\n@param {number} n - Urefu wa kamba ya binary.\n@param {number} m - Idadi ya '1's katika kamba ya binary.\n\nRudisha:\n@returns {number} Jumla ya idadi ya mipango tofauti ya mpangilio.", "tr": "İkili bir dizinin uzunluğu n olan ve '1'lerin sayısı m, '0'ların sayısı n - m olan farklı permütasyon şemalarının sayısını sayın.\n\nParametreler:\n@param {number} n - İkili dizinin uzunluğu.\n@param {number} m - İkili dizideki '1'lerin sayısı.\n\nDöndürür:\n@returns {number} Farklı permütasyon şemalarının toplam sayısı.", "vi": "Đếm số lượng các sơ đồ hoán vị khác nhau cho một chuỗi nhị phân có độ dài n, trong đó số lượng '1' là m và số lượng '0' là n - m.\n\nTham số:\n@param {number} n - Độ dài của chuỗi nhị phân.\n@param {number} m - Số lượng '1' trong chuỗi nhị phân.\n\nTrả về:\n@returns {number} Tổng số lượng các sơ đồ hoán vị khác nhau.", "id": "Hitung jumlah skema permutasi berbeda untuk string biner dengan panjang n, di mana jumlah '1' adalah m dan jumlah '0' adalah n - m.\n\nParameter:\n@param {number} n - Panjang dari string biner.\n@param {number} m - Jumlah '1' dalam string biner.\n\nMengembalikan:\n@returns {number} Jumlah total skema permutasi berbeda.", "ja": "バイナリ文字列の長さが n で、'1' の数が m、'0' の数が n - m の場合の異なる順列スキームの数を数えます。\n\nパラメータ:\n@param {number} n - バイナリ文字列の長さ。\n@param {number} m - バイナリ文字列内の '1' の数。\n\n戻り値:\n@returns {number} 異なる順列スキームの総数。", "ko": "이진 문자열의 길이가 n이고, '1'의 개수가 m이며 '0'의 개수가 n - m일 때, 서로 다른 순열 방식의 수를 계산합니다.\n\n매개변수:\n@param {number} n - 이진 문자열의 길이.\n@param {number} m - 이진 문자열에서 '1'의 개수.\n\n반환값:\n@returns {number} 서로 다른 순열 방식의 총 개수.", "ml": "നീളമുള്ള ബൈനറി സ്ട്രിംഗിന് വ്യത്യസ്തമായ പെർമ്യൂട്ടേഷൻ സ്കീമുകളുടെ എണ്ണം എണ്ണുക n,\n * ഇവിടെ '1' കളുടെ എണ്ണം m ആണ്, '0' കളുടെ എണ്ണം n - m ആണ്.\n\nParameters:\n@param {number} n - ബൈനറി സ്ട്രിംഗിന്റെ നീളം.\n@param {number} m - ബൈനറി സ്ട്രിംഗിലെ '1'കളുടെ എണ്ണം.\n\nReturns:\n@returns {number} വ്യത്യസ്തമായ പെർമ്യൂട്ടേഷൻ സ്കീമുകളുടെ മൊത്തം എണ്ണം.", "fa": "تعداد طرح‌های جایگشت مختلف برای یک رشته باینری به طول n را بشمارید، جایی که تعداد '1' ها برابر m و تعداد '0' ها برابر n - m است.\n\nپارامترها:\n@param {number} n - طول رشته باینری.\n@param {number} m - تعداد '1' ها در رشته باینری.\n\nبازگشت:\n@returns {number} تعداد کل طرح‌های جایگشت مختلف."}}
{"task_id": "JavaScript/20", "prompt": {"en": "/**\n * Answer a series of questions by providing choices A, B, C, or D for each question.\n * Question 1:\n * Constants like 1e6 belong to which data type?\n *     A. unsigned int\n *     B. int\n *     C. float\n *     D. double\n * Question 2:\n * Given 21! = 51,090,942,171,709,440,000, which data type can be used to store this value?\n *     A. int\n *     B. long long\n *     C. double\n *     D. None of the above\n * Question 3:\n * Which statement about left values in expressions is incorrect?\n *     A. Variable name expressions are left values.\n *     B. Increment operation requires the operand to be a left value.\n *     C. Pointer dereference expressions are left values.\n *     D. Prefix increment operation expressions are left values.\n * Question 4:\n * Which statement about functions is incorrect?\n *     A. Formal parameters of a function are local variables.\n *     B. Local variables are allocated space in the stack.\n *     C. The function type is the same as the return value type.\n *     D. A function can call itself from within its body.\n * Question 5:\n * Which statement about pointers is incorrect?\n *     A. Subtracting two pointers equals the difference in their address values.\n *     B. Pointer dereference involves resolving based on the pointer's type.\n *     C. int *p[4], p is an array of int pointers.\n *     D. Function names can be assigned to function pointers.\n *     >>> f_20()\n *     AAAAA\n * You're supposed to only return strings similar to \"AAAAA\", which stand for the choices of the question.\n */\nfunction f_20()", "sq": "/**\n * Përgjigju një serie pyetjesh duke dhënë zgjedhjet A, B, C, ose D për secilën pyetje.\n * Pyetja 1:\n * Konstantet si 1e6 i përkasin cilit tip të dhënash?\n *     A. unsigned int\n *     B. int\n *     C. float\n *     D. double\n * Pyetja 2:\n * Duke pasur parasysh 21! = 51,090,942,171,709,440,000, cili tip i të dhënave mund të përdoret për të ruajtur këtë vlerë?\n *     A. int\n *     B. long long\n *     C. double\n *     D. Asnjë nga të mësipërmet\n * Pyetja 3:\n * Cila deklaratë rreth vlerave të majta në shprehje është e pasaktë?\n *     A. Shprehjet e emrave të variablave janë vlera të majta.\n *     B. Operacioni i inkrementimit kërkon që operandi të jetë një vlerë e majtë.\n *     C. Shprehjet e dereferencimit të treguesve janë vlera të majta.\n *     D. Shprehjet e operacionit të inkrementimit prefiks janë vlera të majta.\n * Pyetja 4:\n * Cila deklaratë rreth funksioneve është e pasaktë?\n *     A. Parametrat formalë të një funksioni janë variabla lokale.\n *     B. Variablat lokale kanë hapësirë të caktuar në stack.\n *     C. Tipi i funksionit është i njëjtë me tipin e vlerës së kthimit.\n *     D. Një funksion mund të thërrasë vetveten brenda trupit të tij.\n * Pyetja 5:\n * Cila deklaratë rreth treguesve është e pasaktë?\n *     A. Zbritja e dy treguesve është e barabartë me diferencën në vlerat e adresave të tyre.\n *     B. Dereferencimi i treguesit përfshin zgjidhjen bazuar në tipin e treguesit.\n *     C. int *p[4], p është një varg i treguesve int.\n *     D. Emrat e funksioneve mund të caktohen në treguesit e funksioneve.\n *     >>> f_20()\n *     AAAAA\n * Duhet të ktheni vetëm vargje të ngjashme me \"AAAAA\", të cilat përfaqësojnë zgjedhjet e pyetjes.\n */\nfunction f_20()", "hy": "/**\n * Պատասխանեք հարցերի շարքին՝ տրամադրելով A, B, C կամ D ընտրանքներից յուրաքանչյուր հարցի համար:\n * Հարց 1:\n * 1e6 նման հաստատունները որ տվյալների տիպին են պատկանում?\n *     A. unsigned int\n *     B. int\n *     C. float\n *     D. double\n * Հարց 2:\n * Տրված է 21! = 51,090,942,171,709,440,000, որ տվյալների տիպը կարող է օգտագործվել այս արժեքը պահելու համար?\n *     A. int\n *     B. long long\n *     C. double\n *     D. Վերը նշվածներից ոչ մեկը\n * Հարց 3:\n * Որ արտահայտությունը ձախ արժեքների մասին սխալ է?\n *     A. Փոփոխականի անվան արտահայտությունները ձախ արժեքներ են:\n *     B. Ինկրեմենտ գործողությունը պահանջում է, որ օպերանդը լինի ձախ արժեք:\n *     C. Ցուցիչի դերեֆերենսի արտահայտությունները ձախ արժեքներ են:\n *     D. Նախածանց ինկրեմենտ գործողության արտահայտությունները ձախ արժեքներ են:\n * Հարց 4:\n * Որ արտահայտությունը ֆունկցիաների մասին սխալ է?\n *     A. Ֆունկցիայի ֆորմալ պարամետրերը տեղական փոփոխականներ են:\n *     B. Տեղական փոփոխականների համար տարածք է հատկացվում ստեկում:\n *     C. Ֆունկցիայի տիպը նույնն է, ինչ վերադարձվող արժեքի տիպը:\n *     D. Ֆունկցիան կարող է ինքն իրեն կանչել իր մարմնից:\n * Հարց 5:\n * Որ արտահայտությունը ցուցիչների մասին սխալ է?\n *     A. Երկու ցուցիչների հանումը հավասար է նրանց հասցեների արժեքների տարբերությանը:\n *     B. Ցուցիչի դերեֆերենսը ներառում է լուծում ցուցիչի տիպի հիման վրա:\n *     C. int *p[4], p-ն int ցուցիչների զանգված է:\n *     D. Ֆունկցիայի անունները կարող են վերագրվել ֆունկցիայի ցուցիչներին:\n *     >>> f_20()\n *     AAAAA\n * Դուք պետք է վերադարձնեք միայն \"AAAAA\"-ի նման տողեր, որոնք ներկայացնում են հարցերի ընտրանքները:\n */\nfunction f_20()", "bn": "/**\n * প্রতিটি প্রশ্নের জন্য পছন্দসমূহ A, B, C, বা D প্রদান করে প্রশ্নগুলির উত্তর দিন।\n * প্রশ্ন ১:\n * 1e6 এর মতো ধ্রুবক কোন ডেটা টাইপের অন্তর্গত?\n *     A. unsigned int\n *     B. int\n *     C. float\n *     D. double\n * প্রশ্ন ২:\n * 21! = 51,090,942,171,709,440,000 দেওয়া হলে, কোন ডেটা টাইপ এই মান সংরক্ষণ করতে ব্যবহার করা যেতে পারে?\n *     A. int\n *     B. long long\n *     C. double\n *     D. উপরোক্ত কোনোটিই নয়\n * প্রশ্ন ৩:\n * এক্সপ্রেশনগুলিতে বাম মান সম্পর্কে কোন বিবৃতিটি ভুল?\n *     A. ভেরিয়েবল নাম এক্সপ্রেশনগুলি বাম মান।\n *     B. ইনক্রিমেন্ট অপারেশনটির জন্য অপারেন্ডটি একটি বাম মান হতে হবে।\n *     C. পয়েন্টার ডেরেফারেন্স এক্সপ্রেশনগুলি বাম মান।\n *     D. প্রিফিক্স ইনক্রিমেন্ট অপারেশন এক্সপ্রেশনগুলি বাম মান।\n * প্রশ্ন ৪:\n * ফাংশন সম্পর্কে কোন বিবৃতিটি ভুল?\n *     A. ফাংশনের আনুষ্ঠানিক প্যারামিটারগুলি স্থানীয় ভেরিয়েবল।\n *     B. স্থানীয় ভেরিয়েবলগুলি স্ট্যাকে স্থান বরাদ্দ পায়।\n *     C. ফাংশন টাইপ এবং রিটার্ন ভ্যালু টাইপ একই।\n *     D. একটি ফাংশন তার দেহের ভিতর থেকে নিজেকে কল করতে পারে।\n * প্রশ্ন ৫:\n * পয়েন্টার সম্পর্কে কোন বিবৃতিটি ভুল?\n *     A. দুটি পয়েন্টার বিয়োগ করলে তাদের ঠিকানা মানের পার্থক্য সমান হয়।\n *     B. পয়েন্টার ডেরেফারেন্স পয়েন্টারের টাইপের উপর ভিত্তি করে সমাধান করা হয়।\n *     C. int *p[4], p একটি int পয়েন্টারের অ্যারে।\n *     D. ফাংশনের নাম ফাংশন পয়েন্টারগুলিতে বরাদ্দ করা যেতে পারে।\n *     >>> f_20()\n *     AAAAA\n * আপনাকে শুধুমাত্র \"AAAAA\" এর মতো স্ট্রিং ফেরত দিতে হবে, যা প্রশ্নের পছন্দগুলির জন্য দাঁড়ায়।\n */\nfunction f_20()", "bg": "/**\n * Отговорете на поредица от въпроси, като предоставите избори A, B, C или D за всеки въпрос.\n * Въпрос 1:\n * Константи като 1e6 принадлежат към кой тип данни?\n *     A. unsigned int\n *     B. int\n *     C. float\n *     D. double\n * Въпрос 2:\n * Дадено е 21! = 51,090,942,171,709,440,000, кой тип данни може да се използва за съхранение на тази стойност?\n *     A. int\n *     B. long long\n *     C. double\n *     D. Нито едно от горните\n * Въпрос 3:\n * Кое твърдение за левите стойности в изразите е неправилно?\n *     A. Изразите с имена на променливи са леви стойности.\n *     B. Операцията за инкрементиране изисква операндът да бъде лява стойност.\n *     C. Изразите за дереференция на указател са леви стойности.\n *     D. Изразите за префиксно инкрементиране са леви стойности.\n * Въпрос 4:\n * Кое твърдение за функциите е неправилно?\n *     A. Формалните параметри на функцията са локални променливи.\n *     B. Локалните променливи са разпределени в стека.\n *     C. Типът на функцията е същият като типа на стойността на връщане.\n *     D. Функцията може да извика сама себе си в тялото си.\n * Въпрос 5:\n * Кое твърдение за указателите е неправилно?\n *     A. Изваждането на два указателя е равно на разликата в техните адресни стойности.\n *     B. Дереференцията на указател включва разрешаване въз основа на типа на указателя.\n *     C. int *p[4], p е масив от указатели към int.\n *     D. Имената на функциите могат да бъдат присвоени на указатели към функции.\n *     >>> f_20()\n *     AAAAA\n * Трябва да върнете само низове, подобни на \"AAAAA\", които представляват изборите на въпросите.\n */\nfunction f_20()", "zh": "/**\n * 通过为每个问题提供选项 A、B、C 或 D 来回答一系列问题。\n * 问题 1:\n * 常量如 1e6 属于哪种数据类型？\n *     A. unsigned int\n *     B. int\n *     C. float\n *     D. double\n * 问题 2:\n * 给定 21! = 51,090,942,171,709,440,000，哪种数据类型可以用来存储这个值？\n *     A. int\n *     B. long long\n *     C. double\n *     D. 以上都不是\n * 问题 3:\n * 关于表达式中的左值，哪个说法是不正确的？\n *     A. 变量名表达式是左值。\n *     B. 增量操作要求操作数是左值。\n *     C. 指针解引用表达式是左值。\n *     D. 前缀增量操作表达式是左值。\n * 问题 4:\n * 关于函数，哪个说法是不正确的？\n *     A. 函数的形式参数是局部变量。\n *     B. 局部变量在栈中分配空间。\n *     C. 函数类型与返回值类型相同。\n *     D. 函数可以在其主体内调用自身。\n * 问题 5:\n * 关于指针，哪个说法是不正确的？\n *     A. 两个指针相减等于它们地址值的差。\n *     B. 指针解引用涉及基于指针的类型进行解析。\n *     C. int *p[4], p 是一个 int 指针数组。\n *     D. 函数名可以赋值给函数指针。\n *     >>> f_20()\n *     AAAAA\n * 你应该只返回类似于 \"AAAAA\" 的字符串，代表问题的选择。\n */", "fr": "/**\n * Répondez à une série de questions en fournissant les choix A, B, C ou D pour chaque question.\n * Question 1 :\n * Les constantes comme 1e6 appartiennent à quel type de données ?\n *     A. unsigned int\n *     B. int\n *     C. float\n *     D. double\n * Question 2 :\n * Étant donné 21! = 51,090,942,171,709,440,000, quel type de données peut être utilisé pour stocker cette valeur ?\n *     A. int\n *     B. long long\n *     C. double\n *     D. Aucun des précédents\n * Question 3 :\n * Quelle affirmation sur les valeurs à gauche dans les expressions est incorrecte ?\n *     A. Les expressions de noms de variables sont des valeurs à gauche.\n *     B. L'opération d'incrémentation nécessite que l'opérande soit une valeur à gauche.\n *     C. Les expressions de déréférencement de pointeur sont des valeurs à gauche.\n *     D. Les expressions d'opération d'incrémentation préfixée sont des valeurs à gauche.\n * Question 4 :\n * Quelle affirmation sur les fonctions est incorrecte ?\n *     A. Les paramètres formels d'une fonction sont des variables locales.\n *     B. Les variables locales sont allouées dans la pile.\n *     C. Le type de la fonction est le même que le type de la valeur de retour.\n *     D. Une fonction peut s'appeler elle-même depuis son corps.\n * Question 5 :\n * Quelle affirmation sur les pointeurs est incorrecte ?\n *     A. Soustraire deux pointeurs équivaut à la différence de leurs valeurs d'adresse.\n *     B. Le déréférencement de pointeur implique une résolution basée sur le type du pointeur.\n *     C. int *p[4], p est un tableau de pointeurs int.\n *     D. Les noms de fonctions peuvent être assignés à des pointeurs de fonction.\n *     >>> f_20()\n *     AAAAA\n * Vous êtes censé ne retourner que des chaînes similaires à \"AAAAA\", qui représentent les choix de la question.\n */\nfunction f_20()", "de": "/**\n * Beantworten Sie eine Reihe von Fragen, indem Sie für jede Frage die Auswahlmöglichkeiten A, B, C oder D angeben.\n * Frage 1:\n * Konstanten wie 1e6 gehören zu welchem Datentyp?\n *     A. unsigned int\n *     B. int\n *     C. float\n *     D. double\n * Frage 2:\n * Angenommen 21! = 51,090,942,171,709,440,000, welcher Datentyp kann verwendet werden, um diesen Wert zu speichern?\n *     A. int\n *     B. long long\n *     C. double\n *     D. Keine der oben genannten\n * Frage 3:\n * Welche Aussage über linke Werte in Ausdrücken ist falsch?\n *     A. Variablennamenausdrücke sind linke Werte.\n *     B. Der Inkrementoperator erfordert, dass der Operand ein linker Wert ist.\n *     C. Zeiger-Dereferenz-Ausdrücke sind linke Werte.\n *     D. Präfix-Inkrement-Ausdrucksoperationen sind linke Werte.\n * Frage 4:\n * Welche Aussage über Funktionen ist falsch?\n *     A. Formale Parameter einer Funktion sind lokale Variablen.\n *     B. Lokale Variablen werden im Stapel Speicherplatz zugewiesen.\n *     C. Der Funktionstyp ist derselbe wie der Rückgabewerttyp.\n *     D. Eine Funktion kann sich selbst innerhalb ihres Körpers aufrufen.\n * Frage 5:\n * Welche Aussage über Zeiger ist falsch?\n *     A. Das Subtrahieren von zwei Zeigern entspricht der Differenz ihrer Adresswerte.\n *     B. Zeiger-Dereferenzierung erfolgt basierend auf dem Typ des Zeigers.\n *     C. int *p[4], p ist ein Array von int-Zeigern.\n *     D. Funktionsnamen können Funktionszeigern zugewiesen werden.\n *     >>> f_20()\n *     AAAAA\n * Sie sollen nur Zeichenfolgen wie \"AAAAA\" zurückgeben, die für die Auswahlmöglichkeiten der Frage stehen.\n */\nfunction f_20()", "ha": "/**\n * Amsa jerin tambayoyi ta hanyar bayar da zaɓuɓɓuka A, B, C, ko D don kowace tambaya.\n * Tambaya ta 1:\n * Constants kamar 1e6 suna cikin wane nau'in bayanai?\n *     A. unsigned int\n *     B. int\n *     C. float\n *     D. double\n * Tambaya ta 2:\n * An ba da 21! = 51,090,942,171,709,440,000, wane nau'in bayanai za a iya amfani da shi don adana wannan ƙima?\n *     A. int\n *     B. long long\n *     C. double\n *     D. Babu ɗaya daga cikin waɗannan\n * Tambaya ta 3:\n * Wane bayani game da ƙimar hagu a cikin bayyana ba daidai ba ne?\n *     A. Bayanan sunan canji suna da ƙimar hagu.\n *     B. Aikin ƙara yana buƙatar operand ya zama ƙimar hagu.\n *     C. Bayanan cire adireshin suna da ƙimar hagu.\n *     D. Bayanan aikin ƙara na farko suna da ƙimar hagu.\n * Tambaya ta 4:\n * Wane bayani game da ayyuka ba daidai ba ne?\n *     A. Sigogin tsari na aiki suna da canje-canje na gida.\n *     B. Canje-canje na gida suna samun sarari a cikin tari.\n *     C. Nau'in aiki yana daidai da nau'in ƙimar dawowa.\n *     D. Aiki na iya kiran kansa daga cikin jikinsa.\n * Tambaya ta 5:\n * Wane bayani game da nuni ba daidai ba ne?\n *     A. Cire nuni biyu yana daidai da bambanci a cikin ƙimar adireshinsu.\n *     B. Cire adireshi yana buƙatar warwarewa bisa nau'in nuni.\n *     C. int *p[4], p tsari ne na nuni na int.\n *     D. Ana iya sanya sunayen ayyuka ga nuni na aiki.\n *     >>> f_20()\n *     AAAAA\n * Ana buƙatar ka dawo da kirtani irin \"AAAAA\" kawai, wanda ke wakiltar zaɓuɓɓukan tambayar.\n */\nfunction f_20()", "hi": "/**\n * प्रत्येक प्रश्न के लिए विकल्प A, B, C, या D प्रदान करके प्रश्नों की एक श्रृंखला का उत्तर दें।\n * प्रश्न 1:\n * 1e6 जैसी स्थिरांक किस डेटा प्रकार से संबंधित हैं?\n *     A. unsigned int\n *     B. int\n *     C. float\n *     D. double\n * प्रश्न 2:\n * दिए गए 21! = 51,090,942,171,709,440,000, इस मान को संग्रहीत करने के लिए किस डेटा प्रकार का उपयोग किया जा सकता है?\n *     A. int\n *     B. long long\n *     C. double\n *     D. उपरोक्त में से कोई नहीं\n * प्रश्न 3:\n * अभिव्यक्तियों में बाएँ मानों के बारे में कौन सा कथन गलत है?\n *     A. वेरिएबल नाम अभिव्यक्तियाँ बाएँ मान हैं।\n *     B. वृद्धि ऑपरेशन के लिए ऑपरेन्ड का बाएँ मान होना आवश्यक है।\n *     C. पॉइंटर डीरिफरेंस अभिव्यक्तियाँ बाएँ मान हैं।\n *     D. उपसर्ग वृद्धि ऑपरेशन अभिव्यक्तियाँ बाएँ मान हैं।\n * प्रश्न 4:\n * कार्यों के बारे में कौन सा कथन गलत है?\n *     A. एक फ़ंक्शन के औपचारिक पैरामीटर स्थानीय चर होते हैं।\n *     B. स्थानीय चर स्टैक में स्थान आवंटित करते हैं।\n *     C. फ़ंक्शन प्रकार वही है जो रिटर्न मान प्रकार है।\n *     D. एक फ़ंक्शन अपने शरीर के भीतर से स्वयं को कॉल कर सकता है।\n * प्रश्न 5:\n * पॉइंटर्स के बारे में कौन सा कथन गलत है?\n *     A. दो पॉइंटर्स को घटाने से उनके पते के मानों में अंतर होता है।\n *     B. पॉइंटर डीरिफरेंस में पॉइंटर के प्रकार के आधार पर समाधान शामिल होता है।\n *     C. int *p[4], p एक int पॉइंटर्स की सरणी है।\n *     D. फ़ंक्शन नामों को फ़ंक्शन पॉइंटर्स को सौंपा जा सकता है।\n *     >>> f_20()\n *     AAAAA\n * आपको केवल \"AAAAA\" जैसे स्ट्रिंग्स लौटाने की आवश्यकता है, जो प्रश्न के विकल्पों के लिए खड़े हैं।\n */\nfunction f_20()", "hu": "/**\n * Válaszolj egy sor kérdésre úgy, hogy A, B, C vagy D választ adsz minden kérdésre.\n * 1. kérdés:\n * Az olyan konstansok, mint az 1e6, melyik adattípushoz tartoznak?\n *     A. unsigned int\n *     B. int\n *     C. float\n *     D. double\n * 2. kérdés:\n * Tekintettel arra, hogy 21! = 51,090,942,171,709,440,000, melyik adattípus használható ennek az értéknek a tárolására?\n *     A. int\n *     B. long long\n *     C. double\n *     D. Egyik sem a fentiek közül\n * 3. kérdés:\n * Melyik állítás helytelen a baloldali értékekről a kifejezésekben?\n *     A. A változó név kifejezések baloldali értékek.\n *     B. Az inkrementálás művelet megköveteli, hogy az operandus baloldali érték legyen.\n *     C. A pointer dereferálás kifejezések baloldali értékek.\n *     D. A prefix inkrementálás művelet kifejezések baloldali értékek.\n * 4. kérdés:\n * Melyik állítás helytelen a függvényekről?\n *     A. A függvény formális paraméterei lokális változók.\n *     B. A lokális változók a veremben kapnak helyet.\n *     C. A függvény típusa megegyezik a visszatérési érték típusával.\n *     D. Egy függvény meghívhatja önmagát a törzsén belül.\n * 5. kérdés:\n * Melyik állítás helytelen a pointerekről?\n *     A. Két pointer kivonása az címértékeik különbségével egyenlő.\n *     B. A pointer dereferálás a pointer típusának megfelelően történik.\n *     C. int *p[4], p egy int pointerek tömbje.\n *     D. A függvénynevek hozzárendelhetők függvénypointerekhez.\n *     >>> f_20()\n *     AAAAA\n * Csak olyan karakterláncokat kell visszaadnod, mint például \"AAAAA\", amelyek a kérdések választásait jelentik.\n */\nfunction f_20()", "es": "/**\n * Responde una serie de preguntas proporcionando opciones A, B, C o D para cada pregunta.\n * Pregunta 1:\n * ¿Constantes como 1e6 pertenecen a qué tipo de dato?\n *     A. unsigned int\n *     B. int\n *     C. float\n *     D. double\n * Pregunta 2:\n * Dado 21! = 51,090,942,171,709,440,000, ¿qué tipo de dato se puede usar para almacenar este valor?\n *     A. int\n *     B. long long\n *     C. double\n *     D. Ninguna de las anteriores\n * Pregunta 3:\n * ¿Cuál afirmación sobre los valores a la izquierda en expresiones es incorrecta?\n *     A. Las expresiones de nombres de variables son valores a la izquierda.\n *     B. La operación de incremento requiere que el operando sea un valor a la izquierda.\n *     C. Las expresiones de desreferencia de punteros son valores a la izquierda.\n *     D. Las expresiones de operación de incremento prefijo son valores a la izquierda.\n * Pregunta 4:\n * ¿Cuál afirmación sobre las funciones es incorrecta?\n *     A. Los parámetros formales de una función son variables locales.\n *     B. Las variables locales se asignan espacio en la pila.\n *     C. El tipo de la función es el mismo que el tipo del valor de retorno.\n *     D. Una función puede llamarse a sí misma desde dentro de su cuerpo.\n * Pregunta 5:\n * ¿Cuál afirmación sobre los punteros es incorrecta?\n *     A. Restar dos punteros equivale a la diferencia en sus valores de dirección.\n *     B. La desreferencia de punteros implica resolver basado en el tipo del puntero.\n *     C. int *p[4], p es un arreglo de punteros a int.\n *     D. Los nombres de funciones pueden asignarse a punteros de función.\n *     >>> f_20()\n *     AAAAA\n * Se supone que solo debes devolver cadenas similares a \"AAAAA\", que representan las opciones de la pregunta.\n */\nfunction f_20()", "arb": "/**\n * أجب عن سلسلة من الأسئلة بتقديم اختيارات A، B، C، أو D لكل سؤال.\n * السؤال 1:\n * الثوابت مثل 1e6 تنتمي إلى أي نوع من البيانات؟\n *     A. unsigned int\n *     B. int\n *     C. float\n *     D. double\n * السؤال 2:\n * بالنظر إلى 21! = 51,090,942,171,709,440,000، أي نوع من البيانات يمكن استخدامه لتخزين هذه القيمة؟\n *     A. int\n *     B. long long\n *     C. double\n *     D. لا شيء مما سبق\n * السؤال 3:\n * أي عبارة عن القيم اليسارية في التعبيرات غير صحيحة؟\n *     A. تعبيرات أسماء المتغيرات هي قيم يسارية.\n *     B. عملية الزيادة تتطلب أن يكون المعامل قيمة يسارية.\n *     C. تعبيرات إلغاء المؤشر هي قيم يسارية.\n *     D. تعبيرات عملية الزيادة المسبقة هي قيم يسارية.\n * السؤال 4:\n * أي عبارة عن الدوال غير صحيحة؟\n *     A. المعاملات الرسمية للدالة هي متغيرات محلية.\n *     B. يتم تخصيص مساحة للمتغيرات المحلية في المكدس.\n *     C. نوع الدالة هو نفسه نوع قيمة الإرجاع.\n *     D. يمكن للدالة أن تستدعي نفسها من داخل جسمها.\n * السؤال 5:\n * أي عبارة عن المؤشرات غير صحيحة؟\n *     A. طرح مؤشرين يساوي الفرق في قيم عناوينهما.\n *     B. إلغاء المؤشر يتضمن الحل بناءً على نوع المؤشر.\n *     C. int *p[4]، p هو مصفوفة من مؤشرات int.\n *     D. يمكن تعيين أسماء الدوال إلى مؤشرات الدوال.\n *     >>> f_20()\n *     AAAAA\n * من المفترض أن تعيد فقط سلاسل مشابهة لـ \"AAAAA\"، والتي تمثل اختيارات السؤال.\n */\nfunction f_20()", "sw": "/**\n * Jibu mfululizo wa maswali kwa kutoa chaguo A, B, C, au D kwa kila swali.\n * Swali la 1:\n * Vigezo kama 1e6 vinatoka kwa aina gani ya data?\n *     A. unsigned int\n *     B. int\n *     C. float\n *     D. double\n * Swali la 2:\n * Ikitolewa 21! = 51,090,942,171,709,440,000, ni aina gani ya data inaweza kutumika kuhifadhi thamani hii?\n *     A. int\n *     B. long long\n *     C. double\n *     D. Hakuna kati ya hizi\n * Swali la 3:\n * Ni kauli gani kuhusu thamani za kushoto katika maelezo si sahihi?\n *     A. Maelezo ya majina ya vigezo ni thamani za kushoto.\n *     B. Operesheni ya kuongeza inahitaji operand kuwa thamani ya kushoto.\n *     C. Maelezo ya kufuta pointer ni thamani za kushoto.\n *     D. Maelezo ya operesheni ya kuongeza awali ni thamani za kushoto.\n * Swali la 4:\n * Ni kauli gani kuhusu kazi si sahihi?\n *     A. Vigezo rasmi vya kazi ni vigezo vya ndani.\n *     B. Vigezo vya ndani vinatengewa nafasi kwenye stack.\n *     C. Aina ya kazi ni sawa na aina ya thamani ya kurudi.\n *     D. Kazi inaweza kujifanyia mwito kutoka ndani ya mwili wake.\n * Swali la 5:\n * Ni kauli gani kuhusu pointer si sahihi?\n *     A. Kutoa pointer mbili ni sawa na tofauti katika thamani za anwani zao.\n *     B. Kufuta pointer kunahusisha kutatua kulingana na aina ya pointer.\n *     C. int *p[4], p ni safu ya pointer za int.\n *     D. Majina ya kazi yanaweza kupewa pointer za kazi.\n *     >>> f_20()\n *     AAAAA\n * Unatakiwa kurudisha tu mistari inayofanana na \"AAAAA\", ambayo inawakilisha chaguo za swali.\n */\nfunction f_20()", "tr": "/**\n * Her soru için A, B, C veya D seçeneklerini sağlayarak bir dizi soruyu yanıtlayın.\n * Soru 1:\n * 1e6 gibi sabitler hangi veri türüne aittir?\n *     A. unsigned int\n *     B. int\n *     C. float\n *     D. double\n * Soru 2:\n * 21! = 51,090,942,171,709,440,000 verildiğinde, bu değeri saklamak için hangi veri türü kullanılabilir?\n *     A. int\n *     B. long long\n *     C. double\n *     D. Yukarıdakilerin hiçbiri\n * Soru 3:\n * İfadelerdeki sol değerler hakkında hangi ifade yanlıştır?\n *     A. Değişken adı ifadeleri sol değerlerdir.\n *     B. Artırma işlemi, operandın bir sol değer olmasını gerektirir.\n *     C. Pointer çözme ifadeleri sol değerlerdir.\n *     D. Ön ek artırma işlemi ifadeleri sol değerlerdir.\n * Soru 4:\n * Fonksiyonlar hakkında hangi ifade yanlıştır?\n *     A. Bir fonksiyonun resmi parametreleri yerel değişkenlerdir.\n *     B. Yerel değişkenler yığında alan tahsis edilir.\n *     C. Fonksiyon türü, dönüş değeri türü ile aynıdır.\n *     D. Bir fonksiyon kendi gövdesinden kendini çağırabilir.\n * Soru 5:\n * Pointerlar hakkında hangi ifade yanlıştır?\n *     A. İki pointerın çıkarılması, adres değerlerindeki farkı eşittir.\n *     B. Pointer çözme, pointerın türüne göre çözümlemeyi içerir.\n *     C. int *p[4], p bir int pointer dizisidir.\n *     D. Fonksiyon isimleri, fonksiyon pointerlarına atanabilir.\n *     >>> f_20()\n *     AAAAA\n * Soruların seçeneklerini temsil eden \"AAAAA\" gibi dizeler döndürmeniz gerekiyor.\n */\nfunction f_20()", "vi": "/**\n * Trả lời một loạt câu hỏi bằng cách cung cấp lựa chọn A, B, C, hoặc D cho mỗi câu hỏi.\n * Câu hỏi 1:\n * Các hằng số như 1e6 thuộc kiểu dữ liệu nào?\n *     A. unsigned int\n *     B. int\n *     C. float\n *     D. double\n * Câu hỏi 2:\n * Cho 21! = 51,090,942,171,709,440,000, kiểu dữ liệu nào có thể được sử dụng để lưu trữ giá trị này?\n *     A. int\n *     B. long long\n *     C. double\n *     D. Không có kiểu nào ở trên\n * Câu hỏi 3:\n * Câu nào về giá trị bên trái trong biểu thức là không đúng?\n *     A. Biểu thức tên biến là giá trị bên trái.\n *     B. Phép tăng yêu cầu toán hạng phải là giá trị bên trái.\n *     C. Biểu thức giải tham chiếu con trỏ là giá trị bên trái.\n *     D. Biểu thức phép tăng tiền tố là giá trị bên trái.\n * Câu hỏi 4:\n * Câu nào về hàm là không đúng?\n *     A. Tham số hình thức của một hàm là biến cục bộ.\n *     B. Biến cục bộ được cấp phát không gian trong ngăn xếp.\n *     C. Kiểu của hàm giống với kiểu giá trị trả về.\n *     D. Một hàm có thể gọi chính nó từ bên trong thân hàm.\n * Câu hỏi 5:\n * Câu nào về con trỏ là không đúng?\n *     A. Trừ hai con trỏ bằng với sự khác biệt trong giá trị địa chỉ của chúng.\n *     B. Giải tham chiếu con trỏ liên quan đến việc giải quyết dựa trên kiểu của con trỏ.\n *     C. int *p[4], p là một mảng các con trỏ int.\n *     D. Tên hàm có thể được gán cho con trỏ hàm.\n *     >>> f_20()\n *     AAAAA\n * Bạn chỉ cần trả về chuỗi tương tự như \"AAAAA\", đại diện cho các lựa chọn của câu hỏi.\n */\nfunction f_20()", "id": "/**\n * Jawab serangkaian pertanyaan dengan memberikan pilihan A, B, C, atau D untuk setiap pertanyaan.\n * Pertanyaan 1:\n * Konstanta seperti 1e6 termasuk dalam tipe data apa?\n *     A. unsigned int\n *     B. int\n *     C. float\n *     D. double\n * Pertanyaan 2:\n * Diberikan 21! = 51,090,942,171,709,440,000, tipe data mana yang dapat digunakan untuk menyimpan nilai ini?\n *     A. int\n *     B. long long\n *     C. double\n *     D. Tidak ada di atas\n * Pertanyaan 3:\n * Pernyataan mana tentang nilai kiri dalam ekspresi yang salah?\n *     A. Ekspresi nama variabel adalah nilai kiri.\n *     B. Operasi peningkatan memerlukan operan untuk menjadi nilai kiri.\n *     C. Ekspresi dereferensi pointer adalah nilai kiri.\n *     D. Ekspresi operasi peningkatan prefiks adalah nilai kiri.\n * Pertanyaan 4:\n * Pernyataan mana tentang fungsi yang salah?\n *     A. Parameter formal dari sebuah fungsi adalah variabel lokal.\n *     B. Variabel lokal dialokasikan ruang di tumpukan.\n *     C. Tipe fungsi sama dengan tipe nilai kembalian.\n *     D. Sebuah fungsi dapat memanggil dirinya sendiri dari dalam tubuhnya.\n * Pertanyaan 5:\n * Pernyataan mana tentang pointer yang salah?\n *     A. Mengurangi dua pointer sama dengan perbedaan dalam nilai alamat mereka.\n *     B. Dereferensi pointer melibatkan penyelesaian berdasarkan tipe pointer.\n *     C. int *p[4], p adalah array dari pointer int.\n *     D. Nama fungsi dapat ditugaskan ke pointer fungsi.\n *     >>> f_20()\n *     AAAAA\n * Anda seharusnya hanya mengembalikan string yang mirip dengan \"AAAAA\", yang mewakili pilihan dari pertanyaan.\n */\nfunction f_20()", "ja": "/**\n * 各質問に対して選択肢A、B、C、またはDを提供して一連の質問に答えてください。\n * 質問1:\n * 1e6のような定数はどのデータ型に属しますか？\n *     A. unsigned int\n *     B. int\n *     C. float\n *     D. double\n * 質問2:\n * 21! = 51,090,942,171,709,440,000の場合、この値を格納するために使用できるデータ型はどれですか？\n *     A. int\n *     B. long long\n *     C. double\n *     D. 上記のいずれでもない\n * 質問3:\n * 式の左辺値について誤っている記述はどれですか？\n *     A. 変数名の式は左辺値です。\n *     B. インクリメント操作にはオペランドが左辺値である必要があります。\n *     C. ポインタのデリファレンス式は左辺値です。\n *     D. プレフィックスインクリメント操作の式は左辺値です。\n * 質問4:\n * 関数について誤っている記述はどれですか？\n *     A. 関数の形式パラメータはローカル変数です。\n *     B. ローカル変数はスタックにスペースが割り当てられます。\n *     C. 関数の型は戻り値の型と同じです。\n *     D. 関数はその本体内から自分自身を呼び出すことができます。\n * 質問5:\n * ポインタについて誤っている記述はどれですか？\n *     A. 2つのポインタを引くと、それらのアドレス値の差になります。\n *     B. ポインタのデリファレンスはポインタの型に基づいて解決されます。\n *     C. int *p[4], pはintポインタの配列です。\n *     D. 関数名は関数ポインタに代入できます。\n *     >>> f_20()\n *     AAAAA\n * 質問の選択肢を表す「AAAAA」のような文字列のみを返すことになっています。\n */\nfunction f_20()", "ko": "/**\n * 각 질문에 대해 선택지 A, B, C, 또는 D를 제공하여 일련의 질문에 답하십시오.\n * 질문 1:\n * 1e6과 같은 상수는 어떤 데이터 유형에 속합니까?\n *     A. unsigned int\n *     B. int\n *     C. float\n *     D. double\n * 질문 2:\n * 21! = 51,090,942,171,709,440,000이 주어졌을 때, 이 값을 저장할 수 있는 데이터 유형은 무엇입니까?\n *     A. int\n *     B. long long\n *     C. double\n *     D. 위의 것들 중 어느 것도 아님\n * 질문 3:\n * 표현식에서 왼쪽 값에 대한 설명 중 틀린 것은 무엇입니까?\n *     A. 변수 이름 표현식은 왼쪽 값입니다.\n *     B. 증가 연산은 피연산자가 왼쪽 값이어야 합니다.\n *     C. 포인터 역참조 표현식은 왼쪽 값입니다.\n *     D. 전위 증가 연산 표현식은 왼쪽 값입니다.\n * 질문 4:\n * 함수에 대한 설명 중 틀린 것은 무엇입니까?\n *     A. 함수의 형식 매개변수는 지역 변수입니다.\n *     B. 지역 변수는 스택에 공간이 할당됩니다.\n *     C. 함수 유형은 반환 값 유형과 동일합니다.\n *     D. 함수는 본문 내에서 스스로를 호출할 수 있습니다.\n * 질문 5:\n * 포인터에 대한 설명 중 틀린 것은 무엇입니까?\n *     A. 두 포인터를 빼면 주소 값의 차이가 됩니다.\n *     B. 포인터 역참조는 포인터의 유형을 기반으로 해석됩니다.\n *     C. int *p[4], p는 int 포인터의 배열입니다.\n *     D. 함수 이름은 함수 포인터에 할당될 수 있습니다.\n *     >>> f_20()\n *     AAAAA\n * 질문의 선택지를 나타내는 \"AAAAA\"와 같은 문자열만 반환해야 합니다.\n */\nfunction f_20()", "ml": "/**\n * ഓരോ ചോദ്യത്തിനും A, B, C, അല്ലെങ്കിൽ D എന്നിങ്ങനെ തിരഞ്ഞെടുക്കലുകൾ നൽകിക്കൊണ്ട് ചോദ്യങ്ങൾക്ക് ഉത്തരം നൽകുക.\n * ചോദ്യ 1:\n * 1e6 പോലുള്ള സ്ഥിരാങ്കങ്ങൾ ഏത് ഡാറ്റാ ടൈപ്പിൽ പെട്ടതാണ്?\n *     A. unsigned int\n *     B. int\n *     C. float\n *     D. double\n * ചോദ്യ 2:\n * 21! = 51,090,942,171,709,440,000 എന്നത് നൽകിയാൽ, ഈ മൂല്യം സംഭരിക്കാൻ ഏത് ഡാറ്റാ ടൈപ്പ് ഉപയോഗിക്കാം?\n *     A. int\n *     B. long long\n *     C. double\n *     D. മുകളിൽ പറയുന്നവയൊന്നുമല്ല\n * ചോദ്യ 3:\n * എക്സ്പ്രഷനുകളിൽ ഇടത് മൂല്യങ്ങളെക്കുറിച്ചുള്ള ഏത് പ്രസ്താവന തെറ്റാണ്?\n *     A. വേരിയബിൾ നെയിം എക്സ്പ്രഷനുകൾ ഇടത് മൂല്യങ്ങളാണ്.\n *     B. വർദ്ധന ഓപ്പറേഷൻ നടത്താൻ ഓപ്പറാൻഡ് ഇടത് മൂല്യം ആയിരിക്കണം.\n *     C. പോയിന്റർ ഡീരഫറൻസ് എക്സ്പ്രഷനുകൾ ഇടത് മൂല്യങ്ങളാണ്.\n *     D. പ്രിഫിക്സ് വർദ്ധന ഓപ്പറേഷൻ എക്സ്പ്രഷനുകൾ ഇടത് മൂല്യങ്ങളാണ്.\n * ചോദ്യ 4:\n * ഫങ്ഷനുകളെക്കുറിച്ചുള്ള ഏത് പ്രസ്താവന തെറ്റാണ്?\n *     A. ഒരു ഫങ്ഷന്റെ ഔപചാരിക പാരാമീറ്ററുകൾ പ്രാദേശിക വേരിയബിൾസ് ആണ്.\n *     B. പ്രാദേശിക വേരിയബിൾസ് സ്റ്റാക്കിൽ സ്ഥലം അനുവദിക്കുന്നു.\n *     C. ഫങ്ഷൻ ടൈപ്പ് റിട്ടേൺ മൂല്യത്തിന്റെ ടൈപ്പിനൊപ്പം സമാനമാണ്.\n *     D. ഒരു ഫങ്ഷൻ അതിന്റെ ബോഡിയിൽ നിന്ന് തന്നെ വിളിക്കാം.\n * ചോദ്യ 5:\n * പോയിന്ററുകളെക്കുറിച്ചുള്ള ഏത് പ്രസ്താവന തെറ്റാണ്?\n *     A. രണ്ട് പോയിന്ററുകൾ കുറയ്ക്കുന്നത് അവരുടെ അഡ്രസ് മൂല്യങ്ങളിലെ വ്യത്യാസത്തിനെ തുല്യമാണ്.\n *     B. പോയിന്റർ ഡീരഫറൻസ്, പോയിന്ററിന്റെ ടൈപ്പിന്റെ അടിസ്ഥാനത്തിൽ പരിഹരിക്കുന്നു.\n *     C. int *p[4], p ഒരു int പോയിന്ററുകളുടെ നിരയാണ്.\n *     D. ഫങ്ഷൻ നാമങ്ങൾ ഫങ്ഷൻ പോയിന്ററുകൾക്ക് നിയോഗിക്കാം.\n *     >>> f_20()\n *     AAAAA\n * നിങ്ങൾ \"AAAAA\" പോലുള്ള സ്ട്രിംഗുകൾ മാത്രമേ തിരികെ നൽകേണ്ടതുള്ളൂ, ഇത് ചോദ്യത്തിന്റെ തിരഞ്ഞെടുക്കലുകൾക്കാണ്.\n */\nfunction f_20()", "fa": "/**\n * به یک سری سوال با ارائه گزینه‌های A، B، C، یا D برای هر سوال پاسخ دهید.\n * سوال 1:\n * ثابت‌هایی مانند 1e6 به کدام نوع داده تعلق دارند؟\n *     A. unsigned int\n *     B. int\n *     C. float\n *     D. double\n * سوال 2:\n * با توجه به 21! = 51,090,942,171,709,440,000، از کدام نوع داده می‌توان برای ذخیره این مقدار استفاده کرد؟\n *     A. int\n *     B. long long\n *     C. double\n *     D. هیچکدام از موارد فوق\n * سوال 3:\n * کدام عبارت درباره مقادیر چپ در عبارات نادرست است؟\n *     A. عبارات نام متغیرها مقادیر چپ هستند.\n *     B. عملیات افزایش نیاز به این دارد که عملوند یک مقدار چپ باشد.\n *     C. عبارات اشاره‌گر به مقادیر چپ هستند.\n *     D. عبارات عملیات افزایش پیشوندی مقادیر چپ هستند.\n * سوال 4:\n * کدام عبارت درباره توابع نادرست است؟\n *     A. پارامترهای رسمی یک تابع متغیرهای محلی هستند.\n *     B. متغیرهای محلی در پشته فضا اختصاص داده می‌شوند.\n *     C. نوع تابع همان نوع مقدار بازگشتی است.\n *     D. یک تابع می‌تواند خود را از درون بدنه‌اش فراخوانی کند.\n * سوال 5:\n * کدام عبارت درباره اشاره‌گرها نادرست است؟\n *     A. تفریق دو اشاره‌گر برابر با تفاوت در مقادیر آدرس آنها است.\n *     B. رفع ارجاع اشاره‌گر شامل حل بر اساس نوع اشاره‌گر است.\n *     C. int *p[4]، p یک آرایه از اشاره‌گرهای int است.\n *     D. نام توابع می‌توانند به اشاره‌گرهای تابع اختصاص داده شوند.\n *     >>> f_20()\n *     AAAAA\n * شما باید فقط رشته‌هایی مشابه \"AAAAA\" که نمایانگر انتخاب‌های سوال هستند را برگردانید.\n */\nfunction f_20()"}, "canonical_solution": "{\n    return \"DDDBA\";\n}", "instruction": {"en": "Write a JavaScript function `function f_20()` to solve the following problem:\nAnswer a series of questions by providing choices A, B, C, or D for each question.\nQuestion 1:\nConstants like 1e6 belong to which data type?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nQuestion 2:\nGiven 21! = 51,090,942,171,709,440,000, which data type can be used to store this value?\n    A. int\n    B. long long\n    C. double\n    D. None of the above\nQuestion 3:\nWhich statement about left values in expressions is incorrect?\n    A. Variable name expressions are left values.\n    B. Increment operation requires the operand to be a left value.\n    C. Pointer dereference expressions are left values.\n    D. Prefix increment operation expressions are left values.\nQuestion 4:\nWhich statement about functions is incorrect?\n    A. Formal parameters of a function are local variables.\n    B. Local variables are allocated space in the stack.\n    C. The function type is the same as the return value type.\n    D. A function can call itself from within its body.\nQuestion 5:\nWhich statement about pointers is incorrect?\n    A. Subtracting two pointers equals the difference in their address values.\n    B. Pointer dereference involves resolving based on the pointer's type.\n    C. int *p[4], p is an array of int pointers.\n    D. Function names can be assigned to function pointers.\n    >>> f_20()\n    AAAAA\nYou're supposed to only return strings similar to \"AAAAA\", which stand for the choices of the question.", "sq": "Shkruani një funksion JavaScript `function f_20()` për të zgjidhur problemin e mëposhtëm:\nPërgjigjuni një serie pyetjesh duke ofruar zgjedhje A, B, C, ose D për secilën pyetje.\nPyetja 1:\nKonstantet si 1e6 i përkasin cilit lloj të dhënash?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nPyetja 2:\nDuke pasur parasysh 21! = 51,090,942,171,709,440,000, cili lloj të dhënash mund të përdoret për të ruajtur këtë vlerë?\n    A. int\n    B. long long\n    C. double\n    D. Asnjë nga të mësipërmet\nPyetja 3:\nCila deklaratë për vlerat e majta në shprehje është e pasaktë?\n    A. Shprehjet e emrave të variablave janë vlera të majta.\n    B. Operacioni i inkrementimit kërkon që operandi të jetë një vlerë e majtë.\n    C. Shprehjet e dereferencimit të treguesve janë vlera të majta.\n    D. Shprehjet e operacionit të inkrementimit prefiks janë vlera të majta.\nPyetja 4:\nCila deklaratë për funksionet është e pasaktë?\n    A. Parametrat formalë të një funksioni janë variabla lokale.\n    B. Variablat lokale kanë hapësirë të caktuar në stack.\n    C. Lloji i funksionit është i njëjtë me llojin e vlerës së kthimit.\n    D. Një funksion mund të thërrasë vetveten nga brenda trupit të tij.\nPyetja 5:\nCila deklaratë për treguesit është e pasaktë?\n    A. Zbritja e dy treguesve është e barabartë me diferencën në vlerat e adresave të tyre.\n    B. Dereferencimi i treguesit përfshin zgjidhjen bazuar në llojin e treguesit.\n    C. int *p[4], p është një varg treguesish int.\n    D. Emrat e funksioneve mund të caktohen te treguesit e funksioneve.\n>>> f_20()\nAAAAA\nJu supozohet të ktheni vetëm vargje të ngjashme me \"AAAAA\", të cilat përfaqësojnë zgjedhjet e pyetjeve.", "hy": "Գրեք JavaScript ֆունկցիա `function f_20()` հետևյալ խնդիրը լուծելու համար:\nՊատասխանեք մի շարք հարցերի՝ տրամադրելով A, B, C կամ D ընտրանքները յուրաքանչյուր հարցի համար:\nՀարց 1:\nՆման հաստատունները, ինչպիսիք են 1e6-ը, որ տվյալների տիպին են պատկանում?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nՀարց 2:\nՀաշվի առնելով 21! = 51,090,942,171,709,440,000, որ տվյալների տիպը կարող է օգտագործվել այս արժեքը պահելու համար?\n    A. int\n    B. long long\n    C. double\n    D. Վերը նշվածներից ոչ մեկը\nՀարց 3:\nՈ՞ր հայտարարությունը ձախ արժեքների մասին արտահայտություններում սխալ է:\n    A. Փոփոխականի անվան արտահայտությունները ձախ արժեքներ են:\n    B. Ինկրեմենտ գործողությունը պահանջում է, որ օպերանդը լինի ձախ արժեք:\n    C. Ցուցիչի ապահղման արտահայտությունները ձախ արժեքներ են:\n    D. Նախածանց ինկրեմենտ գործողության արտահայտությունները ձախ արժեքներ են:\nՀարց 4:\nՈ՞ր հայտարարությունը ֆունկցիաների մասին սխալ է:\n    A. Ֆունկցիայի ֆորմալ պարամետրերը տեղական փոփոխականներ են:\n    B. Տեղական փոփոխականները հատկացվում են ստեկում:\n    C. Ֆունկցիայի տիպը նույնն է, ինչ վերադարձի արժեքի տիպը:\n    D. Ֆունկցիան կարող է ինքն իրեն կանչել իր մարմնի ներսից:\nՀարց 5:\nՈ՞ր հայտարարությունը ցուցիչների մասին սխալ է:\n    A. Երկու ցուցիչների հանումը հավասար է նրանց հասցեների արժեքների տարբերությանը:\n    B. Ցուցիչի ապահղումը ներառում է լուծում ցուցիչի տիպի հիման վրա:\n    C. int *p[4], p-ն int ցուցիչների զանգված է:\n    D. Ֆունկցիայի անունները կարող են վերագրվել ֆունկցիայի ցուցիչներին:\n>>> f_20()\nAAAAA\nԴուք պետք է վերադարձնեք միայն այնպիսի տողեր, ինչպիսիք են \"AAAAA\", որոնք ներկայացնում են հարցերի ընտրանքները:", "bn": "একটি জাভাস্ক্রিপ্ট ফাংশন `function f_20()` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি প্রশ্নমালার উত্তর দিন প্রতিটি প্রশ্নের জন্য A, B, C, বা D বিকল্প প্রদান করে।\nপ্রশ্ন ১:\n১e৬ এর মত ধ্রুবক কোন ডেটা টাইপের অন্তর্গত?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nপ্রশ্ন ২:\n২১! = ৫১,০৯০,৯৪২,১৭১,৭০৯,৪৪০,০০০ দেওয়া হলে, কোন ডেটা টাইপ এই মান সংরক্ষণ করতে ব্যবহার করা যেতে পারে?\n    A. int\n    B. long long\n    C. double\n    D. উপরোক্ত কোনোটিই নয়\nপ্রশ্ন ৩:\nএক্সপ্রেশনে বাম মান সম্পর্কে কোন বিবৃতি ভুল?\n    A. ভেরিয়েবল নাম এক্সপ্রেশনগুলি বাম মান।\n    B. ইনক্রিমেন্ট অপারেশনটির জন্য অপারেন্ডটি বাম মান হতে হবে।\n    C. পয়েন্টার ডিরেফারেন্স এক্সপ্রেশনগুলি বাম মান।\n    D. প্রিফিক্স ইনক্রিমেন্ট অপারেশন এক্সপ্রেশনগুলি বাম মান।\nপ্রশ্ন ৪:\nফাংশন সম্পর্কে কোন বিবৃতি ভুল?\n    A. একটি ফাংশনের আনুষ্ঠানিক প্যারামিটারগুলি স্থানীয় ভেরিয়েবল।\n    B. স্থানীয় ভেরিয়েবলগুলি স্ট্যাকে স্থান বরাদ্দ করা হয়।\n    C. ফাংশনের টাইপ এবং রিটার্ন ভ্যালুর টাইপ একই।\n    D. একটি ফাংশন তার দেহের ভিতর থেকে নিজেকে কল করতে পারে।\nপ্রশ্ন ৫:\nপয়েন্টার সম্পর্কে কোন বিবৃতি ভুল?\n    A. দুটি পয়েন্টার বিয়োগ করলে তাদের ঠিকানা মানের পার্থক্য হয়।\n    B. পয়েন্টার ডিরেফারেন্স পয়েন্টারের টাইপের উপর ভিত্তি করে সমাধান করা হয়।\n    C. int *p[4], p একটি int পয়েন্টারের অ্যারে।\n    D. ফাংশনের নাম ফাংশন পয়েন্টারগুলিতে বরাদ্দ করা যেতে পারে।\n>>> f_20()\nAAAAA\nআপনাকে শুধুমাত্র \"AAAAA\" এর মত স্ট্রিং ফেরত দিতে হবে, যা প্রশ্নের বিকল্পগুলির জন্য দাঁড়ায়।", "bg": "Напишете JavaScript функция `function f_20()`, за да решите следния проблем:  \nОтговорете на серия от въпроси, като предоставите избори A, B, C или D за всеки въпрос.  \nВъпрос 1:  \nКонстанти като 1e6 принадлежат към кой тип данни?  \n    A. unsigned int  \n    B. int  \n    C. float  \n    D. double  \nВъпрос 2:  \nДадено е 21! = 51,090,942,171,709,440,000, кой тип данни може да се използва за съхранение на тази стойност?  \n    A. int  \n    B. long long  \n    C. double  \n    D. Нито едно от горните  \nВъпрос 3:  \nКое твърдение за левите стойности в изразите е неправилно?  \n    A. Изразите с имена на променливи са леви стойности.  \n    B. Операцията за инкрементиране изисква операндът да бъде лява стойност.  \n    C. Изразите с дереференция на указатели са леви стойности.  \n    D. Изразите с префикс инкремент операция са леви стойности.  \nВъпрос 4:  \nКое твърдение за функциите е неправилно?  \n    A. Формалните параметри на функцията са локални променливи.  \n    B. Локалните променливи се разпределят в стека.  \n    C. Типът на функцията е същият като типа на връщаната стойност.  \n    D. Функцията може да извика себе си от тялото си.  \nВъпрос 5:  \nКое твърдение за указателите е неправилно?  \n    A. Изваждането на два указателя е равно на разликата в техните адресни стойности.  \n    B. Дереференцията на указател включва разрешаване на базата на типа на указателя.  \n    C. int *p[4], p е масив от указатели към int.  \n    D. Имената на функциите могат да бъдат присвоени на указатели към функции.  \n>>> f_20()  \nAAAAA  \nТрябва да връщате само низове, подобни на \"AAAAA\", които представляват изборите на въпросите.", "zh": "编写一个 JavaScript 函数 `function f_20()` 来解决以下问题：  \n通过为每个问题提供选择 A、B、C 或 D 来回答一系列问题。\n\n问题 1：  \n像 1e6 这样的常量属于哪种数据类型？  \nA. unsigned int  \nB. int  \nC. float  \nD. double  \n\n问题 2：  \n给定 21! = 51,090,942,171,709,440,000，哪种数据类型可以用来存储这个值？  \nA. int  \nB. long long  \nC. double  \nD. 以上都不是  \n\n问题 3：  \n关于表达式中的左值，哪个说法不正确？  \nA. 变量名表达式是左值。  \nB. 增量操作要求操作数是左值。  \nC. 指针解引用表达式是左值。  \nD. 前缀增量操作表达式是左值。  \n\n问题 4：  \n关于函数，哪个说法不正确？  \nA. 函数的形式参数是局部变量。  \nB. 局部变量在栈中分配空间。  \nC. 函数类型与返回值类型相同。  \nD. 函数可以在其内部调用自身。  \n\n问题 5：  \n关于指针，哪个说法不正确？  \nA. 两个指针相减等于它们地址值的差。  \nB. 指针解引用涉及根据指针的类型进行解析。  \nC. int *p[4]，p 是一个 int 指针数组。  \nD. 函数名可以赋值给函数指针。  \n\n>>> f_20()  \nAAAAA  \n你应该只返回类似于 \"AAAAA\" 的字符串，代表问题的选择。", "fr": "Écrire une fonction JavaScript `function f_20()` pour résoudre le problème suivant :\nRépondre à une série de questions en fournissant des choix A, B, C ou D pour chaque question.\nQuestion 1 :\nLes constantes comme 1e6 appartiennent à quel type de données ?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nQuestion 2 :\nÉtant donné 21! = 51,090,942,171,709,440,000, quel type de données peut être utilisé pour stocker cette valeur ?\n    A. int\n    B. long long\n    C. double\n    D. Aucun des précédents\nQuestion 3 :\nQuelle affirmation concernant les valeurs à gauche dans les expressions est incorrecte ?\n    A. Les expressions de noms de variables sont des valeurs à gauche.\n    B. L'opération d'incrément nécessite que l'opérande soit une valeur à gauche.\n    C. Les expressions de déréférencement de pointeur sont des valeurs à gauche.\n    D. Les expressions d'opération d'incrémentation préfixée sont des valeurs à gauche.\nQuestion 4 :\nQuelle affirmation concernant les fonctions est incorrecte ?\n    A. Les paramètres formels d'une fonction sont des variables locales.\n    B. Les variables locales sont allouées dans la pile.\n    C. Le type de la fonction est le même que le type de la valeur de retour.\n    D. Une fonction peut s'appeler elle-même depuis son corps.\nQuestion 5 :\nQuelle affirmation concernant les pointeurs est incorrecte ?\n    A. Soustraire deux pointeurs équivaut à la différence de leurs valeurs d'adresse.\n    B. Le déréférencement de pointeur implique une résolution basée sur le type du pointeur.\n    C. int *p[4], p est un tableau de pointeurs int.\n    D. Les noms de fonctions peuvent être assignés à des pointeurs de fonction.\n>>> f_20()\nAAAAA\nVous êtes censé uniquement retourner des chaînes similaires à \"AAAAA\", qui représentent les choix de la question.", "de": "Schreiben Sie eine JavaScript-Funktion `function f_20()`, um das folgende Problem zu lösen:\nBeantworten Sie eine Reihe von Fragen, indem Sie für jede Frage die Auswahlmöglichkeiten A, B, C oder D angeben.\nFrage 1:\nKonstanten wie 1e6 gehören zu welchem Datentyp?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nFrage 2:\nGegeben 21! = 51,090,942,171,709,440,000, welcher Datentyp kann verwendet werden, um diesen Wert zu speichern?\n    A. int\n    B. long long\n    C. double\n    D. Keine der oben genannten\nFrage 3:\nWelche Aussage über linke Werte in Ausdrücken ist falsch?\n    A. Variablennamen-Ausdrücke sind linke Werte.\n    B. Inkrementoperation erfordert, dass der Operand ein linker Wert ist.\n    C. Zeiger-Dereferenz-Ausdrücke sind linke Werte.\n    D. Präfix-Inkrement-Operation-Ausdrücke sind linke Werte.\nFrage 4:\nWelche Aussage über Funktionen ist falsch?\n    A. Formale Parameter einer Funktion sind lokale Variablen.\n    B. Lokale Variablen werden im Stack Speicherplatz zugewiesen.\n    C. Der Funktionstyp ist derselbe wie der Rückgabewerttyp.\n    D. Eine Funktion kann sich selbst aus ihrem Körper heraus aufrufen.\nFrage 5:\nWelche Aussage über Zeiger ist falsch?\n    A. Das Subtrahieren von zwei Zeigern entspricht der Differenz ihrer Adresswerte.\n    B. Zeiger-Dereferenzierung beinhaltet die Auflösung basierend auf dem Typ des Zeigers.\n    C. int *p[4], p ist ein Array von int-Zeigern.\n    D. Funktionsnamen können Funktionszeigern zugewiesen werden.\n>>> f_20()\nAAAAA\nSie sollen nur Zeichenfolgen ähnlich wie \"AAAAA\" zurückgeben, die für die Auswahlmöglichkeiten der Frage stehen.", "ha": "Rubuta wani aikin JavaScript `function f_20()` don warware matsalar mai zuwa:\nAmsa jerin tambayoyi ta hanyar bayar da zaɓuɓɓuka A, B, C, ko D ga kowace tambaya.\nTambaya ta 1:\nConstant kamar 1e6 suna cikin wane nau'in bayanai?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nTambaya ta 2:\nAn ba da 21! = 51,090,942,171,709,440,000, wane nau'in bayanai za a iya amfani da shi don adana wannan ƙima?\n    A. int\n    B. long long\n    C. double\n    D. Babu ɗaya daga cikin waɗannan\nTambaya ta 3:\nWane bayani game da ƙimar hagu a cikin bayyana ba daidai ba ne?\n    A. Bayanin sunan canji ƙimar hagu ne.\n    B. Aikin ƙara yana buƙatar operand ya zama ƙimar hagu.\n    C. Bayanin cirewa mai nuna alama ƙimar hagu ne.\n    D. Bayanin aikin ƙara na farko ƙimar hagu ne.\nTambaya ta 4:\nWane bayani game da ayyuka ba daidai ba ne?\n    A. Sigogin yau da kullum na aiki canje-canje ne na gida.\n    B. Canje-canje na gida suna samun sarari a cikin stack.\n    C. Nau'in aiki yana daidai da nau'in ƙimar dawowa.\n    D. Aiki na iya kiran kansa daga cikin jikinsa.\nTambaya ta 5:\nWane bayani game da masu nuna alama ba daidai ba ne?\n    A. Cirewa masu nuna alama biyu yana daidai da bambancin a cikin ƙimar adireshinsu.\n    B. Cirewa mai nuna alama yana buƙatar warwarewa bisa nau'in mai nuna alama.\n    C. int *p[4], p tsari ne na masu nuna alama na int.\n    D. Ana iya ba da sunayen ayyuka ga masu nuna alama na aiki.\n>>> f_20()\nAAAAA\nAna buƙatar ka mayar da kirtani kamar \"AAAAA\", wanda ke wakiltar zaɓuɓɓukan tambayoyin.", "hi": "JavaScript फ़ंक्शन `function f_20()` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nप्रत्येक प्रश्न के लिए विकल्प A, B, C, या D प्रदान करके प्रश्नों की एक श्रृंखला का उत्तर दें।\nप्रश्न 1:\n1e6 जैसी स्थिरांक किस डेटा प्रकार से संबंधित हैं?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nप्रश्न 2:\nदिए गए 21! = 51,090,942,171,709,440,000, इस मान को संग्रहीत करने के लिए किस डेटा प्रकार का उपयोग किया जा सकता है?\n    A. int\n    B. long long\n    C. double\n    D. उपरोक्त में से कोई नहीं\nप्रश्न 3:\nअभिव्यक्तियों में बाएँ मानों के बारे में कौन सा कथन गलत है?\n    A. वेरिएबल नाम अभिव्यक्तियाँ बाएँ मान हैं।\n    B. वृद्धि ऑपरेशन के लिए ऑपरेन्ड का बाएँ मान होना आवश्यक है।\n    C. पॉइंटर डिरेफरेंस अभिव्यक्तियाँ बाएँ मान हैं।\n    D. उपसर्ग वृद्धि ऑपरेशन अभिव्यक्तियाँ बाएँ मान हैं।\nप्रश्न 4:\nफ़ंक्शन्स के बारे में कौन सा कथन गलत है?\n    A. फ़ंक्शन के औपचारिक पैरामीटर स्थानीय वेरिएबल हैं।\n    B. स्थानीय वेरिएबल स्टैक में स्थान आवंटित करते हैं।\n    C. फ़ंक्शन प्रकार वही है जो रिटर्न मान प्रकार है।\n    D. एक फ़ंक्शन अपने शरीर के भीतर से स्वयं को कॉल कर सकता है।\nप्रश्न 5:\nपॉइंटर्स के बारे में कौन सा कथन गलत है?\n    A. दो पॉइंटर्स को घटाने से उनके पते के मानों में अंतर आता है।\n    B. पॉइंटर डिरेफरेंस में पॉइंटर के प्रकार के आधार पर समाधान शामिल होता है।\n    C. int *p[4], p एक int पॉइंटर्स की array है।\n    D. फ़ंक्शन नामों को फ़ंक्शन पॉइंटर्स को सौंपा जा सकता है।\n>>> f_20()\nAAAAA\nआपको केवल \"AAAAA\" जैसे स्ट्रिंग्स लौटाने हैं, जो प्रश्न के विकल्पों का प्रतिनिधित्व करते हैं।", "hu": "Írj egy JavaScript függvényt `function f_20()` a következő probléma megoldására:\nVálaszolj egy sor kérdésre az A, B, C vagy D választási lehetőségek megadásával minden kérdéshez.\n1. kérdés:\nAz olyan konstansok, mint az 1e6, melyik adattípushoz tartoznak?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n2. kérdés:\nTekintve, hogy 21! = 51,090,942,171,709,440,000, melyik adattípus használható ennek az értéknek a tárolására?\n    A. int\n    B. long long\n    C. double\n    D. Egyik sem a fentiek közül\n3. kérdés:\nMelyik állítás helytelen a balértékekkel kapcsolatban kifejezésekben?\n    A. A változónév kifejezések balértékek.\n    B. Az inkrementáló művelet megköveteli, hogy az operandus balérték legyen.\n    C. A pointer dereferálás kifejezések balértékek.\n    D. A prefix inkrementáló művelet kifejezések balértékek.\n4. kérdés:\nMelyik állítás helytelen a függvényekkel kapcsolatban?\n    A. A függvény formális paraméterei lokális változók.\n    B. A lokális változók a veremben kapnak helyet.\n    C. A függvény típusa megegyezik a visszatérési érték típusával.\n    D. Egy függvény meghívhatja önmagát a saját törzsén belül.\n5. kérdés:\nMelyik állítás helytelen a pointerekkel kapcsolatban?\n    A. Két pointer kivonása egyenlő a címértékeik különbségével.\n    B. A pointer dereferálás a pointer típusának alapján történik.\n    C. int *p[4], p egy int pointerek tömbje.\n    D. A függvénynevek hozzárendelhetők függvénypointerekhez.\n>>> f_20()\nAAAAA\nCsak olyan karakterláncokat kell visszaadnod, mint például \"AAAAA\", amelyek a kérdések választási lehetőségeit jelölik.", "es": "Escribe una función de JavaScript `function f_20()` para resolver el siguiente problema:\nResponde a una serie de preguntas proporcionando opciones A, B, C o D para cada pregunta.\nPregunta 1:\n¿Las constantes como 1e6 pertenecen a qué tipo de dato?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nPregunta 2:\nDado 21! = 51,090,942,171,709,440,000, ¿qué tipo de dato se puede usar para almacenar este valor?\n    A. int\n    B. long long\n    C. double\n    D. Ninguna de las anteriores\nPregunta 3:\n¿Cuál afirmación sobre los valores a la izquierda en expresiones es incorrecta?\n    A. Las expresiones de nombres de variables son valores a la izquierda.\n    B. La operación de incremento requiere que el operando sea un valor a la izquierda.\n    C. Las expresiones de desreferencia de punteros son valores a la izquierda.\n    D. Las expresiones de operación de incremento prefijo son valores a la izquierda.\nPregunta 4:\n¿Cuál afirmación sobre las funciones es incorrecta?\n    A. Los parámetros formales de una función son variables locales.\n    B. Las variables locales se asignan espacio en la pila.\n    C. El tipo de la función es el mismo que el tipo del valor de retorno.\n    D. Una función puede llamarse a sí misma desde dentro de su cuerpo.\nPregunta 5:\n¿Cuál afirmación sobre los punteros es incorrecta?\n    A. Restar dos punteros equivale a la diferencia en sus valores de dirección.\n    B. La desreferencia de punteros implica resolver basado en el tipo del puntero.\n    C. int *p[4], p es un arreglo de punteros a int.\n    D. Los nombres de funciones pueden asignarse a punteros de funciones.\n>>> f_20()\nAAAAA\nSe supone que solo debes devolver cadenas similares a \"AAAAA\", que representan las opciones de la pregunta.", "arb": "اكتب دالة JavaScript `function f_20()` لحل المشكلة التالية:\nالإجابة على سلسلة من الأسئلة عن طريق تقديم الخيارات A، B، C، أو D لكل سؤال.\nالسؤال 1:\nالثوابت مثل 1e6 تنتمي إلى أي نوع من البيانات؟\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nالسؤال 2:\nبالنظر إلى 21! = 51,090,942,171,709,440,000، أي نوع من البيانات يمكن استخدامه لتخزين هذه القيمة؟\n    A. int\n    B. long long\n    C. double\n    D. لا شيء مما سبق\nالسؤال 3:\nأي عبارة عن القيم اليسارية في التعبيرات غير صحيحة؟\n    A. تعبيرات أسماء المتغيرات هي قيم يسارية.\n    B. عملية الزيادة تتطلب أن يكون المعامل قيمة يسارية.\n    C. تعبيرات إلغاء المؤشر هي قيم يسارية.\n    D. تعبيرات عملية الزيادة السابقة هي قيم يسارية.\nالسؤال 4:\nأي عبارة عن الدوال غير صحيحة؟\n    A. المعاملات الرسمية للدالة هي متغيرات محلية.\n    B. يتم تخصيص مساحة للمتغيرات المحلية في المكدس.\n    C. نوع الدالة هو نفس نوع قيمة الإرجاع.\n    D. يمكن للدالة استدعاء نفسها من داخل جسمها.\nالسؤال 5:\nأي عبارة عن المؤشرات غير صحيحة؟\n    A. طرح مؤشرين يساوي الفرق في قيم عناوينهما.\n    B. إلغاء المؤشر يتضمن الحل بناءً على نوع المؤشر.\n    C. int *p[4]، p هو مصفوفة من مؤشرات int.\n    D. يمكن تعيين أسماء الدوال إلى مؤشرات الدوال.\n>>> f_20()\nAAAAA\nمن المفترض أن تعيد فقط سلاسل مشابهة لـ \"AAAAA\"، والتي تمثل اختيارات السؤال.", "sw": "Andika kazi ya JavaScript `function f_20()` kutatua tatizo lifuatalo:\nJibu mfululizo wa maswali kwa kutoa chaguo A, B, C, au D kwa kila swali.\nSwali la 1:\nConstants kama 1e6 ni ya aina gani ya data?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nSwali la 2:\nKwa kuwa 21! = 51,090,942,171,709,440,000, ni aina gani ya data inaweza kutumika kuhifadhi thamani hii?\n    A. int\n    B. long long\n    C. double\n    D. Hakuna kati ya haya\nSwali la 3:\nNi kauli gani kuhusu thamani za kushoto katika maonyesho si sahihi?\n    A. Maonyesho ya jina la kigezo ni thamani za kushoto.\n    B. Operesheni ya kuongeza inahitaji operand kuwa thamani ya kushoto.\n    C. Maonyesho ya kutafsiri pointer ni thamani za kushoto.\n    D. Maonyesho ya operesheni ya kuongeza awali ni thamani za kushoto.\nSwali la 4:\nNi kauli gani kuhusu kazi si sahihi?\n    A. Vigezo rasmi vya kazi ni vigezo vya ndani.\n    B. Vigezo vya ndani vinapewa nafasi kwenye stack.\n    C. Aina ya kazi ni sawa na aina ya thamani ya kurudi.\n    D. Kazi inaweza kujita kutoka ndani ya mwili wake.\nSwali la 5:\nNi kauli gani kuhusu pointers si sahihi?\n    A. Kutoa pointers mbili ni sawa na tofauti katika thamani za anwani zao.\n    B. Kutafsiri pointer kunahusisha kutatua kulingana na aina ya pointer.\n    C. int *p[4], p ni safu ya pointers za int.\n    D. Majina ya kazi yanaweza kupewa pointers za kazi.\n>>> f_20()\nAAAAA\nUnatakiwa kurudisha tu misururu inayofanana na \"AAAAA\", ambayo inawakilisha chaguo za swali.", "tr": "Bir JavaScript fonksiyonu `function f_20()` yazarak aşağıdaki problemi çözün:\nHer soru için A, B, C veya D seçeneklerini sağlayarak bir dizi soruyu yanıtlayın.\nSoru 1:\n1e6 gibi sabitler hangi veri türüne aittir?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nSoru 2:\n21! = 51,090,942,171,709,440,000 verildiğinde, bu değeri saklamak için hangi veri türü kullanılabilir?\n    A. int\n    B. long long\n    C. double\n    D. Yukarıdakilerin hiçbiri\nSoru 3:\nİfadelerdeki sol değerlerle ilgili hangi ifade yanlıştır?\n    A. Değişken adı ifadeleri sol değerlerdir.\n    B. Artırma işlemi, operandın bir sol değer olmasını gerektirir.\n    C. Pointer çözme ifadeleri sol değerlerdir.\n    D. Ön ek artırma işlemi ifadeleri sol değerlerdir.\nSoru 4:\nFonksiyonlarla ilgili hangi ifade yanlıştır?\n    A. Bir fonksiyonun resmi parametreleri yerel değişkenlerdir.\n    B. Yerel değişkenler yığında yer kaplar.\n    C. Fonksiyon türü, dönüş değeri türü ile aynıdır.\n    D. Bir fonksiyon, gövdesi içinden kendisini çağırabilir.\nSoru 5:\nPointer'larla ilgili hangi ifade yanlıştır?\n    A. İki pointer'ı çıkarmak, adres değerlerindeki farkı eşittir.\n    B. Pointer çözme, pointer'ın türüne göre çözümlemeyi içerir.\n    C. int *p[4], p bir int pointer dizisidir.\n    D. Fonksiyon adları, fonksiyon pointer'larına atanabilir.\n>>> f_20()\nAAAAA\nSoruların seçeneklerini temsil eden \"AAAAA\" gibi dizeler döndürmeniz gerekmektedir.", "vi": "Viết một hàm JavaScript `function f_20()` để giải quyết vấn đề sau:  \nTrả lời một loạt câu hỏi bằng cách cung cấp lựa chọn A, B, C hoặc D cho mỗi câu hỏi.  \nCâu hỏi 1:  \nCác hằng số như 1e6 thuộc kiểu dữ liệu nào?  \n    A. unsigned int  \n    B. int  \n    C. float  \n    D. double  \nCâu hỏi 2:  \nCho 21! = 51,090,942,171,709,440,000, kiểu dữ liệu nào có thể được sử dụng để lưu trữ giá trị này?  \n    A. int  \n    B. long long  \n    C. double  \n    D. Không có cái nào ở trên  \nCâu hỏi 3:  \nCâu nào về giá trị bên trái trong biểu thức là không đúng?  \n    A. Biểu thức tên biến là giá trị bên trái.  \n    B. Phép tăng yêu cầu toán hạng phải là giá trị bên trái.  \n    C. Biểu thức giải tham chiếu con trỏ là giá trị bên trái.  \n    D. Biểu thức phép tăng tiền tố là giá trị bên trái.  \nCâu hỏi 4:  \nCâu nào về hàm là không đúng?  \n    A. Tham số hình thức của một hàm là biến cục bộ.  \n    B. Biến cục bộ được cấp phát không gian trong ngăn xếp.  \n    C. Kiểu hàm giống với kiểu giá trị trả về.  \n    D. Một hàm có thể tự gọi chính nó từ trong thân hàm.  \nCâu hỏi 5:  \nCâu nào về con trỏ là không đúng?  \n    A. Trừ hai con trỏ bằng sự khác biệt trong giá trị địa chỉ của chúng.  \n    B. Giải tham chiếu con trỏ liên quan đến việc giải quyết dựa trên kiểu của con trỏ.  \n    C. int *p[4], p là một mảng các con trỏ int.  \n    D. Tên hàm có thể được gán cho con trỏ hàm.  \n>>> f_20()  \nAAAAA  \nBạn chỉ cần trả về các chuỗi tương tự như \"AAAAA\", đại diện cho các lựa chọn của câu hỏi.", "id": "Tulis sebuah fungsi JavaScript `function f_20()` untuk menyelesaikan masalah berikut:\nMenjawab serangkaian pertanyaan dengan memberikan pilihan A, B, C, atau D untuk setiap pertanyaan.\nPertanyaan 1:\nKonstanta seperti 1e6 termasuk ke dalam tipe data apa?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nPertanyaan 2:\nDiberikan 21! = 51,090,942,171,709,440,000, tipe data apa yang dapat digunakan untuk menyimpan nilai ini?\n    A. int\n    B. long long\n    C. double\n    D. Tidak ada dari yang di atas\nPertanyaan 3:\nPernyataan mana tentang nilai kiri dalam ekspresi yang salah?\n    A. Ekspresi nama variabel adalah nilai kiri.\n    B. Operasi inkremen memerlukan operan untuk menjadi nilai kiri.\n    C. Ekspresi dereferensi pointer adalah nilai kiri.\n    D. Ekspresi operasi inkremen prefiks adalah nilai kiri.\nPertanyaan 4:\nPernyataan mana tentang fungsi yang salah?\n    A. Parameter formal dari sebuah fungsi adalah variabel lokal.\n    B. Variabel lokal dialokasikan ruang di stack.\n    C. Tipe fungsi sama dengan tipe nilai kembalian.\n    D. Sebuah fungsi dapat memanggil dirinya sendiri dari dalam tubuhnya.\nPertanyaan 5:\nPernyataan mana tentang pointer yang salah?\n    A. Mengurangi dua pointer sama dengan perbedaan dalam nilai alamat mereka.\n    B. Dereferensi pointer melibatkan penyelesaian berdasarkan tipe pointer.\n    C. int *p[4], p adalah array dari pointer int.\n    D. Nama fungsi dapat ditugaskan ke pointer fungsi.\n>>> f_20()\nAAAAA\nAnda seharusnya hanya mengembalikan string yang mirip dengan \"AAAAA\", yang mewakili pilihan dari pertanyaan.", "ja": "JavaScript関数`function f_20()`を作成して、次の問題を解決してください。  \n一連の質問に対して、各質問に対する選択肢A、B、C、またはDを提供して答えてください。  \n質問1:  \n1e6のような定数はどのデータ型に属しますか？  \n    A. unsigned int  \n    B. int  \n    C. float  \n    D. double  \n質問2:  \n21! = 51,090,942,171,709,440,000の場合、この値を格納するために使用できるデータ型はどれですか？  \n    A. int  \n    B. long long  \n    C. double  \n    D. 上記のどれでもない  \n質問3:  \n式中の左辺値に関する記述で誤っているものはどれですか？  \n    A. 変数名の式は左辺値である。  \n    B. インクリメント操作はオペランドが左辺値であることを要求する。  \n    C. ポインタの逆参照式は左辺値である。  \n    D. 前置インクリメント操作の式は左辺値である。  \n質問4:  \n関数に関する記述で誤っているものはどれですか？  \n    A. 関数の仮引数はローカル変数である。  \n    B. ローカル変数はスタックにスペースが割り当てられる。  \n    C. 関数の型は戻り値の型と同じである。  \n    D. 関数はその本体内から自身を呼び出すことができる。  \n質問5:  \nポインタに関する記述で誤っているものはどれですか？  \n    A. 2つのポインタを引くと、そのアドレス値の差になる。  \n    B. ポインタの逆参照はポインタの型に基づいて解決される。  \n    C. int *p[4]、pはintポインタの配列である。  \n    D. 関数名は関数ポインタに代入できる。  \n>>> f_20()  \nAAAAA  \n質問の選択肢を表す\"AAAAA\"のような文字列のみを返すことになっています。", "ko": "JavaScript 함수 `function f_20()`를 작성하여 다음 문제를 해결하십시오:\n각 질문에 대해 선택지 A, B, C, 또는 D를 제공하여 일련의 질문에 답하십시오.\n질문 1:\n1e6과 같은 상수는 어떤 데이터 유형에 속합니까?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n질문 2:\n21! = 51,090,942,171,709,440,000이 주어졌을 때, 이 값을 저장하는 데 사용할 수 있는 데이터 유형은 무엇입니까?\n    A. int\n    B. long long\n    C. double\n    D. 위의 것들 중 아무것도 아님\n질문 3:\n표현식에서 왼쪽 값에 대한 설명 중 잘못된 것은 무엇입니까?\n    A. 변수 이름 표현식은 왼쪽 값입니다.\n    B. 증가 연산은 피연산자가 왼쪽 값이어야 합니다.\n    C. 포인터 역참조 표현식은 왼쪽 값입니다.\n    D. 접두사 증가 연산 표현식은 왼쪽 값입니다.\n질문 4:\n함수에 대한 설명 중 잘못된 것은 무엇입니까?\n    A. 함수의 형식 매개변수는 지역 변수입니다.\n    B. 지역 변수는 스택에 공간이 할당됩니다.\n    C. 함수 유형은 반환 값 유형과 동일합니다.\n    D. 함수는 본문 내에서 자신을 호출할 수 있습니다.\n질문 5:\n포인터에 대한 설명 중 잘못된 것은 무엇입니까?\n    A. 두 포인터를 빼면 주소 값의 차이가 됩니다.\n    B. 포인터 역참조는 포인터의 유형을 기반으로 해석됩니다.\n    C. int *p[4], p는 int 포인터의 배열입니다.\n    D. 함수 이름은 함수 포인터에 할당할 수 있습니다.\n>>> f_20()\nAAAAA\n질문의 선택지를 나타내는 \"AAAAA\"와 유사한 문자열만 반환해야 합니다.", "ml": "JavaScript ഫംഗ്ഷൻ `function f_20()` എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nഓരോ ചോദ്യത്തിനും A, B, C, അല്ലെങ്കിൽ D എന്ന ചോയ്‌സുകൾ നൽകി ചോദ്യങ്ങൾക്ക് ഉത്തരം നൽകുക.\nചോദ്യം 1:\n1e6 പോലുള്ള സ്ഥിരാങ്കങ്ങൾ ഏത് ഡാറ്റാ ടൈപ്പിൽ പെട്ടതാണ്?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nചോദ്യം 2:\n21! = 51,090,942,171,709,440,000 നൽകിയാൽ, ഈ മൂല്യം സംഭരിക്കാൻ ഏത് ഡാറ്റാ ടൈപ്പ് ഉപയോഗിക്കാം?\n    A. int\n    B. long long\n    C. double\n    D. മുകളിൽ പറയുന്നവയിൽ ഒന്നുമല്ല\nചോദ്യം 3:\nവ്യക്തീകരണങ്ങളിലെ ഇടത് മൂല്യങ്ങളെക്കുറിച്ചുള്ള ഏത് പ്രസ്താവന തെറ്റാണ്?\n    A. വേരിയബിൾ നെയിം വ്യക്തീകരണങ്ങൾ ഇടത് മൂല്യങ്ങളാണ്.\n    B. വർദ്ധന ഓപ്പറേഷൻ നടത്താൻ ഓപ്പറാൻഡ് ഇടത് മൂല്യമായിരിക്കണം.\n    C. പോയിന്റർ ഡീറഫറൻസ് വ്യക്തീകരണങ്ങൾ ഇടത് മൂല്യങ്ങളാണ്.\n    D. പ്രിഫിക്സ് വർദ്ധന ഓപ്പറേഷൻ വ്യക്തീകരണങ്ങൾ ഇടത് മൂല്യങ്ങളാണ്.\nചോദ്യം 4:\nഫംഗ്ഷനുകളെക്കുറിച്ചുള്ള ഏത് പ്രസ്താവന തെറ്റാണ്?\n    A. ഒരു ഫംഗ്ഷന്റെ ഔപചാരിക പാരാമീറ്ററുകൾ ലോക്കൽ വേരിയബിൾസ് ആണ്.\n    B. ലോക്കൽ വേരിയബിൾസിന് സ്റ്റാക്കിൽ സ്ഥലം അനുവദിച്ചിരിക്കുന്നു.\n    C. ഫംഗ്ഷൻ ടൈപ്പ് റിട്ടേൺ മൂല്യത്തിന്റെ ടൈപ്പിനോട് സമാനമാണ്.\n    D. ഒരു ഫംഗ്ഷൻ അതിന്റെ ശരീരത്തിൽ നിന്ന് തന്നെ വിളിക്കാം.\nചോദ്യം 5:\nപോയിന്ററുകളെക്കുറിച്ചുള്ള ഏത് പ്രസ്താവന തെറ്റാണ്?\n    A. രണ്ട് പോയിന്ററുകൾ കുറയ്ക്കുന്നത് അവരുടെ വിലാസ മൂല്യങ്ങളുടെ വ്യത്യാസവുമായി തുല്യമാണ്.\n    B. പോയിന്റർ ഡീറഫറൻസ്, പോയിന്ററിന്റെ ടൈപ്പിനെ അടിസ്ഥാനമാക്കി പരിഹരിക്കുന്നു.\n    C. int *p[4], p ഒരു int പോയിന്ററുകളുടെ അറേയാണ്.\n    D. ഫംഗ്ഷൻ നാമങ്ങൾ ഫംഗ്ഷൻ പോയിന്ററുകൾക്ക് നിയോഗിക്കാം.\n>>> f_20()\nAAAAA\nനിങ്ങൾ \"AAAAA\" പോലുള്ള സ്ട്രിംഗുകൾ മാത്രം മടക്കേണ്ടതാണ്, ഇത് ചോദ്യത്തിന്റെ ചോയ്‌സുകൾക്ക് നിൽക്കുന്നു.", "fa": "یک تابع جاوااسکریپت `function f_20()` بنویسید تا مسئله زیر را حل کند:\nبه یک سری سوال با ارائه گزینه‌های A، B، C یا D برای هر سوال پاسخ دهید.\nسوال 1:\nثابت‌هایی مانند 1e6 به کدام نوع داده تعلق دارند؟\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nسوال 2:\nبا توجه به اینکه 21! = 51,090,942,171,709,440,000، از کدام نوع داده می‌توان برای ذخیره این مقدار استفاده کرد؟\n    A. int\n    B. long long\n    C. double\n    D. هیچ‌کدام از موارد فوق\nسوال 3:\nکدام عبارت درباره مقادیر چپ در عبارات نادرست است؟\n    A. عبارات نام متغیر مقادیر چپ هستند.\n    B. عملگر افزایش نیاز دارد که عملوند یک مقدار چپ باشد.\n    C. عبارات اشاره‌گر به مقادیر چپ هستند.\n    D. عبارات عملگر افزایش پیشوند مقادیر چپ هستند.\nسوال 4:\nکدام عبارت درباره توابع نادرست است؟\n    A. پارامترهای رسمی یک تابع متغیرهای محلی هستند.\n    B. متغیرهای محلی در پشته فضا تخصیص داده می‌شوند.\n    C. نوع تابع همان نوع مقدار بازگشتی است.\n    D. یک تابع می‌تواند خود را از درون بدنه‌اش فراخوانی کند.\nسوال 5:\nکدام عبارت درباره اشاره‌گرها نادرست است؟\n    A. تفریق دو اشاره‌گر برابر با تفاوت در مقادیر آدرس آنها است.\n    B. اشاره‌گر به نوع اشاره‌گر برای حل نیاز دارد.\n    C. int *p[4]، p یک آرایه از اشاره‌گرهای int است.\n    D. نام‌های تابع می‌توانند به اشاره‌گرهای تابع اختصاص داده شوند.\n>>> f_20()\nAAAAA\nشما باید فقط رشته‌هایی مشابه \"AAAAA\" که نمایانگر انتخاب‌های سوالات هستند را برگردانید."}, "level": "easy", "test": "function testf_20() {\n    const expected_answers = \"DDDBA\";\n    console.assert(f_20() === expected_answers, \"The function should return DDDBA as the correct answer.\");\n}\n\n// Running the tests\ntestf_20();", "entry_point": "f_20", "signature": "function f_20()", "docstring": {"en": "Answer a series of questions by providing choices A, B, C, or D for each question.\nQuestion 1:\nConstants like 1e6 belong to which data type?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nQuestion 2:\nGiven 21! = 51,090,942,171,709,440,000, which data type can be used to store this value?\n    A. int\n    B. long long\n    C. double\n    D. None of the above\nQuestion 3:\nWhich statement about left values in expressions is incorrect?\n    A. Variable name expressions are left values.\n    B. Increment operation requires the operand to be a left value.\n    C. Pointer dereference expressions are left values.\n    D. Prefix increment operation expressions are left values.\nQuestion 4:\nWhich statement about functions is incorrect?\n    A. Formal parameters of a function are local variables.\n    B. Local variables are allocated space in the stack.\n    C. The function type is the same as the return value type.\n    D. A function can call itself from within its body.\nQuestion 5:\nWhich statement about pointers is incorrect?\n    A. Subtracting two pointers equals the difference in their address values.\n    B. Pointer dereference involves resolving based on the pointer's type.\n    C. int *p[4], p is an array of int pointers.\n    D. Function names can be assigned to function pointers.\n    >>> f_20()\n    AAAAA\nYou're supposed to only return strings similar to \"AAAAA\", which stand for the choices of the question.", "sq": "Përgjigju një serie pyetjesh duke dhënë zgjedhjet A, B, C, ose D për secilën pyetje.\nPyetja 1:\nKonstantet si 1e6 i përkasin cilit tip të dhënash?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nPyetja 2:\nDuke dhënë 21! = 51,090,942,171,709,440,000, cili tip i dhënash mund të përdoret për të ruajtur këtë vlerë?\n    A. int\n    B. long long\n    C. double\n    D. Asnjë nga më sipër\nPyetja 3:\nCila deklaratë rreth vlerave të majta në shprehje është e pasaktë?\n    A. Shprehjet me emra variablash janë vlera të majta.\n    B. Operacioni i rritjes kërkon që operand të jetë një vlerë e majtë.\n    C. Shprehjet e dereferencimit të treguesve janë vlera të majta.\n    D. Shprehjet e operacionit të rritjes prefiks janë vlera të majta.\nPyetja 4:\nCila deklaratë rreth funksioneve është e pasaktë?\n    A. Parametrat formalë të një funksioni janë variabla lokale.\n    B. Variablat lokale kanë hapësirë të alokuar në stack.\n    C. Tipi i funksionit është i njëjtë me tipin e vlerës së kthimit.\n    D. Një funksion mund të thërrasë vetveten brenda trupit të tij.\nPyetja 5:\nCila deklaratë rreth treguesve është e pasaktë?\n    A. Zbritja e dy treguesve është e barabartë me diferencën në vlerat e adresave të tyre.\n    B. Dereferencimi i treguesit përfshin zgjidhjen bazuar në tipin e treguesit.\n    C. int *p[4], p është një varg treguesish int.\n    D. Emrat e funksioneve mund të caktohen në tregues funksionesh.\n>>> f_20()\nAAAAA\nJu duhet të ktheni vetëm vargje të ngjashme me \"AAAAA\", të cilat përfaqësojnë zgjedhjet e pyetjes.", "hy": "Պատասխանեք մի շարք հարցերի՝ յուրաքանչյուր հարցի համար տրամադրելով ընտրանքներ A, B, C կամ D:\nՀարց 1:\nՆման 1e6 հաստատունները որ տվյալների տիպին են պատկանում?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nՀարց 2:\nՏրված է 21! = 51,090,942,171,709,440,000, ո՞ր տվյալների տիպը կարող է օգտագործվել այս արժեքը պահելու համար:\n    A. int\n    B. long long\n    C. double\n    D. Վերը նշվածներից ոչ մեկը\nՀարց 3:\nՈ՞ր պնդումն է սխալ ձախ արժեքների վերաբերյալ արտահայտություններում:\n    A. Փոփոխականի անվան արտահայտությունները ձախ արժեքներ են:\n    B. Ինկրեմենտի գործողությունը պահանջում է, որ օպերանդը լինի ձախ արժեք:\n    C. Ցուցիչի ապահղման արտահայտությունները ձախ արժեքներ են:\n    D. Նախածանց ինկրեմենտի գործողության արտահայտությունները ձախ արժեքներ են:\nՀարց 4:\nՈ՞ր պնդումն է սխալ ֆունկցիաների վերաբերյալ:\n    A. Ֆունկցիայի ֆորմալ պարամետրերը տեղական փոփոխականներ են:\n    B. Տեղական փոփոխականների համար տարածք է հատկացվում ստեկում:\n    C. Ֆունկցիայի տիպը նույնն է, ինչ վերադարձվող արժեքի տիպը:\n    D. Ֆունկցիան կարող է ինքն իրեն կանչել իր մարմնի ներսից:\nՀարց 5:\nՈ՞ր պնդումն է սխալ ցուցիչների վերաբերյալ:\n    A. Երկու ցուցիչների հանումը հավասար է նրանց հասցեների արժեքների տարբերությանը:\n    B. Ցուցիչի ապահղումը ներառում է լուծում ցուցիչի տիպի հիման վրա:\n    C. int *p[4], p-ն int ցուցիչների զանգված է:\n    D. Ֆունկցիաների անունները կարող են վերագրվել ֆունկցիայի ցուցիչներին:\n>>> f_20()\nAAAAA\nԴուք պետք է վերադարձնեք միայն \"AAAAA\"-ի նման տողեր, որոնք ներկայացնում են հարցի ընտրանքները:", "bn": "প্রতিটি প্রশ্নের জন্য A, B, C, বা D বিকল্প প্রদান করে প্রশ্নগুলির একটি সিরিজের উত্তর দিন।\n\nপ্রশ্ন 1:\n1e6 এর মতো ধ্রুবক কোন ডেটা টাইপের অন্তর্গত?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nপ্রশ্ন 2:\n21! = 51,090,942,171,709,440,000 দেওয়া হলে, কোন ডেটা টাইপ এই মান সংরক্ষণ করতে ব্যবহার করা যেতে পারে?\n    A. int\n    B. long long\n    C. double\n    D. উপরোক্ত কোনোটিই নয়\n\nপ্রশ্ন 3:\nএক্সপ্রেশনে বাম মান সম্পর্কে কোন বিবৃতি ভুল?\n    A. ভেরিয়েবল নাম এক্সপ্রেশনগুলি বাম মান।\n    B. ইনক্রিমেন্ট অপারেশনটির জন্য অপারেন্ড একটি বাম মান হতে হবে।\n    C. পয়েন্টার ডেরেফারেন্স এক্সপ্রেশনগুলি বাম মান।\n    D. প্রিফিক্স ইনক্রিমেন্ট অপারেশন এক্সপ্রেশনগুলি বাম মান।\n\nপ্রশ্ন 4:\nফাংশন সম্পর্কে কোন বিবৃতি ভুল?\n    A. একটি ফাংশনের আনুষ্ঠানিক প্যারামিটারগুলি স্থানীয় ভেরিয়েবল।\n    B. স্থানীয় ভেরিয়েবলগুলি স্ট্যাকে স্থান বরাদ্দ করা হয়।\n    C. ফাংশনের ধরন হল রিটার্ন মানের ধরন।\n    D. একটি ফাংশন তার দেহের মধ্যে থেকে নিজেকে কল করতে পারে।\n\nপ্রশ্ন 5:\nপয়েন্টার সম্পর্কে কোন বিবৃতি ভুল?\n    A. দুটি পয়েন্টার বিয়োগ করার মানে তাদের ঠিকানা মানের পার্থক্য।\n    B. পয়েন্টার ডেরেফারেন্স পয়েন্টারের টাইপের উপর ভিত্তি করে সমাধান করা জড়িত।\n    C. int *p[4], p একটি int পয়েন্টারের অ্যারে।\n    D. ফাংশন নামগুলি ফাংশন পয়েন্টারগুলিতে বরাদ্দ করা যেতে পারে।\n\n>>> f_20()\nAAAAA\n\nআপনাকে শুধুমাত্র \"AAAAA\" এর মতো স্ট্রিংগুলি ফেরত দেওয়ার কথা, যা প্রশ্নের বিকল্পগুলির জন্য দাঁড়ায়।", "bg": "Отговорете на серия от въпроси, като предоставите избори A, B, C или D за всеки въпрос.  \nВъпрос 1:  \nКонстанти като 1e6 принадлежат към кой тип данни?  \n    A. unsigned int  \n    B. int  \n    C. float  \n    D. double  \nВъпрос 2:  \nДадено е 21! = 51,090,942,171,709,440,000, кой тип данни може да се използва за съхранение на тази стойност?  \n    A. int  \n    B. long long  \n    C. double  \n    D. Нито едно от горните  \nВъпрос 3:  \nКое твърдение за левите стойности в изразите е неправилно?  \n    A. Изразите с имена на променливи са леви стойности.  \n    B. Операцията за инкремент изисква операндът да бъде лява стойност.  \n    C. Изразите за разименуване на указатели са леви стойности.  \n    D. Изразите за префиксен инкремент са леви стойности.  \nВъпрос 4:  \nКое твърдение за функциите е неправилно?  \n    A. Формалните параметри на функцията са локални променливи.  \n    B. Локалните променливи се разпределят в стека.  \n    C. Типът на функцията е същият като типа на връщаната стойност.  \n    D. Една функция може да извика себе си от тялото си.  \nВъпрос 5:  \nКое твърдение за указателите е неправилно?  \n    A. Изваждането на два указателя е равно на разликата в стойностите на техните адреси.  \n    B. Разименуването на указател включва разрешаване въз основа на типа на указателя.  \n    C. int *p[4], p е масив от указатели към int.  \n    D. Имената на функциите могат да бъдат присвоени на указатели към функции.  \n>>> f_20()  \n    AAAAA  \nТрябва да върнете само низове, подобни на \"AAAAA\", които представляват изборите на въпроса.", "zh": "回答一系列问题，为每个问题提供选择A、B、C或D。\n\n问题1： 常量如1e6属于哪种数据类型？ \n    A. unsigned int \n    B. int \n    C. float \n    D. double \n\n问题2： 给定21! = 51,090,942,171,709,440,000，哪种数据类型可以用来存储这个值？ \n    A. int \n    B. long long \n    C. double \n    D. 以上都不是 \n\n问题3： 关于表达式中的左值，哪个说法不正确？ \n    A. 变量名表达式是左值。 \n    B. 增量操作要求操作数是左值。 \n    C. 指针解引用表达式是左值。 \n    D. 前缀增量操作表达式是左值。 \n\n问题4： 关于函数，哪个说法不正确？ \n    A. 函数的形式参数是局部变量。 \n    B. 局部变量在栈中分配空间。 \n    C. 函数类型与返回值类型相同。 \n    D. 函数可以在其主体内调用自身。 \n\n问题5： 关于指针，哪个说法不正确？ \n    A. 两个指针相减等于它们地址值的差。 \n    B. 指针解引用涉及基于指针类型的解析。 \n    C. int *p[4]，p是一个int指针数组。 \n    D. 函数名可以赋值给函数指针。 \n\n>>> f_20() \n    AAAAA \n你应该只返回类似于“AAAAA”的字符串，代表问题的选择。", "fr": "Répondez à une série de questions en fournissant des choix A, B, C ou D pour chaque question.\n\nQuestion 1:\nLes constantes comme 1e6 appartiennent à quel type de données ?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nQuestion 2:\nÉtant donné 21! = 51,090,942,171,709,440,000, quel type de données peut être utilisé pour stocker cette valeur ?\n    A. int\n    B. long long\n    C. double\n    D. Aucun des précédents\n\nQuestion 3:\nQuelle affirmation concernant les valeurs à gauche dans les expressions est incorrecte ?\n    A. Les expressions de nom de variable sont des valeurs à gauche.\n    B. L'opération d'incrément nécessite que l'opérande soit une valeur à gauche.\n    C. Les expressions de déréférencement de pointeur sont des valeurs à gauche.\n    D. Les expressions d'opération de pré-incrémentation sont des valeurs à gauche.\n\nQuestion 4:\nQuelle affirmation concernant les fonctions est incorrecte ?\n    A. Les paramètres formels d'une fonction sont des variables locales.\n    B. Les variables locales sont allouées dans la pile.\n    C. Le type de la fonction est le même que le type de la valeur de retour.\n    D. Une fonction peut s'appeler elle-même depuis son corps.\n\nQuestion 5:\nQuelle affirmation concernant les pointeurs est incorrecte ?\n    A. Soustraire deux pointeurs équivaut à la différence de leurs valeurs d'adresse.\n    B. Le déréférencement de pointeur implique une résolution basée sur le type du pointeur.\n    C. int *p[4], p est un tableau de pointeurs int.\n    D. Les noms de fonctions peuvent être assignés à des pointeurs de fonction.\n\n>>> f_20()\n    AAAAA\n\nVous êtes censé ne retourner que des chaînes similaires à \"AAAAA\", qui représentent les choix de la question.", "de": "Beantworte eine Reihe von Fragen, indem du für jede Frage die Optionen A, B, C oder D angibst.\nFrage 1:\nKonstanten wie 1e6 gehören zu welchem Datentyp?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nFrage 2:\nAngenommen, 21! = 51,090,942,171,709,440,000, welcher Datentyp kann verwendet werden, um diesen Wert zu speichern?\n    A. int\n    B. long long\n    C. double\n    D. Keine der oben genannten\nFrage 3:\nWelche Aussage über linke Werte in Ausdrücken ist falsch?\n    A. Variablennamen-Ausdrücke sind linke Werte.\n    B. Die Inkrementoperation erfordert, dass der Operand ein linker Wert ist.\n    C. Zeiger-Dereferenz-Ausdrücke sind linke Werte.\n    D. Präfix-Inkrement-Operation-Ausdrücke sind linke Werte.\nFrage 4:\nWelche Aussage über Funktionen ist falsch?\n    A. Formale Parameter einer Funktion sind lokale Variablen.\n    B. Lokale Variablen werden im Stack Speicherplatz zugewiesen.\n    C. Der Funktionstyp ist derselbe wie der Rückgabewerttyp.\n    D. Eine Funktion kann sich selbst innerhalb ihres Körpers aufrufen.\nFrage 5:\nWelche Aussage über Zeiger ist falsch?\n    A. Das Subtrahieren von zwei Zeigern entspricht der Differenz ihrer Adresswerte.\n    B. Zeiger-Dereferenzierung erfolgt basierend auf dem Typ des Zeigers.\n    C. int *p[4], p ist ein Array von int-Zeigern.\n    D. Funktionsnamen können Funktionszeigern zugewiesen werden.\n>>> f_20()\nAAAAA\nDu sollst nur Zeichenfolgen ähnlich wie \"AAAAA\" zurückgeben, die für die Auswahlmöglichkeiten der Frage stehen.", "ha": "Amsa jerin tambayoyi ta hanyar bayar da zaɓuɓɓuka A, B, C, ko D ga kowace tambaya.\n\nTambaya ta 1:\nDindindin kamar 1e6 suna cikin wane nau'in bayanai?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nTambaya ta 2:\nAn bayar da 21! = 51,090,942,171,709,440,000, wane nau'in bayanai za a iya amfani da shi don adana wannan ƙima?\n    A. int\n    B. long long\n    C. double\n    D. Babu ɗaya daga cikin waɗannan\n\nTambaya ta 3:\nWane bayani game da ƙimar hagu a cikin maganganu ba daidai ba ne?\n    A. Maganganun sunayen masu canji ƙimar hagu ne.\n    B. Aiki na ƙara yana buƙatar mai aiki ya zama ƙimar hagu.\n    C. Maganganun cirewa mai nuna suna ƙimar hagu ne.\n    D. Maganganun aiki na ƙara na farko ƙimar hagu ne.\n\nTambaya ta 4:\nWane bayani game da ayyuka ba daidai ba ne?\n    A. Sigogin tsari na aiki masu canji na gida ne.\n    B. Ana ware sarari ga masu canji na gida a cikin faifan.\n    C. Nau'in aiki iri ɗaya ne da nau'in ƙimar dawowa.\n    D. Aiki na iya kiran kansa daga cikin jikinsa.\n\nTambaya ta 5:\nWane bayani game da masu nuna ba daidai ba ne?\n    A. Rage masu nuna biyu yana daidai da bambanci a cikin ƙimar adireshinsu.\n    B. Cire mai nuna yana da alaƙa da warwarewa bisa nau'in mai nuna.\n    C. int *p[4], p tsari ne na masu nuna int.\n    D. Ana iya sanya sunayen ayyuka ga masu nuna ayyuka.\n\n>>> f_20()\nAAAAA\n\nAna tsammanin ka dawo da kirtani irin \"AAAAA\", wanda ke wakiltar zaɓuɓɓukan tambayar.", "hi": "प्रश्नों की एक श्रृंखला का उत्तर देकर प्रत्येक प्रश्न के लिए विकल्प A, B, C, या D प्रदान करें।  \nप्रश्न 1:  \n1e6 जैसी स्थिरांक किस डेटा प्रकार से संबंधित हैं?  \n    A. unsigned int  \n    B. int  \n    C. float  \n    D. double  \nप्रश्न 2:  \nदिया गया 21! = 51,090,942,171,709,440,000, इस मान को संग्रहीत करने के लिए कौन सा डेटा प्रकार उपयोग किया जा सकता है?  \n    A. int  \n    B. long long  \n    C. double  \n    D. उपरोक्त में से कोई नहीं  \nप्रश्न 3:  \nअभिव्यक्तियों में बाएँ मानों के बारे में कौन सा कथन गलत है?  \n    A. चर नाम अभिव्यक्तियाँ बाएँ मान हैं।  \n    B. वृद्धि ऑपरेशन के लिए ऑपरेन्ड का बाएँ मान होना आवश्यक है।  \n    C. पॉइंटर डिरेफरेंस अभिव्यक्तियाँ बाएँ मान हैं।  \n    D. उपसर्ग वृद्धि ऑपरेशन अभिव्यक्तियाँ बाएँ मान हैं।  \nप्रश्न 4:  \nफंक्शनों के बारे में कौन सा कथन गलत है?  \n    A. एक फ़ंक्शन के औपचारिक पैरामीटर स्थानीय चर होते हैं।  \n    B. स्थानीय चर स्टैक में स्थान आवंटित करते हैं।  \n    C. फ़ंक्शन प्रकार वही होता है जो रिटर्न मान प्रकार होता है।  \n    D. एक फ़ंक्शन अपने शरीर के भीतर से स्वयं को कॉल कर सकता है।  \nप्रश्न 5:  \nपॉइंटर्स के बारे में कौन सा कथन गलत है?  \n    A. दो पॉइंटर्स को घटाने से उनके पते के मानों में अंतर होता है।  \n    B. पॉइंटर डिरेफरेंस में पॉइंटर के प्रकार के आधार पर समाधान शामिल होता है।  \n    C. int *p[4], p एक int पॉइंटर्स की सरणी है।  \n    D. फ़ंक्शन नामों को फ़ंक्शन पॉइंटर्स को असाइन किया जा सकता है।  \n>>> f_20()  \nAAAAA  \nआपको केवल \"AAAAA\" जैसे स्ट्रिंग्स लौटाने चाहिए, जो प्रश्न के विकल्पों के लिए खड़े होते हैं।", "hu": "Válaszolj egy sor kérdésre azáltal, hogy A, B, C vagy D választ adsz minden kérdésre.\nKérdés 1:\nAz olyan konstansok, mint az 1e6, melyik adattípushoz tartoznak?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nKérdés 2:\nAdott, hogy 21! = 51,090,942,171,709,440,000, melyik adattípus használható ennek az értéknek a tárolására?\n    A. int\n    B. long long\n    C. double\n    D. Egyik sem a fentiek közül\nKérdés 3:\nMelyik állítás helytelen a balértékekkel kapcsolatban a kifejezésekben?\n    A. A változónév kifejezések balértékek.\n    B. Az inkrementáló művelet megköveteli, hogy az operandus balérték legyen.\n    C. A pointer dereferálás kifejezések balértékek.\n    D. A prefix inkrementáló művelet kifejezések balértékek.\nKérdés 4:\nMelyik állítás helytelen a függvényekkel kapcsolatban?\n    A. A függvény formális paraméterei lokális változók.\n    B. A lokális változók helyet kapnak a veremben.\n    C. A függvény típusa megegyezik a visszatérési érték típusával.\n    D. Egy függvény meghívhatja önmagát a saját törzsén belül.\nKérdés 5:\nMelyik állítás helytelen a pointerekkel kapcsolatban?\n    A. Két pointer kivonása egyenlő a címértékeik különbségével.\n    B. A pointer dereferálása a pointer típusának megfelelően történik.\n    C. int *p[4], p egy int pointerek tömbje.\n    D. A függvénynevek hozzárendelhetők függvénypointerekhez.\n>>> f_20()\nAAAAA\nCsak olyan karakterláncokat kell visszaadnod, mint például \"AAAAA\", amelyek a kérdések választásait jelölik.", "es": "Responder a una serie de preguntas proporcionando opciones A, B, C o D para cada pregunta.  \nPregunta 1:  \n¿A qué tipo de datos pertenecen constantes como 1e6?  \n    A. unsigned int  \n    B. int  \n    C. float  \n    D. double  \nPregunta 2:  \nDado 21! = 51,090,942,171,709,440,000, ¿qué tipo de datos se puede usar para almacenar este valor?  \n    A. int  \n    B. long long  \n    C. double  \n    D. Ninguno de los anteriores  \nPregunta 3:  \n¿Cuál afirmación sobre los valores izquierdos en expresiones es incorrecta?  \n    A. Las expresiones de nombres de variables son valores izquierdos.  \n    B. La operación de incremento requiere que el operando sea un valor izquierdo.  \n    C. Las expresiones de desreferencia de punteros son valores izquierdos.  \n    D. Las expresiones de operación de incremento prefijo son valores izquierdos.  \nPregunta 4:  \n¿Cuál afirmación sobre las funciones es incorrecta?  \n    A. Los parámetros formales de una función son variables locales.  \n    B. Las variables locales se asignan espacio en la pila.  \n    C. El tipo de función es el mismo que el tipo de valor de retorno.  \n    D. Una función puede llamarse a sí misma desde dentro de su cuerpo.  \nPregunta 5:  \n¿Cuál afirmación sobre los punteros es incorrecta?  \n    A. Restar dos punteros equivale a la diferencia en sus valores de dirección.  \n    B. La desreferencia de punteros implica resolver según el tipo del puntero.  \n    C. int *p[4], p es un arreglo de punteros a int.  \n    D. Los nombres de funciones pueden asignarse a punteros de función.  \n>>> f_20()  \nAAAAA  \nSe supone que solo debes devolver cadenas similares a \"AAAAA\", que representan las opciones de la pregunta.", "arb": "أجب عن سلسلة من الأسئلة بتقديم الخيارات A، B، C، أو D لكل سؤال.\nالسؤال 1:\nالثوابت مثل 1e6 تنتمي إلى أي نوع من البيانات؟\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nالسؤال 2:\nبالنظر إلى 21! = 51,090,942,171,709,440,000، أي نوع من البيانات يمكن استخدامه لتخزين هذه القيمة؟\n    A. int\n    B. long long\n    C. double\n    D. لا شيء مما سبق\nالسؤال 3:\nأي عبارة عن القيم اليسارية في التعبيرات غير صحيحة؟\n    A. تعبيرات أسماء المتغيرات هي قيم يسارية.\n    B. عملية الزيادة تتطلب أن يكون المعامل قيمة يسارية.\n    C. تعبيرات إلغاء الإشارة للمؤشر هي قيم يسارية.\n    D. تعبيرات عملية الزيادة المسبقة هي قيم يسارية.\nالسؤال 4:\nأي عبارة عن الدوال غير صحيحة؟\n    A. المعلمات الرسمية للدالة هي متغيرات محلية.\n    B. يتم تخصيص مساحة للمتغيرات المحلية في المكدس.\n    C. نوع الدالة هو نفس نوع قيمة الإرجاع.\n    D. يمكن للدالة أن تستدعي نفسها من داخل جسمها.\nالسؤال 5:\nأي عبارة عن المؤشرات غير صحيحة؟\n    A. طرح مؤشرين يساوي الفرق في قيم عناوينهما.\n    B. إلغاء إشارة المؤشر يتضمن الحل بناءً على نوع المؤشر.\n    C. int *p[4]، p هو مصفوفة من مؤشرات int.\n    D. يمكن تعيين أسماء الدوال إلى مؤشرات الدوال.\n>>> f_20()\nAAAAA\nمن المفترض أن تعيد فقط سلاسل مشابهة لـ \"AAAAA\"، والتي تمثل اختيارات السؤال.", "sw": "Jibu maswali kadhaa kwa kutoa chaguo A, B, C, au D kwa kila swali.  \nSwali la 1:  \nKonstanti kama 1e6 ni za aina gani ya data?  \n    A. unsigned int  \n    B. int  \n    C. float  \n    D. double  \nSwali la 2:  \nKwa kuwa 21! = 51,090,942,171,709,440,000, ni aina gani ya data inaweza kutumika kuhifadhi thamani hii?  \n    A. int  \n    B. long long  \n    C. double  \n    D. Hakuna kati ya hapo juu  \nSwali la 3:  \nNi kauli gani kuhusu thamani za kushoto katika maelezo si sahihi?  \n    A. Maelezo ya majina ya vigezo ni thamani za kushoto.  \n    B. Operesheni ya kuongeza inahitaji operand kuwa thamani ya kushoto.  \n    C. Maelezo ya kufuta pointer ni thamani za kushoto.  \n    D. Maelezo ya operesheni ya kuongeza awali ni thamani za kushoto.  \nSwali la 4:  \nNi kauli gani kuhusu kazi si sahihi?  \n    A. Vigezo rasmi vya kazi ni vigezo vya ndani.  \n    B. Vigezo vya ndani vinatengwa nafasi katika stack.  \n    C. Aina ya kazi ni sawa na aina ya thamani ya kurudi.  \n    D. Kazi inaweza kujita kutoka ndani ya mwili wake.  \nSwali la 5:  \nNi kauli gani kuhusu pointer si sahihi?  \n    A. Kutoa pointer mbili ni sawa na tofauti katika thamani za anwani zao.  \n    B. Kufuta pointer kunahusisha kutatua kulingana na aina ya pointer.  \n    C. int *p[4], p ni safu ya pointer za int.  \n    D. Majina ya kazi yanaweza kupewa pointer za kazi.  \n>>> f_20()  \nAAAAA  \nUnatakiwa kurudisha tu misururu inayofanana na \"AAAAA\", ambayo inasimama kwa chaguo za swali.", "tr": "Bir dizi soruya A, B, C veya D seçeneklerini sağlayarak cevap verin.\nSoru 1:\n1e6 gibi sabitler hangi veri türüne aittir?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nSoru 2:\n21! = 51,090,942,171,709,440,000 verildiğinde, bu değeri saklamak için hangi veri türü kullanılabilir?\n    A. int\n    B. long long\n    C. double\n    D. Yukarıdakilerin hiçbiri\nSoru 3:\nİfadelerdeki sol değerler hakkında hangi ifade yanlıştır?\n    A. Değişken adı ifadeleri sol değerlerdir.\n    B. Artırma işlemi, operandın sol değer olmasını gerektirir.\n    C. İşaretçi çözme ifadeleri sol değerlerdir.\n    D. Ön ek artırma işlemi ifadeleri sol değerlerdir.\nSoru 4:\nFonksiyonlar hakkında hangi ifade yanlıştır?\n    A. Bir fonksiyonun resmi parametreleri yerel değişkenlerdir.\n    B. Yerel değişkenler yığında yer kaplar.\n    C. Fonksiyon türü, dönüş değeri türü ile aynıdır.\n    D. Bir fonksiyon, gövdesi içinden kendisini çağırabilir.\nSoru 5:\nİşaretçiler hakkında hangi ifade yanlıştır?\n    A. İki işaretçinin çıkarılması, adres değerlerindeki farkı eşittir.\n    B. İşaretçi çözme, işaretçinin türüne göre çözümlemeyi içerir.\n    C. int *p[4], p bir int işaretçi dizisidir.\n    D. Fonksiyon adları, fonksiyon işaretçilerine atanabilir.\n>>> f_20()\nAAAAA\nYalnızca soruların seçeneklerini temsil eden \"AAAAA\" gibi dizeleri döndürmeniz gerekiyor.", "vi": "Trả lời một loạt câu hỏi bằng cách cung cấp lựa chọn A, B, C hoặc D cho mỗi câu hỏi.\n\nCâu hỏi 1:\nHằng số như 1e6 thuộc kiểu dữ liệu nào?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nCâu hỏi 2:\nCho 21! = 51,090,942,171,709,440,000, kiểu dữ liệu nào có thể được sử dụng để lưu trữ giá trị này?\n    A. int\n    B. long long\n    C. double\n    D. Không có lựa chọn nào ở trên\n\nCâu hỏi 3:\nPhát biểu nào về giá trị bên trái trong biểu thức là không đúng?\n    A. Biểu thức tên biến là giá trị bên trái.\n    B. Phép toán tăng yêu cầu toán hạng phải là giá trị bên trái.\n    C. Biểu thức giải tham chiếu con trỏ là giá trị bên trái.\n    D. Biểu thức phép toán tăng trước là giá trị bên trái.\n\nCâu hỏi 4:\nPhát biểu nào về hàm là không đúng?\n    A. Tham số hình thức của một hàm là biến cục bộ.\n    B. Biến cục bộ được cấp phát không gian trong ngăn xếp.\n    C. Kiểu của hàm giống với kiểu giá trị trả về.\n    D. Một hàm có thể gọi chính nó từ bên trong thân của nó.\n\nCâu hỏi 5:\nPhát biểu nào về con trỏ là không đúng?\n    A. Trừ hai con trỏ bằng với sự khác biệt trong giá trị địa chỉ của chúng.\n    B. Giải tham chiếu con trỏ liên quan đến việc giải quyết dựa trên kiểu của con trỏ.\n    C. int *p[4], p là một mảng các con trỏ int.\n    D. Tên hàm có thể được gán cho con trỏ hàm.\n\n>>> f_20()\nAAAAA\n\nBạn được yêu cầu chỉ trả về các chuỗi tương tự như \"AAAAA\", đại diện cho các lựa chọn của câu hỏi.", "id": "Menjawab serangkaian pertanyaan dengan memberikan pilihan A, B, C, atau D untuk setiap pertanyaan.\n\nPertanyaan 1:\nKonstanta seperti 1e6 termasuk ke dalam tipe data apa?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nPertanyaan 2:\nDiberikan 21! = 51,090,942,171,709,440,000, tipe data mana yang dapat digunakan untuk menyimpan nilai ini?\n    A. int\n    B. long long\n    C. double\n    D. Tidak ada dari yang di atas\n\nPertanyaan 3:\nPernyataan mana tentang nilai kiri dalam ekspresi yang salah?\n    A. Ekspresi nama variabel adalah nilai kiri.\n    B. Operasi inkremen memerlukan operan menjadi nilai kiri.\n    C. Ekspresi dereferensi pointer adalah nilai kiri.\n    D. Ekspresi operasi inkremen prefiks adalah nilai kiri.\n\nPertanyaan 4:\nPernyataan mana tentang fungsi yang salah?\n    A. Parameter formal dari sebuah fungsi adalah variabel lokal.\n    B. Variabel lokal dialokasikan ruang di stack.\n    C. Tipe fungsi sama dengan tipe nilai kembalian.\n    D. Sebuah fungsi dapat memanggil dirinya sendiri dari dalam tubuhnya.\n\nPertanyaan 5:\nPernyataan mana tentang pointer yang salah?\n    A. Mengurangi dua pointer sama dengan perbedaan dalam nilai alamat mereka.\n    B. Dereferensi pointer melibatkan penyelesaian berdasarkan tipe pointer.\n    C. int *p[4], p adalah array dari pointer int.\n    D. Nama fungsi dapat ditetapkan ke pointer fungsi.\n\n>>> f_20()\nAAAAA\n\nAnda seharusnya hanya mengembalikan string yang mirip dengan \"AAAAA\", yang mewakili pilihan dari pertanyaan.", "ja": "一連の質問に対して、各質問に対して選択肢A、B、C、またはDを提供して答えてください。\n\n質問1:\n1e6のような定数はどのデータ型に属しますか？\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\n質問2:\n21! = 51,090,942,171,709,440,000の場合、この値を格納するのに使用できるデータ型はどれですか？\n    A. int\n    B. long long\n    C. double\n    D. 上記のいずれでもない\n\n質問3:\n式の左辺値について誤っているのはどの文ですか？\n    A. 変数名の式は左辺値です。\n    B. インクリメント操作にはオペランドが左辺値である必要があります。\n    C. ポインタの逆参照式は左辺値です。\n    D. 前置インクリメント操作の式は左辺値です。\n\n質問4:\n関数について誤っているのはどの文ですか？\n    A. 関数の形式パラメータはローカル変数です。\n    B. ローカル変数はスタックにスペースが割り当てられます。\n    C. 関数の型は戻り値の型と同じです。\n    D. 関数はその本体内から自分自身を呼び出すことができます。\n\n質問5:\nポインタについて誤っているのはどの文ですか？\n    A. 2つのポインタを引くと、それらのアドレス値の差になります。\n    B. ポインタの逆参照はポインタの型に基づいて解決されます。\n    C. int *p[4]、pはintポインタの配列です。\n    D. 関数名は関数ポインタに代入できます。\n\n>>> f_20()\nAAAAA\n\n質問の選択肢を表す「AAAAA」のような文字列のみを返すことになっています。", "ko": "일련의 질문에 대해 각 질문에 대한 선택지 A, B, C, 또는 D를 제공하여 답변하십시오.  \n질문 1:  \n1e6과 같은 상수는 어떤 데이터 유형에 속합니까?  \n    A. unsigned int  \n    B. int  \n    C. float  \n    D. double  \n질문 2:  \n21! = 51,090,942,171,709,440,000이 주어졌을 때, 이 값을 저장하는 데 사용할 수 있는 데이터 유형은 무엇입니까?  \n    A. int  \n    B. long long  \n    C. double  \n    D. 위의 어느 것도 아님  \n질문 3:  \n식에서 왼쪽 값에 대한 설명 중 틀린 것은 무엇입니까?  \n    A. 변수 이름 표현식은 왼쪽 값입니다.  \n    B. 증가 연산은 피연산자가 왼쪽 값이어야 합니다.  \n    C. 포인터 역참조 표현식은 왼쪽 값입니다.  \n    D. 접두사 증가 연산 표현식은 왼쪽 값입니다.  \n질문 4:  \n함수에 대한 설명 중 틀린 것은 무엇입니까?  \n    A. 함수의 형식 매개변수는 지역 변수입니다.  \n    B. 지역 변수는 스택에 공간이 할당됩니다.  \n    C. 함수 유형은 반환 값 유형과 동일합니다.  \n    D. 함수는 본문 내에서 자신을 호출할 수 있습니다.  \n질문 5:  \n포인터에 대한 설명 중 틀린 것은 무엇입니까?  \n    A. 두 포인터를 빼면 주소 값의 차이가 됩니다.  \n    B. 포인터 역참조는 포인터의 유형에 따라 해석됩니다.  \n    C. int *p[4], p는 int 포인터의 배열입니다.  \n    D. 함수 이름은 함수 포인터에 할당될 수 있습니다.  \n>>> f_20()  \nAAAAA  \n당신은 질문의 선택지를 나타내는 \"AAAAA\"와 유사한 문자열만 반환해야 합니다.", "ml": "ഒരു ചോദ്യാവലി ചോദ്യങ്ങൾക്ക് ഓരോ ചോദ്യത്തിനും A, B, C, അല്ലെങ്കിൽ D എന്നിങ്ങനെ തിരഞ്ഞെടുക്കലുകൾ നൽകിക്കൊണ്ട് ഉത്തരം നൽകുക.\n\nചോദ്യം 1:\n1e6 പോലുള്ള സ്ഥിരാങ്കങ്ങൾ ഏത് ഡാറ്റാ തരം ആണെന്ന് കാണിക്കുന്നു?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nചോദ്യം 2:\n21! = 51,090,942,171,709,440,000 എന്നത് നൽകിയാൽ, ഈ മൂല്യം സംഭരിക്കാൻ ഏത് ഡാറ്റാ തരം ഉപയോഗിക്കാം?\n    A. int\n    B. long long\n    C. double\n    D. മുകളിലുള്ളവയിൽ ഒന്നുമല്ല\n\nചോദ്യം 3:\nവ്യക്തീകരണങ്ങളിലെ ഇടത് മൂല്യങ്ങളെക്കുറിച്ചുള്ള ഏത് പ്രസ്താവന തെറ്റാണ്?\n    A. വേരിയബിൾ നെയിം എക്സ്പ്രഷനുകൾ ഇടത് മൂല്യങ്ങളാണ്.\n    B. വർദ്ധന പ്രവർത്തനം ഇടത് മൂല്യമായ ഓപ്പറാൻഡ് ആവശ്യമാണ്.\n    C. പോയിന്റർ ഡീരിഫറൻസ് എക്സ്പ്രഷനുകൾ ഇടത് മൂല്യങ്ങളാണ്.\n    D. പ്രിഫിക്സ് വർദ്ധന പ്രവർത്തന എക്സ്പ്രഷനുകൾ ഇടത് മൂല്യങ്ങളാണ്.\n\nചോദ്യം 4:\nഫംഗ്ഷനുകളെക്കുറിച്ചുള്ള ഏത് പ്രസ്താവന തെറ്റാണ്?\n    A. ഒരു ഫംഗ്ഷന്റെ ഔപചാരിക പാരാമീറ്ററുകൾ പ്രാദേശിക ചാരങ്ങളാണ്.\n    B. പ്രാദേശിക ചാരങ്ങൾക്ക് സ്റ്റാക്കിൽ സ്ഥലം അനുവദിച്ചിരിക്കുന്നു.\n    C. ഫംഗ്ഷൻ തരം മടക്ക മൂല്യ തരം പോലെയാണ്.\n    D. ഒരു ഫംഗ്ഷൻ അതിന്റെ ശരീരത്തിൽ നിന്ന് തന്നെ വിളിക്കാം.\n\nചോദ്യം 5:\nപോയിന്ററുകളെക്കുറിച്ചുള്ള ഏത് പ്രസ്താവന തെറ്റാണ്?\n    A. രണ്ട് പോയിന്ററുകൾ കുറയ്ക്കുന്നത് അവരുടെ വിലാസ മൂല്യങ്ങളിലെ വ്യത്യാസം ആണ്.\n    B. പോയിന്റർ ഡീരിഫറൻസ്, പോയിന്ററിന്റെ തരം അടിസ്ഥാനമാക്കി പരിഹരിക്കപ്പെടുന്നു.\n    C. int *p[4], p ഒരു int പോയിന്ററുകളുടെ നിരയാണ്.\n    D. ഫംഗ്ഷൻ നാമങ്ങൾ ഫംഗ്ഷൻ പോയിന്ററുകൾക്ക് നിയോഗിക്കാം.\n\n>>> f_20()\nAAAAA\n\nനിങ്ങൾ \"AAAAA\" പോലുള്ള സ്ട്രിംഗുകൾ മാത്രം മടക്കേണ്ടതാണ്, ഇത് ചോദ്യത്തിന്റെ തിരഞ്ഞെടുക്കലുകൾക്ക് നിൽക്കുന്നു.", "fa": "پاسخ به مجموعه‌ای از سوالات با ارائه گزینه‌های A، B، C یا D برای هر سوال.\n\nسوال 1:\nثابت‌هایی مانند 1e6 به کدام نوع داده تعلق دارند؟\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nسوال 2:\nبا توجه به 21! = 51,090,942,171,709,440,000، کدام نوع داده می‌تواند این مقدار را ذخیره کند؟\n    A. int\n    B. long long\n    C. double\n    D. هیچ‌کدام از موارد بالا\n\nسوال 3:\nکدام عبارت درباره مقادیر چپ در عبارات نادرست است؟\n    A. عبارات نام متغیر مقادیر چپ هستند.\n    B. عملیات افزایش نیاز دارد که عملوند یک مقدار چپ باشد.\n    C. عبارات اشاره‌گر به مقدار مقادیر چپ هستند.\n    D. عبارات عملیات افزایش پیشوندی مقادیر چپ هستند.\n\nسوال 4:\nکدام عبارت درباره توابع نادرست است؟\n    A. پارامترهای رسمی یک تابع متغیرهای محلی هستند.\n    B. متغیرهای محلی در پشته فضا تخصیص می‌دهند.\n    C. نوع تابع همان نوع مقدار بازگشتی است.\n    D. یک تابع می‌تواند خودش را از درون بدنه‌اش فراخوانی کند.\n\nسوال 5:\nکدام عبارت درباره اشاره‌گرها نادرست است؟\n    A. تفریق دو اشاره‌گر برابر با تفاوت در مقادیر آدرس آنها است.\n    B. اشاره‌گر به مقدار شامل حل بر اساس نوع اشاره‌گر است.\n    C. int *p[4]، p یک آرایه از اشاره‌گرهای int است.\n    D. نام‌های تابع می‌توانند به اشاره‌گرهای تابع اختصاص یابند.\n\n>>> f_20()\nAAAAA\n\nشما باید فقط رشته‌هایی مشابه \"AAAAA\" را برگردانید که نمایانگر گزینه‌های سوال هستند."}}
{"task_id": "JavaScript/21", "prompt": {"en": "/**\n * Determines if it is possible to assemble the wooden squares from n buckets,\n * where each bucket contains a_i squares with a side length of 1, into a single larger square.\n * Input: length of the list, array of numbers\n * @param {number} length - The number of buckets.\n * @param {number[]} squares - An array of numbers, where each number represents the count of squares in a bucket.\n * @returns {boolean} - Returns true if it's possible to form a perfect square, otherwise returns false.\n *\n * Examples:\n * f_21(1, [9]) // true\n */\nfunction f_21(length, squares)", "sq": "/**\n * Përcakton nëse është e mundur të montohet katrorët prej druri nga n kovë,\n * ku secila kovë përmban a_i katrorë me një gjatësi anësore prej 1, në një katror më të madh.\n * Hyrja: gjatësia e listës, vargu i numrave\n * @param {number} length - Numri i kovëve.\n * @param {number[]} squares - Një varg numrash, ku secili numër përfaqëson numrin e katrorëve në një kovë.\n * @returns {boolean} - Kthen true nëse është e mundur të formohet një katror i përsosur, përndryshe kthen false.\n *\n * Shembuj:\n * f_21(1, [9]) // true\n */\nfunction f_21(length, squares)", "hy": "/**\n * Որոշում է՝ արդյոք հնարավոր է հավաքել փայտե քառակուսիները n դույլերից,\n * որտեղ յուրաքանչյուր դույլ պարունակում է a_i կողով 1 երկարությամբ քառակուսիներ, մեկ մեծ քառակուսի մեջ:\n * Մուտքագրում՝ ցուցակի երկարություն, թվերի զանգված\n * @param {number} length - Դույլերի քանակը:\n * @param {number[]} squares - Թվերի զանգված, որտեղ յուրաքանչյուր թիվ ներկայացնում է քառակուսիների քանակը դույլում:\n * @returns {boolean} - Վերադարձնում է true, եթե հնարավոր է կազմել կատարյալ քառակուսի, հակառակ դեպքում վերադարձնում է false:\n *\n * Օրինակներ:\n * f_21(1, [9]) // true\n */\nfunction f_21(length, squares)", "bn": "/**\n * এটি নির্ধারণ করে যে n বালতি থেকে কাঠের বর্গক্ষেত্রগুলি একত্রিত করা সম্ভব কিনা,\n * যেখানে প্রতিটি বালতিতে a_i সংখ্যক 1 পার্শ্ব দৈর্ঘ্যের বর্গক্ষেত্র রয়েছে, একটি বড় বর্গক্ষেত্রে।\n * ইনপুট: তালিকার দৈর্ঘ্য, সংখ্যার অ্যারে\n * @param {number} length - বালতির সংখ্যা।\n * @param {number[]} squares - সংখ্যার একটি অ্যারে, যেখানে প্রতিটি সংখ্যা একটি বালতিতে বর্গক্ষেত্রের সংখ্যা উপস্থাপন করে।\n * @returns {boolean} - এটি একটি নিখুঁত বর্গক্ষেত্র গঠন করা সম্ভব হলে true রিটার্ন করে, অন্যথায় false রিটার্ন করে।\n *\n * উদাহরণ:\n * f_21(1, [9]) // true\n */\nfunction f_21(length, squares)", "bg": "/**\n * Определя дали е възможно да се сглобят дървените квадрати от n кофи,\n * където всяка кофа съдържа a_i квадрати със страна с дължина 1, в един по-голям квадрат.\n * Вход: дължина на списъка, масив от числа\n * @param {number} length - Броят на кофите.\n * @param {number[]} squares - Масив от числа, където всяко число представлява броя на квадратите в една кофа.\n * @returns {boolean} - Връща true, ако е възможно да се образува перфектен квадрат, в противен случай връща false.\n *\n * Примери:\n * f_21(1, [9]) // true\n */\nfunction f_21(length, squares)", "zh": "/**\n * 确定是否可以从 n 个桶中组装木方块，\n * 其中每个桶包含 a_i 个边长为 1 的方块，组装成一个更大的正方形。\n * 输入：列表的长度，数字数组\n * @param {number} length - 桶的数量。\n * @param {number[]} squares - 数字数组，其中每个数字表示一个桶中的方块数量。\n * @returns {boolean} - 如果可以形成一个完美的正方形，则返回 true，否则返回 false。\n *\n * 示例:\n * f_21(1, [9]) // true\n */\nfunction f_21(length, squares)", "fr": "/**\n * Détermine s'il est possible d'assembler les carrés en bois à partir de n seaux,\n * où chaque seau contient a_i carrés avec une longueur de côté de 1, en un seul carré plus grand.\n * Entrée : longueur de la liste, tableau de nombres\n * @param {number} length - Le nombre de seaux.\n * @param {number[]} squares - Un tableau de nombres, où chaque nombre représente le nombre de carrés dans un seau.\n * @returns {boolean} - Renvoie true s'il est possible de former un carré parfait, sinon renvoie false.\n *\n * Exemples :\n * f_21(1, [9]) // true\n */\nfunction f_21(length, squares)", "de": "/**\n * Bestimmt, ob es möglich ist, die Holzquadrate aus n Eimern,\n * wobei jeder Eimer a_i Quadrate mit einer Seitenlänge von 1 enthält, zu einem einzigen größeren Quadrat zusammenzusetzen.\n * Eingabe: Länge der Liste, Array von Zahlen\n * @param {number} length - Die Anzahl der Eimer.\n * @param {number[]} squares - Ein Array von Zahlen, wobei jede Zahl die Anzahl der Quadrate in einem Eimer darstellt.\n * @returns {boolean} - Gibt true zurück, wenn es möglich ist, ein perfektes Quadrat zu bilden, andernfalls false.\n *\n * Beispiele:\n * f_21(1, [9]) // true\n */\nfunction f_21(length, squares)", "ha": "/**\n * Yana tantance ko yana yiwuwa a tara murabba'ai na katako daga guga n,\n * inda kowace guga tana dauke da a_i murabba'ai tare da tsawon gefe 1, zuwa murabba'i mafi girma guda daya.\n * Shigarwa: tsawon jerin, jerin lambobi\n * @param {number} length - Yawan guga.\n * @param {number[]} squares - Jerin lambobi, inda kowace lamba ke wakiltar adadin murabba'ai a cikin guga.\n * @returns {boolean} - Yana dawowa gaskiya idan yana yiwuwa a samar da cikakken murabba'i, in ba haka ba yana dawowa karya.\n *\n * Misalai:\n * f_21(1, [9]) // true\n */", "hi": "/**\n * यह निर्धारित करता है कि क्या n बाल्टियों से लकड़ी के वर्गों को इकट्ठा करना संभव है,\n * जहाँ प्रत्येक बाल्टी में a_i वर्ग होते हैं जिनकी भुजा की लंबाई 1 होती है, एक बड़े वर्ग में।\n * इनपुट: सूची की लंबाई, संख्याओं की श्रृंखला\n * @param {number} length - बाल्टियों की संख्या।\n * @param {number[]} squares - संख्याओं की एक श्रृंखला, जहाँ प्रत्येक संख्या एक बाल्टी में वर्गों की गिनती का प्रतिनिधित्व करती है।\n * @returns {boolean} - यदि एक पूर्ण वर्ग बनाना संभव है तो true लौटाता है, अन्यथा false लौटाता है।\n *\n * उदाहरण:\n * f_21(1, [9]) // true\n */", "hu": "/**\n * Meghatározza, hogy lehetséges-e a fából készült négyzeteket n vödörből összeállítani,\n * ahol minden vödör a_i darab, 1 oldalhosszúságú négyzetet tartalmaz, egyetlen nagyobb négyzetté.\n * Bemenet: a lista hossza, számok tömbje\n * @param {number} length - A vödrök száma.\n * @param {number[]} squares - Egy számokat tartalmazó tömb, ahol minden szám egy vödörben lévő négyzetek számát jelenti.\n * @returns {boolean} - Igazat ad vissza, ha lehetséges egy tökéletes négyzetet alkotni, különben hamisat ad vissza.\n *\n * Példák:\n * f_21(1, [9]) // true\n */\nfunction f_21(length, squares)", "es": "/**\n * Determina si es posible ensamblar los cuadrados de madera de n cubetas,\n * donde cada cubeta contiene a_i cuadrados con un lado de longitud 1, en un solo cuadrado más grande.\n * Entrada: longitud de la lista, arreglo de números\n * @param {number} length - El número de cubetas.\n * @param {number[]} squares - Un arreglo de números, donde cada número representa la cantidad de cuadrados en una cubeta.\n * @returns {boolean} - Devuelve true si es posible formar un cuadrado perfecto, de lo contrario devuelve false.\n *\n * Ejemplos:\n * f_21(1, [9]) // true\n */\nfunction f_21(length, squares)", "arb": "/**\n * يحدد ما إذا كان من الممكن تجميع المربعات الخشبية من n دلاء،\n * حيث يحتوي كل دلو على a_i مربعات بطول جانب 1، في مربع أكبر واحد.\n * المدخلات: طول القائمة، مصفوفة من الأرقام\n * @param {number} length - عدد الدلاء.\n * @param {number[]} squares - مصفوفة من الأرقام، حيث يمثل كل رقم عدد المربعات في دلو.\n * @returns {boolean} - يعيد true إذا كان من الممكن تشكيل مربع مثالي، وإلا يعيد false.\n *\n * أمثلة:\n * f_21(1, [9]) // true\n */\nfunction f_21(length, squares)", "sw": "/**\n * Huamua kama inawezekana kuunganisha miraba ya mbao kutoka kwenye ndoo n,\n * ambapo kila ndoo ina a_i miraba yenye urefu wa upande wa 1, kuwa mraba mmoja mkubwa zaidi.\n * Ingizo: urefu wa orodha, safu ya nambari\n * @param {number} length - Idadi ya ndoo.\n * @param {number[]} squares - Safu ya nambari, ambapo kila nambari inawakilisha idadi ya miraba katika ndoo.\n * @returns {boolean} - Inarejesha kweli ikiwa inawezekana kuunda mraba kamili, vinginevyo inarejesha uongo.\n *\n * Mifano:\n * f_21(1, [9]) // true\n */\nfunction f_21(length, squares)", "tr": "/**\n * Her bir kovada a_i kenar uzunluğu 1 olan kareler bulunan n kovadan,\n * tek bir büyük kare oluşturmanın mümkün olup olmadığını belirler.\n * Girdi: listenin uzunluğu, sayıların dizisi\n * @param {number} length - Kova sayısı.\n * @param {number[]} squares - Her bir sayının bir kovadaki kare sayısını temsil ettiği bir sayı dizisi.\n * @returns {boolean} - Mükemmel bir kare oluşturmak mümkünse true, aksi takdirde false döner.\n *\n * Örnekler:\n * f_21(1, [9]) // true\n */\nfunction f_21(length, squares)", "vi": "/**\n * Xác định xem có thể lắp ráp các hình vuông gỗ từ n thùng,\n * trong đó mỗi thùng chứa a_i hình vuông với cạnh dài 1, thành một hình vuông lớn hơn duy nhất hay không.\n * Đầu vào: độ dài của danh sách, mảng số\n * @param {number} length - Số lượng thùng.\n * @param {number[]} squares - Một mảng số, trong đó mỗi số đại diện cho số lượng hình vuông trong một thùng.\n * @returns {boolean} - Trả về true nếu có thể tạo thành một hình vuông hoàn hảo, nếu không trả về false.\n *\n * Ví dụ:\n * f_21(1, [9]) // true\n */\nfunction f_21(length, squares)", "id": "/**\n * Menentukan apakah mungkin untuk menyusun kotak kayu dari n ember,\n * di mana setiap ember berisi a_i kotak dengan panjang sisi 1, menjadi satu kotak yang lebih besar.\n * Input: panjang daftar, array angka\n * @param {number} length - Jumlah ember.\n * @param {number[]} squares - Array angka, di mana setiap angka mewakili jumlah kotak dalam satu ember.\n * @returns {boolean} - Mengembalikan true jika memungkinkan untuk membentuk kotak sempurna, jika tidak mengembalikan false.\n *\n * Contoh:\n * f_21(1, [9]) // true\n */\nfunction f_21(length, squares)", "ja": "/**\n * n個のバケツから木製の正方形を組み立てることが可能かどうかを判断します。\n * 各バケツには1の辺の長さを持つa_i個の正方形が含まれています。それを1つの大きな正方形に組み立てることができるかどうか。\n * 入力: リストの長さ、数値の配列\n * @param {number} length - バケツの数。\n * @param {number[]} squares - 各数値がバケツ内の正方形の数を表す数値の配列。\n * @returns {boolean} - 完全な正方形を形成することが可能な場合はtrueを返し、そうでない場合はfalseを返します。\n *\n * 例:\n * f_21(1, [9]) // true\n */\nfunction f_21(length, squares)", "ko": "/**\n * n개의 버킷에서 각 버킷이 한 변의 길이가 1인 정사각형 a_i를 포함하고 있을 때,\n * 이를 하나의 더 큰 정사각형으로 조립할 수 있는지 여부를 결정합니다.\n * 입력: 리스트의 길이, 숫자 배열\n * @param {number} length - 버킷의 수.\n * @param {number[]} squares - 각 숫자가 버킷에 있는 정사각형의 수를 나타내는 숫자 배열.\n * @returns {boolean} - 완벽한 정사각형을 만들 수 있으면 true를 반환하고, 그렇지 않으면 false를 반환합니다.\n *\n * 예시:\n * f_21(1, [9]) // true\n */\nfunction f_21(length, squares)", "ml": "/**\n * n ബക്കറ്റുകളിൽ നിന്ന് മരം ചതുരങ്ങൾ ഒന്നിച്ച് ചേർക്കാൻ കഴിയുമോ എന്ന് നിർണയിക്കുന്നു,\n * ഓരോ ബക്കറ്റിലും 1 വശ നീളമുള്ള a_i ചതുരങ്ങൾ അടങ്ങിയിരിക്കുന്നു, ഒരു വലിയ ചതുരമായി.\n * ഇൻപുട്ട്: ലിസ്റ്റിന്റെ നീളം, സംഖ്യകളുടെ നിര\n * @param {number} length - ബക്കറ്റുകളുടെ എണ്ണം.\n * @param {number[]} squares - ഓരോ സംഖ്യയും ഒരു ബക്കറ്റിലെ ചതുരങ്ങളുടെ എണ്ണത്തെ പ്രതിനിധീകരിക്കുന്ന സംഖ്യകളുടെ ഒരു നിര.\n * @returns {boolean} - ഒരു പൂർണ്ണചതുരം രൂപപ്പെടുത്താൻ കഴിയുമെങ്കിൽ true മടങ്ങുന്നു, അല്ലെങ്കിൽ false മടങ്ങുന്നു.\n *\n * ഉദാഹരണങ്ങൾ:\n * f_21(1, [9]) // true\n */\nfunction f_21(length, squares)", "fa": "/**\n * تعیین می‌کند که آیا امکان مونتاژ مربع‌های چوبی از n سطل وجود دارد،\n * که در هر سطل a_i مربع با طول ضلع 1 وجود دارد، به یک مربع بزرگتر.\n * ورودی: طول لیست، آرایه‌ای از اعداد\n * @param {number} length - تعداد سطل‌ها.\n * @param {number[]} squares - آرایه‌ای از اعداد، که هر عدد نشان‌دهنده تعداد مربع‌ها در یک سطل است.\n * @returns {boolean} - اگر امکان تشکیل یک مربع کامل وجود داشته باشد، true برمی‌گرداند، در غیر این صورت false برمی‌گرداند.\n *\n * مثال‌ها:\n * f_21(1, [9]) // true\n */\nfunction f_21(length, squares)"}, "canonical_solution": "{\n    let sum = 0;\n    for (let i = 0; i < length; ++i) {\n        sum += squares[i]; // Summing the squares\n    }\n    let root = Math.sqrt(sum);\n    return Math.floor(root) === root; // Checking if sum is a perfect square\n}", "instruction": {"en": "Write a JavaScript function `function f_21(length, squares)` to solve the following problem:\nDetermines if it is possible to assemble the wooden squares from n buckets,\nwhere each bucket contains a_i squares with a side length of 1, into a single larger square.\nInput: length of the list, array of numbers\nParameters:\n- length (number): The number of buckets.\n- squares (number[]): An array of numbers, where each number represents the count of squares in a bucket.\nReturns:\n- boolean: Returns true if it's possible to form a perfect square, otherwise returns false.\n\nExamples:\nf_21(1, [9]) // true\n", "sq": "Shkruani një funksion JavaScript `function f_21(length, squares)` për të zgjidhur problemin e mëposhtëm:\nPërcakton nëse është e mundur të montohen katrorët prej druri nga n kovë,\nku secila kovë përmban a_i katrorë me një gjatësi anësore prej 1, në një katror më të madh.\nHyrja: gjatësia e listës, vargu i numrave\nParametrat:\n- length (numër): Numri i koveve.\n- squares (numër[]): Një varg numrash, ku secili numër përfaqëson numrin e katrorëve në një kovë.\nKthen:\n- boolean: Kthen true nëse është e mundur të formohet një katror perfekt, përndryshe kthen false.\n\nShembuj:\nf_21(1, [9]) // true", "hy": "Գրեք JavaScript ֆունկցիա `function f_21(length, squares)` հետևյալ խնդիրը լուծելու համար:\nՈրոշում է, արդյոք հնարավոր է հավաքել փայտե քառակուսիները n դույլերից,\nորտեղ յուրաքանչյուր դույլ պարունակում է a_i քառակուսի 1 կողմի երկարությամբ, մեկ մեծ քառակուսի մեջ:\nՄուտք: ցուցակի երկարություն, թվերի զանգված\nՊարամետրեր:\n- length (number): Դույլերի քանակը։\n- squares (number[]): Թվերի զանգված, որտեղ յուրաքանչյուր թիվ ներկայացնում է քառակուսիների քանակը դույլում։\nՎերադարձնում է:\n- boolean: Վերադարձնում է true, եթե հնարավոր է կազմել կատարյալ քառակուսի, հակառակ դեպքում վերադարձնում է false։\n\nՕրինակներ:\nf_21(1, [9]) // true", "bn": "একটি জাভাস্ক্রিপ্ট ফাংশন `function f_21(length, squares)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nনির্ধারণ করে যে এটি সম্ভব কিনা n বালতি থেকে কাঠের বর্গক্ষেত্রগুলি একত্রিত করা,\nযেখানে প্রতিটি বালতিতে a_i সংখ্যক 1 পার্শ্ব দৈর্ঘ্যের বর্গক্ষেত্র রয়েছে, একটি বড় বর্গক্ষেত্র তৈরি করতে।\nইনপুট: তালিকার দৈর্ঘ্য, সংখ্যার অ্যারে\nপ্যারামিটারসমূহ:\n- length (number): বালতির সংখ্যা।\n- squares (number[]): সংখ্যার একটি অ্যারে, যেখানে প্রতিটি সংখ্যা একটি বালতিতে থাকা বর্গক্ষেত্রের সংখ্যা নির্দেশ করে।\nরিটার্নস:\n- boolean: যদি একটি নিখুঁত বর্গক্ষেত্র তৈরি করা সম্ভব হয় তবে true রিটার্ন করে, অন্যথায় false রিটার্ন করে।\n\nউদাহরণসমূহ:\nf_21(1, [9]) // true", "bg": "Напишете JavaScript функция `function f_21(length, squares)`, за да решите следния проблем:\nОпределя дали е възможно да се сглобят дървените квадрати от n кофи,\nкъдето всяка кофа съдържа a_i квадрати със страна с дължина 1, в един по-голям квадрат.\nВход: дължина на списъка, масив от числа\nПараметри:\n- length (number): Броят на кофите.\n- squares (number[]): Масив от числа, където всяко число представлява броя на квадратите в една кофа.\nВръща:\n- boolean: Връща true, ако е възможно да се образува перфектен квадрат, в противен случай връща false.\n\nПримери:\nf_21(1, [9]) // true", "zh": "编写一个 JavaScript 函数 `function f_21(length, squares)` 来解决以下问题：\n确定是否可以从 n 个桶中组装木制正方形，其中每个桶包含 a_i 个边长为 1 的正方形，组成一个更大的正方形。\n输入：列表的长度，数字数组\n参数：\n- length (number): 桶的数量。\n- squares (number[]): 一个数字数组，其中每个数字表示一个桶中的正方形数量。\n返回：\n- boolean: 如果可以形成一个完美的正方形，则返回 true，否则返回 false。\n\n示例：\nf_21(1, [9]) // true", "fr": "Écrire une fonction JavaScript `function f_21(length, squares)` pour résoudre le problème suivant :  \nDétermine s'il est possible d'assembler les carrés en bois à partir de n seaux, où chaque seau contient a_i carrés avec une longueur de côté de 1, en un seul carré plus grand.  \nEntrée : longueur de la liste, tableau de nombres  \nParamètres :  \n- length (number): Le nombre de seaux.  \n- squares (number[]): Un tableau de nombres, où chaque nombre représente le nombre de carrés dans un seau.  \nRenvoie :  \n- boolean: Renvoie true s'il est possible de former un carré parfait, sinon renvoie false.  \n\nExemples :  \nf_21(1, [9]) // true  ", "de": "Schreiben Sie eine JavaScript-Funktion `function f_21(length, squares)`, um das folgende Problem zu lösen:\nBestimmt, ob es möglich ist, die Holzquadrate aus n Eimern zusammenzusetzen,\nwobei jeder Eimer a_i Quadrate mit einer Seitenlänge von 1 enthält, um ein einzelnes größeres Quadrat zu bilden.\nEingabe: Länge der Liste, Array von Zahlen\nParameter:\n- length (number): Die Anzahl der Eimer.\n- squares (number[]): Ein Array von Zahlen, wobei jede Zahl die Anzahl der Quadrate in einem Eimer darstellt.\nRückgabewert:\n- boolean: Gibt true zurück, wenn es möglich ist, ein perfektes Quadrat zu bilden, andernfalls false.\n\nBeispiele:\nf_21(1, [9]) // true", "ha": "Rubuta aikin JavaScript `function f_21(length, squares)` don warware matsalar mai zuwa:\nYana tantancewa idan zai yiwu a haɗa murabba'ai na katako daga n kwando,\ninda kowanne kwando ke dauke da a_i murabba'ai tare da tsayin gefe na 1, cikin babban murabba'i guda.\nShigarwa: tsayin jerin, jerin lambobi\nSigogi:\n- length (namba): Yawan kwandunan.\n- squares (namba[]): Jerin lambobi, inda kowanne lamba ke wakiltar adadin murabba'ai a cikin kwando.\nMayarwa:\n- boolean: Yana mayar da gaskiya idan zai yiwu a samar da cikakken murabba'i, in ba haka ba yana mayar da ƙarya.\n\nMisalai:\nf_21(1, [9]) // true", "hi": "एक जावास्क्रिप्ट फ़ंक्शन `function f_21(length, squares)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nनिर्धारित करता है कि क्या n बाल्टियों से लकड़ी के वर्गों को इकट्ठा करना संभव है,\nजहां प्रत्येक बाल्टी में a_i वर्ग होते हैं जिनकी भुजा की लंबाई 1 होती है, एक बड़े वर्ग में।\nइनपुट: सूची की लंबाई, संख्याओं की array\nपैरामीटर:\n- length (number): बाल्टियों की संख्या।\n- squares (number[]): संख्याओं की एक array, जहां प्रत्येक संख्या एक बाल्टी में वर्गों की गिनती का प्रतिनिधित्व करती है।\nवापसी:\n- boolean: अगर एक पूर्ण वर्ग बनाना संभव है तो true लौटाता है, अन्यथा false लौटाता है।\n\nउदाहरण:\nf_21(1, [9]) // true", "hu": "Írj egy JavaScript függvényt `function f_21(length, squares)`, hogy megoldja a következő problémát:\nMegállapítja, hogy lehetséges-e a fából készült négyzeteket n vödörből összeállítani,\nahol minden vödör a_i darab, 1 oldalhosszúságú négyzetet tartalmaz, egyetlen nagyobb négyzetté.\nBemenet: a lista hossza, számok tömbje\nParaméterek:\n- length (number): A vödrök száma.\n- squares (number[]): Egy számokat tartalmazó tömb, ahol minden szám egy vödörben lévő négyzetek számát jelenti.\nVisszatérési érték:\n- boolean: Igazat ad vissza, ha lehetséges egy tökéletes négyzetet formálni, különben hamisat.\n\nPéldák:\nf_21(1, [9]) // true", "es": "Escribe una función de JavaScript `function f_21(length, squares)` para resolver el siguiente problema:\nDetermina si es posible ensamblar los cuadrados de madera de n cubetas,\ndonde cada cubeta contiene a_i cuadrados con una longitud de lado de 1, en un solo cuadrado más grande.\nEntrada: longitud de la lista, array de números\nParámetros:\n- length (number): El número de cubetas.\n- squares (number[]): Un array de números, donde cada número representa la cantidad de cuadrados en una cubeta.\nDevuelve:\n- boolean: Devuelve true si es posible formar un cuadrado perfecto, de lo contrario devuelve false.\n\nEjemplos:\nf_21(1, [9]) // true", "arb": "اكتب دالة JavaScript `function f_21(length, squares)` لحل المشكلة التالية:\nتحديد ما إذا كان من الممكن تجميع المربعات الخشبية من n دلاء،\nحيث يحتوي كل دلو على a_i مربعات بطول ضلع 1، في مربع أكبر واحد.\nالمدخلات: طول القائمة، مصفوفة من الأرقام\nالمعلمات:\n- length (number): عدد الدلاء.\n- squares (number[]): مصفوفة من الأرقام، حيث يمثل كل رقم عدد المربعات في دلو.\nالإرجاع:\n- boolean: يعيد true إذا كان من الممكن تشكيل مربع كامل، وإلا يعيد false.\n\nأمثلة:\nf_21(1, [9]) // true", "sw": "Andika kazi ya JavaScript `function f_21(length, squares)` kutatua tatizo lifuatalo:\nInabainisha kama inawezekana kukusanya mraba wa mbao kutoka kwenye ndoo n,\nambapo kila ndoo ina a_i miraba yenye urefu wa upande wa 1, kuwa mraba mmoja mkubwa.\nIngizo: urefu wa orodha, safu ya namba\nVigezo:\n- length (nambari): Idadi ya ndoo.\n- squares (nambari[]): Safu ya namba, ambapo kila namba inawakilisha idadi ya miraba kwenye ndoo.\nInarudisha:\n- boolean: Inarudisha kweli ikiwa inawezekana kuunda mraba kamili, vinginevyo inarudisha uongo.\n\nMifano:\nf_21(1, [9]) // true", "tr": "Bir JavaScript fonksiyonu `function f_21(length, squares)` yazın ve aşağıdaki problemi çözün:\nHer bir kovada a_i kenar uzunluğu 1 olan kareler bulunan n kovadan ahşap kareleri tek bir büyük kareye monte etmenin mümkün olup olmadığını belirler.\nGirdi: listenin uzunluğu, sayıların dizisi\nParametreler:\n- length (number): Kova sayısı.\n- squares (number[]): Her bir sayının bir kovadaki kare sayısını temsil ettiği bir sayı dizisi.\nDöndürür:\n- boolean: Mükemmel bir kare oluşturmanın mümkün olup olmadığını belirler, mümkünse true, aksi takdirde false döndürür.\n\nÖrnekler:\nf_21(1, [9]) // true", "vi": "Viết một hàm JavaScript `function f_21(length, squares)` để giải quyết vấn đề sau:\nXác định xem có thể lắp ráp các hình vuông gỗ từ n thùng,\ntrong đó mỗi thùng chứa a_i hình vuông với chiều dài cạnh là 1, thành một hình vuông lớn hơn duy nhất hay không.\nĐầu vào: độ dài của danh sách, mảng số\nTham số:\n- length (number): Số lượng thùng.\n- squares (number[]): Một mảng số, trong đó mỗi số đại diện cho số lượng hình vuông trong một thùng.\nTrả về:\n- boolean: Trả về true nếu có thể tạo thành một hình vuông hoàn hảo, ngược lại trả về false.\n\nVí dụ:\nf_21(1, [9]) // true", "id": "Tulis sebuah fungsi JavaScript `function f_21(length, squares)` untuk menyelesaikan masalah berikut:\nMenentukan apakah mungkin untuk merakit kotak kayu dari n ember,\ndi mana setiap ember berisi a_i kotak dengan panjang sisi 1, menjadi satu kotak yang lebih besar.\nInput: panjang daftar, array angka\nParameter:\n- length (number): Jumlah ember.\n- squares (number[]): Sebuah array angka, di mana setiap angka mewakili jumlah kotak dalam sebuah ember.\nMengembalikan:\n- boolean: Mengembalikan true jika mungkin untuk membentuk kotak sempurna, jika tidak mengembalikan false.\n\nContoh:\nf_21(1, [9]) // true", "ja": "JavaScript関数 `function f_21(length, squares)` を作成して、次の問題を解決してください:\nn個のバケツから木製の正方形を組み立てることが可能かどうかを判断します。\n各バケツには1辺の長さが1の正方形がa_i個含まれており、それを1つの大きな正方形に組み立てることができるかどうかを判断します。\n入力: リストの長さ、数値の配列\nパラメータ:\n- length (number): バケツの数。\n- squares (number[]): 各数値がバケツ内の正方形の数を表す数値の配列。\n戻り値:\n- boolean: 完全な正方形を形成することが可能であればtrueを返し、そうでなければfalseを返します。\n\n例:\nf_21(1, [9]) // true", "ko": "JavaScript 함수를 작성하세요 `function f_21(length, squares)` 다음 문제를 해결하기 위해:\nn개의 버킷에서 나무 정사각형을 조립할 수 있는지 여부를 결정합니다,\n각 버킷에는 한 변의 길이가 1인 a_i 정사각형이 들어 있으며, 이를 하나의 더 큰 정사각형으로 조립할 수 있는지 확인합니다.\n입력: 리스트의 길이, 숫자의 배열\n매개변수:\n- length (number): 버킷의 수.\n- squares (number[]): 각 숫자가 버킷에 있는 정사각형의 수를 나타내는 숫자 배열.\n반환:\n- boolean: 완벽한 정사각형을 만들 수 있으면 true를 반환하고, 그렇지 않으면 false를 반환합니다.\n\n예시:\nf_21(1, [9]) // true", "ml": "`function f_21(length, squares)` എന്ന ജാവാസ്ക്രിപ്റ്റ് ഫംഗ്ഷൻ എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nn ബക്കറ്റുകളിൽ നിന്ന് മര ചതുരങ്ങൾ ചേർക്കാൻ സാധ്യമാണോ എന്ന് നിർണയിക്കുന്നു, \nഇവിടെയോ ഓരോ ബക്കറ്റും 1 നീളമുള്ള ഒരു വശമുള്ള a_i ചതുരങ്ങൾ അടങ്ങിയിരിക്കുന്നു, ഒരു വലിയ ചതുരത്തിൽ.\nഇൻപുട്ട്: ലിസ്റ്റിന്റെ നീളം, സംഖ്യകളുടെ അറേ\nപാരാമീറ്ററുകൾ:\n- length (number): ബക്കറ്റുകളുടെ എണ്ണം.\n- squares (number[]): ഓരോ സംഖ്യയും ഒരു ബക്കറ്റിലെ ചതുരങ്ങളുടെ എണ്ണത്തെ പ്രതിനിധീകരിക്കുന്ന സംഖ്യകളുടെ അറേ.\nറിട്ടേൺസ്:\n- boolean: ഒരു പൂർണ്ണ ചതുരം രൂപീകരിക്കാൻ സാധ്യമാണെങ്കിൽ true റിട്ടേൺ ചെയ്യുന്നു, അല്ലെങ്കിൽ false റിട്ടേൺ ചെയ്യുന്നു.\n\nഉദാഹരണങ്ങൾ:\nf_21(1, [9]) // true", "fa": "یک تابع جاوااسکریپت `function f_21(length, squares)` بنویسید تا مسئله زیر را حل کند:\nتعیین می‌کند که آیا امکان دارد مربع‌های چوبی را از n سطل، که هر سطل شامل a_i مربع با طول ضلع ۱ است، به یک مربع بزرگ‌تر تبدیل کرد.\nورودی: طول لیست، آرایه‌ای از اعداد\nپارامترها:\n- length (number): تعداد سطل‌ها.\n- squares (number[]): آرایه‌ای از اعداد، که هر عدد نشان‌دهنده تعداد مربع‌ها در یک سطل است.\nخروجی:\n- boolean: اگر امکان تشکیل یک مربع کامل وجود داشته باشد، true برمی‌گرداند، در غیر این صورت false برمی‌گرداند.\n\nمثال‌ها:\nf_21(1, [9]) // true"}, "level": "easy", "test": "const testf_21 = () => {\n    console.assert(f_21(1, [9]) === true);\n    console.assert(f_21(2, [14, 2]) === true);\n    console.assert(f_21(2, [7, 7]) === false);\n    console.assert(f_21(7, [1, 2, 3, 4, 5, 6, 7]) === false);\n    console.assert(f_21(6, [1, 3, 5, 7, 9, 11]) === true);\n    console.assert(f_21(4, [2, 2, 2, 2]) === false);\n\n    // Additional test cases\n    console.assert(f_21(3, [4, 5, 6]) === false);\n    console.assert(f_21(4, [16, 9, 4, 1]) === false);\n    console.assert(f_21(5, [1, 1, 1, 1, 1]) === false);\n    console.assert(f_21(2, [25, 25]) === false);\n    console.assert(f_21(3, [10, 10, 5]) === true);\n\n    // console.log(\"All tests passed!\");\n}\n\ntestf_21();", "entry_point": "f_21", "signature": "function f_21(length, squares)", "docstring": {"en": "Determines if it is possible to assemble the wooden squares from n buckets,\nwhere each bucket contains a_i squares with a side length of 1, into a single larger square.\nInput: length of the list, array of numbers\nParameters:\n- length (number): The number of buckets.\n- squares (number[]): An array of numbers, where each number represents the count of squares in a bucket.\nReturns:\n- boolean: Returns true if it's possible to form a perfect square, otherwise returns false.\n\nExamples:\nf_21(1, [9]) // true\n", "sq": "Përcakton nëse është e mundur të montohen katrorët prej druri nga n kovë,\nku secila kovë përmban a_i katrorë me një gjatësi anësore prej 1, në një katror më të madh.\nInput: gjatësia e listës, vargu i numrave\nParametrat:\n- length (numër): Numri i kovëve.\n- squares (numër[]): Një varg numrash, ku secili numër përfaqëson numrin e katrorëve në një kovë.\nKthen:\n- boolean: Kthen true nëse është e mundur të formohet një katror i përsosur, përndryshe kthen false.\n\nShembuj:\nf_21(1, [9]) // true", "hy": "Վճռում է՝ արդյոք հնարավոր է հավաքել փայտե քառակուսիները n դույլերից, որտեղ յուրաքանչյուր դույլ պարունակում է a_i կողքի երկարությամբ 1 քառակուսի, մեկ մեծ քառակուսի մեջ:\nՄուտք: ցուցակի երկարություն, թվերի զանգված\nՊարամետրեր:\n- length (թիվ): Դույլերի քանակը:\n- squares (թիվ[]): Թվերի զանգված, որտեղ յուրաքանչյուր թիվ ներկայացնում է դույլում գտնվող քառակուսիների քանակը:\nՎերադարձնում է:\n- boolean: Վերադարձնում է true, եթե հնարավոր է կազմել կատարյալ քառակուսի, հակառակ դեպքում վերադարձնում է false:\n\nՕրինակներ:\nf_21(1, [9]) // true", "bn": "নির্ধারণ করে যে এটি সম্ভব কিনা n বালতি থেকে কাঠের বর্গক্ষেত্রগুলি একত্রিত করা,\nযেখানে প্রতিটি বালতিতে a_i সংখ্যক 1 পার্শ্ব দৈর্ঘ্যের বর্গক্ষেত্র রয়েছে, একটি বড় বর্গক্ষেত্র তৈরি করতে। ইনপুট: তালিকার দৈর্ঘ্য, সংখ্যার অ্যারে Parameters: - length (number): বালতির সংখ্যা। - squares (number[]): সংখ্যার একটি অ্যারে, যেখানে প্রতিটি সংখ্যা একটি বালতিতে থাকা বর্গক্ষেত্রের সংখ্যা নির্দেশ করে। Returns: - boolean: যদি একটি নিখুঁত বর্গক্ষেত্র তৈরি করা সম্ভব হয় তবে সত্য ফেরত দেয়, অন্যথায় মিথ্যা ফেরত দেয়।\n\nউদাহরণ:\nf_21(1, [9]) // true", "bg": "Определя дали е възможно да се сглобят дървените квадрати от n кофи, където всяка кофа съдържа a_i квадрати със страна с дължина 1, в един по-голям квадрат.\nВход: дължина на списъка, масив от числа\nПараметри:\n- length (number): Броят на кофите.\n- squares (number[]): Масив от числа, където всяко число представлява броя на квадратите в кофа.\nВръща:\n- boolean: Връща true, ако е възможно да се образува перфектен квадрат, в противен случай връща false.\n\nПримери:\nf_21(1, [9]) // true", "zh": "确定是否可以从 n 个桶中组装木制正方形，其中每个桶包含 a_i 个边长为 1 的正方形，组装成一个更大的正方形。\n输入：列表的长度，数字数组\n参数：\n- length (number): 桶的数量。\n- squares (number[]): 一个数字数组，其中每个数字表示桶中正方形的数量。\n返回：\n- boolean: 如果可以形成一个完美的正方形，则返回 true，否则返回 false。\n\n示例：\nf_21(1, [9]) // true", "fr": "Détermine s'il est possible d'assembler les carrés en bois à partir de n seaux, où chaque seau contient a_i carrés de côté 1, en un seul grand carré.\nEntrée : longueur de la liste, tableau de nombres\nParamètres :\n- length (nombre) : Le nombre de seaux.\n- squares (nombre[]) : Un tableau de nombres, où chaque nombre représente le nombre de carrés dans un seau.\nRenvoie :\n- booléen : Renvoie vrai s'il est possible de former un carré parfait, sinon renvoie faux.\n\nExemples :\nf_21(1, [9]) // true", "de": "Bestimmt, ob es möglich ist, die Holzquadrate aus n Eimern zusammenzusetzen, wobei jeder Eimer a_i Quadrate mit einer Seitenlänge von 1 enthält, um ein einzelnes größeres Quadrat zu bilden.\nEingabe: Länge der Liste, Array von Zahlen\nParameter:\n- length (number): Die Anzahl der Eimer.\n- squares (number[]): Ein Array von Zahlen, wobei jede Zahl die Anzahl der Quadrate in einem Eimer darstellt.\nRückgabewert:\n- boolean: Gibt true zurück, wenn es möglich ist, ein perfektes Quadrat zu bilden, andernfalls false.\n\nBeispiele:\nf_21(1, [9]) // true", "ha": "Yana tantance ko zai yiwu a tara murabba'ai na katako daga kwandunan n, inda kowanne kwando ya ƙunshi murabba'ai a_i tare da tsawon gefe 1, zuwa murabba'i mafi girma.\nShigarwa: tsawon jerin, jerin lambobi\nSigogi:\n- length (namba): Yawan kwanduna.\n- squares (namba[]): Jerin lambobi, inda kowanne lamba ke wakiltar adadin murabba'ai a cikin kwando.\nMayarwa:\n- boolean: Yana mayar da gaskiya idan zai yiwu a samar da cikakken murabba'i, in ba haka ba yana mayar da ƙarya.\n\nMisalai:\nf_21(1, [9]) // true", "hi": "यह निर्धारित करता है कि क्या n बाल्टियों से लकड़ी के वर्गों को इकट्ठा करना संभव है, जहाँ प्रत्येक बाल्टी में a_i वर्ग होते हैं जिनकी भुजा की लंबाई 1 होती है, एक बड़े वर्ग में।\nइनपुट: सूची की लंबाई, संख्याओं की array\nपैरामीटर:\n- length (संख्या): बाल्टियों की संख्या।\n- squares (number[]): संख्याओं की एक array, जहाँ प्रत्येक संख्या एक बाल्टी में वर्गों की गिनती का प्रतिनिधित्व करती है।\nरिटर्न:\n- boolean: यदि एक पूर्ण वर्ग बनाना संभव है तो true लौटाता है, अन्यथा false लौटाता है।\n\nउदाहरण:\nf_21(1, [9]) // true", "hu": "Meghatározza, hogy lehetséges-e a fa négyzeteket n vödörből összeállítani, ahol minden vödör a_i darab, 1 oldalhosszúságú négyzetet tartalmaz, egyetlen nagyobb négyzetté.\nBemenet: a lista hossza, számok tömbje\nParaméterek:\n- length (szám): A vödrök száma.\n- squares (szám[]): Számok tömbje, ahol minden szám egy vödörben lévő négyzetek számát jelenti.\nVisszatérési érték:\n- boolean: Igazat ad vissza, ha lehetséges tökéletes négyzetet formálni, különben hamisat ad vissza.\n\nPéldák:\nf_21(1, [9]) // true", "es": "Determina si es posible ensamblar los cuadrados de madera de n cubetas, donde cada cubeta contiene a_i cuadrados con un lado de longitud 1, en un cuadrado más grande.  \nEntrada: longitud de la lista, array de números  \nParámetros:  \n- length (número): El número de cubetas.  \n- squares (número[]): Un array de números, donde cada número representa la cantidad de cuadrados en una cubeta.  \nDevuelve:  \n- booleano: Devuelve verdadero si es posible formar un cuadrado perfecto, de lo contrario devuelve falso.  \n\nEjemplos:  \nf_21(1, [9]) // true  ", "arb": "يحدد ما إذا كان من الممكن تجميع المربعات الخشبية من n دلوًا، حيث يحتوي كل دلو على a_i من المربعات ذات طول ضلع 1، في مربع أكبر واحد.\n\nالمدخلات: طول القائمة، مصفوفة الأرقام\n\nالمعلمات:\n- length (رقم): عدد الدلاء.\n- squares (number[]): مصفوفة من الأرقام، حيث يمثل كل رقم عدد المربعات في دلو.\n\nالمخرجات:\n- boolean: يعيد true إذا كان من الممكن تشكيل مربع مثالي، وإلا يعيد false.\n\nأمثلة:\nf_21(1, [9]) // true", "sw": "Inabainisha ikiwa inawezekana kuunganisha mraba wa mbao kutoka kwenye n ndoo, ambapo kila ndoo ina a_i miraba yenye urefu wa upande wa 1, kuwa mraba mmoja mkubwa zaidi.  \nIngizo: urefu wa orodha, safu ya namba  \nVigezo:  \n- length (nambari): Idadi ya ndoo.  \n- squares (nambari[]): Safu ya namba, ambapo kila namba inawakilisha idadi ya miraba katika ndoo.  \nInarejesha:  \n- boolean: Inarejesha kweli ikiwa inawezekana kuunda mraba kamili, vinginevyo inarejesha uongo.  \n\nMifano:  \nf_21(1, [9]) // true", "tr": "n kovadan, her bir kova a_i kenar uzunluğu 1 olan kareler içeriyorsa, ahşap kareleri tek bir büyük kareye monte etmenin mümkün olup olmadığını belirler.\nGirdi: listenin uzunluğu, sayıların dizisi\nParametreler:\n- length (number): Kova sayısı.\n- squares (number[]): Her bir sayının bir kovadaki kare sayısını temsil ettiği bir sayı dizisi.\nDöndürür:\n- boolean: Mükemmel bir kare oluşturmak mümkünse true, aksi takdirde false döner.\n\nÖrnekler:\nf_21(1, [9]) // true", "vi": "Xác định xem có thể lắp ráp các hình vuông gỗ từ n xô, trong đó mỗi xô chứa a_i hình vuông có cạnh dài 1, thành một hình vuông lớn hơn hay không.  \nĐầu vào: độ dài của danh sách, mảng số  \nTham số:  \n- length (number): Số lượng xô.  \n- squares (number[]): Một mảng số, trong đó mỗi số đại diện cho số lượng hình vuông trong một xô.  \nTrả về:  \n- boolean: Trả về true nếu có thể tạo thành một hình vuông hoàn hảo, ngược lại trả về false.  \n\nVí dụ:  \nf_21(1, [9]) // true  ", "id": "Menentukan apakah mungkin untuk merakit kotak kayu dari n ember, di mana setiap ember berisi a_i kotak dengan panjang sisi 1, menjadi satu kotak yang lebih besar.  \nInput: panjang daftar, array angka  \nParameter:  \n- length (number): Jumlah ember.  \n- squares (number[]): Sebuah array angka, di mana setiap angka mewakili jumlah kotak dalam sebuah ember.  \nMengembalikan:  \n- boolean: Mengembalikan true jika mungkin untuk membentuk kotak sempurna, jika tidak mengembalikan false.  \n\nContoh:  \nf_21(1, [9]) // true  ", "ja": "n個のバケツから木製の正方形を組み立てることが可能かどうかを判断します。各バケツには辺の長さが1の正方形がa_i個含まれており、それを1つの大きな正方形に組み立てることができるかどうかを確認します。\n入力: リストの長さ、数値の配列\nパラメータ:\n- length (number): バケツの数。\n- squares (number[]): 各数値がバケツ内の正方形の数を表す数値の配列。\n戻り値:\n- boolean: 完全な正方形を形成することが可能な場合はtrueを返し、そうでない場合はfalseを返します。\n\n例:\nf_21(1, [9]) // true", "ko": "n개의 양동이에서 각 양동이에 한 변의 길이가 1인 정사각형 a_i가 들어 있는 경우, 이 정사각형들을 하나의 더 큰 정사각형으로 조립할 수 있는지 여부를 결정합니다.\n입력: 리스트의 길이, 숫자 배열\n매개변수:\n- length (number): 양동이의 수.\n- squares (number[]): 각 숫자가 양동이에 있는 정사각형의 수를 나타내는 숫자 배열.\n반환:\n- boolean: 완벽한 정사각형을 만들 수 있으면 true를 반환하고, 그렇지 않으면 false를 반환합니다.\n\n예시:\nf_21(1, [9]) // true", "ml": "n ബക്കറ്റുകളിൽ നിന്ന് മരം ചതുരങ്ങൾ ഒന്നിച്ച് ചേർക്കാൻ കഴിയുമോ എന്ന് നിർണയിക്കുന്നു,\n * ഓരോ ബക്കറ്റിലും 1 വശ നീളമുള്ള a_i ചതുരങ്ങൾ അടങ്ങിയിരിക്കുന്നു, ഒരു വലിയ ചതുരമായി..  \nനിർണ്ണയിക്കുന്നത് n ബക്കറ്റുകളിൽ നിന്ന് മര ചതുരങ്ങൾ ഒന്നിച്ച് ചേർത്ത്, ഓരോ ബക്കറ്റിലും 1 വശ നീളമുള്ള a_i ചതുരങ്ങൾ അടങ്ങിയിരിക്കുന്ന ഒരു വലിയ ചതുരം ഉണ്ടാക്കാൻ കഴിയുമോ എന്നത്.\n\nInput: length of the list, array of numbers  \nഇൻപുട്ട്: പട്ടികയുടെ നീളം, സംഖ്യകളുടെ നിര\n\nParameters:  \nപാരാമീറ്ററുകൾ:\n\n- length (number): The number of buckets.  \n  - length (number): ബക്കറ്റുകളുടെ എണ്ണം.\n\n- squares (number[]): An array of numbers, where each number represents the count of squares in a bucket.  \n  - squares (number[]): ഓരോ സംഖ്യയും ഒരു ബക്കറ്റിലെ ചതുരങ്ങളുടെ എണ്ണം പ്രതിനിധീകരിക്കുന്ന സംഖ്യകളുടെ നിര.\n\nReturns:  \nമടക്കുക:\n\n- boolean: Returns true if it's possible to form a perfect square, otherwise returns false.  \n  - boolean: ഒരു പൂർണ്ണചതുരം രൂപീകരിക്കാൻ കഴിയുന്നുവെങ്കിൽ true മടക്കുന്നു, അല്ലെങ്കിൽ false മടക്കുന്നു.\n\nExamples:  \nഉദാഹരണങ്ങൾ:\n\nf_21(1, [9]) // true", "fa": "تشخیص می‌دهد که آیا امکان ساخت مربع‌های چوبی از n سطل وجود دارد یا خیر،\nکه در هر سطل a_i مربع با طول ضلع 1 وجود دارد، به یک مربع بزرگتر.\nورودی: طول لیست، آرایه‌ای از اعداد\nپارامترها:\n- length (number): تعداد سطل‌ها.\n- squares (number[]): آرایه‌ای از اعداد که هر عدد نشان‌دهنده تعداد مربع‌ها در یک سطل است.\nبازگشت:\n- boolean: اگر امکان تشکیل یک مربع کامل وجود داشته باشد، true برمی‌گرداند، در غیر این صورت false برمی‌گرداند.\n\nمثال‌ها:\nf_21(1, [9]) // true"}}
{"task_id": "JavaScript/22", "prompt": {"en": "/**\n * Given integers c and d, where a + b = c and a * b = d, find and return the\n * possible value of a (a <= b). If there are multiple groups, output the group\n * with the smallest a.\n * \n * Parameters:\n *   - c (int): The sum of a and b.\n *   - d (int): The product of a and b.\n * \n * Returns:\n *   A possible value of a or -1 if valid values do not exist.\n * \n * Examples:\n *   f_22(7, 11) // returns -1\n *   f_22(5, 6)  // returns 2\n */\nfunction f_22(c, d)", "sq": "/**\n * Duke pasur parasysh numrat e plotë c dhe d, ku a + b = c dhe a * b = d, gjeni dhe ktheni\n * vlerën e mundshme të a (a <= b). Nëse ka grupe të shumta, jepni grupin\n * me a më të vogël.\n * \n * Parametrat:\n *   - c (int): Shuma e a dhe b.\n *   - d (int): Produkti i a dhe b.\n * \n * Kthen:\n *   Një vlerë të mundshme të a ose -1 nëse vlerat e vlefshme nuk ekzistojnë.\n * \n * Shembuj:\n *   f_22(7, 11) // kthen -1\n *   f_22(5, 6)  // kthen 2\n */", "hy": "/**\n * Տրված են ամբողջ թվեր c և d, որտեղ a + b = c և a * b = d, գտնել և վերադարձնել\n * a-ի հնարավոր արժեքը (a <= b): Եթե կան բազմաթիվ խմբեր, վերադարձնել խումբը\n * ամենափոքր a-ով:\n * \n * Պարամետրեր:\n *   - c (int): a-ի և b-ի գումարը:\n *   - d (int): a-ի և b-ի արտադրյալը:\n * \n * Վերադարձնում է:\n *   a-ի հնարավոր արժեքը կամ -1, եթե վավեր արժեքներ չկան:\n * \n * Օրինակներ:\n *   f_22(7, 11) // վերադարձնում է -1\n *   f_22(5, 6)  // վերադարձնում է 2\n */\nfunction f_22(c, d)", "bn": "/**\n * প্রদত্ত পূর্ণসংখ্যা c এবং d, যেখানে a + b = c এবং a * b = d, a এর সম্ভাব্য মান খুঁজে বের করুন এবং ফেরত দিন (a <= b)। \n * যদি একাধিক গোষ্ঠী থাকে, তবে সবচেয়ে ছোট a সহ গোষ্ঠীটি আউটপুট করুন।\n * \n * প্যারামিটারসমূহ:\n *   - c (int): a এবং b এর যোগফল।\n *   - d (int): a এবং b এর গুণফল।\n * \n * রিটার্নস:\n *   a এর একটি সম্ভাব্য মান বা -1 যদি বৈধ মান বিদ্যমান না থাকে।\n * \n * উদাহরণসমূহ:\n *   f_22(7, 11) // -1 ফেরত দেয়\n *   f_22(5, 6)  // 2 ফেরত দেয়\n */\nfunction f_22(c, d)", "bg": "/**\n * Дадени са цели числа c и d, където a + b = c и a * b = d, намерете и върнете\n * възможната стойност на a (a <= b). Ако има множество групи, изведете групата\n * с най-малката стойност на a.\n * \n * Параметри:\n *   - c (int): Сумата на a и b.\n *   - d (int): Произведението на a и b.\n * \n * Връща:\n *   Възможна стойност на a или -1, ако не съществуват валидни стойности.\n * \n * Примери:\n *   f_22(7, 11) // връща -1\n *   f_22(5, 6)  // връща 2\n */\nfunction f_22(c, d)", "zh": "/**\n * 给定整数 c 和 d，其中 a + b = c 且 a * b = d，找到并返回 a 的可能值 (a <= b)。如果有多个组合，输出 a 最小的组合。\n * \n * 参数:\n *   - c (int): a 和 b 的和。\n *   - d (int): a 和 b 的积。\n * \n * 返回:\n *   a 的一个可能值，或者如果不存在有效值则返回 -1。\n * \n * 示例:\n *   f_22(7, 11) // 返回 -1\n *   f_22(5, 6)  // 返回 2\n */", "fr": "/**\n * Étant donné les entiers c et d, où a + b = c et a * b = d, trouver et retourner la\n * valeur possible de a (a <= b). S'il y a plusieurs groupes, sortir le groupe\n * avec le plus petit a.\n * \n * Paramètres:\n *   - c (int) : La somme de a et b.\n *   - d (int) : Le produit de a et b.\n * \n * Renvoie:\n *   Une valeur possible de a ou -1 si des valeurs valides n'existent pas.\n * \n * Exemples:\n *   f_22(7, 11) // returns -1\n *   f_22(5, 6)  // returns 2\n */\nfunction f_22(c, d)", "de": "/**\n * Gegeben sind die Ganzzahlen c und d, wobei a + b = c und a * b = d. Finde und gib den\n * möglichen Wert von a zurück (a <= b). Wenn es mehrere Gruppen gibt, gib die Gruppe\n * mit dem kleinsten a aus.\n * \n * Parameter:\n *   - c (int): Die Summe von a und b.\n *   - d (int): Das Produkt von a und b.\n * \n * Rückgabewert:\n *   Ein möglicher Wert von a oder -1, wenn keine gültigen Werte existieren.\n * \n * Beispiele:\n *   f_22(7, 11) // gibt -1 zurück\n *   f_22(5, 6)  // gibt 2 zurück\n */\nfunction f_22(c, d)", "ha": "/**\n * An ba da lambobin c da d, inda a + b = c kuma a * b = d, nemo kuma dawo da\n * yuwuwar ƙimar a (a <= b). Idan akwai kungiyoyi da yawa, fitar da ƙungiyar\n * tare da mafi ƙarancin a.\n * \n * Sigogi:\n *   - c (int): Jimillar a da b.\n *   - d (int): Samfurin a da b.\n * \n * Dawowa:\n *   Yuwuwar ƙimar a ko -1 idan ba a sami ƙimar da ta dace ba.\n * \n * Misalai:\n *   f_22(7, 11) // returns -1\n *   f_22(5, 6)  // returns 2\n */\nfunction f_22(c, d)", "hi": "/**\n * दिए गए पूर्णांक c और d, जहाँ a + b = c और a * b = d, a का संभावित मान खोजें और लौटाएं (a <= b)। \n * यदि कई समूह हैं, तो सबसे छोटे a वाले समूह को आउटपुट करें।\n * \n * पैरामीटर्स:\n *   - c (int): a और b का योग।\n *   - d (int): a और b का गुणनफल।\n * \n * रिटर्न करता है:\n *   a का एक संभावित मान या -1 यदि मान्य मान मौजूद नहीं हैं।\n * \n * उदाहरण:\n *   f_22(7, 11) // -1 लौटाता है\n *   f_22(5, 6)  // 2 लौटाता है\n */\nfunction f_22(c, d)", "hu": "/**\n * Adott két egész szám, c és d, ahol a + b = c és a * b = d, találja meg és adja vissza\n * a lehetséges a értéket (a <= b). Ha több csoport is van, adja vissza azt a csoportot,\n * amelyikben a legkisebb az a.\n * \n * Paraméterek:\n *   - c (int): Az a és b összege.\n *   - d (int): Az a és b szorzata.\n * \n * Visszatérési érték:\n *   Egy lehetséges a érték vagy -1, ha nem léteznek érvényes értékek.\n * \n * Példák:\n *   f_22(7, 11) // visszaadja -1\n *   f_22(5, 6)  // visszaadja 2\n */\nfunction f_22(c, d)", "es": "/**\n * Dados los enteros c y d, donde a + b = c y a * b = d, encuentra y devuelve el\n * valor posible de a (a <= b). Si hay múltiples grupos, devuelve el grupo\n * con el menor a.\n * \n * Parámetros:\n *   - c (int): La suma de a y b.\n *   - d (int): El producto de a y b.\n * \n * Devuelve:\n *   Un valor posible de a o -1 si no existen valores válidos.\n * \n * Ejemplos:\n *   f_22(7, 11) // devuelve -1\n *   f_22(5, 6)  // devuelve 2\n */\nfunction f_22(c, d)", "arb": "/**\n * بالنظر إلى الأعداد الصحيحة c و d، حيث a + b = c و a * b = d، ابحث وأعد\n * القيمة الممكنة لـ a (a <= b). إذا كانت هناك مجموعات متعددة، قم بإخراج المجموعة\n * ذات القيمة الأصغر لـ a.\n * \n * المعطيات:\n *   - c (int): مجموع a و b.\n *   - d (int): حاصل ضرب a و b.\n * \n * يعيد:\n *   قيمة ممكنة لـ a أو -1 إذا لم تكن هناك قيم صالحة.\n * \n * أمثلة:\n *   f_22(7, 11) // يعيد -1\n *   f_22(5, 6)  // يعيد 2\n */\nfunction f_22(c, d)", "sw": "/**\n * Ukipewa nambari nzima c na d, ambapo a + b = c na a * b = d, tafuta na urejeshe\n * thamani inayowezekana ya a (a <= b). Ikiwa kuna makundi mengi, toa kundi\n * lenye a ndogo zaidi.\n * \n * Vigezo:\n *   - c (int): Jumla ya a na b.\n *   - d (int): Bidhaa ya a na b.\n * \n * Inarejesha:\n *   Thamani inayowezekana ya a au -1 ikiwa thamani halali hazipo.\n * \n * Mifano:\n *   f_22(7, 11) // inarejesha -1\n *   f_22(5, 6)  // inarejesha 2\n */\nfunction f_22(c, d)", "tr": "/**\n * a ve b'nin toplamı c ve a * b = d olan c ve d tamsayıları verildiğinde,\n * a'nın (a <= b) olası değerini bulun ve döndürün. Birden fazla grup varsa,\n * en küçük a'ya sahip olan grubu çıktıya verin.\n * \n * Parametreler:\n *   - c (int): a ve b'nin toplamı.\n *   - d (int): a ve b'nin çarpımı.\n * \n * Döndürür:\n *   a'nın olası bir değeri veya geçerli değerler yoksa -1.\n * \n * Örnekler:\n *   f_22(7, 11) // -1 döndürür\n *   f_22(5, 6)  // 2 döndürür\n */\nfunction f_22(c, d)", "vi": "/**\n * Cho các số nguyên c và d, trong đó a + b = c và a * b = d, tìm và trả về\n * giá trị có thể của a (a <= b). Nếu có nhiều nhóm, xuất nhóm\n * với a nhỏ nhất.\n * \n * Tham số:\n *   - c (int): Tổng của a và b.\n *   - d (int): Tích của a và b.\n * \n * Trả về:\n *   Một giá trị có thể của a hoặc -1 nếu không tồn tại giá trị hợp lệ.\n * \n * Ví dụ:\n *   f_22(7, 11) // trả về -1\n *   f_22(5, 6)  // trả về 2\n */\nfunction f_22(c, d)", "id": "/**\n * Diberikan bilangan bulat c dan d, di mana a + b = c dan a * b = d, temukan dan kembalikan\n * nilai yang mungkin dari a (a <= b). Jika ada beberapa kelompok, keluarkan kelompok\n * dengan a terkecil.\n * \n * Parameter:\n *   - c (int): Jumlah dari a dan b.\n *   - d (int): Hasil kali dari a dan b.\n * \n * Mengembalikan:\n *   Nilai yang mungkin dari a atau -1 jika nilai yang valid tidak ada.\n * \n * Contoh:\n *   f_22(7, 11) // mengembalikan -1\n *   f_22(5, 6)  // mengembalikan 2\n */\nfunction f_22(c, d)", "ja": "/**\n * 整数cとdが与えられたとき、a + b = cおよびa * b = dとなるaの可能な値を見つけて返します (a <= b)。\n * 複数の組がある場合は、aが最小の組を出力します。\n * \n * パラメータ:\n *   - c (int): aとbの合計。\n *   - d (int): aとbの積。\n * \n * 戻り値:\n *   aの可能な値、または有効な値が存在しない場合は-1。\n * \n * 例:\n *   f_22(7, 11) // -1を返します\n *   f_22(5, 6)  // 2を返します\n */\nfunction f_22(c, d)", "ko": "/**\n * 정수 c와 d가 주어졌을 때, a + b = c이고 a * b = d인 a의 가능한 값을 찾아 반환합니다 (a <= b). \n * 여러 그룹이 있는 경우, a가 가장 작은 그룹을 출력합니다.\n * \n * 매개변수:\n *   - c (int): a와 b의 합.\n *   - d (int): a와 b의 곱.\n * \n * 반환:\n *   a의 가능한 값 또는 유효한 값이 존재하지 않으면 -1.\n * \n * 예시:\n *   f_22(7, 11) // returns -1\n *   f_22(5, 6)  // returns 2\n */\nfunction f_22(c, d)", "ml": "/**\n * നൽകിയിരിക്കുന്ന പൂർണ്ണസംഖ്യകൾ c, d എന്നിവയിൽ, a + b = c കൂടാതെ a * b = d ആയിടത്ത്, a എന്ന\n * (a <= b) സാധ്യതയുള്ള മൂല്യം കണ്ടെത്തി മടക്കുക. നിരവധി ഗ്രൂപ്പുകൾ ഉണ്ടെങ്കിൽ, ഏറ്റവും ചെറിയ\n * a ഉള്ള ഗ്രൂപ്പ് ഔട്ട്‌പുട്ട് ചെയ്യുക.\n * \n * പാരാമീറ്ററുകൾ:\n *   - c (int): a, b എന്നിവയുടെ തുക.\n *   - d (int): a, b എന്നിവയുടെ ഗുണഫലം.\n * \n * മടക്കുന്നു:\n *   a എന്ന ഒരു സാധ്യതയുള്ള മൂല്യം അല്ലെങ്കിൽ സാധുവായ മൂല്യങ്ങൾ ഇല്ലെങ്കിൽ -1.\n * \n * ഉദാഹരണങ്ങൾ:\n *   f_22(7, 11) // -1 മടക്കുന്നു\n *   f_22(5, 6)  // 2 മടക്കുന്നു\n */\nfunction f_22(c, d)", "fa": "/**\n * با توجه به اعداد صحیح c و d، که در آن a + b = c و a * b = d، مقدار ممکن a (a <= b) را پیدا کرده و برگردانید. اگر گروه‌های متعددی وجود دارد، گروهی با کوچکترین a را خروجی دهید.\n * \n * پارامترها:\n *   - c (int): مجموع a و b.\n *   - d (int): حاصل‌ضرب a و b.\n * \n * برمی‌گرداند:\n *   یک مقدار ممکن از a یا -1 اگر مقادیر معتبر وجود نداشته باشند.\n * \n * مثال‌ها:\n *   f_22(7, 11) // برمی‌گرداند -1\n *   f_22(5, 6)  // برمی‌گرداند 2\n */\nfunction f_22(c, d)"}, "canonical_solution": "{\n    for (let i = 0; i <= c / 2; i++) {\n        if (i * (c - i) !== d) continue;\n        return i;\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}", "instruction": {"en": "Write a JavaScript function `function f_22(c, d)` to solve the following problem:\nGiven integers c and d, where a + b = c and a * b = d, find and return the possible value of a (a <= b). If there are multiple groups, output the group with the smallest a.\n\nParameters:\n  - c (int): The sum of a and b.\n  - d (int): The product of a and b.\n\nReturns:\n  A possible value of a or -1 if valid values do not exist.\n\nExamples:\n  f_22(7, 11) // returns -1\n  f_22(5, 6)  // returns 2\n", "sq": "Shkruani një funksion JavaScript `function f_22(c, d)` për të zgjidhur problemin e mëposhtëm:  \nDuke pasur parasysh numrat e plotë c dhe d, ku a + b = c dhe a * b = d, gjeni dhe ktheni vlerën e mundshme të a (a <= b). Nëse ka grupe të shumta, jepni grupin me vlerën më të vogël të a.\n\nParametrat:\n  - c (int): Shuma e a dhe b.\n  - d (int): Produkti i a dhe b.\n\nKthen:\n  Një vlerë të mundshme të a ose -1 nëse vlerat e vlefshme nuk ekzistojnë.\n\nShembuj:\n  f_22(7, 11) // kthen -1\n  f_22(5, 6)  // kthen 2", "hy": "Գրեք JavaScript ֆունկցիա `function f_22(c, d)` հետևյալ խնդիրը լուծելու համար:\nՏրված են ամբողջ թվեր c և d, որտեղ a + b = c և a * b = d, գտնել և վերադարձնել a-ի հնարավոր արժեքը (a <= b): Եթե կան բազմաթիվ խմբեր, վերադարձնել այն խումբը, որտեղ a-ն ամենափոքրն է:\n\nՊարամետրեր:\n  - c (int): a և b-ի գումարը:\n  - d (int): a և b-ի արտադրյալը:\n\nՎերադարձնում է:\n  a-ի հնարավոր արժեք կամ -1, եթե վավեր արժեքներ չկան:\n\nՕրինակներ:\n  f_22(7, 11) // վերադարձնում է -1\n  f_22(5, 6)  // վերադարձնում է 2", "bn": "একটি জাভাস্ক্রিপ্ট ফাংশন `function f_22(c, d)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nপ্রদত্ত পূর্ণসংখ্যা c এবং d, যেখানে a + b = c এবং a * b = d, a এর সম্ভাব্য মান খুঁজে বের করুন এবং ফেরত দিন (a <= b)। যদি একাধিক গ্রুপ থাকে, তাহলে সবচেয়ে ছোট a সহ গ্রুপটি আউটপুট করুন।\n\nপ্যারামিটারসমূহ:\n  - c (int): a এবং b এর যোগফল।\n  - d (int): a এবং b এর গুণফল।\n\nফেরত দেয়:\n  a এর একটি সম্ভাব্য মান বা -1 যদি বৈধ মান বিদ্যমান না থাকে।\n\nউদাহরণ:\n  f_22(7, 11) // -1 ফেরত দেয়\n  f_22(5, 6)  // 2 ফেরত দেয়", "bg": "Напишете JavaScript функция `function f_22(c, d)` за решаване на следния проблем:  \nДадени са цели числа c и d, където a + b = c и a * b = d, намерете и върнете възможната стойност на a (a <= b). Ако има множество групи, изведете групата с най-малка стойност на a.\n\nПараметри:\n  - c (int): Сумата на a и b.\n  - d (int): Произведението на a и b.\n\nВръща:\n  Възможна стойност на a или -1, ако не съществуват валидни стойности.\n\nПримери:\n  f_22(7, 11) // връща -1\n  f_22(5, 6)  // връща 2", "zh": "编写一个 JavaScript 函数 `function f_22(c, d)` 来解决以下问题：\n\n给定整数 c 和 d，其中 a + b = c 且 a * b = d，找到并返回 a 的可能值（a <= b）。如果有多个组合，输出 a 最小的组合。\n\n参数：\n  - c (int): a 和 b 的和。\n  - d (int): a 和 b 的积。\n\n返回：\n  a 的可能值，如果不存在有效值则返回 -1。\n\n示例：\n  f_22(7, 11) // 返回 -1\n  f_22(5, 6)  // 返回 2", "fr": "Écrire une fonction JavaScript `function f_22(c, d)` pour résoudre le problème suivant :  \nÉtant donné les entiers c et d, où a + b = c et a * b = d, trouver et retourner la valeur possible de a (a <= b). S'il y a plusieurs groupes, afficher le groupe avec le plus petit a.\n\nParamètres :\n  - c (int) : La somme de a et b.\n  - d (int) : Le produit de a et b.\n\nRenvoie :\n  Une valeur possible de a ou -1 si des valeurs valides n'existent pas.\n\nExemples :\n  f_22(7, 11) // retourne -1\n  f_22(5, 6)  // retourne 2", "de": "Schreiben Sie eine JavaScript-Funktion `function f_22(c, d)`, um das folgende Problem zu lösen:\nGegeben sind die Ganzzahlen c und d, wobei a + b = c und a * b = d, finden und geben Sie den möglichen Wert von a zurück (a <= b). Wenn es mehrere Gruppen gibt, geben Sie die Gruppe mit dem kleinsten a aus.\n\nParameter:\n  - c (int): Die Summe von a und b.\n  - d (int): Das Produkt von a und b.\n\nRückgabe:\n  Ein möglicher Wert von a oder -1, wenn keine gültigen Werte existieren.\n\nBeispiele:\n  f_22(7, 11) // gibt -1 zurück\n  f_22(5, 6)  // gibt 2 zurück", "ha": "Rubuta wani aikin JavaScript `function f_22(c, d)` don warware matsalar mai zuwa:\nAn ba da lambobin c da d, inda a + b = c kuma a * b = d, nemo kuma dawo da yiwuwar ƙimar a (a <= b). Idan akwai kungiyoyi da yawa, fitar da ƙungiyar da ke da ƙaramin a.\n\nSigogi:\n  - c (int): Jimillar a da b.\n  - d (int): Samfurin a da b.\n\nDawowa:\n  Wata yiwuwar ƙimar a ko -1 idan babu ƙimar da ta dace.\n\nMisalai:\n  f_22(7, 11) // returns -1\n  f_22(5, 6)  // returns 2", "hi": "JavaScript फ़ंक्शन `function f_22(c, d)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए पूर्णांक c और d, जहाँ a + b = c और a * b = d, a का संभावित मान खोजें और लौटाएँ (a <= b)। यदि कई समूह हैं, तो सबसे छोटे a वाले समूह को आउटपुट करें।\n\nपैरामीटर्स:\n  - c (int): a और b का योग।\n  - d (int): a और b का गुणनफल।\n\nवापसी मान:\n  a का एक संभावित मान या -1 यदि मान्य मान मौजूद नहीं हैं।\n\nउदाहरण:\n  f_22(7, 11) // returns -1\n  f_22(5, 6)  // returns 2", "hu": "Írj egy JavaScript függvényt `function f_22(c, d)` a következő probléma megoldására:\nAdottak az egész számok c és d, ahol a + b = c és a * b = d, találd meg és add vissza a lehetséges a értéket (a <= b). Ha több csoport is van, add vissza azt a csoportot, amelyikben a legkisebb az a.\n\nParaméterek:\n  - c (int): Az a és b összege.\n  - d (int): Az a és b szorzata.\n\nVisszatér:\n  Egy lehetséges a érték vagy -1, ha nem léteznek érvényes értékek.\n\nPéldák:\n  f_22(7, 11) // visszaadja -1\n  f_22(5, 6)  // visszaadja 2", "es": "Escribe una función de JavaScript `function f_22(c, d)` para resolver el siguiente problema:\nDado los enteros c y d, donde a + b = c y a * b = d, encuentra y devuelve el valor posible de a (a <= b). Si hay múltiples grupos, muestra el grupo con el menor a.\n\nParámetros:\n  - c (int): La suma de a y b.\n  - d (int): El producto de a y b.\n\nDevuelve:\n  Un valor posible de a o -1 si no existen valores válidos.\n\nEjemplos:\n  f_22(7, 11) // devuelve -1\n  f_22(5, 6)  // devuelve 2", "arb": "اكتب دالة JavaScript `function f_22(c, d)` لحل المشكلة التالية:\nمعطى الأعداد الصحيحة c و d، حيث a + b = c و a * b = d، ابحث وأعد القيمة الممكنة لـ a (حيث a <= b). إذا كانت هناك مجموعات متعددة، قم بإخراج المجموعة ذات القيمة الأصغر لـ a.\n\nالمعطيات:\n  - c (int): مجموع a و b.\n  - d (int): حاصل ضرب a و b.\n\nالقيم المعادة:\n  قيمة ممكنة لـ a أو -1 إذا لم تكن هناك قيم صالحة.\n\nأمثلة:\n  f_22(7, 11) // يعيد -1\n  f_22(5, 6)  // يعيد 2", "sw": "Andika kazi ya JavaScript `function f_22(c, d)` kutatua tatizo lifuatalo:\nUkipiwa nambari kamili c na d, ambapo a + b = c na a * b = d, tafuta na rudisha thamani inayowezekana ya a (a <= b). Ikiwa kuna makundi mengi, toa kundi lenye a ndogo zaidi.\n\nVigezo:\n  - c (int): Jumla ya a na b.\n  - d (int): Bidhaa ya a na b.\n\nRudisha:\n  Thamani inayowezekana ya a au -1 ikiwa thamani halali hazipo.\n\nMifano:\n  f_22(7, 11) // inarudisha -1\n  f_22(5, 6)  // inarudisha 2", "tr": "Bir JavaScript fonksiyonu `function f_22(c, d)` yazın ve aşağıdaki problemi çözün:\nVerilen c ve d tamsayıları için, burada a + b = c ve a * b = d, a'nın (a <= b) olası değerini bulun ve döndürün. Birden fazla grup varsa, en küçük a'ya sahip grubu çıktı olarak verin.\n\nParametreler:\n  - c (int): a ve b'nin toplamı.\n  - d (int): a ve b'nin çarpımı.\n\nDöndürülen:\n  a'nın olası bir değeri veya geçerli değerler yoksa -1.\n\nÖrnekler:\n  f_22(7, 11) // -1 döndürür\n  f_22(5, 6)  // 2 döndürür", "vi": "Viết một hàm JavaScript `function f_22(c, d)` để giải quyết vấn đề sau:  \nCho các số nguyên c và d, trong đó a + b = c và a * b = d, tìm và trả về giá trị có thể của a (a <= b). Nếu có nhiều nhóm, xuất nhóm với a nhỏ nhất.\n\nTham số:\n  - c (int): Tổng của a và b.\n  - d (int): Tích của a và b.\n\nTrả về:\n  Một giá trị có thể của a hoặc -1 nếu không tồn tại giá trị hợp lệ.\n\nVí dụ:\n  f_22(7, 11) // trả về -1\n  f_22(5, 6)  // trả về 2", "id": "Tulis sebuah fungsi JavaScript `function f_22(c, d)` untuk menyelesaikan masalah berikut:\nDiberikan bilangan bulat c dan d, di mana a + b = c dan a * b = d, cari dan kembalikan nilai yang mungkin dari a (a <= b). Jika ada beberapa kelompok, keluarkan kelompok dengan a terkecil.\n\nParameter:\n  - c (int): Jumlah dari a dan b.\n  - d (int): Hasil kali dari a dan b.\n\nMengembalikan:\n  Nilai yang mungkin dari a atau -1 jika nilai yang valid tidak ada.\n\nContoh:\n  f_22(7, 11) // mengembalikan -1\n  f_22(5, 6)  // mengembalikan 2", "ja": "JavaScript関数`function f_22(c, d)`を作成して、次の問題を解決してください:\n整数cとdが与えられたとき、a + b = cかつa * b = dとなるaの可能な値を見つけて返します (a <= b)。複数のグループがある場合は、aが最小のグループを出力してください。\n\nパラメータ:\n  - c (int): aとbの和。\n  - d (int): aとbの積。\n\n戻り値:\n  aの可能な値、または有効な値が存在しない場合は-1。\n\n例:\n  f_22(7, 11) // returns -1\n  f_22(5, 6)  // returns 2", "ko": "JavaScript 함수를 작성하세요 `function f_22(c, d)` 다음 문제를 해결하기 위해:\n정수 c와 d가 주어졌을 때, a + b = c이고 a * b = d인 a의 가능한 값을 찾아 반환합니다 (a <= b). 여러 그룹이 있는 경우, a가 가장 작은 그룹을 출력합니다.\n\n매개변수:\n  - c (int): a와 b의 합.\n  - d (int): a와 b의 곱.\n\n반환값:\n  가능한 a의 값 또는 유효한 값이 존재하지 않으면 -1.\n\n예시:\n  f_22(7, 11) // -1 반환\n  f_22(5, 6)  // 2 반환", "ml": "`function f_22(c, d)` എന്ന ജാവാസ്ക്രിപ്റ്റ് ഫംഗ്ഷൻ എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nഇൻറിജർസ് c, d നൽകിയിരിക്കുന്നു, ഇവിടെ a + b = c, a * b = d, a (a <= b) എന്ന a യുടെ സാദ്ധ്യമായ മൂല്യം കണ്ടെത്തി മടക്കുക. ഒന്നിലധികം ഗ്രൂപ്പുകൾ ഉണ്ടെങ്കിൽ, ഏറ്റവും ചെറിയ a ഉള്ള ഗ്രൂപ്പ് ഔട്ട്‌പുട്ട് ചെയ്യുക.\n\nപാരാമീറ്ററുകൾ:\n  - c (int): a, b യുടെ തുക.\n  - d (int): a, b യുടെ ഗുണഫലം.\n\nമടക്കുന്നു:\n  a യുടെ സാദ്ധ്യമായ മൂല്യം അല്ലെങ്കിൽ സാധുവായ മൂല്യങ്ങൾ ഇല്ലെങ്കിൽ -1.\n\nഉദാഹരണങ്ങൾ:\n  f_22(7, 11) // -1 മടക്കുന്നു\n  f_22(5, 6)  // 2 മടക്കുന്നു", "fa": "یک تابع جاوااسکریپت `function f_22(c, d)` بنویسید تا مسئله زیر را حل کند:\nبا توجه به اعداد صحیح c و d، که در آن a + b = c و a * b = d، مقدار ممکن a (a <= b) را پیدا کرده و برگردانید. اگر گروه‌های متعددی وجود دارد، گروهی با کوچک‌ترین a را خروجی دهید.\n\nپارامترها:\n  - c (int): مجموع a و b.\n  - d (int): حاصل‌ضرب a و b.\n\nبازگشتی:\n  یک مقدار ممکن از a یا -1 اگر مقادیر معتبر وجود نداشته باشند.\n\nمثال‌ها:\n  f_22(7, 11) // بازمی‌گرداند -1\n  f_22(5, 6)  // بازمی‌گرداند 2"}, "level": "easy", "test": "const testf_22 = () => {\n    console.assert(f_22(5, 6) === 2, \"Expected 2\");\n    console.assert(f_22(6, 9) === 3, \"Expected 3\");\n    console.assert(f_22(7, 12) === 3, \"Expected 3\");\n    console.assert(f_22(7, 11) === -1, \"Expected -1\");\n    console.assert(f_22(9, 8) === 1, \"Expected 1\");\n    console.assert(f_22(10, 25) === 5, \"Expected 5\");\n    console.assert(f_22(10000, 8765) === -1, \"Expected -1\");\n    // console.log(\"All tests passed successfully.\");\n}\n\ntestf_22();", "entry_point": "f_22", "signature": "function f_22(c, d)", "docstring": {"en": "Given integers c and d, where a + b = c and a * b = d, find and return the possible value of a (a <= b). If there are multiple groups, output the group with the smallest a.\n\nParameters:\n  - c (int): The sum of a and b.\n  - d (int): The product of a and b.\n\nReturns:\n  A possible value of a or -1 if valid values do not exist.\n\nExamples:\n  f_22(7, 11) // returns -1\n  f_22(5, 6)  // returns 2\n", "sq": "Duke pasur parasysh numrat e plotë c dhe d, ku a + b = c dhe a * b = d, gjeni dhe ktheni vlerën e mundshme të a (a <= b). Nëse ka grupe të shumta, jepni grupin me vlerën më të vogël të a.\n\nParametrat:\n  - c (int): Shuma e a dhe b.\n  - d (int): Produkti i a dhe b.\n\nKthen:\n  Një vlerë të mundshme të a ose -1 nëse vlerat e vlefshme nuk ekzistojnë.\n\nShembuj:\n  f_22(7, 11) // kthen -1\n  f_22(5, 6)  // kthen 2", "hy": "Տրված են ամբողջ թվեր c և d, որտեղ a + b = c և a * b = d, գտնել և վերադարձնել a-ի հնարավոր արժեքը (a <= b): Եթե կան բազմաթիվ խմբեր, վերադարձնել այն խումբը, որտեղ a-ն ամենափոքրն է:\n\nՊարամետրեր:\n  - c (int): a-ի և b-ի գումարը:\n  - d (int): a-ի և b-ի արտադրյալը:\n\nՎերադարձնում է:\n  a-ի հնարավոր արժեք կամ -1, եթե վավեր արժեքներ չկան:\n\nՕրինակներ:\n  f_22(7, 11) // վերադարձնում է -1\n  f_22(5, 6)  // վերադարձնում է 2", "bn": "দেওয়া পূর্ণসংখ্যা c এবং d এর জন্য, যেখানে a + b = c এবং a * b = d, a এর সম্ভাব্য মান খুঁজে বের করুন এবং ফেরত দিন (a <= b)। যদি একাধিক গ্রুপ থাকে, তাহলে সবচেয়ে ছোট a সহ গ্রুপটি আউটপুট করুন।\n\nপ্যারামিটারসমূহ:\n  - c (int): a এবং b এর যোগফল।\n  - d (int): a এবং b এর গুণফল।\n\nফেরত দেয়:\n  a এর একটি সম্ভাব্য মান অথবা -1 যদি বৈধ মান বিদ্যমান না থাকে।\n\nউদাহরণসমূহ:\n  f_22(7, 11) // -1 ফেরত দেয়\n  f_22(5, 6)  // 2 ফেরত দেয়", "bg": "Дадени са цели числа c и d, където a + b = c и a * b = d, намерете и върнете възможната стойност на a (a <= b). Ако има множество групи, изведете групата с най-малката a.\n\nПараметри:\n  - c (int): Сумата на a и b.\n  - d (int): Произведението на a и b.\n\nВръща:\n  Възможна стойност на a или -1, ако не съществуват валидни стойности.\n\nПримери:\n  f_22(7, 11) // връща -1\n  f_22(5, 6)  // връща 2", "zh": "给定整数 c 和 d，其中 a + b = c 且 a * b = d，找出并返回可能的 a 的值（a <= b）。如果有多个组合，输出 a 最小的组合。\n\n参数：\n  - c (int): a 和 b 的和。\n  - d (int): a 和 b 的积。\n\n返回：\n  a 的可能值，或者如果不存在有效值则返回 -1。\n\n示例：\n  f_22(7, 11) // 返回 -1\n  f_22(5, 6)  // 返回 2", "fr": "Étant donné les entiers c et d, où a + b = c et a * b = d, trouver et retourner la valeur possible de a (a <= b). S'il y a plusieurs groupes, afficher le groupe avec le plus petit a.\n\nParamètres:\n  - c (int): La somme de a et b.\n  - d (int): Le produit de a et b.\n\nRenvoie:\n  Une valeur possible de a ou -1 si des valeurs valides n'existent pas.\n\nExemples:\n  f_22(7, 11) // renvoie -1\n  f_22(5, 6)  // renvoie 2", "de": "Gegeben ganze Zahlen c und d, wobei a + b = c und a * b = d, finde und gib den möglichen Wert von a zurück (a <= b). Wenn es mehrere Gruppen gibt, gib die Gruppe mit dem kleinsten a aus.\n\nParameter:\n  - c (int): Die Summe von a und b.\n  - d (int): Das Produkt von a und b.\n\nRückgabe:\n  Ein möglicher Wert von a oder -1, wenn keine gültigen Werte existieren.\n\nBeispiele:\n  f_22(7, 11) // gibt -1 zurück\n  f_22(5, 6)  // gibt 2 zurück", "ha": "An ba da lambobin c da d, inda a + b = c kuma a * b = d, nemo kuma dawo da yuwuwar ƙimar a (a <= b). Idan akwai rukuni da yawa, fitar da rukunin da ke da ƙaramin a.\n\nSigogi:\n  - c (int): Jimillar a da b.\n  - d (int): Samfurin a da b.\n\nDawowa:\n  Yuwuwar ƙimar a ko -1 idan ba a samu ƙimar da ta dace ba.\n\nMisalai:\n  f_22(7, 11) // ya dawo -1\n  f_22(5, 6)  // ya dawo 2", "hi": "दिए गए पूर्णांक c और d के लिए, जहाँ a + b = c और a * b = d, a का संभावित मान खोजें और लौटाएँ (a <= b)। यदि कई समूह हैं, तो सबसे छोटे a वाले समूह को आउटपुट करें।\n\nपैरामीटर्स:\n  - c (int): a और b का योग।\n  - d (int): a और b का गुणनफल।\n\nलौटाता है:\n  a का संभावित मान या -1 यदि मान्य मान मौजूद नहीं हैं।\n\nउदाहरण:\n  f_22(7, 11) // -1 लौटाता है\n  f_22(5, 6)  // 2 लौटाता है", "hu": "Adott c és d egész számok, ahol a + b = c és a * b = d, keresse meg és adja vissza a lehetséges a értékét (a <= b). Ha több csoport is van, adja vissza azt a csoportot, amelyikben a a legkisebb.\n\nParaméterek:\n  - c (int): a és b összege.\n  - d (int): a és b szorzata.\n\nVisszatérési érték:\n  A lehetséges a értéke vagy -1, ha nem léteznek érvényes értékek.\n\nPéldák:\n  f_22(7, 11) // visszaadja -1\n  f_22(5, 6)  // visszaadja 2", "es": "Dado los enteros c y d, donde a + b = c y a * b = d, encuentra y devuelve el valor posible de a (a <= b). Si hay múltiples grupos, devuelve el grupo con el menor a.\n\nParámetros:\n  - c (int): La suma de a y b.\n  - d (int): El producto de a y b.\n\nDevuelve:\n  Un valor posible de a o -1 si no existen valores válidos.\n\nEjemplos:\n  f_22(7, 11) // devuelve -1\n  f_22(5, 6)  // devuelve 2", "arb": "معطى عددان صحيحان c و d، حيث a + b = c و a * b = d، ابحث وأعد القيمة المحتملة لـ a (حيث a <= b). إذا كانت هناك مجموعات متعددة، أخرج المجموعة ذات القيمة الأصغر لـ a.\n\nالمعلمات:\n  - c (int): مجموع a و b.\n  - d (int): حاصل ضرب a و b.\n\nالقيم المعادة:\n  قيمة محتملة لـ a أو -1 إذا لم تكن هناك قيم صالحة موجودة.\n\nأمثلة:\n  f_22(7, 11) // يعيد -1\n  f_22(5, 6)  // يعيد 2", "sw": "Kutolewa nambari za mzima c na d, ambapo a + b = c na a * b = d, tafuta na rudisha thamani inayowezekana ya a (a <= b). Ikiwa kuna makundi mengi, toa kundi lenye a ndogo zaidi.\n\nVigezo:\n  - c (int): Jumla ya a na b.\n  - d (int): Bidhaa ya a na b.\n\nRudisha:\n  Thamani inayowezekana ya a au -1 ikiwa thamani halali hazipo.\n\nMifano:\n  f_22(7, 11) // inarudisha -1\n  f_22(5, 6)  // inarudisha 2", "tr": "Verilen c ve d tamsayıları için, burada a + b = c ve a * b = d, a'nın olası değerini bulun ve döndürün (a <= b). Birden fazla grup varsa, en küçük a'ya sahip olan grubu çıkartın.\n\nParametreler:\n  - c (int): a ve b'nin toplamı.\n  - d (int): a ve b'nin çarpımı.\n\nDöndürür:\n  a'nın olası bir değeri veya geçerli değerler mevcut değilse -1.\n\nÖrnekler:\n  f_22(7, 11) // -1 döndürür\n  f_22(5, 6)  // 2 döndürür", "vi": "Cho các số nguyên c và d, trong đó a + b = c và a * b = d, tìm và trả về giá trị có thể của a (a <= b). Nếu có nhiều nhóm, xuất nhóm với a nhỏ nhất.\n\nTham số:\n  - c (int): Tổng của a và b.\n  - d (int): Tích của a và b.\n\nTrả về:\n  Một giá trị có thể của a hoặc -1 nếu không tồn tại giá trị hợp lệ.\n\nVí dụ:\n  f_22(7, 11) // trả về -1\n  f_22(5, 6)  // trả về 2", "id": "Diberikan bilangan bulat c dan d, di mana a + b = c dan a * b = d, temukan dan kembalikan nilai a yang mungkin (a <= b). Jika ada beberapa kelompok, keluarkan kelompok dengan a terkecil.\n\nParameter:\n  - c (int): Jumlah dari a dan b.\n  - d (int): Hasil kali dari a dan b.\n\nMengembalikan:\n  Nilai a yang mungkin atau -1 jika nilai yang valid tidak ada.\n\nContoh:\n  f_22(7, 11) // mengembalikan -1\n  f_22(5, 6)  // mengembalikan 2", "ja": "与えられた整数 c と d に対して、a + b = c および a * b = d であるとき、a の可能な値を見つけて返します (a <= b)。複数のグループがある場合は、a が最小のグループを出力します。\n\n引数:\n  - c (int): a と b の合計。\n  - d (int): a と b の積。\n\n返り値:\n  a の可能な値、または有効な値が存在しない場合は -1。\n\n例:\n  f_22(7, 11) // -1 を返します\n  f_22(5, 6)  // 2 を返します", "ko": "주어진 정수 c와 d에 대해, a + b = c이고 a * b = d인 가능한 a의 값을 찾아 반환합니다 (a <= b). 여러 그룹이 있는 경우, a가 가장 작은 그룹을 출력합니다.\n\n매개변수:\n  - c (int): a와 b의 합.\n  - d (int): a와 b의 곱.\n\n반환:\n  가능한 a의 값 또는 유효한 값이 존재하지 않으면 -1.\n\n예시:\n  f_22(7, 11) // -1 반환\n  f_22(5, 6)  // 2 반환", "ml": "ഇൻറിജറുകൾ c, d എന്നിവ നൽകിയിരിക്കുന്നു, ഇവിടെ a + b = c, a * b = d, a (a <= b) എന്നതിനുള്ള സാധ്യതയുള്ള മൂല്യം കണ്ടെത്തി തിരിച്ചുനൽകുക. ഒന്നിലധികം ഗ്രൂപ്പുകൾ ഉണ്ടെങ്കിൽ, ഏറ്റവും ചെറിയ a ഉള്ള ഗ്രൂപ്പ് ഔട്ട്‌പുട്ട് ചെയ്യുക.\n\nപാരാമീറ്ററുകൾ:\n  - c (int): a, b എന്നിവയുടെ ആകെ ഫലം.\n  - d (int): a, b എന്നിവയുടെ ഗുണഫലം.\n\nമടക്കുന്നു:\n  a യുടെ സാധ്യതയുള്ള മൂല്യം അല്ലെങ്കിൽ സാധുവായ മൂല്യങ്ങൾ ഇല്ലെങ്കിൽ -1.\n\nഉദാഹരണങ്ങൾ:\n  f_22(7, 11) // -1 മടക്കുന്നു\n  f_22(5, 6)  // 2 മടക്കുന്നു", "fa": "داده شده اعداد صحیح c و d، که در آن a + b = c و a * b = d، مقدار ممکن a را پیدا کنید و برگردانید (a <= b). اگر گروه‌های متعددی وجود دارند، گروهی را با کوچک‌ترین a خروجی دهید.\n\nپارامترها:\n  - c (int): مجموع a و b.\n  - d (int): حاصل‌ضرب a و b.\n\nبازگشت:\n  مقدار ممکن a یا -1 اگر مقادیر معتبر وجود نداشته باشند.\n\nمثال‌ها:\n  f_22(7, 11) // -1 را برمی‌گرداند\n  f_22(5, 6)  // 2 را برمی‌گرداند"}}
{"task_id": "JavaScript/23", "prompt": {"en": "/**\n * Count the number of acute-angled triangles that can be formed by selecting any 3 edges out of a given set of edges.\n * \n * @param {number} edges_count - The number of edges.\n * @param {...number} edges - The lengths of the edges.\n * @returns {number} The count of distinct acute-angled triangles that can be formed.\n * \n * Examples:\n * f_23(4, 1, 1, 1, 1) // returns 4\n */\nfunction f_23(edges_count, ...edges)", "sq": "/**\n * Numëron numrin e trekëndëshave me kënd të mprehtë që mund të formohen duke zgjedhur çdo 3 brinjë nga një grup i dhënë brinjësh.\n * \n * @param {number} edges_count - Numri i brinjëve.\n * @param {...number} edges - Gjatësitë e brinjëve.\n * @returns {number} Numri i trekëndëshave të dallueshëm me kënd të mprehtë që mund të formohen.\n * \n * Shembuj:\n * f_23(4, 1, 1, 1, 1) // kthen 4\n */\nfunction f_23(edges_count, ...edges)", "hy": "/**\n * Հաշվել սուրանկյուն եռանկյունիների քանակը, որոնք կարող են կազմվել ընտրելով ցանկացած 3 կողմերը տրված կողմերի բազմությունից։\n * \n * @param {number} edges_count - Կողմերի քանակը։\n * @param {...number} edges - Կողմերի երկարությունները։\n * @returns {number} Տարբեր սուրանկյուն եռանկյունիների քանակը, որոնք կարող են կազմվել։\n * \n * Օրինակներ:\n * f_23(4, 1, 1, 1, 1) // վերադարձնում է 4\n */\nfunction f_23(edges_count, ...edges)", "bn": "/**\n * প্রদত্ত প্রান্তগুলির একটি সেট থেকে যেকোন 3টি প্রান্ত নির্বাচন করে কতগুলি তীক্ষ্ণ-কোণযুক্ত ত্রিভুজ তৈরি করা যেতে পারে তা গণনা করুন।\n * \n * @param {number} edges_count - প্রান্তের সংখ্যা।\n * @param {...number} edges - প্রান্তগুলির দৈর্ঘ্য।\n * @returns {number} গঠিত পৃথক তীক্ষ্ণ-কোণযুক্ত ত্রিভুজের সংখ্যা।\n * \n * উদাহরণ:\n * f_23(4, 1, 1, 1, 1) // 4 প্রদান করে\n */\nfunction f_23(edges_count, ...edges)", "bg": "/**\n * Пребройте броя на остроъгълните триъгълници, които могат да бъдат образувани чрез избиране на произволни 3 ръба от даден набор от ръбове.\n * \n * @param {number} edges_count - Броят на ръбовете.\n * @param {...number} edges - Дължините на ръбовете.\n * @returns {number} Броят на различните остроъгълни триъгълници, които могат да бъдат образувани.\n * \n * Примери:\n * f_23(4, 1, 1, 1, 1) // връща 4\n */\nfunction f_23(edges_count, ...edges)", "zh": "/**\n * 计算可以通过从给定的一组边中选择任意3条边形成的锐角三角形的数量。\n * \n * @param {number} edges_count - 边的数量。\n * @param {...number} edges - 边的长度。\n * @returns {number} 可以形成的不同锐角三角形的数量。\n * \n * 例子:\n * f_23(4, 1, 1, 1, 1) // 返回 4\n */\nfunction f_23(edges_count, ...edges)", "fr": "/**\n * Compter le nombre de triangles aigus qui peuvent être formés en sélectionnant 3 arêtes parmi un ensemble donné d'arêtes.\n * \n * @param {number} edges_count - Le nombre d'arêtes.\n * @param {...number} edges - Les longueurs des arêtes.\n * @returns {number} Le nombre de triangles aigus distincts qui peuvent être formés.\n * \n * Exemples :\n * f_23(4, 1, 1, 1, 1) // returns 4\n */\nfunction f_23(edges_count, ...edges)", "de": "/**\n * Zähle die Anzahl der spitzwinkligen Dreiecke, die gebildet werden können, indem beliebige 3 Kanten aus einem gegebenen Satz von Kanten ausgewählt werden.\n * \n * @param {number} edges_count - Die Anzahl der Kanten.\n * @param {...number} edges - Die Längen der Kanten.\n * @returns {number} Die Anzahl der unterschiedlichen spitzwinkligen Dreiecke, die gebildet werden können.\n * \n * Beispiele:\n * f_23(4, 1, 1, 1, 1) // gibt 4 zurück\n */\nfunction f_23(edges_count, ...edges)", "ha": "/**\n * Ƙirga adadin kusurwoyi masu kaifi waɗanda za a iya samarwa ta zaɓar kowane gefuna 3 daga cikin wani saiti na gefuna.\n * \n * @param {number} edges_count - Yawan gefuna.\n * @param {...number} edges - Tsawon gefuna.\n * @returns {number} Adadin kusurwoyi masu kaifi daban-daban waɗanda za a iya samarwa.\n * \n * Misalai:\n * f_23(4, 1, 1, 1, 1) // returns 4\n */\nfunction f_23(edges_count, ...edges)", "hi": "/**\n * दिए गए किनारों के सेट में से किसी भी 3 किनारों का चयन करके बनने वाले तीव्र कोण त्रिभुजों की संख्या गिनें।\n * \n * @param {number} edges_count - किनारों की संख्या।\n * @param {...number} edges - किनारों की लंबाई।\n * @returns {number} बनने वाले विशिष्ट तीव्र कोण त्रिभुजों की संख्या।\n * \n * उदाहरण:\n * f_23(4, 1, 1, 1, 1) // 4 लौटाता है\n */\nfunction f_23(edges_count, ...edges)", "hu": "/**\n * Számolja meg a hegyesszögű háromszögek számát, amelyek bármely 3 él kiválasztásával képezhetők a megadott élek halmazából.\n * \n * @param {number} edges_count - Az élek száma.\n * @param {...number} edges - Az élek hossza.\n * @returns {number} Az alkotható különböző hegyesszögű háromszögek száma.\n * \n * Példák:\n * f_23(4, 1, 1, 1, 1) // visszaadja: 4\n */\nfunction f_23(edges_count, ...edges)", "es": "/**\n * Cuenta el número de triángulos acutángulos que se pueden formar seleccionando cualquier 3 lados de un conjunto dado de lados.\n * \n * @param {number} edges_count - El número de lados.\n * @param {...number} edges - Las longitudes de los lados.\n * @returns {number} La cantidad de triángulos acutángulos distintos que se pueden formar.\n * \n * Ejemplos:\n * f_23(4, 1, 1, 1, 1) // devuelve 4\n */\nfunction f_23(edges_count, ...edges)", "arb": "/**\n * احسب عدد المثلثات الحادة الزاوية التي يمكن تشكيلها عن طريق اختيار أي 3 حواف من مجموعة الحواف المعطاة.\n * \n * @param {number} edges_count - عدد الحواف.\n * @param {...number} edges - أطوال الحواف.\n * @returns {number} عدد المثلثات الحادة الزاوية المميزة التي يمكن تشكيلها.\n * \n * أمثلة:\n * f_23(4, 1, 1, 1, 1) // يعيد 4\n */\nfunction f_23(edges_count, ...edges)", "sw": "/**\n * Hesabu idadi ya pembetatu zenye pembe kali ambazo zinaweza kuundwa kwa kuchagua pande 3 kutoka kwenye seti ya pande zilizotolewa.\n * \n * @param {number} edges_count - Idadi ya pande.\n * @param {...number} edges - Urefu wa pande.\n * @returns {number} Idadi ya pembetatu tofauti zenye pembe kali ambazo zinaweza kuundwa.\n * \n * Mifano:\n * f_23(4, 1, 1, 1, 1) // inarudisha 4\n */\nfunction f_23(edges_count, ...edges)", "tr": "/**\n * Verilen bir kenar kümesinden herhangi 3 kenar seçilerek oluşturulabilecek dar açılı üçgenlerin sayısını sayar.\n * \n * @param {number} edges_count - Kenarların sayısı.\n * @param {...number} edges - Kenarların uzunlukları.\n * @returns {number} Oluşturulabilecek farklı dar açılı üçgenlerin sayısı.\n * \n * Örnekler:\n * f_23(4, 1, 1, 1, 1) // 4 döndürür\n */\nfunction f_23(edges_count, ...edges)", "vi": "/**\n * Đếm số lượng tam giác nhọn có thể được tạo thành bằng cách chọn bất kỳ 3 cạnh nào từ một tập hợp các cạnh cho trước.\n * \n * @param {number} edges_count - Số lượng cạnh.\n * @param {...number} edges - Độ dài của các cạnh.\n * @returns {number} Số lượng tam giác nhọn khác nhau có thể được tạo thành.\n * \n * Ví dụ:\n * f_23(4, 1, 1, 1, 1) // trả về 4\n */\nfunction f_23(edges_count, ...edges)", "id": "/**\n * Hitung jumlah segitiga lancip yang dapat dibentuk dengan memilih sembarang 3 sisi dari sekumpulan sisi yang diberikan.\n * \n * @param {number} edges_count - Jumlah sisi.\n * @param {...number} edges - Panjang sisi-sisi.\n * @returns {number} Jumlah segitiga lancip yang berbeda yang dapat dibentuk.\n * \n * Contoh:\n * f_23(4, 1, 1, 1, 1) // mengembalikan 4\n */\nfunction f_23(edges_count, ...edges)", "ja": "/**\n * 与えられたエッジの集合から任意の3つのエッジを選択して形成できる鋭角三角形の数を数えます。\n * \n * @param {number} edges_count - エッジの数。\n * @param {...number} edges - エッジの長さ。\n * @returns {number} 形成できる異なる鋭角三角形の数。\n * \n * 例:\n * f_23(4, 1, 1, 1, 1) // 4を返します\n */\nfunction f_23(edges_count, ...edges)", "ko": "/**\n * 주어진 변 집합에서 임의의 3개의 변을 선택하여 형성할 수 있는 예각 삼각형의 개수를 계산합니다.\n * \n * @param {number} edges_count - 변의 개수.\n * @param {...number} edges - 변의 길이들.\n * @returns {number} 형성할 수 있는 서로 다른 예각 삼각형의 개수.\n * \n * 예시:\n * f_23(4, 1, 1, 1, 1) // returns 4\n */\nfunction f_23(edges_count, ...edges)", "ml": "/**\n * നൽകിയ ഒരു സെറ്റ് എഡ്ജുകളിൽ നിന്ന് ഏതെങ്കിലും 3 എഡ്ജുകൾ തിരഞ്ഞെടുക്കുന്നതിലൂടെ രൂപീകരിക്കാവുന്ന മൂർച്ചയുള്ള കോണുകളുള്ള ത്രികോണങ്ങളുടെ എണ്ണം എണ്ണുക.\n * \n * @param {number} edges_count - എഡ്ജുകളുടെ എണ്ണം.\n * @param {...number} edges - എഡ്ജുകളുടെ നീളങ്ങൾ.\n * @returns {number} രൂപീകരിക്കാവുന്ന വ്യത്യസ്തമായ മൂർച്ചയുള്ള കോണങ്ങളുള്ള ത്രികോണങ്ങളുടെ എണ്ണം.\n * \n * ഉദാഹരണങ്ങൾ:\n * f_23(4, 1, 1, 1, 1) // 4 മടക്കുന്നു\n */\nfunction f_23(edges_count, ...edges)", "fa": "/**\n * تعداد مثلث‌های تیزگوشه‌ای را که می‌توان با انتخاب هر ۳ ضلع از مجموعه‌ای از اضلاع تشکیل داد، بشمارید.\n * \n * @param {number} edges_count - تعداد اضلاع.\n * @param {...number} edges - طول اضلاع.\n * @returns {number} تعداد مثلث‌های تیزگوشه متمایزی که می‌توان تشکیل داد.\n * \n * Examples:\n * f_23(4, 1, 1, 1, 1) // returns 4\n */\nfunction f_23(edges_count, ...edges)"}, "canonical_solution": "{\n    // Sort the edges array\n    edges.sort((a, b) => a - b);\n\n    let sum = 0;\n    // Check each combination of three edges for an acute triangle.\n    for (let i = 0; i < edges_count - 2; i++) {\n        for (let j = i + 1; j < edges_count - 1; j++) {\n            for (let k = j + 1; k < edges_count; k++) {\n                const x = edges[i], y = edges[j], z = edges[k];\n                // The sum of any two sides must be greater than the third, and\n                // it needs to meet the acute angle criteria via Pythagoras.\n                if (x + y > z && (x * x + y * y > z * z)) {\n                    sum++;\n                }\n            }\n        }\n    }\n    return sum;\n}", "instruction": {"en": "Write a JavaScript function `function f_23(edges_count, ...edges)` to solve the following problem:\nCount the number of acute-angled triangles that can be formed by selecting any 3 edges out of a given set of edges.\n\nParameters:\n- edges_count (number): The number of edges.\n- edges (...number): The lengths of the edges.\n\nReturns:\n- number: The count of distinct acute-angled triangles that can be formed.\n\nExamples:\n- f_23(4, 1, 1, 1, 1) // returns 4\n", "sq": "Shkruani një funksion JavaScript `function f_23(edges_count, ...edges)` për të zgjidhur problemin e mëposhtëm:\nNumëroni numrin e trekëndëshave me kënde të mprehta që mund të formohen duke zgjedhur çdo 3 brinjë nga një grup i dhënë brinjësh.\n\nParametrat:\n- edges_count (numër): Numri i brinjëve.\n- edges (...numër): Gjatësitë e brinjëve.\n\nKthen:\n- numër: Numri i trekëndëshave të dallueshëm me kënde të mprehta që mund të formohen.\n\nShembuj:\n- f_23(4, 1, 1, 1, 1) // kthen 4", "hy": "Գրեք JavaScript ֆունկցիա `function f_23(edges_count, ...edges)` հետևյալ խնդիրը լուծելու համար:\nՀաշվեք սուրանկյուն եռանկյունիների քանակը, որոնք կարող են կազմվել ընտրված ցանկացած 3 կողերից տրված կողերի հավաքածուից:\n\nՊարամետրեր:\n- edges_count (number): Կողերի քանակը։\n- edges (...number): Կողերի երկարությունները։\n\nՎերադարձնում է:\n- number: Տարբեր սուրանկյուն եռանկյունիների քանակը, որոնք կարող են կազմվել։\n\nՕրինակներ:\n- f_23(4, 1, 1, 1, 1) // վերադարձնում է 4", "bn": "একটি জাভাস্ক্রিপ্ট ফাংশন `function f_23(edges_count, ...edges)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nপ্রদত্ত প্রান্তের একটি সেট থেকে যেকোনো ৩টি প্রান্ত নির্বাচন করে কতগুলো তীক্ষ্ণকোণী ত্রিভুজ গঠন করা যায় তা গণনা করুন।\n\nপ্যারামিটারসমূহ:\n- edges_count (সংখ্যা): প্রান্তের সংখ্যা।\n- edges (...সংখ্যা): প্রান্তগুলোর দৈর্ঘ্য।\n\nফেরত দেয়:\n- সংখ্যা: গঠিত হতে পারে এমন স্বতন্ত্র তীক্ষ্ণকোণী ত্রিভুজের সংখ্যা।\n\nউদাহরণসমূহ:\n- f_23(4, 1, 1, 1, 1) // 4 ফেরত দেয়", "bg": "Напишете JavaScript функция `function f_23(edges_count, ...edges)`, за да решите следния проблем:  \nБройте броя на остроъгълните триъгълници, които могат да бъдат образувани чрез избиране на произволни 3 ръба от даден набор от ръбове.\n\nПараметри:\n- edges_count (number): Броят на ръбовете.\n- edges (...number): Дължините на ръбовете.\n\nВръща:\n- number: Броят на различните остроъгълни триъгълници, които могат да бъдат образувани.\n\nПримери:\n- f_23(4, 1, 1, 1, 1) // връща 4", "zh": "编写一个 JavaScript 函数 `function f_23(edges_count, ...edges)` 来解决以下问题：  \n计算可以通过从给定的一组边中选择任意 3 条边形成的锐角三角形的数量。\n\n参数：\n- edges_count (number): 边的数量。\n- edges (...number): 边的长度。\n\n返回：\n- number: 可以形成的不同锐角三角形的数量。\n\n示例：\n- f_23(4, 1, 1, 1, 1) // 返回 4", "fr": "Écrire une fonction JavaScript `function f_23(edges_count, ...edges)` pour résoudre le problème suivant :  \nCompter le nombre de triangles acutangles qui peuvent être formés en sélectionnant 3 arêtes parmi un ensemble donné d'arêtes.\n\nParamètres :\n- edges_count (nombre) : Le nombre d'arêtes.\n- edges (...nombre) : Les longueurs des arêtes.\n\nRenvoie :\n- nombre : Le nombre de triangles acutangles distincts qui peuvent être formés.\n\nExemples :\n- f_23(4, 1, 1, 1, 1) // renvoie 4", "de": "Schreiben Sie eine JavaScript-Funktion `function f_23(edges_count, ...edges)`, um das folgende Problem zu lösen:\nZählen Sie die Anzahl der spitzwinkligen Dreiecke, die gebildet werden können, indem Sie beliebige 3 Kanten aus einer gegebenen Menge von Kanten auswählen.\n\nParameter:\n- edges_count (number): Die Anzahl der Kanten.\n- edges (...number): Die Längen der Kanten.\n\nRückgabewert:\n- number: Die Anzahl der verschiedenen spitzwinkligen Dreiecke, die gebildet werden können.\n\nBeispiele:\n- f_23(4, 1, 1, 1, 1) // gibt 4 zurück", "ha": "Rubuta wani aikin JavaScript `function f_23(edges_count, ...edges)` don warware matsalar mai zuwa:\nKirga yawan kusurwoyi masu kaifi da za a iya samarwa ta hanyar zaɓar kowane 3 daga cikin wani saiti na gefuna.\n\nSigogi:\n- edges_count (number): Yawan gefuna.\n- edges (...number): Tsawon gefuna.\n\nDawowa:\n- number: Adadin kusurwoyi masu kaifi daban-daban da za a iya samarwa.\n\nMisalai:\n- f_23(4, 1, 1, 1, 1) // returns 4", "hi": "`function f_23(edges_count, ...edges)` फ़ंक्शन लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए किनारों के सेट में से किसी भी 3 किनारों का चयन करके बनने वाले तीव्र कोण त्रिभुजों की संख्या गिनें।\n\nपैरामीटर्स:\n- edges_count (संख्या): किनारों की संख्या।\n- edges (...संख्या): किनारों की लंबाई।\n\nवापसी:\n- संख्या: बनने वाले भिन्न तीव्र कोण त्रिभुजों की संख्या।\n\nउदाहरण:\n- f_23(4, 1, 1, 1, 1) // 4 लौटाता है", "hu": "Írj egy JavaScript függvényt `function f_23(edges_count, ...edges)` a következő probléma megoldására:  \nSzámold meg, hány hegyesszögű háromszög alakítható ki a megadott élek halmazából bármely 3 él kiválasztásával.\n\nParaméterek:\n- edges_count (szám): Az élek száma.\n- edges (...szám): Az élek hossza.\n\nVisszatér:\n- szám: Az alakítható különböző hegyesszögű háromszögek száma.\n\nPéldák:\n- f_23(4, 1, 1, 1, 1) // visszaadja 4", "es": "Escribe una función de JavaScript `function f_23(edges_count, ...edges)` para resolver el siguiente problema:\nCuenta el número de triángulos acutángulos que se pueden formar seleccionando cualquier 3 lados de un conjunto dado de lados.\n\nParámetros:\n- edges_count (número): El número de lados.\n- edges (...número): Las longitudes de los lados.\n\nDevuelve:\n- número: La cantidad de triángulos acutángulos distintos que se pueden formar.\n\nEjemplos:\n- f_23(4, 1, 1, 1, 1) // devuelve 4", "arb": "اكتب دالة JavaScript `function f_23(edges_count, ...edges)` لحل المشكلة التالية:\nعد عدد المثلثات الحادة الزاوية التي يمكن تشكيلها عن طريق اختيار أي 3 أضلاع من مجموعة الأضلاع المعطاة.\n\nالمعطيات:\n- edges_count (number): عدد الأضلاع.\n- edges (...number): أطوال الأضلاع.\n\nالمخرجات:\n- number: عدد المثلثات الحادة الزاوية المختلفة التي يمكن تشكيلها.\n\nأمثلة:\n- f_23(4, 1, 1, 1, 1) // يعيد 4", "sw": "Andika kazi ya JavaScript `function f_23(edges_count, ...edges)` kutatua tatizo lifuatalo:\nHesabu idadi ya pembetatu zenye pembe kali ambazo zinaweza kuundwa kwa kuchagua pande 3 zozote kutoka kwenye seti iliyotolewa ya pande.\n\nVigezo:\n- edges_count (nambari): Idadi ya pande.\n- edges (...nambari): Urefu wa pande.\n\nInarudisha:\n- nambari: Idadi ya pembetatu zenye pembe kali zinazoweza kuundwa.\n\nMifano:\n- f_23(4, 1, 1, 1, 1) // inarudisha 4", "tr": "Bir JavaScript fonksiyonu `function f_23(edges_count, ...edges)` yazın ve aşağıdaki problemi çözün:\nVerilen bir kenar kümesinden herhangi 3 kenar seçilerek oluşturulabilecek dar açılı üçgenlerin sayısını sayın.\n\nParametreler:\n- edges_count (number): Kenarların sayısı.\n- edges (...number): Kenarların uzunlukları.\n\nDöndürür:\n- number: Oluşturulabilecek farklı dar açılı üçgenlerin sayısı.\n\nÖrnekler:\n- f_23(4, 1, 1, 1, 1) // 4 döndürür", "vi": "Viết một hàm JavaScript `function f_23(edges_count, ...edges)` để giải quyết vấn đề sau:\nĐếm số lượng tam giác nhọn có thể được tạo thành bằng cách chọn bất kỳ 3 cạnh nào từ một tập hợp các cạnh cho trước.\n\nTham số:\n- edges_count (number): Số lượng cạnh.\n- edges (...number): Độ dài của các cạnh.\n\nTrả về:\n- number: Số lượng tam giác nhọn khác biệt có thể được tạo thành.\n\nVí dụ:\n- f_23(4, 1, 1, 1, 1) // trả về 4", "id": "Tulis sebuah fungsi JavaScript `function f_23(edges_count, ...edges)` untuk menyelesaikan masalah berikut:\nHitung jumlah segitiga lancip yang dapat dibentuk dengan memilih 3 sisi dari sekumpulan sisi yang diberikan.\n\nParameter:\n- edges_count (number): Jumlah sisi.\n- edges (...number): Panjang sisi-sisi tersebut.\n\nMengembalikan:\n- number: Jumlah segitiga lancip yang berbeda yang dapat dibentuk.\n\nContoh:\n- f_23(4, 1, 1, 1, 1) // mengembalikan 4", "ja": "JavaScript関数 `function f_23(edges_count, ...edges)` を作成して、次の問題を解決してください:\n与えられたエッジのセットから任意の3つのエッジを選択して形成できる鋭角三角形の数を数えます。\n\nパラメータ:\n- edges_count (number): エッジの数。\n- edges (...number): エッジの長さ。\n\n戻り値:\n- number: 形成できる異なる鋭角三角形の数。\n\n例:\n- f_23(4, 1, 1, 1, 1) // returns 4", "ko": "JavaScript 함수를 작성하세요 `function f_23(edges_count, ...edges)` 다음 문제를 해결하기 위해:\n주어진 변의 집합에서 임의의 3개의 변을 선택하여 만들 수 있는 예각 삼각형의 수를 세십시오.\n\n매개변수:\n- edges_count (number): 변의 수.\n- edges (...number): 변의 길이.\n\n반환:\n- number: 만들 수 있는 서로 다른 예각 삼각형의 개수.\n\n예시:\n- f_23(4, 1, 1, 1, 1) // returns 4", "ml": "JavaScript ഫംഗ്ഷൻ `function f_23(edges_count, ...edges)` എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nഒരു നൽകിയ എഡ്ജുകളുടെ സെറ്റിൽ നിന്ന് ഏതെങ്കിലും 3 എഡ്ജുകൾ തിരഞ്ഞെടുക്കുന്നതിലൂടെ രൂപീകരിക്കാവുന്ന മൂർച്ചയുള്ള കോണുകളുള്ള ത്രികോണങ്ങളുടെ എണ്ണം എണ്ണുക.\n\nപാരാമീറ്ററുകൾ:\n- edges_count (number): എഡ്ജുകളുടെ എണ്ണം.\n- edges (...number): എഡ്ജുകളുടെ നീളങ്ങൾ.\n\nമടക്കിക്കൊടുക്കുന്നു:\n- number: രൂപീകരിക്കാവുന്ന വ്യത്യസ്തമായ മൂർച്ചയുള്ള കോണങ്ങളുള്ള ത്രികോണങ്ങളുടെ എണ്ണം.\n\nഉദാഹരണങ്ങൾ:\n- f_23(4, 1, 1, 1, 1) // 4 മടക്കിക്കൊടുക്കുന്നു", "fa": "یک تابع جاوااسکریپت `function f_23(edges_count, ...edges)` بنویسید تا مسئله زیر را حل کند:\nتعداد مثلث‌های تیزگوشه‌ای که می‌توان با انتخاب هر ۳ ضلع از مجموعه‌ای از اضلاع تشکیل داد را بشمارید.\n\nپارامترها:\n- edges_count (number): تعداد اضلاع.\n- edges (...number): طول اضلاع.\n\nبازمی‌گرداند:\n- number: تعداد مثلث‌های تیزگوشه متمایزی که می‌توان تشکیل داد.\n\nمثال‌ها:\n- f_23(4, 1, 1, 1, 1) // مقدار 4 را برمی‌گرداند"}, "level": "hard", "test": "(function testf_23() {\n    console.assert(f_23(4, 1, 1, 1, 1) === 4, \"Test case 1 failed\");\n    console.assert(f_23(3, 1, 2, 3) === 0, \"Test case 2 failed\");\n    // Additional tests to ensure correctness\n    console.assert(f_23(5, 3, 4, 5, 7, 10) === 0, \"Test case 3 failed\");\n    console.assert(f_23(6, 6, 8, 10, 5, 5, 5) === 4, \"Test case 4 failed\");\n})();", "entry_point": "f_23", "signature": "function f_23(edges_count, ...edges)", "docstring": {"en": "Count the number of acute-angled triangles that can be formed by selecting any 3 edges out of a given set of edges.\n\nParameters:\n- edges_count (number): The number of edges.\n- edges (...number): The lengths of the edges.\n\nReturns:\n- number: The count of distinct acute-angled triangles that can be formed.\n\nExamples:\n- f_23(4, 1, 1, 1, 1) // returns 4\n", "sq": "Numëroni numrin e trekëndëshave me kënd të mprehtë që mund të formohen duke zgjedhur çdo 3 brinjë nga një grup i dhënë brinjësh.\n\nParametrat:\n- edges_count (numër): Numri i brinjëve.\n- edges (...numër): Gjatësitë e brinjëve.\n\nKthen:\n- numër: Numri i trekëndëshave të ndryshëm me kënd të mprehtë që mund të formohen.\n\nShembuj:\n- f_23(4, 1, 1, 1, 1) // kthen 4", "hy": "Հաշվել սուր անկյուն ունեցող եռանկյունիների քանակը, որոնք կարող են կազմվել տրված եզրերից ցանկացած 3-ը ընտրելով:\n\nՊարամետրեր:\n- edges_count (number): Եզրերի քանակը:\n- edges (...number): Եզրերի երկարությունները:\n\nՎերադարձնում է:\n- number: Տարբեր սուր անկյուն ունեցող եռանկյունիների քանակը, որոնք կարող են կազմվել:\n\nՕրինակներ:\n- f_23(4, 1, 1, 1, 1) // վերադարձնում է 4", "bn": "তিনটি প্রান্ত নির্বাচন করে প্রদত্ত প্রান্তগুলির সেট থেকে কতগুলি তীক্ষ্ণ-কোণযুক্ত ত্রিভুজ গঠন করা যায় তা গণনা করুন।\n\nপ্যারামিটারসমূহ:\n- edges_count (number): প্রান্তগুলির সংখ্যা।\n- edges (...number): প্রান্তগুলির দৈর্ঘ্য।\n\nরিটার্নস:\n- number: ভিন্ন তীক্ষ্ণ-কোণযুক্ত ত্রিভুজের সংখ্যা যা গঠন করা যেতে পারে।\n\nউদাহরণসমূহ:\n- f_23(4, 1, 1, 1, 1) // 4 রিটার্ন করে", "bg": "Бройте броя на остроъгълните триъгълници, които могат да бъдат образувани чрез избиране на произволни 3 ръба от даден набор от ръбове.\n\nПараметри:\n- edges_count (number): Броят на ръбовете.\n- edges (...number): Дължините на ръбовете.\n\nВръща:\n- number: Броят на различните остроъгълни триъгълници, които могат да бъдат образувани.\n\nПримери:\n- f_23(4, 1, 1, 1, 1) // връща 4", "zh": "计算可以通过从给定的一组边中选择任意3条边形成的锐角三角形的数量。\n\n参数：\n- edges_count (number): 边的数量。\n- edges (...number): 边的长度。\n\n返回：\n- number: 可以形成的不同锐角三角形的数量。\n\n示例：\n- f_23(4, 1, 1, 1, 1) // 返回 4", "fr": "Compter le nombre de triangles acutangles qui peuvent être formés en sélectionnant n'importe quels 3 côtés parmi un ensemble donné de côtés.\n\nParamètres :\n- edges_count (nombre) : Le nombre de côtés.\n- edges (...nombre) : Les longueurs des côtés.\n\nRenvoie :\n- nombre : Le nombre de triangles acutangles distincts qui peuvent être formés.\n\nExemples :\n- f_23(4, 1, 1, 1, 1) // renvoie 4", "de": "Zähle die Anzahl der spitzwinkligen Dreiecke, die gebildet werden können, indem beliebige 3 Kanten aus einem gegebenen Satz von Kanten ausgewählt werden.\n\nParameter:\n- edges_count (number): Die Anzahl der Kanten.\n- edges (...number): Die Längen der Kanten.\n\nRückgabewerte:\n- number: Die Anzahl der unterschiedlichen spitzwinkligen Dreiecke, die gebildet werden können.\n\nBeispiele:\n- f_23(4, 1, 1, 1, 1) // gibt 4 zurück", "ha": "Kirga yawan kusurwoyi masu kaifi da za a iya samarwa ta hanyar zaɓar kowane 3 daga cikin wani saiti na gefun.\n\nSigogi:\n- edges_count (number): Yawan gefuna.\n- edges (...number): Tsawon gefuna.\n\nDawowa:\n- number: Yawan daban-daban na triangles masu kusurwa masu kaifi da za a iya samarwa.\n\nMisalai:\n- f_23(4, 1, 1, 1, 1) // yana dawowa 4", "hi": "तीव्र कोण वाले त्रिभुजों की संख्या गिनें जो किन्हीं 3 किनारों का चयन करके दिए गए किनारों के सेट से बनाए जा सकते हैं।\n\nपैरामीटर्स:\n- edges_count (संख्या): किनारों की संख्या।\n- edges (...संख्या): किनारों की लंबाई।\n\nवापसी:\n- संख्या: विशिष्ट तीव्र कोण वाले त्रिभुजों की संख्या जो बनाई जा सकती है।\n\nउदाहरण:\n- f_23(4, 1, 1, 1, 1) // 4 लौटाता है", "hu": "Számolja meg a hegyesszögű háromszögek számát, amelyek kialakíthatók bármely 3 él kiválasztásával egy adott élsorozatból.\n\nParaméterek:\n- edges_count (szám): Az élek száma.\n- edges (...szám): Az élek hossza.\n\nVisszatér:\n- szám: Az egyedi hegyesszögű háromszögek száma, amelyek kialakíthatók.\n\nPéldák:\n- f_23(4, 1, 1, 1, 1) // visszaadja 4", "es": "Cuenta el número de triángulos acutángulos que se pueden formar seleccionando cualquier 3 lados de un conjunto dado de lados.\n\nParámetros:\n- edges_count (número): El número de lados.\n- edges (...número): Las longitudes de los lados.\n\nDevuelve:\n- número: La cantidad de triángulos acutángulos distintos que se pueden formar.\n\nEjemplos:\n- f_23(4, 1, 1, 1, 1) // devuelve 4", "arb": "احسب عدد المثلثات الحادة الزاوية التي يمكن تشكيلها عن طريق اختيار أي 3 أضلاع من مجموعة الأضلاع المعطاة.\n\nالمعطيات:\n- edges_count (عدد): عدد الأضلاع.\n- edges (...عدد): أطوال الأضلاع.\n\nالقيم المعادة:\n- عدد: عدد المثلثات الحادة الزاوية المختلفة التي يمكن تشكيلها.\n\nأمثلة:\n- f_23(4, 1, 1, 1, 1) // يعيد 4", "sw": "Hesabu idadi ya pembetatu zenye pembe kali ambazo zinaweza kuundwa kwa kuchagua pande 3 zozote kutoka kwenye seti iliyotolewa ya pande.\n\nVigezo:\n- edges_count (nambari): Idadi ya pande.\n- edges (...nambari): Urefu wa pande.\n\nInarejesha:\n- nambari: Idadi ya pembetatu tofauti zenye pembe kali ambazo zinaweza kuundwa.\n\nMifano:\n- f_23(4, 1, 1, 1, 1) // inarejesha 4", "tr": "Verilen bir kenar kümesinden herhangi bir 3 kenar seçilerek oluşturulabilecek dik açılı olmayan üçgenlerin sayısını sayın.\n\nParametreler:\n- edges_count (number): Kenarların sayısı.\n- edges (...number): Kenarların uzunlukları.\n\nDöndürür:\n- number: Oluşturulabilecek farklı dik açılı olmayan üçgenlerin sayısı.\n\nÖrnekler:\n- f_23(4, 1, 1, 1, 1) // 4 döndürür", "vi": "Đếm số lượng tam giác nhọn có thể được tạo thành bằng cách chọn bất kỳ 3 cạnh nào từ một tập hợp các cạnh đã cho.\n\nTham số:\n- edges_count (number): Số lượng cạnh.\n- edges (...number): Độ dài của các cạnh.\n\nTrả về:\n- number: Số lượng tam giác nhọn khác nhau có thể được tạo thành.\n\nVí dụ:\n- f_23(4, 1, 1, 1, 1) // trả về 4", "id": "Hitung jumlah segitiga lancip yang dapat dibentuk dengan memilih 3 sisi dari sekumpulan sisi yang diberikan.\n\nParameter:\n- edges_count (number): Jumlah sisi.\n- edges (...number): Panjang sisi-sisi.\n\nMengembalikan:\n- number: Jumlah segitiga lancip yang berbeda yang dapat dibentuk.\n\nContoh:\n- f_23(4, 1, 1, 1, 1) // mengembalikan 4", "ja": "鋭角三角形を形成できる、与えられたエッジの集合から任意の3つのエッジを選択する方法の数を数えます。\n\n引数:\n- edges_count (number): エッジの数。\n- edges (...number): エッジの長さ。\n\n戻り値:\n- number: 形成できる異なる鋭角三角形の数。\n\n例:\n- f_23(4, 1, 1, 1, 1) // 4を返します。", "ko": "주어진 모서리 집합에서 임의의 3개의 모서리를 선택하여 형성할 수 있는 예각 삼각형의 수를 계산합니다.\n\n매개변수:\n- edges_count (number): 모서리의 수.\n- edges (...number): 모서리의 길이들.\n\n반환:\n- number: 형성할 수 있는 서로 다른 예각 삼각형의 개수.\n\n예시:\n- f_23(4, 1, 1, 1, 1) // 4를 반환합니다.", "ml": "നൽകിയ ഒരു സെറ്റ് എഡ്ജുകളിൽ നിന്ന് ഏതെങ്കിലും 3 എഡ്ജുകൾ തിരഞ്ഞെടുക്കുന്നതിലൂടെ രൂപീകരിക്കാവുന്ന മൂർച്ചയുള്ള കോണുകളുള്ള ത്രികോണങ്ങളുടെ എണ്ണം എണ്ണുക.\n\nപാരാമീറ്ററുകൾ:\n- edges_count (number): അരികുകളുടെ എണ്ണം.\n- edges (...number): അരികുകളുടെ നീളങ്ങൾ.\n\nമടക്കം:\n- number: രൂപീകരിക്കാവുന്ന വ്യത്യസ്തമായ മൂർച്ചയുള്ള ത്രികോണങ്ങളുടെ എണ്ണം.\n\nഉദാഹരണങ്ങൾ:\n- f_23(4, 1, 1, 1, 1) // 4 മടക്കുന്നു", "fa": "تعداد مثلث‌های تیزگوشه‌ای که می‌توان با انتخاب هر 3 ضلع از مجموعه‌ای از اضلاع تشکیل داد را بشمارید.\n\nپارامترها:\n- edges_count (number): تعداد اضلاع.\n- edges (...number): طول اضلاع.\n\nبازگشت:\n- number: تعداد مثلث‌های تیزگوشه متمایزی که می‌توان تشکیل داد.\n\nمثال‌ها:\n- f_23(4, 1, 1, 1, 1) // مقدار بازگشتی 4"}}
{"task_id": "JavaScript/24", "prompt": {"en": "/**\n * Reads an integer and a character, then returns them as a formatted string separated by a comma.\n * Parameters:\n * - integer_value (number): The input integer.\n * - char_value (string): The input character.\n * Returns:\n * - string: A string containing the integer and character separated by a comma.\n * Examples:\n * f_24(234, 'H') returns '234,H'\n */\nfunction f_24(integer_value, char_value)", "sq": "/**\n * Lexon një numër të plotë dhe një karakter, pastaj i kthen ato si një varg i formatuar i ndarë nga një presje.\n * Parametrat:\n * - integer_value (number): Numri i plotë i futur.\n * - char_value (string): Karakteri i futur.\n * Kthen:\n * - string: Një varg që përmban numrin e plotë dhe karakterin e ndarë nga një presje.\n * Shembuj:\n * f_24(234, 'H') kthen '234,H'\n */\nfunction f_24(integer_value, char_value)", "hy": "/**\n * Կարդում է ամբողջ թիվ և սիմվոլ, ապա վերադարձնում է դրանք ձևաչափված տողում, բաժանված ստորակետով։\n * Պարամետրեր:\n * - integer_value (number): Մուտքային ամբողջ թիվը։\n * - char_value (string): Մուտքային սիմվոլը։\n * Վերադարձնում է:\n * - string: Տող, որը պարունակում է ամբողջ թիվը և սիմվոլը, բաժանված ստորակետով։\n * Օրինակներ:\n * f_24(234, 'H') վերադարձնում է '234,H'\n */\nfunction f_24(integer_value, char_value)", "bn": "/**\n * একটি পূর্ণসংখ্যা এবং একটি অক্ষর পড়ে, তারপর সেগুলিকে কমা দ্বারা পৃথক করা একটি বিন্যাসিত স্ট্রিং হিসাবে ফেরত দেয়।\n * প্যারামিটার:\n * - integer_value (number): ইনপুট পূর্ণসংখ্যা।\n * - char_value (string): ইনপুট অক্ষর।\n * ফেরত দেয়:\n * - string: একটি স্ট্রিং যা পূর্ণসংখ্যা এবং অক্ষরকে কমা দ্বারা পৃথক করে।\n * উদাহরণ:\n * f_24(234, 'H') '234,H' ফেরত দেয়\n */\nfunction f_24(integer_value, char_value)", "bg": "/**\n * Чете цяло число и символ, след това ги връща като форматиран низ, разделен със запетая.\n * Параметри:\n * - integer_value (number): Входното цяло число.\n * - char_value (string): Входният символ.\n * Връща:\n * - string: Низ, съдържащ цялото число и символа, разделени със запетая.\n * Примери:\n * f_24(234, 'H') връща '234,H'\n */\nfunction f_24(integer_value, char_value)", "zh": "/**\n * 读取一个整数和一个字符，然后将它们作为用逗号分隔的格式化字符串返回。\n * 参数：\n * - integer_value (number): 输入的整数。\n * - char_value (string): 输入的字符。\n * 返回：\n * - string: 一个包含整数和字符并用逗号分隔的字符串。\n * 示例：\n * f_24(234, 'H') 返回 '234,H'\n */\nfunction f_24(integer_value, char_value)", "fr": "/**\n * Lit un entier et un caractère, puis les renvoie sous forme de chaîne formatée séparée par une virgule.\n * Paramètres :\n * - integer_value (number): L'entier d'entrée.\n * - char_value (string): Le caractère d'entrée.\n * Renvoie :\n * - string: Une chaîne contenant l'entier et le caractère séparés par une virgule.\n * Exemples :\n * f_24(234, 'H') returns '234,H'\n */\nfunction f_24(integer_value, char_value)", "de": "/**\n * Liest eine Ganzzahl und ein Zeichen ein und gibt sie dann als formatierte Zeichenkette getrennt durch ein Komma zurück.\n * Parameter:\n * - integer_value (number): Die Eingabeganzzahl.\n * - char_value (string): Das Eingabezeichen.\n * Rückgabewerte:\n * - string: Eine Zeichenkette, die die Ganzzahl und das Zeichen getrennt durch ein Komma enthält.\n * Beispiele:\n * f_24(234, 'H') gibt '234,H' zurück\n */\nfunction f_24(integer_value, char_value)", "ha": "/**\n * Karanta lamba mai cikakken adadi da wata alama, sannan ya mayar da su a matsayin wani tsari na rubutu da aka raba su da alamar kwalliya.\n * Sigogi:\n * - integer_value (number): Lambar da aka shigar.\n * - char_value (string): Alamar da aka shigar.\n * Mayarwa:\n * - string: Wani tsari na rubutu da ke dauke da lambar da alamar da aka raba su da alamar kwalliya.\n * Misalai:\n * f_24(234, 'H') returns '234,H'\n */\nfunction f_24(integer_value, char_value)", "hi": "/**\n * एक पूर्णांक और एक वर्ण पढ़ता है, फिर उन्हें अल्पविराम से अलग किए गए स्वरूपित स्ट्रिंग के रूप में लौटाता है।\n * पैरामीटर:\n * - integer_value (number): इनपुट पूर्णांक।\n * - char_value (string): इनपुट वर्ण।\n * लौटाता है:\n * - string: एक स्ट्रिंग जिसमें पूर्णांक और वर्ण अल्पविराम से अलग होते हैं।\n * उदाहरण:\n * f_24(234, 'H') '234,H' लौटाता है\n */\nfunction f_24(integer_value, char_value)", "hu": "/**\n * Beolvas egy egész számot és egy karaktert, majd formázott sztringként adja vissza őket vesszővel elválasztva.\n * Paraméterek:\n * - integer_value (number): A bemeneti egész szám.\n * - char_value (string): A bemeneti karakter.\n * Visszatérési érték:\n * - string: Egy sztring, amely az egész számot és a karaktert tartalmazza vesszővel elválasztva.\n * Példák:\n * f_24(234, 'H') visszaadja '234,H'\n */\nfunction f_24(integer_value, char_value)", "es": "/**\n * Lee un entero y un carácter, luego los devuelve como una cadena formateada separada por una coma.\n * Parámetros:\n * - integer_value (number): El entero de entrada.\n * - char_value (string): El carácter de entrada.\n * Devuelve:\n * - string: Una cadena que contiene el entero y el carácter separados por una coma.\n * Ejemplos:\n * f_24(234, 'H') devuelve '234,H'\n */\nfunction f_24(integer_value, char_value)", "arb": "/**\n * يقرأ عددًا صحيحًا وحرفًا، ثم يعيدهما كسلسلة منسقة مفصولة بفاصلة.\n * المعلمات:\n * - integer_value (number): العدد الصحيح المدخل.\n * - char_value (string): الحرف المدخل.\n * يعيد:\n * - string: سلسلة تحتوي على العدد الصحيح والحرف مفصولين بفاصلة.\n * أمثلة:\n * f_24(234, 'H') يعيد '234,H'\n */\nfunction f_24(integer_value, char_value)", "sw": "/**\n * Husoma nambari kamili na herufi, kisha inazirudisha kama kamba iliyopangwa ikitenganishwa na koma.\n * Vigezo:\n * - integer_value (number): Nambari kamili ya ingizo.\n * - char_value (string): Herufi ya ingizo.\n * Inarudisha:\n * - string: Kamba inayojumuisha nambari kamili na herufi ikitenganishwa na koma.\n * Mifano:\n * f_24(234, 'H') inarudisha '234,H'\n */\nfunction f_24(integer_value, char_value)", "tr": "/**\n * Bir tam sayı ve bir karakter okur, ardından bunları virgülle ayrılmış biçimlendirilmiş bir dize olarak döndürür.\n * Parametreler:\n * - integer_value (number): Girdi tam sayısı.\n * - char_value (string): Girdi karakteri.\n * Döndürür:\n * - string: Tam sayı ve karakteri virgülle ayrılmış bir dize olarak içeren bir dize.\n * Örnekler:\n * f_24(234, 'H') '234,H' döndürür\n */\nfunction f_24(integer_value, char_value)", "vi": "/**\n * Đọc một số nguyên và một ký tự, sau đó trả về chúng dưới dạng một chuỗi định dạng được phân tách bằng dấu phẩy.\n * Tham số:\n * - integer_value (number): Số nguyên đầu vào.\n * - char_value (string): Ký tự đầu vào.\n * Trả về:\n * - string: Một chuỗi chứa số nguyên và ký tự được phân tách bằng dấu phẩy.\n * Ví dụ:\n * f_24(234, 'H') trả về '234,H'\n */\nfunction f_24(integer_value, char_value)", "id": "/**\n * Membaca sebuah bilangan bulat dan sebuah karakter, kemudian mengembalikannya sebagai string yang diformat dipisahkan oleh koma.\n * Parameter:\n * - integer_value (number): Bilangan bulat yang dimasukkan.\n * - char_value (string): Karakter yang dimasukkan.\n * Mengembalikan:\n * - string: Sebuah string yang berisi bilangan bulat dan karakter yang dipisahkan oleh koma.\n * Contoh:\n * f_24(234, 'H') mengembalikan '234,H'\n */\nfunction f_24(integer_value, char_value)", "ja": "/**\n * 整数と文字を読み取り、それらをカンマで区切ったフォーマットされた文字列として返します。\n * パラメータ:\n * - integer_value (number): 入力された整数。\n * - char_value (string): 入力された文字。\n * 戻り値:\n * - string: 整数と文字をカンマで区切った文字列。\n * 例:\n * f_24(234, 'H') は '234,H' を返します\n */\nfunction f_24(integer_value, char_value)", "ko": "/**\n * 정수와 문자를 읽고, 쉼표로 구분된 형식의 문자열로 반환합니다.\n * 매개변수:\n * - integer_value (number): 입력 정수.\n * - char_value (string): 입력 문자.\n * 반환:\n * - string: 쉼표로 구분된 정수와 문자를 포함하는 문자열.\n * 예시:\n * f_24(234, 'H') returns '234,H'\n */\nfunction f_24(integer_value, char_value)", "ml": "/**\n * ഒരു പൂർണ്ണസംഖ്യയും ഒരു അക്ഷരവും വായിച്ച് അവയെ കോമയാൽ വേർതിരിച്ച ഫോർമാറ്റുചെയ്ത സ്ട്രിംഗായി തിരികെ നൽകുന്നു.\n * പാരാമീറ്ററുകൾ:\n * - integer_value (number): ഇൻപുട്ട് പൂർണ്ണസംഖ്യ.\n * - char_value (string): ഇൻപുട്ട് അക്ഷരം.\n * തിരികെ നൽകുന്നത്:\n * - string: കോമയാൽ വേർതിരിച്ച പൂർണ്ണസംഖ്യയും അക്ഷരവും അടങ്ങിയ ഒരു സ്ട്രിംഗ്.\n * ഉദാഹരണങ്ങൾ:\n * f_24(234, 'H') returns '234,H'\n */\nfunction f_24(integer_value, char_value)", "fa": "/**\n * یک عدد صحیح و یک کاراکتر را می‌خواند، سپس آن‌ها را به عنوان یک رشته قالب‌بندی شده با یک کاما جدا می‌کند.\n * پارامترها:\n * - integer_value (number): عدد صحیح ورودی.\n * - char_value (string): کاراکتر ورودی.\n * بازگشت:\n * - string: یک رشته حاوی عدد صحیح و کاراکتر که با یک کاما جدا شده‌اند.\n * مثال‌ها:\n * f_24(234, 'H') returns '234,H'\n */\nfunction f_24(integer_value, char_value)"}, "canonical_solution": "{\n    // Format the string\n    return `${integer_value},${char_value}`;\n}", "instruction": {"en": "Write a JavaScript function `function f_24(integer_value, char_value)` to solve the following problem:\nReads an integer and a character, then returns them as a formatted string separated by a comma.\nParameters:\n- integer_value (number): The input integer.\n- char_value (string): The input character.\nReturns:\n- string: A string containing the integer and character separated by a comma.\nExamples:\nf_24(234, 'H') returns '234,H'\n", "sq": "Shkruani një funksion JavaScript `function f_24(integer_value, char_value)` për të zgjidhur problemin e mëposhtëm:\nLexon një numër të plotë dhe një karakter, pastaj i kthen ato si një varg i formatuar i ndarë me presje.\nParametrat:\n- integer_value (number): Numri i plotë i dhënë.\n- char_value (string): Karakteri i dhënë.\nKthen:\n- string: Një varg që përmban numrin e plotë dhe karakterin e ndarë me presje.\nShembuj:\nf_24(234, 'H') kthen '234,H'", "hy": "Գրեք JavaScript ֆունկցիա `function f_24(integer_value, char_value)` լուծելու համար հետևյալ խնդիրը:\nԿարդում է ամբողջ թիվ և սիմվոլ, ապա վերադարձնում է դրանք ձևաչափված տողում, բաժանված ստորակետով։\nՊարամետրեր:\n- integer_value (number): Մուտքային ամբողջ թիվը։\n- char_value (string): Մուտքային սիմվոլը։\nՎերադարձնում է:\n- string: Տող, որը պարունակում է ամբողջ թիվը և սիմվոլը, բաժանված ստորակետով։\nՕրինակներ:\nf_24(234, 'H') վերադարձնում է '234,H'", "bn": "একটি জাভাস্ক্রিপ্ট ফাংশন `function f_24(integer_value, char_value)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি পূর্ণসংখ্যা এবং একটি অক্ষর পড়ে, তারপর সেগুলিকে একটি বিন্যাসিত স্ট্রিং হিসাবে কমা দ্বারা পৃথক করে ফেরত দেয়।\nপ্যারামিটারসমূহ:\n- integer_value (number): ইনপুট পূর্ণসংখ্যা।\n- char_value (string): ইনপুট অক্ষর।\nফেরত দেয়:\n- string: একটি স্ট্রিং যা পূর্ণসংখ্যা এবং অক্ষরকে কমা দ্বারা পৃথক করে ধারণ করে।\nউদাহরণসমূহ:\nf_24(234, 'H') returns '234,H'", "bg": "Напишете JavaScript функция `function f_24(integer_value, char_value)` за решаване на следния проблем:\nЧете цяло число и символ, след което ги връща като форматиран низ, разделен със запетая.\nПараметри:\n- integer_value (number): Входното цяло число.\n- char_value (string): Входният символ.\nВръща:\n- string: Низ, съдържащ числото и символа, разделени със запетая.\nПримери:\nf_24(234, 'H') връща '234,H'", "zh": "编写一个 JavaScript 函数 `function f_24(integer_value, char_value)` 来解决以下问题：\n读取一个整数和一个字符，然后将它们作为用逗号分隔的格式化字符串返回。\n参数：\n- integer_value (number): 输入的整数。\n- char_value (string): 输入的字符。\n返回：\n- string: 包含整数和字符并用逗号分隔的字符串。\n示例：\nf_24(234, 'H') 返回 '234,H'", "fr": "Écrire une fonction JavaScript `function f_24(integer_value, char_value)` pour résoudre le problème suivant :\nLit un entier et un caractère, puis les renvoie sous forme de chaîne formatée séparée par une virgule.\nParamètres :\n- integer_value (number): L'entier d'entrée.\n- char_value (string): Le caractère d'entrée.\nRenvoie :\n- string: Une chaîne contenant l'entier et le caractère séparés par une virgule.\nExemples :\nf_24(234, 'H') renvoie '234,H'", "de": "Schreiben Sie eine JavaScript-Funktion `function f_24(integer_value, char_value)`, um das folgende Problem zu lösen:\nLiest eine ganze Zahl und ein Zeichen und gibt sie dann als formatierte Zeichenkette, getrennt durch ein Komma, zurück.\nParameter:\n- integer_value (number): Die Eingabe-Ganzzahl.\n- char_value (string): Das Eingabe-Zeichen.\nGibt zurück:\n- string: Eine Zeichenkette, die die Ganzzahl und das Zeichen, getrennt durch ein Komma, enthält.\nBeispiele:\nf_24(234, 'H') gibt '234,H' zurück.", "ha": "Rubuta wani aikin JavaScript `function f_24(integer_value, char_value)` don magance matsalar mai zuwa:\nKaranta wani cikakken lamba da wata alama, sannan ya mayar da su a matsayin jeren haruffa da aka tsara da kwancewa ta hanyar alama.\nSigogi:\n- integer_value (number): Cikakken lambar shigarwa.\n- char_value (string): Alamar shigarwa.\nMayarwa:\n- string: Jeren haruffa da ke dauke da cikakken lamba da alama da aka raba ta hanyar alama.\nMisalai:\nf_24(234, 'H') returns '234,H'", "hi": "एक JavaScript फ़ंक्शन `function f_24(integer_value, char_value)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nएक पूर्णांक और एक वर्ण पढ़ता है, फिर उन्हें एक स्वरूपित स्ट्रिंग के रूप में अल्पविराम द्वारा अलग करके वापस करता है।\nपैरामीटर्स:\n- integer_value (number): इनपुट पूर्णांक।\n- char_value (string): इनपुट वर्ण।\nवापसी:\n- string: एक स्ट्रिंग जो पूर्णांक और वर्ण को अल्पविराम द्वारा अलग करके रखती है।\nउदाहरण:\nf_24(234, 'H') '234,H' लौटाता है।", "hu": "Írj egy JavaScript függvényt `function f_24(integer_value, char_value)` a következő probléma megoldására:\nBeolvas egy egész számot és egy karaktert, majd visszaadja őket egy formázott sztringként vesszővel elválasztva.\nParaméterek:\n- integer_value (number): A bemeneti egész szám.\n- char_value (string): A bemeneti karakter.\nVisszatérési érték:\n- string: Egy sztring, amely az egész számot és a karaktert tartalmazza vesszővel elválasztva.\nPéldák:\nf_24(234, 'H') visszaadja '234,H'", "es": "Escribe una función de JavaScript `function f_24(integer_value, char_value)` para resolver el siguiente problema:  \nLee un entero y un carácter, luego los devuelve como una cadena formateada separada por una coma.  \nParámetros:  \n- integer_value (number): El entero de entrada.  \n- char_value (string): El carácter de entrada.  \nDevuelve:  \n- string: Una cadena que contiene el entero y el carácter separados por una coma.  \nEjemplos:  \nf_24(234, 'H') devuelve '234,H'  ", "arb": "اكتب دالة JavaScript `function f_24(integer_value, char_value)` لحل المشكلة التالية:\nيقرأ عددًا صحيحًا وحرفًا، ثم يعيدهما كسلسلة نصية منسقة مفصولة بفاصلة.\nالمعلمات:\n- integer_value (number): العدد الصحيح المدخل.\n- char_value (string): الحرف المدخل.\nالقيم المعادة:\n- string: سلسلة نصية تحتوي على العدد الصحيح والحرف مفصولين بفاصلة.\nأمثلة:\nf_24(234, 'H') يعيد '234,H'", "sw": "Andika kazi ya JavaScript `function f_24(integer_value, char_value)` kutatua tatizo lifuatalo:  \nSoma nambari nzima na herufi, kisha zirudishe kama kamba iliyopangwa ikitenganishwa na koma.  \nVigezo:  \n- integer_value (number): Nambari nzima ya pembejeo.  \n- char_value (string): Herufi ya pembejeo.  \nRudisha:  \n- string: Kamba inayoambatana na nambari nzima na herufi ikitenganishwa na koma.  \nMifano:  \nf_24(234, 'H') inarudisha '234,H'  ", "tr": "Bir JavaScript fonksiyonu `function f_24(integer_value, char_value)` yazın:\nBir tam sayı ve bir karakter okur, ardından bunları virgülle ayrılmış biçimlendirilmiş bir dize olarak döndürür.\nParametreler:\n- integer_value (number): Girdi tam sayısı.\n- char_value (string): Girdi karakteri.\nDöndürülen:\n- string: Virgülle ayrılmış tam sayı ve karakter içeren bir dize.\nÖrnekler:\nf_24(234, 'H') '234,H' döndürür.", "vi": "Viết một hàm JavaScript `function f_24(integer_value, char_value)` để giải quyết vấn đề sau:\nĐọc một số nguyên và một ký tự, sau đó trả về chúng dưới dạng một chuỗi định dạng được ngăn cách bởi dấu phẩy.\nTham số:\n- integer_value (number): Số nguyên đầu vào.\n- char_value (string): Ký tự đầu vào.\nTrả về:\n- string: Một chuỗi chứa số nguyên và ký tự được ngăn cách bởi dấu phẩy.\nVí dụ:\nf_24(234, 'H') trả về '234,H'", "id": "Tulis sebuah fungsi JavaScript `function f_24(integer_value, char_value)` untuk menyelesaikan masalah berikut:\nMembaca sebuah bilangan bulat dan sebuah karakter, kemudian mengembalikannya sebagai string yang diformat dipisahkan oleh koma.\nParameter:\n- integer_value (number): Bilangan bulat masukan.\n- char_value (string): Karakter masukan.\nMengembalikan:\n- string: Sebuah string yang berisi bilangan bulat dan karakter dipisahkan oleh koma.\nContoh:\nf_24(234, 'H') mengembalikan '234,H'", "ja": "JavaScript関数`function f_24(integer_value, char_value)`を作成して、次の問題を解決してください。  \n整数と文字を読み取り、それらをカンマで区切ったフォーマットされた文字列として返します。  \nパラメータ:  \n- integer_value (number): 入力される整数。  \n- char_value (string): 入力される文字。  \n戻り値:  \n- string: 整数と文字をカンマで区切った文字列。  \n例:  \nf_24(234, 'H') は '234,H' を返します。  ", "ko": "JavaScript 함수를 작성하세요 `function f_24(integer_value, char_value)` 다음 문제를 해결하기 위해:\n정수와 문자를 읽은 다음 쉼표로 구분된 형식의 문자열로 반환합니다.\n매개변수:\n- integer_value (number): 입력 정수.\n- char_value (string): 입력 문자.\n반환:\n- string: 쉼표로 구분된 정수와 문자를 포함하는 문자열.\n예시:\nf_24(234, 'H') returns '234,H'", "ml": "ഒരു ജാവാസ്ക്രിപ്റ്റ് ഫംഗ്ഷൻ `function f_24(integer_value, char_value)` എഴുതുക താഴെ കൊടുത്തിരിക്കുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nഒരു പൂർണ്ണസംഖ്യയും ഒരു പ്രതീകവും വായിച്ച്, അവയെ കോമയാൽ വേർതിരിച്ച ഫോർമാറ്റ് ചെയ്ത ഒരു സ്ട്രിംഗ് രൂപത്തിൽ തിരിച്ചുനൽകുന്നു.\nപാരാമീറ്ററുകൾ:\n- integer_value (number): ഇൻപുട്ട് പൂർണ്ണസംഖ്യ.\n- char_value (string): ഇൻപുട്ട് പ്രതീകം.\nമടക്കുനത്:\n- string: പൂർണ്ണസംഖ്യയും പ്രതീകവും കോമയാൽ വേർതിരിച്ച ഒരു സ്ട്രിംഗ്.\nഉദാഹരണങ്ങൾ:\nf_24(234, 'H') '234,H' മടക്കുന്നു", "fa": "یک تابع JavaScript بنویسید `function f_24(integer_value, char_value)` برای حل مشکل زیر:\nیک عدد صحیح و یک کاراکتر را می‌خواند، سپس آن‌ها را به عنوان یک رشته قالب‌بندی شده که با کاما جدا شده‌اند، برمی‌گرداند.\nپارامترها:\n- integer_value (number): عدد صحیح ورودی.\n- char_value (string): کاراکتر ورودی.\nبرمی‌گرداند:\n- string: یک رشته که شامل عدد صحیح و کاراکتر با یک کاما جدا شده است.\nمثال‌ها:\nf_24(234, 'H') returns '234,H'"}, "level": "easy", "test": "const testf_24 = () => {\n    console.assert(f_24(234, 'H') === '234,H', 'Test 1 Failed');\n    console.assert(f_24(123, 'A') === '123,A', 'Test 2 Failed');\n    console.assert(f_24(0, 'Z') === '0,Z', 'Test 3 Failed');\n}\n\ntestf_24();", "entry_point": "f_24", "signature": "function f_24(integer_value, char_value)", "docstring": {"en": "Reads an integer and a character, then returns them as a formatted string separated by a comma.\nParameters:\n- integer_value (number): The input integer.\n- char_value (string): The input character.\nReturns:\n- string: A string containing the integer and character separated by a comma.\nExamples:\nf_24(234, 'H') returns '234,H'\n", "sq": "Lexon një numër të plotë dhe një karakter, pastaj i kthen ato si një varg i formatuar i ndarë nga një presje.\nParametrat:\n- integer_value (number): Numri i plotë i futur.\n- char_value (string): Karakteri i futur.\nKthen:\n- string: Një varg që përmban numrin e plotë dhe karakterin e ndarë nga një presje.\nShembuj:\nf_24(234, 'H') kthen '234,H'", "hy": "Կարդում է ամբողջ թիվ և սիմվոլ, ապա վերադարձնում է դրանք որպես ձևաչափված տող, որը բաժանված է ստորակետով։\nՊարամետրեր:\n- integer_value (number): Մուտքագրված ամբողջ թիվը։\n- char_value (string): Մուտքագրված սիմվոլը։\nՎերադարձնում է:\n- string: Տող, որը պարունակում է ամբողջ թիվը և սիմվոլը, բաժանված ստորակետով։\nՕրինակներ:\nf_24(234, 'H') վերադարձնում է '234,H'", "bn": "একটি পূর্ণসংখ্যা এবং একটি অক্ষর পড়ে, তারপর সেগুলিকে একটি বিন্যাসিত স্ট্রিং হিসাবে কমা দ্বারা পৃথক করে ফেরত দেয়।\nপ্যারামিটারসমূহ:  \n- integer_value (number): ইনপুট পূর্ণসংখ্যা।  \n- char_value (string): ইনপুট অক্ষর।  \nReturns:  \n- string: একটি স্ট্রিং যা পূর্ণসংখ্যা এবং অক্ষরকে কমা দ্বারা পৃথক করে।  \nExamples:  \nf_24(234, 'H') returns '234,H'  ", "bg": "Чете цяло число и символ, след което ги връща като форматиран низ, разделен със запетая.\nПараметри:\n- integer_value (number): Входното цяло число.\n- char_value (string): Входният символ.\nВръща:\n- string: Низ, съдържащ цялото число и символа, разделени със запетая.\nПримери:\nf_24(234, 'H') връща '234,H'", "zh": "读取一个整数和一个字符，然后将它们作为用逗号分隔的格式化字符串返回。\n参数：\n- integer_value (number): 输入的整数。\n- char_value (string): 输入的字符。\n返回：\n- string: 一个包含整数和字符并用逗号分隔的字符串。\n示例：\nf_24(234, 'H') 返回 '234,H'", "fr": "Lit un entier et un caractère, puis les renvoie sous forme de chaîne formatée séparée par une virgule.\nParamètres :\n- integer_value (number): L'entier d'entrée.\n- char_value (string): Le caractère d'entrée.\nRenvoie :\n- string: Une chaîne contenant l'entier et le caractère séparés par une virgule.\nExemples :\nf_24(234, 'H') renvoie '234,H'", "de": "Liest eine ganze Zahl und ein Zeichen und gibt sie dann als formatierten String zurück, getrennt durch ein Komma.\nParameter:\n- integer_value (number): Die Eingabe-Ganzzahl.\n- char_value (string): Das Eingabe-Zeichen.\nRückgabewert:\n- string: Ein String, der die Ganzzahl und das Zeichen durch ein Komma getrennt enthält.\nBeispiele:\nf_24(234, 'H') gibt '234,H' zurück.", "ha": "Karanta wata lamba da wata alama, sannan ya mayar da su a matsayin kirtani mai tsari wanda aka raba da alamar kwafi.\nSigogi:\n- integer_value (number): Lambar shigarwa.\n- char_value (string): Alamar shigarwa.\nDawowa:\n- string: Wani kirtani da ke dauke da lambar da alamar da aka raba da alamar kwafi.\nMisalai:\nf_24(234, 'H') yana dawowa '234,H'", "hi": "एक पूर्णांक और एक वर्ण पढ़ता है, फिर उन्हें एक स्वरूपित स्ट्रिंग के रूप में अल्पविराम द्वारा अलग करके वापस करता है।\nपैरामीटरs:  \n- integer_value (number): इनपुट पूर्णांक।  \n- char_value (string): इनपुट वर्ण।  \nReturns:  \n- string: एक स्ट्रिंग जो पूर्णांक और वर्ण को अल्पविराम से अलग करके रखती है।  \nExamples:  \nf_24(234, 'H') returns '234,H'  ", "hu": "Beolvas egy egész számot és egy karaktert, majd visszaadja őket egy formázott, vesszővel elválasztott karakterláncként.\nParaméterek:\n- integer_value (number): A bemeneti egész szám.\n- char_value (string): A bemeneti karakter.\nVisszatérési érték:\n- string: Egy karakterlánc, amely az egész számot és a karaktert vesszővel elválasztva tartalmazza.\nPéldák:\nf_24(234, 'H') visszaadja '234,H'", "es": "Lee un entero y un carácter, luego los devuelve como una cadena formateada separada por una coma.\nParámetros:\n- integer_value (number): El entero de entrada.\n- char_value (string): El carácter de entrada.\nDevuelve:\n- string: Una cadena que contiene el entero y el carácter separados por una coma.\nEjemplos:\nf_24(234, 'H') devuelve '234,H'", "arb": "يقرأ عددًا صحيحًا وحرفًا، ثم يعيدهما كسلسلة منسقة مفصولة بفاصلة.\nالمعلمات:\n- integer_value (number): العدد الصحيح المدخل.\n- char_value (string): الحرف المدخل.\nالقيم المعادة:\n- string: سلسلة تحتوي على العدد الصحيح والحرف مفصولين بفاصلة.\nأمثلة:\nf_24(234, 'H') يعيد '234,H'", "sw": "Husoma nambari kamili na herufi, kisha inazirudisha kama mfuatano wa maandishi uliopangwa ukiwa umetenganishwa na koma.  \nVigezo:  \n- integer_value (nambari): Nambari kamili ya ingizo.  \n- char_value (kamba): Herufi ya ingizo.  \nInarejesha:  \n- kamba: Mfuatano wa maandishi unao na nambari kamili na herufi zikitenganishwa na koma.  \nMifano:  \nf_24(234, 'H') inarejesha '234,H'  ", "tr": "Bir tam sayı ve bir karakter okur, ardından bunları virgülle ayrılmış biçimlendirilmiş bir dize olarak döndürür.\nParametreler:\n- integer_value (number): Girdi tam sayısı.\n- char_value (string): Girdi karakteri.\nDöndürülenler:\n- string: Tam sayı ve karakteri virgülle ayırarak içeren bir dize.\nÖrnekler:\nf_24(234, 'H') '234,H' döndürür.", "vi": "Đọc một số nguyên và một ký tự, sau đó trả về chúng dưới dạng một chuỗi định dạng cách nhau bởi dấu phẩy.  \nTham số:  \n- integer_value (number): Số nguyên đầu vào.  \n- char_value (string): Ký tự đầu vào.  \nTrả về:  \n- string: Một chuỗi chứa số nguyên và ký tự cách nhau bởi dấu phẩy.  \nVí dụ:  \nf_24(234, 'H') trả về '234,H'  ", "id": "Membaca sebuah bilangan bulat dan sebuah karakter, kemudian mengembalikannya sebagai string yang diformat dipisahkan oleh koma.\nParameter:\n- integer_value (number): Bilangan bulat yang dimasukkan.\n- char_value (string): Karakter yang dimasukkan.\nMengembalikan:\n- string: Sebuah string yang berisi bilangan bulat dan karakter yang dipisahkan oleh koma.\nContoh:\nf_24(234, 'H') mengembalikan '234,H'", "ja": "整数と文字を読み取り、それらをカンマで区切った形式の文字列として返します。\nパラメータ:\n- integer_value (number): 入力された整数。\n- char_value (string): 入力された文字。\n戻り値:\n- string: 整数と文字をカンマで区切った文字列。\n例:\nf_24(234, 'H') は '234,H' を返します。", "ko": "정수와 문자를 읽은 후, 쉼표로 구분된 형식의 문자열로 반환합니다.  \n매개변수:  \n- integer_value (number): 입력 정수.  \n- char_value (string): 입력 문자.  \n반환:  \n- string: 쉼표로 구분된 정수와 문자를 포함하는 문자열.  \n예제:  \nf_24(234, 'H') returns '234,H'  ", "ml": "ഒരു പൂർണ്ണസംഖ്യയും ഒരു അക്ഷരവും വായിച്ച് അവയെ കോമയാൽ വേർതിരിച്ച ഫോർമാറ്റുചെയ്ത സ്ട്രിംഗായി തിരികെ നൽകുന്നു.  \nപരാമീറ്ററുകൾ:  \n- integer_value (number): ഇൻപുട്ട് പൂർണ്ണസംഖ്യ.  \n- char_value (string): ഇൻപുട്ട് അക്ഷരം.  \nമടക്കുന്നു:  \n- string: പൂർണ്ണസംഖ്യയും അക്ഷരവും കോമയാൽ വേർതിരിച്ച് ഉൾക്കൊള്ളുന്ന ഒരു സ്ട്രിംഗ്.  \nഉദാഹരണങ്ങൾ:  \nf_24(234, 'H') '234,H' മടക്കുന്നു.  ", "fa": "یک عدد صحیح و یک کاراکتر را می‌خواند، سپس آن‌ها را به عنوان یک رشته قالب‌بندی شده با یک کاما جدا می‌کند.  \nپارامترها:  \n- integer_value (number): عدد صحیح ورودی.  \n- char_value (string): کاراکتر ورودی.  \nبازگشت:  \n- string: یک رشته که شامل عدد صحیح و کاراکتر است و با یک کاما جدا شده‌اند.  \nمثال‌ها:  \nf_24(234, 'H') returns '234,H'  "}}
{"task_id": "JavaScript/25", "prompt": {"en": "/**\n * Shifts all characters by 5 positions in alphabetical order.\n * Only letters are replaced, and all letters are in uppercase.\n *\n * @param {string} text The input text to be processed.\n * @returns {string} The transformed text with characters shifted by 5 positions.\n *\n * @example\n * f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n * // returns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n */\nfunction f_25(text)", "sq": "/**\n * Zhvendos të gjitha karakteret me 5 pozicione në rend alfabetik.\n * Vetëm shkronjat zëvendësohen, dhe të gjitha shkronjat janë me shkronja të mëdha.\n *\n * @param {string} text Teksti hyrës që do të përpunohet.\n * @returns {string} Teksti i transformuar me karaktere të zhvendosura me 5 pozicione.\n *\n * @example\n * f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n * // returns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n */\nfunction f_25(text)", "hy": "/**\n * Տեղափոխում է բոլոր նիշերը 5 դիրքով այբբենական կարգով:\n * Միայն տառերն են փոխարինվում, և բոլոր տառերը մեծատառ են:\n *\n * @param {string} text Մուտքային տեքստը, որը պետք է մշակվի:\n * @returns {string} Փոխակերպված տեքստը՝ նիշերը տեղափոխված 5 դիրքով:\n *\n * @example\n * f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n * // returns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n */\nfunction f_25(text)", "bn": "/**\n * বর্ণানুক্রমিক ক্রমে সমস্ত অক্ষরকে ৫ অবস্থানে সরিয়ে দেয়।\n * শুধুমাত্র অক্ষরগুলি প্রতিস্থাপিত হয়, এবং সমস্ত অক্ষর বড় হাতের হয়।\n *\n * @param {string} text প্রক্রিয়াকরণের জন্য ইনপুট টেক্সট।\n * @returns {string} রূপান্তরিত টেক্সট যা অক্ষরগুলি ৫ অবস্থানে সরানো হয়েছে।\n *\n * @example\n * f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n * // returns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n */\nfunction f_25(text)", "bg": "/**\n * Премества всички символи с 5 позиции в азбучен ред.\n * Само буквите се заменят, и всички букви са с главни букви.\n *\n * @param {string} text Входният текст, който ще бъде обработен.\n * @returns {string} Преобразуваният текст със символи, преместени с 5 позиции.\n *\n * @example\n * f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n * // returns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n */\nfunction f_25(text)", "zh": "/**\n * 将所有字符按字母顺序移动5个位置。\n * 只有字母被替换，并且所有字母都是大写。\n *\n * @param {string} text 要处理的输入文本。\n * @returns {string} 字符移动5个位置后的转换文本。\n *\n * @example\n * f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n * // returns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n */\nfunction f_25(text)", "fr": "/**\n * Décale tous les caractères de 5 positions dans l'ordre alphabétique.\n * Seules les lettres sont remplacées, et toutes les lettres sont en majuscules.\n *\n * @param {string} text Le texte d'entrée à traiter.\n * @returns {string} Le texte transformé avec les caractères décalés de 5 positions.\n *\n * @example\n * f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n * // returns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n */\nfunction f_25(text)", "de": "/**\n * Verschiebt alle Zeichen um 5 Positionen in alphabetischer Reihenfolge.\n * Nur Buchstaben werden ersetzt, und alle Buchstaben sind in Großbuchstaben.\n *\n * @param {string} text Der Eingabetext, der verarbeitet werden soll.\n * @returns {string} Der transformierte Text mit um 5 Positionen verschobenen Zeichen.\n *\n * @example\n * f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n * // returns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n */\nfunction f_25(text)", "ha": "/**\n * Canza duk haruffa ta wurin matsar da su wurare 5 a cikin tsarin haruffa.\n * Sai dai haruffa ne kawai za a maye gurbin, kuma duk haruffa suna cikin manyan baƙaƙe.\n *\n * @param {string} text Rubutun shigar da za a sarrafa.\n * @returns {string} Rubutun da aka sauya tare da haruffa da aka matsar da su wurare 5.\n *\n * @example\n * f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n * // returns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n */\nfunction f_25(text)", "hi": "/**\n * वर्णमाला क्रम में सभी वर्णों को 5 स्थानों से स्थानांतरित करता है।\n * केवल अक्षरों को बदला जाता है, और सभी अक्षर बड़े अक्षरों में होते हैं।\n *\n * @param {string} text वह इनपुट पाठ जिसे संसाधित किया जाना है।\n * @returns {string} परिवर्तित पाठ जिसमें वर्ण 5 स्थानों से स्थानांतरित होते हैं।\n *\n * @example\n * f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n * // returns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n */\nfunction f_25(text)", "hu": "/**\n * Az összes karaktert 5 pozícióval eltolja az ábécé sorrendjében.\n * Csak a betűk kerülnek cserére, és minden betű nagybetűs.\n *\n * @param {string} text A feldolgozandó bemeneti szöveg.\n * @returns {string} Az átalakított szöveg, amelyben a karakterek 5 pozícióval eltolódtak.\n *\n * @example\n * f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n * // returns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n */\nfunction f_25(text)", "es": "/**\n * Desplaza todos los caracteres 5 posiciones en orden alfabético.\n * Solo se reemplazan las letras, y todas las letras están en mayúsculas.\n *\n * @param {string} text El texto de entrada a ser procesado.\n * @returns {string} El texto transformado con caracteres desplazados 5 posiciones.\n *\n * @example\n * f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n * // devuelve \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n */\nfunction f_25(text)", "arb": "/**\n * يحرك جميع الأحرف بمقدار 5 مواقع في الترتيب الأبجدي.\n * يتم استبدال الحروف فقط، وجميع الحروف تكون بأحرف كبيرة.\n *\n * @param {string} text النص المدخل ليتم معالجته.\n * @returns {string} النص المحول مع الأحرف المحركة بمقدار 5 مواقع.\n *\n * @example\n * f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n * // يعيد \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n */\nfunction f_25(text)", "sw": "/**\n * Inahamisha herufi zote kwa nafasi 5 katika mpangilio wa alfabeti.\n * Ni herufi pekee zinabadilishwa, na herufi zote ni kubwa.\n *\n * @param {string} text Maandishi ya kuingiza yanayopaswa kushughulikiwa.\n * @returns {string} Maandishi yaliyobadilishwa na herufi zilizohamishwa kwa nafasi 5.\n *\n * @example\n * f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n * // inarudisha \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n */\nfunction f_25(text)", "tr": "/**\n * Tüm karakterleri alfabetik sırada 5 pozisyon kaydırır.\n * Yalnızca harfler değiştirilir ve tüm harfler büyük harfle yazılır.\n *\n * @param {string} text İşlenecek giriş metni.\n * @returns {string} Karakterlerin 5 pozisyon kaydırıldığı dönüştürülmüş metin.\n *\n * @example\n * f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n * // döndürür \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n */\nfunction f_25(text)", "vi": "/**\n * Dịch chuyển tất cả các ký tự 5 vị trí theo thứ tự bảng chữ cái.\n * Chỉ các chữ cái được thay thế, và tất cả các chữ cái đều ở dạng chữ hoa.\n *\n * @param {string} text Văn bản đầu vào cần được xử lý.\n * @returns {string} Văn bản đã được biến đổi với các ký tự dịch chuyển 5 vị trí.\n *\n * @example\n * f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n * // trả về \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n */\nfunction f_25(text)", "id": "/**\n * Menggeser semua karakter sebanyak 5 posisi dalam urutan alfabet.\n * Hanya huruf yang diganti, dan semua huruf dalam huruf besar.\n *\n * @param {string} text Teks input yang akan diproses.\n * @returns {string} Teks yang telah diubah dengan karakter digeser sebanyak 5 posisi.\n *\n * @example\n * f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n * // returns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n */\nfunction f_25(text)", "ja": "/**\n * すべての文字をアルファベット順で5つの位置ずらします。\n * 文字のみが置き換えられ、すべての文字は大文字です。\n *\n * @param {string} text 処理される入力テキスト。\n * @returns {string} 文字が5つの位置ずらされた変換されたテキスト。\n *\n * @example\n * f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n * // returns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n */\nfunction f_25(text)", "ko": "/**\n * 모든 문자를 알파벳 순서로 5자리 이동시킵니다.\n * 문자만 대체되며, 모든 문자는 대문자입니다.\n *\n * @param {string} text 처리할 입력 텍스트입니다.\n * @returns {string} 문자가 5자리 이동된 변환된 텍스트입니다.\n *\n * @example\n * f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n * // returns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n */\nfunction f_25(text)", "ml": "/**\n * എല്ലാ അക്ഷരങ്ങളും അക്ഷരമാലയിലെ 5 സ്ഥാനങ്ങൾ മാറ്റുന്നു.\n * അക്ഷരങ്ങൾ മാത്രമേ മാറ്റപ്പെടൂ, എല്ലാ അക്ഷരങ്ങളും വലിയവയാണ്.\n *\n * @param {string} text പ്രോസസ്സ് ചെയ്യേണ്ട ഇൻപുട്ട് ടെക്സ്റ്റ്.\n * @returns {string} 5 സ്ഥാനങ്ങൾ മാറ്റിയ അക്ഷരങ്ങളുള്ള പരിവർത്തിത ടെക്സ്റ്റ്.\n *\n * @example\n * f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n * // returns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n */\nfunction f_25(text)", "fa": "/**\n * تمام حروف را به اندازه ۵ موقعیت در ترتیب حروف الفبا جابجا می‌کند.\n * تنها حروف جایگزین می‌شوند و همه حروف به صورت بزرگ هستند.\n *\n * @param {string} text متنی که باید پردازش شود.\n * @returns {string} متن تغییر یافته با حروفی که به اندازه ۵ موقعیت جابجا شده‌اند.\n *\n * @example\n * f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n * // returns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n */\nfunction f_25(text)"}, "canonical_solution": "{\n    let shiftedText = '';\n    for (let i = 0; i < text.length; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            shiftedText += String.fromCharCode(text.charCodeAt(i) + 21); // 'V' - 'A' = 21\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            shiftedText += String.fromCharCode(text.charCodeAt(i) - 5); // 'A' - 'F' = -5\n        } else {\n            shiftedText += text[i];\n        }\n    }\n    return shiftedText;\n}", "instruction": {"en": "Write a JavaScript function `function f_25(text)` to solve the following problem:\nShifts all characters by 5 positions in alphabetical order.\nOnly letters are replaced, and all letters are in uppercase.\n\nParameters:\n- text (string): The input text to be processed.\n\nReturns:\n- string: The transformed text with characters shifted by 5 positions.\n\nExample:\n- f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n// returns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "sq": "Shkruani një funksion JavaScript `function f_25(text)` për të zgjidhur problemin e mëposhtëm: \nZhvendos të gjitha karakteret me 5 pozicione në rend alfabetik. \nVetëm shkronjat zëvendësohen, dhe të gjitha shkronjat janë me shkronja të mëdha.\n\nParametrat:\n- text (string): Teksti hyrës që do të përpunohet.\n\nKthen:\n- string: Teksti i transformuar me karaktere të zhvendosura me 5 pozicione.\n\nShembull:\n- f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n// kthen \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "hy": "Գրեք JavaScript ֆունկցիա `function f_25(text)` հետևյալ խնդիրը լուծելու համար:\nՏեղաշարժում է բոլոր տառերը 5 դիրքով այբբենական կարգով:\nՄիայն տառերը են փոխարինվում, և բոլոր տառերը մեծատառ են:\n\nՊարամետրեր:\n- text (string): Մուտքային տեքստը, որը պետք է մշակվի:\n\nՎերադարձնում է:\n- string: Փոխակերպված տեքստը, որտեղ տառերը տեղաշարժված են 5 դիրքով:\n\nՕրինակ:\n- f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n// վերադարձնում է \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "bn": "একটি জাভাস্ক্রিপ্ট ফাংশন `function f_25(text)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nবর্ণানুক্রমিক ক্রমে সমস্ত অক্ষর ৫ পজিশন সরিয়ে দেয়।\nশুধুমাত্র অক্ষরগুলি প্রতিস্থাপিত হয়, এবং সমস্ত অক্ষর বড় হাতের।\n\nপ্যারামিটারসমূহ:\n- text (string): প্রক্রিয়াকরণের জন্য ইনপুট টেক্সট।\n\nফেরত দেয়:\n- string: পরিবর্তিত টেক্সট যেখানে অক্ষরগুলি ৫ পজিশন সরানো হয়েছে।\n\nউদাহরণ:\n- f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n// returns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "bg": "Напишете JavaScript функция `function f_25(text)`, за да решите следния проблем:\nПремества всички символи с 5 позиции в азбучен ред.\nСамо буквите се заменят и всички букви са с главни букви.\n\nПараметри:\n- text (string): Входният текст, който ще бъде обработен.\n\nВръща:\n- string: Преобразуваният текст със символи, преместени с 5 позиции.\n\nПример:\n- f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n// връща \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "zh": "编写一个 JavaScript 函数 `function f_25(text)` 来解决以下问题：\n将所有字符在字母表中移动5个位置。\n只有字母被替换，并且所有字母都是大写。\n\n参数：\n- text (string): 要处理的输入文本。\n\n返回：\n- string: 字符移动了5个位置的转换文本。\n\n示例：\n- f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n// returns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "fr": "Écrire une fonction JavaScript `function f_25(text)` pour résoudre le problème suivant :  \nDécale tous les caractères de 5 positions dans l'ordre alphabétique.  \nSeules les lettres sont remplacées, et toutes les lettres sont en majuscules.\n\nParamètres :  \n- text (string) : Le texte d'entrée à traiter.\n\nRenvoie :  \n- string : Le texte transformé avec les caractères décalés de 5 positions.\n\nExemple :  \n- f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")  \n// renvoie \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "de": "Schreiben Sie eine JavaScript-Funktion `function f_25(text)`, um das folgende Problem zu lösen:\nVerschiebt alle Zeichen um 5 Positionen in alphabetischer Reihenfolge.\nNur Buchstaben werden ersetzt, und alle Buchstaben sind in Großbuchstaben.\n\nParameter:\n- text (string): Der zu verarbeitende Eingabetext.\n\nRückgabewert:\n- string: Der transformierte Text mit um 5 Positionen verschobenen Zeichen.\n\nBeispiel:\n- f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n// gibt zurück \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "ha": "Rubuta wani aikin JavaScript `function f_25(text)` don warware matsalar mai zuwa:\nCanza duk haruffa ta wurin matsar da su wurare 5 a cikin tsari na haruffa.\nHaruffa kawai ake maye gurbinsu, kuma duk haruffa suna cikin manyan baki.\n\nSigogi:\n- text (string): Rubutun shigar da za a sarrafa.\n\nDawowa:\n- string: Rubutun da aka canza tare da haruffa da aka matsar da wurare 5.\n\nMisali:\n- f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n// returns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "hi": "JavaScript फ़ंक्शन `function f_25(text)` लिखें ताकि निम्नलिखित समस्या का समाधान हो सके:\nसभी वर्णों को वर्णमाला क्रम में 5 स्थानों से स्थानांतरित करता है।\nकेवल अक्षरों को बदला जाता है, और सभी अक्षर बड़े अक्षरों में हैं।\n\nपैरामीटर्स:\n- text (string): इनपुट टेक्स्ट जिसे प्रोसेस किया जाना है।\n\nरिटर्न करता है:\n- string: स्थानांतरित किए गए वर्णों के साथ परिवर्तित टेक्स्ट।\n\nउदाहरण:\n- f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n// returns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "hu": "Írj egy JavaScript függvényt `function f_25(text)` a következő probléma megoldására:\nAz összes karaktert 5 pozícióval eltolja ábécé sorrendben.\nCsak a betűk kerülnek cserére, és minden betű nagybetűs.\n\nParaméterek:\n- text (string): A feldolgozandó bemeneti szöveg.\n\nVisszatér:\n- string: Az átalakított szöveg, ahol a karakterek 5 pozícióval eltolódtak.\n\nPélda:\n- f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n// visszaadja \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "es": "Escribe una función de JavaScript `function f_25(text)` para resolver el siguiente problema:\nDesplaza todos los caracteres 5 posiciones en orden alfabético.\nSolo se reemplazan las letras, y todas las letras están en mayúsculas.\n\nParámetros:\n- text (string): El texto de entrada a ser procesado.\n\nDevuelve:\n- string: El texto transformado con caracteres desplazados 5 posiciones.\n\nEjemplo:\n- f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n// devuelve \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "arb": "اكتب دالة JavaScript `function f_25(text)` لحل المشكلة التالية:\nتحريك جميع الأحرف بمقدار 5 مواقع في الترتيب الأبجدي.\nيتم استبدال الأحرف فقط، وجميع الأحرف تكون بحروف كبيرة.\n\nالمعلمات:\n- text (string): النص المدخل ليتم معالجته.\n\nيعيد:\n- string: النص المحول مع الأحرف المحركة بمقدار 5 مواقع.\n\nمثال:\n- f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n// يعيد \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "sw": "Andika kazi ya JavaScript `function f_25(text)` kutatua tatizo lifuatalo:\nInasogeza herufi zote kwa nafasi 5 katika mpangilio wa alfabeti.\nNi herufi pekee zinazobadilishwa, na herufi zote ziko katika herufi kubwa.\n\nVigezo:\n- text (string): Maandishi ya kuingiza yanayopaswa kushughulikiwa.\n\nInarudisha:\n- string: Maandishi yaliyobadilishwa na herufi kusogezwa kwa nafasi 5.\n\nMfano:\n- f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n// inarudisha \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "tr": "Bir JavaScript fonksiyonu `function f_25(text)` yazın:\nAlfabetik sırada tüm karakterleri 5 pozisyon kaydırır.\nSadece harfler değiştirilir ve tüm harfler büyük harfle yazılır.\n\nParametreler:\n- text (string): İşlenecek giriş metni.\n\nDöndürülen:\n- string: Karakterlerin 5 pozisyon kaydırıldığı dönüştürülmüş metin.\n\nÖrnek:\n- f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n// \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\" döndürür.", "vi": "Viết một hàm JavaScript `function f_25(text)` để giải quyết vấn đề sau:\nDịch chuyển tất cả các ký tự 5 vị trí trong thứ tự bảng chữ cái.\nChỉ các chữ cái được thay thế, và tất cả các chữ cái đều ở dạng chữ hoa.\n\nTham số:\n- text (string): Văn bản đầu vào cần xử lý.\n\nTrả về:\n- string: Văn bản đã được biến đổi với các ký tự được dịch chuyển 5 vị trí.\n\nVí dụ:\n- f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n// trả về \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "id": "Tulis sebuah fungsi JavaScript `function f_25(text)` untuk menyelesaikan masalah berikut:\nMenggeser semua karakter sebanyak 5 posisi dalam urutan alfabet.\nHanya huruf yang diganti, dan semua huruf dalam huruf besar.\n\nParameter:\n- text (string): Teks masukan yang akan diproses.\n\nMengembalikan:\n- string: Teks yang telah diubah dengan karakter digeser sebanyak 5 posisi.\n\nContoh:\n- f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n// mengembalikan \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "ja": "JavaScript関数 `function f_25(text)` を作成して、次の問題を解決してください:\nすべての文字をアルファベット順で5つの位置にシフトします。\n文字のみが置き換えられ、すべての文字は大文字です。\n\nパラメータ:\n- text (string): 処理する入力テキスト。\n\n戻り値:\n- string: 文字が5つの位置にシフトされた変換済みテキスト。\n\n例:\n- f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n// returns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "ko": "JavaScript 함수 `function f_25(text)`를 작성하여 다음 문제를 해결하십시오:\n모든 문자를 알파벳 순서로 5자리 이동시킵니다.\n문자는 대문자만 교체됩니다.\n\n매개변수:\n- text (string): 처리할 입력 텍스트입니다.\n\n반환값:\n- string: 문자가 5자리 이동된 변환된 텍스트입니다.\n\n예시:\n- f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n// \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\" 반환", "ml": "`function f_25(text)` എന്ന ജാവാസ്ക്രിപ്റ്റ് ഫംഗ്ഷൻ എഴുതുക താഴെ കൊടുത്തിരിക്കുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nഎല്ലാ അക്ഷരങ്ങളും അക്ഷരമാല ക്രമത്തിൽ 5 സ്ഥാനങ്ങൾ മാറ്റുന്നു.\nഅക്ഷരങ്ങൾ മാത്രമേ മാറ്റപ്പെടുകയുള്ളൂ, എല്ലാ അക്ഷരങ്ങളും വലിയവയാകണം.\n\nപാരാമീറ്ററുകൾ:\n- text (string): പ്രോസസ്സ് ചെയ്യേണ്ട ഇൻപുട്ട് ടെക്സ്റ്റ്.\n\nമടക്കം:\n- string: 5 സ്ഥാനങ്ങൾ മാറ്റിയ അക്ഷരങ്ങളുള്ള പരിവർത്തിത ടെക്സ്റ്റ്.\n\nഉദാഹരണം:\n- f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n// \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\" മടക്കം ചെയ്യുന്നു", "fa": "یک تابع جاوااسکریپت `function f_25(text)` بنویسید تا مسئله زیر را حل کند:\nتمام حروف را به اندازه ۵ موقعیت در ترتیب الفبایی جابجا می‌کند.\nفقط حروف جایگزین می‌شوند و همه حروف به صورت بزرگ هستند.\n\nپارامترها:\n- text (string): متنی که باید پردازش شود.\n\nبرمی‌گرداند:\n- string: متن تغییر یافته با حروفی که به اندازه ۵ موقعیت جابجا شده‌اند.\n\nمثال:\n- f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n// برمی‌گرداند \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\""}, "level": "middle", "test": "const testf_25 = () => {\n    console.assert(f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\") === \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\", 'Test 1 failed');\n    console.assert(f_25(\"N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ\") === \"I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME\", 'Test 2 failed');\n    console.assert(f_25(\"IFSLJW PSTBX KZQQ BJQQ YMFY HFJXFW NX RTWJ IFSLJWTZX YMFS MJ\") === \"DANGER KNOWS FULL WELL THAT CAESAR IS MORE DANGEROUS THAN HE\", 'Test 3 failed');\n};\n\ntestf_25();", "entry_point": "f_25", "signature": "function f_25(text)", "docstring": {"en": "Shifts all characters by 5 positions in alphabetical order.\nOnly letters are replaced, and all letters are in uppercase.\n\nParameters:\n- text (string): The input text to be processed.\n\nReturns:\n- string: The transformed text with characters shifted by 5 positions.\n\nExample:\n- f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n// returns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "sq": "Zhvendos të gjitha karakteret me 5 pozicione në rend alfabetik. Vetëm shkronjat zëvendësohen dhe të gjitha shkronjat janë me shkronja të mëdha.\n\nParametrat:\n- text (string): Teksti hyrës që do të përpunohet.\n\nKthen:\n- string: Teksti i transformuar me karaktere të zhvendosura me 5 pozicione.\n\nShembull:\n- f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n// kthen \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "hy": "Տեղափոխում է բոլոր տառերը այբբենական կարգով 5 դիրքով:\nՄիայն տառերն են փոխարինվում, և բոլոր տառերը մեծատառ են:\n\nՊարամետրեր:\n- text (string): Մուտքային տեքստը, որը պետք է մշակվի:\n\nՎերադարձնում է:\n- string: Փոխակերպված տեքստը, որտեղ տառերը տեղափոխված են 5 դիրքով:\n\nՕրինակ:\n- f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n// վերադարձնում է \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "bn": "অক্ষরগুলিকে বর্ণানুক্রমিক ক্রমে ৫টি অবস্থানে স্থানান্তর করে।\nশুধুমাত্র অক্ষরগুলি প্রতিস্থাপিত হয়, এবং সমস্ত অক্ষর বড় হাতের হয়।\n\nপ্যারামিটার:\n- text (string): প্রক্রিয়াকরণের জন্য ইনপুট টেক্সট।\n\nফেরত দেয়:\n- string: পরিবর্তিত টেক্সট যেখানে অক্ষরগুলি ৫টি অবস্থানে স্থানান্তরিত হয়।\n\nউদাহরণ:\n- f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n// ফেরত দেয় \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "bg": "Изместете всички символи с 5 позиции в азбучен ред. Само буквите се заменят и всички букви са с главни букви.\n\nПараметри:\n- text (string): Входният текст, който ще бъде обработен.\n\nВръща:\n- string: Преобразуваният текст със символи, изместени с 5 позиции.\n\nПример:\n- f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n// връща \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "zh": "将所有字符在字母表中向后移动5个位置。  \n只有字母会被替换，并且所有字母都是大写。\n\n参数:  \n- text (string): 要处理的输入文本。\n\n返回:  \n- string: 字符被移动5个位置后的转换文本。\n\n示例:  \n- f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")  \n// 返回 \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "fr": "Décale tous les caractères de 5 positions dans l'ordre alphabétique.\nSeules les lettres sont remplacées, et toutes les lettres sont en majuscules.\n\nParamètres:\n- text (string): Le texte d'entrée à traiter.\n\nRenvoie:\n- string: Le texte transformé avec les caractères décalés de 5 positions.\n\nExemple:\n- f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n// returns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "de": "Verschiebt alle Zeichen um 5 Positionen in alphabetischer Reihenfolge.\nNur Buchstaben werden ersetzt, und alle Buchstaben sind in Großbuchstaben.\n\nParameter:\n- text (string): Der zu verarbeitende Eingabetext.\n\nRückgabewert:\n- string: Der transformierte Text mit um 5 Positionen verschobenen Zeichen.\n\nBeispiel:\n- f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n// gibt \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\" zurück", "ha": "Canza dukkan haruffa da matsayi 5 a cikin tsarin haruffa na alfabeti. \nHaruffa kawai ake maye gurbinsu, kuma duk haruffa suna cikin manyan baki.\n\nSigogi:\n- text (string): Rubutun shigarwa da za a sarrafa.\n\nDawowa:\n- string: Rubutun da aka canza tare da haruffa da aka matsa da matsayi 5.\n\nMisali:\n- f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n// returns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "hi": "सभी वर्णों को वर्णानुक्रम में 5 स्थानों से स्थानांतरित करता है।  \nकेवल अक्षरों को बदला जाता है, और सभी अक्षर बड़े अक्षरों में होते हैं।\n\nपैरामीटर्स:\n- text (string): इनपुट पाठ जिसे संसाधित किया जाना है।\n\nवापसी:\n- string: परिवर्तित पाठ जिसमें वर्ण 5 स्थानों से स्थानांतरित होते हैं।\n\nउदाहरण:\n- f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n// returns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "hu": "Eltolja az összes karaktert 5 pozícióval az ábécé sorrendjében.\nCsak a betűk kerülnek cserére, és minden betű nagybetűs.\n\nParaméterek:\n- text (string): A feldolgozandó bemeneti szöveg.\n\nVisszatér:\n- string: Az átalakított szöveg, amelynek karakterei 5 pozícióval eltolódtak.\n\nPélda:\n- f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n// visszaadja \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "es": "Desplaza todos los caracteres 5 posiciones en orden alfabético.  \nSolo se reemplazan las letras, y todas las letras están en mayúsculas.\n\nParámetros:\n- text (string): El texto de entrada a ser procesado.\n\nDevuelve:\n- string: El texto transformado con caracteres desplazados 5 posiciones.\n\nEjemplo:\n- f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n// devuelve \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "arb": "ينقل جميع الأحرف بمقدار 5 مواقع في الترتيب الأبجدي. يتم استبدال الحروف فقط، وجميع الحروف تكون بأحرف كبيرة.\n\nالمعلمات:\n- text (string): النص المدخل ليتم معالجته.\n\nالقيم المعادة:\n- string: النص المحول مع الأحرف المنقولة بمقدار 5 مواقع.\n\nمثال:\n- f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n// يعيد \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "sw": "Hubadilisha herufi zote kwa nafasi 5 katika mpangilio wa alfabeti. \nNi herufi pekee zinazobadilishwa, na herufi zote ziko katika herufi kubwa.\n\nVigezo:\n- text (string): Maandishi ya kuingiza yanayopaswa kushughulikiwa.\n\nRudisha:\n- string: Maandishi yaliyobadilishwa na herufi zilizohamishwa kwa nafasi 5.\n\nMfano:\n- f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n// inarudisha \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "tr": "Alfabetik sırada tüm karakterleri 5 pozisyon kaydırır. \nYalnızca harfler değiştirilir ve tüm harfler büyük harfle yazılır.\n\nParametreler:\n- text (string): İşlenecek giriş metni.\n\nDöndürür:\n- string: Karakterleri 5 pozisyon kaydırılmış dönüştürülmüş metin.\n\nÖrnek:\n- f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n// \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\" döndürür", "vi": "Dịch chuyển tất cả các ký tự lên 5 vị trí trong thứ tự bảng chữ cái.  \nChỉ các chữ cái được thay thế, và tất cả các chữ cái đều ở dạng chữ hoa.\n\nTham số:\n- text (string): Văn bản đầu vào cần xử lý.\n\nTrả về:\n- string: Văn bản đã được biến đổi với các ký tự dịch chuyển lên 5 vị trí.\n\nVí dụ:\n- f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n// trả về \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "id": "Menggeser semua karakter sebanyak 5 posisi dalam urutan alfabet. Hanya huruf yang diganti, dan semua huruf dalam huruf besar.\n\nParameter:\n- text (string): Teks masukan yang akan diproses.\n\nMengembalikan:\n- string: Teks yang telah diubah dengan karakter digeser sebanyak 5 posisi.\n\nContoh:\n- f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n// mengembalikan \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "ja": "アルファベット順で全ての文字を5つの位置ずらします。  \n文字のみが置き換えられ、全ての文字は大文字です。\n\nパラメータ:\n- text (string): 処理する入力テキスト。\n\n戻り値:\n- string: 文字が5つの位置ずらされた変換されたテキスト。\n\n例:\n- f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n// returns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "ko": "알파벳 순서에서 모든 문자를 5자리씩 이동합니다.  \n문자만 대체되며, 모든 문자는 대문자입니다.\n\n매개변수:\n- text (string): 처리할 입력 텍스트입니다.\n\n반환:\n- string: 문자가 5자리씩 이동된 변환된 텍스트입니다.\n\n예시:\n- f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n// returns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "ml": "ആഖ്യരങ്ങളെ അക്ഷരമാല ക്രമത്തിൽ 5 സ്ഥാനങ്ങൾ മാറ്റുന്നു.\nഅക്ഷരങ്ങൾ മാത്രം മാറ്റപ്പെടുന്നു, എല്ലാ അക്ഷരങ്ങളും വലുതാക്ഷരങ്ങളായിരിക്കും.\n\nപാരാമീറ്ററുകൾ:\n- text (string): പ്രോസസ്സ് ചെയ്യേണ്ട ഇൻപുട്ട് ടെക്സ്റ്റ്.\n\nമടക്കുന്നു:\n- string: 5 സ്ഥാനങ്ങൾ മാറ്റിയ അക്ഷരങ്ങളുള്ള പരിവർത്തിത ടെക്സ്റ്റ്.\n\nഉദാഹരണം:\n- f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n// \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\" മടക്കുന്നു", "fa": "تمام حروف را به اندازه ۵ موقعیت در ترتیب حروف الفبا جابجا می‌کند.  \nفقط حروف جایگزین می‌شوند و همه حروف به صورت بزرگ هستند.  \n\nParameters:  \nپارامترها:  \n- text (string): The input text to be processed.  \n- text (string): متنی که باید پردازش شود.  \n\nReturns:  \nبرمی‌گرداند:  \n- string: The transformed text with characters shifted by 5 positions.  \n- string: متن تغییر یافته با حروف جابجا شده به اندازه ۵ موقعیت.  \n\nExample:  \nمثال:  \n- f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")  \n// returns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\""}}
{"task_id": "JavaScript/26", "prompt": {"en": "\n/*\nClassify the integer x based on the following method:\nIf x is a single-digit number, x belongs to its own class.\nOtherwise, sum the digits of x, get a new x, and iterate until \nthe class is determined.\n\nParameters:\n- x (string): The integer to be classified as a string.\n\nReturns:\nint: The class to which the integer x belongs.\n\nExamples:\nf_26(\"24\") // returns 6\nf_26(\"39\") // returns 3\nf_26(\"123456789\") // returns 9\nf_26(\"123456789012345678901234567890\") // returns 9\nf_26(\"12345\") // returns 6\nf_26(\"999999999\") // returns 9\n*/\nfunction f_26(x)", "sq": "/*\nKlasifikoni numrin e plotë x bazuar në metodën e mëposhtme:\nNëse x është një numër njëshifror, x i përket klasës së vet.\nPërndryshe, mblidhni shifrat e x, merrni një x të ri dhe iteroni derisa \nklasa të përcaktohet.\n\nParametrat:\n- x (string): Numri i plotë që do të klasifikohet si një varg.\n\nKthen:\nint: Klasa së cilës i përket numri i plotë x.\n\nShembuj:\nf_26(\"24\") // kthen 6\nf_26(\"39\") // kthen 3\nf_26(\"123456789\") // kthen 9\nf_26(\"123456789012345678901234567890\") // kthen 9\nf_26(\"12345\") // kthen 6\nf_26(\"999999999\") // kthen 9\n*/\nfunction f_26(x)", "hy": "/*\nԴասակարգել ամբողջ թիվը x-ը հետևյալ մեթոդով:\nԵթե x-ը միանիշ թիվ է, ապա x-ը պատկանում է իր սեփական դասին:\nՀակառակ դեպքում, գումարել x-ի թվանշանները, ստանալ նոր x և կրկնել, մինչև \nդասը որոշվի:\n\nՊարամետրեր:\n- x (string): Ամբողջ թիվը, որը պետք է դասակարգվի որպես տող:\n\nՎերադարձնում է:\nint: Դասը, որին պատկանում է ամբողջ թիվը x-ը:\n\nՕրինակներ:\nf_26(\"24\") // վերադարձնում է 6\nf_26(\"39\") // վերադարձնում է 3\nf_26(\"123456789\") // վերադարձնում է 9\nf_26(\"123456789012345678901234567890\") // վերադարձնում է 9\nf_26(\"12345\") // վերադարձնում է 6\nf_26(\"999999999\") // վերադարձնում է 9\n*/\nfunction f_26(x)", "bn": "/*\nইন্টিজার x নিম্নলিখিত পদ্ধতির ভিত্তিতে শ্রেণীবদ্ধ করুন:\nযদি x একটি একক অঙ্কের সংখ্যা হয়, তাহলে x তার নিজস্ব শ্রেণীতে অন্তর্ভুক্ত।\nঅন্যথায়, x এর অঙ্কগুলির যোগফল নিন, একটি নতুন x পান, এবং পুনরাবৃত্তি করুন যতক্ষণ না শ্রেণী নির্ধারিত হয়।\n\nপ্যারামিটার:\n- x (string): ইন্টিজারটি একটি স্ট্রিং হিসাবে শ্রেণীবদ্ধ করার জন্য।\n\nরিটার্নস:\nint: যে শ্রেণীতে ইন্টিজার x অন্তর্ভুক্ত।\n\nউদাহরণ:\nf_26(\"24\") // 6 রিটার্ন করে\nf_26(\"39\") // 3 রিটার্ন করে\nf_26(\"123456789\") // 9 রিটার্ন করে\nf_26(\"123456789012345678901234567890\") // 9 রিটার্ন করে\nf_26(\"12345\") // 6 রিটার্ন করে\nf_26(\"999999999\") // 9 রিটার্ন করে\n*/\nfunction f_26(x)", "bg": "/*\nКласифицирайте цялото число x въз основа на следния метод:\nАко x е едноцифрено число, x принадлежи към своя собствен клас.\nВ противен случай, съберете цифрите на x, получете ново x, и итерайте, докато\nкласът бъде определен.\n\nПараметри:\n- x (string): Цялото число, което трябва да бъде класифицирано като низ.\n\nВръща:\nint: Класът, към който принадлежи цялото число x.\n\nПримери:\nf_26(\"24\") // връща 6\nf_26(\"39\") // връща 3\nf_26(\"123456789\") // връща 9\nf_26(\"123456789012345678901234567890\") // връща 9\nf_26(\"12345\") // връща 6\nf_26(\"999999999\") // връща 9\n*/\nfunction f_26(x)", "zh": "/*\n根据以下方法对整数 x 进行分类：\n如果 x 是一位数，x 属于它自己的类别。\n否则，将 x 的各位数字相加，得到一个新的 x，并迭代直到确定类别。\n\n参数：\n- x (string): 要分类的整数，作为字符串。\n\n返回：\nint: 整数 x 所属的类别。\n\n示例：\nf_26(\"24\") // returns 6\nf_26(\"39\") // returns 3\nf_26(\"123456789\") // returns 9\nf_26(\"123456789012345678901234567890\") // returns 9\nf_26(\"12345\") // returns 6\nf_26(\"999999999\") // returns 9\n*/\nfunction f_26(x)", "fr": "/*\nClassifiez l'entier x selon la méthode suivante :\nSi x est un nombre à un seul chiffre, x appartient à sa propre classe.\nSinon, additionnez les chiffres de x, obtenez un nouveau x, et itérez jusqu'à ce que \nla classe soit déterminée.\n\nParamètres :\n- x (string) : L'entier à classer sous forme de chaîne.\n\nRenvoie :\nint : La classe à laquelle appartient l'entier x.\n\nExemples :\nf_26(\"24\") // renvoie 6\nf_26(\"39\") // renvoie 3\nf_26(\"123456789\") // renvoie 9\nf_26(\"123456789012345678901234567890\") // renvoie 9\nf_26(\"12345\") // renvoie 6\nf_26(\"999999999\") // renvoie 9\n*/\nfunction f_26(x)", "de": "/*\nKlassifiziere die ganze Zahl x basierend auf der folgenden Methode:\nWenn x eine einstellige Zahl ist, gehört x zu seiner eigenen Klasse.\nAndernfalls summiere die Ziffern von x, erhalte ein neues x und iteriere, bis \ndie Klasse bestimmt ist.\n\nParameter:\n- x (string): Die als Zeichenkette zu klassifizierende ganze Zahl.\n\nRückgabe:\nint: Die Klasse, zu der die ganze Zahl x gehört.\n\nBeispiele:\nf_26(\"24\") // gibt 6 zurück\nf_26(\"39\") // gibt 3 zurück\nf_26(\"123456789\") // gibt 9 zurück\nf_26(\"123456789012345678901234567890\") // gibt 9 zurück\nf_26(\"12345\") // gibt 6 zurück\nf_26(\"999999999\") // gibt 9 zurück\n*/\nfunction f_26(x)", "ha": "/*\nRarraba lambar x bisa ga hanyar da ke gaba:\nIdan x lamba ce mai lamba guda ɗaya, x tana cikin ajin kanta.\nIn ba haka ba, tara lambobin x, sami sabon x, kuma maimaita har \najin ya ƙayyade.\n\nSigogi:\n- x (string): Lambar da za a rarraba a matsayin kirtani.\n\nDawowa:\nint: Ajin da lambar x ta ke ciki.\n\nMisalai:\nf_26(\"24\") // returns 6\nf_26(\"39\") // returns 3\nf_26(\"123456789\") // returns 9\nf_26(\"123456789012345678901234567890\") // returns 9\nf_26(\"12345\") // returns 6\nf_26(\"999999999\") // returns 9\n*/\nfunction f_26(x)", "hi": "/*\nपूर्णांक x को निम्नलिखित विधि के आधार पर वर्गीकृत करें:\nयदि x एकल-अंक संख्या है, तो x अपनी स्वयं की श्रेणी में आता है।\nअन्यथा, x के अंकों का योग करें, एक नया x प्राप्त करें, और तब तक पुनरावृत्ति करें \nजब तक कि श्रेणी निर्धारित न हो जाए।\n\nपैरामीटर्स:\n- x (string): पूर्णांक जिसे स्ट्रिंग के रूप में वर्गीकृत किया जाना है।\n\nवापसी मान:\nint: वह श्रेणी जिसमें पूर्णांक x आता है।\n\nउदाहरण:\nf_26(\"24\") // 6 लौटाता है\nf_26(\"39\") // 3 लौटाता है\nf_26(\"123456789\") // 9 लौटाता है\nf_26(\"123456789012345678901234567890\") // 9 लौटाता है\nf_26(\"12345\") // 6 लौटाता है\nf_26(\"999999999\") // 9 लौटाता है\n*/\nfunction f_26(x)", "hu": "/*\nOsztályozza az x egész számot az alábbi módszer alapján:\nHa x egyjegyű szám, akkor x a saját osztályába tartozik.\nEgyébként adja össze x számjegyeit, kapjon egy új x-et, és ismételje, amíg az osztály meg nem határozódik.\n\nParaméterek:\n- x (string): Az egész szám, amelyet karakterláncként kell osztályozni.\n\nVisszatér:\nint: Az osztály, amelyhez az x egész szám tartozik.\n\nPéldák:\nf_26(\"24\") // returns 6\nf_26(\"39\") // returns 3\nf_26(\"123456789\") // returns 9\nf_26(\"123456789012345678901234567890\") // returns 9\nf_26(\"12345\") // returns 6\nf_26(\"999999999\") // returns 9\n*/\nfunction f_26(x)", "es": "/*\nClasificar el entero x basado en el siguiente método:\nSi x es un número de un solo dígito, x pertenece a su propia clase.\nDe lo contrario, suma los dígitos de x, obtiene un nuevo x, e itera hasta que \nse determine la clase.\n\nParámetros:\n- x (string): El entero a clasificar como una cadena.\n\nDevuelve:\nint: La clase a la que pertenece el entero x.\n\nEjemplos:\nf_26(\"24\") // devuelve 6\nf_26(\"39\") // devuelve 3\nf_26(\"123456789\") // devuelve 9\nf_26(\"123456789012345678901234567890\") // devuelve 9\nf_26(\"12345\") // devuelve 6\nf_26(\"999999999\") // devuelve 9\n*/\nfunction f_26(x)", "arb": "/*\nتصنيف العدد الصحيح x بناءً على الطريقة التالية:\nإذا كان x رقمًا مكونًا من رقم واحد، فإن x ينتمي إلى فئته الخاصة.\nخلاف ذلك، اجمع أرقام x، احصل على x جديد، وكرر حتى يتم تحديد الفئة.\n\nالمعلمات:\n- x (string): العدد الصحيح الذي سيتم تصنيفه كسلسلة.\n\nالإرجاع:\nint: الفئة التي ينتمي إليها العدد الصحيح x.\n\nأمثلة:\nf_26(\"24\") // يعيد 6\nf_26(\"39\") // يعيد 3\nf_26(\"123456789\") // يعيد 9\nf_26(\"123456789012345678901234567890\") // يعيد 9\nf_26(\"12345\") // يعيد 6\nf_26(\"999999999\") // يعيد 9\n*/\nfunction f_26(x)", "sw": "/*\nKlasifai nambari x kulingana na njia ifuatayo:\nIkiwa x ni nambari ya tarakimu moja, x inahusishwa na darasa lake lenyewe.\nVinginevyo, jumlisha tarakimu za x, pata x mpya, na rudia hadi \ndarasa litakapobainishwa.\n\nVigezo:\n- x (string): Nambari ya kuhesabu inayopaswa kuainishwa kama string.\n\nInarudisha:\nint: Darasa ambalo nambari x inahusishwa.\n\nMifano:\nf_26(\"24\") // inarudisha 6\nf_26(\"39\") // inarudisha 3\nf_26(\"123456789\") // inarudisha 9\nf_26(\"123456789012345678901234567890\") // inarudisha 9\nf_26(\"12345\") // inarudisha 6\nf_26(\"999999999\") // inarudisha 9\n*/\nfunction f_26(x)", "tr": "/*\nAşağıdaki yönteme göre tam sayı x'i sınıflandırın:\nEğer x tek basamaklı bir sayı ise, x kendi sınıfına aittir.\nAksi takdirde, x'in rakamlarını toplayın, yeni bir x elde edin ve sınıf belirlenene kadar yineleyin.\n\nParametreler:\n- x (string): Sınıflandırılacak tam sayı bir string olarak.\n\nDöndürür:\nint: Tam sayı x'in ait olduğu sınıf.\n\nÖrnekler:\nf_26(\"24\") // 6 döndürür\nf_26(\"39\") // 3 döndürür\nf_26(\"123456789\") // 9 döndürür\nf_26(\"123456789012345678901234567890\") // 9 döndürür\nf_26(\"12345\") // 6 döndürür\nf_26(\"999999999\") // 9 döndürür\n*/\nfunction f_26(x)", "vi": "/*\nPhân loại số nguyên x dựa trên phương pháp sau:\nNếu x là một số có một chữ số, x thuộc về lớp của chính nó.\nNgược lại, tổng các chữ số của x, lấy một x mới, và lặp lại cho đến khi \nlớp được xác định.\n\nTham số:\n- x (string): Số nguyên cần được phân loại dưới dạng chuỗi.\n\nTrả về:\nint: Lớp mà số nguyên x thuộc về.\n\nVí dụ:\nf_26(\"24\") // trả về 6\nf_26(\"39\") // trả về 3\nf_26(\"123456789\") // trả về 9\nf_26(\"123456789012345678901234567890\") // trả về 9\nf_26(\"12345\") // trả về 6\nf_26(\"999999999\") // trả về 9\n*/\nfunction f_26(x)", "id": "/*\nKlasifikasikan bilangan bulat x berdasarkan metode berikut:\nJika x adalah angka satu digit, x termasuk dalam kelasnya sendiri.\nJika tidak, jumlahkan digit-digit x, dapatkan x baru, dan ulangi sampai\nkelas ditentukan.\n\nParameter:\n- x (string): Bilangan bulat yang akan diklasifikasikan sebagai string.\n\nMengembalikan:\nint: Kelas yang mana bilangan bulat x termasuk.\n\nContoh:\nf_26(\"24\") // mengembalikan 6\nf_26(\"39\") // mengembalikan 3\nf_26(\"123456789\") // mengembalikan 9\nf_26(\"123456789012345678901234567890\") // mengembalikan 9\nf_26(\"12345\") // mengembalikan 6\nf_26(\"999999999\") // mengembalikan 9\n*/\nfunction f_26(x)", "ja": "/*\n整数 x を次の方法に基づいて分類します:\nx が一桁の数字である場合、x はそれ自身のクラスに属します。\nそれ以外の場合は、x の桁を合計し、新しい x を取得し、クラスが決定されるまで繰り返します。\n\nパラメータ:\n- x (string): 文字列として分類される整数。\n\n戻り値:\nint: 整数 x が属するクラス。\n\n例:\nf_26(\"24\") // returns 6\nf_26(\"39\") // returns 3\nf_26(\"123456789\") // returns 9\nf_26(\"123456789012345678901234567890\") // returns 9\nf_26(\"12345\") // returns 6\nf_26(\"999999999\") // returns 9\n*/\nfunction f_26(x)", "ko": "/*\n정수 x를 다음 방법에 따라 분류합니다:\nx가 한 자리 숫자이면, x는 자신의 클래스에 속합니다.\n그렇지 않으면, x의 각 자릿수를 더하여 새로운 x를 얻고, 클래스가 결정될 때까지 반복합니다.\n\n매개변수:\n- x (string): 문자열로 분류할 정수입니다.\n\n반환값:\nint: 정수 x가 속하는 클래스입니다.\n\n예시:\nf_26(\"24\") // returns 6\nf_26(\"39\") // returns 3\nf_26(\"123456789\") // returns 9\nf_26(\"123456789012345678901234567890\") // returns 9\nf_26(\"12345\") // returns 6\nf_26(\"999999999\") // returns 9\n*/\nfunction f_26(x)", "ml": "/*\nഇനിപ്പറയുന്ന രീതിയിൽ പൂർണ്ണസംഖ്യ x-നെ വർഗ്ഗീകരിക്കുക:\nx ഒറ്റ അക്ക സംഖ്യയായാൽ, x സ്വന്തം വർഗ്ഗത്തിൽ പെട്ടതാണ്.\nഅല്ലെങ്കിൽ, x-ന്റെ അക്കങ്ങൾ കൂട്ടിച്ചേർക്കുക, ഒരു പുതിയ x നേടുക, വർഗ്ഗം നിർണ്ണയിക്കുന്നതുവരെ ആവർത്തിക്കുക.\n\nപാരാമീറ്ററുകൾ:\n- x (string): ഒരു സ്ട്രിംഗായി വർഗ്ഗീകരിക്കപ്പെടേണ്ട പൂർണ്ണസംഖ്യ.\n\nമടക്കം:\nint: പൂർണ്ണസംഖ്യ x ഏതു വർഗ്ഗത്തിലാണ് പെട്ടതെന്ന് കാണിക്കുന്നു.\n\nഉദാഹരണങ്ങൾ:\nf_26(\"24\") // 6 മടക്കം ചെയ്യുന്നു\nf_26(\"39\") // 3 മടക്കം ചെയ്യുന്നു\nf_26(\"123456789\") // 9 മടക്കം ചെയ്യുന്നു\nf_26(\"123456789012345678901234567890\") // 9 മടക്കം ചെയ്യുന്നു\nf_26(\"12345\") // 6 മടക്കം ചെയ്യുന്നു\nf_26(\"999999999\") // 9 മടക്കം ചെയ്യുന്നു\n*/\nfunction f_26(x)", "fa": "/*\nطبقه‌بندی عدد صحیح x بر اساس روش زیر:\nاگر x یک عدد یک رقمی باشد، x به کلاس خودش تعلق دارد.\nدر غیر این صورت، ارقام x را جمع کنید، یک x جدید بگیرید، و تکرار کنید تا \nکلاس تعیین شود.\n\nپارامترها:\n- x (string): عدد صحیحی که باید به عنوان یک رشته طبقه‌بندی شود.\n\nبرمی‌گرداند:\nint: کلاسی که عدد صحیح x به آن تعلق دارد.\n\nمثال‌ها:\nf_26(\"24\") // برمی‌گرداند 6\nf_26(\"39\") // برمی‌گرداند 3\nf_26(\"123456789\") // برمی‌گرداند 9\nf_26(\"123456789012345678901234567890\") // برمی‌گرداند 9\nf_26(\"12345\") // برمی‌گرداند 6\nf_26(\"999999999\") // برمی‌گرداند 9\n*/\nfunction f_26(x)"}, "canonical_solution": "{\n    let n = 0;\n    for (let i = 0; i < x.length; i++) {\n        n += parseInt(x[i], 10);\n    }\n    while (n > 9) {\n        let t = n;\n        let a = 0;\n        while (t) {\n            a += t % 10;\n            t = Math.floor(t / 10);\n        }\n        n = a;\n    }\n    return n;\n}", "instruction": {"en": "Write a JavaScript function `function f_26(x)` to solve the following problem:\nClassify the integer x based on the following method:\nIf x is a single-digit number, x belongs to its own class.\nOtherwise, sum the digits of x, get a new x, and iterate until \nthe class is determined.\n\nParameters:\n- x (string): The integer to be classified as a string.\n\nReturns:\nint: The class to which the integer x belongs.\n\nExamples:\nf_26(\"24\") // returns 6\nf_26(\"39\") // returns 3\nf_26(\"123456789\") // returns 9\nf_26(\"123456789012345678901234567890\") // returns 9\nf_26(\"12345\") // returns 6\nf_26(\"999999999\") // returns 9", "sq": "Shkruani një funksion JavaScript `function f_26(x)` për të zgjidhur problemin e mëposhtëm:\nKlasifikoni numrin e plotë x bazuar në metodën e mëposhtme:\nNëse x është një numër njëshifror, x i përket klasës së vet.\nPërndryshe, mblidhni shifrat e x, merrni një x të ri, dhe përsëritni derisa\nklasa të përcaktohet.\n\nParametrat:\n- x (string): Numri i plotë për t'u klasifikuar si një varg.\n\nKthen:\nint: Klasa së cilës i përket numri i plotë x.\n\nShembuj:\nf_26(\"24\") // returns 6\nf_26(\"39\") // returns 3\nf_26(\"123456789\") // returns 9\nf_26(\"123456789012345678901234567890\") // returns 9\nf_26(\"12345\") // returns 6\nf_26(\"999999999\") // returns 9", "hy": "Գրեք JavaScript ֆունկցիա `function f_26(x)` հետևյալ խնդիրը լուծելու համար:\nԴասակարգեք ամբողջ թիվը x հետևյալ մեթոդով:\nԵթե x-ը միանիշ թիվ է, ապա x-ը պատկանում է իր սեփական դասին:\nՀակառակ դեպքում, գումարեք x-ի թվանշանները, ստացեք նոր x և կրկնեք, մինչև \nդասը որոշվի:\n\nՊարամետրեր:\n- x (string): Դասակարգվող ամբողջ թիվը որպես տող:\n\nՎերադարձնում է:\nint: Դասը, որին պատկանում է ամբողջ թիվը x:\n\nՕրինակներ:\nf_26(\"24\") // վերադարձնում է 6\nf_26(\"39\") // վերադարձնում է 3\nf_26(\"123456789\") // վերադարձնում է 9\nf_26(\"123456789012345678901234567890\") // վերադարձնում է 9\nf_26(\"12345\") // վերադարձնում է 6\nf_26(\"999999999\") // վերադարձնում է 9", "bn": "একটি জাভাস্ক্রিপ্ট ফাংশন `function f_26(x)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nনিম্নলিখিত পদ্ধতির ভিত্তিতে পূর্ণসংখ্যা x শ্রেণীবদ্ধ করুন:\nযদি x একটি এক অঙ্কের সংখ্যা হয়, তাহলে x তার নিজের শ্রেণীতে অন্তর্ভুক্ত।\nঅন্যথায়, x এর অঙ্কগুলির যোগফল নিন, একটি নতুন x পান, এবং পুনরাবৃত্তি করুন যতক্ষণ না শ্রেণী নির্ধারিত হয়।\n\nপ্যারামিটারসমূহ:\n- x (string): পূর্ণসংখ্যা যা একটি স্ট্রিং হিসাবে শ্রেণীবদ্ধ করা হবে।\n\nরিটার্নস:\nint: শ্রেণী যা পূর্ণসংখ্যা x এর অন্তর্ভুক্ত।\n\nউদাহরণসমূহ:\nf_26(\"24\") // 6 রিটার্ন করে\nf_26(\"39\") // 3 রিটার্ন করে\nf_26(\"123456789\") // 9 রিটার্ন করে\nf_26(\"123456789012345678901234567890\") // 9 রিটার্ন করে\nf_26(\"12345\") // 6 রিটার্ন করে\nf_26(\"999999999\") // 9 রিটার্ন করে", "bg": "Напишете JavaScript функция `function f_26(x)`, за да решите следния проблем:\nКласифицирайте целочисленото x въз основа на следния метод:\nАко x е едноцифрено число, x принадлежи към своя собствен клас.\nВ противен случай, съберете цифрите на x, получете ново x и итерайте, докато класът бъде определен.\n\nПараметри:\n- x (string): Целочисленото число, което да бъде класифицирано като низ.\n\nВръща:\nint: Класът, към който принадлежи целочисленото x.\n\nПримери:\nf_26(\"24\") // връща 6\nf_26(\"39\") // връща 3\nf_26(\"123456789\") // връща 9\nf_26(\"123456789012345678901234567890\") // връща 9\nf_26(\"12345\") // връща 6\nf_26(\"999999999\") // връща 9", "zh": "编写一个 JavaScript 函数 `function f_26(x)` 来解决以下问题：\n根据以下方法对整数 x 进行分类：\n如果 x 是一个个位数，则 x 属于其自身的类。\n否则，将 x 的各位数字相加，得到一个新的 x，并迭代直到确定类。\n\n参数：\n- x (string): 要分类的整数，作为字符串。\n\n返回：\nint: 整数 x 所属的类。\n\n示例：\nf_26(\"24\") // returns 6\nf_26(\"39\") // returns 3\nf_26(\"123456789\") // returns 9\nf_26(\"123456789012345678901234567890\") // returns 9\nf_26(\"12345\") // returns 6\nf_26(\"999999999\") // returns 9", "fr": "Écrire une fonction JavaScript `function f_26(x)` pour résoudre le problème suivant :\nClasser l'entier x selon la méthode suivante :\nSi x est un nombre à un seul chiffre, x appartient à sa propre classe.\nSinon, additionner les chiffres de x, obtenir un nouveau x, et itérer jusqu'à ce que la classe soit déterminée.\n\nParamètres :\n- x (string) : L'entier à classer sous forme de chaîne.\n\nRenvoie :\nint : La classe à laquelle appartient l'entier x.\n\nExemples :\nf_26(\"24\") // returns 6\nf_26(\"39\") // returns 3\nf_26(\"123456789\") // returns 9\nf_26(\"123456789012345678901234567890\") // returns 9\nf_26(\"12345\") // returns 6\nf_26(\"999999999\") // returns 9", "de": "Schreiben Sie eine JavaScript-Funktion `function f_26(x)`, um das folgende Problem zu lösen:\nKlassifizieren Sie die ganze Zahl x basierend auf der folgenden Methode:\nWenn x eine einstellige Zahl ist, gehört x zu seiner eigenen Klasse.\nAndernfalls summieren Sie die Ziffern von x, erhalten ein neues x und iterieren, bis \ndie Klasse bestimmt ist.\n\nParameter:\n- x (string): Die als Zeichenfolge zu klassifizierende ganze Zahl.\n\nRückgabewert:\nint: Die Klasse, zu der die ganze Zahl x gehört.\n\nBeispiele:\nf_26(\"24\") // returns 6\nf_26(\"39\") // returns 3\nf_26(\"123456789\") // returns 9\nf_26(\"123456789012345678901234567890\") // returns 9\nf_26(\"12345\") // returns 6\nf_26(\"999999999\") // returns 9", "ha": "Rubuta aikin JavaScript `function f_26(x)` don warware matsalar mai zuwa:\nRarraba lambar x bisa ga hanyar mai zuwa:\nIdan x lamba ce guda ɗaya, x tana cikin ajin kanta.\nIn ba haka ba, tara lambobin x, sami sabon x, kuma maimaita har \najin ya ƙayyade.\n\nSigogi:\n- x (string): Lambar da za a rarraba a matsayin kirtani.\n\nDawowa:\nint: Aji wanda lambar x take ciki.\n\nMisalai:\nf_26(\"24\") // returns 6\nf_26(\"39\") // returns 3\nf_26(\"123456789\") // returns 9\nf_26(\"123456789012345678901234567890\") // returns 9\nf_26(\"12345\") // returns 6\nf_26(\"999999999\") // returns 9", "hi": "JavaScript फ़ंक्शन `function f_26(x)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nनिम्नलिखित विधि के आधार पर पूर्णांक x को वर्गीकृत करें:\nयदि x एक एकल-अंकीय संख्या है, तो x अपने स्वयं के वर्ग से संबंधित है।\nअन्यथा, x के अंकों का योग करें, एक नया x प्राप्त करें, और तब तक पुनरावृत्ति करें \nजब तक वर्ग निर्धारित नहीं हो जाता।\n\nपैरामीटर्स:\n- x (string): पूर्णांक जिसे स्ट्रिंग के रूप में वर्गीकृत किया जाना है।\n\nरिटर्न्स:\nint: वह वर्ग जिसमें पूर्णांक x संबंधित है।\n\nउदाहरण:\nf_26(\"24\") // returns 6\nf_26(\"39\") // returns 3\nf_26(\"123456789\") // returns 9\nf_26(\"123456789012345678901234567890\") // returns 9\nf_26(\"12345\") // returns 6\nf_26(\"999999999\") // returns 9", "hu": "Írj egy JavaScript függvényt `function f_26(x)` a következő probléma megoldására:\nOsztályozd az x egész számot a következő módszer alapján:\nHa x egy egyjegyű szám, akkor x a saját osztályába tartozik.\nEgyébként add össze x számjegyeit, kapj egy új x-et, és iterálj, amíg \naz osztály meg nem határozódik.\n\nParaméterek:\n- x (string): Az osztályozandó egész szám stringként.\n\nVisszatér:\nint: Az osztály, amelyhez az x egész szám tartozik.\n\nPéldák:\nf_26(\"24\") // returns 6\nf_26(\"39\") // returns 3\nf_26(\"123456789\") // returns 9\nf_26(\"123456789012345678901234567890\") // returns 9\nf_26(\"12345\") // returns 6\nf_26(\"999999999\") // returns 9", "es": "Escribe una función de JavaScript `function f_26(x)` para resolver el siguiente problema:\nClasificar el entero x basado en el siguiente método:\nSi x es un número de un solo dígito, x pertenece a su propia clase.\nDe lo contrario, suma los dígitos de x, obtén un nuevo x, e itera hasta que \nse determine la clase.\n\nParámetros:\n- x (string): El entero a clasificar como una cadena.\n\nDevuelve:\nint: La clase a la que pertenece el entero x.\n\nEjemplos:\nf_26(\"24\") // devuelve 6\nf_26(\"39\") // devuelve 3\nf_26(\"123456789\") // devuelve 9\nf_26(\"123456789012345678901234567890\") // devuelve 9\nf_26(\"12345\") // devuelve 6\nf_26(\"999999999\") // devuelve 9", "arb": "اكتب دالة JavaScript `function f_26(x)` لحل المشكلة التالية:\nصنّف العدد الصحيح x بناءً على الطريقة التالية:\nإذا كان x رقمًا مكونًا من خانة واحدة، فإن x ينتمي إلى فئته الخاصة.\nخلاف ذلك، اجمع أرقام x، واحصل على x جديد، وكرر حتى يتم تحديد الفئة.\n\nالمعطيات:\n- x (string): العدد الصحيح الذي سيتم تصنيفه كسلسلة.\n\nالقيم المعادة:\nint: الفئة التي ينتمي إليها العدد الصحيح x.\n\nأمثلة:\nf_26(\"24\") // يعيد 6\nf_26(\"39\") // يعيد 3\nf_26(\"123456789\") // يعيد 9\nf_26(\"123456789012345678901234567890\") // يعيد 9\nf_26(\"12345\") // يعيد 6\nf_26(\"999999999\") // يعيد 9", "sw": "Andika kazi ya JavaScript `function f_26(x)` kutatua tatizo lifuatalo:\nTambua nambari x kulingana na njia ifuatayo:\nIkiwa x ni nambari ya tarakimu moja, x ni ya darasa lake yenyewe.\nVinginevyo, jumlisha tarakimu za x, pata x mpya, na rudia hadi \ndarasa litakapobainishwa.\n\nVigezo:\n- x (string): Nambari ya kuainishwa kama kamba.\n\nRudisha:\nint: Darasa ambalo nambari x inahusishwa.\n\nMifano:\nf_26(\"24\") // inarudisha 6\nf_26(\"39\") // inarudisha 3\nf_26(\"123456789\") // inarudisha 9\nf_26(\"123456789012345678901234567890\") // inarudisha 9\nf_26(\"12345\") // inarudisha 6\nf_26(\"999999999\") // inarudisha 9", "tr": "Bir JavaScript fonksiyonu `function f_26(x)` yazın ve aşağıdaki problemi çözün:\nTam sayı x'i aşağıdaki yönteme göre sınıflandırın:\nEğer x tek basamaklı bir sayı ise, x kendi sınıfına aittir.\nAksi takdirde, x'in basamaklarını toplayın, yeni bir x elde edin ve sınıf belirlenene kadar yineleyin.\n\nParametreler:\n- x (string): Sınıflandırılacak tam sayı, string olarak.\n\nDöndürülen:\nint: Tam sayı x'in ait olduğu sınıf.\n\nÖrnekler:\nf_26(\"24\") // 6 döndürür\nf_26(\"39\") // 3 döndürür\nf_26(\"123456789\") // 9 döndürür\nf_26(\"123456789012345678901234567890\") // 9 döndürür\nf_26(\"12345\") // 6 döndürür\nf_26(\"999999999\") // 9 döndürür", "vi": "Viết một hàm JavaScript `function f_26(x)` để giải quyết vấn đề sau:\nPhân loại số nguyên x dựa trên phương pháp sau:\nNếu x là một số có một chữ số, x thuộc về lớp của chính nó.\nNgược lại, tính tổng các chữ số của x, lấy một x mới, và lặp lại cho đến khi \nlớp được xác định.\n\nTham số:\n- x (string): Số nguyên cần được phân loại dưới dạng chuỗi.\n\nTrả về:\nint: Lớp mà số nguyên x thuộc về.\n\nVí dụ:\nf_26(\"24\") // trả về 6\nf_26(\"39\") // trả về 3\nf_26(\"123456789\") // trả về 9\nf_26(\"123456789012345678901234567890\") // trả về 9\nf_26(\"12345\") // trả về 6\nf_26(\"999999999\") // trả về 9", "id": "Tulis sebuah fungsi JavaScript `function f_26(x)` untuk menyelesaikan masalah berikut:\nKlasifikasikan bilangan bulat x berdasarkan metode berikut:\nJika x adalah angka satu digit, x termasuk dalam kelasnya sendiri.\nJika tidak, jumlahkan digit-digit dari x, dapatkan x baru, dan iterasi sampai kelas ditentukan.\n\nParameter:\n- x (string): Bilangan bulat yang akan diklasifikasikan sebagai string.\n\nMengembalikan:\nint: Kelas di mana bilangan bulat x termasuk.\n\nContoh:\nf_26(\"24\") // returns 6\nf_26(\"39\") // returns 3\nf_26(\"123456789\") // returns 9\nf_26(\"123456789012345678901234567890\") // returns 9\nf_26(\"12345\") // returns 6\nf_26(\"999999999\") // returns 9", "ja": "JavaScript関数 `function f_26(x)` を作成して、次の問題を解決してください:\n以下の方法に基づいて整数 x を分類します:\nもし x が一桁の数字であれば、x はそれ自身のクラスに属します。\nそれ以外の場合、x の桁を合計し、新しい x を取得し、クラスが決定されるまで繰り返します。\n\nパラメータ:\n- x (string): 文字列として分類される整数。\n\n戻り値:\nint: 整数 x が属するクラス。\n\n例:\nf_26(\"24\") // returns 6\nf_26(\"39\") // returns 3\nf_26(\"123456789\") // returns 9\nf_26(\"123456789012345678901234567890\") // returns 9\nf_26(\"12345\") // returns 6\nf_26(\"999999999\") // returns 9", "ko": "JavaScript 함수 `function f_26(x)`를 작성하여 다음 문제를 해결하십시오:\n다음 방법에 따라 정수 x를 분류합니다:\nx가 한 자리 숫자이면, x는 자신의 클래스에 속합니다.\n그렇지 않으면, x의 자릿수를 합산하여 새로운 x를 얻고, 클래스가 결정될 때까지 반복합니다.\n\n매개변수:\n- x (string): 문자열로 분류할 정수입니다.\n\n반환값:\nint: 정수 x가 속하는 클래스입니다.\n\n예시:\nf_26(\"24\") // returns 6\nf_26(\"39\") // returns 3\nf_26(\"123456789\") // returns 9\nf_26(\"123456789012345678901234567890\") // returns 9\nf_26(\"12345\") // returns 6\nf_26(\"999999999\") // returns 9", "ml": "JavaScript ഫംഗ്ഷൻ `function f_26(x)` എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nഇനിപ്പറയുന്ന രീതിയിൽ പൂർണ്ണസംഖ്യ x-നെ വർഗ്ഗീകരിക്കുക:\nx ഒറ്റ അക്ക സംഖ്യയായാൽ, x സ്വന്തം വർഗ്ഗത്തിൽ പെട്ടതാണ്.\nഇല്ലെങ്കിൽ, x-ന്റെ അക്കങ്ങൾ കൂട്ടിച്ചേർക്കുക, ഒരു പുതിയ x നേടുക, വർഗ്ഗം നിർണ്ണയിക്കുന്നതുവരെ ആവർത്തിക്കുക.\n\nപാരാമീറ്ററുകൾ:\n- x (string): പൂർണ്ണസംഖ്യയെ ഒരു സ്ട്രിംഗായി വർഗ്ഗീകരിക്കേണ്ടത്.\n\nമടക്കുന്നു:\nint: പൂർണ്ണസംഖ്യ x ഏത് വർഗ്ഗത്തിൽ പെടുന്നു.\n\nഉദാഹരണങ്ങൾ:\nf_26(\"24\") // 6 മടക്കുന്നു\nf_26(\"39\") // 3 മടക്കുന്നു\nf_26(\"123456789\") // 9 മടക്കുന്നു\nf_26(\"123456789012345678901234567890\") // 9 മടക്കുന്നു\nf_26(\"12345\") // 6 മടക്കുന്നു\nf_26(\"999999999\") // 9 മടക്കുന്നു", "fa": "یک تابع جاوااسکریپت `function f_26(x)` بنویسید تا مسئله زیر را حل کند:\nعدد صحیح x را بر اساس روش زیر طبقه‌بندی کنید:\nاگر x یک عدد یک‌رقمی است، x به کلاس خودش تعلق دارد.\nدر غیر این صورت، ارقام x را جمع کنید، یک x جدید بگیرید، و تا زمانی که کلاس تعیین شود تکرار کنید.\n\nپارامترها:\n- x (string): عدد صحیحی که به صورت رشته برای طبقه‌بندی است.\n\nبازگشت:\nint: کلاسی که عدد صحیح x به آن تعلق دارد.\n\nمثال‌ها:\nf_26(\"24\") // returns 6\nf_26(\"39\") // returns 3\nf_26(\"123456789\") // returns 9\nf_26(\"123456789012345678901234567890\") // returns 9\nf_26(\"12345\") // returns 6\nf_26(\"999999999\") // returns 9"}, "level": "easy", "test": "function testf_26() {\n    console.assert(f_26(\"24\") === 6, \"Test failed: f_26('24') should return 6.\");\n    console.assert(f_26(\"39\") === 3, \"Test failed: f_26('39') should return 3.\");\n    console.assert(f_26(\"123456789\") === 9, \"Test failed: f_26('123456789') should return 9.\");\n    console.assert(f_26(\"123456789012345678901234567890\") === 9, \"Test failed: f_26('123456789012345678901234567890') should return 9.\");\n    console.assert(f_26(\"12345\") === 6, \"Test failed: f_26('12345') should return 6.\");\n    console.assert(f_26(\"999999999\") === 9, \"Test failed: f_26('999999999') should return 9.\");\n}\n\ntestf_26();", "entry_point": "f_26", "signature": "function f_26(x)", "docstring": {"en": "Classify the integer x based on the following method:\nIf x is a single-digit number, x belongs to its own class.\nOtherwise, sum the digits of x, get a new x, and iterate until \nthe class is determined.\n\nParameters:\n- x (string): The integer to be classified as a string.\n\nReturns:\nint: The class to which the integer x belongs.\n\nExamples:\nf_26(\"24\") // returns 6\nf_26(\"39\") // returns 3\nf_26(\"123456789\") // returns 9\nf_26(\"123456789012345678901234567890\") // returns 9\nf_26(\"12345\") // returns 6\nf_26(\"999999999\") // returns 9", "sq": "Klasifikoni numrin e plotë x bazuar në metodën e mëposhtme:\nNëse x është një numër me një shifër, x i përket klasës së vet.\nPërndryshe, mblidhni shifrat e x, merrni një x të ri dhe përsëritni derisa \nklasa të përcaktohet.\n\nParametrat:\n- x (string): Numri i plotë që do të klasifikohet si një varg.\n\nKthen:\nint: Klasa së cilës i përket numri i plotë x.\n\nShembuj:\nf_26(\"24\") // kthen 6\nf_26(\"39\") // kthen 3\nf_26(\"123456789\") // kthen 9\nf_26(\"123456789012345678901234567890\") // kthen 9\nf_26(\"12345\") // kthen 6\nf_26(\"999999999\") // kthen 9", "hy": "Դասակարգել ամբողջ թիվը x-ը հետևյալ մեթոդով:\nԵթե x-ը միանիշ թիվ է, ապա x-ը պատկանում է իր սեփական դասին:\nՀակառակ դեպքում, գումարեք x-ի թվանշանները, ստացեք նոր x և կրկնեք, մինչև \nդասը որոշվի:\n\nՊարամետրեր:\n- x (string): Որպես տող դասակարգվելիք ամբողջ թիվը:\n\nՎերադարձնում է:\nint: Դասը, որին պատկանում է ամբողջ թիվը x-ը:\n\nՕրինակներ:\nf_26(\"24\") // վերադարձնում է 6\nf_26(\"39\") // վերադարձնում է 3\nf_26(\"123456789\") // վերադարձնում է 9\nf_26(\"123456789012345678901234567890\") // վերադարձնում է 9\nf_26(\"12345\") // վերադարձնում է 6\nf_26(\"999999999\") // վերադարձնում է 9", "bn": "ইন্টিজার x কে নিম্নলিখিত পদ্ধতির ভিত্তিতে শ্রেণীবদ্ধ করুন:\nযদি x একটি একক-সংখ্যার সংখ্যা হয়, তাহলে x তার নিজস্ব শ্রেণীতে অন্তর্ভুক্ত।\nঅন্যথায়, x এর অঙ্কগুলির যোগফল নিন, একটি নতুন x পান, এবং পুনরাবৃত্তি করুন যতক্ষণ না শ্রেণী নির্ধারিত হয়।\n\nপ্যারামিটার:\n- x (string): ইন্টিজারটি একটি স্ট্রিং হিসেবে শ্রেণীবদ্ধ করার জন্য।\n\nরিটার্নস:\nint: শ্রেণী যেখানে ইন্টিজার x অন্তর্ভুক্ত।\n\nউদাহরণ:\nf_26(\"24\") // 6 রিটার্ন করে\nf_26(\"39\") // 3 রিটার্ন করে\nf_26(\"123456789\") // 9 রিটার্ন করে\nf_26(\"123456789012345678901234567890\") // 9 রিটার্ন করে\nf_26(\"12345\") // 6 রিটার্ন করে\nf_26(\"999999999\") // 9 রিটার্ন করে", "bg": "Класифицирайте цялото число x въз основа на следния метод:\nАко x е едноцифрено число, x принадлежи на своя собствен клас.\nВ противен случай, съберете цифрите на x, получете ново x и повтаряйте, докато класът бъде определен.\n\nПараметри:\n- x (string): Цялото число, което трябва да бъде класифицирано, като низ.\n\nВръща:\nint: Класът, към който принадлежи цялото число x.\n\nПримери:\nf_26(\"24\") // връща 6\nf_26(\"39\") // връща 3\nf_26(\"123456789\") // връща 9\nf_26(\"123456789012345678901234567890\") // връща 9\nf_26(\"12345\") // връща 6\nf_26(\"999999999\") // връща 9", "zh": "将整数 x 分类，基于以下方法：\n如果 x 是一个个位数，则 x 属于它自己的类。\n否则，将 x 的各位数字相加，得到一个新的 x，并迭代直到确定类。\n\n参数：\n- x (string): 要分类的整数，作为字符串。\n\n返回：\nint: 整数 x 所属的类。\n\n示例：\nf_26(\"24\") // 返回 6\nf_26(\"39\") // 返回 3\nf_26(\"123456789\") // 返回 9\nf_26(\"123456789012345678901234567890\") // 返回 9\nf_26(\"12345\") // 返回 6\nf_26(\"999999999\") // 返回 9", "fr": "Classifiez l'entier x selon la méthode suivante :\nSi x est un nombre à un chiffre, x appartient à sa propre classe.\nSinon, additionnez les chiffres de x, obtenez un nouveau x, et itérez jusqu'à ce que la classe soit déterminée.\n\nParamètres :\n- x (string): L'entier à classer sous forme de chaîne de caractères.\n\nRenvoie :\nint: La classe à laquelle appartient l'entier x.\n\nExemples :\nf_26(\"24\") // renvoie 6\nf_26(\"39\") // renvoie 3\nf_26(\"123456789\") // renvoie 9\nf_26(\"123456789012345678901234567890\") // renvoie 9\nf_26(\"12345\") // renvoie 6\nf_26(\"999999999\") // renvoie 9", "de": "Klassifizieren Sie die ganze Zahl x basierend auf der folgenden Methode:\nWenn x eine einstellige Zahl ist, gehört x zu seiner eigenen Klasse.\nAndernfalls summieren Sie die Ziffern von x, erhalten ein neues x und wiederholen, bis \ndie Klasse bestimmt ist.\n\nParameter:\n- x (string): Die zu klassifizierende ganze Zahl als Zeichenkette.\n\nRückgabewerte:\nint: Die Klasse, zu der die ganze Zahl x gehört.\n\nBeispiele:\nf_26(\"24\") // gibt 6 zurück\nf_26(\"39\") // gibt 3 zurück\nf_26(\"123456789\") // gibt 9 zurück\nf_26(\"123456789012345678901234567890\") // gibt 9 zurück\nf_26(\"12345\") // gibt 6 zurück\nf_26(\"999999999\") // gibt 9 zurück", "ha": "Rarraba lambar x bisa ga hanyar da ke gaba:\nIdan x lamba ce mai lamba guda ɗaya, x tana cikin ajinta.\nIn ba haka ba, tara lambobin x, sami sabon x, kuma maimaita har \nan tantance ajin.\n\nParameters:\n- x (string): Lambar da za a tantance a matsayin kirtani.\n\nReturns:\nint: Aji wanda lambar x take ciki.\n\nExamples:\nf_26(\"24\") // returns 6\nf_26(\"39\") // returns 3\nf_26(\"123456789\") // returns 9\nf_26(\"123456789012345678901234567890\") // returns 9\nf_26(\"12345\") // returns 6\nf_26(\"999999999\") // returns 9", "hi": "पूरे संख्या x को निम्नलिखित विधि के आधार पर वर्गीकृत करें:\nयदि x एकल अंक की संख्या है, तो x अपनी स्वयं की श्रेणी में आता है।\nअन्यथा, x के अंकों का योग करें, एक नया x प्राप्त करें, और तब तक पुनरावृत्ति करें जब तक कि श्रेणी निर्धारित न हो जाए।\n\nपैरामीटर्स:\n- x (string): पूर्णांक को एक स्ट्रिंग के रूप में वर्गीकृत करने के लिए।\n\nवापसी:\nint: वह श्रेणी जिसमें पूर्णांक x आता है।\n\nउदाहरण:\nf_26(\"24\") // 6 लौटाता है\nf_26(\"39\") // 3 लौटाता है\nf_26(\"123456789\") // 9 लौटाता है\nf_26(\"123456789012345678901234567890\") // 9 लौटाता है\nf_26(\"12345\") // 6 लौटाता है\nf_26(\"999999999\") // 9 लौटाता है", "hu": "Osztályozza az x egész számot az alábbi módszer alapján:\nHa x egyjegyű szám, akkor x a saját osztályába tartozik.\nEgyébként adja össze x számjegyeit, kapjon egy új x-et, és ismételje meg, amíg az osztály meg nem határozódik.\n\nParaméterek:\n- x (string): Az osztályozandó egész szám sztringként.\n\nVisszatér:\nint: Az osztály, amelyhez az x egész szám tartozik.\n\nPéldák:\nf_26(\"24\") // visszaadja 6\nf_26(\"39\") // visszaadja 3\nf_26(\"123456789\") // visszaadja 9\nf_26(\"123456789012345678901234567890\") // visszaadja 9\nf_26(\"12345\") // visszaadja 6\nf_26(\"999999999\") // visszaadja 9", "es": "Clasificar el entero x basado en el siguiente método:  \nSi x es un número de un solo dígito, x pertenece a su propia clase.  \nDe lo contrario, suma los dígitos de x, obtén un nuevo x, e itera hasta que  \nse determine la clase.\n\nParámetros:  \n- x (string): El entero a clasificar como una cadena.\n\nDevuelve:  \nint: La clase a la que pertenece el entero x.\n\nEjemplos:  \nf_26(\"24\") // devuelve 6  \nf_26(\"39\") // devuelve 3  \nf_26(\"123456789\") // devuelve 9  \nf_26(\"123456789012345678901234567890\") // devuelve 9  \nf_26(\"12345\") // devuelve 6  \nf_26(\"999999999\") // devuelve 9  ", "arb": "تصنيف العدد الصحيح x بناءً على الطريقة التالية:\nإذا كان x رقمًا مكونًا من خانة واحدة، فإن x ينتمي إلى فئته الخاصة.\nوإلا، قم بجمع أرقام x، واحصل على x جديد، وكرر حتى يتم تحديد الفئة.\n\nالمعطيات:\n- x (string): العدد الصحيح الذي سيتم تصنيفه كسلسلة.\n\nالقيم المعادة:\nint: الفئة التي ينتمي إليها العدد الصحيح x.\n\nأمثلة:\nf_26(\"24\") // يعيد 6\nf_26(\"39\") // يعيد 3\nf_26(\"123456789\") // يعيد 9\nf_26(\"123456789012345678901234567890\") // يعيد 9\nf_26(\"12345\") // يعيد 6\nf_26(\"999999999\") // يعيد 9", "sw": "Tambua nambari nzima x kulingana na njia ifuatayo:\nIkiwa x ni nambari ya tarakimu moja, x inahusiana na darasa lake lenyewe.\nVinginevyo, jumlisha tarakimu za x, pata x mpya, na rudia hadi \ndarasa litakapobainishwa.\n\nVigezo:\n- x (string): Nambari nzima inayopaswa kutambuliwa kama kamba.\n\nInarejesha:\nint: Darasa ambalo nambari nzima x inahusiana.\n\nMifano:\nf_26(\"24\") // inarejesha 6\nf_26(\"39\") // inarejesha 3\nf_26(\"123456789\") // inarejesha 9\nf_26(\"123456789012345678901234567890\") // inarejesha 9\nf_26(\"12345\") // inarejesha 6\nf_26(\"999999999\") // inarejesha 9", "tr": "Tamsayı x'i aşağıdaki yönteme göre sınıflandırın:\nEğer x tek basamaklı bir sayı ise, x kendi sınıfına aittir.\nAksi takdirde, x'in basamaklarını toplayın, yeni bir x elde edin ve sınıf belirlenene kadar yineleyin.\n\nParametreler:\n- x (string): Sınıflandırılacak tamsayıyı bir string olarak belirtir.\n\nDöndürülen:\nint: Tamsayı x'in ait olduğu sınıf.\n\nÖrnekler:\nf_26(\"24\") // 6 döndürür\nf_26(\"39\") // 3 döndürür\nf_26(\"123456789\") // 9 döndürür\nf_26(\"123456789012345678901234567890\") // 9 döndürür\nf_26(\"12345\") // 6 döndürür\nf_26(\"999999999\") // 9 döndürür", "vi": "Phân loại số nguyên x dựa trên phương pháp sau:\nNếu x là một số có một chữ số, x thuộc về lớp của chính nó.\nNgược lại, cộng các chữ số của x, lấy một x mới, và lặp lại cho đến khi lớp được xác định.\n\nTham số:\n- x (string): Số nguyên cần phân loại dưới dạng chuỗi.\n\nTrả về:\nint: Lớp mà số nguyên x thuộc về.\n\nVí dụ:\nf_26(\"24\") // trả về 6\nf_26(\"39\") // trả về 3\nf_26(\"123456789\") // trả về 9\nf_26(\"123456789012345678901234567890\") // trả về 9\nf_26(\"12345\") // trả về 6\nf_26(\"999999999\") // trả về 9", "id": "Klasifikasikan bilangan bulat x berdasarkan metode berikut:\nJika x adalah angka satu digit, x termasuk dalam kelasnya sendiri.\nJika tidak, jumlahkan digit-digit dari x, dapatkan x baru, dan iterasi sampai\nkelas ditentukan.\n\nParameter:\n- x (string): Bilangan bulat yang akan diklasifikasikan sebagai string.\n\nMengembalikan:\nint: Kelas di mana bilangan bulat x termasuk.\n\nContoh:\nf_26(\"24\") // mengembalikan 6\nf_26(\"39\") // mengembalikan 3\nf_26(\"123456789\") // mengembalikan 9\nf_26(\"123456789012345678901234567890\") // mengembalikan 9\nf_26(\"12345\") // mengembalikan 6\nf_26(\"999999999\") // mengembalikan 9", "ja": "整数 x を次の方法で分類します:\nx が一桁の数である場合、x はそれ自身のクラスに属します。\nそれ以外の場合、x の桁を合計し、新しい x を取得し、クラスが決定されるまで繰り返します。\n\nパラメータ:\n- x (string): 文字列として分類される整数。\n\n戻り値:\nint: 整数 x が属するクラス。\n\n例:\nf_26(\"24\") // returns 6\nf_26(\"39\") // returns 3\nf_26(\"123456789\") // returns 9\nf_26(\"123456789012345678901234567890\") // returns 9\nf_26(\"12345\") // returns 6\nf_26(\"999999999\") // returns 9", "ko": "정수 x를 다음 방법에 따라 분류합니다:\nx가 한 자리 숫자이면, x는 자신의 클래스에 속합니다.\n그렇지 않으면, x의 자릿수를 합산하여 새로운 x를 얻고, 클래스가 결정될 때까지 반복합니다.\n\n매개변수:\n- x (string): 문자열로 된 분류할 정수.\n\n반환:\nint: 정수 x가 속하는 클래스.\n\n예시:\nf_26(\"24\") // returns 6\nf_26(\"39\") // returns 3\nf_26(\"123456789\") // returns 9\nf_26(\"123456789012345678901234567890\") // returns 9\nf_26(\"12345\") // returns 6\nf_26(\"999999999\") // returns 9", "ml": "പൂർവ്വനിശ്ചയിച്ചിരിക്കുന്ന രീതിയിൽ പൂർണ്ണസംഖ്യ x-നെ വർഗ്ഗീകരിക്കുക:\nx ഒറ്റ അക്ക സംഖ്യയായാൽ, x സ്വന്തം വർഗ്ഗത്തിൽപ്പെടുന്നു.\nഇല്ലെങ്കിൽ, x-ന്റെ അക്കങ്ങൾ കൂട്ടിച്ചേർത്ത് പുതിയ x ലഭിക്കുക, വർഗ്ഗം നിർണയിക്കുന്നതുവരെ ആവർത്തിക്കുക.\n\nപാരാമീറ്ററുകൾ:\n- x (string): പൂർണ്ണസംഖ്യയെ ഒരു സ്ട്രിംഗായി വർഗ്ഗീകരിക്കാൻ.\n\nമടക്കം:\nint: പൂർണ്ണസംഖ്യ x ഏതു വർഗ്ഗത്തിൽപ്പെടുന്നു.\n\nഉദാഹരണങ്ങൾ:\nf_26(\"24\") // 6 മടക്കുന്നു\nf_26(\"39\") // 3 മടക്കുന്നു\nf_26(\"123456789\") // 9 മടക്കുന്നു\nf_26(\"123456789012345678901234567890\") // 9 മടക്കുന്നു\nf_26(\"12345\") // 6 മടക്കുന്നു\nf_26(\"999999999\") // 9 മടക്കുന്നു", "fa": "طبقه‌بندی عدد صحیح x بر اساس روش زیر: \nاگر x یک عدد یک‌رقمی باشد، x به کلاس خودش تعلق دارد.  \nدر غیر این صورت، ارقام x را جمع کنید، یک x جدید به دست آورید و تکرار کنید تا کلاس تعیین شود.\n\nParameters:  \n- x (string): عدد صحیحی که باید به‌صورت رشته‌ای طبقه‌بندی شود.\n\nReturns:  \nint: کلاسی که عدد صحیح x به آن تعلق دارد.\n\nExamples:  \nf_26(\"24\") // returns 6  \nf_26(\"39\") // returns 3  \nf_26(\"123456789\") // returns 9  \nf_26(\"123456789012345678901234567890\") // returns 9  \nf_26(\"12345\") // returns 6  \nf_26(\"999999999\") // returns 9  "}}
{"task_id": "JavaScript/27", "prompt": {"en": "/**\n * Transforms the case of a given letter.\n * - letter (char): The input letter to be transformed.\n * \n * Returns:\n * - char: The letter with its case reversed. If the input is lowercase,\n * returns uppercase, and if the input is uppercase, returns lowercase.\n * \n * Example:\n * f_27('b') returns 'B'\n * f_27('Z') returns 'z'\n */\nfunction f_27(letter)", "sq": "/**\n * Transformon shkronjën e dhënë në rastin tjetër.\n * - letter (char): Shkronja hyrëse që do të transformohet.\n * \n * Kthen:\n * - char: Shkronja me rastin e saj të përmbysur. Nëse hyrja është me shkronja të vogla,\n * kthen me shkronja të mëdha, dhe nëse hyrja është me shkronja të mëdha, kthen me shkronja të vogla.\n * \n * Shembull:\n * f_27('b') kthen 'B'\n * f_27('Z') kthen 'z'\n */\nfunction f_27(letter)", "hy": "/**\n * Փոխակերպում է տրված տառի ռեգիստրը։\n * - letter (char): Մուտքային տառը, որը պետք է փոխակերպվի։\n * \n * Վերադարձնում է:\n * - char: Տառը՝ իր ռեգիստրը փոխված։ Եթե մուտքը փոքրատառ է,\n * վերադարձնում է մեծատառ, և եթե մուտքը մեծատառ է, վերադարձնում է փոքրատառ։\n * \n * Օրինակ:\n * f_27('b') վերադարձնում է 'B'\n * f_27('Z') վերադարձնում է 'z'\n */\nfunction f_27(letter)", "bn": "/**\n * প্রদত্ত একটি অক্ষরের কেস পরিবর্তন করে।\n * - letter (char): পরিবর্তন করার জন্য ইনপুট অক্ষর।\n * \n * রিটার্ন:\n * - char: অক্ষরটি যার কেস বিপরীত করা হয়েছে। যদি ইনপুট ছোট হাতের হয়,\n * বড় হাতের রিটার্ন করে, এবং যদি ইনপুট বড় হাতের হয়, ছোট হাতের রিটার্ন করে।\n * \n * উদাহরণ:\n * f_27('b') returns 'B'\n * f_27('Z') returns 'z'\n */\nfunction f_27(letter)", "bg": "/**\n * Преобразува регистъра на дадена буква.\n * - letter (char): Входната буква, която ще бъде преобразувана.\n * \n * Връща:\n * - char: Буквата с обърнат регистър. Ако входът е с малки букви,\n * връща с главни букви, и ако входът е с главни букви, връща с малки букви.\n * \n * Пример:\n * f_27('b') връща 'B'\n * f_27('Z') връща 'z'\n */\nfunction f_27(letter)", "zh": "/**\n * 转换给定字母的大小写。\n * - letter (char): 要转换的输入字母。\n * \n * 返回:\n * - char: 大小写已转换的字母。如果输入是小写，则返回大写；如果输入是大写，则返回小写。\n * \n * 示例:\n * f_27('b') returns 'B'\n * f_27('Z') returns 'z'\n */\nfunction f_27(letter)", "fr": "/**\n * Transforme la casse d'une lettre donnée.\n * - letter (char): La lettre d'entrée à transformer.\n * \n * Renvoie:\n * - char: La lettre avec sa casse inversée. Si l'entrée est en minuscule,\n * renvoie en majuscule, et si l'entrée est en majuscule, renvoie en minuscule.\n * \n * Exemple:\n * f_27('b') returns 'B'\n * f_27('Z') returns 'z'\n */\nfunction f_27(letter)", "de": "/**\n * Transformiert die Groß-/Kleinschreibung eines gegebenen Buchstabens.\n * - letter (char): Der Eingabebuchstabe, dessen Groß-/Kleinschreibung transformiert werden soll.\n * \n * Rückgabe:\n * - char: Der Buchstabe mit umgekehrter Groß-/Kleinschreibung. Wenn die Eingabe klein geschrieben ist,\n * wird groß zurückgegeben, und wenn die Eingabe groß geschrieben ist, wird klein zurückgegeben.\n * \n * Beispiel:\n * f_27('b') gibt 'B' zurück\n * f_27('Z') gibt 'z' zurück\n */\nfunction f_27(letter)", "ha": "/**\n * Canza yanayin harafin da aka bayar.\n * - letter (char): Harafin da za a canza yanayinsa.\n * \n * Returns:\n * - char: Harafin tare da yanayinsa da aka juya. Idan shigarwar tana cikin ƙananan haruffa,\n * yana dawowa cikin manyan haruffa, kuma idan shigarwar tana cikin manyan haruffa, yana dawowa cikin ƙananan haruffa.\n * \n * Example:\n * f_27('b') returns 'B'\n * f_27('Z') returns 'z'\n */\nfunction f_27(letter)", "hi": "/**\n * दिए गए अक्षर के मामले को बदलता है।\n * - letter (char): परिवर्तित किए जाने वाला इनपुट अक्षर।\n * \n * Returns:\n * - char: अक्षर जिसका मामला उलट दिया गया है। यदि इनपुट लोअरकेस है,\n * तो अपरकेस लौटाता है, और यदि इनपुट अपरकेस है, तो लोअरकेस लौटाता है।\n * \n * Example:\n * f_27('b') returns 'B'\n * f_27('Z') returns 'z'\n */\nfunction f_27(letter)", "hu": "/**\n * Egy adott betű esetét alakítja át.\n * - letter (char): Az átalakítandó bemeneti betű.\n * \n * Visszatér:\n * - char: A betű megfordított esettel. Ha a bemenet kisbetűs,\n * nagybetűs formában tér vissza, és ha a bemenet nagybetűs, kisbetűs formában tér vissza.\n * \n * Példa:\n * f_27('b') visszaadja 'B'\n * f_27('Z') visszaadja 'z'\n */\nfunction f_27(letter)", "es": "/**\n * Transforma el caso de una letra dada.\n * - letter (char): La letra de entrada a ser transformada.\n * \n * Devuelve:\n * - char: La letra con su caso invertido. Si la entrada es minúscula,\n * devuelve mayúscula, y si la entrada es mayúscula, devuelve minúscula.\n * \n * Ejemplo:\n * f_27('b') devuelve 'B'\n * f_27('Z') devuelve 'z'\n */\nfunction f_27(letter)", "arb": "/**\n * يحول حالة حرف معين.\n * - letter (char): الحرف المدخل الذي سيتم تحويله.\n * \n * يعيد:\n * - char: الحرف مع عكس حالته. إذا كان المدخل بحروف صغيرة،\n * يعيد بحروف كبيرة، وإذا كان المدخل بحروف كبيرة، يعيد بحروف صغيرة.\n * \n * مثال:\n * f_27('b') يعيد 'B'\n * f_27('Z') يعيد 'z'\n */\nfunction f_27(letter)", "sw": "/**\n * Hubadilisha herufi kubwa au ndogo ya herufi iliyotolewa.\n * - letter (char): Herufi ya kuingiza inayopaswa kubadilishwa.\n * \n * Inarudisha:\n * - char: Herufi ikiwa na herufi kubwa au ndogo imebadilishwa. Ikiwa ingizo ni herufi ndogo,\n * inarudisha herufi kubwa, na ikiwa ingizo ni herufi kubwa, inarudisha herufi ndogo.\n * \n * Mfano:\n * f_27('b') inarejesha 'B'\n * f_27('Z') inarejesha 'z'\n */\nfunction f_27(letter)", "tr": "/**\n * Verilen bir harfin büyük/küçük harf durumunu değiştirir.\n * - letter (char): Dönüştürülecek giriş harfi.\n * \n * Döndürür:\n * - char: Harfin büyük/küçük harf durumu ters çevrilmiş hali. Eğer giriş küçük harfse,\n * büyük harf olarak döner ve eğer giriş büyük harfse, küçük harf olarak döner.\n * \n * Örnek:\n * f_27('b') 'B' döner\n * f_27('Z') 'z' döner\n */\nfunction f_27(letter)", "vi": "/**\n * Chuyển đổi chữ hoa/thường của một chữ cái cho trước.\n * - letter (char): Chữ cái đầu vào cần được chuyển đổi.\n * \n * Trả về:\n * - char: Chữ cái với chữ hoa/thường được đảo ngược. Nếu đầu vào là chữ thường,\n * trả về chữ hoa, và nếu đầu vào là chữ hoa, trả về chữ thường.\n * \n * Ví dụ:\n * f_27('b') trả về 'B'\n * f_27('Z') trả về 'z'\n */\nfunction f_27(letter)", "id": "/**\n * Mengubah huruf menjadi bentuk lain.\n * - letter (char): Huruf masukan yang akan diubah.\n * \n * Mengembalikan:\n * - char: Huruf dengan bentuk yang dibalik. Jika masukan adalah huruf kecil,\n * mengembalikan huruf besar, dan jika masukan adalah huruf besar, mengembalikan huruf kecil.\n * \n * Contoh:\n * f_27('b') mengembalikan 'B'\n * f_27('Z') mengembalikan 'z'\n */\nfunction f_27(letter)", "ja": "/**\n * 指定された文字の大文字小文字を変換します。\n * - letter (char): 変換する入力文字。\n * \n * 戻り値:\n * - char: 大文字小文字が反転された文字。入力が小文字の場合は大文字を返し、入力が大文字の場合は小文字を返します。\n * \n * 例:\n * f_27('b') returns 'B'\n * f_27('Z') returns 'z'\n */\nfunction f_27(letter)", "ko": "/**\n * 주어진 문자의 대소문자를 변환합니다.\n * - letter (char): 변환할 입력 문자입니다.\n * \n * 반환값:\n * - char: 대소문자가 반전된 문자입니다. 입력이 소문자이면 대문자를 반환하고, 입력이 대문자이면 소문자를 반환합니다.\n * \n * 예시:\n * f_27('b') returns 'B'\n * f_27('Z') returns 'z'\n */\nfunction f_27(letter)", "ml": "/**\n * നൽകിയ അക്ഷരത്തിന്റെ കേസ് മാറ്റുന്നു.\n * - letter (char): മാറ്റേണ്ട ഇൻപുട്ട് അക്ഷരം.\n * \n * Returns:\n * - char: അക്ഷരത്തിന്റെ കേസ് മറിച്ചിരിക്കുന്നു. ഇൻപുട്ട് ചെറിയക്ഷരമെങ്കിൽ,\n * വലിയക്ഷരം തിരികെ നൽകുന്നു, ഇൻപുട്ട് വലിയക്ഷരമെങ്കിൽ, ചെറിയക്ഷരം തിരികെ നൽകുന്നു.\n * \n * Example:\n * f_27('b') returns 'B'\n * f_27('Z') returns 'z'\n */\nfunction f_27(letter)", "fa": "/**\n * تغییر حالت حروف یک حرف داده شده.\n * - letter (char): حرف ورودی که باید تغییر حالت داده شود.\n * \n * بازگشت:\n * - char: حرف با حالت برعکس. اگر ورودی حروف کوچک باشد،\n * حروف بزرگ بازمی‌گرداند و اگر ورودی حروف بزرگ باشد، حروف کوچک بازمی‌گرداند.\n * \n * مثال:\n * f_27('b') returns 'B'\n * f_27('Z') returns 'z'\n */\nfunction f_27(letter)"}, "canonical_solution": "{\n    const charCode = letter.charCodeAt(0);\n    if (charCode >= 'A'.charCodeAt(0) && charCode <= 'Z'.charCodeAt(0)) {\n        // Convert uppercase to lowercase\n        return String.fromCharCode(charCode + ('a'.charCodeAt(0) - 'A'.charCodeAt(0)));\n    } else if (charCode >= 'a'.charCodeAt(0) && charCode <= 'z'.charCodeAt(0)) {\n        // Convert lowercase to uppercase\n        return String.fromCharCode(charCode - ('a'.charCodeAt(0) - 'A'.charCodeAt(0)));\n    } else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}", "instruction": {"en": "Write a JavaScript function `function f_27(letter)` to solve the following problem:\nTransforms the case of a given letter.\n- letter (char): The input letter to be transformed.\n\nReturns:\n- char: The letter with its case reversed. If the input is lowercase, returns uppercase, and if the input is uppercase, returns lowercase.\n\nExample:\nf_27('b') returns 'B'\nf_27('Z') returns 'z'", "sq": "Shkruani një funksion JavaScript `function f_27(letter)` për të zgjidhur problemin e mëposhtëm:\nTransformon rastin e një shkronje të dhënë.\n- letter (char): Shkronja hyrëse që do të transformohet.\n\nKthen:\n- char: Shkronja me rastin e saj të kthyer. Nëse hyrja është me shkronja të vogla, kthen me shkronja të mëdha, dhe nëse hyrja është me shkronja të mëdha, kthen me shkronja të vogla.\n\nShembull:\nf_27('b') kthen 'B'\nf_27('Z') kthen 'z'", "hy": "Գրեք JavaScript ֆունկցիա `function f_27(letter)` հետևյալ խնդիրը լուծելու համար:\nՓոխակերպում է տրված տառի ռեգիստրը։\n- letter (char): Մուտքային տառը, որը պետք է փոխակերպվի։\n\nՎերադարձնում է:\n- char: Տառը՝ իր ռեգիստրը փոխված։ Եթե մուտքը փոքրատառ է, վերադարձնում է մեծատառ, իսկ եթե մուտքը մեծատառ է, վերադարձնում է փոքրատառ։\n\nՕրինակ:\nf_27('b') վերադարձնում է 'B'\nf_27('Z') վերադարձնում է 'z'", "bn": "একটি জাভাস্ক্রিপ্ট ফাংশন `function f_27(letter)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি প্রদত্ত অক্ষরের কেস পরিবর্তন করে।\n- letter (char): পরিবর্তন করার জন্য ইনপুট অক্ষর।\n\nফেরত দেয়:\n- char: অক্ষরটি যার কেস বিপরীত হয়েছে। যদি ইনপুট ছোট হাতের হয়, তাহলে বড় হাতের ফেরত দেয়, এবং যদি ইনপুট বড় হাতের হয়, তাহলে ছোট হাতের ফেরত দেয়।\n\nউদাহরণ:\nf_27('b') returns 'B'\nf_27('Z') returns 'z'", "bg": "Напишете JavaScript функция `function f_27(letter)` за решаване на следния проблем:  \nПреобразува регистъра на дадена буква.  \n- letter (char): Входната буква, която ще бъде преобразувана.\n\nВръща:  \n- char: Буквата с обърнат регистър. Ако входът е с малки букви, връща с главни букви, и ако входът е с главни букви, връща с малки букви.\n\nПример:  \nf_27('b') връща 'B'  \nf_27('Z') връща 'z'", "zh": "编写一个 JavaScript 函数 `function f_27(letter)` 来解决以下问题：\n转换给定字母的大小写。\n- letter (char): 要转换的输入字母。\n\n返回：\n- char: 大小写已反转的字母。如果输入是小写，则返回大写；如果输入是大写，则返回小写。\n\n示例：\nf_27('b') 返回 'B'\nf_27('Z') 返回 'z'", "fr": "Écrire une fonction JavaScript `function f_27(letter)` pour résoudre le problème suivant :  \nTransforme la casse d'une lettre donnée.  \n- letter (char) : La lettre d'entrée à transformer.\n\nRenvoie :  \n- char : La lettre avec sa casse inversée. Si l'entrée est en minuscule, renvoie en majuscule, et si l'entrée est en majuscule, renvoie en minuscule.\n\nExemple :  \nf_27('b') renvoie 'B'  \nf_27('Z') renvoie 'z'", "de": "Schreiben Sie eine JavaScript-Funktion `function f_27(letter)`, um das folgende Problem zu lösen:\nTransformiert die Groß-/Kleinschreibung eines gegebenen Buchstabens.\n- letter (char): Der Eingabebuchstabe, der transformiert werden soll.\n\nRückgabe:\n- char: Der Buchstabe mit umgekehrter Groß-/Kleinschreibung. Wenn die Eingabe klein geschrieben ist, wird Großbuchstabe zurückgegeben, und wenn die Eingabe groß geschrieben ist, wird Kleinbuchstabe zurückgegeben.\n\nBeispiel:\nf_27('b') gibt 'B' zurück\nf_27('Z') gibt 'z' zurück", "ha": "Rubuta wani aikin JavaScript `function f_27(letter)` don warware matsalar mai zuwa:\nCanza yanayin harafin da aka bayar.\n- letter (char): Harafin shigarwa da za a canza.\n\nYana dawowa:\n- char: Harafin tare da yanayinsa da aka juya. Idan shigarwar tana cikin ƙananan haruffa, yana dawowa da manyan haruffa, kuma idan shigarwar tana cikin manyan haruffa, yana dawowa da ƙananan haruffa.\n\nMisali:\nf_27('b') yana dawowa 'B'\nf_27('Z') yana dawowa 'z'", "hi": "JavaScript फ़ंक्शन `function f_27(letter)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए अक्षर के केस को परिवर्तित करता है।\n- letter (char): परिवर्तित किए जाने वाला इनपुट अक्षर।\n\nवापसी:\n- char: अक्षर जिसका केस उलट दिया गया है। यदि इनपुट लोअरकेस है, तो अपरकेस लौटाता है, और यदि इनपुट अपरकेस है, तो लोअरकेस लौटाता है।\n\nउदाहरण:\nf_27('b') returns 'B'\nf_27('Z') returns 'z'", "hu": "Írj egy JavaScript függvényt `function f_27(letter)` a következő probléma megoldására:\nÁtalakítja egy adott betű kis- és nagybetűs formáját.\n- letter (char): Az átalakítandó bemeneti betű.\n\nVisszatérési érték:\n- char: A betű megfordított kis- és nagybetűs formában. Ha a bemenet kisbetűs, nagybetűs formát ad vissza, és ha a bemenet nagybetűs, kisbetűs formát ad vissza.\n\nPélda:\nf_27('b') visszaadja 'B'\nf_27('Z') visszaadja 'z'", "es": "Escribe una función de JavaScript `function f_27(letter)` para resolver el siguiente problema:\nTransforma el caso de una letra dada.\n- letter (char): La letra de entrada a transformar.\n\nDevuelve:\n- char: La letra con su caso invertido. Si la entrada es minúscula, devuelve mayúscula, y si la entrada es mayúscula, devuelve minúscula.\n\nEjemplo:\nf_27('b') devuelve 'B'\nf_27('Z') devuelve 'z'", "arb": "اكتب دالة JavaScript `function f_27(letter)` لحل المشكلة التالية:\nتحول حالة الحرف المعطى.\n- letter (char): الحرف المدخل الذي سيتم تحويله.\n\nالمخرجات:\n- char: الحرف مع حالته معكوسة. إذا كان المدخل بحروف صغيرة، يعيد حروف كبيرة، وإذا كان المدخل بحروف كبيرة، يعيد حروف صغيرة.\n\nمثال:\nf_27('b') يعيد 'B'\nf_27('Z') يعيد 'z'", "sw": "Andika kazi ya JavaScript `function f_27(letter)` kutatua tatizo lifuatalo:\nHubadilisha herufi kubwa au ndogo ya herufi iliyotolewa.\n- letter (char): Herufi ya kuingiza ambayo itabadilishwa.\n\nInarudisha:\n- char: Herufi ikiwa na herufi kubwa au ndogo imebadilishwa. Ikiwa ingizo ni herufi ndogo, inarudisha herufi kubwa, na ikiwa ingizo ni herufi kubwa, inarudisha herufi ndogo.\n\nMfano:\nf_27('b') inarudisha 'B'\nf_27('Z') inarudisha 'z'", "tr": "Bir JavaScript fonksiyonu `function f_27(letter)` yazın:\nVerilen bir harfin büyük/küçük harf durumunu dönüştürür.\n- letter (char): Dönüştürülecek giriş harfi.\n\nDöndürülen:\n- char: Harfin büyük/küçük durumu ters çevrilmiş hali. Eğer giriş küçük harfse, büyük harf döner ve eğer giriş büyük harfse, küçük harf döner.\n\nÖrnek:\nf_27('b') 'B' döner\nf_27('Z') 'z' döner", "vi": "Viết một hàm JavaScript `function f_27(letter)` để giải quyết vấn đề sau:\nChuyển đổi chữ hoa/thường của một chữ cái cho trước.\n- letter (char): Chữ cái đầu vào cần được chuyển đổi.\n\nTrả về:\n- char: Chữ cái với chữ hoa/thường được đảo ngược. Nếu đầu vào là chữ thường, trả về chữ hoa, và nếu đầu vào là chữ hoa, trả về chữ thường.\n\nVí dụ:\nf_27('b') trả về 'B'\nf_27('Z') trả về 'z'", "id": "Tulis sebuah fungsi JavaScript `function f_27(letter)` untuk menyelesaikan masalah berikut:\nMengubah huruf menjadi huruf dengan kasus yang berbeda.\n- letter (char): Huruf masukan yang akan diubah.\n\nMengembalikan:\n- char: Huruf dengan kasus yang dibalik. Jika masukan adalah huruf kecil, mengembalikan huruf besar, dan jika masukan adalah huruf besar, mengembalikan huruf kecil.\n\nContoh:\nf_27('b') mengembalikan 'B'\nf_27('Z') mengembalikan 'z'", "ja": "JavaScript関数`function f_27(letter)`を作成して、次の問題を解決してください:\n与えられた文字のケースを変換します。\n- letter (char): 変換する入力文字。\n\n戻り値:\n- char: ケースが逆になった文字。入力が小文字の場合は大文字を返し、入力が大文字の場合は小文字を返します。\n\n例:\nf_27('b') は 'B' を返します\nf_27('Z') は 'z' を返します", "ko": "JavaScript 함수를 작성하세요 `function f_27(letter)` 다음 문제를 해결하기 위해:\n주어진 문자의 대소문자를 변환합니다.\n- letter (char): 변환할 입력 문자입니다.\n\n반환:\n- char: 대소문자가 반전된 문자입니다. 입력이 소문자이면 대문자를 반환하고, 입력이 대문자이면 소문자를 반환합니다.\n\n예시:\nf_27('b') returns 'B'\nf_27('Z') returns 'z'", "ml": "`function f_27(letter)` എന്ന ജാവാസ്ക്രിപ്റ്റ് ഫംഗ്ഷൻ എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nനൽകിയിരിക്കുന്ന അക്ഷരത്തിന്റെ കേസ് മാറ്റുന്നു.\n- letter (char): മാറ്റാൻ വേണ്ട ഇൻപുട്ട് അക്ഷരം.\n\nമടക്കം:\n- char: അക്ഷരത്തിന്റെ കേസ് മറിച്ചുള്ളത്. ഇൻപുട്ട് ചെറിയക്ഷരമാണെങ്കിൽ, വലിയക്ഷരമാക്കുകയും, ഇൻപുട്ട് വലിയക്ഷരമാണെങ്കിൽ, ചെറിയക്ഷരമാക്കുകയും ചെയ്യുന്നു.\n\nഉദാഹരണം:\nf_27('b') 'B' മടക്കുന്നു\nf_27('Z') 'z' മടക്കുന്നു", "fa": "یک تابع جاوااسکریپت `function f_27(letter)` بنویسید تا مسئله زیر را حل کند:\nحالت یک حرف داده شده را تغییر می‌دهد.\n- letter (char): حرف ورودی که باید تغییر یابد.\n\nبرمی‌گرداند:\n- char: حرف با حالت معکوس. اگر ورودی حروف کوچک باشد، حروف بزرگ برمی‌گرداند و اگر ورودی حروف بزرگ باشد، حروف کوچک برمی‌گرداند.\n\nمثال:\nf_27('b') برمی‌گرداند 'B'\nf_27('Z') برمی‌گرداند 'z'"}, "level": "hard", "test": "const testf_27 = () => {\n    console.assert(f_27('b') === 'B');\n    console.assert(f_27('B') === 'b');\n    // Additional test cases\n    console.assert(f_27('z') === 'Z');\n    console.assert(f_27('Z') === 'z');\n    console.assert(f_27('m') === 'M');\n    console.assert(f_27('M') === 'm');\n    console.assert(f_27('1') === '1'); // Non-alphabetic, should be unchanged\n    console.assert(f_27('!') === '!'); // Non-alphabetic, should be unchanged\n\n    // Uncomment the following line to log a message for passed tests\n    // console.log(\"All tests passed successfully.\");\n};\n\ntestf_27();", "entry_point": "f_27", "signature": "function f_27(letter)", "docstring": {"en": "Transforms the case of a given letter.\n- letter (char): The input letter to be transformed.\n\nReturns:\n- char: The letter with its case reversed. If the input is lowercase, returns uppercase, and if the input is uppercase, returns lowercase.\n\nExample:\nf_27('b') returns 'B'\nf_27('Z') returns 'z'", "sq": "Transformon rastin e një shkronje të dhënë.\n- letter (char): Shkronja hyrëse që do të transformohet.\n\nKthen:\n- char: Shkronja me rastin e saj të kthyer. Nëse hyrja është me shkronjë të vogël, kthen me shkronjë të madhe, dhe nëse hyrja është me shkronjë të madhe, kthen me shkronjë të vogël.\n\nShembull:\nf_27('b') kthen 'B'\nf_27('Z') kthen 'z'", "hy": "Փոխակերպում է տրված տառի ռեգիստրը:\n- letter (char): Մուտքային տառը, որը պետք է փոխակերպվի:\n\nՎերադարձնում է:\n- char: Տառը՝ իր ռեգիստրը փոխված: Եթե մուտքը փոքրատառ է, վերադարձնում է մեծատառ, և եթե մուտքը մեծատառ է, վերադարձնում է փոքրատառ:\n\nՕրինակ:\nf_27('b') վերադարձնում է 'B'\nf_27('Z') վերադարձնում է 'z'", "bn": "একটি প্রদত্ত অক্ষরের কেস পরিবর্তন করে।\n- letter (char): পরিবর্তন করার জন্য ইনপুট অক্ষর।\n\nReturns:\n- char: অক্ষরটি যার কেস বিপরীত করা হয়েছে। যদি ইনপুট ছোট হাতের হয়, তাহলে বড় হাতের ফেরত দেয়, এবং যদি ইনপুট বড় হাতের হয়, তাহলে ছোট হাতের ফেরত দেয়।\n\nExample:\nf_27('b') returns 'B'\nf_27('Z') returns 'z'", "bg": "Преобразува регистъра на дадена буква.\n- letter (char): Входната буква, която ще бъде преобразувана.\n\nВръща:\n- char: Буквата с обърнат регистър. Ако входът е с малки букви, връща с главни букви, и ако входът е с главни букви, връща с малки букви.\n\nПример:\nf_27('b') връща 'B'\nf_27('Z') връща 'z'", "zh": "转换给定字母的大小写。\n- letter (char): 要转换的输入字母。\n\nReturns:  \n- char: 大小写已反转的字母。如果输入为小写，则返回大写；如果输入为大写，则返回小写。\n\nExample:  \nf_27('b') returns 'B'  \nf_27('Z') returns 'z'", "fr": "Transforme la casse d'une lettre donnée.\n- letter (char) : La lettre d'entrée à transformer.\n\nRenvoie :\n- char : La lettre avec sa casse inversée. Si l'entrée est en minuscule, renvoie en majuscule, et si l'entrée est en majuscule, renvoie en minuscule.\n\nExemple :\nf_27('b') renvoie 'B'\nf_27('Z') renvoie 'z'", "de": "Transformiert die Groß-/Kleinschreibung eines gegebenen Buchstabens\n- letter (char): Der Eingabebuchstabe, der umgewandelt werden soll.\n\nReturns:  \n- char: Der Buchstabe mit umgekehrter Groß-/Kleinschreibung. Wenn die Eingabe klein geschrieben ist, wird Großbuchstabe zurückgegeben, und wenn die Eingabe groß geschrieben ist, wird Kleinbuchstabe zurückgegeben.\n\nExample:  \nf_27('b') returns 'B'  \nf_27('Z') returns 'z'", "ha": "Canza yanayin harafin da aka bayar.\n- letter (char): Harafin shigarwa da za a sauya.\n\nReturns:\n- char: Harafin da aka sauya masa hali. Idan shigarwar harafi ƙarami ne, yana mayar da babban harafi, kuma idan shigarwar babban harafi ne, yana mayar da ƙaramin harafi.\n\nExample:\nf_27('b') returns 'B'\nf_27('Z') returns 'z'", "hi": "दिए गए अक्षर के केस को बदलता है।\n- letter (char): वह इनपुट अक्षर जिसे बदला जाना है।\n\nReturns:\n- char: अक्षर जिसका केस उलटा हो गया है। यदि इनपुट लोअरकेस है, तो अपरकेस लौटाता है, और यदि इनपुट अपरकेस है, तो लोअरकेस लौटाता है।\n\nउदाहरण:\nf_27('b') returns 'B'\nf_27('Z') returns 'z'", "hu": "Átalakítja egy adott betű esetét.\n- letter (char): Az átalakítandó bemeneti betű.\n\nVisszatér:\n- char: A betű az esetének megfordításával. Ha a bemenet kisbetűs, nagybetűt ad vissza, és ha a bemenet nagybetűs, kisbetűt ad vissza.\n\nPélda:\nf_27('b') visszaadja 'B'\nf_27('Z') visszaadja 'z'", "es": "Transforma el caso de una letra dada.\n- letter (char): La letra de entrada a ser transformada.\n\nDevuelve:\n- char: La letra con su caso invertido. Si la entrada es minúscula, devuelve mayúscula, y si la entrada es mayúscula, devuelve minúscula.\n\nEjemplo:\nf_27('b') devuelve 'B'\nf_27('Z') devuelve 'z'", "arb": "يحول حالة حرف معين.\n- letter (char): الحرف المدخل الذي سيتم تحويله.\n\nReturns:\n- char: الحرف مع عكس حالته. إذا كان المدخل بحروف صغيرة، يعيد بحروف كبيرة، وإذا كان المدخل بحروف كبيرة، يعيد بحروف صغيرة.\n\nمثال :\nf_27('b') يعيد 'B'\nf_27('Z') يعيد 'z'", "sw": "Hurekebisha herufi ya herufi iliyotolewa.\n- letter (char): Herufi ya kuingiza inayopaswa kubadilishwa.\n\nInarejesha:\n- char: Herufi ikiwa na herufi zake zimebadilishwa. Ikiwa ingizo ni herufi ndogo, inarejesha herufi kubwa, na ikiwa ingizo ni herufi kubwa, inarejesha herufi ndogo.\n\nMfano:\nf_27('b') inarejesha 'B'\nf_27('Z') inarejesha 'z'", "tr": "Verilen bir harfin büyük/küçük harf durumunu dönüştürür.\n- letter (char): Dönüştürülecek giriş harfi.\n\nDöndürür:\n- char: Harfin büyük/küçük harf durumu ters çevrilmiş hali. Eğer giriş küçük harfse, büyük harf döndürür ve eğer giriş büyük harfse, küçük harf döndürür.\n\nÖrnek:\nf_27('b') 'B' döndürür\nf_27('Z') 'z' döndürür", "vi": "Chuyển đổi chữ hoa/thường của một chữ cái đã cho.\n- letter (char): Chữ cái đầu vào cần được chuyển đổi.\n\nTrả về:\n- char: Chữ cái với chữ hoa/thường được đảo ngược. Nếu đầu vào là chữ thường, trả về chữ hoa, và nếu đầu vào là chữ hoa, trả về chữ thường.\n\nVí dụ:\nf_27('b') trả về 'B'\nf_27('Z') trả về 'z'", "id": "Mengubah huruf besar/kecil dari sebuah huruf yang diberikan.\n- letter (char): Huruf input yang akan diubah.\n\nMengembalikan:\n- char: Huruf dengan huruf besar/kecil yang dibalik. Jika input adalah huruf kecil, mengembalikan huruf besar, dan jika input adalah huruf besar, mengembalikan huruf kecil.\n\nContoh:\nf_27('b') mengembalikan 'B'\nf_27('Z') mengembalikan 'z'", "ja": "与えられた文字のケースを変換します。\n- letter (char): 変換される入力文字。\n\n戻り値:\n- char: ケースが反転された文字。入力が小文字の場合は大文字を返し、入力が大文字の場合は小文字を返します。\n\n例:\nf_27('b') は 'B' を返します\nf_27('Z') は 'z' を返します", "ko": "주어진 문자의 대소문자를 변환합니다.\n- letter (char): 변환할 입력 문자입니다.\n\n반환:\n- char: 대소문자가 반전된 문자입니다. 입력이 소문자이면 대문자를 반환하고, 입력이 대문자이면 소문자를 반환합니다.\n\n예제:\nf_27('b') returns 'B'\nf_27('Z') returns 'z'", "ml": "നൽകിയ അക്ഷരത്തിന്റെ കേസ് മാറ്റുന്നു.\n- letter (char): മാറ്റാൻ ഉദ്ദേശിക്കുന്ന ഇൻപുട്ട് അക്ഷരം.\n\nReturns:\n- char: അക്ഷരത്തിന്റെ കേസ് മറിച്ചിരിക്കുന്നു. ഇൻപുട്ട് ലെറ്റർ ചെറിയക്ഷരമാണെങ്കിൽ, വലിയക്ഷരം തിരികെ നൽകുന്നു, ഇൻപുട്ട് വലിയക്ഷരമാണെങ്കിൽ, ചെറിയക്ഷരം തിരികെ നൽകുന്നു.\n\nExample:\nf_27('b') returns 'B'\nf_27('Z') returns 'z'", "fa": "تبدیل حالت یک حرف داده شده.\n- letter (char): حرف ورودی که باید تبدیل شود.\n\nبازگشت:\n- char: حرف با حالت معکوس شده. اگر ورودی با حروف کوچک باشد، با حروف بزرگ برمی‌گردد و اگر ورودی با حروف بزرگ باشد، با حروف کوچک برمی‌گردد.\n\nمثال:\nf_27('b') returns 'B'\nf_27('Z') returns 'z'"}}
{"task_id": "JavaScript/28", "prompt": {"en": "/**\n * Display the ASCII information for a given character.\n *\n * @param {char} character - The input character for which ASCII information is to be displayed.\n * @returns {number} - The corresponding ASCII code.\n * \n * Examples:\n * f_28('A');\n * // => 65\n */\nfunction f_28(character)", "sq": "/**\n * Shfaq informacionin ASCII për një karakter të dhënë.\n *\n * @param {char} character - Karakteri i hyrjes për të cilin informacioni ASCII do të shfaqet.\n * @returns {number} - Kodi përkatës ASCII.\n * \n * Shembuj:\n * f_28('A');\n * // => 65\n */\nfunction f_28(character)", "hy": "/**\n * Ցուցադրել ASCII տեղեկատվությունը տրված սիմվոլի համար։\n *\n * @param {char} character - Մուտքային սիմվոլը, որի համար պետք է ցուցադրվի ASCII տեղեկատվությունը։\n * @returns {number} - Համապատասխան ASCII կոդը։\n * \n * Օրինակներ:\n * f_28('A');\n * // => 65\n */\nfunction f_28(character)", "bn": "/**\n * প্রদত্ত অক্ষরের জন্য ASCII তথ্য প্রদর্শন করুন।\n *\n * @param {char} character - ইনপুট অক্ষর যার জন্য ASCII তথ্য প্রদর্শন করা হবে।\n * @returns {number} - সংশ্লিষ্ট ASCII কোড।\n * \n * উদাহরণ:\n * f_28('A');\n * // => 65\n */\nfunction f_28(character)", "bg": "/**\n * Показва ASCII информацията за даден символ.\n *\n * @param {char} character - Входният символ, за който ще се покаже ASCII информацията.\n * @returns {number} - Съответният ASCII код.\n * \n * Примери:\n * f_28('A');\n * // => 65\n */\nfunction f_28(character)", "zh": "/**\n * 显示给定字符的ASCII信息。\n *\n * @param {char} character - 要显示其ASCII信息的输入字符。\n * @returns {number} - 对应的ASCII码。\n * \n * 示例:\n * f_28('A');\n * // => 65\n */\nfunction f_28(character)", "fr": "/**\n * Afficher les informations ASCII pour un caractère donné.\n *\n * @param {char} character - Le caractère d'entrée pour lequel les informations ASCII doivent être affichées.\n * @returns {number} - Le code ASCII correspondant.\n * \n * Exemples :\n * f_28('A');\n * // => 65\n */\nfunction f_28(character)", "de": "/**\n * Zeigt die ASCII-Informationen für ein gegebenes Zeichen an.\n *\n * @param {char} character - Das Eingabezeichen, für das die ASCII-Informationen angezeigt werden sollen.\n * @returns {number} - Der entsprechende ASCII-Code.\n * \n * Beispiele:\n * f_28('A');\n * // => 65\n */\nfunction f_28(character)", "ha": "/**\n * Nuna bayanin ASCII don wata alama da aka bayar.\n *\n * @param {char} character - Alamar shigarwa wanda za a nuna bayanin ASCII.\n * @returns {number} - Lambar ASCII da ta dace.\n * \n * Misalai:\n * f_28('A');\n * // => 65\n */\nfunction f_28(character)", "hi": "/**\n * दिए गए वर्ण के लिए ASCII जानकारी प्रदर्शित करें।\n *\n * @param {char} character - वह इनपुट वर्ण जिसके लिए ASCII जानकारी प्रदर्शित की जानी है।\n * @returns {number} - संबंधित ASCII कोड।\n * \n * उदाहरण:\n * f_28('A');\n * // => 65\n */\nfunction f_28(character)", "hu": "/**\n * Megjeleníti az ASCII információt egy adott karakterhez.\n *\n * @param {char} character - Az input karakter, amelyhez az ASCII információt meg kell jeleníteni.\n * @returns {number} - A megfelelő ASCII kód.\n * \n * Példák:\n * f_28('A');\n * // => 65\n */\nfunction f_28(character)", "es": "/**\n * Muestra la información ASCII para un carácter dado.\n *\n * @param {char} character - El carácter de entrada para el cual se mostrará la información ASCII.\n * @returns {number} - El código ASCII correspondiente.\n * \n * Ejemplos:\n * f_28('A');\n * // => 65\n */\nfunction f_28(character)", "arb": "/**\n * عرض معلومات ASCII للحرف المعطى.\n *\n * @param {char} character - الحرف المدخل الذي سيتم عرض معلومات ASCII له.\n * @returns {number} - الكود ASCII المقابل.\n * \n * أمثلة:\n * f_28('A');\n * // => 65\n */\nfunction f_28(character)", "sw": "/**\n * Onyesha taarifa za ASCII kwa herufi iliyotolewa.\n *\n * @param {char} character - Herufi ya ingizo ambayo taarifa za ASCII zitaonyeshwa.\n * @returns {number} - Nambari ya ASCII inayolingana.\n * \n * Mifano:\n * f_28('A');\n * // => 65\n */\nfunction f_28(character)", "tr": "/**\n * Belirtilen bir karakter için ASCII bilgisini göster.\n *\n * @param {char} character - ASCII bilgisinin gösterileceği giriş karakteri.\n * @returns {number} - Karşılık gelen ASCII kodu.\n * \n * Örnekler:\n * f_28('A');\n * // => 65\n */\nfunction f_28(character)", "vi": "/**\n * Hiển thị thông tin ASCII cho một ký tự được cung cấp.\n *\n * @param {char} character - Ký tự đầu vào mà thông tin ASCII cần được hiển thị.\n * @returns {number} - Mã ASCII tương ứng.\n * \n * Ví dụ:\n * f_28('A');\n * // => 65\n */\nfunction f_28(character)", "id": "/**\n * Menampilkan informasi ASCII untuk karakter yang diberikan.\n *\n * @param {char} character - Karakter input yang informasinya akan ditampilkan.\n * @returns {number} - Kode ASCII yang sesuai.\n * \n * Contoh:\n * f_28('A');\n * // => 65\n */\nfunction f_28(character)", "ja": "/**\n * 指定された文字のASCII情報を表示します。\n *\n * @param {char} character - ASCII情報を表示するための入力文字。\n * @returns {number} - 対応するASCIIコード。\n * \n * 例:\n * f_28('A');\n * // => 65\n */\nfunction f_28(character)", "ko": "/**\n * 주어진 문자에 대한 ASCII 정보를 표시합니다.\n *\n * @param {char} character - ASCII 정보를 표시할 입력 문자입니다.\n * @returns {number} - 해당하는 ASCII 코드입니다.\n * \n * 예시:\n * f_28('A');\n * // => 65\n */\nfunction f_28(character)", "ml": "/**\n * നൽകിയ അക്ഷരത്തിനായുള്ള ASCII വിവരങ്ങൾ പ്രദർശിപ്പിക്കുക.\n *\n * @param {char} character - ASCII വിവരങ്ങൾ പ്രദർശിപ്പിക്കേണ്ട ഇൻപുട്ട് അക്ഷരം.\n * @returns {number} - അനുബന്ധ ASCII കോഡ്.\n * \n * ഉദാഹരണങ്ങൾ:\n * f_28('A');\n * // => 65\n */\nfunction f_28(character)", "fa": "/**\n * نمایش اطلاعات ASCII برای یک کاراکتر داده شده.\n *\n * @param {char} character - کاراکتر ورودی که اطلاعات ASCII آن نمایش داده می‌شود.\n * @returns {number} - کد ASCII مربوطه.\n * \n * Examples:\n * f_28('A');\n * // => 65\n */\nfunction f_28(character)"}, "canonical_solution": "{\n    return character.charCodeAt(0);\n}", "instruction": {"en": "Write a JavaScript function `function f_28(character)` to solve the following problem:\nDisplay the ASCII information for a given character.\n\nParameters:\n@param {char} character - The input character for which ASCII information is to be displayed.\n\nReturns:\n@returns {number} - The corresponding ASCII code.\n\nExamples:\nf_28('A');\n// => 65\n", "sq": "Shkruani një funksion JavaScript `function f_28(character)` për të zgjidhur problemin e mëposhtëm:  \nShfaq informacionin ASCII për një karakter të dhënë.\n\nParametrat:  \n@param {char} character - Karakteri i hyrjes për të cilin informacioni ASCII duhet të shfaqet.\n\nKthen:  \n@returns {number} - Kodi përkatës ASCII.\n\nShembuj:  \nf_28('A');  \n// => 65", "hy": "Գրեք JavaScript ֆունկցիա `function f_28(character)` հետևյալ խնդիրը լուծելու համար: \nՑուցադրել տրված սիմվոլի ASCII տեղեկատվությունը:\n\nՊարամետրեր:\n@param {char} character - Մուտքային սիմվոլը, որի համար պետք է ցուցադրվի ASCII տեղեկատվությունը:\n\nՎերադարձնում է:\n@returns {number} - Համապատասխանող ASCII կոդը:\n\nՕրինակներ:\nf_28('A');\n// => 65", "bn": "একটি জাভাস্ক্রিপ্ট ফাংশন `function f_28(character)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য: \nএকটি প্রদত্ত অক্ষরের জন্য ASCII তথ্য প্রদর্শন করুন।\n\nপ্যারামিটারসমূহ:\n@param {char} character - ইনপুট অক্ষর যার জন্য ASCII তথ্য প্রদর্শন করা হবে।\n\nফেরত দেয়:\n@returns {number} - সংশ্লিষ্ট ASCII কোড।\n\nউদাহরণসমূহ:\nf_28('A');\n// => 65", "bg": "Напишете JavaScript функция `function f_28(character)`, за да решите следния проблем:  \nПоказване на ASCII информацията за даден символ.\n\nПараметри:  \n@param {char} character - Входният символ, за който трябва да се покаже ASCII информацията.\n\nВръща:  \n@returns {number} - Съответстващият ASCII код.\n\nПримери:  \nf_28('A');  \n// => 65", "zh": "编写一个 JavaScript 函数 `function f_28(character)` 来解决以下问题：  \n显示给定字符的 ASCII 信息。\n\n参数：  \n@param {char} character - 要显示其 ASCII 信息的输入字符。\n\n返回：  \n@returns {number} - 对应的 ASCII 码。\n\n示例：  \nf_28('A');  \n// => 65  ", "fr": "Écrire une fonction JavaScript `function f_28(character)` pour résoudre le problème suivant :  \nAfficher les informations ASCII pour un caractère donné.\n\nParamètres :  \n@param {char} character - Le caractère d'entrée pour lequel les informations ASCII doivent être affichées.\n\nRetourne :  \n@returns {number} - Le code ASCII correspondant.\n\nExemples :  \nf_28('A');  \n// => 65  ", "de": "Schreiben Sie eine JavaScript-Funktion `function f_28(character)`, um das folgende Problem zu lösen:  \nZeigen Sie die ASCII-Informationen für ein gegebenes Zeichen an.\n\nParameter:  \n@param {char} character - Das Eingabezeichen, für das die ASCII-Informationen angezeigt werden sollen.\n\nRückgabewert:  \n@returns {number} - Der entsprechende ASCII-Code.\n\nBeispiele:  \nf_28('A');  \n// => 65", "ha": "Rubuta wani aikin JavaScript `function f_28(character)` don warware matsalar mai zuwa: Nuna bayanin ASCII don wata alama da aka bayar.\n\nSigogi:\n@param {char} character - Alamar shigarwa wadda za a nuna bayanin ASCII nata.\n\nKomawa:\n@returns {number} - Lambar ASCII da ta dace.\n\nMisalai:\nf_28('A');\n// => 65", "hi": "JavaScript फ़ंक्शन `function f_28(character)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए अक्षर के लिए ASCII जानकारी प्रदर्शित करें।\n\nपैरामीटर्स:\n@param {char} character - वह इनपुट अक्षर जिसके लिए ASCII जानकारी प्रदर्शित की जानी है।\n\nवापसी:\n@returns {number} - संबंधित ASCII कोड।\n\nउदाहरण:\nf_28('A');\n// => 65", "hu": "Írj egy JavaScript függvényt `function f_28(character)` a következő probléma megoldására:  \nJelenítsd meg az ASCII információt egy adott karakterhez.\n\nParaméterek:  \n@param {char} character - Az a bemeneti karakter, amelyhez az ASCII információt meg kell jeleníteni.\n\nVisszatérési érték:  \n@returns {number} - A megfelelő ASCII kód.\n\nPéldák:  \nf_28('A');  \n// => 65", "es": "Escribe una función de JavaScript `function f_28(character)` para resolver el siguiente problema:\nMuestra la información ASCII para un carácter dado.\n\nParámetros:\n@param {char} character - El carácter de entrada para el cual se mostrará la información ASCII.\n\nDevuelve:\n@returns {number} - El código ASCII correspondiente.\n\nEjemplos:\nf_28('A');\n// => 65", "arb": "اكتب دالة JavaScript `function f_28(character)` لحل المشكلة التالية:\nعرض معلومات ASCII للحرف المعطى.\n\nالمعطيات:\n@param {char} character - الحرف المدخل الذي سيتم عرض معلومات ASCII له.\n\nالقيم المعادة:\n@returns {number} - الكود ASCII المقابل.\n\nأمثلة:\nf_28('A');\n// => 65", "sw": "Andika kazi ya JavaScript `function f_28(character)` kutatua tatizo lifuatalo:\nOnyesha taarifa za ASCII kwa herufi iliyopewa.\n\nVigezo:\n@param {char} character - Herufi ya kuingiza ambayo taarifa za ASCII zinapaswa kuonyeshwa.\n\nInarejesha:\n@returns {number} - Nambari ya ASCII inayolingana.\n\nMifano:\nf_28('A');\n// => 65", "tr": "Bir JavaScript fonksiyonu `function f_28(character)` yazın:\nVerilen bir karakter için ASCII bilgisini görüntüleyin.\n\nParametreler:\n@param {char} character - ASCII bilgisinin görüntüleneceği giriş karakteri.\n\nDöndürülenler:\n@returns {number} - Karşılık gelen ASCII kodu.\n\nÖrnekler:\nf_28('A');\n// => 65", "vi": "Viết một hàm JavaScript `function f_28(character)` để giải quyết vấn đề sau:  \nHiển thị thông tin ASCII cho một ký tự cho trước.\n\nTham số:  \n@param {char} character - Ký tự đầu vào mà thông tin ASCII cần được hiển thị.\n\nTrả về:  \n@returns {number} - Mã ASCII tương ứng.\n\nVí dụ:  \nf_28('A');  \n// => 65", "id": "Tulis sebuah fungsi JavaScript `function f_28(character)` untuk menyelesaikan masalah berikut:  \nTampilkan informasi ASCII untuk karakter yang diberikan.\n\nParameter:\n@param {char} character - Karakter input yang informasi ASCII-nya akan ditampilkan.\n\nMengembalikan:\n@returns {number} - Kode ASCII yang sesuai.\n\nContoh:\nf_28('A');\n// => 65", "ja": "JavaScript関数 `function f_28(character)` を作成して、次の問題を解決してください:\n指定された文字のASCII情報を表示します。\n\nパラメータ:\n@param {char} character - ASCII情報を表示するための入力文字。\n\n戻り値:\n@returns {number} - 対応するASCIIコード。\n\n例:\nf_28('A');\n// => 65", "ko": "JavaScript 함수 `function f_28(character)`를 작성하여 다음 문제를 해결하십시오:\n주어진 문자에 대한 ASCII 정보를 표시합니다.\n\n매개변수:\n@param {char} character - ASCII 정보를 표시할 입력 문자입니다.\n\n반환값:\n@returns {number} - 해당하는 ASCII 코드입니다.\n\n예시:\nf_28('A');\n// => 65", "ml": "`function f_28(character)` എന്ന ജാവാസ്ക്രിപ്റ്റ് ഫംഗ്ഷൻ എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:  \nനൽകിയിരിക്കുന്ന പ്രതീകത്തിന്റെ ASCII വിവരങ്ങൾ പ്രദർശിപ്പിക്കുക.\n\nപാരാമീറ്ററുകൾ:  \n@param {char} character - ASCII വിവരങ്ങൾ പ്രദർശിപ്പിക്കേണ്ട ഇൻപുട്ട് പ്രതീകം.\n\nമടക്കുക:  \n@returns {number} - അനുബന്ധ ASCII കോഡ്.\n\nഉദാഹരണങ്ങൾ:  \nf_28('A');  \n// => 65", "fa": "یک تابع جاوااسکریپت `function f_28(character)` بنویسید تا مسئله زیر را حل کند:\nاطلاعات ASCII را برای یک کاراکتر داده شده نمایش دهد.\n\nپارامترها:\n@param {char} character - کاراکتر ورودی که اطلاعات ASCII آن باید نمایش داده شود.\n\nبازگشتی:\n@returns {number} - کد ASCII متناظر.\n\nمثال‌ها:\nf_28('A');\n// => 65"}, "level": "easy", "test": "(() => {\n    console.assert(f_28('A') === 65, \"'A' should return 65\");\n    console.assert(f_28('B') === 66, \"'B' should return 66\"); // Additional test case\n    console.assert(f_28('0') === 48, \"'0' should return 48\"); // Additional test case\n    console.assert(f_28(' ') === 32, \"' ' should return 32\"); // Additional test case\n    // console.log(\"All tests passed.\");\n})();", "entry_point": "f_28", "signature": "function f_28(character)", "docstring": {"en": "Display the ASCII information for a given character.\n\nParameters:\n@param {char} character - The input character for which ASCII information is to be displayed.\n\nReturns:\n@returns {number} - The corresponding ASCII code.\n\nExamples:\nf_28('A');\n// => 65\n", "sq": "Shfaq informacionin ASCII për një karakter të dhënë.\n\nParametrat:\n@param {char} character - Karakteri i hyrjes për të cilin do të shfaqet informacioni ASCII.\n\nKthen:\n@returns {number} - Kodi përkatës ASCII.\n\nShembuj:\nf_28('A');\n// => 65", "hy": "ASCII տեղեկատվությունը ցուցադրել տրված սիմվոլի համար։\n\nՊարամետրեր:\n@param {char} character - Մուտքային սիմվոլը, որի համար պետք է ցուցադրվի ASCII տեղեկատվությունը։\n\nՎերադարձնում է:\n@returns {number} - Համապատասխանող ASCII կոդը։\n\nՕրինակներ:\nf_28('A');\n// => 65", "bn": "একটি প্রদত্ত অক্ষরের জন্য ASCII তথ্য প্রদর্শন করুন।\n\nপ্যারামিটার:\n@param {char} character - ইনপুট অক্ষর যার জন্য ASCII তথ্য প্রদর্শন করা হবে।\n\nরিটার্নস:\n@returns {number} - সংশ্লিষ্ট ASCII কোড।\n\nউদাহরণ:\nf_28('A');\n// => 65", "bg": "Показва ASCII информацията за даден символ.\n\nПараметри:\n@param {char} character - Входният символ, за който трябва да се покаже ASCII информация.\n\nВръща:\n@returns {number} - Съответният ASCII код.\n\nПримери:\nf_28('A');\n// => 65", "zh": "显示给定字符的ASCII信息。\n\n参数:\n@param {char} character - 要显示其ASCII信息的输入字符。\n\n返回:\n@returns {number} - 对应的ASCII代码。\n\n示例:\nf_28('A');\n// => 65", "fr": "Afficher les informations ASCII pour un caractère donné.\n\nParamètres:\n@param {char} character - Le caractère d'entrée pour lequel les informations ASCII doivent être affichées.\n\nRenvoie:\n@returns {number} - Le code ASCII correspondant.\n\nExemples:\nf_28('A');\n// => 65", "de": "Zeige die ASCII-Informationen für ein gegebenes Zeichen an.\n\nParameter:\n@param {char} character - Das Eingabezeichen, für das die ASCII-Informationen angezeigt werden sollen.\n\nRückgabewerte:\n@returns {number} - Der entsprechende ASCII-Code.\n\nBeispiele:\nf_28('A');\n// => 65", "ha": "Nuna bayanin ASCII don wata alama da aka bayar.\n\nSigogi:\n@param {char} character - Harafin shigarwa wanda za a nuna bayanin ASCII.\n\nAbin da ya dawo:\n@returns {number} - Lambar ASCII da ta dace.\n\nMisalai:\nf_28('A');\n// => 65", "hi": "दिए गए अक्षर के लिए ASCII जानकारी प्रदर्शित करें।\n\nParameters:\n@param {char} character - वह इनपुट वर्ण जिसके लिए ASCII जानकारी प्रदर्शित की जानी है।\n\nReturns:\n@returns {number} - संबंधित ASCII कोड।\n\nExamples:\nf_28('A');\n// => 65", "hu": "Adja meg egy adott karakter ASCII információját.\n\nParaméterek:\n@param {char} character - Az a bemeneti karakter, amelynek ASCII információját meg kell jeleníteni.\n\nVisszatérési érték:\n@returns {number} - A megfelelő ASCII kód.\n\nPéldák:\nf_28('A');\n// => 65", "es": "Mostrar la información ASCII para un carácter dado.\n\nParámetros:\n@param {char} character - El carácter de entrada para el cual se mostrará la información ASCII.\n\nDevuelve:\n@returns {number} - El código ASCII correspondiente.\n\nEjemplos:\nf_28('A');\n// => 65", "arb": "عرض معلومات ASCII للحرف المعطى.\n\nالمعلمات:\n@param {char} character - الحرف المدخل الذي سيتم عرض معلومات ASCII له.\n\nالقيم المعادة:\n@returns {number} - رمز ASCII المقابل.\n\nأمثلة:\nf_28('A');\n// => 65", "sw": "Onyesha taarifa za ASCII kwa herufi iliyotolewa.\n\nVigezo:\n@param {char} character - Herufi ya ingizo ambayo taarifa za ASCII zinapaswa kuonyeshwa.\n\nInarejesha:\n@returns {number} - Nambari ya ASCII inayolingana.\n\nMifano:\nf_28('A');\n// => 65", "tr": "Verilen bir karakter için ASCII bilgisini görüntüleyin.\n\nParametreler:\n@param {char} character - ASCII bilgisinin gösterileceği giriş karakteri.\n\nDönüş:\n@returns {number} - Karşılık gelen ASCII kodu.\n\nÖrnekler:\nf_28('A');\n// => 65", "vi": "Hiển thị thông tin ASCII cho một ký tự cho trước.\n\nTham số:\n@param {char} character - Ký tự đầu vào mà thông tin ASCII sẽ được hiển thị.\n\nTrả về:\n@returns {number} - Mã ASCII tương ứng.\n\nVí dụ:\nf_28('A');\n// => 65", "id": "Tampilkan informasi ASCII untuk karakter yang diberikan.\n\nParameter:\n@param {char} character - Karakter input yang informasinya akan ditampilkan.\n\nMengembalikan:\n@returns {number} - Kode ASCII yang sesuai.\n\nContoh:\nf_28('A');\n// => 65", "ja": "与えられた文字のASCII情報を表示します。\n\nパラメータ:\n@param {char} character - ASCII情報を表示するための入力文字。\n\n戻り値:\n@returns {number} - 対応するASCIIコード。\n\n例:\nf_28('A');\n// => 65", "ko": "주어진 문자에 대한 ASCII 정보를 표시합니다.\n\n매개변수:\n@param {char} character - ASCII 정보를 표시할 입력 문자입니다.\n\n반환값:\n@returns {number} - 해당하는 ASCII 코드입니다.\n\n예시:\nf_28('A');\n// => 65", "ml": "ASCII വിവരങ്ങൾ നൽകിയ അക്ഷരത്തിനായി പ്രദർശിപ്പിക്കുക.\n\nപാരാമീറ്ററുകൾ:\n@param {char} character - ASCII വിവരങ്ങൾ പ്രദർശിപ്പിക്കേണ്ട ഇൻപുട്ട് അക്ഷരം.\n\nമടക്കുന്നു:\n@returns {number} - അനുബന്ധ ASCII കോഡ്.\n\nഉദാഹരണങ്ങൾ:\nf_28('A');\n// => 65", "fa": "نمایش اطلاعات ASCII برای یک کاراکتر داده شده.\n\nپارامترها:\n@param {char} character - کاراکتر ورودی که اطلاعات ASCII برای آن نمایش داده می‌شود.\n\nبازگشت:\n@returns {number} - کد ASCII مربوطه.\n\nمثال‌ها:\nf_28('A');\n// => 65"}}
{"task_id": "JavaScript/29", "prompt": {"en": "/**\n * Evaluate the grade for an input integer.\n * \n * Parameters:\n * - score (int): The integer score to be evaluated.\n * \n * Returns:\n * ​​    char: The grade corresponding to the input score.\n * ​​         If the score is between 90 and 100 (inclusive), returns 'A'.\n * ​​         Otherwise, returns 'B'.\n * \n * @example\n * f_29(90) // returns 'A'\n */\nfunction f_29(score)", "sq": "/**\n * Vlerëson notën për një numër të plotë hyrës.\n * \n * Parametrat:\n * - score (int): Nota e plotë që do të vlerësohet.\n * \n * Kthen:\n * ​​    char: Nota që korrespondon me notën hyrëse.\n * ​​         Nëse nota është midis 90 dhe 100 (përfshirë), kthen 'A'.\n * ​​         Përndryshe, kthen 'B'.\n * \n * @example\n * f_29(90) // returns 'A'\n */\nfunction f_29(score)", "hy": "/**\n * Գնահատել մուտքային ամբողջ թվի գնահատականը։\n * \n * Պարամետրեր:\n * - score (int): Գնահատման ենթակա ամբողջ թիվ։\n * \n * Վերադարձնում է:\n * ​​    char: Մուտքային գնահատականին համապատասխանող գնահատականը։\n * ​​         Եթե գնահատականը 90-ից 100 (ներառյալ) միջակայքում է, վերադարձնում է 'A'։\n * ​​         Հակառակ դեպքում, վերադարձնում է 'B'։\n * \n * @example\n * f_29(90) // returns 'A'\n */\nfunction f_29(score)", "bn": "/**\n * একটি ইনপুট পূর্ণসংখ্যার জন্য গ্রেড মূল্যায়ন করুন।\n * \n * প্যারামিটার:\n * - score (int): মূল্যায়ন করার জন্য পূর্ণসংখ্যার স্কোর।\n * \n * রিটার্নস:\n * ​​    char: ইনপুট স্কোরের সাথে সম্পর্কিত গ্রেড।\n * ​​         যদি স্কোর 90 এবং 100 (অন্তর্ভুক্ত) এর মধ্যে হয়, তাহলে 'A' রিটার্ন করে।\n * ​​         অন্যথায়, 'B' রিটার্ন করে।\n * \n * @example\n * f_29(90) // returns 'A'\n */\nfunction f_29(score)", "bg": "/**\n * Оценете оценката за входно цяло число.\n * \n * Параметри:\n * - score (int): Цялото число, което трябва да бъде оценено.\n * \n * Връща:\n * ​​    char: Оценката, съответстваща на входното число.\n * ​​         Ако числото е между 90 и 100 (включително), връща 'A'.\n * ​​         В противен случай, връща 'B'.\n * \n * @пример\n * f_29(90) // връща 'A'\n */\nfunction f_29(score)", "zh": "/**\n * 评估输入整数的等级。\n * \n * 参数:\n * - score (int): 要评估的整数分数。\n * \n * 返回:\n * ​​    char: 与输入分数对应的等级。\n * ​​         如果分数在90到100之间（包括90和100），返回 'A'。\n * ​​         否则，返回 'B'。\n * \n * @example\n * f_29(90) // returns 'A'\n */\nfunction f_29(score)", "fr": "/**\n * Évaluer la note pour un entier d'entrée.\n * \n * Paramètres:\n * - score (int): Le score entier à évaluer.\n * \n * Renvoie:\n * ​​    char: La note correspondant au score d'entrée.\n * ​​         Si le score est entre 90 et 100 (inclus), renvoie 'A'.\n * ​​         Sinon, renvoie 'B'.\n * \n * @example\n * f_29(90) // returns 'A'\n */\nfunction f_29(score)", "de": "/**\n * Bewerte die Note für eine eingegebene ganze Zahl.\n * \n * Parameter:\n * - score (int): Die zu bewertende Ganzzahl.\n * \n * Rückgabe:\n * ​​    char: Die Note, die der Eingabepunktzahl entspricht.\n * ​​         Wenn die Punktzahl zwischen 90 und 100 (einschließlich) liegt, wird 'A' zurückgegeben.\n * ​​         Andernfalls wird 'B' zurückgegeben.\n * \n * @example\n * f_29(90) // returns 'A'\n */", "ha": "/**\n * Kimanta darajar don lamba mai shigarwa.\n * \n * Sigogi:\n * - score (int): Lambar da za a kimanta.\n * \n * Komawa:\n * ​​    char: Darajar da ta dace da lambar shigarwa.\n * ​​         Idan lambar tana tsakanin 90 da 100 (ciki har da), yana dawowa 'A'.\n * ​​         In ba haka ba, yana dawowa 'B'.\n * \n * @example\n * f_29(90) // returns 'A'\n */\nfunction f_29(score)", "hi": "/**\n * इनपुट पूर्णांक के लिए ग्रेड का मूल्यांकन करें।\n * \n * पैरामीटर:\n * - score (int): मूल्यांकन के लिए पूर्णांक स्कोर।\n * \n * रिटर्न:\n * ​​    char: इनपुट स्कोर के अनुरूप ग्रेड।\n * ​​         यदि स्कोर 90 और 100 (समावेशी) के बीच है, तो 'A' लौटाता है।\n * ​​         अन्यथा, 'B' लौटाता है।\n * \n * @example\n * f_29(90) // returns 'A'\n */\nfunction f_29(score)", "hu": "/**\n * Értékelje az egész szám osztályzatát.\n * \n * Paraméterek:\n * - score (int): Az értékelendő egész szám pontszám.\n * \n * Visszatér:\n * ​​    char: Az input pontszámnak megfelelő osztályzat.\n * ​​         Ha a pontszám 90 és 100 között van (beleértve), 'A'-t ad vissza.\n * ​​         Egyébként 'B'-t ad vissza.\n * \n * @példa\n * f_29(90) // returns 'A'\n */\nfunction f_29(score)", "es": "/**\n * Evaluar la calificación para un entero de entrada.\n * \n * Parámetros:\n * - score (int): La puntuación entera a evaluar.\n * \n * Devuelve:\n * ​​    char: La calificación correspondiente a la puntuación de entrada.\n * ​​         Si la puntuación está entre 90 y 100 (inclusive), devuelve 'A'.\n * ​​         De lo contrario, devuelve 'B'.\n * \n * @example\n * f_29(90) // devuelve 'A'\n */\nfunction f_29(score)", "arb": "/**\n * تقييم الدرجة لعدد صحيح مدخل.\n * \n * المعلمات:\n * - score (int): الدرجة الصحيحة التي سيتم تقييمها.\n * \n * يعيد:\n * ​​    char: الدرجة المقابلة للدرجة المدخلة.\n * ​​         إذا كانت الدرجة بين 90 و 100 (شاملة)، يعيد 'A'.\n * ​​         خلاف ذلك، يعيد 'B'.\n * \n * @example\n * f_29(90) // يعيد 'A'\n */\nfunction f_29(score)", "sw": "/**\n * Tambua alama kwa nambari kamili iliyoingizwa.\n * \n * Vigezo:\n * - score (int): Alama ya nambari kamili inayopaswa kutambuliwa.\n * \n * Inarudisha:\n * ​​    char: Alama inayolingana na alama iliyoingizwa.\n * ​​         Ikiwa alama iko kati ya 90 na 100 (ikijumuisha), inarudisha 'A'.\n * ​​         Vinginevyo, inarudisha 'B'.\n * \n * @example\n * f_29(90) // inarejesha 'A'\n */\nfunction f_29(score)", "tr": "/**\n * Bir tamsayı için notu değerlendir.\n * \n * Parametreler:\n * - score (int): Değerlendirilecek tamsayı puanı.\n * \n * Döndürür:\n * ​​    char: Girdi puanına karşılık gelen not.\n * ​​         Eğer puan 90 ile 100 arasında (dahil) ise, 'A' döndürür.\n * ​​         Aksi takdirde, 'B' döndürür.\n * \n * @example\n * f_29(90) // 'A' döndürür\n */\nfunction f_29(score)", "vi": "/**\n * Đánh giá điểm cho một số nguyên đầu vào.\n * \n * Tham số:\n * - score (int): Điểm số nguyên cần được đánh giá.\n * \n * Trả về:\n * ​​    char: Điểm tương ứng với điểm số đầu vào.\n * ​​         Nếu điểm số nằm trong khoảng từ 90 đến 100 (bao gồm), trả về 'A'.\n * ​​         Ngược lại, trả về 'B'.\n * \n * @example\n * f_29(90) // trả về 'A'\n */\nfunction f_29(score)", "id": "/**\n * Evaluasi nilai untuk sebuah bilangan bulat masukan.\n * \n * Parameter:\n * - score (int): Skor bilangan bulat yang akan dievaluasi.\n * \n * Mengembalikan:\n * ​​    char: Nilai yang sesuai dengan skor masukan.\n * ​​         Jika skor antara 90 dan 100 (inklusif), mengembalikan 'A'.\n * ​​         Jika tidak, mengembalikan 'B'.\n * \n * @example\n * f_29(90) // mengembalikan 'A'\n */\nfunction f_29(score)", "ja": "/**\n * 入力された整数の評価を行います。\n * \n * パラメータ:\n * - score (int): 評価する整数のスコア。\n * \n * 戻り値:\n * ​​    char: 入力スコアに対応する評価。\n * ​​         スコアが90から100の範囲（含む）の場合、'A'を返します。\n * ​​         それ以外の場合は、'B'を返します。\n * \n * @example\n * f_29(90) // returns 'A'\n */\nfunction f_29(score)", "ko": "/**\n * 입력 정수에 대한 등급을 평가합니다.\n * \n * 매개변수:\n * - score (int): 평가할 정수 점수입니다.\n * \n * 반환값:\n * ​​    char: 입력 점수에 해당하는 등급입니다.\n * ​​         점수가 90에서 100 사이(포함)인 경우, 'A'를 반환합니다.\n * ​​         그렇지 않으면 'B'를 반환합니다.\n * \n * @example\n * f_29(90) // returns 'A'\n */\nfunction f_29(score)", "ml": "/**\n * ഒരു ഇൻപുട്ട് ഇൻറീജറിനുള്ള ഗ്രേഡ് വിലയിരുത്തുക.\n * \n * പാരാമീറ്ററുകൾ:\n * - score (int): വിലയിരുത്തേണ്ട ഇൻറീജർ സ്കോർ.\n * \n * തിരികെ നൽകുന്നു:\n * ​​    char: ഇൻപുട്ട് സ്കോറിനൊത്തുള്ള ഗ്രേഡ്.\n * ​​         സ്കോർ 90നും 100നും ഇടയിൽ (ഉൾപ്പെടെ) ആണെങ്കിൽ, 'A' തിരികെ നൽകുന്നു.\n * ​​         അല്ലെങ്കിൽ, 'B' തിരികെ നൽകുന്നു.\n * \n * @example\n * f_29(90) // returns 'A'\n */\nfunction f_29(score)", "fa": "/**\n * ارزیابی نمره برای یک عدد صحیح ورودی.\n * \n * پارامترها:\n * - score (int): نمره صحیحی که باید ارزیابی شود.\n * \n * بازمی‌گرداند:\n * ​​    char: نمره‌ای که با نمره ورودی مطابقت دارد.\n * ​​         اگر نمره بین 90 و 100 (شامل) باشد، 'A' را بازمی‌گرداند.\n * ​​         در غیر این صورت، 'B' را بازمی‌گرداند.\n * \n * @example\n * f_29(90) // returns 'A'\n */\nfunction f_29(score)"}, "canonical_solution": "{\n    // Return 'A' or 'B' based on the condition\n    return ((90 <= score && score <= 100) ? 'A' : 'B');\n}", "instruction": {"en": "Write a JavaScript function `function f_29(score)` to solve the following problem:\nEvaluate the grade for an input integer.\n\nParameters:\n- score (int): The integer score to be evaluated.\n\nReturns:\n    char: The grade corresponding to the input score.\n    If the score is between 90 and 100 (inclusive), returns 'A'.\n    Otherwise, returns 'B'.\n\n@example\nf_29(90) // returns 'A'\n", "sq": "Shkruani një funksion JavaScript `function f_29(score)` për të zgjidhur problemin e mëposhtëm:  \nVlerësoni notën për një numër të plotë hyrës.\n\nParametrat:  \n- score (int): Nota e plotë që do të vlerësohet.\n\nKthen:  \n    char: Nota që korrespondon me notën hyrëse.  \n    Nëse nota është midis 90 dhe 100 (përfshirë), kthen 'A'.  \n    Përndryshe, kthen 'B'.\n\n@example  \nf_29(90) // returns 'A'", "hy": "Գրեք JavaScript ֆունկցիա `function f_29(score)` հետևյալ խնդիրը լուծելու համար:\nԳնահատել մուտքային ամբողջ թվի գնահատականը:\n\nՊարամետրեր:\n- score (int): Գնահատվող ամբողջ թիվը:\n\nՎերադարձնում է:\n    char: Մուտքային գնահատականին համապատասխանող գնահատականը:\n    Եթե գնահատականը 90-ից 100 (ներառյալ) միջակայքում է, վերադարձնում է 'A':\n    Հակառակ դեպքում, վերադարձնում է 'B':\n\n@example\nf_29(90) // returns 'A'", "bn": "একটি JavaScript ফাংশন `function f_29(score)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি পূর্ণসংখ্যা গ্রেড মূল্যায়ন করুন।\n\nপ্যারামিটারসমূহ:\n- score (int): মূল্যায়ন করার জন্য পূর্ণসংখ্যা স্কোর।\n\nফেরত দেয়:\n    char: ইনপুট স্কোরের সাথে সম্পর্কিত গ্রেড।\n    যদি স্কোর 90 এবং 100 (অন্তর্ভুক্ত) এর মধ্যে হয়, তাহলে 'A' ফেরত দেয়।\n    অন্যথায়, 'B' ফেরত দেয়।\n\n@example\nf_29(90) // returns 'A'", "bg": "Напишете JavaScript функция `function f_29(score)` за решаване на следния проблем:\nОценете оценката за входно цяло число.\n\nПараметри:  \n- score (int): Цялото число, което трябва да бъде оценено.\n\nВръща:  \n    char: Оценката, съответстваща на входното число.  \n    Ако числото е между 90 и 100 (включително), връща 'A'.  \n    В противен случай, връща 'B'.  \n\n@example  \nf_29(90) // returns 'A'", "zh": "编写一个 JavaScript 函数 `function f_29(score)` 来解决以下问题：\n评估输入整数的等级。\n\n参数：\n- score (int): 要评估的整数分数。\n\n返回：  \n    char: 与输入分数对应的等级。  \n    如果分数在 90 到 100 之间（包括 90 和 100），返回 'A'。  \n    否则，返回 'B'。\n\n@example  \nf_29(90) // returns 'A'", "fr": "Écrire une fonction JavaScript `function f_29(score)` pour résoudre le problème suivant:\nÉvaluer la note pour un entier en entrée.\n\nParamètres :  \n- score (int) : Le score entier à évaluer.\n\nRenvoie :  \n    char : La note correspondant au score d'entrée.  \n    Si le score est entre 90 et 100 (inclus), renvoie 'A'.  \n    Sinon, renvoie 'B'.\n\n@example  \nf_29(90) // returns 'A'", "de": "Schreiben Sie eine JavaScript-Funktion `function f_29(score)`, um das folgende Problem zu lösen:\nBewerten Sie die Note für eine eingegebene ganze Zahl.\n\nParameter:\n- score (int): Die zu bewertende ganze Zahl.\n\nRückgabewert:\n    char: Die Note, die der eingegebenen Punktzahl entspricht.\n    Wenn die Punktzahl zwischen 90 und 100 (einschließlich) liegt, wird 'A' zurückgegeben.\n    Andernfalls wird 'B' zurückgegeben.\n\n@example\nf_29(90) // returns 'A'", "ha": "Rubuta aikin JavaScript `function f_29(score)` don warware matsalar mai zuwa:\nKimanta darajar don wani shigarwar cikakken lamba.\n\nSigogi:\n- score (int): Cikakken lamban da za a kimanta.\n\nDawowa:\n    char: Darajar da ta dace da shigarwar maki.\n    Idan maki yana tsakanin 90 da 100 (ciki har da), yana dawowa 'A'.\n    In ba haka ba, yana dawowa 'B'.\n\n@example\nf_29(90) // returns 'A'", "hi": "एक JavaScript फ़ंक्शन `function f_29(score)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nकिसी इनपुट पूर्णांक के लिए ग्रेड का मूल्यांकन करें।\n\nपैरामीटर्स:\n- score (int): मूल्यांकन के लिए पूर्णांक स्कोर।\n\nवापसी:\n    char: इनपुट स्कोर के अनुरूप ग्रेड।\n    यदि स्कोर 90 और 100 (समावेशी) के बीच है, तो 'A' लौटाता है।\n    अन्यथा, 'B' लौटाता है।\n\n@example\nf_29(90) // returns 'A'", "hu": "Írj egy JavaScript függvényt `function f_29(score)` a következő probléma megoldására:\nÉrtékeld ki a jegyet egy bemeneti egész számra.\n\nParaméterek:\n- score (int): Az értékelendő egész szám.\n\nVisszatér:\n    char: A bemeneti pontszámnak megfelelő jegy.\n    Ha a pontszám 90 és 100 között van (beleértve), 'A'-t ad vissza.\n    Ellenkező esetben 'B'-t ad vissza.\n\n@example\nf_29(90) // returns 'A'", "es": "Escribe una función de JavaScript `function f_29(score)` para resolver el siguiente problema:\nEvalúa la calificación para un entero de entrada.\n\nParámetros:\n- score (int): La puntuación entera a evaluar.\n\nDevuelve:\n    char: La calificación correspondiente a la puntuación de entrada.\n    Si la puntuación está entre 90 y 100 (inclusive), devuelve 'A'.\n    De lo contrario, devuelve 'B'.\n\n@example\nf_29(90) // devuelve 'A'", "arb": "اكتب دالة JavaScript `function f_29(score)` لحل المشكلة التالية:\nتقييم الدرجة لعدد صحيح مدخل.\n\nالمعطيات:\n- score (int): الدرجة الصحيحة التي سيتم تقييمها.\n\nالقيم المعادة:\n    char: الدرجة المقابلة للدرجة المدخلة.\n    إذا كانت الدرجة بين 90 و 100 (شاملة)، تعيد 'A'.\n    خلاف ذلك، تعيد 'B'.\n\n@example\nf_29(90) // يعيد 'A'", "sw": "Andika kazi ya JavaScript `function f_29(score)` kutatua tatizo lifuatalo:  \nTambua alama kwa namba kamili iliyoingizwa.\n\nVigezo:\n- score (int): Alama ya namba kamili inayopaswa kutathminiwa.\n\nInarudisha:\n    char: Alama inayolingana na alama iliyoingizwa.\n    Ikiwa alama iko kati ya 90 na 100 (ikijumuisha), inarudisha 'A'.\n    Vinginevyo, inarudisha 'B'.\n\n@example\nf_29(90) // inarejesha 'A'", "tr": "Bir JavaScript fonksiyonu `function f_29(score)` yazın:\nBir tamsayı notunu değerlendirin.\n\nParametreler:\n- score (int): Değerlendirilecek tamsayı puanı.\n\nDöndürür:\n    char: Girdi puanına karşılık gelen not.\n    Eğer puan 90 ile 100 arasında (dahil) ise, 'A' döndürür.\n    Aksi takdirde, 'B' döndürür.\n\n@example\nf_29(90) // 'A' döndürür", "vi": "Viết một hàm JavaScript `function f_29(score)` để giải quyết vấn đề sau:  \nĐánh giá điểm cho một số nguyên đầu vào.\n\nTham số:  \n- score (int): Điểm số nguyên cần được đánh giá.\n\nTrả về:  \n    char: Điểm tương ứng với điểm số đầu vào.  \n    Nếu điểm số nằm trong khoảng từ 90 đến 100 (bao gồm cả 90 và 100), trả về 'A'.  \n    Ngược lại, trả về 'B'.\n\n@example  \nf_29(90) // trả về 'A'", "id": "Tulis sebuah fungsi JavaScript `function f_29(score)` untuk menyelesaikan masalah berikut:\nEvaluasi nilai untuk sebuah bilangan bulat masukan.\n\nParameter:\n- score (int): Skor bilangan bulat yang akan dievaluasi.\n\nMengembalikan:\n    char: Nilai yang sesuai dengan skor masukan.\n    Jika skor antara 90 dan 100 (inklusif), mengembalikan 'A'.\n    Jika tidak, mengembalikan 'B'.\n\n@example\nf_29(90) // returns 'A'", "ja": "次の問題を解決するためのJavaScript関数 `function f_29(score)` を作成してください:\n入力された整数の評価を行います。\n\nパラメータ:\n- score (int): 評価する整数のスコア。\n\n戻り値:\n    char: 入力されたスコアに対応する評価。\n    スコアが90から100の間（含む）の場合は 'A' を返します。\n    それ以外の場合は 'B' を返します。\n\n@example\nf_29(90) // returns 'A'", "ko": "`function f_29(score)` 함수를 작성하여 다음 문제를 해결하십시오:\n입력 정수에 대한 등급을 평가합니다.\n\n매개변수:\n- score (int): 평가할 정수 점수입니다.\n\n반환:\n    char: 입력 점수에 해당하는 등급입니다.\n    점수가 90에서 100 사이(포함)인 경우, 'A'를 반환합니다.\n    그렇지 않으면, 'B'를 반환합니다.\n\n@example\nf_29(90) // returns 'A'", "ml": "`function f_29(score)` എന്ന ജാവാസ്ക്രിപ്റ്റ് ഫംഗ്ഷൻ എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nഇൻപുട്ട് ഇന്റിജർ ഗ്രേഡ് വിലയിരുത്തുക.\n\nപാരാമീറ്ററുകൾ:\n- score (int): വിലയിരുത്തേണ്ട ഇന്റിജർ സ്കോർ.\n\nമടക്കുന്നു:\n    char: ഇൻപുട്ട് സ്കോറിനൊത്തുള്ള ഗ്രേഡ്.\n    സ്കോർ 90നും 100നും (ഉൾപ്പെടെ) ഇടയിൽ ആണെങ്കിൽ, 'A' മടക്കുന്നു.\n    അല്ലെങ്കിൽ, 'B' മടക്കുന്നു.\n\n@example\nf_29(90) // returns 'A'", "fa": "یک تابع جاوااسکریپت `function f_29(score)` بنویسید تا مسئله زیر را حل کند:\nنمره را برای یک عدد صحیح ورودی ارزیابی کنید.\n\nپارامترها:\n- score (int): نمره عدد صحیحی که باید ارزیابی شود.\n\nبازگشت:\n    char: نمره‌ای که با نمره ورودی مطابقت دارد.\n    اگر نمره بین 90 و 100 (شامل) باشد، 'A' را برمی‌گرداند.\n    در غیر این صورت، 'B' را برمی‌گرداند.\n\n@example\nf_29(90) // returns 'A'"}, "level": "easy", "test": "function testf_29() {\n    console.assert(f_29(90) === 'A', 'Score of 90 should yield an A');\n    console.assert(f_29(89) === 'B', 'Score of 89 should yield a B');\n    console.assert(f_29(95) === 'A', 'Score of 95 should yield an A');\n    console.assert(f_29(100) === 'A', 'Score of 100 should yield an A');\n    console.assert(f_29(101) === 'B', 'Score of 101 should yield a B');\n\n    // console.log(\"All tests passed!\");\n}\n\ntestf_29();", "entry_point": "f_29", "signature": "function f_29(score)", "docstring": {"en": "Evaluate the grade for an input integer.\n\nParameters:\n- score (int): The integer score to be evaluated.\n\nReturns:\n    char: The grade corresponding to the input score.\n    If the score is between 90 and 100 (inclusive), returns 'A'.\n    Otherwise, returns 'B'.\n\n@example\nf_29(90) // returns 'A'\n", "sq": "Vlerësoni notën për një numër të plotë hyrës.\n\nParametrat:\n- score (int): Nota e plotë që do të vlerësohet.\n\nKthen:\n    char: Nota që korrespondon me notën hyrëse.\n    Nëse nota është midis 90 dhe 100 (përfshirë), kthen 'A'.\n    Përndryshe, kthen 'B'.\n\n@example\nf_29(90) // kthen 'A'", "hy": "Մուտքագրեք ամբողջ թիվը գնահատելու համար։\n\nՊարամետրեր:\n- score (int): Գնահատման ենթակա ամբողջ թիվը։\n\nՎերադարձնում է:\n    char: Մուտքագրված գնահատականին համապատասխան գնահատականը։\n    Եթե գնահատականը 90-ից 100 (ներառյալ) միջակայքում է, վերադարձնում է 'A'։\n    Հակառակ դեպքում, վերադարձնում է 'B'։\n\n@example\nf_29(90) // returns 'A'", "bn": "একটি পূর্ণসংখ্যা গ্রেড মূল্যায়ন করুন।\n\nপ্যারামিটারসমূহ:\n- score (int): মূল্যায়ন করার জন্য পূর্ণসংখ্যার স্কোর।\n\nফেরত দেয়:\n    char: ইনপুট স্কোরের সাথে সম্পর্কিত গ্রেড।\n    যদি স্কোর ৯০ এবং ১০০ এর মধ্যে (অন্তর্ভুক্ত) হয়, তাহলে 'A' ফেরত দেয়।\n    অন্যথায়, 'B' ফেরত দেয়।\n\n@example\nf_29(90) // returns 'A'", "bg": "Оценете оценката за входящо цяло число.\n\nПараметри:\n- score (int): Цялочислената оценка, която ще бъде оценена.\n\nВръща:\n    char: Оценката, съответстваща на входящата оценка.\n    Ако оценката е между 90 и 100 (включително), връща 'A'.\n    В противен случай, връща 'B'.\n\n@пример\nf_29(90) // връща 'A'", "zh": "评估输入整数的等级。\n\n参数：\n- score (int): 要评估的整数分数。\n\n返回：\n    char: 与输入分数对应的等级。\n    如果分数在90到100之间（包括90和100），返回 'A'。\n    否则，返回 'B'。\n\n@example\nf_29(90) // returns 'A'", "fr": "Évaluer la note pour un entier d'entrée.\n\nParamètres:\n- score (int): Le score entier à évaluer.\n\nRenvoie:\n    char: La note correspondant au score d'entrée.\n    Si le score est compris entre 90 et 100 (inclus), renvoie 'A'.\n    Sinon, renvoie 'B'.\n\n@example\nf_29(90) // returns 'A'", "de": "Bewerten Sie die Note für eine eingegebene ganze Zahl.\n\nParameter:\n- score (int): Die zu bewertende Ganzzahlpunktzahl.\n\nRückgabewerte:\n    char: Die Note, die der eingegebenen Punktzahl entspricht.\n    Wenn die Punktzahl zwischen 90 und 100 (einschließlich) liegt, wird 'A' zurückgegeben.\n    Andernfalls wird 'B' zurückgegeben.\n\n@Beispiel\nf_29(90) // gibt 'A' zurück", "ha": "Kimanta darajar don wani shigarwar cikakken lamba.\n\nSigogi:\n- score (int): Lambar maki da za a tantance.\n\nDawowa:\n    char: Darajar da ta dace da shigarwar maki.\n    Idan maki yana tsakanin 90 da 100 (ciki har da), yana dawowa 'A'.\n    In ba haka ba, yana dawowa 'B'.\n\n@misali\nf_29(90) // yana dawowa 'A'", "hi": "इनपुट पूर्णांक के लिए ग्रेड का मूल्यांकन करें।\n\nपैरामीटर्स:\n- score (int): मूल्यांकन के लिए पूर्णांक स्कोर।\n\nवापसी:\n    char: इनपुट स्कोर के अनुरूप ग्रेड।\n    यदि स्कोर 90 और 100 के बीच (समावेशी) है, तो 'A' लौटाता है।\n    अन्यथा, 'B' लौटाता है।\n\n@उदाहरण\nf_29(90) // 'A' लौटाता है", "hu": "Értékelje az egész szám osztályzatát.\n\nParaméterek:\n- score (int): Az értékelendő egész szám pontszám.\n\nVisszatér:\n    char: A bemeneti pontszámnak megfelelő osztályzat.\n    Ha a pontszám 90 és 100 között van (beleértve), 'A'-t ad vissza.\n    Egyébként 'B'-t ad vissza.\n\n@példa\nf_29(90) // returns 'A'", "es": "Evaluar la calificación para un entero de entrada.\n\nParámetros:\n- score (int): La puntuación entera a evaluar.\n\nDevuelve:\n    char: La calificación correspondiente a la puntuación de entrada.\n    Si la puntuación está entre 90 y 100 (inclusive), devuelve 'A'.\n    De lo contrario, devuelve 'B'.\n\n@example\nf_29(90) // devuelve 'A'", "arb": "تقييم الدرجة لعدد صحيح مُدخل.\n\nالمعلمات:\n- score (int): الدرجة الصحيحة التي سيتم تقييمها.\n\nالعوائد:\n    char: الدرجة المقابلة للدرجة المُدخلة.\n    إذا كانت الدرجة بين 90 و 100 (شاملة)، تُرجع 'A'.\n    خلاف ذلك، تُرجع 'B'.\n\n@example\nf_29(90) // يعيد 'A'", "sw": "Tambua daraja kwa namba kamili iliyoingizwa.\n\nVigezo:\n- score (int): Alama ya namba kamili inayopaswa kutathminiwa.\n\nRudisha:\n    char: Daraja linalolingana na alama iliyoingizwa.\n    Ikiwa alama iko kati ya 90 na 100 (ikiwemo), inarudisha 'A'.\n    Vinginevyo, inarudisha 'B'.\n\n@mfano\nf_29(90) // inarudisha 'A'", "tr": "Girdi tam sayısı için notu değerlendirin.\n\nParametreler:\n- score (int): Değerlendirilecek tam sayı puanı.\n\nDöndürülenler:\n    char: Girdi puanına karşılık gelen not.\n    Eğer puan 90 ile 100 arasında (dahil) ise, 'A' döner.\n    Aksi takdirde, 'B' döner.\n\n@example\nf_29(90) // 'A' döner", "vi": "Đánh giá điểm cho một số nguyên đầu vào.\n\nTham số:\n- score (int): Điểm số nguyên cần được đánh giá.\n\nTrả về:\n    char: Điểm tương ứng với điểm số đầu vào.\n    Nếu điểm số nằm trong khoảng từ 90 đến 100 (bao gồm cả 90 và 100), trả về 'A'.\n    Ngược lại, trả về 'B'.\n\n@example\nf_29(90) // trả về 'A'", "id": "Evaluasi nilai untuk bilangan bulat masukan.\n\nParameter:\n- score (int): Skor bilangan bulat yang akan dievaluasi.\n\nMengembalikan:\n    char: Nilai yang sesuai dengan skor masukan.\n    Jika skor antara 90 dan 100 (inklusif), mengembalikan 'A'.\n    Jika tidak, mengembalikan 'B'.\n\n@example\nf_29(90) // mengembalikan 'A'", "ja": "入力整数の評価を行います。\n\n引数:\n- score (int): 評価する整数スコア。\n\n返り値:\n    char: 入力スコアに対応する評価。\n    スコアが90から100の範囲（含む）の場合は 'A' を返します。\n    それ以外の場合は 'B' を返します。\n\n@example\nf_29(90) // returns 'A'", "ko": "입력된 정수에 대한 등급을 평가합니다.\n\n매개변수:\n- score (int): 평가할 정수 점수입니다.\n\n반환값:\n    char: 입력 점수에 해당하는 등급입니다.\n    점수가 90에서 100 사이(포함)인 경우 'A'를 반환합니다.\n    그렇지 않으면 'B'를 반환합니다.\n\n@example\nf_29(90) // returns 'A'", "ml": "ഇൻപുട്ട് ഇന്റിജറിന് ഗ്രേഡ് വിലയിരുത്തുക.\n\nപാരാമീറ്ററുകൾ:\n- score (int): വിലയിരുത്തേണ്ട ഇന്റിജർ സ്കോർ.\n\nമടക്കങ്ങൾ:\n    char: ഇൻപുട്ട് സ്കോറിന് അനുയോജ്യമായ ഗ്രേഡ്.\n    സ്കോർ 90നും 100നും ഇടയിൽ (ഉൾപ്പെടെ) ആണെങ്കിൽ, 'A' മടക്കുന്നു.\n    അല്ലെങ്കിൽ, 'B' മടക്കുന്നു.\n\n@example\nf_29(90) // 'A' മടക്കുന്നു", "fa": "ارزیابی نمره برای یک عدد صحیح ورودی.\n\nپارامترها:\n- score (int): نمره عدد صحیح که باید ارزیابی شود.\n\nبازگشت:\n    char: نمره‌ای که با نمره ورودی مطابقت دارد.\n    اگر نمره بین 90 و 100 (شامل) باشد، 'A' را برمی‌گرداند.\n    در غیر این صورت، 'B' را برمی‌گرداند.\n\n@example\nf_29(90) // returns 'A'"}}
{"task_id": "JavaScript/30", "prompt": {"en": "// Note: No import statement is required in JavaScript for this function\n/**\n * Checks if a string with exactly three characters has two characters that are the same.\n * \n * @param {string} str - The three-character string to be checked.\n * @return {string} - Returns 'Yes' if the input has exactly two equal characters, otherwise 'No'.\n * \n * Examples:\n * f_30('112') // 'Yes'\n * f_30('123') // 'No'\n */\nfunction f_30(str)", "sq": "// Shënim: Nuk kërkohet ndonjë deklaratë importi në JavaScript për këtë funksion\n/**\n * Kontrollon nëse një varg me saktësisht tre karaktere ka dy karaktere që janë të njëjta.\n * \n * @param {string} str - Vargu me tre karaktere që do të kontrollohet.\n * @return {string} - Kthen 'Yes' nëse hyrja ka saktësisht dy karaktere të barabarta, përndryshe 'No'.\n * \n * Shembuj:\n * f_30('112') // 'Yes'\n * f_30('123') // 'No'\n */", "hy": "// Նշում: JavaScript-ում այս ֆունկցիայի համար ներմուծման հրահանգ անհրաժեշտ չէ\n/**\n * Ստուգում է, արդյոք երեք նիշ ունեցող տողում կա երկու նույն նիշ:\n * \n * @param {string} str - Երեք նիշ ունեցող տողը, որը պետք է ստուգվի:\n * @return {string} - Վերադարձնում է 'Yes', եթե մուտքագրումը ունի հենց երկու հավասար նիշ, հակառակ դեպքում՝ 'No':\n * \n * Օրինակներ:\n * f_30('112') // 'Yes'\n * f_30('123') // 'No'\n */", "bn": "// লক্ষ্য করুন: এই ফাংশনের জন্য জাভাস্ক্রিপ্টে কোনো ইম্পোর্ট স্টেটমেন্ট প্রয়োজন নেই\n/**\n * পরীক্ষা করে যে একটি স্ট্রিংয়ের ঠিক তিনটি অক্ষর আছে এবং তার মধ্যে দুটি অক্ষর একই কিনা।\n * \n * @param {string} str - তিন-অক্ষরের স্ট্রিং যা পরীক্ষা করা হবে।\n * @return {string} - 'Yes' রিটার্ন করে যদি ইনপুটে ঠিক দুটি সমান অক্ষর থাকে, অন্যথায় 'No'।\n * \n * উদাহরণ:\n * f_30('112') // 'Yes'\n * f_30('123') // 'No'\n */", "bg": "// Забележка: Не е необходимо включване на import израз в JavaScript за тази функция\n/**\n * Проверява дали низ с точно три символа има два еднакви символа.\n * \n * @param {string} str - Трисимволният низ, който ще бъде проверен.\n * @return {string} - Връща 'Yes', ако входът има точно два еднакви символа, в противен случай 'No'.\n * \n * Примери:\n * f_30('112') // 'Yes'\n * f_30('123') // 'No'\n */\nfunction f_30(str)", "zh": "// 注意：在 JavaScript 中，这个函数不需要导入语句\n/**\n * 检查一个正好有三个字符的字符串是否有两个字符相同。\n * \n * @param {string} str - 要检查的三字符字符串。\n * @return {string} - 如果输入有正好两个相等的字符，则返回 'Yes'，否则返回 'No'。\n * \n * 示例:\n * f_30('112') // 'Yes'\n * f_30('123') // 'No'\n */\nfunction f_30(str)", "fr": "// Remarque : Aucune instruction d'importation n'est requise en JavaScript pour cette fonction\n/**\n * Vérifie si une chaîne de exactement trois caractères a deux caractères identiques.\n * \n * @param {string} str - La chaîne de trois caractères à vérifier.\n * @return {string} - Retourne 'Yes' si l'entrée a exactement deux caractères égaux, sinon 'No'.\n * \n * Exemples :\n * f_30('112') // 'Yes'\n * f_30('123') // 'No'\n */\nfunction f_30(str)", "de": "// Hinweis: Für diese Funktion ist in JavaScript keine Importanweisung erforderlich\n/**\n * Überprüft, ob ein String mit genau drei Zeichen zwei gleiche Zeichen hat.\n * \n * @param {string} str - Der zu überprüfende Drei-Zeichen-String.\n * @return {string} - Gibt 'Yes' zurück, wenn der Eingabewert genau zwei gleiche Zeichen hat, andernfalls 'No'.\n * \n * Beispiele:\n * f_30('112') // 'Yes'\n * f_30('123') // 'No'\n */", "ha": "// Lura: Babu buƙatar shigo da bayanin a JavaScript don wannan aikin\n/**\n * Duba idan igiyar da ke da haruffa uku daidai tana da haruffa biyu da suke daidai.\n * \n * @param {string} str - Igiyar haruffa uku da za a duba.\n * @return {string} - Ya dawo da 'Yes' idan shigarwar tana da daidai haruffa biyu, in ba haka ba 'No'.\n * \n * Misalai:\n * f_30('112') // 'Yes'\n * f_30('123') // 'No'\n */", "hi": "// नोट: इस फ़ंक्शन के लिए JavaScript में कोई इम्पोर्ट स्टेटमेंट आवश्यक नहीं है\n/**\n * जाँच करता है कि क्या तीन वर्णों वाली एक स्ट्रिंग में दो वर्ण समान हैं।\n * \n * @param {string} str - जाँच के लिए तीन-वर्णों वाली स्ट्रिंग।\n * @return {string} - यदि इनपुट में ठीक दो समान वर्ण हैं तो 'Yes' लौटाता है, अन्यथा 'No'।\n * \n * उदाहरण:\n * f_30('112') // 'Yes'\n * f_30('123') // 'No'\n */\nfunction f_30(str)", "hu": "// Megjegyzés: Ehhez a függvényhez nincs szükség import utasításra JavaScriptben\n/**\n * Ellenőrzi, hogy egy pontosan három karakter hosszú stringben van-e két azonos karakter.\n * \n * @param {string} str - Az ellenőrizendő három karakter hosszú string.\n * @return {string} - 'Yes'-t ad vissza, ha a bemenet pontosan két egyenlő karaktert tartalmaz, különben 'No'-t.\n * \n * Példák:\n * f_30('112') // 'Yes'\n * f_30('123') // 'No'\n */", "es": "// Nota: No se requiere una declaración de importación en JavaScript para esta función\n/**\n * Verifica si una cadena con exactamente tres caracteres tiene dos caracteres que son iguales.\n * \n * @param {string} str - La cadena de tres caracteres a verificar.\n * @return {string} - Devuelve 'Yes' si la entrada tiene exactamente dos caracteres iguales, de lo contrario 'No'.\n * \n * Ejemplos:\n * f_30('112') // 'Yes'\n * f_30('123') // 'No'\n */\nfunction f_30(str)", "arb": "// ملاحظة: لا حاجة لجملة استيراد في JavaScript لهذه الدالة\n/**\n * يتحقق مما إذا كانت سلسلة تحتوي على ثلاثة أحرف بالضبط لديها حرفان متماثلان.\n * \n * @param {string} str - السلسلة المكونة من ثلاثة أحرف التي سيتم التحقق منها.\n * @return {string} - يعيد 'Yes' إذا كان المدخل يحتوي على حرفين متساويين بالضبط، وإلا 'No'.\n * \n * أمثلة:\n * f_30('112') // 'Yes'\n * f_30('123') // 'No'\n */\nfunction f_30(str)", "sw": "// Kumbuka: Hakuna tamko la kuingiza linalohitajika katika JavaScript kwa kazi hii\n/**\n * Hukagua kama kamba yenye herufi tatu ina herufi mbili ambazo ni sawa.\n * \n * @param {string} str - Kamba ya herufi tatu inayopaswa kukaguliwa.\n * @return {string} - Inarudisha 'Yes' ikiwa ingizo lina herufi mbili sawa, vinginevyo 'No'.\n * \n * Mifano:\n * f_30('112') // 'Yes'\n * f_30('123') // 'No'\n */\nfunction f_30(str)", "tr": "// Not: Bu fonksiyon için JavaScript'te herhangi bir import ifadesi gerekli değildir.\n/**\n * Üç karakterden oluşan bir dizgede iki karakterin aynı olup olmadığını kontrol eder.\n * \n * @param {string} str - Kontrol edilecek üç karakterli dizge.\n * @return {string} - Girdi tam olarak iki eşit karaktere sahipse 'Yes', aksi takdirde 'No' döner.\n * \n * Örnekler:\n * f_30('112') // 'Yes'\n * f_30('123') // 'No'\n */\nfunction f_30(str)", "vi": "// Lưu ý: Không cần câu lệnh import trong JavaScript cho hàm này\n/**\n * Kiểm tra xem một chuỗi có đúng ba ký tự có hai ký tự giống nhau hay không.\n * \n * @param {string} str - Chuỗi ba ký tự cần được kiểm tra.\n * @return {string} - Trả về 'Yes' nếu đầu vào có đúng hai ký tự bằng nhau, ngược lại trả về 'No'.\n * \n * Ví dụ:\n * f_30('112') // 'Yes'\n * f_30('123') // 'No'\n */\nfunction f_30(str)", "id": "// Catatan: Tidak diperlukan pernyataan impor dalam JavaScript untuk fungsi ini\n/**\n * Memeriksa apakah sebuah string dengan tepat tiga karakter memiliki dua karakter yang sama.\n * \n * @param {string} str - String tiga karakter yang akan diperiksa.\n * @return {string} - Mengembalikan 'Yes' jika input memiliki tepat dua karakter yang sama, jika tidak 'No'.\n * \n * Contoh:\n * f_30('112') // 'Yes'\n * f_30('123') // 'No'\n */\nfunction f_30(str)", "ja": "// 注意: この関数にはJavaScriptでインポート文は必要ありません\n/**\n * 3文字ちょうどの文字列に同じ文字が2つあるかどうかを確認します。\n * \n * @param {string} str - チェックする3文字の文字列。\n * @return {string} - 入力にちょうど2つの同じ文字がある場合は 'Yes' を返し、それ以外の場合は 'No' を返します。\n * \n * 例:\n * f_30('112') // 'Yes'\n * f_30('123') // 'No'\n */\nfunction f_30(str)", "ko": "// 참고: 이 함수에는 JavaScript에서 import 문이 필요하지 않습니다.\n/**\n * 정확히 세 개의 문자로 구성된 문자열에 두 개의 문자가 동일한지 확인합니다.\n * \n * @param {string} str - 확인할 세 문자로 구성된 문자열입니다.\n * @return {string} - 입력에 정확히 두 개의 동일한 문자가 있으면 'Yes'를 반환하고, 그렇지 않으면 'No'를 반환합니다.\n * \n * 예시:\n * f_30('112') // 'Yes'\n * f_30('123') // 'No'\n */\nfunction f_30(str)", "ml": "// കുറിപ്പ്: ഈ ഫംഗ്ഷനിലേക്ക് JavaScript-ൽ ഒരു ഇമ്പോർട്ട് സ്റ്റേറ്റ്മെന്റും ആവശ്യമില്ല\n/**\n * മൂന്ന് അക്ഷരങ്ങൾ ഉള്ള ഒരു സ്ട്രിംഗിൽ രണ്ട് അക്ഷരങ്ങൾ സമാനമാണോ എന്ന് പരിശോധിക്കുന്നു.\n * \n * @param {string} str - പരിശോധിക്കേണ്ട മൂന്ന് അക്ഷരങ്ങളുള്ള സ്ട്രിംഗ്.\n * @return {string} - ഇൻപുട്ടിൽ കൃത്യമായി രണ്ട് സമാന അക്ഷരങ്ങൾ ഉണ്ടെങ്കിൽ 'Yes' തിരികെ നൽകുന്നു, അല്ലെങ്കിൽ 'No'.\n * \n * ഉദാഹരണങ്ങൾ:\n * f_30('112') // 'Yes'\n * f_30('123') // 'No'\n */\nfunction f_30(str)", "fa": "// توجه: برای این تابع در جاوااسکریپت نیازی به دستور import نیست\n/**\n * بررسی می‌کند که آیا یک رشته با دقیقاً سه کاراکتر دارای دو کاراکتر یکسان است یا خیر.\n * \n * @param {string} str - رشته سه کاراکتری که باید بررسی شود.\n * @return {string} - 'Yes' را برمی‌گرداند اگر ورودی دقیقاً دو کاراکتر برابر داشته باشد، در غیر این صورت 'No'.\n * \n * مثال‌ها:\n * f_30('112') // 'Yes'\n * f_30('123') // 'No'\n */"}, "canonical_solution": "{\n    if ((str[0] === str[1] && str[1] !== str[2]) ||\n        (str[0] === str[2] && str[0] !== str[1]) ||\n        (str[1] === str[2] && str[0] !== str[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}", "instruction": {"en": "Write a JavaScript function `function f_30(str)` to solve the following problem:\nChecks if a string with exactly three characters has two characters that are the same.\n\nParameters:\n- str (string): The three-character string to be checked.\n\nReturns:\n- string: Returns 'Yes' if the input has exactly two equal characters, otherwise 'No'.\n\nExamples:\n f_30('112') // 'Yes'\n f_30('123') // 'No'", "sq": "Shkruani një funksion JavaScript `function f_30(str)` për të zgjidhur problemin e mëposhtëm:  \nKontrollon nëse një varg me saktësisht tre karaktere ka dy karaktere që janë të njëjta.\n\nParametrat:  \n- str (string): Vargu me tre karaktere që do të kontrollohet.\n\nKthen:  \n- string: Kthen 'Yes' nëse inputi ka saktësisht dy karaktere të barabartë, përndryshe 'No'.\n\nShembuj:  \n f_30('112') // 'Yes'  \n f_30('123') // 'No'", "hy": "Գրեք JavaScript ֆունկցիա `function f_30(str)` հետևյալ խնդիրը լուծելու համար:\nՍտուգում է, արդյոք երեք նիշից բաղկացած տողում կա երկու նույն նիշ:\n\nՊարամետրեր:\n- str (string): Երեք նիշից բաղկացած ստուգվող տողը:\n\nՎերադարձնում է:\n- string: Վերադարձնում է 'Yes', եթե մուտքագրումը ունի ճիշտ երկու հավասար նիշ, հակառակ դեպքում՝ 'No':\n\nՕրինակներ:\n f_30('112') // 'Yes'\n f_30('123') // 'No'", "bn": "একটি জাভাস্ক্রিপ্ট ফাংশন `function f_30(str)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nযাচাই করে যে একটি তিনটি অক্ষরের স্ট্রিংয়ে দুটি অক্ষর একই কি না।\n\nপ্যারামিটারসমূহ:\n- str (string): তিনটি অক্ষরের স্ট্রিং যা যাচাই করা হবে।\n\nরিটার্নস:\n- string: যদি ইনপুটে ঠিক দুটি সমান অক্ষর থাকে তবে 'Yes' রিটার্ন করে, অন্যথায় 'No'।\n\nউদাহরণসমূহ:\n f_30('112') // 'Yes'\n f_30('123') // 'No'", "bg": "Напишете JavaScript функция `function f_30(str)`, за да решите следния проблем:  \nПроверява дали низ с точно три знака има два знака, които са еднакви.\n\nПараметри:\n- str (string): Тризнаковият низ, който ще бъде проверен.\n\nВръща:\n- string: Връща 'Yes', ако входът има точно два еднакви знака, в противен случай 'No'.\n\nПримери:\n f_30('112') // 'Yes'\n f_30('123') // 'No'", "zh": "编写一个 JavaScript 函数 `function f_30(str)` 来解决以下问题：\n检查一个恰好有三个字符的字符串是否有两个字符相同。\n\n参数：\n- str (string): 要检查的三个字符的字符串。\n\n返回：\n- string: 如果输入恰好有两个相同的字符，则返回 'Yes'，否则返回 'No'。\n\n示例：\n f_30('112') // 'Yes'\n f_30('123') // 'No'", "fr": "Écrire une fonction JavaScript `function f_30(str)` pour résoudre le problème suivant :  \nVérifie si une chaîne de caractères avec exactement trois caractères a deux caractères qui sont identiques.\n\nParamètres :  \n- str (string) : La chaîne de trois caractères à vérifier.\n\nRenvoie :  \n- string : Renvoie 'Yes' si l'entrée a exactement deux caractères égaux, sinon 'No'.\n\nExemples :  \n f_30('112') // 'Yes'  \n f_30('123') // 'No'", "de": "Schreiben Sie eine JavaScript-Funktion `function f_30(str)`, um das folgende Problem zu lösen:\nÜberprüft, ob ein String mit genau drei Zeichen zwei gleiche Zeichen hat.\n\nParameter:\n- str (string): Der zu überprüfende Drei-Zeichen-String.\n\nRückgabewerte:\n- string: Gibt 'Yes' zurück, wenn der Eingabewert genau zwei gleiche Zeichen hat, andernfalls 'No'.\n\nBeispiele:\n f_30('112') // 'Yes'\n f_30('123') // 'No'", "ha": "Rubuta wani aikin JavaScript `function f_30(str)` don magance matsalar mai zuwa: \n\nDuba idan kirtani da ke daidai haruffa uku yana da haruffa biyu da suke daidai.\n\nSigogi:\n- str (string): Kirtanin haruffa uku da za a duba.\n\nDawowa:\n- string: Ya dawo 'Yes' idan shigarwar tana daidai da haruffa biyu, in ba haka ba 'No'.\n\nMisalai:\n f_30('112') // 'Yes'\n f_30('123') // 'No'", "hi": "JavaScript फ़ंक्शन `function f_30(str)` लिखें ताकि निम्नलिखित समस्या को हल किया जा सके:\nजाँच करता है कि क्या तीन वर्णों वाली एक स्ट्रिंग में दो वर्ण समान हैं।\n\nपैरामीटर्स:\n- str (string): तीन-वर्णों वाली स्ट्रिंग जिसे जाँचना है।\n\nवापसी:\n- string: 'Yes' लौटाता है यदि इनपुट में ठीक दो समान वर्ण हैं, अन्यथा 'No'।\n\nउदाहरण:\n f_30('112') // 'Yes'\n f_30('123') // 'No'", "hu": "Írj egy JavaScript függvényt `function f_30(str)` a következő probléma megoldására:\nEllenőrzi, hogy egy pontosan három karakterből álló string tartalmaz-e két azonos karaktert.\n\nParaméterek:\n- str (string): Az ellenőrizendő három karakteres string.\n\nVisszatérési érték:\n- string: 'Yes'-t ad vissza, ha a bemenet pontosan két egyenlő karaktert tartalmaz, különben 'No'-t.\n\nPéldák:\n f_30('112') // 'Yes'\n f_30('123') // 'No'", "es": "Escribe una función de JavaScript `function f_30(str)` para resolver el siguiente problema:\nVerifica si una cadena con exactamente tres caracteres tiene dos caracteres que son iguales.\n\nParámetros:\n- str (string): La cadena de tres caracteres que se va a verificar.\n\nDevuelve:\n- string: Devuelve 'Yes' si la entrada tiene exactamente dos caracteres iguales, de lo contrario 'No'.\n\nEjemplos:\n f_30('112') // 'Yes'\n f_30('123') // 'No'", "arb": "اكتب دالة جافا سكريبت `function f_30(str)` لحل المشكلة التالية:\nالتحقق مما إذا كانت سلسلة تحتوي على ثلاثة أحرف بالضبط تحتوي على حرفين متشابهين.\n\nالمعلمات:\n- str (string): السلسلة المكونة من ثلاثة أحرف التي سيتم التحقق منها.\n\nالقيم المعادة:\n- string: تعيد 'Yes' إذا كان الإدخال يحتوي على حرفين متساويين بالضبط، وإلا تعيد 'No'.\n\nأمثلة:\n f_30('112') // 'Yes'\n f_30('123') // 'No'", "sw": "Andika kazi ya JavaScript `function f_30(str)` kutatua tatizo lifuatalo:\nInakagua kama kamba yenye herufi tatu tu ina herufi mbili ambazo ni sawa.\n\nVigezo:\n- str (string): Kamba ya herufi tatu itakayokaguliwa.\n\nInarudisha:\n- string: Inarudisha 'Yes' ikiwa kipengele kina herufi mbili sawa, vinginevyo 'No'.\n\nMifano:\n f_30('112') // 'Yes'\n f_30('123') // 'No'", "tr": "Bir JavaScript fonksiyonu `function f_30(str)` yazın:\nTam olarak üç karakter içeren bir dizgede iki karakterin aynı olup olmadığını kontrol eder.\n\nParametreler:\n- str (string): Kontrol edilecek üç karakterli dizge.\n\nDöndürür:\n- string: Girdi tam olarak iki eşit karaktere sahipse 'Yes', aksi takdirde 'No' döndürür.\n\nÖrnekler:\n f_30('112') // 'Yes'\n f_30('123') // 'No'", "vi": "Viết một hàm JavaScript `function f_30(str)` để giải quyết vấn đề sau:  \nKiểm tra xem một chuỗi có đúng ba ký tự có hai ký tự giống nhau hay không.\n\nTham số:\n- str (string): Chuỗi ba ký tự cần được kiểm tra.\n\nTrả về:\n- string: Trả về 'Yes' nếu đầu vào có chính xác hai ký tự giống nhau, ngược lại 'No'.\n\nVí dụ:\n f_30('112') // 'Yes'\n f_30('123') // 'No'", "id": "Tulis fungsi JavaScript `function f_30(str)` untuk menyelesaikan masalah berikut:\nMemeriksa apakah sebuah string dengan tepat tiga karakter memiliki dua karakter yang sama.\n\nParameter:\n- str (string): String tiga karakter yang akan diperiksa.\n\nMengembalikan:\n- string: Mengembalikan 'Yes' jika input memiliki tepat dua karakter yang sama, jika tidak 'No'.\n\nContoh:\n f_30('112') // 'Yes'\n f_30('123') // 'No'", "ja": "JavaScript関数`function f_30(str)`を作成して、次の問題を解決してください:\n3文字ちょうどの文字列に、同じ文字が2つあるかどうかを確認します。\n\nパラメータ:\n- str (string): チェックする3文字の文字列。\n\n戻り値:\n- string: 入力にちょうど2つの同じ文字がある場合は 'Yes' を返し、それ以外の場合は 'No' を返します。\n\n例:\n f_30('112') // 'Yes'\n f_30('123') // 'No'", "ko": "JavaScript 함수 `function f_30(str)`를 작성하여 다음 문제를 해결하십시오:  \n세 개의 문자로 구성된 문자열에 두 개의 동일한 문자가 있는지 확인합니다.\n\n매개변수:  \n- str (string): 확인할 세 문자로 구성된 문자열.\n\n반환:  \n- string: 입력에 정확히 두 개의 동일한 문자가 있으면 'Yes'를 반환하고, 그렇지 않으면 'No'를 반환합니다.\n\n예시:  \n f_30('112') // 'Yes'  \n f_30('123') // 'No'", "ml": "`function f_30(str)` എന്ന ജാവാസ്ക്രിപ്റ്റ് ഫംഗ്ഷൻ എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nമൂന്ന് അക്ഷരങ്ങൾ കൃത്യമായി ഉള്ള ഒരു സ്ട്രിംഗിൽ രണ്ട് അക്ഷരങ്ങൾ ഒരേപോലെ ഉണ്ടോ എന്ന് പരിശോധിക്കുന്നു.\n\nപാരാമീറ്ററുകൾ:\n- str (string): പരിശോധിക്കേണ്ട മൂന്ന്-അക്ഷര സ്ട്രിംഗ്.\n\nമടക്കുക:\n- string: ഇൻപുട്ടിൽ കൃത്യമായി രണ്ട് സമാനമായ അക്ഷരങ്ങൾ ഉണ്ടെങ്കിൽ 'Yes' മടക്കുന്നു, അല്ലെങ്കിൽ 'No'.\n\nഉദാഹരണങ്ങൾ:\n f_30('112') // 'Yes'\n f_30('123') // 'No'", "fa": "یک تابع جاوااسکریپت `function f_30(str)` بنویسید تا مسئله زیر را حل کند:\nبررسی می‌کند که آیا یک رشته با دقیقاً سه کاراکتر دارای دو کاراکتر مشابه است یا خیر.\n\nپارامترها:\n- str (string): رشته سه کاراکتری که باید بررسی شود.\n\nبازگشت:\n- string: اگر ورودی دقیقاً دو کاراکتر برابر داشته باشد، 'Yes' برمی‌گرداند، در غیر این صورت 'No'.\n\nمثال‌ها:\n f_30('112') // 'Yes'\n f_30('123') // 'No'"}, "level": "easy", "test": "const testf_30 = () => {\n    console.assert(f_30(\"112\") === \"Yes\");\n    console.assert(f_30(\"123\") === \"No\");\n    console.assert(f_30(\"232\") === \"Yes\");\n    console.assert(f_30(\"444\") === \"No\"); // All three characters are equal, not two.\n    console.assert(f_30(\"121\") === \"Yes\");\n\n    // Additional test cases to cover more scenarios\n    console.assert(f_30(\"787\") === \"Yes\");\n    console.assert(f_30(\"999\") === \"No\"); // All three characters are equal\n    console.assert(f_30(\"890\") === \"No\");\n    console.assert(f_30(\"556\") === \"Yes\");\n    console.assert(f_30(\"353\") === \"Yes\"); // No two characters are equal\n    \n    // console.log(\"All tests passed successfully.\");\n};\n\ntestf_30();", "entry_point": "f_30", "signature": "function f_30(str)", "docstring": {"en": "Checks if a string with exactly three characters has two characters that are the same.\n\nParameters:\n- str (string): The three-character string to be checked.\n\nReturns:\n- string: Returns 'Yes' if the input has exactly two equal characters, otherwise 'No'.\n\nExamples:\n f_30('112') // 'Yes'\n f_30('123') // 'No'", "sq": "Kontrollon nëse një varg me saktësisht tre karaktere ka dy karaktere që janë të njëjta.\n\nParametrat:\n- str (string): Vargu me tre karaktere që do të kontrollohet.\n\nKthen:\n- string: Kthen 'Yes' nëse hyrja ka saktësisht dy karaktere të barabartë, përndryshe 'No'.\n\nShembuj:\n f_30('112') // 'Yes'\n f_30('123') // 'No'", "hy": "Ստուգում է, արդյոք երեք նիշից բաղկացած տողում կա երկու նույն նիշ։\n\nՊարամետրեր:\n- str (string): Երեք նիշից բաղկացած տողը, որը պետք է ստուգել։\n\nՎերադարձնում է:\n- string: Վերադարձնում է 'Yes', եթե մուտքում կա հենց երկու հավասար նիշ, հակառակ դեպքում՝ 'No'։\n\nՕրինակներ:\n f_30('112') // 'Yes'\n f_30('123') // 'No'", "bn": "একটি স্ট্রিং যা ঠিক তিনটি অক্ষর নিয়ে গঠিত, তা যাচাই করে যদি দুটি অক্ষর একই হয়।\n\nপ্যারামিটার:\n- str (string): তিন-অক্ষরের স্ট্রিং যা যাচাই করা হবে।\n\nরিটার্নস:\n- string: 'Yes' রিটার্ন করে যদি ইনপুটে ঠিক দুটি সমান অক্ষর থাকে, অন্যথায় 'No'।\n\nউদাহরণ:\n f_30('112') // 'Yes'\n f_30('123') // 'No'", "bg": "Проверява дали низ с точно три знака има два еднакви знака.\n\nПараметри:\n- str (string): Тристойностният низ, който ще бъде проверен.\n\nВръща:\n- string: Връща 'Yes', ако входът има точно два еднакви знака, в противен случай 'No'.\n\nПримери:\n f_30('112') // 'Yes'\n f_30('123') // 'No'", "zh": "检查一个正好有三个字符的字符串是否有两个字符相同。\n\n参数：\n- str (string): 要检查的三个字符的字符串。\n\n返回：\n- string: 如果输入有正好两个相同的字符，则返回 'Yes'，否则返回 'No'。\n\n示例：\n f_30('112') // 'Yes'\n f_30('123') // 'No'", "fr": "Vérifie si une chaîne de caractères avec exactement trois caractères a deux caractères identiques.\n\nParamètres:\n- str (string): La chaîne de trois caractères à vérifier.\n\nRenvoie:\n- string: Renvoie 'Yes' si l'entrée a exactement deux caractères égaux, sinon 'No'.\n\nExemples:\n f_30('112') // 'Yes'\n f_30('123') // 'No'", "de": "Prüft, ob ein String mit genau drei Zeichen zwei gleiche Zeichen hat.\n\nParameter:\n- str (string): Der zu überprüfende Drei-Zeichen-String.\n\nRückgabe:\n- string: Gibt 'Yes' zurück, wenn der Eingabewert genau zwei gleiche Zeichen hat, andernfalls 'No'.\n\nBeispiele:\n f_30('112') // 'Yes'\n f_30('123') // 'No'", "ha": "Duba idan wani kirtani mai ainihin haruffa uku yana da haruffa biyu da suke iri ɗaya.\n\nSigogi:\n- str (string): Kirtanin haruffa uku da za a duba.\n\nAbin da ya dawo:\n- string: Yana dawowa 'Yes' idan shigarwar tana da ainihin haruffa biyu masu daidaituwa, in ba haka ba 'No'.\n\nMisalai:\n f_30('112') // 'Yes'\n f_30('123') // 'No'", "hi": "तीन वर्णों वाली एक स्ट्रिंग की जाँच करता है कि उसमें दो वर्ण समान हैं या नहीं।\n\nपैरामीटर्स:\n- str (string): तीन वर्णों वाली स्ट्रिंग जिसकी जाँच की जानी है।\n\nवापसी:\n- string: 'Yes' लौटाता है यदि इनपुट में ठीक दो समान वर्ण हैं, अन्यथा 'No'।\n\nउदाहरण:\n f_30('112') // 'Yes'\n f_30('123') // 'No'", "hu": "Ellenőrzi, hogy egy pontosan három karakterből álló stringben van-e két azonos karakter.\n\nParaméterek:\n- str (string): Az ellenőrizendő három karakter hosszú string.\n\nVisszatérési érték:\n- string: 'Yes' értéket ad vissza, ha a bemenetben pontosan két egyenlő karakter van, ellenkező esetben 'No'.\n\nPéldák:\n f_30('112') // 'Yes'\n f_30('123') // 'No'", "es": "Verifica si una cadena con exactamente tres caracteres tiene dos caracteres que son iguales.\n\nParámetros:\n- str (string): La cadena de tres caracteres que se va a verificar.\n\nDevuelve:\n- string: Devuelve 'Yes' si la entrada tiene exactamente dos caracteres iguales, de lo contrario 'No'.\n\nEjemplos:\n f_30('112') // 'Yes'\n f_30('123') // 'No'", "arb": "يتحقق مما إذا كانت سلسلة تحتوي على ثلاثة أحرف بالضبط تحتوي على حرفين متشابهين.\n\nالمعلمات:\n- str (string): السلسلة المكونة من ثلاثة أحرف التي سيتم التحقق منها.\n\nالقيم المعادة:\n- string: يعيد 'Yes' إذا كان الإدخال يحتوي على حرفين متساويين بالضبط، وإلا يعيد 'No'.\n\nأمثلة:\n f_30('112') // 'Yes'\n f_30('123') // 'No'", "sw": "Hukagua kama kamba yenye herufi tatu ina herufi mbili zinazofanana.\n\nVigezo:\n- str (string): Kamba ya herufi tatu itakayokaguliwa.\n\nInarejesha:\n- string: Inarejesha 'Yes' ikiwa ingizo lina herufi mbili sawa, vinginevyo 'No'.\n\nMifano:\n f_30('112') // 'Yes'\n f_30('123') // 'No'", "tr": "Üç karakterden oluşan bir dizgede iki karakterin aynı olup olmadığını kontrol eder.\n\nParametreler:\n- str (string): Kontrol edilecek üç karakterli dizge.\n\nDöndürülenler:\n- string: Girdi tam olarak iki eşit karaktere sahipse 'Yes' döner, aksi takdirde 'No'.\n\nÖrnekler:\n f_30('112') // 'Yes'\n f_30('123') // 'No'", "vi": "Kiểm tra xem một chuỗi có đúng ba ký tự có hai ký tự giống nhau hay không.\n\nTham số:\n- str (string): Chuỗi ba ký tự cần được kiểm tra.\n\nTrả về:\n- string: Trả về 'Yes' nếu đầu vào có đúng hai ký tự bằng nhau, ngược lại trả về 'No'.\n\nVí dụ:\n f_30('112') // 'Yes'\n f_30('123') // 'No'", "id": "Memeriksa apakah sebuah string dengan tepat tiga karakter memiliki dua karakter yang sama.\n\nParameter:\n- str (string): String tiga karakter yang akan diperiksa.\n\nMengembalikan:\n- string: Mengembalikan 'Yes' jika input memiliki tepat dua karakter yang sama, jika tidak 'No'.\n\nContoh:\n f_30('112') // 'Yes'\n f_30('123') // 'No'", "ja": "3文字の文字列に、同じ文字が2つあるかどうかを確認します。\n\n引数:\n- str (string): チェックする3文字の文字列。\n\n戻り値:\n- string: 入力に正確に2つの等しい文字がある場合は 'Yes' を返し、それ以外の場合は 'No' を返します。\n\n例:\n f_30('112') // 'Yes'\n f_30('123') // 'No'", "ko": "세 문자의 문자열에 두 개의 문자가 동일한지 확인합니다.\n\n매개변수:\n- str (string): 확인할 세 문자로 구성된 문자열입니다.\n\n반환값:\n- string: 입력에 정확히 두 개의 동일한 문자가 있으면 'Yes'를 반환하고, 그렇지 않으면 'No'를 반환합니다.\n\n예시:\n f_30('112') // 'Yes'\n f_30('123') // 'No'", "ml": "മൂന്ന് അക്ഷരങ്ങളുള്ള ഒരു സ്ട്രിംഗിൽ രണ്ട് അക്ഷരങ്ങൾ ഒരേപോലെയാണോ എന്ന് പരിശോധിക്കുന്നു.\n\nപാരാമീറ്ററുകൾ:\n- str (string): പരിശോധിക്കേണ്ട മൂന്ന് അക്ഷരങ്ങളുള്ള സ്ട്രിംഗ്.\n\nമടക്കം:\n- string: ഇൻപുട്ടിൽ കൃത്യമായി രണ്ട് സമാനമായ അക്ഷരങ്ങൾ ഉണ്ടെങ്കിൽ 'Yes' മടക്കുന്നു, അല്ലെങ്കിൽ 'No'.\n\nഉദാഹരണങ്ങൾ:\n f_30('112') // 'Yes'\n f_30('123') // 'No'", "fa": "بررسی می‌کند که آیا یک رشته با دقیقاً سه کاراکتر دارای دو کاراکتر یکسان است یا خیر.\n\nپارامترها:\n- str (string): رشته‌ای با سه کاراکتر که باید بررسی شود.\n\nبازگشتی:\n- string: اگر ورودی دقیقاً دو کاراکتر برابر داشته باشد، 'Yes' برمی‌گرداند، در غیر این صورت 'No'.\n\nمثال‌ها:\n f_30('112') // 'Yes'\n f_30('123') // 'No'"}}
{"task_id": "JavaScript/31", "prompt": {"en": "/**\n * Given a string consisting of lowercase English letters, you can change one character to another\n * in each round. This function calculates the minimum number of rounds needed to make the string\n * composed of the same character.\n * @param {string} s - The input string.\n * @returns {number} The minimum number of rounds to make all characters in the string the same.\n *\n * Examples:\n * f_31(\"aab\") // returns 1\n * f_31(\"abc\") // returns 2\n * f_31(\"aaa\") // returns 0\n */\nfunction f_31(s)", "sq": "/**\n * Duke pasur një varg që përbëhet nga shkronjat e vogla të anglishtes, ju mund të ndryshoni një karakter në një tjetër\n * në çdo raund. Kjo funksion llogarit numrin minimal të raundeve të nevojshme për ta bërë vargun\n * të përbërë nga i njëjti karakter.\n * @param {string} s - Vargu hyrës.\n * @returns {number} Numri minimal i raundeve për të bërë të gjithë karakteret në varg të njëjta.\n *\n * Shembuj:\n * f_31(\"aab\") // kthen 1\n * f_31(\"abc\") // kthen 2\n * f_31(\"aaa\") // kthen 0\n */\nfunction f_31(s)", "hy": "/**\n * Տրված է փոքրատառ անգլերեն տառերից կազմված տող, դուք կարող եք յուրաքանչյուր փուլում մեկ նիշը փոխել\n * մեկ այլ նիշով։ Այս ֆունկցիան հաշվում է նվազագույն փուլերի քանակը, որը անհրաժեշտ է տողը\n * նույն նիշից կազմված դարձնելու համար։\n * @param {string} s - Մուտքային տողը։\n * @returns {number} Նվազագույն փուլերի քանակը, որպեսզի տողի բոլոր նիշերը դառնան նույնը։\n *\n * Օրինակներ:\n * f_31(\"aab\") // վերադարձնում է 1\n * f_31(\"abc\") // վերադարձնում է 2\n * f_31(\"aaa\") // վերադարձնում է 0\n */\nfunction f_31(s)", "bn": "/**\n * একটি স্ট্রিং দেওয়া হয়েছে যা ছোট হাতের ইংরেজি অক্ষর নিয়ে গঠিত, আপনি প্রতিটি রাউন্ডে একটি অক্ষরকে অন্য অক্ষরে পরিবর্তন করতে পারেন।\n * এই ফাংশনটি স্ট্রিংটিকে একই অক্ষর দিয়ে গঠিত করতে প্রয়োজনীয় সর্বনিম্ন রাউন্ডের সংখ্যা গণনা করে।\n * @param {string} s - ইনপুট স্ট্রিং।\n * @returns {number} স্ট্রিংয়ের সমস্ত অক্ষরকে একই করতে প্রয়োজনীয় সর্বনিম্ন রাউন্ডের সংখ্যা।\n *\n * উদাহরণ:\n * f_31(\"aab\") // 1 প্রদান করে\n * f_31(\"abc\") // 2 প্রদান করে\n * f_31(\"aaa\") // 0 প্রদান করে\n */\nfunction f_31(s)", "bg": "/**\n * Даден е низ, състоящ се от малки английски букви, можете да промените един символ на друг\n * във всеки рунд. Тази функция изчислява минималния брой рундове, необходими за да направите низа\n * съставен от един и същ символ.\n * @param {string} s - Входният низ.\n * @returns {number} Минималният брой рундове, за да направите всички символи в низа еднакви.\n *\n * Примери:\n * f_31(\"aab\") // връща 1\n * f_31(\"abc\") // връща 2\n * f_31(\"aaa\") // връща 0\n */\nfunction f_31(s)", "zh": "/**\n * 给定一个由小写英文字母组成的字符串，你可以在每一轮中将一个字符更改为另一个字符。\n * 该函数计算将字符串变为由相同字符组成所需的最小轮数。\n * @param {string} s - 输入字符串。\n * @returns {number} 将字符串中的所有字符变为相同所需的最小轮数。\n *\n * 示例:\n * f_31(\"aab\") // returns 1\n * f_31(\"abc\") // returns 2\n * f_31(\"aaa\") // returns 0\n */\nfunction f_31(s)", "fr": "/**\n * Étant donné une chaîne composée de lettres minuscules anglaises, vous pouvez changer un caractère en un autre\n * à chaque tour. Cette fonction calcule le nombre minimum de tours nécessaires pour rendre la chaîne\n * composée du même caractère.\n * @param {string} s - La chaîne d'entrée.\n * @returns {number} Le nombre minimum de tours pour que tous les caractères de la chaîne soient identiques.\n *\n * Exemples :\n * f_31(\"aab\") // returns 1\n * f_31(\"abc\") // returns 2\n * f_31(\"aaa\") // returns 0\n */\nfunction f_31(s)", "de": "/**\n * Gegeben ist ein String, der aus Kleinbuchstaben des englischen Alphabets besteht. Sie können in jeder Runde ein Zeichen in ein anderes ändern. Diese Funktion berechnet die minimale Anzahl von Runden, die erforderlich sind, um den String aus demselben Zeichen zusammengesetzt zu machen.\n * @param {string} s - Der Eingabestring.\n * @returns {number} Die minimale Anzahl von Runden, um alle Zeichen im String gleich zu machen.\n *\n * Beispiele:\n * f_31(\"aab\") // returns 1\n * f_31(\"abc\") // returns 2\n * f_31(\"aaa\") // returns 0\n */", "ha": "/**\n * An ba da wata ƙirari mai ƙunshe da ƙananan haruffan Ingilishi, za ka iya canza harafi ɗaya zuwa wani\n * a kowane zagaye. Wannan aikin yana ƙididdige mafi ƙarancin adadin zagaye da ake buƙata don sanya ƙirarin\n * ta ƙunshi harafi iri ɗaya.\n * @param {string} s - Shigar da ƙirari.\n * @returns {number} Mafi ƙarancin adadin zagaye don sanya duk haruffa a cikin ƙirari su zama iri ɗaya.\n *\n * Misalai:\n * f_31(\"aab\") // returns 1\n * f_31(\"abc\") // returns 2\n * f_31(\"aaa\") // returns 0\n */\nfunction f_31(s)", "hi": "/**\n * एक स्ट्रिंग जिसमें छोटे अंग्रेजी अक्षर होते हैं, आप प्रत्येक राउंड में एक वर्ण को दूसरे में बदल सकते हैं।\n * यह फ़ंक्शन गणना करता है कि स्ट्रिंग को एक ही वर्ण से मिलकर बनाने के लिए न्यूनतम कितने राउंड की आवश्यकता है।\n * @param {string} s - इनपुट स्ट्रिंग।\n * @returns {number} स्ट्रिंग के सभी वर्णों को एक जैसा बनाने के लिए न्यूनतम राउंड की संख्या।\n *\n * उदाहरण:\n * f_31(\"aab\") // returns 1\n * f_31(\"abc\") // returns 2\n * f_31(\"aaa\") // returns 0\n */", "hu": "/**\n * Adott egy kisbetűs angol betűkből álló string, minden körben megváltoztathatsz egy karaktert egy másikra.\n * Ez a függvény kiszámítja a minimális körök számát, amely szükséges ahhoz, hogy a string azonos karakterekből álljon.\n * @param {string} s - A bemeneti string.\n * @returns {number} A minimális körök száma, hogy a string összes karaktere azonos legyen.\n *\n * Példák:\n * f_31(\"aab\") // visszaadja 1\n * f_31(\"abc\") // visszaadja 2\n * f_31(\"aaa\") // visszaadja 0\n */\nfunction f_31(s)", "es": "/**\n * Dada una cadena que consiste en letras minúsculas del alfabeto inglés, puedes cambiar un carácter por otro\n * en cada ronda. Esta función calcula el número mínimo de rondas necesarias para hacer que la cadena\n * esté compuesta por el mismo carácter.\n * @param {string} s - La cadena de entrada.\n * @returns {number} El número mínimo de rondas para hacer que todos los caracteres en la cadena sean iguales.\n *\n * Ejemplos:\n * f_31(\"aab\") // devuelve 1\n * f_31(\"abc\") // devuelve 2\n * f_31(\"aaa\") // devuelve 0\n */\nfunction f_31(s)", "arb": "/**\n * بالنظر إلى سلسلة تتكون من حروف إنجليزية صغيرة، يمكنك تغيير حرف واحد إلى آخر\n * في كل جولة. تقوم هذه الدالة بحساب الحد الأدنى لعدد الجولات اللازمة لجعل السلسلة\n * تتكون من نفس الحرف.\n * @param {string} s - السلسلة المدخلة.\n * @returns {number} الحد الأدنى لعدد الجولات لجعل جميع الحروف في السلسلة متشابهة.\n *\n * أمثلة:\n * f_31(\"aab\") // يعيد 1\n * f_31(\"abc\") // يعيد 2\n * f_31(\"aaa\") // يعيد 0\n */\nfunction f_31(s)", "sw": "/**\n * Ukipewa kamba inayojumuisha herufi ndogo za Kiingereza, unaweza kubadilisha herufi moja kuwa nyingine\n * katika kila raundi. Kazi hii inahesabu idadi ndogo zaidi ya raundi zinazohitajika kufanya kamba\n * iwe na herufi sawa.\n * @param {string} s - Kamba ya ingizo.\n * @returns {number} Idadi ndogo zaidi ya raundi za kufanya herufi zote katika kamba ziwe sawa.\n *\n * Mifano:\n * f_31(\"aab\") // inarudisha 1\n * f_31(\"abc\") // inarudisha 2\n * f_31(\"aaa\") // inarudisha 0\n */\nfunction f_31(s)", "tr": "/**\n * Küçük harflerden oluşan bir dize verildiğinde, her turda bir karakteri başka bir karaktere değiştirebilirsiniz.\n * Bu fonksiyon, diziyi aynı karakterden oluşacak şekilde yapmak için gereken minimum tur sayısını hesaplar.\n * @param {string} s - Girdi dizisi.\n * @returns {number} Dizideki tüm karakterleri aynı yapmak için gereken minimum tur sayısı.\n *\n * Örnekler:\n * f_31(\"aab\") // 1 döndürür\n * f_31(\"abc\") // 2 döndürür\n * f_31(\"aaa\") // 0 döndürür\n */\nfunction f_31(s)", "vi": "/**\n * Cho một chuỗi gồm các chữ cái tiếng Anh viết thường, bạn có thể thay đổi một ký tự thành ký tự khác\n * trong mỗi vòng. Hàm này tính toán số vòng tối thiểu cần thiết để làm cho chuỗi\n * được tạo thành từ cùng một ký tự.\n * @param {string} s - Chuỗi đầu vào.\n * @returns {number} Số vòng tối thiểu để làm cho tất cả các ký tự trong chuỗi giống nhau.\n *\n * Ví dụ:\n * f_31(\"aab\") // trả về 1\n * f_31(\"abc\") // trả về 2\n * f_31(\"aaa\") // trả về 0\n */\nfunction f_31(s)", "id": "/**\n * Diberikan sebuah string yang terdiri dari huruf kecil bahasa Inggris, Anda dapat mengubah satu karakter menjadi karakter lain\n * di setiap putaran. Fungsi ini menghitung jumlah putaran minimum yang diperlukan untuk membuat string\n * terdiri dari karakter yang sama.\n * @param {string} s - String masukan.\n * @returns {number} Jumlah putaran minimum untuk membuat semua karakter dalam string menjadi sama.\n *\n * Contoh:\n * f_31(\"aab\") // mengembalikan 1\n * f_31(\"abc\") // mengembalikan 2\n * f_31(\"aaa\") // mengembalikan 0\n */\nfunction f_31(s)", "ja": "/**\n * 小文字の英字からなる文字列が与えられたとき、各ラウンドで1文字を別の文字に変更できます。\n * この関数は、文字列を同じ文字で構成するために必要な最小ラウンド数を計算します。\n * @param {string} s - 入力文字列。\n * @returns {number} 文字列内のすべての文字を同じにするための最小ラウンド数。\n *\n * 例:\n * f_31(\"aab\") // returns 1\n * f_31(\"abc\") // returns 2\n * f_31(\"aaa\") // returns 0\n */\nfunction f_31(s)", "ko": "/**\n * 소문자 영어 문자로 구성된 문자열이 주어졌을 때, 각 라운드마다 하나의 문자를 다른 문자로 변경할 수 있습니다.\n * 이 함수는 문자열을 동일한 문자로 구성하는 데 필요한 최소 라운드 수를 계산합니다.\n * @param {string} s - 입력 문자열.\n * @returns {number} 문자열의 모든 문자를 동일하게 만드는 데 필요한 최소 라운드 수.\n *\n * 예시:\n * f_31(\"aab\") // returns 1\n * f_31(\"abc\") // returns 2\n * f_31(\"aaa\") // returns 0\n */\nfunction f_31(s)", "ml": "/**\n * ചെറിയ അക്ഷരങ്ങളായ ഇംഗ്ലീഷ് അക്ഷരങ്ങൾ അടങ്ങിയ ഒരു സ്ട്രിംഗ് നൽകിയാൽ, ഓരോ റൗണ്ടിലും ഒരു അക്ഷരം മറ്റൊന്നാക്കി മാറ്റാം.\n * സ്ട്രിംഗ് ഒരേ അക്ഷരത്തിൽ നിന്ന് രൂപപ്പെട്ടതാക്കാൻ ആവശ്യമായ കുറഞ്ഞ റൗണ്ടുകളുടെ എണ്ണം ഈ ഫംഗ്ഷൻ കണക്കാക്കുന്നു.\n * @param {string} s - ഇൻപുട്ട് സ്ട്രിംഗ്.\n * @returns {number} സ്ട്രിംഗിലെ എല്ലാ അക്ഷരങ്ങളും ഒരേ ആക്കാൻ ആവശ്യമായ കുറഞ്ഞ റൗണ്ടുകളുടെ എണ്ണം.\n *\n * ഉദാഹരണങ്ങൾ:\n * f_31(\"aab\") // 1 തിരികെ നൽകുന്നു\n * f_31(\"abc\") // 2 തിരികെ നൽകുന്നു\n * f_31(\"aaa\") // 0 തിരികെ നൽകുന്നു\n */\nfunction f_31(s)", "fa": "/**\n * با داشتن یک رشته که شامل حروف کوچک انگلیسی است، می‌توانید در هر دور یک کاراکتر را به کاراکتر دیگری تغییر دهید.\n * این تابع حداقل تعداد دورهایی را که لازم است تا رشته از یک کاراکتر مشابه تشکیل شود را محاسبه می‌کند.\n * @param {string} s - رشته ورودی.\n * @returns {number} حداقل تعداد دورهایی که لازم است تا تمام کاراکترهای رشته مشابه شوند.\n *\n * مثال‌ها:\n * f_31(\"aab\") // برمی‌گرداند 1\n * f_31(\"abc\") // برمی‌گرداند 2\n * f_31(\"aaa\") // برمی‌گرداند 0\n */\nfunction f_31(s)"}, "canonical_solution": "{\n    const charCount = new Array(26).fill(0); // Assuming only lowercase letters\n    for (const char of s) {\n        charCount[char.charCodeAt(0) - 'a'.charCodeAt(0)]++;\n    }\n    let maxCount = 0;\n    for (const count of charCount) {\n        if (count !== 0) {\n            maxCount++;\n        }\n    }\n\n    return maxCount - 1;\n}", "instruction": {"en": "Write a JavaScript function `function f_31(s)` to solve the following problem:\nGiven a string consisting of lowercase English letters, you can change one character to another in each round. This function calculates the minimum number of rounds needed to make the string composed of the same character.\n@param {string} s - The input string.\n@returns {number} The minimum number of rounds to make all characters in the string the same.\n\nExamples:\nf_31(\"aab\") // returns 1\nf_31(\"abc\") // returns 2\nf_31(\"aaa\") // returns 0", "sq": "Shkruani një funksion JavaScript `function f_31(s)` për të zgjidhur problemin në vijim:  \nDuke pasur një varg që përbëhet nga shkronja të vogla të anglishtes, ju mund të ndryshoni një karakter në një tjetër në secilën raund. Ky funksion llogarit numrin minimal të raundeve të nevojshme për ta bërë vargun të përbërë nga i njëjti karakter.  \n@param {string} s - Vargu hyrës.  \n@returns {number} Numri minimal i raundeve për të bërë të gjithë karakteret në varg të njëjta.  \n\nShembuj:  \nf_31(\"aab\") // kthen 1  \nf_31(\"abc\") // kthen 2  \nf_31(\"aaa\") // kthen 0  ", "hy": "Գրեք JavaScript ֆունկցիա `function f_31(s)` հետևյալ խնդիրը լուծելու համար:\nՏրված է փոքրատառ անգլերեն տառերից կազմված տող, դուք կարող եք յուրաքանչյուր փուլում փոխել մեկ նշանը մյուսով: Այս ֆունկցիան հաշվում է նվազագույն փուլերի քանակը, որը անհրաժեշտ է տողը նույն նշանով կազմված դարձնելու համար:\n@param {string} s - Մուտքային տողը:\n@returns {number} Նվազագույն փուլերի քանակը, որպեսզի տողի բոլոր նշանները դառնան նույնը:\n\nՕրինակներ:\nf_31(\"aab\") // վերադարձնում է 1\nf_31(\"abc\") // վերադարձնում է 2\nf_31(\"aaa\") // վերադարձնում է 0", "bn": "একটি জাভাস্ক্রিপ্ট ফাংশন `function f_31(s)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি স্ট্রিং দেওয়া হয়েছে যা ছোট হাতের ইংরেজি অক্ষর নিয়ে গঠিত, আপনি প্রতিটি রাউন্ডে একটি অক্ষরকে অন্য অক্ষরে পরিবর্তন করতে পারেন। এই ফাংশনটি স্ট্রিংটিকে একই অক্ষর দিয়ে গঠিত করতে ন্যূনতম রাউন্ডের সংখ্যা গণনা করে।\n@param {string} s - ইনপুট স্ট্রিং।\n@returns {number} স্ট্রিংয়ের সমস্ত অক্ষরকে একই করতে ন্যূনতম রাউন্ডের সংখ্যা।\n\nউদাহরণ:\nf_31(\"aab\") // 1 রিটার্ন করে\nf_31(\"abc\") // 2 রিটার্ন করে\nf_31(\"aaa\") // 0 রিটার্ন করে", "bg": "Напишете JavaScript функция `function f_31(s)`, за да решите следния проблем:  \nДаден е низ, състоящ се от малки букви на английската азбука, можете да промените един символ на друг във всеки рунд. Тази функция изчислява минималния брой рундове, необходими, за да направите низа съставен от един и същ символ.  \n@param {string} s - Входният низ.  \n@returns {number} Минималният брой рундове, за да се направят всички символи в низа еднакви.  \n\nПримери:  \nf_31(\"aab\") // връща 1  \nf_31(\"abc\") // връща 2  \nf_31(\"aaa\") // връща 0  ", "zh": "编写一个 JavaScript 函数 `function f_31(s)` 来解决以下问题：  \n给定一个由小写英文字母组成的字符串，你可以在每一轮中将一个字符更改为另一个字符。此函数计算将字符串变为由相同字符组成所需的最小轮数。  \n@param {string} s - 输入字符串。  \n@returns {number} 将字符串中的所有字符变为相同所需的最小轮数。  \n\n示例：  \nf_31(\"aab\") // 返回 1  \nf_31(\"abc\") // 返回 2  \nf_31(\"aaa\") // 返回 0  ", "fr": "Écrire une fonction JavaScript `function f_31(s)` pour résoudre le problème suivant :  \nÉtant donné une chaîne composée de lettres minuscules anglaises, vous pouvez changer un caractère en un autre à chaque tour. Cette fonction calcule le nombre minimum de tours nécessaires pour que la chaîne soit composée du même caractère.\n@param {string} s - La chaîne d'entrée.\n@returns {number} Le nombre minimum de tours pour rendre tous les caractères de la chaîne identiques.\n\nExemples :  \nf_31(\"aab\") // retourne 1  \nf_31(\"abc\") // retourne 2  \nf_31(\"aaa\") // retourne 0  ", "de": "Schreiben Sie eine JavaScript-Funktion `function f_31(s)`, um das folgende Problem zu lösen:\nGegeben ist ein String, der aus Kleinbuchstaben des englischen Alphabets besteht. Sie können in jeder Runde ein Zeichen in ein anderes ändern. Diese Funktion berechnet die minimale Anzahl von Runden, die benötigt werden, um den String aus demselben Zeichen zu machen.\n@param {string} s - Der Eingabestring.\n@returns {number} Die minimale Anzahl von Runden, um alle Zeichen im String gleich zu machen.\n\nBeispiele:\nf_31(\"aab\") // gibt 1 zurück\nf_31(\"abc\") // gibt 2 zurück\nf_31(\"aaa\") // gibt 0 zurück", "ha": "Rubuta wani aikin JavaScript `function f_31(s)` don warware matsalar mai zuwa:\nAn ba da wani kirtani mai ƙunshe da ƙananan haruffan Ingilishi, za ka iya canza harafi ɗaya zuwa wani a kowace zagaye. Wannan aikin yana ƙididdige mafi ƙarancin adadin zagaye da ake buƙata don sanya kirtani ya ƙunshi harafi iri ɗaya.\n@param {string} s - Kirtanin shigarwa.\n@returns {number} Mafi ƙarancin adadin zagaye don sanya duk haruffa a cikin kirtani su zama iri ɗaya.\n\nMisalai:\nf_31(\"aab\") // returns 1\nf_31(\"abc\") // returns 2\nf_31(\"aaa\") // returns 0", "hi": "एक जावास्क्रिप्ट फ़ंक्शन `function f_31(s)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए एक स्ट्रिंग में जो छोटे अक्षरों वाले अंग्रेजी अक्षरों से बनी होती है, आप प्रत्येक राउंड में एक अक्षर को दूसरे में बदल सकते हैं। यह फ़ंक्शन न्यूनतम राउंड की संख्या की गणना करता है जो स्ट्रिंग को एक ही अक्षर से बनी बनाने के लिए आवश्यक है।\n@param {string} s - इनपुट स्ट्रिंग।\n@returns {number} न्यूनतम राउंड की संख्या ताकि स्ट्रिंग के सभी अक्षर समान हो जाएं।\n\nउदाहरण:\nf_31(\"aab\") // returns 1\nf_31(\"abc\") // returns 2\nf_31(\"aaa\") // returns 0", "hu": "Írj egy JavaScript függvényt `function f_31(s)` a következő probléma megoldására:\nAdott egy kisbetűs angol betűkből álló karakterlánc, minden körben megváltoztathatsz egy karaktert egy másikra. Ez a függvény kiszámítja a minimális körök számát, amelyek szükségesek ahhoz, hogy a karakterlánc ugyanabból a karakterből álljon.\n@param {string} s - A bemeneti karakterlánc.\n@returns {number} A minimális körök száma, hogy az összes karakter a karakterláncban ugyanaz legyen.\n\nPéldák:\nf_31(\"aab\") // visszaadja 1\nf_31(\"abc\") // visszaadja 2\nf_31(\"aaa\") // visszaadja 0", "es": "Escribe una función de JavaScript `function f_31(s)` para resolver el siguiente problema:\nDada una cadena que consiste en letras minúsculas del alfabeto inglés, puedes cambiar un carácter por otro en cada ronda. Esta función calcula el número mínimo de rondas necesarias para hacer que la cadena esté compuesta por el mismo carácter.\n@param {string} s - La cadena de entrada.\n@returns {number} El número mínimo de rondas para hacer que todos los caracteres en la cadena sean iguales.\n\nEjemplos:\nf_31(\"aab\") // devuelve 1\nf_31(\"abc\") // devuelve 2\nf_31(\"aaa\") // devuelve 0", "arb": "اكتب دالة JavaScript `function f_31(s)` لحل المشكلة التالية:\nبالنظر إلى سلسلة تتكون من أحرف إنجليزية صغيرة، يمكنك تغيير حرف واحد إلى آخر في كل جولة. تقوم هذه الدالة بحساب الحد الأدنى لعدد الجولات اللازمة لجعل السلسلة مكونة من نفس الحرف.\n@param {string} s - سلسلة الإدخال.\n@returns {number} الحد الأدنى لعدد الجولات لجعل جميع الأحرف في السلسلة متشابهة.\n\nأمثلة:\nf_31(\"aab\") // يعيد 1\nf_31(\"abc\") // يعيد 2\nf_31(\"aaa\") // يعيد 0", "sw": "Andika kazi ya JavaScript `function f_31(s)` kutatua tatizo lifuatalo:  \nUkipiwa kamba inayojumuisha herufi ndogo za Kiingereza, unaweza kubadilisha herufi moja kuwa nyingine katika kila raundi. Kazi hii inahesabu idadi ndogo ya raundi zinazohitajika ili kufanya kamba iwe na herufi sawa.  \n@param {string} s - Kamba ya ingizo.  \n@returns {number} Idadi ndogo ya raundi za kufanya herufi zote kwenye kamba ziwe sawa.  \n\nMifano:  \nf_31(\"aab\") // inarudisha 1  \nf_31(\"abc\") // inarudisha 2  \nf_31(\"aaa\") // inarudisha 0  ", "tr": "Bir JavaScript fonksiyonu `function f_31(s)` yazın ve aşağıdaki problemi çözün:\nKüçük harflerden oluşan bir dize verildiğinde, her turda bir karakteri başka bir karakterle değiştirebilirsiniz. Bu fonksiyon, diziyi aynı karakterden oluşacak şekilde yapmak için gereken minimum tur sayısını hesaplar.\n@param {string} s - Girdi dizisi.\n@returns {number} Dizideki tüm karakterleri aynı yapmak için gereken minimum tur sayısı.\n\nÖrnekler:\nf_31(\"aab\") // 1 döndürür\nf_31(\"abc\") // 2 döndürür\nf_31(\"aaa\") // 0 döndürür", "vi": "Viết một hàm JavaScript `function f_31(s)` để giải quyết vấn đề sau:\nCho một chuỗi bao gồm các chữ cái tiếng Anh viết thường, bạn có thể thay đổi một ký tự thành ký tự khác trong mỗi vòng. Hàm này tính toán số vòng tối thiểu cần thiết để làm cho chuỗi được tạo thành từ cùng một ký tự.\n@param {string} s - Chuỗi đầu vào.\n@returns {number} Số vòng tối thiểu để làm cho tất cả các ký tự trong chuỗi giống nhau.\n\nVí dụ:\nf_31(\"aab\") // trả về 1\nf_31(\"abc\") // trả về 2\nf_31(\"aaa\") // trả về 0", "id": "Tulis fungsi JavaScript `function f_31(s)` untuk menyelesaikan masalah berikut:\nDiberikan sebuah string yang terdiri dari huruf kecil bahasa Inggris, Anda dapat mengubah satu karakter menjadi karakter lain di setiap putaran. Fungsi ini menghitung jumlah minimum putaran yang diperlukan untuk membuat string terdiri dari karakter yang sama.\n@param {string} s - String masukan.\n@returns {number} Jumlah minimum putaran untuk membuat semua karakter dalam string menjadi sama.\n\nContoh:\nf_31(\"aab\") // mengembalikan 1\nf_31(\"abc\") // mengembalikan 2\nf_31(\"aaa\") // mengembalikan 0", "ja": "JavaScript関数 `function f_31(s)` を作成して、次の問題を解決してください:\n小文字の英字からなる文字列が与えられたとき、各ラウンドで1つの文字を別の文字に変更できます。この関数は、文字列を同じ文字で構成するために必要な最小ラウンド数を計算します。\n@param {string} s - 入力文字列。\n@returns {number} 文字列内のすべての文字を同じにするために必要な最小ラウンド数。\n\n例:\nf_31(\"aab\") // returns 1\nf_31(\"abc\") // returns 2\nf_31(\"aaa\") // returns 0", "ko": "JavaScript 함수 `function f_31(s)`를 작성하여 다음 문제를 해결하십시오:\n소문자 영어 문자로 구성된 문자열이 주어졌을 때, 각 라운드에서 하나의 문자를 다른 문자로 변경할 수 있습니다. 이 함수는 문자열을 동일한 문자로 구성하는 데 필요한 최소 라운드 수를 계산합니다.\n@param {string} s - 입력 문자열.\n@returns {number} 문자열의 모든 문자를 동일하게 만드는 데 필요한 최소 라운드 수.\n\n예시:\nf_31(\"aab\") // 1 반환\nf_31(\"abc\") // 2 반환\nf_31(\"aaa\") // 0 반환", "ml": "`function f_31(s)` എന്ന ജാവാസ്ക്രിപ്റ്റ് ഫങ്ഷൻ എഴുതുക താഴെക്കൊടുത്തിരിക്കുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nചെറിയ ഇംഗ്ലീഷ് അക്ഷരങ്ങൾ ഉൾക്കൊള്ളുന്ന ഒരു സ്ട്രിംഗ് നൽകിയിരിക്കുന്നു, ഓരോ റൗണ്ടിലും ഒരു പ്രതീകം മറ്റൊന്നായി മാറ്റാൻ നിങ്ങൾക്ക് കഴിയും. സ്ട്രിംഗ് ഒരേ പ്രതീകം കൊണ്ട് നിർമ്മിക്കാൻ ആവശ്യമായ ഏറ്റവും കുറഞ്ഞ റൗണ്ടുകളുടെ എണ്ണം ഈ ഫങ്ഷൻ കണക്കാക്കുന്നു.\n@param {string} s - ഇൻപുട്ട് സ്ട്രിംഗ്.\n@returns {number} സ്ട്രിംഗിലെ എല്ലാ പ്രതീകങ്ങളും ഒരേ ആകാൻ വേണ്ട ഏറ്റവും കുറഞ്ഞ റൗണ്ടുകളുടെ എണ്ണം.\n\nഉദാഹരണങ്ങൾ:\nf_31(\"aab\") // 1 തിരികെ നൽകുന്നു\nf_31(\"abc\") // 2 തിരികെ നൽകുന്നു\nf_31(\"aaa\") // 0 തിരികെ നൽകുന്നു", "fa": "یک تابع جاوااسکریپت `function f_31(s)` بنویسید تا مسئله زیر را حل کند:\nبا توجه به یک رشته که شامل حروف کوچک انگلیسی است، شما می‌توانید در هر دور یک کاراکتر را به کاراکتر دیگری تغییر دهید. این تابع حداقل تعداد دورهایی که لازم است تا رشته از کاراکترهای یکسان تشکیل شود را محاسبه می‌کند.\n@param {string} s - رشته ورودی.\n@returns {number} حداقل تعداد دورهایی که لازم است تا همه کاراکترهای رشته یکسان شوند.\n\nمثال‌ها:\nf_31(\"aab\") // برمی‌گرداند 1\nf_31(\"abc\") // برمی‌گرداند 2\nf_31(\"aaa\") // برمی‌گرداند 0"}, "level": "middle", "test": "const testf_31 = () => {\n    console.assert(f_31(\"aab\") === 1, \"Expected 1 round for 'aab'\");\n    console.assert(f_31(\"abc\") === 2, \"Expected 2 rounds for 'abc'\");\n    console.assert(f_31(\"aaa\") === 0, \"Expected 0 rounds for 'aaa'\");\n    console.assert(f_31(\"abab\") === 1, \"Expected 1 round for 'abab'\");\n    console.assert(f_31(\"zzzzz\") === 0, \"Expected 0 rounds for 'zzzzz'\");\n};\n\ntestf_31();", "entry_point": "f_31", "signature": "function f_31(s)", "docstring": {"en": "Given a string consisting of lowercase English letters, you can change one character to another in each round. This function calculates the minimum number of rounds needed to make the string composed of the same character.\n@param {string} s - The input string.\n@returns {number} The minimum number of rounds to make all characters in the string the same.\n\nExamples:\nf_31(\"aab\") // returns 1\nf_31(\"abc\") // returns 2\nf_31(\"aaa\") // returns 0", "sq": "Duke pasur një varg që përbëhet nga shkronja të vogla të anglishtes, ju mund të ndryshoni një karakter në një tjetër në çdo raund. Kjo funksion llogarit numrin minimal të raundeve të nevojshme për ta bërë vargun të përbërë nga i njëjti karakter.\n@param {string} s - Vargu hyrës.\n@returns {number} Numri minimal i raundeve për t'i bërë të gjithë karakteret në varg të njëjtë.\n\nShembuj:\nf_31(\"aab\") // kthen 1\nf_31(\"abc\") // kthen 2\nf_31(\"aaa\") // kthen 0", "hy": "Տրված է փոքրատառ անգլերեն տառերից կազմված տող, դուք կարող եք յուրաքանչյուր փուլում փոխել մեկ նշանը մյուսով: Այս ֆունկցիան հաշվում է նվազագույն փուլերի քանակը, որը անհրաժեշտ է տողը նույն նշանով կազմված դարձնելու համար:\n@param {string} s - Մուտքային տողը:\n@returns {number} Նվազագույն ռաունդների քանակը, որպեսզի տողի բոլոր նիշերը դառնան նույնը:\n\nՕրինակներ:\nf_31(\"aab\") // վերադարձնում է 1\nf_31(\"abc\") // վերադարձնում է 2\nf_31(\"aaa\") // վերադարձնում է 0", "bn": "একটি স্ট্রিং দেওয়া হয়েছে যা ছোট হাতের ইংরেজি অক্ষর নিয়ে গঠিত, আপনি প্রতিটি রাউন্ডে একটি অক্ষরকে অন্য অক্ষরে পরিবর্তন করতে পারেন। এই ফাংশনটি স্ট্রিংটিকে একই অক্ষর দিয়ে গঠিত করতে ন্যূনতম রাউন্ডের সংখ্যা গণনা করে।\n@param {string} s - ইনপুট স্ট্রিং।\n@returns {number} স্ট্রিংয়ের সমস্ত অক্ষর একই করতে ন্যূনতম রাউন্ড সংখ্যা।\n\nউদাহরণ:\nf_31(\"aab\") // 1 রিটার্ন করে\nf_31(\"abc\") // 2 রিটার্ন করে\nf_31(\"aaa\") // 0 রিটার্ন করে", "bg": "Даден е низ, състоящ се от малки английски букви, можете да промените един символ на друг във всеки кръг. Тази функция изчислява минималния брой кръгове, необходими, за да направите низа съставен от един и същ символ.\n@param {string} s - Входният низ.\n@returns {number} Минималният брой кръгове, за да направите всички символи в низа еднакви.\n\nПримери:\nf_31(\"aab\") // връща 1\nf_31(\"abc\") // връща 2\nf_31(\"aaa\") // връща 0", "zh": "给定一个由小写英文字母组成的字符串，你可以在每一轮中将一个字符更改为另一个字符。此函数计算使字符串由相同字符组成所需的最小轮数。\n@param {string} s - 输入字符串。\n@returns {number} 使字符串中的所有字符相同所需的最小轮数。\n示例：\nf_31(\"aab\") // 返回 1\nf_31(\"abc\") // 返回 2\nf_31(\"aaa\") // 返回 0", "fr": "Étant donné une chaîne composée de lettres minuscules anglaises, vous pouvez changer un caractère en un autre à chaque tour. Cette fonction calcule le nombre minimum de tours nécessaires pour que la chaîne soit composée du même caractère.\n@param {string} s - La chaîne d'entrée.\n@returns {number} Le nombre minimum de tours pour rendre tous les caractères de la chaîne identiques.\n\nExemples :\nf_31(\"aab\") // retourne 1\nf_31(\"abc\") // retourne 2\nf_31(\"aaa\") // retourne 0", "de": "Gegeben ist ein String, der aus Kleinbuchstaben des englischen Alphabets besteht. Sie können in jeder Runde ein Zeichen in ein anderes ändern. Diese Funktion berechnet die minimale Anzahl von Runden, die benötigt werden, um den String aus demselben Zeichen zu machen.\n\n@param {string} s - Der Eingabestring.\n@returns {number} Die minimale Anzahl von Runden, um alle Zeichen im String gleich zu machen.\n\nBeispiele:\nf_31(\"aab\") // gibt 1 zurück\nf_31(\"abc\") // gibt 2 zurück\nf_31(\"aaa\") // gibt 0 zurück", "ha": "An ba da wani kirtani mai ƙunshe da ƙananan haruffan Ingilishi, za ka iya canza harafi ɗaya zuwa wani a kowace zagaye. Wannan aikin yana ƙididdige mafi ƙarancin adadin zagaye da ake buƙata don sanya kirtani ya ƙunshi harafi iri ɗaya.\n@param {string} s - Kirtani mai shigarwa.  \n@returns {number} Mafi ƙarancin adadin zagaye don sanya duk haruffa a cikin kirtani iri ɗaya.  \n\nMisalai:  \nf_31(\"aab\") // returns 1  \nf_31(\"abc\") // returns 2  \nf_31(\"aaa\") // returns 0  ", "hi": "दिए गए एक स्ट्रिंग में जो छोटे अक्षरों वाले अंग्रेजी अक्षरों से बनी होती है, आप प्रत्येक राउंड में एक अक्षर को दूसरे में बदल सकते हैं। यह फ़ंक्शन न्यूनतम राउंड की संख्या की गणना करता है जो स्ट्रिंग को एक ही अक्षर से बनी बनाने के लिए आवश्यक है।\n@param {string} s - इनपुट स्ट्रिंग।\n\n@returns {number} स्ट्रिंग के सभी अक्षरों को समान बनाने के लिए न्यूनतम राउंड की संख्या।\n\nउदाहरण:\nf_31(\"aab\") // 1 लौटाता है\nf_31(\"abc\") // 2 लौटाता है\nf_31(\"aaa\") // 0 लौटाता है", "hu": "Adott egy kisbetűs angol betűkből álló karakterlánc, amelyben minden körben megváltoztathat egy karaktert egy másikra. Ez a függvény kiszámítja a minimális körök számát, amely szükséges ahhoz, hogy a karakterlánc ugyanabból a karakterből álljon.\n@param {string} s - A bemeneti karakterlánc.\n@returns {number} A minimális körök száma, hogy a karakterlánc összes karaktere ugyanaz legyen.\n\nPéldák:\nf_31(\"aab\") // visszaadja 1\nf_31(\"abc\") // visszaadja 2\nf_31(\"aaa\") // visszaadja 0", "es": "Dada una cadena compuesta por letras minúsculas del alfabeto inglés, puedes cambiar un carácter por otro en cada ronda. Esta función calcula el número mínimo de rondas necesarias para hacer que la cadena esté compuesta por el mismo carácter.\n@param {string} s - La cadena de entrada.\n@returns {number} El número mínimo de rondas para hacer que todos los caracteres en la cadena sean iguales.\n\nEjemplos:\nf_31(\"aab\") // devuelve 1\nf_31(\"abc\") // devuelve 2\nf_31(\"aaa\") // devuelve 0", "arb": "نظرًا لسلسلة تتكون من حروف إنجليزية صغيرة، يمكنك تغيير حرف واحد إلى آخر في كل جولة. تقوم هذه الدالة بحساب الحد الأدنى لعدد الجولات اللازمة لجعل السلسلة تتكون من نفس الحرف.\n@param {string} s - السلسلة المدخلة.\n@returns {number} الحد الأدنى لعدد الجولات لجعل جميع الحروف في السلسلة متشابهة.\n\nأمثلة:\nf_31(\"aab\") // يعيد 1\nf_31(\"abc\") // يعيد 2\nf_31(\"aaa\") // يعيد 0", "sw": "Ukipiwa kamba inayojumuisha herufi ndogo za Kiingereza, unaweza kubadilisha herufi moja kuwa nyingine katika kila raundi. Kazi hii inahesabu idadi ndogo ya raundi zinazohitajika ili kufanya kamba iwe na herufi sawa. \n\n@param {string} s - Uzi wa ingizo.\n\n@returns {number} Idadi ndogo ya raundi za kufanya herufi zote kwenye uzi kuwa sawa.\n\nMifano:\nf_31(\"aab\") // inarudisha 1\nf_31(\"abc\") // inarudisha 2\nf_31(\"aaa\") // inarudisha 0", "tr": "Küçük harflerden oluşan bir dize verildiğinde, her turda bir karakteri başka bir karakterle değiştirebilirsiniz. Bu fonksiyon, diziyi aynı karakterden oluşacak şekilde yapmak için gereken minimum tur sayısını hesaplar.\n@param {string} s - Girdi stringi.\n@returns {number} Stringdeki tüm karakterleri aynı yapmak için gereken minimum tur sayısı.\n\nÖrnekler:\nf_31(\"aab\") // 1 döndürür\nf_31(\"abc\") // 2 döndürür\nf_31(\"aaa\") // 0 döndürür", "vi": "Cho một chuỗi bao gồm các chữ cái tiếng Anh viết thường, bạn có thể thay đổi một ký tự thành ký tự khác trong mỗi vòng. Hàm này tính toán số vòng tối thiểu cần thiết để làm cho chuỗi được tạo thành từ cùng một ký tự.\n\n@param {string} s - Chuỗi đầu vào.\n\n@returns {number} Số vòng tối thiểu để làm cho tất cả các ký tự trong chuỗi giống nhau.\n\nVí dụ:\nf_31(\"aab\") // trả về 1\nf_31(\"abc\") // trả về 2\nf_31(\"aaa\") // trả về 0", "id": "Diberikan sebuah string yang terdiri dari huruf kecil bahasa Inggris, Anda dapat mengubah satu karakter menjadi karakter lain di setiap putaran. Fungsi ini menghitung jumlah minimum putaran yang diperlukan untuk membuat string terdiri dari karakter yang sama.\n@param {string} s - String masukan.\n@returns {number} Jumlah minimum putaran untuk membuat semua karakter dalam string menjadi sama.\n\nContoh:\nf_31(\"aab\") // mengembalikan 1\nf_31(\"abc\") // mengembalikan 2\nf_31(\"aaa\") // mengembalikan 0", "ja": "小文字の英字からなる文字列が与えられたとき、各ラウンドで1文字を別の文字に変更できます。\n * この関数は、文字列を同じ文字で構成するために必要な最小ラウンド数を計算します。\n@param {string} s - 入力文字列。\n@returns {number} 文字列内のすべての文字を同じにするために必要な最小ラウンド数。\n\n例:\nf_31(\"aab\") // returns 1\nf_31(\"abc\") // returns 2\nf_31(\"aaa\") // returns 0", "ko": "주어진 문자열이 소문자 영어 문자로 구성되어 있을 때, 각 라운드마다 하나의 문자를 다른 문자로 변경할 수 있습니다. 이 함수는 문자열을 동일한 문자로 구성되도록 만드는 데 필요한 최소 라운드 수를 계산합니다.\n@param {string} s - 입력 문자열.\n@returns {number} 문자열의 모든 문자를 동일하게 만드는 데 필요한 최소 라운드 수.\n\n예시:\nf_31(\"aab\") // returns 1\nf_31(\"abc\") // returns 2\nf_31(\"aaa\") // returns 0", "ml": "ചെറിയ അക്ഷരങ്ങളായ ഇംഗ്ലീഷ് അക്ഷരങ്ങൾ അടങ്ങിയ ഒരു സ്ട്രിംഗ് നൽകിയാൽ, ഓരോ റൗണ്ടിലും ഒരു അക്ഷരം മറ്റൊന്നാക്കി മാറ്റാം.\n * സ്ട്രിംഗ് ഒരേ അക്ഷരത്തിൽ നിന്ന് രൂപപ്പെട്ടതാക്കാൻ ആവശ്യമായ കുറഞ്ഞ റൗണ്ടുകളുടെ എണ്ണം ഈ ഫംഗ്ഷൻ കണക്കാക്കുന്നു.\n\n@param {string} s - ഇൻപുട്ട് സ്ട്രിംഗ്.\n\n@returns {number} സ്ട്രിംഗിലെ എല്ലാ അക്ഷരങ്ങളും ഒരേപോലെയാക്കാൻ വേണ്ട കുറഞ്ഞ റൗണ്ടുകളുടെ എണ്ണം.\n\nExamples:\nf_31(\"aab\") // returns 1\nf_31(\"abc\") // returns 2\nf_31(\"aaa\") // returns 0", "fa": "با داشتن یک رشته که شامل حروف کوچک انگلیسی است، می‌توانید در هر دور یک کاراکتر را به کاراکتر دیگری تغییر دهید.\n * این تابع حداقل تعداد دورهایی را که لازم است تا رشته از یک کاراکتر مشابه تشکیل شود را محاسبه می‌کند.\n\n@param {string} s - رشته ورودی.\n@returns {number} حداقل تعداد دورهایی که لازم است تا تمام کاراکترهای رشته یکسان شوند.\n\nExamples:\nf_31(\"aab\") // returns 1\nf_31(\"abc\") // returns 2\nf_31(\"aaa\") // returns 0"}}
{"task_id": "JavaScript/32", "prompt": {"en": "/**\n * Calculates the year Y_n when the n-th event occurs, considering that each\n * event has a periodicity of a_i years. The countdown for event i+1 starts\n * the year after event i occurs.\n * @param {number} n - the total number of events\n * @param {number[]} signs - an array representing the periodicities of the events\n * @returns {number} The year when the n-th event occurs\n * \n * Example:\n * f_32(6, [3,2,4,5,9,18])\n * // returns 36\n */\nfunction f_32(n, signs)", "sq": "/**\n * Llogarit vitin Y_n kur ndodh ngjarja e n-të, duke marrë parasysh që çdo\n * ngjarje ka një periodikë prej a_i vitesh. Numërimi mbrapsht për ngjarjen i+1 fillon\n * vitin pas ngjarjes i.\n * @param {number} n - numri total i ngjarjeve\n * @param {number[]} signs - një varg që përfaqëson periodikët e ngjarjeve\n * @returns {number} Viti kur ndodh ngjarja e n-të\n * \n * Shembull:\n * f_32(6, [3,2,4,5,9,18])\n * // kthen 36\n */", "hy": "/**\n * Հաշվում է Y_n տարին, երբ տեղի է ունենում n-րդ իրադարձությունը, հաշվի առնելով, որ \n * յուրաքանչյուր իրադարձություն ունի a_i տարիների պարբերականություն։ i+1 իրադարձության \n * հետհաշվարկը սկսվում է i իրադարձության տեղի ունենալուց հետո։\n * @param {number} n - իրադարձությունների ընդհանուր քանակը\n * @param {number[]} signs - զանգված, որը ներկայացնում է իրադարձությունների պարբերականությունները\n * @returns {number} Տարին, երբ տեղի է ունենում n-րդ իրադարձությունը\n * \n * Օրինակ:\n * f_32(6, [3,2,4,5,9,18])\n * // վերադարձնում է 36\n */\nfunction f_32(n, signs)", "bn": "/**\n * গণনা করে Y_n বছর যখন n-তম ঘটনা ঘটে, বিবেচনা করে যে প্রতিটি\n * ঘটনার একটি a_i বছরের পর্যায়কাল রয়েছে। ঘটনা i+1 এর জন্য গণনা শুরু হয়\n * ঘটনা i ঘটার পরের বছর থেকে।\n * @param {number} n - মোট ঘটনার সংখ্যা\n * @param {number[]} signs - ঘটনাগুলির পর্যায়কাল প্রতিনিধিত্বকারী একটি অ্যারে\n * @returns {number} বছর যখন n-তম ঘটনা ঘটে\n * \n * উদাহরণ:\n * f_32(6, [3,2,4,5,9,18])\n * // 36 ফেরত দেয়\n */\nfunction f_32(n, signs)", "bg": "/**\n * Изчислява годината Y_n, когато се случва n-тото събитие, като се има предвид, че всяко\n * събитие има периодичност от a_i години. Обратното броене за събитие i+1 започва\n * годината след като се случи събитие i.\n * @param {number} n - общият брой на събитията\n * @param {number[]} signs - масив, представляващ периодичностите на събитията\n * @returns {number} Годината, когато се случва n-тото събитие\n * \n * Пример:\n * f_32(6, [3,2,4,5,9,18])\n * // връща 36\n */\nfunction f_32(n, signs)", "zh": "/**\n * 计算第 n 个事件发生的年份 Y_n，考虑到每个事件的周期性为 a_i 年。事件 i+1 的倒计时从事件 i 发生后的下一年开始。\n * @param {number} n - 事件的总数\n * @param {number[]} signs - 一个表示事件周期性的数组\n * @returns {number} 第 n 个事件发生的年份\n * \n * 示例:\n * f_32(6, [3,2,4,5,9,18])\n * // 返回 36\n */\nfunction f_32(n, signs)", "fr": "/**\n * Calcule l'année Y_n lorsque le n-ième événement se produit, en considérant que chaque\n * événement a une périodicité de a_i années. Le compte à rebours pour l'événement i+1 commence\n * l'année après que l'événement i se produit.\n * @param {number} n - le nombre total d'événements\n * @param {number[]} signs - un tableau représentant les périodicités des événements\n * @returns {number} L'année où le n-ième événement se produit\n * \n * Exemple:\n * f_32(6, [3,2,4,5,9,18])\n * // returns 36\n */\nfunction f_32(n, signs)", "de": "/**\n * Berechnet das Jahr Y_n, in dem das n-te Ereignis eintritt, wobei jedes\n * Ereignis eine Periodizität von a_i Jahren hat. Der Countdown für Ereignis i+1 beginnt\n * im Jahr nach dem Eintreten von Ereignis i.\n * @param {number} n - die Gesamtanzahl der Ereignisse\n * @param {number[]} signs - ein Array, das die Periodizitäten der Ereignisse darstellt\n * @returns {number} Das Jahr, in dem das n-te Ereignis eintritt\n * \n * Beispiel:\n * f_32(6, [3,2,4,5,9,18])\n * // gibt 36 zurück\n */\nfunction f_32(n, signs)", "ha": "/**\n * Yana ƙididdige shekarar Y_n lokacin da taron na n-ya faru, la'akari da cewa kowanne\n * taron yana da tsawon lokaci na a_i shekaru. Kirga don taron i+1 yana farawa\n * shekarar bayan taron i ya faru.\n * @param {number} n - jimillar adadin abubuwan da suka faru\n * @param {number[]} signs - jerin lambobi da ke wakiltar tsawon lokaci na abubuwan da suka faru\n * @returns {number} Shekarar da taron na n-ya faru\n * \n * Misali:\n * f_32(6, [3,2,4,5,9,18])\n * // yana dawowa 36\n */\nfunction f_32(n, signs)", "hi": "/**\n * गणना करता है वर्ष Y_n जब n-वां घटना होती है, यह मानते हुए कि प्रत्येक\n * घटना की आवृत्ति a_i वर्षों की है। घटना i+1 की उलटी गिनती\n * घटना i के होने के अगले वर्ष से शुरू होती है।\n * @param {number} n - कुल घटनाओं की संख्या\n * @param {number[]} signs - घटनाओं की आवृत्तियों का प्रतिनिधित्व करने वाला एक array\n * @returns {number} वह वर्ष जब n-वां घटना होती है\n * \n * उदाहरण:\n * f_32(6, [3,2,4,5,9,18])\n * // 36 लौटाता है\n */\nfunction f_32(n, signs)", "hu": "/**\n * Kiszámítja az Y_n évet, amikor az n-edik esemény bekövetkezik, figyelembe véve, hogy minden\n * esemény a_i éves periódussal rendelkezik. Az i+1 esemény visszaszámlálása\n * az i esemény bekövetkezése utáni évben kezdődik.\n * @param {number} n - az események teljes száma\n * @param {number[]} signs - egy tömb, amely az események periódusait reprezentálja\n * @returns {number} Az év, amikor az n-edik esemény bekövetkezik\n * \n * Példa:\n * f_32(6, [3,2,4,5,9,18])\n * // visszaadja: 36\n */\nfunction f_32(n, signs)", "es": "/**\n * Calcula el año Y_n cuando ocurre el evento n-ésimo, considerando que cada\n * evento tiene una periodicidad de a_i años. La cuenta regresiva para el evento i+1 comienza\n * el año después de que ocurre el evento i.\n * @param {number} n - el número total de eventos\n * @param {number[]} signs - un arreglo que representa las periodicidades de los eventos\n * @returns {number} El año en que ocurre el evento n-ésimo\n * \n * Ejemplo:\n * f_32(6, [3,2,4,5,9,18])\n * // devuelve 36\n */\nfunction f_32(n, signs)", "arb": "/**\n * يحسب السنة Y_n عندما يحدث الحدث رقم n، مع الأخذ في الاعتبار أن كل\n * حدث له دورية a_i سنوات. يبدأ العد التنازلي للحدث i+1\n * في السنة التي تلي حدوث الحدث i.\n * @param {number} n - العدد الإجمالي للأحداث\n * @param {number[]} signs - مصفوفة تمثل دوريات الأحداث\n * @returns {number} السنة التي يحدث فيها الحدث رقم n\n * \n * مثال:\n * f_32(6, [3,2,4,5,9,18])\n * // يعيد 36\n */\nfunction f_32(n, signs)", "sw": "/**\n * Inahesabu mwaka Y_n wakati tukio la n linapotokea, ikizingatia kwamba kila\n * tukio lina kipindi cha miaka a_i. Hesabu ya nyuma kwa tukio i+1 huanza\n * mwaka baada ya tukio i kutokea.\n * @param {number} n - jumla ya idadi ya matukio\n * @param {number[]} signs - safu inayowakilisha vipindi vya matukio\n * @returns {number} Mwaka ambapo tukio la n linatokea\n * \n * Mfano:\n * f_32(6, [3,2,4,5,9,18])\n * // inarudisha 36\n */\nfunction f_32(n, signs)", "tr": "/**\n * Her bir olayın a_i yıl periyoduna sahip olduğunu göz önünde bulundurarak, n-inci olayın gerçekleştiği Y_n yılını hesaplar. \n * i+1 olayının geri sayımı, i olayı gerçekleştiği yılın ardından başlar.\n * @param {number} n - toplam olay sayısı\n * @param {number[]} signs - olayların periyotlarını temsil eden bir dizi\n * @returns {number} n-inci olayın gerçekleştiği yıl\n * \n * Örnek:\n * f_32(6, [3,2,4,5,9,18])\n * // 36 döndürür\n */\nfunction f_32(n, signs)", "vi": "/**\n * Tính toán năm Y_n khi sự kiện thứ n xảy ra, với giả định rằng mỗi\n * sự kiện có chu kỳ a_i năm. Đếm ngược cho sự kiện i+1 bắt đầu\n * vào năm sau khi sự kiện i xảy ra.\n * @param {number} n - tổng số sự kiện\n * @param {number[]} signs - một mảng đại diện cho chu kỳ của các sự kiện\n * @returns {number} Năm khi sự kiện thứ n xảy ra\n * \n * Ví dụ:\n * f_32(6, [3,2,4,5,9,18])\n * // trả về 36\n */\nfunction f_32(n, signs)", "id": "/**\n * Menghitung tahun Y_n ketika peristiwa ke-n terjadi, dengan mempertimbangkan bahwa setiap\n * peristiwa memiliki periodisitas a_i tahun. Hitungan mundur untuk peristiwa i+1 dimulai\n * tahun setelah peristiwa i terjadi.\n * @param {number} n - total jumlah peristiwa\n * @param {number[]} signs - sebuah array yang mewakili periodisitas dari peristiwa-peristiwa\n * @returns {number} Tahun ketika peristiwa ke-n terjadi\n * \n * Contoh:\n * f_32(6, [3,2,4,5,9,18])\n * // mengembalikan 36\n */\nfunction f_32(n, signs)", "ja": "/**\n * 各イベントがa_i年の周期性を持つことを考慮して、n番目のイベントが発生する年Y_nを計算します。\n * イベントi+1のカウントダウンは、イベントiが発生した翌年から始まります。\n * @param {number} n - イベントの総数\n * @param {number[]} signs - イベントの周期性を表す配列\n * @returns {number} n番目のイベントが発生する年\n * \n * 例:\n * f_32(6, [3,2,4,5,9,18])\n * // returns 36\n */\nfunction f_32(n, signs)", "ko": "/**\n * n번째 이벤트가 발생하는 연도 Y_n을 계산합니다. 각 이벤트는 a_i년의 주기를 가지고 있습니다.\n * 이벤트 i+1의 카운트다운은 이벤트 i가 발생한 다음 해부터 시작됩니다.\n * @param {number} n - 총 이벤트 수\n * @param {number[]} signs - 이벤트의 주기를 나타내는 배열\n * @returns {number} n번째 이벤트가 발생하는 연도\n * \n * 예시:\n * f_32(6, [3,2,4,5,9,18])\n * // returns 36\n */\nfunction f_32(n, signs)", "ml": "/**\n * ഓരോ സംഭവത്തിനും a_i വർഷങ്ങളുടെ കാലയളവുള്ള ഒരു ആവർത്തിത്വം ഉണ്ടെന്ന് കണക്കാക്കുമ്പോൾ n-ആം സംഭവം നടക്കുമ്പോഴുള്ള Y_n വർഷം കണക്കാക്കുന്നു. \n * സംഭവം i+1 ന്റെ കൗണ്ട്ഡൗൺ സംഭവം i നടക്കുന്നതിന് ശേഷം വർഷം ആരംഭിക്കുന്നു.\n * @param {number} n - സംഭവങ്ങളുടെ മൊത്തം എണ്ണം\n * @param {number[]} signs - സംഭവങ്ങളുടെ ആവർത്തിത്വങ്ങളെ പ്രതിനിധീകരിക്കുന്ന ഒരു നിര\n * @returns {number} n-ആം സംഭവം നടക്കുമ്പോഴുള്ള വർഷം\n * \n * ഉദാഹരണം:\n * f_32(6, [3,2,4,5,9,18])\n * // 36 തിരികെ നൽകുന്നു\n */\nfunction f_32(n, signs)", "fa": "/**\n * محاسبه می‌کند سال Y_n که رویداد n-ام رخ می‌دهد، با در نظر گرفتن اینکه هر\n * رویداد دارای دوره تناوب a_i سال است. شمارش معکوس برای رویداد i+1 از\n * سال بعد از وقوع رویداد i شروع می‌شود.\n * @param {number} n - تعداد کل رویدادها\n * @param {number[]} signs - آرایه‌ای که دوره تناوب رویدادها را نشان می‌دهد\n * @returns {number} سالی که رویداد n-ام رخ می‌دهد\n * \n * مثال:\n * f_32(6, [3,2,4,5,9,18])\n * // برمی‌گرداند 36\n */\nfunction f_32(n, signs)"}, "canonical_solution": "{\n    let year = 0;\n    for (let i = 0; i < n; ++i) {\n        let period = signs[i];\n        let nextOccurrence = Math.floor(year / period + 1) * period;\n        year = nextOccurrence;\n    }\n    return year;\n}", "instruction": {"en": "Write a JavaScript function `function f_32(n, signs)` to solve the following problem:\nCalculates the year Y_n when the n-th event occurs, considering that each event has a periodicity of a_i years. The countdown for event i+1 starts the year after event i occurs.\nParameters:\n- n (number): The total number of events\n- signs (number[]): An array representing the periodicities of the events\nReturns:\n- number: The year when the n-th event occurs\n\nExample:\nf_32(6, [3,2,4,5,9,18])\n// returns 36", "sq": "Shkruani një funksion JavaScript `function f_32(n, signs)` për të zgjidhur problemin në vijim:  \nLlogarit vitin Y_n kur ndodh ngjarja e n-të, duke marrë parasysh që secila ngjarje ka një periodicitet prej a_i vitesh. Numërimi mbrapsht për ngjarjen i+1 fillon vitin pas ngjarjes i që ndodh.  \nParametrat:  \n- n (numër): Numri total i ngjarjeve  \n- signs (numër[]): Një varg që përfaqëson periodicitetet e ngjarjeve  \nKthen:  \n- numër: Viti kur ndodh ngjarja e n-të  \n\nShembull:  \nf_32(6, [3,2,4,5,9,18])  \n// kthen 36", "hy": "Գրեք JavaScript ֆունկցիա `function f_32(n, signs)`՝ հետևյալ խնդիրը լուծելու համար:\nՀաշվում է Y_n տարին, երբ տեղի է ունենում n-րդ իրադարձությունը, հաշվի առնելով, որ յուրաքանչյուր իրադարձություն ունի a_i տարիների պարբերականություն։ Իրադարձություն i+1-ի համար հետհաշվարկը սկսվում է իրադարձություն i-ի տեղի ունենալուց հետո։\nՊարամետրեր՝\n- n (թիվ): Իրադարձությունների ընդհանուր քանակը\n- signs (թիվ[]): Զանգված, որը ներկայացնում է իրադարձությունների պարբերականությունները\nՎերադարձնում է՝\n- թիվ: Տարին, երբ տեղի է ունենում n-րդ իրադարձությունը\n\nՕրինակ:\nf_32(6, [3,2,4,5,9,18])\n// վերադարձնում է 36", "bn": "একটি জাভাস্ক্রিপ্ট ফাংশন `function f_32(n, signs)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nহিসাব করে n-তম ঘটনাটি যে বছর Y_n-এ ঘটে, বিবেচনা করে যে প্রতিটি ঘটনার একটি a_i বছর পরপর পুনরাবৃত্তি হয়। ঘটনা i+1 এর জন্য কাউন্টডাউন শুরু হয় ঘটনা i ঘটার পরের বছর থেকে।\nপ্যারামিটারসমূহ:\n- n (সংখ্যা): মোট ঘটনার সংখ্যা\n- signs (number[]): ঘটনাগুলির পুনরাবৃত্তির সময়কাল নির্দেশ করে এমন একটি অ্যারে\nফেরত দেয়:\n- সংখ্যা: যে বছর n-তম ঘটনা ঘটে\n\nউদাহরণ:\nf_32(6, [3,2,4,5,9,18])\n// 36 ফেরত দেয়", "bg": "Напишете JavaScript функция `function f_32(n, signs)`, за да решите следния проблем:\nИзчислява годината Y_n, когато се случва n-тото събитие, като се има предвид, че всяко събитие има периодичност от a_i години. Обратното броене за събитие i+1 започва годината след като събитие i се случи.\nПараметри:\n- n (number): Общият брой на събитията\n- signs (number[]): Масив, представляващ периодичностите на събитията\nВръща:\n- number: Годината, когато се случва n-тото събитие\n\nПример:\nf_32(6, [3,2,4,5,9,18])\n// връща 36", "zh": "编写一个 JavaScript 函数 `function f_32(n, signs)` 来解决以下问题：  \n计算第 n 个事件发生的年份 Y_n，考虑到每个事件的周期性为 a_i 年。事件 i+1 的倒计时从事件 i 发生后的下一年开始。  \n参数：  \n- n (number): 事件的总数  \n- signs (number[]): 一个数组，表示事件的周期性  \n返回：  \n- number: 第 n 个事件发生的年份  \n\n示例：  \nf_32(6, [3,2,4,5,9,18])  \n// 返回 36  ", "fr": "Écrire une fonction JavaScript `function f_32(n, signs)` pour résoudre le problème suivant :\nCalcule l'année Y_n lorsque le n-ième événement se produit, en considérant que chaque événement a une périodicité de a_i années. Le compte à rebours pour l'événement i+1 commence l'année après que l'événement i se produit.\nParamètres :\n- n (nombre) : Le nombre total d'événements\n- signs (nombre[]) : Un tableau représentant les périodicités des événements\nRenvoie :\n- nombre : L'année où le n-ième événement se produit\n\nExemple :\nf_32(6, [3,2,4,5,9,18])\n// renvoie 36", "de": "Schreiben Sie eine JavaScript-Funktion `function f_32(n, signs)`, um das folgende Problem zu lösen:\nBerechnet das Jahr Y_n, in dem das n-te Ereignis eintritt, wobei jedes Ereignis eine Periodizität von a_i Jahren hat. Der Countdown für Ereignis i+1 beginnt im Jahr nach dem Eintreten von Ereignis i.\nParameter:\n- n (number): Die Gesamtanzahl der Ereignisse\n- signs (number[]): Ein Array, das die Periodizitäten der Ereignisse darstellt\nRückgabewert:\n- number: Das Jahr, in dem das n-te Ereignis eintritt\n\nBeispiel:\nf_32(6, [3,2,4,5,9,18])\n// gibt 36 zurück", "ha": "Rubuta wani aikin JavaScript `function f_32(n, signs)` don warware matsalar mai zuwa:\nLissafa shekarar Y_n lokacin da abin da ya faru na n-th ya faru, la'akari da cewa kowane abin da ya faru yana da maimaituwa na a_i shekaru. Kirga don abin da ya faru na i+1 yana farawa shekara bayan abin da ya faru na i ya faru.\nSigogi:\n- n (lamba): Jimlar adadin abubuwan da suka faru\n- signs (lamba[]): Wani tsari da ke wakiltar maimaituwar abubuwan da suka faru\nMayarwa:\n- lamba: Shekarar da abin da ya faru na n-th ya faru\n\nMisali:\nf_32(6, [3,2,4,5,9,18])\n// yana mayar da 36", "hi": "JavaScript फ़ंक्शन `function f_32(n, signs)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nगणना करता है वर्ष Y_n जब n-वीं घटना होती है, यह मानते हुए कि प्रत्येक घटना की आवृत्ति a_i वर्षों की होती है। घटना i+1 के लिए उलटी गिनती घटना i के होने के अगले वर्ष से शुरू होती है।\nपैरामीटर्स:\n- n (संख्या): घटनाओं की कुल संख्या\n- signs (संख्या[]): घटनाओं की आवृत्तियों का प्रतिनिधित्व करने वाला एक ऐरे\nवापसी करता है:\n- संख्या: वर्ष जब n-वीं घटना होती है\n\nउदाहरण:\nf_32(6, [3,2,4,5,9,18])\n// 36 लौटाता है", "hu": "Írj egy JavaScript függvényt `function f_32(n, signs)` a következő probléma megoldására:\nKiszámítja az Y_n évet, amikor az n-edik esemény bekövetkezik, figyelembe véve, hogy minden esemény a_i évenkénti periodicitással rendelkezik. Az i+1-edik esemény visszaszámlálása azután az év után kezdődik, amikor az i-edik esemény bekövetkezik.\nParaméterek:\n- n (szám): Az események teljes száma\n- signs (szám[]): Egy tömb, amely az események periodicitását reprezentálja\nVisszatér:\n- szám: Az év, amikor az n-edik esemény bekövetkezik\n\nPélda:\nf_32(6, [3,2,4,5,9,18])\n// visszaadja 36", "es": "Escribe una función de JavaScript `function f_32(n, signs)` para resolver el siguiente problema:\nCalcula el año Y_n cuando ocurre el n-ésimo evento, considerando que cada evento tiene una periodicidad de a_i años. La cuenta regresiva para el evento i+1 comienza el año después de que ocurre el evento i.\nParámetros:\n- n (number): El número total de eventos\n- signs (number[]): Un arreglo que representa las periodicidades de los eventos\nDevuelve:\n- number: El año en que ocurre el n-ésimo evento\n\nEjemplo:\nf_32(6, [3,2,4,5,9,18])\n// devuelve 36", "arb": "اكتب دالة JavaScript `function f_32(n, signs)` لحل المشكلة التالية:\nتحسب السنة Y_n عندما يحدث الحدث n، مع الأخذ في الاعتبار أن لكل حدث دورية a_i سنوات. يبدأ العد التنازلي للحدث i+1 في السنة التي تلي حدوث الحدث i.\nالمعطيات:\n- n (رقم): العدد الإجمالي للأحداث\n- signs (عدد[]): مصفوفة تمثل دوريات الأحداث\nالإرجاع:\n- رقم: السنة التي يحدث فيها الحدث n\n\nمثال:\nf_32(6, [3,2,4,5,9,18])\n// يعيد 36", "sw": "Andika kazi ya JavaScript `function f_32(n, signs)` kutatua tatizo lifuatalo:\nHesabu mwaka Y_n wakati tukio la n linatokea, ukizingatia kwamba kila tukio lina kipindi cha miaka a_i. Muda wa kuhesabu kwa tukio la i+1 huanza mwaka baada ya tukio la i kutokea.\nVigezo:\n- n (nambari): Jumla ya matukio\n- signs (nambari[]): Orodha inayowakilisha vipindi vya matukio\nInarudisha:\n- nambari: Mwaka ambapo tukio la n linatokea\n\nMfano:\nf_32(6, [3,2,4,5,9,18])\n// inarudisha 36", "tr": "Bir JavaScript fonksiyonu `function f_32(n, signs)` yazın, aşağıdaki problemi çözmek için:\nHer olayın a_i yıllık bir periyodiklikle gerçekleştiğini göz önünde bulundurarak, n-inci olayın gerçekleştiği Y_n yılını hesaplar. i+1 olayının geri sayımı, i olayı gerçekleştikten sonraki yıl başlar.\nParametreler:\n- n (number): Toplam olay sayısı\n- signs (number[]): Olayların periyodikliklerini temsil eden bir dizi\nDöndürür:\n- number: n-inci olayın gerçekleştiği yıl\n\nÖrnek:\nf_32(6, [3,2,4,5,9,18])\n// 36 döndürür", "vi": "Viết một hàm JavaScript `function f_32(n, signs)` để giải quyết vấn đề sau:\nTính toán năm Y_n khi sự kiện thứ n xảy ra, với điều kiện mỗi sự kiện có chu kỳ a_i năm. Đếm ngược cho sự kiện i+1 bắt đầu vào năm sau khi sự kiện i xảy ra.\nTham số:\n- n (number): Tổng số sự kiện\n- signs (number[]): Một mảng đại diện cho chu kỳ của các sự kiện\nTrả về:\n- number: Năm khi sự kiện thứ n xảy ra\n\nVí dụ:\nf_32(6, [3,2,4,5,9,18])\n// trả về 36", "id": "Tulis sebuah fungsi JavaScript `function f_32(n, signs)` untuk menyelesaikan masalah berikut:\nMenghitung tahun Y_n ketika peristiwa ke-n terjadi, dengan mempertimbangkan bahwa setiap peristiwa memiliki periodisitas a_i tahun. Hitungan mundur untuk peristiwa i+1 dimulai tahun setelah peristiwa i terjadi.\nParameter:\n- n (number): Jumlah total peristiwa\n- signs (number[]): Sebuah array yang mewakili periodisitas dari peristiwa-peristiwa tersebut\nMengembalikan:\n- number: Tahun ketika peristiwa ke-n terjadi\n\nContoh:\nf_32(6, [3,2,4,5,9,18])\n// mengembalikan 36", "ja": "JavaScript関数`function f_32(n, signs)`を作成して、次の問題を解決してください。  \nn番目のイベントが発生する年Y_nを計算します。各イベントはa_i年の周期性を持つと考えられます。イベントi+1のカウントダウンは、イベントiが発生した翌年から始まります。  \nパラメータ:  \n- n (number): イベントの総数  \n- signs (number[]): イベントの周期性を表す配列  \n戻り値:  \n- number: n番目のイベントが発生する年  \n\n例:  \nf_32(6, [3,2,4,5,9,18])  \n// 36を返します  ", "ko": "JavaScript 함수 `function f_32(n, signs)`를 작성하여 다음 문제를 해결하십시오:\n각 이벤트가 a_i년의 주기를 가지고 있다고 고려할 때, n번째 이벤트가 발생하는 해 Y_n을 계산합니다. 이벤트 i+1의 카운트다운은 이벤트 i가 발생한 다음 해에 시작됩니다.\n매개변수:\n- n (number): 이벤트의 총 수\n- signs (number[]): 이벤트의 주기를 나타내는 배열\n반환:\n- number: n번째 이벤트가 발생하는 해\n\n예시:\nf_32(6, [3,2,4,5,9,18])\n// 36을 반환합니다", "ml": "`function f_32(n, signs)` എന്ന ജാവാസ്ക്രിപ്റ്റ് ഫംഗ്ഷൻ എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nഓരോ സംഭവത്തിനും a_i വർഷങ്ങളുടെ കാലപരിധി ഉള്ളതായി കണക്കാക്കുമ്പോൾ, n-ആമത്തെ സംഭവം നടക്കുമ്പോൾ Y_n വർഷം കണക്കാക്കുന്നു. സംഭവം i നടക്കുന്നതിന് ശേഷം അടുത്ത വർഷം സംഭവ i+1 ന്റെ കൗണ്ട്ഡൗൺ ആരംഭിക്കുന്നു.\nപാരാമീറ്ററുകൾ:\n- n (number): ആകെ സംഭവങ്ങളുടെ എണ്ണം\n- signs (number[]): സംഭവങ്ങളുടെ കാലപരിധികളെ പ്രതിനിധീകരിക്കുന്ന ഒരു അറേ\nമടക്കം:\n- number: n-ആമത്തെ സംഭവം നടക്കുമ്പോൾ വർഷം\n\nഉദാഹരണം:\nf_32(6, [3,2,4,5,9,18])\n// 36 മടക്കം ചെയ്യുന്നു", "fa": "یک تابع جاوااسکریپت `function f_32(n, signs)` بنویسید تا مسئله زیر را حل کند:\nمحاسبه می‌کند سال Y_n که در آن رویداد n-ام رخ می‌دهد، با در نظر گرفتن اینکه هر رویداد دارای دوره تناوب a_i سال است. شمارش معکوس برای رویداد i+1 از سال بعد از وقوع رویداد i آغاز می‌شود.\nپارامترها:\n- n (عدد): تعداد کل رویدادها\n- signs (آرایه‌ای از اعداد): آرایه‌ای که دوره تناوب رویدادها را نشان می‌دهد\nبرمی‌گرداند:\n- عدد: سالی که در آن رویداد n-ام رخ می‌دهد\n\nمثال:\nf_32(6, [3,2,4,5,9,18])\n// برمی‌گرداند 36"}, "level": "easy", "test": "const testf_32 = () => {\n    console.assert(f_32(6, [3, 2, 4, 5, 9, 18]) === 36);\n    console.assert(f_32(5, [1, 2, 3, 4, 5]) === 5);\n    console.assert(f_32(5, [1, 1, 1, 1, 1]) === 5);\n    console.assert(f_32(6, [50, 30, 711, 200, 503, 1006]) === 2012);\n    console.assert(f_32(2, [1, 2]) === 2);\n    console.assert(f_32(3, [3, 1, 2]) === 6);\n    console.assert(f_32(3, [2, 3, 4]) === 4);\n    console.assert(f_32(4, [1, 2, 3, 4]) === 4);\n    console.assert(f_32(4, [5, 7, 11, 13]) === 13);\n    console.assert(f_32(5, [2, 2, 2, 2, 2]) === 10);\n    console.assert(f_32(3, [6, 10, 15]) === 15);\n    console.assert(f_32(3, [4, 6, 14]) === 14);\n    console.assert(f_32(4, [50, 30, 711, 200]) === 800);\n    console.assert(f_32(6, [1, 1, 1, 1, 1, 1]) === 6);\n    console.assert(f_32(2, [1000000, 999999]) === 1999998);\n};\n\ntestf_32();", "entry_point": "f_32", "signature": "function f_32(n, signs)", "docstring": {"en": "Calculates the year Y_n when the n-th event occurs, considering that each event has a periodicity of a_i years. The countdown for event i+1 starts the year after event i occurs.\nParameters:\n- n (number): The total number of events\n- signs (number[]): An array representing the periodicities of the events\nReturns:\n- number: The year when the n-th event occurs\n\nExample:\nf_32(6, [3,2,4,5,9,18])\n// returns 36", "sq": "Llogarit vitin Y_n kur ndodh ngjarja e n-të, duke marrë parasysh se çdo ngjarje ka një periodicitet prej a_i vitesh. Numërimi mbrapsht për ngjarjen i+1 fillon vitin pas ngjarjes i.\nParametrat:\n- n (numër): Numri total i ngjarjeve\n- signs (numër[]): Një varg që përfaqëson periodicitetet e ngjarjeve\nKthen:\n- numër: Viti kur ndodh ngjarja e n-të\n\nShembull:\nf_32(6, [3,2,4,5,9,18])\n// kthen 36", "hy": "Հաշվում է Y_n տարին, երբ տեղի է ունենում n-րդ իրադարձությունը՝ հաշվի առնելով, որ յուրաքանչյուր իրադարձություն ունի a_i տարիների պարբերականություն։ Իրադարձություն i+1-ի հետհաշվարկը սկսվում է i իրադարձության տեղի ունենալուց հետո հաջորդ տարում։\nՊարամետրեր՝\n- n (թիվ): Իրադարձությունների ընդհանուր քանակը\n- signs (թիվ[]): Զանգված, որը ներկայացնում է իրադարձությունների պարբերականությունները\nՎերադարձնում է՝\n- թիվ: Տարին, երբ տեղի է ունենում n-րդ իրադարձությունը\n\nՕրինակ:\nf_32(6, [3,2,4,5,9,18])\n// վերադարձնում է 36", "bn": "n-তম ঘটনা কখন ঘটে তা গণনা করে, বিবেচনা করে যে প্রতিটি ঘটনার একটি a_i বছর পরপর পুনরাবৃত্তি ঘটে। ঘটনা i+1 এর জন্য কাউন্টডাউন শুরু হয় ঘটনা i ঘটার পরের বছর থেকে।\n\nপ্যারামিটারসমূহ:\n- n (number): মোট ঘটনার সংখ্যা\n- signs (number[]): ঘটনাগুলির পুনরাবৃত্তির সময়কাল নির্দেশকারী একটি অ্যারে\n\nরিটার্নস:\n- number: n-তম ঘটনা যখন ঘটে সেই বছর\n\nউদাহরণ:\nf_32(6, [3,2,4,5,9,18])\n// 36 রিটার্ন করে", "bg": "Изчислява годината Y_n, когато се случва n-тото събитие, като се има предвид, че всяко събитие има периодичност от a_i години. Обратното броене за събитие i+1 започва годината след като събитие i се случи.\nПараметри:\n- n (number): Общият брой на събитията\n- signs (number[]): Масив, представляващ периодичностите на събитията\nВръща:\n- number: Годината, когато се случва n-тото събитие\n\nПример:\nf_32(6, [3,2,4,5,9,18])\n// връща 36", "zh": "计算第 n 个事件发生的年份 Y_n，考虑到每个事件的周期性为 a_i 年。事件 i+1 的倒计时从事件 i 发生后的下一年开始。\n\n参数：\n- n (number): 事件的总数\n- signs (number[]): 一个表示事件周期性的数组\n\n返回：\n- number: 第 n 个事件发生的年份\n\n示例：\nf_32(6, [3,2,4,5,9,18])\n// 返回 36", "fr": "Calcule l'année Y_n lorsque le n-ième événement se produit, en considérant que chaque événement a une périodicité de a_i années. Le compte à rebours pour l'événement i+1 commence l'année après que l'événement i se produit.\n\nParamètres:\n- n (nombre) : Le nombre total d'événements\n- signs (nombre[]) : Un tableau représentant les périodicités des événements\n\nRetourne:\n- nombre : L'année où le n-ième événement se produit\n\nExemple:\nf_32(6, [3,2,4,5,9,18])\n// retourne 36", "de": "Berechnet das Jahr Y_n, in dem das n-te Ereignis eintritt, wobei berücksichtigt wird, dass jedes Ereignis eine Periodizität von a_i Jahren hat. Der Countdown für Ereignis i+1 beginnt im Jahr nach dem Eintreten von Ereignis i.\nParameter:\n- n (number): Die Gesamtanzahl der Ereignisse\n- signs (number[]): Ein Array, das die Periodizitäten der Ereignisse darstellt\nRückgabe:\n- number: Das Jahr, in dem das n-te Ereignis eintritt\n\nBeispiel:\nf_32(6, [3,2,4,5,9,18])\n// gibt 36 zurück", "ha": "Lissafa shekarar Y_n lokacin da abin da ya faru na n-th ya faru, la'akari da cewa kowane abin da ya faru yana da maimaituwa na a_i shekaru. Kirga don abin da ya faru na i+1 yana farawa shekara bayan abin da ya faru na i ya faru.\nSigogi:\n- n (number): Jimlar adadin abubuwan da suka faru\n- signs (number[]): Wani tsari da ke wakiltar lokutan abubuwan da suka faru\n\nReturns:\n- number: Shekarar da abin da ya faru na n-th zai faru\n\nExample:\nf_32(6, [3,2,4,5,9,18])\n// returns 36", "hi": "nवें घटना के घटित होने का वर्ष Y_n की गणना करता है, यह मानते हुए कि प्रत्येक घटना की आवृत्ति a_i वर्षों की होती है। घटना i+1 की उलटी गिनती घटना i के घटित होने के अगले वर्ष से शुरू होती है।\n\nपैरामीटर्स:\n- n (number): घटनाओं की कुल संख्या\n- signs (number[]): घटनाओं की आवृत्तियों का प्रतिनिधित्व करने वाला एक ऐरे\n\nवापसी:\n- number: वह वर्ष जब nवीं घटना घटित होती है\n\nउदाहरण:\nf_32(6, [3,2,4,5,9,18])\n// returns 36", "hu": "Kiszámítja az Y_n évet, amikor az n-edik esemény bekövetkezik, figyelembe véve, hogy minden eseménynek a_i éves periódusa van. Az i+1. esemény visszaszámlálása az i. esemény bekövetkezése utáni évben kezdődik.\nParaméterek:\n- n (szám): Az események teljes száma\n- signs (szám[]): Egy tömb, amely az események periódusait jelöli\nVisszatérési érték:\n- szám: Az év, amikor az n-edik esemény bekövetkezik\n\nPélda:\nf_32(6, [3,2,4,5,9,18])\n// visszaadja 36", "es": "Calcula el año Y_n cuando ocurre el evento n-ésimo, considerando que cada evento tiene una periodicidad de a_i años. La cuenta regresiva para el evento i+1 comienza el año después de que ocurre el evento i.\n\nParámetros:\n- n (número): El número total de eventos\n- signs (número[]): Un arreglo que representa las periodicidades de los eventos\n\nDevuelve:\n- número: El año en que ocurre el evento n-ésimo\n\nEjemplo:\nf_32(6, [3,2,4,5,9,18])\n// devuelve 36", "arb": "يحسب السنة Y_n عندما يحدث الحدث n، مع الأخذ في الاعتبار أن كل حدث له دورية a_i سنوات. يبدأ العد التنازلي للحدث i+1 في السنة التي تلي حدوث الحدث i.\n\nالمعلمات:\n- n (عدد): العدد الإجمالي للأحداث\n- signs (عدد[]): مصفوفة تمثل دوريات الأحداث\n\nالقيم المعادة:\n- عدد: السنة التي يحدث فيها الحدث n\n\nمثال:\nf_32(6, [3,2,4,5,9,18])\n// يعيد 36", "sw": "Hesabu mwaka Y_n wakati tukio la n linapotokea, ukizingatia kwamba kila tukio lina kipindi cha a_i miaka. Kuanzia kwa tukio la i+1 huanza mwaka mmoja baada ya tukio la i kutokea.\n\nVipengele:\n- n (nambari): Jumla ya idadi ya matukio\n- signs (nambari[]): Kifurushi kinachowakilisha vipindi vya matukio\n\nInarudi:\n- nambari: Mwaka ambapo tukio la n linatokea\n\nMfano:\nf_32(6, [3,2,4,5,9,18])\n// inarudi 36", "tr": "Y_n yılını hesaplar, n'inci olayın gerçekleştiği yıl, her olayın a_i yıllık bir periyodiklikle gerçekleştiğini dikkate alarak. Olay i+1 için geri sayım, olay i gerçekleştiği yılın sonrasında başlar.\nParametreler:\n- n (number): Toplam olay sayısı\n- signs (number[]): Olayların periyodikliklerini temsil eden bir dizi\nDöndürür:\n- number: n'inci olayın gerçekleştiği yıl\n\nÖrnek:\nf_32(6, [3,2,4,5,9,18])\n// 36 döndürür", "vi": "Tính toán năm Y_n khi sự kiện thứ n xảy ra, với điều kiện rằng mỗi sự kiện có chu kỳ a_i năm. Đếm ngược cho sự kiện i+1 bắt đầu từ năm sau khi sự kiện i xảy ra.\nTham số:\n- n (number): Tổng số sự kiện\n- signs (number[]): Một mảng đại diện cho chu kỳ của các sự kiện\nTrả về:\n- number: Năm khi sự kiện thứ n xảy ra\n\nVí dụ:\nf_32(6, [3,2,4,5,9,18])\n// trả về 36", "id": "Menghitung tahun Y_n ketika peristiwa ke-n terjadi, dengan mempertimbangkan bahwa setiap peristiwa memiliki periodisitas a_i tahun. Hitungan mundur untuk peristiwa i+1 dimulai tahun setelah peristiwa i terjadi.\n\nParameter:\n- n (number): Jumlah total peristiwa\n- signs (number[]): Sebuah array yang mewakili periodisitas dari peristiwa-peristiwa\n\nMengembalikan:\n- number: Tahun ketika peristiwa ke-n terjadi\n\nContoh:\nf_32(6, [3,2,4,5,9,18])\n// mengembalikan 36", "ja": "n番目のイベントが発生する年Y_nを計算します。各イベントはa_i年の周期性を持っており、イベントiが発生した翌年からイベントi+1のカウントダウンが始まります。\n\n引数:\n- n (number): イベントの総数\n- signs (number[]): イベントの周期性を表す配列\n\n戻り値:\n- number: n番目のイベントが発生する年\n\n例:\nf_32(6, [3,2,4,5,9,18])\n// 36を返します", "ko": "n번째 이벤트가 발생하는 연도 Y_n을 계산합니다. 각 이벤트는 a_i년의 주기를 가지고 있으며, 이벤트 i가 발생한 다음 해부터 이벤트 i+1의 카운트다운이 시작됩니다.\n매개변수:\n- n (number): 총 이벤트 수\n- signs (number[]): 이벤트의 주기를 나타내는 배열\n반환값:\n- number: n번째 이벤트가 발생하는 연도\n\n예시:\nf_32(6, [3,2,4,5,9,18])\n// 36을 반환합니다.", "ml": "ഓരോ സംഭവത്തിനും a_i വർഷങ്ങളുടെ കാലയളവുള്ള ഒരു ആവർത്തിത്വം ഉണ്ടെന്ന് കണക്കാക്കുമ്പോൾ n-ആം സംഭവം നടക്കുമ്പോഴുള്ള Y_n വർഷം കണക്കാക്കുന്നു. \n * സംഭവം i+1 ന്റെ കൗണ്ട്ഡൗൺ സംഭവം i നടക്കുന്നതിന് ശേഷം വർഷം ആരംഭിക്കുന്നു.\n- n (number): സംഭവങ്ങളുടെ മൊത്തം എണ്ണം\n- signs (number[]): സംഭവങ്ങളുടെ കാലപരിധികളെ പ്രതിനിധാനം ചെയ്യുന്ന ഒരു നിര\n\nമടക്കം:\n- number: n-ആമത്തെ സംഭവം നടക്കുമ്പോഴുള്ള വർഷം\n\nഉദാഹരണം:\nf_32(6, [3,2,4,5,9,18])\n// 36 മടക്കം ചെയ്യുന്നു", "fa": "محاسبه می‌کند سال Y_n که در آن رویداد n-ام رخ می‌دهد، با در نظر گرفتن اینکه هر رویداد دارای دوره تناوب a_i سال است. شمارش معکوس برای رویداد i+1 از سال بعد از وقوع رویداد i شروع می‌شود.\n\nپارامترها:\n- n (عدد): تعداد کل رویدادها\n- signs (آرایه عددی): آرایه‌ای که دوره تناوب رویدادها را نشان می‌دهد\n\nبازگشت:\n- عدد: سالی که در آن رویداد n-ام رخ می‌دهد\n\nمثال:\nf_32(6, [3,2,4,5,9,18])\n// بازگشت 36"}}
{"task_id": "JavaScript/33", "prompt": {"en": "/**\n * This problem introduces a new modulo operation, denoted by the symbol \"⊕\".\n * When calculating x ⊕ y, if x is not a multiple of y, the result is the remainder of x divided by y.\n * Otherwise, divide x by y repeatedly until x is no longer a multiple of y, denoting the final value as x'.\n * Then the result is the remainder of x' divided by y. \n * For example, 4⊕5=4, 20⊕5=4, 100⊕5=4.\n * Given a prime number p, there will be several queries. For each query, an integer n is given,\n * and you need to compute the value of n! ⊕ p, where n! is the factorial of n,\n * i.e. the product of all positive integers less than or equal to n.\n * \n * @example\n * f_33(3, 7); // returns 6\n */\nfunction f_33(n, p)", "sq": "/**\n * Ky problem prezanton një operacion të ri modulo, i shënuar me simbolin \"⊕\".\n * Kur llogarit x ⊕ y, nëse x nuk është shumëfish i y, rezultati është mbetja e x e ndarë me y.\n * Përndryshe, ndaj x me y vazhdimisht derisa x të mos jetë më shumëfish i y, duke e shënuar vlerën përfundimtare si x'.\n * Pastaj rezultati është mbetja e x' e ndarë me y.\n * Për shembull, 4⊕5=4, 20⊕5=4, 100⊕5=4.\n * Duke pasur një numër të thjeshtë p, do të ketë disa kërkesa. Për çdo kërkesë, jepet një numër i plotë n,\n * dhe ju duhet të llogaritni vlerën e n! ⊕ p, ku n! është faktoriali i n,\n * dmth. prodhimi i të gjithë numrave të plotë pozitivë më të vegjël ose të barabartë me n.\n * \n * @example\n * f_33(3, 7); // kthen 6\n */\nfunction f_33(n, p)", "hy": "/**\n * Այս խնդիրը ներկայացնում է նոր մնացորդային գործողություն, որը նշվում է \"⊕\" նշանով:\n * Երբ հաշվարկում ենք x ⊕ y, եթե x-ը y-ի բազմապատիկ չէ, արդյունքը x-ի y-ի բաժանման մնացորդն է:\n * Հակառակ դեպքում, բազմիցս բաժանեք x-ը y-ի վրա, մինչև x-ը այլևս y-ի բազմապատիկ չլինի, վերջնական արժեքը նշելով որպես x':\n * Ապա արդյունքը x'-ի y-ի բաժանման մնացորդն է: \n * Օրինակ, 4⊕5=4, 20⊕5=4, 100⊕5=4:\n * Տրված է p պարզ թիվը, լինելու են մի քանի հարցումներ: Յուրաքանչյուր հարցման համար տրված է n ամբողջ թիվը,\n * և դուք պետք է հաշվեք n! ⊕ p արժեքը, որտեղ n! n-ի ֆակտորիալն է,\n * այսինքն՝ n-ից փոքր կամ հավասար բոլոր դրական ամբողջ թվերի արտադրյալը:\n * \n * @example\n * f_33(3, 7); // վերադարձնում է 6\n */\nfunction f_33(n, p)", "bn": "/**\n * এই সমস্যাটি একটি নতুন মডুলো অপারেশন পরিচয় করিয়ে দেয়, যা \"⊕\" প্রতীক দ্বারা চিহ্নিত।\n * x ⊕ y গণনা করার সময়, যদি x y এর গুণিতক না হয়, তাহলে ফলাফল হল x কে y দ্বারা ভাগ করার অবশিষ্টাংশ।\n * অন্যথায়, x কে y দ্বারা বারবার ভাগ করুন যতক্ষণ না x আর y এর গুণিতক থাকে না, চূড়ান্ত মানটিকে x' হিসাবে চিহ্নিত করুন।\n * তারপর ফলাফল হল x' কে y দ্বারা ভাগ করার অবশিষ্টাংশ। \n * উদাহরণস্বরূপ, 4⊕5=4, 20⊕5=4, 100⊕5=4।\n * একটি মৌলিক সংখ্যা p দেওয়া হলে, সেখানে বেশ কয়েকটি প্রশ্ন থাকবে। প্রতিটি প্রশ্নের জন্য, একটি পূর্ণসংখ্যা n দেওয়া হবে,\n * এবং আপনাকে n! ⊕ p এর মান গণনা করতে হবে, যেখানে n! হল n এর ফ্যাক্টোরিয়াল,\n * অর্থাৎ n এর চেয়ে ছোট বা সমান সমস্ত ধনাত্মক পূর্ণসংখ্যার গুণফল।\n * \n * @example\n * f_33(3, 7); // returns 6\n */\nfunction f_33(n, p)", "bg": "/**\n * Този проблем въвежда нова операция за модуло, обозначена със символа \"⊕\".\n * При изчисляване на x ⊕ y, ако x не е кратно на y, резултатът е остатъкът от x, разделено на y.\n * В противен случай, разделяйте x на y многократно, докато x вече не е кратно на y, обозначавайки крайната стойност като x'.\n * Тогава резултатът е остатъкът от x', разделено на y.\n * Например, 4⊕5=4, 20⊕5=4, 100⊕5=4.\n * Дадено е просто число p, ще има няколко заявки. За всяка заявка е дадено цяло число n,\n * и трябва да изчислите стойността на n! ⊕ p, където n! е факториелът на n,\n * т.е. произведението на всички положителни цели числа, по-малки или равни на n.\n * \n * @example\n * f_33(3, 7); // връща 6\n */\nfunction f_33(n, p)", "zh": "/**\n * 这个问题引入了一种新的模运算，用符号“⊕”表示。\n * 计算 x ⊕ y 时，如果 x 不是 y 的倍数，结果是 x 除以 y 的余数。\n * 否则，反复将 x 除以 y，直到 x 不再是 y 的倍数，将最终值记为 x'。\n * 然后结果是 x' 除以 y 的余数。\n * 例如，4⊕5=4，20⊕5=4，100⊕5=4。\n * 给定一个素数 p，会有若干查询。对于每个查询，给定一个整数 n，\n * 你需要计算 n! ⊕ p 的值，其中 n! 是 n 的阶乘，\n * 即小于或等于 n 的所有正整数的乘积。\n * \n * @example\n * f_33(3, 7); // returns 6\n */", "fr": "/**\n * Ce problème introduit une nouvelle opération modulo, notée par le symbole \"⊕\".\n * Lors du calcul de x ⊕ y, si x n'est pas un multiple de y, le résultat est le reste de x divisé par y.\n * Sinon, divisez x par y de manière répétée jusqu'à ce que x ne soit plus un multiple de y, en désignant la valeur finale par x'.\n * Ensuite, le résultat est le reste de x' divisé par y.\n * Par exemple, 4⊕5=4, 20⊕5=4, 100⊕5=4.\n * Étant donné un nombre premier p, il y aura plusieurs requêtes. Pour chaque requête, un entier n est donné,\n * et vous devez calculer la valeur de n! ⊕ p, où n! est la factorielle de n,\n * c'est-à-dire le produit de tous les entiers positifs inférieurs ou égaux à n.\n * \n * @example\n * f_33(3, 7); // returns 6\n */\nfunction f_33(n, p)", "de": "/**\n * Dieses Problem führt eine neue Modulo-Operation ein, die durch das Symbol \"⊕\" dargestellt wird.\n * Bei der Berechnung von x ⊕ y, wenn x kein Vielfaches von y ist, ist das Ergebnis der Rest von x geteilt durch y.\n * Andernfalls wird x wiederholt durch y geteilt, bis x kein Vielfaches von y mehr ist, wobei der Endwert als x' bezeichnet wird.\n * Dann ist das Ergebnis der Rest von x' geteilt durch y.\n * Zum Beispiel, 4⊕5=4, 20⊕5=4, 100⊕5=4.\n * Gegeben ist eine Primzahl p, es wird mehrere Anfragen geben. Für jede Anfrage wird eine ganze Zahl n gegeben,\n * und Sie müssen den Wert von n! ⊕ p berechnen, wobei n! die Fakultät von n ist,\n * d.h. das Produkt aller positiven ganzen Zahlen kleiner oder gleich n.\n * \n * @example\n * f_33(3, 7); // gibt 6 zurück\n */\nfunction f_33(n, p)", "ha": "/**\n * Wannan matsala tana gabatar da sabon aikin modulo, wanda aka nuna da alamar \"⊕\".\n * Lokacin da ake lissafin x ⊕ y, idan x ba ya kasu ba tare da saura ba ga y, sakamakon shi ne saura na x raba y.\n * In ba haka ba, a raba x da y akai-akai har sai x ba ya kasu ba tare da saura ba ga y, ana nuni da ƙimar ƙarshe a matsayin x'.\n * Sannan sakamakon shi ne saura na x' raba y.\n * Alal misali, 4⊕5=4, 20⊕5=4, 100⊕5=4.\n * An ba da lamba mai firamare p, za a sami tambayoyi da dama. Don kowace tambaya, ana ba da cikakken lamba n,\n * kuma kuna buƙatar lissafin ƙimar n! ⊕ p, inda n! shine factorial na n,\n * wato samfurin duk lambobi masu kyau da suka fi ko dai dai da n.\n * \n * @example\n * f_33(3, 7); // returns 6\n */\nfunction f_33(n, p)", "hi": "/**\n * इस समस्या में एक नया मॉड्यूलो ऑपरेशन प्रस्तुत किया गया है, जिसे प्रतीक \"⊕\" द्वारा दर्शाया गया है।\n * जब x ⊕ y की गणना की जाती है, यदि x, y का गुणज नहीं है, तो परिणाम x को y से विभाजित करने पर शेषफल होता है।\n * अन्यथा, x को y से बार-बार विभाजित करें जब तक कि x अब y का गुणज न हो, अंतिम मान को x' के रूप में दर्शाते हुए।\n * फिर परिणाम x' को y से विभाजित करने पर शेषफल होता है।\n * उदाहरण के लिए, 4⊕5=4, 20⊕5=4, 100⊕5=4।\n * एक अभाज्य संख्या p दी गई है, कई क्वेरीज़ होंगी। प्रत्येक क्वेरी के लिए, एक पूर्णांक n दिया गया है,\n * और आपको n! ⊕ p का मान गणना करने की आवश्यकता है, जहाँ n! n का फैक्टोरियल है,\n * अर्थात n से कम या बराबर सभी धनात्मक पूर्णांकों का गुणनफल।\n * \n * @example\n * f_33(3, 7); // returns 6\n */\nfunction f_33(n, p)", "hu": "/**\n * Ez a probléma bevezet egy új modulo műveletet, amelyet a \"⊕\" szimbólum jelöl.\n * Amikor x ⊕ y-t számítjuk, ha x nem osztható y-nal, az eredmény x maradéka y-val osztva.\n * Ellenkező esetben osszuk el x-et y-nal ismételten, amíg x már nem osztható y-nal, és jelöljük a végső értéket x'-ként.\n * Ekkor az eredmény x' maradéka y-val osztva. \n * Például, 4⊕5=4, 20⊕5=4, 100⊕5=4.\n * Adott egy prímszám p, több lekérdezés lesz. Minden lekérdezésnél adott egy egész szám n,\n * és ki kell számítani az n! ⊕ p értékét, ahol n! az n faktoriálisa,\n * azaz az összes pozitív egész szám szorzata, amely kisebb vagy egyenlő n-nel.\n * \n * @példa\n * f_33(3, 7); // visszaadja 6\n */\nfunction f_33(n, p)", "es": "/**\n * Este problema introduce una nueva operación de módulo, denotada por el símbolo \"⊕\".\n * Al calcular x ⊕ y, si x no es un múltiplo de y, el resultado es el resto de x dividido por y.\n * De lo contrario, divide x por y repetidamente hasta que x ya no sea un múltiplo de y, denotando el valor final como x'.\n * Entonces el resultado es el resto de x' dividido por y.\n * Por ejemplo, 4⊕5=4, 20⊕5=4, 100⊕5=4.\n * Dado un número primo p, habrá varias consultas. Para cada consulta, se da un número entero n,\n * y necesitas calcular el valor de n! ⊕ p, donde n! es el factorial de n,\n * es decir, el producto de todos los enteros positivos menores o iguales a n.\n * \n * @example\n * f_33(3, 7); // devuelve 6\n */\nfunction f_33(n, p)", "arb": "/**\n * هذه المسألة تقدم عملية جديدة للمودولو، يرمز لها بالرمز \"⊕\".\n * عند حساب x ⊕ y، إذا لم يكن x مضاعفًا لـ y، فإن النتيجة هي باقي قسمة x على y.\n * خلاف ذلك، قسم x على y بشكل متكرر حتى لا يكون x مضاعفًا لـ y، مشيرًا إلى القيمة النهائية كـ x'.\n * ثم تكون النتيجة هي باقي قسمة x' على y.\n * على سبيل المثال، 4⊕5=4، 20⊕5=4، 100⊕5=4.\n * بالنظر إلى عدد أولي p، سيكون هناك عدة استفسارات. لكل استفسار، يُعطى عدد صحيح n،\n * وتحتاج إلى حساب قيمة n! ⊕ p، حيث n! هو مضروب n،\n * أي حاصل ضرب جميع الأعداد الصحيحة الموجبة الأقل من أو تساوي n.\n * \n * @example\n * f_33(3, 7); // يعيد 6\n */\nfunction f_33(n, p)", "sw": "/**\n * Shida hii inatambulisha operesheni mpya ya modulo, inayowakilishwa na alama \"⊕\".\n * Wakati wa kuhesabu x ⊕ y, ikiwa x si kigezo cha y, matokeo ni baki ya x iliyogawanywa na y.\n * Vinginevyo, gawa x kwa y mara kwa mara hadi x isiwe tena kigezo cha y, ikiwakilisha thamani ya mwisho kama x'.\n * Kisha matokeo ni baki ya x' iliyogawanywa na y.\n * Kwa mfano, 4⊕5=4, 20⊕5=4, 100⊕5=4.\n * Ukipewa nambari ya kwanza p, kutakuwa na maswali kadhaa. Kwa kila swali, nambari nzima n inatolewa,\n * na unahitaji kuhesabu thamani ya n! ⊕ p, ambapo n! ni factorial ya n,\n * yaani ni bidhaa ya nambari zote chanya zilizo chini au sawa na n.\n * \n * @example\n * f_33(3, 7); // inarejesha 6\n */\nfunction f_33(n, p)", "tr": "/**\n * Bu problem, \"⊕\" sembolüyle gösterilen yeni bir modül işlemi tanıtmaktadır.\n * x ⊕ y hesaplanırken, eğer x, y'nin katı değilse, sonuç x'in y'ye bölümünden kalan olur.\n * Aksi takdirde, x artık y'nin katı olmayana kadar x'i y'ye tekrar tekrar bölün, son değeri x' olarak belirtin.\n * Sonra sonuç, x'in y'ye bölümünden kalan olur.\n * Örneğin, 4⊕5=4, 20⊕5=4, 100⊕5=4.\n * Verilen bir asal sayı p için, birkaç sorgu olacaktır. Her sorgu için bir tamsayı n verilir\n * ve n! ⊕ p değerini hesaplamanız gerekir, burada n! n'nin faktöriyelidir,\n * yani n'ye eşit veya daha küçük olan tüm pozitif tamsayıların çarpımıdır.\n * \n * @example\n * f_33(3, 7); // 6 döndürür\n */\nfunction f_33(n, p)", "vi": "/**\n * Vấn đề này giới thiệu một phép toán modulo mới, ký hiệu là \"⊕\".\n * Khi tính toán x ⊕ y, nếu x không phải là bội số của y, kết quả là phần dư của x chia cho y.\n * Nếu không, chia x cho y liên tục cho đến khi x không còn là bội số của y, ký hiệu giá trị cuối cùng là x'.\n * Sau đó kết quả là phần dư của x' chia cho y. \n * Ví dụ, 4⊕5=4, 20⊕5=4, 100⊕5=4.\n * Cho một số nguyên tố p, sẽ có một số truy vấn. Đối với mỗi truy vấn, một số nguyên n được cho,\n * và bạn cần tính giá trị của n! ⊕ p, trong đó n! là giai thừa của n,\n * tức là tích của tất cả các số nguyên dương nhỏ hơn hoặc bằng n.\n * \n * @example\n * f_33(3, 7); // trả về 6\n */\nfunction f_33(n, p)", "id": "/**\n * Masalah ini memperkenalkan operasi modulo baru, yang dilambangkan dengan simbol \"⊕\".\n * Ketika menghitung x ⊕ y, jika x bukan kelipatan dari y, hasilnya adalah sisa dari x dibagi y.\n * Jika tidak, bagi x dengan y berulang kali sampai x tidak lagi menjadi kelipatan dari y, menandai nilai akhir sebagai x'.\n * Kemudian hasilnya adalah sisa dari x' dibagi y.\n * Sebagai contoh, 4⊕5=4, 20⊕5=4, 100⊕5=4.\n * Diberikan sebuah bilangan prima p, akan ada beberapa kueri. Untuk setiap kueri, diberikan sebuah bilangan bulat n,\n * dan Anda perlu menghitung nilai dari n! ⊕ p, di mana n! adalah faktorial dari n,\n * yaitu hasil kali dari semua bilangan bulat positif yang kurang dari atau sama dengan n.\n * \n * @example\n * f_33(3, 7); // mengembalikan 6\n */\nfunction f_33(n, p)", "ja": "/**\n * この問題では、新しい剰余演算「⊕」を導入します。\n * x ⊕ y を計算する際、x が y の倍数でない場合、結果は x を y で割った余りです。\n * そうでない場合、x を y で割り続け、x が y の倍数でなくなるまで繰り返し、最終的な値を x' とします。\n * その後、結果は x' を y で割った余りです。\n * 例えば、4⊕5=4, 20⊕5=4, 100⊕5=4 です。\n * 素数 p が与えられ、いくつかのクエリがあります。各クエリでは整数 n が与えられ、\n * n! ⊕ p の値を計算する必要があります。ここで n! は n の階乗であり、\n * n 以下のすべての正の整数の積です。\n * \n * @example\n * f_33(3, 7); // returns 6\n */\nfunction f_33(n, p)", "ko": "/**\n * 이 문제는 \"⊕\" 기호로 표시되는 새로운 모듈로 연산을 소개합니다.\n * x ⊕ y를 계산할 때, x가 y의 배수가 아니면 결과는 x를 y로 나눈 나머지입니다.\n * 그렇지 않으면, x를 y의 배수가 아닐 때까지 반복적으로 나누고, 최종 값을 x'로 나타냅니다.\n * 그런 다음 결과는 x'를 y로 나눈 나머지입니다.\n * 예를 들어, 4⊕5=4, 20⊕5=4, 100⊕5=4입니다.\n * 소수 p가 주어지면, 여러 쿼리가 있을 것입니다. 각 쿼리에 대해 정수 n이 주어지고,\n * n! ⊕ p의 값을 계산해야 합니다. 여기서 n!은 n 이하의 모든 양의 정수의 곱입니다.\n * \n * @example\n * f_33(3, 7); // returns 6\n */\nfunction f_33(n, p)", "ml": "/**\n * ഈ പ്രശ്നം \"⊕\" എന്ന ചിഹ്നം കൊണ്ട് സൂചിപ്പിക്കുന്ന ഒരു പുതിയ മോഡുലോ ഓപ്പറേഷൻ പരിചയപ്പെടുത്തുന്നു.\n * x ⊕ y കണക്കാക്കുമ്പോൾ, x y-ന്റെ ഗുണിതമല്ലെങ്കിൽ, ഫലം x y-ൽ വിഭജിച്ച ശേഷമുള്ള ശേഷമാണ്.\n * അല്ലാത്തപക്ഷം, x y-ൽ നിന്ന് വീണ്ടും വീണ്ടും വിഭജിക്കുക, x y-ന്റെ ഗുണിതമല്ലാത്തതുവരെ, അന്തിമ മൂല്യം x' ആയി സൂചിപ്പിക്കുക.\n * പിന്നീടുള്ള ഫലം x' y-ൽ വിഭജിച്ച ശേഷമുള്ള ശേഷമാണ്.\n * ഉദാഹരണത്തിന്, 4⊕5=4, 20⊕5=4, 100⊕5=4.\n * ഒരു പ്രധാന സംഖ്യ p നൽകിയാൽ, നിരവധി ക്വറിയുകൾ ഉണ്ടാകും. ഓരോ ക്വറിയിക്കും, ഒരു പൂർണ്ണസംഖ്യ n നൽകപ്പെടുന്നു,\n * നിങ്ങൾ n! ⊕ p-യുടെ മൂല്യം കണക്കാക്കണം, n! എന്നത് n-നേക്കാൾ കുറവായ അല്ലെങ്കിൽ തുല്യമായ എല്ലാ ധനാത്മക പൂർണ്ണസംഖ്യകളുടെ ഗുണിതമാണ്.\n * \n * @example\n * f_33(3, 7); // 6 മടക്കുന്നു\n */\nfunction f_33(n, p)", "fa": "/**\n * این مسئله یک عملگر جدید به نام \"⊕\" معرفی می‌کند.\n * هنگام محاسبه x ⊕ y، اگر x مضربی از y نباشد، نتیجه باقی‌مانده تقسیم x بر y است.\n * در غیر این صورت، x را به طور مکرر بر y تقسیم کنید تا زمانی که x دیگر مضربی از y نباشد، مقدار نهایی را به عنوان x' نشان دهید.\n * سپس نتیجه باقی‌مانده تقسیم x' بر y است.\n * به عنوان مثال، 4⊕5=4، 20⊕5=4، 100⊕5=4.\n * با توجه به یک عدد اول p، چندین پرسش وجود خواهد داشت. برای هر پرسش، یک عدد صحیح n داده می‌شود،\n * و شما باید مقدار n! ⊕ p را محاسبه کنید، که در آن n! فاکتوریل n است،\n * یعنی حاصل‌ضرب تمام اعداد صحیح مثبت کمتر یا مساوی n.\n * \n * @example\n * f_33(3, 7); // returns 6\n */\nfunction f_33(n, p)"}, "canonical_solution": "{\n    const pj = new Array(p).fill(1);\n    for (let i = 2; i < p; i++) pj[i] = (i * pj[i - 1]) % p;\n    \n    let ans = 1;\n    while (n > 0) {\n        ans = (ans * pj[n % p]) % p;\n        ans = ((n / p) & 1) ? p - ans : ans;\n        n = Math.floor(n / p);\n    }\n    return ans;\n}", "instruction": {"en": "Write a JavaScript function `function f_33(n, p)` to solve the following problem:\nThis problem introduces a new modulo operation, denoted by the symbol \"⊕\".\nWhen calculating x ⊕ y, if x is not a multiple of y, the result is the remainder of x divided by y.\nOtherwise, divide x by y repeatedly until x is no longer a multiple of y, denoting the final value as x'.\nThen the result is the remainder of x' divided by y. \nFor example, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nGiven a prime number p, there will be several queries. For each query, an integer n is given,\nand you need to compute the value of n! ⊕ p, where n! is the factorial of n,\ni.e. the product of all positive integers less than or equal to n.\n\n@example\nf_33(3, 7); // returns 6\n", "sq": "Shkruani një funksion JavaScript `function f_33(n, p)` për të zgjidhur problemin në vijim:\nKy problem prezanton një operacion të ri modulo, i shënuar me simbolin \"⊕\".\nKur llogaritni x ⊕ y, nëse x nuk është një shumëfish i y, rezultati është mbetja e x e ndarë me y.\nPërndryshe, ndani x me y në mënyrë të përsëritur derisa x të mos jetë më një shumëfish i y, duke e shënuar vlerën përfundimtare si x'.\nAtëherë rezultati është mbetja e x' e ndarë me y.\nPër shembull, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nDuke pasur një numër të plotë p, do të ketë disa pyetje. Për çdo pyetje, jepet një numër i plotë n,\ndhe ju duhet të llogaritni vlerën e n! ⊕ p, ku n! është faktoriali i n,\nd.m.th. prodhimi i të gjithë numrave të plotë pozitivë më të vegjël ose të barabartë me n.", "hy": "Գրեք JavaScript ֆունկցիա `function f_33(n, p)՝ հետևյալ խնդիրը լուծելու համար:\nԱյս խնդիրը ներկայացնում է նոր մնացորդի գործողություն, որը նշվում է \"⊕\" նշանով:\nԵրբ հաշվարկում ենք x ⊕ y, եթե x-ը y-ի բազմապատիկ չէ, արդյունքը x-ի y-ի բաժանման մնացորդն է:\nՀակառակ դեպքում, բաժանեք x-ը y-ի վրա կրկնակիորեն, մինչև x-ը այլևս y-ի բազմապատիկ չլինի, վերջնական արժեքը նշելով որպես x':\nԱյնուհետև արդյունքը x'-ի y-ի բաժանման մնացորդն է: \nՕրինակ, 4⊕5=4, 20⊕5=4, 100⊕5=4:\nՏրված է պարզ թիվ p, և լինելու են մի քանի հարցումներ: Յուրաքանչյուր հարցման համար տրված է ամբողջ թիվ n,\nև դուք պետք է հաշվեք n! ⊕ p արժեքը, որտեղ n! n-ի ֆակտորիալն է,\nայսինքն՝ n-ից փոքր կամ հավասար բոլոր դրական ամբողջ թվերի արտադրյալը:\n\n@example\nf_33(3, 7); // վերադարձնում է 6", "bn": "একটি JavaScript ফাংশন `function f_33(n, p)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএই সমস্যাটি একটি নতুন মডুলো অপারেশন পরিচয় করায়, যা \"⊕\" প্রতীকে নির্দেশিত।\nযখন x ⊕ y গণনা করা হয়, যদি x y এর গুণিতক না হয়, তাহলে ফলাফল হয় x কে y দিয়ে ভাগ করার পরে অবশিষ্টাংশ।\nঅন্যথায়, x কে y দিয়ে বারবার ভাগ করুন যতক্ষণ না x আর y এর গুণিতক থাকে, চূড়ান্ত মানটিকে x' হিসাবে নির্দেশিত করুন।\nতারপর ফলাফল হয় x' কে y দিয়ে ভাগ করার পরে অবশিষ্টাংশ। \nউদাহরণস্বরূপ, 4⊕5=4, 20⊕5=4, 100⊕5=4।\nএকটি মৌলিক সংখ্যা p দেওয়া হলে, সেখানে বেশ কয়েকটি প্রশ্ন থাকবে। প্রতিটি প্রশ্নের জন্য, একটি পূর্ণসংখ্যা n দেওয়া হয়,\nএবং আপনাকে n! ⊕ p এর মান গণনা করতে হবে, যেখানে n! হল n এর ফ্যাক্টোরিয়াল,\nঅর্থাৎ n এর চেয়ে ছোট বা সমান সমস্ত ধনাত্মক পূর্ণসংখ্যার গুণফল।\n\n@example\nf_33(3, 7); // returns 6", "bg": "Напишете функция на JavaScript `function f_33(n, p)` за решаване на следния проблем:\nТози проблем въвежда нова операция за модул, обозначена със символа \"⊕\".\nПри изчисляване на x ⊕ y, ако x не е кратно на y, резултатът е остатъкът от x, разделен на y.\nВ противен случай, разделяйте x на y многократно, докато x вече не е кратно на y, обозначавайки крайната стойност като x'.\nТогава резултатът е остатъкът от x', разделен на y.\nНапример, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nДадено е просто число p, ще има няколко заявки. За всяка заявка е дадено цяло число n,\nи трябва да изчислите стойността на n! ⊕ p, където n! е факториелът на n,\nт.е. произведението на всички положителни цели числа, по-малки или равни на n.\n\n@example\nf_33(3, 7); // връща 6", "zh": "编写一个 JavaScript 函数 `function f_33(n, p)` 来解决以下问题：\n这个问题引入了一种新的模运算，用符号“⊕”表示。\n计算 x ⊕ y 时，如果 x 不是 y 的倍数，结果是 x 除以 y 的余数。\n否则，重复将 x 除以 y，直到 x 不再是 y 的倍数，最终值记为 x'。\n然后结果是 x' 除以 y 的余数。\n例如，4⊕5=4，20⊕5=4，100⊕5=4。\n给定一个素数 p，会有若干查询。对于每个查询，给定一个整数 n，\n你需要计算 n! ⊕ p 的值，其中 n! 是 n 的阶乘，\n即小于或等于 n 的所有正整数的乘积。\n\n@example\nf_33(3, 7); // returns 6", "fr": "Écrire une fonction JavaScript `function f_33(n, p)` pour résoudre le problème suivant :\nCe problème introduit une nouvelle opération modulo, notée par le symbole \"⊕\".\nLors du calcul de x ⊕ y, si x n'est pas un multiple de y, le résultat est le reste de x divisé par y.\nSinon, divisez x par y de manière répétée jusqu'à ce que x ne soit plus un multiple de y, en désignant la valeur finale comme x'.\nEnsuite, le résultat est le reste de x' divisé par y.\nPar exemple, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nÉtant donné un nombre premier p, il y aura plusieurs requêtes. Pour chaque requête, un entier n est donné,\net vous devez calculer la valeur de n! ⊕ p, où n! est la factorielle de n,\nc'est-à-dire le produit de tous les entiers positifs inférieurs ou égaux à n.\n\n@example\nf_33(3, 7); // returns 6", "de": "Schreiben Sie eine JavaScript-Funktion `function f_33(n, p)`, um das folgende Problem zu lösen:\nDieses Problem führt eine neue Modulo-Operation ein, die durch das Symbol \"⊕\" dargestellt wird.\nBeim Berechnen von x ⊕ y, wenn x kein Vielfaches von y ist, ist das Ergebnis der Rest von x geteilt durch y.\nAndernfalls teilen Sie x wiederholt durch y, bis x kein Vielfaches von y mehr ist, und bezeichnen den Endwert als x'.\nDann ist das Ergebnis der Rest von x' geteilt durch y.\nZum Beispiel, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nGegeben eine Primzahl p, wird es mehrere Anfragen geben. Für jede Anfrage wird eine ganze Zahl n gegeben,\nund Sie müssen den Wert von n! ⊕ p berechnen, wobei n! die Fakultät von n ist,\nd.h. das Produkt aller positiven ganzen Zahlen kleiner oder gleich n.", "ha": "Rubuta aikin JavaScript `function f_33(n, p)` don warware matsalar mai zuwa:\nWannan matsalar tana gabatar da sabon aiki na modulo, wanda aka nuna da alamar \"⊕\".\nLokacin da ake lissafin x ⊕ y, idan x ba ya rabo da y, sakamakon shi ne saura na x raba da y.\nIn ba haka ba, raba x da y sau da yawa har sai x ba ya rabo da y, ana nuna ƙimar ƙarshe da x'.\nSa'an nan sakamakon shi ne saura na x' raba da y.\nMisali, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nAn ba da lamba mai lamba p, za a sami tambayoyi da yawa. Ga kowane tambaya, an ba da lamba n,\nkuma kuna buƙatar lissafin ƙimar n! ⊕ p, inda n! shine factorial na n,\nwato samfurin duk lambobin kirki ƙasa ko daidai da n.", "hi": "JavaScript फ़ंक्शन `function f_33(n, p)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nयह समस्या एक नए माड्यूलो ऑपरेशन को प्रस्तुत करती है, जिसे \"⊕\" प्रतीक द्वारा दर्शाया गया है।\nजब x ⊕ y की गणना की जाती है, यदि x, y का गुणज नहीं है, तो परिणाम x को y से विभाजित करने का शेषफल होता है।\nअन्यथा, x को y से बार-बार विभाजित करें जब तक कि x अब y का गुणज न हो, अंतिम मान को x' के रूप में दर्शाते हुए।\nफिर परिणाम x' को y से विभाजित करने का शेषफल होता है।\nउदाहरण के लिए, 4⊕5=4, 20⊕5=4, 100⊕5=4।\nदिए गए एक अभाज्य संख्या p के लिए, कई क्वेरीज़ होंगी। प्रत्येक क्वेरी के लिए, एक पूर्णांक n दिया गया है,\nऔर आपको n! ⊕ p का मान गणना करना है, जहाँ n! n का फैक्टोरियल है,\nअर्थात n से कम या बराबर सभी धनात्मक पूर्णांकों का गुणनफल।\n\n@example\nf_33(3, 7); // returns 6", "hu": "Írj egy JavaScript függvényt `function f_33(n, p)` a következő probléma megoldására:\nEz a probléma egy új modulo műveletet vezet be, amelyet a \"⊕\" szimbólum jelöl.\nAmikor x ⊕ y-t számítunk, ha x nem osztható y-nal, az eredmény x maradéka y-nal osztva.\nEgyébként osszuk el x-et y-nal ismételten, amíg x már nem osztható y-nal, és jelöljük a végső értéket x'-ként.\nEzután az eredmény x' maradéka y-nal osztva. \nPéldául, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nAdott egy prímszám p, több lekérdezés lesz. Minden lekérdezéshez adott egy egész szám n,\nés ki kell számítani az n! ⊕ p értékét, ahol n! az n faktoriálisa,\nazaz az összes pozitív egész szám szorzata, amely kisebb vagy egyenlő n-nél.\n\n@example\nf_33(3, 7); // returns 6", "es": "Escribe una función de JavaScript `function f_33(n, p)` para resolver el siguiente problema:\nEste problema introduce una nueva operación de módulo, denotada por el símbolo \"⊕\".\nAl calcular x ⊕ y, si x no es un múltiplo de y, el resultado es el resto de x dividido por y.\nDe lo contrario, divide x por y repetidamente hasta que x ya no sea un múltiplo de y, denotando el valor final como x'.\nEntonces el resultado es el resto de x' dividido por y.\nPor ejemplo, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nDado un número primo p, habrá varias consultas. Para cada consulta, se da un número entero n,\ny necesitas calcular el valor de n! ⊕ p, donde n! es el factorial de n,\nes decir, el producto de todos los enteros positivos menores o iguales a n.\n\n@example\nf_33(3, 7); // devuelve 6", "arb": "اكتب دالة JavaScript `function f_33(n, p)` لحل المشكلة التالية:\nتقدم هذه المشكلة عملية باقي جديدة، يرمز لها بالرمز \"⊕\".\nعند حساب x ⊕ y، إذا لم يكن x مضاعفًا لـ y، فإن النتيجة هي باقي قسمة x على y.\nوإلا، قم بقسمة x على y بشكل متكرر حتى لا يكون x مضاعفًا لـ y، مع الإشارة إلى القيمة النهائية كـ x'.\nثم تكون النتيجة هي باقي قسمة x' على y.\nعلى سبيل المثال، 4⊕5=4، 20⊕5=4، 100⊕5=4.\nبالنظر إلى عدد أولي p، سيكون هناك عدة استفسارات. لكل استفسار، يُعطى عدد صحيح n،\nوتحتاج إلى حساب قيمة n! ⊕ p، حيث n! هو مضروب n،\nأي حاصل ضرب جميع الأعداد الصحيحة الموجبة الأقل من أو تساوي n.\n\n@example\nf_33(3, 7); // يعيد 6", "sw": "Andika kazi ya JavaScript `function f_33(n, p)` kutatua tatizo lifuatalo:  \nTatizo hili linaanzisha operesheni mpya ya modulo, inayowakilishwa na alama \"⊕\".  \nWakati wa kuhesabu x ⊕ y, ikiwa x si kigezo cha y, matokeo ni mabaki ya x kugawanywa na y.  \nVinginevyo, gawanya x kwa y mara kwa mara hadi x isiwe tena kigezo cha y, ukionyesha thamani ya mwisho kama x'.  \nKisha matokeo ni mabaki ya x' kugawanywa na y.  \nKwa mfano, 4⊕5=4, 20⊕5=4, 100⊕5=4.  \nUkipatiwa nambari ya kwanza p, kutakuwa na maswali kadhaa. Kwa kila swali, nambari nzima n inapewa,  \nna unahitaji kuhesabu thamani ya n! ⊕ p, ambapo n! ni factorial ya n,  \nyaani, bidhaa ya nambari zote chanya zilizo chini au sawa na n.\n\n@example\nf_33(3, 7); // inarejesha 6", "tr": "Bir JavaScript fonksiyonu `function f_33(n, p)` yazın ve aşağıdaki problemi çözün:\nBu problem, \"⊕\" sembolüyle gösterilen yeni bir modül işlemi tanıtır.\nx ⊕ y hesaplanırken, eğer x, y'nin katı değilse, sonuç x'in y'ye bölümünden kalan olur.\nAksi takdirde, x artık y'nin katı olmayana kadar x'i y'ye tekrar tekrar bölün, son değeri x' olarak belirtin.\nDaha sonra sonuç, x' in y'ye bölümünden kalan olur.\nÖrneğin, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nVerilen bir asal sayı p için, birkaç sorgu olacaktır. Her sorgu için bir tamsayı n verilir\nve n! ⊕ p değerini hesaplamanız gerekir, burada n! n faktöriyelidir,\nyani n'den küçük veya eşit tüm pozitif tamsayıların çarpımıdır.\n\n@example\nf_33(3, 7); // 6 döndürür", "vi": "Viết một hàm JavaScript `function f_33(n, p)` để giải quyết vấn đề sau:\nVấn đề này giới thiệu một phép toán modulo mới, được ký hiệu bằng biểu tượng \"⊕\".\nKhi tính x ⊕ y, nếu x không phải là bội số của y, kết quả là phần dư của x chia cho y.\nNgược lại, chia x cho y liên tục cho đến khi x không còn là bội số của y, ký hiệu giá trị cuối cùng là x'.\nSau đó kết quả là phần dư của x' chia cho y.\nVí dụ, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nCho một số nguyên tố p, sẽ có một số truy vấn. Đối với mỗi truy vấn, một số nguyên n được cho,\nvà bạn cần tính giá trị của n! ⊕ p, trong đó n! là giai thừa của n,\ntức là tích của tất cả các số nguyên dương nhỏ hơn hoặc bằng n.\n\n@example\nf_33(3, 7); // trả về 6", "id": "Tulis sebuah fungsi JavaScript `function f_33(n, p)` untuk menyelesaikan masalah berikut:\nMasalah ini memperkenalkan operasi modulo baru, yang dilambangkan dengan simbol \"⊕\".\nKetika menghitung x ⊕ y, jika x bukan kelipatan dari y, hasilnya adalah sisa dari x dibagi y.\nJika tidak, bagi x dengan y berulang kali sampai x tidak lagi menjadi kelipatan dari y, menandai nilai akhir sebagai x'.\nKemudian hasilnya adalah sisa dari x' dibagi y.\nSebagai contoh, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nDiberikan sebuah bilangan prima p, akan ada beberapa kueri. Untuk setiap kueri, diberikan sebuah bilangan bulat n,\ndan Anda perlu menghitung nilai dari n! ⊕ p, di mana n! adalah faktorial dari n,\nyaitu hasil kali dari semua bilangan bulat positif yang kurang dari atau sama dengan n.\n\n@example\nf_33(3, 7); // mengembalikan 6", "ja": "JavaScript関数`function f_33(n, p)`を作成して、次の問題を解決してください：\nこの問題では、新しい剰余演算を導入します。この演算は記号\"⊕\"で表されます。\nx ⊕ yを計算する際、もしxがyの倍数でない場合、結果はxをyで割った余りです。\nそうでない場合、xをyで割り続け、xがもはやyの倍数でなくなるまで繰り返し、その最終的な値をx'とします。\nその後、結果はx'をyで割った余りです。\n例えば、4⊕5=4, 20⊕5=4, 100⊕5=4です。\n素数pが与えられたとき、いくつかのクエリがあります。各クエリに対して、整数nが与えられ、\nn! ⊕ pの値を計算する必要があります。ここでn!はnの階乗であり、\nすなわちn以下のすべての正の整数の積です。\n\n@example\nf_33(3, 7); // returns 6", "ko": "JavaScript 함수 `function f_33(n, p)`를 작성하여 다음 문제를 해결하십시오:\n이 문제는 \"⊕\" 기호로 표시되는 새로운 모듈로 연산을 도입합니다.\nx ⊕ y를 계산할 때, x가 y의 배수가 아니면 결과는 x를 y로 나눈 나머지입니다.\n그렇지 않으면, x가 더 이상 y의 배수가 아닐 때까지 x를 y로 반복해서 나누고, 최종 값을 x'로 표시합니다.\n그런 다음 결과는 x'를 y로 나눈 나머지입니다.\n예를 들어, 4⊕5=4, 20⊕5=4, 100⊕5=4입니다.\n소수 p가 주어지면 여러 쿼리가 있을 것입니다. 각 쿼리에 대해 정수 n이 주어지고,\nn! ⊕ p의 값을 계산해야 합니다. 여기서 n!은 n의 팩토리얼로,\nn 이하의 모든 양의 정수의 곱입니다.\n\n@example\nf_33(3, 7); // returns 6", "ml": "JavaScript ഫംഗ്ഷൻ `function f_33(n, p)` എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nഈ പ്രശ്നം ഒരു പുതിയ മോഡുലോ ഓപ്പറേഷൻ അവതരിപ്പിക്കുന്നു, \"⊕\" എന്ന ചിഹ്നം ഉപയോഗിച്ച് സൂചിപ്പിക്കുന്നു.\nx ⊕ y കണക്കാക്കുമ്പോൾ, x y-ന്റെ ഗുണിതമല്ലെങ്കിൽ, x y-ൽ വിഭജിച്ച ശേഷമുള്ള ശേഷിപ്പാണ് ഫലം.\nഇല്ലെങ്കിൽ, x y-ൽ വിഭജിക്കുമ്പോൾ x y-ന്റെ ഗുണിതമല്ലാത്തതുവരെ x-നെ പുനഃപുനഃ വിഭജിക്കുക, അന്തിമ മൂല്യം x' ആയി സൂചിപ്പിക്കുക.\nഅപ്പോൾ ഫലം x' y-ൽ വിഭജിച്ച ശേഷമുള്ള ശേഷിപ്പാണ്. \nഉദാഹരണത്തിന്, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nഒരു പ്രധാന സംഖ്യ p നൽകിയാൽ, നിരവധി ക്വറികൾ ഉണ്ടാകും. ഓരോ ക്വറിയിനും, ഒരു പൂർണ്ണസംഖ്യ n നൽകപ്പെടും,\nനിങ്ങൾ n! ⊕ p-ന്റെ മൂല്യം കണക്കാക്കണം, n! എന്നത് n-ൽ കുറവോ തുല്യമോ ആയ എല്ലാ ധനാത്മക പൂർണ്ണസംഖ്യകളുടെ ഗുണിതമാണ്.\n\n@example\nf_33(3, 7); // returns 6", "fa": "یک تابع جاوااسکریپت `function f_33(n, p)` بنویسید تا مسئله زیر را حل کند:\nاین مسئله یک عملگر جدید باقیمانده را معرفی می‌کند که با نماد \"⊕\" نشان داده می‌شود.\nهنگام محاسبه x ⊕ y، اگر x مضربی از y نباشد، نتیجه باقیمانده x تقسیم بر y است.\nدر غیر این صورت، x را به طور مکرر بر y تقسیم کنید تا زمانی که x دیگر مضربی از y نباشد، و مقدار نهایی را به عنوان x' نشان دهید.\nسپس نتیجه باقیمانده x' تقسیم بر y است.\nبرای مثال، 4⊕5=4، 20⊕5=4، 100⊕5=4.\nبا توجه به یک عدد اول p، چندین پرسش وجود خواهد داشت. برای هر پرسش، یک عدد صحیح n داده می‌شود،\nو شما باید مقدار n! ⊕ p را محاسبه کنید، که در آن n! فاکتوریل n است،\nیعنی حاصل‌ضرب تمام اعداد صحیح مثبت کمتر یا مساوی n.\n\n@example\nf_33(3, 7); // returns 6"}, "level": "easy", "test": "(function testf_33() {\n    console.assert(f_33(3, 7) === 6, 'Test at n=3, p=7 failed');\n    console.assert(f_33(10, 3) === 1, 'Test at n=10, p=3 failed');\n    console.assert(f_33(11, 7) === 4, 'Test at n=11, p=7 failed');\n    console.assert(f_33(45, 7) === 1, 'Test at n=45, p=7 failed');\n    console.assert(f_33(14, 7) === 2, 'Test at n=14, p=7 failed');\n    console.assert(f_33(1919, 10007) === 3152, 'Test at n=1919, p=10007 failed');\n    console.assert(f_33(810, 10007) === 3679, 'Test at n=810, p=10007 failed');\n    console.assert(f_33(1, 2) === 1, 'Test at n=1, p=2 failed');\n    console.assert(f_33(5, 11) === 10, 'Test at n=5, p=11 failed');\n    console.assert(f_33(6, 13) === 5, 'Test at n=6, p=13 failed');\n    console.assert(f_33(8, 17) === 13, 'Test at n=8, p=17 failed');\n    console.assert(f_33(15, 19) === 16, 'Test at n=15, p=19 failed');\n    console.assert(f_33(21, 23) === 1, 'Test at n=21, p=23 failed');\n    console.assert(f_33(30, 29) === 28, 'Test at n=30, p=29 failed');\n    console.assert(f_33(100, 101) === 100, 'Test at n=100, p=101 failed');\n})();", "entry_point": "f_33", "signature": "function f_33(n, p)", "docstring": {"en": "This problem introduces a new modulo operation, denoted by the symbol \"⊕\".\nWhen calculating x ⊕ y, if x is not a multiple of y, the result is the remainder of x divided by y.\nOtherwise, divide x by y repeatedly until x is no longer a multiple of y, denoting the final value as x'.\nThen the result is the remainder of x' divided by y. \nFor example, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nGiven a prime number p, there will be several queries. For each query, an integer n is given,\nand you need to compute the value of n! ⊕ p, where n! is the factorial of n,\ni.e. the product of all positive integers less than or equal to n.\n\n@example\nf_33(3, 7); // returns 6\n", "sq": "Ky problem prezanton një operacion të ri modulo, i shënuar me simbolin \"⊕\".  \nKur llogarit x ⊕ y, nëse x nuk është shumëfish i y, rezultati është mbetja e x e ndarë me y.  \nPërndryshe, ndaj x me y vazhdimisht derisa x të mos jetë më shumëfish i y, duke e shënuar vlerën përfundimtare si x'.  \nPastaj rezultati është mbetja e x' e ndarë me y.  \nPër shembull, 4⊕5=4, 20⊕5=4, 100⊕5=4.  \nDuke pasur një numër të plotë p, do të ketë disa kërkesa. Për çdo kërkesë, jepet një numër i plotë n,  \ndhe ju duhet të llogaritni vlerën e n! ⊕ p, ku n! është faktoriali i n,  \ndmth. prodhimi i të gjithë numrave të plotë pozitivë më të vegjël ose të barabartë me n.\n\n@example\nf_33(3, 7); // kthen 6", "hy": "Այս խնդիրը ներկայացնում է նոր մոդուլո գործողություն, որը նշվում է \"⊕\" նշանով։ \nԵրբ հաշվարկում ենք x ⊕ y, եթե x-ը y-ի բազմապատիկ չէ, արդյունքը x-ի y-ի բաժանումից մնացորդն է։ \nՀակառակ դեպքում, բաժանեք x-ը y-ի վրա կրկնվող կերպով, մինչև x-ը այլևս y-ի բազմապատիկ չլինի, վերջնական արժեքը նշելով որպես x'։ \nԱյնուհետև արդյունքը x'-ի y-ի բաժանումից մնացորդն է։ \nՕրինակ, 4⊕5=4, 20⊕5=4, 100⊕5=4։ \nՏրված է p պարզ թիվ, և կլինեն մի քանի հարցումներ։ Յուրաքանչյուր հարցման համար տրված է n ամբողջ թիվը,\nև դուք պետք է հաշվարկեք n! ⊕ p արժեքը, որտեղ n! n-ի ֆակտորիալն է,\nայսինքն՝ բոլոր դրական ամբողջ թվերի արտադրյալը, որոնք փոքր կամ հավասար են n-ին։\n\n@example\nf_33(3, 7); // վերադարձնում է 6", "bn": "এই সমস্যাটি একটি নতুন মডুলো অপারেশন পরিচয় করিয়ে দেয়, যা \"⊕\" প্রতীক দ্বারা চিহ্নিত করা হয়। \nযখন x ⊕ y গণনা করা হয়, যদি x, y এর গুণিতক না হয়, তাহলে ফলাফল হয় x কে y দিয়ে ভাগ করলে যে অবশিষ্ট থাকে তা। \nঅন্যথায়, x কে y দিয়ে বারবার ভাগ করুন যতক্ষণ না x আর y এর গুণিতক থাকে, চূড়ান্ত মানটিকে x' হিসাবে চিহ্নিত করুন। \nতারপর ফলাফল হয় x' কে y দিয়ে ভাগ করলে যে অবশিষ্ট থাকে তা। \nউদাহরণস্বরূপ, 4⊕5=4, 20⊕5=4, 100⊕5=4।\nএকটি মৌলিক সংখ্যা p দেওয়া হলে, বেশ কয়েকটি প্রশ্ন থাকবে। প্রতিটি প্রশ্নের জন্য, একটি পূর্ণসংখ্যা n দেওয়া হয়,\nএবং আপনাকে n! ⊕ p এর মান গণনা করতে হবে, যেখানে n! হল n এর ফ্যাক্টোরিয়াল,\nঅর্থাৎ n এর সমান বা তার চেয়ে ছোট সব ধনাত্মক পূর্ণসংখ্যার গুণফল।\n\n@example\nf_33(3, 7); // returns 6", "bg": "Този проблем въвежда нова операция модуло, обозначена със символа \"⊕\". \nКогато се изчислява x ⊕ y, ако x не е кратно на y, резултатът е остатъкът от x, разделен на y. \nВ противен случай, разделяйте x на y многократно, докато x вече не е кратно на y, като обозначите крайната стойност като x'. \nТогава резултатът е остатъкът от x', разделен на y. \nНапример, 4⊕5=4, 20⊕5=4, 100⊕5=4. \nДадено е просто число p, ще има няколко запитвания. За всяко запитване е дадено цяло число n, \nи трябва да изчислите стойността на n! ⊕ p, където n! е факториелът на n, \nт.е. произведението на всички положителни цели числа, по-малки или равни на n.\n\n@пример\nf_33(3, 7); // връща 6", "zh": "这个问题引入了一种新的模运算，用符号“⊕”表示。\n当计算 x ⊕ y 时，如果 x 不是 y 的倍数，结果是 x 除以 y 的余数。\n否则，重复将 x 除以 y，直到 x 不再是 y 的倍数，将最终值记为 x'。\n然后结果是 x' 除以 y 的余数。\n例如，4⊕5=4，20⊕5=4，100⊕5=4。\n给定一个素数 p，会有若干查询。对于每个查询，给定一个整数 n，\n你需要计算 n! ⊕ p 的值，其中 n! 是 n 的阶乘，\n即小于或等于 n 的所有正整数的乘积。\n\n@example\nf_33(3, 7); // returns 6", "fr": "Ce problème introduit une nouvelle opération modulo, notée par le symbole \"⊕\".\nLors du calcul de x ⊕ y, si x n'est pas un multiple de y, le résultat est le reste de x divisé par y.\nSinon, divisez x par y à plusieurs reprises jusqu'à ce que x ne soit plus un multiple de y, en notant la valeur finale comme x'.\nEnsuite, le résultat est le reste de x' divisé par y.\nPar exemple, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nÉtant donné un nombre premier p, il y aura plusieurs requêtes. Pour chaque requête, un entier n est donné,\net vous devez calculer la valeur de n! ⊕ p, où n! est la factorielle de n,\nc'est-à-dire le produit de tous les entiers positifs inférieurs ou égaux à n.\n\n@example\nf_33(3, 7); // returns 6", "de": "Diese Aufgabe führt eine neue Modulo-Operation ein, die durch das Symbol \"⊕\" dargestellt wird.\nBei der Berechnung von x ⊕ y, wenn x kein Vielfaches von y ist, ist das Ergebnis der Rest von x geteilt durch y.\nAndernfalls wird x wiederholt durch y geteilt, bis x kein Vielfaches von y mehr ist, wobei der Endwert als x' bezeichnet wird.\nDann ist das Ergebnis der Rest von x' geteilt durch y.\nZum Beispiel, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nGegeben eine Primzahl p, wird es mehrere Anfragen geben. Für jede Anfrage wird eine ganze Zahl n gegeben,\nund Sie müssen den Wert von n! ⊕ p berechnen, wobei n! die Fakultät von n ist,\nd.h. das Produkt aller positiven ganzen Zahlen, die kleiner oder gleich n sind.\n\n@example\nf_33(3, 7); // gibt 6 zurück", "ha": "Wannan matsalar tana gabatar da sabon aikin modulo, wanda aka nuna da alamar \"⊕\".\nLokacin da ake lissafin x ⊕ y, idan x ba ya raba y ba tare da saura ba, sakamakon shi ne saura na x raba da y.\nIn ba haka ba, a raba x da y a kai a kai har sai x ya daina raba y ba tare da saura ba, ana nuna ƙimar ƙarshe a matsayin x'.\nSannan sakamakon shi ne saura na x' raba da y.\nMisali, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nAn ba da lamba mai firam p, za a sami tambayoyi da yawa. Ga kowane tambaya, an ba da cikakken lamba n,\nkuma kuna buƙatar lissafin ƙimar n! ⊕ p, inda n! shine factorial na n,\nwato samfurin duk lambobin da suka fi ko daidai da n.\n\n@example\nf_33(3, 7); // returns 6", "hi": "इस समस्या में एक नया माड्यूलो ऑपरेशन प्रस्तुत किया गया है, जिसे प्रतीक \"⊕\" द्वारा दर्शाया गया है। \nजब x ⊕ y की गणना की जाती है, यदि x, y का गुणज नहीं है, तो परिणाम x को y से विभाजित करने पर शेषफल होता है। \nअन्यथा, x को y से बार-बार विभाजित करें जब तक कि x अब y का गुणज न हो, अंतिम मान को x' के रूप में दर्शाते हुए। \nतब परिणाम x' को y से विभाजित करने पर शेषफल होता है। \nउदाहरण के लिए, 4⊕5=4, 20⊕5=4, 100⊕5=4। \nएक अभाज्य संख्या p दी गई है, कई क्वेरीज़ होंगी। प्रत्येक क्वेरी के लिए, एक पूर्णांक n दिया गया है, \nऔर आपको n! ⊕ p का मान गणना करने की आवश्यकता है, जहाँ n! n का फैक्टोरियल है, \nअर्थात n से कम या उसके बराबर सभी धनात्मक पूर्णांकों का गुणनफल।\n\n@example\nf_33(3, 7); // 6 लौटाता है", "hu": "Ez a probléma bevezet egy új modulo műveletet, amelyet a \"⊕\" szimbólum jelöl.\nAmikor az x ⊕ y értéket számítjuk ki, ha x nem osztható maradék nélkül y-nal, az eredmény x osztva y maradéka.\nEgyébként osszuk el x-et y-nal ismételten, amíg x már nem osztható maradék nélkül y-nal, az utolsó értéket x'-ként jelölve.\nEzután az eredmény x' osztva y maradéka. \nPéldául, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nAdott egy prímszám p, több lekérdezés lesz. Minden lekérdezéshez adott egy egész szám n,\nés ki kell számítani az n! ⊕ p értékét, ahol n! az n faktoriálisa,\nazaz az összes pozitív egész szám szorzata, amely kisebb vagy egyenlő n-nel.\n\n@example\nf_33(3, 7); // visszaadja 6", "es": "Este problema introduce una nueva operación de módulo, denotada por el símbolo \"⊕\". \nAl calcular x ⊕ y, si x no es un múltiplo de y, el resultado es el resto de x dividido por y. \nDe lo contrario, divide x por y repetidamente hasta que x ya no sea un múltiplo de y, denotando el valor final como x'. \nEntonces, el resultado es el resto de x' dividido por y. \nPor ejemplo, 4⊕5=4, 20⊕5=4, 100⊕5=4. \nDado un número primo p, habrá varias consultas. Para cada consulta, se da un número entero n, \ny necesitas calcular el valor de n! ⊕ p, donde n! es el factorial de n, \nes decir, el producto de todos los enteros positivos menores o iguales a n.\n\n@example\nf_33(3, 7); // devuelve 6", "arb": "هذه المسألة تقدم عملية جديدة للمودولو، يرمز لها بالرمز \"⊕\". عند حساب x ⊕ y، إذا لم يكن x مضاعفًا لـ y، فإن النتيجة هي باقي قسمة x على y. وإلا، قم بقسمة x على y بشكل متكرر حتى لا يكون x مضاعفًا لـ y، مع تحديد القيمة النهائية كـ x'. ثم تكون النتيجة هي باقي قسمة x' على y. على سبيل المثال، 4⊕5=4، 20⊕5=4، 100⊕5=4. بالنظر إلى عدد أولي p، سيكون هناك عدة استفسارات. لكل استفسار، يُعطى عدد صحيح n، وتحتاج إلى حساب قيمة n! ⊕ p، حيث n! هو مضروب n، أي حاصل ضرب جميع الأعداد الصحيحة الموجبة الأقل من أو تساوي n.\n\n@example\nf_33(3, 7); // يعيد 6", "sw": "Tatizo hili linaanzisha operesheni mpya ya modulo, inayojulikana kwa alama \"⊕\". Wakati wa kuhesabu x ⊕ y, ikiwa x si kigezo cha y, matokeo ni baki ya x iliyogawanywa na y. Vinginevyo, gawanya x kwa y mara kwa mara hadi x isiwe tena kigezo cha y, ukionyesha thamani ya mwisho kama x'. Kisha matokeo ni baki ya x' iliyogawanywa na y. Kwa mfano, 4⊕5=4, 20⊕5=4, 100⊕5=4. Ukipewa nambari ya kwanza p, kutakuwa na maswali kadhaa. Kwa kila swali, nambari kamili n inatolewa, na unahitaji kuhesabu thamani ya n! ⊕ p, ambapo n! ni factorial ya n, yaani, ni bidhaa ya nambari zote kamili chanya zilizo chini au sawa na n.\n\n@example\nf_33(3, 7); // inarudisha 6", "tr": "Bu problem, \"⊕\" sembolü ile gösterilen yeni bir modül işlemi tanıtmaktadır.\nx ⊕ y hesaplanırken, eğer x, y'nin katı değilse, sonuç x'in y'ye bölünmesinden kalan değerdir.\nAksi takdirde, x artık y'nin katı olmayana kadar x'i y'ye tekrar tekrar bölün, son değeri x' olarak belirtin.\nSonuç, x' in y'ye bölünmesinden kalan değerdir.\nÖrneğin, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nVerilen bir asal sayı p için birkaç sorgu olacaktır. Her sorgu için bir tamsayı n verilir\nve n! ⊕ p değerini hesaplamanız gerekir, burada n! n'nin faktöriyelidir,\nyani n'ye eşit veya daha küçük olan tüm pozitif tamsayıların çarpımıdır.\n\n@example\nf_33(3, 7); // 6 döndürür", "vi": "Vấn đề này giới thiệu một phép toán modulo mới, được ký hiệu bằng biểu tượng \"⊕\". Khi tính toán x ⊕ y, nếu x không phải là bội số của y, kết quả là phần dư của x chia cho y. Ngược lại, chia x cho y liên tục cho đến khi x không còn là bội số của y, ký hiệu giá trị cuối cùng là x'. Sau đó kết quả là phần dư của x' chia cho y. Ví dụ, 4⊕5=4, 20⊕5=4, 100⊕5=4. Cho một số nguyên tố p, sẽ có một số truy vấn. Đối với mỗi truy vấn, một số nguyên n được cho, và bạn cần tính giá trị của n! ⊕ p, trong đó n! là giai thừa của n, tức là tích của tất cả các số nguyên dương nhỏ hơn hoặc bằng n.\n\n@example\nf_33(3, 7); // trả về 6", "id": "Masalah ini memperkenalkan operasi modulo baru, yang dilambangkan dengan simbol \"⊕\". Ketika menghitung x ⊕ y, jika x bukan kelipatan dari y, hasilnya adalah sisa dari x dibagi y. Jika tidak, bagi x dengan y berulang kali sampai x tidak lagi menjadi kelipatan dari y, yang menandakan nilai akhir sebagai x'. Kemudian hasilnya adalah sisa dari x' dibagi y. Sebagai contoh, 4⊕5=4, 20⊕5=4, 100⊕5=4. Diberikan sebuah bilangan prima p, akan ada beberapa kueri. Untuk setiap kueri, diberikan sebuah bilangan bulat n, dan Anda perlu menghitung nilai dari n! ⊕ p, di mana n! adalah faktorial dari n, yaitu hasil kali dari semua bilangan bulat positif yang kurang dari atau sama dengan n.\n\n@example\nf_33(3, 7); // mengembalikan 6", "ja": "この問題では、新しい剰余演算「⊕」を導入します。\nx ⊕ y を計算する際、x が y の倍数でない場合、結果は x を y で割った余りです。\nそうでない場合、x を y で割り続け、x がもはや y の倍数でなくなるまで繰り返し、その最終的な値を x' とします。\nその後、結果は x' を y で割った余りです。\n例えば、4⊕5=4、20⊕5=4、100⊕5=4 です。\n素数 p が与えられ、いくつかのクエリがあります。各クエリでは整数 n が与えられ、\nn! ⊕ p の値を計算する必要があります。ここで n! は n の階乗であり、\nn 以下のすべての正の整数の積です。\n\n@example\nf_33(3, 7); // returns 6", "ko": "이 문제는 \"⊕\" 기호로 표시되는 새로운 모듈로 연산을 소개합니다. \nx ⊕ y를 계산할 때, x가 y의 배수가 아니면 결과는 x를 y로 나눈 나머지입니다. \n그렇지 않으면, x가 더 이상 y의 배수가 아닐 때까지 x를 y로 반복해서 나누고, 최종 값을 x'로 표시합니다. \n그런 다음 결과는 x'를 y로 나눈 나머지입니다. \n예를 들어, 4⊕5=4, 20⊕5=4, 100⊕5=4입니다. \n소수 p가 주어지면, 여러 쿼리가 있을 것입니다. 각 쿼리마다 정수 n이 주어지며, \nn! ⊕ p의 값을 계산해야 합니다. 여기서 n!은 n의 팩토리얼, 즉 n 이하의 모든 양의 정수의 곱입니다.\n\n@example\nf_33(3, 7); // returns 6", "ml": "ഈ പ്രശ്നം \"⊕\" എന്ന ചിഹ്നം ഉപയോഗിച്ച് ഒരു പുതിയ മോഡുലോ ഓപ്പറേഷൻ അവതരിപ്പിക്കുന്നു. \nx ⊕ y കണക്കാക്കുമ്പോൾ, x y-ന്റെ ഗുണിതമല്ലെങ്കിൽ, ഫലം x y-ൽ വിഭജിച്ച ശേഷമുള്ള ശേഷിപ്പാണ്. \nഇല്ലെങ്കിൽ, x y-ൽ വീണ്ടും വീണ്ടും വിഭജിക്കുക, x y-ന്റെ ഗുണിതമല്ലാത്തതുവരെ, അന്തിമ മൂല്യം x' ആയി സൂചിപ്പിക്കുക. \nഅപ്പോൾ ഫലം x' y-ൽ വിഭജിച്ച ശേഷമുള്ള ശേഷിപ്പാണ്. \nഉദാഹരണത്തിന്, 4⊕5=4, 20⊕5=4, 100⊕5=4. \nഒരു പ്രധാന സംഖ്യയായ p നൽകിയാൽ, നിരവധി ചോദ്യങ്ങൾ ഉണ്ടാകും. ഓരോ ചോദ്യത്തിനും, ഒരു പൂർണ്ണസംഖ്യ n നൽകപ്പെടുന്നു, \nനിങ്ങൾക്ക് n! ⊕ p-ന്റെ മൂല്യം കണക്കാക്കേണ്ടതുണ്ട്, n! എന്നത് n-നേക്കാൾ ചെറിയതോ തുല്യമായതോ ആയ എല്ലാ അനുകൂല പൂർണ്ണസംഖ്യകളുടെ ഗുണിതമാണ്.\n\n@example\nf_33(3, 7); // 6 മടക്കുന്നു", "fa": "این مسئله یک عملگر جدید به نام \"⊕\" را معرفی می‌کند.  \nهنگام محاسبه x ⊕ y، اگر x مضربی از y نباشد، نتیجه باقی‌مانده تقسیم x بر y است.  \nدر غیر این صورت، x را به طور مکرر بر y تقسیم کنید تا زمانی که x دیگر مضربی از y نباشد، مقدار نهایی را به عنوان x' نشان دهید.  \nسپس نتیجه باقی‌مانده تقسیم x' بر y است.  \nبرای مثال، 4⊕5=4، 20⊕5=4، 100⊕5=4.  \nبا توجه به یک عدد اول p، چندین پرسش وجود خواهد داشت. برای هر پرسش، یک عدد صحیح n داده می‌شود،  \nو شما باید مقدار n! ⊕ p را محاسبه کنید، جایی که n! فاکتوریل n است،  \nیعنی حاصل‌ضرب تمام اعداد صحیح مثبت کمتر یا مساوی n.\n\n@example\nf_33(3, 7); // returns 6"}}
{"task_id": "JavaScript/34", "prompt": {"en": "/**\n * You are given an array a of n integers. You can perform at most one operation where\n * you select three integers i, j, x (1 <= i <= j <= n) and replace all elements from a[i] to a[j]\n * with x, at a cost of (j - i + 1).\n * Find the minimum cost to make all elements in the array equal.\n */\nfunction f_34(n, a)", "sq": "/**\n * Ju jepet një varg a me n numra të plotë. Ju mund të kryeni maksimumi një operacion ku\n * zgjidhni tre numra të plotë i, j, x (1 <= i <= j <= n) dhe zëvendësoni të gjitha elementet nga a[i] në a[j]\n * me x, me një kosto prej (j - i + 1).\n * Gjeni koston minimale për të bërë të gjitha elementet në varg të barabarta.\n */\nfunction f_34(n, a)", "hy": "/**\n * Ձեզ տրված է n ամբողջ թվերի զանգված a։ Դուք կարող եք կատարել առավելագույնը մեկ գործողություն, որտեղ\n * ընտրում եք երեք ամբողջ թվեր i, j, x (1 <= i <= j <= n) և փոխարինում եք a[i]-ից a[j] բոլոր տարրերը\n * x-ով, արժեքով (j - i + 1)։\n * Գտեք նվազագույն արժեքը, որպեսզի զանգվածի բոլոր տարրերը դառնան հավասար։\n */\nfunction f_34(n, a)", "bn": "/**\n * আপনাকে n পূর্ণসংখ্যার একটি অ্যারে a দেওয়া হয়েছে। আপনি সর্বাধিক একটি অপারেশন করতে পারেন যেখানে\n * আপনি তিনটি পূর্ণসংখ্যা i, j, x (1 <= i <= j <= n) নির্বাচন করেন এবং a[i] থেকে a[j] পর্যন্ত সমস্ত উপাদানকে\n * x দিয়ে প্রতিস্থাপন করেন, যার খরচ (j - i + 1)।\n * অ্যারের সমস্ত উপাদান সমান করতে ন্যূনতম খরচ খুঁজে বের করুন।\n */\nfunction f_34(n, a)", "bg": "/**\n * Даден ви е масив a от n цели числа. Можете да извършите най-много една операция, при която\n * избирате три цели числа i, j, x (1 <= i <= j <= n) и заменяте всички елементи от a[i] до a[j]\n * с x, на цена (j - i + 1).\n * Намерете минималната цена, за да направите всички елементи в масива равни.\n */\nfunction f_34(n, a)", "zh": "/**\n * 给定一个由 n 个整数组成的数组 a。你最多可以执行一次操作，\n * 在该操作中你选择三个整数 i, j, x (1 <= i <= j <= n)，并将从 a[i] 到 a[j] 的所有元素替换为 x，\n * 其代价为 (j - i + 1)。\n * 找出使数组中所有元素相等的最小代价。\n */\nfunction f_34(n, a)", "fr": "/**\n * Vous avez un tableau a de n entiers. Vous pouvez effectuer au plus une opération où\n * vous sélectionnez trois entiers i, j, x (1 <= i <= j <= n) et remplacez tous les éléments de a[i] à a[j]\n * par x, à un coût de (j - i + 1).\n * Trouvez le coût minimum pour rendre tous les éléments du tableau égaux.\n */\nfunction f_34(n, a)", "de": "/**\n * Sie haben ein Array a mit n ganzen Zahlen. Sie können höchstens eine Operation ausführen, bei der\n * Sie drei ganze Zahlen i, j, x (1 <= i <= j <= n) auswählen und alle Elemente von a[i] bis a[j]\n * mit x ersetzen, zu Kosten von (j - i + 1).\n * Finden Sie die minimalen Kosten, um alle Elemente im Array gleich zu machen.\n */\nfunction f_34(n, a)", "ha": "/**\n * An ba ku wani jerin lambobi a na n. Kuna iya yin aiki guda ɗaya kawai inda\n * za ku zaɓi lambobi uku i, j, x (1 <= i <= j <= n) kuma ku maye gurbin dukkan abubuwa daga a[i] zuwa a[j]\n * da x, a kan farashi na (j - i + 1).\n * Nemo mafi ƙarancin farashi don sanya dukkan abubuwa a cikin jerin su zama daidai.\n */\nfunction f_34(n, a)", "hi": "/**\n * आपको n पूर्णांकों का एक array a दिया गया है। आप अधिकतम एक ऑपरेशन कर सकते हैं जहाँ\n * आप तीन पूर्णांक i, j, x (1 <= i <= j <= n) चुनते हैं और a[i] से a[j] तक के सभी तत्वों को\n * x से बदल देते हैं, जिसकी लागत (j - i + 1) होती है।\n * सभी तत्वों को array में समान बनाने की न्यूनतम लागत खोजें।\n */\nfunction f_34(n, a)", "hu": "/**\n * Adott egy n egész számot tartalmazó tömb, a. Legfeljebb egy műveletet hajthatsz végre, ahol\n * kiválasztasz három egész számot i, j, x (1 <= i <= j <= n), és az a[i] és a[j] közötti összes elemet\n * kicseréled x-re, (j - i + 1) költséggel.\n * Találd meg a minimális költséget, hogy az összes elem a tömbben egyenlő legyen.\n */\nfunction f_34(n, a)", "es": "/**\n * Se te da un array a de n enteros. Puedes realizar como máximo una operación donde\n * seleccionas tres enteros i, j, x (1 <= i <= j <= n) y reemplazas todos los elementos desde a[i] hasta a[j]\n * con x, a un costo de (j - i + 1).\n * Encuentra el costo mínimo para hacer que todos los elementos en el array sean iguales.\n */\nfunction f_34(n, a)", "arb": "/**\n * لديك مصفوفة a تحتوي على n عدد صحيح. يمكنك تنفيذ عملية واحدة على الأكثر حيث\n * تختار ثلاثة أعداد صحيحة i, j, x (1 <= i <= j <= n) وتستبدل جميع العناصر من a[i] إلى a[j]\n * بـ x، بتكلفة (j - i + 1).\n * ابحث عن الحد الأدنى للتكلفة لجعل جميع العناصر في المصفوفة متساوية.\n */\nfunction f_34(n, a)", "sw": "/**\n * Umepewa safu a ya n nambari za mzima. Unaweza kufanya operesheni moja tu ambapo\n * unachagua nambari tatu i, j, x (1 <= i <= j <= n) na kubadilisha vipengele vyote kutoka a[i] hadi a[j]\n * na x, kwa gharama ya (j - i + 1).\n * Pata gharama ya chini kabisa ya kufanya vipengele vyote katika safu kuwa sawa.\n */\nfunction f_34(n, a)", "tr": "/**\n * Size n olan bir tamsayı dizisi verilmektedir. En fazla bir işlem gerçekleştirebilirsiniz; bu işlemde\n * i, j, x (1 <= i <= j <= n) üç tamsayısını seçip a[i] ile a[j] arasındaki tüm elemanları\n * x ile değiştirebilirsiniz, bu işlemin maliyeti (j - i + 1) olacaktır.\n * Dizideki tüm elemanları eşit hale getirmek için minimum maliyeti bulun.\n */\nfunction f_34(n, a)", "vi": "/**\n * Bạn được cung cấp một mảng a gồm n số nguyên. Bạn có thể thực hiện tối đa một thao tác\n * trong đó bạn chọn ba số nguyên i, j, x (1 <= i <= j <= n) và thay thế tất cả các phần tử từ a[i] đến a[j]\n * bằng x, với chi phí là (j - i + 1).\n * Tìm chi phí tối thiểu để làm cho tất cả các phần tử trong mảng bằng nhau.\n */\nfunction f_34(n, a)", "id": "/**\n * Anda diberikan sebuah array a yang terdiri dari n bilangan bulat. Anda dapat melakukan paling banyak satu operasi di mana\n * Anda memilih tiga bilangan bulat i, j, x (1 <= i <= j <= n) dan mengganti semua elemen dari a[i] hingga a[j]\n * dengan x, dengan biaya sebesar (j - i + 1).\n * Temukan biaya minimum untuk membuat semua elemen dalam array menjadi sama.\n */\nfunction f_34(n, a)", "ja": "/**\n * 配列aがn個の整数で与えられます。次の操作を高々1回行うことができます。\n * 3つの整数i, j, x (1 <= i <= j <= n) を選び、a[i]からa[j]までのすべての要素をxに置き換えます。\n * その際のコストは(j - i + 1)です。\n * 配列内のすべての要素を等しくするための最小コストを求めてください。\n */\nfunction f_34(n, a)", "ko": "/**\n * 정수 n개의 배열 a가 주어집니다. 최대 한 번의 연산을 수행할 수 있으며,\n * 세 정수 i, j, x (1 <= i <= j <= n)를 선택하여 a[i]부터 a[j]까지의 모든 요소를\n * x로 대체할 수 있으며, 비용은 (j - i + 1)입니다.\n * 배열의 모든 요소를 동일하게 만드는 최소 비용을 찾으세요.\n */\nfunction f_34(n, a)", "ml": "/**\n * നിങ്ങൾക്ക് n പൂർണ്ണസംഖ്യകളുടെ ഒരു നിര a നൽകിയിരിക്കുന്നു. \n * നിങ്ങൾക്ക് പരമാവധി ഒരു പ്രവർത്തനം നടത്താം, \n * അവിടെ നിങ്ങൾ മൂന്ന് പൂർണ്ണസംഖ്യകൾ i, j, x (1 <= i <= j <= n) തിരഞ്ഞെടുക്കുകയും \n * a[i] മുതൽ a[j] വരെയുള്ള എല്ലാ ഘടകങ്ങളും x-ൽ മാറ്റിസ്ഥാപിക്കുകയും ചെയ്യാം, \n * (j - i + 1) എന്ന ചെലവിൽ.\n * നിരയിലെ എല്ലാ ഘടകങ്ങളും തുല്യമായാക്കുന്നതിനുള്ള കുറഞ്ഞ ചെലവ് കണ്ടെത്തുക.\n */\nfunction f_34(n, a)", "fa": "/**\n * شما یک آرایه a از n عدد صحیح دارید. شما می‌توانید حداکثر یک عملیات انجام دهید که در آن\n * سه عدد صحیح i، j، x (1 <= i <= j <= n) را انتخاب کرده و تمام عناصر از a[i] تا a[j]\n * را با x جایگزین کنید، با هزینه (j - i + 1).\n * حداقل هزینه برای برابر کردن تمام عناصر در آرایه را پیدا کنید.\n */\nfunction f_34(n, a)"}, "canonical_solution": "{\n    let j = 0, p = 1, q = 0, c, d;\n    let k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] !== a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] !== a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] !== a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] !== a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}", "instruction": {"en": "Write a JavaScript function `function f_34(n, a)` to solve the following problem:\nYou are given an array a of n integers. You can perform at most one operation where\nyou select three integers i, j, x (1 <= i <= j <= n) and replace all elements from a[i] to a[j]\nwith x, at a cost of (j - i + 1).\nFind the minimum cost to make all elements in the array equal.", "sq": "Shkruani një funksion JavaScript `function f_34(n, a)` për të zgjidhur problemin e mëposhtëm:\nJu jepet një varg a me n numra të plotë. Ju mund të kryeni maksimumi një operacion ku\nzgjidhni tre numra të plotë i, j, x (1 <= i <= j <= n) dhe zëvendësoni të gjitha elementet nga a[i] në a[j]\nme x, me një kosto prej (j - i + 1).\nGjeni koston minimale për t'i bërë të gjitha elementet në varg të barabarta.", "hy": "Գրեք JavaScript ֆունկցիա `function f_34(n, a)` հետևյալ խնդիրը լուծելու համար:\nՁեզ տրված է n ամբողջ թվերի զանգված a։ Դուք կարող եք կատարել առավելագույնը մեկ գործողություն, որտեղ\nընտրում եք երեք ամբողջ թվեր i, j, x (1 <= i <= j <= n) և փոխարինում զանգվածի բոլոր տարրերը a[i]-ից a[j]\nx-ով, արժեքով (j - i + 1)։\nԳտեք նվազագույն արժեքը, որպեսզի զանգվածի բոլոր տարրերը հավասար լինեն։", "bn": "একটি JavaScript ফাংশন `function f_34(n, a)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nআপনাকে n পূর্ণসংখ্যার একটি অ্যারে a দেওয়া হয়েছে। আপনি সর্বাধিক একটি অপারেশন করতে পারেন যেখানে\nআপনি তিনটি পূর্ণসংখ্যা i, j, x (1 <= i <= j <= n) নির্বাচন করেন এবং a[i] থেকে a[j] পর্যন্ত সমস্ত উপাদান x দিয়ে প্রতিস্থাপন করেন, যার খরচ (j - i + 1)।\nঅ্যারের সমস্ত উপাদান সমান করতে ন্যূনতম খরচ খুঁজে বের করুন।", "bg": "Напишете JavaScript функция `function f_34(n, a)`, за да решите следния проблем:\nДаден ви е масив a от n цели числа. Можете да извършите най-много една операция, при която\nизбирате три цели числа i, j, x (1 <= i <= j <= n) и замествате всички елементи от a[i] до a[j]\nс x, на цена от (j - i + 1).\nНамерете минималната цена, за да направите всички елементи в масива равни.", "zh": "编写一个 JavaScript 函数 `function f_34(n, a)` 来解决以下问题：  \n给定一个包含 n 个整数的数组 a。你最多可以执行一次操作，选择三个整数 i, j, x (1 <= i <= j <= n)，并将 a[i] 到 a[j] 的所有元素替换为 x，代价为 (j - i + 1)。  \n找到使数组中所有元素相等的最小代价。", "fr": "Écrivez une fonction JavaScript `function f_34(n, a)` pour résoudre le problème suivant :  \nOn vous donne un tableau a de n entiers. Vous pouvez effectuer au plus une opération où vous sélectionnez trois entiers i, j, x (1 <= i <= j <= n) et remplacez tous les éléments de a[i] à a[j] par x, à un coût de (j - i + 1).  \nTrouvez le coût minimum pour rendre tous les éléments du tableau égaux.", "de": "Schreiben Sie eine JavaScript-Funktion `function f_34(n, a)`, um das folgende Problem zu lösen:\nSie haben ein Array a mit n ganzen Zahlen. Sie können höchstens eine Operation durchführen, bei der\nSie drei ganze Zahlen i, j, x (1 <= i <= j <= n) auswählen und alle Elemente von a[i] bis a[j]\ndurch x ersetzen, zu Kosten von (j - i + 1).\nFinden Sie die minimalen Kosten, um alle Elemente im Array gleich zu machen.", "ha": "Rubuta aikin JavaScript `function f_34(n, a)` don warware matsalar mai zuwa:\nAn baka wani array a na lambobi n. Zaka iya aiwatar da akalla daya daga cikin ayyuka inda\nzaka zabi lambobi uku i, j, x (1 <= i <= j <= n) kuma ka maye gurbin dukkan abubuwa daga a[i] zuwa a[j]\nda x, a kan kudin (j - i + 1).\nNemo mafi karancin kudi don sanya duk abubuwan cikin array su zama daidai.", "hi": "`function f_34(n, a)` नामक एक JavaScript फ़ंक्शन लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nआपको n पूर्णांकों के एक array a दिया गया है। आप अधिकतम एक ऑपरेशन कर सकते हैं जहाँ\nआप तीन पूर्णांक i, j, x (1 <= i <= j <= n) का चयन करते हैं और a[i] से a[j] तक के सभी तत्वों को x से बदलते हैं, जिसकी लागत (j - i + 1) होती है।\nसभी तत्वों को array में समान बनाने के लिए न्यूनतम लागत खोजें।", "hu": "Írj egy JavaScript függvényt `function f_34(n, a)` a következő probléma megoldására:\nAdott egy n egész számot tartalmazó tömb a. Legfeljebb egy műveletet hajthatsz végre, ahol\nkiválasztasz három egész számot i, j, x (1 <= i <= j <= n) és az a[i] és a[j] közötti összes elemet x-re cseréled, (j - i + 1) költséggel.\nTaláld meg a minimális költséget, hogy a tömb összes eleme egyenlő legyen.", "es": "Escribe una función de JavaScript `function f_34(n, a)` para resolver el siguiente problema:\nSe te da un arreglo a de n enteros. Puedes realizar como máximo una operación donde\nseleccionas tres enteros i, j, x (1 <= i <= j <= n) y reemplazas todos los elementos desde a[i] hasta a[j]\ncon x, a un costo de (j - i + 1).\nEncuentra el costo mínimo para hacer que todos los elementos en el arreglo sean iguales.", "arb": "اكتب دالة JavaScript `function f_34(n, a)` لحل المشكلة التالية:\nأنت مُعطى مصفوفة a تحتوي على n عدد صحيح. يمكنك تنفيذ عملية واحدة على الأكثر حيث\nتختار ثلاثة أعداد صحيحة i, j, x (1 <= i <= j <= n) وتستبدل جميع العناصر من a[i] إلى a[j]\nبـ x، بتكلفة (j - i + 1).\nابحث عن الحد الأدنى للتكلفة لجعل جميع العناصر في المصفوفة متساوية.", "sw": "Andika kazi ya JavaScript `function f_34(n, a)` kutatua tatizo lifuatalo:\nUmepewa safu a ya n ya nambari za mzima. Unaweza kufanya operesheni moja tu ambapo\nunachagua nambari tatu i, j, x (1 <= i <= j <= n) na kubadilisha vipengele vyote kutoka a[i] hadi a[j]\nna x, kwa gharama ya (j - i + 1).\nPata gharama ndogo zaidi ya kufanya vipengele vyote katika safu kuwa sawa.", "tr": "Bir JavaScript fonksiyonu `function f_34(n, a)` yazın ve aşağıdaki problemi çözün:\nSize n tamsayısından oluşan bir dizi a verilmektedir. En fazla bir işlem gerçekleştirebilirsiniz; burada \nüç tamsayı i, j, x (1 <= i <= j <= n) seçer ve a[i] ile a[j] arasındaki tüm elemanları x ile değiştirirsiniz, bu işlemin maliyeti (j - i + 1) olur.\nDizideki tüm elemanları eşit yapmak için minimum maliyeti bulun.", "vi": "Viết một hàm JavaScript `function f_34(n, a)` để giải quyết vấn đề sau:\nBạn được cung cấp một mảng a gồm n số nguyên. Bạn có thể thực hiện tối đa một thao tác, trong đó bạn chọn ba số nguyên i, j, x (1 <= i <= j <= n) và thay thế tất cả các phần tử từ a[i] đến a[j] bằng x, với chi phí là (j - i + 1).\nTìm chi phí tối thiểu để làm cho tất cả các phần tử trong mảng bằng nhau.", "id": "Tulis sebuah fungsi JavaScript `function f_34(n, a)` untuk menyelesaikan masalah berikut:\nAnda diberikan sebuah array a yang terdiri dari n bilangan bulat. Anda dapat melakukan paling banyak satu operasi di mana\nAnda memilih tiga bilangan bulat i, j, x (1 <= i <= j <= n) dan mengganti semua elemen dari a[i] hingga a[j]\ndengan x, dengan biaya (j - i + 1).\nTemukan biaya minimum untuk membuat semua elemen dalam array menjadi sama.", "ja": "JavaScript関数 `function f_34(n, a)` を作成して、次の問題を解決してください:\n配列 a が n 個の整数で与えられます。最大で1回の操作を行うことができます。この操作では、3つの整数 i, j, x (1 <= i <= j <= n) を選択し、a[i] から a[j] までのすべての要素を x に置き換えます。この操作のコストは (j - i + 1) です。\n配列内のすべての要素を等しくするための最小コストを求めてください。", "ko": "JavaScript 함수를 작성하세요 `function f_34(n, a)` 다음 문제를 해결하기 위해:\n배열 a가 n개의 정수로 주어집니다. 최대 한 번의 연산을 수행할 수 있으며, \n세 개의 정수 i, j, x (1 <= i <= j <= n)를 선택하고 a[i]부터 a[j]까지의 모든 요소를 x로 대체합니다. 이때 비용은 (j - i + 1)입니다.\n배열의 모든 요소를 동일하게 만드는 최소 비용을 찾으세요.", "ml": "`function f_34(n, a)` എന്ന ജാവാസ്ക്രിപ്റ്റ് ഫംഗ്ഷൻ എഴുതുക താഴെ കൊടുത്തിരിക്കുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nനിങ്ങൾക്ക് n പൂർണ്ണസംഖ്യകളുടെ ഒരു നിര a ലഭ്യമാണ്. നിങ്ങൾക്ക് ഏറ്റവും കൂടുതൽ ഒരു പ്രവർത്തനം നടത്താം, അതായത്\nനിങ്ങൾ മൂന്നു പൂർണ്ണസംഖ്യകൾ i, j, x (1 <= i <= j <= n) തിരഞ്ഞെടുക്കുകയും a[i] മുതൽ a[j] വരെയുള്ള എല്ലാ മൂല്യങ്ങളും x-ആയി മാറ്റുകയും ചെയ്യാം, (j - i + 1) എന്ന ചെലവിൽ.\nഎല്ലാ മൂല്യങ്ങളും സമാനമാക്കുന്നതിനുള്ള കുറഞ്ഞ ചെലവ് കണ്ടെത്തുക.", "fa": "یک تابع JavaScript به نام `function f_34(n, a)` بنویسید تا مسئله زیر را حل کند:\nشما یک آرایه a شامل n عدد صحیح دارید. شما می‌توانید حداکثر یک عملیات انجام دهید که در آن سه عدد صحیح i، j، x (۱ <= i <= j <= n) را انتخاب کرده و تمام عناصر از a[i] تا a[j] را با x جایگزین کنید، با هزینه‌ای برابر با (j - i + 1).\nحداقل هزینه برای برابر کردن تمام عناصر در آرایه را پیدا کنید."}, "level": "middle", "test": "function testf_34() {\n    console.assert(f_34(6, [1, 2, 3, 4, 5, 1]) === 4);\n    console.assert(f_34(7, [1, 1, 1, 1, 1, 1, 1]) === 0);\n    console.assert(f_34(8, [8, 8, 8, 1, 2, 8, 8, 8]) === 2);\n    console.assert(f_34(3, [1, 2, 3]) === 2);\n    console.assert(f_34(7, [4, 3, 2, 7, 1, 1, 3]) === 6);\n    console.assert(f_34(9, [9, 9, 2, 9, 2, 5, 5, 5, 3]) === 7);\n    \n    console.assert(f_34(3, [1, 2, 1]) === 1);\n    console.assert(f_34(5, [5, 5, 1, 5, 5]) === 1);\n    console.assert(f_34(4, [1, 1, 1, 1]) === 0);\n    console.assert(f_34(6, [2, 2, 2, 3, 2, 2]) === 1);\n    console.assert(f_34(1, [1]) === 0);\n    console.assert(f_34(2, [1, 2]) === 1);\n    console.assert(f_34(4, [1, 2, 2, 1]) === 2);\n    console.assert(f_34(7, [4, 4, 4, 3, 3, 4, 4]) === 2);\n    console.assert(f_34(6, [5, 4, 4, 4, 5, 5]) === 3);\n    console.assert(f_34(7, [1, 2, 1, 2, 1, 2, 1]) === 5);\n\n}\n\ntestf_34();", "entry_point": "f_34", "signature": "function f_34(n, a)", "docstring": {"en": "You are given an array a of n integers. You can perform at most one operation where\nyou select three integers i, j, x (1 <= i <= j <= n) and replace all elements from a[i] to a[j]\nwith x, at a cost of (j - i + 1).\nFind the minimum cost to make all elements in the array equal.", "sq": "Ju jepet një varg a me n numra të plotë. Ju mund të kryeni maksimumi një operacion ku\nzgjidhni tre numra të plotë i, j, x (1 <= i <= j <= n) dhe zëvendësoni të gjitha elementet nga a[i] deri te a[j]\nme x, me një kosto prej (j - i + 1).\nGjeni koston minimale për të bërë të gjitha elementet në varg të barabarta.", "hy": "Դուք ունեք n ամբողջ թվերից կազմված զանգված a։ Դուք կարող եք կատարել առավելագույնը մեկ գործողություն, որտեղ\nդուք ընտրում եք երեք ամբողջ թվեր՝ i, j, x (1 <= i <= j <= n) և փոխարինում եք a[i]-ից մինչև a[j] բոլոր տարրերը\nx-ով, արժեքով (j - i + 1)։\nԳտեք նվազագույն արժեքը, որպեսզի զանգվածի բոլոր տարրերը հավասար լինեն։", "bn": "আপনাকে n পূর্ণসংখ্যার একটি অ্যারে a দেওয়া হয়েছে। আপনি সর্বাধিক একটি অপারেশন করতে পারেন যেখানে আপনি তিনটি পূর্ণসংখ্যা i, j, x (1 <= i <= j <= n) নির্বাচন করেন এবং a[i] থেকে a[j] পর্যন্ত সমস্ত উপাদান x দিয়ে প্রতিস্থাপন করেন, যার খরচ (j - i + 1) হয়। অ্যারের সমস্ত উপাদান সমান করতে ন্যূনতম খরচ খুঁজে বের করুন।", "bg": "Даден ви е масив a от n цели числа. Можете да извършите най-много една операция, при която избирате три цели числа i, j, x (1 <= i <= j <= n) и заменяте всички елементи от a[i] до a[j] с x, на цена (j - i + 1). Намерете минималната цена, за да направите всички елементи в масива равни.", "zh": "你有一个包含 n 个整数的数组 a。你可以最多执行一次操作，其中你选择三个整数 i, j, x (1 <= i <= j <= n)，并将从 a[i] 到 a[j] 的所有元素替换为 x，代价为 (j - i + 1)。  \n找出使数组中所有元素相等的最小代价。", "fr": "Vous disposez d'un tableau `a` de `n` entiers. Vous pouvez effectuer au plus une opération où vous sélectionnez trois entiers `i`, `j`, `x` (1 <= i <= j <= n) et remplacez tous les éléments de `a[i]` à `a[j]` par `x`, à un coût de (j - i + 1). Trouvez le coût minimum pour rendre tous les éléments du tableau égaux.", "de": "Du hast ein Array a mit n ganzen Zahlen. Du kannst höchstens eine Operation durchführen, bei der du drei ganze Zahlen i, j, x (1 <= i <= j <= n) auswählst und alle Elemente von a[i] bis a[j] mit x ersetzt, zu Kosten von (j - i + 1). Finde die minimalen Kosten, um alle Elemente im Array gleich zu machen.", "ha": "An ba ku wani tsari a na n lambobi. Kuna iya aiwatar da akalla aiki guda ɗaya inda\nzaku zaɓi lambobi uku i, j, x (1 <= i <= j <= n) kuma ku maye gurbin dukkan abubuwa daga a[i] zuwa a[j]\nda x, a kan kuɗin (j - i + 1).\nNemo mafi ƙarancin kuɗi don sanya duk abubuwan cikin tsarin su zama daidai.", "hi": "आपको n पूर्णांकों की एक श्रृंखला a दी गई है। आप अधिकतम एक ऑपरेशन कर सकते हैं जिसमें आप तीन पूर्णांक i, j, x (1 <= i <= j <= n) का चयन करते हैं और a[i] से a[j] तक के सभी तत्वों को x से बदलते हैं, जिसकी लागत (j - i + 1) होती है। सभी तत्वों को श्रृंखला में समान बनाने की न्यूनतम लागत खोजें।", "hu": "Önnek adott egy n egész számot tartalmazó tömb, a. Legfeljebb egy műveletet hajthat végre, ahol kiválaszt három egész számot i, j, x (1 <= i <= j <= n), és az a[i]-től a[j]-ig terjedő összes elemet x-re cseréli, (j - i + 1) költséggel. Találja meg a minimális költséget, hogy az összes elem a tömbben egyenlő legyen.", "es": "Se te da un array a de n enteros. Puedes realizar como máximo una operación donde seleccionas tres enteros i, j, x (1 <= i <= j <= n) y reemplazas todos los elementos desde a[i] hasta a[j] con x, a un costo de (j - i + 1). Encuentra el costo mínimo para hacer que todos los elementos en el array sean iguales.", "arb": "تم إعطاؤك مصفوفة a تحتوي على n من الأعداد الصحيحة. يمكنك تنفيذ عملية واحدة على الأكثر حيث تختار ثلاثة أعداد صحيحة i، j، x (1 <= i <= j <= n) وتستبدل جميع العناصر من a[i] إلى a[j] بـ x، بتكلفة (j - i + 1).  \nابحث عن الحد الأدنى للتكلفة لجعل جميع العناصر في المصفوفة متساوية.", "sw": "Umepewa safu a ya n nambari za mzima. Unaweza kufanya operesheni moja tu ambapo\nunachagua nambari tatu i, j, x (1 <= i <= j <= n) na kubadilisha vipengele vyote kutoka a[i] hadi a[j]\nna x, kwa gharama ya (j - i + 1).\nPata gharama ya chini ya kufanya vipengele vyote katika safu kuwa sawa.", "tr": "Bir n tam sayısından oluşan bir dizi a verilmektedir. En fazla bir işlem gerçekleştirebilirsiniz, burada i, j, x (1 <= i <= j <= n) üç tam sayısını seçer ve a[i] ile a[j] arasındaki tüm elemanları x ile değiştirirsiniz, bu işlem (j - i + 1) maliyetine sahiptir. Dizideki tüm elemanları eşit yapmak için minimum maliyeti bulun.", "vi": "Bạn được cung cấp một mảng a gồm n số nguyên. Bạn có thể thực hiện tối đa một thao tác, trong đó bạn chọn ba số nguyên i, j, x (1 <= i <= j <= n) và thay thế tất cả các phần tử từ a[i] đến a[j] bằng x, với chi phí là (j - i + 1). Tìm chi phí tối thiểu để làm cho tất cả các phần tử trong mảng bằng nhau.", "id": "Anda diberikan sebuah array a yang terdiri dari n bilangan bulat. Anda dapat melakukan paling banyak satu operasi di mana Anda memilih tiga bilangan bulat i, j, x (1 <= i <= j <= n) dan mengganti semua elemen dari a[i] hingga a[j] dengan x, dengan biaya (j - i + 1). Temukan biaya minimum untuk membuat semua elemen dalam array menjadi sama.", "ja": "配列 a が n 個の整数を持っています。最大で1回の操作を行うことができ、その操作では3つの整数 i, j, x (1 <= i <= j <= n) を選び、a[i] から a[j] までのすべての要素を x に置き換えます。この操作のコストは (j - i + 1) です。\n配列内のすべての要素を等しくするための最小コストを求めてください。", "ko": "당신은 n개의 정수로 이루어진 배열 a를 가지고 있습니다. 최대 한 번의 연산을 수행할 수 있으며, 여기서 세 개의 정수 i, j, x (1 <= i <= j <= n)를 선택하여 a[i]부터 a[j]까지의 모든 요소를 x로 바꿀 수 있습니다. 이때 비용은 (j - i + 1)입니다. 배열의 모든 요소를 동일하게 만드는 최소 비용을 찾으십시오.", "ml": "നിങ്ങൾക്ക് n പൂർണ്ണസംഖ്യകളുടെ ഒരു നിര a ലഭിച്ചിട്ടുണ്ട്. നിങ്ങൾക്ക് ഏറ്റവും കൂടുതൽ ഒരു പ്രവർത്തനം നടത്താൻ കഴിയും, അവിടെ നിങ്ങൾ മൂന്ന് പൂർണ്ണസംഖ്യകൾ i, j, x (1 <= i <= j <= n) തിരഞ്ഞെടുക്കുകയും a[i] മുതൽ a[j] വരെയുള്ള എല്ലാ ഘടകങ്ങളും x-നായി മാറ്റുകയും ചെയ്യാം, (j - i + 1) എന്ന ചെലവിൽ. നിരയിലെ എല്ലാ ഘടകങ്ങളും തുല്യമായാക്കാനുള്ള കുറഞ്ഞ ചെലവ് കണ്ടെത്തുക.", "fa": "شما یک آرایه a شامل n شما می‌توانید حداکثر یک عملیات انجام دهید که در آن سه عدد i، j، x (1 <= i <= j <= n) را انتخاب کرده و تمام عناصر از a[i] تا a[j] را با x جایگزین کنید، با هزینه‌ای برابر با (j - i + 1). حداقل هزینه برای برابر کردن تمام عناصر در آرایه را پیدا کنید."}}
{"task_id": "JavaScript/35", "prompt": {"en": "/**\n * Given a sequence of N piles of stones numbered from 1 to N, with each pile containing a positive number of stones,\n * determine the winner of a game played by Charlie and Dan. Charlie goes first, and they take turns moving a \n * positive number of stones from the leftmost non-empty pile to the adjacent right pile. The player who can \n * only move stones in the last pile loses. Assuming both players use the best possible strategy, find out \n * who will win the game.\n *\n * @example\n * f_35([3, 1, 2, 2]) // returns \"Dan\"\n */\nfunction f_35(piles)", "sq": "/**\n * Duke pasur një sekuencë prej N grumbuj gurësh të numëruar nga 1 deri në N, ku secili grumbull përmban një numër pozitiv gurësh,\n * përcaktoni fituesin e një loje të luajtur nga Charlie dhe Dan. Charlie fillon i pari, dhe ata marrin radhë duke lëvizur një \n * numër pozitiv gurësh nga grumbulli më i majtë jo bosh në grumbullin fqinjë në të djathtë. Lojtari që mund të \n * lëvizë gurë vetëm në grumbullin e fundit humbet. Duke supozuar se të dy lojtarët përdorin strategjinë më të mirë të mundshme, zbuloni \n * kush do të fitojë lojën.\n *\n * @example\n * f_35([3, 1, 2, 2]) // returns \"Dan\"\n */\nfunction f_35(piles)", "hy": "/**\n * Տրված է N քարերի կույտերի հաջորդականություն, որոնք համարակալված են 1-ից N, և յուրաքանչյուր կույտ պարունակում է դրական թվով քարեր,\n * որոշեք խաղի հաղթողին, որը խաղում են Չարլին և Դենը։ Չարլին առաջինն է գնում, և նրանք հերթով տեղափոխում են \n * դրական թվով քարեր ձախից առաջին ոչ դատարկ կույտից դեպի հարակից աջ կույտ։ Խաղացողը, որը կարող է \n * միայն տեղափոխել քարերը վերջին կույտում, պարտվում է։ Ենթադրելով, որ երկու խաղացողներն էլ օգտագործում են հնարավոր լավագույն ռազմավարությունը, պարզեք \n * ով կհաղթի խաղը։\n *\n * @օրինակ\n * f_35([3, 1, 2, 2]) // վերադարձնում է \"Dan\"\n */", "bn": "/**\n * ১ থেকে N পর্যন্ত নম্বরযুক্ত N পাথরের স্তূপের একটি ক্রম দেওয়া হয়েছে, যেখানে প্রতিটি স্তূপে একটি ধনাত্মক সংখ্যা পাথর রয়েছে,\n * চার্লি এবং ড্যান দ্বারা খেলা একটি গেমের বিজয়ী নির্ধারণ করুন। চার্লি প্রথমে যায়, এবং তারা পালাক্রমে \n * বামদিকের প্রথম খালি নয় এমন স্তূপ থেকে ডানদিকে সংলগ্ন স্তূপে একটি ধনাত্মক সংখ্যা পাথর সরিয়ে নেয়। যে খেলোয়াড় \n * শুধুমাত্র শেষ স্তূপে পাথর সরাতে পারে সে হেরে যায়। ধরে নিই উভয় খেলোয়াড়ই সর্বোত্তম কৌশল ব্যবহার করে, \n * খেলা কে জিতবে তা খুঁজে বের করুন।\n *\n * @example\n * f_35([3, 1, 2, 2]) // returns \"Dan\"\n */\nfunction f_35(piles)", "bg": "/**\n * Дадена е последователност от N купчини камъни, номерирани от 1 до N, като всяка купчина съдържа положителен брой камъни,\n * определете победителя в игра, играна от Чарли и Дан. Чарли започва пръв и те се редуват да преместват\n * положителен брой камъни от най-лявата непразна купчина към съседната дясна купчина. Играчът, който може\n * да премества камъни само в последната купчина, губи. При условие, че и двамата играчи използват най-добрата възможна стратегия, установете\n * кой ще спечели играта.\n *\n * @example\n * f_35([3, 1, 2, 2]) // returns \"Dan\"\n */\nfunction f_35(piles)", "zh": "/**\n * 给定一个编号从1到N的石堆序列，每堆包含一个正数的石头，\n * 确定由Charlie和Dan进行的游戏的获胜者。Charlie先开始，他们轮流将\n * 左边第一个非空堆中的正数石头移动到相邻的右边堆。只能在最后一堆中移动石头的玩家输掉游戏。\n * 假设两位玩家都使用最佳策略，找出谁将赢得比赛。\n *\n * @example\n * f_35([3, 1, 2, 2]) // returns \"Dan\"\n */", "fr": "/**\n * Étant donné une séquence de N tas de pierres numérotés de 1 à N, chaque tas contenant un nombre positif de pierres,\n * déterminez le gagnant d'un jeu joué par Charlie et Dan. Charlie commence, et ils jouent à tour de rôle en déplaçant \n * un nombre positif de pierres du tas non vide le plus à gauche vers le tas adjacent à droite. Le joueur qui ne peut \n * déplacer des pierres que dans le dernier tas perd. En supposant que les deux joueurs utilisent la meilleure stratégie possible, \n * découvrez qui gagnera le jeu.\n *\n * @example\n * f_35([3, 1, 2, 2]) // returns \"Dan\"\n */\nfunction f_35(piles)", "de": "/**\n * Gegeben eine Sequenz von N Steinhaufen, nummeriert von 1 bis N, wobei jeder Haufen eine positive Anzahl von Steinen enthält,\n * bestimmen Sie den Gewinner eines Spiels, das von Charlie und Dan gespielt wird. Charlie beginnt, und sie ziehen abwechselnd \n * eine positive Anzahl von Steinen vom linken, nicht leeren Haufen zum benachbarten rechten Haufen. Der Spieler, der nur \n * Steine im letzten Haufen bewegen kann, verliert. Angenommen, beide Spieler verwenden die bestmögliche Strategie, \n * finden Sie heraus, wer das Spiel gewinnen wird.\n *\n * @example\n * f_35([3, 1, 2, 2]) // returns \"Dan\"\n */\nfunction f_35(piles)", "ha": "/**\n * An ba da jerin N na tarin duwatsu da aka lamba daga 1 zuwa N, tare da kowanne tarin yana dauke da adadin duwatsu masu kyau,\n * tantance wanda zai ci nasara a wasan da Charlie da Dan suke yi. Charlie ne zai fara, kuma suna juyawa suna motsa \n * adadin duwatsu masu kyau daga tarin da ke hagu wanda ba komai ba zuwa tarin da ke dama kusa. Dan wasan da zai iya \n * motsa duwatsu a cikin tarin karshe kadai zai yi rashin nasara. Ana tsammanin duka 'yan wasan suna amfani da \n * mafi kyawun dabaru, gano wanda zai ci nasara a wasan.\n *\n * @example\n * f_35([3, 1, 2, 2]) // returns \"Dan\"\n */\nfunction f_35(piles)", "hi": "/**\n * दिए गए N पत्थरों के ढेरों की एक अनुक्रमिक श्रृंखला, जिन्हें 1 से N तक क्रमांकित किया गया है, के साथ, \n * जहाँ प्रत्येक ढेर में सकारात्मक संख्या में पत्थर हैं, चार्ली और डैन द्वारा खेले गए खेल के विजेता का निर्धारण करें। \n * चार्ली पहले जाता है, और वे बारी-बारी से बाएँ से दाएँ सबसे पहले गैर-खाली ढेर से सकारात्मक संख्या में पत्थर \n * लेकर उन्हें समीपवर्ती दाएँ ढेर में डालते हैं। वह खिलाड़ी जो केवल अंतिम ढेर में पत्थर ले जा सकता है, हार जाता है। \n * मान लें कि दोनों खिलाड़ी सबसे अच्छी संभव रणनीति का उपयोग करते हैं, यह पता करें कि खेल कौन जीतेगा।\n *\n * @example\n * f_35([3, 1, 2, 2]) // \"Dan\" लौटाता है\n */", "hu": "/**\n * Adott egy N kövekből álló halom sorozat, amelyeket 1-től N-ig számoztak, és mindegyik halom pozitív számú követ tartalmaz,\n * határozza meg a Charlie és Dan által játszott játék győztesét. Charlie kezd, és felváltva mozgatnak egy \n * pozitív számú követ a legbaloldalibb nem üres halomból a szomszédos jobb oldali halomba. Az a játékos veszít, aki \n * csak az utolsó halomban tud köveket mozgatni. Feltételezve, hogy mindkét játékos a lehető legjobb stratégiát alkalmazza, derítse ki, \n * ki fogja megnyerni a játékot.\n *\n * @példa\n * f_35([3, 1, 2, 2]) // visszatér \"Dan\"\n */", "es": "/**\n * Dada una secuencia de N pilas de piedras numeradas del 1 al N, con cada pila conteniendo un número positivo de piedras,\n * determina el ganador de un juego jugado por Charlie y Dan. Charlie va primero, y se turnan moviendo un \n * número positivo de piedras de la pila más a la izquierda que no esté vacía a la pila adyacente a la derecha. El jugador que solo puede \n * mover piedras en la última pila pierde. Suponiendo que ambos jugadores usan la mejor estrategia posible, averigua \n * quién ganará el juego.\n *\n * @example\n * f_35([3, 1, 2, 2]) // devuelve \"Dan\"\n */\nfunction f_35(piles)", "arb": "/**\n * بالنظر إلى تسلسل من N أكوام من الحجارة مرقمة من 1 إلى N، مع احتواء كل كومة على عدد موجب من الحجارة،\n * حدد الفائز في لعبة يلعبها تشارلي ودان. يبدأ تشارلي أولاً، ويتناوبون في نقل عدد موجب من الحجارة \n * من الكومة اليسرى غير الفارغة إلى الكومة المجاورة على اليمين. اللاعب الذي يمكنه فقط نقل الحجارة \n * في الكومة الأخيرة يخسر. بافتراض أن كلا اللاعبين يستخدمان أفضل استراتيجية ممكنة، اكتشف \n * من سيفوز باللعبة.\n *\n * @example\n * f_35([3, 1, 2, 2]) // يعيد \"Dan\"\n */\nfunction f_35(piles)", "sw": "/**\n * Ukiwa na mlolongo wa marundo N ya mawe yaliyohesabiwa kutoka 1 hadi N, ambapo kila rundo lina idadi chanya ya mawe,\n * bainisha mshindi wa mchezo unaochezwa na Charlie na Dan. Charlie huanza kwanza, na wanachukua zamu kuhamisha \n * idadi chanya ya mawe kutoka kwenye rundo la kwanza lisilo tupu kwenda kwenye rundo la kulia lililo karibu. Mchezaji ambaye anaweza \n * tu kuhamisha mawe kwenye rundo la mwisho anapoteza. Tukidhani wachezaji wote wanatumia mkakati bora zaidi, gundua \n * nani atashinda mchezo.\n *\n * @example\n * f_35([3, 1, 2, 2]) // inarejesha \"Dan\"\n */\nfunction f_35(piles)", "tr": "/**\n * 1'den N'e kadar numaralandırılmış N taş yığını dizisi verildiğinde, her yığın pozitif sayıda taş içerir,\n * Charlie ve Dan tarafından oynanan bir oyunun kazananını belirleyin. Charlie ilk başlar ve sırayla \n * soldaki en dolu olmayan yığından sağdaki bitişik yığına pozitif sayıda taş taşırlar. \n * Sadece son yığındaki taşları hareket ettirebilen oyuncu kaybeder. Her iki oyuncunun da \n * en iyi stratejiyi kullandığını varsayarak, oyunu kimin kazanacağını bulun.\n *\n * @example\n * f_35([3, 1, 2, 2]) // \"Dan\" döndürür\n */\nfunction f_35(piles)", "vi": "/**\n * Cho một dãy N đống đá được đánh số từ 1 đến N, với mỗi đống chứa một số lượng đá dương,\n * xác định người chiến thắng của trò chơi được chơi bởi Charlie và Dan. Charlie đi trước, và họ lần lượt \n * di chuyển một số lượng đá dương từ đống không rỗng bên trái nhất sang đống liền kề bên phải. Người chơi \n * chỉ có thể di chuyển đá ở đống cuối cùng sẽ thua. Giả sử cả hai người chơi đều sử dụng chiến lược tốt nhất có thể, \n * tìm ra ai sẽ thắng trò chơi.\n *\n * @example\n * f_35([3, 1, 2, 2]) // trả về \"Dan\"\n */\nfunction f_35(piles)", "id": "/**\n * Diberikan urutan N tumpukan batu bernomor dari 1 hingga N, dengan setiap tumpukan berisi sejumlah batu positif,\n * tentukan pemenang dari permainan yang dimainkan oleh Charlie dan Dan. Charlie pergi lebih dulu, dan mereka bergantian \n * memindahkan sejumlah batu positif dari tumpukan paling kiri yang tidak kosong ke tumpukan kanan yang berdekatan. \n * Pemain yang hanya bisa memindahkan batu di tumpukan terakhir kalah. Dengan asumsi kedua pemain menggunakan strategi \n * terbaik yang mungkin, cari tahu siapa yang akan memenangkan permainan.\n *\n * @example\n * f_35([3, 1, 2, 2]) // mengembalikan \"Dan\"\n */\nfunction f_35(piles)", "ja": "/**\n * 1からNまで番号が振られたN個の石の山があり、それぞれの山には正の数の石が含まれています。\n * チャーリーとダンがプレイするゲームの勝者を決定します。チャーリーが最初に行動し、彼らは交互に\n * 左端の空でない山から隣の右の山に正の数の石を移動させます。最後の山でしか石を移動できないプレイヤーが負けます。\n * 両方のプレイヤーが可能な限り最善の戦略を使用すると仮定して、誰がゲームに勝つかを見つけてください。\n *\n * @example\n * f_35([3, 1, 2, 2]) // returns \"Dan\"\n */\nfunction f_35(piles)", "ko": "/**\n * 1부터 N까지 번호가 매겨진 N개의 돌무더기 시퀀스가 주어졌을 때, 각 무더기에는 양의 개수의 돌이 포함되어 있습니다.\n * Charlie와 Dan이 하는 게임의 승자를 결정하세요. Charlie가 먼저 시작하고, 그들은 차례로 \n * 왼쪽에서 가장 가까운 비어 있지 않은 무더기에서 인접한 오른쪽 무더기로 양의 개수의 돌을 옮깁니다. \n * 마지막 무더기에서만 돌을 움직일 수 있는 플레이어가 패배합니다. 두 플레이어 모두 최상의 전략을 사용한다고 가정할 때, \n * 누가 게임에서 이길지 알아보세요.\n *\n * @example\n * f_35([3, 1, 2, 2]) // returns \"Dan\"\n */\nfunction f_35(piles)", "ml": "/**\n * 1 മുതൽ N വരെ നമ്പർ ചെയ്ത N കൂമ്പാരങ്ങളുടെ ഒരു നിര നൽകിയിരിക്കുന്നു, ഓരോ കൂമ്പാരവും ഒരു പോസിറ്റീവ് എണ്ണം കല്ലുകൾ അടങ്ങിയിരിക്കുന്നു,\n * ചാർളിയും ഡാനും കളിക്കുന്ന ഒരു ഗെയിമിന്റെ വിജയിയെ നിർണ്ണയിക്കുക. ചാർളി ആദ്യം പോകുന്നു, അവർ മാറി മാറി \n * ഇടതുവശത്തുള്ള ശൂന്യമല്ലാത്ത കൂമ്പാരത്തിൽ നിന്ന് അടുത്ത വലതുവശത്തെ കൂമ്പാരത്തിലേക്ക് ഒരു പോസിറ്റീവ് എണ്ണം കല്ലുകൾ നീക്കുന്നു. \n * അവസാന കൂമ്പാരത്തിൽ മാത്രം കല്ലുകൾ നീക്കാൻ കഴിയുന്ന കളിക്കാരൻ തോൽക്കും. ഇരുവരും മികച്ച തന്ത്രം ഉപയോഗിക്കുന്നു എന്ന് കരുതുമ്പോൾ, \n * ഗെയിം ആരാണ് ജയിക്കുക എന്ന് കണ്ടെത്തുക.\n *\n * @example\n * f_35([3, 1, 2, 2]) // returns \"Dan\"\n */\nfunction f_35(piles)", "fa": "/**\n * با توجه به دنباله‌ای از N توده سنگ شماره‌گذاری شده از 1 تا N، که هر توده شامل تعداد مثبتی از سنگ‌ها است،\n * برنده بازی که توسط چارلی و دن انجام می‌شود را تعیین کنید. چارلی اول می‌رود و آن‌ها به نوبت یک \n * تعداد مثبت از سنگ‌ها را از توده غیرخالی سمت چپ به توده مجاور سمت راست منتقل می‌کنند. بازیکنی که \n * فقط می‌تواند سنگ‌ها را در توده آخر حرکت دهد، بازنده است. با فرض اینکه هر دو بازیکن از بهترین استراتژی ممکن استفاده می‌کنند، \n * مشخص کنید که چه کسی برنده بازی خواهد شد.\n *\n * @example\n * f_35([3, 1, 2, 2]) // returns \"Dan\"\n */\nfunction f_35(piles)"}, "canonical_solution": "{\n    const n = piles.length;\n    const firstPileStones = piles[0];\n    \n    if (n === 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones === 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}", "instruction": {"en": "Write a JavaScript function `function f_35(piles)` to solve the following problem:\nGiven a sequence of N piles of stones numbered from 1 to N, with each pile containing a positive number of stones,\n determine the winner of a game played by Charlie and Dan. Charlie goes first, and they take turns moving a\n positive number of stones from the leftmost non-empty pile to the adjacent right pile. The player who can\n only move stones in the last pile loses. Assuming both players use the best possible strategy, find out\n who will win the game.\n\n@example\nf_35([3, 1, 2, 2]) // returns \"Dan\"", "sq": "Shkruani një funksion JavaScript `function f_35(piles)` për të zgjidhur problemin e mëposhtëm:  \nDuke pasur një sekuencë prej N grumbuj gurësh të numëruar nga 1 deri në N, me secilin grumbull që përmban një numër pozitiv gurësh,  \npërcaktoni fituesin e një loje të luajtur nga Charlie dhe Dan. Charlie fillon i pari, dhe ata marrin kthesa duke lëvizur një  \nnumër pozitiv gurësh nga grumbulli më i majtë jo-bosh në grumbullin ngjitur në të djathtë. Lojtari që mund të  \nlëvizë gurë vetëm në grumbullin e fundit humbet. Duke supozuar se të dy lojtarët përdorin strategjinë më të mirë të mundshme, zbuloni  \nkush do ta fitojë lojën.", "hy": "Գրեք JavaScript ֆունկցիա `function f_35(piles)`՝ հետևյալ խնդիրը լուծելու համար:\nՏրված է քարերի N կույտերի հաջորդականություն, որոնք համարակալված են 1-ից N, և յուրաքանչյուր կույտ պարունակում է քարերի դրական քանակ:\nորոշեք խաղի հաղթողին, որը խաղում են Չարլին և Դենը: Չարլին առաջինն է գնում, և նրանք հերթով տեղափոխում են\nքարերի դրական քանակություն ձախից ամենաառաջին ոչ դատարկ կույտից դեպի հարևան աջ կույտ: Խաղացողը, ով կարող է\nմիայն քարեր տեղափոխել վերջին կույտում, պարտվում է: Ենթադրելով, որ երկու խաղացողներն էլ օգտագործում են հնարավոր լավագույն ռազմավարությունը, պարզեք\nով կհաղթի խաղը.", "bn": "একটি জাভাস্ক্রিপ্ট ফাংশন `function f_35(piles)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য: \nধরা যাক ১ থেকে N পর্যন্ত নম্বরযুক্ত পাথরের Nটি স্তূপ রয়েছে, প্রতিটি স্তূপে একটি ধনাত্মক সংখ্যক পাথর রয়েছে, \nচার্লি এবং ড্যান দ্বারা খেলা একটি গেমের বিজয়ী নির্ধারণ করুন। চার্লি প্রথমে যায়, এবং তারা পালাক্রমে \nবামদিকের প্রথম খালি না থাকা স্তূপ থেকে ডান পাশের সংলগ্ন স্তূপে একটি ধনাত্মক সংখ্যক পাথর সরিয়ে নেয়। \nযে খেলোয়াড় কেবলমাত্র শেষ স্তূপে পাথর সরাতে পারে সে হেরে যায়। ধরে নেওয়া হয় উভয় খেলোয়াড়ই \nসর্বোত্তম কৌশল ব্যবহার করে, খেলা কে জিতবে তা খুঁজে বের করুন।", "bg": "Напишете JavaScript функция `function f_35(piles)`, за да решите следния проблем:  \nДадена е последователност от N купчини камъни, номерирани от 1 до N, като всяка купчина съдържа положителен брой камъни,  \nопределете победителя в игра, играна от Чарли и Дан. Чарли започва пръв и те се редуват да преместват  \nположителен брой камъни от най-лявата непразна купчина към съседната дясна купчина. Играчът, който може  \nда премества камъни само в последната купчина, губи. Приемайки, че и двамата играчи използват най-добрата възможна стратегия, разберете  \nкой ще спечели играта.", "zh": "编写一个 JavaScript 函数 `function f_35(piles)` 来解决以下问题：  \n给定一个编号从 1 到 N 的石头堆序列，每堆包含一个正数的石头，确定由 Charlie 和 Dan 玩的游戏的获胜者。Charlie 先开始，他们轮流将一个正数的石头从最左边的非空堆移动到相邻的右边堆。只能在最后一堆移动石头的玩家输掉游戏。假设两位玩家都使用最佳策略，找出谁将赢得比赛。", "fr": "Écrire une fonction JavaScript `function f_35(piles)` pour résoudre le problème suivant :  \nÉtant donné une séquence de N tas de pierres numérotés de 1 à N, chaque tas contenant un nombre positif de pierres,  \ndéterminer le gagnant d'un jeu joué par Charlie et Dan. Charlie commence, et ils jouent à tour de rôle en déplaçant un  \nnombre positif de pierres du tas non vide le plus à gauche vers le tas adjacent à droite. Le joueur qui ne peut  \ndéplacer des pierres que dans le dernier tas perd. En supposant que les deux joueurs utilisent la meilleure stratégie possible, découvrez  \nqui gagnera le jeu.", "de": "Schreiben Sie eine JavaScript-Funktion `function f_35(piles)`, um das folgende Problem zu lösen:\nGegeben ist eine Sequenz von N Steinhaufen, nummeriert von 1 bis N, wobei jeder Haufen eine positive Anzahl von Steinen enthält. Bestimmen Sie den Gewinner eines Spiels, das von Charlie und Dan gespielt wird. Charlie beginnt, und sie ziehen abwechselnd eine positive Anzahl von Steinen vom linken, nicht leeren Haufen zum benachbarten rechten Haufen. Der Spieler, der nur noch Steine im letzten Haufen bewegen kann, verliert. Angenommen, beide Spieler verwenden die bestmögliche Strategie, finden Sie heraus, wer das Spiel gewinnen wird.", "ha": "Rubuta wani aiki na JavaScript `function f_35(piles)` don warware matsalar mai zuwa:\nAn ba da jerin N na tarin duwatsu da aka lamba daga 1 zuwa N, tare da kowanne tarin yana dauke da adadi mai kyau na duwatsu,\n tantance wanda zai ci nasara a wani wasa da Charlie da Dan suka buga. Charlie ne ke farawa, kuma suna juyawa suna motsa a\n adadi mai kyau na duwatsu daga mafi hagu wanda ba komai ba zuwa tarin dama kusa. Dan wasan da zai iya\n kawai motsa duwatsu a cikin tarin karshe ya rasa. Ana tsammanin duka 'yan wasan suna amfani da mafi kyawun dabaru, gano\n wanda zai ci nasara a wasan.\n\n@example\nf_35([3, 1, 2, 2]) // returns \"Dan\"", "hi": "JavaScript फ़ंक्शन `function f_35(piles)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए N पत्थरों के ढेरों की एक श्रृंखला, जिन्हें 1 से N तक क्रमांकित किया गया है, और प्रत्येक ढेर में पत्थरों की एक सकारात्मक संख्या है, यह निर्धारित करें कि चार्ली और डैन द्वारा खेले गए खेल का विजेता कौन होगा। चार्ली पहले जाता है, और वे बारी-बारी से बाएँ से दाएँ सबसे पहले गैर-खाली ढेर से एक सकारात्मक संख्या में पत्थर को पास के दाएँ ढेर में ले जाते हैं। वह खिलाड़ी जो केवल अंतिम ढेर में पत्थर ले जा सकता है, हार जाता है। मान लें कि दोनों खिलाड़ी सर्वश्रेष्ठ संभव रणनीति का उपयोग करते हैं, यह पता करें कि खेल कौन जीतेगा।", "hu": "Írj egy JavaScript függvényt `function f_35(piles)` a következő probléma megoldására:\nAdott egy N kövekből álló halom sorozat, 1-től N-ig számozva, ahol minden halom pozitív számú követ tartalmaz,\nhatározd meg a Charlie és Dan által játszott játék győztesét. Charlie kezd, és felváltva mozgatnak egy\npozitív számú követ a bal szélső nem üres halomból a szomszédos jobb halomba. Az a játékos veszít, aki csak\naz utolsó halomban tud köveket mozgatni. Feltételezve, hogy mindkét játékos a lehető legjobb stratégiát alkalmazza, derítsd ki,\nki fogja megnyerni a játékot.", "es": "Escribe una función de JavaScript `function f_35(piles)` para resolver el siguiente problema:\nDada una secuencia de N pilas de piedras numeradas del 1 al N, con cada pila conteniendo un número positivo de piedras,\ndetermina el ganador de un juego jugado por Charlie y Dan. Charlie va primero, y se turnan moviendo un\nnúmero positivo de piedras de la pila más a la izquierda no vacía a la pila adyacente a la derecha. El jugador que solo puede\nmover piedras en la última pila pierde. Suponiendo que ambos jugadores usan la mejor estrategia posible, averigua\nquién ganará el juego.\n\n@example\nf_35([3, 1, 2, 2]) // devuelve \"Dan\"", "arb": "اكتب دالة JavaScript `function f_35(piles)` لحل المشكلة التالية:\nبالنظر إلى تسلسل من N أكوام من الحجارة مرقمة من 1 إلى N، مع احتواء كل كومة على عدد موجب من الحجارة،\nحدد الفائز في لعبة يلعبها تشارلي ودان. يبدأ تشارلي أولاً، ويتناوبان في نقل عدد\nموجب من الحجارة من الكومة غير الفارغة الأكثر إلى اليسار إلى الكومة المجاورة على اليمين. اللاعب الذي لا يمكنه\nإلا نقل الحجارة في الكومة الأخيرة يخسر. بافتراض أن كلا اللاعبين يستخدمان أفضل استراتيجية ممكنة، اكتشف\nمن سيفوز باللعبة.\n\n@example\nf_35([3, 1, 2, 2]) // يعيد \"Dan\"", "sw": "Andika kazi ya JavaScript `function f_35(piles)` kutatua tatizo lifuatalo:\nUkipatiwa mlolongo wa marundo ya mawe N yaliyopangwa kutoka 1 hadi N, ambapo kila rundo lina idadi chanya ya mawe,\n amua mshindi wa mchezo unaochezwa na Charlie na Dan. Charlie huanza kwanza, na wanachukua zamu kuhamisha\n idadi chanya ya mawe kutoka kwenye rundo la kwanza lisilo tupu kwenda kwenye rundo la kulia lililo karibu. Mchezaji ambaye anaweza\n tu kuhamisha mawe kwenye rundo la mwisho anapoteza. Tukidhani wachezaji wote wanatumia mkakati bora zaidi, tafuta\n nani atakayeshinda mchezo.\n\n@example\nf_35([3, 1, 2, 2]) // inarejesha \"Dan\"", "tr": "Bir JavaScript fonksiyonu `function f_35(piles)` yazın ve aşağıdaki problemi çözün:\n1'den N'ye kadar numaralandırılmış N taş yığını dizisi verildiğinde, her yığın pozitif sayıda taş içerir,\nCharlie ve Dan tarafından oynanan bir oyunun kazananını belirleyin. Charlie ilk başlar ve sırayla\npozitif sayıda taşı en soldaki boş olmayan yığından bitişik sağdaki yığına taşırlar. Sadece son yığındaki taşları hareket ettirebilen oyuncu kaybeder. Her iki oyuncunun da en iyi stratejiyi kullandığını varsayarak, oyunu kimin kazanacağını bulun.\n\n@example\nf_35([3, 1, 2, 2]) // \"Dan\" döndürür", "vi": "Viết một hàm JavaScript `function f_35(piles)` để giải quyết vấn đề sau:\nCho một dãy N đống đá được đánh số từ 1 đến N, với mỗi đống chứa một số lượng đá dương,\nxác định người chiến thắng của trò chơi được chơi bởi Charlie và Dan. Charlie đi trước, và họ lần lượt di chuyển một\nsố lượng đá dương từ đống không trống bên trái nhất sang đống liền kề bên phải. Người chơi chỉ có thể\ndi chuyển đá trong đống cuối cùng sẽ thua. Giả sử cả hai người chơi đều sử dụng chiến lược tốt nhất có thể, hãy tìm ra\nai sẽ thắng trò chơi.\n\n@example\nf_35([3, 1, 2, 2]) // trả về \"Dan\"", "id": "Tulis sebuah fungsi JavaScript `function f_35(piles)` untuk menyelesaikan masalah berikut:\nDiberikan sebuah urutan N tumpukan batu yang diberi nomor dari 1 hingga N, dengan setiap tumpukan berisi sejumlah batu positif,\ntentukan pemenang dari permainan yang dimainkan oleh Charlie dan Dan. Charlie pergi lebih dulu, dan mereka bergantian memindahkan sejumlah\nbatu positif dari tumpukan paling kiri yang tidak kosong ke tumpukan kanan yang berdekatan. Pemain yang hanya bisa memindahkan batu di tumpukan terakhir kalah. Dengan asumsi kedua pemain menggunakan strategi terbaik yang mungkin, cari tahu siapa yang akan memenangkan permainan.\n\n@example\nf_35([3, 1, 2, 2]) // mengembalikan \"Dan\"", "ja": "JavaScript関数 `function f_35(piles)` を作成して、次の問題を解決してください:\nN個の石の山の列が1からNまで番号付けされており、各山には正の数の石が含まれています。\nチャーリーとダンがプレイするゲームの勝者を決定します。チャーリーが最初に行動し、彼らは交互に\n左端の空でない山から隣接する右の山に正の数の石を移動します。最後の山でしか石を動かせないプレイヤーが負けます。両方のプレイヤーが最善の戦略を使用すると仮定して、誰がゲームに勝つかを見つけてください。\n\n@example\nf_35([3, 1, 2, 2]) // returns \"Dan\"", "ko": "JavaScript 함수 `function f_35(piles)`를 작성하여 다음 문제를 해결하십시오:\nN개의 돌무더기 시퀀스가 1부터 N까지 번호가 매겨져 있으며, 각 무더기에는 양의 개수의 돌이 포함되어 있습니다. Charlie와 Dan이 플레이하는 게임의 승자를 결정하십시오. Charlie가 먼저 시작하고, 그들은 차례로 가장 왼쪽의 비어 있지 않은 무더기에서 인접한 오른쪽 무더기로 양의 개수의 돌을 옮깁니다. 마지막 무더기에서만 돌을 옮길 수 있는 플레이어가 패배합니다. 두 플레이어가 최상의 전략을 사용한다고 가정할 때, 누가 게임에서 이길지 알아내십시오.\n\n@example\nf_35([3, 1, 2, 2]) // returns \"Dan\"", "ml": "`function f_35(piles)` എന്ന ജാവാസ്ക്രിപ്റ്റ് ഫംഗ്ഷൻ എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nN കൂമ്പാരങ്ങളുടെ ഒരു അനുക്രമം നൽകിയിരിക്കുന്നു, ഓരോ കൂമ്പാരവും 1 മുതൽ N വരെ നമ്പർ ചെയ്തിരിക്കുന്നു, ഓരോ കൂമ്പാരവും ഒരു പോസിറ്റീവ് എണ്ണം കല്ലുകൾ അടങ്ങിയിരിക്കുന്നു,\nചാർളിയും ഡാനും കളിക്കുന്ന ഒരു ഗെയിമിന്റെ വിജയിയെ നിർണ്ണയിക്കുക. ചാർലി ആദ്യം പോകുന്നു, അവർ മാറി മാറി നീക്കങ്ങൾ നടത്തുന്നു\nഇടതുവശത്തുള്ള ആദ്യത്തെ ശൂന്യമല്ലാത്ത കൂമ്പാരത്തിൽ നിന്ന് അടുത്ത വലതുവശത്തെ കൂമ്പാരത്തിലേക്ക് ഒരു പോസിറ്റീവ് എണ്ണം കല്ലുകൾ നീക്കുന്നു. അവസാന കൂമ്പാരത്തിൽ മാത്രം കല്ലുകൾ നീക്കാൻ കഴിയുന്ന കളിക്കാരൻ തോൽക്കുന്നു. ഇരുവരും ഏറ്റവും മികച്ച തന്ത്രം ഉപയോഗിക്കുന്നതായി കണക്കാക്കുമ്പോൾ, ഗെയിം ആരാണ് ജയിക്കുക എന്ന് കണ്ടെത്തുക.\n\n@example\nf_35([3, 1, 2, 2]) // \"Dan\" തിരികെ നൽകുന്നു", "fa": "یک تابع جاوااسکریپت `function f_35(piles)` بنویسید تا مسئله زیر را حل کند:\nبا توجه به دنباله‌ای از N توده سنگ شماره‌گذاری شده از 1 تا N، که هر توده شامل تعداد مثبتی از سنگ‌ها است،\nبرنده بازی که توسط چارلی و دن انجام می‌شود را تعیین کنید. چارلی اول حرکت می‌کند و آن‌ها به نوبت\nتعداد مثبتی از سنگ‌ها را از چپ‌ترین توده غیرخالی به توده مجاور راست منتقل می‌کنند. بازیکنی که فقط می‌تواند\nسنگ‌ها را در آخرین توده حرکت دهد، می‌بازد. با فرض اینکه هر دو بازیکن از بهترین استراتژی ممکن استفاده می‌کنند، مشخص کنید\nچه کسی برنده بازی خواهد شد.\n\n@example\nf_35([3, 1, 2, 2]) // بازمی‌گرداند \"Dan\""}, "level": "middle", "test": "(() => {\n    console.assert(f_35([1, 2, 2]) === \"Dan\", \"Test 1 failed\");\n    console.assert(f_35([5, 5, 5, 5, 5]) === \"Charlie\", \"Test 2 failed\");\n    console.assert(f_35([2, 1, 2]) === \"Charlie\", \"Test 3 failed\");\n    console.assert(f_35([3, 3, 3, 3]) === \"Charlie\", \"Test 4 failed\");\n    console.assert(f_35([1, 1]) === \"Charlie\", \"Test 5 failed\");\n    console.assert(f_35([2, 1]) === \"Charlie\", \"Test 6 failed\");\n    console.assert(f_35([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) === \"Dan\", \"Test 7 failed\");\n    console.assert(f_35([2, 2, 2, 2, 2, 2, 2, 2, 2, 1]) === \"Charlie\", \"Test 8 failed\");\n    console.assert(f_35([10, 10, 10, 10, 10, 10, 10, 10, 10, 10]) === \"Charlie\", \"Test 9 failed\");\n    console.assert(f_35([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) === \"Dan\", \"Test 10 failed\");\n})();", "entry_point": "f_35", "signature": "function f_35(piles)", "docstring": {"en": "Given a sequence of N piles of stones numbered from 1 to N, with each pile containing a positive number of stones,\n determine the winner of a game played by Charlie and Dan. Charlie goes first, and they take turns moving a\n positive number of stones from the leftmost non-empty pile to the adjacent right pile. The player who can\n only move stones in the last pile loses. Assuming both players use the best possible strategy, find out\n who will win the game.\n\n@example\nf_35([3, 1, 2, 2]) // returns \"Dan\"", "sq": "Duke pasur një sekuencë prej N grumbuj gurësh të numëruar nga 1 deri në N, me secilin grumbull që përmban një numër pozitiv gurësh, përcaktoni fituesin e një loje të luajtur nga Charlie dhe Dan. Charlie fillon i pari, dhe ata marrin me radhë duke lëvizur një numër pozitiv gurësh nga grumbulli më i majtë jo bosh në grumbullin fqinj në të djathtë. Lojtari që mund të lëvizë gurë vetëm në grumbullin e fundit humbet. Duke supozuar se të dy lojtarët përdorin strategjinë më të mirë të mundshme, zbuloni kush do të fitojë lojën.\n\n@example\nf_35([3, 1, 2, 2]) // kthen \"Dan\"", "hy": "Տրված է N քարերի կույտերի հաջորդականություն, համարակալված 1-ից N, որտեղ յուրաքանչյուր կույտ պարունակում է քարերի դրական քանակ: որոշեք Չարլիի և Դենի կողմից խաղացած խաղի հաղթողը: Չարլին առաջինն է գնում, և նրանք հերթով տեղափոխում են դրական քանակի քարեր ձախից ամենաառաջին ոչ դատարկ կույտից դեպի հարակից աջ կույտ: Խաղացողը, ով կարող է միայն քարեր տեղափոխել վերջին կույտում, պարտվում է: Ենթադրելով, որ երկու խաղացողներն էլ օգտագործում են հնարավոր լավագույն ռազմավարությունը, պարզեք, թե ով կհաղթի խաղը:\n\n@example\nf_35([3, 1, 2, 2]) // վերադարձնում է \"Dan\"", "bn": "N সংখ্যক পাথরের স্তূপের একটি ক্রম দেওয়া হয়েছে, যা 1 থেকে N পর্যন্ত নম্বরযুক্ত, প্রতিটি স্তূপে একটি ধনাত্মক সংখ্যক পাথর রয়েছে, চার্লি এবং ড্যান দ্বারা খেলা একটি গেমের বিজয়ী নির্ধারণ করুন। চার্লি প্রথমে যায়, এবং তারা পালাক্রমে বামদিকের প্রথম খালি না হওয়া স্তূপ থেকে ডানদিকে সংলগ্ন স্তূপে একটি ধনাত্মক সংখ্যক পাথর সরিয়ে নেয়। যে খেলোয়াড় শুধুমাত্র শেষ স্তূপে পাথর সরাতে পারে সে হেরে যায়। ধরে নেওয়া হয়েছে উভয় খেলোয়াড়ই সর্বোত্তম কৌশল ব্যবহার করে, খুঁজে বের করুন কে গেমটি জিতবে।\n\n@example\nf_35([3, 1, 2, 2]) // returns \"Dan\"", "bg": "Дадена е последователност от N купчини камъни, номерирани от 1 до N, като всяка купчина съдържа положителен брой камъни, определете победителя в игра, играна от Чарли и Дан. Чарли започва пръв и те се редуват да местят положителен брой камъни от най-лявата непразна купчина към съседната дясна купчина. Играчът, който може да мести камъни само в последната купчина, губи. Приемайки, че и двамата играчи използват най-добрата възможна стратегия, разберете кой ще спечели играта.\n\n@example\nf_35([3, 1, 2, 2]) // връща \"Dan\"", "zh": "给定一个编号从1到N的石堆序列，每堆包含一个正数的石头，确定由Charlie和Dan进行的游戏的获胜者。Charlie先开始，他们轮流将正数的石头从最左边的非空堆移动到相邻的右边堆。只能在最后一堆移动石头的玩家输掉游戏。假设两位玩家都使用最佳策略，找出谁将赢得比赛。\n\n@example\nf_35([3, 1, 2, 2]) // 返回 \"Dan\"", "fr": "Étant donné une séquence de N tas de pierres numérotés de 1 à N, chaque tas contenant un nombre positif de pierres, déterminez le gagnant d'un jeu joué par Charlie et Dan. Charlie commence, et ils jouent à tour de rôle en déplaçant un nombre positif de pierres du tas non vide le plus à gauche vers le tas adjacent à droite. Le joueur qui ne peut déplacer des pierres que dans le dernier tas perd. En supposant que les deux joueurs utilisent la meilleure stratégie possible, découvrez qui gagnera le jeu.\n\n@example\nf_35([3, 1, 2, 2]) // retourne \"Dan\"", "de": "Angenommen, es gibt eine Sequenz von N Steinhaufen, nummeriert von 1 bis N, wobei jeder Haufen eine positive Anzahl von Steinen enthält, bestimmen Sie den Gewinner eines Spiels, das von Charlie und Dan gespielt wird. Charlie beginnt, und sie ziehen abwechselnd eine positive Anzahl von Steinen vom linken, nicht leeren Haufen zum benachbarten rechten Haufen. Der Spieler, der nur noch Steine im letzten Haufen bewegen kann, verliert. Angenommen, beide Spieler verwenden die bestmögliche Strategie, finden Sie heraus, wer das Spiel gewinnen wird.\n\n@example\nf_35([3, 1, 2, 2]) // gibt \"Dan\" zurück", "ha": "An ba da jerin N na tarin duwatsu da aka lamba daga 1 zuwa N, tare da kowanne tarin dauke da adadi mai kyau na duwatsu, tantance wanda zai ci nasara a wasan da Charlie da Dan suka buga. Charlie ne ke farawa, kuma suna juyawa suna motsa adadi mai kyau na duwatsu daga mafi hagu da ba komai a ciki zuwa tarin dama kusa. Dan wasan da zai iya motsa duwatsu a cikin tarin karshe kawai zai yi rashin nasara. Idan aka dauka cewa duka 'yan wasan suna amfani da mafi kyawun dabaru, gano wanda zai ci nasara a wasan.\n\n@example\nf_35([3, 1, 2, 2]) // returns \"Dan\"", "hi": "दिए गए पत्थरों के N ढेरों की एक अनुक्रमणिका है, जिन्हें 1 से N तक क्रमांकित किया गया है, जिसमें प्रत्येक ढेर में पत्थरों की एक सकारात्मक संख्या है, यह निर्धारित करें कि चार्ली और डैन द्वारा खेले गए खेल का विजेता कौन होगा। चार्ली पहले जाता है, और वे बारी-बारी से बाएं से दाएं सबसे निकटतम गैर-खाली ढेर से पत्थरों की एक सकारात्मक संख्या को दाएं सटे हुए ढेर में स्थानांतरित करते हैं। वह खिलाड़ी जो केवल अंतिम ढेर में पत्थरों को स्थानांतरित कर सकता है, हार जाता है। यह मानते हुए कि दोनों खिलाड़ी सबसे अच्छी संभव रणनीति का उपयोग करते हैं, पता करें कि खेल कौन जीतेगा।\n\n@example\nf_35([3, 1, 2, 2]) // \"Dan\" लौटाता है", "hu": "Adott egy N kövekből álló sorozat, amelyeket 1-től N-ig számoznak, és mindegyik halom pozitív számú követ tartalmaz. Határozza meg a Charlie és Dan által játszott játék nyertesét. Charlie kezd, és felváltva mozgatnak egy pozitív számú követ a bal szélső nem üres halomból a szomszédos jobb halomba. Az a játékos veszít, aki csak az utolsó halomban tud köveket mozgatni. Feltételezve, hogy mindkét játékos a lehető legjobb stratégiát alkalmazza, derítse ki, ki fogja megnyerni a játékot.\n\n@example\nf_35([3, 1, 2, 2]) // visszaadja \"Dan\"", "es": "Dada una secuencia de N montones de piedras numerados del 1 al N, con cada montón conteniendo un número positivo de piedras, determina el ganador de un juego jugado por Charlie y Dan. Charlie va primero, y ellos se turnan moviendo un número positivo de piedras del montón más a la izquierda que no esté vacío al montón adyacente a la derecha. El jugador que solo pueda mover piedras en el último montón pierde. Suponiendo que ambos jugadores usan la mejor estrategia posible, averigua quién ganará el juego.\n\n@example\nf_35([3, 1, 2, 2]) // devuelve \"Dan\"", "arb": "بالنظر إلى تسلسل من N أكوام من الحجارة مرقمة من 1 إلى N، حيث يحتوي كل كومة على عدد موجب من الحجارة، حدد الفائز في لعبة يلعبها تشارلي ودان. يبدأ تشارلي أولاً، ويتناوبون على نقل عدد موجب من الحجارة من الكومة غير الفارغة اليسرى إلى الكومة المجاورة اليمنى. اللاعب الذي لا يمكنه سوى نقل الحجارة في الكومة الأخيرة يخسر. بافتراض أن كلا اللاعبين يستخدمان أفضل استراتيجية ممكنة، اكتشف من سيفوز باللعبة.\n\n@example\nf_35([3, 1, 2, 2]) // يعيد \"Dan\"", "sw": "Kwa kuzingatia mlolongo wa marundo N ya mawe yaliyohesabiwa kutoka 1 hadi N, ambapo kila rundo lina idadi chanya ya mawe, amua mshindi wa mchezo unaochezwa na Charlie na Dan. Charlie anaanza kwanza, na wanachukua zamu kuhamisha idadi chanya ya mawe kutoka kwenye rundo la kwanza lisilo tupu kwenda kwenye rundo la kulia lililo karibu. Mchezaji ambaye anaweza tu kuhamisha mawe kwenye rundo la mwisho anapoteza. Tukichukulia wachezaji wote wanatumia mkakati bora zaidi, gundua ni nani atakayeshinda mchezo.\n\n@example\nf_35([3, 1, 2, 2]) // inarudisha \"Dan\"", "tr": "Verilen 1'den N'ye numaralandırılmış N taş yığını dizisinde, her yığın pozitif sayıda taş içerir, Charlie ve Dan tarafından oynanan bir oyunun kazananını belirleyin. Charlie ilk hamleyi yapar ve sırayla pozitif sayıda taşı en soldaki boş olmayan yığından bitişik sağ yığına taşırlar. Sadece son yığındaki taşları hareket ettirebilen oyuncu kaybeder. Her iki oyuncunun da en iyi stratejiyi kullandığını varsayarak, oyunu kimin kazanacağını bulun.\n\n@example\nf_35([3, 1, 2, 2]) // \"Dan\" döndürür", "vi": "Cho một dãy N đống đá được đánh số từ 1 đến N, với mỗi đống chứa một số lượng đá dương, xác định người chiến thắng của trò chơi được chơi bởi Charlie và Dan. Charlie đi trước, và họ lần lượt di chuyển một số lượng đá dương từ đống không rỗng ngoài cùng bên trái sang đống liền kề bên phải. Người chơi chỉ có thể di chuyển đá trong đống cuối cùng sẽ thua. Giả sử cả hai người chơi sử dụng chiến lược tốt nhất có thể, hãy tìm ra ai sẽ thắng trò chơi.\n\n@example\nf_35([3, 1, 2, 2]) // trả về \"Dan\"", "id": "Diberikan urutan N tumpukan batu yang diberi nomor dari 1 hingga N, dengan setiap tumpukan berisi sejumlah batu positif, tentukan pemenang dari permainan yang dimainkan oleh Charlie dan Dan. Charlie pergi lebih dulu, dan mereka bergiliran memindahkan sejumlah batu positif dari tumpukan paling kiri yang tidak kosong ke tumpukan kanan yang berdekatan. Pemain yang hanya dapat memindahkan batu di tumpukan terakhir kalah. Dengan asumsi kedua pemain menggunakan strategi terbaik yang mungkin, cari tahu siapa yang akan memenangkan permainan.\n\n@example\nf_35([3, 1, 2, 2]) // mengembalikan \"Dan\"", "ja": "N個の石の山が1からNまで番号付けられており、それぞれの山には正の数の石が含まれています。チャーリーとダンがプレイするゲームの勝者を決定します。チャーリーが最初に行動し、彼らは交互に左端の空でない山から隣の右の山に正の数の石を移動します。最後の山でしか石を動かせないプレイヤーが負けます。両方のプレイヤーが最善の戦略を使用すると仮定して、誰がゲームに勝つかを見つけてください。\n\n@example\nf_35([3, 1, 2, 2]) // \"Dan\"を返します", "ko": "주어진 N개의 돌무더기 시퀀스가 1부터 N까지 번호가 매겨져 있으며, 각 무더기에는 양의 개수의 돌이 포함되어 있습니다. Charlie와 Dan이 플레이하는 게임의 승자를 결정하세요. Charlie가 먼저 시작하며, 그들은 차례로 왼쪽에서 가장 가까운 비어 있지 않은 무더기에서 인접한 오른쪽 무더기로 양의 개수의 돌을 이동합니다. 마지막 무더기에서만 돌을 이동할 수 있는 플레이어가 패배합니다. 두 플레이어 모두 최상의 전략을 사용한다고 가정할 때, 누가 게임에서 승리할지 알아보세요.\n\n@example\nf_35([3, 1, 2, 2]) // returns \"Dan\"", "ml": "നമ്പർ 1 മുതൽ N വരെ നമ്പർ ചെയ്ത N കൂമ്പാരങ്ങളുള്ള ഒരു നിര നൽകിയാൽ, ഓരോ കൂമ്പാരവും ഒരു പോസിറ്റീവ് എണ്ണം കല്ലുകൾ അടങ്ങിയിരിക്കുന്നു, ചാർളിയും ഡാനും കളിക്കുന്ന ഒരു കളിയുടെ വിജയിയെ നിർണയിക്കുക. ചാർളി ആദ്യം പോകുന്നു, അവർ മാറിമാറി നീങ്ങുന്നു, ഇടത്തെ ഏറ്റവും ഒഴിഞ്ഞിട്ടില്ലാത്ത കൂമ്പാരത്തിൽ നിന്ന് ഒരു പോസിറ്റീവ് എണ്ണം കല്ലുകൾ അടുത്ത വലതുവശത്തെ കൂമ്പാരത്തിലേക്ക് നീക്കുന്നു. അവസാന കൂമ്പാരത്തിൽ മാത്രം കല്ലുകൾ നീക്കാൻ കഴിയുന്ന കളിക്കാരൻ തോൽക്കും. ഇരുവരും മികച്ച സാധ്യതയുള്ള തന്ത്രം ഉപയോഗിക്കുന്നുവെന്ന് കരുതുമ്പോൾ, ആരാണ് കളി ജയിക്കുക എന്ന് കണ്ടെത്തുക.\n\n@example\nf_35([3, 1, 2, 2]) // \"Dan\" തിരിച്ചുകൊടുക്കുന്നു", "fa": "با توجه به دنباله‌ای از N توده سنگ که از 1 تا N شماره‌گذاری شده‌اند و هر توده شامل تعداد مثبتی از سنگ‌هاست، برنده بازی‌ای که توسط چارلی و دن انجام می‌شود را تعیین کنید. چارلی اول می‌رود و آن‌ها به نوبت تعداد مثبتی از سنگ‌ها را از توده غیرخالی سمت چپ به توده مجاور سمت راست منتقل می‌کنند. بازیکنی که تنها می‌تواند سنگ‌ها را در توده آخر حرکت دهد، بازنده است. با فرض اینکه هر دو بازیکن از بهترین استراتژی ممکن استفاده می‌کنند، مشخص کنید چه کسی بازی را خواهد برد.\n\n@example\nf_35([3, 1, 2, 2]) // returns \"Dan\""}}
{"task_id": "JavaScript/36", "prompt": {"en": "/**\n * Given n doors arranged in a circle, the player starts in front of door 1.\n * Each turn, the player can choose a number i and pay a cost C_i to move i steps\n * to the right and then open the door at that position. It is guaranteed that\n * C_i >= C_{i+1} for 1 <= i < n.\n * The task is to determine the minimum total cost required to open all doors.\n * \n * Example:\n *     > f_36(3, [1, 1, 1])\n *     3\n */\nfunction f_36(n, C)", "sq": "/**\n * Duke pasur parasysh n dyer të renditura në një rreth, lojtari fillon përpara derës 1.\n * Çdo radhë, lojtari mund të zgjedhë një numër i dhe të paguajë një kosto C_i për të lëvizur i hapa\n * djathtas dhe pastaj të hapë derën në atë pozicion. Është e garantuar që\n * C_i >= C_{i+1} për 1 <= i < n.\n * Detyra është të përcaktohet kostoja minimale totale e nevojshme për të hapur të gjitha dyert.\n * \n * Shembull:\n *     > f_36(3, [1, 1, 1])\n *     3\n */\nfunction f_36(n, C)", "hy": "/**\n * Տրված է n դռներ, որոնք դասավորված են շրջանաձև, խաղացողը սկսում է դուռ 1-ի դիմաց:\n * Յուրաքանչյուր քայլի ժամանակ խաղացողը կարող է ընտրել թիվ i և վճարել C_i արժեքը՝\n * i քայլ աջ շարժվելու և այն դիրքում գտնվող դուռը բացելու համար: Երաշխավորված է, որ\n * C_i >= C_{i+1} համար 1 <= i < n:\n * Խնդիրը կայանում է որոշելու բոլոր դռները բացելու համար անհրաժեշտ նվազագույն ընդհանուր արժեքը:\n * \n * Օրինակ:\n *     > f_36(3, [1, 1, 1])\n *     3\n */\nfunction f_36(n, C)", "bn": "/**\n * একটি বৃত্তে n দরজা দেওয়া আছে, খেলোয়াড় দরজা 1 এর সামনে থেকে শুরু করে।\n * প্রতিটি পালায়, খেলোয়াড় একটি সংখ্যা i নির্বাচন করতে পারে এবং i ধাপ\n * ডানদিকে সরতে C_i খরচ দিতে পারে এবং তারপর সেই অবস্থানের দরজা খুলতে পারে। এটি নিশ্চিত যে\n * C_i >= C_{i+1} যেখানে 1 <= i < n।\n * কাজটি হল সমস্ত দরজা খোলার জন্য প্রয়োজনীয় সর্বনিম্ন মোট খরচ নির্ধারণ করা।\n * \n * উদাহরণ:\n *     > f_36(3, [1, 1, 1])\n *     3\n */", "bg": "/**\n * Дадени са n врати, подредени в кръг, играчът започва пред врата 1.\n * Всеки ход, играчът може да избере число i и да плати цена C_i, за да се придвижи i стъпки\n * надясно и след това да отвори вратата на тази позиция. Гарантирано е, че\n * C_i >= C_{i+1} за 1 <= i < n.\n * Задачата е да се определи минималната обща цена, необходима за отваряне на всички врати.\n * \n * Пример:\n *     > f_36(3, [1, 1, 1])\n *     3\n */\nfunction f_36(n, C)", "zh": "/**\n * 给定 n 个门排成一个圆圈，玩家从门 1 前面开始。\n * 每回合，玩家可以选择一个数字 i 并支付费用 C_i 向右移动 i 步，\n * 然后打开该位置的门。保证 C_i >= C_{i+1} 对于 1 <= i < n。\n * 任务是确定打开所有门所需的最小总费用。\n * \n * 示例:\n *     > f_36(3, [1, 1, 1])\n *     3\n */\nfunction f_36(n, C)", "fr": "/**\n * Étant donné n portes disposées en cercle, le joueur commence devant la porte 1.\n * À chaque tour, le joueur peut choisir un nombre i et payer un coût C_i pour avancer de i pas\n * vers la droite puis ouvrir la porte à cette position. Il est garanti que\n * C_i >= C_{i+1} pour 1 <= i < n.\n * La tâche consiste à déterminer le coût total minimum requis pour ouvrir toutes les portes.\n * \n * Exemple :\n *     > f_36(3, [1, 1, 1])\n *     3\n */\nfunction f_36(n, C)", "de": "/**\n * Gegeben sind n Türen, die in einem Kreis angeordnet sind, und der Spieler beginnt vor Tür 1.\n * Bei jedem Zug kann der Spieler eine Zahl i wählen und einen Kosten C_i zahlen, um i Schritte\n * nach rechts zu gehen und dann die Tür an dieser Position zu öffnen. Es ist garantiert, dass\n * C_i >= C_{i+1} für 1 <= i < n.\n * Die Aufgabe besteht darin, die minimalen Gesamtkosten zu bestimmen, die erforderlich sind, um alle Türen zu öffnen.\n * \n * Beispiel:\n *     > f_36(3, [1, 1, 1])\n *     3\n */\nfunction f_36(n, C)", "ha": "/**\n * An ba da ƙofa n da aka shirya a cikin da'ira, ɗan wasa yana farawa a gaban ƙofa ta 1.\n * Kowanne juyi, ɗan wasa zai iya zaɓar lamba i kuma ya biya kuɗin C_i don matsawa matakai i\n * zuwa dama sannan ya buɗe ƙofar a wannan matsayi. An tabbatar da cewa\n * C_i >= C_{i+1} don 1 <= i < n.\n * Aikin shi ne don tantance mafi ƙarancin jimlar kuɗi da ake buƙata don buɗe duk ƙofofin.\n * \n * Misali:\n *     > f_36(3, [1, 1, 1])\n *     3\n */", "hi": "/**\n * दिए गए n दरवाजे जो एक वृत्त में व्यवस्थित हैं, खिलाड़ी दरवाजा 1 के सामने से शुरू करता है।\n * प्रत्येक बारी में, खिलाड़ी एक संख्या i चुन सकता है और i कदम दाईं ओर जाने के लिए एक लागत C_i का भुगतान कर सकता है\n * और फिर उस स्थिति पर दरवाजा खोल सकता है। यह गारंटी है कि\n * C_i >= C_{i+1} जहाँ 1 <= i < n।\n * कार्य यह निर्धारित करना है कि सभी दरवाजे खोलने के लिए न्यूनतम कुल लागत क्या होगी।\n * \n * उदाहरण:\n *     > f_36(3, [1, 1, 1])\n *     3\n */", "hu": "/**\n * Adott n ajtó, amelyek körben vannak elrendezve, a játékos az 1-es ajtó előtt kezd.\n * Minden körben a játékos választhat egy számot i, és fizet egy C_i költséget, hogy i lépést\n * jobbra lépjen, majd kinyissa az adott pozíción lévő ajtót. Garantált, hogy\n * C_i >= C_{i+1} minden 1 <= i < n esetén.\n * A feladat az, hogy meghatározzuk a minimális összköltséget, amely szükséges az összes ajtó kinyitásához.\n * \n * Példa:\n *     > f_36(3, [1, 1, 1])\n *     3\n */\nfunction f_36(n, C)", "es": "/**\n * Dado n puertas dispuestas en un círculo, el jugador comienza frente a la puerta 1.\n * En cada turno, el jugador puede elegir un número i y pagar un costo C_i para moverse i pasos\n * a la derecha y luego abrir la puerta en esa posición. Se garantiza que\n * C_i >= C_{i+1} para 1 <= i < n.\n * La tarea es determinar el costo total mínimo requerido para abrir todas las puertas.\n * \n * Ejemplo:\n *     > f_36(3, [1, 1, 1])\n *     3\n */\nfunction f_36(n, C)", "arb": "/**\n * بالنظر إلى n أبواب مرتبة في دائرة، يبدأ اللاعب أمام الباب 1.\n * في كل دور، يمكن للاعب اختيار رقم i ودفع تكلفة C_i للتحرك i خطوات\n * إلى اليمين ثم فتح الباب في ذلك الموقع. من المضمون أن\n * C_i >= C_{i+1} لـ 1 <= i < n.\n * المهمة هي تحديد الحد الأدنى للتكلفة الإجمالية المطلوبة لفتح جميع الأبواب.\n * \n * مثال:\n *     > f_36(3, [1, 1, 1])\n *     3\n */\nfunction f_36(n, C)", "sw": "/**\n * Ukiwa na milango n iliyopangwa kwenye mduara, mchezaji anaanza mbele ya mlango wa 1.\n * Kila zamu, mchezaji anaweza kuchagua nambari i na kulipa gharama C_i ili kusonga hatua i\n * kuelekea kulia na kisha kufungua mlango katika nafasi hiyo. Inahakikishwa kuwa\n * C_i >= C_{i+1} kwa 1 <= i < n.\n * Kazi ni kuamua gharama ya jumla ya chini kabisa inayohitajika kufungua milango yote.\n * \n * Mfano:\n *     > f_36(3, [1, 1, 1])\n *     3\n */\nfunction f_36(n, C)", "tr": "/**\n * Bir daire şeklinde düzenlenmiş n kapı verildiğinde, oyuncu kapı 1'in önünde başlar.\n * Her turda, oyuncu bir sayı i seçebilir ve i adım sağa hareket etmek için bir maliyet C_i ödeyebilir\n * ve ardından o konumdaki kapıyı açabilir. C_i >= C_{i+1} olduğu garanti edilir 1 <= i < n için.\n * Görev, tüm kapıları açmak için gereken minimum toplam maliyeti belirlemektir.\n * \n * Örnek:\n *     > f_36(3, [1, 1, 1])\n *     3\n */", "vi": "/**\n * Cho n cánh cửa được sắp xếp thành một vòng tròn, người chơi bắt đầu trước cửa số 1.\n * Mỗi lượt, người chơi có thể chọn một số i và trả một chi phí C_i để di chuyển i bước\n * sang phải và sau đó mở cánh cửa ở vị trí đó. Đảm bảo rằng\n * C_i >= C_{i+1} cho 1 <= i < n.\n * Nhiệm vụ là xác định tổng chi phí tối thiểu cần thiết để mở tất cả các cửa.\n * \n * Ví dụ:\n *     > f_36(3, [1, 1, 1])\n *     3\n */\nfunction f_36(n, C)", "id": "/**\n * Diberikan n pintu yang diatur dalam lingkaran, pemain mulai di depan pintu 1.\n * Setiap giliran, pemain dapat memilih angka i dan membayar biaya C_i untuk bergerak i langkah\n * ke kanan dan kemudian membuka pintu di posisi tersebut. Dijamin bahwa\n * C_i >= C_{i+1} untuk 1 <= i < n.\n * Tugasnya adalah menentukan total biaya minimum yang diperlukan untuk membuka semua pintu.\n * \n * Contoh:\n *     > f_36(3, [1, 1, 1])\n *     3\n */\nfunction f_36(n, C)", "ja": "/**\n * n 個のドアが円形に配置されている場合、プレイヤーはドア1の前から開始します。\n * 各ターンで、プレイヤーは数 i を選び、コスト C_i を支払って右に i ステップ移動し、\n * その位置のドアを開けることができます。C_i >= C_{i+1} が 1 <= i < n の範囲で保証されています。\n * すべてのドアを開けるために必要な最小の総コストを求めることが課題です。\n * \n * 例:\n *     > f_36(3, [1, 1, 1])\n *     3\n */\nfunction f_36(n, C)", "ko": "/**\n * 원형으로 배열된 n개의 문이 주어졌을 때, 플레이어는 문 1 앞에서 시작합니다.\n * 각 턴마다, 플레이어는 숫자 i를 선택하고 비용 C_i를 지불하여 i단계 오른쪽으로 이동한 후\n * 그 위치에 있는 문을 엽니다. C_i >= C_{i+1}이 1 <= i < n에 대해 보장됩니다.\n * 모든 문을 여는 데 필요한 최소 총 비용을 결정하는 것이 과제입니다.\n * \n * 예시:\n *     > f_36(3, [1, 1, 1])\n *     3\n */\nfunction f_36(n, C)", "ml": "/**\n * വൃത്താകൃതിയിൽ ക്രമീകരിച്ച n വാതിലുകൾ നൽകിയിരിക്കുന്നു, കളിക്കാരൻ വാതിൽ 1-ന്റെ മുൻപിൽ നിന്ന് ആരംഭിക്കുന്നു.\n * ഓരോ തവണയും, കളിക്കാരൻ ഒരു സംഖ്യ i തിരഞ്ഞെടുക്കുകയും i ഘട്ടങ്ങൾ വലത്തോട്ട് നീങ്ങാൻ ഒരു ചെലവ് C_i നൽകുകയും\n * ആ സ്ഥാനത്ത് വാതിൽ തുറക്കുകയും ചെയ്യാം. 1 <= i < n എന്നതിനായി C_i >= C_{i+1} എന്നു ഉറപ്പാണ്.\n * എല്ലാ വാതിലുകളും തുറക്കാൻ ആവശ്യമായ കുറഞ്ഞ മൊത്തം ചെലവ് നിർണയിക്കാനുള്ളതാണ് ഈ പ്രവർത്തനം.\n * \n * ഉദാഹരണം:\n *     > f_36(3, [1, 1, 1])\n *     3\n */\nfunction f_36(n, C)", "fa": "/**\n * با توجه به n در که به صورت دایره‌ای چیده شده‌اند، بازیکن در مقابل در شماره 1 شروع می‌کند.\n * در هر نوبت، بازیکن می‌تواند عدد i را انتخاب کرده و هزینه C_i را بپردازد تا i قدم\n * به سمت راست حرکت کند و سپس در آن موقعیت در را باز کند. تضمین شده است که\n * C_i >= C_{i+1} برای 1 <= i < n.\n * وظیفه این است که حداقل هزینه کل مورد نیاز برای باز کردن تمام درها را تعیین کنید.\n * \n * مثال:\n *     > f_36(3, [1, 1, 1])\n *     3\n */\nfunction f_36(n, C)"}, "canonical_solution": "{\n   return C[n-2] * (n - 1) + C[n-1];\n}", "instruction": {"en": "Write a JavaScript function `function f_36(n, C)` to solve the following problem:\nGiven n doors arranged in a circle, the player starts in front of door 1.\nEach turn, the player can choose a number i and pay a cost C_i to move i steps\nto the right and then open the door at that position. It is guaranteed that\nC_i >= C_{i+1} for 1 <= i < n.\nThe task is to determine the minimum total cost required to open all doors.\n\nExample:\n    > f_36(3, [1, 1, 1])\n    3\n", "sq": "Shkruani një funksion JavaScript `function f_36(n, C)` për të zgjidhur problemin në vijim:  \nDuke pasur parasysh n dyer të rregulluara në një rreth, lojtari fillon përballë derës 1.  \nÇdo radhë, lojtari mund të zgjedhë një numër i dhe të paguajë një kosto C_i për të lëvizur i hapa  \nnë të djathtë dhe pastaj të hapë derën në atë pozicion. Është e garantuar që  \nC_i >= C_{i+1} për 1 <= i < n.  \nDetyra është të përcaktohet kostoja totale minimale e kërkuar për të hapur të gjitha dyert.  \n\nShembull:  \n    > f_36(3, [1, 1, 1])  \n    3  ", "hy": "Գրեք JavaScript ֆունկցիա `function f_36(n, C)` հետևյալ խնդիրը լուծելու համար:\nՏրված են n դռներ, որոնք դասավորված են շրջանաձև, խաղացողը սկսում է դուռ 1-ի դիմաց:\nՅուրաքանչյուր քայլի ժամանակ, խաղացողը կարող է ընտրել թիվ i և վճարել արժեք C_i՝ i քայլ աջ շարժվելու համար, ապա բացել այդ դիրքի դուռը: Երաշխավորված է, որ C_i >= C_{i+1} 1 <= i < n-ի համար:\nԽնդիրն է որոշել նվազագույն ընդհանուր արժեքը, որը պահանջվում է բոլոր դռները բացելու համար:\n\nՕրինակ:\n    > f_36(3, [1, 1, 1])\n    3", "bn": "একটি JavaScript ফাংশন `function f_36(n, C)` লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\nn দরজা একটি বৃত্তে সাজানো আছে, খেলোয়াড় দরজা 1 এর সামনে শুরু করে। \nপ্রতিটি পালায়, খেলোয়াড় একটি সংখ্যা i বেছে নিতে পারে এবং i ধাপ ডানে সরতে C_i খরচ দিতে পারে এবং তারপর সেই অবস্থানে দরজা খুলতে পারে। এটি নিশ্চিত করা হয়েছে যে 1 <= i < n এর জন্য C_i >= C_{i+1}। \nকাজটি হল সমস্ত দরজা খোলার জন্য প্রয়োজনীয় সর্বনিম্ন মোট খরচ নির্ধারণ করা।\n\nউদাহরণ:\n    > f_36(3, [1, 1, 1])\n    3", "bg": "Напишете JavaScript функция `function f_36(n, C)`, за да решите следния проблем:  \nДадени са n врати, подредени в кръг, играчът започва пред врата 1.  \nВсеки ход играчът може да избере число i и да плати цена C_i, за да се премести i стъпки надясно и след това да отвори вратата на тази позиция. Гарантирано е, че C_i >= C_{i+1} за 1 <= i < n.  \nЗадачата е да се определи минималната обща цена, необходима за отваряне на всички врати.\n\nПример:  \n    > f_36(3, [1, 1, 1])  \n    3", "zh": "编写一个 JavaScript 函数 `function f_36(n, C)` 来解决以下问题：  \n给定 n 扇门按圆形排列，玩家从第 1 扇门前开始。  \n每回合，玩家可以选择一个数字 i 并支付一个代价 C_i 向右移动 i 步，然后打开该位置的门。  \n保证 C_i >= C_{i+1} 对于 1 <= i < n。  \n任务是确定打开所有门所需的最小总成本。\n\n示例：  \n    > f_36(3, [1, 1, 1])  \n    3  ", "fr": "Écrire une fonction JavaScript `function f_36(n, C)` pour résoudre le problème suivant :  \nÉtant donné n portes disposées en cercle, le joueur commence devant la porte 1.  \nÀ chaque tour, le joueur peut choisir un nombre i et payer un coût C_i pour avancer de i pas vers la droite, puis ouvrir la porte à cette position. Il est garanti que C_i >= C_{i+1} pour 1 <= i < n.  \nLa tâche consiste à déterminer le coût total minimum nécessaire pour ouvrir toutes les portes.\n\nExemple :  \n    > f_36(3, [1, 1, 1])  \n    3  ", "de": "Schreiben Sie eine JavaScript-Funktion `function f_36(n, C)`, um das folgende Problem zu lösen:\nGegeben sind n Türen, die in einem Kreis angeordnet sind, der Spieler beginnt vor Tür 1.\nJede Runde kann der Spieler eine Zahl i wählen und einen Kosten C_i zahlen, um i Schritte\nnach rechts zu gehen und dann die Tür an dieser Position zu öffnen. Es ist garantiert, dass\nC_i >= C_{i+1} für 1 <= i < n.\nDie Aufgabe besteht darin, die minimalen Gesamtkosten zu bestimmen, die erforderlich sind, um alle Türen zu öffnen.\n\nBeispiel:\n    > f_36(3, [1, 1, 1])\n    3", "ha": "Rubuta aikin JavaScript `function f_36(n, C)` don warware matsalar mai zuwa:  \nAn ba da ƙofofi n da aka shirya a cikin da'ira, ɗan wasa yana farawa a gaban ƙofa ta 1.  \nA kowanne juyi, ɗan wasa zai iya zaɓar lamba i kuma ya biya kuɗi C_i don matsawa matakai i  \nzuwa dama sannan ya buɗe ƙofar a wannan matsayi. An tabbatar da cewa  \nC_i >= C_{i+1} don 1 <= i < n.  \nAikin shi ne ƙayyade mafi ƙarancin jimillar kuɗi da ake buƙata don buɗe duk ƙofofi.\n\nMisali:  \n    > f_36(3, [1, 1, 1])  \n    3  ", "hi": "JavaScript फ़ंक्शन `function f_36(n, C)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए n दरवाज़े जो एक वृत्त में व्यवस्थित हैं, खिलाड़ी दरवाज़ा 1 के सामने से शुरू करता है।\nप्रत्येक चाल में, खिलाड़ी एक संख्या i चुन सकता है और i कदम दाईं ओर जाने के लिए C_i लागत का भुगतान कर सकता है और फिर उस स्थिति पर दरवाज़ा खोल सकता है। यह सुनिश्चित किया गया है कि C_i >= C_{i+1} जहाँ 1 <= i < n।\nकार्य यह निर्धारित करना है कि सभी दरवाज़े खोलने के लिए न्यूनतम कुल लागत क्या होगी।", "hu": "Írj egy JavaScript függvényt `function f_36(n, C)` a következő probléma megoldására:  \nAdott n ajtó, amelyek körben vannak elrendezve, a játékos az 1-es ajtó előtt kezd.  \nMinden körben a játékos választhat egy számot i, és fizet egy C_i költséget, hogy i lépést tegyen jobbra, majd kinyissa az adott pozíción lévő ajtót. Garantált, hogy C_i >= C_{i+1} minden 1 <= i < n esetén.  \nA feladat annak meghatározása, hogy mi a minimális összköltség az összes ajtó kinyitásához.\n\nPélda:  \n    > f_36(3, [1, 1, 1])  \n    3  ", "es": "Escribe una función de JavaScript `function f_36(n, C)` para resolver el siguiente problema:\nDadas n puertas dispuestas en un círculo, el jugador comienza frente a la puerta 1.\nEn cada turno, el jugador puede elegir un número i y pagar un costo C_i para moverse i pasos\na la derecha y luego abrir la puerta en esa posición. Se garantiza que\nC_i >= C_{i+1} para 1 <= i < n.\nLa tarea es determinar el costo total mínimo requerido para abrir todas las puertas.\n\nEjemplo:\n    > f_36(3, [1, 1, 1])\n    3", "arb": "اكتب دالة JavaScript `function f_36(n, C)` لحل المشكلة التالية:\nمعطى n من الأبواب مرتبة في دائرة، يبدأ اللاعب أمام الباب 1.\nفي كل دور، يمكن للاعب اختيار رقم i ودفع تكلفة C_i للتحرك i خطوات\nإلى اليمين ثم فتح الباب في ذلك الموضع. من المضمون أن\nC_i >= C_{i+1} لـ 1 <= i < n.\nالمهمة هي تحديد الحد الأدنى للتكلفة الإجمالية المطلوبة لفتح جميع الأبواب.\n\nمثال:\n    > f_36(3, [1, 1, 1])\n    3", "sw": "Andika kazi ya JavaScript `function f_36(n, C)` kutatua tatizo lifuatalo:\nUkipiwa milango n iliyopangwa katika mduara, mchezaji huanza mbele ya mlango wa 1.\nKila zamu, mchezaji anaweza kuchagua namba i na kulipa gharama C_i ili kusonga hatua i\nkulia na kisha kufungua mlango katika nafasi hiyo. Imethibitishwa kuwa\nC_i >= C_{i+1} kwa 1 <= i < n.\nKazi ni kuamua gharama ndogo kabisa inayohitajika kufungua milango yote.\n\nMfano:\n    > f_36(3, [1, 1, 1])\n    3", "tr": "Bir JavaScript fonksiyonu `function f_36(n, C)` yazın ve aşağıdaki problemi çözün:\nBir çember şeklinde düzenlenmiş n kapı verildiğinde, oyuncu 1 numaralı kapının önünde başlar.\nHer turda, oyuncu bir sayı i seçebilir ve i adım sağa hareket etmek ve ardından o konumdaki kapıyı açmak için bir maliyet C_i öder.\nC_i >= C_{i+1} olduğu garanti edilir, burada 1 <= i < n.\nGörev, tüm kapıları açmak için gereken minimum toplam maliyeti belirlemektir.\n\nÖrnek:\n    > f_36(3, [1, 1, 1])\n    3", "vi": "Viết một hàm JavaScript `function f_36(n, C)` để giải quyết vấn đề sau:\nCho n cánh cửa được sắp xếp thành một vòng tròn, người chơi bắt đầu trước cửa số 1.\nMỗi lượt, người chơi có thể chọn một số i và trả một chi phí C_i để di chuyển i bước\nsang phải và sau đó mở cánh cửa ở vị trí đó. Đảm bảo rằng\nC_i >= C_{i+1} với 1 <= i < n.\nNhiệm vụ là xác định tổng chi phí tối thiểu cần thiết để mở tất cả các cửa.\n\nVí dụ:\n    > f_36(3, [1, 1, 1])\n    3", "id": "Tulis fungsi JavaScript `function f_36(n, C)` untuk menyelesaikan masalah berikut:\nDiberikan n pintu yang diatur dalam lingkaran, pemain mulai di depan pintu 1.\nSetiap giliran, pemain dapat memilih angka i dan membayar biaya C_i untuk bergerak i langkah\nke kanan dan kemudian membuka pintu di posisi tersebut. Dijamin bahwa\nC_i >= C_{i+1} untuk 1 <= i < n.\nTugasnya adalah menentukan total biaya minimum yang diperlukan untuk membuka semua pintu.\n\nContoh:\n    > f_36(3, [1, 1, 1])\n    3", "ja": "JavaScript関数`function f_36(n, C)`を作成して、次の問題を解決してください。  \nn個のドアが円形に配置されており、プレイヤーはドア1の前からスタートします。  \n各ターンで、プレイヤーは数iを選び、コストC_iを支払って右にiステップ移動し、その位置のドアを開けることができます。  \nC_i >= C_{i+1}が1 <= i < nに対して保証されています。  \nすべてのドアを開けるために必要な最小の総コストを求めることが課題です。\n\n例:\n    > f_36(3, [1, 1, 1])\n    3", "ko": "JavaScript 함수 `function f_36(n, C)`를 작성하여 다음 문제를 해결하십시오:\nn개의 문이 원형으로 배열되어 있을 때, 플레이어는 문 1 앞에서 시작합니다.\n각 턴마다 플레이어는 숫자 i를 선택하고 비용 C_i를 지불하여 i단계 오른쪽으로 이동한 후 해당 위치의 문을 엽니다. C_i >= C_{i+1}이 1 <= i < n에 대해 보장됩니다.\n모든 문을 여는 데 필요한 최소 총 비용을 결정하는 것이 과제입니다.\n\n예시:\n    > f_36(3, [1, 1, 1])\n    3", "ml": "`function f_36(n, C)` എന്ന ജാവാസ്ക്രിപ്റ്റ് ഫംഗ്ഷൻ എഴുതുക താഴെ കൊടുത്തിരിക്കുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nn വാതിലുകൾ ഒരു വൃത്തത്തിൽ ക്രമീകരിച്ചിരിക്കുന്നു, കളിക്കാരൻ വാതിൽ 1-ന്റെ മുന്നിൽ നിന്ന് ആരംഭിക്കുന്നു.\nഓരോ തവണയും, കളിക്കാരൻ ഒരു സംഖ്യ i തിരഞ്ഞെടുക്കുകയും i ഘട്ടങ്ങൾ വലത്തേക്ക് നീങ്ങാൻ C_i ചെലവ് നൽകുകയും \nഅതിനുശേഷം ആ സ്ഥാനത്തെ വാതിൽ തുറക്കുകയും ചെയ്യാം. 1 <= i < n എന്നതിനായി C_i >= C_{i+1} എന്ന് ഉറപ്പുനൽകുന്നു.\nഎല്ലാ വാതിലുകളും തുറക്കാൻ ആവശ്യമായ ഏറ്റവും കുറഞ്ഞ മൊത്തം ചെലവ് നിർണയിക്കുകയാണ് ഈ ജോലിയുടെ ലക്ഷ്യം.\n\nഉദാഹരണം:\n    > f_36(3, [1, 1, 1])\n    3", "fa": "یک تابع جاوااسکریپت `function f_36(n, C)` بنویسید تا مسئله زیر را حل کند:\nبا توجه به n در که به صورت دایره‌ای چیده شده‌اند، بازیکن در مقابل در 1 شروع می‌کند.\nدر هر نوبت، بازیکن می‌تواند یک عدد i را انتخاب کند و هزینه C_i را بپردازد تا i قدم\nبه سمت راست حرکت کند و سپس در آن موقعیت را باز کند. تضمین شده است که\nC_i >= C_{i+1} برای 1 <= i < n.\nوظیفه این است که حداقل هزینه کل مورد نیاز برای باز کردن تمام درها را تعیین کنید.\n\nمثال:\n    > f_36(3, [1, 1, 1])\n    3"}, "level": "easy", "test": "function testf_36() {\n    console.assert(f_36(5, [4, 3, 3, 3, 3]) === 15);\n    console.assert(f_36(3, [1, 1, 1]) === 3);\n    console.assert(f_36(4, [5, 4, 3, 2]) === 11);\n    console.assert(f_36(4, [100, 99, 98, 97]) === 391);\n    console.assert(f_36(6, [10, 9, 8, 7, 6, 5]) === 35);\n    console.assert(f_36(7, [2, 2, 2, 2, 2, 2, 2]) === 14);\n    console.assert(f_36(8, [9, 7, 7, 7, 7, 7, 7, 7]) === 56);\n    console.assert(f_36(9, [3, 2, 2, 2, 2, 2, 2, 2, 2]) === 18);\n    console.assert(f_36(10, [6, 5, 5, 5, 5, 5, 5, 5, 5, 5]) === 50);\n    console.assert(f_36(11, [8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) === 11);\n\n}\n\ntestf_36();", "entry_point": "f_36", "signature": "function f_36(n, C)", "docstring": {"en": "Given n doors arranged in a circle, the player starts in front of door 1.\nEach turn, the player can choose a number i and pay a cost C_i to move i steps\nto the right and then open the door at that position. It is guaranteed that\nC_i >= C_{i+1} for 1 <= i < n.\nThe task is to determine the minimum total cost required to open all doors.\n\nExample:\n    > f_36(3, [1, 1, 1])\n    3\n", "sq": "Duke pasur parasysh n dyer të rregulluara në një rreth, lojtari fillon përballë derës 1. Çdo radhë, lojtari mund të zgjedhë një numër i dhe të paguajë një kosto C_i për të lëvizur i hapa djathtas dhe pastaj të hapë derën në atë pozicion. Është e garantuar që C_i >= C_{i+1} për 1 <= i < n. Detyra është të përcaktohet kostoja totale minimale e kërkuar për të hapur të gjitha dyert.\n\nShembull:\n    > f_36(3, [1, 1, 1])\n    3", "hy": "Տրված է n դռներ, որոնք դասավորված են շրջանաձև, խաղացողը սկսում է դռան 1 դիմացից։ Յուրաքանչյուր քայլի, խաղացողը կարող է ընտրել թիվ i և վճարել արժեք C_i՝ i քայլ աջ շարժվելու և այն դիրքի դուռը բացելու համար։ Երաշխավորված է, որ C_i >= C_{i+1} 1 <= i < n-ի համար։ Խնդիրը կայանում է որոշել բոլոր դռները բացելու համար անհրաժեշտ նվազագույն ընդհանուր արժեքը։\n\nՕրինակ:\n    > f_36(3, [1, 1, 1])\n    3", "bn": "nটি দরজা একটি বৃত্তে সাজানো আছে, খেলোয়াড় দরজা 1 এর সামনে থেকে শুরু করে। \nপ্রত্যেক টার্নে, খেলোয়াড় একটি সংখ্যা i বেছে নিতে পারে এবং i ধাপ ডানদিকে যেতে C_i খরচ দিতে পারে \nএবং তারপর সেই অবস্থানে দরজা খুলতে পারে। এটি নিশ্চিত যে \nC_i >= C_{i+1} যেখানে 1 <= i < n। \nসকল দরজা খোলার জন্য প্রয়োজনীয় সর্বনিম্ন মোট খরচ নির্ধারণ করাই কাজ।\n\nউদাহরণ:\n    > f_36(3, [1, 1, 1])\n    3", "bg": "Дадени са n врати, подредени в кръг, играчът започва пред врата 1. \nВсеки ход играчът може да избере число i и да плати цена C_i, за да се премести i стъпки надясно и след това да отвори вратата на тази позиция. Гарантирано е, че C_i >= C_{i+1} за 1 <= i < n. \nЗадачата е да се определи минималната обща цена, необходима за отваряне на всички врати.\n\nПример:\n    > f_36(3, [1, 1, 1])\n    3", "zh": "给定 n 个门按圆形排列，玩家从门 1 前面开始。  \n每一轮，玩家可以选择一个数字 i 并支付一个代价 C_i 向右移动 i 步，然后打开该位置的门。保证 C_i >= C_{i+1} 对于 1 <= i < n。  \n任务是确定打开所有门所需的最小总成本。\n\n示例：  \n    > f_36(3, [1, 1, 1])  \n    3  ", "fr": "Étant donné n portes disposées en cercle, le joueur commence devant la porte 1. À chaque tour, le joueur peut choisir un nombre i et payer un coût C_i pour avancer de i pas vers la droite puis ouvrir la porte à cette position. Il est garanti que C_i >= C_{i+1} pour 1 <= i < n. La tâche consiste à déterminer le coût total minimum nécessaire pour ouvrir toutes les portes.\n\nExemple :\n    > f_36(3, [1, 1, 1])\n    3", "de": "Gegeben n Türen, die in einem Kreis angeordnet sind, beginnt der Spieler vor Tür 1.\nJede Runde kann der Spieler eine Zahl i wählen und einen Kosten C_i zahlen, um i Schritte\nnach rechts zu gehen und dann die Tür an dieser Position zu öffnen. Es ist garantiert, dass\nC_i >= C_{i+1} für 1 <= i < n.\nDie Aufgabe besteht darin, die minimalen Gesamtkosten zu bestimmen, die erforderlich sind, um alle Türen zu öffnen.\n\nBeispiel:\n    > f_36(3, [1, 1, 1])\n    3", "ha": "An ba da ƙofa n da aka shirya a cikin da'ira, ɗan wasa yana farawa a gaban ƙofa ta 1. A kowane juyi, ɗan wasa zai iya zaɓar lamba i kuma ya biya farashi C_i don matsawa matakai i zuwa dama sannan ya buɗe ƙofar a wannan matsayi. An tabbatar da cewa C_i >= C_{i+1} don 1 <= i < n. Aikin shi ne a tantance mafi ƙarancin jimillar farashi da ake buƙata don buɗe duk ƙofofi.\n\nMisali:\n    > f_36(3, [1, 1, 1])\n    3", "hi": "n दरवाजों को एक वृत्त में व्यवस्थित किया गया है, खिलाड़ी दरवाजा 1 के सामने से शुरू करता है।  \nप्रत्येक चाल में, खिलाड़ी एक संख्या i चुन सकता है और i कदम दाईं ओर जाने के लिए एक लागत C_i का भुगतान कर सकता है और फिर उस स्थिति पर दरवाजा खोल सकता है। यह सुनिश्चित किया गया है कि  \nC_i >= C_{i+1} जहाँ 1 <= i < n।  \nकार्य यह निर्धारित करना है कि सभी दरवाजे खोलने के लिए न्यूनतम कुल लागत क्या होगी।\n\nउदाहरण:\n    > f_36(3, [1, 1, 1])\n    3", "hu": "Adott n ajtó, amelyek körben vannak elrendezve, a játékos az 1-es ajtó előtt kezd. Minden körben a játékos választhat egy számot i, és fizet egy C_i költséget, hogy i lépést tegyen jobbra, majd kinyissa az ott lévő ajtót. Garantált, hogy C_i >= C_{i+1} minden 1 <= i < n esetén. A feladat az, hogy meghatározzuk az összes ajtó kinyitásához szükséges minimális összköltséget.\n\nPélda:\n    > f_36(3, [1, 1, 1])\n    3", "es": "Dado n puertas dispuestas en un círculo, el jugador comienza frente a la puerta 1.  \nEn cada turno, el jugador puede elegir un número i y pagar un costo C_i para moverse i pasos a la derecha y luego abrir la puerta en esa posición. Se garantiza que C_i >= C_{i+1} para 1 <= i < n.  \nLa tarea es determinar el costo total mínimo requerido para abrir todas las puertas.\n\nEjemplo:  \n    > f_36(3, [1, 1, 1])  \n    3  ", "arb": "نظرًا لوجود n أبواب مرتبة في دائرة، يبدأ اللاعب أمام الباب 1.  \nفي كل دور، يمكن للاعب اختيار رقم i ودفع تكلفة C_i للتحرك i خطوات إلى اليمين ثم فتح الباب في هذا الموقع. من المضمون أن C_i >= C_{i+1} لـ 1 <= i < n.  \nالمهمة هي تحديد الحد الأدنى من التكلفة الإجمالية المطلوبة لفتح جميع الأبواب.\n\nمثال:  \n    > f_36(3, [1, 1, 1])  \n    3  ", "sw": "Kwa kuzingatia milango n iliyopangwa katika mduara, mchezaji anaanza mbele ya mlango wa 1. Kila zamu, mchezaji anaweza kuchagua namba i na kulipa gharama C_i ili kusogea hatua i kwenda kulia na kisha kufungua mlango katika nafasi hiyo. Inahakikishwa kuwa C_i >= C_{i+1} kwa 1 <= i < n. Kazi ni kubaini gharama ndogo kabisa inayohitajika kufungua milango yote.\n\nMfano:\n    > f_36(3, [1, 1, 1])\n    3", "tr": "Verilen n kapı bir çember şeklinde düzenlenmiştir, oyuncu kapı 1'in önünde başlar. Her turda, oyuncu bir sayı i seçebilir ve i adım sağa gitmek için bir maliyet C_i ödeyebilir ve ardından o konumdaki kapıyı açabilir. C_i >= C_{i+1} olduğu garanti edilir, 1 <= i < n için. Görev, tüm kapıları açmak için gereken minimum toplam maliyeti belirlemektir.\n\nÖrnek:\n    > f_36(3, [1, 1, 1])\n    3", "vi": "Cho n cánh cửa được sắp xếp theo hình tròn, người chơi bắt đầu trước cửa số 1. Mỗi lượt, người chơi có thể chọn một số i và trả một chi phí C_i để di chuyển i bước sang phải và sau đó mở cửa tại vị trí đó. Đảm bảo rằng C_i >= C_{i+1} cho 1 <= i < n. Nhiệm vụ là xác định tổng chi phí tối thiểu cần thiết để mở tất cả các cửa.\n\nVí dụ:\n    > f_36(3, [1, 1, 1])\n    3", "id": "Diberikan n pintu yang disusun dalam lingkaran, pemain mulai di depan pintu 1. Setiap giliran, pemain dapat memilih angka i dan membayar biaya C_i untuk bergerak i langkah ke kanan dan kemudian membuka pintu di posisi tersebut. Dijamin bahwa C_i >= C_{i+1} untuk 1 <= i < n. Tugasnya adalah menentukan total biaya minimum yang diperlukan untuk membuka semua pintu.\n\nContoh:\n    > f_36(3, [1, 1, 1])\n    3", "ja": "与えられた n 個のドアが円形に配置されている場合、プレイヤーはドア 1 の前からスタートします。\n各ターンで、プレイヤーは番号 i を選び、コスト C_i を支払って右に i ステップ移動し、その位置のドアを開けることができます。C_i >= C_{i+1} が 1 <= i < n の範囲で保証されています。\nすべてのドアを開けるために必要な最小の総コストを求めることが課題です。\n\n例:\n    > f_36(3, [1, 1, 1])\n    3", "ko": "주어진 n개의 문이 원형으로 배열되어 있을 때, 플레이어는 문 1 앞에서 시작합니다.  \n각 턴마다 플레이어는 숫자 i를 선택하고 비용 C_i를 지불하여 오른쪽으로 i단계 이동한 후 그 위치의 문을 엽니다.  \nC_i >= C_{i+1}는 1 <= i < n에 대해 보장됩니다.  \n모든 문을 여는 데 필요한 최소 총 비용을 결정하는 것이 과제입니다.\n\n예시:\n    > f_36(3, [1, 1, 1])\n    3", "ml": "n വാതിലുകൾ വൃത്താകൃതിയിൽ ക്രമീകരിച്ചിരിക്കുന്നപ്പോൾ, കളിക്കാരൻ വാതിൽ 1-ന്റെ മുന്നിൽ നിന്ന് തുടങ്ങുന്നു. ഓരോ തവണയും, കളിക്കാരൻ ഒരു സംഖ്യ i തിരഞ്ഞെടുക്കുകയും i വലത്തേക്ക് ചുവടുകൾ നീങ്ങാൻ ഒരു ചെലവ് C_i നൽകുകയും, പിന്നീട് ആ സ്ഥാനത്തെ വാതിൽ തുറക്കുകയും ചെയ്യാം. 1 <= i < n എന്നതിനുള്ള C_i >= C_{i+1} എന്ന് ഉറപ്പാണ്. എല്ലാ വാതിലുകളും തുറക്കുന്നതിനുള്ള കുറഞ്ഞ മൊത്തം ചെലവ് നിർണ്ണയിക്കുകയാണ് ഈ പ്രവർത്തനത്തിന്റെ ലക്ഷ്യം.\n\nഉദാഹരണം:\n    > f_36(3, [1, 1, 1])\n    3", "fa": "با توجه به n در که به صورت دایره‌ای چیده شده‌اند، بازیکن در مقابل در شماره 1 شروع می‌کند.  \nدر هر نوبت، بازیکن می‌تواند یک عدد i را انتخاب کند و هزینه C_i را بپردازد تا i قدم به سمت راست حرکت کند و سپس در آن موقعیت را باز کند. تضمین شده است که C_i >= C_{i+1} برای 1 <= i < n.  \nوظیفه این است که حداقل هزینه کل مورد نیاز برای باز کردن تمام درها را تعیین کنید.\n\nمثال:  \n    > f_36(3, [1, 1, 1])  \n    3  "}}
{"task_id": "JavaScript/37", "prompt": {"en": "/**\n * Given a sequence of student IDs entering a classroom, where the IDs range from 0 to N-1,\n * calculate the total number of handshakes that occur. Each student will shake hands with \n * every student already in the classroom who has a smaller ID number. The sequence represents \n * the order in which students enter the classroom.\n *\n * Examples:\n *    f_37(3, [2, 1, 0])  // returns 0\n */\nfunction f_37(n, order)", "sq": "/**\n * Duke pasur një sekuencë të ID-ve të studentëve që hyjnë në klasë, ku ID-të variojnë nga 0 deri në N-1,\n * llogarit numrin total të shtrëngimeve të duarve që ndodhin. Çdo student do të shtrëngojë duart me \n * çdo student që tashmë është në klasë dhe ka një numër ID më të vogël. Sekuenca përfaqëson \n * rendin në të cilin studentët hyjnë në klasë.\n *\n * Shembuj:\n *    f_37(3, [2, 1, 0])  // kthen 0\n */\nfunction f_37(n, order)", "hy": "/**\n * Տրված է ուսանողների ID-ների հաջորդականություն, որոնք մտնում են դասարան, որտեղ ID-ները տատանվում են 0-ից մինչև N-1,\n * հաշվարկել ընդհանուր ձեռքսեղմումների քանակը, որոնք տեղի են ունենում։ Յուրաքանչյուր ուսանող ձեռք կսեղմի \n * արդեն դասարանում գտնվող յուրաքանչյուր ուսանողի հետ, ով ունի ավելի փոքր ID համար։ Հաջորդականությունը ներկայացնում է \n * այն կարգը, որով ուսանողները մտնում են դասարան։\n *\n * Օրինակներ:\n *    f_37(3, [2, 1, 0])  // վերադարձնում է 0\n */\nfunction f_37(n, order)", "bn": "/**\n * একটি শ্রেণীকক্ষে প্রবেশ করা ছাত্রদের আইডি সমূহের একটি ক্রম দেওয়া হয়েছে, যেখানে আইডি 0 থেকে N-1 পর্যন্ত বিস্তৃত,\n * মোট কতগুলি হ্যান্ডশেক হয় তা গণনা করুন। প্রতিটি ছাত্র শ্রেণীকক্ষে ইতিমধ্যে উপস্থিত প্রতিটি ছাত্রের সাথে হ্যান্ডশেক করবে \n * যার আইডি নম্বর ছোট। ক্রমটি ছাত্রদের শ্রেণীকক্ষে প্রবেশের ক্রম নির্দেশ করে।\n *\n * উদাহরণ:\n *    f_37(3, [2, 1, 0])  // 0 ফেরত দেয়\n */\nfunction f_37(n, order)", "bg": "/**\n * Дадена е последователност от студентски ID номера, влизащи в класната стая, където ID номерата варират от 0 до N-1,\n * изчислете общия брой ръкостискания, които се случват. Всеки студент ще се ръкува с \n * всеки студент, който вече е в класната стая и има по-малък ID номер. Последователността представлява \n * реда, в който студентите влизат в класната стая.\n *\n * Примери:\n *    f_37(3, [2, 1, 0])  // връща 0\n */\nfunction f_37(n, order)", "zh": "/**\n * 给定一个进入教室的学生ID序列，其中ID范围从0到N-1，\n * 计算发生的握手总数。每个学生将与教室中已经存在的ID号较小的每个学生握手。\n * 该序列表示学生进入教室的顺序。\n *\n * 例子:\n *    f_37(3, [2, 1, 0])  // 返回 0\n */\nfunction f_37(n, order)", "fr": "/**\n * Étant donné une séquence d'IDs d'étudiants entrant dans une salle de classe, où les IDs vont de 0 à N-1,\n * calculez le nombre total de poignées de main qui se produisent. Chaque étudiant serrera la main de \n * chaque étudiant déjà dans la salle de classe qui a un numéro d'ID plus petit. La séquence représente \n * l'ordre dans lequel les étudiants entrent dans la salle de classe.\n *\n * Exemples :\n *    f_37(3, [2, 1, 0])  // retourne 0\n */\nfunction f_37(n, order)", "de": "/**\n * Gegeben eine Sequenz von Studenten-IDs, die einen Klassenraum betreten, wobei die IDs von 0 bis N-1 reichen,\n * berechne die Gesamtanzahl der Händedrucke, die stattfinden. Jeder Student wird jedem Studenten die Hand schütteln,\n * der bereits im Klassenraum ist und eine kleinere ID-Nummer hat. Die Sequenz repräsentiert die Reihenfolge, in der die Studenten den Klassenraum betreten.\n *\n * Beispiele:\n *    f_37(3, [2, 1, 0])  // gibt 0 zurück\n */\nfunction f_37(n, order)", "ha": "/**\n * An ba da jerin lambobin ID na ɗalibai suna shiga aji, inda lambobin ID ke tsakanin 0 zuwa N-1,\n * ƙididdige jimlar yawan musabaha da ke faruwa. Kowane ɗalibi zai yi musabaha da \n * kowane ɗalibi da ke cikin aji wanda ke da ƙaramin lambar ID. Jerin yana wakiltar \n * tsarin da ɗalibai ke shiga aji.\n *\n * Misalai:\n *    f_37(3, [2, 1, 0])  // yana dawowa 0\n */\nfunction f_37(n, order)", "hi": "/**\n * दिए गए अनुक्रम में छात्र आईडी के साथ एक कक्षा में प्रवेश करते हैं, जहां आईडी 0 से N-1 तक होती हैं,\n * कुल कितनी बार हाथ मिलाए जाते हैं, यह गणना करें। प्रत्येक छात्र उन सभी छात्रों से हाथ मिलाएगा \n * जो पहले से ही कक्षा में हैं और जिनकी आईडी संख्या उससे छोटी है। अनुक्रम उस क्रम को दर्शाता है \n * जिसमें छात्र कक्षा में प्रवेश करते हैं।\n *\n * उदाहरण:\n *    f_37(3, [2, 1, 0])  // 0 लौटाता है\n */\nfunction f_37(n, order)", "hu": "/**\n * Adott egy diákazonosító sorozat, akik belépnek egy tanterembe, ahol az azonosítók 0-tól N-1-ig terjednek,\n * számítsd ki a kézfogások összes számát, ami történik. Minden diák kezet fog minden olyan diákkal, \n * aki már a tanteremben van, és kisebb azonosítószámmal rendelkezik. A sorozat azt az sorrendet képviseli, \n * amelyben a diákok belépnek a tanterembe.\n *\n * Példák:\n *    f_37(3, [2, 1, 0])  // 0-t ad vissza\n */\nfunction f_37(n, order)", "es": "/**\n * Dada una secuencia de identificaciones de estudiantes que ingresan a un aula, donde las identificaciones van de 0 a N-1,\n * calcula el número total de apretones de manos que ocurren. Cada estudiante estrechará la mano con \n * cada estudiante que ya esté en el aula y que tenga un número de identificación menor. La secuencia representa \n * el orden en que los estudiantes ingresan al aula.\n *\n * Ejemplos:\n *    f_37(3, [2, 1, 0])  // devuelve 0\n */\nfunction f_37(n, order)", "arb": "/**\n * بالنظر إلى تسلسل معرفات الطلاب الذين يدخلون إلى الفصل الدراسي، حيث تتراوح المعرفات من 0 إلى N-1،\n * احسب العدد الإجمالي للمصافحات التي تحدث. كل طالب سوف يصافح كل طالب موجود بالفعل في الفصل \n * الذي لديه رقم معرف أصغر. يمثل التسلسل ترتيب دخول الطلاب إلى الفصل.\n *\n * أمثلة:\n *    f_37(3, [2, 1, 0])  // يعيد 0\n */\nfunction f_37(n, order)", "sw": "/**\n * Ukipewa mlolongo wa vitambulisho vya wanafunzi wanaoingia darasani, ambapo vitambulisho vinatoka 0 hadi N-1,\n * hesabu jumla ya mikono iliyoshikwa inayotokea. Kila mwanafunzi atashikana mikono na \n * kila mwanafunzi aliyeko darasani tayari ambaye ana namba ya kitambulisho ndogo. Mlolongo unaonyesha \n * mpangilio ambao wanafunzi wanaingia darasani.\n *\n * Mifano:\n *    f_37(3, [2, 1, 0])  // inarejesha 0\n */\nfunction f_37(n, order)", "tr": "/**\n * 0'dan N-1'e kadar olan öğrenci kimlik numaralarının bir sınıfa giriş sırasına göre,\n * gerçekleşen toplam tokalaşma sayısını hesaplayın. Her öğrenci, sınıfta zaten bulunan \n * ve daha küçük bir kimlik numarasına sahip olan her öğrenciyle tokalaşacaktır. \n * Sıra, öğrencilerin sınıfa giriş sırasını temsil eder.\n *\n * Örnekler:\n *    f_37(3, [2, 1, 0])  // 0 döndürür\n */\nfunction f_37(n, order)", "vi": "/**\n * Cho một dãy số ID của học sinh khi vào lớp học, trong đó các ID nằm trong khoảng từ 0 đến N-1,\n * tính tổng số lần bắt tay diễn ra. Mỗi học sinh sẽ bắt tay với \n * mọi học sinh đã có mặt trong lớp có số ID nhỏ hơn. Dãy số đại diện cho thứ tự học sinh vào lớp.\n *\n * Ví dụ:\n *    f_37(3, [2, 1, 0])  // trả về 0\n */\nfunction f_37(n, order)", "id": "/**\n * Diberikan urutan ID siswa yang memasuki kelas, di mana ID berkisar dari 0 hingga N-1,\n * hitung total jumlah jabat tangan yang terjadi. Setiap siswa akan berjabat tangan dengan \n * setiap siswa yang sudah ada di kelas yang memiliki nomor ID lebih kecil. Urutan tersebut \n * mewakili urutan di mana siswa memasuki kelas.\n *\n * Contoh:\n *    f_37(3, [2, 1, 0])  // mengembalikan 0\n */\nfunction f_37(n, order)", "ja": "/**\n * 学生IDが教室に入る順序が与えられたとき、IDは0からN-1までの範囲であるとします。\n * 発生する握手の総数を計算します。各学生は、すでに教室にいて自分より小さいID番号を持つ\n * すべての学生と握手をします。この順序は、学生が教室に入る順番を表しています。\n *\n * 例:\n *    f_37(3, [2, 1, 0])  // 0を返します\n */\nfunction f_37(n, order)", "ko": "/**\n * 학생 ID가 교실에 들어가는 순서가 주어졌을 때, ID는 0부터 N-1까지의 범위입니다.\n * 발생하는 총 악수의 수를 계산합니다. 각 학생은 이미 교실에 있는 자신보다 작은 ID 번호를 가진 \n * 모든 학생과 악수를 할 것입니다. 이 순서는 학생들이 교실에 들어가는 순서를 나타냅니다.\n *\n * 예시:\n *    f_37(3, [2, 1, 0])  // 0을 반환합니다\n */\nfunction f_37(n, order)", "ml": "/**\n * 0 മുതൽ N-1 വരെ ഉള്ള ഐഡികൾ ഉള്ള വിദ്യാർത്ഥികൾ ഒരു ക്ലാസ്റൂമിലേക്ക് പ്രവേശിക്കുന്ന ഒരു ക്രമം നൽകിയാൽ,\n * ഉണ്ടാകുന്ന ആകെ കൈകുലുക്കലുകളുടെ എണ്ണം കണക്കാക്കുക. ഓരോ വിദ്യാർത്ഥിയും \n * ക്ലാസ്റൂമിൽ ഇതിനകം ഉള്ള, തനിക്കു ചെറുതായ ഐഡി നമ്പർ ഉള്ള എല്ലാ വിദ്യാർത്ഥികളുമായും കൈകുലുക്കും. \n * ഈ ക്രമം വിദ്യാർത്ഥികൾ ക്ലാസ്റൂമിലേക്ക് പ്രവേശിക്കുന്ന ക്രമം പ്രതിനിധീകരിക്കുന്നു.\n *\n * ഉദാഹരണങ്ങൾ:\n *    f_37(3, [2, 1, 0])  // 0 മടക്കുന്നു\n */\nfunction f_37(n, order)", "fa": "/**\n * با توجه به دنباله‌ای از شناسه‌های دانش‌آموزانی که وارد کلاس می‌شوند، که شناسه‌ها از 0 تا N-1 هستند،\n * تعداد کل دست دادن‌هایی که اتفاق می‌افتد را محاسبه کنید. هر دانش‌آموز با هر دانش‌آموزی که قبلاً در کلاس حضور دارد و شناسه کوچکتری دارد، دست می‌دهد. \n * دنباله نشان‌دهنده ترتیب ورود دانش‌آموزان به کلاس است.\n *\n * مثال‌ها:\n *    f_37(3, [2, 1, 0])  // مقدار 0 را برمی‌گرداند\n */\nfunction f_37(n, order)"}, "canonical_solution": "{\n    let ans = 0;\n    const tr = new Array(n + 1).fill(0); // Increase the size to accommodate 1-indexed values.\n    for (let i = 0; i < n; ++i) {\n        let x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (let j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (let j = x; j <= n; j += j & (-j)) {\n            tr[j]++;\n        }\n    }\n    return ans;\n}", "instruction": {"en": "Write a JavaScript function `function f_37(n, order)` to solve the following problem:\nGiven a sequence of student IDs entering a classroom, where the IDs range from 0 to N-1,\ncalculate the total number of handshakes that occur. Each student will shake hands with\nevery student already in the classroom who has a smaller ID number. The sequence represents\nthe order in which students enter the classroom.\n\nExamples:\nf_37(3, [2, 1, 0])  // returns 0", "sq": "Shkruani një funksion JavaScript `function f_37(n, order)` për të zgjidhur problemin e mëposhtëm:\nDuke pasur një sekuencë të ID-ve të studentëve që hyjnë në një klasë, ku ID-të variojnë nga 0 deri në N-1,\nllogaritni numrin total të shtrëngimeve të duarve që ndodhin. Çdo student do të shtrëngojë duart me\nçdo student që tashmë është në klasë dhe që ka një numër ID më të vogël. Sekuenca përfaqëson\nradhën në të cilën studentët hyjnë në klasë.\n\nShembuj:\nf_37(3, [2, 1, 0])  // kthen 0", "hy": "Գրեք JavaScript ֆունկցիա `function f_37(n, order)`՝ հետևյալ խնդիրը լուծելու համար:\nՈւնենալով ուսանողների ID-ների հաջորդականություն, որոնք մտնում են դասարան, որտեղ ID-ները տատանվում են 0-ից մինչև N-1,\nհաշվեք ընդհանուր ձեռքսեղմումների քանակը, որոնք տեղի են ունենում։ Յուրաքանչյուր ուսանող ձեռք կսեղմի\nդասարանում արդեն գտնվող յուրաքանչյուր ուսանողի հետ, ով ունի ավելի փոքր ID համար։ Հաջորդականությունը ներկայացնում է\nդասարան մտնող ուսանողների կարգը։", "bn": "একটি JavaScript ফাংশন `function f_37(n, order)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি শ্রেণীকক্ষে প্রবেশ করা ছাত্রদের আইডির একটি ক্রম দেওয়া হয়েছে, যেখানে আইডিগুলি 0 থেকে N-1 পর্যন্ত রয়েছে, মোট কতগুলি হ্যান্ডশেক হয় তা গণনা করুন। প্রতিটি ছাত্র তার চেয়ে ছোট আইডি নম্বরের ছাত্রদের সাথে, যারা ইতিমধ্যে শ্রেণীকক্ষে আছে, হ্যান্ডশেক করবে। ক্রমটি ছাত্রদের শ্রেণীকক্ষে প্রবেশের ক্রমকে উপস্থাপন করে।\n\nউদাহরণ:\nf_37(3, [2, 1, 0])  // 0 রিটার্ন করে", "bg": "Напишете JavaScript функция `function f_37(n, order)` за решаване на следния проблем:  \nДадена е последователност от идентификатори на ученици, които влизат в класната стая, където идентификаторите варират от 0 до N-1,  \nизчислете общия брой ръкостискания, които се случват. Всеки ученик ще се ръкува с  \nвсеки ученик, който вече е в класната стая и има по-малък идентификационен номер. Последователността представлява  \nреда, в който учениците влизат в класната стая.\n\nПримери:  \nf_37(3, [2, 1, 0])  // връща 0", "zh": "编写一个 JavaScript 函数 `function f_37(n, order)` 来解决以下问题：  \n给定一个进入教室的学生ID序列，其中ID的范围是从0到N-1，  \n计算发生的握手总数。每个学生将与教室中每个ID号较小的学生握手。该序列表示学生进入教室的顺序。\n\n示例：  \nf_37(3, [2, 1, 0])  // 返回 0", "fr": "Écrire une fonction JavaScript `function f_37(n, order)` pour résoudre le problème suivant :  \nÉtant donné une séquence d'IDs d'étudiants entrant dans une salle de classe, où les IDs vont de 0 à N-1,  \ncalculez le nombre total de poignées de main qui se produisent. Chaque étudiant serrera la main de  \nchaque étudiant déjà dans la salle de classe qui a un numéro d'ID plus petit. La séquence représente  \nl'ordre dans lequel les étudiants entrent dans la salle de classe.  \n\nExemples :  \nf_37(3, [2, 1, 0])  // returns 0", "de": "Schreiben Sie eine JavaScript-Funktion `function f_37(n, order)`, um das folgende Problem zu lösen:\nGegeben ist eine Sequenz von Studenten-IDs, die ein Klassenzimmer betreten, wobei die IDs von 0 bis N-1 reichen.\nBerechnen Sie die Gesamtanzahl der stattfindenden Händedrucke. Jeder Student wird jedem bereits im Klassenzimmer befindlichen Studenten die Hand schütteln, der eine kleinere ID-Nummer hat. Die Sequenz repräsentiert die Reihenfolge, in der die Studenten das Klassenzimmer betreten.\n\nBeispiele:\nf_37(3, [2, 1, 0])  // gibt 0 zurück", "ha": "Rubuta wani aikin JavaScript `function f_37(n, order)` don warware matsalar mai zuwa:\nAn ba da jerin lambobin ID na ɗalibai da ke shiga aji, inda lambobin ID ɗin ke tsakanin 0 zuwa N-1,\nƙididdige jimlar adadin musabaha da ke faruwa. Kowanne ɗalibi zai yi musabaha da\nduk wani ɗalibi da ke cikin aji wanda ke da ƙaramin lamba ID. Jerin yana wakiltar tsarin da ɗalibai ke shiga aji.\n\nMisalai:\nf_37(3, [2, 1, 0])  // returns 0", "hi": "JavaScript फ़ंक्शन `function f_37(n, order)` लिखें ताकि निम्नलिखित समस्या को हल किया जा सके:\nएक कक्षा में प्रवेश करने वाले छात्र आईडी का अनुक्रम दिया गया है, जहाँ आईडी 0 से N-1 तक होती हैं,\nकुल हैंडशेक की संख्या की गणना करें जो होती है। प्रत्येक छात्र उन सभी छात्रों से हाथ मिलाएगा\nजो पहले से कक्षा में हैं और जिनकी आईडी संख्या छोटी है। अनुक्रम दर्शाता है\nजिस क्रम में छात्र कक्षा में प्रवेश करते हैं।", "hu": "Írj egy JavaScript függvényt `function f_37(n, order)` a következő probléma megoldására:\nAdott egy sorozat diákazonosító, akik belépnek egy osztályterembe, ahol az azonosítók 0-tól N-1-ig terjednek,\nszámítsd ki a kézfogások teljes számát, amelyek megtörténnek. Minden diák kezet fog\nminden már az osztályteremben lévő diákkal, akinek kisebb az azonosító száma. A sorozat azt az sorrendet képviseli,\namelyben a diákok belépnek az osztályterembe.\n\nPéldák:\nf_37(3, [2, 1, 0])  // visszaadja 0", "es": "Escribe una función de JavaScript `function f_37(n, order)` para resolver el siguiente problema:\nDada una secuencia de identificaciones de estudiantes que ingresan a un aula, donde las identificaciones varían de 0 a N-1,\ncalcula el número total de apretones de manos que ocurren. Cada estudiante estrechará la mano con\ncada estudiante que ya esté en el aula y que tenga un número de identificación menor. La secuencia representa\nel orden en que los estudiantes ingresan al aula.\n\nEjemplos:\nf_37(3, [2, 1, 0])  // devuelve 0", "arb": "اكتب دالة JavaScript `function f_37(n, order)` لحل المشكلة التالية:\nبالنظر إلى تسلسل معرفات الطلاب الذين يدخلون الفصل، حيث تتراوح المعرفات من 0 إلى N-1،\nاحسب العدد الإجمالي للمصافحات التي تحدث. كل طالب سوف يصافح\nكل طالب موجود بالفعل في الفصل الذي لديه رقم تعريف أصغر. يمثل التسلسل\nالترتيب الذي يدخل فيه الطلاب إلى الفصل.\n\nأمثلة:\nf_37(3, [2, 1, 0])  // يعيد 0", "sw": "Andika kazi ya JavaScript `function f_37(n, order)` kutatua tatizo lifuatalo:\nUkipiwa mlolongo wa vitambulisho vya wanafunzi wanaoingia darasani, ambapo vitambulisho vinatoka 0 hadi N-1,\nhesabu jumla ya mikono iliyoshikwa. Kila mwanafunzi atashikana mikono na kila mwanafunzi aliyeko darasani tayari ambaye ana namba ya kitambulisho ndogo zaidi. Mlolongo unawakilisha mpangilio ambao wanafunzi wanaingia darasani.\n\nMifano:\nf_37(3, [2, 1, 0])  // inarudisha 0", "tr": "Bir JavaScript fonksiyonu `function f_37(n, order)` yazın ve aşağıdaki problemi çözün:\nBir sınıfa giren öğrenci kimlik numaralarının bir dizisi verildiğinde, kimlik numaraları 0'dan N-1'e kadar sıralanır, toplam tokalaşma sayısını hesaplayın. Her öğrenci, sınıfta zaten bulunan ve daha küçük bir kimlik numarasına sahip olan her öğrenciyle tokalaşacaktır. Dizi, öğrencilerin sınıfa giriş sırasını temsil eder.\n\nÖrnekler:\nf_37(3, [2, 1, 0])  // 0 döndürür", "vi": "Viết một hàm JavaScript `function f_37(n, order)` để giải quyết vấn đề sau:\nCho một dãy số ID của học sinh khi vào lớp học, trong đó các ID có giá trị từ 0 đến N-1,\ntính tổng số lần bắt tay xảy ra. Mỗi học sinh sẽ bắt tay với\nmọi học sinh đã có mặt trong lớp có số ID nhỏ hơn. Dãy số biểu thị\nthứ tự học sinh vào lớp.\n\nVí dụ:\nf_37(3, [2, 1, 0])  // trả về 0", "id": "Tulis sebuah fungsi JavaScript `function f_37(n, order)` untuk menyelesaikan masalah berikut:  \nDiberikan sebuah urutan ID siswa yang memasuki ruang kelas, di mana ID berkisar dari 0 hingga N-1,  \nhitung total jumlah jabat tangan yang terjadi. Setiap siswa akan berjabat tangan dengan  \nsetiap siswa yang sudah ada di ruang kelas yang memiliki nomor ID lebih kecil. Urutan tersebut mewakili  \nurutan di mana siswa memasuki ruang kelas.\n\nContoh:  \nf_37(3, [2, 1, 0])  // mengembalikan 0", "ja": "JavaScript関数 `function f_37(n, order)` を作成して、次の問題を解決してください:\n教室に入る学生IDのシーケンスが与えられます。IDは0からN-1の範囲です。\n発生する握手の総数を計算します。各学生は、すでに教室にいる自分より小さいID番号のすべての学生と握手します。このシーケンスは、学生が教室に入る順序を表しています。\n\n例:\nf_37(3, [2, 1, 0])  // 0を返します", "ko": "JavaScript 함수를 작성하세요 `function f_37(n, order)` 다음 문제를 해결하기 위해:\n학생 ID가 0부터 N-1까지 범위인 학생들이 교실에 들어오는 순서가 주어졌을 때,\n발생하는 총 악수 횟수를 계산하세요. 각 학생은 이미 교실에 있는 자신보다 작은 ID 번호를 가진\n모든 학생과 악수를 합니다. 이 순서는 학생들이 교실에 들어오는 순서를 나타냅니다.\n\n예시:\nf_37(3, [2, 1, 0])  // 0을 반환합니다.", "ml": "`function f_37(n, order)` എന്ന ജാവാസ്ക്രിപ്റ്റ് ഫംഗ്ഷൻ എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ: വിദ്യാർത്ഥികളുടെ ഐഡി ക്രമത്തിൽ ക്ലാസ്റൂമിലേക്ക് പ്രവേശിക്കുന്ന ഒരു ശ്രേണി നൽകിയിരിക്കുന്നു, ഇവിടെ ഐഡികൾ 0 മുതൽ N-1 വരെ ആണ്, സംഭവിക്കുന്ന ആകെ കൈകുലുക്കലുകളുടെ എണ്ണം കണക്കാക്കുക. ഓരോ വിദ്യാർത്ഥിയും ക്ലാസ്റൂമിൽ ഇതിനകം ഉള്ള, തനിക്കു ചുരുങ്ങിയ ഐഡി നമ്പർ ഉള്ള എല്ലാ വിദ്യാർത്ഥികളുമായും കൈകുലുക്കും. ഈ ശ്രേണി വിദ്യാർത്ഥികൾ ക്ലാസ്റൂമിലേക്ക് പ്രവേശിക്കുന്ന ക്രമം പ്രതിനിധീകരിക്കുന്നു.\n\nഉദാഹരണങ്ങൾ:\nf_37(3, [2, 1, 0])  // 0 മടക്കുന്നു", "fa": "یک تابع جاوااسکریپت `function f_37(n, order)` بنویسید تا مسئله زیر را حل کند:\nبا توجه به یک دنباله از شناسه‌های دانش‌آموزانی که وارد کلاس می‌شوند، که شناسه‌ها از 0 تا N-1 متغیر هستند،\nتعداد کل دست دادن‌هایی که اتفاق می‌افتد را محاسبه کنید. هر دانش‌آموز با هر دانش‌آموزی که قبلاً در کلاس حضور دارد و شناسه کوچکتری دارد دست می‌دهد. دنباله نشان‌دهنده ترتیب ورود دانش‌آموزان به کلاس است.\n\nمثال‌ها:\nf_37(3, [2, 1, 0])  // مقدار 0 را برمی‌گرداند"}, "level": "middle", "test": "(() => {\n    console.assert(f_37(4, [2, 1, 3, 0]) === 2, \"Test 1 failed\");\n    console.assert(f_37(6, [0, 1, 2, 3, 4, 5]) === 15, \"Test 2 failed\");\n    console.assert(f_37(3, [1, 2, 0]) === 1, \"Test 3 failed\");\n    console.assert(f_37(4, [3, 2, 1, 0]) === 0, \"Test 4 failed\");\n    console.assert(f_37(4, [0, 1, 2, 3]) === 6, \"Test 5 failed\");\n    console.assert(f_37(6, [5, 4, 3, 2, 1, 0]) === 0, \"Test 6 failed\");\n    console.assert(f_37(4, [0, 2, 1, 3]) === 5, \"Test 7 failed\");\n    console.assert(f_37(5, [3, 1, 4, 2, 0]) === 3, \"Test 8 failed\");\n    console.assert(f_37(4, [1, 0, 3, 2]) === 4, \"Test 9 failed\");\n    console.assert(f_37(3, [2, 0, 1]) === 1, \"Test 10 failed\");\n    console.assert(f_37(5, [1, 3, 0, 2, 4]) === 7, \"Test 11 failed\");\n    console.assert(f_37(5, [4, 3, 2, 1, 0]) === 0, \"Test 12 failed\");\n})();", "entry_point": "f_37", "signature": "function f_37(n, order)", "docstring": {"en": "Given a sequence of student IDs entering a classroom, where the IDs range from 0 to N-1,\ncalculate the total number of handshakes that occur. Each student will shake hands with\nevery student already in the classroom who has a smaller ID number. The sequence represents\nthe order in which students enter the classroom.\n\nExamples:\nf_37(3, [2, 1, 0])  // returns 0", "sq": "Duke pasur një sekuencë të ID-ve të studentëve që hyjnë në klasë, ku ID-të variojnë nga 0 deri në N-1,\nllogaritet numri total i shtrëngimeve të duarve që ndodhin. Çdo student do të shtrëngojë duart me\nçdo student që tashmë është në klasë dhe që ka një numër ID më të vogël. Sekuenca përfaqëson\nradhën në të cilën studentët hyjnë në klasë.\n\nShembuj:\nf_37(3, [2, 1, 0])  // kthen 0", "hy": "Ունենալով ուսանողների ID-ների հաջորդականություն, որոնք մտնում են դասարան, որտեղ ID-ները տատանվում են 0-ից մինչև N-1, հաշվեք տեղի ունեցող ողջունումների ընդհանուր քանակը։ Յուրաքանչյուր ուսանող ողջունում է արդեն դասարանում գտնվող բոլոր ուսանողներին, որոնց ID-ն ավելի փոքր է։ Հաջորդականությունը ներկայացնում է ուսանողների դասարան մտնելու հերթականությունը։\n\nՕրինակներ:\nf_37(3, [2, 1, 0])  // վերադարձնում է 0", "bn": "প্রদত্ত একটি সিকোয়েন্স যেখানে ছাত্রদের আইডি রয়েছে যারা একটি শ্রেণীকক্ষে প্রবেশ করছে, যেখানে আইডিগুলি 0 থেকে N-1 পর্যন্ত বিস্তৃত, মোট কতগুলি হ্যান্ডশেক হয় তা গণনা করুন। প্রতিটি ছাত্র শ্রেণীকক্ষে ইতিমধ্যে উপস্থিত প্রতিটি ছাত্রের সাথে হ্যান্ডশেক করবে যার আইডি নম্বর ছোট। সিকোয়েন্সটি ছাত্রদের শ্রেণীকক্ষে প্রবেশের ক্রমকে উপস্থাপন করে।\n\nউদাহরণ:\nf_37(3, [2, 1, 0])  // 0 রিটার্ন করে", "bg": "Дадена е последователност от идентификатори на студенти, влизащи в класна стая, където идентификаторите варират от 0 до N-1, изчислете общия брой ръкостискания, които се случват. Всеки студент ще се ръкува с всеки студент, който вече е в класната стая и има по-малък идентификационен номер. Последователността представлява реда, в който студентите влизат в класната стая.\n\nПримери:\nf_37(3, [2, 1, 0])  // връща 0", "zh": "给定一个进入教室的学生ID序列，其中ID范围从0到N-1，计算发生的握手总数。每个学生将与已经在教室中且ID号较小的每个学生握手。序列表示学生进入教室的顺序。\n\n示例：\nf_37(3, [2, 1, 0])  // 返回 0", "fr": "Étant donné une séquence d'IDs d'étudiants entrant dans une salle de classe, où les IDs vont de 0 à N-1, calculez le nombre total de poignées de main qui se produisent. Chaque étudiant serrera la main de chaque étudiant déjà dans la salle de classe qui a un numéro d'ID plus petit. La séquence représente l'ordre dans lequel les étudiants entrent dans la salle de classe.\n\nExemples :\nf_37(3, [2, 1, 0])  // retourne 0", "de": "Angenommen, eine Sequenz von Studenten-IDs betritt einen Klassenraum, wobei die IDs von 0 bis N-1 reichen, berechnen Sie die Gesamtanzahl der stattfindenden Händedrucke. Jeder Student wird mit jedem bereits im Klassenraum befindlichen Studenten, der eine kleinere ID-Nummer hat, Händeschütteln. Die Sequenz repräsentiert die Reihenfolge, in der die Studenten den Klassenraum betreten.\n\nBeispiele:\nf_37(3, [2, 1, 0])  // gibt 0 zurück", "ha": "An ba da jerin lambobin dalibai suna shiga aji, inda lambobin ID ke tsakanin 0 zuwa N-1, ƙididdige adadin yawan gaisuwar hannu da ke faruwa. Kowanne dalibi zai gaisa da kowanne dalibi da ke cikin aji wanda ke da ƙaramin lamba. Jerin yana wakiltar tsarin da dalibai ke shiga aji.\n\nMisalai:\nf_37(3, [2, 1, 0])  // yana dawowa 0", "hi": "एक कक्षा में प्रवेश करने वाले छात्र आईडी की एक अनुक्रम दिया गया है, जहाँ आईडी 0 से N-1 तक होती हैं, कुल हाथ मिलाने की संख्या की गणना करें जो होती है। प्रत्येक छात्र उन सभी छात्रों से हाथ मिलाएगा जो पहले से कक्षा में हैं और जिनकी आईडी संख्या छोटी है। अनुक्रम उस क्रम को दर्शाता है जिसमें छात्र कक्षा में प्रवेश करते हैं।\n\nउदाहरण:\nf_37(3, [2, 1, 0])  // 0 लौटाता है", "hu": "Adott egy diákazonosítókból álló sorozat, akik belépnek egy osztályterembe, ahol az azonosítók 0-tól N-1-ig terjednek, számítsuk ki a kézfogások teljes számát, amelyek megtörténnek. Minden diák kezet fog minden olyan diákkal, aki már az osztályteremben van, és kisebb azonosító számmal rendelkezik. A sorozat azt a sorrendet képviseli, amelyben a diákok belépnek az osztályterembe.\n\nPéldák:\nf_37(3, [2, 1, 0])  // visszaadja 0", "es": "Dada una secuencia de identificaciones de estudiantes que ingresan a un aula, donde las identificaciones varían de 0 a N-1, calcula el número total de apretones de manos que ocurren. Cada estudiante estrechará la mano con cada estudiante que ya esté en el aula y que tenga un número de identificación menor. La secuencia representa el orden en que los estudiantes ingresan al aula.\n\nEjemplos:\nf_37(3, [2, 1, 0])  // devuelve 0", "arb": "بالنظر إلى تسلسل معرفات الطلاب الذين يدخلون الفصل، حيث تتراوح المعرفات من 0 إلى N-1، احسب العدد الإجمالي للمصافحات التي تحدث. كل طالب سيصافح كل طالب موجود بالفعل في الفصل الذي لديه رقم معرف أصغر. يمثل التسلسل الترتيب الذي يدخل به الطلاب إلى الفصل.\n\nأمثلة:\nf_37(3, [2, 1, 0])  // يعيد 0", "sw": "Kwa kupewa mlolongo wa vitambulisho vya wanafunzi wanaoingia darasani, ambapo vitambulisho vinaanzia 0 hadi N-1, hesabu jumla ya mikono inayoshikana. Kila mwanafunzi atashikana mikono na kila mwanafunzi ambaye tayari yuko darasani na ana namba ya kitambulisho ndogo zaidi. Mlolongo unawakilisha mpangilio ambao wanafunzi wanaingia darasani.\n\nMifano:\nf_37(3, [2, 1, 0])  // inarudisha 0", "tr": "Verilen bir sınıfa giren öğrenci kimlik numaralarının dizisinde, kimlik numaraları 0'dan N-1'e kadar sıralanmıştır,\ntoplam tokalaşma sayısını hesaplayın. Her öğrenci, sınıfta zaten bulunan ve daha küçük bir kimlik numarasına sahip olan\nher öğrenciyle tokalaşacaktır. Dizi, öğrencilerin sınıfa giriş sırasını temsil eder.\n\nÖrnekler:\nf_37(3, [2, 1, 0])  // 0 döndürür", "vi": "Cho một dãy số ID của học sinh khi vào lớp học, trong đó các ID có giá trị từ 0 đến N-1,\ntính tổng số lần bắt tay xảy ra. Mỗi học sinh sẽ bắt tay với\nmỗi học sinh đã có mặt trong lớp học có số ID nhỏ hơn. Dãy số đại diện cho\nthứ tự mà học sinh vào lớp học.\n\nVí dụ:\nf_37(3, [2, 1, 0])  // trả về 0", "id": "Diberikan urutan ID siswa yang memasuki ruang kelas, di mana ID berkisar dari 0 hingga N-1, hitung jumlah total jabat tangan yang terjadi. Setiap siswa akan berjabat tangan dengan setiap siswa yang sudah ada di ruang kelas yang memiliki nomor ID lebih kecil. Urutan tersebut mewakili urutan di mana siswa memasuki ruang kelas.\n\nContoh:\nf_37(3, [2, 1, 0])  // mengembalikan 0", "ja": "与えられた教室に入る学生IDのシーケンスがあり、IDは0からN-1までの範囲です。このとき、発生する握手の総数を計算します。各学生は、教室にすでにいる自分より小さいID番号を持つすべての学生と握手します。このシーケンスは、学生が教室に入る順序を表しています。\n\n例:\nf_37(3, [2, 1, 0])  // 0を返します", "ko": "학생 ID가 교실에 들어가는 순서가 주어졌을 때, ID는 0부터 N-1까지의 범위입니다.\n  * 발생하는 총 악수의 수를 계산합니다. 각 학생은 이미 교실에 있는 자신보다 작은 ID 번호를 가진 \n   * 모든 학생과 악수를 할 것입니다. 이 순서는 학생들이 교실에 들어가는 순서를 나타냅니다. \n\n예시:\nf_37(3, [2, 1, 0])  // 0을 반환합니다.", "ml": "നൽകിയിരിക്കുന്ന വിദ്യാർത്ഥി ഐഡി ക്രമത്തിൽ ഒരു ക്ലാസ്റൂമിലേക്ക് പ്രവേശിക്കുന്നതിനാൽ, ഐഡികൾ 0 മുതൽ N-1 വരെ ആയിരിക്കും, ഉണ്ടാകുന്ന ആകെ കൈകുലുക്കലുകളുടെ എണ്ണം കണക്കാക്കുക. ഓരോ വിദ്യാർത്ഥിയും, ക്ലാസ്റൂമിൽ ഇതിനകം ഉള്ള, തങ്ങളേക്കാൾ ചെറിയ ഐഡി നമ്പർ ഉള്ള എല്ലാ വിദ്യാർത്ഥികളുമായി കൈകുലുക്കും. വിദ്യാർത്ഥികൾ ക്ലാസ്റൂമിലേക്ക് പ്രവേശിക്കുന്ന ക്രമം ഈ ക്രമം പ്രതിനിധീകരിക്കുന്നു.\n\nഉദാഹരണങ്ങൾ:\nf_37(3, [2, 1, 0])  // 0 മടക്കുന്നു", "fa": "با توجه به دنباله‌ای از شناسه‌های دانش‌آموزانی که وارد کلاس می‌شوند، که شناسه‌ها از 0 تا N-1 هستند، تعداد کل دست‌دادن‌هایی که رخ می‌دهد را محاسبه کنید. هر دانش‌آموز با هر دانش‌آموزی که قبلاً در کلاس است و شناسه کوچک‌تری دارد، دست می‌دهد. دنباله نشان‌دهنده ترتیب ورود دانش‌آموزان به کلاس است.\n\nمثال‌ها:\nf_37(3, [2, 1, 0])  // مقدار 0 را برمی‌گرداند"}}
{"task_id": "JavaScript/38", "prompt": {"en": "/**\n * Given n positive integers representing the count of each number from 1 to n, \n * find the maximum sum of the mode (most frequent element) for all prefixes of \n * a sequence constructed from these numbers. The mode is the largest number \n * among the most frequent elements in a sequence.\n * For example:\n *   f_38(3, [1, 2, 3])\n *   A sequence that reaches its maximum value is [3, 2, 3, 1, 2, 2], and the sum is 17.\n */\nfunction f_38(n, counts)", "sq": "/**\n * Duke pasur n numra pozitivë që përfaqësojnë numrin e secilit numër nga 1 deri në n, \n * gjeni shumën maksimale të modës (elementi më i shpeshtë) për të gjitha prefikset e \n * një sekuence të ndërtuar nga këta numra. Moda është numri më i madh \n * ndër elementët më të shpeshtë në një sekuencë.\n * Për shembull:\n *   f_38(3, [1, 2, 3])\n *   Një sekuencë që arrin vlerën e saj maksimale është [3, 2, 3, 1, 2, 2], dhe shuma është 17.\n */\nfunction f_38(n, counts)", "hy": "/**\n * Տրված է n դրական ամբողջ թիվ, որը ներկայացնում է 1-ից n թվերի քանակը,\n * գտնել մոդայի (ամենահաճախ հանդիպող տարր) առավելագույն գումարը բոլոր նախածանցների համար\n * հաջորդականության, որը կառուցված է այս թվերից։ Մոդան հաջորդականության ամենահաճախ հանդիպող տարրերի\n * մեջ ամենամեծ թիվն է։\n * Օրինակ:\n *   f_38(3, [1, 2, 3])\n *   Հաջորդականություն, որը հասնում է իր առավելագույն արժեքին, [3, 2, 3, 1, 2, 2] է, և գումարը 17 է։\n */\nfunction f_38(n, counts)", "bn": "/**\n * ১ থেকে n পর্যন্ত প্রতিটি সংখ্যার গণনা উপস্থাপনকারী n ধনাত্মক পূর্ণসংখ্যা দেওয়া আছে, \n * এই সংখ্যাগুলি থেকে নির্মিত একটি ক্রমের সমস্ত উপসর্গের জন্য মোডের (সবচেয়ে ঘন ঘন উপাদান) সর্বাধিক যোগফল খুঁজে বের করুন। \n * মোড হল একটি ক্রমের সবচেয়ে ঘন ঘন উপাদানগুলির মধ্যে বৃহত্তম সংখ্যা।\n * উদাহরণস্বরূপ:\n *   f_38(3, [1, 2, 3])\n *   একটি ক্রম যা তার সর্বাধিক মানে পৌঁছায় তা হল [3, 2, 3, 1, 2, 2], এবং যোগফল হল 17।\n */ \nfunction f_38(n, counts)", "bg": "/**\n * Дадени са n положителни цели числа, представляващи броя на всяко число от 1 до n,\n * намерете максималната сума на модата (най-често срещания елемент) за всички префикси на\n * последователност, конструирана от тези числа. Модата е най-голямото число\n * сред най-често срещаните елементи в последователност.\n * Например:\n *   f_38(3, [1, 2, 3])\n *   Последователност, която достига максималната си стойност е [3, 2, 3, 1, 2, 2], и сумата е 17.\n */\nfunction f_38(n, counts)", "zh": "/**\n * 给定 n 个正整数，表示从 1 到 n 的每个数字的计数，\n * 找出从这些数字构造的序列的所有前缀的众数（最频繁元素）的最大和。\n * 众数是序列中最频繁元素中最大的数字。\n * 例如：\n *   f_38(3, [1, 2, 3])\n *   一个达到最大值的序列是 [3, 2, 3, 1, 2, 2]，和是 17。\n */\nfunction f_38(n, counts)", "fr": "/**\n * Étant donné n entiers positifs représentant le compte de chaque nombre de 1 à n,\n * trouvez la somme maximale du mode (élément le plus fréquent) pour tous les préfixes d'une\n * séquence construite à partir de ces nombres. Le mode est le plus grand nombre\n * parmi les éléments les plus fréquents dans une séquence.\n * Par exemple :\n *   f_38(3, [1, 2, 3])\n *   Une séquence qui atteint sa valeur maximale est [3, 2, 3, 1, 2, 2], et la somme est 17.\n */\nfunction f_38(n, counts)", "de": "/**\n * Gegeben n positive ganze Zahlen, die die Anzahl jedes Zahl von 1 bis n darstellen,\n * finde die maximale Summe des Modus (häufigstes Element) für alle Präfixe einer\n * Sequenz, die aus diesen Zahlen konstruiert wurde. Der Modus ist die größte Zahl\n * unter den häufigsten Elementen in einer Sequenz.\n * Zum Beispiel:\n *   f_38(3, [1, 2, 3])\n *   Eine Sequenz, die ihren Maximalwert erreicht, ist [3, 2, 3, 1, 2, 2], und die Summe ist 17.\n */\nfunction f_38(n, counts)", "ha": "/**\n * An ba da lambobi masu kyau n waɗanda ke wakiltar adadin kowace lamba daga 1 zuwa n,\n * nemo mafi girman jimillar yanayin (mafi yawan abu) don dukkan ƙarin\n * jerin da aka gina daga waɗannan lambobin. Yanayin shine mafi girman lamba\n * tsakanin abubuwan da suka fi yawa a cikin jerin.\n * Alal misali:\n *   f_38(3, [1, 2, 3])\n *   Jerin da ya kai ga ƙimar sa mafi girma shine [3, 2, 3, 1, 2, 2], kuma jimillar ita ce 17.\n */\nfunction f_38(n, counts)", "hi": "/**\n * दिए गए n धनात्मक पूर्णांक जो 1 से n तक प्रत्येक संख्या की गिनती का प्रतिनिधित्व करते हैं,\n * अनुक्रम के सभी उपसर्गों के लिए मोड (सबसे अधिक बार आने वाला तत्व) का अधिकतम योग खोजें\n * जो इन संख्याओं से निर्मित होता है। मोड अनुक्रम में सबसे अधिक बार आने वाले तत्वों में सबसे बड़ी संख्या है।\n * उदाहरण के लिए:\n *   f_38(3, [1, 2, 3])\n *   एक अनुक्रम जो अपने अधिकतम मान तक पहुँचता है वह है [3, 2, 3, 1, 2, 2], और योग 17 है।\n */\nfunction f_38(n, counts)", "hu": "/**\n * Adott n pozitív egész szám, amelyek az 1-től n-ig terjedő számok számát jelölik, \n * keresse meg a módusz (leggyakrabban előforduló elem) maximális összegét az \n * ezekből a számokból felépített sorozat minden előtagjára. A módusz a legnagyobb \n * szám a sorozat leggyakrabban előforduló elemei között.\n * Például:\n *   f_38(3, [1, 2, 3])\n *   Egy sorozat, amely eléri a maximális értékét: [3, 2, 3, 1, 2, 2], és az összeg 17.\n */\nfunction f_38(n, counts)", "es": "/**\n * Dado n enteros positivos que representan la cantidad de cada número de 1 a n, \n * encuentra la suma máxima del modo (elemento más frecuente) para todos los prefijos de \n * una secuencia construida a partir de estos números. El modo es el número más grande \n * entre los elementos más frecuentes en una secuencia.\n * Por ejemplo:\n *   f_38(3, [1, 2, 3])\n *   Una secuencia que alcanza su valor máximo es [3, 2, 3, 1, 2, 2], y la suma es 17.\n */\nfunction f_38(n, counts)", "arb": "/**\n * بالنظر إلى n من الأعداد الصحيحة الموجبة التي تمثل عدد كل رقم من 1 إلى n،\n * ابحث عن الحد الأقصى لمجموع النمط (العنصر الأكثر تكرارًا) لجميع البادئات\n * لتسلسل مُنشأ من هذه الأرقام. النمط هو أكبر رقم بين العناصر الأكثر تكرارًا في تسلسل.\n * على سبيل المثال:\n *   f_38(3, [1, 2, 3])\n *   تسلسل يصل إلى قيمته القصوى هو [3, 2, 3, 1, 2, 2]، والمجموع هو 17.\n */\nfunction f_38(n, counts)", "sw": "/**\n * Ukipewa n nambari chanya zinazoashiria idadi ya kila nambari kutoka 1 hadi n, \n * pata jumla ya juu zaidi ya hali (kipengele kinachojitokeza mara nyingi zaidi) kwa viambishi vyote vya \n * mlolongo ulioundwa kutoka kwa nambari hizi. Hali ni nambari kubwa zaidi \n * kati ya vipengele vinavyojitokeza mara nyingi zaidi katika mlolongo.\n * Kwa mfano:\n *   f_38(3, [1, 2, 3])\n *   Mlolongo unaofikia thamani yake ya juu zaidi ni [3, 2, 3, 1, 2, 2], na jumla ni 17.\n */\nfunction f_38(n, counts)", "tr": "/**\n * 1'den n'e kadar olan her sayının sayısını temsil eden n pozitif tamsayı verildiğinde,\n * bu sayılardan oluşturulan bir dizinin tüm önekleri için modun (en sık rastlanan eleman) maksimum toplamını bulun.\n * Mod, bir dizideki en sık rastlanan elemanlar arasında en büyük sayıdır.\n * Örneğin:\n *   f_38(3, [1, 2, 3])\n *   Maksimum değerine ulaşan bir dizi [3, 2, 3, 1, 2, 2] ve toplam 17'dir.\n */\nfunction f_38(n, counts)", "vi": "/**\n * Cho n số nguyên dương đại diện cho số lượng của mỗi số từ 1 đến n, \n * tìm tổng lớn nhất của mode (phần tử xuất hiện nhiều nhất) cho tất cả các tiền tố của \n * một dãy được tạo từ các số này. Mode là số lớn nhất \n * trong số các phần tử xuất hiện nhiều nhất trong một dãy.\n * Ví dụ:\n *   f_38(3, [1, 2, 3])\n *   Một dãy đạt giá trị tối đa là [3, 2, 3, 1, 2, 2], và tổng là 17.\n */\nfunction f_38(n, counts)", "id": "/**\n * Diberikan n bilangan bulat positif yang mewakili jumlah masing-masing angka dari 1 hingga n,\n * temukan jumlah maksimum dari modus (elemen yang paling sering muncul) untuk semua awalan dari\n * sebuah urutan yang dibangun dari angka-angka ini. Modus adalah angka terbesar\n * di antara elemen yang paling sering muncul dalam sebuah urutan.\n * Sebagai contoh:\n *   f_38(3, [1, 2, 3])\n *   Sebuah urutan yang mencapai nilai maksimumnya adalah [3, 2, 3, 1, 2, 2], dan jumlahnya adalah 17.\n */\nfunction f_38(n, counts)", "ja": "/**\n * 1からnまでの各数字の個数を表すn個の正の整数が与えられたとき、これらの数字から構成されるシーケンスのすべての接頭辞に対して、モード（最頻出要素）の最大合計を見つけます。モードはシーケンス内の最頻出要素の中で最大の数字です。\n * 例えば:\n *   f_38(3, [1, 2, 3])\n *   最大値に達するシーケンスは [3, 2, 3, 1, 2, 2] であり、合計は17です。\n */\nfunction f_38(n, counts)", "ko": "/**\n * 1부터 n까지의 각 숫자의 개수를 나타내는 n개의 양의 정수가 주어졌을 때, \n * 이러한 숫자로 구성된 시퀀스의 모든 접두사에 대해 최빈값(가장 빈번한 요소)의 최대 합을 찾으시오. \n * 최빈값은 시퀀스에서 가장 빈번한 요소 중 가장 큰 숫자입니다.\n * 예를 들어:\n *   f_38(3, [1, 2, 3])\n *   최대값에 도달하는 시퀀스는 [3, 2, 3, 1, 2, 2]이며, 합은 17입니다.\n */\nfunction f_38(n, counts)", "ml": "/**\n * 1 മുതൽ n വരെ ഓരോ സംഖ്യയുടെ എണ്ണവും പ്രതിനിധീകരിക്കുന്ന n പോസിറ്റീവ് പൂർണ്ണസംഖ്യകൾ നൽകിയാൽ, \n * ഈ സംഖ്യകളിൽ നിന്ന് നിർമ്മിച്ച ഒരു അനുക്രമണത്തിന്റെ എല്ലാ പ്രിഫിക്സുകളുടെയും മോഡ് (ഏറ്റവും കൂടുതൽ ആവർത്തിക്കുന്ന മൂല്യം) \n * പരമാവധി തുക കണ്ടെത്തുക. ഒരു അനുക്രമണത്തിലെ ഏറ്റവും കൂടുതൽ ആവർത്തിക്കുന്ന മൂല്യങ്ങളിൽ ഏറ്റവും വലിയ സംഖ്യയാണ് മോഡ്.\n * ഉദാഹരണത്തിന്:\n *   f_38(3, [1, 2, 3])\n *   പരമാവധി മൂല്യത്തിലെത്തുന്ന ഒരു അനുക്രമണം [3, 2, 3, 1, 2, 2] ആണ്, കൂടാതെ തുക 17 ആണ്.\n */\nfunction f_38(n, counts)", "fa": "/**\n * با داشتن n عدد مثبت که نشان‌دهنده تعداد هر عدد از 1 تا n هستند، \n * حداکثر مجموع مد (عنصر پرتکرار) را برای تمام پیشوندهای \n * یک دنباله ساخته شده از این اعداد پیدا کنید. مد بزرگترین عدد \n * در میان عناصر پرتکرار در یک دنباله است.\n * برای مثال:\n *   f_38(3, [1, 2, 3])\n *   یک دنباله که به حداکثر مقدار خود می‌رسد [3, 2, 3, 1, 2, 2] است و مجموع آن 17 است.\n */\nfunction f_38(n, counts)"}, "canonical_solution": "{\n  let ans = 0;\n  let mx = 0;\n  let f = new Array(100000).fill(0); // Initialize the array with zeroes\n\n  for (let i = 0; i <= n; ++i) {\n    f[i] = 0;\n  }\n\n  for (let i = n; i > 0; --i) {\n    while (mx < counts[i - 1]) {\n      mx++;\n      f[mx] = f[mx - 1] + i;\n    }\n    ans += f[counts[i - 1]];\n  }\n  return ans;\n}", "instruction": {"en": "Write a JavaScript function `function f_38(n, counts)` to solve the following problem:\nGiven n positive integers representing the count of each number from 1 to n, find the maximum sum of the mode (most frequent element) for all prefixes of a sequence constructed from these numbers. The mode is the largest number among the most frequent elements in a sequence. For example:   f_38(3, [1, 2, 3]) A sequence that reaches its maximum value is [3, 2, 3, 1, 2, 2], and the sum is 17.", "sq": "Shkruani një funksion JavaScript `function f_38(n, counts)` për të zgjidhur problemin në vijim:  \nDuke pasur n numra pozitivë që përfaqësojnë numrin e secilit numër nga 1 deri në n, gjeni shumën maksimale të modës (elementi më i shpeshtë) për të gjitha parashtesat e një sekuence të ndërtuar nga këta numra. Moda është numri më i madh ndër elementët më të shpeshtë në një sekuencë. Për shembull: f_38(3, [1, 2, 3]) Një sekuencë që arrin vlerën e saj maksimale është [3, 2, 3, 1, 2, 2], dhe shuma është 17.", "hy": "Գրեք JavaScript ֆունկցիա `function f_38(n, counts)`՝ հետևյալ խնդիրը լուծելու համար: Տրված են n դրական ամբողջ թվեր, որոնք ներկայացնում են 1-ից n թվերի քանակը, գտնել մոդի (ամենահաճախ հանդիպող տարրը) առավելագույն գումարը բոլոր նախածանցների համար, որոնք կազմված են այդ թվերից: Մոդը ամենամեծ թիվն է ամենահաճախ հանդիպող տարրերի շարքում: Օրինակ՝ f_38(3, [1, 2, 3]) Շարքը, որը հասնում է իր առավելագույն արժեքին, [3, 2, 3, 1, 2, 2] է, և գումարը 17 է:", "bn": "একটি JavaScript ফাংশন `function f_38(n, counts)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য: n টি ধনাত্মক পূর্ণসংখ্যা দেওয়া আছে যা 1 থেকে n পর্যন্ত প্রতিটি সংখ্যার গণনাকে উপস্থাপন করে, একটি ক্রম থেকে গঠিত প্রতিটি উপসর্গের জন্য মোডের (সবচেয়ে ঘন ঘন উপাদান) সর্বাধিক যোগফল খুঁজে বের করুন। মোড হল একটি ক্রমে সবচেয়ে ঘন ঘন উপাদানগুলির মধ্যে বৃহত্তম সংখ্যা। উদাহরণস্বরূপ: f_38(3, [1, 2, 3]) একটি ক্রম যা তার সর্বাধিক মানে পৌঁছায় তা হল [3, 2, 3, 1, 2, 2], এবং যোগফল হল 17।", "bg": "Напишете JavaScript функция `function f_38(n, counts)`, за да решите следния проблем:  \nДадени са n положителни цели числа, представляващи броя на всяко число от 1 до n, намерете максималната сума на модата (най-често срещания елемент) за всички префикси на последователност, съставена от тези числа. Модата е най-голямото число сред най-често срещаните елементи в последователност. Например: f_38(3, [1, 2, 3]) Последователност, която достига максималната си стойност, е [3, 2, 3, 1, 2, 2], и сумата е 17.", "zh": "编写一个 JavaScript 函数 `function f_38(n, counts)` 来解决以下问题：  \n给定 n 个正整数，表示从 1 到 n 的每个数字的计数，找到从这些数字构造的序列的所有前缀的众数（最频繁元素）的最大和。众数是序列中最频繁元素中最大的数字。例如：f_38(3, [1, 2, 3]) 一个达到其最大值的序列是 [3, 2, 3, 1, 2, 2]，和为 17。", "fr": "Écrire une fonction JavaScript `function f_38(n, counts)` pour résoudre le problème suivant :  \nÉtant donné n entiers positifs représentant le nombre de chaque nombre de 1 à n, trouver la somme maximale du mode (élément le plus fréquent) pour tous les préfixes d'une séquence construite à partir de ces nombres. Le mode est le plus grand nombre parmi les éléments les plus fréquents dans une séquence. Par exemple : f_38(3, [1, 2, 3]) Une séquence qui atteint sa valeur maximale est [3, 2, 3, 1, 2, 2], et la somme est 17.", "de": "Schreiben Sie eine JavaScript-Funktion `function f_38(n, counts)`, um das folgende Problem zu lösen:\nGegeben sind n positive ganze Zahlen, die die Anzahl jedes Zahl von 1 bis n darstellen. Finden Sie die maximale Summe des Modus (häufigstes Element) für alle Präfixe einer Sequenz, die aus diesen Zahlen konstruiert wird. Der Modus ist die größte Zahl unter den häufigsten Elementen in einer Sequenz. Zum Beispiel: f_38(3, [1, 2, 3]) Eine Sequenz, die ihren maximalen Wert erreicht, ist [3, 2, 3, 1, 2, 2], und die Summe ist 17.", "ha": "Rubuta aikin JavaScript `function f_38(n, counts)` don warware matsalar mai zuwa:\nAn ba da lambobi masu kyau n waɗanda ke wakiltar adadin kowace lamba daga 1 zuwa n, nemo mafi girman jimlar yanayin (mafi yawan abu) don dukkanin gaban jerin da aka gina daga waɗannan lambobin. Yanayin shine mafi girman lamba tsakanin abubuwan da suka fi yawa a cikin jerin. Alal misali: f_38(3, [1, 2, 3]) Jerin da ya kai darajarsa mafi girma shine [3, 2, 3, 1, 2, 2], kuma jimlar ita ce 17.", "hi": "JavaScript फ़ंक्शन `function f_38(n, counts)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए n धनात्मक पूर्णांक जो 1 से n तक प्रत्येक संख्या की गिनती का प्रतिनिधित्व करते हैं, उन सभी अनुक्रमों के उपसर्गों के लिए मोड (सबसे अधिक बार आने वाला तत्व) का अधिकतम योग खोजें जो इन संख्याओं से निर्मित होते हैं। मोड अनुक्रम में सबसे अधिक बार आने वाले तत्वों में सबसे बड़ी संख्या है। उदाहरण के लिए: f_38(3, [1, 2, 3]) एक अनुक्रम जो अपनी अधिकतम मान तक पहुँचता है वह है [3, 2, 3, 1, 2, 2], और योग 17 है।", "hu": "Írj egy JavaScript függvényt `function f_38(n, counts)` a következő probléma megoldására:  \nAdott n pozitív egész szám, amelyek az 1-től n-ig terjedő számok előfordulási számát jelölik. Találd meg a módusz (leggyakrabban előforduló elem) maximális összegét a számokból felépített sorozat minden prefixére. A módusz a legnagyobb szám a sorozat leggyakrabban előforduló elemei között. Például: f_38(3, [1, 2, 3]) Egy sorozat, amely eléri a maximális értékét: [3, 2, 3, 1, 2, 2], és az összeg 17.", "es": "Escribe una función de JavaScript `function f_38(n, counts)` para resolver el siguiente problema:  \nDado n números enteros positivos que representan la cantidad de cada número del 1 al n, encuentra la suma máxima del modo (elemento más frecuente) para todos los prefijos de una secuencia construida a partir de estos números. El modo es el número más grande entre los elementos más frecuentes en una secuencia. Por ejemplo: f_38(3, [1, 2, 3]) Una secuencia que alcanza su valor máximo es [3, 2, 3, 1, 2, 2], y la suma es 17.", "arb": "اكتب دالة JavaScript `function f_38(n, counts)` لحل المشكلة التالية:  \nمعطى n من الأعداد الصحيحة الموجبة التي تمثل عدد كل رقم من 1 إلى n، ابحث عن الحد الأقصى لمجموع النمط (العنصر الأكثر تكرارًا) لجميع البادئات لتسلسل مُنشأ من هذه الأرقام. النمط هو أكبر عدد بين العناصر الأكثر تكرارًا في تسلسل. على سبيل المثال: f_38(3, [1, 2, 3]) تسلسل يصل إلى قيمته القصوى هو [3, 2, 3, 1, 2, 2]، والمجموع هو 17.", "sw": "Andika kazi ya JavaScript `function f_38(n, counts)` kutatua tatizo lifuatalo:  \nUkipiwa n nambari chanya zinazowakilisha idadi ya kila nambari kutoka 1 hadi n, pata jumla ya juu zaidi ya hali (kipengele kinachojitokeza mara nyingi zaidi) kwa viambishi vyote vya mlolongo uliotengenezwa kutoka kwa nambari hizi. Hali ni nambari kubwa zaidi kati ya vipengele vinavyojitokeza mara nyingi zaidi katika mlolongo. Kwa mfano: f_38(3, [1, 2, 3]) Mlolongo unaofikia thamani yake ya juu zaidi ni [3, 2, 3, 1, 2, 2], na jumla ni 17.", "tr": "Bir JavaScript fonksiyonu `function f_38(n, counts)` yazın ve aşağıdaki problemi çözün:\n1'den n'ye kadar olan her sayının sayısını temsil eden n pozitif tamsayı verildiğinde, bu sayılardan oluşturulan bir dizinin tüm ön ekleri için modun (en sık görülen eleman) maksimum toplamını bulun. Mod, bir dizideki en sık görülen elemanlar arasında en büyük sayıdır. Örneğin: f_38(3, [1, 2, 3]) Maksimum değere ulaşan bir dizi [3, 2, 3, 1, 2, 2] ve toplam 17'dir.", "vi": "Viết một hàm JavaScript `function f_38(n, counts)` để giải quyết vấn đề sau:  \nCho n số nguyên dương đại diện cho số lượng của mỗi số từ 1 đến n, tìm tổng lớn nhất của mode (phần tử xuất hiện nhiều nhất) cho tất cả các tiền tố của một dãy được tạo từ các số này. Mode là số lớn nhất trong số các phần tử xuất hiện nhiều nhất trong một dãy. Ví dụ: f_38(3, [1, 2, 3]) Một dãy đạt giá trị lớn nhất là [3, 2, 3, 1, 2, 2], và tổng là 17.", "id": "Tulis sebuah fungsi JavaScript `function f_38(n, counts)` untuk menyelesaikan masalah berikut:  \nDiberikan n bilangan bulat positif yang mewakili jumlah setiap angka dari 1 hingga n, temukan jumlah maksimum dari modus (elemen yang paling sering muncul) untuk semua awalan dari sebuah urutan yang dibangun dari angka-angka ini. Modus adalah angka terbesar di antara elemen yang paling sering muncul dalam sebuah urutan. Sebagai contoh: f_38(3, [1, 2, 3]) Urutan yang mencapai nilai maksimumnya adalah [3, 2, 3, 1, 2, 2], dan jumlahnya adalah 17.", "ja": "JavaScript関数`function f_38(n, counts)`を作成して、次の問題を解決してください:  \n1からnまでの各数の出現回数を表すn個の正の整数が与えられたとき、これらの数から構成されるシーケンスのすべての接頭辞に対して、モード（最頻出要素）の最大合計を求めます。モードは、シーケンス内の最頻出要素の中で最大の数です。例えば: f_38(3, [1, 2, 3]) 最大値に達するシーケンスは[3, 2, 3, 1, 2, 2]であり、合計は17です。", "ko": "JavaScript 함수를 작성하세요 `function f_38(n, counts)` 다음 문제를 해결하기 위해:\n양의 정수 n이 주어지며, 이는 1부터 n까지의 각 숫자의 개수를 나타냅니다. 이러한 숫자들로 구성된 시퀀스의 모든 접두사에 대해 최빈값(가장 빈번한 요소)의 최대 합을 찾으세요. 최빈값은 시퀀스에서 가장 빈번한 요소 중 가장 큰 숫자입니다. 예를 들어: f_38(3, [1, 2, 3]) 최대값에 도달하는 시퀀스는 [3, 2, 3, 1, 2, 2]이며, 합계는 17입니다.", "ml": "`function f_38(n, counts)` എന്ന ജാവാസ്ക്രിപ്റ്റ് ഫംഗ്ഷൻ എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ: 1 മുതൽ n വരെ ഓരോ സംഖ്യയുടെ എണ്ണവും പ്രതിനിധീകരിക്കുന്ന n അനുകൂല സംഖ്യകൾ നൽകിയാൽ, ഈ സംഖ്യകളിൽ നിന്ന് നിർമ്മിച്ച ഒരു ക്രമത്തിന്റെ എല്ലാ മുൻഗാമികളുടെ മോഡ് (ഏറ്റവും അധികം ആവർത്തിക്കുന്ന ഘടകം) യുടെ പരമാവധി തുക കണ്ടെത്തുക. ഒരു ക്രമത്തിലെ ഏറ്റവും അധികം ആവർത്തിക്കുന്ന ഘടകങ്ങളിൽ ഏറ്റവും വലിയ സംഖ്യയാണ് മോഡ്. ഉദാഹരണത്തിന്: f_38(3, [1, 2, 3]) പരമാവധി മൂല്യത്തിലെത്തുന്ന ഒരു ക്രമം [3, 2, 3, 1, 2, 2] ആണ്, തുക 17 ആണ്.", "fa": "یک تابع جاوااسکریپت `function f_38(n, counts)` بنویسید تا مسئله زیر را حل کند:\nبا توجه به n عدد صحیح مثبت که نشان‌دهنده تعداد هر عدد از 1 تا n هستند، حداکثر مجموع مد (عنصر پرتکرار) برای تمام پیشوندهای یک دنباله ساخته شده از این اعداد را پیدا کنید. مد بزرگترین عدد در میان عناصر پرتکرار در یک دنباله است. به عنوان مثال: f_38(3, [1, 2, 3]) یک دنباله که به حداکثر مقدار خود می‌رسد [3, 2, 3, 1, 2, 2] است و مجموع برابر 17 است."}, "level": "easy", "test": "(function testf_38() {\n  console.assert(f_38(3, [1, 3, 2]) === 17, 'Test case 1 failed');\n  console.assert(f_38(4, [4, 1, 2, 3]) === 37, 'Test case 2 failed');\n  console.assert(f_38(2, [1, 1]) === 4, 'Test case 3 failed');\n  console.assert(f_38(5, [1, 2, 3, 4, 5]) === 75, 'Test case 4 failed');\n  console.assert(f_38(1, [100000]) === 100000, 'Test case 5 failed');\n  console.assert(f_38(5, [5, 3, 2, 4, 1]) === 62, 'Test case 6 failed');\n  console.assert(f_38(3, [100000, 100000, 100000]) === 900000, 'Test case 7 failed');\n  console.assert(f_38(3, [2, 2, 5]) === 27, 'Test case 8 failed');\n  console.assert(f_38(4, [4, 4, 4, 4]) === 64, 'Test case 9 failed');\n  console.assert(f_38(6, [1, 2, 3, 4, 5, 6]) === 126, 'Test case 10 failed');\n  console.assert(f_38(3, [3, 1, 2]) === 16, 'Test case 11 failed');\n})();", "entry_point": "f_38", "signature": "function f_38(n, counts)", "docstring": {"en": "Given n positive integers representing the count of each number from 1 to n, find the maximum sum of the mode (most frequent element) for all prefixes of a sequence constructed from these numbers. The mode is the largest number among the most frequent elements in a sequence. For example:   f_38(3, [1, 2, 3]) A sequence that reaches its maximum value is [3, 2, 3, 1, 2, 2], and the sum is 17.", "sq": "Duke pasur n numra të plotë pozitivë që përfaqësojnë numrin e secilit numër nga 1 deri në n, gjeni shumën maksimale të modës (elementi më i shpeshtë) për të gjitha parashtesat e një sekuence të ndërtuar nga këta numra. Moda është numri më i madh ndër elementët më të shpeshtë në një sekuencë. Për shembull: f_38(3, [1, 2, 3]) Një sekuencë që arrin vlerën e saj maksimale është [3, 2, 3, 1, 2, 2], dhe shuma është 17.", "hy": "Տրված են n դրական ամբողջ թվեր, որոնք ներկայացնում են 1-ից n թվերի քանակը, գտնել մաքսիմալ գումարը մոդայի (ամենահաճախ հանդիպող տարրի) բոլոր նախածանցների համար, որոնք կառուցված են այս թվերից։ Մոդան ամենամեծ թիվն է ամենահաճախ հանդիպող տարրերի շարքում։ Օրինակ՝ f_38(3, [1, 2, 3])։ Շարքը, որը հասնում է իր մաքսիմալ արժեքին, [3, 2, 3, 1, 2, 2] է, և գումարը 17 է։", "bn": "প্রতিটি সংখ্যা 1 থেকে n পর্যন্ত গণনা উপস্থাপনকারী n টি ধনাত্মক পূর্ণসংখ্যা দেওয়া হয়েছে, এই সংখ্যাগুলি থেকে নির্মিত একটি ক্রমের সমস্ত উপসর্গের জন্য মোডের (সবচেয়ে ঘন ঘন উপাদান) সর্বাধিক যোগফল খুঁজে বের করুন। মোড হল একটি ক্রমের সবচেয়ে ঘন ঘন উপাদানগুলির মধ্যে বৃহত্তম সংখ্যা। উদাহরণস্বরূপ: \n\nf_38(3, [1, 2, 3]) একটি ক্রম যা তার সর্বাধিক মানে পৌঁছায় তা হল [3, 2, 3, 1, 2, 2], এবং যোগফল হল 17।", "bg": "Дадени са n положителни цели числа, представляващи броя на всяко число от 1 до n, намерете максималната сума на модата (най-често срещания елемент) за всички префикси на последователност, съставена от тези числа. Модата е най-голямото число сред най-често срещаните елементи в последователността. Например: f_38(3, [1, 2, 3]) Последователност, която достига максималната си стойност, е [3, 2, 3, 1, 2, 2], и сумата е 17.", "zh": "给定 n 个正整数，表示从 1 到 n 的每个数字的计数，找出从这些数字构造的序列的所有前缀的众数（最频繁元素）的最大和。众数是序列中最频繁元素中最大的数字。例如：\n\nf_38(3, [1, 2, 3])\n\n一个达到其最大值的序列是 [3, 2, 3, 1, 2, 2]，其和为 17。", "fr": "Étant donné n entiers positifs représentant le compte de chaque nombre de 1 à n, trouvez la somme maximale du mode (élément le plus fréquent) pour tous les préfixes d'une séquence construite à partir de ces nombres. Le mode est le plus grand nombre parmi les éléments les plus fréquents dans une séquence. Par exemple : f_38(3, [1, 2, 3]) Une séquence qui atteint sa valeur maximale est [3, 2, 3, 1, 2, 2], et la somme est 17.", "de": "Gegeben n positive ganze Zahlen, die die Anzahl jedes Zahl von 1 bis n darstellen, finde die maximale Summe des Modus (häufigstes Element) für alle Präfixe einer Sequenz, die aus diesen Zahlen konstruiert wurde. Der Modus ist die größte Zahl unter den häufigsten Elementen in einer Sequenz. Zum Beispiel: f_38(3, [1, 2, 3]) Eine Sequenz, die ihren Maximalwert erreicht, ist [3, 2, 3, 1, 2, 2], und die Summe beträgt 17.", "ha": "An ba da lambobi masu kyau n waɗanda ke wakiltar adadin kowace lamba daga 1 zuwa n, nemo mafi girman jimlar yanayin (mafi yawan abu) don dukkanin gaban jerin da aka gina daga waɗannan lambobin. Yanayin shine mafi girman lamba tsakanin abubuwan da suka fi yawa a cikin jerin. Alal misali:   f_38(3, [1, 2, 3]) Wani jeri da ya kai matsakaicin ƙimar sa shine [3, 2, 3, 1, 2, 2], kuma jumlar ita ce 17.", "hi": "n धनात्मक पूर्णांकों को दिया गया है जो 1 से n तक प्रत्येक संख्या की गिनती का प्रतिनिधित्व करते हैं, इन संख्याओं से निर्मित अनुक्रम के सभी उपसर्गों के लिए मोड (सबसे अधिक बार आने वाला तत्व) का अधिकतम योग खोजें। मोड अनुक्रम में सबसे अधिक बार आने वाले तत्वों में सबसे बड़ी संख्या है। उदाहरण के लिए: \n\nf_38(3, [1, 2, 3]) एक अनुक्रम जो अपने अधिकतम मान तक पहुँचता है वह है [3, 2, 3, 1, 2, 2], और योग 17 है।", "hu": "Adott n pozitív egész szám, amelyek az 1-től n-ig terjedő számok számosságát jelölik, találja meg az összes előtag móduszának (leggyakoribb elem) maximális összegét egy ezen számokból felépített sorozat esetén. A módusz a legnagyobb szám a sorozat leggyakoribb elemei között. Például: f_38(3, [1, 2, 3]) Egy sorozat, amely eléri a maximális értékét: [3, 2, 3, 1, 2, 2], és az összeg 17.", "es": "Dado n enteros positivos que representan el conteo de cada número del 1 al n, encuentra la suma máxima de la moda (elemento más frecuente) para todos los prefijos de una secuencia construida a partir de estos números. La moda es el número más grande entre los elementos más frecuentes en una secuencia. Por ejemplo: f_38(3, [1, 2, 3]) Una secuencia que alcanza su valor máximo es [3, 2, 3, 1, 2, 2], y la suma es 17.", "arb": "نظرًا لوجود n من الأعداد الصحيحة الموجبة التي تمثل عدد كل رقم من 1 إلى n، ابحث عن الحد الأقصى لمجموع الوضع (العنصر الأكثر تكرارًا) لجميع البادئات لتسلسل مُنشأ من هذه الأرقام. الوضع هو أكبر رقم بين العناصر الأكثر تكرارًا في تسلسل. على سبيل المثال: f_38(3, [1, 2, 3]) تسلسل يصل إلى قيمته القصوى هو [3, 2, 3, 1, 2, 2]، والمجموع هو 17.", "sw": "Ukipiwa n nambari chanya zinazowakilisha idadi ya kila nambari kutoka 1 hadi n, pata jumla ya juu zaidi ya hali (kipengele kinachojitokeza mara nyingi zaidi) kwa viambishi vyote vya mlolongo uliotengenezwa kutoka kwa nambari hizi. Hali ni nambari kubwa zaidi kati ya vipengele vinavyojitokeza mara nyingi zaidi katika mlolongo. Kwa mfano: \n\nf_38(3, [1, 2, 3]) \n\nMfuatano unaofikia thamani yake ya juu ni [3, 2, 3, 1, 2, 2], na jumla ni 17.", "tr": "Verilen n pozitif tam sayı, 1'den n'e kadar olan her sayının sayısını temsil eder, bu sayılardan oluşturulan bir dizinin tüm önekleri için modun (en sık görülen eleman) maksimum toplamını bulun. Mod, bir dizide en sık görülen elemanlar arasında en büyük sayıdır. Örneğin: f_38(3, [1, 2, 3]) Maksimum değerine ulaşan bir dizi [3, 2, 3, 1, 2, 2] olup, toplam 17'dir.", "vi": "Cho n số nguyên dương đại diện cho số lượng của mỗi số từ 1 đến n, tìm tổng lớn nhất của mode (phần tử xuất hiện nhiều nhất) cho tất cả các tiền tố của một dãy được tạo từ các số này. Mode là số lớn nhất trong số các phần tử xuất hiện nhiều nhất trong một dãy. Ví dụ:\n\nf_38(3, [1, 2, 3])\n\nMột dãy đạt giá trị tối đa là [3, 2, 3, 1, 2, 2], và tổng là 17.", "id": "Diberikan n bilangan bulat positif yang mewakili jumlah masing-masing angka dari 1 hingga n, temukan jumlah maksimum dari modus (elemen yang paling sering muncul) untuk semua awalan dari sebuah urutan yang dibangun dari angka-angka ini. Modus adalah angka terbesar di antara elemen-elemen yang paling sering muncul dalam sebuah urutan. Sebagai contoh: f_38(3, [1, 2, 3]) Sebuah urutan yang mencapai nilai maksimumnya adalah [3, 2, 3, 1, 2, 2], dan jumlahnya adalah 17.", "ja": "与えられたn個の正の整数は、1からnまでの各数のカウントを表します。これらの数から構成されるシーケンスのすべての接頭辞に対して、モード（最も頻繁に出現する要素）の最大合計を見つけます。モードは、シーケンス内の最も頻繁に出現する要素の中で最大の数です。例えば: f_38(3, [1, 2, 3]) 最大値に達するシーケンスは[3, 2, 3, 1, 2, 2]であり、合計は17です。", "ko": "주어진 n개의 양의 정수는 1부터 n까지의 각 숫자의 개수를 나타냅니다. 이러한 숫자로 구성된 시퀀스의 모든 접두사의 최빈값(가장 자주 나타나는 요소)의 최대 합을 찾으세요. 최빈값은 시퀀스에서 가장 자주 나타나는 요소 중 가장 큰 숫자입니다. 예를 들어: f_38(3, [1, 2, 3]) 최대값에 도달하는 시퀀스는 [3, 2, 3, 1, 2, 2]이며, 합계는 17입니다.", "ml": "Given n positive integers representing the count of each number from 1 to n, find the maximum sum of the mode (most frequent element) for all prefixes of a sequence constructed from these numbers. The mode is the largest number among the most frequent elements in a sequence. For example:   f_38(3, [1, 2, 3]) ഒരു ശ്രേണിയിൽ നിന്ന് നിർമ്മിച്ച എല്ലാ മുൻഗാമികളുടെ മോഡ് (ഏറ്റവും അധികം ആവർത്തിക്കുന്ന ഘടകം) പരമാവധി തുക കണ്ടെത്തുക. ഈ സംഖ്യകളിൽ നിന്ന് 1 മുതൽ n വരെ ഓരോ സംഖ്യയുടെ എണ്ണവും പ്രതിനിധീകരിക്കുന്ന n അനുകൂല സംഖ്യകൾ നൽകിയിരിക്കുന്നു. മോഡ് എന്നത് ഒരു ശ്രേണിയിലെ ഏറ്റവും അധികം ആവർത്തിക്കുന്ന ഘടകങ്ങളിൽ ഏറ്റവും വലിയ സംഖ്യയാണ്. ഉദാഹരണത്തിന്:   f_38(3, [1, 2, 3]) പരമാവധി മൂല്യത്തിലെത്തുന്ന ഒരു ശ്രേണി [3, 2, 3, 1, 2, 2] ആണ്, തുക 17 ആണ്.", "fa": "با توجه به n عدد صحیح مثبت که نشان‌دهنده تعداد هر عدد از 1 تا n هستند، حداکثر مجموع مد (عنصر پرتکرارتر) را برای تمام پیشوندهای یک دنباله ساخته شده از این اعداد پیدا کنید. مد بزرگترین عدد در میان عناصر پرتکرار در یک دنباله است. برای مثال:\n\nf_38(3, [1, 2, 3])\n\nیک دنباله که به حداکثر مقدار خود می‌رسد [3, 2, 3, 1, 2, 2] است و مجموع آن 17 است."}}
{"task_id": "JavaScript/39", "prompt": {"en": "/**\n * Given an array A of integers, the task is to calculate the sum of the XOR of all subarrays.\n * A subarray is defined by a pair of indices (L, R) such that 1 <= L <= R <= the length of the array.\n * The XOR sum of a subarray is the result of XORing all elements from L to R.\n * The final result is the sum of the XOR sums for all possible subarrays.\n *\n * Example:\n * f_39([1, 2, 3, 4, 5])  // returns 39\n */\nfunction f_39(A)", "sq": "/**\n * Duke pasur një varg A të numrave të plotë, detyra është të llogaritet shuma e XOR-it të të gjitha nënvargjeve.\n * Një nënvargje përcaktohet nga një palë indeksesh (L, R) të tilla që 1 <= L <= R <= gjatësia e vargut.\n * Shuma XOR e një nënvargu është rezultati i XOR-it të të gjithë elementeve nga L në R.\n * Rezultati përfundimtar është shuma e shumave XOR për të gjitha nënvargjet e mundshme.\n *\n * Shembull:\n * f_39([1, 2, 3, 4, 5])  // kthen 39\n */", "hy": "/**\n * Տրված է ամբողջ թվերի զանգված A, խնդիրը հաշվարկել է բոլոր ենթազանգվածների XOR-ի գումարը:\n * Ենթազանգվածը սահմանվում է (L, R) ինդեքսների զույգով, այնպես, որ 1 <= L <= R <= զանգվածի երկարությունը:\n * Ենթազանգվածի XOR-ի գումարը L-ից R բոլոր տարրերի XOR-ի արդյունքն է:\n * Վերջնական արդյունքը բոլոր հնարավոր ենթազանգվածների XOR գումարների գումարն է:\n *\n * Օրինակ:\n * f_39([1, 2, 3, 4, 5])  // վերադարձնում է 39\n */\nfunction f_39(A)", "bn": "/**\n * পূর্ণসংখ্যার একটি অ্যারে A দেওয়া আছে, কাজটি হল সমস্ত উপঅ্যারের XOR এর যোগফল গণনা করা।\n * একটি উপঅ্যারে একটি জোড়া সূচক (L, R) দ্বারা সংজ্ঞায়িত করা হয় যাতে 1 <= L <= R <= অ্যারের দৈর্ঘ্য।\n * একটি উপঅ্যারের XOR যোগফল হল L থেকে R পর্যন্ত সমস্ত উপাদান XOR করার ফলাফল।\n * চূড়ান্ত ফলাফল হল সমস্ত সম্ভাব্য উপঅ্যারের জন্য XOR যোগফলের যোগফল।\n *\n * উদাহরণ:\n * f_39([1, 2, 3, 4, 5])  // 39 ফেরত দেয়\n */\nfunction f_39(A)", "bg": "/**\n * Даден е масив A от цели числа, задачата е да се изчисли сумата от XOR на всички подмасиви.\n * Подмасив се дефинира чрез двойка индекси (L, R) така че 1 <= L <= R <= дължината на масива.\n * XOR сумата на подмасив е резултатът от XOR на всички елементи от L до R.\n * Крайният резултат е сумата от XOR сумите за всички възможни подмасиви.\n *\n * Пример:\n * f_39([1, 2, 3, 4, 5])  // връща 39\n */\nfunction f_39(A)", "zh": "/**\n * 给定一个整数数组A，任务是计算所有子数组的异或和的总和。\n * 子数组由一对索引(L, R)定义，其中1 <= L <= R <= 数组的长度。\n * 子数组的异或和是从L到R的所有元素进行异或运算的结果。\n * 最终结果是所有可能子数组的异或和的总和。\n *\n * 示例:\n * f_39([1, 2, 3, 4, 5])  // 返回39\n */", "fr": "/**\n * Étant donné un tableau A d'entiers, la tâche est de calculer la somme du XOR de tous les sous-tableaux.\n * Un sous-tableau est défini par une paire d'indices (L, R) telle que 1 <= L <= R <= la longueur du tableau.\n * La somme XOR d'un sous-tableau est le résultat du XOR de tous les éléments de L à R.\n * Le résultat final est la somme des sommes XOR pour tous les sous-tableaux possibles.\n *\n * Exemple:\n * f_39([1, 2, 3, 4, 5])  // retourne 39\n */\nfunction f_39(A)", "de": "/**\n * Gegeben ein Array A von ganzen Zahlen, ist die Aufgabe, die Summe des XOR aller Teilarrays zu berechnen.\n * Ein Teilarray wird durch ein Paar von Indizes (L, R) definiert, so dass 1 <= L <= R <= die Länge des Arrays.\n * Die XOR-Summe eines Teilarrays ist das Ergebnis des XORs aller Elemente von L bis R.\n * Das Endergebnis ist die Summe der XOR-Summen für alle möglichen Teilarrays.\n *\n * Beispiel:\n * f_39([1, 2, 3, 4, 5])  // gibt 39 zurück\n */\nfunction f_39(A)", "ha": "/**\n * An ba da jerin lambobi A, aikin shi ne a ƙididdige jimillar XOR na dukkan ƙananan jerin.\n * Ana ayyana ƙaramin jeri ta hanyar ma'aurata na alamomi (L, R) inda 1 <= L <= R <= tsawon jerin.\n * Jimillar XOR na ƙaramin jeri ita ce sakamakon XORing dukkan abubuwa daga L zuwa R.\n * Sakamakon ƙarshe shi ne jimillar XOR sums don dukkan yiwuwar ƙananan jerin.\n *\n * Misali:\n * f_39([1, 2, 3, 4, 5])  // yana dawowa 39\n */\nfunction f_39(A)", "hi": "/**\n * दिए गए पूर्णांकों की एक सरणी A के लिए, कार्य यह है कि सभी उप-सरणियों के XOR का योग गणना करें।\n * एक उप-सरणी को (L, R) इंडेक्स की एक जोड़ी द्वारा परिभाषित किया जाता है, जिससे 1 <= L <= R <= सरणी की लंबाई।\n * एक उप-सरणी का XOR योग L से R तक के सभी तत्वों का XOR करने का परिणाम होता है।\n * अंतिम परिणाम सभी संभावित उप-सरणियों के लिए XOR योगों का योग होता है।\n *\n * उदाहरण:\n * f_39([1, 2, 3, 4, 5])  // 39 लौटाता है\n */\nfunction f_39(A)", "hu": "/**\n * Adott egy A egész számokat tartalmazó tömb, a feladat az összes részhalmaz XOR összegének kiszámítása.\n * Egy részhalmazt egy (L, R) indexpár határoz meg, ahol 1 <= L <= R <= a tömb hossza.\n * Egy részhalmaz XOR összege az L-től R-ig terjedő összes elem XOR-olásának eredménye.\n * A végső eredmény az összes lehetséges részhalmaz XOR összegeinek összege.\n *\n * Példa:\n * f_39([1, 2, 3, 4, 5])  // visszaadja: 39\n */\nfunction f_39(A)", "es": "/**\n * Dado un array A de enteros, la tarea es calcular la suma del XOR de todos los subarrays.\n * Un subarray se define por un par de índices (L, R) tal que 1 <= L <= R <= la longitud del array.\n * La suma XOR de un subarray es el resultado de aplicar XOR a todos los elementos desde L hasta R.\n * El resultado final es la suma de las sumas XOR para todos los subarrays posibles.\n *\n * Ejemplo:\n * f_39([1, 2, 3, 4, 5])  // devuelve 39\n */\nfunction f_39(A)", "arb": "/**\n * بالنظر إلى مصفوفة A من الأعداد الصحيحة، المهمة هي حساب مجموع الـ XOR لجميع المصفوفات الفرعية.\n * يتم تعريف المصفوفة الفرعية بواسطة زوج من الفهارس (L, R) بحيث 1 <= L <= R <= طول المصفوفة.\n * مجموع الـ XOR لمصفوفة فرعية هو نتيجة تطبيق عملية XOR على جميع العناصر من L إلى R.\n * النتيجة النهائية هي مجموع نتائج الـ XOR لجميع المصفوفات الفرعية الممكنة.\n *\n * مثال:\n * f_39([1, 2, 3, 4, 5])  // يعيد 39\n */\nfunction f_39(A)", "sw": "/**\n * Ukipewa safu A ya nambari za mzima, kazi ni kuhesabu jumla ya XOR ya vipengele vidogo vyote.\n * Kipengele kidogo kinafafanuliwa na jozi ya fahirisi (L, R) ambapo 1 <= L <= R <= urefu wa safu.\n * Jumla ya XOR ya kipengele kidogo ni matokeo ya XOR ya vipengele vyote kutoka L hadi R.\n * Matokeo ya mwisho ni jumla ya jumla za XOR kwa vipengele vidogo vyote vinavyowezekana.\n *\n * Mfano:\n * f_39([1, 2, 3, 4, 5])  // inarudisha 39\n */\nfunction f_39(A)", "tr": "/**\n * Bir tamsayı dizisi A verildiğinde, görev tüm alt dizilerin XOR toplamını hesaplamaktır.\n * Bir alt dizi, 1 <= L <= R <= dizinin uzunluğu olacak şekilde bir (L, R) indeks çifti ile tanımlanır.\n * Bir alt dizinin XOR toplamı, L'den R'ye kadar olan tüm elemanların XOR'lanması sonucudur.\n * Nihai sonuç, mümkün olan tüm alt diziler için XOR toplamlarının toplamıdır.\n *\n * Örnek:\n * f_39([1, 2, 3, 4, 5])  // 39 döndürür\n */\nfunction f_39(A)", "vi": "/**\n * Cho một mảng A gồm các số nguyên, nhiệm vụ là tính tổng của XOR của tất cả các mảng con.\n * Một mảng con được định nghĩa bởi một cặp chỉ số (L, R) sao cho 1 <= L <= R <= độ dài của mảng.\n * Tổng XOR của một mảng con là kết quả của việc XOR tất cả các phần tử từ L đến R.\n * Kết quả cuối cùng là tổng của các tổng XOR cho tất cả các mảng con có thể.\n *\n * Ví dụ:\n * f_39([1, 2, 3, 4, 5])  // trả về 39\n */\nfunction f_39(A)", "id": "/**\n * Diberikan sebuah array A dari bilangan bulat, tugasnya adalah menghitung jumlah XOR dari semua subarray.\n * Sebuah subarray didefinisikan oleh sepasang indeks (L, R) sehingga 1 <= L <= R <= panjang array.\n * Jumlah XOR dari sebuah subarray adalah hasil dari XOR semua elemen dari L hingga R.\n * Hasil akhirnya adalah jumlah dari semua jumlah XOR untuk semua subarray yang mungkin.\n *\n * Contoh:\n * f_39([1, 2, 3, 4, 5])  // mengembalikan 39\n */\nfunction f_39(A)", "ja": "/**\n * 整数の配列Aが与えられたとき、すべての部分配列のXORの合計を計算することが課題です。\n * 部分配列は、1 <= L <= R <= 配列の長さを満たすインデックスのペア(L, R)によって定義されます。\n * 部分配列のXORの合計は、LからRまでのすべての要素をXORした結果です。\n * 最終的な結果は、可能なすべての部分配列のXOR合計の合計です。\n *\n * 例:\n * f_39([1, 2, 3, 4, 5])  // 39を返します\n */\nfunction f_39(A)", "ko": "/**\n * 정수 배열 A가 주어졌을 때, 모든 부분 배열의 XOR 합을 계산하는 작업입니다.\n * 부분 배열은 인덱스 쌍 (L, R)에 의해 정의되며, 1 <= L <= R <= 배열의 길이입니다.\n * 부분 배열의 XOR 합은 L부터 R까지의 모든 요소를 XOR한 결과입니다.\n * 최종 결과는 가능한 모든 부분 배열의 XOR 합의 합입니다.\n *\n * 예시:\n * f_39([1, 2, 3, 4, 5])  // 39를 반환합니다.\n */\nfunction f_39(A)", "ml": "/**\n * മുഴുവൻ ഉപവ്യവസ്ഥകളുടെ XOR യുടെ തുക കണക്കാക്കുക എന്നതാണ്, ഒരു പദാവലി A നൽകിയാൽ, ഈ പ്രവർത്തനം.\n * ഒരു ഉപവ്യവസ്ഥ (L, R) എന്ന സൂചികകളുടെ ഒരു ജോഡിയാൽ നിർവ്വചിക്കപ്പെടുന്നു, 1 <= L <= R <= പദാവലിയുടെ നീളം.\n * ഒരു ഉപവ്യവസ്ഥയുടെ XOR തുക L മുതൽ R വരെയുള്ള എല്ലാ ഘടകങ്ങളും XOR ചെയ്യുന്നതിന്റെ ഫലമാണ്.\n * എല്ലാ സാധ്യതയുള്ള ഉപവ്യവസ്ഥകളുടെയും XOR തുകകളുടെ തുകയാണ് അന്തിമ ഫലം.\n *\n * ഉദാഹരണം:\n * f_39([1, 2, 3, 4, 5])  // 39 മടക്കുന്നു\n */\nfunction f_39(A)", "fa": "/**\n * با توجه به آرایه A از اعداد صحیح، وظیفه محاسبه مجموع XOR تمام زیرآرایه‌ها است.\n * یک زیرآرایه با یک جفت شاخص (L, R) تعریف می‌شود به طوری که 1 <= L <= R <= طول آرایه.\n * مجموع XOR یک زیرآرایه نتیجه‌ی XOR کردن تمام عناصر از L تا R است.\n * نتیجه نهایی مجموع مقادیر XOR برای تمام زیرآرایه‌های ممکن است.\n *\n * مثال:\n * f_39([1, 2, 3, 4, 5])  // مقدار 39 را برمی‌گرداند\n */\nfunction f_39(A)"}, "canonical_solution": "{\n    const n = A.length;\n    let q = new Array(n + 1).fill(0);\n    let w = Array.from({ length: 21 }, () => [0, 0]);\n    let ans = 0;\n\n    for (let i = 1; i <= n; i++) {\n        q[i] = q[i - 1] ^ A[i - 1];\n    }\n\n    for (let i = 0; i <= n; i++) {\n        for (let j = 20; j >= 0; j--) {\n            w[j][(q[i] >> j) & 1]++;\n        }\n    }\n\n    for (let i = 0; i <= 20; i++) {\n        ans += w[i][0] * w[i][1] * (1 << i);\n    }\n\n    return ans;\n}", "instruction": {"en": "Write a JavaScript function `function f_39(A)` to solve the following problem:\nGiven an array A of integers, the task is to calculate the sum of the XOR of all subarrays.\nA subarray is defined by a pair of indices (L, R) such that 1 <= L <= R <= the length of the array.\nThe XOR sum of a subarray is the result of XORing all elements from L to R.\nThe final result is the sum of the XOR sums for all possible subarrays.\n\nExample:\nf_39([1, 2, 3, 4, 5])  // returns 39\n", "sq": "Shkruani një funksion JavaScript `function f_39(A)` për të zgjidhur problemin e mëposhtëm:  \nDuke pasur një varg A të numrave të plotë, detyra është të llogaritet shuma e XOR e të gjitha nënvargjeve.  \nNjë nënvarg përcaktohet nga një palë indeksesh (L, R) të tilla që 1 <= L <= R <= gjatësia e vargut.  \nShuma XOR e një nënvargu është rezultati i XOR-it të të gjithë elementeve nga L në R.  \nRezultati përfundimtar është shuma e shumave XOR për të gjitha nënvargjet e mundshme.\n\nShembull:  \nf_39([1, 2, 3, 4, 5])  // kthen 39", "hy": "JavaScript ֆունկցիա `function f_39(A)` գրել հետևյալ խնդիրը լուծելու համար: Տրված է ամբողջ թվերի զանգված A, խնդիրը բոլոր ենթազանգվածների XOR գումարը հաշվարկելն է: Ենթազանգվածը սահմանվում է (L, R) զույգ ինդեքսներով, այնպես, որ 1 <= L <= R <= զանգվածի երկարությունը: Ենթազանգվածի XOR գումարը L-ից R բոլոր տարրերի XOR-ի արդյունքն է: Վերջնական արդյունքը բոլոր հնարավոր ենթազանգվածների XOR գումարների գումարն է:\n\nՕրինակ:\nf_39([1, 2, 3, 4, 5])  // վերադարձնում է 39", "bn": "একটি জাভাস্ক্রিপ্ট ফাংশন `function f_39(A)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি পূর্ণসংখ্যার অ্যারে A দেওয়া আছে, কাজটি হল সমস্ত উপঅ্যারের XOR এর যোগফল গণনা করা।\nএকটি উপঅ্যারে একটি জোড়া সূচক (L, R) দ্বারা সংজ্ঞায়িত করা হয় যেখানে 1 <= L <= R <= অ্যারের দৈর্ঘ্য।\nএকটি উপঅ্যারের XOR যোগফল হল L থেকে R পর্যন্ত সমস্ত উপাদান XOR করার ফলাফল।\nচূড়ান্ত ফলাফল হল সমস্ত সম্ভাব্য উপঅ্যারের জন্য XOR যোগফলের যোগফল।\n\nউদাহরণ:\nf_39([1, 2, 3, 4, 5])  // 39 রিটার্ন করে", "bg": "Напишете JavaScript функция `function f_39(A)`, за да решите следния проблем:  \nДаден е масив A от цели числа, задачата е да се изчисли сумата на XOR на всички подмасиви.  \nПодмасив се определя от двойка индекси (L, R), така че 1 <= L <= R <= дължината на масива.  \nXOR сумата на подмасив е резултатът от XOR на всички елементи от L до R.  \nКрайният резултат е сумата на XOR сумите за всички възможни подмасиви.\n\nПример:  \nf_39([1, 2, 3, 4, 5])  // връща 39", "zh": "编写一个 JavaScript 函数 `function f_39(A)` 来解决以下问题：  \n给定一个整数数组 A，任务是计算所有子数组的异或和的总和。  \n子数组由一对索引 (L, R) 定义，其中 1 <= L <= R <= 数组的长度。  \n子数组的异或和是从 L 到 R 的所有元素的异或结果。  \n最终结果是所有可能子数组的异或和的总和。  \n\n示例：  \nf_39([1, 2, 3, 4, 5])  // 返回 39  ", "fr": "Écrire une fonction JavaScript `function f_39(A)` pour résoudre le problème suivant :  \nÉtant donné un tableau A d'entiers, la tâche consiste à calculer la somme du XOR de tous les sous-tableaux.  \nUn sous-tableau est défini par une paire d'indices (L, R) telle que 1 <= L <= R <= la longueur du tableau.  \nLa somme XOR d'un sous-tableau est le résultat du XOR de tous les éléments de L à R.  \nLe résultat final est la somme des sommes XOR pour tous les sous-tableaux possibles.  \n\nExemple :  \nf_39([1, 2, 3, 4, 5])  // retourne 39", "de": "Schreiben Sie eine JavaScript-Funktion `function f_39(A)`, um das folgende Problem zu lösen:\nGegeben ein Array A von ganzen Zahlen, besteht die Aufgabe darin, die Summe des XOR aller Teilarrays zu berechnen.\nEin Teilarray wird durch ein Paar von Indizes (L, R) definiert, so dass 1 <= L <= R <= die Länge des Arrays.\nDie XOR-Summe eines Teilarrays ist das Ergebnis des XORs aller Elemente von L bis R.\nDas Endergebnis ist die Summe der XOR-Summen für alle möglichen Teilarrays.\n\nBeispiel:\nf_39([1, 2, 3, 4, 5])  // gibt 39 zurück", "ha": "Rubuta wani aikin JavaScript `function f_39(A)` don warware matsalar mai zuwa:\nAn ba da wani array A na lambobi masu cikakken lamba, aikin shi ne a ƙididdige jumlar XOR na dukkan subarrays.\nAna ayyana wani subarray ta hanyar ma'aurata na alamomin (L, R) ta yadda 1 <= L <= R <= tsawon array.\nJumlar XOR na wani subarray ita ce sakamakon XORing dukkan abubuwa daga L zuwa R.\nSakamakon ƙarshe shi ne jumlar XOR sums don dukkan subarrays masu yiwuwa.\n\nMisali:\nf_39([1, 2, 3, 4, 5])  // returns 39", "hi": "`function f_39(A)` नामक एक JavaScript फ़ंक्शन लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए पूर्णांकों की एक array A के लिए, कार्य यह है कि सभी उप-श्रृंखलाओं के XOR का योग गणना करें।\nएक उप-श्रृंखला को (L, R) सूचकांक की एक जोड़ी द्वारा परिभाषित किया जाता है ताकि 1 <= L <= R <= array की लंबाई।\nएक उप-श्रृंखला का XOR योग L से R तक के सभी तत्वों का XOR करने का परिणाम है।\nअंतिम परिणाम सभी संभावित उप-श्रृंखलाओं के लिए XOR योगों का योग है।\n\nउदाहरण:\nf_39([1, 2, 3, 4, 5])  // 39 लौटाता है", "hu": "Írj egy JavaScript függvényt `function f_39(A)` a következő probléma megoldására:\nAdott egy A egész számokat tartalmazó tömb, a feladat az, hogy kiszámítsuk az összes részhalmaz XOR összegét.\nEgy részhalmazt egy (L, R) indexpár határoz meg, ahol 1 <= L <= R <= a tömb hossza.\nEgy részhalmaz XOR összege az L-től R-ig terjedő összes elem XOR-olásának eredménye.\nA végső eredmény az összes lehetséges részhalmaz XOR összegeinek összege.\n\nPélda:\nf_39([1, 2, 3, 4, 5])  // visszaadja 39", "es": "Escribe una función de JavaScript `function f_39(A)` para resolver el siguiente problema:\nDado un array A de enteros, la tarea es calcular la suma del XOR de todos los subarrays.\nUn subarray se define por un par de índices (L, R) tal que 1 <= L <= R <= la longitud del array.\nLa suma XOR de un subarray es el resultado de aplicar XOR a todos los elementos desde L hasta R.\nEl resultado final es la suma de las sumas XOR para todos los subarrays posibles.\n\nEjemplo:\nf_39([1, 2, 3, 4, 5])  // devuelve 39", "arb": "اكتب دالة JavaScript `function f_39(A)` لحل المشكلة التالية:\nمعطى مصفوفة A من الأعداد الصحيحة، المهمة هي حساب مجموع XOR لجميع المصفوفات الفرعية.\nيتم تعريف المصفوفة الفرعية بواسطة زوج من الفهارس (L, R) بحيث 1 <= L <= R <= طول المصفوفة.\nمجموع XOR لمصفوفة فرعية هو نتيجة XOR لجميع العناصر من L إلى R.\nالنتيجة النهائية هي مجموع نتائج XOR لجميع المصفوفات الفرعية الممكنة.\n\nمثال:\nf_39([1, 2, 3, 4, 5])  // يعيد 39", "sw": "Andika kazi ya JavaScript `function f_39(A)` kutatua tatizo lifuatalo:\nUkipiwa safu A ya nambari za mzima, kazi ni kuhesabu jumla ya XOR ya sehemu zote ndogo za safu.\nSehemu ndogo ya safu inafafanuliwa na jozi ya faharasa (L, R) ambapo 1 <= L <= R <= urefu wa safu.\nJumla ya XOR ya sehemu ndogo ya safu ni matokeo ya XOR ya vipengele vyote kutoka L hadi R.\nMatokeo ya mwisho ni jumla ya XOR za sehemu ndogo zote zinazowezekana.\n\nMfano:\nf_39([1, 2, 3, 4, 5])  // inarudisha 39", "tr": "Bir JavaScript fonksiyonu `function f_39(A)` yazın ve aşağıdaki problemi çözün:\nVerilen bir tamsayı dizisi A için, tüm alt dizilerin XOR toplamını hesaplama görevi.\nBir alt dizi, (L, R) indeks çifti ile tanımlanır ve 1 <= L <= R <= dizinin uzunluğu olmalıdır.\nBir alt dizinin XOR toplamı, L'den R'ye kadar olan tüm elemanların XOR'lanması sonucudur.\nNihai sonuç, tüm olası alt diziler için XOR toplamlarının toplamıdır.\n\nÖrnek:\nf_39([1, 2, 3, 4, 5])  // 39 döndürür", "vi": "Viết một hàm JavaScript `function f_39(A)` để giải quyết vấn đề sau:  \nCho một mảng A gồm các số nguyên, nhiệm vụ là tính tổng của XOR của tất cả các mảng con.  \nMột mảng con được định nghĩa bởi một cặp chỉ số (L, R) sao cho 1 <= L <= R <= độ dài của mảng.  \nTổng XOR của một mảng con là kết quả của việc XOR tất cả các phần tử từ L đến R.  \nKết quả cuối cùng là tổng của các tổng XOR cho tất cả các mảng con có thể có.\n\nVí dụ:  \nf_39([1, 2, 3, 4, 5])  // trả về 39", "id": "Tulis sebuah fungsi JavaScript `function f_39(A)` untuk menyelesaikan masalah berikut:\nDiberikan sebuah array A yang berisi bilangan bulat, tugasnya adalah menghitung jumlah dari XOR semua subarray.\nSebuah subarray didefinisikan oleh sepasang indeks (L, R) sehingga 1 <= L <= R <= panjang array.\nJumlah XOR dari sebuah subarray adalah hasil dari XOR semua elemen dari L hingga R.\nHasil akhirnya adalah jumlah dari semua jumlah XOR untuk semua subarray yang mungkin.\n\nContoh:\nf_39([1, 2, 3, 4, 5])  // mengembalikan 39", "ja": "`function f_39(A)`というJavaScript関数を書いて、次の問題を解決してください:\n整数の配列Aが与えられたとき、すべての部分配列のXORの合計を計算することが課題です。\n部分配列は、1 <= L <= R <= 配列の長さを満たすインデックスのペア(L, R)によって定義されます。\n部分配列のXORの合計は、LからRまでのすべての要素をXORした結果です。\n最終結果は、すべての可能な部分配列のXOR合計の合計です。\n\n例:\nf_39([1, 2, 3, 4, 5])  // returns 39", "ko": "JavaScript 함수를 작성하십시오 `function f_39(A)` 다음 문제를 해결하기 위해:\n정수 배열 A가 주어졌을 때, 모든 부분 배열의 XOR 합의 합계를 계산하는 것이 과제입니다.\n부분 배열은 인덱스 쌍 (L, R)에 의해 정의되며, 여기서 1 <= L <= R <= 배열의 길이입니다.\n부분 배열의 XOR 합은 L에서 R까지의 모든 요소를 XOR한 결과입니다.\n최종 결과는 가능한 모든 부분 배열에 대한 XOR 합의 합입니다.\n\n예시:\nf_39([1, 2, 3, 4, 5])  // 39를 반환합니다.", "ml": "`function f_39(A)` എന്ന ജാവാസ്ക്രിപ്റ്റ് ഫംഗ്ഷൻ എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nഒരു പൂർണ്ണസംഖ്യകളുടെ നിര A നൽകിയാൽ, എല്ലാ ഉപനിരകളുടെയും XOR യുടെ സംഖ്യ കണക്കാക്കുക എന്നതാണ് ഈ പ്രവർത്തി.\nഒരു ഉപനിര (L, R) എന്ന സൂചികകളുടെ ജോഡിയാൽ നിർവ്വചിക്കപ്പെടുന്നു, 1 <= L <= R <= നിരയുടെ നീളം.\nഒരു ഉപനിരയുടെ XOR സംഖ്യ L മുതൽ R വരെയുള്ള എല്ലാ ഘടകങ്ങളുടെയും XOR ഫലമാണ്.\nഎല്ലാ സാധ്യതയുള്ള ഉപനിരകളുടെയും XOR സംഖ്യകളുടെ സംഖ്യയാണ് അന്തിമ ഫലം.\n\nഉദാഹരണം:\nf_39([1, 2, 3, 4, 5])  // 39 മടക്കുന്നു", "fa": "یک تابع جاوااسکریپت `function f_39(A)` بنویسید تا مسئله زیر را حل کند:\nبا توجه به یک آرایه A از اعداد صحیح، وظیفه محاسبه مجموع XOR تمام زیرآرایه‌ها است.\nیک زیرآرایه با یک جفت شاخص (L, R) تعریف می‌شود به طوری که 1 <= L <= R <= طول آرایه.\nمجموع XOR یک زیرآرایه نتیجه XOR کردن تمام عناصر از L تا R است.\nنتیجه نهایی مجموع مجموع‌های XOR برای تمام زیرآرایه‌های ممکن است.\n\nمثال:\nf_39([1, 2, 3, 4, 5])  // returns 39"}, "level": "middle", "test": "const testf_39 = () => {\n    console.assert(f_39([1, 2, 3, 4, 5]) === 39);\n    console.assert(f_39([1, 1, 1]) === 4);\n    console.assert(f_39([2, 3, 1]) === 9);\n    console.assert(f_39([4, 5, 7, 9]) === 74);\n    console.assert(f_39([0, 0, 0, 0]) === 0);\n    console.assert(f_39([8, 8, 8, 8, 8]) === 72);\n    console.assert(f_39([3, 6, 9, 12, 15]) === 125);\n    console.assert(f_39([10, 20, 30, 40, 50]) === 390);\n    console.assert(f_39([16, 16, 16, 16, 16, 16]) === 192);\n    console.assert(f_39([1, 3, 5, 7, 9, 11, 13]) === 192);\n    console.assert(f_39([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) === 218);\n}\n\ntestf_39();", "entry_point": "f_39", "signature": "function f_39(A)", "docstring": {"en": "Given an array A of integers, the task is to calculate the sum of the XOR of all subarrays.\nA subarray is defined by a pair of indices (L, R) such that 1 <= L <= R <= the length of the array.\nThe XOR sum of a subarray is the result of XORing all elements from L to R.\nThe final result is the sum of the XOR sums for all possible subarrays.\n\nExample:\nf_39([1, 2, 3, 4, 5])  // returns 39\n", "sq": "Duke pasur një varg A të numrave të plotë, detyra është të llogaritet shuma e XOR-it të të gjitha nënvargjeve. Një nënvarg përcaktohet nga një çift indeksesh (L, R) të tilla që 1 <= L <= R <= gjatësia e vargut. Shuma XOR e një nënvargu është rezultati i XOR-it të të gjithë elementeve nga L në R. Rezultati përfundimtar është shuma e shumave XOR për të gjitha nënvargjet e mundshme.\n\nShembull:\nf_39([1, 2, 3, 4, 5])  // kthen 39", "hy": "Տրված է A ամբողջ թվերի զանգվածը, խնդիրը բոլոր ենթազանգվածների XOR-ի գումարը հաշվարկելն է:\nԵնթազանգվածը սահմանվում է (L, R) զույգ ինդեքսներով, այնպես, որ 1 <= L <= R <= զանգվածի երկարությունը:\nԵնթազանգվածի XOR գումարը L-ից R բոլոր տարրերի XOR-ի արդյունքն է:\nՎերջնական արդյունքը բոլոր հնարավոր ենթազանգվածների համար XOR գումարների գումարն է:\n\nՕրինակ:\nf_39([1, 2, 3, 4, 5])  // վերադարձնում է 39", "bn": "একটি পূর্ণসংখ্যার অ্যারে A দেওয়া হয়েছে, কাজটি হল সমস্ত উপঅ্যারের XOR এর যোগফল গণনা করা। \nএকটি উপঅ্যারে (L, R) সূচক জোড়া দ্বারা সংজ্ঞায়িত করা হয় যেখানে 1 <= L <= R <= অ্যারের দৈর্ঘ্য। \nএকটি উপঅ্যারের XOR যোগফল হল L থেকে R পর্যন্ত সমস্ত উপাদানের XOR এর ফলাফল। \nচূড়ান্ত ফলাফল হল সমস্ত সম্ভাব্য উপঅ্যারের জন্য XOR যোগফলের যোগফল।\n\nউদাহরণ:\nf_39([1, 2, 3, 4, 5])  // 39 ফেরত দেয়", "bg": "Даден е масив A от цели числа, задачата е да се изчисли сумата от XOR на всички подмасиви. Подмасив се дефинира от двойка индекси (L, R) така че 1 <= L <= R <= дължината на масива. XOR сумата на подмасив е резултатът от прилагането на XOR върху всички елементи от L до R. Крайният резултат е сумата от XOR сумите за всички възможни подмасиви.\n\nПример:\nf_39([1, 2, 3, 4, 5])  // връща 39", "zh": "给定一个整数数组A，任务是计算所有子数组的异或和之和。\n子数组由一对索引 (L, R) 定义，其中 1 <= L <= R <= 数组的长度。\n子数组的异或和是从 L 到 R 的所有元素进行异或运算的结果。\n最终结果是所有可能子数组的异或和之和。\n\n示例：\nf_39([1, 2, 3, 4, 5])  // 返回 39", "fr": "Étant donné un tableau A d'entiers, la tâche consiste à calculer la somme du XOR de tous les sous-tableaux.  \nUn sous-tableau est défini par une paire d'indices (L, R) telle que 1 <= L <= R <= la longueur du tableau.  \nLa somme XOR d'un sous-tableau est le résultat du XOR de tous les éléments de L à R.  \nLe résultat final est la somme des sommes XOR pour tous les sous-tableaux possibles.\n\nExemple :  \nf_39([1, 2, 3, 4, 5])  // renvoie 39", "de": "Gegeben ein Array A von ganzen Zahlen, besteht die Aufgabe darin, die Summe des XOR aller Teilarrays zu berechnen.\nEin Teilarray wird durch ein Paar von Indizes (L, R) definiert, so dass 1 <= L <= R <= die Länge des Arrays.\nDie XOR-Summe eines Teilarrays ist das Ergebnis des XORs aller Elemente von L bis R.\nDas Endergebnis ist die Summe der XOR-Summen für alle möglichen Teilarrays.\n\nBeispiel:\nf_39([1, 2, 3, 4, 5])  // gibt 39 zurück", "ha": "An ba da wani array A na lambobi masu cikakken lamba, aikin shi ne a ƙididdige jumlar XOR na dukkan subarrays.\nAnfani ne aka bayyana ta hanyar ma'aurata na alamomin (L, R) wanda 1 <= L <= R <= tsawon jerin.\nJimillar XOR na wani subarray shine sakamakon XORing duk abubuwa daga L zuwa R.\nSakamakon karshe shine jimillar XOR na dukkanin subarrays masu yiwuwa.\n\nMisali:\nf_39([1, 2, 3, 4, 5])  // yana dawowa 39", "hi": "दिए गए पूर्णांकों की एक सरणी A के लिए, कार्य सभी उपसरणियों के XOR का योग गणना करना है। एक उपसरणी को (L, R) सूचकांक की एक जोड़ी द्वारा परिभाषित किया जाता है, जहाँ 1 <= L <= R <= सरणी की लंबाई। एक उपसरणी का XOR योग L से R तक के सभी तत्वों का XOR करने का परिणाम है। अंतिम परिणाम सभी संभावित उपसरणियों के XOR योगों का योग है।\n\nउदाहरण:\nf_39([1, 2, 3, 4, 5])  // 39 लौटाता है", "hu": "Adott egy A egész számokat tartalmazó tömb, a feladat az összes részhalmaz XOR összegének kiszámítása. \nEgy részhalmazt egy (L, R) indexpár határoz meg, ahol 1 <= L <= R <= a tömb hossza. \nEgy részhalmaz XOR összege az L-től R-ig terjedő összes elem XOR-olásának eredménye. \nA végső eredmény az összes lehetséges részhalmaz XOR összegeinek összege.\n\nPélda:\nf_39([1, 2, 3, 4, 5])  // visszaadja a 39-et", "es": "Dado un array A de enteros, la tarea es calcular la suma del XOR de todos los subarrays.  \nUn subarray se define por un par de índices (L, R) tal que 1 <= L <= R <= la longitud del array.  \nLa suma XOR de un subarray es el resultado de aplicar XOR a todos los elementos desde L hasta R.  \nEl resultado final es la suma de las sumas XOR para todos los subarrays posibles.\n\nEjemplo:  \nf_39([1, 2, 3, 4, 5])  // devuelve 39", "arb": "بالنظر إلى مصفوفة A من الأعداد الصحيحة، المهمة هي حساب مجموع الـ XOR لجميع القطع الفرعية.\nيتم تعريف القطعة الفرعية بواسطة زوج من الفهارس (L, R) بحيث 1 <= L <= R <= طول المصفوفة.\nمجموع الـ XOR لقطعة فرعية هو نتيجة تطبيق عملية XOR على جميع العناصر من L إلى R.\nالنتيجة النهائية هي مجموع قيم الـ XOR لجميع القطع الفرعية الممكنة.\n\nمثال:\nf_39([1, 2, 3, 4, 5])  // يعيد 39", "sw": "Ukipiwa safu A ya nambari za mzima, kazi ni kuhesabu jumla ya XOR ya sehemu ndogo zote.\nSehemu ndogo inafafanuliwa na jozi ya fahirisi (L, R) ambapo 1 <= L <= R <= urefu wa safu.\nJumla ya XOR ya sehemu ndogo ni matokeo ya XOR ya vipengele vyote kutoka L hadi R.\nMatokeo ya mwisho ni jumla ya jumla za XOR kwa sehemu ndogo zote zinazowezekana.\n\nMfano:\nf_39([1, 2, 3, 4, 5])  // inarejesha 39", "tr": "Verilen bir tamsayı dizisi A için, tüm alt dizilerin XOR toplamını hesaplama görevi.\nBir alt dizi, 1 <= L <= R <= dizinin uzunluğu olacak şekilde bir (L, R) indeks çifti ile tanımlanır.\nBir alt dizinin XOR toplamı, L'den R'ye kadar olan tüm elemanların XOR'lanması sonucu elde edilir.\nSonuç, tüm olası alt diziler için XOR toplamlarının toplamıdır.\n\nÖrnek:\nf_39([1, 2, 3, 4, 5])  // 39 döndürür", "vi": "Cho một mảng A gồm các số nguyên, nhiệm vụ là tính tổng của XOR của tất cả các mảng con. \nMột mảng con được định nghĩa bởi một cặp chỉ số (L, R) sao cho 1 <= L <= R <= độ dài của mảng. \nTổng XOR của một mảng con là kết quả của việc XOR tất cả các phần tử từ L đến R. \nKết quả cuối cùng là tổng của các tổng XOR cho tất cả các mảng con có thể.\n\nVí dụ:\nf_39([1, 2, 3, 4, 5])  // trả về 39", "id": "Diberikan sebuah array A yang berisi bilangan bulat, tugasnya adalah menghitung jumlah dari XOR semua subarray.  \nSebuah subarray didefinisikan oleh sepasang indeks (L, R) di mana 1 <= L <= R <= panjang array.  \nJumlah XOR dari sebuah subarray adalah hasil dari XOR semua elemen dari L hingga R.  \nHasil akhirnya adalah jumlah dari semua jumlah XOR untuk semua subarray yang mungkin.\n\nContoh:\nf_39([1, 2, 3, 4, 5])  // mengembalikan 39", "ja": "整数の配列 A が与えられたとき、すべての部分配列の XOR の合計を計算するタスクです。\n部分配列は、1 <= L <= R <= 配列の長さを満たすインデックスのペア (L, R) によって定義されます。\n部分配列の XOR 合計は、L から R までのすべての要素を XOR した結果です。\n最終的な結果は、すべての可能な部分配列の XOR 合計の合計です。\n\n例:\nf_39([1, 2, 3, 4, 5])  // 39 を返します", "ko": "주어진 정수 배열 A에 대해, 모든 부분 배열의 XOR 합을 계산하는 작업입니다.  \n부분 배열은 인덱스 쌍 (L, R)에 의해 정의되며, 여기서 1 <= L <= R <= 배열의 길이입니다.  \n부분 배열의 XOR 합은 L에서 R까지의 모든 요소를 XOR한 결과입니다.  \n최종 결과는 가능한 모든 부분 배열의 XOR 합의 합입니다.\n\n예시:\nf_39([1, 2, 3, 4, 5])  // 39 반환", "ml": "ഒരു പൂർണ്ണസംഖ്യകളുടെ നിരയായ A നൽകിയാൽ, എല്ലാ ഉപനിരകളുടെയും XOR യുടെ മൊത്തം കണക്കാക്കുക എന്നതാണ് ഈ പ്രവർത്തിയുടെ ലക്ഷ്യം. \nഒരു ഉപനിര 1 <= L <= R <= നിരയുടെ നീളം എന്ന വ്യവസ്ഥ പാലിക്കുന്ന (L, R) എന്ന സൂചികകളുടെ ജോഡിയാൽ നിർവ്വചിക്കപ്പെടുന്നു. \nഒരു ഉപനിരയുടെ XOR മൊത്തം L മുതൽ R വരെ എല്ലാ ഘടകങ്ങളുടെയും XOR ഫലമാണ്. \nഎല്ലാ സാധ്യതയുള്ള ഉപനിരകളുടെയും XOR മൊത്തങ്ങളുടെ തുകയാണ് അന്തിമ ഫലം.\n\nഉദാഹരണം:\nf_39([1, 2, 3, 4, 5])  // 39 മടക്കുന്നു", "fa": "با توجه به آرایه A از اعداد صحیح، وظیفه این است که مجموع XOR تمام زیرآرایه‌ها را محاسبه کنیم.\nیک زیرآرایه با یک جفت اندیس (L, R) تعریف می‌شود به طوری که 1 <= L <= R <= طول آرایه.\nمجموع XOR یک زیرآرایه نتیجه XOR کردن تمام عناصر از L تا R است.\nنتیجه نهایی مجموع مقادیر XOR برای تمام زیرآرایه‌های ممکن است.\n\nمثال:\nf_39([1, 2, 3, 4, 5])  // مقدار 39 را بازمی‌گرداند"}}
{"task_id": "JavaScript/40", "prompt": {"en": "/**\n * Given two positive integers n and k, find the number of positive integers x,\n * where 1 <= x <= n, that can be expressed as x = a^b with a and b being positive integers\n * and b >= k. Different legal representations of the same number are counted only once.\n * Example:\n *   f_40(99, 1) returns 99\n */\nfunction f_40(n, k) {", "sq": "/**\n * Duke pasur dy numra të plotë pozitivë n dhe k, gjeni numrin e numrave të plotë pozitivë x,\n * ku 1 <= x <= n, që mund të shprehen si x = a^b me a dhe b që janë numra të plotë pozitivë\n * dhe b >= k. Reprezentimet e ndryshme të ligjshme të të njëjtit numër numërohen vetëm një herë.\n * Shembull:\n *   f_40(99, 1) kthen 99\n */\nfunction f_40(n, k) {", "hy": "/**\n * Տրված է երկու դրական ամբողջ թիվ n և k, գտնել դրական ամբողջ թվերի x քանակը,\n * որտեղ 1 <= x <= n, որոնք կարող են արտահայտվել որպես x = a^b, որտեղ a և b դրական ամբողջ թվեր են\n * և b >= k: Նույն թվի տարբեր թույլատրելի ներկայացումները հաշվում են միայն մեկ անգամ:\n * Օրինակ:\n *   f_40(99, 1) վերադարձնում է 99\n */\nfunction f_40(n, k) {", "bn": "/**\n * দুটি ধনাত্মক পূর্ণসংখ্যা n এবং k দেওয়া আছে, ধনাত্মক পূর্ণসংখ্যা x এর সংখ্যা খুঁজে বের করুন,\n * যেখানে 1 <= x <= n, যা x = a^b হিসাবে প্রকাশ করা যায় যেখানে a এবং b ধনাত্মক পূর্ণসংখ্যা\n * এবং b >= k। একই সংখ্যার বিভিন্ন বৈধ উপস্থাপনাকে কেবল একবার গণনা করা হয়।\n * উদাহরণ:\n *   f_40(99, 1) returns 99\n */\nfunction f_40(n, k) {", "bg": "/**\n * Дадени са две положителни цели числа n и k, намерете броя на положителните цели числа x,\n * където 1 <= x <= n, които могат да бъдат изразени като x = a^b с a и b, които са положителни цели числа\n * и b >= k. Различните легални представяния на едно и също число се броят само веднъж.\n * Пример:\n *   f_40(99, 1) връща 99\n */\nfunction f_40(n, k) {", "zh": "/**\n * 给定两个正整数 n 和 k，找出有多少个正整数 x，\n * 其中 1 <= x <= n，可以表示为 x = a^b，且 a 和 b 为正整数\n * 且 b >= k。相同数字的不同合法表示仅计数一次。\n * 示例：\n *   f_40(99, 1) 返回 99\n */\nfunction f_40(n, k) {", "fr": "/**\n * Étant donné deux entiers positifs n et k, trouver le nombre d'entiers positifs x,\n * où 1 <= x <= n, qui peuvent être exprimés comme x = a^b avec a et b étant des entiers positifs\n * et b >= k. Différentes représentations légales du même nombre sont comptées une seule fois.\n * Exemple :\n *   f_40(99, 1) retourne 99\n */\nfunction f_40(n, k) {", "de": "/**\n * Gegeben zwei positive ganze Zahlen n und k, finde die Anzahl der positiven ganzen Zahlen x,\n * wobei 1 <= x <= n, die als x = a^b ausgedrückt werden können, wobei a und b positive ganze Zahlen sind\n * und b >= k. Verschiedene gültige Darstellungen derselben Zahl werden nur einmal gezählt.\n * Beispiel:\n *   f_40(99, 1) gibt 99 zurück\n */\nfunction f_40(n, k) {", "ha": "/**\n * An ba lambobi guda biyu masu kyau n da k, nemo adadin lambobi masu kyau x,\n * inda 1 <= x <= n, wanda za a iya bayyana shi azaman x = a^b tare da a da b suna kasancewa lambobi masu kyau\n * kuma b >= k. Ana kirga wakilcin doka daban-daban na lamba ɗaya sau ɗaya kawai.\n * Misali:\n *   f_40(99, 1) returns 99\n */\nfunction f_40(n, k) {", "hi": "/**\n * दिए गए दो धनात्मक पूर्णांक n और k, उन धनात्मक पूर्णांकों x की संख्या खोजें,\n * जहाँ 1 <= x <= n, जिसे x = a^b के रूप में व्यक्त किया जा सकता है जहाँ a और b धनात्मक पूर्णांक हैं\n * और b >= k. एक ही संख्या के विभिन्न वैध अभ्यावेदन केवल एक बार गिने जाते हैं।\n * उदाहरण:\n *   f_40(99, 1) returns 99\n */\nfunction f_40(n, k) {", "hu": "/**\n * Két pozitív egész szám, n és k esetén, találja meg azon pozitív egész számok x számát,\n * ahol 1 <= x <= n, amelyek kifejezhetők x = a^b alakban, ahol a és b pozitív egész számok\n * és b >= k. Ugyanazon szám különböző jogszerű ábrázolásait csak egyszer számoljuk.\n * Példa:\n *   f_40(99, 1) visszaadja 99\n */\nfunction f_40(n, k) {", "es": "/**\n * Dado dos enteros positivos n y k, encuentra el número de enteros positivos x,\n * donde 1 <= x <= n, que se pueden expresar como x = a^b con a y b siendo enteros positivos\n * y b >= k. Diferentes representaciones legales del mismo número se cuentan solo una vez.\n * Ejemplo:\n *   f_40(99, 1) devuelve 99\n */\nfunction f_40(n, k) {", "arb": "/**\n * معطى عددين صحيحين موجبين n و k، ابحث عن عدد الأعداد الصحيحة الموجبة x،\n * حيث 1 <= x <= n، التي يمكن التعبير عنها كـ x = a^b بحيث أن a و b هما عددان صحيحان موجبان\n * و b >= k. يتم احتساب التمثيلات القانونية المختلفة لنفس العدد مرة واحدة فقط.\n * مثال:\n *   f_40(99, 1) يعيد 99\n */\nfunction f_40(n, k) {", "sw": "/**\n * Ukipewa nambari mbili chanya n na k, tafuta idadi ya nambari chanya x,\n * ambapo 1 <= x <= n, ambazo zinaweza kuonyeshwa kama x = a^b huku a na b wakiwa nambari chanya\n * na b >= k. Uwakilishi tofauti halali wa nambari sawa huhesabiwa mara moja tu.\n * Mfano:\n *   f_40(99, 1) inarudisha 99\n */\nfunction f_40(n, k) {", "tr": "/**\n * İki pozitif tam sayı n ve k verildiğinde, 1 <= x <= n aralığında,\n * x = a^b şeklinde ifade edilebilen pozitif tam sayı x'lerin sayısını bulun,\n * burada a ve b pozitif tam sayılardır ve b >= k'dır. Aynı sayının farklı yasal temsilleri yalnızca bir kez sayılır.\n * Örnek:\n *   f_40(99, 1) 99 döndürür\n */\nfunction f_40(n, k) {", "vi": "/**\n * Cho hai số nguyên dương n và k, tìm số lượng số nguyên dương x,\n * với 1 <= x <= n, có thể biểu diễn dưới dạng x = a^b với a và b là các số nguyên dương\n * và b >= k. Các biểu diễn hợp lệ khác nhau của cùng một số chỉ được đếm một lần.\n * Ví dụ:\n *   f_40(99, 1) trả về 99\n */\nfunction f_40(n, k) {", "id": "/**\n * Diberikan dua bilangan bulat positif n dan k, temukan jumlah bilangan bulat positif x,\n * di mana 1 <= x <= n, yang dapat dinyatakan sebagai x = a^b dengan a dan b adalah bilangan bulat positif\n * dan b >= k. Representasi legal yang berbeda dari angka yang sama dihitung hanya sekali.\n * Contoh:\n *   f_40(99, 1) mengembalikan 99\n */\nfunction f_40(n, k) {", "ja": "/**\n * 2つの正の整数nとkが与えられたとき、1 <= x <= nの範囲で、\n * x = a^bとして表現できる正の整数xの数を求めます。ここでaとbは正の整数であり、\n * b >= kです。同じ数の異なる合法的な表現は一度だけカウントされます。\n * 例:\n *   f_40(99, 1) は99を返します\n */\nfunction f_40(n, k) {", "ko": "/**\n * 두 양의 정수 n과 k가 주어졌을 때, 1 <= x <= n인 양의 정수 x의 개수를 찾습니다.\n * 여기서 x는 a와 b가 양의 정수이고 b >= k인 경우 x = a^b로 표현될 수 있습니다.\n * 동일한 숫자의 다른 합법적인 표현은 한 번만 계산됩니다.\n * 예시:\n *   f_40(99, 1) returns 99\n */\nfunction f_40(n, k) {", "ml": "/**\n * രണ്ട് പോസിറ്റീവ് പൂർണ്ണസംഖ്യകൾ n, k എന്നിവ നൽകിയാൽ, 1 <= x <= n എന്ന നിലയിൽ,\n * x = a^b എന്ന രൂപത്തിൽ പ്രകടിപ്പിക്കാവുന്ന പോസിറ്റീവ് പൂർണ്ണസംഖ്യകളുടെ എണ്ണം കണ്ടെത്തുക,\n * ഇവിടെ a, b പോസിറ്റീവ് പൂർണ്ണസംഖ്യകളാണ്, b >= k. \n * ഒരേ സംഖ്യയുടെ വ്യത്യസ്തമായ നിയമാനുസൃത പ്രതിനിധാനങ്ങൾ ഒരിക്കൽ മാത്രം എണ്ണപ്പെടും.\n * ഉദാഹരണം:\n *   f_40(99, 1) 99 നെ തിരികെ നൽകുന്നു\n */\nfunction f_40(n, k) {", "fa": "/**\n * با داشتن دو عدد صحیح مثبت n و k، تعداد اعداد صحیح مثبت x را پیدا کنید،\n * که در آن 1 <= x <= n، که می‌توان آن را به صورت x = a^b بیان کرد که a و b اعداد صحیح مثبت هستند\n * و b >= k. نمایش‌های قانونی مختلف از یک عدد مشابه فقط یک بار شمارش می‌شوند.\n * مثال:\n *   f_40(99, 1) returns 99\n */\nfunction f_40(n, k) {"}, "canonical_solution": "let count = 0;\n    let x = 0;\n    let mp = new Array(n + 1).fill(false);\n    \n    for (let i = 2; i <= Math.cbrt(n); ++i) {\n        let t = i * i;\n        let m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if (Math.pow(Math.floor(Math.sqrt(t)), 2) === t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k === 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += Math.floor(Math.sqrt(n)) - x;\n    }\n    return count;\n}", "instruction": {"en": "Write a JavaScript function `function f_40(n, k)` to solve the following problem:\nGiven two positive integers n and k, find the number of positive integers x,\nwhere 1 <= x <= n, that can be expressed as x = a^b with a and b being positive integers\nand b >= k. Different legal representations of the same number are counted only once.\nExample:\n  f_40(99, 1) returns 99\n", "sq": "Shkruani një funksion JavaScript `function f_40(n, k)` për të zgjidhur problemin e mëposhtëm:  \nDuke pasur dy numra të plotë pozitivë n dhe k, gjeni numrin e numrave të plotë pozitivë x,  \nku 1 <= x <= n, që mund të shprehen si x = a^b me a dhe b që janë numra të plotë pozitivë  \ndhe b >= k. Përfaqësimet e ndryshme të ligjshme të të njëjtit numër numërohen vetëm një herë.  \nShembull:  \n  f_40(99, 1) kthen 99  ", "hy": "Գրեք JavaScript ֆունկցիա `function f_40(n, k)` հետևյալ խնդիրը լուծելու համար:\nՏրված են երկու դրական ամբողջ թվեր n և k, գտնել դրական ամբողջ թվերի քանակը x,\nորտեղ 1 <= x <= n, որը կարող է արտահայտվել որպես x = a^b, որտեղ a և b դրական ամբողջ թվեր են\nև b >= k: Նույն թվի տարբեր օրինական ներկայացումները հաշվում են միայն մեկ անգամ:\nՕրինակ:\n  f_40(99, 1) վերադարձնում է 99", "bn": "একটি জাভাস্ক্রিপ্ট ফাংশন `function f_40(n, k)` লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\nদুটি ধনাত্মক পূর্ণসংখ্যা n এবং k দেওয়া আছে, এমন ধনাত্মক পূর্ণসংখ্যা x এর সংখ্যা খুঁজে বের করুন,\nযেখানে 1 <= x <= n, যা x = a^b হিসাবে প্রকাশ করা যেতে পারে যেখানে a এবং b ধনাত্মক পূর্ণসংখ্যা\nএবং b >= k। একই সংখ্যার বিভিন্ন বৈধ উপস্থাপনাকে শুধুমাত্র একবার গণনা করা হয়।\nউদাহরণ:\n  f_40(99, 1) returns 99", "bg": "Напишете JavaScript функция `function f_40(n, k)` за решаване на следния проблем:  \nДадени са две положителни цели числа n и k, намерете броя на положителните цели числа x,  \nкъдето 1 <= x <= n, които могат да бъдат изразени като x = a^b с a и b като положителни цели числа  \nи b >= k. Различните легални представяния на едно и също число се броят само веднъж.  \nПример:  \n  f_40(99, 1) връща 99  ", "zh": "编写一个 JavaScript 函数 `function f_40(n, k)` 来解决以下问题：  \n给定两个正整数 n 和 k，找出多少个正整数 x，满足 1 <= x <= n，可以表示为 x = a^b，其中 a 和 b 是正整数，且 b >= k。相同数字的不同合法表示只计数一次。  \n示例：  \nf_40(99, 1) 返回 99  ", "fr": "Écrire une fonction JavaScript `function f_40(n, k)` pour résoudre le problème suivant :  \nÉtant donné deux entiers positifs n et k, trouver le nombre d'entiers positifs x,  \noù 1 <= x <= n, qui peuvent être exprimés comme x = a^b avec a et b étant des entiers positifs  \net b >= k. Différentes représentations légales du même nombre sont comptées une seule fois.  \nExemple :  \n  f_40(99, 1) retourne 99  ", "de": "Schreiben Sie eine JavaScript-Funktion `function f_40(n, k)`, um das folgende Problem zu lösen:\nGegeben sind zwei positive ganze Zahlen n und k. Finden Sie die Anzahl der positiven ganzen Zahlen x,\nfür die 1 <= x <= n gilt, die als x = a^b ausgedrückt werden können, wobei a und b positive ganze Zahlen sind\nund b >= k. Verschiedene zulässige Darstellungen derselben Zahl werden nur einmal gezählt.\nBeispiel:\n  f_40(99, 1) gibt 99 zurück", "ha": "Rubuta wani aikin JavaScript `function f_40(n, k)` don warware matsalar mai zuwa:\nAn ba da lambobi guda biyu masu kyau n da k, nemo adadin lambobi masu kyau x,\ninda 1 <= x <= n, wanda za a iya bayyana shi a matsayin x = a^b tare da a da b kasancewa lambobi masu kyau\nkuma b >= k. Ana kirga wakilcin doka daban-daban na wannan lambar sau daya kawai.\nMisali:\n  f_40(99, 1) returns 99", "hi": "JavaScript फ़ंक्शन `function f_40(n, k)` लिखें ताकि निम्नलिखित समस्या का समाधान हो सके:\nदिए गए दो धनात्मक पूर्णांक n और k के लिए, उन धनात्मक पूर्णांकों x की संख्या ज्ञात करें,\nजहाँ 1 <= x <= n, जिसे x = a^b के रूप में व्यक्त किया जा सकता है जहाँ a और b धनात्मक पूर्णांक हैं\nऔर b >= k। एक ही संख्या के विभिन्न वैध अभ्यावेदन को केवल एक बार गिना जाता है।\nउदाहरण:\n  f_40(99, 1) returns 99", "hu": "Írj egy JavaScript függvényt `function f_40(n, k)` a következő probléma megoldására:\nAdott két pozitív egész szám, n és k, találd meg azon pozitív egész számok x számát,\nahol 1 <= x <= n, és amelyek kifejezhetők x = a^b alakban, ahol a és b pozitív egész számok\nés b >= k. Ugyanazon szám különböző érvényes ábrázolásai csak egyszer számítanak.\nPélda:\n  f_40(99, 1) visszaadja 99", "es": "Escribe una función de JavaScript `function f_40(n, k)` para resolver el siguiente problema:  \nDado dos enteros positivos n y k, encuentra el número de enteros positivos x,  \ndonde 1 <= x <= n, que pueden expresarse como x = a^b con a y b siendo enteros positivos  \ny b >= k. Diferentes representaciones legales del mismo número se cuentan solo una vez.  \nEjemplo:  \n  f_40(99, 1) devuelve 99  ", "arb": "اكتب دالة JavaScript `function f_40(n, k)` لحل المشكلة التالية:\nمعطى عددين صحيحين موجبين n و k، ابحث عن عدد الأعداد الصحيحة الموجبة x،\nحيث 1 <= x <= n، والتي يمكن التعبير عنها كـ x = a^b مع كون a و b أعداد صحيحة موجبة\nو b >= k. يتم احتساب التمثيلات القانونية المختلفة لنفس الرقم مرة واحدة فقط.\nمثال:\n  f_40(99, 1) يعيد 99", "sw": "Andika kazi ya JavaScript `function f_40(n, k)` kutatua tatizo lifuatalo:  \nUkipiwa nambari mbili nzima chanya n na k, tafuta idadi ya nambari chanya x,  \nambapo 1 <= x <= n, ambazo zinaweza kuonyeshwa kama x = a^b huku a na b wakiwa nambari nzima chanya  \nna b >= k. Uwakilishi tofauti halali wa nambari sawa unahesabiwa mara moja tu.  \nMfano:  \n  f_40(99, 1) inarudisha 99  ", "tr": "Bir JavaScript fonksiyonu `function f_40(n, k)` yazın ve aşağıdaki problemi çözün:\nİki pozitif tamsayı n ve k verildiğinde, 1 <= x <= n aralığında, x = a^b şeklinde ifade edilebilen pozitif tamsayı x sayısını bulun. Burada a ve b pozitif tamsayılar ve b >= k. Aynı sayının farklı yasal gösterimleri yalnızca bir kez sayılır.\nÖrnek:\n  f_40(99, 1) döndürür 99", "vi": "Viết một hàm JavaScript `function f_40(n, k)` để giải quyết vấn đề sau:  \nCho hai số nguyên dương n và k, tìm số lượng số nguyên dương x,  \nvới 1 <= x <= n, có thể được biểu diễn dưới dạng x = a^b với a và b là các số nguyên dương  \nvà b >= k. Các biểu diễn hợp pháp khác nhau của cùng một số chỉ được đếm một lần.  \nVí dụ:  \n  f_40(99, 1) trả về 99  ", "id": "Tulis sebuah fungsi JavaScript `function f_40(n, k)` untuk menyelesaikan masalah berikut:  \nDiberikan dua bilangan bulat positif n dan k, temukan jumlah bilangan bulat positif x,  \ndi mana 1 <= x <= n, yang dapat dinyatakan sebagai x = a^b dengan a dan b adalah bilangan bulat positif  \ndan b >= k. Representasi legal yang berbeda dari angka yang sama dihitung hanya sekali.  \nContoh:  \n  f_40(99, 1) mengembalikan 99  ", "ja": "JavaScript関数 `function f_40(n, k)` を作成して、次の問題を解決してください。  \n2つの正の整数 n と k が与えられたとき、1 <= x <= n の範囲で、x = a^b と表現できる正の整数 x の数を求めます。ここで、a と b は正の整数であり、b >= k です。同じ数の異なる合法的な表現は一度だけカウントされます。  \n例:  \n  f_40(99, 1) は 99 を返します。", "ko": "JavaScript 함수를 작성하십시오 `function f_40(n, k)` 다음 문제를 해결하기 위해:\n두 개의 양의 정수 n과 k가 주어졌을 때, 1 <= x <= n인 양의 정수 x의 개수를 찾으십시오. 여기서 x는 x = a^b로 표현될 수 있으며, a와 b는 양의 정수이고 b >= k입니다. 동일한 숫자의 다른 합법적인 표현은 한 번만 계산됩니다.\n예:\n  f_40(99, 1) returns 99", "ml": "JavaScript ഫംഗ്ഷൻ `function f_40(n, k)` എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:  \nരണ്ട് പോസിറ്റീവ് പൂർണ്ണസംഖ്യകൾ n, k നൽകിയാൽ, 1 <= x <= n എന്ന നിലയിൽ, x = a^b എന്ന രൂപത്തിൽ പ്രകടിപ്പിക്കാവുന്ന പോസിറ്റീവ് പൂർണ്ണസംഖ്യകളുടെ എണ്ണം കണ്ടെത്തുക, ഇവിടെ a, b പോസിറ്റീവ് പൂർണ്ണസംഖ്യകളാണ്, b >= k. ഒരു സംഖ്യയുടെ വ്യത്യസ്ത നിയമാനുസൃത പ്രതിനിധാനങ്ങൾ ഒരു പ്രാവശ്യം മാത്രമേ എണ്ണുകയുള്ളൂ.  \nഉദാഹരണം:  \n  f_40(99, 1) 99 നെ തിരികെ നൽകുന്നു", "fa": "یک تابع جاوااسکریپت `function f_40(n, k)` بنویسید تا مسئله زیر را حل کند:\nبا توجه به دو عدد صحیح مثبت n و k، تعداد اعداد صحیح مثبت x را پیدا کنید،\nکه 1 <= x <= n، که می‌توان آن را به صورت x = a^b با a و b به عنوان اعداد صحیح مثبت\nو b >= k بیان کرد. نمایش‌های قانونی مختلف از یک عدد مشابه فقط یک بار شمارش می‌شوند.\nمثال:\n  f_40(99, 1) مقدار 99 را برمی‌گرداند."}, "level": "hard", "test": "const testf_40 = () => {\n    console.assert(f_40(99, 1) === 99, 'Expected 99, got ' + f_40(99, 1));\n    console.assert(f_40(99, 3) === 7, 'Expected 7, got ' + f_40(99, 3));\n    console.assert(f_40(99, 2) === 12, 'Expected 12, got ' + f_40(99, 2));\n    console.assert(f_40(10, 1) === 10, 'Expected 10, got ' + f_40(10, 1));\n    console.assert(f_40(10, 2) === 4, 'Expected 4, got ' + f_40(10, 2));\n    console.assert(f_40(500, 1) === 500, 'Expected 500, got ' + f_40(500, 1));\n    console.assert(f_40(500, 2) === 30, 'Expected 30, got ' + f_40(500, 2));\n    console.assert(f_40(500, 3) === 13, 'Expected 13, got ' + f_40(500, 3));\n    console.assert(f_40(1000, 1) === 1000, 'Expected 1000, got ' + f_40(1000, 1));\n    console.assert(f_40(1000, 2) === 41, 'Expected 41, got ' + f_40(1000, 2));\n    console.assert(f_40(1000, 3) === 17, 'Expected 17, got ' + f_40(1000, 3));\n    console.assert(f_40(1000, 93) === 1, 'Expected 1, got ' + f_40(1000, 93));\n    console.assert(f_40(50, 2) === 10, 'Expected 10, got ' + f_40(50, 2));\n    console.assert(f_40(50, 3) === 5, 'Expected 5, got ' + f_40(50, 3));\n    console.assert(f_40(2, 3) === 1, 'Expected 1, got ' + f_40(2, 3));\n};\ntestf_40();", "entry_point": "f_40", "signature": "function f_40(n, k)", "docstring": {"en": "Given two positive integers n and k, find the number of positive integers x,\nwhere 1 <= x <= n, that can be expressed as x = a^b with a and b being positive integers\nand b >= k. Different legal representations of the same number are counted only once.\nExample:\n  f_40(99, 1) returns 99\n", "sq": "Duke pasur dy numra të plotë pozitivë n dhe k, gjeni numrin e numrave të plotë pozitivë x,\nku 1 <= x <= n, që mund të shprehen si x = a^b me a dhe b që janë numra të plotë pozitivë\ndhe b >= k. Përfaqësimet e ndryshme të ligjshme të të njëjtit numër numërohen vetëm një herë.\nShembull:\n  f_40(99, 1) kthen 99", "hy": "Տրված է երկու դրական ամբողջ թիվ n և k, գտնել դրական ամբողջ թվերի x քանակը, որտեղ 1 <= x <= n, որոնք կարող են արտահայտվել որպես x = a^b, որտեղ a և b դրական ամբողջ թվեր են և b >= k: Նույն թվի տարբեր թույլատրելի ներկայացումները հաշվում են միայն մեկ անգամ:\nՕրինակ:\n  f_40(99, 1) վերադարձնում է 99", "bn": "দুটি ধনাত্মক পূর্ণসংখ্যা n এবং k দেওয়া আছে, ধনাত্মক পূর্ণসংখ্যা x-এর সংখ্যা খুঁজে বের করুন, যেখানে 1 <= x <= n, যা x = a^b হিসাবে প্রকাশ করা যায় এবং a এবং b ধনাত্মক পূর্ণসংখ্যা এবং b >= k। একই সংখ্যার বিভিন্ন বৈধ উপস্থাপনাকে শুধুমাত্র একবার গণনা করা হয়।\n\nউদাহরণ:\n  f_40(99, 1) 99 প্রদান করে", "bg": "Дадени са две положителни цели числа n и k, намерете броя на положителните цели числа x, където 1 <= x <= n, които могат да бъдат изразени като x = a^b с a и b, които са положителни цели числа и b >= k. Различните легални представяния на едно и също число се броят само веднъж.\nПример:\n  f_40(99, 1) връща 99", "zh": "给定两个正整数 n 和 k，找出有多少个正整数 x，其中 1 <= x <= n，可以表示为 x = a^b，其中 a 和 b 是正整数且 b >= k。相同数字的不同合法表示仅计数一次。\n\n示例：\n  f_40(99, 1) 返回 99", "fr": "Étant donné deux entiers positifs n et k, trouvez le nombre d'entiers positifs x,\noù 1 <= x <= n, qui peuvent être exprimés comme x = a^b avec a et b étant des entiers positifs\net b >= k. Différentes représentations légales du même nombre sont comptées une seule fois.\nExemple :\n  f_40(99, 1) renvoie 99", "de": "Gegeben zwei positive ganze Zahlen n und k, finde die Anzahl der positiven ganzen Zahlen x, wobei 1 <= x <= n, die als x = a^b ausgedrückt werden können, wobei a und b positive ganze Zahlen sind und b >= k. Verschiedene zulässige Darstellungen derselben Zahl werden nur einmal gezählt.\nBeispiel:\n  f_40(99, 1) gibt 99 zurück", "ha": "An ba da lambobi masu kyau guda biyu n da k, nemo adadin lambobi masu kyau x, inda 1 <= x <= n, wanda za a iya bayyana shi a matsayin x = a^b tare da a da b suna zama lambobi masu kyau kuma b >= k. Ana kirga daban-daban halattattun wakilci na lamba ɗaya sau ɗaya kawai.\n\nMisali:\n  f_40(99, 1) returns 99", "hi": "दो सकारात्मक पूर्णांक n और k दिए गए हैं, उन सकारात्मक पूर्णांकों x की संख्या ज्ञात करें, जहाँ 1 <= x <= n, जिन्हें x = a^b के रूप में व्यक्त किया जा सकता है, जहाँ a और b सकारात्मक पूर्णांक हैं और b >= k है। एक ही संख्या के विभिन्न वैध अभ्यावेदन को केवल एक बार गिना जाता है।\nउदाहरण:\n  f_40(99, 1) 99 लौटाता है", "hu": "Két pozitív egész szám, n és k esetén, találjuk meg azon pozitív egész számok x számát, ahol 1 <= x <= n, és amelyek kifejezhetők x = a^b formában, ahol a és b pozitív egész számok és b >= k. Ugyanazon szám különböző érvényes ábrázolásai csak egyszer számítanak.\n\nPélda:\n  f_40(99, 1) visszaadja 99", "es": "Dado dos enteros positivos n y k, encuentra el número de enteros positivos x, donde 1 <= x <= n, que se pueden expresar como x = a^b con a y b siendo enteros positivos y b >= k. Diferentes representaciones legales del mismo número se cuentan solo una vez.\nEjemplo:\n  f_40(99, 1) devuelve 99", "arb": "بالنظر إلى عددين صحيحين موجبين n و k، ابحث عن عدد الأعداد الصحيحة الموجبة x، حيث 1 <= x <= n، والتي يمكن التعبير عنها كـ x = a^b مع كون a و b أعدادًا صحيحة موجبة و b >= k. يتم احتساب التمثيلات القانونية المختلفة لنفس الرقم مرة واحدة فقط.\n\nمثال:\n  f_40(99, 1) يعيد 99", "sw": "Kwa kupewa nambari mbili nzima chanya n na k, pata idadi ya nambari chanya x,\nambapo 1 <= x <= n, ambazo zinaweza kuonyeshwa kama x = a^b huku a na b wakiwa nambari nzima chanya\nna b >= k. Uwakilishi tofauti halali wa nambari ile ile unahesabiwa mara moja tu.\nMfano:\n  f_40(99, 1) inarudisha 99", "tr": "İki pozitif tamsayı n ve k verildiğinde, 1 <= x <= n aralığında, x = a^b şeklinde ifade edilebilen pozitif tamsayı x sayısını bulun, burada a ve b pozitif tamsayılardır ve b >= k. Aynı sayının farklı yasal gösterimleri yalnızca bir kez sayılır.\nÖrnek:\n  f_40(99, 1) 99 döndürür", "vi": "Cho hai số nguyên dương n và k, tìm số lượng số nguyên dương x, với 1 <= x <= n, có thể được biểu diễn dưới dạng x = a^b với a và b là các số nguyên dương và b >= k. Các cách biểu diễn hợp lệ khác nhau của cùng một số chỉ được đếm một lần.\n\nVí dụ:\n  f_40(99, 1) trả về 99", "id": "Diberikan dua bilangan bulat positif n dan k, temukan jumlah bilangan bulat positif x, di mana 1 <= x <= n, yang dapat dinyatakan sebagai x = a^b dengan a dan b adalah bilangan bulat positif dan b >= k. Representasi legal yang berbeda dari bilangan yang sama hanya dihitung sekali.\n\nContoh:\n  f_40(99, 1) mengembalikan 99", "ja": "2つの正の整数 n と k が与えられたとき、1 <= x <= n の範囲で、x = a^b と表現できる正の整数 x の数を求めます。ただし、a と b は正の整数であり、b >= k です。同じ数の異なる合法的な表現は一度だけカウントされます。\n\n例:\n  f_40(99, 1) は 99 を返します。", "ko": "두 개의 양의 정수 n과 k가 주어졌을 때, 1 <= x <= n을 만족하는 양의 정수 x의 개수를 찾으십시오. 여기서 x = a^b로 표현될 수 있으며, a와 b는 양의 정수이고 b >= k입니다. 같은 숫자의 서로 다른 합법적인 표현은 한 번만 계산됩니다.\n예:\n  f_40(99, 1) returns 99", "ml": "രണ്ട് പോസിറ്റീവ് പൂർണ്ണസംഖ്യകൾ n, k എന്നിവ നൽകിയാൽ, 1 <= x <= n എന്ന നിലയിൽ,\n * x = a^b എന്ന രൂപത്തിൽ പ്രകടിപ്പിക്കാവുന്ന പോസിറ്റീവ് പൂർണ്ണസംഖ്യകളുടെ എണ്ണം കണ്ടെത്തുക,\n * ഇവിടെ a, b പോസിറ്റീവ് പൂർണ്ണസംഖ്യകളാണ്, b >= k. \n * ഒരേ സംഖ്യയുടെ വ്യത്യസ്തമായ നിയമാനുസൃത പ്രതിനിധാനങ്ങൾ ഒരിക്കൽ മാത്രം എണ്ണപ്പെടും.\n\nMalayalam Translation:\n\nരണ്ട് പോസിറ്റീവ് പൂർണ്ണസംഖ്യകൾ n, k എന്നിവ നൽകിയാൽ, 1 <= x <= n എന്ന വ്യവസ്ഥയിൽ x = a^b എന്ന രൂപത്തിൽ രേഖപ്പെടുത്താവുന്ന പോസിറ്റീവ് പൂർണ്ണസംഖ്യകളുടെ എണ്ണം കണ്ടെത്തുക. a, b എന്നിവ പോസിറ്റീവ് പൂർണ്ണസംഖ്യകളായിരിക്കണം, കൂടാതെ b >= k ആയിരിക്കണം. ഒരേ സംഖ്യയുടെ വ്യത്യസ്തമായ നിയമപരമായ പ്രതിനിധാനങ്ങൾ ഒരിക്കൽ മാത്രമേ എണ്ണപ്പെടൂ.\n\nExample:\n  f_40(99, 1) returns 99", "fa": "با توجه به دو عدد صحیح مثبت n و k، تعداد اعداد صحیح مثبت x را پیدا کنید،\nکه در آن 1 <= x <= n، که می‌توان به صورت x = a^b با a و b به عنوان اعداد صحیح مثبت\nو b >= k بیان کرد. نمایش‌های قانونی مختلف از یک عدد مشابه فقط یک بار شمارش می‌شوند.\nمثال:\n  f_40(99, 1) مقدار 99 را برمی‌گرداند."}}
{"task_id": "JavaScript/41", "prompt": {"en": "/**\n * Given three integers n, m, and k, find the number of sequences consisting of n '(' and m ')', \n * such that the longest balanced subsequence is of length 2 * k. The result should be calculated \n * modulo 1,000,000,007 (10^9 + 7).\n * \n * For example:\n *     f_41(2, 2, 2)\n *     // returns 2\n */\nfunction f_41(n, m, k)", "sq": "/**\n * Duke pasur tre numra të plotë n, m, dhe k, gjeni numrin e sekuencave që përbëhen nga n '(' dhe m ')',\n * të tilla që nënsekuenca më e gjatë e balancuar është me gjatësi 2 * k. Rezultati duhet të llogaritet\n * modulo 1,000,000,007 (10^9 + 7).\n * \n * Për shembull:\n *     f_41(2, 2, 2)\n *     // kthen 2\n */\nfunction f_41(n, m, k)", "hy": "/**\n * Տրված է երեք ամբողջ թիվ՝ n, m և k, գտնել հաջորդականությունների քանակը, որոնք կազմված են n '(' և m ')' նշաններից,\n * այնպես, որ ամենաերկար հավասարակշռված ենթահաջորդականությունը լինի 2 * k երկարությամբ։ Արդյունքը պետք է հաշվարկվի\n * 1,000,000,007 (10^9 + 7) մոդուլով։\n * \n * Օրինակ՝\n *     f_41(2, 2, 2)\n *     // վերադարձնում է 2\n */\nfunction f_41(n, m, k)", "bn": "/**\n * তিনটি পূর্ণসংখ্যা n, m, এবং k দেওয়া হলে, n '(' এবং m ')' নিয়ে গঠিত সিকোয়েন্সের সংখ্যা খুঁজে বের করুন, \n * যাতে দীর্ঘতম ব্যালেন্সড উপসিকোয়েন্সের দৈর্ঘ্য 2 * k হয়। ফলাফলটি 1,000,000,007 (10^9 + 7) দ্বারা \n * মডুলো গণনা করা উচিত।\n * \n * উদাহরণস্বরূপ:\n *     f_41(2, 2, 2)\n *     // 2 রিটার্ন করে\n */\nfunction f_41(n, m, k)", "bg": "/**\n * Дадени са три цели числа n, m и k, намерете броя на последователностите, състоящи се от n '(' и m ')',\n * такива, че най-дългата балансирана подредба е с дължина 2 * k. Резултатът трябва да бъде изчислен\n * по модул 1,000,000,007 (10^9 + 7).\n * \n * Например:\n *     f_41(2, 2, 2)\n *     // връща 2\n */\nfunction f_41(n, m, k)", "zh": "/**\n * 给定三个整数 n, m 和 k，找出由 n 个 '(' 和 m 个 ')' 组成的序列的数量，\n * 使得最长的平衡子序列的长度为 2 * k。结果应以 1,000,000,007 (10^9 + 7) 为模进行计算。\n * \n * 例如:\n *     f_41(2, 2, 2)\n *     // 返回 2\n */\nfunction f_41(n, m, k)", "fr": "/**\n * Étant donné trois entiers n, m, et k, trouvez le nombre de séquences consistant en n '(' et m ')', \n * telles que la plus longue sous-séquence équilibrée soit de longueur 2 * k. Le résultat doit être calculé \n * modulo 1,000,000,007 (10^9 + 7).\n * \n * Par exemple :\n *     f_41(2, 2, 2)\n *     // retourne 2\n */\nfunction f_41(n, m, k)", "de": "/**\n * Gegeben sind drei ganze Zahlen n, m und k. Finde die Anzahl der Sequenzen, die aus n '(' und m ')' bestehen,\n * so dass die längste ausgeglichene Teilsequenz die Länge 2 * k hat. Das Ergebnis sollte modulo 1.000.000.007 (10^9 + 7) berechnet werden.\n * \n * Zum Beispiel:\n *     f_41(2, 2, 2)\n *     // gibt 2 zurück\n */\nfunction f_41(n, m, k)", "ha": "/**\n * An ba da lambobi guda uku n, m, da k, nemo adadin jerin lambobi da suka ƙunshi n '(' da m ')', \n * ta yadda mafi tsawon jeri mai daidaito yana da tsawon 2 * k. Dole ne a ƙididdige sakamakon \n * modulo 1,000,000,007 (10^9 + 7).\n * \n * Alal misali:\n *     f_41(2, 2, 2)\n *     // yana dawowa 2\n */\nfunction f_41(n, m, k)", "hi": "/**\n * तीन पूर्णांक n, m, और k दिए गए हैं, उन अनुक्रमों की संख्या खोजें जो n '(' और m ')' से बने हैं,\n * ताकि सबसे लंबा संतुलित उप-अनुक्रम की लंबाई 2 * k हो। परिणाम को 1,000,000,007 (10^9 + 7) से \n * मापांकित किया जाना चाहिए।\n * \n * उदाहरण के लिए:\n *     f_41(2, 2, 2)\n *     // 2 लौटाता है\n */\nfunction f_41(n, m, k)", "hu": "/**\n * Adott három egész szám: n, m és k, keresse meg azon sorozatok számát, amelyek n '(' és m ')' \n * karakterből állnak, úgy, hogy a leghosszabb kiegyensúlyozott részszekvencia hossza 2 * k. \n * Az eredményt 1,000,000,007 (10^9 + 7) modulo szerint kell kiszámítani.\n * \n * Például:\n *     f_41(2, 2, 2)\n *     // visszaadja: 2\n */\nfunction f_41(n, m, k)", "es": "/**\n * Dados tres enteros n, m, y k, encuentra el número de secuencias que consisten en n '(' y m ')',\n * tal que la subsecuencia balanceada más larga tenga una longitud de 2 * k. El resultado debe ser calculado\n * módulo 1,000,000,007 (10^9 + 7).\n * \n * Por ejemplo:\n *     f_41(2, 2, 2)\n *     // devuelve 2\n */\nfunction f_41(n, m, k)", "arb": "/**\n * بالنظر إلى ثلاثة أعداد صحيحة n، m، و k، جد عدد التتابعات التي تتكون من n '(' و m ')',\n * بحيث يكون أطول تتابع متوازن بطول 2 * k. يجب حساب النتيجة بتطبيق باقي القسمة 1,000,000,007 (10^9 + 7).\n * \n * على سبيل المثال:\n *     f_41(2, 2, 2)\n *     // يعيد 2\n */\nfunction f_41(n, m, k)", "sw": "/**\n * Ukipewa nambari tatu n, m, na k, tafuta idadi ya mlolongo unaojumuisha n '(' na m ')', \n * kiasi kwamba mlolongo mrefu zaidi ulio sawa ni wa urefu wa 2 * k. Matokeo yanapaswa kuhesabiwa \n * kwa modulo 1,000,000,007 (10^9 + 7).\n * \n * Kwa mfano:\n *     f_41(2, 2, 2)\n *     // inarudisha 2\n */\nfunction f_41(n, m, k)", "tr": "/**\n * Üç tamsayı n, m ve k verildiğinde, n '(' ve m ')' içeren dizilerin sayısını bulun, \n * öyle ki en uzun dengeli alt dizi uzunluğu 2 * k olur. Sonuç, 1,000,000,007 (10^9 + 7) \n * modunda hesaplanmalıdır.\n * \n * Örneğin:\n *     f_41(2, 2, 2)\n *     // 2 döndürür\n */\nfunction f_41(n, m, k)", "vi": "/**\n * Cho ba số nguyên n, m, và k, tìm số lượng dãy bao gồm n '(' và m ')', \n * sao cho dãy con cân bằng dài nhất có độ dài 2 * k. Kết quả cần được tính \n * theo modulo 1,000,000,007 (10^9 + 7).\n * \n * Ví dụ:\n *     f_41(2, 2, 2)\n *     // trả về 2\n */\nfunction f_41(n, m, k)", "id": "/**\n * Diberikan tiga bilangan bulat n, m, dan k, temukan jumlah urutan yang terdiri dari n '(' dan m ')',\n * sedemikian rupa sehingga subsekuens seimbang terpanjang adalah dengan panjang 2 * k. Hasilnya harus dihitung\n * modulo 1,000,000,007 (10^9 + 7).\n * \n * Sebagai contoh:\n *     f_41(2, 2, 2)\n *     // mengembalikan 2\n */\nfunction f_41(n, m, k)", "ja": "/**\n * 3つの整数 n, m, k が与えられたとき、n 個の '(' と m 個の ')' からなるシーケンスのうち、\n * 最長のバランスの取れた部分シーケンスの長さが 2 * k であるものの数を求めます。結果は\n * 1,000,000,007 (10^9 + 7) での剰余として計算されるべきです。\n * \n * 例えば:\n *     f_41(2, 2, 2)\n *     // 2 を返します\n */\nfunction f_41(n, m, k)", "ko": "/**\n * 세 개의 정수 n, m, k가 주어졌을 때, n개의 '('와 m개의 ')'로 구성된 시퀀스 중에서 \n * 가장 긴 균형 잡힌 부분 시퀀스의 길이가 2 * k인 경우의 수를 찾으시오. 결과는 \n * 1,000,000,007 (10^9 + 7)로 나눈 나머지로 계산되어야 합니다.\n * \n * 예를 들어:\n *     f_41(2, 2, 2)\n *     // 2를 반환합니다\n */\nfunction f_41(n, m, k)", "ml": "/**\n * മൂന്നു പൂർണ്ണസംഖ്യകൾ n, m, k നൽകിയാൽ, n '('  മും m ')'  മും അടങ്ങിയ അനുക്രമങ്ങളുടെ എണ്ണം കണ്ടുപിടിക്കുക, \n *  ഏറ്റവും നീളമുള്ള ബാലൻസ്ഡ് ഉപമാലികയുടെ നീളം 2 * k ആയിരിക്കണം. ഫലം 1,000,000,007 (10^9 + 7) കൊണ്ട് \n *  മോഡുലോ കണക്കാക്കണം.\n * \n * ഉദാഹരണത്തിന്:\n *     f_41(2, 2, 2)\n *     // 2 തിരിച്ചു നൽകുന്നു\n */\nfunction f_41(n, m, k)", "fa": "/**\n * با توجه به سه عدد صحیح n، m و k، تعداد دنباله‌هایی را پیدا کنید که از n '(' و m ')' تشکیل شده‌اند،\n * به طوری که طولانی‌ترین زیر دنباله متعادل دارای طول 2 * k باشد. نتیجه باید به پیمانه 1,000,000,007 (10^9 + 7) محاسبه شود.\n * \n * برای مثال:\n *     f_41(2, 2, 2)\n *     // 2 را برمی‌گرداند\n */\nfunction f_41(n, m, k)"}, "canonical_solution": "{\n    const P = 1e9 + 7;\n    const C = Array.from({ length: 4003 }, () => Array(4003).fill(0));\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] === 0) {\n        for (let i = 0; i <= 4002; i++) C[i][0] = 1;\n        for (let i = 1; i <= 4002; i++)\n            for (let j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    \n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}", "instruction": {"en": "Write a JavaScript function `function f_41(n, m, k)` to solve the following problem:\nGiven three integers n, m, and k, find the number of sequences consisting of n '(' and m ')', such that the longest balanced subsequence is of length 2 * k. The result should be calculated modulo 1,000,000,007 (10^9 + 7).\n\nFor example:\n    f_41(2, 2, 2)\n    // returns 2", "sq": "Shkruani një funksion JavaScript `function f_41(n, m, k)` për të zgjidhur problemin e mëposhtëm:  \nDuke pasur tre numra të plotë n, m, dhe k, gjeni numrin e sekuencave që përbëhen nga n '(' dhe m ')', të tilla që nënsekuenca më e gjatë e balancuar të jetë me gjatësi 2 * k. Rezultati duhet të llogaritet modulo 1,000,000,007 (10^9 + 7).\n\nPër shembull:\n    f_41(2, 2, 2)\n    // kthen 2", "hy": "Գրեք JavaScript ֆունկցիա `function f_41(n, m, k)` հետևյալ խնդիրը լուծելու համար:\nԵրեք ամբողջ թիվ n, m և k տրված են, գտնել n '(' և m ')' բաղկացած հաջորդականությունների քանակը, այնպես, որ ամենաերկար հավասարակշռված ենթահաջորդականությունը լինի 2 * k երկարությամբ: Արդյունքը պետք է հաշվարկվի 1,000,000,007 (10^9 + 7) մոդուլով:\n\nՕրինակ:\n    f_41(2, 2, 2)\n    // վերադարձնում է 2", "bn": "একটি জাভাস্ক্রিপ্ট ফাংশন `function f_41(n, m, k)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nতিনটি পূর্ণসংখ্যা n, m, এবং k দেওয়া আছে, n '(' এবং m ')' নিয়ে গঠিত সিকোয়েন্সের সংখ্যা খুঁজে বের করুন, যাতে দীর্ঘতম ব্যালেন্সড সাবসিকোয়েন্সের দৈর্ঘ্য 2 * k হয়। ফলাফলটি 1,000,000,007 (10^9 + 7) দ্বারা মডুলো গণনা করা উচিত।\n\nউদাহরণস্বরূপ:\n    f_41(2, 2, 2)\n    // 2 ফেরত দেয়", "bg": "Напишете JavaScript функция `function f_41(n, m, k)` за решаване на следния проблем:  \nДадени са три цели числа n, m и k, намерете броя на последователностите, състоящи се от n '(' и m ')', така че най-дългата балансирана подредба да е с дължина 2 * k. Резултатът трябва да се изчисли по модул 1,000,000,007 (10^9 + 7).\n\nНапример:\n    f_41(2, 2, 2)\n    // връща 2", "zh": "编写一个 JavaScript 函数 `function f_41(n, m, k)` 来解决以下问题：  \n给定三个整数 n, m 和 k，找出由 n 个 '(' 和 m 个 ')' 组成的序列的数量，使得最长的平衡子序列的长度为 2 * k。结果应计算为对 1,000,000,007 (10^9 + 7) 取模。\n\n例如：  \n    f_41(2, 2, 2)  \n    // 返回 2", "fr": "Écrire une fonction JavaScript `function f_41(n, m, k)` pour résoudre le problème suivant :  \nÉtant donné trois entiers n, m, et k, trouver le nombre de séquences constituées de n '(' et m ')', telles que la plus longue sous-séquence équilibrée soit de longueur 2 * k. Le résultat doit être calculé modulo 1,000,000,007 (10^9 + 7).\n\nPar exemple :\n    f_41(2, 2, 2)\n    // retourne 2", "de": "Schreiben Sie eine JavaScript-Funktion `function f_41(n, m, k)`, um das folgende Problem zu lösen:  \nGegeben sind drei ganze Zahlen n, m und k. Finden Sie die Anzahl der Sequenzen, die aus n '(' und m ')' bestehen, sodass die längste ausgeglichene Teilsequenz die Länge 2 * k hat. Das Ergebnis sollte modulo 1.000.000.007 (10^9 + 7) berechnet werden.\n\nZum Beispiel:\n    f_41(2, 2, 2)\n    // gibt 2 zurück", "ha": "Rubuta wani aikin JavaScript `function f_41(n, m, k)` don warware matsalar mai zuwa:\nAn ba da lambobi guda uku n, m, da k, nemo yawan jerin abubuwa da suka ƙunshi n '(' da m ')', ta yadda mafi tsawon jerin da aka daidaita yana da tsawon 2 * k. Dole ne a ƙididdige sakamakon modulo 1,000,000,007 (10^9 + 7).\n\nAlal misali:\n    f_41(2, 2, 2)\n    // yana dawowa 2", "hi": "JavaScript फ़ंक्शन `function f_41(n, m, k)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए तीन पूर्णांक n, m, और k के लिए, उन अनुक्रमों की संख्या खोजें जो n '(' और m ')' से बने होते हैं, ताकि सबसे लंबा संतुलित उप-अनुक्रम की लंबाई 2 * k हो। परिणाम को 1,000,000,007 (10^9 + 7) के मापांक में गणना किया जाना चाहिए।\n\nउदाहरण के लिए:\n    f_41(2, 2, 2)\n    // 2 लौटाता है", "hu": "Írj egy JavaScript függvényt `function f_41(n, m, k)` a következő probléma megoldására:\nAdott három egész szám: n, m és k. Találd meg azon sorozatok számát, amelyek n '(' és m ')' karakterből állnak, úgy hogy a leghosszabb kiegyensúlyozott részsorozat hossza 2 * k. Az eredményt 1,000,000,007 (10^9 + 7) modulo szerint kell kiszámítani.\n\nPéldául:\n    f_41(2, 2, 2)\n    // 2-t ad vissza", "es": "Escribe una función de JavaScript `function f_41(n, m, k)` para resolver el siguiente problema:\nDado tres enteros n, m, y k, encuentra el número de secuencias que consisten en n '(' y m ')', tal que la subsecuencia balanceada más larga tiene una longitud de 2 * k. El resultado debe ser calculado módulo 1,000,000,007 (10^9 + 7).\n\nPor ejemplo:\n    f_41(2, 2, 2)\n    // devuelve 2", "arb": "اكتب دالة JavaScript `function f_41(n, m, k)` لحل المشكلة التالية:\nمعطى ثلاثة أعداد صحيحة n، m، و k، ابحث عن عدد التسلسلات المكونة من n '(' و m ')', بحيث يكون أطول تسلسل متوازن بطول 2 * k. يجب حساب النتيجة بتطبيق باقي القسمة 1,000,000,007 (10^9 + 7).\n\nعلى سبيل المثال:\n    f_41(2, 2, 2)\n    // يعيد 2", "sw": "Andika kazi ya JavaScript `function f_41(n, m, k)` kutatua tatizo lifuatalo:\nUkipiwa nambari tatu n, m, na k, tafuta idadi ya mlolongo unaojumuisha n '(' na m ')', kiasi kwamba mlolongo mrefu zaidi ulio sawa ni wa urefu wa 2 * k. Matokeo yanapaswa kuhesabiwa kwa modulo 1,000,000,007 (10^9 + 7).\n\nKwa mfano:\n    f_41(2, 2, 2)\n    // inarudisha 2", "tr": "Bir JavaScript fonksiyonu `function f_41(n, m, k)` yazın ve aşağıdaki problemi çözün:\nVerilen üç tamsayı n, m ve k için, n '(' ve m ')' karakterlerinden oluşan dizilerin sayısını bulun, öyle ki en uzun dengeli alt dizi uzunluğu 2 * k olsun. Sonuç 1,000,000,007 (10^9 + 7) modunda hesaplanmalıdır.\n\nÖrneğin:\n    f_41(2, 2, 2)\n    // 2 döndürür", "vi": "Viết một hàm JavaScript `function f_41(n, m, k)` để giải quyết vấn đề sau:\nCho ba số nguyên n, m và k, tìm số lượng dãy gồm n '(' và m ')', sao cho dãy con cân bằng dài nhất có độ dài 2 * k. Kết quả nên được tính theo modulo 1,000,000,007 (10^9 + 7).\n\nVí dụ:\n    f_41(2, 2, 2)\n    // trả về 2", "id": "Tulis sebuah fungsi JavaScript `function f_41(n, m, k)` untuk menyelesaikan masalah berikut:  \nDiberikan tiga bilangan bulat n, m, dan k, temukan jumlah urutan yang terdiri dari n '(' dan m ')', sehingga subsekuens seimbang terpanjang memiliki panjang 2 * k. Hasilnya harus dihitung dengan modulo 1,000,000,007 (10^9 + 7).\n\nSebagai contoh:\n    f_41(2, 2, 2)\n    // mengembalikan 2", "ja": "JavaScript関数 `function f_41(n, m, k)` を作成して、次の問題を解決してください:\n3つの整数 n, m, k が与えられたとき、n 個の '(' と m 個の ')' からなるシーケンスのうち、最も長いバランスの取れた部分シーケンスが長さ 2 * k であるものの数を求めます。結果は1,000,000,007 (10^9 + 7) で計算されたものとします。\n\n例えば:\n    f_41(2, 2, 2)\n    // 2 を返します", "ko": "JavaScript 함수 `function f_41(n, m, k)`를 작성하여 다음 문제를 해결하십시오:\n세 개의 정수 n, m, k가 주어졌을 때, n개의 '('와 m개의 ')'로 구성된 시퀀스 중 가장 긴 균형 잡힌 부분 시퀀스의 길이가 2 * k인 경우의 수를 찾으십시오. 결과는 1,000,000,007 (10^9 + 7)로 나눈 나머지로 계산되어야 합니다.\n\n예를 들어:\n    f_41(2, 2, 2)\n    // 2를 반환합니다.", "ml": "`function f_41(n, m, k)` എന്ന ജാവാസ്ക്രിപ്റ്റ് ഫംഗ്ഷൻ എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nമൂന്ന് പൂർണ്ണസംഖ്യകൾ n, m, k നൽകിയാൽ, n '(' and m ')' അടങ്ങിയ സീക്വൻസുകളുടെ എണ്ണം കണ്ടെത്തുക, അങ്ങനെ ഏറ്റവും നീളമുള്ള ബാലൻസ്ഡ് സബ്‌സീക്വൻസ് 2 * k നീളമുള്ളതായിരിക്കും. ഫലം 1,000,000,007 (10^9 + 7) മൂല്യത്തിൽ മോഡുലോ ആയി കണക്കാക്കണം.\n\nഉദാഹരണത്തിന്:\n    f_41(2, 2, 2)\n    // 2 മടക്കുന്നു", "fa": "یک تابع جاوااسکریپت `function f_41(n, m, k)` بنویسید تا مسئله زیر را حل کند:\nبا توجه به سه عدد صحیح n، m و k، تعداد دنباله‌هایی که از n '(' و m ')' تشکیل شده‌اند را بیابید، به‌طوری‌که طولانی‌ترین زیر دنباله متوازن دارای طول 2 * k باشد. نتیجه باید به‌صورت پیمانه‌ای با 1,000,000,007 (10^9 + 7) محاسبه شود.\n\nبرای مثال:\n    f_41(2, 2, 2)\n    // 2 را برمی‌گرداند"}, "level": "hard", "test": "(() => {\n    console.assert(f_41(2, 2, 2) === 2, 'Test case 1 failed');\n    console.assert(f_41(3, 2, 3) === 0, 'Test case 2 failed');\n    console.assert(f_41(3, 2, 1) === 4, 'Test case 3 failed');\n    console.assert(f_41(4, 3, 2) === 14, 'Test case 4 failed');\n    console.assert(f_41(5, 5, 2) === 35, 'Test case 5 failed');\n    console.assert(f_41(6, 1, 1) === 6, 'Test case 6 failed');\n    console.assert(f_41(1, 6, 1) === 6, 'Test case 7 failed');\n    console.assert(f_41(7, 2, 2) === 27, 'Test case 8 failed');\n    console.assert(f_41(8, 3, 3) === 110, 'Test case 9 failed');\n    console.assert(f_41(10, 10, 5) === 10659, 'Test case 10 failed');\n    console.assert(f_41(20, 20, 10) === 574221648, 'Test case 11 failed');\n    console.assert(f_41(2000, 2000, 1000) === 854104531, 'Test case 12 failed');\n    console.assert(f_41(2000, 1999, 1000) === 334874485, 'Test case 13 failed');\n    console.assert(f_41(2000, 2000, 1999) === 259428024, 'Test case 14 failed');\n})();", "entry_point": "f_41", "signature": "function f_41(n, m, k)", "docstring": {"en": "Given three integers n, m, and k, find the number of sequences consisting of n '(' and m ')', such that the longest balanced subsequence is of length 2 * k. The result should be calculated modulo 1,000,000,007 (10^9 + 7).\n\nFor example:\n    f_41(2, 2, 2)\n    // returns 2", "sq": "Duke pasur tre numra të plotë n, m, dhe k, gjeni numrin e sekuencave që përbëhen nga n '(' dhe m ')', të tilla që nënpasuesi më i gjatë i balancuar është me gjatësi 2 * k. Rezultati duhet të llogaritet modulo 1,000,000,007 (10^9 + 7).\n\nPër shembull:\n    f_41(2, 2, 2)\n    // kthen 2", "hy": "Երեք ամբողջ թիվ n, m և k ունենալով, գտնել հաջորդականությունների քանակը, որոնք բաղկացած են n '(' և m ')', այնպես, որ ամենաերկար հավասարակշռված ենթահաջորդականությունը լինի 2 * k երկարությամբ: Արդյունքը պետք է հաշվարկվի 1,000,000,007 (10^9 + 7) մոդուլով:\n\nՕրինակ:\n    f_41(2, 2, 2)\n    // վերադարձնում է 2", "bn": "তিনটি পূর্ণসংখ্যা n, m, এবং k দেওয়া আছে, n টি '(' এবং m টি ')' নিয়ে গঠিত সিকোয়েন্সের সংখ্যা খুঁজে বের করুন, যাতে দীর্ঘতম ব্যালান্সড উপসিকোয়েন্সের দৈর্ঘ্য 2 * k হয়। ফলাফলটি 1,000,000,007 (10^9 + 7) দ্বারা মডুলো হিসাব করা উচিত।\n\nউদাহরণস্বরূপ:\n    f_41(2, 2, 2)\n    // 2 প্রদান করে", "bg": "Дадени са три цели числа n, m и k, намерете броя на последователностите, състоящи се от n '(' и m ')', така че най-дългата балансирана подредена последователност да е с дължина 2 * k. Резултатът трябва да бъде изчислен по модул 1,000,000,007 (10^9 + 7).\n\nНапример:\n    f_41(2, 2, 2)\n    // връща 2", "zh": "给定三个整数 n, m 和 k，找出由 n 个 '(' 和 m 个 ')' 组成的序列的数量，使得最长的平衡子序列的长度为 2 * k。结果应以 1,000,000,007 (10^9 + 7) 为模进行计算。\n\n例如：\n    f_41(2, 2, 2)\n    // 返回 2", "fr": "Étant donnés trois entiers n, m et k, trouvez le nombre de séquences consistant en n '(' et m ')', de telle sorte que la plus longue sous-séquence équilibrée soit de longueur 2 * k. Le résultat doit être calculé modulo 1,000,000,007 (10^9 + 7).\n\nPar exemple :\n    f_41(2, 2, 2)\n    // renvoie 2", "de": "Gegeben drei ganze Zahlen n, m und k, finde die Anzahl der Sequenzen, die aus n '(' und m ')' bestehen, so dass die längste ausgeglichene Teilsequenz die Länge 2 * k hat. Das Ergebnis sollte modulo 1.000.000.007 (10^9 + 7) berechnet werden.\n\nZum Beispiel:\n    f_41(2, 2, 2)\n    // gibt 2 zurück", "ha": "An ba da lambobi guda uku n, m, da k, nemo adadin jerin lambobi da suka ƙunshi n '(' da m ')', ta yadda mafi tsawon subsequence mai daidaituwa yana da tsawon 2 * k. A sakamakon ya kamata a ƙididdige shi modulo 1,000,000,007 (10^9 + 7).\n\nMisali:\n    f_41(2, 2, 2)\n    // ya dawo da 2", "hi": "तीन पूर्णांक n, m, और k दिए गए हैं, उन अनुक्रमों की संख्या खोजें जो n '(' और m ')' से मिलकर बने होते हैं, ताकि सबसे लंबा संतुलित उप-अनुक्रम 2 * k लंबाई का हो। परिणाम को 1,000,000,007 (10^9 + 7) के मापांक में गणना किया जाना चाहिए।\n\nउदाहरण के लिए:\n    f_41(2, 2, 2)\n    // 2 लौटाता है", "hu": "Három egész szám, n, m és k megadása esetén találja meg az n '(' és m ')' karakterekből álló sorozatok számát úgy, hogy a leghosszabb kiegyensúlyozott részszekvencia hossza 2 * k legyen. Az eredményt 1,000,000,007 (10^9 + 7) modulo szerint kell kiszámítani.\n\nPéldául:\n    f_41(2, 2, 2)\n    // visszatér 2", "es": "Dado tres enteros n, m y k, encuentra el número de secuencias que consisten en n '(' y m ')', de tal manera que la subsecuencia balanceada más larga tenga una longitud de 2 * k. El resultado debe ser calculado módulo 1,000,000,007 (10^9 + 7).\n\nPor ejemplo:\n    f_41(2, 2, 2)\n    // devuelve 2", "arb": "معطى ثلاثة أعداد صحيحة n و m و k، ابحث عن عدد التتابعات المكونة من n '(' و m ')', بحيث يكون أطول تتابع متوازن هو بطول 2 * k. يجب حساب النتيجة بتطبيق باقي القسمة على 1,000,000,007 (10^9 + 7).\n\nعلى سبيل المثال:\n    f_41(2, 2, 2)\n    // يعيد 2", "sw": "Kutolewa nambari tatu za mzima n, m, na k, pata idadi ya misururu inayojumuisha n '(' na m ')', kiasi kwamba mfuatano mrefu zaidi wenye usawa una urefu wa 2 * k. Matokeo yanapaswa kuhesabiwa modulo 1,000,000,007 (10^9 + 7).\n\nKwa mfano:\n    f_41(2, 2, 2)\n    // inarudisha 2", "tr": "Verilen üç tamsayı n, m ve k için, n '(' ve m ')' karakterlerinden oluşan dizilerin sayısını bulun, öyle ki en uzun dengeli alt dizi uzunluğu 2 * k olsun. Sonuç 1,000,000,007 (10^9 + 7) modunda hesaplanmalıdır.\n\nÖrneğin:\n    f_41(2, 2, 2)\n    // 2 döndürür", "vi": "Cho ba số nguyên n, m và k, tìm số lượng dãy gồm n dấu '(' và m dấu ')', sao cho dãy con cân bằng dài nhất có độ dài 2 * k. Kết quả nên được tính theo modulo 1,000,000,007 (10^9 + 7).\n\nVí dụ:\n    f_41(2, 2, 2)\n    // trả về 2", "id": "Diberikan tiga bilangan bulat n, m, dan k, temukan jumlah urutan yang terdiri dari n '(' dan m ')', sehingga subsekuens seimbang terpanjang memiliki panjang 2 * k. Hasilnya harus dihitung dengan modulo 1,000,000,007 (10^9 + 7).\n\nSebagai contoh:\n    f_41(2, 2, 2)\n    // mengembalikan 2", "ja": "3つの整数 n、m、k が与えられたとき、n 個の '(' と m 個の ')' からなるシーケンスのうち、最長のバランスの取れた部分列が長さ 2 * k であるものの数を求めます。結果は 1,000,000,007 (10^9 + 7) での剰余として計算されるべきです。\n\n例:\n    f_41(2, 2, 2)\n    // 2 を返します", "ko": "세 개의 정수 n, m, k가 주어졌을 때, n개의 '('와 m개의 ')'로 구성된 시퀀스 중에서 가장 긴 균형 잡힌 부분 시퀀스의 길이가 2 * k인 경우의 수를 찾으시오. 결과는 1,000,000,007 (10^9 + 7)로 나눈 나머지로 계산되어야 합니다.\n\n예를 들어:\n    f_41(2, 2, 2)\n    // 2를 반환합니다.", "ml": "മൂന്നു പൂർണ്ണസംഖ്യകൾ n, m, k നൽകിയാൽ, n '('  മും m ')'  മും അടങ്ങിയ അനുക്രമങ്ങളുടെ എണ്ണം കണ്ടുപിടിക്കുക, \n *  ഏറ്റവും നീളമുള്ള ബാലൻസ്ഡ് ഉപമാലികയുടെ നീളം 2 * k ആയിരിക്കണം. ഫലം 1,000,000,007 (10^9 + 7) കൊണ്ട്\n\nമൂന്ന് പൂർണ്ണസംഖ്യകൾ n, m, k എന്നിവ നൽകിയാൽ, n '(' മുകളിലായി m ')' അടങ്ങിയ അനുബന്ധങ്ങളുടെ എണ്ണം കണ്ടെത്തുക, ഏറ്റവും നീളമുള്ള ബാലൻസ്ഡ് ഉപക്രമം 2 * k നീളമുള്ളതായിരിക്കണം. ഫലം 1,000,000,007 (10^9 + 7) മോടുലോയിൽ കണക്കാക്കണം.\n\nFor example:\n    f_41(2, 2, 2)\n    // returns 2\n\nഉദാഹരണത്തിന്:\n    f_41(2, 2, 2)\n    // 2 മടങ്ങുന്നു", "fa": "با توجه به سه عدد صحیح n، m و k، تعداد دنباله‌هایی را پیدا کنید که شامل n '(' و m ')' باشند، به طوری که طولانی‌ترین زیر دنباله متوازن دارای طول 2 * k باشد. نتیجه باید به صورت پیمانه 1,000,000,007 (10^9 + 7) محاسبه شود.\n\nبرای مثال:\n    f_41(2, 2, 2)\n    // مقدار بازگشتی 2"}}
{"task_id": "JavaScript/42", "prompt": {"en": "/**\n * Given a rectangle paper of size n x m placed on a plane Cartesian coordinate system with its bottom-left \n * corner at (0,0) and top-right corner at (n,m), you need to calculate the expected number of operations\n * to cut the paper such that the remaining area is less than k.\n * In each operation, a line is randomly chosen that is parallel to the axes, passes through points with\n * integer coordinates, and cuts through (not just touching the edge) the paper. The bottom or right part\n * of the paper along this line is then discarded.\n * The answer should be modulo 10^9+7.\n *\n * For example:\n *    f_42(3, 3, 4) // returns 3\n *    f_42(5, 5, 12) // returns 2\n */\nfunction f_42(n, m, k)", "sq": "/**\n * Duke pasur një letër drejtkëndore me madhësi n x m të vendosur në një sistem koordinativ Kartesian të planit me këndin e poshtëm të majtë\n * në (0,0) dhe këndin e sipërm të djathtë në (n,m), ju duhet të llogaritni numrin e pritur të operacioneve\n * për të prerë letrën në mënyrë që sipërfaqja e mbetur të jetë më pak se k.\n * Në secilën operacion, një vijë zgjidhet rastësisht që është paralele me boshtet, kalon nëpër pika me\n * koordinata të plota, dhe pret (jo vetëm prek skajin) letrën. Pjesa e poshtme ose e djathtë e letrës përgjatë kësaj vije pastaj hidhet.\n * Përgjigjja duhet të jetë modulo 10^9+7.\n *\n * Për shembull:\n *    f_42(3, 3, 4) // kthen 3\n *    f_42(5, 5, 12) // kthen 2\n */\nfunction f_42(n, m, k)", "hy": "/**\n * Ունենալով n x m չափսերով ուղղանկյուն թուղթ, որը տեղադրված է հարթության Կարտեզյան կոորդինատային համակարգում՝\n * իր ներքևի ձախ անկյունը (0,0) կետում և վերևի աջ անկյունը (n,m) կետում, անհրաժեշտ է հաշվել գործողությունների\n * սպասվող քանակը, որպեսզի թղթի մնացած մակերեսը լինի k-ից փոքր։\n * Յուրաքանչյուր գործողության ժամանակ պատահականորեն ընտրվում է գիծ, որը զուգահեռ է առանցքներին, անցնում է\n * ամբողջ թվային կոորդինատներով կետերով և կտրում է թուղթը (ոչ միայն շոշափում է եզրը)։ Թղթի այս գծի երկայնքով\n * ներքևի կամ աջ մասը ապա դուրս է մնում։\n * Պատասխանը պետք է լինի 10^9+7 մոդուլով։\n *\n * Օրինակ՝\n *    f_42(3, 3, 4) // վերադարձնում է 3\n *    f_42(5, 5, 12) // վերադարձնում է 2\n */", "bn": "/**\n * একটি আয়তাকার কাগজ n x m আকারের একটি সমতল কার্টেসিয়ান স্থানাঙ্ক পদ্ধতিতে রাখা হয়েছে যার নিচের-বাম \n * কোণ (0,0) এবং উপরের-ডান কোণ (n,m) এ অবস্থিত, আপনাকে কাগজ কাটার প্রত্যাশিত সংখ্যা গণনা করতে হবে \n * যাতে অবশিষ্ট ক্ষেত্রফল k এর চেয়ে কম হয়।\n * প্রতিটি অপারেশনে, একটি লাইন এলোমেলোভাবে নির্বাচন করা হয় যা অক্ষের সমান্তরাল, পূর্ণসংখ্যা স্থানাঙ্ক সহ \n * বিন্দুগুলির মধ্য দিয়ে যায় এবং কাগজের মধ্য দিয়ে কেটে যায় (শুধু প্রান্ত স্পর্শ নয়)। এই লাইনের \n * বরাবর কাগজের নিচের বা ডান অংশটি তারপর বাতিল করা হয়।\n * উত্তরটি 10^9+7 দ্বারা মডুলো হওয়া উচিত।\n *\n * উদাহরণস্বরূপ:\n *    f_42(3, 3, 4) // 3 প্রদান করে\n *    f_42(5, 5, 12) // 2 প্রদান করে\n */", "bg": "/**\n * Даден е правоъгълник от хартия с размер n x m, разположен в равнинна декартова координатна система с долен ляв \n * ъгъл в (0,0) и горен десен ъгъл в (n,m), трябва да изчислите очаквания брой операции\n * за да се изреже хартията така, че останалата площ да е по-малка от k.\n * При всяка операция се избира случайно линия, която е успоредна на осите, преминава през точки с\n * цели координати и пресича (не само докосва ръба) хартията. Долната или дясната част\n * на хартията по тази линия след това се изхвърля.\n * Отговорът трябва да бъде по модул 10^9+7.\n *\n * Например:\n *    f_42(3, 3, 4) // връща 3\n *    f_42(5, 5, 12) // връща 2\n */", "zh": "/**\n * 给定一个大小为 n x m 的矩形纸张，放置在平面直角坐标系中，其左下角在 (0,0) 位置，右上角在 (n,m) 位置，\n * 你需要计算切割纸张的期望操作次数，使得剩余面积小于 k。\n * 在每次操作中，随机选择一条与坐标轴平行的线，该线通过整数坐标的点，并切割（不仅仅是接触边缘）纸张。\n * 然后沿着这条线丢弃纸张的底部或右侧部分。\n * 答案应对 10^9+7 取模。\n *\n * 例如:\n *    f_42(3, 3, 4) // 返回 3\n *    f_42(5, 5, 12) // 返回 2\n */", "fr": "/**\n * Étant donné un papier rectangulaire de taille n x m placé sur un système de coordonnées cartésiennes avec son coin inférieur gauche\n * à (0,0) et son coin supérieur droit à (n,m), vous devez calculer le nombre attendu d'opérations\n * pour couper le papier de sorte que la surface restante soit inférieure à k.\n * À chaque opération, une ligne est choisie au hasard qui est parallèle aux axes, passe par des points avec\n * des coordonnées entières, et coupe (ne fait pas que toucher le bord) le papier. La partie inférieure ou droite\n * du papier le long de cette ligne est alors jetée.\n * La réponse doit être modulo 10^9+7.\n *\n * Par exemple :\n *    f_42(3, 3, 4) // retourne 3\n *    f_42(5, 5, 12) // retourne 2\n */", "de": "/**\n * Gegeben ein rechteckiges Papier der Größe n x m, das in einem kartesischen Koordinatensystem platziert ist, \n * mit seiner unteren linken Ecke bei (0,0) und der oberen rechten Ecke bei (n,m), müssen Sie die erwartete \n * Anzahl von Operationen berechnen, um das Papier so zu schneiden, dass die verbleibende Fläche kleiner als k ist.\n * Bei jeder Operation wird eine Linie zufällig gewählt, die parallel zu den Achsen verläuft, durch Punkte mit \n * ganzzahligen Koordinaten geht und das Papier durchschneidet (nicht nur den Rand berührt). Der untere oder \n * rechte Teil des Papiers entlang dieser Linie wird dann verworfen.\n * Die Antwort sollte modulo 10^9+7 sein.\n *\n * Zum Beispiel:\n *    f_42(3, 3, 4) // gibt 3 zurück\n *    f_42(5, 5, 12) // gibt 2 zurück\n */", "ha": "/**\n * An ba takardar murabba'i mai girman n x m a kan tsarin daidaitawa na Cartesian tare da kusurwar ƙasa-hagu\n * a (0,0) da kusurwar sama-dama a (n,m), kana buƙatar ƙididdige yawan ayyukan da ake tsammani\n * don yanke takardar ta yadda yankin da ya rage ya zama ƙasa da k.\n * A kowane aiki, ana zaɓar layi da bazuwar wanda yake daidai da ɗakunan ajiya, yana wucewa ta wuraren da ke da\n * daidaitattun lambobi, kuma yana yanke (ba kawai taɓa gefen ba) takardar. Sashin ƙasa ko dama\n * na takardar tare da wannan layin ana watsar.\n * Amsar ya kamata ta zama modulo 10^9+7.\n *\n * Alal misali:\n *    f_42(3, 3, 4) // returns 3\n *    f_42(5, 5, 12) // returns 2\n */", "hi": "/**\n * एक आयताकार कागज जिसका आकार n x m है, को एक समतल कार्टेशियन निर्देशांक प्रणाली पर रखा गया है, \n * जिसकी निचली-बाईं कोने पर (0,0) और ऊपरी-दाईं कोने पर (n,m) है। \n * आपको उन ऑपरेशनों की अपेक्षित संख्या की गणना करनी है जिससे कागज का शेष क्षेत्रफल k से कम हो जाए।\n * प्रत्येक ऑपरेशन में, एक रेखा को यादृच्छिक रूप से चुना जाता है जो अक्षों के समानांतर होती है, \n * पूर्णांक निर्देशांक वाले बिंदुओं से गुजरती है, और कागज को काटती है (सिर्फ किनारे को छूने के बजाय)। \n * इस रेखा के साथ कागज का निचला या दायां भाग फिर त्याग दिया जाता है।\n * उत्तर को 10^9+7 के मापांक में होना चाहिए।\n *\n * उदाहरण के लिए:\n *    f_42(3, 3, 4) // 3 लौटाता है\n *    f_42(5, 5, 12) // 2 लौटाता है\n */\nfunction f_42(n, m, k)", "hu": "/**\n * Adott egy n x m méretű téglalap alakú papír, amely egy síkbeli derékszögű koordináta-rendszerben van elhelyezve, \n * az alsó-bal sarok a (0,0) pontban és a felső-jobb sarok az (n,m) pontban található. Ki kell számítani a várható \n * műveletek számát, hogy a papírt úgy vágjuk, hogy a megmaradt terület kisebb legyen, mint k.\n * Minden művelet során véletlenszerűen kiválasztunk egy vonalat, amely párhuzamos a tengelyekkel, egész koordinátájú \n * pontokon halad át, és átvágja (nem csak érinti a szélét) a papírt. A papírnak az ezen a vonalon lévő alsó vagy \n * jobb részét eldobjuk.\n * Az eredményt 10^9+7 modullal kell megadni.\n *\n * Például:\n *    f_42(3, 3, 4) // visszaadja 3\n *    f_42(5, 5, 12) // visszaadja 2\n */", "es": "/**\n * Dado un papel rectangular de tamaño n x m colocado en un sistema de coordenadas cartesianas en un plano con su esquina inferior izquierda en (0,0) y la esquina superior derecha en (n,m), necesitas calcular el número esperado de operaciones para cortar el papel de tal manera que el área restante sea menor que k.\n * En cada operación, se elige aleatoriamente una línea que es paralela a los ejes, pasa por puntos con coordenadas enteras y corta (no solo toca el borde) el papel. La parte inferior o derecha del papel a lo largo de esta línea se descarta.\n * La respuesta debe ser módulo 10^9+7.\n *\n * Por ejemplo:\n *    f_42(3, 3, 4) // devuelve 3\n *    f_42(5, 5, 12) // devuelve 2\n */\nfunction f_42(n, m, k)", "arb": "/**\n * بالنظر إلى ورقة مستطيلة بحجم n x m موضوعة على نظام إحداثيات ديكارتي مستوي مع وجود زاويتها السفلية اليسرى \n * عند (0,0) وزاويتها العلوية اليمنى عند (n,m)، تحتاج إلى حساب العدد المتوقع من العمليات\n * لقطع الورقة بحيث تكون المساحة المتبقية أقل من k.\n * في كل عملية، يتم اختيار خط بشكل عشوائي يكون موازياً للمحاور، ويمر عبر نقاط ذات إحداثيات صحيحة،\n * ويقطع الورقة (وليس فقط ملامسة الحافة). يتم بعد ذلك التخلص من الجزء السفلي أو الأيمن من الورقة على طول هذا الخط.\n * يجب أن تكون الإجابة موديولو 10^9+7.\n *\n * على سبيل المثال:\n *    f_42(3, 3, 4) // يعيد 3\n *    f_42(5, 5, 12) // يعيد 2\n */\nfunction f_42(n, m, k)", "sw": "/**\n * Ukipewa karatasi ya mstatili ya ukubwa n x m iliyowekwa kwenye mfumo wa kuratibu wa Cartesian na kona yake ya chini-kushoto \n * iko kwenye (0,0) na kona ya juu-kulia iko kwenye (n,m), unahitaji kuhesabu idadi inayotarajiwa ya operesheni\n * za kukata karatasi ili eneo linalobaki liwe chini ya k.\n * Katika kila operesheni, mstari huchaguliwa kwa nasibu ambao ni sambamba na mhimili, unapita kwenye pointi zenye\n * kuratibu za nambari kamili, na hukata (si kugusa tu ukingo) karatasi. Sehemu ya chini au ya kulia ya karatasi kando ya mstari huu \n * kisha hutupwa.\n * Jibu linapaswa kuwa modulo 10^9+7.\n *\n * Kwa mfano:\n *    f_42(3, 3, 4) // inarejesha 3\n *    f_42(5, 5, 12) // inarejesha 2\n */\nfunction f_42(n, m, k)", "tr": "/**\n * n x m boyutunda bir dikdörtgen kağıt, alt-sol köşesi (0,0) ve üst-sağ köşesi (n,m) olan bir düzlem Kartezyen koordinat sistemine yerleştirilmiştir. \n * Kalan alanın k'dan küçük olması için kağıdı kesmek için gereken beklenen işlem sayısını hesaplamanız gerekiyor.\n * Her işlemde, eksenlere paralel, tam sayı koordinatlarına sahip noktalardan geçen ve kağıdı kesen (sadece kenara dokunmayan) bir çizgi rastgele seçilir. \n * Bu çizgi boyunca kağıdın alt veya sağ kısmı atılır.\n * Cevap 10^9+7 modunda olmalıdır.\n *\n * Örneğin:\n *    f_42(3, 3, 4) // 3 döndürür\n *    f_42(5, 5, 12) // 2 döndürür\n */\nfunction f_42(n, m, k)", "vi": "/**\n * Cho một tờ giấy hình chữ nhật kích thước n x m đặt trên hệ tọa độ phẳng Descartes với góc dưới bên trái\n * tại (0,0) và góc trên bên phải tại (n,m), bạn cần tính số lần cắt dự kiến\n * để cắt giấy sao cho diện tích còn lại nhỏ hơn k.\n * Trong mỗi lần cắt, một đường thẳng được chọn ngẫu nhiên song song với các trục, đi qua các điểm có\n * tọa độ nguyên, và cắt qua (không chỉ chạm vào cạnh) tờ giấy. Phần dưới hoặc bên phải\n * của tờ giấy dọc theo đường này sau đó bị loại bỏ.\n * Câu trả lời nên được lấy modulo 10^9+7.\n *\n * Ví dụ:\n *    f_42(3, 3, 4) // trả về 3\n *    f_42(5, 5, 12) // trả về 2\n */\nfunction f_42(n, m, k)", "id": "/**\n * Diberikan sebuah kertas persegi panjang berukuran n x m yang ditempatkan pada sistem koordinat Kartesius\n * dengan sudut kiri bawah di (0,0) dan sudut kanan atas di (n,m), Anda perlu menghitung jumlah operasi\n * yang diharapkan untuk memotong kertas sehingga area yang tersisa kurang dari k.\n * Dalam setiap operasi, sebuah garis dipilih secara acak yang sejajar dengan sumbu, melewati titik dengan\n * koordinat integer, dan memotong (bukan hanya menyentuh tepi) kertas. Bagian bawah atau kanan dari kertas\n * sepanjang garis ini kemudian dibuang.\n * Jawabannya harus dalam modulo 10^9+7.\n *\n * Sebagai contoh:\n *    f_42(3, 3, 4) // mengembalikan 3\n *    f_42(5, 5, 12) // mengembalikan 2\n */\nfunction f_42(n, m, k)", "ja": "/**\n * サイズ n x m の長方形の紙が、平面直交座標系上に配置されており、その左下の角が (0,0)、右上の角が (n,m) にあります。\n * 残りの面積が k 未満になるように紙を切るための操作の期待回数を計算する必要があります。\n * 各操作では、軸に平行で、整数座標を持つ点を通り、紙を切断する（エッジに触れるだけでなく）線がランダムに選ばれます。\n * この線に沿った紙の下または右の部分は破棄されます。\n * 答えは 10^9+7 での剰余として返す必要があります。\n *\n * 例えば:\n *    f_42(3, 3, 4) // 3 を返します\n *    f_42(5, 5, 12) // 2 を返します\n */\nfunction f_42(n, m, k)", "ko": "/**\n * 크기가 n x m인 직사각형 종이가 평면 직교 좌표계에 놓여 있으며, 왼쪽 아래 모서리가 (0,0)에 있고 \n * 오른쪽 위 모서리가 (n,m)에 있습니다. 남은 면적이 k보다 작아지도록 종이를 자르는 데 필요한 \n * 예상 작업 수를 계산해야 합니다.\n * 각 작업에서는 축에 평행하고 정수 좌표를 지나는 선이 무작위로 선택되어 종이를 자릅니다 \n * (단순히 가장자리에 닿는 것이 아님). 그런 다음 이 선을 따라 종이의 아래쪽 또는 오른쪽 부분이 버려집니다.\n * 답은 10^9+7로 나눈 나머지여야 합니다.\n *\n * 예를 들어:\n *    f_42(3, 3, 4) // 3을 반환\n *    f_42(5, 5, 12) // 2를 반환\n */\nfunction f_42(n, m, k)", "ml": "/**\n * n x m വലിപ്പമുള്ള ഒരു ചതുരശ്രാകൃതത്തിലുള്ള കാഗിതം കാർട്ടീഷ്യൻ കോഓർഡിനേറ്റ് സിസ്റ്റത്തിൽ (0,0) എന്ന ബോട്ടം-ലെഫ്റ്റ് \n * കോർണറിൽ നിന്നും (n,m) എന്ന ടോപ്പ്-റൈറ്റ് കോർണറിൽ വരെ വച്ചിരിക്കുന്നപ്പോൾ, ശേഷിക്കുന്ന വിസ്തീർണ്ണം k-ൽ \n * കുറവായിരിക്കാനായി കട്ടിയെടുക്കേണ്ട പ്രതീക്ഷിക്കുന്ന പ്രവർത്തനങ്ങളുടെ എണ്ണം കണക്കാക്കേണ്ടതുണ്ട്.\n * ഓരോ പ്രവർത്തനത്തിലും, അക്ഷങ്ങളോട് സമാന്തരമായ, പൂർണ്ണസംഖ്യാ കോഓർഡിനേറ്റുകളുള്ള പോയിന്റുകൾ വഴി കടന്നുപോകുന്ന \n * ഒരു വരി യാദൃശ്ചികമായി തിരഞ്ഞെടുക്കപ്പെടുന്നു, ഇത് കാഗിതം കട്ട് ചെയ്യുന്നു (വരമ്പ് മാത്രം സ്പർശിക്കുന്നതല്ല). \n * ഈ വരിയോടൊപ്പം കാഗിതത്തിന്റെ ബോട്ടം അല്ലെങ്കിൽ റൈറ്റ് ഭാഗം പിന്നീട് ഉപേക്ഷിക്കുന്നു.\n * ഉത്തരം 10^9+7 മോഡുലോ ആയി നൽകണം.\n *\n * ഉദാഹരണത്തിന്:\n *    f_42(3, 3, 4) // 3 തിരിച്ചുനൽകുന്നു\n *    f_42(5, 5, 12) // 2 തിരിച്ചുനൽകുന്നു\n */\nfunction f_42(n, m, k)", "fa": "/**\n * با توجه به یک کاغذ مستطیلی به اندازه n x m که در یک سیستم مختصات دکارتی صفحه‌ای قرار دارد و گوشه پایین-چپ آن \n * در نقطه (0,0) و گوشه بالا-راست آن در نقطه (n,m) است، شما باید تعداد مورد انتظار عملیات‌ها را محاسبه کنید\n * تا کاغذ به گونه‌ای بریده شود که مساحت باقی‌مانده کمتر از k باشد.\n * در هر عملیات، یک خط به صورت تصادفی انتخاب می‌شود که موازی با محور‌ها است، از نقاط با مختصات صحیح عبور می‌کند،\n * و از کاغذ می‌گذرد (نه فقط لبه را لمس کند). قسمت پایین یا راست کاغذ در امتداد این خط سپس دور انداخته می‌شود.\n * پاسخ باید به پیمانه 10^9+7 باشد.\n *\n * برای مثال:\n *    f_42(3, 3, 4) // مقدار 3 را برمی‌گرداند\n *    f_42(5, 5, 12) // مقدار 2 را برمی‌گرداند\n */\nfunction f_42(n, m, k)"}, "canonical_solution": "{\n    const MD = 1000000007;\n    const N = 1000000;\n    let vv = new Array(N * 2 + 2).fill(0);\n    let ans = 1;\n\n    vv[1] = 1;\n    for (let i = 2; i <= N * 2; i++)\n        vv[i] = vv[i - MD % i] * (Math.floor(MD / i) + 1) % MD;\n    if (k > n * m) {\n        return 0;\n    }\n\n    for (let i = Math.floor((k + m - 1) / m); i < n; i++) {\n        ans = (ans + vv[i + Math.floor((k + i - 1) / i) - 1]) % MD;\n    }\n    for (let j = Math.floor((k + n - 1) / n); j < m; j++)\n        ans = (ans + vv[Math.floor((k + j - 1) / j) + j - 1]) % MD;\n\n    return ans;\n}", "instruction": {"en": "Write a JavaScript function `function f_42(n, m, k)` to solve the following problem:\nGiven a rectangle paper of size n x m placed on a plane Cartesian coordinate system with its bottom-left corner at (0,0) and top-right corner at (n,m), you need to calculate the expected number of operations to cut the paper such that the remaining area is less than k. In each operation, a line is randomly chosen that is parallel to the axes, passes through points with integer coordinates, and cuts through (not just touching the edge) the paper. The bottom or right part of the paper along this line is then discarded. The answer should be modulo 10^9+7.\n\nFor example:\n    f_42(3, 3, 4) // returns 3\n    f_42(5, 5, 12) // returns 2\n", "sq": "Shkruani një funksion JavaScript `function f_42(n, m, k)` për të zgjidhur problemin e mëposhtëm:\nDuke pasur një letër drejtkëndore me madhësi n x m të vendosur në një sistem koordinativ Kartesian në plan me këndin e poshtëm të majtë në (0,0) dhe këndin e sipërm të djathtë në (n,m), ju duhet të llogaritni numrin e pritur të operacioneve për të prerë letrën në mënyrë që sipërfaqja e mbetur të jetë më pak se k. Në secilën operacion, zgjidhet rastësisht një vijë që është paralele me boshtet, kalon nëpër pika me koordinata të plota dhe pret (jo vetëm prek skajin) letrën. Pjesa e poshtme ose e djathtë e letrës përgjatë kësaj vije pastaj hidhet poshtë. Përgjigjja duhet të jetë modulo 10^9+7.\n\nPër shembull:\n    f_42(3, 3, 4) // kthen 3\n    f_42(5, 5, 12) // kthen 2", "hy": "Գրեք JavaScript ֆունկցիա `function f_42(n, m, k)` հետևյալ խնդիրը լուծելու համար:\nՏրված է n x m չափսերով ուղղանկյուն թուղթ, որը տեղադրված է հարթ Cartesian կոորդինատային համակարգում՝ իր ներքևի ձախ անկյունը (0,0) կետում և վերևի աջ անկյունը (n,m) կետում, դուք պետք է հաշվեք գործողությունների ակնկալվող քանակը, որպեսզի կտրեք թուղթը այնպես, որ մնացած տարածքը լինի k-ից փոքր: Յուրաքանչյուր գործողության ժամանակ պատահականորեն ընտրվում է գիծ, որը զուգահեռ է առանցքներին, անցնում է ամբողջ կոորդինատներով կետերով և կտրում է թուղթը (ոչ միայն եզրին դիպչելով): Թղթի այս գծի երկայնքով ներքևի կամ աջ մասը ապա հեռացվում է: Պատասխանը պետք է լինի 10^9+7 մոդուլով:\n\nՕրինակ:\n    f_42(3, 3, 4) // վերադարձնում է 3\n    f_42(5, 5, 12) // վերադարձնում է 2", "bn": "একটি JavaScript ফাংশন `function f_42(n, m, k)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি আয়তাকার কাগজের টুকরো, যার আকার n x m, একটি সমতল কার্টেসিয়ান স্থানাঙ্ক পদ্ধতিতে রাখা হয়েছে যার নিচের-বাম কোণ (0,0) এবং উপরের-ডান কোণ (n,m) এ অবস্থিত, আপনাকে কাগজটি কাটার জন্য প্রত্যাশিত অপারেশনের সংখ্যা গণনা করতে হবে যাতে অবশিষ্ট এলাকা k এর চেয়ে কম হয়। প্রতিটি অপারেশনে, একটি লাইন এলোমেলোভাবে নির্বাচন করা হয় যা অক্ষের সমান্তরাল, পূর্ণসংখ্যা স্থানাঙ্ক সহ বিন্দুগুলির মধ্য দিয়ে যায় এবং কাগজের মধ্য দিয়ে কেটে যায় (শুধুমাত্র প্রান্ত স্পর্শ নয়)। এই লাইনের বরাবর কাগজের নিচের বা ডান দিকের অংশটি তখন বাতিল করা হয়। উত্তরটি 10^9+7 এর মডুলো হওয়া উচিত।\n\nউদাহরণস্বরূপ:\n    f_42(3, 3, 4) // 3 রিটার্ন করে\n    f_42(5, 5, 12) // 2 রিটার্ন করে", "bg": "Напишете JavaScript функция `function f_42(n, m, k)`, за да решите следния проблем:\nДаден е правоъгълник от хартия с размер n x m, разположен в равнинна декартова координатна система с долния ляв ъгъл в (0,0) и горния десен ъгъл в (n,m). Трябва да изчислите очаквания брой операции за рязане на хартията така, че оставащата площ да е по-малка от k. При всяка операция се избира случайна линия, която е успоредна на осите, минава през точки с цели координати и пресича (не само докосва ръба) хартията. Долната или дясната част на хартията по тази линия след това се изхвърля. Отговорът трябва да бъде модул 10^9+7.\n\nНапример:\n    f_42(3, 3, 4) // връща 3\n    f_42(5, 5, 12) // връща 2", "zh": "编写一个JavaScript函数 `function f_42(n, m, k)` 来解决以下问题：  \n给定一个大小为 n x m 的矩形纸张，放置在平面直角坐标系中，其左下角在 (0,0) 处，右上角在 (n,m) 处，你需要计算切割纸张的期望操作次数，使得剩余面积小于 k。在每次操作中，随机选择一条与坐标轴平行的线，该线通过整数坐标点，并切割（不仅仅是接触边缘）纸张。然后沿着这条线丢弃纸张的底部或右侧部分。答案应取模 10^9+7。\n\n例如：\n    f_42(3, 3, 4) // 返回 3\n    f_42(5, 5, 12) // 返回 2", "fr": "Écrire une fonction JavaScript `function f_42(n, m, k)` pour résoudre le problème suivant :  \nÉtant donné un papier rectangulaire de taille n x m placé sur un système de coordonnées cartésiennes avec son coin inférieur gauche à (0,0) et son coin supérieur droit à (n,m), vous devez calculer le nombre attendu d'opérations pour couper le papier de sorte que la surface restante soit inférieure à k. À chaque opération, une ligne est choisie au hasard, parallèle aux axes, passant par des points avec des coordonnées entières, et traverse (ne se contente pas de toucher le bord) le papier. La partie inférieure ou droite du papier le long de cette ligne est alors jetée. La réponse doit être modulo 10^9+7.\n\nPar exemple :\n    f_42(3, 3, 4) // retourne 3\n    f_42(5, 5, 12) // retourne 2", "de": "Schreiben Sie eine JavaScript-Funktion `function f_42(n, m, k)`, um das folgende Problem zu lösen:\nGegeben ist ein rechteckiges Papier der Größe n x m, das in einem kartesischen Koordinatensystem auf einer Ebene platziert ist, mit seiner unteren linken Ecke bei (0,0) und der oberen rechten Ecke bei (n,m). Sie müssen die erwartete Anzahl von Operationen berechnen, um das Papier so zu schneiden, dass die verbleibende Fläche kleiner als k ist. Bei jeder Operation wird zufällig eine Linie gewählt, die parallel zu den Achsen verläuft, durch Punkte mit ganzzahligen Koordinaten geht und das Papier durchschneidet (nicht nur den Rand berührt). Der untere oder rechte Teil des Papiers entlang dieser Linie wird dann verworfen. Die Antwort sollte modulo 10^9+7 sein.\n\nZum Beispiel:\n    f_42(3, 3, 4) // gibt 3 zurück\n    f_42(5, 5, 12) // gibt 2 zurück", "ha": "Rubuta aikin JavaScript `function f_42(n, m, k)` don warware matsalar mai zuwa:\nAn ba da takarda murabba'i mai girman n x m da aka sanya a kan tsarin daidaitawa na Cartesian tare da kusurwar ƙasa-hagu a (0,0) da kusurwar sama-dama a (n,m), kana buƙatar ƙididdige yawan ayyukan da ake tsammanin don yanke takardar ta yadda yankin da ya rage ya zama ƙasa da k. A kowane aiki, ana zaɓar layi da bazuwar wanda yake daidai da manyan layukan, yana wucewa ta wuraren da ke da daidaitattun lambobi, kuma yana yanke (ba kawai taɓa gefen ba) takardar. Ana watsar da ƙasa ko ɓangaren dama na takardar tare da wannan layin. Amsar ya kamata ta kasance modulo 10^9+7.\n\nAlal misali:\n    f_42(3, 3, 4) // returns 3\n    f_42(5, 5, 12) // returns 2", "hi": "`function f_42(n, m, k)` लिखने के लिए एक JavaScript फ़ंक्शन निम्नलिखित समस्या को हल करने के लिए:\nदिया गया है कि एक आयताकार कागज का आकार n x m है जो एक समतल कार्टेशियन निर्देशांक प्रणाली पर रखा गया है, जिसका निचला-बायां कोना (0,0) पर है और ऊपरी-दायां कोना (n,m) पर है, आपको उन ऑपरेशनों की अपेक्षित संख्या की गणना करनी है ताकि कागज का शेष क्षेत्रफल k से कम हो। प्रत्येक ऑपरेशन में, एक रेखा यादृच्छिक रूप से चुनी जाती है जो अक्षों के समानांतर होती है, पूर्णांक निर्देशांक वाले बिंदुओं से गुजरती है, और कागज को काटती है (सिर्फ किनारे को छूने के बजाय)। इस रेखा के साथ कागज का निचला या दायां हिस्सा तब त्याग दिया जाता है। उत्तर 10^9+7 के मापांक के रूप में होना चाहिए।\n\nउदाहरण के लिए:\n    f_42(3, 3, 4) // 3 लौटाता है\n    f_42(5, 5, 12) // 2 लौटाता है", "hu": "Írj egy JavaScript függvényt `function f_42(n, m, k)`, hogy megoldja a következő problémát:\nAdott egy n x m méretű téglalap alakú papír, amely a sík Descartes-koordináta-rendszerben helyezkedik el, az alsó-bal sarka a (0,0) pontban, a felső-jobb sarka pedig az (n,m) pontban van. Ki kell számítanod a várható műveletek számát, hogy a papírt úgy vágd el, hogy a megmaradt terület kisebb legyen, mint k. Minden művelet során véletlenszerűen választanak ki egy vonalat, amely párhuzamos a tengelyekkel, egész koordinátájú pontokon halad át, és átvágja (nem csak érinti a szélét) a papírt. A papír ezen vonal mentén lévő alsó vagy jobb része ezután eldobásra kerül. A válasznak 10^9+7 modulo szerint kell lennie.\n\nPéldául:\n    f_42(3, 3, 4) // visszaadja 3\n    f_42(5, 5, 12) // visszaadja 2", "es": "Escribe una función de JavaScript `function f_42(n, m, k)` para resolver el siguiente problema:\nDado un papel rectangular de tamaño n x m colocado en un sistema de coordenadas Cartesianas en el plano con su esquina inferior izquierda en (0,0) y su esquina superior derecha en (n,m), necesitas calcular el número esperado de operaciones para cortar el papel de manera que el área restante sea menor que k. En cada operación, se elige aleatoriamente una línea que es paralela a los ejes, pasa por puntos con coordenadas enteras, y corta (no solo toca el borde) el papel. La parte inferior o derecha del papel a lo largo de esta línea se descarta. La respuesta debe ser módulo 10^9+7.\n\nPor ejemplo:\n    f_42(3, 3, 4) // devuelve 3\n    f_42(5, 5, 12) // devuelve 2", "arb": "اكتب دالة JavaScript `function f_42(n, m, k)` لحل المشكلة التالية:\nمعطى ورقة مستطيلة بحجم n x m موضوعة على نظام إحداثيات ديكارتي مستوي مع ركنها السفلي الأيسر عند (0,0) وركنها العلوي الأيمن عند (n,m)، تحتاج إلى حساب العدد المتوقع من العمليات لقطع الورقة بحيث تكون المساحة المتبقية أقل من k. في كل عملية، يتم اختيار خط عشوائي موازٍ للمحاور، يمر عبر نقاط ذات إحداثيات صحيحة، ويقطع (وليس فقط يلامس الحافة) الورقة. يتم بعد ذلك التخلص من الجزء السفلي أو الأيمن من الورقة على طول هذا الخط. يجب أن يكون الجواب موديولو 10^9+7.\n\nعلى سبيل المثال:\n    f_42(3, 3, 4) // يعيد 3\n    f_42(5, 5, 12) // يعيد 2", "sw": "Andika kazi ya JavaScript `function f_42(n, m, k)` kutatua tatizo lifuatalo:\nUkipatiwa karatasi ya mstatili yenye ukubwa wa n x m iliyowekwa kwenye mfumo wa kuratibu wa Cartesian kwenye ndege na kona yake ya chini-kushoto iko kwenye (0,0) na kona ya juu-kulia iko kwenye (n,m), unahitaji kuhesabu idadi inayotarajiwa ya operesheni za kukata karatasi hiyo ili eneo linalobaki liwe chini ya k. Katika kila operesheni, mstari unachaguliwa kwa nasibu ambao ni sambamba na mhimili, unapita kwenye pointi zenye kuratibu za namba kamili, na unakata (sio tu kugusa ukingo) karatasi hiyo. Sehemu ya chini au ya kulia ya karatasi kando ya mstari huu kisha hutupwa. Jibu linapaswa kuwa modulo 10^9+7.\n\nKwa mfano:\n    f_42(3, 3, 4) // inarudisha 3\n    f_42(5, 5, 12) // inarudisha 2", "tr": "Bir JavaScript fonksiyonu `function f_42(n, m, k)` yazın. Aşağıdaki problemi çözmek için: \nBir dikdörtgen kağıt, n x m boyutunda, düzlem Kartezyen koordinat sistemine yerleştirilmiş ve sol alt köşesi (0,0), sağ üst köşesi (n,m) olan bir kağıt verildiğinde, kalan alanın k'dan küçük olması için kağıdı kesmek üzere beklenen işlem sayısını hesaplamanız gerekir. Her işlemde, eksenlere paralel olan, tam sayı koordinatlarına sahip noktalardan geçen ve kağıdı kesen (sadece kenara dokunmayan) bir çizgi rastgele seçilir. Bu çizgi boyunca kağıdın alt veya sağ kısmı atılır. Cevap 10^9+7 modunda olmalıdır.\n\nÖrneğin:\n    f_42(3, 3, 4) // 3 döndürür\n    f_42(5, 5, 12) // 2 döndürür", "vi": "Viết một hàm JavaScript `function f_42(n, m, k)` để giải quyết vấn đề sau:\nCho một tờ giấy hình chữ nhật kích thước n x m đặt trên hệ tọa độ phẳng Cartesian với góc dưới bên trái tại (0,0) và góc trên bên phải tại (n,m), bạn cần tính số lượng thao tác kỳ vọng để cắt tờ giấy sao cho diện tích còn lại nhỏ hơn k. Trong mỗi thao tác, một đường thẳng được chọn ngẫu nhiên song song với các trục, đi qua các điểm có tọa độ nguyên, và cắt qua (không chỉ chạm vào cạnh) tờ giấy. Phần dưới hoặc bên phải của tờ giấy dọc theo đường này sau đó bị loại bỏ. Câu trả lời nên được tính theo modulo 10^9+7.\n\nVí dụ:\n    f_42(3, 3, 4) // trả về 3\n    f_42(5, 5, 12) // trả về 2", "id": "Tulis sebuah fungsi JavaScript `function f_42(n, m, k)` untuk menyelesaikan masalah berikut:\nDiberikan selembar kertas berbentuk persegi panjang berukuran n x m yang ditempatkan pada sistem koordinat Kartesius dengan sudut kiri bawah di (0,0) dan sudut kanan atas di (n,m), Anda perlu menghitung jumlah operasi yang diharapkan untuk memotong kertas sehingga area yang tersisa kurang dari k. Dalam setiap operasi, sebuah garis dipilih secara acak yang sejajar dengan sumbu, melewati titik dengan koordinat bilangan bulat, dan memotong (bukan hanya menyentuh tepi) kertas. Bagian bawah atau kanan dari kertas sepanjang garis ini kemudian dibuang. Jawaban harus dalam modulo 10^9+7.\n\nSebagai contoh:\n    f_42(3, 3, 4) // mengembalikan 3\n    f_42(5, 5, 12) // mengembalikan 2", "ja": "JavaScript関数 `function f_42(n, m, k)` を作成して、次の問題を解決してください:\nn x m のサイズの長方形の紙が、平面のデカルト座標系上に配置されており、その左下の角が (0,0)、右上の角が (n,m) にあります。この紙を切る操作の期待回数を計算する必要があります。残りの面積が k 未満になるようにします。各操作では、軸に平行で、整数座標を持つ点を通り、紙を切断する（端に触れるだけではない）線がランダムに選ばれます。この線に沿った紙の下または右の部分は破棄されます。答えは 10^9+7 での剰余として返す必要があります。\n\n例えば:\n    f_42(3, 3, 4) // 3 を返します\n    f_42(5, 5, 12) // 2 を返します", "ko": "JavaScript 함수 `function f_42(n, m, k)`를 작성하여 다음 문제를 해결하십시오:\n크기 n x m의 직사각형 종이가 평면 직교 좌표계에 놓여 있으며, 그 왼쪽 아래 모서리가 (0,0)에, 오른쪽 위 모서리가 (n,m)에 있습니다. 남은 면적이 k보다 작아지도록 종이를 자르는 작업의 예상 횟수를 계산해야 합니다. 각 작업에서는 축에 평행하고 정수 좌표를 지나는 선이 무작위로 선택되어 종이를 자릅니다(가장자리를 단순히 만지는 것이 아님). 그런 다음 이 선을 따라 종이의 아래쪽 또는 오른쪽 부분이 버려집니다. 답은 10^9+7로 나눈 나머지가 되어야 합니다.\n\n예를 들어:\n    f_42(3, 3, 4) // 3을 반환\n    f_42(5, 5, 12) // 2를 반환", "ml": "JavaScript ഫംഗ്ഷൻ `function f_42(n, m, k)` എഴുതുക താഴെക്കാണുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nn x m വലിപ്പമുള്ള ഒരു ചതുരശ്രക്കടലാസ് ഒരു പ്ലെയിൻ കാർട്ടീഷ്യൻ കോഓർഡിനേറ്റ് സിസ്റ്റത്തിൽ (0,0) എന്നതിൽ നിന്ന് (n,m) എന്നതിൽ വരെ വലിച്ചിടുക, ബാക്കിയുള്ള വിസ്തീർണം k-ൽ കുറവായിരിക്കേണ്ടതിനായി കടലാസ്സ് മുറിക്കാൻ ആവശ്യമായ പ്രവർത്തനങ്ങളുടെ പ്രതീക്ഷിത സംഖ്യ കണക്കാക്കേണ്ടതുണ്ട്. ഓരോ പ്രവർത്തനത്തിലും, അച്ചുതണ്ടുകളോട് സമാന്തരമായ, പൂർണ്ണസംഖ്യ കോഓർഡിനേറ്റുകളുള്ള പോയിന്റുകൾ വഴി കടന്നുപോകുന്ന ഒരു വരി യാദൃശ്ചികമായി തിരഞ്ഞെടുക്കപ്പെടുന്നു, ഇത് കടലാസ്സിനെ (അറ്റത്തെ മാത്രം തൊടാതെ) മുറിക്കുന്നു. ഈ വരിയോടൊപ്പം കടലാസ്സിന്റെ താഴത്തെ അല്ലെങ്കിൽ വലത്തെ ഭാഗം പിന്നീട് ഉപേക്ഷിക്കുന്നു. ഉത്തരം 10^9+7 മോഡുലോ ആയിരിക്കണം.\n\nഉദാഹരണത്തിന്:\n    f_42(3, 3, 4) // 3 മടക്കുന്നു\n    f_42(5, 5, 12) // 2 മടക്കുന്നു", "fa": "یک تابع جاوااسکریپت `function f_42(n, m, k)` بنویسید تا مسئله زیر را حل کند:\nبا توجه به یک کاغذ مستطیلی به ابعاد n x m که در یک سیستم مختصات دکارتی صفحه قرار دارد و گوشه پایین-چپ آن در (0,0) و گوشه بالا-راست آن در (n,m) است، شما باید تعداد عملیات مورد انتظار برای بریدن کاغذ را محاسبه کنید به طوری که مساحت باقی‌مانده کمتر از k باشد. در هر عملیات، یک خط به صورت تصادفی انتخاب می‌شود که موازی با محورها است، از نقاط با مختصات صحیح عبور می‌کند و از کاغذ عبور می‌کند (نه فقط لبه را لمس کند). سپس قسمت پایین یا راست کاغذ در امتداد این خط کنار گذاشته می‌شود. پاسخ باید به صورت مدولوی 10^9+7 باشد.\n\nبرای مثال:\n    f_42(3, 3, 4) // مقدار 3 را برمی‌گرداند\n    f_42(5, 5, 12) // مقدار 2 را برمی‌گرداند"}, "level": "hard", "test": "function testf_42() {\n    console.assert(f_42(2, 4, 10) === 0, 'Test 1 failed');\n    console.assert(f_42(2, 4, 8) === 1, 'Test 2 failed');\n    console.assert(f_42(2, 4, 2) === 833333342, 'Test 3 failed');\n    console.assert(f_42(2, 4, 6) === 250000003, 'Test 4 failed');\n    console.assert(f_42(3, 3, 4) === 666666673, 'Test 5 failed');\n    console.assert(f_42(5, 5, 12) === 666666673, 'Test 6 failed');\n    console.assert(f_42(6, 7, 20) === 722222229, 'Test 7 failed');\n    console.assert(f_42(10, 10, 50) === 714285721, 'Test 9 failed');\n    console.assert(f_42(1, 10, 5) === 945634929, 'Test 10 failed');\n    console.assert(f_42(10, 1, 5) === 945634929, 'Test 11 failed');\n}\n\ntestf_42();", "entry_point": "f_42", "signature": "function f_42(n, m, k)", "docstring": {"en": "Given a rectangle paper of size n x m placed on a plane Cartesian coordinate system with its bottom-left corner at (0,0) and top-right corner at (n,m), you need to calculate the expected number of operations to cut the paper such that the remaining area is less than k. In each operation, a line is randomly chosen that is parallel to the axes, passes through points with integer coordinates, and cuts through (not just touching the edge) the paper. The bottom or right part of the paper along this line is then discarded. The answer should be modulo 10^9+7.\n\nFor example:\n    f_42(3, 3, 4) // returns 3\n    f_42(5, 5, 12) // returns 2\n", "sq": "Duke pasur një letër drejtkëndëshe me madhësi n x m të vendosur në një sistem koordinativ kartezian të planit me këndin e poshtëm të majtë në (0,0) dhe këndin e sipërm të djathtë në (n,m), ju duhet të llogaritni numrin e pritur të operacioneve për të prerë letrën në mënyrë që sipërfaqja e mbetur të jetë më pak se k. Në secilën operacion, zgjidhet rastësisht një vijë që është paralele me boshtet, kalon përmes pikave me koordinata të plota, dhe pret (jo vetëm prek buzën) letrën. Pjesa e poshtme ose e djathtë e letrës përgjatë kësaj vije pastaj hidhet poshtë. Përgjigja duhet të jetë modulo 10^9+7.\n\nPër shembull:\n    f_42(3, 3, 4) // kthen 3\n    f_42(5, 5, 12) // kthen 2", "hy": "Ունենալով n x m չափսի ուղղանկյուն թուղթ, որը տեղադրված է հարթության Կարտեզյան կոորդինատային համակարգում՝ իր ներքևի ձախ անկյունը (0,0) կետում և վերևի աջ անկյունը (n,m) կետում, անհրաժեշտ է հաշվարկել գործողությունների սպասվող քանակը՝ թուղթը կտրելու համար այնպես, որ մնացած մակերեսը լինի k-ից փոքր: Յուրաքանչյուր գործողության ժամանակ պատահականորեն ընտրվում է մի գիծ, որը զուգահեռ է առանցքներին, անցնում է ամբողջ թվային կոորդինատներով կետերով և կտրում է թուղթը (ոչ միայն հպվում է եզրին): Թղթի այդ գծի երկայնքով ներքևի կամ աջ մասը ապա հեռացվում է: Պատասխանը պետք է լինի 10^9+7 մոդուլով:\n\nՕրինակ:\n    f_42(3, 3, 4) // վերադարձնում է 3\n    f_42(5, 5, 12) // վերադարձնում է 2", "bn": "একটি আয়তাকার কাগজের টুকরো n x m আকারের, যা একটি প্লেন কার্টেসিয়ান কোঅর্ডিনেট সিস্টেমে স্থাপন করা হয়েছে, যার নিচের-বাম কোণ (0,0) এবং উপরের-ডান কোণ (n,m) এ অবস্থিত। আপনাকে এমন অপারেশনগুলির প্রত্যাশিত সংখ্যা গণনা করতে হবে যাতে কাগজের অবশিষ্ট এলাকা k এর চেয়ে কম হয়। প্রতিটি অপারেশনে, একটি লাইন এলোমেলোভাবে নির্বাচিত হয় যা অক্ষগুলির সমান্তরাল, পূর্ণসংখ্যা কোঅর্ডিনেট সহ বিন্দুগুলির মধ্য দিয়ে যায় এবং কাগজের মধ্য দিয়ে কেটে যায় (শুধু প্রান্ত স্পর্শ নয়)। এই লাইনের বরাবর কাগজের নিচের বা ডান অংশটি তারপর বাতিল করা হয়। উত্তরটি 10^9+7 দ্বারা মডুলো করা উচিত।\n\nউদাহরণস্বরূপ:\n    f_42(3, 3, 4) // 3 ফেরত দেয়\n    f_42(5, 5, 12) // 2 ফেরত দেয়", "bg": "Даден е правоъгълен лист хартия с размер n x m, поставен в равнинна декартова координатна система с долен ляв ъгъл в (0,0) и горен десен ъгъл в (n,m). Трябва да изчислите очаквания брой операции за изрязване на хартията така, че оставащата площ да е по-малка от k. При всяка операция се избира случайно линия, която е успоредна на осите, минава през точки с цели координати и пресича (не само докосва ръба) хартията. Долната или дясната част на хартията по тази линия след това се изхвърля. Отговорът трябва да бъде модуло 10^9+7.\n\nНапример:\n    f_42(3, 3, 4) // връща 3\n    f_42(5, 5, 12) // връща 2", "zh": "给定一个大小为 n x m 的矩形纸张，放置在平面直角坐标系中，其左下角位于 (0,0)，右上角位于 (n,m)，你需要计算切割纸张的期望操作次数，使得剩余面积小于 k。在每次操作中，随机选择一条平行于坐标轴的直线，该直线通过整数坐标的点，并切割（不仅仅是接触边缘）纸张。然后沿着这条线丢弃纸张的底部或右侧部分。答案应对 10^9+7 取模。\n\n例如：\n    f_42(3, 3, 4) // 返回 3\n    f_42(5, 5, 12) // 返回 2", "fr": "Étant donné un papier rectangulaire de taille n x m placé sur un système de coordonnées cartésiennes avec son coin inférieur gauche à (0,0) et son coin supérieur droit à (n,m), vous devez calculer le nombre attendu d'opérations pour couper le papier de sorte que la surface restante soit inférieure à k. À chaque opération, une ligne est choisie aléatoirement, parallèle aux axes, passant par des points avec des coordonnées entières, et traversant (pas seulement touchant le bord) le papier. La partie inférieure ou droite du papier le long de cette ligne est ensuite éliminée. La réponse doit être modulo 10^9+7.\n\nPar exemple :\n    f_42(3, 3, 4) // retourne 3\n    f_42(5, 5, 12) // retourne 2", "de": "Gegeben ein rechteckiges Papier der Größe n x m, das in einem kartesischen Koordinatensystem auf einer Ebene platziert ist, mit seiner unteren linken Ecke bei (0,0) und der oberen rechten Ecke bei (n,m), müssen Sie die erwartete Anzahl von Operationen berechnen, um das Papier so zu schneiden, dass die verbleibende Fläche kleiner als k ist. Bei jeder Operation wird zufällig eine Linie gewählt, die parallel zu den Achsen verläuft, durch Punkte mit ganzzahligen Koordinaten geht und das Papier durchschneidet (nicht nur die Kante berührt). Der untere oder rechte Teil des Papiers entlang dieser Linie wird dann verworfen. Die Antwort sollte modulo 10^9+7 sein.\n\nZum Beispiel:\n    f_42(3, 3, 4) // gibt 3 zurück\n    f_42(5, 5, 12) // gibt 2 zurück", "ha": "An ba takardar murabba'i mai girman n x m da aka sanya a kan tsarin daidaitawa na Cartesian tare da kusurwar ƙasa-hagu a (0,0) da kusurwar sama-dama a (n,m), kuna buƙatar ƙididdige yawan ayyukan da ake tsammani don yanke takardar ta yadda yankin da ya rage ya kasance ƙasa da k. A kowane aiki, ana zaɓar layi da bazuwar wanda yake daidai da ginshiƙai, yana wucewa ta wuraren da ke da daidaitattun lambobi, kuma yana yanke (ba kawai taɓa gefen ba) takardar. Ana watsar da ɓangaren ƙasa ko dama na takardar tare da wannan layin. Amsar yakamata ta kasance modulo 10^9+7.\n\nMisali:\n    f_42(3, 3, 4) // yana dawowa 3\n    f_42(5, 5, 12) // yana dawowa 2", "hi": "दिया गया एक आयताकार कागज जिसका आकार n x m है, एक समतल कार्टेशियन निर्देशांक प्रणाली पर रखा गया है, जिसकी निचली-बाईं कोने पर स्थिति (0,0) है और ऊपरी-दाईं कोने पर स्थिति (n,m) है। आपको कागज को इस प्रकार काटने के लिए अपेक्षित संचालन की संख्या की गणना करनी है कि शेष क्षेत्रफल k से कम हो। प्रत्येक संचालन में, एक रेखा यादृच्छिक रूप से चुनी जाती है जो अक्षों के समानांतर होती है, पूर्णांक निर्देशांक वाले बिंदुओं से गुजरती है, और कागज को काटती है (सिर्फ किनारे को छूती नहीं है)। इस रेखा के साथ कागज के निचले या दाईं हिस्से को फिर त्याग दिया जाता है। उत्तर को 10^9+7 से मोड्यूलो लेना चाहिए।\n\nउदाहरण के लिए:\n    f_42(3, 3, 4) // 3 लौटाता है\n    f_42(5, 5, 12) // 2 लौटाता है", "hu": "Egy n x m méretű téglalap alakú papírt helyezünk el a síkbeli derékszögű koordináta-rendszerben, amelynek bal alsó sarka a (0,0) pontban, a jobb felső sarka pedig az (n,m) pontban van. Ki kell számítanod a várható műveletek számát, hogy a papírt úgy vágd el, hogy a megmaradó terület kisebb legyen, mint k. Minden művelet során véletlenszerűen kiválasztunk egy vonalat, amely párhuzamos a tengelyekkel, egész koordinátájú pontokon halad át, és átvágja (nem csak érinti a szélét) a papírt. A papírnak a vonal mentén lévő alsó vagy jobb részét ezután elvetjük. Az eredményt 10^9+7 modullal kell megadni.\n\nPéldául:\n    f_42(3, 3, 4) // visszaadja 3\n    f_42(5, 5, 12) // visszaadja 2", "es": "Dado un papel rectangular de tamaño n x m colocado en un sistema de coordenadas cartesianas en un plano con su esquina inferior izquierda en (0,0) y la esquina superior derecha en (n,m), necesitas calcular el número esperado de operaciones para cortar el papel de tal manera que el área restante sea menor que k. En cada operación, se elige aleatoriamente una línea que es paralela a los ejes, pasa por puntos con coordenadas enteras y corta (no solo toca el borde) el papel. La parte inferior o derecha del papel a lo largo de esta línea se descarta. La respuesta debe ser módulo 10^9+7.\n\nPor ejemplo:\n    f_42(3, 3, 4) // devuelve 3\n    f_42(5, 5, 12) // devuelve 2", "arb": "بالنظر إلى ورقة مستطيلة بحجم n x m موضوعة على نظام إحداثي ديكارتي مستوي مع وجود الزاوية السفلية اليسرى عند (0,0) والزواية العلوية اليمنى عند (n,m)، تحتاج إلى حساب العدد المتوقع من العمليات لقطع الورقة بحيث تكون المساحة المتبقية أقل من k. في كل عملية، يتم اختيار خط عشوائي موازٍ للمحاور، يمر عبر نقاط ذات إحداثيات صحيحة، ويقطع (وليس فقط يلامس الحافة) الورقة. يتم بعد ذلك التخلص من الجزء السفلي أو الأيمن من الورقة على طول هذا الخط. يجب أن تكون الإجابة موديولو 10^9+7.\n\nعلى سبيل المثال:\n    f_42(3, 3, 4) // يعيد 3\n    f_42(5, 5, 12) // يعيد 2", "sw": "Kwa kupewa karatasi ya mstatili yenye ukubwa wa n x m iliyowekwa kwenye mfumo wa kuratibu wa Cartesian kwenye ndege na kona yake ya chini-kushoto iko kwenye (0,0) na kona ya juu-kulia iko kwenye (n,m), unahitaji kuhesabu idadi inayotarajiwa ya operesheni za kukata karatasi ili eneo lililobaki liwe chini ya k. Katika kila operesheni, mstari unachaguliwa kwa nasibu ambao ni sambamba na mhimili, unapita kwenye pointi zenye kuratibu za nambari kamili, na unakata (si kugusa tu ukingo) karatasi. Sehemu ya chini au kulia ya karatasi kando ya mstari huu kisha hutupwa. Jibu linapaswa kuwa moduli ya 10^9+7.\n\nKwa mfano:\n    f_42(3, 3, 4) // inarudisha 3\n    f_42(5, 5, 12) // inarudisha 2", "tr": "Verilen bir n x m boyutunda dikdörtgen kağıt, alt sol köşesi (0,0) ve üst sağ köşesi (n,m) olan bir düzlem Kartezyen koordinat sistemine yerleştirilmiştir. Kağıdın kalan alanının k'dan küçük olacak şekilde kesilmesi için gereken beklenen işlem sayısını hesaplamanız gerekmektedir. Her işlemde, eksenlere paralel, tam sayı koordinatlarına sahip noktalardan geçen ve kağıdı kesen (sadece kenara dokunmayan) bir çizgi rastgele seçilir. Bu çizgi boyunca kağıdın alt veya sağ kısmı atılır. Cevap 10^9+7 ile mod alınarak verilmelidir.\n\nÖrneğin:\n    f_42(3, 3, 4) // 3 döndürür\n    f_42(5, 5, 12) // 2 döndürür", "vi": "Cho một tờ giấy hình chữ nhật kích thước n x m đặt trên hệ tọa độ phẳng Cartesian với góc dưới bên trái tại (0,0) và góc trên bên phải tại (n,m), bạn cần tính số lần cắt dự kiến để cắt tờ giấy sao cho diện tích còn lại nhỏ hơn k. Trong mỗi lần cắt, một đường thẳng được chọn ngẫu nhiên song song với các trục, đi qua các điểm có tọa độ nguyên, và cắt qua (không chỉ chạm vào cạnh) tờ giấy. Phần dưới hoặc bên phải của tờ giấy dọc theo đường này sau đó bị loại bỏ. Câu trả lời cần được tính theo modulo 10^9+7.\n\nVí dụ:\n    f_42(3, 3, 4) // trả về 3\n    f_42(5, 5, 12) // trả về 2", "id": "Diberikan sebuah kertas berbentuk persegi panjang berukuran n x m yang ditempatkan pada sistem koordinat Kartesius dengan sudut kiri bawah di (0,0) dan sudut kanan atas di (n,m), Anda perlu menghitung jumlah operasi yang diharapkan untuk memotong kertas sehingga area yang tersisa kurang dari k. Dalam setiap operasi, sebuah garis dipilih secara acak yang sejajar dengan sumbu, melewati titik-titik dengan koordinat integer, dan memotong (tidak hanya menyentuh tepi) kertas tersebut. Bagian bawah atau kanan dari kertas sepanjang garis ini kemudian dibuang. Jawabannya harus dalam bentuk modulo 10^9+7.\n\nSebagai contoh:\n    f_42(3, 3, 4) // mengembalikan 3\n    f_42(5, 5, 12) // mengembalikan 2", "ja": "与えられた長方形の紙のサイズが n x m で、平面のデカルト座標系においてその左下の角が (0,0)、右上の角が (n,m) に配置されています。この紙を切って残りの面積が k 未満になるまでの操作の期待値を計算する必要があります。各操作では、軸に平行で、整数座標を持つ点を通り、紙を（端に触れるだけではなく）切断する線がランダムに選ばれます。この線に沿った紙の下または右の部分は捨てられます。答えは 10^9+7 での剰余を取る必要があります。\n\n例:\n    f_42(3, 3, 4) // 3 を返す\n    f_42(5, 5, 12) // 2 を返す", "ko": "주어진 n x m 크기의 직사각형 종이가 평면 직교 좌표계에 놓여 있으며, 왼쪽 아래 모서리는 (0,0)에, 오른쪽 위 모서리는 (n,m)에 위치해 있습니다. 남은 면적이 k보다 작아지도록 종이를 자르는 작업의 기대 횟수를 계산해야 합니다. 각 작업에서는 축에 평행하고 정수 좌표를 지나는 선이 무작위로 선택되어 종이를 자릅니다(단순히 가장자리를 터치하는 것이 아님). 그런 다음 이 선을 따라 종이의 아래쪽 또는 오른쪽 부분이 폐기됩니다. 답은 10^9+7로 모듈러 연산한 결과여야 합니다.\n\n예를 들어:\n    f_42(3, 3, 4) // 3을 반환\n    f_42(5, 5, 12) // 2를 반환", "ml": "നിർദ്ദിഷ്ട n x m വലുപ്പമുള്ള ഒരു ചതുരശ്രാകൃതത്തിലുള്ള കാഗിതത്തെ കാർട്ടീസിയൻ കോഓർഡിനേറ്റ് സിസ്റ്റത്തിൽ (0,0) എന്ന ബോട്ടം-ലെഫ്റ്റ് കോർണറിൽ നിന്നും (n,m) എന്ന ടോപ്പ്-റൈറ്റ് കോർണറിൽ വരെ സ്ഥിതിചെയ്യുന്ന വിധത്തിൽ വെച്ചിരിക്കുമ്പോൾ, ശേഷിക്കുന്ന വിസ്തീർണം k-ൽ കുറവായിരിക്കേണ്ടതിന് വേണ്ടി കാഗിതം മുറിക്കാൻ പ്രതീക്ഷിക്കപ്പെടുന്ന പ്രവർത്തനങ്ങളുടെ എണ്ണം കണക്കാക്കേണ്ടതുണ്ട്. ഓരോ പ്രവർത്തനത്തിലും, അക്ഷങ്ങളോട് സമാന്തരമായ, പൂർണ്ണസംഖ്യാ കോഓർഡിനേറ്റുകളുള്ള ബിന്ദുക്കളിലൂടെ കടന്നുപോകുന്ന ഒരു വരി യാദൃശ്ചികമായി തിരഞ്ഞെടുക്കപ്പെടുന്നു, ഇത് കാഗിതത്തെ മുറിക്കുന്നു (വരമ്പ് മാത്രം സ്പർശിക്കുന്നതല്ല). ഈ വരിയോടൊപ്പം കാഗിതത്തിന്റെ താഴത്തെ അല്ലെങ്കിൽ വലതുവശം പിന്നീട് ഉപേക്ഷിക്കുന്നു. ഉത്തരം 10^9+7 നു മോഡുലോ ആയി നൽകണം.\n\nഉദാഹരണത്തിന്:\n    f_42(3, 3, 4) // 3 തിരിച്ചുനൽകുന്നു\n    f_42(5, 5, 12) // 2 തിരിച്ചുനൽകുന്നു", "fa": "با توجه به یک کاغذ مستطیلی به اندازه n x m که در یک سیستم مختصات دکارتی صفحه‌ای قرار گرفته است و گوشه پایین-چپ آن در نقطه (0,0) و گوشه بالا-راست آن در نقطه (n,m) قرار دارد، شما باید تعداد عملیات‌های مورد انتظار برای بریدن کاغذ را محاسبه کنید به طوری که مساحت باقی‌مانده کمتر از k باشد. در هر عملیات، یک خط به صورت تصادفی انتخاب می‌شود که موازی با محور‌ها است، از نقاط با مختصات صحیح عبور می‌کند، و از کاغذ عبور می‌کند (نه فقط لبه را لمس کند). سپس بخش پایین یا راست کاغذ در امتداد این خط کنار گذاشته می‌شود. پاسخ باید به پیمانه 10^9+7 باشد.\n\nبرای مثال:\n    f_42(3, 3, 4) // مقدار برگشتی 3\n    f_42(5, 5, 12) // مقدار برگشتی 2"}}
{"task_id": "JavaScript/43", "prompt": {"en": "/**\n * Given a permutation q of n elements and an integer k, find the number of permutations p of n elements\n * such that f(p) = q, where f(p) is the lexicographically smallest permutation that can be obtained by\n * dividing p into exactly k non-empty contiguous segments and sorting each segment (i.e., choose k-1\n * breakpoints 1 <= x1 < x2 < ... < x(k-1) < n, and divide it into [1, x1], (x1, x2], ..., (x(k-1), n]).\n * The result should be modulo 998244353.\n * \n * @example\n * f_43(2, 1, [1, 2])\n * // returns 2\n */\nconst f_43 = (n, k, q) => {", "sq": "/**\n * Duke pasur një permutacion q të n elementeve dhe një numër të plotë k, gjeni numrin e permutacioneve p të n elementeve\n * të tilla që f(p) = q, ku f(p) është permutacioni më i vogël leksikografik që mund të merret duke\n * ndarë p në saktësisht k segmente të pandara dhe duke renditur secilin segment (d.m.th., zgjidhni k-1\n * pika ndarëse 1 <= x1 < x2 < ... < x(k-1) < n, dhe ndajeni atë në [1, x1], (x1, x2], ..., (x(k-1), n]).\n * Rezultati duhet të jetë modulo 998244353.\n * \n * @example\n * f_43(2, 1, [1, 2])\n * // kthen 2\n */\nconst f_43 = (n, k, q) => {", "hy": "/**\n * Տրված է n տարրերի q փոխատեղումը և k ամբողջ թիվը, գտնել n տարրերի p փոխատեղումների քանակը\n * այնպես, որ f(p) = q, որտեղ f(p)-ն լեքսիկոգրաֆիկորեն ամենափոքր փոխատեղումն է, որը կարելի է ստանալ\n * p-ն բաժանելով հենց k ոչ դատարկ հարակից հատվածների և տեսակավորելով յուրաքանչյուր հատվածը (այսինքն՝ ընտրել k-1\n * կոտրման կետեր 1 <= x1 < x2 < ... < x(k-1) < n, և բաժանել այն [1, x1], (x1, x2], ..., (x(k-1), n]).\n * Արդյունքը պետք է լինի 998244353 մոդուլով։\n * \n * @օրինակ\n * f_43(2, 1, [1, 2])\n * // վերադարձնում է 2\n */", "bn": "/**\n * একটি n উপাদানের পারমুটেশন q এবং একটি পূর্ণসংখ্যা k দেওয়া আছে, এমন n উপাদানের পারমুটেশন p এর সংখ্যা খুঁজুন\n * যাতে f(p) = q, যেখানে f(p) হল লেক্সিকোগ্রাফিকভাবে সবচেয়ে ছোট পারমুটেশন যা পাওয়া যেতে পারে\n * p কে ঠিক k টি খালি নয় এমন সংলগ্ন সেগমেন্টে ভাগ করে এবং প্রতিটি সেগমেন্টকে সাজিয়ে (অর্থাৎ, k-1 টি\n * ব্রেকপয়েন্ট 1 <= x1 < x2 < ... < x(k-1) < n নির্বাচন করে, এবং এটিকে [1, x1], (x1, x2], ..., (x(k-1), n]) এ ভাগ করে)।\n * ফলাফলটি 998244353 মডুলো আকারে হওয়া উচিত।\n * \n * @example\n * f_43(2, 1, [1, 2])\n * // returns 2\n */\nconst f_43 = (n, k, q) => {", "bg": "/**\n * Дадена е пермутация q от n елемента и цяло число k, намерете броя на пермутациите p от n елемента\n * такива, че f(p) = q, където f(p) е лексикографски най-малката пермутация, която може да се получи чрез\n * разделяне на p на точно k непразни съседни сегмента и сортиране на всеки сегмент (т.е. изберете k-1\n * точки на прекъсване 1 <= x1 < x2 < ... < x(k-1) < n, и го разделете на [1, x1], (x1, x2], ..., (x(k-1), n]).\n * Резултатът трябва да бъде по модул 998244353.\n * \n * @пример\n * f_43(2, 1, [1, 2])\n * // връща 2\n */\nconst f_43 = (n, k, q) => {", "zh": "/**\n * 给定一个由n个元素组成的排列q和一个整数k，找出有多少个由n个元素组成的排列p\n * 使得f(p) = q，其中f(p)是可以通过将p分成恰好k个非空连续段并对每个段进行排序得到的字典序最小的排列\n * （即选择k-1个断点1 <= x1 < x2 < ... < x(k-1) < n，并将其分为[1, x1], (x1, x2], ..., (x(k-1), n]）。\n * 结果应对998244353取模。\n * \n * @example\n * f_43(2, 1, [1, 2])\n * // returns 2\n */\nconst f_43 = (n, k, q) => {", "fr": "/**\n * Étant donné une permutation q de n éléments et un entier k, trouver le nombre de permutations p de n éléments\n * telles que f(p) = q, où f(p) est la permutation lexicographiquement la plus petite qui peut être obtenue en\n * divisant p en exactement k segments contigus non vides et en triant chaque segment (c'est-à-dire, choisir k-1\n * points de rupture 1 <= x1 < x2 < ... < x(k-1) < n, et le diviser en [1, x1], (x1, x2], ..., (x(k-1), n]).\n * Le résultat doit être modulo 998244353.\n * \n * @example\n * f_43(2, 1, [1, 2])\n * // returns 2\n */\nconst f_43 = (n, k, q) => {", "de": "/**\n * Gegeben eine Permutation q von n Elementen und eine ganze Zahl k, finde die Anzahl der Permutationen p von n Elementen\n * so dass f(p) = q, wobei f(p) die lexikographisch kleinste Permutation ist, die erhalten werden kann, indem\n * p in genau k nicht-leere zusammenhängende Segmente unterteilt und jedes Segment sortiert wird (d.h. wähle k-1\n * Trennpunkte 1 <= x1 < x2 < ... < x(k-1) < n, und teile es in [1, x1], (x1, x2], ..., (x(k-1), n]).\n * Das Ergebnis sollte modulo 998244353 sein.\n * \n * @example\n * f_43(2, 1, [1, 2])\n * // returns 2\n */\nconst f_43 = (n, k, q) => {", "ha": "/**\n * An ba da permutation q na abubuwa n da kuma cikakken lamba k, nemo yawan permutations p na abubuwa n\n * ta yadda f(p) = q, inda f(p) shine mafi ƙarancin permutation a cikin tsarin haruffa wanda za'a iya samu ta\n * hanyar raba p zuwa daidai k sassa masu cike da babu komai kuma a jera kowane sashe (wato, zaɓi k-1\n * wuraren tsagewa 1 <= x1 < x2 < ... < x(k-1) < n, kuma a raba shi zuwa [1, x1], (x1, x2], ..., (x(k-1), n]).\n * Sakamakon ya kasance modulo 998244353.\n * \n * @example\n * f_43(2, 1, [1, 2])\n * // returns 2\n */\nconst f_43 = (n, k, q) => {", "hi": "/**\n * दिए गए n तत्वों के एक क्रमचय q और एक पूर्णांक k के लिए, n तत्वों के क्रमचयों की संख्या खोजें\n * ताकि f(p) = q हो, जहाँ f(p) वह शब्दकोशीय रूप से सबसे छोटा क्रमचय है जो प्राप्त किया जा सकता है\n * p को ठीक k गैर-खाली निरंतर खंडों में विभाजित करके और प्रत्येक खंड को क्रमबद्ध करके (अर्थात, k-1\n * ब्रेकपॉइंट चुनें 1 <= x1 < x2 < ... < x(k-1) < n, और इसे [1, x1], (x1, x2], ..., (x(k-1), n]) में विभाजित करें।\n * परिणाम 998244353 के मापांक में होना चाहिए।\n * \n * @example\n * f_43(2, 1, [1, 2])\n * // returns 2\n */\nconst f_43 = (n, k, q) => {", "hu": "/**\n * Adott egy q permutáció n elemről és egy egész szám k, meg kell találni az n elem p permutációinak számát\n * úgy, hogy f(p) = q, ahol f(p) a lexikográfiailag legkisebb permutáció, amelyet úgy lehet megkapni, hogy\n * p-t pontosan k nem üres, összefüggő szegmensre osztjuk és minden szegmenst sorba rendezünk (azaz válasszunk k-1\n * töréspontot 1 <= x1 < x2 < ... < x(k-1) < n, és osszuk fel [1, x1], (x1, x2], ..., (x(k-1), n] részekre).\n * Az eredménynek 998244353-mal vett maradéka kell legyen.\n * \n * @példa\n * f_43(2, 1, [1, 2])\n * // visszaadja 2\n */\nconst f_43 = (n, k, q) => {", "es": "/**\n * Dada una permutación q de n elementos y un entero k, encuentra el número de permutaciones p de n elementos\n * tal que f(p) = q, donde f(p) es la permutación lexicográficamente más pequeña que se puede obtener\n * dividiendo p en exactamente k segmentos contiguos no vacíos y ordenando cada segmento (es decir, elige k-1\n * puntos de corte 1 <= x1 < x2 < ... < x(k-1) < n, y divídelo en [1, x1], (x1, x2], ..., (x(k-1), n]).\n * El resultado debe ser módulo 998244353.\n * \n * @example\n * f_43(2, 1, [1, 2])\n * // devuelve 2\n */\nconst f_43 = (n, k, q) => {", "arb": "/**\n * بالنظر إلى ترتيب q من n عنصر وعدد صحيح k، ابحث عن عدد التباديل p من n عنصر\n * بحيث يكون f(p) = q، حيث أن f(p) هو الترتيب المعجمي الأصغر الذي يمكن الحصول عليه عن طريق\n * تقسيم p إلى k مقاطع متجاورة غير فارغة وترتيب كل مقطع (أي اختيار k-1\n * نقاط تقطيع 1 <= x1 < x2 < ... < x(k-1) < n، وتقسيمها إلى [1, x1]، (x1, x2]، ...، (x(k-1), n]).\n * يجب أن تكون النتيجة موديولو 998244353.\n * \n * @example\n * f_43(2, 1, [1, 2])\n * // يعيد 2\n */\nconst f_43 = (n, k, q) => {", "sw": "/**\n * Ukipewa mpangilio q wa vipengele n na nambari k, pata idadi ya mipangilio p ya vipengele n\n * kama kwamba f(p) = q, ambapo f(p) ni mpangilio mdogo zaidi kwa mpangilio wa lexicographically ambao unaweza kupatikana kwa\n * kugawanya p katika sehemu k zisizo tupu zinazoendelea na kupanga kila sehemu (yaani, chagua k-1\n * sehemu za kuvunja 1 <= x1 < x2 < ... < x(k-1) < n, na igawanye katika [1, x1], (x1, x2], ..., (x(k-1), n]).\n * Matokeo yanapaswa kuwa modulo 998244353.\n * \n * @example\n * f_43(2, 1, [1, 2])\n * // inarudisha 2\n */\nconst f_43 = (n, k, q) => {", "tr": "/**\n * n elemanlı bir q permütasyonu ve bir k tam sayısı verildiğinde, n elemanlı p permütasyonlarının sayısını bulun\n * öyle ki f(p) = q, burada f(p), p'yi tam olarak k boş olmayan ardışık parçaya bölerek ve her parçayı sıralayarak\n * elde edilebilecek sözlük sırasına göre en küçük permütasyondur (yani, k-1 tane kırılma noktası seçin 1 <= x1 < x2 < ... < x(k-1) < n, ve bunu [1, x1], (x1, x2], ..., (x(k-1), n] olarak bölün).\n * Sonuç 998244353 ile mod alınmış olmalıdır.\n * \n * @example\n * f_43(2, 1, [1, 2])\n * // 2 döndürür\n */\nconst f_43 = (n, k, q) => {", "vi": "/**\n * Cho một hoán vị q của n phần tử và một số nguyên k, tìm số lượng hoán vị p của n phần tử\n * sao cho f(p) = q, trong đó f(p) là hoán vị nhỏ nhất theo thứ tự từ điển có thể thu được bằng cách\n * chia p thành chính xác k đoạn liên tiếp không rỗng và sắp xếp từng đoạn (tức là, chọn k-1\n * điểm ngắt 1 <= x1 < x2 < ... < x(k-1) < n, và chia nó thành [1, x1], (x1, x2], ..., (x(k-1), n]).\n * Kết quả nên được lấy modulo 998244353.\n * \n * @example\n * f_43(2, 1, [1, 2])\n * // trả về 2\n */\nconst f_43 = (n, k, q) => {", "id": "/**\n * Diberikan sebuah permutasi q dari n elemen dan sebuah bilangan bulat k, temukan jumlah permutasi p dari n elemen\n * sedemikian rupa sehingga f(p) = q, di mana f(p) adalah permutasi terkecil secara leksikografis yang dapat diperoleh dengan\n * membagi p menjadi tepat k segmen kontigu yang tidak kosong dan mengurutkan setiap segmen (yaitu, pilih k-1\n * titik putus 1 <= x1 < x2 < ... < x(k-1) < n, dan bagi menjadi [1, x1], (x1, x2], ..., (x(k-1), n]).\n * Hasilnya harus dimodulo 998244353.\n * \n * @example\n * f_43(2, 1, [1, 2])\n * // mengembalikan 2\n */\nconst f_43 = (n, k, q) => {", "ja": "/**\n * n個の要素の順列qと整数kが与えられたとき、f(p) = qとなるn個の要素の順列pの数を見つけます。\n * ここで、f(p)はpをちょうどk個の空でない連続したセグメントに分割し、各セグメントをソートすることで得られる辞書順で最小の順列です\n * （つまり、k-1個のブレークポイント1 <= x1 < x2 < ... < x(k-1) < nを選び、[1, x1], (x1, x2], ..., (x(k-1), n]に分割します）。\n * 結果は998244353でのモジュロとします。\n * \n * @example\n * f_43(2, 1, [1, 2])\n * // returns 2\n */\nconst f_43 = (n, k, q) => {", "ko": "/**\n * n개의 요소로 구성된 순열 q와 정수 k가 주어졌을 때, f(p) = q인 n개의 요소로 구성된 순열 p의 개수를 찾습니다.\n * 여기서 f(p)는 p를 정확히 k개의 비어 있지 않은 연속된 구간으로 나누고 각 구간을 정렬하여 얻을 수 있는\n * 사전순으로 가장 작은 순열입니다 (즉, k-1개의 분할점을 선택하여 1 <= x1 < x2 < ... < x(k-1) < n,\n * [1, x1], (x1, x2], ..., (x(k-1), n]으로 나눕니다).\n * 결과는 998244353로 나눈 나머지가 되어야 합니다.\n * \n * @example\n * f_43(2, 1, [1, 2])\n * // returns 2\n */\nconst f_43 = (n, k, q) => {", "ml": "/**\n * n ഘടകങ്ങളുടെ ഒരു permutation q ഉം ഒരു പൂർണ്ണസംഖ്യ k ഉം നൽകിയാൽ, n ഘടകങ്ങളുടെ permutation p കളുടെ എണ്ണം കണ്ടെത്തുക\n * f(p) = q ആയിരിക്കുക, f(p) എന്നത് p നെ കൃത്യമായി k ശൂന്യമല്ലാത്ത തുടർച്ചയായ വിഭാഗങ്ങളായി വിഭജിച്ച് ഓരോ വിഭാഗവും ക്രമീകരിച്ച് ലഭിക്കാവുന്ന\n * ലെക്സികോഗ്രാഫിക്‌ ആയി ഏറ്റവും ചെറിയ permutation ആണ് (അഥവാ, k-1\n * ബ്രേക്ക്പോയിന്റുകൾ 1 <= x1 < x2 < ... < x(k-1) < n തിരഞ്ഞെടുക്കുക, [1, x1], (x1, x2], ..., (x(k-1), n] ആയി വിഭജിക്കുക).\n * ഫലം 998244353 ന്റെ മോഡുലോ ആയിരിക്കണം.\n * \n * @example\n * f_43(2, 1, [1, 2])\n * // returns 2\n */\nconst f_43 = (n, k, q) => {", "fa": "/**\n * با توجه به یک جایگشت q از n عنصر و یک عدد صحیح k، تعداد جایگشت‌های p از n عنصر را پیدا کنید\n * به طوری که f(p) = q، که در آن f(p) کوچکترین جایگشت لغت‌نامه‌ای است که می‌توان با\n * تقسیم p به دقیقاً k بخش متوالی غیر خالی و مرتب‌سازی هر بخش به دست آورد (یعنی k-1 نقطه شکست 1 <= x1 < x2 < ... < x(k-1) < n را انتخاب کنید و آن را به [1, x1]، (x1, x2]، ...، (x(k-1), n] تقسیم کنید).\n * نتیجه باید به پیمانه 998244353 باشد.\n * \n * @example\n * f_43(2, 1, [1, 2])\n * // returns 2\n */\nconst f_43 = (n, k, q) => {"}, "canonical_solution": "const P = 998244353;\n    let dp = Array.from({length: n + 1}, () => new Array(n + 1).fill(0));\n    let jc = new Array(n + 1).fill(0);\n    let f = new Array(n + 1).fill(0);\n    \n    dp[0][0] = f[0] = jc[0] = 1;\n    \n    for (let i = 1; i <= n; i++) {\n        jc[i] = (jc[i - 1] * i) % P;\n    }\n    \n    for (let i = 1; i <= n; i++) {\n        f[i] = jc[i];\n        for (let j = 1; j < i; j++) {\n            f[i] = (f[i] + P - (f[j] * jc[i - j]) % P) % P;\n        }\n    }\n    \n    for (let i = 1; i <= n; i++) {\n        for (let j = 0; j < i; j++) {\n            for (let kk = 1; kk <= n; kk++) {\n                dp[i][kk] = (dp[i][kk] + dp[j][kk - 1] * f[i - j]) % P;\n            }\n        }\n    }\n    \n    let m = 0;\n    for (let i = 1; i < n; i++) {\n        if (q[i - 1] > q[i]) {\n            m = i;\n            break;\n        }\n    }\n    \n    let ans = 0;\n    if (m === n || m === 0) {\n        for (let i = k; i <= n; i++) {\n            ans = (ans + dp[n][i]) % P;\n        }\n    } else {\n        for (let i = m + 1; i <= n; i++) {\n            if (i !== m + 1 && (q[i - 2] > q[i - 1] || q[i - 1] < q[m - 1])) {\n                break;\n            }\n            let c = k - 1 + i - n;\n            if (c >= 0) {\n                ans = (ans + dp[m][c] * jc[i - m - 1]) % P;\n            }\n        }\n    }\n    \n    return ans;\n};", "instruction": {"en": "Write a JavaScript function `const f_43 = (n, k, q) =>` to solve the following problem:\nGiven a permutation q of n elements and an integer k, find the number of permutations p of n elements\n such that f(p) = q, where f(p) is the lexicographically smallest permutation that can be obtained by\n dividing p into exactly k non-empty contiguous segments and sorting each segment (i.e., choose k-1\n breakpoints 1 <= x1 < x2 < ... < x(k-1) < n, and divide it into [1, x1], (x1, x2], ..., (x(k-1), n]).\n The result should be modulo 998244353.\n\n @example\n f_43(2, 1, [1, 2])\n // returns 2\n", "sq": "Shkruani një funksion JavaScript `const f_43 = (n, k, q) =>` për të zgjidhur problemin e mëposhtëm:\nDuke pasur një permutacion q të n elementeve dhe një numër të plotë k, gjeni numrin e permutacioneve p të n elementeve\ntë tilla që f(p) = q, ku f(p) është permutacioni leksikografikisht më i vogël që mund të merret duke\nndarë p në saktësisht k segmente të pandara bosh dhe duke renditur secilin segment (d.m.th., zgjidhni k-1\npikat e ndarjes 1 <= x1 < x2 < ... < x(k-1) < n, dhe ndajeni në [1, x1], (x1, x2], ..., (x(k-1), n]).\nRezultati duhet të jetë modulo 998244353.\n\n@example\nf_43(2, 1, [1, 2])\n// kthen 2", "hy": "Գրեք JavaScript ֆունկցիա `const f_43 = (n, k, q) =>` հետևյալ խնդիրը լուծելու համար:\nՏրված է n տարրերից կազմված q փոխատեղումը և k ամբողջ թիվը, գտնել n տարրերից կազմված p փոխատեղումների քանակը\n այնպես, որ f(p) = q, որտեղ f(p)-ն ամենափոքր լեքսիկոգրաֆիկ փոխատեղումն է, որը կարող է ստացվել\n p-ն բաժանելով հենց k ոչ դատարկ հարակից հատվածների և դասավորելով յուրաքանչյուր հատվածը (այսինքն՝ ընտրել k-1\n կոտրման կետեր 1 <= x1 < x2 < ... < x(k-1) < n, և բաժանել այն [1, x1], (x1, x2], ..., (x(k-1), n] հատվածների):\n Արդյունքը պետք է լինի 998244353 մոդուլով:\n\n @օրինակ\n f_43(2, 1, [1, 2])\n // վերադարձնում է 2", "bn": "একটি জাভাস্ক্রিপ্ট ফাংশন `const f_43 = (n, k, q) =>` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nn উপাদানের একটি permutation q এবং একটি পূর্ণসংখ্যা k দেওয়া আছে, এমন n উপাদানের কতগুলি permutation p আছে তা খুঁজে বের করুন\nযাতে f(p) = q, যেখানে f(p) হল লেক্সিকোগ্রাফিকভাবে সবচেয়ে ছোট permutation যা পাওয়া যেতে পারে\np কে ঠিক k টি খালি নয় এমন ধারাবাহিক segment এ ভাগ করে এবং প্রতিটি segment কে সাজিয়ে (অর্থাৎ, k-1 টি\nbreakpoints 1 <= x1 < x2 < ... < x(k-1) < n বেছে নিন, এবং এটিকে [1, x1], (x1, x2], ..., (x(k-1), n]) এ ভাগ করুন)।\nফলাফলটি 998244353 দ্বারা মডুলো করা উচিত।\n\n@example\nf_43(2, 1, [1, 2])\n// 2 ফেরত দেয়", "bg": "Напишете JavaScript функция `const f_43 = (n, k, q) =>` за решаване на следния проблем:  \nДадена е пермутация q от n елемента и цяло число k, намерете броя на пермутациите p от n елемента, така че f(p) = q, където f(p) е лексикографски най-малката пермутация, която може да се получи чрез разделяне на p на точно k непразни съседни сегмента и сортиране на всеки сегмент (т.е. изберете k-1 точки на прекъсване 1 <= x1 < x2 < ... < x(k-1) < n и го разделете на [1, x1], (x1, x2], ..., (x(k-1), n]).  \nРезултатът трябва да бъде модуло 998244353.\n\n@example\nf_43(2, 1, [1, 2])\n// връща 2", "zh": "编写一个 JavaScript 函数 `const f_43 = (n, k, q) =>` 来解决以下问题：\n给定一个 n 个元素的排列 q 和一个整数 k，找到 n 个元素的排列 p 的数量，使得 f(p) = q，其中 f(p) 是通过将 p 分成恰好 k 个非空连续段并对每个段进行排序（即，选择 k-1 个断点 1 <= x1 < x2 < ... < x(k-1) < n，并将其分成 [1, x1], (x1, x2], ..., (x(k-1), n]）可以获得的字典序最小的排列。结果应对 998244353 取模。\n\n@example\nf_43(2, 1, [1, 2])\n// 返回 2", "fr": "Écrire une fonction JavaScript `const f_43 = (n, k, q) =>` pour résoudre le problème suivant :\nÉtant donné une permutation q de n éléments et un entier k, trouver le nombre de permutations p de n éléments\n tel que f(p) = q, où f(p) est la permutation lexicographiquement la plus petite qui peut être obtenue en\n divisant p en exactement k segments contigus non vides et en triant chaque segment (c'est-à-dire, choisir k-1\n points de rupture 1 <= x1 < x2 < ... < x(k-1) < n, et le diviser en [1, x1], (x1, x2], ..., (x(k-1), n]).\n Le résultat doit être modulo 998244353.\n\n @example\n f_43(2, 1, [1, 2])\n // returns 2", "de": "Schreiben Sie eine JavaScript-Funktion `const f_43 = (n, k, q) =>`, um das folgende Problem zu lösen:\nGegeben eine Permutation q von n Elementen und eine ganze Zahl k, finde die Anzahl der Permutationen p von n Elementen,\nso dass f(p) = q, wobei f(p) die lexikographisch kleinste Permutation ist, die erhalten werden kann, indem\np in genau k nicht-leere zusammenhängende Segmente unterteilt und jedes Segment sortiert wird (d.h. wähle k-1\nTrennpunkte 1 <= x1 < x2 < ... < x(k-1) < n, und teile es in [1, x1], (x1, x2], ..., (x(k-1), n]).\nDas Ergebnis sollte modulo 998244353 sein.\n\n@example\nf_43(2, 1, [1, 2])\n// gibt 2 zurück", "ha": "Rubuta aikin JavaScript `const f_43 = (n, k, q) =>` don warware matsalar mai zuwa:\nAn ba da permutation q na abubuwa n da kuma lamba k, nemo yawan permutations p na abubuwa n\n ta yadda f(p) = q, inda f(p) shine permutation mafi ƙarancin lexicographically wanda za a iya samu ta\n raba p zuwa daidai k sassa masu ci gaba da ba komai ba kuma a tsara kowane sashi (wato, zaɓi k-1\n wuraren tsagewa 1 <= x1 < x2 < ... < x(k-1) < n, kuma raba shi zuwa [1, x1], (x1, x2], ..., (x(k-1), n]).\n Sakamakon ya zama modulo 998244353.\n\n @misali\n f_43(2, 1, [1, 2])\n // ya dawo da 2", "hi": "JavaScript फ़ंक्शन `const f_43 = (n, k, q) =>` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए n तत्वों के क्रमचय q और एक पूर्णांक k के लिए, n तत्वों के क्रमचयों की संख्या ज्ञात करें\nऐसे कि f(p) = q, जहाँ f(p) वह शब्दकोशीय रूप से सबसे छोटा क्रमचय है जो प्राप्त किया जा सकता है\np को ठीक k गैर-खाली सतत खंडों में विभाजित करके और प्रत्येक खंड को क्रमबद्ध करके (अर्थात् k-1\nब्रेकपॉइंट चुनें 1 <= x1 < x2 < ... < x(k-1) < n, और इसे [1, x1], (x1, x2], ..., (x(k-1), n]) में विभाजित करें)।\nपरिणाम 998244353 के मापांक में होना चाहिए।\n\n@example\nf_43(2, 1, [1, 2])\n// 2 लौटाता है", "hu": "Írj egy JavaScript függvényt `const f_43 = (n, k, q) =>` a következő probléma megoldására:\nAdott egy q permutáció n elemről és egy egész szám k, találd meg azon p permutációk számát n elemről,\namelyekre f(p) = q, ahol f(p) az a lexikográfiailag legkisebb permutáció, amelyet úgy lehet megkapni,\nhogy p-t pontosan k nem üres, egymást követő szegmensre osztjuk, és minden szegmenst sorba rendezünk (azaz válassz k-1\ntöréspontot 1 <= x1 < x2 < ... < x(k-1) < n, és oszd fel [1, x1], (x1, x2], ..., (x(k-1), n] szegmensekre).\nAz eredményt 998244353-mal modulozva kell megadni.\n\n @példa\n f_43(2, 1, [1, 2])\n // visszaadja 2", "es": "Escribe una función de JavaScript `const f_43 = (n, k, q) =>` para resolver el siguiente problema:\nDada una permutación q de n elementos y un entero k, encuentra el número de permutaciones p de n elementos\ntal que f(p) = q, donde f(p) es la permutación lexicográficamente más pequeña que se puede obtener\ndividiendo p en exactamente k segmentos contiguos no vacíos y ordenando cada segmento (es decir, elige k-1\npuntos de ruptura 1 <= x1 < x2 < ... < x(k-1) < n, y divídelo en [1, x1], (x1, x2], ..., (x(k-1), n]).\nEl resultado debe ser módulo 998244353.\n\n@example\nf_43(2, 1, [1, 2])\n// devuelve 2", "arb": "اكتب دالة JavaScript `const f_43 = (n, k, q) =>` لحل المشكلة التالية:\nبالنظر إلى ترتيب q من n عنصر وعدد صحيح k، ابحث عن عدد التباديل p من n عنصر\nبحيث يكون f(p) = q، حيث أن f(p) هو الترتيب المعجمي الأصغر الذي يمكن الحصول عليه عن طريق\nتقسيم p إلى k مقاطع متجاورة غير فارغة وترتيب كل مقطع (أي اختيار k-1\nنقاط توقف 1 <= x1 < x2 < ... < x(k-1) < n، وتقسيمها إلى [1, x1]، (x1, x2]، ...، (x(k-1), n]).\nيجب أن تكون النتيجة موديولو 998244353.\n\n@example\nf_43(2, 1, [1, 2])\n// يعيد 2", "sw": "Andika kazi ya JavaScript `const f_43 = (n, k, q) =>` kutatua tatizo lifuatalo:\nUkipiwa mpangilio q wa vipengele n na nambari kamili k, pata idadi ya mipangilio p ya vipengele n\nkama kwamba f(p) = q, ambapo f(p) ni mpangilio mdogo zaidi wa lexicographically ambao unaweza kupatikana kwa\nkugawanya p katika sehemu k zisizo tupu zinazofuatana na kupanga kila sehemu (yaani, chagua k-1\nalama za kuvunja 1 <= x1 < x2 < ... < x(k-1) < n, na igawanye katika [1, x1], (x1, x2], ..., (x(k-1), n]).\nMatokeo yanapaswa kuwa modulo 998244353.\n\n@example\nf_43(2, 1, [1, 2])\n// inarudisha 2", "tr": "Bir JavaScript fonksiyonu `const f_43 = (n, k, q) =>` yazın, aşağıdaki problemi çözmek için:\nn elemanlı bir q permütasyonu ve bir k tam sayısı verildiğinde, n elemanlı p permütasyonlarının sayısını bulun\nöyle ki f(p) = q, burada f(p), p'yi tam olarak k boş olmayan ardışık segmentlere bölerek ve her segmenti sıralayarak\nelde edilebilecek sözlük sırasına göre en küçük permütasyondur (yani, k-1 tane\n1 <= x1 < x2 < ... < x(k-1) < n kesme noktası seçin ve [1, x1], (x1, x2], ..., (x(k-1), n] olarak bölün).\nSonuç 998244353 ile mod alınmalıdır.\n\n@example\nf_43(2, 1, [1, 2])\n// 2 döndürür", "vi": "Viết một hàm JavaScript `const f_43 = (n, k, q) =>` để giải quyết vấn đề sau:  \nCho một hoán vị q của n phần tử và một số nguyên k, tìm số lượng hoán vị p của n phần tử sao cho f(p) = q, trong đó f(p) là hoán vị nhỏ nhất theo thứ tự từ điển có thể thu được bằng cách chia p thành chính xác k đoạn liên tiếp không rỗng và sắp xếp từng đoạn (tức là, chọn k-1 điểm ngắt 1 <= x1 < x2 < ... < x(k-1) < n, và chia thành [1, x1], (x1, x2], ..., (x(k-1), n]). Kết quả nên được lấy modulo 998244353.\n\n@example\nf_43(2, 1, [1, 2])\n// trả về 2", "id": "Tulis fungsi JavaScript `const f_43 = (n, k, q) =>` untuk menyelesaikan masalah berikut:\nDiberikan sebuah permutasi q dari n elemen dan sebuah bilangan bulat k, temukan jumlah permutasi p dari n elemen\nsehingga f(p) = q, di mana f(p) adalah permutasi terkecil secara leksikografis yang dapat diperoleh dengan\nmembagi p menjadi tepat k segmen kontigu yang tidak kosong dan mengurutkan setiap segmen (yaitu, pilih k-1\ntitik putus 1 <= x1 < x2 < ... < x(k-1) < n, dan bagi menjadi [1, x1], (x1, x2], ..., (x(k-1), n]).\nHasilnya harus dalam modulo 998244353.\n\n@example\nf_43(2, 1, [1, 2])\n// mengembalikan 2", "ja": "JavaScript関数`const f_43 = (n, k, q) =>`を作成して、次の問題を解決してください:\nn個の要素の順列qと整数kが与えられたとき、f(p) = qとなるn個の要素の順列pの数を求めます。ここで、f(p)は、pをちょうどk個の空でない連続したセグメントに分割し、各セグメントをソートすることによって得られる辞書式で最小の順列です（すなわち、1 <= x1 < x2 < ... < x(k-1) < nのk-1個のブレークポイントを選択し、[1, x1], (x1, x2], ..., (x(k-1), n]に分割します）。\n結果は998244353で割った余りとします。\n\n@example\nf_43(2, 1, [1, 2])\n// 2を返します", "ko": "JavaScript 함수를 작성하세요 `const f_43 = (n, k, q) =>` 다음 문제를 해결하기 위해:\nn 요소의 순열 q와 정수 k가 주어졌을 때, f(p) = q가 되는 n 요소의 순열 p의 개수를 찾으세요. 여기서 f(p)는 정확히 k개의 비어 있지 않은 연속 구간으로 나누고 각 구간을 정렬하여 얻을 수 있는 사전식으로 가장 작은 순열입니다 (즉, k-1개의 분할점 1 <= x1 < x2 < ... < x(k-1) < n을 선택하고, [1, x1], (x1, x2], ..., (x(k-1), n]으로 나눕니다). 결과는 998244353로 나눈 나머지가 되어야 합니다.\n\n@example\nf_43(2, 1, [1, 2])\n// 2를 반환합니다.", "ml": "`const f_43 = (n, k, q) =>` എന്ന ജാവാസ്ക്രിപ്റ്റ് ഫങ്ഷൻ എഴുതി താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കുക:\nn ഘടകങ്ങളുടെ ഒരു ക്രമവിന്യാസം qയും ഒരു പൂർണ്ണസംഖ്യ kയും നൽകിയാൽ, f(p) = q ആയ n ഘടകങ്ങളുടെ ക്രമവിന്യാസങ്ങളുടെ എണ്ണം കണ്ടെത്തുക, ഇവിടെ f(p) എന്നത് p കൃത്യമായി k ശൂന്യമല്ലാത്ത തുടർച്ചയായ വിഭാഗങ്ങളായി വിഭജിച്ച് ഓരോ വിഭാഗവും ക്രമീകരിച്ച് ലഭിക്കാവുന്ന ലെക്സികോഗ്രാഫിക്കായി ഏറ്റവും ചെറിയ ക്രമവിന്യാസമാണ് (അഥവാ, k-1 ബ്രേക്ക്പോയിന്റുകൾ 1 <= x1 < x2 < ... < x(k-1) < n തിരഞ്ഞെടുക്കുക, അത് [1, x1], (x1, x2], ..., (x(k-1), n] ആയി വിഭജിക്കുക). ഫലം 998244353 മൊഡുലോ ആയിരിക്കണം.\n\n@example\nf_43(2, 1, [1, 2])\n// 2 മടക്കുന്നു", "fa": "یک تابع جاوااسکریپت `const f_43 = (n, k, q) =>` بنویسید تا مسئله زیر را حل کند:\nبا توجه به یک جایگشت q از n عنصر و یک عدد صحیح k، تعداد جایگشت‌های p از n عنصر را پیدا کنید\nبه طوری که f(p) = q، که در آن f(p) کوچکترین جایگشت لغت‌نامه‌ای است که می‌توان با\nتقسیم p به طور دقیق به k قطعه متوالی غیر خالی و مرتب کردن هر قطعه به دست آورد (یعنی k-1\nنقطه شکست 1 <= x1 < x2 < ... < x(k-1) < n را انتخاب کنید و آن را به [1, x1]، (x1, x2]، ...، (x(k-1), n] تقسیم کنید).\nنتیجه باید به پیمانه 998244353 باشد.\n\n@example\nf_43(2, 1, [1, 2])\n// مقدار 2 را برمی‌گرداند"}, "level": "hard", "test": "console.assert(f_43(2, 1, [1, 2]) === 2, 'Test failed for input ([1, 2])');\nconsole.assert(f_43(3, 3, [3, 1, 2]) === 1, 'Test failed for input ([3, 1, 2])');\nconsole.assert(f_43(6, 3, [1, 2, 3, 6, 5, 4]) === 13, 'Test failed for input ([1, 2, 3, 6, 5, 4])');\nconsole.assert(f_43(6, 1, [1, 2, 3, 4, 5, 6]) === 720, 'Test failed for input ([1, 2, 3, 4, 5, 6])');\nconsole.assert(f_43(6, 3, [1, 2, 5, 3, 4, 5]) === 0, 'Test failed for input ([1, 2, 5, 3, 4, 5])');\nconsole.assert(f_43(9, 9, [1, 2, 3, 4, 5, 6, 7, 8, 9]) === 1, 'Test failed for input ([1, 2, 3, 4, 5, 6, 7, 8, 9])');\nconsole.assert(f_43(9, 2, [1, 2, 3, 4, 5, 6, 7, 9, 8]) === 29093);", "entry_point": "f_43", "signature": "const f_43 = (n, k, q) =>", "docstring": {"en": "Given a permutation q of n elements and an integer k, find the number of permutations p of n elements\n such that f(p) = q, where f(p) is the lexicographically smallest permutation that can be obtained by\n dividing p into exactly k non-empty contiguous segments and sorting each segment (i.e., choose k-1\n breakpoints 1 <= x1 < x2 < ... < x(k-1) < n, and divide it into [1, x1], (x1, x2], ..., (x(k-1), n]).\n The result should be modulo 998244353.\n\n @example\n f_43(2, 1, [1, 2])\n // returns 2\n", "sq": "Given një permutacion q të n elementeve dhe një numër të plotë k, gjeni numrin e permutacioneve p të n elementeve\n të tilla që f(p) = q, ku f(p) është permutacioni më i vogël leksikografik që mund të merret duke\n ndarë p në saktësisht k segmente të pandara dhe duke renditur secilin segment (d.m.th., zgjidhni k-1\n pika ndarjeje 1 <= x1 < x2 < ... < x(k-1) < n, dhe ndajeni atë në [1, x1], (x1, x2], ..., (x(k-1), n]).\n Rezultati duhet të jetë modulo 998244353.\n\n @shembull\n f_43(2, 1, [1, 2])\n // kthen 2", "hy": "Տրված է n տարրերի q փոխատեղումը և k ամբողջ թիվը, գտնել n տարրերի p փոխատեղումների քանակը, \nորոնց համար f(p) = q, որտեղ f(p)-ն ամենափոքր լեքսիկոգրաֆիկ փոխատեղումն է, որը կարելի է ստանալ p-ն \nճշգրիտ k չդատարկ հարակից հատվածների բաժանելով և յուրաքանչյուր հատվածը դասավորելով (այսինքն՝ ընտրել k-1 \nբեկման կետեր 1 <= x1 < x2 < ... < x(k-1) < n, և բաժանել այն [1, x1], (x1, x2], ..., (x(k-1), n]).\n Արդյունքը պետք է լինի 998244353 մոդուլով։\n\n @օրինակ\n f_43(2, 1, [1, 2])\n // վերադարձնում է 2", "bn": "একটি n উপাদানের পারমুটেশন q এবং একটি পূর্ণসংখ্যা k দেওয়া হয়েছে, n উপাদানের পারমুটেশন p-এর সংখ্যা খুঁজে বের করুন\nযেমন f(p) = q, যেখানে f(p) হল লেক্সিকোগ্রাফিকভাবে সবচেয়ে ছোট পারমুটেশন যা পাওয়া যেতে পারে\np-কে ঠিক kটি খালি নয় এমন ধারাবাহিক অংশে ভাগ করে এবং প্রতিটি অংশকে সাজিয়ে (অর্থাৎ, k-1টি\nব্রেকপয়েন্ট 1 <= x1 < x2 < ... < x(k-1) < n নির্বাচন করুন, এবং এটিকে [1, x1], (x1, x2], ..., (x(k-1), n]) ভাগ করুন।\nফলাফলটি 998244353 মডুলো হতে হবে।\n\n@example\nf_43(2, 1, [1, 2])\n// 2 ফেরত দেয়", "bg": "Дадена е пермутация q от n елемента и цяло число k, намерете броя на пермутациите p от n елемента, така че f(p) = q, където f(p) е лексикографски най-малката пермутация, която може да бъде получена чрез разделяне на p на точно k непразни съседни сегмента и сортиране на всеки сегмент (т.е. изберете k-1 точки на прекъсване 1 <= x1 < x2 < ... < x(k-1) < n, и го разделете на [1, x1], (x1, x2], ..., (x(k-1), n]). Резултатът трябва да бъде модуло 998244353.\n\n @пример\n f_43(2, 1, [1, 2])\n // връща 2", "zh": "给定一个 n 个元素的排列 q 和一个整数 k，找到 n 个元素的排列 p 的数量，使得 f(p) = q，其中 f(p) 是可以通过将 p 精确地划分为 k 个非空连续段并对每个段进行排序而获得的字典序最小的排列（即，选择 k-1 个断点 1 <= x1 < x2 < ... < x(k-1) < n，并将其划分为 [1, x1], (x1, x2], ..., (x(k-1), n]）。结果应取模 998244353。\n\n@example\nf_43(2, 1, [1, 2])\n// 返回 2", "fr": "Étant donné une permutation q de n éléments et un entier k, trouvez le nombre de permutations p de n éléments\n tel que f(p) = q, où f(p) est la permutation lexicographiquement la plus petite qui peut être obtenue en\n divisant p en exactement k segments contigus non vides et en triant chaque segment (c'est-à-dire, choisissez k-1\n points de rupture 1 <= x1 < x2 < ... < x(k-1) < n, et divisez-le en [1, x1], (x1, x2], ..., (x(k-1), n]).\n Le résultat doit être modulo 998244353.\n\n @exemple\n f_43(2, 1, [1, 2])\n // retourne 2", "de": "Gegeben eine Permutation q von n Elementen und eine ganze Zahl k, finde die Anzahl der Permutationen p von n Elementen,\nso dass f(p) = q, wobei f(p) die lexikographisch kleinste Permutation ist, die erhalten werden kann, indem\np in genau k nicht-leere zusammenhängende Segmente unterteilt und jedes Segment sortiert wird (d.h. wähle k-1\nTrennpunkte 1 <= x1 < x2 < ... < x(k-1) < n, und teile es in [1, x1], (x1, x2], ..., (x(k-1), n]).\nDas Ergebnis sollte modulo 998244353 sein.\n\n@example\nf_43(2, 1, [1, 2])\n// gibt 2 zurück", "ha": "An ba da permutation q na abubuwa n da kuma lamba k, gano yawan permutations p na abubuwa n\n irin wanda f(p) = q, inda f(p) shine mafi ƙarancin permutation a cikin tsari na lexicographically wanda za'a iya samu ta hanyar\n raba p zuwa daidai k sassa masu ci gaba ba tare da komai ba kuma tsara kowane sashe (wato, zaɓi k-1\n wuraren tsayawa 1 <= x1 < x2 < ... < x(k-1) < n, kuma raba shi zuwa [1, x1], (x1, x2], ..., (x(k-1), n]).\n Sakamakon ya kamata ya zama modulo 998244353.\n\n @misali\n f_43(2, 1, [1, 2])\n // ya dawo da 2", "hi": "दी गई n तत्वों की एक क्रमचय q और एक पूर्णांक k के लिए, n तत्वों की उन क्रमचयों की संख्या खोजें\nजिसके लिए f(p) = q, जहाँ f(p) वह शब्दकोश क्रम में सबसे छोटी क्रमचय है जो प्राप्त की जा सकती है\np को ठीक k गैर-खाली संलग्न खंडों में विभाजित करके और प्रत्येक खंड को क्रमबद्ध करके (अर्थात, k-1\nब्रेकपॉइंट चुनें 1 <= x1 < x2 < ... < x(k-1) < n, और इसे [1, x1], (x1, x2], ..., (x(k-1), n] में विभाजित करें)।\nपरिणाम 998244353 के मापांक में होना चाहिए।\n\n@example\nf_43(2, 1, [1, 2])\n// 2 लौटाता है", "hu": "Adott egy q permutáció n elemről és egy k egész szám, találja meg az n elemű p permutációk számát úgy, hogy f(p) = q, ahol f(p) a lexikográfiailag legkisebb permutáció, amelyet úgy lehet megkapni, hogy p-t pontosan k nem üres, összefüggő szegmensre osztjuk, és minden szegmenst sorba rendezünk (azaz válasszunk k-1 töréspontot 1 <= x1 < x2 < ... < x(k-1) < n, és osszuk fel [1, x1], (x1, x2], ..., (x(k-1), n] részekre). Az eredménynek 998244353-mal vett maradékát kell adni.\n\n @példa\n f_43(2, 1, [1, 2])\n // visszaadja: 2", "es": "Dada una permutación q de n elementos y un entero k, encuentra el número de permutaciones p de n elementos tal que f(p) = q, donde f(p) es la permutación lexicográficamente más pequeña que se puede obtener dividiendo p en exactamente k segmentos contiguos no vacíos y ordenando cada segmento (es decir, elige k-1 puntos de corte 1 <= x1 < x2 < ... < x(k-1) < n, y divídelo en [1, x1], (x1, x2], ..., (x(k-1), n]). El resultado debe ser módulo 998244353.\n\n @example\n f_43(2, 1, [1, 2])\n // devuelve 2", "arb": "بالنظر إلى تبديل q يحتوي على n من العناصر وعدد صحيح k، ابحث عن عدد التبديلات p التي تحتوي على n من العناصر بحيث أن f(p) = q، حيث أن f(p) هو التبديل الأصغر ترتيبًا لغويًا الذي يمكن الحصول عليه عن طريق تقسيم p إلى بالضبط k من المقاطع المتجاورة غير الفارغة وترتيب كل مقطع (أي اختيار k-1 من نقاط التقسيم 1 <= x1 < x2 < ... < x(k-1) < n، وتقسيمها إلى [1, x1]، (x1, x2]، ...، (x(k-1), n]). يجب أن تكون النتيجة مودولو 998244353.\n\n@example\nf_43(2, 1, [1, 2])\n// يعيد 2", "sw": "Ukipiwa mpangilio q wa vipengele n na nambari kamili k, pata idadi ya mipangilio p ya vipengele n\n kama f(p) = q, ambapo f(p) ni mpangilio mdogo kabisa wa lexicographically ambao unaweza kupatikana kwa\n kugawanya p katika sehemu k hasa zisizo tupu na kupanga kila sehemu (yaani, chagua k-1\n sehemu za kuvunja 1 <= x1 < x2 < ... < x(k-1) < n, na igawanye katika [1, x1], (x1, x2], ..., (x(k-1), n]).\n Matokeo yanapaswa kuwa modulo 998244353.\n\n @mfano\n f_43(2, 1, [1, 2])\n // inarudisha 2", "tr": "Verilen n elemanlı bir q permütasyonu ve bir k tam sayısı için, n elemanlı p permütasyonlarının sayısını bulun\n öyle ki f(p) = q, burada f(p), p'yi tam olarak k boş olmayan ardışık segmente bölerek ve her segmenti sıralayarak\n elde edilebilecek sözlük sırasına göre en küçük permütasyondur (yani, k-1 tane kırılma noktası seçin 1 <= x1 < x2 < ... < x(k-1) < n, ve [1, x1], (x1, x2], ..., (x(k-1), n] olarak bölün).\n Sonuç 998244353 ile mod alınmalıdır.\n\n @örnek\n f_43(2, 1, [1, 2])\n // 2 döndürür", "vi": "Cho một hoán vị q của n phần tử và một số nguyên k, tìm số lượng hoán vị p của n phần tử sao cho f(p) = q, trong đó f(p) là hoán vị nhỏ nhất theo thứ tự từ điển có thể thu được bằng cách chia p thành chính xác k đoạn liên tiếp không rỗng và sắp xếp từng đoạn (tức là, chọn k-1 điểm ngắt 1 <= x1 < x2 < ... < x(k-1) < n, và chia thành [1, x1], (x1, x2], ..., (x(k-1), n]). Kết quả nên được lấy modulo 998244353.\n\n@example\nf_43(2, 1, [1, 2])\n// trả về 2", "id": "Diberikan sebuah permutasi q dari n elemen dan sebuah bilangan bulat k, temukan jumlah permutasi p dari n elemen sedemikian sehingga f(p) = q, di mana f(p) adalah permutasi terkecil secara leksikografis yang dapat diperoleh dengan membagi p menjadi tepat k segmen kontigu yang tidak kosong dan mengurutkan setiap segmen (yaitu, pilih k-1 titik putus 1 <= x1 < x2 < ... < x(k-1) < n, dan bagi menjadi [1, x1], (x1, x2], ..., (x(k-1), n]). Hasilnya harus dalam modulo 998244353.\n\n@example\nf_43(2, 1, [1, 2])\n// mengembalikan 2", "ja": "与えられたn要素の順列qと整数kに対して、f(p) = qとなるn要素の順列pの数を求めます。ここで、f(p)は、pを正確にk個の空でない連続したセグメントに分割し、各セグメントをソートすることによって得られる辞書順で最小の順列です（すなわち、1 <= x1 < x2 < ... < x(k-1) < nのk-1個のブレークポイントを選び、それを[1, x1], (x1, x2], ..., (x(k-1), n]に分割します）。結果は998244353でのモジュロとします。\n\n@example\nf_43(2, 1, [1, 2])\n// 2を返します", "ko": "주어진 n 요소의 순열 q와 정수 k가 주어졌을 때, n 요소의 순열 p의 수를 찾으시오. 여기서 f(p) = q이고, f(p)는 p를 정확히 k개의 비어 있지 않은 연속 구간으로 나누고 각 구간을 정렬하여 얻을 수 있는 사전식으로 가장 작은 순열입니다 (즉, k-1개의 분할점을 선택하여 1 <= x1 < x2 < ... < x(k-1) < n, 그리고 [1, x1], (x1, x2], ..., (x(k-1), n]으로 나눕니다). 결과는 998244353로 나눈 나머지가 되어야 합니다.\n\n @예시\n f_43(2, 1, [1, 2])\n // 2를 반환합니다.", "ml": "n ഘടകങ്ങളുടെ ഒരു permutation q ഉം ഒരു പൂർണ്ണസംഖ്യ k ഉം നൽകിയാൽ, n ഘടകങ്ങളുടെ permutation p കളുടെ എണ്ണം കണ്ടെത്തുക\n * f(p) = q ആയിരിക്കുക, f(p) എന്നത് p നെ കൃത്യമായി k ശൂന്യമല്ലാത്ത തുടർച്ചയായ വിഭാഗങ്ങളായി വിഭജിച്ച് ഓരോ വിഭാഗവും ക്രമീകരിച്ച് ലഭിക്കാവുന്ന\n * ലെക്സികോഗ്രാഫിക്‌ ആയി ഏറ്റവും ചെറിയ permutation ആണ് (അഥവാ, k-1\n * ബ്രേക്ക്പോയിന്റുകൾ 1 <= x1 < x2 < ... < x(k-1) < n തിരഞ്ഞെടുക്കുക, [1, x1], (x1, x2], ..., (x(k-1), n] ആയി വിഭജിക്കുക).\n * ഫലം 998244353 ന്റെ മോഡുലോ ആയിരിക്കണം.\n\nഒരു n ഘടകങ്ങളുടെ ക്രമവിന്യാസവും ഒരു പൂർണ്ണസംഖ്യ kയും നൽകിയാൽ, f(p) = q ആയ n ഘടകങ്ങളുടെ ക്രമവിന്യാസങ്ങളുടെ എണ്ണം കണ്ടെത്തുക, f(p) എന്നത് p കൃത്യമായി k ശൂന്യമല്ലാത്ത തുടർച്ചയായ വിഭാഗങ്ങളായി വിഭജിച്ച് ഓരോ വിഭാഗവും ക്രമീകരിച്ച് ലഭിക്കാവുന്ന ലെക്സിക്കോഗ്രാഫിക്‌ ആയി ഏറ്റവും ചെറിയ ക്രമവിന്യാസമാണ് (അഥവാ, k-1 ബ്രേക്ക്‌പോയിന്റുകൾ തിരഞ്ഞെടുക്കുക 1 <= x1 < x2 < ... < x(k-1) < n, അതിനെ [1, x1], (x1, x2], ..., (x(k-1), n] ആയി വിഭജിക്കുക). ഫലം 998244353 മോദുലോ ആയിരിക്കണം.\n\n@example\nf_43(2, 1, [1, 2])\n// 2 മടക്കുന്നു", "fa": "با توجه به جایگشت q از n عنصر و یک عدد صحیح k، تعداد جایگشت‌های p از n عنصر را پیدا کنید\n به طوری که f(p) = q، که در آن f(p) کوچکترین جایگشت لغت‌نامه‌ای است که می‌توان با\n تقسیم p به دقیقاً k بخش متوالی غیر خالی و مرتب‌سازی هر بخش به دست آورد (یعنی k-1\n نقاط شکست را انتخاب کنید 1 <= x1 < x2 < ... < x(k-1) < n، و آن را به [1, x1]، (x1, x2]، ...، (x(k-1), n] تقسیم کنید).\n نتیجه باید به صورت مدولوی 998244353 باشد.\n\n @مثال\n f_43(2, 1, [1, 2])\n // 2 را برمی‌گرداند"}}
{"task_id": "JavaScript/44", "prompt": {"en": "/**\n * Determines the number of ways to choose a triplet (a, b, c) \n * from an array of distinct integers representing heights such that the \n * greatest common divisor (GCD) of the maximum and minimum values \n * of the triplet is 1.\n * \n * @example\n * f_44([1, 5, 7])\n * // Returns: 1\n */\nfunction f_44(heights)", "sq": "/**\n * Përcakton numrin e mënyrave për të zgjedhur një treshe (a, b, c) \n * nga një varg i numrave të plotë të ndryshëm që përfaqësojnë lartësitë në mënyrë të tillë që \n * faktori më i madh i përbashkët (GCD) i vlerave maksimale dhe minimale \n * të treshes është 1.\n * \n * @example\n * f_44([1, 5, 7])\n * // Kthen: 1\n */\nfunction f_44(heights)", "hy": "/**\n * Սահմանում է, թե քանի եղանակով կարելի է ընտրել եռյակ (a, b, c) \n * տարբեր բարձրություններ ներկայացնող ամբողջ թվերի զանգվածից այնպես, որ \n * եռյակի առավելագույն և նվազագույն արժեքների \n * ամենամեծ ընդհանուր բաժանարարը (GCD) լինի 1:\n * \n * @example\n * f_44([1, 5, 7])\n * // Վերադարձնում է: 1\n */\nfunction f_44(heights)", "bn": "/**\n * একটি অ্যারের ভিন্ন পূর্ণসংখ্যা যা উচ্চতাকে উপস্থাপন করে সেখান থেকে \n * একটি ত্রয়ী (a, b, c) নির্বাচন করার উপায়ের সংখ্যা নির্ধারণ করে \n * যাতে ত্রয়ীর সর্বাধিক এবং সর্বনিম্ন মানের \n * গ্রেটেস্ট কমন ডিভাইসর (GCD) হয় 1।\n * \n * @example\n * f_44([1, 5, 7])\n * // Returns: 1\n */\nfunction f_44(heights)", "bg": "/**\n * Определя броя начини за избор на тройка (a, b, c) \n * от масив от различни цели числа, представляващи височини, така че \n * най-големият общ делител (НОД) на максималната и минималната стойност \n * на тройката да е 1.\n * \n * @example\n * f_44([1, 5, 7])\n * // Връща: 1\n */\nfunction f_44(heights)", "zh": "/**\n * 确定从表示高度的不同整数数组中选择三元组 (a, b, c) 的方法数，\n * 使得该三元组的最大值和最小值的最大公约数 (GCD) 为 1。\n * \n * @example\n * f_44([1, 5, 7])\n * // 返回: 1\n */\nfunction f_44(heights)", "fr": "/**\n * Détermine le nombre de façons de choisir un triplet (a, b, c) \n * à partir d'un tableau d'entiers distincts représentant des hauteurs tel que le \n * plus grand commun diviseur (PGCD) des valeurs maximale et minimale \n * du triplet soit 1.\n * \n * @example\n * f_44([1, 5, 7])\n * // Retourne : 1\n */\nfunction f_44(heights)", "de": "/**\n * Bestimmt die Anzahl der Möglichkeiten, ein Tripel (a, b, c) \n * aus einem Array von verschiedenen ganzen Zahlen, die Höhen darstellen, \n * so auszuwählen, dass der größte gemeinsame Teiler (GCD) der maximalen \n * und minimalen Werte des Tripels 1 ist.\n * \n * @example\n * f_44([1, 5, 7])\n * // Gibt zurück: 1\n */\nfunction f_44(heights)", "ha": "/**\n * Yana tantance yawan hanyoyin zaɓar triplet (a, b, c)\n * daga jerin lambobi daban-daban da ke wakiltar tsayi ta yadda\n * babbar mai raba kowa da kowa (GCD) na mafi girma da mafi ƙarancin ƙima\n * na triplet ɗin shine 1.\n * \n * @misali\n * f_44([1, 5, 7])\n * // Yana dawowa: 1\n */\nfunction f_44(heights)", "hi": "/**\n * एक त्रिक (a, b, c) को चुनने के तरीकों की संख्या निर्धारित करता है \n * जो ऊँचाइयों का प्रतिनिधित्व करने वाले भिन्न पूर्णांकों की एक सरणी से है, \n * ताकि त्रिक के अधिकतम और न्यूनतम मानों का महत्तम समापवर्तक (GCD) 1 हो।\n * \n * @example\n * f_44([1, 5, 7])\n * // Returns: 1\n */\nfunction f_44(heights)", "hu": "/**\n * Meghatározza, hogy hányféleképpen lehet kiválasztani egy hármas (a, b, c) \n * különböző egész számokat tartalmazó tömbből, amelyek magasságokat jelképeznek, úgy, hogy a \n * hármas maximumának és minimumának legnagyobb közös osztója (GCD) 1 legyen.\n * \n * @példa\n * f_44([1, 5, 7])\n * // Visszatér: 1\n */\nfunction f_44(heights)", "es": "/**\n * Determina el número de maneras de elegir un triplete (a, b, c) \n * de un arreglo de enteros distintos que representan alturas tal que el \n * máximo común divisor (MCD) de los valores máximo y mínimo \n * del triplete sea 1.\n * \n * @example\n * f_44([1, 5, 7])\n * // Devuelve: 1\n */\nfunction f_44(heights)", "arb": "/**\n * يحدد عدد الطرق لاختيار ثلاثية (a, b, c) \n * من مصفوفة من الأعداد الصحيحة المميزة التي تمثل الارتفاعات بحيث يكون \n * القاسم المشترك الأكبر (GCD) للقيمتين العظمى والصغرى \n * للثلاثية هو 1.\n * \n * @example\n * f_44([1, 5, 7])\n * // يعيد: 1\n */\nfunction f_44(heights)", "sw": "/**\n * Huamua idadi ya njia za kuchagua tatu (a, b, c) \n * kutoka kwenye safu ya nambari tofauti zinazoashiria urefu ili kwamba \n * mgawanyiko mkuu wa kawaida (GCD) wa thamani ya juu na ya chini \n * ya tatu ni 1.\n * \n * @example\n * f_44([1, 5, 7])\n * // Inarudisha: 1\n */\nfunction f_44(heights)", "tr": "/**\n * Bir dizideki farklı tamsayıları temsil eden yüksekliklerden \n * (a, b, c) üçlüsünü seçmenin yollarını belirler, \n * bu üçlünün maksimum ve minimum değerlerinin \n * en büyük ortak böleni (GCD) 1 olacak şekilde.\n * \n * @example\n * f_44([1, 5, 7])\n * // Döndürür: 1\n */\nfunction f_44(heights)", "vi": "/**\n * Xác định số cách chọn một bộ ba (a, b, c) \n * từ một mảng các số nguyên khác nhau đại diện cho chiều cao sao cho \n * ước số chung lớn nhất (GCD) của giá trị lớn nhất và nhỏ nhất \n * của bộ ba là 1.\n * \n * @example\n * f_44([1, 5, 7])\n * // Trả về: 1\n */\nfunction f_44(heights)", "id": "/**\n * Menentukan jumlah cara untuk memilih triplet (a, b, c) \n * dari array bilangan bulat berbeda yang mewakili tinggi sehingga \n * faktor persekutuan terbesar (FPB) dari nilai maksimum dan minimum \n * dari triplet adalah 1.\n * \n * @example\n * f_44([1, 5, 7])\n * // Mengembalikan: 1\n */\nfunction f_44(heights)", "ja": "/**\n * 配列内の異なる整数を表す高さから三つ組 (a, b, c) を選ぶ方法の数を決定します。\n * このとき、三つ組の最大値と最小値の最大公約数 (GCD) が1である必要があります。\n * \n * @example\n * f_44([1, 5, 7])\n * // 戻り値: 1\n */\nfunction f_44(heights)", "ko": "/**\n * 배열의 서로 다른 정수로 구성된 높이에서 최대값과 최소값의 최대 공약수(GCD)가 1인 \n * 삼중항 (a, b, c)을 선택하는 방법의 수를 결정합니다.\n * \n * @example\n * f_44([1, 5, 7])\n * // 반환값: 1\n */\nfunction f_44(heights)", "ml": "/**\n * ഒരു ത്രിപ്ലെറ്റ് (a, b, c) തിരഞ്ഞെടുക്കാനുള്ള മാർഗങ്ങളുടെ എണ്ണം \n * വ്യത്യസ്തമായ മുഴുവൻ സംഖ്യകളുടെ ഒരു നിരയിൽ നിന്ന് ഉയരങ്ങൾ പ്രതിനിധീകരിക്കുന്നതും \n * ത്രിപ്ലെറ്റിന്റെ പരമാവധി, കുറഞ്ഞ മൂല്യങ്ങളുടെ \n * മഹത്തായ പൊതുഹരവും (GCD) 1 ആകുന്നതുമായ രീതിയിൽ നിർണ്ണയിക്കുന്നു.\n * \n * @example\n * f_44([1, 5, 7])\n * // Returns: 1\n */\nfunction f_44(heights)", "fa": "/**\n * تعیین می‌کند که چند روش برای انتخاب یک سه‌تایی (a, b, c) \n * از یک آرایه از اعداد صحیح متمایز که ارتفاع‌ها را نشان می‌دهند وجود دارد به طوری که \n * بزرگترین مقسوم‌علیه مشترک (GCD) مقادیر حداکثر و حداقل \n * سه‌تایی برابر با 1 باشد.\n * \n * @example\n * f_44([1, 5, 7])\n * // بازگشت: 1\n */\nfunction f_44(heights)"}, "canonical_solution": "{\n    let count = 0;\n    const n = heights.length;\n    for (let i = 0; i < n; ++i) {\n        for (let j = i + 1; j < n; ++j) {\n            for (let k = j + 1; k < n; ++k) {\n                const minVal = Math.min(heights[i], heights[j], heights[k]);\n                const maxVal = Math.max(heights[i], heights[j], heights[k]);\n                if (gcd(minVal, maxVal) === 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\n// Helper function to find the greatest common divisor\nfunction gcd(a, b) {\n    while (b !== 0) {\n        let t = b;\n        b = a % b;\n        a = t;\n    }\n    return a;\n}", "instruction": {"en": "Write a JavaScript function `function f_44(heights)` to solve the following problem:\nDetermines the number of ways to choose a triplet (a, b, c) from an array of distinct integers representing heights such that the greatest common divisor (GCD) of the maximum and minimum values of the triplet is 1.\n\n@example\nf_44([1, 5, 7])\n// Returns: 1\n", "sq": "Shkruani një funksion JavaScript `function f_44(heights)` për të zgjidhur problemin në vijim:  \nPërcakton numrin e mënyrave për të zgjedhur një treshe (a, b, c) nga një varg i numrave të plotë të ndryshëm që përfaqësojnë lartësitë, në mënyrë që faktori më i madh i përbashkët (GCD) i vlerave maksimale dhe minimale të tresheve të jetë 1.", "hy": "Գրեք JavaScript ֆունկցիա `function f_44(heights)` հետևյալ խնդիրը լուծելու համար:\nՈրոշում է եղանակների քանակը, թե ինչպես ընտրել եռյակ (a, b, c) տարբեր ամբողջ թվերի զանգվածից, որոնք ներկայացնում են բարձրությունները, այնպես, որ եռյակի առավելագույն և նվազագույն արժեքների ամենամեծ ընդհանուր բաժանարարը (GCD) լինի 1:\n\n@example\nf_44([1, 5, 7])\n// Վերադարձնում է: 1", "bn": "একটি জাভাস্ক্রিপ্ট ফাংশন `function f_44(heights)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি পৃথক পূর্ণসংখ্যার অ্যারের থেকে একটি ত্রয়ী (a, b, c) বেছে নেওয়ার উপায়ের সংখ্যা নির্ধারণ করে যা উচ্চতা উপস্থাপন করে যাতে ত্রয়ীর সর্বাধিক এবং সর্বনিম্ন মানের গ্রেটেস্ট কমন ডিভাইসর (GCD) হয় 1।\n\n@example\nf_44([1, 5, 7])\n// Returns: 1", "bg": "Напишете JavaScript функция `function f_44(heights)`, за да решите следния проблем:  \nОпределя броя на начините за избор на тройка (a, b, c) от масив от различни цели числа, представляващи височини, така че най-големият общ делител (НОД) на максималните и минималните стойности на тройката да е 1.\n\n@example\nf_44([1, 5, 7])\n// Връща: 1", "zh": "编写一个 JavaScript 函数 `function f_44(heights)` 来解决以下问题：  \n确定从表示高度的不同整数数组中选择三元组 (a, b, c) 的方法数，使得该三元组的最大值和最小值的最大公约数 (GCD) 为 1。  \n\n@example  \nf_44([1, 5, 7])  \n// 返回: 1  ", "fr": "Écrire une fonction JavaScript `function f_44(heights)` pour résoudre le problème suivant :  \nDétermine le nombre de façons de choisir un triplet (a, b, c) à partir d'un tableau d'entiers distincts représentant des hauteurs, de sorte que le plus grand commun diviseur (PGCD) des valeurs maximale et minimale du triplet soit 1.\n\n@example\nf_44([1, 5, 7])\n// Renvoie : 1", "de": "Schreiben Sie eine JavaScript-Funktion `function f_44(heights)`, um das folgende Problem zu lösen:\nBestimmt die Anzahl der Möglichkeiten, ein Tripel (a, b, c) aus einem Array von verschiedenen ganzen Zahlen, die Höhen darstellen, so zu wählen, dass der größte gemeinsame Teiler (GCD) der maximalen und minimalen Werte des Tripels 1 ist.\n\n@example\nf_44([1, 5, 7])\n// Gibt zurück: 1", "ha": "Rubuta aikin JavaScript `function f_44(heights)` don warware matsalar mai zuwa:  \nYana tantance yawan hanyoyin zaɓar triplet (a, b, c) daga jerin lambobi daban-daban da ke wakiltar tsayi ta yadda mafi girman abin raba da ke tsakanin mafi girma da mafi ƙanƙanta na triplet ɗin zai zama 1.\n\n@example\nf_44([1, 5, 7])\n// Returns: 1", "hi": "JavaScript फ़ंक्शन `function f_44(heights)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nयह निर्धारित करता है कि एक अद्वितीय पूर्णांकों की array से (a, b, c) त्रिक को चुनने के कितने तरीके हैं जो ऊँचाइयों का प्रतिनिधित्व करते हैं ताकि त्रिक के अधिकतम और न्यूनतम मानों का महत्तम समापवर्तक (GCD) 1 हो।\n\n@example\nf_44([1, 5, 7])\n// Returns: 1", "hu": "Írj egy JavaScript függvényt `function f_44(heights)`, hogy megoldja a következő problémát:  \nMeghatározza, hányféleképpen lehet választani egy hármas (a, b, c) egy tömbből, amely különböző egész számokat tartalmaz, amelyek magasságokat képviselnek, úgy hogy a hármas maximális és minimális értékeinek legnagyobb közös osztója (GCD) 1 legyen.\n\n@example\nf_44([1, 5, 7])\n// Visszatér: 1", "es": "Escribe una función de JavaScript `function f_44(heights)` para resolver el siguiente problema:\nDetermina el número de formas de elegir un triplete (a, b, c) de un arreglo de enteros distintos que representan alturas, tal que el máximo común divisor (GCD) de los valores máximo y mínimo del triplete sea 1.\n\n@example\nf_44([1, 5, 7])\n// Devuelve: 1", "arb": "اكتب دالة JavaScript `function f_44(heights)` لحل المشكلة التالية:\nتحديد عدد الطرق لاختيار ثلاثية (a, b, c) من مصفوفة من الأعداد الصحيحة المميزة التي تمثل الارتفاعات بحيث يكون القاسم المشترك الأكبر (GCD) للقيمتين العظمى والصغرى للثلاثية هو 1.\n\n@example\nf_44([1, 5, 7])\n// يعيد: 1", "sw": "Andika kazi ya JavaScript `function f_44(heights)` kutatua tatizo lifuatalo:  \nInabainisha idadi ya njia za kuchagua tatu (a, b, c) kutoka kwenye safu ya nambari tofauti zinazoashiria urefu ili kwamba mgawanyiko mkuu wa juu zaidi (GCD) wa thamani za juu na za chini za tatu hiyo ni 1.\n\n@example\nf_44([1, 5, 7])\n// Inarudisha: 1", "tr": "Bir JavaScript fonksiyonu `function f_44(heights)` yazın ve aşağıdaki problemi çözün:\nBir dizi farklı tamsayıdan yükseklikleri temsil eden bir üçlü (a, b, c) seçmenin kaç yolu olduğunu belirler, böylece üçlünün maksimum ve minimum değerlerinin en büyük ortak böleni (GCD) 1 olur.\n\n@example\nf_44([1, 5, 7])\n// Döndürür: 1", "vi": "Viết một hàm JavaScript `function f_44(heights)` để giải quyết vấn đề sau:  \nXác định số cách chọn một bộ ba (a, b, c) từ một mảng các số nguyên khác nhau đại diện cho chiều cao sao cho ước số chung lớn nhất (GCD) của giá trị lớn nhất và nhỏ nhất của bộ ba là 1.\n\n@example\nf_44([1, 5, 7])\n// Trả về: 1", "id": "Tulis sebuah fungsi JavaScript `function f_44(heights)` untuk menyelesaikan masalah berikut:\nMenentukan jumlah cara untuk memilih triplet (a, b, c) dari sebuah array bilangan bulat yang berbeda yang mewakili tinggi sehingga pembagi terbesar (GCD) dari nilai maksimum dan minimum dari triplet adalah 1.\n\n@example\nf_44([1, 5, 7])\n// Mengembalikan: 1", "ja": "JavaScript関数 `function f_44(heights)` を作成して、次の問題を解決してください:\n異なる整数の配列で高さを表すものから三つ組 (a, b, c) を選ぶ方法の数を決定します。その際、三つ組の最大値と最小値の最大公約数 (GCD) が1であること。\n\n@example\nf_44([1, 5, 7])\n// Returns: 1", "ko": "JavaScript 함수 `function f_44(heights)`를 작성하여 다음 문제를 해결하십시오:  \n서로 다른 정수로 구성된 배열에서 높이를 나타내는 세 개의 요소 (a, b, c)를 선택하는 방법의 수를 결정합니다. 이때, 선택된 세 요소 중 최대값과 최소값의 최대공약수(GCD)가 1이어야 합니다.\n\n@example\nf_44([1, 5, 7])\n// 반환값: 1", "ml": "`function f_44(heights)` എന്ന ജാവാസ്ക്രിപ്റ്റ് ഫങ്ഷൻ എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nഒരു ട്രിപ്പ്ലെറ്റ് (a, b, c) തിരഞ്ഞെടുക്കാനുള്ള മാർഗങ്ങളുടെ എണ്ണം നിർണ്ണയിക്കുന്നു, അതായത് ഉയരങ്ങൾ പ്രതിനിധീകരിക്കുന്ന വ്യത്യസ്തമായ പൂർണ്ണസംഖ്യകളുടെ ഒരു നിരയിൽ നിന്ന്, ട്രിപ്പ്ലെറ്റിന്റെ പരമാവധി, കുറഞ്ഞ മൂല്യങ്ങളുടെ ഏറ്റവും വലിയ പൊതുഹരസ്പദം (GCD) 1 ആകുന്ന വിധത്തിൽ.\n\n@example\nf_44([1, 5, 7])\n// Returns: 1", "fa": "یک تابع جاوااسکریپت `function f_44(heights)` بنویسید تا مسئله زیر را حل کند:\nتعداد روش‌های انتخاب یک سه‌تایی (a, b, c) از یک آرایه از اعداد صحیح متمایز که نمایانگر ارتفاع‌ها هستند را تعیین می‌کند به طوری که بزرگترین مقسوم‌علیه مشترک (GCD) مقادیر حداکثر و حداقل سه‌تایی برابر با 1 باشد.\n\n@example\nf_44([1, 5, 7])\n// بازمی‌گرداند: 1"}, "level": "hard", "test": "const main = () => {\n    console.assert(f_44([1, 5, 7]) === 1);\n    console.assert(f_44([1, 6, 2, 3]) === 3);\n    console.assert(f_44([16, 4, 8, 2]) === 0);\n    console.assert(f_44([10, 1, 6, 7, 9, 8, 4, 3, 5, 2]) === 77);\n    console.assert(f_44([4, 5, 9, 11, 14]) === 7);\n    console.assert(f_44([15, 10, 6, 9, 7, 3, 12, 8, 11, 1, 2]) === 104);\n    console.assert(f_44([3, 7, 11, 13]) === 4);\n    console.assert(f_44([5, 12, 13, 17, 19]) === 10);\n    console.assert(f_44([2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]) === 87);\n    console.assert(f_44([1, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17]) === 122);\n}\n\nmain();", "entry_point": "f_44", "signature": "function f_44(heights)", "docstring": {"en": "Determines the number of ways to choose a triplet (a, b, c) from an array of distinct integers representing heights such that the greatest common divisor (GCD) of the maximum and minimum values of the triplet is 1.\n\n@example\nf_44([1, 5, 7])\n// Returns: 1\n", "sq": "Përcakton numrin e mënyrave për të zgjedhur një treshe (a, b, c) nga një varg i numrave të plotë të ndryshëm që përfaqësojnë lartësitë në mënyrë të tillë që faktori më i madh i përbashkët (GCD) i vlerave maksimale dhe minimale të treshes është 1.\n\n@example\nf_44([1, 5, 7])\n// Kthen: 1", "hy": "Սահմանում է, թե քանի եղանակով կարելի է ընտրել եռյակ (a, b, c) տարբեր ամբողջ թվերից կազմված զանգվածից, որոնք ներկայացնում են բարձրությունները այնպես, որ եռյակի առավելագույն և նվազագույն արժեքների ամենամեծ ընդհանուր բաժանարարը (GCD) լինի 1:\n\n@example\nf_44([1, 5, 7])\n// Վերադարձնում է: 1", "bn": "একটি পৃথক পূর্ণসংখ্যার অ্যারের থেকে একটি ত্রয়ী (a, b, c) বেছে নেওয়ার উপায়ের সংখ্যা নির্ধারণ করে যা উচ্চতা উপস্থাপন করে যাতে ত্রয়ীর সর্বাধিক এবং সর্বনিম্ন মানের গ্রেটেস্ট কমন ডিভাইসর (GCD) হয় 1।\n\n@example\nf_44([1, 5, 7])\n// ফেরত দেয়: 1", "bg": "Определя броя на начините за избор на тройка (a, b, c) от масив от различни цели числа, представляващи височини, така че най-големият общ делител (НОД) на максималната и минималната стойност на тройката да е 1.\n\n@example\nf_44([1, 5, 7])\n// Връща: 1", "zh": "确定从一个表示高度的不同整数数组中选择一个三元组 (a, b, c) 的方法数，使得该三元组的最大值和最小值的最大公约数 (GCD) 为 1。\n\n@example\nf_44([1, 5, 7])\n// 返回: 1", "fr": "Détermine le nombre de façons de choisir un triplet (a, b, c) à partir d'un tableau d'entiers distincts représentant des hauteurs, de sorte que le plus grand commun diviseur (PGCD) des valeurs maximale et minimale du triplet soit 1.\n\n@example\nf_44([1, 5, 7])\n// Renvoie : 1", "de": "Bestimmt die Anzahl der Möglichkeiten, ein Tripel (a, b, c) aus einem Array von verschiedenen ganzen Zahlen zu wählen, die Höhen darstellen, sodass der größte gemeinsame Teiler (GGT) der maximalen und minimalen Werte des Tripels 1 ist.\n\n@example\nf_44([1, 5, 7])\n// Gibt zurück: 1", "ha": "Yana ƙayyade yawan hanyoyin zaɓar triplet (a, b, c) daga wani tsari na lambobi daban-daban masu wakiltar tsawo ta yadda babban raba mai haɗin kai (GCD) na mafi girma da ƙananan ƙimar triplet ɗin shine 1.\n\n@example\nf_44([1, 5, 7])\n// Returns: 1", "hi": "त्रयक (a, b, c) चुनने के तरीकों की संख्या निर्धारित करता है जो ऊँचाइयों का प्रतिनिधित्व करने वाले भिन्न पूर्णांकों के एक सरणी से होते हैं ताकि त्रयक के अधिकतम और न्यूनतम मानों का महत्तम समापवर्तक (GCD) 1 हो।\n\n@example\nf_44([1, 5, 7])\n// लौटाता है: 1", "hu": "Meghatározza, hogy hányféleképpen lehet kiválasztani egy (a, b, c) hármast egy különböző egész számokat tartalmazó tömbből, amelyek magasságokat képviselnek, úgy, hogy a hármas maximális és minimális értékeinek legnagyobb közös osztója (GCD) 1 legyen.\n\n@example\nf_44([1, 5, 7])\n// Visszatér: 1", "es": "Determina el número de maneras de elegir un triplete (a, b, c) de un arreglo de enteros distintos que representan alturas tal que el máximo común divisor (MCD) de los valores máximo y mínimo del triplete sea 1.\n\n@example\nf_44([1, 5, 7])\n// Devuelve: 1", "arb": "يحدد عدد الطرق لاختيار ثلاثية (a, b, c) من مصفوفة من الأعداد الصحيحة المختلفة التي تمثل الارتفاعات بحيث يكون القاسم المشترك الأكبر (GCD) للقيمتين العظمى والصغرى للثلاثية هو 1.\n\n@example\nf_44([1, 5, 7])\n// يعيد: 1", "sw": "Inabainisha idadi ya njia za kuchagua tatu (a, b, c) kutoka kwenye safu ya nambari tofauti zinazoashiria urefu ili kwamba mgawanyiko mkuu wa juu (GCD) wa thamani ya juu na ya chini ya tatu hiyo ni 1.\n\n@example\nf_44([1, 5, 7])\n// Inarejesha: 1", "tr": "Belirli yükseklikleri temsil eden farklı tamsayıların bulunduğu bir diziden bir üçlü (a, b, c) seçmenin kaç yolu olduğunu belirler, öyle ki üçlünün maksimum ve minimum değerlerinin en büyük ortak böleni (EBOB) 1'dir.\n\n@example\nf_44([1, 5, 7])\n// Döndürür: 1", "vi": "Xác định số cách để chọn một bộ ba (a, b, c) từ một mảng các số nguyên khác nhau đại diện cho chiều cao sao cho ước số chung lớn nhất (GCD) của giá trị lớn nhất và nhỏ nhất của bộ ba là 1.\n\n@example\nf_44([1, 5, 7])\n// Trả về: 1", "id": "Menentukan jumlah cara untuk memilih triplet (a, b, c) dari sebuah array bilangan bulat yang berbeda yang mewakili tinggi sehingga pembagi persekutuan terbesar (GCD) dari nilai maksimum dan minimum dari triplet adalah 1.\n\n@example\nf_44([1, 5, 7])\n// Mengembalikan: 1", "ja": "数列から高さを表す異なる整数のトリプレット (a, b, c) を選ぶ方法の数を決定します。このとき、トリプレットの最大値と最小値の最大公約数 (GCD) が1である必要があります。\n\n@example\nf_44([1, 5, 7])\n// 戻り値: 1", "ko": "배열에서 높이를 나타내는 서로 다른 정수들로부터 삼중항 (a, b, c)를 선택하는 방법의 수를 결정합니다. 이때 삼중항의 최대값과 최소값의 최대공약수(GCD)가 1이 되어야 합니다.\n\n@example\nf_44([1, 5, 7])\n// 반환: 1", "ml": "ആകൃതിയിലുള്ള വ്യത്യസ്തമായ മുഴക്കങ്ങളെ പ്രതിനിധീകരിക്കുന്ന ഒരു നിരയിൽ നിന്ന് ഒരു ത്രയീകം (a, b, c) തിരഞ്ഞെടുക്കാനുള്ള മാർഗങ്ങളുടെ എണ്ണം നിർണ്ണയിക്കുന്നു, അങ്ങനെ ത്രയീകത്തിന്റെ പരമാവധി, കുറഞ്ഞ മൂല്യങ്ങളുടെ മഹത്തായ പൊതുവായ ഗുണകം (GCD) 1 ആണ്.\n\n@example\nf_44([1, 5, 7])\n// Returns: 1", "fa": "تعداد روش‌های انتخاب یک سه‌تایی (a, b, c) از یک آرایه از اعداد صحیح متمایز که ارتفاع‌ها را نشان می‌دهند، به طوری که بزرگترین مقسوم‌علیه مشترک (GCD) مقادیر حداکثر و حداقل سه‌تایی برابر با 1 باشد، تعیین می‌کند.\n\n@example\nf_44([1, 5, 7])\n// بازمی‌گرداند: 1"}}
{"task_id": "JavaScript/45", "prompt": {"en": "/**\n * Given a 1 by n pixel image, each pixel has a color represented by an integer. You can change all \n * connected pixels of the same color to a chosen color, where two pixels are connected if they are \n * adjacent and have the same color. The goal is to find the minimum number of operations required \n * to make all pixels the same color.\n * Note: For each color, there are at most 20 pixels of that color.\n * \n * Examples:\n *    extraNumber(5, [1, 2, 3, 2, 1]) returns 2\n */\nfunction f_45(n, pixels)", "sq": "/**\n * Duke pasur një imazh 1 me n piksel, secili piksel ka një ngjyrë të përfaqësuar nga një numër i plotë. Ju mund të ndryshoni të gjithë \n * pikselët e lidhur të së njëjtës ngjyrë në një ngjyrë të zgjedhur, ku dy pikselë janë të lidhur nëse janë \n * ngjitur dhe kanë të njëjtën ngjyrë. Qëllimi është të gjeni numrin minimal të operacioneve të kërkuara \n * për t'i bërë të gjithë pikselët të së njëjtës ngjyrë.\n * Shënim: Për çdo ngjyrë, ka maksimumi 20 pikselë të asaj ngjyre.\n * \n * Shembuj:\n *    extraNumber(5, [1, 2, 3, 2, 1]) kthen 2\n */\nfunction f_45(n, pixels)", "hy": "/**\n * Տրված է 1xn չափսի պատկեր, որտեղ յուրաքանչյուր պիքսել ունի գույն, որը ներկայացված է ամբողջ թվով։ Դուք կարող եք փոխել \n * նույն գույնի բոլոր միացված պիքսելները ընտրված գույնի, որտեղ երկու պիքսելները միացված են, եթե նրանք հարակից են և ունեն նույն գույնը։ \n * Նպատակն է գտնել նվազագույն քանակությամբ գործողություններ, որոնք անհրաժեշտ են բոլոր պիքսելները նույն գույնի դարձնելու համար։\n * Նշում: Յուրաքանչյուր գույնի համար առավելագույնը կա 20 պիքսել։\n * \n * Օրինակներ:\n *    extraNumber(5, [1, 2, 3, 2, 1]) վերադարձնում է 2\n */\nfunction f_45(n, pixels)", "bn": "/**\n * একটি 1 বাই n পিক্সেল ইমেজ দেওয়া আছে, যেখানে প্রতিটি পিক্সেলের রঙ একটি পূর্ণসংখ্যা দ্বারা প্রতিনিধিত্ব করা হয়। আপনি সমস্ত সংযুক্ত পিক্সেলগুলিকে একটি পছন্দের রঙে পরিবর্তন করতে পারেন, যেখানে দুটি পিক্সেল সংযুক্ত থাকে যদি তারা সংলগ্ন হয় এবং একই রঙের হয়। লক্ষ্য হল সমস্ত পিক্সেলকে একই রঙে পরিণত করতে প্রয়োজনীয় সর্বনিম্ন সংখ্যক অপারেশন খুঁজে বের করা।\n * নোট: প্রতিটি রঙের জন্য, সেই রঙের সর্বাধিক 20টি পিক্সেল রয়েছে।\n * \n * উদাহরণ:\n *    extraNumber(5, [1, 2, 3, 2, 1]) 2 প্রদান করে\n */", "bg": "/**\n * Дадено е изображение 1 на n пиксела, като всеки пиксел има цвят, представен с цяло число. Можете да промените всички \n * свързани пиксели със същия цвят на избран цвят, където два пиксела са свързани, ако са съседни и имат същия цвят. Целта е да се намери минималният брой операции, необходими \n * за да се направят всички пиксели с един и същ цвят.\n * Забележка: За всеки цвят има най-много 20 пиксела от този цвят.\n * \n * Примери:\n *    extraNumber(5, [1, 2, 3, 2, 1]) връща 2\n */", "zh": "/**\n * 给定一个 1 x n 像素的图像，每个像素的颜色由一个整数表示。你可以将所有相同颜色的相连像素更改为选定的颜色，其中如果两个像素相邻且颜色相同，则它们是相连的。目标是找到使所有像素颜色相同所需的最小操作次数。\n * 注意：对于每种颜色，最多有 20 个该颜色的像素。\n * \n * 示例:\n *    extraNumber(5, [1, 2, 3, 2, 1]) 返回 2\n */", "fr": "/**\n * Étant donné une image de 1 par n pixels, chaque pixel a une couleur représentée par un entier. Vous pouvez changer tous \n * les pixels connectés de la même couleur en une couleur choisie, où deux pixels sont connectés s'ils sont \n * adjacents et ont la même couleur. Le but est de trouver le nombre minimum d'opérations nécessaires \n * pour que tous les pixels soient de la même couleur.\n * Remarque : Pour chaque couleur, il y a au maximum 20 pixels de cette couleur.\n * \n * Exemples :\n *    extraNumber(5, [1, 2, 3, 2, 1]) retourne 2\n */", "de": "/**\n * Gegeben ein 1x n Pixelbild, hat jedes Pixel eine Farbe, die durch eine ganze Zahl dargestellt wird. Sie können alle \n * verbundenen Pixel derselben Farbe in eine gewählte Farbe ändern, wobei zwei Pixel verbunden sind, wenn sie \n * benachbart sind und dieselbe Farbe haben. Das Ziel ist es, die minimale Anzahl von Operationen zu finden, die erforderlich sind, \n * um alle Pixel in dieselbe Farbe zu ändern.\n * Hinweis: Für jede Farbe gibt es höchstens 20 Pixel dieser Farbe.\n * \n * Beispiele:\n *    extraNumber(5, [1, 2, 3, 2, 1]) gibt 2 zurück\n */\nfunction f_45(n, pixels)", "ha": "/**\n * An bayar da hoton pixel 1 ta n, kowane pixel yana da launi wanda aka wakilta da lamba. Za ka iya canza duk \n * pixels masu haɗuwa na launi ɗaya zuwa launi da aka zaɓa, inda pixels biyu suke haɗuwa idan suna \n * kusa kuma suna da launi ɗaya. Manufar ita ce nemo mafi ƙarancin adadin ayyuka da ake buƙata \n * don sa duk pixels su zama launi ɗaya.\n * Lura: Ga kowane launi, akwai a kalla pixels 20 na wannan launi.\n * \n * Misalai:\n *    extraNumber(5, [1, 2, 3, 2, 1]) yana dawowa 2\n */\nfunction f_45(n, pixels)", "hi": "/**\n * दिए गए 1 बाय n पिक्सेल छवि में, प्रत्येक पिक्सेल का रंग एक पूर्णांक द्वारा दर्शाया गया है। आप सभी \n * जुड़े हुए पिक्सेल को एक चुने हुए रंग में बदल सकते हैं, जहाँ दो पिक्सेल जुड़े हुए होते हैं यदि वे \n * आसन्न होते हैं और उनका रंग समान होता है। लक्ष्य यह है कि सभी पिक्सेल को एक ही रंग में बनाने के लिए \n * न्यूनतम संख्या में ऑपरेशन्स का पता लगाना।\n * नोट: प्रत्येक रंग के लिए, उस रंग के अधिकतम 20 पिक्सेल होते हैं।\n * \n * उदाहरण:\n *    extraNumber(5, [1, 2, 3, 2, 1]) 2 लौटाता है\n */\nfunction f_45(n, pixels)", "hu": "/**\n * Adott egy 1 x n pixeles kép, ahol minden pixel színét egy egész szám reprezentálja. Módosíthatod az összes \n * összekapcsolt, azonos színű pixelt egy választott színre, ahol két pixel akkor van összekapcsolva, ha szomszédosak \n * és azonos színűek. A cél az, hogy megtaláljuk a minimális műveletszámot, amely szükséges ahhoz, hogy minden pixel \n * azonos színű legyen.\n * Megjegyzés: Minden szín esetében legfeljebb 20 pixel van abból a színből.\n * \n * Példák:\n *    extraNumber(5, [1, 2, 3, 2, 1]) visszaadja 2\n */\nfunction f_45(n, pixels)", "es": "/**\n * Dada una imagen de 1 por n píxeles, cada píxel tiene un color representado por un entero. Puedes cambiar todos\n * los píxeles conectados del mismo color a un color elegido, donde dos píxeles están conectados si son\n * adyacentes y tienen el mismo color. El objetivo es encontrar el número mínimo de operaciones requeridas\n * para hacer que todos los píxeles sean del mismo color.\n * Nota: Para cada color, hay como máximo 20 píxeles de ese color.\n * \n * Ejemplos:\n *    extraNumber(5, [1, 2, 3, 2, 1]) devuelve 2\n */\nfunction f_45(n, pixels)", "arb": "/**\n * معطى صورة بكسل بحجم 1 في n، كل بكسل له لون ممثل برقم صحيح. يمكنك تغيير جميع \n * البكسلات المتصلة من نفس اللون إلى لون مختار، حيث يكون البكسلان متصلان إذا كانا \n * متجاورين ولهما نفس اللون. الهدف هو العثور على الحد الأدنى من العمليات المطلوبة \n * لجعل جميع البكسلات بنفس اللون.\n * ملاحظة: لكل لون، هناك على الأكثر 20 بكسل من ذلك اللون.\n * \n * أمثلة:\n *    extraNumber(5, [1, 2, 3, 2, 1]) يعيد 2\n */ \nfunction f_45(n, pixels)", "sw": "/**\n * Ukipewa picha ya pikseli 1 kwa n, kila pikseli ina rangi inayowakilishwa na nambari. Unaweza kubadilisha \n * pikseli zote zilizounganishwa za rangi sawa kuwa rangi iliyochaguliwa, ambapo pikseli mbili zimeunganishwa \n * ikiwa ziko karibu na zina rangi sawa. Lengo ni kupata idadi ndogo ya operesheni zinazohitajika \n * kufanya pikseli zote ziwe na rangi sawa.\n * Kumbuka: Kwa kila rangi, kuna pikseli zisizozidi 20 za rangi hiyo.\n * \n * Mifano:\n *    extraNumber(5, [1, 2, 3, 2, 1]) inarudisha 2\n */\nfunction f_45(n, pixels)", "tr": "/**\n * 1'e n piksel görüntüsü verildiğinde, her piksel bir tamsayı ile temsil edilen bir renge sahiptir. \n * Aynı renkteki tüm bağlı pikselleri seçilen bir renge değiştirebilirsiniz, burada iki piksel \n * bitişik ve aynı renkte ise bağlı kabul edilir. Amaç, tüm pikselleri aynı renkte yapmak için \n * gereken minimum işlem sayısını bulmaktır.\n * Not: Her renk için en fazla 20 piksel vardır.\n * \n * Örnekler:\n *    extraNumber(5, [1, 2, 3, 2, 1]) 2 döndürür\n */\nfunction f_45(n, pixels)", "vi": "/**\n * Cho một hình ảnh 1 x n pixel, mỗi pixel có một màu được biểu diễn bằng một số nguyên. Bạn có thể thay đổi tất cả\n * các pixel kết nối có cùng màu thành một màu đã chọn, trong đó hai pixel được kết nối nếu chúng\n * liền kề và có cùng màu. Mục tiêu là tìm số lượng thao tác tối thiểu cần thiết\n * để làm cho tất cả các pixel có cùng màu.\n * Lưu ý: Đối với mỗi màu, có tối đa 20 pixel của màu đó.\n * \n * Ví dụ:\n *    extraNumber(5, [1, 2, 3, 2, 1]) trả về 2\n */\nfunction f_45(n, pixels)", "id": "/**\n * Diberikan gambar 1 kali n piksel, setiap piksel memiliki warna yang diwakili oleh sebuah bilangan bulat. Anda dapat mengubah semua \n * piksel yang terhubung dengan warna yang sama menjadi warna yang dipilih, di mana dua piksel terhubung jika mereka \n * bersebelahan dan memiliki warna yang sama. Tujuannya adalah untuk menemukan jumlah operasi minimum yang diperlukan \n * untuk membuat semua piksel memiliki warna yang sama.\n * Catatan: Untuk setiap warna, ada paling banyak 20 piksel dengan warna tersebut.\n * \n * Contoh:\n *    extraNumber(5, [1, 2, 3, 2, 1]) mengembalikan 2\n */\nfunction f_45(n, pixels)", "ja": "/**\n * 1 x n ピクセルの画像が与えられ、各ピクセルは整数で表される色を持っています。同じ色の隣接したピクセルをすべて選んだ色に変更できます。隣接していて同じ色を持つ場合、2つのピクセルは接続されています。すべてのピクセルを同じ色にするために必要な最小の操作回数を見つけることが目標です。\n * 注意: 各色について、その色のピクセルは最大で20個です。\n * \n * 例:\n *    extraNumber(5, [1, 2, 3, 2, 1]) は 2 を返します\n */\nfunction f_45(n, pixels)", "ko": "/**\n * 1 by n 픽셀 이미지가 주어졌을 때, 각 픽셀은 정수로 표현된 색상을 가지고 있습니다. 같은 색상의 연결된 모든 픽셀을 선택한 색상으로 변경할 수 있으며, 두 픽셀이 연결되어 있다는 것은 인접해 있고 같은 색상이라는 것을 의미합니다. 목표는 모든 픽셀이 같은 색상이 되도록 하는 데 필요한 최소 작업 수를 찾는 것입니다.\n * 참고: 각 색상에 대해 해당 색상의 픽셀이 최대 20개 있습니다.\n * \n * 예시:\n *    extraNumber(5, [1, 2, 3, 2, 1]) returns 2\n */\nfunction f_45(n, pixels)", "ml": "/**\n * 1 by n പിക്‌സൽ ചിത്രം നൽകിയിരിക്കുന്നു, ഓരോ പിക്‌സലിനും ഒരു പൂർണ്ണസംഖ്യയാൽ പ്രതിനിധീകരിക്കുന്ന ഒരു നിറം ഉണ്ട്. \n * നിങ്ങൾക്ക് തിരഞ്ഞെടുക്കപ്പെട്ട നിറത്തിലേക്ക് അതേ നിറമുള്ള എല്ലാ ബന്ധിപ്പിച്ച പിക്‌സലുകളും മാറ്റാൻ കഴിയും, \n * രണ്ട് പിക്‌സലുകൾ ബന്ധിപ്പിക്കപ്പെടുന്നത് അവർ ചേർന്നിരിക്കുന്നതും അതേ നിറമുള്ളതുമായിരിക്കുമ്പോഴാണ്. \n * എല്ലാ പിക്‌സലുകളും ഒരേ നിറത്തിലുള്ളതാക്കാൻ ആവശ്യമായ കുറഞ്ഞ പ്രവർത്തനങ്ങളുടെ എണ്ണം കണ്ടെത്തുകയാണ് ലക്ഷ്യം.\n * കുറിപ്പ്: ഓരോ നിറത്തിനും ആ നിറത്തിലുള്ള പരമാവധി 20 പിക്‌സലുകൾ മാത്രമേയുള്ളൂ.\n * \n * ഉദാഹരണങ്ങൾ:\n *    extraNumber(5, [1, 2, 3, 2, 1]) 2 തിരികെ നൽകുന്നു\n */\nfunction f_45(n, pixels)", "fa": "/**\n * با توجه به یک تصویر 1 در n پیکسلی، هر پیکسل دارای رنگی است که با یک عدد صحیح نمایش داده می‌شود. شما می‌توانید \n * تمام پیکسل‌های متصل با رنگ مشابه را به رنگ دلخواه تغییر دهید، جایی که دو پیکسل متصل هستند اگر مجاور باشند و \n * رنگ یکسانی داشته باشند. هدف این است که حداقل تعداد عملیات مورد نیاز برای یکسان کردن رنگ تمام پیکسل‌ها را پیدا کنید.\n * توجه: برای هر رنگ، حداکثر 20 پیکسل از آن رنگ وجود دارد.\n * \n * مثال‌ها:\n *    extraNumber(5, [1, 2, 3, 2, 1]) مقدار 2 را برمی‌گرداند\n */\nfunction f_45(n, pixels)"}, "canonical_solution": "{\n    let pre = new Array(n+1).fill(0),\n        u = new Array(n+1).fill(0),\n        f = Array.from({length: n+1}, () => new Array(n+1).fill(Infinity));\n\n    for (let i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    \n    for (let i = 1; i <= n; i++) {\n        f[i][i] = 0;\n    }\n    \n    for (let len = 2; len <= n; len++) {\n        for (let i = 1; i <= n - len + 1; i++) {\n            let j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (let l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = Math.min(f[i][j], f[i][l] + f[l + 1][j]);\n            }\n        }\n    }\n    \n    return f[1][n];\n}", "instruction": {"en": "Write a JavaScript function `function f_45(n, pixels)` to solve the following problem:\nGiven a 1 by n pixel image, each pixel has a color represented by an integer. You can change all connected pixels of the same color to a chosen color, where two pixels are connected if they are adjacent and have the same color. The goal is to find the minimum number of operations required to make all pixels the same color.\nNote: For each color, there are at most 20 pixels of that color.\n\nExamples:\nextraNumber(5, [1, 2, 3, 2, 1]) returns 2", "sq": "Shkruani një funksion JavaScript `function f_45(n, pixels)` për të zgjidhur problemin në vijim:  \nDuke pasur një imazh 1 me n pikselë, secili piksel ka një ngjyrë të përfaqësuar nga një numër i plotë. Ju mund të ndryshoni të gjithë pikselët e lidhur me të njëjtën ngjyrë në një ngjyrë të zgjedhur, ku dy pikselë janë të lidhur nëse janë ngjitur dhe kanë të njëjtën ngjyrë. Qëllimi është të gjeni numrin minimal të operacioneve të kërkuara për t'i bërë të gjithë pikselët me të njëjtën ngjyrë.  \nShënim: Për çdo ngjyrë, ka maksimumi 20 pikselë të asaj ngjyre.\n\nShembuj:  \nextraNumber(5, [1, 2, 3, 2, 1]) kthen 2", "hy": "Գրեք JavaScript ֆունկցիա `function f_45(n, pixels)` հետևյալ խնդիրը լուծելու համար:\nՏրված է 1-ից n պիքսել պատկեր, յուրաքանչյուր պիքսել ունի գույն, որը ներկայացված է ամբողջ թվով: Դուք կարող եք փոխել նույն գույնի բոլոր միացված պիքսելները ընտրված գույնի, որտեղ երկու պիքսելները միացված են, եթե նրանք հարակից են և ունեն նույն գույնը: Նպատակն է գտնել նվազագույն գործողությունների քանակը, որը պահանջվում է բոլոր պիքսելները նույն գույնի դարձնելու համար:\nՆշում: Յուրաքանչյուր գույնի համար առավելագույնը կա 20 պիքսել այդ գույնի:\n\nՕրինակներ:\nextraNumber(5, [1, 2, 3, 2, 1]) վերադարձնում է 2", "bn": "একটি JavaScript ফাংশন `function f_45(n, pixels)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nধরা যাক একটি 1 বাই n পিক্সেল ইমেজ, প্রতিটি পিক্সেলের একটি রঙ আছে যা একটি পূর্ণসংখ্যা দ্বারা উপস্থাপিত হয়। আপনি একই রঙের সংযুক্ত পিক্সেলগুলিকে একটি পছন্দের রঙে পরিবর্তন করতে পারেন, যেখানে দুটি পিক্সেল সংযুক্ত থাকে যদি তারা সংলগ্ন হয় এবং তাদের রঙ একই হয়। লক্ষ্য হল সমস্ত পিক্সেলকে একই রঙে করার জন্য প্রয়োজনীয় সর্বনিম্ন সংখ্যক অপারেশন খুঁজে বের করা।\nবিঃদ্রঃ: প্রতিটি রঙের জন্য, সেই রঙের সর্বাধিক ২০টি পিক্সেল রয়েছে।\n\nউদাহরণ:\nextraNumber(5, [1, 2, 3, 2, 1]) 2 রিটার্ন করে", "bg": "Напишете JavaScript функция `function f_45(n, pixels)`, за да решите следния проблем:  \nДадено е изображение с размер 1 на n пиксела, като всеки пиксел има цвят, представен от цяло число. Можете да промените всички свързани пиксели със същия цвят на избран цвят, където два пиксела са свързани, ако са съседни и имат същия цвят. Целта е да се намери минималният брой операции, необходими, за да се направят всички пиксели с един и същ цвят.  \nЗабележка: За всеки цвят има най-много 20 пиксела от този цвят.  \n\nПримери:  \nextraNumber(5, [1, 2, 3, 2, 1]) връща 2", "zh": "编写一个JavaScript函数 `function f_45(n, pixels)` 来解决以下问题：  \n给定一个1乘n的像素图像，每个像素都有一个由整数表示的颜色。你可以将所有相同颜色的连接像素更改为一个选定的颜色，其中如果两个像素相邻且颜色相同，则它们是连接的。目标是找到使所有像素颜色相同所需的最小操作次数。  \n注意：对于每种颜色，最多有20个该颜色的像素。\n\n示例：  \nextraNumber(5, [1, 2, 3, 2, 1]) 返回 2", "fr": "Écrire une fonction JavaScript `function f_45(n, pixels)` pour résoudre le problème suivant :  \nÉtant donné une image de 1 par n pixels, chaque pixel a une couleur représentée par un entier. Vous pouvez changer tous les pixels connectés de la même couleur en une couleur choisie, où deux pixels sont connectés s'ils sont adjacents et ont la même couleur. L'objectif est de trouver le nombre minimum d'opérations nécessaires pour que tous les pixels soient de la même couleur.  \nRemarque : Pour chaque couleur, il y a au plus 20 pixels de cette couleur.\n\nExemples :  \nextraNumber(5, [1, 2, 3, 2, 1]) renvoie 2", "de": "Schreiben Sie eine JavaScript-Funktion `function f_45(n, pixels)`, um das folgende Problem zu lösen:\nGegeben ist ein 1-mal-n-Pixel-Bild, wobei jedes Pixel eine Farbe hat, die durch eine ganze Zahl dargestellt wird. Sie können alle verbundenen Pixel derselben Farbe in eine gewählte Farbe ändern, wobei zwei Pixel verbunden sind, wenn sie benachbart sind und dieselbe Farbe haben. Das Ziel ist es, die minimale Anzahl von Operationen zu finden, die erforderlich sind, um alle Pixel in dieselbe Farbe zu ändern.\nHinweis: Für jede Farbe gibt es höchstens 20 Pixel dieser Farbe.\n\nBeispiele:\nextraNumber(5, [1, 2, 3, 2, 1]) gibt 2 zurück", "ha": "Rubuta aikin JavaScript `function f_45(n, pixels)` don warware matsalar mai zuwa:\nAn ba da hoton pixel 1 ta n, kowanne pixel yana da launi wanda aka wakilta da lamba. Kuna iya canza duk pixels masu haɗin kai na launi ɗaya zuwa launi da aka zaɓa, inda pixels biyu suka haɗu idan suna makwabtaka kuma suna da launi ɗaya. Manufar ita ce nemo mafi ƙarancin adadin ayyuka da ake buƙata don sanya duk pixels su zama launi ɗaya.\nLura: Ga kowane launi, akwai mafi yawa pixels 20 na wannan launi.\n\nMisalai:\nextraNumber(5, [1, 2, 3, 2, 1]) yana dawowa 2", "hi": "`function f_45(n, pixels)` फ़ंक्शन लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए 1 बाय n पिक्सेल इमेज में, प्रत्येक पिक्सेल का रंग एक पूर्णांक द्वारा दर्शाया गया है। आप चुने गए रंग में एक ही रंग के सभी जुड़े पिक्सेल को बदल सकते हैं, जहां दो पिक्सेल जुड़े होते हैं यदि वे आसन्न होते हैं और उनका रंग समान होता है। लक्ष्य यह है कि सभी पिक्सेल को एक ही रंग में बदलने के लिए आवश्यक न्यूनतम ऑपरेशनों की संख्या का पता लगाया जाए।\nनोट: प्रत्येक रंग के लिए, उस रंग के अधिकतम 20 पिक्सेल होते हैं।\n\nउदाहरण:\nextraNumber(5, [1, 2, 3, 2, 1]) 2 लौटाता है।", "hu": "Írj egy JavaScript függvényt `function f_45(n, pixels)` a következő probléma megoldására:  \nAdott egy 1 x n képpontból álló kép, ahol minden képpont színe egy egész számmal van reprezentálva. Megváltoztathatod az összes összekapcsolt, azonos színű képpontot egy választott színre, ahol két képpont akkor van összekapcsolva, ha szomszédosak és azonos színűek. A cél az, hogy megtaláljuk a minimális műveletszámot, amely szükséges ahhoz, hogy az összes képpont azonos színű legyen.  \nMegjegyzés: Minden szín esetében legfeljebb 20 képpont van abból a színből.\n\nPéldák:  \nextraNumber(5, [1, 2, 3, 2, 1]) visszaadja 2", "es": "Escribe una función de JavaScript `function f_45(n, pixels)` para resolver el siguiente problema:\nDada una imagen de 1 por n píxeles, cada píxel tiene un color representado por un número entero. Puedes cambiar todos los píxeles conectados del mismo color a un color elegido, donde dos píxeles están conectados si son adyacentes y tienen el mismo color. El objetivo es encontrar el número mínimo de operaciones necesarias para hacer que todos los píxeles sean del mismo color.\nNota: Para cada color, hay como máximo 20 píxeles de ese color.\n\nEjemplos:\nextraNumber(5, [1, 2, 3, 2, 1]) devuelve 2", "arb": "اكتب دالة JavaScript `function f_45(n, pixels)` لحل المشكلة التالية:\nبالنظر إلى صورة بحجم 1 في n بكسل، كل بكسل له لون ممثل برقم صحيح. يمكنك تغيير جميع البكسلات المتصلة بنفس اللون إلى لون مختار، حيث يكون البكسلان متصلان إذا كانا متجاورين ولهما نفس اللون. الهدف هو إيجاد الحد الأدنى لعدد العمليات المطلوبة لجعل جميع البكسلات بنفس اللون.\nملاحظة: لكل لون، هناك بحد أقصى 20 بكسل من ذلك اللون.\n\nأمثلة:\nextraNumber(5, [1, 2, 3, 2, 1]) يعيد 2", "sw": "Andika kazi ya JavaScript `function f_45(n, pixels)` kutatua tatizo lifuatalo:\nUkipiwa picha ya pikseli 1 kwa n, kila pikseli ina rangi inayowakilishwa na nambari. Unaweza kubadilisha pikseli zote zilizounganishwa za rangi sawa kuwa rangi iliyochaguliwa, ambapo pikseli mbili zimeunganishwa ikiwa zipo karibu na zina rangi sawa. Lengo ni kupata idadi ndogo ya operesheni zinazohitajika kufanya pikseli zote ziwe na rangi sawa.\nKumbuka: Kwa kila rangi, kuna pikseli zisizozidi 20 za rangi hiyo.\n\nMifano:\nextraNumber(5, [1, 2, 3, 2, 1]) inarudisha 2", "tr": "Bir JavaScript fonksiyonu `function f_45(n, pixels)` yazın ve aşağıdaki problemi çözün:\n1'e n piksel görüntü verildiğinde, her piksel bir tamsayı ile temsil edilen bir renge sahiptir. Aynı renkteki tüm bağlı pikselleri seçilen bir renge değiştirebilirsiniz, burada iki piksel bitişik ve aynı renkte ise bağlıdır. Amaç, tüm pikselleri aynı renkte yapmak için gereken minimum işlem sayısını bulmaktır.\nNot: Her renk için en fazla 20 piksel vardır.\n\nÖrnekler:\nextraNumber(5, [1, 2, 3, 2, 1]) 2 döndürür", "vi": "Viết một hàm JavaScript `function f_45(n, pixels)` để giải quyết vấn đề sau:\nCho một hình ảnh 1 x n pixel, mỗi pixel có một màu được biểu diễn bằng một số nguyên. Bạn có thể thay đổi tất cả các pixel kết nối có cùng màu sang một màu đã chọn, trong đó hai pixel được kết nối nếu chúng liền kề và có cùng màu. Mục tiêu là tìm số lượng thao tác tối thiểu cần thiết để làm cho tất cả các pixel có cùng màu.\nLưu ý: Đối với mỗi màu, có tối đa 20 pixel của màu đó.\n\nVí dụ:\nextraNumber(5, [1, 2, 3, 2, 1]) trả về 2", "id": "Tulis sebuah fungsi JavaScript `function f_45(n, pixels)` untuk menyelesaikan masalah berikut:\nDiberikan gambar 1 kali n piksel, setiap piksel memiliki warna yang diwakili oleh sebuah bilangan bulat. Anda dapat mengubah semua piksel yang terhubung dengan warna yang sama menjadi warna yang dipilih, di mana dua piksel terhubung jika mereka bersebelahan dan memiliki warna yang sama. Tujuannya adalah untuk menemukan jumlah operasi minimum yang diperlukan untuk membuat semua piksel memiliki warna yang sama.\nCatatan: Untuk setiap warna, terdapat paling banyak 20 piksel dengan warna tersebut.\n\nContoh:\nextraNumber(5, [1, 2, 3, 2, 1]) mengembalikan 2", "ja": "以下の問題を解決するためのJavaScript関数 `function f_45(n, pixels)` を作成してください:\n1 by nのピクセル画像が与えられ、各ピクセルは整数で表される色を持っています。隣接していて同じ色を持つピクセルを選んだ色に変更することができます。目標は、すべてのピクセルを同じ色にするために必要な最小の操作回数を見つけることです。\n注意: 各色について、その色のピクセルは最大で20個です。\n\n例:\nextraNumber(5, [1, 2, 3, 2, 1]) は2を返します。", "ko": "JavaScript 함수 `function f_45(n, pixels)`를 작성하여 다음 문제를 해결하십시오:\n1 by n 픽셀 이미지가 주어졌을 때, 각 픽셀은 정수로 표현된 색상을 가지고 있습니다. 인접하고 동일한 색상을 가진 두 픽셀이 연결되어 있을 때, 동일한 색상의 연결된 모든 픽셀을 선택한 색상으로 변경할 수 있습니다. 목표는 모든 픽셀을 동일한 색상으로 만드는 데 필요한 최소 작업 수를 찾는 것입니다.\n참고: 각 색상에 대해 해당 색상의 픽셀이 최대 20개 있습니다.\n\n예시:\nextraNumber(5, [1, 2, 3, 2, 1])는 2를 반환합니다.", "ml": "`function f_45(n, pixels)` എന്ന ജാവാസ്ക്രിപ്റ്റ് ഫങ്ഷൻ എഴുതുക താഴെ കൊടുത്തിരിക്കുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\n1 by n പിക്സൽ ഇമേജ് നൽകിയിരിക്കുന്നു, ഓരോ പിക്സലിനും ഒരു പൂർണ്ണസംഖ്യയാൽ പ്രതിനിധീകരിക്കുന്ന ഒരു നിറമുണ്ട്. നിങ്ങൾക്ക് ഒരേ നിറമുള്ള എല്ലാ ബന്ധിപ്പിച്ചിരിക്കുന്ന പിക്സലുകളെയും തിരഞ്ഞെടുക്കുന്ന ഒരു നിറത്തിലേക്ക് മാറ്റാം, ഇവിടെ രണ്ട് പിക്സലുകൾ ബന്ധിപ്പിച്ചിരിക്കുന്നുവെന്ന് അർത്ഥം അവ അടുത്തുള്ളവയും ഒരേ നിറമുള്ളവയുമാണ്. എല്ലാ പിക്സലുകളും ഒരേ നിറത്തിലാക്കാൻ ആവശ്യമായ കുറഞ്ഞ പ്രവർത്തനങ്ങളുടെ എണ്ണം കണ്ടെത്തുക എന്നതാണ് ലക്ഷ്യം.\nകുറിപ്പ്: ഓരോ നിറത്തിനും ആ നിറത്തിലുള്ള പരമാവധി 20 പിക്സലുകൾ മാത്രമേ ഉണ്ടാകൂ.\n\nഉദാഹരണങ്ങൾ:\nextraNumber(5, [1, 2, 3, 2, 1]) 2 മടക്കുന്നു", "fa": "یک تابع جاوااسکریپت `function f_45(n, pixels)` بنویسید تا مسئله زیر را حل کند:\nبا توجه به یک تصویر 1 در n پیکسلی، هر پیکسل دارای رنگی است که با یک عدد صحیح نشان داده می‌شود. شما می‌توانید تمام پیکسل‌های متصل با رنگ مشابه را به یک رنگ دلخواه تغییر دهید، جایی که دو پیکسل متصل هستند اگر مجاور باشند و رنگ یکسانی داشته باشند. هدف این است که حداقل تعداد عملیات لازم برای یکسان کردن رنگ تمام پیکسل‌ها را پیدا کنید.\nتوجه: برای هر رنگ، حداکثر 20 پیکسل از آن رنگ وجود دارد.\n\nمثال‌ها:\nextraNumber(5, [1, 2, 3, 2, 1]) مقدار 2 را برمی‌گرداند."}, "level": "hard", "test": "(() => {\n    console.assert(f_45(5, [1, 2, 3, 2, 1]) === 2);\n    console.assert(f_45(4, [1, 1, 2, 2]) === 1);\n    console.assert(f_45(5, [1, 2, 1, 4, 2]) === 3);\n    console.assert(f_45(5, [5, 5, 5, 5, 5]) === 0);\n    console.assert(f_45(6, [1, 1, 1, 2, 2, 2]) === 1);\n    console.assert(f_45(7, [1, 3, 3, 3, 2, 2, 2]) === 2);\n    console.assert(f_45(8, [4, 4, 4, 4, 3, 3, 3, 3]) === 1);\n    console.assert(f_45(9, [1, 2, 3, 4, 5, 6, 7, 8, 9]) === 8);\n    console.assert(f_45(10, [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]) === 5);\n    console.assert(f_45(3, [3, 3, 3]) === 0);\n    console.assert(f_45(4, [2, 1, 1, 2]) === 1);\n})();", "entry_point": "f_45", "signature": "function f_45(n, pixels)", "docstring": {"en": "Given a 1 by n pixel image, each pixel has a color represented by an integer. You can change all connected pixels of the same color to a chosen color, where two pixels are connected if they are adjacent and have the same color. The goal is to find the minimum number of operations required to make all pixels the same color.\nNote: For each color, there are at most 20 pixels of that color.\n\nExamples:\nextraNumber(5, [1, 2, 3, 2, 1]) returns 2", "sq": "Duke pasur një imazh 1 me n piksel, secili piksel ka një ngjyrë të përfaqësuar nga një numër i plotë. Ju mund të ndryshoni të gjithë piksela të lidhur të së njëjtës ngjyrë në një ngjyrë të zgjedhur, ku dy piksela janë të lidhur nëse janë ngjitur dhe kanë të njëjtën ngjyrë. Qëllimi është të gjendet numri minimal i operacioneve të nevojshme për të bërë që të gjithë piksela të kenë të njëjtën ngjyrë.\nShënim: Për çdo ngjyrë, ka më së shumti 20 piksela të asaj ngjyre.\n\nShembuj:\nextraNumber(5, [1, 2, 3, 2, 1]) kthen 2", "hy": "Տրված է 1 x n պիքսել պատկեր, որտեղ յուրաքանչյուր պիքսել ունի գույն, որը ներկայացված է ամբողջ թվով։ Դուք կարող եք փոխել նույն գույնի բոլոր միացված պիքսելները ընտրված գույնի, որտեղ երկու պիքսելներ միացված են, եթե նրանք հարակից են և ունեն նույն գույնը։ Նպատակն է գտնել նվազագույն գործողությունների քանակը, որը պահանջվում է բոլոր պիքսելները նույն գույնի դարձնելու համար:\nՆշում: Յուրաքանչյուր գույնի համար առավելագույնը կա 20 պիքսել։\n\nՕրինակներ:\nextraNumber(5, [1, 2, 3, 2, 1]) վերադարձնում է 2", "bn": "একটি 1 বাই n পিক্সেল ইমেজ দেওয়া হয়েছে, যেখানে প্রতিটি পিক্সেলের একটি রঙ রয়েছে যা একটি পূর্ণসংখ্যা দ্বারা উপস্থাপিত হয়। আপনি একটি নির্বাচিত রঙে একই রঙের সংযুক্ত সমস্ত পিক্সেল পরিবর্তন করতে পারেন, যেখানে দুটি পিক্সেল সংযুক্ত থাকে যদি তারা সংলগ্ন হয় এবং একই রঙ থাকে। সমস্ত পিক্সেলকে একই রঙে পরিবর্তন করতে প্রয়োজনীয় সর্বনিম্ন সংখ্যক অপারেশন খুঁজে বের করাই লক্ষ্য।\nনোট: প্রতিটি রঙের জন্য, সেই রঙের সর্বাধিক ২০টি পিক্সেল থাকতে পারে।\n\nউদাহরণ:\nextraNumber(5, [1, 2, 3, 2, 1]) ২ ফেরত দেয়", "bg": "Дадено е изображение с размери 1 на n пиксела, като всеки пиксел има цвят, представен с цяло число. Можете да промените всички свързани пиксели със същия цвят на избран цвят, където два пиксела са свързани, ако са съседни и имат същия цвят. Целта е да се намери минималният брой операции, необходими, за да се направят всички пиксели с един и същ цвят.\nЗабележка: За всеки цвят има най-много 20 пиксела с този цвят.\n\nПримери:\nextraNumber(5, [1, 2, 3, 2, 1]) връща 2", "zh": "给定一个 1 x n 像素的图像，每个像素的颜色由一个整数表示。您可以将所有相同颜色的连接像素更改为选定的颜色，其中如果两个像素相邻并且颜色相同，则它们是连接的。目标是找到使所有像素颜色相同所需的最小操作次数。\n注意：对于每种颜色，最多有 20 个该颜色的像素。\n\n示例：\nextraNumber(5, [1, 2, 3, 2, 1]) 返回 2", "fr": "Étant donné une image de 1 par n pixels, chaque pixel a une couleur représentée par un entier. Vous pouvez changer tous les pixels connectés de la même couleur en une couleur choisie, où deux pixels sont connectés s'ils sont adjacents et ont la même couleur. L'objectif est de trouver le nombre minimum d'opérations nécessaires pour que tous les pixels aient la même couleur.\nRemarque : Pour chaque couleur, il y a au plus 20 pixels de cette couleur.\n\nExemples:\nextraNumber(5, [1, 2, 3, 2, 1]) retourne 2", "de": "Gegeben ein 1x n Pixel Bild, wobei jedes Pixel eine durch eine ganze Zahl dargestellte Farbe hat. Sie können alle verbundenen Pixel derselben Farbe in eine gewählte Farbe ändern, wobei zwei Pixel verbunden sind, wenn sie benachbart sind und dieselbe Farbe haben. Das Ziel ist es, die minimale Anzahl von Operationen zu finden, die erforderlich sind, um alle Pixel in dieselbe Farbe zu ändern.\nHinweis: Für jede Farbe gibt es höchstens 20 Pixel dieser Farbe.\n\nBeispiele:\nextraNumber(5, [1, 2, 3, 2, 1]) gibt 2 zurück", "ha": "An ba da hoton pixel 1 ta n, kowane pixel yana da launi wanda aka wakilta da lamba. Za ka iya canza duk pixels da aka haɗa na launi ɗaya zuwa launi da aka zaɓa, inda aka haɗa pixels biyu idan suna kusa kuma suna da launi ɗaya. Manufar ita ce nemo mafi ƙarancin adadin ayyuka da ake buƙata don sanya duk pixels su zama launi ɗaya.\nLura: Don kowane launi, akwai akalla pixels 20 na wannan launi.\n\nMisalai:\nextraNumber(5, [1, 2, 3, 2, 1]) yana dawowa 2", "hi": "1 by n पिक्सेल छवि दी गई है, प्रत्येक पिक्सेल का रंग एक पूर्णांक द्वारा दर्शाया गया है। आप एक चुने हुए रंग में एक ही रंग के सभी जुड़े पिक्सेल को बदल सकते हैं, जहाँ दो पिक्सेल जुड़े होते हैं यदि वे आसन्न होते हैं और उनका रंग समान होता है। लक्ष्य यह है कि सभी पिक्सेल को एक ही रंग में बनाने के लिए आवश्यक न्यूनतम संचालन की संख्या का पता लगाना है। \nनोट: प्रत्येक रंग के लिए, उस रंग के अधिकतम 20 पिक्सेल होते हैं।\n\nउदाहरण:\nextraNumber(5, [1, 2, 3, 2, 1]) 2 लौटाता है", "hu": "Egy 1 x n pixeles képet kapunk, ahol minden pixel színe egy egész számmal van ábrázolva. Megváltoztathatja az összes összekapcsolt, azonos színű pixelt egy választott színre, ahol két pixel akkor van összekapcsolva, ha szomszédosak és azonos színűek. A cél az, hogy megtaláljuk a minimális műveletszámot, amely szükséges ahhoz, hogy az összes pixel azonos színű legyen.\nMegjegyzés: Minden színhez legfeljebb 20 pixel tartozik.\n\nPéldák:\nextraNumber(5, [1, 2, 3, 2, 1]) visszaadja 2", "es": "Dada una imagen de 1 por n píxeles, cada píxel tiene un color representado por un número entero. Puedes cambiar todos los píxeles conectados del mismo color a un color elegido, donde dos píxeles están conectados si son adyacentes y tienen el mismo color. El objetivo es encontrar el número mínimo de operaciones requeridas para hacer que todos los píxeles sean del mismo color.\nNota: Para cada color, hay como máximo 20 píxeles de ese color.\n\nEjemplos:\nextraNumber(5, [1, 2, 3, 2, 1]) devuelve 2", "arb": "نظرًا لصورة مكونة من 1 في n بكسل، كل بكسل له لون يمثله عدد صحيح. يمكنك تغيير جميع البكسلات المتصلة من نفس اللون إلى لون مختار، حيث يعتبر بكسلان متصلان إذا كانا متجاورين ولهما نفس اللون. الهدف هو إيجاد الحد الأدنى من العمليات المطلوبة لجعل جميع البكسلات بنفس اللون.\nملاحظة: لكل لون، هناك بحد أقصى 20 بكسل من ذلك اللون.\n\nأمثلة:\nextraNumber(5, [1, 2, 3, 2, 1]) يعيد 2", "sw": "Dokezo: Picha ya pikseli 1 kwa n, kila pikseli ina rangi inayowakilishwa na nambari kamili. Unaweza kubadilisha pikseli zote zilizounganishwa za rangi sawa kuwa rangi iliyochaguliwa, ambapo pikseli mbili zimeunganishwa ikiwa ziko karibu na zina rangi sawa. Lengo ni kupata idadi ndogo ya operesheni zinazohitajika ili kufanya pikseli zote ziwe na rangi sawa. \nKumbuka: Kwa kila rangi, kuna pikseli zisizozidi 20 za rangi hiyo.\n\nMifano:\nextraNumber(5, [1, 2, 3, 2, 1]) inarudisha 2", "tr": "Verilen 1'e n piksel görüntüsünde, her piksel bir tamsayı ile temsil edilen bir renge sahiptir. Aynı renkteki tüm bağlı pikselleri seçilen bir renge değiştirebilirsiniz, burada iki piksel, bitişik ve aynı renkte olduklarında bağlı kabul edilir. Amaç, tüm pikselleri aynı renkte yapmak için gereken minimum işlem sayısını bulmaktır.\nNot: Her renk için en fazla 20 piksel bulunmaktadır.\n\nÖrnekler:\nextraNumber(5, [1, 2, 3, 2, 1]) 2 döndürür", "vi": "Đưa ra một hình ảnh 1 x n pixel, mỗi pixel có một màu được biểu diễn bằng một số nguyên. Bạn có thể thay đổi tất cả các pixel kết nối có cùng màu sang một màu được chọn, trong đó hai pixel được kết nối nếu chúng liền kề và có cùng màu. Mục tiêu là tìm số lượng thao tác tối thiểu cần thiết để làm cho tất cả các pixel có cùng màu.\nLưu ý: Đối với mỗi màu, có nhiều nhất 20 pixel của màu đó.\n\nVí dụ:\nextraNumber(5, [1, 2, 3, 2, 1]) trả về 2", "id": "Diberikan gambar 1 x n piksel, setiap piksel memiliki warna yang diwakili oleh sebuah bilangan bulat. Anda dapat mengubah semua piksel yang terhubung dengan warna yang sama menjadi warna yang dipilih, di mana dua piksel terhubung jika mereka bersebelahan dan memiliki warna yang sama. Tujuannya adalah untuk menemukan jumlah operasi minimum yang diperlukan untuk membuat semua piksel memiliki warna yang sama.\nCatatan: Untuk setiap warna, terdapat paling banyak 20 piksel dengan warna tersebut.\n\nContoh:\nextraNumber(5, [1, 2, 3, 2, 1]) mengembalikan 2", "ja": "1 by n のピクセル画像が与えられ、各ピクセルは整数で表される色を持っています。同じ色のすべての接続されたピクセルを選択した色に変更することができます。ここで、2つのピクセルは隣接していて同じ色である場合に接続されているとみなされます。目標は、すべてのピクセルを同じ色にするために必要な最小の操作回数を見つけることです。\n注意: 各色について、その色のピクセルは最大で20個です。\n\n例:\nextraNumber(5, [1, 2, 3, 2, 1]) は 2 を返します。", "ko": "1 by n 픽셀 이미지가 주어졌을 때, 각 픽셀은 정수로 표현된 색상을 가집니다. 인접하고 같은 색상을 가진 경우, 서로 연결된 모든 픽셀을 선택한 색상으로 변경할 수 있습니다. 목표는 모든 픽셀이 동일한 색상이 되도록 하는 데 필요한 최소 작업 수를 찾는 것입니다.\n참고: 각 색상에 대해 해당 색상의 픽셀이 최대 20개 있습니다.\n\n예시:\nextraNumber(5, [1, 2, 3, 2, 1])는 2를 반환합니다.", "ml": "1 by n പിക്സൽ ചിത്രത്തിൽ, ഓരോ പിക്സലിനും ഒരു പൂർണ്ണസംഖ്യയാൽ പ്രതിനിധീകരിക്കുന്ന ഒരു നിറമുണ്ട്. നിങ്ങൾക്ക് അതേ നിറത്തിലുള്ള എല്ലാ ബന്ധിപ്പിച്ച പിക്സലുകളും തിരഞ്ഞെടുക്കപ്പെട്ട നിറത്തിലേക്ക് മാറ്റാം, രണ്ട് പിക്സലുകൾ ചേർന്നിരിക്കുന്നതും അതേ നിറമുള്ളതുമായിരിക്കുമ്പോൾ അവ ബന്ധിപ്പിച്ചിരിക്കുന്നു. എല്ലാ പിക്സലുകളും ഒരേ നിറത്തിലാക്കാൻ ആവശ്യമായ കുറഞ്ഞ പ്രവർത്തനങ്ങളുടെ എണ്ണം കണ്ടെത്തുകയാണ് ലക്ഷ്യം. \nകുറിപ്പ്: ഓരോ നിറത്തിനും ആ നിറത്തിലുള്ള പരമാവധി 20 പിക്സലുകൾ മാത്രമേയുള്ളൂ.\n\nഉദാഹരണങ്ങൾ:\nextraNumber(5, [1, 2, 3, 2, 1]) 2 തിരിച്ചുനൽകുന്നു", "fa": "با توجه به یک تصویر ۱ در n پیکسل، هر پیکسل دارای رنگی است که با یک عدد صحیح نمایش داده می‌شود. شما می‌توانید تمام پیکسل‌های متصل با رنگ یکسان را به رنگی انتخابی تغییر دهید، به شرطی که دو پیکسل متصل باشند اگر مجاور باشند و رنگ یکسانی داشته باشند. هدف این است که حداقل تعداد عملیات لازم برای یکسان‌سازی رنگ تمام پیکسل‌ها را پیدا کنید.\nتوجه: برای هر رنگ، حداکثر ۲۰ پیکسل از آن رنگ وجود دارد.\n\nمثال‌ها:\nextraNumber(5, [1, 2, 3, 2, 1]) مقدار ۲ را برمی‌گرداند."}}
{"task_id": "JavaScript/46", "prompt": {"en": "/**\n * Given an integer n, write a function to compute the sum of all numbers from 1 to n\n * that are multiples of either 3 or 5. If a number is a multiple of both 3 and 5,\n * it should only be counted once.\n * For example:\n *     f_46(10); // returns 33 (3 + 5 + 6 + 9 + 10)\n */\nfunction f_46(n)", "sq": "/**\n * Duke pasur një numër të plotë n, shkruani një funksion për të llogaritur shumën e të gjithë numrave nga 1 deri në n\n * që janë shumëfish i 3 ose 5. Nëse një numër është shumëfish i të dyjave 3 dhe 5,\n * ai duhet të numërohet vetëm një herë.\n * Për shembull:\n *     f_46(10); // kthen 33 (3 + 5 + 6 + 9 + 10)\n */\nfunction f_46(n)", "hy": "/**\n * Տրված է ամբողջ թիվ n, գրեք ֆունկցիա՝ հաշվարկելու 1-ից n բոլոր այն թվերի գումարը,\n * որոնք բազմապատիկ են 3-ի կամ 5-ի։ Եթե թիվը բազմապատիկ է և՛ 3-ի, և՛ 5-ի,\n * այն պետք է հաշվել միայն մեկ անգամ։\n * Օրինակ:\n *     f_46(10); // վերադարձնում է 33 (3 + 5 + 6 + 9 + 10)\n */\nfunction f_46(n)", "bn": "/**\n * একটি পূর্ণসংখ্যা n দেওয়া হলে, 1 থেকে n পর্যন্ত সমস্ত সংখ্যার যোগফল গণনা করার জন্য একটি ফাংশন লিখুন\n * যা হয় 3 অথবা 5 এর গুণিতক। যদি কোনো সংখ্যা 3 এবং 5 উভয়েরই গুণিতক হয়,\n * তবে এটি শুধুমাত্র একবার গণনা করা উচিত।\n * উদাহরণস্বরূপ:\n *     f_46(10); // 33 ফেরত দেয় (3 + 5 + 6 + 9 + 10)\n */\nfunction f_46(n)", "bg": "/**\n * Дадено е цяло число n, напишете функция за изчисляване на сумата на всички числа от 1 до n,\n * които са кратни на 3 или 5. Ако едно число е кратно и на 3, и на 5,\n * то трябва да бъде преброено само веднъж.\n * Например:\n *     f_46(10); // връща 33 (3 + 5 + 6 + 9 + 10)\n */\nfunction f_46(n)", "zh": "/**\n * 给定一个整数 n，编写一个函数来计算从 1 到 n 之间所有是 3 或 5 的倍数的数字之和。\n * 如果一个数字同时是 3 和 5 的倍数，它应该只被计算一次。\n * 例如：\n *     f_46(10); // 返回 33 (3 + 5 + 6 + 9 + 10)\n */\nfunction f_46(n)", "fr": "/**\n * Étant donné un entier n, écrivez une fonction pour calculer la somme de tous les nombres de 1 à n\n * qui sont des multiples de 3 ou 5. Si un nombre est un multiple à la fois de 3 et de 5,\n * il ne doit être compté qu'une seule fois.\n * Par exemple :\n *     f_46(10); // retourne 33 (3 + 5 + 6 + 9 + 10)\n */\nfunction f_46(n)", "de": "/**\n * Gegeben eine ganze Zahl n, schreibe eine Funktion, um die Summe aller Zahlen von 1 bis n\n * zu berechnen, die Vielfache von entweder 3 oder 5 sind. Wenn eine Zahl ein Vielfaches von sowohl 3 als auch 5 ist,\n * sollte sie nur einmal gezählt werden.\n * Zum Beispiel:\n *     f_46(10); // gibt 33 zurück (3 + 5 + 6 + 9 + 10)\n */\nfunction f_46(n)", "ha": "/**\n * Idan aka ba da lamba n, rubuta wata aiki don lissafin jimillar dukkan lambobi daga 1 zuwa n\n * waɗanda suke masu yawa na ko dai 3 ko 5. Idan lamba tana mai yawa na duka 3 da 5,\n * ya kamata a ƙirga shi sau ɗaya kawai.\n * Alal misali:\n *     f_46(10); // ya dawo da 33 (3 + 5 + 6 + 9 + 10)\n */\nfunction f_46(n)", "hi": "/**\n * दिए गए पूर्णांक n के लिए, एक फ़ंक्शन लिखें जो 1 से n तक के उन सभी संख्याओं का योग गणना करे\n * जो या तो 3 या 5 के गुणज हैं। यदि कोई संख्या 3 और 5 दोनों की गुणज है,\n * तो उसे केवल एक बार गिना जाना चाहिए।\n * उदाहरण के लिए:\n *     f_46(10); // 33 लौटाता है (3 + 5 + 6 + 9 + 10)\n */\nfunction f_46(n)", "hu": "/**\n * Adott egy egész szám n, írj egy függvényt, amely kiszámítja az összes 1-től n-ig terjedő szám összegét,\n * amelyek 3 vagy 5 többszörösei. Ha egy szám mind a 3-nak, mind az 5-nek többszöröse,\n * akkor csak egyszer kell számolni.\n * Például:\n *     f_46(10); // visszaadja 33 (3 + 5 + 6 + 9 + 10)\n */\nfunction f_46(n)", "es": "/**\n * Dado un entero n, escribe una función para calcular la suma de todos los números desde 1 hasta n\n * que son múltiplos de 3 o 5. Si un número es múltiplo de ambos 3 y 5,\n * solo debe contarse una vez.\n * Por ejemplo:\n *     f_46(10); // devuelve 33 (3 + 5 + 6 + 9 + 10)\n */\nfunction f_46(n)", "arb": "/**\n * بالنظر إلى عدد صحيح n، اكتب دالة لحساب مجموع جميع الأرقام من 1 إلى n\n * التي هي مضاعفات إما لـ 3 أو 5. إذا كان الرقم مضاعفًا لكل من 3 و 5،\n * يجب أن يُحسب مرة واحدة فقط.\n * على سبيل المثال:\n *     f_46(10); // يعيد 33 (3 + 5 + 6 + 9 + 10)\n */\nfunction f_46(n)", "sw": "/**\n * Ukipewa nambari nzima n, andika kazi ya kuhesabu jumla ya nambari zote kutoka 1 hadi n\n * ambazo ni maradufu ya 3 au 5. Ikiwa nambari ni maradufu ya 3 na 5,\n * inapaswa kuhesabiwa mara moja tu.\n * Kwa mfano:\n *     f_46(10); // inarudisha 33 (3 + 5 + 6 + 9 + 10)\n */\nfunction f_46(n)", "tr": "/**\n * Verilen bir tamsayı n için, 1'den n'e kadar olan sayılardan 3 veya 5'in katı olanların toplamını hesaplayan bir fonksiyon yazın.\n * Bir sayı hem 3'ün hem de 5'in katıysa, yalnızca bir kez sayılmalıdır.\n * Örneğin:\n *     f_46(10); // 33 döndürür (3 + 5 + 6 + 9 + 10)\n */\nfunction f_46(n)", "vi": "/**\n * Cho một số nguyên n, viết một hàm để tính tổng của tất cả các số từ 1 đến n\n * mà là bội số của 3 hoặc 5. Nếu một số là bội số của cả 3 và 5,\n * nó chỉ nên được tính một lần.\n * Ví dụ:\n *     f_46(10); // trả về 33 (3 + 5 + 6 + 9 + 10)\n */\nfunction f_46(n)", "id": "/**\n * Diberikan sebuah bilangan bulat n, tulislah sebuah fungsi untuk menghitung jumlah semua angka dari 1 hingga n\n * yang merupakan kelipatan dari 3 atau 5. Jika sebuah angka merupakan kelipatan dari 3 dan 5,\n * angka tersebut hanya dihitung sekali.\n * Sebagai contoh:\n *     f_46(10); // mengembalikan 33 (3 + 5 + 6 + 9 + 10)\n */\nfunction f_46(n)", "ja": "/**\n * 整数 n が与えられたとき、1 から n までのすべての数のうち、3 または 5 の倍数であるものの合計を計算する関数を書いてください。\n * 数字が 3 と 5 の両方の倍数である場合、それは一度だけカウントされるべきです。\n * 例えば:\n *     f_46(10); // 33 を返します (3 + 5 + 6 + 9 + 10)\n */\nfunction f_46(n)", "ko": "/**\n * 정수 n이 주어지면, 1부터 n까지의 숫자 중 3 또는 5의 배수인 모든 숫자의 합을 계산하는 함수를 작성하세요.\n * 숫자가 3과 5의 공배수인 경우, 한 번만 계산되어야 합니다.\n * 예를 들어:\n *     f_46(10); // 33을 반환합니다 (3 + 5 + 6 + 9 + 10)\n */\nfunction f_46(n)", "ml": "/**\n * ഒരു പൂർണ്ണസംഖ്യ n നൽകിയാൽ, 1 മുതൽ n വരെ 3 അല്ലെങ്കിൽ 5 ന്റെ ഗുണിതകങ്ങൾ ആയ എല്ലാ സംഖ്യകളുടെയും മൊത്തം കണക്കാക്കാൻ ഒരു ഫങ്ഷൻ എഴുതുക.\n * ഒരു സംഖ്യ 3 ന്റെയും 5 ന്റെയും ഗുണിതകം ആയാൽ, അത് ഒരിക്കൽ മാത്രമേ എണ്ണിക്കൊള്ളൂ.\n * ഉദാഹരണത്തിന്:\n *     f_46(10); // 33 (3 + 5 + 6 + 9 + 10) മടക്കുന്നു\n */\nfunction f_46(n)", "fa": "/**\n * با داشتن یک عدد صحیح n، یک تابع بنویسید تا مجموع تمام اعداد از 1 تا n\n * که مضرب 3 یا 5 هستند را محاسبه کند. اگر عددی مضرب هر دو 3 و 5 باشد،\n * باید فقط یک بار شمرده شود.\n * برای مثال:\n *     f_46(10); // برمی‌گرداند 33 (3 + 5 + 6 + 9 + 10)\n */\nfunction f_46(n)"}, "canonical_solution": "{\n    let sum = 0;\n    for (let i = 1; i <= n; ++i) {\n        if (i % 3 === 0 || i % 5 === 0) {\n            sum += i;\n        }\n    }\n    return sum;\n}", "instruction": {"en": "Write a JavaScript function `function f_46(n)` to solve the following problem:\nGiven an integer n, write a function to compute the sum of all numbers from 1 to n that are multiples of either 3 or 5. If a number is a multiple of both 3 and 5, it should only be counted once.\nFor example:\n    f_46(10); // returns 33 (3 + 5 + 6 + 9 + 10)", "sq": "Shkruani një funksion JavaScript `function f_46(n)` për të zgjidhur problemin e mëposhtëm:  \nDuke pasur një numër të plotë n, shkruani një funksion për të llogaritur shumën e të gjithë numrave nga 1 deri në n që janë shumëfish i 3 ose 5. Nëse një numër është shumëfish i të dyjave 3 dhe 5, ai duhet të numërohet vetëm një herë.  \nPër shembull:  \n    f_46(10); // kthen 33 (3 + 5 + 6 + 9 + 10)", "hy": "Գրեք JavaScript ֆունկցիա `function f_46(n)` հետևյալ խնդիրը լուծելու համար:\nՏրված է ամբողջ թիվ n, գրեք ֆունկցիա՝ հաշվելու համար 1-ից մինչև n բոլոր այն թվերի գումարը, որոնք բազմապատիկ են 3-ի կամ 5-ի։ Եթե թիվը բազմապատիկ է և՛ 3-ի, և՛ 5-ի, այն պետք է հաշվի առնվի միայն մեկ անգամ։\nՕրինակ:\n    f_46(10); // վերադարձնում է 33 (3 + 5 + 6 + 9 + 10)", "bn": "একটি জাভাস্ক্রিপ্ট ফাংশন `function f_46(n)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি পূর্ণসংখ্যা n দেওয়া হলে, একটি ফাংশন লিখুন যা 1 থেকে n পর্যন্ত সমস্ত সংখ্যার যোগফল গণনা করে যা 3 বা 5 এর গুণিতক। যদি কোনো সংখ্যা 3 এবং 5 উভয়েরই গুণিতক হয়, তবে এটি কেবল একবার গণনা করা উচিত।\nউদাহরণস্বরূপ:\n    f_46(10); // returns 33 (3 + 5 + 6 + 9 + 10)", "bg": "Напишете функция на JavaScript `function f_46(n)`, за да решите следния проблем:  \nДадено е цяло число n, напишете функция за изчисляване на сумата на всички числа от 1 до n, които са кратни на 3 или 5. Ако едно число е кратно и на 3, и на 5, то трябва да се брои само веднъж.  \nНапример:  \n    f_46(10); // връща 33 (3 + 5 + 6 + 9 + 10)", "zh": "编写一个 JavaScript 函数 `function f_46(n)` 来解决以下问题：  \n给定一个整数 n，编写一个函数来计算从 1 到 n 的所有 3 或 5 的倍数的和。如果一个数字同时是 3 和 5 的倍数，则只应计算一次。  \n例如：  \n    f_46(10); // 返回 33 (3 + 5 + 6 + 9 + 10)", "fr": "Écrire une fonction JavaScript `function f_46(n)` pour résoudre le problème suivant :  \nÉtant donné un entier n, écrire une fonction pour calculer la somme de tous les nombres de 1 à n qui sont des multiples de 3 ou 5. Si un nombre est un multiple à la fois de 3 et de 5, il ne doit être compté qu'une seule fois.  \nPar exemple :  \n    f_46(10); // retourne 33 (3 + 5 + 6 + 9 + 10)", "de": "Schreiben Sie eine JavaScript-Funktion `function f_46(n)`, um das folgende Problem zu lösen:\nGegeben eine ganze Zahl n, schreiben Sie eine Funktion, um die Summe aller Zahlen von 1 bis n zu berechnen, die Vielfache von entweder 3 oder 5 sind. Wenn eine Zahl ein Vielfaches sowohl von 3 als auch von 5 ist, sollte sie nur einmal gezählt werden.\nZum Beispiel:\n    f_46(10); // gibt 33 zurück (3 + 5 + 6 + 9 + 10)", "ha": "Rubuta wani aikin JavaScript `function f_46(n)` don warware matsalar mai zuwa:\nAn ba da wani cikakken lamba n, rubuta wani aiki don lissafin jimillar dukkan lambobi daga 1 zuwa n waɗanda suke masu yawa na 3 ko 5. Idan lamba tana da yawa na 3 da 5 duka, ya kamata a ƙidaya shi sau ɗaya kawai.\nMisali:\n    f_46(10); // yana dawowa 33 (3 + 5 + 6 + 9 + 10)", "hi": "`function f_46(n)` समस्या को हल करने के लिए एक JavaScript फ़ंक्शन लिखें:\nदिए गए पूर्णांक n के लिए, एक फ़ंक्शन लिखें जो 1 से n तक के सभी संख्याओं का योग गणना करे जो या तो 3 या 5 के गुणज हैं। यदि कोई संख्या 3 और 5 दोनों का गुणज है, तो उसे केवल एक बार गिना जाना चाहिए।\nउदाहरण के लिए:\n    f_46(10); // 33 लौटाता है (3 + 5 + 6 + 9 + 10)", "hu": "Írj egy JavaScript függvényt `function f_46(n)` a következő probléma megoldására:\nAdott egy egész szám n, írj egy függvényt, amely kiszámítja az összes 1 és n közötti szám összegét, amelyek 3 vagy 5 többszörösei. Ha egy szám mind a 3, mind az 5 többszöröse, akkor csak egyszer kell számolni.\nPéldául:\n    f_46(10); // returns 33 (3 + 5 + 6 + 9 + 10)", "es": "Escribe una función de JavaScript `function f_46(n)` para resolver el siguiente problema:\nDado un entero n, escribe una función para calcular la suma de todos los números desde 1 hasta n que sean múltiplos de 3 o 5. Si un número es múltiplo de ambos 3 y 5, solo debe contarse una vez.\nPor ejemplo:\n    f_46(10); // devuelve 33 (3 + 5 + 6 + 9 + 10)", "arb": "اكتب دالة JavaScript `function f_46(n)` لحل المشكلة التالية:\nمعطى عدد صحيح n، اكتب دالة لحساب مجموع جميع الأرقام من 1 إلى n التي هي مضاعفات إما لـ 3 أو 5. إذا كان الرقم مضاعفًا لكل من 3 و 5، فيجب احتسابه مرة واحدة فقط.\nعلى سبيل المثال:\n    f_46(10); // يعيد 33 (3 + 5 + 6 + 9 + 10)", "sw": "Andika kazi ya JavaScript `function f_46(n)` kutatua tatizo lifuatalo:\nUkipiwa nambari nzima n, andika kazi ya kuhesabu jumla ya nambari zote kutoka 1 hadi n ambazo ni marudufu ya 3 au 5. Ikiwa nambari ni marudufu ya 3 na 5, inapaswa kuhesabiwa mara moja tu.\nKwa mfano:\n    f_46(10); // inarudisha 33 (3 + 5 + 6 + 9 + 10)", "tr": "Bir JavaScript fonksiyonu `function f_46(n)` yazın ve aşağıdaki problemi çözün:\nVerilen bir tamsayı n için, 1'den n'ye kadar olan sayılardan 3 veya 5'in katı olanların toplamını hesaplayan bir fonksiyon yazın. Bir sayı hem 3 hem de 5'in katıysa, yalnızca bir kez sayılmalıdır.\nÖrneğin:\n    f_46(10); // 33 döndürür (3 + 5 + 6 + 9 + 10)", "vi": "Viết một hàm JavaScript `function f_46(n)` để giải quyết vấn đề sau:  \nCho một số nguyên n, viết một hàm để tính tổng của tất cả các số từ 1 đến n mà là bội số của 3 hoặc 5. Nếu một số là bội số của cả 3 và 5, nó chỉ nên được tính một lần.  \nVí dụ:  \n    f_46(10); // trả về 33 (3 + 5 + 6 + 9 + 10)", "id": "Tulis sebuah fungsi JavaScript `function f_46(n)` untuk menyelesaikan masalah berikut:\nDiberikan sebuah bilangan bulat n, tulislah sebuah fungsi untuk menghitung jumlah dari semua angka dari 1 hingga n yang merupakan kelipatan dari 3 atau 5. Jika sebuah angka merupakan kelipatan dari 3 dan 5, angka tersebut hanya dihitung sekali.\nSebagai contoh:\n    f_46(10); // mengembalikan 33 (3 + 5 + 6 + 9 + 10)", "ja": "JavaScript関数`function f_46(n)`を書いて、次の問題を解決してください:\n整数nが与えられたとき、1からnまでの数字のうち、3または5の倍数であるすべての数字の合計を計算する関数を書いてください。ある数字が3と5の両方の倍数である場合、それは一度だけカウントされるべきです。\n例えば:\n    f_46(10); // returns 33 (3 + 5 + 6 + 9 + 10)", "ko": "JavaScript 함수 `function f_46(n)`를 작성하여 다음 문제를 해결하십시오:\n정수 n이 주어졌을 때, 1부터 n까지의 숫자 중 3 또는 5의 배수인 모든 숫자의 합을 계산하는 함수를 작성하십시오. 숫자가 3과 5의 공배수인 경우에는 한 번만 계산해야 합니다.\n예를 들어:\n    f_46(10); // returns 33 (3 + 5 + 6 + 9 + 10)", "ml": "`function f_46(n)` എന്ന ജാവാസ്ക്രിപ്റ്റ് ഫംഗ്ഷൻ എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nഒരു പൂർണ്ണസംഖ്യ n നൽകിയാൽ, 3 അല്ലെങ്കിൽ 5 ന്റെ ഗുണിതങ്ങളായ 1 മുതൽ n വരെ ഉള്ള എല്ലാ സംഖ്യകളുടെ മൊത്തം കണക്കാക്കാൻ ഒരു ഫംഗ്ഷൻ എഴുതുക. ഒരു സംഖ്യ 3 നും 5 നും ഗുണിതമാണെങ്കിൽ, അത് ഒരിക്കൽ മാത്രമേ എണ്ണിക്കൊള്ളൂ.\nഉദാഹരണത്തിന്:\n    f_46(10); // 33 (3 + 5 + 6 + 9 + 10) മടക്കുന്നു", "fa": "یک تابع جاوااسکریپت `function f_46(n)` بنویسید تا مسئله زیر را حل کند:\nبا توجه به یک عدد صحیح n، تابعی بنویسید که مجموع تمام اعداد از 1 تا n که مضربی از 3 یا 5 هستند را محاسبه کند. اگر عددی مضربی از هر دو 3 و 5 باشد، باید فقط یک بار شمارش شود.\nبرای مثال:\n    f_46(10); // مقدار 33 را برمی‌گرداند (3 + 5 + 6 + 9 + 10)"}, "level": "easy", "test": "const testf_46 = () => {\n    console.assert(f_46(10) === 33, 'Test case n=10 failed');\n    console.assert(f_46(15) === 60, 'Test case n=15 failed');\n    console.assert(f_46(20) === 98, 'Test case n=20 failed');\n    console.assert(f_46(5) === 8, 'Test case n=5 failed');\n    console.assert(f_46(3) === 3, 'Test case n=3 failed');\n    console.assert(f_46(6) === 14, 'Test case n=6 failed');\n    console.assert(f_46(9) === 23, 'Test case n=9 failed');\n    console.assert(f_46(12) === 45, 'Test case n=12 failed');\n    console.assert(f_46(17) === 60, 'Test case n=17 failed');\n    console.assert(f_46(21) === 119, 'Test case n=21 failed');\n    console.assert(f_46(25) === 168, 'Test case n=25 failed');\n};\n\ntestf_46();", "entry_point": "f_46", "signature": "function f_46(n)", "docstring": {"en": "Given an integer n, write a function to compute the sum of all numbers from 1 to n that are multiples of either 3 or 5. If a number is a multiple of both 3 and 5, it should only be counted once.\nFor example:\n    f_46(10); // returns 33 (3 + 5 + 6 + 9 + 10)", "sq": "Duke pasur një numër të plotë n, shkruani një funksion për të llogaritur shumën e të gjithë numrave nga 1 deri në n që janë shumëfish të 3 ose 5. Nëse një numër është shumëfish i të dyjave 3 dhe 5, ai duhet të numërohet vetëm një herë.\nPër shembull:\n    f_46(10); // kthen 33 (3 + 5 + 6 + 9 + 10)", "hy": "Տրված է n ամբողջ թիվը, գրեք ֆունկցիա՝ հաշվելու համար 1-ից n բոլոր այն թվերի գումարը, որոնք բազմապատիկ են 3-ի կամ 5-ի: Եթե թիվը բազմապատիկ է և՛ 3-ի, և՛ 5-ի, այն պետք է հաշվի առնվի միայն մեկ անգամ:\nՕրինակ:\n    f_46(10); // վերադարձնում է 33 (3 + 5 + 6 + 9 + 10)", "bn": "একটি পূর্ণসংখ্যা n দেওয়া হলে, ১ থেকে n পর্যন্ত সমস্ত সংখ্যার যোগফল গণনা করার জন্য একটি ফাংশন লিখুন যা ৩ অথবা ৫ এর গুণিতক। যদি কোনো সংখ্যা ৩ এবং ৫ উভয়েরই গুণিতক হয়, তবে এটি কেবল একবার গণনা করা উচিত।\n\nউদাহরণস্বরূপ:\n    f_46(10); // 33 ফেরত দেয় (3 + 5 + 6 + 9 + 10)", "bg": "Дадено е цяло число n, напишете функция за изчисляване на сумата на всички числа от 1 до n, които са кратни на 3 или 5. Ако едно число е кратно и на 3, и на 5, то трябва да се брои само веднъж.\nНапример:\n    f_46(10); // връща 33 (3 + 5 + 6 + 9 + 10)", "zh": "给定一个整数 n，编写一个函数来计算从 1 到 n 之间所有是 3 或 5 的倍数的数字之和。如果一个数字同时是 3 和 5 的倍数，则只应计算一次。\n例如：\n    f_46(10); // 返回 33 (3 + 5 + 6 + 9 + 10)", "fr": "Étant donné un entier n, écrivez une fonction pour calculer la somme de tous les nombres de 1 à n qui sont des multiples de 3 ou 5. Si un nombre est un multiple à la fois de 3 et de 5, il ne doit être compté qu'une seule fois.\nPar exemple :\n    f_46(10); // retourne 33 (3 + 5 + 6 + 9 + 10)", "de": "Angenommen, eine ganze Zahl n ist gegeben, schreiben Sie eine Funktion, um die Summe aller Zahlen von 1 bis n zu berechnen, die Vielfache von entweder 3 oder 5 sind. Wenn eine Zahl ein Vielfaches von sowohl 3 als auch 5 ist, sollte sie nur einmal gezählt werden.\nZum Beispiel:\n    f_46(10); // gibt 33 zurück (3 + 5 + 6 + 9 + 10)", "ha": "An ba da wani lamba n, rubuta wata aiki don ƙididdige jumlar duk lambobin daga 1 zuwa n waɗanda suke masu yawa na ko dai 3 ko 5. Idan lamba tana da yawa na duka 3 da 5, ya kamata a ƙirga ta sau ɗaya kawai.\nMisali:\n    f_46(10); // yana dawowa 33 (3 + 5 + 6 + 9 + 10)", "hi": "दिए गए पूर्णांक n के लिए, एक फ़ंक्शन लिखें जो 1 से n तक के उन सभी संख्याओं का योग गणना करे जो 3 या 5 के गुणज हैं। यदि कोई संख्या 3 और 5 दोनों का गुणज है, तो उसे केवल एक बार गिना जाना चाहिए।\nउदाहरण के लिए:\n    f_46(10); // 33 लौटाता है (3 + 5 + 6 + 9 + 10)", "hu": "Adott egy egész szám n, írj egy függvényt, amely kiszámítja az összes olyan szám összegét 1-től n-ig, amelyek 3 vagy 5 többszörösei. Ha egy szám mind a 3, mind az 5 többszöröse, akkor azt csak egyszer kell számolni.\nPéldául:\n    f_46(10); // visszaadja a 33-at (3 + 5 + 6 + 9 + 10)", "es": "Dado un entero n, escribe una función para calcular la suma de todos los números desde 1 hasta n que sean múltiplos de 3 o 5. Si un número es múltiplo de ambos 3 y 5, debe contarse solo una vez.  \nPor ejemplo:  \n    f_46(10); // devuelve 33 (3 + 5 + 6 + 9 + 10)", "arb": "بالنظر إلى عدد صحيح n، اكتب دالة لحساب مجموع جميع الأرقام من 1 إلى n التي هي من مضاعفات إما 3 أو 5. إذا كان الرقم من مضاعفات كل من 3 و5، فيجب احتسابه مرة واحدة فقط.  \nعلى سبيل المثال:  \n    f_46(10); // يعيد 33 (3 + 5 + 6 + 9 + 10)", "sw": "Ukipewa nambari nzima n, andika kazi ya kuhesabu jumla ya nambari zote kutoka 1 hadi n ambazo ni maradufu ya 3 au 5. Ikiwa nambari ni maradufu ya 3 na 5, inapaswa kuhesabiwa mara moja tu.\nKwa mfano:\n    f_46(10); // inarudisha 33 (3 + 5 + 6 + 9 + 10)", "tr": "Verilen bir tamsayı n için, 1'den n'e kadar olan sayılardan 3 veya 5'in katı olanların toplamını hesaplayan bir fonksiyon yazın. Bir sayı hem 3 hem de 5'in katı ise, yalnızca bir kez sayılmalıdır.\nÖrneğin:\n    f_46(10); // 33 döndürür (3 + 5 + 6 + 9 + 10)", "vi": "Cho một số nguyên n, viết một hàm để tính tổng của tất cả các số từ 1 đến n mà là bội số của 3 hoặc 5. Nếu một số là bội số của cả 3 và 5, nó chỉ nên được tính một lần.\nVí dụ:\n    f_46(10); // trả về 33 (3 + 5 + 6 + 9 + 10)", "id": "Diberikan sebuah bilangan bulat n, tulislah sebuah fungsi untuk menghitung jumlah semua angka dari 1 hingga n yang merupakan kelipatan dari 3 atau 5. Jika sebuah angka merupakan kelipatan dari 3 dan 5, angka tersebut hanya dihitung sekali.\nSebagai contoh:\n    f_46(10); // mengembalikan 33 (3 + 5 + 6 + 9 + 10)", "ja": "整数 n が与えられたとき、3 または 5 のいずれかの倍数である 1 から n までのすべての数の合計を計算する関数を書いてください。ある数が 3 と 5 の両方の倍数である場合、それは一度だけカウントされるべきです。\n例えば:\n    f_46(10); // 33 を返します (3 + 5 + 6 + 9 + 10)", "ko": "정수 n이 주어졌을 때, 1부터 n까지의 숫자 중 3 또는 5의 배수인 모든 숫자의 합을 계산하는 함수를 작성하세요. 숫자가 3과 5의 공배수인 경우에는 한 번만 계산되어야 합니다.\n예를 들어:\n    f_46(10); // 33을 반환합니다 (3 + 5 + 6 + 9 + 10)", "ml": "ഒരു പൂർണ്ണസംഖ്യ n നൽകിയാൽ, 3 അല്ലെങ്കിൽ 5 ന്റെ ഗുണിതകങ്ങൾ ആയ 1 മുതൽ n വരെ ഉള്ള എല്ലാ സംഖ്യകളുടെയും മൊത്തം കൂട്ടം കണക്കാക്കാൻ ഒരു ഫങ്ഷൻ എഴുതുക. ഒരു സംഖ്യ 3നും 5നും ഗുണിതകമായാൽ, അത് ഒരിക്കൽ മാത്രം എണ്ണണം. \nഉദാഹരണത്തിന്:\n    f_46(10); // 33 (3 + 5 + 6 + 9 + 10) മടക്കുന്നു", "fa": "با توجه به یک عدد صحیح n، یک تابع بنویسید که مجموع تمام اعداد از 1 تا n را که مضرب 3 یا 5 هستند محاسبه کند. اگر عددی مضرب هر دو 3 و 5 باشد، باید فقط یک بار شمرده شود.\nبرای مثال:\n    f_46(10); // مقدار 33 را برمی‌گرداند (3 + 5 + 6 + 9 + 10)"}}
{"task_id": "JavaScript/47", "prompt": {"en": "/**\n * Determine if a given string is a palindrome.\n * A palindrome is a word, phrase, number, or other sequence of characters\n * that reads the same forward and backward (ignoring spaces, punctuation,\n * and capitalization).\n * \n * Examples:\n * f_47(\"racecar\") // returns true\n * f_47(\"hello\") // returns false\n */\nfunction f_47(str)", "sq": "/**\n * Përcaktoni nëse një varg i dhënë është një palindrom.\n * Një palindrom është një fjalë, frazë, numër, ose një sekuencë tjetër karakteresh\n * që lexohet njësoj përpara dhe prapa (duke injoruar hapësirat, shenjat e pikësimit,\n * dhe shkronjat e mëdha).\n * \n * Shembuj:\n * f_47(\"racecar\") // kthen true\n * f_47(\"hello\") // kthen false\n */\nfunction f_47(str)", "hy": "/**\n * Պարզել, արդյոք տրված տողը պալինդրոմ է:\n * Պալինդրոմը բառ, արտահայտություն, թիվ կամ այլ նիշերի հաջորդականություն է,\n * որը կարդացվում է նույն կերպ առաջ և հետ (անտեսելով բացատները, կետադրությունը\n * և մեծատառերը):\n * \n * Օրինակներ:\n * f_47(\"racecar\") // վերադարձնում է true\n * f_47(\"hello\") // վերադարձնում է false\n */\nfunction f_47(str)", "bn": "/**\n * একটি প্রদত্ত স্ট্রিং প্যালিনড্রোম কিনা তা নির্ধারণ করুন।\n * একটি প্যালিনড্রোম হল একটি শব্দ, বাক্যাংশ, সংখ্যা, বা অন্যান্য অক্ষরের ক্রম\n * যা সামনের দিকে এবং পিছনের দিকে একইভাবে পড়ে (স্পেস, বিরামচিহ্ন,\n * এবং বড় হাতের অক্ষর উপেক্ষা করে)।\n * \n * উদাহরণসমূহ:\n * f_47(\"racecar\") // true রিটার্ন করে\n * f_47(\"hello\") // false রিটার্ন করে\n */\nfunction f_47(str)", "bg": "/**\n * Определете дали даден низ е палиндром.\n * Палиндром е дума, фраза, число или друга последователност от символи,\n * която се чете еднакво напред и назад (като се игнорират интервалите, пунктуацията\n * и главните букви).\n * \n * Примери:\n * f_47(\"racecar\") // връща true\n * f_47(\"hello\") // връща false\n */\nfunction f_47(str)", "zh": "/**\n * 确定给定的字符串是否是回文。\n * 回文是指正读和反读都相同的单词、短语、数字或其他字符序列\n * （忽略空格、标点符号和大小写）。\n * \n * 示例:\n * f_47(\"racecar\") // 返回 true\n * f_47(\"hello\") // 返回 false\n */\nfunction f_47(str)", "fr": "/**\n * Déterminer si une chaîne donnée est un palindrome.\n * Un palindrome est un mot, une phrase, un nombre ou une autre séquence de caractères\n * qui se lit de la même façon à l'endroit et à l'envers (en ignorant les espaces, la ponctuation,\n * et la capitalisation).\n * \n * Exemples :\n * f_47(\"racecar\") // retourne true\n * f_47(\"hello\") // retourne false\n */\nfunction f_47(str)", "de": "/**\n * Bestimmen, ob eine gegebene Zeichenkette ein Palindrom ist.\n * Ein Palindrom ist ein Wort, ein Satz, eine Zahl oder eine andere Zeichenfolge,\n * die vorwärts und rückwärts gleich gelesen wird (ohne Berücksichtigung von Leerzeichen, \n * Satzzeichen und Groß-/Kleinschreibung).\n * \n * Beispiele:\n * f_47(\"racecar\") // gibt true zurück\n * f_47(\"hello\") // gibt false zurück\n */\nfunction f_47(str)", "ha": "/**\n * Tantance ko wani kirtani da aka bayar palindrome ne.\n * Palindrome kalma ce, jimla, lamba, ko wata jerin haruffa\n * da ke karantawa iri ɗaya gaba da baya (ba tare da la'akari da sarari, rubutu,\n * da manyan ba).\n * \n * Misalai:\n * f_47(\"racecar\") // ya dawo da true\n * f_47(\"hello\") // ya dawo da false\n */\nfunction f_47(str)", "hi": "/**\n * यह निर्धारित करें कि दिया गया स्ट्रिंग एक पालिंड्रोम है या नहीं।\n * एक पालिंड्रोम एक शब्द, वाक्यांश, संख्या, या अन्य वर्णों का अनुक्रम है\n * जो आगे और पीछे से समान रूप से पढ़ा जाता है (स्पेस, विराम चिह्न,\n * और बड़े अक्षरों को नजरअंदाज करते हुए)।\n * \n * उदाहरण:\n * f_47(\"racecar\") // true लौटाता है\n * f_47(\"hello\") // false लौटाता है\n */\nfunction f_47(str)", "hu": "/**\n * Határozza meg, hogy egy adott sztring palindróm-e.\n * Egy palindróm egy szó, kifejezés, szám vagy más karaktersorozat,\n * amely előre és hátra olvasva is ugyanaz (figyelmen kívül hagyva a szóközöket, írásjeleket\n * és a nagybetűket).\n * \n * Példák:\n * f_47(\"racecar\") // visszaadja: true\n * f_47(\"hello\") // visszaadja: false\n */\nfunction f_47(str)", "es": "/**\n * Determinar si una cadena dada es un palíndromo.\n * Un palíndromo es una palabra, frase, número u otra secuencia de caracteres\n * que se lee igual de adelante hacia atrás (ignorando espacios, puntuación\n * y mayúsculas).\n * \n * Ejemplos:\n * f_47(\"racecar\") // devuelve true\n * f_47(\"hello\") // devuelve false\n */\nfunction f_47(str)", "arb": "/**\n * تحديد ما إذا كانت سلسلة معينة هي كلمة متطابقة.\n * الكلمة المتطابقة هي كلمة أو عبارة أو رقم أو تسلسل آخر من الأحرف\n * الذي يقرأ نفسه من الأمام إلى الخلف والعكس صحيح (مع تجاهل المسافات وعلامات الترقيم\n * والحروف الكبيرة).\n * \n * أمثلة:\n * f_47(\"racecar\") // يعيد true\n * f_47(\"hello\") // يعيد false\n */\nfunction f_47(str)", "sw": "/**\n * Tambua kama string iliyotolewa ni palindrome.\n * Palindrome ni neno, kifungu, nambari, au mfuatano mwingine wa herufi\n * ambao unasomeka sawa mbele na nyuma (ukipuuza nafasi, alama za uakifishaji,\n * na herufi kubwa na ndogo).\n * \n * Mifano:\n * f_47(\"racecar\") // inarudisha true\n * f_47(\"hello\") // inarudisha false\n */\nfunction f_47(str)", "tr": "/**\n * Verilen bir stringin palindrom olup olmadığını belirleyin.\n * Palindrom, ileri ve geri okunduğunda aynı olan (boşluk, noktalama işaretleri\n * ve büyük/küçük harf farkı göz ardı edilerek) bir kelime, ifade, sayı veya diğer karakter dizisidir.\n * \n * Örnekler:\n * f_47(\"racecar\") // true döndürür\n * f_47(\"hello\") // false döndürür\n */\nfunction f_47(str)", "vi": "/**\n * Xác định xem một chuỗi cho trước có phải là chuỗi đối xứng hay không.\n * Chuỗi đối xứng là một từ, cụm từ, số, hoặc một chuỗi ký tự khác\n * mà khi đọc từ trái sang phải và từ phải sang trái đều giống nhau (bỏ qua khoảng trắng, dấu câu,\n * và chữ hoa chữ thường).\n * \n * Ví dụ:\n * f_47(\"racecar\") // trả về true\n * f_47(\"hello\") // trả về false\n */\nfunction f_47(str)", "id": "/**\n * Menentukan apakah string yang diberikan adalah palindrom.\n * Palindrom adalah kata, frasa, angka, atau urutan karakter lainnya\n * yang dibaca sama dari depan ke belakang (mengabaikan spasi, tanda baca,\n * dan kapitalisasi).\n * \n * Contoh:\n * f_47(\"racecar\") // mengembalikan true\n * f_47(\"hello\") // mengembalikan false\n */\nfunction f_47(str)", "ja": "/**\n * 与えられた文字列が回文かどうかを判断します。\n * 回文とは、前から読んでも後ろから読んでも同じになる単語、フレーズ、数字、または他の文字列のことです\n * （スペース、句読点、大文字小文字を無視します）。\n * \n * 例:\n * f_47(\"racecar\") // trueを返します\n * f_47(\"hello\") // falseを返します\n */\nfunction f_47(str)", "ko": "/**\n * 주어진 문자열이 회문인지 확인합니다.\n * 회문은 앞뒤로 읽어도 동일한 단어, 구, 숫자 또는 기타 문자 시퀀스를 말합니다\n * (공백, 구두점, 대소문자를 무시하고).\n * \n * 예시:\n * f_47(\"racecar\") // true 반환\n * f_47(\"hello\") // false 반환\n */\nfunction f_47(str)", "ml": "/**\n * നൽകിയ ഒരു സ്ട്രിംഗ് പലിൻഡ്രോമാണോ എന്ന് നിർണയിക്കുക.\n * പലിൻഡ്രോം എന്നത് ഒരു വാക്ക്, വാചകം, സംഖ്യ, അല്ലെങ്കിൽ മറ്റ് പ്രതീകങ്ങളുടെ ക്രമമാണ്\n * അത് മുന്നോട്ടും പിന്നോട്ടും ഒരേപോലെ വായിക്കപ്പെടുന്നു (ഇടവേളകൾ, ചിഹ്നങ്ങൾ,\n * അക്ഷരമാലാക്രമം എന്നിവ അവഗണിക്കുന്നു).\n * \n * ഉദാഹരണങ്ങൾ:\n * f_47(\"racecar\") // true തിരികെ നൽകുന്നു\n * f_47(\"hello\") // false തിരികെ നൽകുന്നു\n */\nfunction f_47(str)", "fa": "/**\n * تعیین کنید که آیا یک رشته داده شده یک پالیندروم است.\n * پالیندروم کلمه، عبارت، عدد یا دنباله دیگری از کاراکترهاست\n * که از جلو به عقب و از عقب به جلو یکسان خوانده می‌شود (با نادیده گرفتن فضاها، نشانه‌گذاری‌ها،\n * و حروف بزرگ و کوچک).\n * \n * مثال‌ها:\n * f_47(\"racecar\") // بازمی‌گرداند true\n * f_47(\"hello\") // بازمی‌گرداند false\n */\nfunction f_47(str)"}, "canonical_solution": "{\n  let start = 0;\n  let end = str.length - 1;\n\n  while (start < end) {\n    // Skip non-alphanumeric characters and handle case insensitivity\n    while (!isalnum(str[start]) && start < end) start++;\n    while (!isalnum(str[end]) && start < end) end--;\n    if (str[start].toLowerCase() !== str[end].toLowerCase())\n      return false;\n    start++;\n    end--;\n  }\n  return true;\n}\n\n// Helper function to check if a character is alphanumeric\nfunction isalnum(char) {\n  let code = char.charCodeAt(0);\n  return (code > 47 && code < 58) || // numeric (0-9)\n         (code > 64 && code < 91) || // upper alpha (A-Z)\n         (code > 96 && code < 123);  // lower alpha (a-z)\n}", "instruction": {"en": "Write a JavaScript function `function f_47(str)` to solve the following problem:\nDetermine if a given string is a palindrome.\nA palindrome is a word, phrase, number, or other sequence of characters\nthat reads the same forward and backward (ignoring spaces, punctuation,\nand capitalization).\n\nExamples:\nf_47(\"racecar\") // returns true\nf_47(\"hello\") // returns false", "sq": "Shkruani një funksion JavaScript `function f_47(str)` për të zgjidhur problemin e mëposhtëm:\nPërcaktoni nëse një varg i dhënë është një palindrom.\nNjë palindrom është një fjalë, frazë, numër, ose një sekuencë tjetër karakteresh\nqë lexohet njësoj përpara dhe mbrapa (duke injoruar hapësirat, shenjat e pikësimit,\ndhe shkronjat e mëdha).\n\nShembuj:\nf_47(\"racecar\") // kthen true\nf_47(\"hello\") // kthen false", "hy": "Գրեք JavaScript ֆունկցիա `function f_47(str)`՝ հետևյալ խնդիրը լուծելու համար:\nՍահմանեք՝ արդյոք տրված տողը պալինդրոմ է:\nՊալինդրոմը բառ, արտահայտություն, թիվ կամ այլ նիշերի հաջորդականություն է,\nորը կարդացվում է նույն կերպ առաջ և հետ (անտեսելով բացատները, կետադրությունը\nև մեծատառերը):\n\nՕրինակներ:\nf_47(\"racecar\") // վերադարձնում է true\nf_47(\"hello\") // վերադարձնում է false", "bn": "একটি JavaScript ফাংশন `function f_47(str)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nনির্ধারণ করুন একটি প্রদত্ত স্ট্রিং প্যালিনড্রোম কিনা।\nএকটি প্যালিনড্রোম হল একটি শব্দ, বাক্যাংশ, সংখ্যা, বা অন্যান্য অক্ষরের ক্রম\nযা সামনের দিকে এবং পিছনের দিকে একইভাবে পড়ে (স্পেস, বিরামচিহ্ন,\nএবং বড় হাতের অক্ষর উপেক্ষা করে)।\n\nউদাহরণ:\nf_47(\"racecar\") // true রিটার্ন করে\nf_47(\"hello\") // false রিটার্ন করে", "bg": "Напишете JavaScript функция `function f_47(str)` за решаване на следния проблем:  \nОпределете дали даден низ е палиндром.  \nПалиндром е дума, фраза, число или друга последователност от символи,  \nкоято се чете еднакво напред и назад (като се игнорират интервали, пунктуация  \nи главни букви).\n\nПримери:  \nf_47(\"racecar\") // връща true  \nf_47(\"hello\") // връща false", "zh": "编写一个 JavaScript 函数 `function f_47(str)` 来解决以下问题：  \n确定给定的字符串是否是回文。  \n回文是指正着读和反着读都相同的单词、短语、数字或其他字符序列（忽略空格、标点符号和大小写）。  \n\n示例：  \nf_47(\"racecar\") // 返回 true  \nf_47(\"hello\") // 返回 false", "fr": "Écrire une fonction JavaScript `function f_47(str)` pour résoudre le problème suivant :  \nDéterminer si une chaîne donnée est un palindrome.  \nUn palindrome est un mot, une phrase, un nombre ou une autre séquence de caractères  \nqui se lit de la même façon de l'avant vers l'arrière et de l'arrière vers l'avant (en ignorant les espaces, la ponctuation,  \net la capitalisation).\n\nExemples :  \nf_47(\"racecar\") // retourne true  \nf_47(\"hello\") // retourne false", "de": "Schreiben Sie eine JavaScript-Funktion `function f_47(str)`, um das folgende Problem zu lösen:\nBestimmen Sie, ob ein gegebener String ein Palindrom ist.\nEin Palindrom ist ein Wort, ein Satz, eine Zahl oder eine andere Zeichenfolge,\ndie vorwärts und rückwärts gleich gelesen wird (unter Ignorierung von Leerzeichen, Interpunktion\nund Groß-/Kleinschreibung).\n\nBeispiele:\nf_47(\"racecar\") // gibt true zurück\nf_47(\"hello\") // gibt false zurück", "ha": "Rubuta wani aikin JavaScript `function f_47(str)` don warware matsalar mai zuwa:  \nGano ko wani kirtani da aka bayar palindrome ne.  \nPalindrome kalma ce, jimla, lamba, ko wata jerin haruffa  \nwanda yake karanta iri ɗaya a gaba da baya (ba tare da la'akari da sarari, rubutu,  \nda manyan haruffa ba).  \n\nMisalai:  \nf_47(\"racecar\") // returns true  \nf_47(\"hello\") // returns false  ", "hi": "एक JavaScript फ़ंक्शन `function f_47(str)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nयह निर्धारित करें कि दिया गया स्ट्रिंग एक पालिंड्रोम है या नहीं।\nएक पालिंड्रोम एक शब्द, वाक्यांश, संख्या, या अन्य वर्णों का अनुक्रम है\nजो आगे और पीछे से समान रूप से पढ़ा जाता है (स्पेस, विराम चिह्न, और बड़े अक्षरों को अनदेखा करते हुए)।\n\nउदाहरण:\nf_47(\"racecar\") // returns true\nf_47(\"hello\") // returns false", "hu": "Írj egy JavaScript függvényt `function f_47(str)` a következő probléma megoldására:\nHatározd meg, hogy egy adott string palindróm-e.\nA palindróm egy szó, kifejezés, szám vagy más karakterlánc,\namely előre és hátrafelé olvasva is ugyanaz (figyelmen kívül hagyva a szóközöket, írásjeleket\nés a nagybetűket).\n\nPéldák:\nf_47(\"racecar\") // visszaadja: true\nf_47(\"hello\") // visszaadja: false", "es": "Escribe una función de JavaScript `function f_47(str)` para resolver el siguiente problema:  \nDeterminar si una cadena dada es un palíndromo.  \nUn palíndromo es una palabra, frase, número u otra secuencia de caracteres  \nque se lee igual de adelante hacia atrás (ignorando espacios, puntuación  \ny mayúsculas).\n\nEjemplos:  \nf_47(\"racecar\") // devuelve true  \nf_47(\"hello\") // devuelve false", "arb": "اكتب دالة JavaScript `function f_47(str)` لحل المشكلة التالية:\nتحديد ما إذا كانت سلسلة معينة هي كلمة متطابقة.\nالكلمة المتطابقة هي كلمة، عبارة، رقم، أو تسلسل آخر من الأحرف\nيُقرأ بنفس الطريقة من الأمام والخلف (مع تجاهل المسافات، وعلامات الترقيم،\nوحالة الأحرف).\n\nأمثلة:\nf_47(\"racecar\") // يعيد true\nf_47(\"hello\") // يعيد false", "sw": "Andika kazi ya JavaScript `function f_47(str)` kutatua tatizo lifuatalo:  \nTambua kama mfuatano wa herufi uliopewa ni palindrome.  \nPalindrome ni neno, kifungu, nambari, au mfuatano mwingine wa herufi  \nambao unasomeka sawa mbele na nyuma (kupuuza nafasi, alama za uakifishaji,  \nna herufi kubwa na ndogo).\n\nMifano:  \nf_47(\"racecar\") // inarejesha true  \nf_47(\"hello\") // inarejesha false", "tr": "Bir JavaScript fonksiyonu `function f_47(str)` yazın:\nVerilen bir stringin palindrom olup olmadığını belirleyin.\nPalindrom, ileri ve geri okunduğunda aynı olan (boşluklar, noktalama işaretleri ve büyük/küçük harf farkı göz ardı edilerek) bir kelime, ifade, sayı veya diğer karakter dizisidir.\n\nÖrnekler:\nf_47(\"racecar\") // true döndürür\nf_47(\"hello\") // false döndürür", "vi": "Viết một hàm JavaScript `function f_47(str)` để giải quyết vấn đề sau:  \nXác định xem một chuỗi đã cho có phải là một palindrome hay không.  \nMột palindrome là một từ, cụm từ, số, hoặc một chuỗi ký tự khác mà đọc xuôi hay ngược đều giống nhau (bỏ qua khoảng trắng, dấu câu, và phân biệt chữ hoa chữ thường).\n\nVí dụ:  \nf_47(\"racecar\") // trả về true  \nf_47(\"hello\") // trả về false  ", "id": "Tulis sebuah fungsi JavaScript `function f_47(str)` untuk menyelesaikan masalah berikut:\nTentukan apakah sebuah string yang diberikan adalah palindrom.\nPalindrom adalah sebuah kata, frasa, angka, atau urutan karakter lainnya\nyang dibaca sama dari depan ke belakang (mengabaikan spasi, tanda baca,\ndan kapitalisasi).\n\nContoh:\nf_47(\"racecar\") // mengembalikan true\nf_47(\"hello\") // mengembalikan false", "ja": "JavaScript関数 `function f_47(str)` を作成して、次の問題を解決してください:\n与えられた文字列が回文かどうかを判定します。\n回文とは、前から読んでも後ろから読んでも同じになる単語、フレーズ、数字、またはその他の文字列のことです（スペース、句読点、大文字小文字は無視します）。\n\n例:\nf_47(\"racecar\") // returns true\nf_47(\"hello\") // returns false", "ko": "JavaScript 함수 `function f_47(str)`을 작성하여 다음 문제를 해결하십시오:  \n주어진 문자열이 회문인지 확인하십시오.  \n회문은 앞뒤로 같은 방식으로 읽히는 단어, 구, 숫자 또는 기타 문자 시퀀스입니다  \n(공백, 구두점 및 대소문자를 무시합니다).\n\n예시:  \nf_47(\"racecar\") // returns true  \nf_47(\"hello\") // returns false  ", "ml": "`function f_47(str)` എന്ന JavaScript ഫംഗ്ഷൻ എഴുതുക താഴെ കൊടുത്തിരിക്കുന്ന പ്രശ്നം പരിഹരിക്കാൻ: \nഒരു നൽകിയിരിക്കുന്ന സ്ട്രിംഗ് പാലിൻഡ്രോം ആണോ എന്ന് നിർണയിക്കുക. \nഒരു പാലിൻഡ്രോം എന്നത് ഒരു വാക്ക്, വാചകം, സംഖ്യ, അല്ലെങ്കിൽ മറ്റേതെങ്കിലും അക്ഷരമാലാ ക്രമമാണ് \nഅത് മുന്നോട്ടും പിന്നോട്ടും ഒരേപോലെ വായിക്കപ്പെടുന്നു (ഇടവേളകൾ, ചിഹ്നങ്ങൾ, \nമറ്റു വലിപ്പ വ്യത്യാസങ്ങൾ എന്നിവ അവഗണിക്കുന്നു).\n\nഉദാഹരണങ്ങൾ:\nf_47(\"racecar\") // true തിരികെ നൽകുന്നു\nf_47(\"hello\") // false തിരികെ നൽകുന്നു", "fa": "یک تابع جاوااسکریپت `function f_47(str)` بنویسید تا مسئله زیر را حل کند:\nتعیین کنید که آیا یک رشته داده شده یک پالیندروم است یا خیر.\nپالیندروم کلمه، عبارت، عدد یا دنباله‌ای از کاراکترها است که از جلو به عقب و از عقب به جلو (با نادیده گرفتن فاصله‌ها، علائم نگارشی و حروف بزرگ و کوچک) به یک شکل خوانده می‌شود.\n\nمثال‌ها:\nf_47(\"racecar\") // مقدار true را برمی‌گرداند\nf_47(\"hello\") // مقدار false را برمی‌گرداند"}, "level": "hard", "test": "const testf_47 = () => {\n  console.assert(f_47(\"A man a plan a canal Panama\") === true, \"Test 1 failed\");\n  console.assert(f_47(\"No lemon, no melon\") === true, \"Test 2 failed\");\n  console.assert(f_47(\"Was it a car or a cat I saw\") === true, \"Test 3 failed\");\n  console.assert(f_47(\"Madam, in Eden, I'm Adam\") === true, \"Test 4 failed\");\n  console.assert(f_47(\"Never odd or even\") === true, \"Test 5 failed\");\n  console.assert(f_47(\"Eva, can I see bees in a cave\") === true, \"Test 6 failed\");\n  console.assert(f_47(\"hello\") === false, \"Test 7 failed\");\n  console.assert(f_47(\"GitHub\") === false, \"Test 8 failed\");\n  console.assert(f_47(\"programming\") === false, \"Test 9 failed\");\n};\n\ntestf_47();", "entry_point": "f_47", "signature": "function f_47(str)", "docstring": {"en": "Determine if a given string is a palindrome.\nA palindrome is a word, phrase, number, or other sequence of characters\nthat reads the same forward and backward (ignoring spaces, punctuation,\nand capitalization).\n\nExamples:\nf_47(\"racecar\") // returns true\nf_47(\"hello\") // returns false", "sq": "Përcaktoni nëse një varg i dhënë është një palindrom.\nNjë palindrom është një fjalë, frazë, numër, ose një sekuencë tjetër karakteresh\nqë lexohet njësoj përpara dhe prapa (duke injoruar hapësirat, shenjat e pikësimit,\ndhe kapitalizimin).\n\nShembuj:\nf_47(\"racecar\") // kthen true\nf_47(\"hello\") // kthen false", "hy": "Սահմանել, արդյոք տրված տողը պալինդրոմ է:\nՊալինդրոմը բառ է, արտահայտություն, թիվ կամ այլ նիշերի հաջորդականություն,\nորն ընթերցվում է նույն կերպ առաջ և հետ (անտեսելով բացատները, կետադրությունը\nև մեծատառերը):\n\nՕրինակներ:\nf_47(\"racecar\") // վերադարձնում է true\nf_47(\"hello\") // վերադարձնում է false", "bn": "একটি প্রদত্ত স্ট্রিং প্যালিনড্রোম কিনা তা নির্ধারণ করুন। \nএকটি প্যালিনড্রোম হল এমন একটি শব্দ, বাক্যাংশ, সংখ্যা, বা অন্যান্য অক্ষরের ক্রম যা সামনের দিকে এবং পিছনের দিকে একইভাবে পড়ে (স্পেস, বিরামচিহ্ন এবং বড় হাতের অক্ষর উপেক্ষা করে)।\n\nউদাহরণ:\nf_47(\"racecar\") // true ফেরত দেয়\nf_47(\"hello\") // false ফেরত দেয়", "bg": "Определете дали даден низ е палиндром.  \nПалиндром е дума, фраза, число или друга последователност от символи, която се чете еднакво напред и назад (като се игнорират интервали, пунктуация и главни букви).\n\nПримери:  \nf_47(\"racecar\") // връща true  \nf_47(\"hello\") // връща false", "zh": "确定给定的字符串是否是回文。  \n回文是指一个单词、短语、数字或其他字符序列，正反读起来都一样（忽略空格、标点和大小写）。\n\n示例：  \nf_47(\"racecar\") // 返回 true  \nf_47(\"hello\") // 返回 false", "fr": "Déterminer si une chaîne donnée est un palindrome.  \nUn palindrome est un mot, une phrase, un nombre ou une autre séquence de caractères qui se lit de la même manière de gauche à droite et de droite à gauche (en ignorant les espaces, la ponctuation et la capitalisation).\n\nExemples :  \nf_47(\"racecar\") // retourne true  \nf_47(\"hello\") // retourne false  ", "de": "Bestimmen Sie, ob ein gegebener String ein Palindrom ist. Ein Palindrom ist ein Wort, ein Satz, eine Zahl oder eine andere Zeichenfolge, die vorwärts und rückwärts gleich gelesen wird (unter Ignorierung von Leerzeichen, Interpunktion und Groß-/Kleinschreibung).\n\nBeispiele:\nf_47(\"racecar\") // gibt true zurück\nf_47(\"hello\") // gibt false zurück", "ha": "Kunna ko wani kirtani da aka bayar palindrome ne.  \nPalindrome kalma ce, jimla, lamba, ko wata jerin haruffa  \nwanda ke karanta iri ɗaya gaba da baya (watsi da sarari, rubutu,  \nda manyan baƙaƙe).\n\nMisalai:  \nf_47(\"racecar\") // yana dawowa gaskiya  \nf_47(\"hello\") // yana dawowa ƙarya  ", "hi": "दिया गया स्ट्रिंग एक पालिंड्रोम है या नहीं, यह निर्धारित करें।  \nएक पालिंड्रोम एक शब्द, वाक्यांश, संख्या, या अन्य वर्णों का अनुक्रम है  \nजो आगे और पीछे से समान पढ़ा जाता है (स्पेस, विराम चिह्न, और बड़े अक्षरों की अनदेखी करते हुए)।\n\nउदाहरण:\nf_47(\"racecar\") // true लौटाता है\nf_47(\"hello\") // false लौटाता है", "hu": "Határozza meg, hogy egy adott sztring palindróm-e.\nA palindróm olyan szó, kifejezés, szám vagy más karakterlánc,\namely előre és hátra olvasva is ugyanaz (figyelmen kívül hagyva a szóközöket, írásjeleket\nés a nagybetűket).\n\nPéldák:\nf_47(\"racecar\") // visszaadja: true\nf_47(\"hello\") // visszaadja: false", "es": "Determinar si una cadena dada es un palíndromo.  \nUn palíndromo es una palabra, frase, número u otra secuencia de caracteres  \nque se lee igual de adelante hacia atrás (ignorando espacios, puntuación  \ny mayúsculas).\n\nEjemplos:  \nf_47(\"racecar\") // devuelve true  \nf_47(\"hello\") // devuelve false  ", "arb": "تحديد ما إذا كانت سلسلة معينة هي جملة متناظرة.\nالجملة المتناظرة هي كلمة، أو عبارة، أو رقم، أو تسلسل آخر من الأحرف\nيُقرأ بنفس الطريقة من الأمام والخلف (مع تجاهل المسافات، وعلامات الترقيم،\nوحالة الأحرف).\n\nأمثلة:\nf_47(\"racecar\") // يُرجع true\nf_47(\"hello\") // يُرجع false", "sw": "Amua ikiwa kamba iliyotolewa ni palindrome.  \nPalindrome ni neno, kifungu, nambari, au mlolongo mwingine wa herufi  \nambazo zinasomwa sawa mbele na nyuma (kupuuza nafasi, alama za uakifishaji,  \nna herufi kubwa na ndogo).\n\nMifano:  \nf_47(\"racecar\") // inarudisha true  \nf_47(\"hello\") // inarudisha false  ", "tr": "Belirtilen bir dizgenin palindrom olup olmadığını belirleyin.  \nPalindrom, ileri ve geri okunduğunda aynı olan (boşluklar, noktalama işaretleri ve büyük/küçük harf farkı göz ardı edilerek) bir kelime, ifade, sayı veya diğer karakter dizisidir.\n\nÖrnekler:  \nf_47(\"racecar\") // true döndürür  \nf_47(\"hello\") // false döndürür", "vi": "Xác định xem một chuỗi cho trước có phải là một chuỗi palindrome hay không.  \nMột chuỗi palindrome là một từ, cụm từ, số, hoặc một dãy ký tự khác  \nmà đọc xuôi hay ngược đều giống nhau (bỏ qua khoảng trắng, dấu câu,  \nvà chữ hoa chữ thường).\n\nVí dụ:\nf_47(\"racecar\") // trả về true\nf_47(\"hello\") // trả về false", "id": "Menentukan apakah string yang diberikan adalah palindrom.  \nPalindrom adalah kata, frasa, angka, atau urutan karakter lainnya  \nyang dibaca sama dari depan ke belakang dan sebaliknya (mengabaikan spasi, tanda baca,  \ndan kapitalisasi).\n\nContoh:  \nf_47(\"racecar\") // mengembalikan true  \nf_47(\"hello\") // mengembalikan false  ", "ja": "与えられた文字列が回文かどうかを判断します。\n回文とは、前から読んでも後ろから読んでも同じになる単語、フレーズ、数字、またはその他の文字列のことです（スペース、句読点、大文字小文字は無視します）。\n\n例:\nf_47(\"racecar\") // trueを返します\nf_47(\"hello\") // falseを返します", "ko": "주어진 문자열이 회문인지 확인합니다.  \n회문은 앞뒤로 읽어도 동일한 단어, 구, 숫자 또는 기타 문자 시퀀스를 말합니다 (공백, 구두점 및 대소문자는 무시합니다).\n\n예시:\nf_47(\"racecar\") // true 반환\nf_47(\"hello\") // false 반환", "ml": "ഒരു നൽകിയ സ്റ്റ്രിംഗ് പലിൻഡ്രോം ആണോ എന്ന് നിർണ്ണയിക്കുക.  \nഒരു പലിൻഡ്രോം എന്നത് ഒരു വാക്ക്, വാചകം, സംഖ്യ, അല്ലെങ്കിൽ മറ്റു കഥാപാത്രങ്ങളുടെ ഒരു ശ്രേണിയാണ്,  \nഅത് മുന്നോട്ടും പിന്നോട്ടും ഒരേപോലെ വായിക്കപ്പെടുന്നു (വിരാമചിഹ്നങ്ങൾ, ഇടവേളകൾ,  \nമറ്റും അവഗണിക്കുന്നു).\n\nഉദാഹരണങ്ങൾ:\nf_47(\"racecar\") // true തിരികെ നൽകുന്നു\nf_47(\"hello\") // false തിരികെ നൽകുന്നു", "fa": "تعیین کنید که آیا رشته داده شده یک پالیندروم است.  \nپالیندروم یک کلمه، عبارت، عدد یا دنباله‌ای از کاراکترها است  \nکه از جلو و عقب به یک صورت خوانده می‌شود (با نادیده گرفتن فاصله‌ها، علائم نگارشی،  \nand capitalization).  \nو حروف بزرگ و کوچک).  \n\nExamples:  \nمثال‌ها:  \nf_47(\"racecar\") // returns true  \nf_47(\"hello\") // returns false  "}}
{"task_id": "JavaScript/48", "prompt": {"en": "/**\n * Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.\n * For example:\n *   f_48(38)  // returns 2\n *   Explanation: 3 + 8 = 11, and 1 + 1 = 2. Since 2 has only one digit, 2 is the result.\n */\nfunction f_48(num)", "sq": "/**\n * Duke pasur një numër jo-negativ num, shtoni përsëri të gjitha shifrat e tij derisa rezultati të ketë vetëm një shifër.\n * Për shembull:\n *   f_48(38)  // kthen 2\n *   Shpjegim: 3 + 8 = 11, dhe 1 + 1 = 2. Meqenëse 2 ka vetëm një shifër, 2 është rezultati.\n */\nfunction f_48(num)", "hy": "/**\n * Տրված է ոչ բացասական ամբողջ թիվ num, բազմիցս գումարեք դրա բոլոր թվանշանները, մինչև արդյունքը ունենա միայն մեկ թվանշան:\n * Օրինակ:\n *   f_48(38)  // վերադարձնում է 2\n *   Բացատրություն: 3 + 8 = 11, և 1 + 1 = 2: Քանի որ 2-ն ունի միայն մեկ թվանշան, 2-ն է արդյունքը:\n */\nfunction f_48(num)", "bn": "/**\n * একটি অ-ঋণাত্মক পূর্ণসংখ্যা num দেওয়া হলে, এর সমস্ত অঙ্ক বারবার যোগ করুন যতক্ষণ না ফলাফলে শুধুমাত্র একটি অঙ্ক থাকে।\n * উদাহরণস্বরূপ:\n *   f_48(38)  // 2 ফেরত দেয়\n *   ব্যাখ্যা: 3 + 8 = 11, এবং 1 + 1 = 2। যেহেতু 2-এ শুধুমাত্র একটি অঙ্ক রয়েছে, 2 হল ফলাফল।\n */\nfunction f_48(num)", "bg": "/**\n * Като се даде неотрицателно цяло число num, повтаряйте събирането на всичките му цифри, докато резултатът не стане едноцифрено число.\n * Например:\n *   f_48(38)  // връща 2\n *   Обяснение: 3 + 8 = 11, и 1 + 1 = 2. Тъй като 2 е едноцифрено число, 2 е резултатът.\n */\nfunction f_48(num)", "zh": "/**\n * 给定一个非负整数 num，反复将所有位上的数字相加，直到结果只有一位数字。\n * 例如：\n *   f_48(38)  // 返回 2\n *   解释：3 + 8 = 11，且 1 + 1 = 2。由于 2 只有一位数字，因此 2 是结果。\n */\nfunction f_48(num)", "fr": "/**\n * Étant donné un entier non négatif num, additionnez de manière répétée tous ses chiffres jusqu'à ce que le résultat n'ait qu'un seul chiffre.\n * Par exemple :\n *   f_48(38)  // renvoie 2\n *   Explication : 3 + 8 = 11, et 1 + 1 = 2. Puisque 2 n'a qu'un seul chiffre, 2 est le résultat.\n */\nfunction f_48(num)", "de": "/**\n * Gegeben eine nicht-negative ganze Zahl num, addiere wiederholt alle ihre Ziffern, bis das Ergebnis nur noch eine Ziffer hat.\n * Zum Beispiel:\n *   f_48(38)  // gibt 2 zurück\n *   Erklärung: 3 + 8 = 11, und 1 + 1 = 2. Da 2 nur eine Ziffer hat, ist 2 das Ergebnis.\n */\nfunction f_48(num)", "ha": "/**\n * An ba da wani lamba mara kyau num, a ci gaba da ƙara duk lambobinsa har sai sakamakon yana da lamba ɗaya kawai.\n * Alal misali:\n *   f_48(38)  // yana dawowa 2\n *   Bayani: 3 + 8 = 11, kuma 1 + 1 = 2. Tun da 2 yana da lamba ɗaya kawai, 2 shine sakamakon.\n */\nfunction f_48(num)", "hi": "/**\n * दिए गए एक गैर-ऋणात्मक पूर्णांक num के लिए, इसके सभी अंकों को तब तक जोड़ते रहें जब तक परिणाम में केवल एक अंक न रह जाए।\n * उदाहरण के लिए:\n *   f_48(38)  // 2 लौटाता है\n *   व्याख्या: 3 + 8 = 11, और 1 + 1 = 2। चूंकि 2 में केवल एक अंक है, 2 परिणाम है।\n */\nfunction f_48(num)", "hu": "/**\n * Adott egy nem negatív egész szám, ismételten add össze az összes számjegyét, amíg az eredmény csak egy számjegyből áll.\n * Például:\n *   f_48(38)  // visszaadja a 2-t\n *   Magyarázat: 3 + 8 = 11, és 1 + 1 = 2. Mivel a 2 csak egy számjegyből áll, 2 az eredmény.\n */\nfunction f_48(num)", "es": "/**\n * Dado un número entero no negativo num, suma repetidamente todos sus dígitos hasta que el resultado tenga solo un dígito.\n * Por ejemplo:\n *   f_48(38)  // devuelve 2\n *   Explicación: 3 + 8 = 11, y 1 + 1 = 2. Dado que 2 tiene solo un dígito, 2 es el resultado.\n */\nfunction f_48(num)", "arb": "/**\n * بالنظر إلى عدد صحيح غير سالب، قم بإضافة جميع أرقامه بشكل متكرر حتى يكون الناتج رقمًا واحدًا فقط.\n * على سبيل المثال:\n *   f_48(38)  // يعيد 2\n *   الشرح: 3 + 8 = 11، و 1 + 1 = 2. بما أن 2 يحتوي على رقم واحد فقط، فإن 2 هو الناتج.\n */\nfunction f_48(num)", "sw": "/**\n * Ukipewa nambari isiyo hasi num, ongeza mara kwa mara tarakimu zake zote hadi matokeo yawe na tarakimu moja tu.\n * Kwa mfano:\n *   f_48(38)  // inarudisha 2\n *   Maelezo: 3 + 8 = 11, na 1 + 1 = 2. Kwa kuwa 2 ina tarakimu moja tu, 2 ndiyo matokeo.\n */\nfunction f_48(num)", "tr": "/**\n * Verilen negatif olmayan bir tam sayı num için, sonucu tek basamaklı olana kadar tüm basamaklarını tekrar tekrar topla.\n * Örneğin:\n *   f_48(38)  // 2 döndürür\n *   Açıklama: 3 + 8 = 11 ve 1 + 1 = 2. 2 tek basamaklı olduğundan, sonuç 2'dir.\n */\nfunction f_48(num)", "vi": "/**\n * Cho một số nguyên không âm num, liên tục cộng tất cả các chữ số của nó cho đến khi kết quả chỉ còn một chữ số.\n * Ví dụ:\n *   f_48(38)  // trả về 2\n *   Giải thích: 3 + 8 = 11, và 1 + 1 = 2. Vì 2 chỉ có một chữ số, 2 là kết quả.\n */\nfunction f_48(num)", "id": "/**\n * Diberikan bilangan bulat non-negatif num, tambahkan semua digitnya berulang kali hingga hasilnya hanya memiliki satu digit.\n * Sebagai contoh:\n *   f_48(38)  // mengembalikan 2\n *   Penjelasan: 3 + 8 = 11, dan 1 + 1 = 2. Karena 2 hanya memiliki satu digit, 2 adalah hasilnya.\n */\nfunction f_48(num)", "ja": "/**\n * 非負の整数 num が与えられたとき、その桁を繰り返し加算して結果が一桁になるまで続けます。\n * 例えば:\n *   f_48(38)  // 2 を返します\n *   説明: 3 + 8 = 11, そして 1 + 1 = 2。2 は一桁なので、2 が結果です。\n */\nfunction f_48(num)", "ko": "/**\n * 음수가 아닌 정수 num이 주어졌을 때, 결과가 한 자리 숫자가 될 때까지 모든 자릿수를 반복해서 더합니다.\n * 예를 들어:\n *   f_48(38)  // 2를 반환합니다\n *   설명: 3 + 8 = 11, 그리고 1 + 1 = 2. 2는 한 자리 숫자이므로, 2가 결과입니다.\n */\nfunction f_48(num)", "ml": "/**\n * ഒരു നെഗറ്റീവ് അല്ലാത്ത പൂർണ്ണസംഖ്യ നൽകിയാൽ, ഫലം ഒരു അക്കമാത്രം ഉള്ളതാകുന്നത് വരെ അതിന്റെ എല്ലാ അക്കങ്ങളും ആവർത്തിച്ച് കൂട്ടുക.\n * ഉദാഹരണത്തിന്:\n *   f_48(38)  // 2 മടക്കുന്നു\n *   വിശദീകരണം: 3 + 8 = 11, കൂടാതെ 1 + 1 = 2. 2 ന് ഒരു അക്കമാത്രം ഉള്ളതിനാൽ, 2 ആണ് ഫലം.\n */\nfunction f_48(num)", "fa": "/**\n * با توجه به یک عدد صحیح غیر منفی، به طور مکرر تمام ارقام آن را اضافه کنید تا نتیجه فقط یک رقم داشته باشد.\n * برای مثال:\n *   f_48(38)  // مقدار 2 را برمی‌گرداند\n *   توضیح: 3 + 8 = 11، و 1 + 1 = 2. از آنجایی که 2 فقط یک رقم دارد، 2 نتیجه است.\n */\nfunction f_48(num)"}, "canonical_solution": "{\n    while (num >= 10) {\n        let sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num = Math.floor(num / 10);\n        }\n        num = sum;\n    }\n    return num;\n}", "instruction": {"en": "Write a JavaScript function `function f_48(num)` to solve the following problem:\nGiven a non-negative integer num, repeatedly add all its digits until the result has only one digit.\nFor example:\n  f_48(38)  // returns 2\n  Explanation: 3 + 8 = 11, and 1 + 1 = 2. Since 2 has only one digit, 2 is the result.", "sq": "Shkruani një funksion JavaScript `function f_48(num)` për të zgjidhur problemin e mëposhtëm:  \nDuke pasur një numër të plotë jo-negativ num, shtoni përsëri të gjitha shifrat e tij derisa rezultati të ketë vetëm një shifër.  \nPër shembull:  \n  f_48(38)  // kthen 2  \n  Shpjegim: 3 + 8 = 11, dhe 1 + 1 = 2. Meqenëse 2 ka vetëm një shifër, 2 është rezultati.", "hy": "Գրեք JavaScript ֆունկցիա `function f_48(num)`՝ հետևյալ խնդիրը լուծելու համար:\nՏրված է ոչ բացասական ամբողջ թիվ num, շարունակաբար գումարեք դրա բոլոր թվանշանները, մինչև արդյունքը կունենա միայն մեկ թվանշան:\nՕրինակ:\n  f_48(38)  // վերադարձնում է 2\n  Բացատրություն: 3 + 8 = 11, և 1 + 1 = 2։ Քանի որ 2-ն ունի միայն մեկ թվանշան, 2-ն է արդյունքը։", "bn": "একটি জাভাস্ক্রিপ্ট ফাংশন `function f_48(num)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি অ-ঋণাত্মক পূর্ণসংখ্যা num দেওয়া আছে, এর সমস্ত অঙ্ক বারবার যোগ করুন যতক্ষণ না ফলাফল এক অঙ্কের হয়।\nউদাহরণস্বরূপ:\n  f_48(38)  // 2 ফেরত দেয়\n  ব্যাখ্যা: 3 + 8 = 11, এবং 1 + 1 = 2। যেহেতু 2 এক অঙ্কের, তাই 2 হল ফলাফল।", "bg": "Напишете JavaScript функция `function f_48(num)`, за да решите следния проблем:  \nДадено е неотрицателно цяло число num, повтаряйте събирането на всичките му цифри, докато резултатът не стане едноцифрено число.  \nНапример:  \n  f_48(38)  // връща 2  \n  Обяснение: 3 + 8 = 11, и 1 + 1 = 2. Тъй като 2 е едноцифрено число, 2 е резултатът.", "zh": "编写一个 JavaScript 函数 `function f_48(num)` 来解决以下问题：  \n给定一个非负整数 num，重复将其所有位数相加，直到结果只有一位数字。  \n例如：  \n  f_48(38)  // 返回 2  \n  解释：3 + 8 = 11，1 + 1 = 2。由于 2 只有一位数字，因此结果是 2。", "fr": "Écrire une fonction JavaScript `function f_48(num)` pour résoudre le problème suivant :  \nÉtant donné un entier non négatif num, additionner de manière répétée tous ses chiffres jusqu'à ce que le résultat n'ait qu'un seul chiffre.  \nPar exemple :  \n  f_48(38)  // renvoie 2  \n  Explication : 3 + 8 = 11, et 1 + 1 = 2. Puisque 2 n'a qu'un seul chiffre, 2 est le résultat.", "de": "Schreiben Sie eine JavaScript-Funktion `function f_48(num)`, um das folgende Problem zu lösen:  \nGegeben ist eine nicht-negative ganze Zahl num, addieren Sie wiederholt alle ihre Ziffern, bis das Ergebnis nur noch eine Ziffer hat.  \nZum Beispiel:  \n  f_48(38)  // gibt 2 zurück  \n  Erklärung: 3 + 8 = 11, und 1 + 1 = 2. Da 2 nur eine Ziffer hat, ist 2 das Ergebnis.", "ha": "Rubuta wani aikin JavaScript `function f_48(num)` don warware matsalar mai zuwa:  \nAn ba da lamba mara kyau num, ci gaba da ƙara duk lambobinsa har sai sakamakon yana da lamba ɗaya kawai.  \nMisali:  \n  f_48(38)  // yana dawowa 2  \n  Bayani: 3 + 8 = 11, kuma 1 + 1 = 2. Tun da 2 yana da lamba ɗaya kawai, 2 shine sakamakon.", "hi": "एक जावास्क्रिप्ट फ़ंक्शन `function f_48(num)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए एक गैर-ऋणात्मक पूर्णांक num के सभी अंकों को बार-बार जोड़ें जब तक कि परिणाम में केवल एक अंक न रह जाए।\nउदाहरण के लिए:\n  f_48(38)  // 2 लौटाता है\n  व्याख्या: 3 + 8 = 11, और 1 + 1 = 2. चूंकि 2 में केवल एक अंक है, 2 परिणाम है।", "hu": "Írj egy JavaScript függvényt `function f_48(num)` a következő probléma megoldására:\nAdott egy nem negatív egész szám num, ismételten add össze az összes számjegyét, amíg az eredmény csak egy számjegyből áll.\nPéldául:\n  f_48(38)  // visszaadja a 2-t\n  Magyarázat: 3 + 8 = 11, és 1 + 1 = 2. Mivel a 2 csak egy számjegyből áll, a 2 az eredmény.", "es": "Escribe una función de JavaScript `function f_48(num)` para resolver el siguiente problema:  \nDado un número entero no negativo num, suma repetidamente todos sus dígitos hasta que el resultado tenga solo un dígito.  \nPor ejemplo:  \n  f_48(38)  // devuelve 2  \n  Explicación: 3 + 8 = 11, y 1 + 1 = 2. Dado que 2 tiene solo un dígito, 2 es el resultado.", "arb": "اكتب دالة JavaScript `function f_48(num)` لحل المشكلة التالية:\nمعطى عدد صحيح غير سالب num، قم بجمع جميع أرقامه بشكل متكرر حتى يكون الناتج رقمًا واحدًا فقط.\nعلى سبيل المثال:\n  f_48(38)  // يعيد 2\n  التفسير: 3 + 8 = 11، و 1 + 1 = 2. بما أن 2 يحتوي على رقم واحد فقط، فإن 2 هو الناتج.", "sw": "Andika kazi ya JavaScript `function f_48(num)` kutatua tatizo lifuatalo:\nUkipiwa nambari isiyo hasi num, ongeza mara kwa mara tarakimu zake zote hadi matokeo yawe na tarakimu moja tu.\nKwa mfano:\n  f_48(38)  // inarudisha 2\n  Maelezo: 3 + 8 = 11, na 1 + 1 = 2. Kwa kuwa 2 ina tarakimu moja tu, 2 ndiyo matokeo.", "tr": "Bir JavaScript fonksiyonu `function f_48(num)` yazın ve aşağıdaki problemi çözün:\nVerilen bir negatif olmayan tamsayı num için, sonucu tek basamaklı olana kadar tüm basamaklarını tekrar tekrar toplayın.\nÖrneğin:\n  f_48(38)  // 2 döndürür\n  Açıklama: 3 + 8 = 11 ve 1 + 1 = 2. 2 tek basamaklı olduğundan, sonuç 2'dir.", "vi": "Viết một hàm JavaScript `function f_48(num)` để giải quyết vấn đề sau:  \nCho một số nguyên không âm num, liên tục cộng tất cả các chữ số của nó cho đến khi kết quả chỉ còn một chữ số.  \nVí dụ:  \n  f_48(38)  // trả về 2  \n  Giải thích: 3 + 8 = 11, và 1 + 1 = 2. Vì 2 chỉ có một chữ số, 2 là kết quả.", "id": "Tulis fungsi JavaScript `function f_48(num)` untuk menyelesaikan masalah berikut:\nDiberikan bilangan bulat non-negatif num, tambahkan semua digitnya berulang kali hingga hasilnya hanya memiliki satu digit.\nSebagai contoh:\n  f_48(38)  // mengembalikan 2\n  Penjelasan: 3 + 8 = 11, dan 1 + 1 = 2. Karena 2 hanya memiliki satu digit, 2 adalah hasilnya.", "ja": "JavaScript関数 `function f_48(num)` を作成して、次の問題を解決してください:\n非負整数numが与えられたとき、その桁をすべて足し合わせ、その結果が一桁になるまで繰り返します。\n例えば:\n  f_48(38)  // 2を返します\n  説明: 3 + 8 = 11, そして 1 + 1 = 2。2は一桁なので、2が結果です。", "ko": "JavaScript 함수를 작성하세요 `function f_48(num)` 다음 문제를 해결하기 위해:\n주어진 비음수 정수 num에 대해, 그 자리 숫자들을 반복적으로 더하여 결과가 한 자리 숫자가 될 때까지 반복하세요.\n예를 들어:\n  f_48(38)  // 2를 반환합니다\n  설명: 3 + 8 = 11, 그리고 1 + 1 = 2. 2는 한 자리 숫자이므로, 2가 결과입니다.", "ml": "`function f_48(num)` എന്ന JavaScript ഫങ്ഷൻ എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nഒരു non-negative പൂർണ്ണസംഖ്യയായ num നൽകിയാൽ, ഫലം ഒരു അക്കമാത്രം ഉള്ളതാകുന്നത് വരെ അതിന്റെ എല്ലാ അക്കങ്ങളും ആവർത്തിച്ച് കൂട്ടുക.\nഉദാഹരണത്തിന്:\n  f_48(38)  // 2 മടക്കുന്നു\n  വിശദീകരണം: 3 + 8 = 11, കൂടാതെ 1 + 1 = 2. 2 ന് ഒരു അക്കമാത്രം ഉള്ളതിനാൽ, 2 ആണ് ഫലം.", "fa": "یک تابع جاوااسکریپت `function f_48(num)` بنویسید تا مسئله زیر را حل کند:\nبا توجه به یک عدد صحیح غیرمنفی num، به طور مکرر تمام ارقام آن را جمع کنید تا زمانی که نتیجه فقط یک رقم داشته باشد.\nبرای مثال:\n  f_48(38)  // مقدار 2 را برمی‌گرداند\n  توضیح: 3 + 8 = 11، و 1 + 1 = 2. از آنجا که 2 فقط یک رقم دارد، 2 نتیجه است."}, "level": "easy", "test": "const testf_48 = () => {\n    console.assert(f_48(38) === 2, 'Test 1 failed');\n    console.assert(f_48(0) === 0, 'Test 2 failed');\n    console.assert(f_48(9) === 9, 'Test 3 failed');\n    console.assert(f_48(123) === 6, 'Test 4 failed');\n    console.assert(f_48(456) === 6, 'Test 5 failed');\n    console.assert(f_48(9999) === 9, 'Test 6 failed');\n    console.assert(f_48(100) === 1, 'Test 7 failed');\n    console.assert(f_48(1010) === 2, 'Test 8 failed');\n    console.assert(f_48(1234) === 1, 'Test 9 failed');\n    console.assert(f_48(9876) === 3, 'Test 10 failed');\n    console.assert(f_48(199) === 1, 'Test 11 failed');\n};\n\ntestf_48();", "entry_point": "f_48", "signature": "function f_48(num)", "docstring": {"en": "Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.\nFor example:\n  f_48(38)  // returns 2\n  Explanation: 3 + 8 = 11, and 1 + 1 = 2. Since 2 has only one digit, 2 is the result.", "sq": "Duke pasur një numër të plotë jo-negativ num, shtoni në mënyrë të përsëritur të gjitha shifrat e tij derisa rezultati të ketë vetëm një shifër.\nPër shembull:\n  f_48(38)  // kthen 2\n  Shpjegim: 3 + 8 = 11, dhe 1 + 1 = 2. Meqenëse 2 ka vetëm një shifër, 2 është rezultati.", "hy": "Տրված է ոչ բացասական ամբողջ թիվ num, բազմիցս գումարեք դրա բոլոր թվանշանները, մինչև արդյունքը ունենա միայն մեկ թվանշան:\nՕրինակ:\n  f_48(38)  // վերադարձնում է 2\n  Բացատրություն: 3 + 8 = 11, և 1 + 1 = 2։ Քանի որ 2-ը ունի միայն մեկ թվանշան, 2-ը արդյունքն է։", "bn": "একটি অ-ঋণাত্মক পূর্ণসংখ্যা num দেওয়া হলে, তার সমস্ত অঙ্ক বারবার যোগ করুন যতক্ষণ না ফলাফলটি কেবল এক অঙ্কের হয়। উদাহরণস্বরূপ:\n  f_48(38)  // 2 ফেরত দেয়\n  ব্যাখ্যা: 3 + 8 = 11, এবং 1 + 1 = 2। যেহেতু 2 কেবল এক অঙ্কের, তাই 2 হল ফলাফল।", "bg": "Дадено е неотрицателно цяло число num, повтаряйте събирането на всичките му цифри, докато резултатът не стане едноцифрено число.\nНапример:\n  f_48(38)  // връща 2\n  Обяснение: 3 + 8 = 11, и 1 + 1 = 2. Тъй като 2 е едноцифрено число, 2 е резултатът.", "zh": "给定一个非负整数 num，重复相加其所有数字，直到结果只有一位数字。\n\n例如：\n  f_48(38)  // 返回 2\n  解释：3 + 8 = 11，然后 1 + 1 = 2。由于 2 只有一位数字，因此结果是 2。", "fr": "Étant donné un entier non négatif num, ajoutez de manière répétée tous ses chiffres jusqu'à ce que le résultat n'ait qu'un seul chiffre.\nPar exemple :\n  f_48(38)  // renvoie 2\n  Explication : 3 + 8 = 11, et 1 + 1 = 2. Puisque 2 n'a qu'un seul chiffre, 2 est le résultat.", "de": "Für eine nicht-negative ganze Zahl num, addiere wiederholt alle ihre Ziffern, bis das Ergebnis nur noch eine Ziffer hat.\nZum Beispiel:\n  f_48(38)  // gibt 2 zurück\n  Erklärung: 3 + 8 = 11, und 1 + 1 = 2. Da 2 nur eine Ziffer hat, ist 2 das Ergebnis.", "ha": "An ba da wani lamba mara kyau num, a ci gaba da ƙara dukkan lambobinsa har sai sakamakon yana da lamba ɗaya kawai.\nMisali:\n  f_48(38)  // yana dawowa 2\n  Bayani: 3 + 8 = 11, kuma 1 + 1 = 2. Tun da 2 yana da lamba ɗaya kawai, 2 shine sakamakon.", "hi": "एक गैर-ऋणात्मक पूर्णांक num दिया गया है, इसके सभी अंकों को बार-बार जोड़ें जब तक कि परिणाम में केवल एक अंक न रह जाए।\n\nउदाहरण:\n  f_48(38)  // 2 लौटाता है\n  व्याख्या: 3 + 8 = 11, और 1 + 1 = 2। चूंकि 2 में केवल एक अंक है, 2 परिणाम है।", "hu": "Adott egy nem negatív egész szám, num, ismételten add össze az összes számjegyét, amíg az eredmény csak egy számjegyből áll.\nPéldául:\n  f_48(38)  // visszaadja a 2-t\n  Magyarázat: 3 + 8 = 11, és 1 + 1 = 2. Mivel a 2 csak egy számjegyből áll, 2 az eredmény.", "es": "Dado un número entero no negativo num, suma repetidamente todos sus dígitos hasta que el resultado tenga solo un dígito.\nPor ejemplo:\n  f_48(38)  // devuelve 2\n  Explicación: 3 + 8 = 11, y 1 + 1 = 2. Dado que 2 tiene solo un dígito, 2 es el resultado.", "arb": "بالنظر إلى عدد صحيح غير سالب num، قم بإضافة جميع أرقامه بشكل متكرر حتى يكون الناتج رقماً واحداً فقط.\nعلى سبيل المثال:\n  f_48(38)  // يعيد 2\n  التوضيح: 3 + 8 = 11، و 1 + 1 = 2. بما أن 2 يحتوي على رقم واحد فقط، فإن 2 هو الناتج.", "sw": "Ukipiwa nambari isiyo hasi num, ongeza mara kwa mara tarakimu zake zote hadi matokeo yawe na tarakimu moja tu.  \nKwa mfano:  \n  f_48(38)  // inarudisha 2  \n  Maelezo: 3 + 8 = 11, na 1 + 1 = 2. Kwa kuwa 2 ina tarakimu moja tu, 2 ndiyo matokeo.", "tr": "Verilen negatif olmayan bir tam sayı num için, sonucu yalnızca bir basamak kalana kadar tüm basamaklarını tekrar tekrar toplayın.  \nÖrneğin:  \n  f_48(38)  // 2 döndürür  \n  Açıklama: 3 + 8 = 11 ve 1 + 1 = 2. 2 yalnızca bir basamak olduğundan, sonuç 2'dir.", "vi": "Cho một số nguyên không âm num, liên tục cộng tất cả các chữ số của nó cho đến khi kết quả chỉ còn một chữ số.  \nVí dụ:  \n  f_48(38)  // trả về 2  \n  Giải thích: 3 + 8 = 11, và 1 + 1 = 2. Vì 2 chỉ có một chữ số, 2 là kết quả.", "id": "Diberikan bilangan bulat non-negatif num, tambahkan semua digitnya secara berulang hingga hasilnya hanya memiliki satu digit.\nSebagai contoh:\n  f_48(38)  // mengembalikan 2\n  Penjelasan: 3 + 8 = 11, dan 1 + 1 = 2. Karena 2 hanya memiliki satu digit, 2 adalah hasilnya.", "ja": "非負の整数 num が与えられたとき、その桁を繰り返しすべて足し合わせ、結果が一桁になるまで続けます。\n例えば:\n  f_48(38)  // 2を返します\n  説明: 3 + 8 = 11, そして 1 + 1 = 2。2 は一桁なので、2 が結果です。", "ko": "주어진 비음수 정수 num에 대해, 그 결과가 한 자리 숫자가 될 때까지 모든 자릿수를 반복해서 더합니다.\n예를 들어:\n  f_48(38)  // 2를 반환합니다\n  설명: 3 + 8 = 11, 그리고 1 + 1 = 2. 2는 한 자리 숫자이므로, 2가 결과입니다.", "ml": "ഒരു നെഗറ്റീവ് അല്ലാത്ത പൂർണ്ണസംഖ്യയായ num നൽകിയാൽ, ഫലം ഒരു അക്കമാത്രം ഉള്ളതാകുന്നത് വരെ അതിന്റെ എല്ലാ അക്കങ്ങളും ആവർത്തിച്ച് ചേർക്കുക. ഉദാഹരണത്തിന്:\n  f_48(38)  // 2 മടങ്ങി നൽകുന്നു\n  വിശദീകരണം: 3 + 8 = 11, കൂടാതെ 1 + 1 = 2. 2 ന് ഒരു അക്കമാത്രം ഉള്ളതിനാൽ, 2 ആണ് ഫലം.", "fa": "با توجه به یک عدد صحیح غیرمنفی num، به طور مکرر تمام ارقام آن را اضافه کنید تا زمانی که نتیجه فقط یک رقم داشته باشد.\n\nبرای مثال:\n  f_48(38)  // مقدار 2 را برمی‌گرداند\n  توضیح: 3 + 8 = 11، و 1 + 1 = 2. از آنجا که 2 فقط یک رقم دارد، 2 نتیجه است."}}
{"task_id": "JavaScript/49", "prompt": {"en": "/**\n * You are playing a game called Nim. In this game, you start with a pile\n * of n stones, and you and your opponent take turns to remove 1 to 3\n * stones from the pile. The one who removes the last stone wins the game.\n * Given the number of stones n, determine if you can win the game if both\n * you and your opponent play optimally.\n * Note: You always take the first turn.\n *\n * Here are some cases:\n *   f_49(1) // returns true\n */\nfunction f_49(n)", "sq": "/**\n * Po luani një lojë të quajtur Nim. Në këtë lojë, ju filloni me një grumbull\n * prej n gurësh, dhe ju dhe kundërshtari juaj merrni radhë për të hequr 1 deri në 3\n * gurë nga grumbulli. Ai që heq gurin e fundit fiton lojën.\n * Duke pasur parasysh numrin e gurëve n, përcaktoni nëse mund ta fitoni lojën nëse të dy\n * ju dhe kundërshtari juaj luani në mënyrë optimale.\n * Shënim: Ju gjithmonë merrni radhën e parë.\n *\n * Ja disa raste:\n *   f_49(1) // kthen true\n */\nfunction f_49(n)", "hy": "/**\n * Դուք խաղում եք Nim կոչվող խաղը։ Այս խաղում դուք սկսում եք n քարերի կույտով,\n * և դուք ու ձեր մրցակիցը հերթով հեռացնում եք 1-ից 3 քարեր կույտից։ Նա, ով հեռացնում է\n * վերջին քարը, հաղթում է խաղը։ Տրված է քարերի քանակը n, որոշեք՝ արդյոք դուք կարող եք\n * հաղթել խաղը, եթե դուք և ձեր մրցակիցը խաղում եք օպտիմալ։\n * Նշում: Դուք միշտ առաջինն եք խաղում։\n *\n * Ահա որոշ դեպքեր:\n *   f_49(1) // վերադարձնում է true\n */", "bn": "/**\n * আপনি একটি গেম খেলছেন যার নাম নিম। এই গেমে, আপনি একটি স্তূপের সাথে শুরু করেন\n * n পাথর, এবং আপনি এবং আপনার প্রতিপক্ষ পালাক্রমে 1 থেকে 3\n * পাথর স্তূপ থেকে সরিয়ে নেন। যে শেষ পাথরটি সরায় সে গেমটি জিতে।\n * পাথরের সংখ্যা n দেওয়া আছে, নির্ধারণ করুন আপনি গেমটি জিততে পারবেন কিনা যদি উভয়\n * আপনি এবং আপনার প্রতিপক্ষ সর্বোত্তমভাবে খেলে।\n * নোট: আপনি সর্বদা প্রথম পালা নেন।\n *\n * এখানে কিছু উদাহরণ রয়েছে:\n *   f_49(1) // true ফেরত দেয়\n */\nfunction f_49(n)", "bg": "/**\n * Играете игра, наречена Nim. В тази игра започвате с купчина\n * от n камъка, и вие и вашият противник се редувате да премахвате от 1 до 3\n * камъка от купчината. Този, който премахне последния камък, печели играта.\n * Като се даде броят на камъните n, определете дали можете да спечелите играта, ако и двамата\n * вие и вашият противник играете оптимално.\n * Забележка: Винаги вие правите първия ход.\n *\n * Ето някои случаи:\n *   f_49(1) // връща true\n */\nfunction f_49(n)", "zh": "/**\n * 你正在玩一个叫做 Nim 的游戏。在这个游戏中，你从一堆 n 个石头开始，你和你的对手轮流从堆中移除 1 到 3 个石头。移除最后一个石头的人赢得游戏。\n * 给定石头的数量 n，判断如果你和你的对手都采取最优策略，你是否能赢得游戏。\n * 注意：你总是先手。\n *\n * 这里有一些情况：\n *   f_49(1) // 返回 true\n */\nfunction f_49(n)", "fr": "/**\n * Vous jouez à un jeu appelé Nim. Dans ce jeu, vous commencez avec un tas\n * de n pierres, et vous et votre adversaire prenez à tour de rôle 1 à 3\n * pierres du tas. Celui qui enlève la dernière pierre gagne la partie.\n * Étant donné le nombre de pierres n, déterminez si vous pouvez gagner la partie si vous et votre adversaire jouez de manière optimale.\n * Remarque : Vous jouez toujours le premier tour.\n *\n * Voici quelques cas :\n *   f_49(1) // renvoie true\n */\nfunction f_49(n)", "de": "/**\n * Du spielst ein Spiel namens Nim. In diesem Spiel beginnst du mit einem Haufen\n * von n Steinen, und du und dein Gegner wechseln euch ab, um 1 bis 3\n * Steine aus dem Haufen zu entfernen. Derjenige, der den letzten Stein entfernt, gewinnt das Spiel.\n * Angesichts der Anzahl der Steine n, bestimme, ob du das Spiel gewinnen kannst, wenn sowohl\n * du als auch dein Gegner optimal spielen.\n * Hinweis: Du bist immer der Erste, der an der Reihe ist.\n *\n * Hier sind einige Fälle:\n *   f_49(1) // gibt true zurück\n */", "ha": "/**\n * Kana wasa da ake kira Nim. A cikin wannan wasa, ka fara da tarin\n * duwatsu n, kai da abokin hamayyarka kuna juyawa don cire 1 zuwa 3\n * duwatsu daga tarin. Wanda ya cire dutse na karshe shi ne ya ci wasan.\n * An ba da yawan duwatsu n, ka tantance ko za ka iya cin nasara idan duka\n * kai da abokin hamayyarka kuna wasa da hikima.\n * Lura: Kai ne kullum ke fara wasa.\n *\n * Ga wasu lokuta:\n *   f_49(1) // ya dawo da true\n */", "hi": "/**\n * आप एक खेल खेल रहे हैं जिसे निम कहा जाता है। इस खेल में, आप n पत्थरों के ढेर से शुरू करते हैं,\n * और आप और आपका प्रतिद्वंद्वी बारी-बारी से 1 से 3 पत्थर ढेर से हटाते हैं। जो अंतिम पत्थर हटाता है वह खेल जीतता है।\n * दिए गए पत्थरों की संख्या n के आधार पर, यह निर्धारित करें कि क्या आप खेल जीत सकते हैं यदि आप और आपका प्रतिद्वंद्वी दोनों\n * सर्वोत्तम तरीके से खेलते हैं।\n * नोट: आप हमेशा पहली बारी लेते हैं।\n *\n * यहाँ कुछ मामले हैं:\n *   f_49(1) // true लौटाता है\n */\nfunction f_49(n)", "hu": "/**\n * Egy Nim nevű játékot játszol. Ebben a játékban egy halom\n * n kővel kezdesz, és te és az ellenfeled felváltva távolítotok el 1-3\n * követ a halomból. Az nyer, aki az utolsó követ eltávolítja.\n * Adott a kövek száma n, határozd meg, hogy meg tudod-e nyerni a játékot, ha mindketten\n * optimálisan játszotok.\n * Megjegyzés: Mindig te kezded az első kört.\n *\n * Íme néhány eset:\n *   f_49(1) // visszaadja, hogy igaz\n */\nfunction f_49(n)", "es": "/**\n * Estás jugando un juego llamado Nim. En este juego, comienzas con un montón\n * de n piedras, y tú y tu oponente se turnan para quitar de 1 a 3\n * piedras del montón. El que quita la última piedra gana el juego.\n * Dado el número de piedras n, determina si puedes ganar el juego si ambos\n * tú y tu oponente juegan de manera óptima.\n * Nota: Siempre tomas el primer turno.\n *\n * Aquí hay algunos casos:\n *   f_49(1) // devuelve true\n */\nfunction f_49(n)", "arb": "/**\n * أنت تلعب لعبة تسمى نيم. في هذه اللعبة، تبدأ بكومة من n من الحجارة،\n * وأنت وخصمك تتناوبان على إزالة 1 إلى 3 حجارة من الكومة. الشخص الذي يزيل\n * الحجر الأخير يفوز باللعبة. بالنظر إلى عدد الحجارة n، حدد ما إذا كان بإمكانك\n * الفوز باللعبة إذا لعبت أنت وخصمك بشكل مثالي.\n * ملاحظة: أنت دائمًا تأخذ الدور الأول.\n *\n * إليك بعض الحالات:\n *   f_49(1) // يعيد true\n */\nfunction f_49(n)", "sw": "/**\n * Unacheza mchezo uitwao Nim. Katika mchezo huu, unaanza na rundo\n * la mawe n, na wewe na mpinzani wako mnachukua zamu kuondoa mawe 1 hadi 3\n * kutoka kwenye rundo. Yule anayeondoa jiwe la mwisho anashinda mchezo.\n * Ukizingatia idadi ya mawe n, amua kama unaweza kushinda mchezo ikiwa wote\n * wewe na mpinzani wako mna cheza kwa umahiri.\n * Kumbuka: Daima unachukua zamu ya kwanza.\n *\n * Hapa kuna baadhi ya kesi:\n *   f_49(1) // inarudisha kweli\n */\nfunction f_49(n)", "tr": "/**\n * Nim adında bir oyun oynuyorsunuz. Bu oyunda, n taşlık bir yığınla\n * başlarsınız ve siz ve rakibiniz sırayla yığından 1 ila 3 taş\n * çıkarırsınız. Son taşı çıkaran oyunu kazanır.\n * Taş sayısı n verildiğinde, eğer hem siz hem de rakibiniz optimal\n * oynarsa oyunu kazanıp kazanamayacağınızı belirleyin.\n * Not: Her zaman ilk hamleyi siz yaparsınız.\n *\n * İşte bazı durumlar:\n *   f_49(1) // true döndürür\n */\nfunction f_49(n)", "vi": "/**\n * Bạn đang chơi một trò chơi gọi là Nim. Trong trò chơi này, bạn bắt đầu với\n * một đống n viên đá, và bạn cùng đối thủ của mình lần lượt lấy đi từ 1 đến 3\n * viên đá từ đống. Người lấy viên đá cuối cùng sẽ thắng trò chơi.\n * Cho số viên đá n, xác định xem bạn có thể thắng trò chơi nếu cả bạn và\n * đối thủ đều chơi tối ưu.\n * Lưu ý: Bạn luôn đi trước.\n *\n * Dưới đây là một số trường hợp:\n *   f_49(1) // trả về true\n */\nfunction f_49(n)", "id": "/**\n * Anda sedang bermain game bernama Nim. Dalam game ini, Anda memulai dengan\n * tumpukan n batu, dan Anda serta lawan Anda bergiliran untuk mengambil 1 hingga 3\n * batu dari tumpukan. Orang yang mengambil batu terakhir memenangkan permainan.\n * Diberikan jumlah batu n, tentukan apakah Anda bisa memenangkan permainan jika\n * Anda dan lawan Anda bermain secara optimal.\n * Catatan: Anda selalu mengambil giliran pertama.\n *\n * Berikut adalah beberapa kasus:\n *   f_49(1) // mengembalikan true\n */\nfunction f_49(n)", "ja": "/**\n * あなたはNimというゲームをプレイしています。このゲームでは、n個の石の山から始め、\n * あなたと対戦相手が交互に1から3個の石を山から取り除きます。最後の石を取った人が\n * ゲームに勝ちます。石の数nが与えられたとき、あなたと対戦相手が最適にプレイした場合に\n * あなたがゲームに勝てるかどうかを判断してください。\n * 注意: あなたが常に最初のターンを取ります。\n *\n * 以下はいくつかのケースです:\n *   f_49(1) // trueを返します\n */\nfunction f_49(n)", "ko": "/**\n * 당신은 Nim이라는 게임을 하고 있습니다. 이 게임에서, 당신은 n개의 돌무더기로 시작하며,\n * 당신과 상대방은 번갈아 가며 돌무더기에서 1개에서 3개의 돌을 제거합니다.\n * 마지막 돌을 제거하는 사람이 게임에서 승리합니다.\n * 돌의 수 n이 주어졌을 때, 당신과 상대방이 최적으로 플레이할 경우 당신이 게임에서 승리할 수 있는지 결정하세요.\n * 참고: 당신이 항상 첫 번째 턴을 가집니다.\n *\n * 다음은 몇 가지 경우입니다:\n *   f_49(1) // true를 반환합니다\n */\nfunction f_49(n)", "ml": "/**\n * നിങ്ങൾ നിം എന്നൊരു ഗെയിം കളിക്കുകയാണ്. ഈ ഗെയിമിൽ, നിങ്ങൾക്ക് n കല്ലുകൾ ഉള്ള ഒരു കൂമ്പാരം ആരംഭിക്കാം,\n * നിങ്ങൾക്കും നിങ്ങളുടെ എതിരാളിക്കും കൂമ്പാരത്തിൽ നിന്ന് 1 മുതൽ 3 വരെ കല്ലുകൾ നീക്കം ചെയ്യാൻ കഴിയും.\n * അവസാന കല്ല് നീക്കം ചെയ്യുന്നവൻ ഗെയിം ജയിക്കും. കല്ലുകളുടെ എണ്ണം n നൽകിയാൽ, നിങ്ങൾക്കും നിങ്ങളുടെ എതിരാളിക്കും\n * മികച്ച രീതിയിൽ കളിക്കുമ്പോൾ നിങ്ങൾക്ക് ഗെയിം ജയിക്കാനാകുമോ എന്ന് നിർണയിക്കുക.\n * കുറിപ്പ്: നിങ്ങൾ എപ്പോഴും ആദ്യമായി കളിക്കും.\n *\n * ഇവിടെ ചില കേസുകൾ:\n *   f_49(1) // true മടക്കുന്നു\n */\nfunction f_49(n)", "fa": "/**\n * شما در حال بازی به نام Nim هستید. در این بازی، شما با یک توده\n * از n سنگ شروع می‌کنید و شما و حریف‌تان به نوبت 1 تا 3\n * سنگ از توده برمی‌دارید. کسی که آخرین سنگ را برمی‌دارد، برنده بازی است.\n * با توجه به تعداد سنگ‌ها n، تعیین کنید که آیا می‌توانید برنده بازی باشید اگر هر دو\n * شما و حریف‌تان بهینه بازی کنید.\n * توجه: شما همیشه اولین نوبت را دارید.\n *\n * در اینجا چند مورد وجود دارد:\n *   f_49(1) // مقدار true را برمی‌گرداند\n */\nfunction f_49(n)"}, "canonical_solution": "{\n    return n % 4 !== 0;\n}", "instruction": {"en": "Write a JavaScript function `function f_49(n)` to solve the following problem:\nYou are playing a game called Nim. In this game, you start with a pile of n stones, and you and your opponent take turns to remove 1 to 3 stones from the pile. The one who removes the last stone wins the game. Given the number of stones n, determine if you can win the game if both you and your opponent play optimally. Note: You always take the first turn.\n\nHere are some cases:\n  f_49(1) // returns true", "sq": "Shkruani një funksion JavaScript `function f_49(n)` për të zgjidhur problemin e mëposhtëm:\nJu po luani një lojë të quajtur Nim. Në këtë lojë, ju filloni me një grumbull prej n gurësh, dhe ju dhe kundërshtari juaj merrni radhë për të hequr 1 deri në 3 gurë nga grumbulli. Ai që heq gurin e fundit fiton lojën. Duke pasur parasysh numrin e gurëve n, përcaktoni nëse mund të fitoni lojën nëse si ju ashtu edhe kundërshtari juaj luani në mënyrë optimale. Shënim: Ju gjithmonë merrni radhën e parë.\n\nJa disa raste:\n  f_49(1) // kthen true", "hy": "Գրեք JavaScript ֆունկցիա `function f_49(n)`՝ հետևյալ խնդիրը լուծելու համար:\nԴուք խաղում եք Nim կոչվող խաղը։ Այս խաղում դուք սկսում եք n քարերով կույտից, և դուք և ձեր մրցակիցը հերթով հեռացնում եք 1-ից 3 քար կույտից։ Նա, ով հեռացնում է վերջին քարը, հաղթում է խաղը։ Տրված է քարերի քանակը n, որոշեք՝ արդյոք դուք կարող եք հաղթել խաղը, եթե և դուք, և ձեր մրցակիցը խաղում եք օպտիմալ կերպով։ Նշում. Դուք միշտ առաջինն եք քայլում։\n\nԱհա մի քանի դեպքեր:\n  f_49(1) // վերադարձնում է true", "bn": "একটি JavaScript ফাংশন `function f_49(n)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nআপনি একটি খেলা খেলছেন যার নাম নিম। এই খেলায়, আপনি n পাথর দিয়ে শুরু করেন, এবং আপনি এবং আপনার প্রতিপক্ষ পালাক্রমে ১ থেকে ৩টি পাথর স্তূপ থেকে সরান। যে শেষ পাথরটি সরায় সে খেলাটি জেতে। প্রদত্ত n সংখ্যক পাথর, নির্ধারণ করুন আপনি খেলাটি জিততে পারবেন কিনা যদি আপনি এবং আপনার প্রতিপক্ষ উভয়ই সর্বোত্তমভাবে খেলে। লক্ষ্য করুন: আপনি সবসময় প্রথম পালা নেন।\n\nকিছু উদাহরণ এখানে দেওয়া হল:\n  f_49(1) // true রিটার্ন করে", "bg": "Напишете JavaScript функция `function f_49(n)`, за да решите следния проблем:  \nИграете игра, наречена Nim. В тази игра започвате с купчина от n камъка, и вие и вашият противник се редувате да премахвате от 1 до 3 камъка от купчината. Този, който премахне последния камък, печели играта. Даден е броят на камъните n, определете дали можете да спечелите играта, ако и вие, и вашият противник играете оптимално. Забележка: Винаги вие вземате първия ход.\n\nЕто някои случаи:  \n  f_49(1) // връща true", "zh": "编写一个 JavaScript 函数 `function f_49(n)` 来解决以下问题：\n你正在玩一个叫做 Nim 的游戏。在这个游戏中，你从一堆 n 个石头开始，你和你的对手轮流从堆中移除 1 到 3 个石头。移除最后一个石头的人赢得游戏。给定石头的数量 n，确定如果你和你的对手都以最佳方式进行游戏，你是否能赢得游戏。注意：你总是先走。\n\n以下是一些情况：\n  f_49(1) // 返回 true", "fr": "Écrivez une fonction JavaScript `function f_49(n)` pour résoudre le problème suivant :  \nVous jouez à un jeu appelé Nim. Dans ce jeu, vous commencez avec un tas de n pierres, et vous et votre adversaire prenez à tour de rôle 1 à 3 pierres du tas. Celui qui enlève la dernière pierre gagne la partie. Étant donné le nombre de pierres n, déterminez si vous pouvez gagner la partie si vous et votre adversaire jouez de manière optimale. Remarque : Vous prenez toujours le premier tour.\n\nVoici quelques cas :  \n  f_49(1) // retourne true", "de": "Schreiben Sie eine JavaScript-Funktion `function f_49(n)`, um das folgende Problem zu lösen:\nSie spielen ein Spiel namens Nim. In diesem Spiel beginnen Sie mit einem Haufen von n Steinen, und Sie und Ihr Gegner wechseln sich ab, um 1 bis 3 Steine vom Haufen zu entfernen. Derjenige, der den letzten Stein entfernt, gewinnt das Spiel. Angesichts der Anzahl der Steine n, bestimmen Sie, ob Sie das Spiel gewinnen können, wenn sowohl Sie als auch Ihr Gegner optimal spielen. Hinweis: Sie sind immer der Erste, der an der Reihe ist.\n\nHier sind einige Fälle:\n  f_49(1) // gibt true zurück", "ha": "Rubuta wani aikin JavaScript `function f_49(n)` don warware matsalar mai zuwa:\nKana wasa mai suna Nim. A cikin wannan wasa, ka fara da tarin duwatsu n, kai da abokin hamayyarka kuna juyawa don cire 1 zuwa 3 duwatsu daga tarin. Wanda ya cire dutse na ƙarshe shi ne ya ci wasan. An ba da adadin duwatsu n, tantance idan za ka iya cin wasan idan kai da abokin hamayyarka kuna wasa da hikima. Lura: Kai ne koyaushe ke fara juyawa.\n\nGa wasu lokuta:\n  f_49(1) // returns true", "hi": "JavaScript फ़ंक्शन `function f_49(n)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nआप एक गेम खेल रहे हैं जिसे निम कहा जाता है। इस खेल में, आप n पत्थरों के ढेर के साथ शुरू करते हैं, और आप और आपका प्रतिद्वंद्वी बारी-बारी से ढेर से 1 से 3 पत्थर हटाते हैं। जो अंतिम पत्थर हटाता है वह खेल जीतता है। दिए गए पत्थरों की संख्या n के आधार पर, यह निर्धारित करें कि क्या आप खेल जीत सकते हैं यदि आप और आपका प्रतिद्वंद्वी दोनों ही अनुकूल रूप से खेलते हैं। नोट: आप हमेशा पहली बारी लेते हैं।\n\nयहाँ कुछ उदाहरण हैं:\n  f_49(1) // true लौटाता है", "hu": "Írj egy JavaScript függvényt `function f_49(n)` a következő probléma megoldására:\nEgy Nim nevű játékot játszol. Ebben a játékban egy halom n kővel kezdesz, és te valamint az ellenfeled felváltva távolítotok el 1-től 3-ig terjedő számú követ a halomból. Az nyer, aki az utolsó követ eltávolítja. Adott a kövek száma n, határozd meg, hogy meg tudod-e nyerni a játékot, ha te és az ellenfeled is optimálisan játszotok. Megjegyzés: Mindig te kezded az első kört.\n\nÍme néhány eset:\n  f_49(1) // visszaadja true", "es": "Escribe una función de JavaScript `function f_49(n)` para resolver el siguiente problema:\nEstás jugando un juego llamado Nim. En este juego, comienzas con una pila de n piedras, y tú y tu oponente se turnan para quitar de 1 a 3 piedras de la pila. El que quite la última piedra gana el juego. Dado el número de piedras n, determina si puedes ganar el juego si tanto tú como tu oponente juegan de manera óptima. Nota: Siempre tomas el primer turno.\n\nAquí hay algunos casos:\n  f_49(1) // devuelve true", "arb": "اكتب دالة JavaScript `function f_49(n)` لحل المشكلة التالية:\nأنت تلعب لعبة تسمى نيم. في هذه اللعبة، تبدأ بكومة من n حجارة، وأنت وخصمك تتناوبان على إزالة 1 إلى 3 حجارة من الكومة. الشخص الذي يزيل الحجر الأخير يفوز باللعبة. بالنظر إلى عدد الحجارة n، حدد ما إذا كان بإمكانك الفوز باللعبة إذا لعبت أنت وخصمك بشكل مثالي. ملاحظة: أنت دائمًا تأخذ الدور الأول.\n\nإليك بعض الحالات:\n  f_49(1) // يعيد true", "sw": "Andika kazi ya JavaScript `function f_49(n)` kutatua tatizo lifuatalo:\nUnacheza mchezo unaoitwa Nim. Katika mchezo huu, unaanza na rundo la mawe n, na wewe na mpinzani wako mnachukua zamu kuondoa mawe 1 hadi 3 kutoka kwenye rundo. Yule anayeondoa jiwe la mwisho anashinda mchezo. Ukipewa idadi ya mawe n, amua kama unaweza kushinda mchezo ikiwa wewe na mpinzani wako mna cheza kwa ufanisi. Kumbuka: Daima unachukua zamu ya kwanza.\n\nHapa kuna baadhi ya kesi:\n  f_49(1) // inarudisha true", "tr": "Bir JavaScript fonksiyonu `function f_49(n)` yazın ve aşağıdaki problemi çözün:\nNim adında bir oyun oynuyorsunuz. Bu oyunda, n taşlık bir yığınla başlarsınız ve siz ve rakibiniz sırayla yığından 1 ila 3 taş çıkarırsınız. Son taşı çıkaran oyunu kazanır. Verilen taş sayısına göre, eğer siz ve rakibiniz en iyi şekilde oynarsanız oyunu kazanıp kazanamayacağınızı belirleyin. Not: Her zaman ilk hamleyi siz yaparsınız.\n\nİşte bazı durumlar:\n  f_49(1) // true döndürür", "vi": "Viết một hàm JavaScript `function f_49(n)` để giải quyết vấn đề sau:\nBạn đang chơi một trò chơi gọi là Nim. Trong trò chơi này, bạn bắt đầu với một đống n viên đá, và bạn cùng đối thủ lần lượt lấy đi từ 1 đến 3 viên đá từ đống. Người nào lấy viên đá cuối cùng sẽ thắng trò chơi. Cho số viên đá n, xác định xem bạn có thể thắng trò chơi nếu cả bạn và đối thủ đều chơi tối ưu. Lưu ý: Bạn luôn là người đi trước.\n\nDưới đây là một số trường hợp:\n  f_49(1) // trả về true", "id": "Tulis sebuah fungsi JavaScript `function f_49(n)` untuk menyelesaikan masalah berikut:\nAnda sedang bermain permainan bernama Nim. Dalam permainan ini, Anda memulai dengan tumpukan n batu, dan Anda serta lawan Anda bergiliran mengambil 1 hingga 3 batu dari tumpukan. Orang yang mengambil batu terakhir memenangkan permainan. Diberikan jumlah batu n, tentukan apakah Anda bisa memenangkan permainan jika Anda dan lawan Anda bermain secara optimal. Catatan: Anda selalu mengambil giliran pertama.\n\nBerikut beberapa kasus:\n  f_49(1) // mengembalikan true", "ja": "JavaScript関数 `function f_49(n)` を作成して、次の問題を解決してください:\nあなたはNimというゲームをプレイしています。このゲームでは、n個の石の山から始め、あなたと対戦相手は交互に1から3個の石を山から取り除きます。最後の石を取った人がゲームに勝ちます。石の数nが与えられたとき、あなたと対戦相手が最適にプレイした場合に、あなたがゲームに勝てるかどうかを判断してください。注意: あなたは常に最初のターンを取ります。\n\nいくつかのケース:\n  f_49(1) // returns true", "ko": "JavaScript 함수 `function f_49(n)`을 작성하여 다음 문제를 해결하십시오:\n당신은 Nim이라는 게임을 하고 있습니다. 이 게임에서, 당신은 n개의 돌무더기로 시작하며, 당신과 상대방은 번갈아 가며 돌무더기에서 1개에서 3개의 돌을 제거합니다. 마지막 돌을 제거하는 사람이 게임에서 승리합니다. 돌의 수 n이 주어졌을 때, 당신과 상대방이 최적으로 플레이할 경우 당신이 게임에서 승리할 수 있는지 결정하십시오. 참고: 당신이 항상 첫 번째 턴을 가집니다.\n\n다음은 몇 가지 경우입니다:\n  f_49(1) // returns true", "ml": "`function f_49(n)` എന്ന ജാവാസ്ക്രിപ്റ്റ് ഫംഗ്ഷൻ എഴുതുക താഴെക്കാണുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nനിം എന്നൊരു ഗെയിം നിങ്ങൾ കളിക്കുകയാണ്. ഈ ഗെയിമിൽ, നിങ്ങൾ n കല്ലുകൾ ഉള്ള ഒരു കൂമ്പാരം കൊണ്ട് ആരംഭിക്കുന്നു, നിങ്ങൾക്കും നിങ്ങളുടെ എതിരാളിക്കും കൂമ്പാരത്തിൽ നിന്ന് 1 മുതൽ 3 വരെ കല്ലുകൾ നീക്കം ചെയ്യാൻ തവണകൾ ലഭിക്കുന്നു. അവസാന കല്ല് നീക്കം ചെയ്യുന്നവൻ ഗെയിം ജയിക്കുന്നു. കല്ലുകളുടെ എണ്ണം n നൽകിയിരിക്കുന്നപ്പോൾ, നിങ്ങൾക്കും നിങ്ങളുടെ എതിരാളിക്കും മികച്ച രീതിയിൽ കളിക്കുന്നുവെങ്കിൽ, നിങ്ങൾക്ക് ഗെയിം ജയിക്കാനാകുമോ എന്ന് നിർണയിക്കുക. കുറിപ്പ്: നിങ്ങൾ എപ്പോഴും ആദ്യ തവണ എടുക്കുന്നു.\n\nഇവിടെ ചില കേസുകൾ:\n  f_49(1) // true മടക്കുന്നു", "fa": "یک تابع جاوااسکریپت `function f_49(n)` بنویسید تا مسئله زیر را حل کند:\nشما در حال بازی به نام نیم هستید. در این بازی، شما با یک توده از n سنگ شروع می‌کنید و شما و حریف‌تان به نوبت 1 تا 3 سنگ را از توده برمی‌دارید. کسی که آخرین سنگ را برمی‌دارد برنده بازی است. با توجه به تعداد سنگ‌ها n، تعیین کنید که آیا می‌توانید بازی را ببرید اگر هر دو شما و حریف‌تان بهینه بازی کنید. توجه: شما همیشه اولین نوبت را برمی‌دارید.\n\nدر اینجا چند مورد وجود دارد:\n  f_49(1) // مقدار true را برمی‌گرداند"}, "level": "easy", "test": "function testf_49() {\n    console.assert(f_49(1) === true, \"Test case 1 failed\");\n    console.assert(f_49(2) === true, \"Test case 2 failed\");\n    console.assert(f_49(3) === true, \"Test case 3 failed\");\n    console.assert(f_49(4) === false, \"Test case 4 failed\");\n    console.assert(f_49(5) === true, \"Test case 5 failed\");\n    console.assert(f_49(6) === true, \"Test case 6 failed\");\n    console.assert(f_49(7) === true, \"Test case 7 failed\");\n    console.assert(f_49(8) === false, \"Test case 8 failed\");\n    console.assert(f_49(9) === true, \"Test case 9 failed\");\n    console.assert(f_49(10) === true, \"Test case 10 failed\");\n    console.assert(f_49(11) === true, \"Test case 11 failed\");\n    console.assert(f_49(12) === false, \"Test case 12 failed\");\n    console.assert(f_49(13) === true, \"Test case 13 failed\");\n    console.assert(f_49(14) === true, \"Test case 14 failed\");\n    console.assert(f_49(15) === true, \"Test case 15 failed\");\n    console.assert(f_49(16) === false, \"Test case 16 failed\");\n    console.assert(f_49(17) === true, \"Test case 17 failed\");\n    console.assert(f_49(18) === true, \"Test case 18 failed\");\n    console.assert(f_49(19) === true, \"Test case 19 failed\");\n    console.assert(f_49(20) === false, \"Test case 20 failed\");\n}\ntestf_49();", "entry_point": "f_49", "signature": "function f_49(n)", "docstring": {"en": "You are playing a game called Nim. In this game, you start with a pile of n stones, and you and your opponent take turns to remove 1 to 3 stones from the pile. The one who removes the last stone wins the game. Given the number of stones n, determine if you can win the game if both you and your opponent play optimally. Note: You always take the first turn.\n\nHere are some cases:\n  f_49(1) // returns true", "sq": "Ju po luani një lojë të quajtur Nim. Në këtë lojë, ju filloni me një grumbull prej n gurësh, dhe ju dhe kundërshtari juaj merrni me radhë për të hequr 1 deri në 3 gurë nga grumbulli. Ai që heq gurin e fundit fiton lojën. Duke pasur parasysh numrin e gurëve n, përcaktoni nëse mund të fitoni lojën nëse si ju ashtu edhe kundërshtari juaj luani në mënyrë optimale. Shënim: Ju gjithmonë merrni radhën e parë.\n\nKëtu janë disa raste:\n  f_49(1) // kthen true", "hy": "Դուք խաղում եք Նիմ կոչվող խաղը։ Այս խաղում դուք սկսում եք n քարերով կույտից, և դուք ու ձեր մրցակիցը հերթով հեռացնում եք 1-ից 3 քարեր կույտից։ Նա, ով հեռացնում է վերջին քարը, հաղթում է խաղը։ Տրված է քարերի քանակը n, որոշեք՝ արդյոք դուք կարող եք հաղթել խաղը, եթե դուք և ձեր մրցակիցը խաղում եք օպտիմալ կերպով։ Նշում. Դուք միշտ առաջինն եք խաղում։\n\nԱհա որոշ դեպքեր.\n  f_49(1) // վերադարձնում է true", "bn": "আপনি একটি খেলা খেলছেন যার নাম নিম। এই খেলায়, আপনি একটি n পাথরের স্তূপ দিয়ে শুরু করেন, এবং আপনি এবং আপনার প্রতিপক্ষ পালাক্রমে স্তূপ থেকে ১ থেকে ৩টি পাথর সরান। যে ব্যক্তি শেষ পাথরটি সরায় সে খেলায় জেতে। পাথরের সংখ্যা n দেওয়া আছে, যদি আপনি এবং আপনার প্রতিপক্ষ উভয়েই সর্বোত্তমভাবে খেলেন, তবে আপনি কি খেলাটি জিততে পারবেন তা নির্ধারণ করুন। লক্ষ্য করুন: আপনি সবসময় প্রথম পালা নেন।\n\nকিছু উদাহরণ এখানে দেওয়া হল:\n  f_49(1) // true ফেরত দেয়", "bg": "Играете игра, наречена Nim. В тази игра започвате с купчина от n камъка, и вие и вашият противник се редувате да премахвате от 1 до 3 камъка от купчината. Този, който премахне последния камък, печели играта. Като имате предвид броя на камъните n, определете дали можете да спечелите играта, ако и вие, и вашият противник играете оптимално. Забележка: Винаги вие започвате първи.\n\nЕто някои случаи:\n  f_49(1) // връща true", "zh": "你正在玩一个叫做 Nim 的游戏。在这个游戏中，你从一堆 n 个石头开始，你和你的对手轮流从堆中移走 1 到 3 个石头。移走最后一个石头的人赢得游戏。给定石头的数量 n，判断如果你和你的对手都采取最佳策略，你是否能赢得游戏。注意：你总是先走。\n\n以下是一些情况：\n  f_49(1) // 返回 true", "fr": "Vous jouez à un jeu appelé Nim. Dans ce jeu, vous commencez avec un tas de n pierres, et vous et votre adversaire retirez à tour de rôle de 1 à 3 pierres du tas. Celui qui retire la dernière pierre gagne la partie. Étant donné le nombre de pierres n, déterminez si vous pouvez gagner la partie si vous et votre adversaire jouez de manière optimale. Remarque : Vous jouez toujours le premier tour.\n\nVoici quelques cas :\n  f_49(1) // renvoie true", "de": "Du spielst ein Spiel namens Nim. In diesem Spiel beginnst du mit einem Haufen von n Steinen, und du und dein Gegner wechseln euch ab, um 1 bis 3 Steine vom Haufen zu entfernen. Derjenige, der den letzten Stein entfernt, gewinnt das Spiel. Gegeben ist die Anzahl der Steine n, bestimme, ob du das Spiel gewinnen kannst, wenn sowohl du als auch dein Gegner optimal spielen. Hinweis: Du bist immer derjenige, der den ersten Zug macht.\n\nHier sind einige Fälle:\n  f_49(1) // gibt true zurück", "ha": "Kana wasa mai suna Nim. A cikin wannan wasa, ka fara da tarin duwatsu n, kai da abokin hamayyarka kuna juyawa don cire 1 zuwa 3 duwatsu daga tarin. Wanda ya cire dutse na ƙarshe shi ne zai ci wasan. An ba da adadin duwatsu n, tantance ko za ka iya cin nasara a wasan idan kai da abokin hamayyarka kuna wasa da kyau. Lura: Kai ne kullum ke fara wasa.\n\nGa wasu lokuta:\n  f_49(1) // yana dawowa da gaskiya", "hi": "आप एक खेल खेल रहे हैं जिसे निम कहा जाता है। इस खेल में, आप n पत्थरों के ढेर के साथ शुरू करते हैं, और आप और आपका प्रतिद्वंद्वी बारी-बारी से ढेर से 1 से 3 पत्थर हटाते हैं। जो अंतिम पत्थर हटाता है वह खेल जीतता है। दिए गए पत्थरों की संख्या n के आधार पर, यह निर्धारित करें कि क्या आप खेल जीत सकते हैं यदि आप और आपका प्रतिद्वंद्वी दोनों ही अनुकूल रूप से खेलते हैं। नोट: आप हमेशा पहली बारी लेते हैं।\n\nयहाँ कुछ मामले हैं:\n  f_49(1) // true लौटाता है", "hu": "Nim nevű játékot játszol. Ebben a játékban egy halom n kővel kezdesz, és te, valamint az ellenfeled felváltva távolítotok el 1-3 követ a halomból. Az nyer, aki az utolsó követ eltávolítja. Adott a kövek száma n, határozd meg, hogy nyerhetsz-e, ha te és az ellenfeled is optimálisan játszotok. Megjegyzés: Mindig te kezded az első lépést.\n\nÍme néhány eset:\n  f_49(1) // visszaadja: true", "es": "Estás jugando un juego llamado Nim. En este juego, comienzas con un montón de n piedras, y tú y tu oponente se turnan para quitar de 1 a 3 piedras del montón. Quien quite la última piedra gana el juego. Dado el número de piedras n, determina si puedes ganar el juego si tanto tú como tu oponente juegan de manera óptima. Nota: Siempre tomas el primer turno.\n\nAquí hay algunos casos:\n  f_49(1) // devuelve true", "arb": "أنت تلعب لعبة تسمى نيم. في هذه اللعبة، تبدأ بكومة من n من الحجارة، وأنت وخصمك تتناوبان على إزالة 1 إلى 3 حجارة من الكومة. الشخص الذي يزيل آخر حجر يفوز باللعبة. بالنظر إلى عدد الحجارة n، حدد ما إذا كان بإمكانك الفوز باللعبة إذا لعبت أنت وخصمك بشكل مثالي. ملاحظة: أنت دائمًا تأخذ الدور الأول.\n\nإليك بعض الحالات:\n  f_49(1) // يعيد true", "sw": "Unacheza mchezo unaoitwa Nim. Katika mchezo huu, unaanza na rundo la mawe n, na wewe na mpinzani wako mnapokezana kuondoa mawe 1 hadi 3 kutoka kwenye rundo. Yule anayeondoa jiwe la mwisho ndiye anayeshinda mchezo. Ukipewa idadi ya mawe n, amua kama unaweza kushinda mchezo ikiwa wewe na mpinzani wako mnaocheza kwa ufanisi. Kumbuka: Daima unachukua zamu ya kwanza.\n\nHapa kuna baadhi ya kesi:\n  f_49(1) // inarudisha kweli", "tr": "Nim adlı bir oyun oynuyorsunuz. Bu oyunda, n taşlık bir yığınla başlarsınız ve siz ve rakibiniz sırayla yığından 1 ila 3 taş alırsınız. Son taşı alan oyunu kazanır. Taş sayısı n verildiğinde, hem siz hem de rakibiniz en iyi şekilde oynarsa oyunu kazanıp kazanamayacağınızı belirleyin. Not: Her zaman ilk hamleyi siz yaparsınız.\n\nİşte bazı durumlar:\n  f_49(1) // true döndürür", "vi": "Bạn đang chơi một trò chơi có tên là Nim. Trong trò chơi này, bạn bắt đầu với một đống gồm n viên đá, và bạn cùng đối thủ lần lượt lấy đi từ 1 đến 3 viên đá từ đống. Người nào lấy viên đá cuối cùng sẽ thắng trò chơi. Với số viên đá n đã cho, xác định xem bạn có thể thắng trò chơi hay không nếu cả bạn và đối thủ đều chơi tối ưu. Lưu ý: Bạn luôn đi trước.\n\nDưới đây là một số trường hợp:\n  f_49(1) // trả về true", "id": "Anda sedang bermain permainan bernama Nim. Dalam permainan ini, Anda memulai dengan tumpukan n batu, dan Anda serta lawan Anda bergiliran untuk mengambil 1 hingga 3 batu dari tumpukan. Orang yang mengambil batu terakhir memenangkan permainan. Diberikan jumlah batu n, tentukan apakah Anda bisa memenangkan permainan jika Anda dan lawan Anda bermain secara optimal. Catatan: Anda selalu mengambil giliran pertama.\n\nBerikut adalah beberapa kasus:\n  f_49(1) // mengembalikan true", "ja": "あなたはNimというゲームをプレイしています。このゲームでは、n個の石の山から始め、あなたと対戦相手が交互に1から3個の石を山から取り除きます。最後の石を取り除いた人がゲームに勝ちます。石の数nが与えられたとき、あなたと対戦相手が最適にプレイした場合に、あなたがゲームに勝てるかどうかを判断してください。注意: あなたは常に最初のターンを取ります。\n\nいくつかのケースを示します:\n  f_49(1) // trueを返します", "ko": "당신은 Nim이라는 게임을 하고 있습니다. 이 게임에서, 당신은 n개의 돌 더미로 시작하고, 당신과 상대방은 번갈아 가며 더미에서 1개에서 3개의 돌을 제거합니다. 마지막 돌을 제거하는 사람이 게임에서 승리합니다. 돌의 수 n이 주어졌을 때, 당신과 상대방이 최적의 플레이를 한다면 당신이 게임에서 승리할 수 있는지 판단하십시오. 참고: 당신이 항상 첫 번째 턴을 가집니다.\n\n다음은 몇 가지 경우입니다:\n  f_49(1) // true를 반환합니다", "ml": "നിങ്ങൾ നിം എന്നൊരു ഗെയിം കളിക്കുകയാണ്. ഈ ഗെയിമിൽ, നിങ്ങൾ n കല്ലുകൾ അടങ്ങിയ ഒരു കൂമ്പാരം ഉപയോഗിച്ച് തുടങ്ങുന്നു, നിങ്ങൾക്കും നിങ്ങളുടെ എതിരാളിക്കും കൂമ്പാരത്തിൽ നിന്ന് 1 മുതൽ 3 വരെ കല്ലുകൾ നീക്കം ചെയ്യാനുള്ള അവസരം ലഭിക്കുന്നു. അവസാനത്തെ കല്ല് നീക്കം ചെയ്യുന്നവൻ ഗെയിം ജയിക്കും. കല്ലുകളുടെ എണ്ണം n നൽകിയാൽ, നിങ്ങൾക്കും നിങ്ങളുടെ എതിരാളിക്കും മികച്ച രീതിയിൽ കളിക്കുമ്പോൾ നിങ്ങൾക്ക് ഗെയിം ജയിക്കാനാകുമോ എന്ന് നിർണയിക്കുക. കുറിപ്പ്: നിങ്ങൾ എപ്പോഴും ആദ്യ തവണ കളിക്കുന്നു.\n\nഇവിടെ ചില കേസുകൾ ഉണ്ട്:\n  f_49(1) // true തിരികെ നൽകുന്നു", "fa": "شما در حال بازی به نام Nim هستید. در این بازی، شما با یک توده از n سنگ شروع می‌کنید و شما و حریف‌تان به نوبت 1 تا 3 سنگ از توده برمی‌دارید. کسی که آخرین سنگ را بردارد، برنده بازی است. با توجه به تعداد سنگ‌ها n، تعیین کنید که آیا می‌توانید بازی را ببرید اگر هر دو شما و حریف‌تان بهینه بازی کنید. توجه: شما همیشه اولین نوبت را دارید.\n\nدر اینجا چند مورد وجود دارد:\n  f_49(1) // true را برمی‌گرداند"}}
{"task_id": "JavaScript/50", "prompt": {"en": "/**\n * Given two integers a and b, return the sum if the sum is even,\n * or return the product of a and b if the sum is odd.\n * Examples:\n *   f_50(2, 3) returns 6\n */\nfunction f_50(a, b)", "sq": "/**\n * Duke pasur dy numra të plotë a dhe b, kthe shumën nëse shuma është çift,\n * ose kthe produktin e a dhe b nëse shuma është tek.\n * Shembuj:\n *   f_50(2, 3) kthen 6\n */\nfunction f_50(a, b)", "hy": "/**\n * Տրված երկու ամբողջ թիվ a և b, վերադարձնել գումարը, եթե գումարը զույգ է,\n * կամ վերադարձնել a և b արտադրյալը, եթե գումարը կենտ է։\n * Օրինակներ:\n *   f_50(2, 3) վերադարձնում է 6\n */\nfunction f_50(a, b)", "bn": "/**\n * দুটি পূর্ণসংখ্যা a এবং b দেওয়া হলে, যোগফলটি যদি জোড় হয় তবে যোগফল ফেরত দিন,\n * অথবা যদি যোগফলটি বিজোড় হয় তবে a এবং b এর গুণফল ফেরত দিন।\n * উদাহরণ:\n *   f_50(2, 3) 6 ফেরত দেয়\n */\nfunction f_50(a, b)", "bg": "/**\n * Дадени са две цели числа a и b, върни сумата, ако сумата е четна,\n * или върни произведението на a и b, ако сумата е нечетна.\n * Примери:\n *   f_50(2, 3) връща 6\n */\nfunction f_50(a, b)", "zh": "/**\n * 给定两个整数 a 和 b，如果它们的和是偶数，则返回和，\n * 如果和是奇数，则返回 a 和 b 的乘积。\n * 示例:\n *   f_50(2, 3) 返回 6\n */\nfunction f_50(a, b)", "fr": "/**\n * Étant donné deux entiers a et b, retourner la somme si la somme est paire,\n * ou retourner le produit de a et b si la somme est impaire.\n * Exemples :\n *   f_50(2, 3) retourne 6\n */\nfunction f_50(a, b)", "de": "/**\n * Gegeben zwei ganze Zahlen a und b, gib die Summe zurück, wenn die Summe gerade ist,\n * oder gib das Produkt von a und b zurück, wenn die Summe ungerade ist.\n * Beispiele:\n *   f_50(2, 3) gibt 6 zurück\n */\nfunction f_50(a, b)", "ha": "/**\n * Idan aka ba da lambobi guda biyu a da b, dawo da jumlar idan jumlar ta zama lamba mai lamba biyu,\n * ko kuma dawo da samfurin a da b idan jumlar ta zama lamba mai lamba daya.\n * Misalai:\n *   f_50(2, 3) returns 6\n */\nfunction f_50(a, b)", "hi": "/**\n * दिए गए दो पूर्णांक a और b, यदि योग सम है तो योग लौटाएं,\n * या यदि योग विषम है तो a और b का गुणनफल लौटाएं।\n * उदाहरण:\n *   f_50(2, 3) 6 लौटाता है\n */\nfunction f_50(a, b)", "hu": "/**\n * Két egész szám, a és b esetén térj vissza az összeggel, ha az összeg páros,\n * vagy térj vissza a és b szorzatával, ha az összeg páratlan.\n * Példák:\n *   f_50(2, 3) visszaadja 6\n */\nfunction f_50(a, b)", "es": "/**\n * Dados dos enteros a y b, devuelve la suma si la suma es par,\n * o devuelve el producto de a y b si la suma es impar.\n * Ejemplos:\n *   f_50(2, 3) devuelve 6\n */\nfunction f_50(a, b)", "arb": "/**\n * بالنظر إلى عددين صحيحين a و b، قم بإرجاع المجموع إذا كان المجموع زوجيًا،\n * أو قم بإرجاع حاصل ضرب a و b إذا كان المجموع فرديًا.\n * أمثلة:\n *   f_50(2, 3) يعيد 6\n */\nfunction f_50(a, b)", "sw": "/**\n * Ukipewa nambari mbili a na b, rudisha jumla ikiwa jumla ni nambari shufwa,\n * au rudisha bidhaa ya a na b ikiwa jumla ni nambari witiri.\n * Mifano:\n *   f_50(2, 3) inarudisha 6\n */\nfunction f_50(a, b)", "tr": "/**\n * İki tamsayı a ve b verildiğinde, toplam çift ise toplamı döndür,\n * veya toplam tek ise a ve b'nin çarpımını döndür.\n * Örnekler:\n *   f_50(2, 3) 6 döndürür\n */\nfunction f_50(a, b)", "vi": "/**\n * Cho hai số nguyên a và b, trả về tổng nếu tổng là số chẵn,\n * hoặc trả về tích của a và b nếu tổng là số lẻ.\n * Ví dụ:\n *   f_50(2, 3) trả về 6\n */\nfunction f_50(a, b)", "id": "/**\n * Diberikan dua bilangan bulat a dan b, kembalikan jumlahnya jika jumlahnya genap,\n * atau kembalikan hasil kali a dan b jika jumlahnya ganjil.\n * Contoh:\n *   f_50(2, 3) mengembalikan 6\n */\nfunction f_50(a, b)", "ja": "/**\n * 2つの整数aとbが与えられたとき、合計が偶数であればその合計を返し、\n * 合計が奇数であればaとbの積を返します。\n * 例:\n *   f_50(2, 3) は6を返します\n */\nfunction f_50(a, b)", "ko": "/**\n * 두 정수 a와 b가 주어졌을 때, 합이 짝수이면 합을 반환하고,\n * 합이 홀수이면 a와 b의 곱을 반환합니다.\n * 예시:\n *   f_50(2, 3) returns 6\n */\nfunction f_50(a, b)", "ml": "/**\n * രണ്ട് പൂർണ്ണസംഖ്യകൾ a, b എന്നിവ നൽകിയാൽ, തുക സമവായിരിക്കുകയാണെങ്കിൽ തുക തിരികെ നൽകുക,\n * അല്ലെങ്കിൽ തുക ഒറ്റയാണെങ്കിൽ a, b എന്നിവയുടെ ഗുണഫലം തിരികെ നൽകുക.\n * ഉദാഹരണങ്ങൾ:\n *   f_50(2, 3) 6 തിരികെ നൽകുന്നു\n */\nfunction f_50(a, b)", "fa": "/**\n * با توجه به دو عدد صحیح a و b، اگر مجموع زوج باشد، مجموع را برگردانید،\n * یا اگر مجموع فرد باشد، حاصل‌ضرب a و b را برگردانید.\n * مثال‌ها:\n *   f_50(2, 3) returns 6\n */\nfunction f_50(a, b)"}, "canonical_solution": "{\n    let sum = a + b;\n    if (sum % 2 === 0) {\n        return sum;\n    } else {\n        return a * b;\n    }\n}", "instruction": {"en": "Write a JavaScript function `function f_50(a, b)` to solve the following problem:\nGiven two integers a and b, return the sum if the sum is even,\n or return the product of a and b if the sum is odd.\n Examples:\n   f_50(2, 3) returns 6\n", "sq": "Shkruani një funksion JavaScript `function f_50(a, b)` për të zgjidhur problemin në vijim:  \nDuke pasur dy numra të plotë a dhe b, kthejeni shumën nëse shuma është çift,  \nose kthejeni produktin e a dhe b nëse shuma është tek.  \nShembuj:  \n  f_50(2, 3) kthen 6", "hy": "Գրեք JavaScript ֆունկցիա `function f_50(a, b)`՝ հետևյալ խնդիրը լուծելու համար:\nՏրված են երկու ամբողջ թիվ a և b, վերադարձնել գումարը, եթե գումարը զույգ է,\nկամ վերադարձնել a և b արտադրյալը, եթե գումարը կենտ է:\nՕրինակներ:\n   f_50(2, 3) վերադարձնում է 6", "bn": "একটি জাভাস্ক্রিপ্ট ফাংশন `function f_50(a, b)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nদুটি পূর্ণসংখ্যা a এবং b দেওয়া হলে, যোগফলটি যদি জোড় হয় তবে যোগফল ফেরত দিন,\nঅথবা যদি যোগফলটি বিজোড় হয় তবে a এবং b এর গুণফল ফেরত দিন।\nউদাহরণসমূহ:\n   f_50(2, 3) 6 ফেরত দেয়", "bg": "Напишете JavaScript функция `function f_50(a, b)` за решаване на следния проблем:  \nДадени са два цели числа a и b, върнете сумата, ако сумата е четна,  \nили върнете произведението на a и b, ако сумата е нечетна.  \nПримери:  \n  f_50(2, 3) връща 6  ", "zh": "编写一个 JavaScript 函数 `function f_50(a, b)` 来解决以下问题：  \n给定两个整数 a 和 b，如果它们的和是偶数则返回和，  \n如果和是奇数则返回 a 和 b 的乘积。  \n示例：  \n  f_50(2, 3) 返回 6  ", "fr": "Écrire une fonction JavaScript `function f_50(a, b)` pour résoudre le problème suivant :  \nÉtant donné deux entiers a et b, retourner la somme si la somme est paire,  \nou retourner le produit de a et b si la somme est impaire.  \nExemples :  \n  f_50(2, 3) retourne 6  ", "de": "Schreiben Sie eine JavaScript-Funktion `function f_50(a, b)`, um das folgende Problem zu lösen:  \nGegeben sind zwei ganze Zahlen a und b, geben Sie die Summe zurück, wenn die Summe gerade ist,  \noder geben Sie das Produkt von a und b zurück, wenn die Summe ungerade ist.  \nBeispiele:  \n   f_50(2, 3) gibt 6 zurück  ", "ha": "Rubuta aikin JavaScript `function f_50(a, b)` don warware matsalar mai zuwa:\nAn ba da lambobi guda biyu a da b, dawo da jimlar idan jimlar tana da lamba maɗaukaki,\n ko dawo da samfurin a da b idan jimlar tana da lamba maras maɗaukaki.\n Misalai:\n   f_50(2, 3) returns 6", "hi": "`function f_50(a, b)` नामक एक JavaScript फ़ंक्शन लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके: दिए गए दो पूर्णांक a और b, यदि योग सम है तो योग लौटाएं, या यदि योग विषम है तो a और b का गुणनफल लौटाएं। उदाहरण: f_50(2, 3) 6 लौटाता है", "hu": "Írj egy JavaScript függvényt `function f_50(a, b)` a következő probléma megoldására:  \nAdott két egész szám, a és b, add vissza az összegüket, ha az összeg páros,  \nvagy add vissza a szorzatukat, ha az összeg páratlan.  \nPéldák:  \n  f_50(2, 3) visszaadja 6", "es": "Escribe una función de JavaScript `function f_50(a, b)` para resolver el siguiente problema:  \nDado dos enteros a y b, devuelve la suma si la suma es par,  \no devuelve el producto de a y b si la suma es impar.  \nEjemplos:  \n  f_50(2, 3) devuelve 6  ", "arb": "اكتب دالة JavaScript `function f_50(a, b)` لحل المشكلة التالية:\nبالنظر إلى عددين صحيحين a و b، أعد المجموع إذا كان المجموع زوجيًا، أو أعد حاصل ضرب a و b إذا كان المجموع فرديًا.\nأمثلة:\n   f_50(2, 3) يعيد 6", "sw": "Andika kazi ya JavaScript `function f_50(a, b)` kutatua tatizo lifuatalo:  \nUkipiwa nambari mbili nzima a na b, rudisha jumla ikiwa jumla ni nambari shufwa,  \nau rudisha bidhaa ya a na b ikiwa jumla ni nambari witiri.  \nMifano:  \n  f_50(2, 3) inarudisha 6  ", "tr": "Bir JavaScript fonksiyonu `function f_50(a, b)` yazın ve aşağıdaki problemi çözün:\nVerilen iki tam sayı a ve b için, toplam çift ise toplamı döndürün,\n eğer toplam tek ise a ve b'nin çarpımını döndürün.\n Örnekler:\n   f_50(2, 3) 6 döndürür", "vi": "Viết một hàm JavaScript `function f_50(a, b)` để giải quyết vấn đề sau:\nCho hai số nguyên a và b, trả về tổng nếu tổng là số chẵn,\nhoặc trả về tích của a và b nếu tổng là số lẻ.\nVí dụ:\n  f_50(2, 3) trả về 6", "id": "Tulis sebuah fungsi JavaScript `function f_50(a, b)` untuk menyelesaikan masalah berikut:  \nDiberikan dua bilangan bulat a dan b, kembalikan jumlahnya jika jumlahnya genap,  \natau kembalikan hasil kali dari a dan b jika jumlahnya ganjil.  \nContoh:  \n  f_50(2, 3) mengembalikan 6  ", "ja": "JavaScript関数 `function f_50(a, b)` を作成して、次の問題を解決してください:\n2つの整数 a と b が与えられたとき、合計が偶数であれば合計を返し、\n合計が奇数であれば a と b の積を返します。\n例:\n   f_50(2, 3) は 6 を返します", "ko": "JavaScript 함수를 작성하세요 `function f_50(a, b)` 다음 문제를 해결하기 위해:\n두 정수 a와 b가 주어졌을 때, 합이 짝수이면 합을 반환하고,\n합이 홀수이면 a와 b의 곱을 반환하세요.\n예시:\n   f_50(2, 3) returns 6", "ml": "`function f_50(a, b)` എന്ന ജാവാസ്ക്രിപ്റ്റ് ഫങ്ഷൻ എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nരണ്ട് പൂർണ്ണസംഖ്യകൾ a, b എന്നിവ നൽകിയാൽ, ആകെ തുക സമവായിരിക്കുകയാണെങ്കിൽ തുക തിരിച്ചുനൽകുക,\nഅല്ലെങ്കിൽ ആകെ തുക ബിസമവായിരിക്കുകയാണെങ്കിൽ a, b എന്നിവയുടെ ഗുണഫലം തിരിച്ചുനൽകുക.\nഉദാഹരണങ്ങൾ:\n   f_50(2, 3) 6 തിരിച്ചുനൽകുന്നു", "fa": "یک تابع جاوااسکریپت `function f_50(a, b)` بنویسید تا مسئله زیر را حل کند:\nبا توجه به دو عدد صحیح a و b، اگر مجموع زوج باشد، مجموع را برگردانید،\nیا اگر مجموع فرد باشد، حاصل‌ضرب a و b را برگردانید.\nمثال‌ها:\n   f_50(2, 3) مقدار 6 را برمی‌گرداند"}, "level": "easy", "test": "const testf_50 = () => {\n    console.assert(f_50(2, 3) === 6, 'Test Case 1 Failed');\n    console.assert(f_50(5, 5) === 10, 'Test Case 2 Failed');\n    console.assert(f_50(1, 1) === 2, 'Test Case 3 Failed');\n    console.assert(f_50(0, 0) === 0, 'Test Case 4 Failed');\n    console.assert(f_50(-1, -1) === -2, 'Test Case 5 Failed');\n    console.assert(f_50(100, 200) === 300, 'Test Case 6 Failed');\n    console.assert(f_50(3, 4) === 12, 'Test Case 7 Failed');\n    console.assert(f_50(-5, 5) === 0, 'Test Case 8 Failed');\n    console.assert(f_50(7, 8) === 56, 'Test Case 9 Failed');\n    console.assert(f_50(9, 10) === 90, 'Test Case 10 Failed');\n    console.assert(f_50(11, 14) === 154, 'Test Case 11 Failed');\n}\n\ntestf_50();", "entry_point": "f_50", "signature": "function f_50(a, b)", "docstring": {"en": "Given two integers a and b, return the sum if the sum is even,\n or return the product of a and b if the sum is odd.\n Examples:\n   f_50(2, 3) returns 6\n", "sq": "Given dy numra të plotë a dhe b, kthe shumën nëse shuma është çift, ose kthe produktin e a dhe b nëse shuma është tek.\nShembuj:\n   f_50(2, 3) returns 6", "hy": "Տրված են երկու ամբողջ թվեր a և b, վերադարձնել գումարը, եթե գումարը զույգ է,\n կամ վերադարձնել a և b արտադրյալը, եթե գումարը կենտ է։\n Օրինակներ:\n   f_50(2, 3) վերադարձնում է 6", "bn": "দুটি পূর্ণসংখ্যা a এবং b দেওয়া হলে, যদি যোগফলটি জোড় হয় তবে যোগফলটি ফেরত দিন, অথবা যদি যোগফলটি বিজোড় হয় তবে a এবং b এর গুণফল ফেরত দিন। \nউদাহরণসমূহ:\n   f_50(2, 3) 6 ফেরত দেয়", "bg": "Дадени са две цели числа a и b, върнете сумата, ако сумата е четна, или върнете произведението на a и b, ако сумата е нечетна.\nПримери:\n   f_50(2, 3) връща 6", "zh": "给定两个整数 a 和 b，如果它们的和是偶数，则返回和；如果和是奇数，则返回 a 和 b 的乘积。\n示例：\n   f_50(2, 3) 返回 6", "fr": "Étant donné deux entiers a et b, renvoyer la somme si la somme est paire, ou renvoyer le produit de a et b si la somme est impaire.\nExemples:\n   f_50(2, 3) renvoie 6", "de": "Gegeben sind zwei ganze Zahlen a und b, geben Sie die Summe zurück, wenn die Summe gerade ist,\n oder geben Sie das Produkt von a und b zurück, wenn die Summe ungerade ist.\nBeispiele:\n   f_50(2, 3) gibt 6 zurück  ", "ha": "An ba da lambobi guda biyu a da b, dawo da jimlar idan jimlar tana da lamba maɗaukaki,\n ko dawo da samfurin a da b idan jimlar tana da lamba maras maɗaukaki.\nMisalai:\n   f_50(2, 3) returns 6", "hi": "दो पूर्णांक a और b दिए गए हैं, यदि योग सम है तो योग लौटाएं, या यदि योग विषम है तो a और b का गुणनफल लौटाएं। उदाहरण: f_50(2, 3) 6 लौटाता है", "hu": "Két egész szám, a és b esetén térjen vissza az összeggel, ha az összeg páros, vagy térjen vissza a és b szorzatával, ha az összeg páratlan.\nPéldák:\n   f_50(2, 3) visszatér 6", "es": "Dado dos enteros a y b, devuelve la suma si la suma es par, o devuelve el producto de a y b si la suma es impar.\nEjemplos:\n   f_50(2, 3) devuelve 6", "arb": "إعطاء عددين صحيحين a و b، إرجاع المجموع إذا كان المجموع زوجيًا، أو إرجاع حاصل ضرب a و b إذا كان المجموع فرديًا.\n\nأمثلة:\n   f_50(2, 3) يعيد 6", "sw": "Ukipiwa nambari mbili nzima a na b, rudisha jumla ikiwa jumla ni nambari shufwa, \n au rudisha bidhaa ya a na b ikiwa jumla ni nambari witiri.\n Mifano:\n   f_50(2, 3) inarudisha 6", "tr": " Verilen iki tam sayı a ve b için, toplam çift ise toplamı döndürün,\n eğer toplam tek ise a ve b'nin çarpımını döndürün.\n Örnekler:\n   f_50(2, 3) 6 döndürür", "vi": "Cho hai số nguyên a và b, trả về tổng nếu tổng là số chẵn,\nhoặc trả về tích của a và b nếu tổng là số lẻ.\nVí dụ:\n  f_50(2, 3) trả về 6  ", "id": "Diberikan dua bilangan bulat a dan b, kembalikan jumlahnya jika jumlahnya genap, atau kembalikan hasil kali dari a dan b jika jumlahnya ganjil.\nContoh:\n   f_50(2, 3) mengembalikan 6", "ja": "2つの整数aとbが与えられたとき、合計が偶数であればその合計を返し、合計が奇数であればaとbの積を返します。\n例:\n   f_50(2, 3) は6を返します", "ko": "두 정수 a와 b가 주어지면, 합이 짝수일 경우 합을 반환하고, 합이 홀수일 경우 a와 b의 곱을 반환합니다.\n예시:\n   f_50(2, 3) returns 6", "ml": "രണ്ട് പൂർണ്ണസംഖ്യകൾ a, b എന്നിവ നൽകിയാൽ, തുക സമവായിരിക്കുകയാണെങ്കിൽ തുക തിരികെ നൽകുക,\n * അല്ലെങ്കിൽ തുക ഒറ്റയാണെങ്കിൽ a, b എന്നിവയുടെ ഗുണഫലം തിരികെ നൽകുക.\nഉദാഹരണങ്ങൾ:\n   f_50(2, 3) 6 മടക്കുന്നു", "fa": "با توجه به دو عدد صحیح a و b، اگر مجموع زوج باشد، مجموع را برگردانید، \nیا اگر مجموع فرد است، حاصل‌ضرب a و b را برگردانید.  \nExamples:  \n   f_50(2, 3) returns 6"}}
