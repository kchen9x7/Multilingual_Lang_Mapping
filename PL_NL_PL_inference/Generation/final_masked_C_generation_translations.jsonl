{"task_id": "C/1", "prompt": {"en": "#include <assert.h>\n#include <string.h>\n// Return \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"\nchar *f_1()", "sq": "#include <assert.h>\n#include <string.h>\n// Kthen \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"\nchar *f_1()", "hy": "#include <assert.h>\n#include <string.h>\n// Վերադարձնել \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"\nchar *f_1()", "bn": "#include <assert.h>\n#include <string.h>\n// \"Hello, Mass-McEval: massively scaled multilingual code evaluation\" ফেরত দিন\nchar *f_1()", "bg": "#include <assert.h>\n#include <string.h>\n// Връща \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"\nchar *f_1()", "zh": "#include <assert.h>\n#include <string.h>\n// 返回 \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"\nchar *f_1()", "fr": "#include <assert.h>\n#include <string.h>\n// Retourne \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"\nchar *f_1()", "de": "#include <assert.h>\n#include <string.h>\n// Gibt \"Hello, Mass-McEval: massively scaled multilingual code evaluation\" zurück\nchar *f_1()", "ha": "#include <assert.h>\n#include <string.h>\n// Mayar da \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"\nchar *f_1()", "hi": "#include <assert.h>\n#include <string.h>\n// \"Hello, Mass-McEval: massively scaled multilingual code evaluation\" लौटाएं\nchar *f_1()", "hu": "#include <assert.h>\n#include <string.h>\n// Adja vissza a \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"\nchar *f_1()", "es": "#include <assert.h>\n#include <string.h>\n// Devuelve \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"\nchar *f_1()", "arb": "#include <assert.h>\n#include <string.h>\n// إرجاع \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"\nchar *f_1()", "sw": "#include <assert.h>\n#include <string.h>\n// Rudisha \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"\nchar *f_1()", "tr": "#include <assert.h>\n#include <string.h>\n// çözün\"Hello, Mass-McEval: massively scaled multilingual code evaluation\" döndür\nchar *f_1()", "vi": "#include <assert.h>\n#include <string.h>\n// Trả về \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"\nchar *f_1()", "id": "#include <assert.h>\n#include <string.h>\n// Mengembalikan \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"\nchar *f_1()\n", "ja": "#include <assert.h>\n#include <string.h>\n// \"Hello, Mass-McEval: massively scaled multilingual code evaluation\" を返します\nchar *f_1()", "ko": "#include <assert.h>\n#include <string.h>\n// \"Hello, Mass-McEval: massively scaled multilingual code evaluation\" 반환\nchar *f_1()\n", "ml": "#include <assert.h>\n#include <string.h>\n// \"Hello, Mass-McEval: massively scaled multilingual code evaluation\" എന്നത് തിരിച്ചുനൽകുക\nchar *f_1()", "fa": "#include <assert.h>\n#include <string.h>\n// بازگرداندن \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"\nchar *f_1()"}, "canonical_solution": "{\n    return \"Hello, Mass-McEval: massively scaled multilingual code evaluation\";\n}", "instruction": {"en": "Write a C function `char *f_1()` to solve the following problem:\nReturn \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "sq": "Shkruani një funksion në C `char *f_1()` për të zgjidhur problemin e mëposhtëm:\nKthe \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "hy": "Գրեք C ֆունկցիա `char *f_1()` հետևյալ խնդիրը լուծելու համար:\nՎերադարձնել \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "bn": "একটি C ফাংশন `char *f_1()` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\n\"Hello, Mass-McEval: massively scaled multilingual code evaluation\" রিটার্ন করুন", "bg": "Напишете C функция `char *f_1()` за решаване на следния проблем:\nВърнете \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "zh": "编写一个 C 函数 `char *f_1()` 来解决以下问题：\n返回 \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "fr": "Écrivez une fonction C `char *f_1()` pour résoudre le problème suivant:\nRetourner \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "de": "Schreiben Sie eine C-Funktion `char *f_1()`, um das folgende Problem zu lösen:\nGeben Sie \"Hello, Mass-McEval: massively scaled multilingual code evaluation\" zurück.", "ha": "Rubuta wani aikin C `char *f_1()` don warware matsalar mai zuwa:\nMayar da \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "hi": "एक C फ़ंक्शन `char *f_1()` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\"Hello, Mass-McEval: massively scaled multilingual code evaluation\" लौटाएं।", "hu": "Írj egy C függvényt `char *f_1()` a következő probléma megoldására:\nAdja vissza a \"Hello, Mass-McEval: massively scaled multilingual code evaluation\" szöveget", "es": "Escribe una función en C `char *f_1()` para resolver el siguiente problema:\nDevuelve: \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "arb": "اكتب دالة بلغة C `char *f_1()` لحل المشكلة التالية:\nإرجاع \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "sw": "Andika kazi ya C `char *f_1()` kutatua tatizo lifuatalo:\nRudisha \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "tr": "Bir C fonksiyonu `char *f_1()` yazın ve aşağıdaki problemi \nçözün:\n\"Hello, Mass-McEval: massively scaled multilingual code evaluation\" döndürün.", "vi": "Viết một hàm C `char *f_1()` để giải quyết vấn đề sau:\nTrả về \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "id": "Tulis fungsi C `char *f_1()` untuk menyelesaikan masalah berikut:\nKembalikan \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "ja": "Cの関数を書け `char *f_1()` を作成して、次の問題を解決してください:\n\"Hello, Mass-McEval: massively scaled multilingual code evaluation\" を返します", "ko": "C 함수를 작성하세요 `char *f_1()` 다음 문제를 해결하기 위해:\n\"Hello, Mass-McEval: massively scaled multilingual code evaluation\"을 반환하세요.", "ml": "C ഫംഗ്ഷൻ `char *f_1()` എഴുതുക താഴെക്കാണുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\n\"Hello, Mass-McEval: massively scaled multilingual code evaluation\" തിരിച്ചുകൊടുക്കുക", "fa": "یک تابع C به نام `char *f_1()` بنویسید تا مسئله زیر را حل کند:\n\"Hello, Mass-McEval: massively scaled multilingual code evaluation\" را برگرداند."}, "level": "easy", "test": "int main()\n{\n    assert(strcmp(f_1(), \"Hello, Mass-McEval: massively scaled multilingual code evaluation\") == 0);\n    return 0;\n}", "entry_point": "f_1", "signature": "char *f_1()", "docstring": {"en": "Return \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "sq": "Kthe \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "hy": "Վերադարձնել \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "bn": "রিটার্ন \"Hello, Mass-McEval: massively scaled multilingual code evaluation", "bg": "Върнете \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "zh": "返回 \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "fr": "Retourne \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "de": "Rückgabe \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "ha": "Komawa \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "hi": "रिटर्न \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "hu": "Visszatér \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "es": "Devuelve:\"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "arb": "إرجاع:\"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "sw": "Rudisha: \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "tr": "çözün: \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "vi": "Trả về: \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "id": "Mengembalikan \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "ja": "\"Hello, Mass-McEval: massively scaled multilingual code evaluation\" を返します。", "ko": "\"Hello, Mass-McEval: massively scaled multilingual code evaluation\"을 반환하세요.", "ml": "\"Hello, Mass-McEval: massively scaled multilingual code evaluation\" തിരിച്ചുകൊടുക്കുക", "fa": "بازگرداندن \"Hello, Mass-McEval: massively scaled multilingual code evaluation\""}}
{"task_id": "C/2", "prompt": {"en": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCalculate the area of a triangle given its three sides.\n​    Parameters:\n- a (float): Length of side 'a'.\n- b (float): Length of side 'b'.\n- c (float): Length of side 'c'.\n​    Returns:\n- str: If the provided sides form a triangle, return the calculated area with 2 decimal places.\nOtherwise, return \"-1\"\n    >>> f_2(3,5,4)\n    6\n*/\ndouble f_2(double a, double b, double c)", "sq": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nLlogarit sipërfaqen e një trekëndëshi duke pasur parasysh tre anët e tij.\n​    Parametrat:\n- a (float): Gjatësia e anës 'a'.\n- b (float): Gjatësia e anës 'b'.\n- c (float): Gjatësia e anës 'c'.\n​    Kthen:\n- str: Nëse anët e dhëna formojnë një trekëndësh, kthen sipërfaqen e llogaritur me 2 shifra dhjetore.\nPërndryshe, kthe \"-1\"\n    >>> f_2(3,5,4)\n    6\n*/\ndouble f_2(double a, double b, double c)", "hy": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nՀաշվել եռանկյան մակերեսը՝ տրված նրա երեք կողմերը:\n​    Պարամետրեր:\n- a (float): 'a' կողմի երկարությունը:\n- b (float): 'b' կողմի երկարությունը:\n- c (float): 'c' կողմի երկարությունը:\n​    Վերադարձնում է:\n- str: Եթե տրված կողմերը կազմում են եռանկյուն, վերադարձնում է հաշվարկված մակերեսը՝ 2 տասնորդական թվանշաններով:\nՀակառակ դեպքում վերադարձնում է \"-1\"\n    >>> f_2(3,5,4)\n    6\n*/\ndouble f_2(double a, double b, double c)", "bn": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nএকটি ত্রিভুজের তিনটি বাহু দেওয়া থাকলে তার ক্ষেত্রফল গণনা করুন।\n    প্যারামিটার:\n- a (float): বাহু 'a' এর দৈর্ঘ্য।\n- b (float): বাহু 'b' এর দৈর্ঘ্য।\n- c (float): বাহু 'c' এর দৈর্ঘ্য।\n    রিটার্নস:\n- str: যদি প্রদত্ত বাহুগুলি একটি ত্রিভুজ গঠন করে, তবে 2 দশমিক স্থান সহ গণনা করা ক্ষেত্রফল রিটার্ন করুন।\nঅন্যথায়, \"-1\" রিটার্ন করুন\n    >>> f_2(3,5,4)\n    6\n*/\ndouble f_2(double a, double b, double c)", "bg": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nИзчислете лицето на триъгълник, дадени неговите три страни.\n​    Параметри:\n- a (float): Дължина на страна 'a'.\n- b (float): Дължина на страна 'b'.\n- c (float): Дължина на страна 'c'.\n​    Връща:\n- str: Ако предоставените страни образуват триъгълник, връща изчисленото лице с 2 знака след десетичната точка.\nВ противен случай връща \"-1\"\n    >>> f_2(3,5,4)\n    6\n*/\ndouble f_2(double a, double b, double c)", "zh": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n计算给定三边的三角形面积。\n​    参数:\n- a (float): 边 'a' 的长度。\n- b (float): 边 'b' 的长度。\n- c (float): 边 'c' 的长度。\n​    返回:\n- str: 如果提供的边能构成三角形，返回计算出的面积，保留两位小数。\n否则，返回 \"-1\"\n    >>> f_2(3,5,4)\n    6\n*/\ndouble f_2(double a, double b, double c)", "fr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCalculez l'aire d'un triangle donné ses trois côtés.\n    Paramètres :\n- a (float) : Longueur du côté 'a'.\n- b (float) : Longueur du côté 'b'.\n- c (float) : Longueur du côté 'c'.\n    Renvoie :\n- str : Si les côtés fournis forment un triangle, renvoie l'aire calculée avec 2 décimales.\nSinon, renvoie \"-1\"\n    >>> f_2(3,5,4)\n    6\n*/\ndouble f_2(double a, double b, double c)", "de": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nBerechnet die Fläche eines Dreiecks anhand seiner drei Seiten.\n    Parameter:\n- a (float): Länge der Seite 'a'.\n- b (float): Länge der Seite 'b'.\n- c (float): Länge der Seite 'c'.\n    Rückgabe:\n- str: Wenn die angegebenen Seiten ein Dreieck bilden, geben Sie die berechnete Fläche mit 2 Dezimalstellen zurück.\nAndernfalls geben Sie \"-1\" zurück.\n    >>> f_2(3,5,4)\n    6\n*/\ndouble f_2(double a, double b, double c)", "ha": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nƘididdige yanki na alwatika idan aka ba da gefensa uku.\n​    Sigogi:\n- a (float): Tsawon gefen 'a'.\n- b (float): Tsawon gefen 'b'.\n- c (float): Tsawon gefen 'c'.\n​    Mayarwa:\n- str: Idan gefen da aka bayar sun samar da alwatika, mayar da yankin da aka ƙididdige tare da wurare guda 2 bayan alamar kashi.\nIn ba haka ba, mayar da \"-1\"\n    >>> f_2(3,5,4)\n    6\n*/\ndouble f_2(double a, double b, double c)", "hi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nतीन भुजाओं के दिए गए लंबाई के आधार पर त्रिभुज का क्षेत्रफल गणना करें।\n    पैरामीटर्स:\n- a (float): भुजा 'a' की लंबाई।\n- b (float): भुजा 'b' की लंबाई।\n- c (float): भुजा 'c' की लंबाई।\n    रिटर्न्स:\n- str: यदि दी गई भुजाएँ एक त्रिभुज बनाती हैं, तो 2 दशमलव स्थानों के साथ गणना किया गया क्षेत्रफल लौटाएं।\nअन्यथा, \"-1\" लौटाएं\n    >>> f_2(3,5,4)\n    6\n*/\ndouble f_2(double a, double b, double c)", "hu": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nSzámítsa ki egy háromszög területét a három oldalának ismeretében.\n​    Paraméterek:\n- a (float): Az 'a' oldal hossza.\n- b (float): A 'b' oldal hossza.\n- c (float): A 'c' oldal hossza.\n​    Visszatér:\n- str: Ha a megadott oldalak háromszöget alkotnak, térjen vissza a kiszámított területtel 2 tizedesjegyre kerekítve.\nEgyébként térjen vissza \"-1\"-gyel.\n    >>> f_2(3,5,4)\n    6\n*/\ndouble f_2(double a, double b, double c)", "es": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCalcular el área de un triángulo dados sus tres lados.\n    Parámetros:\n- a (float): Longitud del lado 'a'.\n- b (float): Longitud del lado 'b'.\n- c (float): Longitud del lado 'c'.\n    Devuelve:\n- str: Si los lados proporcionados forman un triángulo, devuelve el área calculada con 2 decimales.\nDe lo contrario, devuelve \"-1\"\n    >>> f_2(3,5,4)\n    6\n*/\ndouble f_2(double a, double b, double c)", "arb": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nاحسب مساحة المثلث المعطى أطوال أضلاعه الثلاثة.\n    المعلمات:\n- a (float): طول الضلع 'a'.\n- b (float): طول الضلع 'b'.\n- c (float): طول الضلع 'c'.\n    يعيد:\n- str: إذا كانت الأضلاع المقدمة تشكل مثلثًا، يتم إرجاع المساحة المحسوبة بدقتين عشريتين.\nخلاف ذلك، يتم إرجاع \"-1\"\n    >>> f_2(3,5,4)\n    6\n*/\ndouble f_2(double a, double b, double c)", "sw": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nHesabu eneo la pembetatu ukizingatia pande zake tatu.\n​    Vigezo:\n- a (float): Urefu wa upande 'a'.\n- b (float): Urefu wa upande 'b'.\n- c (float): Urefu wa upande 'c'.\n​    Inarudisha:\n- str: Ikiwa pande zilizotolewa zinaunda pembetatu, rudisha eneo lililohesabiwa na sehemu 2 za desimali.\nVinginevyo, rudisha \"-1\"\n    >>> f_2(3,5,4)\n    6\n*/\ndouble f_2(double a, double b, double c)", "tr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nÜç kenarı verilen bir üçgenin alanını hesaplayın.\n​    Parametreler:\n- a (float): 'a' kenarının uzunluğu.\n- b (float): 'b' kenarının uzunluğu.\n- c (float): 'c' kenarının uzunluğu.\n​    Döndürür:\n- str: Sağlanan kenarlar bir üçgen oluşturuyorsa, hesaplanan alanı 2 ondalık basamakla döndürün.\nAksi takdirde, \"-1\" döndürün.\n    >>> f_2(3,5,4)\n    6\n*/\ndouble f_2(double a, double b, double c)", "vi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nTính diện tích của một tam giác khi biết ba cạnh của nó.\n​    Tham số:\n- a (float): Độ dài cạnh 'a'.\n- b (float): Độ dài cạnh 'b'.\n- c (float): Độ dài cạnh 'c'.\n​    Trả về:\n- str: Nếu các cạnh đã cho tạo thành một tam giác, trả về diện tích đã tính với 2 chữ số thập phân.\nNếu không, trả về \"-1\"\n    >>> f_2(3,5,4)\n    6\n*/\ndouble f_2(double a, double b, double c)", "id": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nMenghitung luas segitiga yang diberikan tiga sisinya.\n​    Parameter:\n- a (float): Panjang sisi 'a'.\n- b (float): Panjang sisi 'b'.\n- c (float): Panjang sisi 'c'.\n​    Mengembalikan:\n- str: Jika sisi yang diberikan membentuk segitiga, kembalikan luas yang dihitung dengan 2 tempat desimal.\nJika tidak, kembalikan \"-1\"\n    >>> f_2(3,5,4)\n    6\n*/\ndouble f_2(double a, double b, double c)", "ja": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n三角形の3辺が与えられたときの面積を計算します。\n​    パラメータ:\n- a (float): 辺 'a' の長さ。\n- b (float): 辺 'b' の長さ。\n- c (float): 辺 'c' の長さ。\n​    戻り値:\n- str: 提供された辺が三角形を形成する場合、計算された面積を小数点以下2桁で返します。\nそうでない場合は \"-1\" を返します。\n    >>> f_2(3,5,4)\n    6\n*/\ndouble f_2(double a, double b, double c)", "ko": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n주어진 세 변을 통해 삼각형의 면적을 계산합니다.\n​    매개변수:\n- a (float): 변 'a'의 길이.\n- b (float): 변 'b'의 길이.\n- c (float): 변 'c'의 길이.\n​    반환값:\n- str: 제공된 변들이 삼각형을 형성하면, 소수점 두 자리까지 계산된 면적을 반환합니다.\n그렇지 않으면, \"-1\"을 반환합니다.\n    >>> f_2(3,5,4)\n    6\n*/\ndouble f_2(double a, double b, double c)", "ml": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nഒരു ത്രികോണത്തിന്റെ മൂന്ന് വശങ്ങൾ നൽകിയാൽ അതിന്റെ വിസ്തീർണ്ണം കണക്കാക്കുക.\n    പാരാമീറ്ററുകൾ:\n- a (float): 'a' വശത്തിന്റെ നീളം.\n- b (float): 'b' വശത്തിന്റെ നീളം.\n- c (float): 'c' വശത്തിന്റെ നീളം.\n    മടക്കുക:\n- str: നൽകിയ വശങ്ങൾ ഒരു ത്രികോണം രൂപീകരിക്കുന്നുവെങ്കിൽ, 2 ദശാംശ സ്ഥാനങ്ങളോടെ കണക്കാക്കിയ വിസ്തീർണ്ണം മടക്കുക.\nഅല്ലെങ്കിൽ, \"-1\" മടക്കുക\n    >>> f_2(3,5,4)\n    6\n*/\ndouble f_2(double a, double b, double c)", "fa": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nمحاسبه مساحت یک مثلث با توجه به سه ضلع آن.\n    پارامترها:\n- a (float): طول ضلع 'a'.\n- b (float): طول ضلع 'b'.\n- c (float): طول ضلع 'c'.\n    بازگشت:\n- str: اگر اضلاع داده شده یک مثلث تشکیل دهند، مساحت محاسبه شده با 2 رقم اعشار برگردانده می‌شود.\nدر غیر این صورت، \"-1\" برگردانده می‌شود.\n    >>> f_2(3,5,4)\n    6\n*/\ndouble f_2(double a, double b, double c)"}, "canonical_solution": "{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        // printf(\"Not a triangle.\\n\");\n        return -1; // Use a special value to indicate not a triangle\n    }\n}", "instruction": {"en": "Write a C function `double f_2(double a, double b, double c)` to solve the following problem:\nCalculate the area of a triangle given its three sides.\n    Parameters:\n- a (float): Length of side 'a'.\n- b (float): Length of side 'b'.\n- c (float): Length of side 'c'.\n    Returns:\n- str: If the provided sides form a triangle, return the calculated area with 2 decimal places.\nOtherwise, return \"-1\"\n    >>> f_2(3,5,4)\n    6\n", "sq": "Shkruani një funksion në C `double f_2(double a, double b, double c)` për të zgjidhur problemin e mëposhtëm:\nLlogaritni sipërfaqen e një trekëndëshi duke pasur parasysh tre anët e tij.\n    Parametrat:\n- a (float): Gjatësia e anës 'a'.\n- b (float): Gjatësia e anës 'b'.\n- c (float): Gjatësia e anës 'c'.\n    Kthen:\n- str: Nëse anët e dhëna formojnë një trekëndësh, kthen sipërfaqen e llogaritur me 2 shifra dhjetore.\nPërndryshe, kthen \"-1\"\n    >>> f_2(3,5,4)\n    6", "hy": "Գրեք C ֆունկցիա `double f_2(double a, double b, double c)` հետևյալ խնդիրը լուծելու համար:\nՀաշվեք եռանկյան մակերեսը՝ հաշվի առնելով նրա երեք կողմերը:\n    Պարամետրեր:\n- a (float): 'a' կողմի երկարությունը:\n- b (float): 'b' կողմի երկարությունը:\n- c (float): 'c' կողմի երկարությունը:\n    Վերադարձնում է:\n- str: Եթե տրված կողմերը կազմում են եռանկյուն, վերադարձնում է հաշվարկված մակերեսը՝ 2 տասնորդական թվանշաններով:\nՀակառակ դեպքում վերադարձնում է \"-1\"\n    >>> f_2(3,5,4)\n    6", "bn": "একটি C ফাংশন `double f_2(double a, double b, double c)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএর তিনটি বাহু দেওয়া হলে একটি ত্রিভুজের ক্ষেত্রফল গণনা করুন।\n    প্যারামিটারসমূহ:\n- a (float): বাহু 'a' এর দৈর্ঘ্য।\n- b (float): বাহু 'b' এর দৈর্ঘ্য।\n- c (float): বাহু 'c' এর দৈর্ঘ্য।\n    রিটার্নস:\n- str: যদি প্রদত্ত বাহুগুলি একটি ত্রিভুজ গঠন করে, তবে 2 দশমিক স্থান সহ গণনা করা ক্ষেত্রফল রিটার্ন করুন।\nঅন্যথায়, \"-1\" রিটার্ন করুন\n    >>> f_2(3,5,4)\n    6", "bg": "Напишете C функция `double f_2(double a, double b, double c)`, за да решите следния проблем:\nИзчислете лицето на триъгълник, дадени неговите три страни.\n    Параметри:\n- a (float): Дължина на страна 'a'.\n- b (float): Дължина на страна 'b'.\n- c (float): Дължина на страна 'c'.\n    Връща:\n- str: Ако предоставените страни образуват триъгълник, върнете изчисленото лице с 2 знака след десетичната запетая.\nВ противен случай върнете \"-1\"\n    >>> f_2(3,5,4)\n    6", "zh": "编写一个 C 函数 `double f_2(double a, double b, double c)` 来解决以下问题：\n计算给定三边的三角形面积。\n    参数：\n- a (float): 边 'a' 的长度。\n- b (float): 边 'b' 的长度。\n- c (float): 边 'c' 的长度。\n    返回：\n- str: 如果提供的边能构成一个三角形，返回计算出的面积，保留两位小数。\n否则，返回 \"-1\"\n    >>> f_2(3,5,4)\n    6", "fr": "Écrire une fonction C `double f_2(double a, double b, double c)` pour résoudre le problème suivant:\nCalculer l'aire d'un triangle donné par ses trois côtés.\n    Paramètres :\n- a (float) : Longueur du côté 'a'.\n- b (float) : Longueur du côté 'b'.\n- c (float) : Longueur du côté 'c'.\n    Renvoie :\n- str : Si les côtés fournis forment un triangle, renvoie l'aire calculée avec 2 décimales.\nSinon, renvoie \"-1\"", "de": "Schreiben Sie eine C-Funktion `double f_2(double a, double b, double c)`, um das folgende Problem zu lösen:\nBerechnen Sie die Fläche eines Dreiecks, gegeben durch seine drei Seiten.\n    Parameter:\n- a (float): Länge der Seite 'a'.\n- b (float): Länge der Seite 'b'.\n- c (float): Länge der Seite 'c'.\n    Rückgabe:\n- str: Wenn die angegebenen Seiten ein Dreieck bilden, geben Sie die berechnete Fläche mit 2 Dezimalstellen zurück.\nAndernfalls geben Sie \"-1\" zurück.\n    >>> f_2(3,5,4)\n    6", "ha": "Rubuta aikin C `double f_2(double a, double b, double c)` don warware matsalar mai zuwa:\nƘididdige yankin wani alwatika idan aka ba da gefen sa uku.\n    Sigogi:\n- a (float): Tsawon gefen 'a'.\n- b (float): Tsawon gefen 'b'.\n- c (float): Tsawon gefen 'c'.\n    Komawa:\n- str: Idan gefen da aka bayar sun samar da alwatika, dawo da yankin da aka ƙididdige tare da wurare 2 na adadi mai lamba.\nIn ba haka ba, dawo da \"-1\"\n    >>> f_2(3,5,4)\n    6", "hi": "C फ़ंक्शन `double f_2(double a, double b, double c)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nइसके तीन भुजाओं के दिए गए लंबाई के आधार पर त्रिभुज का क्षेत्रफल ज्ञात करें।\n    पैरामीटर्स:\n- a (float): भुजा 'a' की लंबाई।\n- b (float): भुजा 'b' की लंबाई।\n- c (float): भुजा 'c' की लंबाई।\n    रिटर्न्स:\n- str: यदि दी गई भुजाएँ एक त्रिभुज बनाती हैं, तो 2 दशमलव स्थानों के साथ गणना किया गया क्षेत्रफल लौटाएँ।\nअन्यथा, \"-1\" लौटाएँ\n    >>> f_2(3,5,4)\n    6", "hu": "Írj egy C függvényt `double f_2(double a, double b, double c)` a következő probléma megoldására:\nSzámítsd ki egy háromszög területét a három oldalának ismeretében.\n    Paraméterek:\n- a (float): Az 'a' oldal hossza.\n- b (float): A 'b' oldal hossza.\n- c (float): A 'c' oldal hossza.\n    Visszatérési érték:\n- str: Ha a megadott oldalak háromszöget alkotnak, térj vissza a kiszámított területtel 2 tizedesjegy pontossággal.\nEgyébként térj vissza \"-1\"\n    >>> f_2(3,5,4)\n    6", "es": "Escribe una función en C `double f_2(double a, double b, double c)` para resolver el siguiente problema:\nCalcular el área de un triángulo dados sus tres lados.\n    Parámetros:\n- a (float): Longitud del lado 'a'.\n- b (float): Longitud del lado 'b'.\n- c (float): Longitud del lado 'c'.\n    Devuelve:\n- str: Si los lados proporcionados forman un triángulo, devuelve el área calculada con 2 decimales.\nDe lo contrario, devuelve \"-1\"\n    >>> f_2(3,5,4)\n    6", "arb": "اكتب دالة بلغة C `double f_2(double a, double b, double c)` لحل المشكلة التالية:\nاحسب مساحة مثلث معطى أطوال أضلاعه الثلاثة.\n    المعلمات:\n- a (float): طول الضلع 'a'.\n- b (float): طول الضلع 'b'.\n- c (float): طول الضلع 'c'.\n    يعيد:\n- str: إذا كانت الأضلاع المقدمة تشكل مثلثًا، أعد المساحة المحسوبة بدقتين عشريتين.\nخلاف ذلك، أعد \"-1\"\n    >>> f_2(3,5,4)\n    6", "sw": "Andika kazi ya C `double f_2(double a, double b, double c)` kutatua tatizo lifuatalo:\nHesabu eneo la pembetatu ukizingatia pande zake tatu.\n    Vigezo:\n- a (float): Urefu wa upande 'a'.\n- b (float): Urefu wa upande 'b'.\n- c (float): Urefu wa upande 'c'.\n    Inarejesha:\n- str: Ikiwa pande zilizotolewa zinaunda pembetatu, rejesha eneo lililohesabiwa na sehemu 2 za desimali.\nVinginevyo, rejesha \"-1\"\n    >>> f_2(3,5,4)\n    6\n", "tr": "Bir C fonksiyonu `double f_2(double a, double b, double c)` yazın ve aşağıdaki problemi çözün:\nÜç kenarı verilen bir üçgenin alanını hesaplayın.\n    Parametreler:\n- a (float): 'a' kenarının uzunluğu.\n- b (float): 'b' kenarının uzunluğu.\n- c (float): 'c' kenarının uzunluğu.\n    Döndürür:\n- str: Eğer verilen kenarlar bir üçgen oluşturuyorsa, hesaplanan alanı 2 ondalık basamakla döndürün.\nAksi takdirde, \"-1\" döndürün.\n    >>> f_2(3,5,4)\n    6", "vi": "Viết một hàm C `double f_2(double a, double b, double c)` để giải quyết vấn đề sau:\nTính diện tích của một tam giác khi biết ba cạnh của nó.\n    Tham số:\n- a (float): Chiều dài cạnh 'a'.\n- b (float): Chiều dài cạnh 'b'.\n- c (float): Chiều dài cạnh 'c'.\n    Trả về:\n- str: Nếu các cạnh được cung cấp tạo thành một tam giác, trả về diện tích đã tính với 2 chữ số thập phân.\nNgược lại, trả về \"-1\"\n    >>> f_2(3,5,4)\n    6", "id": "Tulis fungsi C `double f_2(double a, double b, double c)` untuk menyelesaikan masalah berikut:\nHitung luas segitiga yang diberikan tiga sisinya.\n    Parameter:\n- a (float): Panjang sisi 'a'.\n- b (float): Panjang sisi 'b'.\n- c (float): Panjang sisi 'c'.\n    Mengembalikan:\n- str: Jika sisi yang diberikan membentuk segitiga, kembalikan luas yang dihitung dengan 2 tempat desimal.\nJika tidak, kembalikan \"-1\"\n    >>> f_2(3,5,4)\n    6\n", "ja": "Cの関数を書け `double f_2(double a, double b, double c)` を作成して、次の問題を解決してください:\n3辺が与えられた三角形の面積を計算します。\n    パラメータ:\n- a (float): 辺 'a' の長さ。\n- b (float): 辺 'b' の長さ。\n- c (float): 辺 'c' の長さ。\n    戻り値:\n- str: 提供された辺が三角形を形成する場合、計算された面積を小数点以下2桁で返します。\nそうでない場合は、\"-1\" を返します。\n    >>> f_2(3,5,4)\n    6", "ko": "C 함수 `double f_2(double a, double b, double c)`를 작성하여 다음 문제를 해결하십시오:\n세 변이 주어졌을 때 삼각형의 면적을 계산하십시오.\n    매개변수:\n- a (float): 변 'a'의 길이.\n- b (float): 변 'b'의 길이.\n- c (float): 변 'c'의 길이.\n    반환값:\n- str: 제공된 변이 삼각형을 형성하면, 소수점 두 자리로 계산된 면적을 반환합니다.\n그렇지 않으면 \"-1\"을 반환합니다.\n    >>> f_2(3,5,4)\n    6", "ml": "C ഫംഗ്ഷൻ `double f_2(double a, double b, double c)` എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nത്രീ സൈഡുകൾ നൽകിയിരിക്കുന്ന ഒരു ത്രികോണത്തിന്റെ വിസ്തീർണ്ണം കണക്കാക്കുക.\n    പാരാമീറ്ററുകൾ:\n- a (float): 'a' എന്ന വശത്തിന്റെ നീളം.\n- b (float): 'b' എന്ന വശത്തിന്റെ നീളം.\n- c (float): 'c' എന്ന വശത്തിന്റെ നീളം.\n    റിട്ടേൺസ്:\n- str: നൽകിയ വശങ്ങൾ ഒരു ത്രികോണം രൂപീകരിക്കുന്നുവെങ്കിൽ, കണക്കാക്കിയ വിസ്തീർണ്ണം 2 ദശാംശസ്ഥാനം സഹിതം മടക്കിക്കൊടുക്കുക.\nഇല്ലെങ്കിൽ, \"-1\" മടക്കിക്കൊടുക്കുക\n    >>> f_2(3,5,4)\n    6", "fa": "یک تابع C `double f_2(double a, double b, double c)` بنویسید تا مسئله زیر را حل کند:\nمساحت یک مثلث را با توجه به سه ضلع آن محاسبه کنید.\n    پارامترها:\n- a (float): طول ضلع 'a'.\n- b (float): طول ضلع 'b'.\n- c (float): طول ضلع 'c'.\n    بازگشت:\n- str: اگر اضلاع داده شده یک مثلث تشکیل دهند، مساحت محاسبه شده را با 2 رقم اعشار برگردانید.\nدر غیر این صورت، \"-1\" را برگردانید.\n    >>> f_2(3,5,4)\n    6"}, "level": "easy", "test": "int main()\n{\n    double area;\n\n    // Triangle with sides 3, 5, 4 should return area 6\n    area = f_2(3, 5, 4);\n    assert(fabs(area - 6) < 1e-6);\n\n    // Not a triangle with sides 1, 1, 4 should print \"Not a triangle.\"\n    area = f_2(1, 1, 4);\n    assert(area == -1);\n\n    // Triangle with sides 7, 24, 25 should return area 84\n    area = f_2(7, 24, 25);\n    assert(fabs(area - 84) < 1e-6);\n\n    // Triangle with sides 10.5, 6.2, 7.3 should return a correct area\n    area = f_2(10.5, 6.2, 7.3);\n    // printf(\"%lf\\n\", area); // Print the area with 2 decimal places\n    // For precision issues, we test if the calculated area is close enough to the expected value\n    assert(fabs(area - 22.15) < 1e-2);\n\n    \n    return 0;\n}", "entry_point": "f_2", "signature": "double f_2(double a, double b, double c)", "docstring": {"en": "Calculate the area of a triangle given its three sides.\n    Parameters:\n- a (float): Length of side 'a'.\n- b (float): Length of side 'b'.\n- c (float): Length of side 'c'.\n    Returns:\n- str: If the provided sides form a triangle, return the calculated area with 2 decimal places.\nOtherwise, return \"-1\"\n    >>> f_2(3,5,4)\n    6\n", "sq": "Llogarit sipërfaqen e një trekëndëshi duke pasur parasysh tre anët e tij.\n    Parametrat:\n- a (float): Gjatësia e anës 'a'.\n- b (float): Gjatësia e anës 'b'.\n- c (float): Gjatësia e anës 'c'.\n    Kthen:\n- str: Nëse anët e dhëna formojnë një trekëndësh, kthen sipërfaqen e llogaritur me 2 vende dhjetore.\nPërndryshe, kthen \"-1\"\n    >>> f_2(3,5,4)\n    6", "hy": "Եռանկյան մակերեսը հաշվարկել, եթե տրված են նրա երեք կողմերը:\n    Պարամետրեր:\n- a (float): 'a' կողմի երկարությունը:\n- b (float): 'b' կողմի երկարությունը:\n- c (float): 'c' կողմի երկարությունը:\n    Վերադարձնում է:\n- str: Եթե տրված կողմերը կազմում են եռանկյուն, վերադարձնում է հաշվարկված մակերեսը 2 տասնորդական թվանշաններով:\nՀակառակ դեպքում, վերադարձնում է \"-1\"\n    >>> f_2(3,5,4)\n    6", "bn": "ত্রিভুজের তিনটি বাহুর দৈর্ঘ্য দেওয়া থাকলে তার ক্ষেত্রফল গণনা করুন।\n    প্যারামিটারসমূহ:\n- a (float): বাহু 'a' এর দৈর্ঘ্য।\n- b (float): বাহু 'b' এর দৈর্ঘ্য।\n- c (float): বাহু 'c' এর দৈর্ঘ্য।\n    রিটার্নস:\n- str: যদি প্রদত্ত বাহুগুলি একটি ত্রিভুজ গঠন করে, তবে ২ দশমিক স্থান সহ গণনা করা ক্ষেত্রফল ফেরত দিন।\nঅন্যথায়, \"-1\" ফেরত দিন\n    >>> f_2(3,5,4)\n    6", "bg": "Изчисляване на лицето на триъгълник, дадени неговите три страни.\n    Параметри:\n- a (float): Дължина на страна 'a'.\n- b (float): Дължина на страна 'b'.\n- c (float): Дължина на страна 'c'.\n    Връща:\n- str: Ако предоставените страни образуват триъгълник, връща изчисленото лице с 2 знака след десетичната запетая.\nВ противен случай връща \"-1\"\n    >>> f_2(3,5,4)\n    6", "zh": "计算给定三边的三角形面积。\n    参数:\n- a (float): 边 'a' 的长度。\n- b (float): 边 'b' 的长度。\n- c (float): 边 'c' 的长度。\n    返回:\n- str: 如果提供的边能构成一个三角形，返回计算出的面积，保留两位小数。\n否则，返回 \"-1\"\n    >>> f_2(3,5,4)\n    6", "fr": "Calculer l'aire d'un triangle donné par ses trois côtés.\n    Paramètres:\n- a (float): Longueur du côté 'a'.\n- b (float): Longueur du côté 'b'.\n- c (float): Longueur du côté 'c'.\n    Renvoie:\n- str: Si les côtés fournis forment un triangle, renvoie l'aire calculée avec 2 décimales.\nSinon, renvoie \"-1\"\n    >>> f_2(3,5,4)\n    6", "de": "Berechnen Sie die Fläche eines Dreiecks anhand seiner drei Seiten.\n    Parameter:\n- a (float): Länge der Seite 'a'.\n- b (float): Länge der Seite 'b'.\n- c (float): Länge der Seite 'c'.\n    Rückgabewerte:\n- str: Wenn die angegebenen Seiten ein Dreieck bilden, geben Sie die berechnete Fläche mit 2 Dezimalstellen zurück.\nAndernfalls geben Sie \"-1\" zurück.\n    >>> f_2(3,5,4)\n    6", "ha": "Ƙididdige yanki na alwatika idan aka ba da gefensa uku.\n    Parameters:\n- a (float): Tsawon gefen 'a'.\n- b (float): Tsawon gefen 'b'.\n- c (float): Tsawon gefen 'c'.\n    Returns:\n- str: Idan gefen da aka bayar sun samar da alwatika, dawo da yankin da aka lissafa tare da wurare biyu na goma.\nIn ba haka ba, dawo da \"-1\"\n    >>> f_2(3,5,4)\n    6", "hi": "त्रिभुज के तीन भुजाओं के आधार पर क्षेत्रफल की गणना करें।\n    पैरामीटर्स:\n- a (float): भुजा 'a' की लंबाई।\n- b (float): भुजा 'b' की लंबाई।\n- c (float): भुजा 'c' की लंबाई।\n    रिटर्न:\n- str: यदि दी गई भुजाएँ एक त्रिभुज बनाती हैं, तो 2 दशमलव स्थानों के साथ गणना किया गया क्षेत्रफल लौटाएँ।\nअन्यथा, \"-1\" लौटाएँ\n    >>> f_2(3,5,4)\n    6", "hu": "Számítsa ki egy háromszög területét a három oldalának megadásával.\n    Paraméterek:\n- a (float): Az 'a' oldal hossza.\n- b (float): A 'b' oldal hossza.\n- c (float): A 'c' oldal hossza.\n    Visszatérési érték:\n- str: Ha a megadott oldalak háromszöget alkotnak, adja vissza a kiszámított területet 2 tizedesjegy pontossággal.\nEllenkező esetben adja vissza \"-1\"\n    >>> f_2(3,5,4)\n    6", "es": "Calcular el área de un triángulo dado sus tres lados.\n    Parámetros:\n- a (float): Longitud del lado 'a'.\n- b (float): Longitud del lado 'b'.\n- c (float): Longitud del lado 'c'.\n    Devuelve:\n- str: Si los lados proporcionados forman un triángulo, devuelve el área calculada con 2 decimales.\nDe lo contrario, devuelve \"-1\"\n    >>> f_2(3,5,4)\n    6", "arb": "حساب مساحة المثلث المعطى أضلاعه الثلاثة.\n    المعلمات:\n- a (float): طول الضلع 'a'.\n- b (float): طول الضلع 'b'.\n- c (float): طول الضلع 'c'.\n    يعيد:\n- str: إذا كانت الأضلاع المقدمة تشكل مثلثًا، يتم إرجاع المساحة المحسوبة مع منزلتين عشريتين.\nوإلا، يتم إرجاع \"-1\"\n    >>> f_2(3,5,4)\n    6", "sw": "Hesabu eneo la pembetatu ukizingatia pande zake tatu.\n    Parameters:\n- a (float): Urefu wa upande 'a'.\n- b (float): Urefu wa upande 'b'.\n- c (float): Urefu wa upande 'c'.\n    Returns:\n- str: Ikiwa pande zilizotolewa zinaunda pembetatu, rudisha eneo lililokokotolewa na sehemu 2 za desimali.\nVinginevyo, rudisha \"-1\"\n    >>> f_2(3,5,4)\n    6", "tr": "Üç kenarı verilen bir üçgenin alanını hesaplayın.\n    Parametreler:\n- a (float): 'a' kenarının uzunluğu.\n- b (float): 'b' kenarının uzunluğu.\n- c (float): 'c' kenarının uzunluğu.\n    Döndürülen:\n- str: Sağlanan kenarlar bir üçgen oluşturuyorsa, hesaplanan alanı 2 ondalık basamakla döndürün.\nAksi takdirde, \"-1\" döndürün.\n    >>> f_2(3,5,4)\n    6", "vi": "Tính diện tích của một tam giác khi biết độ dài ba cạnh của nó.\n    Tham số:\n- a (float): Độ dài của cạnh 'a'.\n- b (float): Độ dài của cạnh 'b'.\n- c (float): Độ dài của cạnh 'c'.\n    Trả về:\n- str: Nếu các cạnh được cung cấp tạo thành một tam giác, trả về diện tích đã tính với 2 chữ số thập phân.\nNếu không, trả về \"-1\"\n    >>> f_2(3,5,4)\n    6", "id": "Hitung luas segitiga berdasarkan tiga sisinya.\n    Parameter:\n- a (float): Panjang sisi 'a'.\n- b (float): Panjang sisi 'b'.\n- c (float): Panjang sisi 'c'.\n    Mengembalikan:\n- str: Jika sisi yang diberikan membentuk segitiga, kembalikan luas yang dihitung dengan 2 tempat desimal.\nJika tidak, kembalikan \"-1\"\n    >>> f_2(3,5,4)\n    6", "ja": "三辺が与えられた三角形の面積を計算します。\n    引数:\n- a (float): 辺 'a' の長さ。\n- b (float): 辺 'b' の長さ。\n- c (float): 辺 'c' の長さ。\n    戻り値:\n- str: 提供された辺が三角形を形成する場合、計算された面積を小数点以下2桁で返します。\nそうでない場合は、\"-1\" を返します。\n    >>> f_2(3,5,4)\n    6", "ko": "삼각형의 세 변이 주어졌을 때 면적을 계산합니다.\n    매개변수:\n- a (float): 변 'a'의 길이.\n- b (float): 변 'b'의 길이.\n- c (float): 변 'c'의 길이.\n    반환값:\n- str: 제공된 변들이 삼각형을 형성하면, 소수점 둘째 자리까지 계산된 면적을 반환합니다.\n그렇지 않으면 \"-1\"을 반환합니다.\n    >>> f_2(3,5,4)\n    6", "ml": "ത്രികോണമിതിയുടെ മൂന്നു വശങ്ങളും നൽകിയാൽ ഒരു ത്രികോണത്തിന്റെ വിസ്തീർണ്ണം കണക്കാക്കുക.\n    പാരാമീറ്ററുകൾ:\n- a (float): 'a' വശത്തിന്റെ നീളം.\n- b (float): 'b' വശത്തിന്റെ നീളം.\n- c (float): 'c' വശത്തിന്റെ നീളം.\n    മടക്കങ്ങൾ:\n- str: നൽകിയ വശങ്ങൾ ഒരു ത്രികോണം രൂപീകരിക്കുന്നുവെങ്കിൽ, കണക്കാക്കിയ വിസ്തീർണ്ണം 2 ദശാംശസ്ഥാനം വരെ മടക്കുക. അല്ലെങ്കിൽ, \"-1\" മടക്കുക.\n    >>> f_2(3,5,4)\n    6", "fa": "محاسبه مساحت یک مثلث با توجه به سه ضلع آن.\n    پارامترها:\n- a (float): طول ضلع 'a'.\n- b (float): طول ضلع 'b'.\n- c (float): طول ضلع 'c'.\n    بازگشتی:\n- str: اگر اضلاع داده شده یک مثلث را تشکیل دهند، مساحت محاسبه شده با 2 رقم اعشار را برگردانید.\nدر غیر این صورت، \"-1\" را برگردانید.\n    >>> f_2(3,5,4)\n    6"}}
{"task_id": "C/3", "prompt": {"en": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCalculate the value of the function for a given input.\n    Parameters:\n- x (int): Input value for the function.\n    Returns:\n- double or string: If x is not in the defined domain, returns \"Not define\".\nOtherwise, returns the calculated function value rounded to 5 decimal places.\n\n    Function Definitions:\n- For 0 <= x < 10: y = cos(x + 3.0)\n- For 10 <= x < 20: y = (cos(x + 7.5))^2\n- For 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n\tNot define\n*/\nconst char* f_3(int x)", "sq": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nLlogarit vlerën e funksionit për një input të dhënë.\n    Parametrat:\n- x (int): Vlera e inputit për funksionin.\n    Kthen:\n- double ose string: Nëse x nuk është në domenin e përcaktuar, kthen \"Not define\".\nPërndryshe, kthen vlerën e llogaritur të funksionit të rrumbullakosur në 5 vende dhjetore.\n\n    Përkufizimet e Funksionit:\n- Për 0 <= x < 10: y = cos(x + 3.0)\n- Për 10 <= x < 20: y = (cos(x + 7.5))^2\n- Për 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n\tNot define\n*/\nconst char* f_3(int x)", "hy": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nՀաշվարկել ֆունկցիայի արժեքը տրված մուտքային արժեքի համար։\n    Պարամետրեր:\n- x (int): Ֆունկցիայի մուտքային արժեքը։\n    Վերադարձնում է:\n- double կամ string: Եթե x-ը սահմանված տիրույթում չէ, վերադարձնում է \"Not define\"։ \nՀակառակ դեպքում, վերադարձնում է հաշվարկված ֆունկցիայի արժեքը կլորացված մինչև 5 տասնորդական։\n\n    Ֆունկցիայի սահմանումներ:\n- 0 <= x < 10: y = cos(x + 3.0)\n- 10 <= x < 20: y = (cos(x + 7.5))^2\n- 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n\tNot define\n*/\nconst char* f_3(int x)", "bn": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nএকটি প্রদত্ত ইনপুটের জন্য ফাংশনের মান গণনা করুন।\n    প্যারামিটার:\n- x (int): ফাংশনের জন্য ইনপুট মান।\n    রিটার্নস:\n- double বা string: যদি x সংজ্ঞায়িত ডোমেইনে না থাকে, তাহলে \"Not define\" রিটার্ন করে।\nঅন্যথায়, গণনা করা ফাংশনের মান 5 দশমিক স্থান পর্যন্ত রাউন্ড করে রিটার্ন করে।\n\n    ফাংশন সংজ্ঞা:\n- 0 <= x < 10 এর জন্য: y = cos(x + 3.0)\n- 10 <= x < 20 এর জন্য: y = (cos(x + 7.5))^2\n- 20 <= x < 30 এর জন্য: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n\tNot define\n*/\nconst char* f_3(int x)", "bg": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nИзчислете стойността на функцията за даден вход.\n    Параметри:\n- x (int): Входна стойност за функцията.\n    Връща:\n- double или string: Ако x не е в дефинирания домейн, връща \"Not define\".\nВ противен случай, връща изчислената стойност на функцията, закръглена до 5 десетични знака.\n\n    Дефиниции на функцията:\n- За 0 <= x < 10: y = cos(x + 3.0)\n- За 10 <= x < 20: y = (cos(x + 7.5))^2\n- За 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n\tNot define\n*/\nconst char* f_3(int x)", "zh": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n计算给定输入的函数值。\n    参数:\n- x (int): 函数的输入值。\n    返回:\n- double 或 string: 如果 x 不在定义域内，返回 \"Not define\"。\n否则，返回计算的函数值，保留到小数点后5位。\n\n    函数定义:\n- 对于 0 <= x < 10: y = cos(x + 3.0)\n- 对于 10 <= x < 20: y = (cos(x + 7.5))^2\n- 对于 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n\tNot define\n*/\nconst char* f_3(int x)", "fr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCalcule la valeur de la fonction pour une entrée donnée.\n    Paramètres:\n- x (int): Valeur d'entrée pour la fonction.\n    Renvoie:\n- double ou chaîne: Si x n'est pas dans le domaine défini, renvoie \"Not define\".\nSinon, renvoie la valeur calculée de la fonction arrondie à 5 décimales.\n\n    Définitions de la fonction:\n- Pour 0 <= x < 10: y = cos(x + 3.0)\n- Pour 10 <= x < 20: y = (cos(x + 7.5))^2\n- Pour 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n\tNot define\n*/\nconst char* f_3(int x)", "de": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nBerechnet den Wert der Funktion für eine gegebene Eingabe.\n    Parameter:\n- x (int): Eingabewert für die Funktion.\n    Rückgabewerte:\n- double oder string: Wenn x nicht im definierten Bereich liegt, wird \"Not define\" zurückgegeben.\nAndernfalls wird der berechnete Funktionswert auf 5 Dezimalstellen gerundet zurückgegeben.\n\n    Funktionsdefinitionen:\n- Für 0 <= x < 10: y = cos(x + 3.0)\n- Für 10 <= x < 20: y = (cos(x + 7.5))^2\n- Für 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n\tNot define\n*/\nconst char* f_3(int x)", "ha": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nƘididdige ƙimar aikin don wani shigarwa da aka bayar.\n    Sigogi:\n- x (int): Ƙimar shigarwa don aikin.\n    Komawa:\n- double ko string: Idan x ba ya cikin yankin da aka ayyana, yana mayar da \"Not define\".\nIn ba haka ba, yana mayar da ƙimar aikin da aka ƙididdige wanda aka zagaye zuwa wurare 5 na goma.\n\n    Ma'anar Aiki:\n- Don 0 <= x < 10: y = cos(x + 3.0)\n- Don 10 <= x < 20: y = (cos(x + 7.5))^2\n- Don 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n\tNot define\n*/\nconst char* f_3(int x)", "hi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nदिए गए इनपुट के लिए फ़ंक्शन का मान गणना करें।\n    पैरामीटर्स:\n- x (int): फ़ंक्शन के लिए इनपुट मान।\n    रिटर्न्स:\n- double या string: यदि x परिभाषित डोमेन में नहीं है, तो \"Not define\" लौटाता है।\nअन्यथा, गणना किए गए फ़ंक्शन मान को 5 दशमलव स्थानों तक राउंड करके लौटाता है।\n\n    फ़ंक्शन परिभाषाएँ:\n- 0 <= x < 10 के लिए: y = cos(x + 3.0)\n- 10 <= x < 20 के लिए: y = (cos(x + 7.5))^2\n- 20 <= x < 30 के लिए: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n\tNot define\n*/\nconst char* f_3(int x)", "hu": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nSzámítsa ki a függvény értékét egy adott bemenetre.\n    Paraméterek:\n- x (int): A függvény bemeneti értéke.\n    Visszatérési érték:\n- double vagy string: Ha x nincs a meghatározott tartományban, \"Not define\" értéket ad vissza.\nEgyébként a kiszámított függvényértéket adja vissza 5 tizedesjegyre kerekítve.\n\n    Függvény definíciók:\n- Ha 0 <= x < 10: y = cos(x + 3.0)\n- Ha 10 <= x < 20: y = (cos(x + 7.5))^2\n- Ha 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n\tNot define\n*/\nconst char* f_3(int x)", "es": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCalcular el valor de la función para una entrada dada.\n    Parámetros:\n- x (int): Valor de entrada para la función.\n    Retorna:\n- double o string: Si x no está en el dominio definido, retorna \"Not define\".\nDe lo contrario, retorna el valor calculado de la función redondeado a 5 decimales.\n\n    Definiciones de la función:\n- Para 0 <= x < 10: y = cos(x + 3.0)\n- Para 10 <= x < 20: y = (cos(x + 7.5))^2\n- Para 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n\tNot define\n*/\nconst char* f_3(int x)", "arb": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nاحسب قيمة الدالة لمدخل معين.\n    المعاملات:\n- x (int): قيمة المدخل للدالة.\n    يعيد:\n- double أو string: إذا لم يكن x في النطاق المحدد، يعيد \"Not define\".\nوإلا، يعيد قيمة الدالة المحسوبة مقربة إلى 5 منازل عشرية.\n\n    تعريفات الدالة:\n- لـ 0 <= x < 10: y = cos(x + 3.0)\n- لـ 10 <= x < 20: y = (cos(x + 7.5))^2\n- لـ 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n\tNot define\n*/\nconst char* f_3(int x)", "sw": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nHesabu thamani ya kazi kwa ingizo lililopewa.\n    Vigezo:\n- x (int): Thamani ya ingizo kwa kazi.\n    Inarudisha:\n- double au string: Ikiwa x haiko kwenye kikoa kilichobainishwa, inarudisha \"Not define\".\nVinginevyo, inarudisha thamani ya kazi iliyohesabiwa iliyozungushwa hadi sehemu tano za desimali.\n\n    Ufafanuzi wa Kazi:\n- Kwa 0 <= x < 10: y = cos(x + 3.0)\n- Kwa 10 <= x < 20: y = (cos(x + 7.5))^2\n- Kwa 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n\tNot define\n*/\nconst char* f_3(int x)", "tr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nBelirtilen bir girdi için fonksiyonun değerini hesapla.\n    Parametreler:\n- x (int): Fonksiyon için giriş değeri.\n    Döndürür:\n- double veya string: x tanımlı alanda değilse, \"Not define\" döndürür.\nAksi takdirde, hesaplanan fonksiyon değerini 5 ondalık basamağa yuvarlanmış olarak döndürür.\n\n    Fonksiyon Tanımları:\n- 0 <= x < 10 için: y = cos(x + 3.0)\n- 10 <= x < 20 için: y = (cos(x + 7.5))^2\n- 20 <= x < 30 için: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n\tNot define\n*/\nconst char* f_3(int x)", "vi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nTính giá trị của hàm cho một đầu vào cho trước.\n    Tham số:\n- x (int): Giá trị đầu vào cho hàm.\n    Trả về:\n- double hoặc string: Nếu x không nằm trong miền xác định, trả về \"Not define\".\nNgược lại, trả về giá trị hàm đã tính được làm tròn đến 5 chữ số thập phân.\n\n    Định nghĩa hàm:\n- Với 0 <= x < 10: y = cos(x + 3.0)\n- Với 10 <= x < 20: y = (cos(x + 7.5))^2\n- Với 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n\tNot define\n*/\nconst char* f_3(int x)", "id": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nMenghitung nilai fungsi untuk input yang diberikan.\n    Parameter:\n- x (int): Nilai input untuk fungsi.\n    Mengembalikan:\n- double atau string: Jika x tidak dalam domain yang ditentukan, mengembalikan \"Not define\".\nJika tidak, mengembalikan nilai fungsi yang dihitung dibulatkan ke 5 tempat desimal.\n\n    Definisi Fungsi:\n- Untuk 0 <= x < 10: y = cos(x + 3.0)\n- Untuk 10 <= x < 20: y = (cos(x + 7.5))^2\n- Untuk 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n\tNot define\n*/\nconst char* f_3(int x)\n", "ja": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n与えられた入力に対して関数の値を計算します。\n    パラメータ:\n- x (int): 関数の入力値。\n    戻り値:\n- double または string: x が定義された領域にない場合は \"Not define\" を返します。\nそれ以外の場合、計算された関数の値を小数点以下5桁に丸めて返します。\n\n    関数定義:\n- 0 <= x < 10 の場合: y = cos(x + 3.0)\n- 10 <= x < 20 の場合: y = (cos(x + 7.5))^2\n- 20 <= x < 30 の場合: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n\tNot define\n*/\nconst char* f_3(int x)", "ko": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n주어진 입력에 대한 함수의 값을 계산합니다.\n    매개변수:\n- x (int): 함수의 입력 값.\n    반환:\n- double 또는 string: x가 정의된 도메인에 없으면 \"Not define\"을 반환합니다.\n그렇지 않으면 계산된 함수 값을 소수점 5자리로 반올림하여 반환합니다.\n\n    함수 정의:\n- 0 <= x < 10: y = cos(x + 3.0)\n- 10 <= x < 20: y = (cos(x + 7.5))^2\n- 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n\tNot define\n*/\nconst char* f_3(int x)", "ml": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nഒരു നൽകിയ ഇൻപുട്ടിനായി ഫംഗ്ഷന്റെ മൂല്യം കണക്കാക്കുക.\n    പാരാമീറ്ററുകൾ:\n- x (int): ഫംഗ്ഷനുള്ള ഇൻപുട്ട് മൂല്യം.\n    തിരികെ നൽകുന്നത്:\n- double അല്ലെങ്കിൽ string: x നിർവ്വചിച്ചിരിക്കുന്ന ഡൊമെയ്‌നിൽ ഇല്ലെങ്കിൽ, \"Not define\" തിരികെ നൽകുന്നു.\nഇതിനാൽ, കണക്കാക്കിയ ഫംഗ്ഷൻ മൂല്യം 5 ഡെസിമൽ സ്ഥാനങ്ങളിൽ ചുറ്റികൊള്ളുന്നു.\n\n    ഫംഗ്ഷൻ നിർവ്വചനങ്ങൾ:\n- 0 <= x < 10: y = cos(x + 3.0)\n- 10 <= x < 20: y = (cos(x + 7.5))^2\n- 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n\tNot define\n*/\nconst char* f_3(int x)", "fa": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nمحاسبه مقدار تابع برای یک ورودی داده شده.\n    پارامترها:\n- x (int): مقدار ورودی برای تابع.\n    بازگشت:\n- double یا string: اگر x در دامنه تعریف شده نباشد، \"Not define\" را برمی‌گرداند.\nدر غیر این صورت، مقدار محاسبه شده تابع را با گرد کردن به 5 رقم اعشار برمی‌گرداند.\n\n    تعریف توابع:\n- برای 0 <= x < 10: y = cos(x + 3.0)\n- برای 10 <= x < 20: y = (cos(x + 7.5))^2\n- برای 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n\tNot define\n*/\nconst char* f_3(int x)"}, "canonical_solution": "{\n    static char output[50]; // Buffer to hold the output string.\n    \n    if (0 <= x && x < 10) {\n        sprintf(output, \"%.5lf\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return output;\n}", "instruction": {"en": "Write a C function `const char* f_3(int x)` to solve the following problem:\nCalculate the value of the function for a given input.\n    Parameters:\n- x (int): Input value for the function.\n    Returns:\n- double or string: If x is not in the defined domain, returns \"Not define\".\nOtherwise, returns the calculated function value rounded to 5 decimal places.\n\n    Function Definitions:\n- For 0 <= x < 10: y = cos(x + 3.0)\n- For 10 <= x < 20: y = (cos(x + 7.5))^2\n- For 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n    Not define\n", "sq": "Shkruani një funksion në C `const char* f_3(int x)` për të zgjidhur problemin në vijim:\nLlogaritni vlerën e funksionit për një hyrje të dhënë.\n    Parametrat:\n- x (int): Vlera e hyrjes për funksionin.\n    Kthen:\n- double ose string: Nëse x nuk është në domenin e përcaktuar, kthen \"Not define\".\nPërndryshe, kthen vlerën e llogaritur të funksionit të rrumbullakosur në 5 vende dhjetore.\n\n    Përkufizimet e Funksionit:\n- Për 0 <= x < 10: y = cos(x + 3.0)\n- Për 10 <= x < 20: y = (cos(x + 7.5))^2\n- Për 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n    Not define", "hy": "Գրեք C ֆունկցիա `const char* f_3(int x)`՝ հետևյալ խնդիրը լուծելու համար:\nՀաշվեք ֆունկցիայի արժեքը տրված մուտքային արժեքի համար։\n    Պարամետրեր:\n- x (int): Մուտքային արժեք ֆունկցիայի համար։\n    Վերադարձնում է:\n- double կամ string: Եթե x-ը սահմանված տիրույթում չէ, վերադարձնում է \"Not define\"։\nՀակառակ դեպքում, վերադարձնում է հաշվարկված ֆունկցիայի արժեքը կլորացված մինչև 5 տասնորդական նշան։\n\n    Ֆունկցիայի սահմանումներ:\n- 0 <= x < 10: y = cos(x + 3.0)\n- 10 <= x < 20: y = (cos(x + 7.5))^2\n- 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n    Not define", "bn": "একটি C ফাংশন `const char* f_3(int x)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি প্রদত্ত ইনপুটের জন্য ফাংশনের মান গণনা করুন।\n    প্যারামিটার:\n- x (int): ফাংশনের জন্য ইনপুট মান।\n    রিটার্নস:\n- double বা string: যদি x সংজ্ঞায়িত ডোমেইনে না থাকে, তাহলে \"Not define\" রিটার্ন করে।\nঅন্যথায়, গণনা করা ফাংশনের মান 5 দশমিক স্থানে রাউন্ড করে রিটার্ন করে।\n\n    ফাংশন সংজ্ঞা:\n- 0 <= x < 10: y = cos(x + 3.0)\n- 10 <= x < 20: y = (cos(x + 7.5))^2\n- 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n    Not define", "bg": "Напишете C функция `const char* f_3(int x)`, за да решите следния проблем:\nИзчислете стойността на функцията за даден вход.\n    Параметри:\n- x (int): Входна стойност за функцията.\n    Връща:\n- double или низ: Ако x не е в определения домейн, връща \"Not define\".\nВ противен случай връща изчислената стойност на функцията, закръглена до 5 знака след десетичната запетая.\n\n    Дефиниции на функцията:\n- За 0 <= x < 10: y = cos(x + 3.0)\n- За 10 <= x < 20: y = (cos(x + 7.5))^2\n- За 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n    Not define", "zh": "编写一个 C 函数 `const char* f_3(int x)` 来解决以下问题：\n计算给定输入的函数值。\n参数：\n- x (int): 函数的输入值。\n返回：\n- double 或 string: 如果 x 不在定义域内，返回 \"Not define\"。\n否则，返回计算后的函数值，四舍五入到小数点后 5 位。\n\n函数定义：\n- 对于 0 <= x < 10: y = cos(x + 3.0)\n- 对于 10 <= x < 20: y = (cos(x + 7.5))^2\n- 对于 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n    Not define", "fr": "Écrire une fonction C `const char* f_3(int x)` pour résoudre le problème suivant :\nCalculer la valeur de la fonction pour une entrée donnée.\n    Paramètres :\n- x (int) : Valeur d'entrée pour la fonction.\n    Renvoie :\n- double ou chaîne de caractères : Si x n'est pas dans le domaine défini, renvoie \"Not define\".\nSinon, renvoie la valeur calculée de la fonction arrondie à 5 décimales.\n\n    Définitions de la fonction :\n- Pour 0 <= x < 10 : y = cos(x + 3.0)\n- Pour 10 <= x < 20 : y = (cos(x + 7.5))^2\n- Pour 20 <= x < 30 : y = (cos(x + 4.0))^4\n    >>> f_3(40)\n    Not define", "de": "Schreiben Sie eine C-Funktion `const char* f_3(int x)`, um das folgende Problem zu lösen:\nBerechnen Sie den Wert der Funktion für eine gegebene Eingabe.\n    Parameter:\n- x (int): Eingabewert für die Funktion.\n    Rückgabe:\n- double oder string: Wenn x nicht im definierten Bereich liegt, wird \"Not define\" zurückgegeben.\nAndernfalls wird der berechnete Funktionswert auf 5 Dezimalstellen gerundet zurückgegeben.\n\n    Funktionsdefinitionen:\n- Für 0 <= x < 10: y = cos(x + 3.0)\n- Für 10 <= x < 20: y = (cos(x + 7.5))^2\n- Für 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n    Not define", "ha": "Rubuta wani aikin C `const char* f_3(int x)` don warware matsalar mai zuwa:\nƘididdige ƙimar aikin don wani shigarwa da aka bayar.\n    Sigogi:\n- x (int): Ƙimar shigarwa don aikin.\n    Mayarwa:\n- double ko string: Idan x ba ya cikin yankin da aka ayyana, yana mayar da \"Not define\".\nIn ba haka ba, yana mayar da ƙimar aikin da aka ƙididdige tare da zagaye zuwa wurare 5 na decimal.\n\n    Ma'anar Aiki:\n- Don 0 <= x < 10: y = cos(x + 3.0)\n- Don 10 <= x < 20: y = (cos(x + 7.5))^2\n- Don 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n    Not define", "hi": "C फ़ंक्शन `const char* f_3(int x)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए इनपुट के लिए फ़ंक्शन का मान गणना करें।\n    पैरामीटर्स:\n- x (int): फ़ंक्शन के लिए इनपुट मान।\n    रिटर्न्स:\n- double या string: यदि x परिभाषित डोमेन में नहीं है, तो \"Not define\" लौटाता है।\nअन्यथा, गणना किए गए फ़ंक्शन मान को 5 दशमलव स्थानों तक राउंड करके लौटाता है।\n\n    फ़ंक्शन परिभाषाएँ:\n- 0 <= x < 10 के लिए: y = cos(x + 3.0)\n- 10 <= x < 20 के लिए: y = (cos(x + 7.5))^2\n- 20 <= x < 30 के लिए: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n    Not define", "hu": "Írj egy C függvényt `const char* f_3(int x)` a következő probléma megoldására:\nSzámítsd ki a függvény értékét egy adott bemenetre.\n    Paraméterek:\n- x (int): A függvény bemeneti értéke.\n    Visszatérési érték:\n- double vagy string: Ha x nincs a meghatározott tartományban, \"Not define\" értéket ad vissza.\nEgyébként visszaadja a kiszámított függvényértéket 5 tizedesjegyre kerekítve.\n\n    Függvény definíciók:\n- Ha 0 <= x < 10: y = cos(x + 3.0)\n- Ha 10 <= x < 20: y = (cos(x + 7.5))^2\n- Ha 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n    Not define", "es": "Escribe una función en C `const char* f_3(int x)` para resolver el siguiente problema:\nCalcula el valor de la función para una entrada dada.\n    Parámetros:\n- x (int): Valor de entrada para la función.\n    Retorna:\n- double o string: Si x no está en el dominio definido, devuelve \"Not define\".\nDe lo contrario, devuelve el valor calculado de la función redondeado a 5 decimales.\n\n    Definiciones de la función:\n- Para 0 <= x < 10: y = cos(x + 3.0)\n- Para 10 <= x < 20: y = (cos(x + 7.5))^2\n- Para 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n    Not define", "arb": "اكتب دالة بلغة C `const char* f_3(int x)` لحل المشكلة التالية:\nاحسب قيمة الدالة لقيمة مدخلة معينة.\n    المعاملات:\n- x (int): قيمة المدخل للدالة.\n    يعيد:\n- double أو string: إذا لم يكن x في النطاق المحدد، يعيد \"Not define\".\nبخلاف ذلك، يعيد قيمة الدالة المحسوبة مقربة إلى 5 منازل عشرية.\n\n    تعريفات الدالة:\n- لـ 0 <= x < 10: y = cos(x + 3.0)\n- لـ 10 <= x < 20: y = (cos(x + 7.5))^2\n- لـ 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n    Not define", "sw": "Andika kazi ya C `const char* f_3(int x)` kutatua tatizo lifuatalo:\nHesabu thamani ya kazi kwa pembejeo iliyotolewa.\n    Vigezo:\n- x (int): Thamani ya pembejeo kwa kazi.\n    Inarejesha:\n- double au string: Ikiwa x haiko kwenye kikoa kilichobainishwa, inarejesha \"Not define\".\nVinginevyo, inarejesha thamani ya kazi iliyohesabiwa iliyozungushwa hadi sehemu tano za desimali.\n\n    Ufafanuzi wa Kazi:\n- Kwa 0 <= x < 10: y = cos(x + 3.0)\n- Kwa 10 <= x < 20: y = (cos(x + 7.5))^2\n- Kwa 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n    Not define", "tr": "Bir C fonksiyonu `const char* f_3(int x)` yazın ve aşağıdaki problemi çözün:\nVerilen bir girdi için fonksiyonun değerini hesaplayın.\n    \nParametreler:\n- x (int): Fonksiyon için giriş değeri.\n\nDöndürülenler:\n- double veya string: Eğer x tanımlı alanda değilse, \"Not define\" döner.\nAksi takdirde, hesaplanan fonksiyon değerini 5 ondalık basamağa yuvarlanmış olarak döner.\n\nFonksiyon Tanımları:\n- 0 <= x < 10 için: y = cos(x + 3.0)\n- 10 <= x < 20 için: y = (cos(x + 7.5))^2\n- 20 <= x < 30 için: y = (cos(x + 4.0))^4\n\n    >>> f_3(40)\n    Not define", "vi": "Viết một hàm C `const char* f_3(int x)` để giải quyết vấn đề sau:\nTính giá trị của hàm cho một đầu vào cho trước.\n    Tham số:\n- x (int): Giá trị đầu vào cho hàm.\n    Trả về:\n- double hoặc chuỗi: Nếu x không nằm trong miền xác định, trả về \"Not define\".\nNgược lại, trả về giá trị hàm đã tính được làm tròn đến 5 chữ số thập phân.\n\n    Định nghĩa hàm:\n- Với 0 <= x < 10: y = cos(x + 3.0)\n- Với 10 <= x < 20: y = (cos(x + 7.5))^2\n- Với 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n    Not define", "id": "Tulis fungsi C `const char* f_3(int x)` untuk menyelesaikan masalah berikut:\nHitung nilai fungsi untuk input yang diberikan.\n    Parameter:\n- x (int): Nilai input untuk fungsi.\n    Mengembalikan:\n- double atau string: Jika x tidak dalam domain yang ditentukan, mengembalikan \"Not define\".\nJika tidak, mengembalikan nilai fungsi yang dihitung dibulatkan ke 5 tempat desimal.\n\n    Definisi Fungsi:\n- Untuk 0 <= x < 10: y = cos(x + 3.0)\n- Untuk 10 <= x < 20: y = (cos(x + 7.5))^2\n- Untuk 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n    Not define", "ja": "Cの関数を書け `const char* f_3(int x)` を作成して、次の問題を解決してください:\n与えられた入力に対して関数の値を計算します。\n    パラメータ:\n- x (int): 関数の入力値。\n    戻り値:\n- double または string: x が定義された領域にない場合、\"Not define\" を返します。\nそれ以外の場合、計算された関数の値を小数点以下5桁に丸めて返します。\n\n    関数定義:\n- 0 <= x < 10 の場合: y = cos(x + 3.0)\n- 10 <= x < 20 の場合: y = (cos(x + 7.5))^2\n- 20 <= x < 30 の場合: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n    Not define", "ko": "C 함수 `const char* f_3(int x)`를 작성하여 다음 문제를 해결하십시오:\n주어진 입력에 대한 함수의 값을 계산하십시오.\n    매개변수:\n- x (int): 함수에 대한 입력 값.\n    반환값:\n- double 또는 string: x가 정의된 도메인에 없으면 \"Not define\"을 반환합니다.\n그렇지 않으면 계산된 함수 값을 소수점 5자리로 반올림하여 반환합니다.\n\n    함수 정의:\n- 0 <= x < 10: y = cos(x + 3.0)\n- 10 <= x < 20: y = (cos(x + 7.5))^2\n- 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n    Not define", "ml": "ഒരു C ഫംഗ്ഷൻ `const char* f_3(int x)` എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nനൽകിയിരിക്കുന്ന ഇൻപുട്ടിനായി ഫംഗ്ഷന്റെ മൂല്യം കണക്കാക്കുക.\n    പാരാമീറ്ററുകൾ:\n- x (int): ഫംഗ്ഷനുള്ള ഇൻപുട്ട് മൂല്യം.\n    തിരികെ നൽകുന്നത്:\n- double അല്ലെങ്കിൽ string: x നിർവ്വചിച്ചിരിക്കുന്ന ഡൊമെയിനിൽ ഇല്ലെങ്കിൽ, \"Not define\" തിരികെ നൽകുന്നു.\nഅല്ലെങ്കിൽ, കണക്കാക്കിയ ഫംഗ്ഷൻ മൂല്യം 5 ദശാംശ സ്ഥാനങ്ങൾ വരെ വൃത്താകൃതിയിലുള്ളത് തിരികെ നൽകുന്നു.\n\n    ഫംഗ്ഷൻ നിർവ്വചനങ്ങൾ:\n- 0 <= x < 10: y = cos(x + 3.0)\n- 10 <= x < 20: y = (cos(x + 7.5))^2\n- 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n    Not define", "fa": "یک تابع C `const char* f_3(int x)` بنویسید تا مسئله زیر را حل کند:\nمحاسبه مقدار تابع برای یک ورودی داده شده.\n    پارامترها:\n- x (int): مقدار ورودی برای تابع.\n    بازگشتی‌ها:\n- double یا string: اگر x در دامنه تعریف شده نباشد، \"Not define\" را برمی‌گرداند.\nدر غیر این صورت، مقدار محاسبه شده تابع را که به 5 رقم اعشار گرد شده است، برمی‌گرداند.\n\n    تعریف توابع:\n- برای 0 <= x < 10: y = cos(x + 3.0)\n- برای 10 <= x < 20: y = (cos(x + 7.5))^2\n- برای 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n    Not define"}, "level": "middle", "test": "int main() {\n    const char* result = f_3(40);\n    assert(strcmp(result, \"Not define\") == 0);\n    \n    // Additional test cases based on provided function definitions\n    assert(strcmp(f_3(40), \"Not define\") == 0);\n    assert(strcmp(f_3(5), \"-0.14550\") == 0);\n    assert(strcmp(f_3(15), \"0.76266\") == 0);\n    assert(strcmp(f_3(25), \"0.31314\") == 0);\n    assert(strcmp(f_3(-1), \"Not define\") == 0);\n    return 0;\n}", "entry_point": "f_3", "signature": "const char* f_3(int x)", "docstring": {"en": "Calculate the value of the function for a given input.\n    Parameters:\n- x (int): Input value for the function.\n    Returns:\n- double or string: If x is not in the defined domain, returns \"Not define\".\nOtherwise, returns the calculated function value rounded to 5 decimal places.\n\n    Function Definitions:\n- For 0 <= x < 10: y = cos(x + 3.0)\n- For 10 <= x < 20: y = (cos(x + 7.5))^2\n- For 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n    Not define\n", "sq": "Llogarit vlerën e funksionit për një hyrje të dhënë.\n    Parametra:\n- x (int): Vlera e hyrjes për funksionin.\n    Kthen:\n- double ose string: Nëse x nuk është në domenin e përcaktuar, kthen \"Jo e përcaktuar\".\nPërndryshe, kthen vlerën e llogaritur të funksionit të rrumbullakosur në 5 shifra dhjetore.\n\n    Përkufizimet e Funksionit:\n- Për 0 <= x < 10: y = cos(x + 3.0)\n- Për 10 <= x < 20: y = (cos(x + 7.5))^2\n- Për 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n    Jo e përcaktuar", "hy": "Հաշվել ֆունկցիայի արժեքը տրված մուտքային արժեքի համար։\n    Պարամետրեր:\n- x (int): Մուտքային արժեք ֆունկցիայի համար։\n    Վերադարձնում է:\n- double կամ string: Եթե x-ը սահմանված տիրույթում չէ, վերադարձնում է \"Not define\"։ Հակառակ դեպքում, վերադարձնում է հաշվարկված ֆունկցիայի արժեքը կլորացված մինչև 5 տասնորդական թվանշան։\n\n    Ֆունկցիայի սահմանումներ:\n- 0 <= x < 10: y = cos(x + 3.0)\n- 10 <= x < 20: y = (cos(x + 7.5))^2\n- 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n    Not define", "bn": "প্রদত্ত ইনপুটের জন্য ফাংশনের মান গণনা করুন।\n    প্যারামিটারসমূহ:\n- x (int): ফাংশনের জন্য ইনপুট মান।\n    রিটার্নসমূহ:\n- double বা string: যদি x সংজ্ঞায়িত ডোমেইনে না থাকে, তাহলে \"Not define\" রিটার্ন করে।\nঅন্যথায়, গণনা করা ফাংশনের মান 5 দশমিক স্থান পর্যন্ত রাউন্ড করে রিটার্ন করে।\n\n    ফাংশনের সংজ্ঞা:\n- 0 <= x < 10 এর জন্য: y = cos(x + 3.0)\n- 10 <= x < 20 এর জন্য: y = (cos(x + 7.5))^2\n- 20 <= x < 30 এর জন্য: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n    Not define", "bg": "Изчислява стойността на функцията за даден вход.\n    Параметри:\n- x (int): Входна стойност за функцията.\n    Връща:\n- double или string: Ако x не е в определения домейн, връща \"Not define\".\nВ противен случай, връща изчислената стойност на функцията, закръглена до 5 знака след десетичната запетая.\n\n    Определения на функцията:\n- За 0 <= x < 10: y = cos(x + 3.0)\n- За 10 <= x < 20: y = (cos(x + 7.5))^2\n- За 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n    Not define", "zh": "计算给定输入的函数值。\n    参数：\n- x (int): 函数的输入值。\n    返回：\n- double 或 string: 如果 x 不在定义域内，返回 \"Not define\"。\n否则，返回计算后的函数值，保留到小数点后五位。\n\n    函数定义：\n- 对于 0 <= x < 10: y = cos(x + 3.0)\n- 对于 10 <= x < 20: y = (cos(x + 7.5))^2\n- 对于 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n    Not define", "fr": "Calculer la valeur de la fonction pour une entrée donnée.\n    Paramètres:\n- x (int): Valeur d'entrée pour la fonction.\n    Renvoie:\n- double ou string: Si x n'est pas dans le domaine défini, renvoie \"Not define\".\nSinon, renvoie la valeur calculée de la fonction arrondie à 5 décimales.\n\n    Définitions de la fonction:\n- Pour 0 <= x < 10: y = cos(x + 3.0)\n- Pour 10 <= x < 20: y = (cos(x + 7.5))^2\n- Pour 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n    Not define", "de": "Berechne den Wert der Funktion für eine gegebene Eingabe.\n    Parameter:\n- x (int): Eingabewert für die Funktion.\n    Rückgabewerte:\n- double oder string: Wenn x nicht im definierten Bereich liegt, wird \"Not define\" zurückgegeben.\nAndernfalls wird der berechnete Funktionswert auf 5 Dezimalstellen gerundet zurückgegeben.\n\n    Funktionsdefinitionen:\n- Für 0 <= x < 10: y = cos(x + 3.0)\n- Für 10 <= x < 20: y = (cos(x + 7.5))^2\n- Für 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n    Not define", "ha": "Ƙididdige ƙimar aikin don wani shigarwa da aka bayar.\n    Sigogi:\n- x (int): Darajar shigarwa don aikin.\n    Returns:\n- double ko string: Idan x ba ya cikin kewayon da aka ayyana, yana dawowa da \"Not define\".\nIn ba haka ba, yana dawowa da darajar aikin da aka lissafa an zagaye zuwa wurare 5 na decimal.\n\n    Function Definitions:\n- Don 0 <= x < 10: y = cos(x + 3.0)\n- Don 10 <= x < 20: y = (cos(x + 7.5))^2\n- Don 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n    Not define", "hi": "दिए गए इनपुट के लिए फ़ंक्शन का मान गणना करें।\n    पैरामीटर्स:\n- x (int): फ़ंक्शन के लिए इनपुट मान।\n    रिटर्न्स:\n- double या string: यदि x परिभाषित डोमेन में नहीं है, तो \"Not define\" लौटाता है।\nअन्यथा, गणना किए गए फ़ंक्शन मान को 5 दशमलव स्थानों तक राउंड करके लौटाता है।\n\n    फ़ंक्शन परिभाषाएँ:\n- 0 <= x < 10 के लिए: y = cos(x + 3.0)\n- 10 <= x < 20 के लिए: y = (cos(x + 7.5))^2\n- 20 <= x < 30 के लिए: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n    Not define", "hu": "Számítsa ki a függvény értékét egy adott bemenetre.\n    Paraméterek:\n- x (int): A függvény bemeneti értéke.\n    Visszatérési érték:\n- double vagy string: Ha x nincs a meghatározott tartományban, \"Not define\" értéket ad vissza.\nEgyébként visszaadja a kiszámított függvényértéket 5 tizedesjegyre kerekítve.\n\n    Függvénydefiníciók:\n- Ha 0 <= x < 10: y = cos(x + 3.0)\n- Ha 10 <= x < 20: y = (cos(x + 7.5))^2\n- Ha 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n    Not define", "es": "Calcular el valor de la función para una entrada dada.\n    Parámetros:\n- x (int): Valor de entrada para la función.\n    Devuelve:\n- double o string: Si x no está en el dominio definido, devuelve \"Not define\".\nDe lo contrario, devuelve el valor calculado de la función redondeado a 5 decimales.\n\n    Definiciones de la función:\n- Para 0 <= x < 10: y = cos(x + 3.0)\n- Para 10 <= x < 20: y = (cos(x + 7.5))^2\n- Para 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n    Not define", "arb": "احسب قيمة الدالة لمدخل معين.\n    المعلمات:\n- x (int): قيمة المدخل للدالة.\n    يعيد:\n- double أو string: إذا لم يكن x في النطاق المحدد، يعيد \"غير معرف\".\nخلاف ذلك، يعيد قيمة الدالة المحسوبة مقربة إلى 5 منازل عشرية.\n\n    تعريفات الدوال:\n- لـ 0 <= x < 10: y = cos(x + 3.0)\n- لـ 10 <= x < 20: y = (cos(x + 7.5))^2\n- لـ 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n    Not define", "sw": "Hesabu thamani ya kazi kwa pembejeo iliyotolewa.\n    Vigezo:\n- x (int): Thamani ya pembejeo kwa kazi.\n    Inarudisha:\n- double au string: Ikiwa x haiko katika kikoa kilichobainishwa, inarudisha \"Not define\".\nVinginevyo, inarudisha thamani ya kazi iliyohesabiwa iliyokatwa hadi sehemu 5 za desimali.\n\n    Ufafanuzi wa Kazi:\n- Kwa 0 <= x < 10: y = cos(x + 3.0)\n- Kwa 10 <= x < 20: y = (cos(x + 7.5))^2\n- Kwa 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n    Not define", "tr": "Belirtilen bir giriş için fonksiyonun değerini hesaplayın.\n    Parametreler:\n- x (int): Fonksiyon için giriş değeri.\n    Döndürür:\n- double veya string: Eğer x tanımlı alanda değilse, \"Tanımsız\" döndürür.\nAksi takdirde, hesaplanan fonksiyon değerini 5 ondalık basamağa yuvarlanmış olarak döndürür.\n\n    Fonksiyon Tanımları:\n- 0 <= x < 10 için: y = cos(x + 3.0)\n- 10 <= x < 20 için: y = (cos(x + 7.5))^2\n- 20 <= x < 30 için: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n    Tanımsız", "vi": "Tính giá trị của hàm cho một đầu vào nhất định.\n    Tham số:\n- x (int): Giá trị đầu vào cho hàm.\n    Trả về:\n- double hoặc string: Nếu x không nằm trong miền xác định, trả về \"Not define\".\nNgược lại, trả về giá trị hàm đã tính toán được làm tròn đến 5 chữ số thập phân.\n\n    Định nghĩa hàm:\n- Với 0 <= x < 10: y = cos(x + 3.0)\n- Với 10 <= x < 20: y = (cos(x + 7.5))^2\n- Với 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n    Not define", "id": "Hitung nilai fungsi untuk input yang diberikan.\n    Parameter:\n- x (int): Nilai input untuk fungsi.\n    Mengembalikan:\n- double atau string: Jika x tidak dalam domain yang ditentukan, mengembalikan \"Not define\".\nJika tidak, mengembalikan nilai fungsi yang dihitung dibulatkan hingga 5 tempat desimal.\n\n    Definisi Fungsi:\n- Untuk 0 <= x < 10: y = cos(x + 3.0)\n- Untuk 10 <= x < 20: y = (cos(x + 7.5))^2\n- Untuk 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n    Not define", "ja": "与えられた入力に対して関数の値を計算します。\n    パラメータ:\n- x (int): 関数の入力値。\n    戻り値:\n- double または string: x が定義された領域にない場合は \"Not define\" を返します。\nそれ以外の場合は、計算された関数の値を小数点以下5桁に丸めて返します。\n\n    関数定義:\n- 0 <= x < 10 の場合: y = cos(x + 3.0)\n- 10 <= x < 20 の場合: y = (cos(x + 7.5))^2\n- 20 <= x < 30 の場合: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n    Not define", "ko": "입력된 값에 대한 함수의 값을 계산합니다.\n    매개변수:\n- x (int): 함수의 입력 값.\n    반환값:\n- double 또는 string: x가 정의된 도메인에 없으면 \"Not define\"을 반환합니다.\n그렇지 않으면 계산된 함수 값을 소수점 5자리로 반올림하여 반환합니다.\n\n    함수 정의:\n- 0 <= x < 10: y = cos(x + 3.0)\n- 10 <= x < 20: y = (cos(x + 7.5))^2\n- 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n    Not define", "ml": "Calculate the value of the function for a given input.\n    പാരാമീറ്ററുകൾ:\n- x (int): ഫങ്ഷനിലേക്കുള്ള ഇൻപുട്ട് മൂല്യം.\n    മടക്കങ്ങൾ:\n- double അല്ലെങ്കിൽ string: x നിർവചിച്ചിരിക്കുന്ന ഡൊമെയിനിൽ ഇല്ലെങ്കിൽ, \"Not define\" മടക്കുന്നു.\nഅല്ലെങ്കിൽ, കണക്കാക്കിയ ഫങ്ഷൻ മൂല്യം 5 ദശാംശസ്ഥാനം വരെ വൃത്തിയാക്കുന്നു.\n\n    ഫങ്ഷൻ നിർവചനങ്ങൾ:\n- 0 <= x < 10: y = cos(x + 3.0)\n- 10 <= x < 20: y = (cos(x + 7.5))^2\n- 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n    Not define", "fa": "محاسبه مقدار تابع برای یک ورودی داده شده.\n    پارامترها:\n- x (int): مقدار ورودی برای تابع.\n    بازگشت:\n- double یا string: اگر x در دامنه تعریف شده نباشد، \"Not define\" را برمی‌گرداند.\nدر غیر این صورت، مقدار محاسبه شده تابع را که به 5 رقم اعشار گرد شده است برمی‌گرداند.\n\n    تعریف توابع:\n- برای 0 <= x < 10: y = cos(x + 3.0)\n- برای 10 <= x < 20: y = (cos(x + 7.5))^2\n- برای 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> f_3(40)\n    Not define"}}
{"task_id": "C/4", "prompt": {"en": "#include <assert.h>\n#include <stdio.h>\n/*\nFind the maximum and minimum of three distinct integers.\nParameters:\na (int): The first integer.\nb (int): The second integer.\nc (int): The third integer.\n\nReturns:\nTuple[int, int]: A tuple is not a concept in C; instead, we will return by reference.\n\n>>> Example call: \nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid f_4(int a, int b, int c, int *max, int *min)", "sq": "#include <assert.h>\n#include <stdio.h>\n/*\nGjej maksimumin dhe minimumin e tre numrave të plotë të ndryshëm.\nParametrat:\na (int): Numri i parë i plotë.\nb (int): Numri i dytë i plotë.\nc (int): Numri i tretë i plotë.\n\nKthen:\nTuple[int, int]: Një tuple nuk është një koncept në C; në vend të kësaj, ne do të kthejmë me referencë.\n\n>>> Thirrja e shembullit: \nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid f_4(int a, int b, int c, int *max, int *min)", "hy": "#include <assert.h>\n#include <stdio.h>\n/*\nԳտնել երեք տարբեր ամբողջ թվերի առավելագույնը և նվազագույնը:\nՊարամետրեր:\na (int): Առաջին ամբողջ թիվը:\nb (int): Երկրորդ ամբողջ թիվը:\nc (int): Երրորդ ամբողջ թիվը:\n\nՎերադարձնում է:\nTuple[int, int]: Tuple-ը C-ում հասկացություն չէ; փոխարենը մենք կվերադարձնենք հղումով:\n\n>>> Օրինակ զանգ:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid f_4(int a, int b, int c, int *max, int *min)", "bn": "#include <assert.h>\n#include <stdio.h>\n/*\nতিনটি পৃথক পূর্ণসংখ্যার মধ্যে সর্বাধিক এবং সর্বনিম্ন খুঁজুন।\nপ্যারামিটার:\na (int): প্রথম পূর্ণসংখ্যা।\nb (int): দ্বিতীয় পূর্ণসংখ্যা।\nc (int): তৃতীয় পূর্ণসংখ্যা।\n\nফেরত:\nTuple[int, int]: একটি টুপল C তে ধারণা নয়; পরিবর্তে, আমরা রেফারেন্স দ্বারা ফেরত দেব।\n\n>>> উদাহরণ কল:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid f_4(int a, int b, int c, int *max, int *min)", "bg": "#include <assert.h>\n#include <stdio.h>\n/*\nНамерете максимума и минимума на три различни цели числа.\nПараметри:\na (int): Първото цяло число.\nb (int): Второто цяло число.\nc (int): Третото цяло число.\n\nВръща:\nTuple[int, int]: Кортеж не е концепция в C; вместо това ще върнем чрез референция.\n\n>>> Примерно извикване: \nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid f_4(int a, int b, int c, int *max, int *min)", "zh": "#include <assert.h>\n#include <stdio.h>\n/*\n找到三个不同整数的最大值和最小值。\n参数：\na (int): 第一个整数。\nb (int): 第二个整数。\nc (int): 第三个整数。\n\n返回：\nTuple[int, int]: 在C语言中没有元组的概念，我们将通过引用返回。\n\n>>> 示例调用: \nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid f_4(int a, int b, int c, int *max, int *min)", "fr": "#include <assert.h>\n#include <stdio.h>\n/*\nTrouver le maximum et le minimum de trois entiers distincts.\nParamètres :\na (int) : Le premier entier.\nb (int) : Le deuxième entier.\nc (int) : Le troisième entier.\n\nRenvoie :\nTuple[int, int] : Un tuple n'est pas un concept en C ; à la place, nous allons retourner par référence.\n\n>>> Appel d'exemple : \nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid f_4(int a, int b, int c, int *max, int *min)", "de": "#include <assert.h>\n#include <stdio.h>\n/*\nFinde das Maximum und Minimum von drei verschiedenen ganzen Zahlen.\nParameter:\na (int): Die erste ganze Zahl.\nb (int): Die zweite ganze Zahl.\nc (int): Die dritte ganze Zahl.\n\nRückgabewert:\nTuple[int, int]: Ein Tupel ist kein Konzept in C; stattdessen werden wir durch Referenz zurückgeben.\n\n>>> Beispielaufruf: \nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid f_4(int a, int b, int c, int *max, int *min)", "ha": "#include <assert.h>\n#include <stdio.h>\n/*\nNemo mafi girma da mafi ƙanƙanta daga cikin lambobi guda uku daban-daban.\nSigogi:\na (int): Lamba ta farko.\nb (int): Lamba ta biyu.\nc (int): Lamba ta uku.\n\nKomawa:\nTuple[int, int]: Ba a da ma'anar tuple a cikin C; maimakon haka, za mu dawo ta hanyar tunani.\n\n>>> Misalin kira:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid f_4(int a, int b, int c, int *max, int *min)", "hi": "#include <assert.h>\n#include <stdio.h>\n/*\nतीन भिन्न पूर्णांकों में से अधिकतम और न्यूनतम खोजें।\nपैरामीटर्स:\na (int): पहला पूर्णांक।\nb (int): दूसरा पूर्णांक।\nc (int): तीसरा पूर्णांक।\n\nवापसी मान:\nTuple[int, int]: C में एक ट्यूपल की अवधारणा नहीं है; इसके बजाय, हम संदर्भ द्वारा लौटाएंगे।\n\n>>> उदाहरण कॉल:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid f_4(int a, int b, int c, int *max, int *min)", "hu": "#include <assert.h>\n#include <stdio.h>\n/*\nKeresse meg három különböző egész szám maximumát és minimumát.\nParaméterek:\na (int): Az első egész szám.\nb (int): A második egész szám.\nc (int): A harmadik egész szám.\n\nVisszatér:\nTuple[int, int]: A tuple nem egy fogalom a C-ben; ehelyett referencia alapján fogunk visszatérni.\n\n>>> Példa hívás: \nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid f_4(int a, int b, int c, int *max, int *min)", "es": "#include <assert.h>\n#include <stdio.h>\n/*\nEncontrar el máximo y mínimo de tres enteros distintos.\nParámetros:\na (int): El primer entero.\nb (int): El segundo entero.\nc (int): El tercer entero.\n\nDevuelve:\nTuple[int, int]: Una tupla no es un concepto en C; en su lugar, devolveremos por referencia.\n\n>>> Llamada de ejemplo: \nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid f_4(int a, int b, int c, int *max, int *min)", "arb": "#include <assert.h>\n#include <stdio.h>\n/*\nإيجاد القيمة العظمى والصغرى لثلاثة أعداد صحيحة متميزة.\nالمعلمات:\na (int): العدد الصحيح الأول.\nb (int): العدد الصحيح الثاني.\nc (int): العدد الصحيح الثالث.\n\nالقيم المعادة:\nTuple[int, int]: مفهوم tuple غير موجود في لغة C؛ بدلاً من ذلك، سنعيد القيم بواسطة المرجع.\n\n>>> مثال على الاستدعاء:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid f_4(int a, int b, int c, int *max, int *min)", "sw": "#include <assert.h>\n#include <stdio.h>\n/*\nPata kubwa na ndogo kati ya nambari tatu tofauti za mzima.\nVigezo:\na (int): Nambari ya kwanza ya mzima.\nb (int): Nambari ya pili ya mzima.\nc (int): Nambari ya tatu ya mzima.\n\nInarudisha:\nTuple[int, int]: Tuple si dhana katika C; badala yake, tutarudisha kwa marejeleo.\n\n>>> Mfano wa kupiga:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid f_4(int a, int b, int c, int *max, int *min)", "tr": "#include <assert.h>\n#include <stdio.h>\n/*\nÜç farklı tam sayının maksimum ve minimumunu bulun.\nParametreler:\na (int): Birinci tam sayı.\nb (int): İkinci tam sayı.\nc (int): Üçüncü tam sayı.\n\nDöndürülenler:\nTuple[int, int]: C'de bir tuple kavramı yoktur; bunun yerine referansla döneceğiz.\n\n>>> Örnek çağrı: \nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid f_4(int a, int b, int c, int *max, int *min)", "vi": "#include <assert.h>\n#include <stdio.h>\n/*\nTìm giá trị lớn nhất và nhỏ nhất của ba số nguyên khác nhau.\nTham số:\na (int): Số nguyên thứ nhất.\nb (int): Số nguyên thứ hai.\nc (int): Số nguyên thứ ba.\n\nTrả về:\nTuple[int, int]: Một tuple không phải là khái niệm trong C; thay vào đó, chúng ta sẽ trả về bằng tham chiếu.\n\n>>> Ví dụ gọi:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid f_4(int a, int b, int c, int *max, int *min)", "id": "#include <assert.h>\n#include <stdio.h>\n/*\nMenemukan nilai maksimum dan minimum dari tiga bilangan bulat yang berbeda.\nParameter:\na (int): Bilangan bulat pertama.\nb (int): Bilangan bulat kedua.\nc (int): Bilangan bulat ketiga.\n\nMengembalikan:\nTuple[int, int]: Tuple bukanlah konsep dalam C; sebagai gantinya, kita akan mengembalikan melalui referensi.\n\n>>> Contoh panggilan: \nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid f_4(int a, int b, int c, int *max, int *min)", "ja": "#include <assert.h>\n#include <stdio.h>\n/*\n3つの異なる整数の最大値と最小値を見つけます。\nパラメータ:\na (int): 最初の整数。\nb (int): 2番目の整数。\nc (int): 3番目の整数。\n\n戻り値:\nTuple[int, int]: Cではタプルは概念ではないため、参照によって返します。\n\n>>> 呼び出し例: \nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid f_4(int a, int b, int c, int *max, int *min)", "ko": "#include <assert.h>\n#include <stdio.h>\n/*\n세 개의 서로 다른 정수의 최대값과 최소값을 찾습니다.\n매개변수:\na (int): 첫 번째 정수.\nb (int): 두 번째 정수.\nc (int): 세 번째 정수.\n\n반환값:\nTuple[int, int]: 튜플은 C에서 개념이 아니므로, 대신 참조로 반환합니다.\n\n>>> 예시 호출: \nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid f_4(int a, int b, int c, int *max, int *min)", "ml": "#include <assert.h>\n#include <stdio.h>\n/*\nമൂന്ന് വ്യത്യസ്തമായ പൂർണ്ണസംഖ്യകളിൽ പരമാവധിയും കുറഞ്ഞതും കണ്ടെത്തുക.\nപാരാമീറ്ററുകൾ:\na (int): ആദ്യത്തെ പൂർണ്ണസംഖ്യ.\nb (int): രണ്ടാം പൂർണ്ണസംഖ്യ.\nc (int): മൂന്നാമത്തെ പൂർണ്ണസംഖ്യ.\n\nമടക്കുക:\nTuple[int, int]: C-യിൽ ട്യൂപ്പിൾ എന്ന ആശയം ഇല്ല; പകരം, നാം റഫറൻസിലൂടെ മടക്കും.\n\n>>> ഉദാഹരണ കോൾ:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid f_4(int a, int b, int c, int *max, int *min)", "fa": "#include <assert.h>\n#include <stdio.h>\n/*\nحداکثر و حداقل سه عدد صحیح متمایز را پیدا کنید.\nپارامترها:\na (int): عدد صحیح اول.\nb (int): عدد صحیح دوم.\nc (int): عدد صحیح سوم.\n\nبرمی‌گرداند:\nTuple[int, int]: تاپل یک مفهوم در C نیست؛ در عوض، ما با ارجاع برمی‌گردانیم.\n\n>>> مثال فراخوانی: \nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid f_4(int a, int b, int c, int *max, int *min)"}, "canonical_solution": "{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else {\n        if (b > c) {\n            *max = b;\n            *min = (a < c) ? a : c;\n        } else {\n            *max = c;\n            *min = a;\n        }\n    }\n}", "instruction": {"en": "Write a C function `void f_4(int a, int b, int c, int *max, int *min)` to solve the following problem:\nFind the maximum and minimum of three distinct integers.\nParameters:\na (int): The first integer.\nb (int): The second integer.\nc (int): The third integer.\n\nReturns:\nTuple[int, int]: A tuple is not a concept in C; instead, we will return by reference.\n\n>>> Example call: \nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "sq": "Shkruani një funksion në C `void f_4(int a, int b, int c, int *max, int *min)` për të zgjidhur problemin e mëposhtëm:\nGjeni maksimumin dhe minimumin e tre numrave të plotë të ndryshëm.\nParametrat:\na (int): Numri i parë i plotë.\nb (int): Numri i dytë i plotë.\nc (int): Numri i tretë i plotë.\n\nKthen:\nTuple[int, int]: Një tuple nuk është një koncept në C; në vend të kësaj, ne do të kthejmë me referencë.\n\n>>> Thirrje shembull:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "hy": "Գրեք C ֆունկցիա `void f_4(int a, int b, int c, int *max, int *min)` հետևյալ խնդիրը լուծելու համար:\nԳտնել երեք տարբեր ամբողջ թվերի առավելագույնը և նվազագույնը։\nՊարամետրեր:\na (int): Առաջին ամբողջ թիվը։\nb (int): Երկրորդ ամբողջ թիվը։\nc (int): Երրորդ ամբողջ թիվը։\n\nՎերադարձնում է:\nTuple[int, int]: Tuple-ը C-ում հասկացություն չէ; փոխարենը, մենք կվերադարձնենք հղումով։\n\n>>> Օրինակ կանչ:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "bn": "একটি C ফাংশন `void f_4(int a, int b, int c, int *max, int *min)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nতিনটি ভিন্ন পূর্ণসংখ্যার সর্বাধিক এবং সর্বনিম্ন খুঁজে বের করুন।\nপ্যারামিটারসমূহ:\na (int): প্রথম পূর্ণসংখ্যা।\nb (int): দ্বিতীয় পূর্ণসংখ্যা।\nc (int): তৃতীয় পূর্ণসংখ্যা।\n\nরিটার্ন করে:\nTuple[int, int]: একটি টিউপল C তে একটি ধারণা নয়; বরং আমরা রেফারেন্সের মাধ্যমে রিটার্ন করব।\n\n>>> উদাহরণ কল:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "bg": "Напишете C функция `void f_4(int a, int b, int c, int *max, int *min)`, за да решите следния проблем:\nНамерете максимума и минимума на три различни цели числа.\nПараметри:\na (int): Първото цяло число.\nb (int): Второто цяло число.\nc (int): Третото цяло число.\n\nВръща:\nTuple[int, int]: Кортеж не е концепция в C; вместо това ще върнем чрез препратка.\n\n>>> Примерно извикване: \nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "zh": "编写一个 C 函数 `void f_4(int a, int b, int c, int *max, int *min)` 来解决以下问题：\n找到三个不同整数中的最大值和最小值。\n参数：\na (int): 第一个整数。\nb (int): 第二个整数。\nc (int): 第三个整数。\n\n返回：\nTuple[int, int]: 元组在 C 中不是一个概念，我们将通过引用返回。\n\n>>> 示例调用：\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "fr": "Écrire une fonction C `void f_4(int a, int b, int c, int *max, int *min)` pour résoudre le problème suivant :\nTrouver le maximum et le minimum de trois entiers distincts.\nParamètres :\na (int) : Le premier entier.\nb (int) : Le deuxième entier.\nc (int) : Le troisième entier.\n\nRetourne :\nTuple[int, int] : Un tuple n'est pas un concept en C ; à la place, nous allons retourner par référence.\n\n>>> Exemple d'appel : \nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "de": "Schreiben Sie eine C-Funktion `void f_4(int a, int b, int c, int *max, int *min)`, um das folgende Problem zu lösen:\nFinden Sie das Maximum und Minimum von drei verschiedenen ganzen Zahlen.\nParameter:\na (int): Die erste ganze Zahl.\nb (int): Die zweite ganze Zahl.\nc (int): Die dritte ganze Zahl.\n\nRückgabe:\nTuple[int, int]: Ein Tupel ist kein Konzept in C; stattdessen werden wir per Referenz zurückgeben.\n\n>>> Beispielaufruf: \nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "ha": "Rubuta aikin C `void f_4(int a, int b, int c, int *max, int *min)` don warware matsalar mai zuwa:\nNemo mafi girma da mafi ƙanƙanta daga lambobi guda uku masu bambanci.\nSigogi:\na (int): Lamba ta farko.\nb (int): Lamba ta biyu.\nc (int): Lamba ta uku.\n\nDawowa:\nTuple[int, int]: Ba a amfani da ra'ayin tuple a cikin C; maimakon haka, za mu dawo ta hanyar tunani.\n\n>>> Misalin kira:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "hi": "C फ़ंक्शन `void f_4(int a, int b, int c, int *max, int *min)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nतीन भिन्न पूर्णांकों का अधिकतम और न्यूनतम मान खोजें।\nपैरामीटर्स:\na (int): पहला पूर्णांक।\nb (int): दूसरा पूर्णांक।\nc (int): तीसरा पूर्णांक।\n\nवापसी:\nTuple[int, int]: C में ट्यूपल एक अवधारणा नहीं है; इसके बजाय, हम संदर्भ द्वारा वापस करेंगे।\n\n>>> उदाहरण कॉल:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "hu": "Írj egy C függvényt `void f_4(int a, int b, int c, int *max, int *min)` a következő probléma megoldására:\nTaláld meg három különböző egész szám maximumát és minimumát.\nParaméterek:\na (int): Az első egész szám.\nb (int): A második egész szám.\nc (int): A harmadik egész szám.\n\nVisszatérési érték:\nTuple[int, int]: A tuple nem egy fogalom a C nyelvben; ehelyett referencia alapján térünk vissza.\n\n>>> Példa hívás:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "es": "Escribe una función en C `void f_4(int a, int b, int c, int *max, int *min)` para resolver el siguiente problema:\nEncuentra el máximo y el mínimo de tres enteros distintos.\nParámetros:\na (int): El primer entero.\nb (int): El segundo entero.\nc (int): El tercer entero.\n\nDevuelve:\nTuple[int, int]: Una tupla no es un concepto en C; en su lugar, devolveremos por referencia.\n\n>>> Llamada de ejemplo:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "arb": "اكتب دالة بلغة C `void f_4(int a, int b, int c, int *max, int *min)` لحل المشكلة التالية:\nإيجاد القيمة العظمى والصغرى لثلاثة أعداد صحيحة مختلفة.\nالمعطيات:\na (int): العدد الصحيح الأول.\nb (int): العدد الصحيح الثاني.\nc (int): العدد الصحيح الثالث.\n\nالقيم المعادة:\nTuple[int, int]: لا يوجد مفهوم الترتيب في C؛ بدلاً من ذلك، سنعيد القيم عن طريق المرجع.\n\n>>> مثال على الاستدعاء:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "sw": "Andika kazi ya C `void f_4(int a, int b, int c, int *max, int *min)` kutatua tatizo lifuatalo:\nPata kubwa na ndogo kati ya nambari tatu tofauti.\nVigezo:\na (int): Nambari ya kwanza.\nb (int): Nambari ya pili.\nc (int): Nambari ya tatu.\n\nInarudisha:\nTuple[int, int]: Tuple si dhana katika C; badala yake, tutarudisha kwa marejeleo.\n\n>>> Mfano wa kupiga simu:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "tr": "Bir C fonksiyonu `void f_4(int a, int b, int c, int *max, int *min)` yazın ve aşağıdaki problemi çözün:\nÜç farklı tamsayının maksimum ve minimumunu bulun.\nParametreler:\na (int): Birinci tamsayı.\nb (int): İkinci tamsayı.\nc (int): Üçüncü tamsayı.\n\nDöndürülenler:\nTuple[int, int]: C'de tuple bir kavram değildir; bunun yerine referansla döneceğiz.\n\n>>> Örnek çağrı: \nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "vi": "Viết một hàm C `void f_4(int a, int b, int c, int *max, int *min)` để giải quyết vấn đề sau:\nTìm giá trị lớn nhất và nhỏ nhất của ba số nguyên khác nhau.\nTham số:\na (int): Số nguyên thứ nhất.\nb (int): Số nguyên thứ hai.\nc (int): Số nguyên thứ ba.\n\nTrả về:\nTuple[int, int]: Một tuple không phải là khái niệm trong C; thay vào đó, chúng ta sẽ trả về bằng tham chiếu.\n\n>>> Ví dụ gọi:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "id": "Tulis fungsi C `void f_4(int a, int b, int c, int *max, int *min)` untuk menyelesaikan masalah berikut:\nTemukan nilai maksimum dan minimum dari tiga bilangan bulat yang berbeda.\nParameter:\na (int): Bilangan bulat pertama.\nb (int): Bilangan bulat kedua.\nc (int): Bilangan bulat ketiga.\n\nMengembalikan:\nTuple[int, int]: Tuple bukanlah konsep dalam C; sebagai gantinya, kita akan mengembalikan melalui referensi.\n\n>>> Contoh pemanggilan: \nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "ja": "Cの関数を書け `void f_4(int a, int b, int c, int *max, int *min)` を作成して、次の問題を解決してください:\n3つの異なる整数の最大値と最小値を見つけます。\nパラメータ:\na (int): 最初の整数。\nb (int): 2番目の整数。\nc (int): 3番目の整数。\n\n戻り値:\nTuple[int, int]: タプルはCの概念ではありません。代わりに参照によって返します。\n\n>>> 例の呼び出し:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "ko": "C 함수 `void f_4(int a, int b, int c, int *max, int *min)`을 작성하여 다음 문제를 해결하십시오:\n세 개의 서로 다른 정수의 최대값과 최소값을 찾으십시오.\n매개변수:\na (int): 첫 번째 정수.\nb (int): 두 번째 정수.\nc (int): 세 번째 정수.\n\n반환:\nTuple[int, int]: 튜플은 C에서 개념이 아닙니다; 대신 참조로 반환할 것입니다.\n\n>>> 예제 호출:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "ml": "C ഫംഗ്ഷൻ `void f_4(int a, int b, int c, int *max, int *min)` എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nമൂന്ന് വ്യത്യസ്തമായ പൂർണ്ണസംഖ്യകളുടെ പരമാവധി, പരമാവധി കുറഞ്ഞത് കണ്ടെത്തുക.\nപാരാമീറ്ററുകൾ:\na (int): ആദ്യത്തെ പൂർണ്ണസംഖ്യ.\nb (int): രണ്ടാം പൂർണ്ണസംഖ്യ.\nc (int): മൂന്നാം പൂർണ്ണസംഖ്യ.\n\nമടക്കുക:\nTuple[int, int]: C-യിൽ ട്യൂപ്പിൾ എന്ന ആശയം ഇല്ല; പകരം, നാം റഫറൻസിലൂടെ മടക്കും.\n\n>>> ഉദാഹരണ കോൾ:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "fa": "یک تابع C بنویسید `void f_4(int a, int b, int c, int *max, int *min)` برای حل مسئله زیر:\nبیشینه و کمینه سه عدد صحیح متمایز را پیدا کنید.\nپارامترها:\na (int): اولین عدد صحیح.\nb (int): دومین عدد صحیح.\nc (int): سومین عدد صحیح.\n\nبازگشت:\nTuple[int, int]: تاپل یک مفهوم در C نیست؛ در عوض، ما با ارجاع برمی‌گردیم.\n\n>>> مثال فراخوانی:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);"}, "level": "middle", "test": "int main() {\n    int max, min;\n\n    f_4(1, 2, 3, &max, &min);\n    assert(max == 3 && min == 1);\n\n    // Additional tests\n    f_4(5, 3, 4, &max, &min);\n    assert(max == 5 && min == 3);\n\n    f_4(10, -2, 7, &max, &min);\n    assert(max == 10 && min == -2);\n\n    f_4(-1, -3, -2, &max, &min);\n    assert(max == -1 && min == -3);\n\n    return 0;\n}", "entry_point": "f_4", "signature": "void f_4(int a, int b, int c, int *max, int *min)", "docstring": {"en": "Find the maximum and minimum of three distinct integers.\nParameters:\na (int): The first integer.\nb (int): The second integer.\nc (int): The third integer.\n\nReturns:\nTuple[int, int]: A tuple is not a concept in C; instead, we will return by reference.\n\n>>> Example call: \nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "sq": "Gjeni maksimumin dhe minimumin e tre numrave të plotë të ndryshëm.\nParametrat:\na (int): Numri i parë i plotë.\nb (int): Numri i dytë i plotë.\nc (int): Numri i tretë i plotë.\n\nKthen:\nTuple[int, int]: Një tuple nuk është një koncept në C; në vend të kësaj, ne do të kthejmë me referencë.\n\n>>> Shembull thirrje:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "hy": "Երեք տարբեր ամբողջ թվերի առավելագույնը և նվազագույնը գտնել:\nՊարամետրեր:\na (int): Առաջին ամբողջ թիվը:\nb (int): Երկրորդ ամբողջ թիվը:\nc (int): Երրորդ ամբողջ թիվը:\n\nՎերադարձնում է:\nTuple[int, int]: Tuple-ը հասկացություն չէ C-ում; փոխարենը մենք կվերադարձնենք հղումով:\n\n>>> Օրինակ կանչ:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "bn": "তিনটি পৃথক পূর্ণসংখ্যার মধ্যে সর্বাধিক এবং সর্বনিম্ন খুঁজুন।\nপ্যারামিটারসমূহ:  \na (int): প্রথম পূর্ণসংখ্যা।  \nb (int): দ্বিতীয় পূর্ণসংখ্যা।  \nc (int): তৃতীয় পূর্ণসংখ্যা।  \n\nরিটার্নস:  \nTuple[int, int]: একটি টিউপল C তে ধারণা নয়; পরিবর্তে, আমরা রেফারেন্স দ্বারা ফেরত দেব।  \n\n>>> উদাহরণ কল:  \nint max, min;  \nf_4(1,2,3, &max, &min);  \nassert(max == 3 && min == 1);  ", "bg": "Намерете максимума и минимума на три различни цели числа.\nПараметри:  \na (int): Първото цяло число.  \nb (int): Второто цяло число.  \nc (int): Третото цяло число.  \n\nВръща:  \nTuple[int, int]: Кортеж не е концепция в C; вместо това ще върнем чрез референция.\n\n>>> Примерно извикване:  \nint max, min;  \nf_4(1,2,3, &max, &min);  \nassert(max == 3 && min == 1);", "zh": "找出三个不同整数的最大值和最小值。\n参数：\na (int): 第一个整数。\nb (int): 第二个整数。\nc (int): 第三个整数。\n\n返回：\nTuple[int, int]: 元组在 C 中不是一个概念，因此我们将通过引用返回。\n\n>>> 示例调用：\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "fr": "Trouver le maximum et le minimum de trois entiers distincts.\nParamètres :\na (int) : Le premier entier.\nb (int) : Le deuxième entier.\nc (int) : Le troisième entier.\n\nRenvoie :\nTuple[int, int] : Un tuple n'est pas un concept en C ; à la place, nous renverrons par référence.\n\n>>> Appel d'exemple : \nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "de": "Finde das Maximum und Minimum von drei verschiedenen ganzen Zahlen.\nParameter:\na (int): Die erste ganze Zahl.\nb (int): Die zweite ganze Zahl.\nc (int): Die dritte ganze Zahl.\n\nRückgabewert:\nTuple[int, int]: Ein Tupel ist kein Konzept in C; stattdessen werden wir durch Referenz zurückgeben.\n\n>>> Beispielaufruf:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "ha": "Nemo mafi girma da mafi ƙanƙanta daga cikin lambobi guda uku daban-daban.\nSigogi:  \na (int): Na farko cikakken lamba.  \nb (int): Na biyu cikakken lamba.  \nc (int): Na uku cikakken lamba.  \n\nDawowa:  \nTuple[int, int]: Tuple ba wani abu bane a cikin C; maimakon haka, za mu dawo ta hanyar tunani.  \n\n>>> Misali kira:  \nint max, min;  \nf_4(1,2,3, &max, &min);  \nassert(max == 3 && min == 1);  ", "hi": "तीन भिन्न पूर्णांकों का अधिकतम और न्यूनतम मान खोजें।\nपैरामीटर्स:\na (int): पहला पूर्णांक।\nb (int): दूसरा पूर्णांक।\nc (int): तीसरा पूर्णांक।\n\nवापसी मान:\nTuple[int, int]: C में ट्यूपल की अवधारणा नहीं है; इसके बजाय, हम संदर्भ द्वारा लौटाएंगे।\n\n>>> उदाहरण कॉल:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "hu": "Három különböző egész szám maximumának és minimumának meghatározása.\nParaméterek:\na (int): Az első egész szám.\nb (int): A második egész szám.\nc (int): A harmadik egész szám.\n\nVisszatér:\nTuple[int, int]: A tuple nem egy fogalom a C-ben; ehelyett referencia alapján fogunk visszatérni.\n\n>>> Példa hívás:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "es": "Encuentra el máximo y el mínimo de tres enteros distintos.\nParámetros:\na (int): El primer entero.\nb (int): El segundo entero.\nc (int): El tercer entero.\n\nDevuelve:\nTuple[int, int]: Una tupla no es un concepto en C; en su lugar, devolveremos por referencia.\n\n>>> Llamada de ejemplo:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "arb": "إيجاد القيمة القصوى والدنيا لثلاثة أعداد صحيحة متميزة.\nالمعلمات:\na (int): العدد الصحيح الأول.\nb (int): العدد الصحيح الثاني.\nc (int): العدد الصحيح الثالث.\n\nالقيم المعادة:\nTuple[int, int]: ليست هناك مفهوم للـ tuple في C؛ بدلاً من ذلك، سنعيد بالقيمة المرجعية.\n\n>>> مثال على الاستدعاء:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "sw": "Tafuta kubwa na ndogo kati ya nambari tatu tofauti za mzima.\n\nVigezo:\na (int): Nambari ya kwanza ya mzima.\nb (int): Nambari ya pili ya mzima.\nc (int): Nambari ya tatu ya mzima.\n\nInarejesha:\nTuple[int, int]: Tuple si dhana katika C; badala yake, tutarejesha kwa marejeleo.\n\n>>> Mfano wa kupiga simu:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "tr": "Üç farklı tamsayının maksimum ve minimumunu bulun.\nParametreler:\na (int): Birinci tamsayı.\nb (int): İkinci tamsayı.\nc (int): Üçüncü tamsayı.\n\nDöndürülenler:\nTuple[int, int]: C'de bir kavram değildir; bunun yerine referansla döneceğiz.\n\n>>> Örnek çağrı:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "vi": "Tìm giá trị lớn nhất và nhỏ nhất của ba số nguyên khác nhau.  \nTham số:  \na (int): Số nguyên thứ nhất.  \nb (int): Số nguyên thứ hai.  \nc (int): Số nguyên thứ ba.  \n\nTrả về:  \nTuple[int, int]: Một tuple không phải là khái niệm trong C; thay vào đó, chúng ta sẽ trả về bằng tham chiếu.\n\n>>> Ví dụ gọi:  \nint max, min;  \nf_4(1,2,3, &max, &min);  \nassert(max == 3 && min == 1);  ", "id": "Temukan nilai maksimum dan minimum dari tiga bilangan bulat yang berbeda.\nParameter:\na (int): Bilangan bulat pertama.\nb (int): Bilangan bulat kedua.\nc (int): Bilangan bulat ketiga.\n\nMengembalikan:\nTuple[int, int]: Sebuah tuple bukanlah konsep dalam C; sebagai gantinya, kita akan mengembalikan melalui referensi.\n\n>>> Contoh pemanggilan:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "ja": "3つの異なる整数の最大値と最小値を見つけます。\nパラメータ:\na (int): 最初の整数。\nb (int): 2番目の整数。\nc (int): 3番目の整数。\n\n返り値:\nTuple[int, int]: タプルはCの概念ではないため、参照によって返します。\n\n>>> 例の呼び出し:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "ko": "세 개의 서로 다른 정수의 최대값과 최소값을 찾습니다.  \n매개변수:  \na (int): 첫 번째 정수입니다.  \nb (int): 두 번째 정수입니다.  \nc (int): 세 번째 정수입니다.  \n\n반환값:  \nTuple[int, int]: 튜플은 C에서 개념이 아니므로, 참조에 의해 반환합니다.  \n\n>>> 예제 호출:  \nint max, min;  \nf_4(1,2,3, &max, &min);  \nassert(max == 3 && min == 1);  ", "ml": "Find the maximum and minimum of three distinct integers.\nപാരാമീറ്ററുകൾ:\na (int): ആദ്യത്തെ പൂർണ്ണസംഖ്യ.\nb (int): രണ്ടാം പൂർണ്ണസംഖ്യ.\nc (int): മൂന്നാമത്തെ പൂർണ്ണസംഖ്യ.\n\nമടക്കുന്നു:\nTuple[int, int]: C-യിൽ ഒരു ആശയം അല്ല, പകരം, നാം റഫറൻസിലൂടെ മടക്കും.\n\n>>> ഉദാഹരണ കോൾ:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "fa": "حداکثر و حداقل سه عدد صحیح متمایز را پیدا کنید.\nپارامترها:\na (int): عدد صحیح اول.\nb (int): عدد صحیح دوم.\nc (int): عدد صحیح سوم.\n\nبازگشت:\nTuple[int, int]: یک تاپل مفهومی در C نیست؛ در عوض، ما با ارجاع باز خواهیم گشت.\n\n>>> مثال فراخوانی:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);"}}
{"task_id": "C/5", "prompt": {"en": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCalculate the distance between two points A (xa, ya) and B (xb, yb).\n    Parameters:\n- xa (double): x-coordinate of point A.\n- ya (double): y-coordinate of point A.\n- xb (double): x-coordinate of point B.\n- yb (double): y-coordinate of point B.\n    \n    Returns:\n    double: The distance between points A and B.\n    >>> f_5(0,0,3,4)\n    5\n*/\ndouble f_5(double xa, double ya, double xb, double yb)", "sq": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nLlogarit distancën midis dy pikave A (xa, ya) dhe B (xb, yb).\n    Parametrat:\n- xa (double): koordinata x e pikës A.\n- ya (double): koordinata y e pikës A.\n- xb (double): koordinata x e pikës B.\n- yb (double): koordinata y e pikës B.\n    \n    Kthen:\n    double: Distanca midis pikave A dhe B.\n    >>> f_5(0,0,3,4)\n    5\n*/\ndouble f_5(double xa, double ya, double xb, double yb)", "hy": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nՀաշվել հեռավորությունը երկու կետերի A (xa, ya) և B (xb, yb) միջև։\n    Պարամետրեր:\n- xa (double): A կետի x-կոորդինատը։\n- ya (double): A կետի y-կոորդինատը։\n- xb (double): B կետի x-կոորդինատը։\n- yb (double): B կետի y-կոորդինատը։\n    \n    Վերադարձնում է:\n    double: Հեռավորությունը A և B կետերի միջև։\n    >>> f_5(0,0,3,4)\n    5\n*/\ndouble f_5(double xa, double ya, double xb, double yb)", "bn": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nদুটি বিন্দু A (xa, ya) এবং B (xb, yb) এর মধ্যে দূরত্ব গণনা করুন।\n    প্যারামিটার:\n- xa (double): বিন্দু A এর x-সমন্বয়।\n- ya (double): বিন্দু A এর y-সমন্বয়।\n- xb (double): বিন্দু B এর x-সমন্বয়।\n- yb (double): বিন্দু B এর y-সমন্বয়।\n    \n    রিটার্নস:\n    double: বিন্দু A এবং B এর মধ্যে দূরত্ব।\n    >>> f_5(0,0,3,4)\n    5\n*/\ndouble f_5(double xa, double ya, double xb, double yb)", "bg": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nИзчисляване на разстоянието между две точки A (xa, ya) и B (xb, yb).\n    Параметри:\n- xa (double): x-координата на точка A.\n- ya (double): y-координата на точка A.\n- xb (double): x-координата на точка B.\n- yb (double): y-координата на точка B.\n    \n    Връща:\n    double: Разстоянието между точките A и B.\n    >>> f_5(0,0,3,4)\n    5\n*/\ndouble f_5(double xa, double ya, double xb, double yb)", "zh": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n计算两点 A (xa, ya) 和 B (xb, yb) 之间的距离。\n    参数:\n- xa (double): 点 A 的 x 坐标。\n- ya (double): 点 A 的 y 坐标。\n- xb (double): 点 B 的 x 坐标。\n- yb (double): 点 B 的 y 坐标。\n    \n    返回:\n    double: 点 A 和 B 之间的距离。\n    >>> f_5(0,0,3,4)\n    5\n*/\ndouble f_5(double xa, double ya, double xb, double yb)", "fr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCalcule la distance entre deux points A (xa, ya) et B (xb, yb).\n    Paramètres :\n- xa (double) : coordonnée x du point A.\n- ya (double) : coordonnée y du point A.\n- xb (double) : coordonnée x du point B.\n- yb (double) : coordonnée y du point B.\n    \n    Renvoie :\n    double : La distance entre les points A et B.\n    >>> f_5(0,0,3,4)\n    5\n*/\ndouble f_5(double xa, double ya, double xb, double yb)", "de": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nBerechne die Entfernung zwischen zwei Punkten A (xa, ya) und B (xb, yb).\n    Parameter:\n- xa (double): x-Koordinate des Punktes A.\n- ya (double): y-Koordinate des Punktes A.\n- xb (double): x-Koordinate des Punktes B.\n- yb (double): y-Koordinate des Punktes B.\n    \n    Rückgabe:\n    double: Die Entfernung zwischen den Punkten A und B.\n    >>> f_5(0,0,3,4)\n    5\n*/\ndouble f_5(double xa, double ya, double xb, double yb)", "ha": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nƘididdige nisan tsakanin maki biyu A (xa, ya) da B (xb, yb).\n    Sigogi:\n- xa (double): x-da'irar maki A.\n- ya (double): y-da'irar maki A.\n- xb (double): x-da'irar maki B.\n- yb (double): y-da'irar maki B.\n    \n    Komawa:\n    double: Nisan tsakanin maki A da B.\n    >>> f_5(0,0,3,4)\n    5\n*/\ndouble f_5(double xa, double ya, double xb, double yb)", "hi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nदो बिंदुओं A (xa, ya) और B (xb, yb) के बीच की दूरी की गणना करें।\n    पैरामीटर्स:\n- xa (double): बिंदु A का x-निर्देशांक।\n- ya (double): बिंदु A का y-निर्देशांक।\n- xb (double): बिंदु B का x-निर्देशांक।\n- yb (double): बिंदु B का y-निर्देशांक।\n    \n    रिटर्न करता है:\n    double: बिंदु A और B के बीच की दूरी।\n    >>> f_5(0,0,3,4)\n    5\n*/\ndouble f_5(double xa, double ya, double xb, double yb)", "hu": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nSzámítsa ki két pont, A (xa, ya) és B (xb, yb) közötti távolságot.\n    Paraméterek:\n- xa (double): A pont x-koordinátája.\n- ya (double): A pont y-koordinátája.\n- xb (double): B pont x-koordinátája.\n- yb (double): B pont y-koordinátája.\n    \n    Visszatér:\n    double: Az A és B pontok közötti távolság.\n    >>> f_5(0,0,3,4)\n    5\n*/\ndouble f_5(double xa, double ya, double xb, double yb)", "es": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCalcular la distancia entre dos puntos A (xa, ya) y B (xb, yb).\n    Parámetros:\n- xa (double): coordenada x del punto A.\n- ya (double): coordenada y del punto A.\n- xb (double): coordenada x del punto B.\n- yb (double): coordenada y del punto B.\n    \n    Devuelve:\n    double: La distancia entre los puntos A y B.\n    >>> f_5(0,0,3,4)\n    5\n*/\ndouble f_5(double xa, double ya, double xb, double yb)", "arb": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nاحسب المسافة بين نقطتين A (xa, ya) و B (xb, yb).\n    المعلمات:\n- xa (double): الإحداثي السيني للنقطة A.\n- ya (double): الإحداثي الصادي للنقطة A.\n- xb (double): الإحداثي السيني للنقطة B.\n- yb (double): الإحداثي الصادي للنقطة B.\n    \n    يعيد:\n    double: المسافة بين النقطتين A و B.\n    >>> f_5(0,0,3,4)\n    5\n*/\ndouble f_5(double xa, double ya, double xb, double yb)", "sw": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nHesabu umbali kati ya pointi mbili A (xa, ya) na B (xb, yb).\n    Vigezo:\n- xa (double): x-kiwianishi cha pointi A.\n- ya (double): y-kiwianishi cha pointi A.\n- xb (double): x-kiwianishi cha pointi B.\n- yb (double): y-kiwianishi cha pointi B.\n    \n    Inarejesha:\n    double: Umbali kati ya pointi A na B.\n    >>> f_5(0,0,3,4)\n    5\n*/\ndouble f_5(double xa, double ya, double xb, double yb)", "tr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nİki nokta A (xa, ya) ve B (xb, yb) arasındaki mesafeyi hesaplayın.\n    Parametreler:\n- xa (double): A noktasının x-koordinatı.\n- ya (double): A noktasının y-koordinatı.\n- xb (double): B noktasının x-koordinatı.\n- yb (double): B noktasının y-koordinatı.\n    \n    Döndürür:\n    double: A ve B noktaları arasındaki mesafe.\n    >>> f_5(0,0,3,4)\n    5\n*/\ndouble f_5(double xa, double ya, double xb, double yb)", "vi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nTính khoảng cách giữa hai điểm A (xa, ya) và B (xb, yb).\n    Tham số:\n- xa (double): tọa độ x của điểm A.\n- ya (double): tọa độ y của điểm A.\n- xb (double): tọa độ x của điểm B.\n- yb (double): tọa độ y của điểm B.\n    \n    Trả về:\n    double: Khoảng cách giữa điểm A và B.\n    >>> f_5(0,0,3,4)\n    5\n*/\ndouble f_5(double xa, double ya, double xb, double yb)", "id": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nMenghitung jarak antara dua titik A (xa, ya) dan B (xb, yb).\n    Parameter:\n- xa (double): koordinat x dari titik A.\n- ya (double): koordinat y dari titik A.\n- xb (double): koordinat x dari titik B.\n- yb (double): koordinat y dari titik B.\n    \n    Mengembalikan:\n    double: Jarak antara titik A dan B.\n    >>> f_5(0,0,3,4)\n    5\n*/\ndouble f_5(double xa, double ya, double xb, double yb)", "ja": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n2点A (xa, ya) とB (xb, yb) の間の距離を計算します。\n    パラメータ:\n- xa (double): 点Aのx座標。\n- ya (double): 点Aのy座標。\n- xb (double): 点Bのx座標。\n- yb (double): 点Bのy座標。\n    \n    戻り値:\n    double: 点AとBの間の距離。\n    >>> f_5(0,0,3,4)\n    5\n*/\ndouble f_5(double xa, double ya, double xb, double yb)", "ko": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n두 점 A (xa, ya)와 B (xb, yb) 사이의 거리를 계산합니다.\n    매개변수:\n- xa (double): 점 A의 x-좌표.\n- ya (double): 점 A의 y-좌표.\n- xb (double): 점 B의 x-좌표.\n- yb (double): 점 B의 y-좌표.\n    \n    반환:\n    double: 점 A와 B 사이의 거리.\n    >>> f_5(0,0,3,4)\n    5\n*/\ndouble f_5(double xa, double ya, double xb, double yb)", "ml": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nരണ്ട് ബിന്ദുക്കൾ A (xa, ya) and B (xb, yb) തമ്മിലുള്ള ദൂരം കണക്കാക്കുക.\n    പാരാമീറ്ററുകൾ:\n- xa (double): ബിന്ദു A യുടെ x-കോഓർഡിനേറ്റ്.\n- ya (double): ബിന്ദു A യുടെ y-കോഓർഡിനേറ്റ്.\n- xb (double): ബിന്ദു B യുടെ x-കോഓർഡിനേറ്റ്.\n- yb (double): ബിന്ദു B യുടെ y-കോഓർഡിനേറ്റ്.\n    \n    തിരികെ നൽകുന്നു:\n    double: ബിന്ദുക്കൾ A and B തമ്മിലുള്ള ദൂരം.\n    >>> f_5(0,0,3,4)\n    5\n*/\ndouble f_5(double xa, double ya, double xb, double yb)", "fa": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nفاصله بین دو نقطه A (xa, ya) و B (xb, yb) را محاسبه کنید.\n    پارامترها:\n- xa (double): مختصات x نقطه A.\n- ya (double): مختصات y نقطه A.\n- xb (double): مختصات x نقطه B.\n- yb (double): مختصات y نقطه B.\n    \n    بازگشت:\n    double: فاصله بین نقاط A و B.\n    >>> f_5(0,0,3,4)\n    5\n*/\ndouble f_5(double xa, double ya, double xb, double yb)"}, "canonical_solution": "{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}", "instruction": {"en": "Write a C function `double f_5(double xa, double ya, double xb, double yb)` to solve the following problem:\nCalculate the distance between two points A (xa, ya) and B (xb, yb).\n    Parameters:\n- xa (double): x-coordinate of point A.\n- ya (double): y-coordinate of point A.\n- xb (double): x-coordinate of point B.\n- yb (double): y-coordinate of point B.\n    \n    Returns:\n    double: The distance between points A and B.\n    >>> f_5(0,0,3,4)\n    5\n", "sq": "Shkruani një funksion në C `double f_5(double xa, double ya, double xb, double yb)` për të zgjidhur problemin e mëposhtëm:\nLlogaritni distancën midis dy pikave A (xa, ya) dhe B (xb, yb).\n    Parametrat:\n- xa (double): koordinata x e pikës A.\n- ya (double): koordinata y e pikës A.\n- xb (double): koordinata x e pikës B.\n- yb (double): koordinata y e pikës B.\n    \n    Kthen:\n    double: Distanca midis pikave A dhe B.\n    >>> f_5(0,0,3,4)\n    5", "hy": "Գրեք C ֆունկցիա `double f_5(double xa, double ya, double xb, double yb)` հետևյալ խնդիրը լուծելու համար:\nՀաշվեք հեռավորությունը A (xa, ya) և B (xb, yb) կետերի միջև:\n    Պարամետրեր:\n- xa (double): A կետի x-կոորդինատը։\n- ya (double): A կետի y-կոորդինատը։\n- xb (double): B կետի x-կոորդինատը։\n- yb (double): B կետի y-կոորդինատը։\n    \n    Վերադարձնում է:\n    double: A և B կետերի միջև հեռավորությունը։\n    >>> f_5(0,0,3,4)\n    5", "bn": "একটি C ফাংশন `double f_5(double xa, double ya, double xb, double yb)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nদুটি বিন্দু A (xa, ya) এবং B (xb, yb) এর মধ্যে দূরত্ব গণনা করুন।\n    প্যারামিটারসমূহ:\n- xa (double): বিন্দু A এর x-অক্ষাংশ।\n- ya (double): বিন্দু A এর y-অক্ষাংশ।\n- xb (double): বিন্দু B এর x-অক্ষাংশ।\n- yb (double): বিন্দু B এর y-অক্ষাংশ।\n    \n    রিটার্নস:\n    double: বিন্দু A এবং B এর মধ্যে দূরত্ব।\n    >>> f_5(0,0,3,4)\n    5", "bg": "Напишете C функция `double f_5(double xa, double ya, double xb, double yb)`, за да решите следния проблем:\nИзчислете разстоянието между две точки A (xa, ya) и B (xb, yb).  \n    Параметри:  \n- xa (double): x-координата на точка A.  \n- ya (double): y-координата на точка A.  \n- xb (double): x-координата на точка B.  \n- yb (double): y-координата на точка B.  \n   \n    Връща:  \n    double: Разстоянието между точките A и B.  \n    >>> f_5(0,0,3,4)  \n    5  ", "zh": "编写一个 C 函数 `double f_5(double xa, double ya, double xb, double yb)` 来解决以下问题：\n计算两点 A (xa, ya) 和 B (xb, yb) 之间的距离。\n参数：\n- xa (double): 点 A 的 x 坐标。\n- ya (double): 点 A 的 y 坐标。\n- xb (double): 点 B 的 x 坐标。\n- yb (double): 点 B 的 y 坐标。\n    \n返回：\ndouble: 点 A 和 B 之间的距离。", "fr": "Écrire une fonction C `double f_5(double xa, double ya, double xb, double yb)` pour résoudre le problème suivant :\nCalculer la distance entre deux points A (xa, ya) et B (xb, yb).\n    Paramètres :\n- xa (double) : coordonnée x du point A.\n- ya (double) : coordonnée y du point A.\n- xb (double) : coordonnée x du point B.\n- yb (double) : coordonnée y du point B.\n    \n    Renvoie :\n    double : La distance entre les points A et B.\n    >>> f_5(0,0,3,4)\n    5", "de": "Schreiben Sie eine C-Funktion `double f_5(double xa, double ya, double xb, double yb)`, um das folgende Problem zu lösen:\nBerechnen Sie die Entfernung zwischen zwei Punkten A (xa, ya) und B (xb, yb).\n    \n    Parameter:\n- xa (double): x-Koordinate des Punktes A.\n- ya (double): y-Koordinate des Punktes A.\n- xb (double): x-Koordinate des Punktes B.\n- yb (double): y-Koordinate des Punktes B.\n    \n    Rückgabewert:\n    double: Die Entfernung zwischen den Punkten A und B.\n    >>> f_5(0,0,3,4)\n    5", "ha": "Rubuta aikin C `double f_5(double xa, double ya, double xb, double yb)` don warware matsalar mai zuwa:\nƘididdige nisan tsakanin maki biyu A (xa, ya) da B (xb, yb).\n    Sigogi:\n- xa (double): x-ƙoordinat na maki A.\n- ya (double): y-ƙoordinat na maki A.\n- xb (double): x-ƙoordinat na maki B.\n- yb (double): y-ƙoordinat na maki B.\n    \n    Mayar da:\n    double: Nisan tsakanin maki A da B.\n    >>> f_5(0,0,3,4)\n    5", "hi": "C फ़ंक्शन `double f_5(double xa, double ya, double xb, double yb)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदो बिंदुओं A (xa, ya) और B (xb, yb) के बीच की दूरी की गणना करें।\n    पैरामीटर्स:\n- xa (double): बिंदु A का x-निर्देशांक।\n- ya (double): बिंदु A का y-निर्देशांक।\n- xb (double): बिंदु B का x-निर्देशांक।\n- yb (double): बिंदु B का y-निर्देशांक।\n    \n    रिटर्न करता है:\n    double: बिंदुओं A और B के बीच की दूरी।\n    >>> f_5(0,0,3,4)\n    5", "hu": "Írj egy C függvényt `double f_5(double xa, double ya, double xb, double yb)` a következő probléma megoldására:\nSzámítsd ki a távolságot két pont, A (xa, ya) és B (xb, yb) között.\n    Paraméterek:\n- xa (double): A pont x-koordinátája.\n- ya (double): A pont y-koordinátája.\n- xb (double): B pont x-koordinátája.\n- yb (double): B pont y-koordinátája.\n    \n    Visszatérési érték:\n    double: A távolság A és B pontok között.\n    >>> f_5(0,0,3,4)\n    5", "es": "Escribe una función en C `double f_5(double xa, double ya, double xb, double yb)` para resolver el siguiente problema:\nCalcular la distancia entre dos puntos A (xa, ya) y B (xb, yb).\n    Parámetros:\n- xa (double): coordenada x del punto A.\n- ya (double): coordenada y del punto A.\n- xb (double): coordenada x del punto B.\n- yb (double): coordenada y del punto B.\n    \n    Retorna:\n    double: La distancia entre los puntos A y B.\n    >>> f_5(0,0,3,4)\n    5", "arb": "اكتب دالة C `double f_5(double xa, double ya, double xb, double yb)` لحل المشكلة التالية:\nاحسب المسافة بين نقطتين A (xa, ya) و B (xb, yb).\n    المعاملات:\n- xa (double): الإحداثي السيني للنقطة A.\n- ya (double): الإحداثي الصادي للنقطة A.\n- xb (double): الإحداثي السيني للنقطة B.\n- yb (double): الإحداثي الصادي للنقطة B.\n    \n    يعيد:\n    double: المسافة بين النقطتين A و B.\n    >>> f_5(0,0,3,4)\n    5", "sw": "Andika kazi ya C `double f_5(double xa, double ya, double xb, double yb)` kutatua tatizo lifuatalo:\nHesabu umbali kati ya pointi mbili A (xa, ya) na B (xb, yb).\n    Vigezo:\n- xa (double): x-kiwianishi cha pointi A.\n- ya (double): y-kiwianishi cha pointi A.\n- xb (double): x-kiwianishi cha pointi B.\n- yb (double): y-kiwianishi cha pointi B.\n    \n    Inarudisha:\n    double: Umbali kati ya pointi A na B.\n    >>> f_5(0,0,3,4)\n    5", "tr": "Bir C fonksiyonu `double f_5(double xa, double ya, double xb, double yb)` yazın ve aşağıdaki problemi çözün:\nİki nokta A (xa, ya) ve B (xb, yb) arasındaki mesafeyi hesaplayın.\n    Parametreler:\n- xa (double): A noktasının x-koordinatı.\n- ya (double): A noktasının y-koordinatı.\n- xb (double): B noktasının x-koordinatı.\n- yb (double): B noktasının y-koordinatı.\n    \n    Döndürür:\n    double: A ve B noktaları arasındaki mesafe.\n    >>> f_5(0,0,3,4)\n    5", "vi": "Viết một hàm C `double f_5(double xa, double ya, double xb, double yb)` để giải quyết vấn đề sau:\nTính khoảng cách giữa hai điểm A (xa, ya) và B (xb, yb).\n    Tham số:\n- xa (double): tọa độ x của điểm A.\n- ya (double): tọa độ y của điểm A.\n- xb (double): tọa độ x của điểm B.\n- yb (double): tọa độ y của điểm B.\n    \n    Trả về:\n    double: Khoảng cách giữa điểm A và B.\n    >>> f_5(0,0,3,4)\n    5\n", "id": "Tulis sebuah fungsi C `double f_5(double xa, double ya, double xb, double yb)` untuk menyelesaikan masalah berikut:\nHitung jarak antara dua titik A (xa, ya) dan B (xb, yb).\n    Parameter:\n- xa (double): koordinat x dari titik A.\n- ya (double): koordinat y dari titik A.\n- xb (double): koordinat x dari titik B.\n- yb (double): koordinat y dari titik B.\n    \n    Mengembalikan:\n    double: Jarak antara titik A dan B.\n    >>> f_5(0,0,3,4)\n    5", "ja": "Cの関数を書け `double f_5(double xa, double ya, double xb, double yb)` を作成して、次の問題を解決してください:\n2点 A (xa, ya) と B (xb, yb) の間の距離を計算します。\n    パラメータ:\n- xa (double): 点Aのx座標。\n- ya (double): 点Aのy座標。\n- xb (double): 点Bのx座標。\n- yb (double): 点Bのy座標。\n    \n    戻り値:\n    double: 点AとBの間の距離。\n    >>> f_5(0,0,3,4)\n    5", "ko": "C 함수 `double f_5(double xa, double ya, double xb, double yb)`를 작성하여 다음 문제를 해결하십시오:\n두 점 A (xa, ya)와 B (xb, yb) 사이의 거리를 계산합니다.\n    매개변수:\n- xa (double): 점 A의 x-좌표.\n- ya (double): 점 A의 y-좌표.\n- xb (double): 점 B의 x-좌표.\n- yb (double): 점 B의 y-좌표.\n    \n    반환값:\n    double: 점 A와 B 사이의 거리.\n    >>> f_5(0,0,3,4)\n    5", "ml": "C ഭാഷയിൽ ഒരു ഫംഗ്ഷൻ `double f_5(double xa, double ya, double xb, double yb)` എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nരണ്ട് ബിന്ദുക്കളുടെ A (xa, ya) and B (xb, yb) ഇടയിലെ ദൂരമനക്കുക.\n    പാരാമീറ്ററുകൾ:\n- xa (double): A ബിന്ദുവിന്റെ x-കോഓർഡിനേറ്റ്.\n- ya (double): A ബിന്ദുവിന്റെ y-കോഓർഡിനേറ്റ്.\n- xb (double): B ബിന്ദുവിന്റെ x-കോഓർഡിനേറ്റ്.\n- yb (double): B ബിന്ദുവിന്റെ y-കോഓർഡിനേറ്റ്.\n    \n    മടക്കുന്നു:\n    double: A and B ബിന്ദുക്കളുടെ ഇടയിലെ ദൂരം.\n    >>> f_5(0,0,3,4)\n    5", "fa": "یک تابع C به نام `double f_5(double xa, double ya, double xb, double yb)` بنویسید تا مسئله زیر را حل کند:\nفاصله بین دو نقطه A (xa, ya) و B (xb, yb) را محاسبه کنید.\n    پارامترها:\n- xa (double): مختصات x نقطه A.\n- ya (double): مختصات y نقطه A.\n- xb (double): مختصات x نقطه B.\n- yb (double): مختصات y نقطه B.\n    \n    بازگشتی:\n    double: فاصله بین نقاط A و B.\n    >>> f_5(0,0,3,4)\n    5"}, "level": "easy", "test": "int main() {\n    assert(fabs(f_5(0,0,3,4) - 5) < 1e-6);\n    assert(fabs(f_5(0,0,0,0) - 0) < 1e-6);\n    assert(fabs(f_5(-1,-1,2,2) - 4.242640687) < 1e-6);\n    assert(fabs(f_5(1.5,3.9,4.2,-1.1) - 5.68243) < 1e-6);\n    // printf(\"All test cases passed!\\n\");\n    return 0;\n}", "entry_point": "f_5", "signature": "double f_5(double xa, double ya, double xb, double yb)", "docstring": {"en": "Calculate the distance between two points A (xa, ya) and B (xb, yb).\n    Parameters:\n- xa (double): x-coordinate of point A.\n- ya (double): y-coordinate of point A.\n- xb (double): x-coordinate of point B.\n- yb (double): y-coordinate of point B.\n    \n    Returns:\n    double: The distance between points A and B.\n    >>> f_5(0,0,3,4)\n    5\n", "sq": "Llogarit distancën midis dy pikave A (xa, ya) dhe B (xb, yb).\n    Parametra:\n- xa (double): koordinata x e pikës A.\n- ya (double): koordinata y e pikës A.\n- xb (double): koordinata x e pikës B.\n- yb (double): koordinata y e pikës B.\n    \n    Kthen:\n    double: Distanca midis pikave A dhe B.\n    >>> f_5(0,0,3,4)\n    5", "hy": "Հաշվել հեռավորությունը երկու կետերի A (xa, ya) և B (xb, yb) միջև:\n    Պարամետրեր:\n- xa (double): A կետի x-կոորդինատը:\n- ya (double): A կետի y-կոորդինատը:\n- xb (double): B կետի x-կոորդինատը:\n- yb (double): B կետի y-կոորդինատը:\n    \n    Վերադարձնում է:\n    double: Հեռավորությունը A և B կետերի միջև:\n    >>> f_5(0,0,3,4)\n    5", "bn": "দুটি বিন্দু A (xa, ya) এবং B (xb, yb) এর মধ্যে দূরত্ব গণনা করুন।\n    Parameters:\n- xa (double): বিন্দু A এর x-সমন্বয়।\n- ya (double): বিন্দু A এর y-সমন্বয়।\n- xb (double): বিন্দু B এর x-সমন্বয়।\n- yb (double): বিন্দু B এর y-সমন্বয়।\n    \n    Returns:\n    double: বিন্দু A এবং B এর মধ্যে দূরত্ব।\n    >>> f_5(0,0,3,4)\n    5", "bg": "Изчислете разстоянието между две точки A (xa, ya) и B (xb, yb).\n    Параметри:\n- xa (double): x-координата на точка A.\n- ya (double): y-координата на точка A.\n- xb (double): x-координата на точка B.\n- yb (double): y-координата на точка B.\n    \n    Връща:\n    double: Разстоянието между точките A и B.\n    >>> f_5(0,0,3,4)\n    5", "zh": "计算两点 A (xa, ya) 和 B (xb, yb) 之间的距离。\n    参数:\n- xa (double): 点 A 的 x 坐标。\n- ya (double): 点 A 的 y 坐标。\n- xb (double): 点 B 的 x 坐标。\n- yb (double): 点 B 的 y 坐标。\n    \n    返回:\n    double: 点 A 和 B 之间的距离。\n    >>> f_5(0,0,3,4)\n    5", "fr": "Calculer la distance entre deux points A (xa, ya) et B (xb, yb).\n    Paramètres:\n- xa (double): coordonnée x du point A.\n- ya (double): coordonnée y du point A.\n- xb (double): coordonnée x du point B.\n- yb (double): coordonnée y du point B.\n    \n    Renvoie:\n    double: La distance entre les points A et B.\n    >>> f_5(0,0,3,4)\n    5", "de": "Berechnen Sie die Entfernung zwischen zwei Punkten A (xa, ya) und B (xb, yb).\n    Parameter:\n- xa (double): x-Koordinate des Punktes A.\n- ya (double): y-Koordinate des Punktes A.\n- xb (double): x-Koordinate des Punktes B.\n- yb (double): y-Koordinate des Punktes B.\n    \n    Rückgabewert:\n    double: Die Entfernung zwischen den Punkten A und B.\n    >>> f_5(0,0,3,4)\n    5", "ha": "Ƙididdige nisan tsakanin maki biyu A (xa, ya) da B (xb, yb).\n    Sigogi:\n- xa (double): x-hadin gwiwar aya A.\n- ya (double): y-hadin gwiwar aya A.\n- xb (double): x-hadin gwiwar aya B.\n- yb (double): y-hadin gwiwar aya B.\n    \n    Yana dawowa:\n    double: Nisan tsakanin maki A da B.\n    >>> f_5(0,0,3,4)\n    5", "hi": "दो बिंदुओं A (xa, ya) और B (xb, yb) के बीच की दूरी की गणना करें।\n    पैरामीटर्स:\n- xa (double): बिंदु A का x-निर्देशांक।\n- ya (double): बिंदु A का y-निर्देशांक।\n- xb (double): बिंदु B का x-निर्देशांक।\n- yb (double): बिंदु B का y-निर्देशांक।\n    \n    रिटर्न करता है:\n    double: बिंदु A और B के बीच की दूरी।\n    >>> f_5(0,0,3,4)\n    5", "hu": "Számítsa ki a távolságot két pont, A (xa, ya) és B (xb, yb) között.\n    Paraméterek:\n- xa (double): A pont x-koordinátája.\n- ya (double): A pont y-koordinátája.\n- xb (double): B pont x-koordinátája.\n- yb (double): B pont y-koordinátája.\n    \n    Visszatérési érték:\n    double: A távolság A és B pontok között.\n    >>> f_5(0,0,3,4)\n    5", "es": "Calcular la distancia entre dos puntos A (xa, ya) y B (xb, yb).\n    Parámetros:\n- xa (double): coordenada x del punto A.\n- ya (double): coordenada y del punto A.\n- xb (double): coordenada x del punto B.\n- yb (double): coordenada y del punto B.\n    \n    Devuelve:\n    double: La distancia entre los puntos A y B.\n    >>> f_5(0,0,3,4)\n    5", "arb": "احسب المسافة بين نقطتين A (xa, ya) و B (xb, yb).\n    المعاملات:\n- xa (double): الإحداثي السيني للنقطة A.\n- ya (double): الإحداثي الصادي للنقطة A.\n- xb (double): الإحداثي السيني للنقطة B.\n- yb (double): الإحداثي الصادي للنقطة B.\n\n    يعيد:\n    double: المسافة بين النقطتين A و B.\n    >>> f_5(0,0,3,4)\n    5", "sw": "Hesabu umbali kati ya pointi mbili A (xa, ya) na B (xb, yb).\n    Vigezo:\n- xa (double): x-kipeo cha pointi A.\n- ya (double): y-kipeo cha pointi A.\n- xb (double): x-kipeo cha pointi B.\n- yb (double): y-kipeo cha pointi B.\n    \n    Inarejesha:\n    double: Umbali kati ya pointi A na B.\n    >>> f_5(0,0,3,4)\n    5", "tr": "İki nokta A (xa, ya) ve B (xb, yb) arasındaki mesafeyi hesaplayın.\n    Parametreler:\n- xa (double): A noktasının x-koordinatı.\n- ya (double): A noktasının y-koordinatı.\n- xb (double): B noktasının x-koordinatı.\n- yb (double): B noktasının y-koordinatı.\n    \n    Döndürülenler:\n    double: A ve B noktaları arasındaki mesafe.\n    >>> f_5(0,0,3,4)\n    5", "vi": "Tính khoảng cách giữa hai điểm A (xa, ya) và B (xb, yb).\n    Tham số:\n- xa (double): tọa độ x của điểm A.\n- ya (double): tọa độ y của điểm A.\n- xb (double): tọa độ x của điểm B.\n- yb (double): tọa độ y của điểm B.\n    \n    Trả về:\n    double: Khoảng cách giữa điểm A và B.\n    >>> f_5(0,0,3,4)\n    5", "id": "Hitung jarak antara dua titik A (xa, ya) dan B (xb, yb).\n    Parameter:\n- xa (double): koordinat x dari titik A.\n- ya (double): koordinat y dari titik A.\n- xb (double): koordinat x dari titik B.\n- yb (double): koordinat y dari titik B.\n    \n    Mengembalikan:\n    double: Jarak antara titik A dan B.\n    >>> f_5(0,0,3,4)\n    5", "ja": "2点A (xa, ya) とB (xb, yb) の間の距離を計算します。\n    パラメータ:\n- xa (double): 点Aのx座標。\n- ya (double): 点Aのy座標。\n- xb (double): 点Bのx座標。\n- yb (double): 点Bのy座標。\n    \n    戻り値:\n    double: 点AとBの間の距離。\n    >>> f_5(0,0,3,4)\n    5", "ko": "두 점 A (xa, ya)와 B (xb, yb) 사이의 거리를 계산합니다.\n    매개변수:\n- xa (double): 점 A의 x-좌표.\n- ya (double): 점 A의 y-좌표.\n- xb (double): 점 B의 x-좌표.\n- yb (double): 점 B의 y-좌표.\n    \n    반환값:\n    double: 점 A와 B 사이의 거리.\n    >>> f_5(0,0,3,4)\n    5", "ml": "Calculate the distance between two points A (xa, ya) and B (xb, yb).\n    പാരാമീറ്ററുകൾ:\n- xa (double): A ബിന്ദുവിന്റെ x-കോഓർഡിനേറ്റ്.\n- ya (double): A ബിന്ദുവിന്റെ y-കോഓർഡിനേറ്റ്.\n- xb (double): B ബിന്ദുവിന്റെ x-കോഓർഡിനേറ്റ്.\n- yb (double): B ബിന്ദുവിന്റെ y-കോഓർഡിനേറ്റ്.\n    \n    മടക്കങ്ങൾ:\n    double: A, B ബിന്ദുക്കൾക്കിടയിലെ ദൂരം.\n    >>> f_5(0,0,3,4)\n    5", "fa": "محاسبه فاصله بین دو نقطه A (xa, ya) و B (xb, yb).\n    پارامترها:\n- xa (double): مختصات x نقطه A.\n- ya (double): مختصات y نقطه A.\n- xb (double): مختصات x نقطه B.\n- yb (double): مختصات y نقطه B.\n    \n    بازگشت:\n    double: فاصله بین نقاط A و B.\n    >>> f_5(0,0,3,4)\n    5"}}
{"task_id": "C/6", "prompt": {"en": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nFind the factorial of N and take the modulo 10007 of the result.\n​    Parameters:\n- N (int): An integer representing the input value (N <= 10000).\n​    Returns:\n​    int: The result after taking the modulo 10007 of the output.\n    >>> f_6(1)\n    1\n*/\nint f_6(int n)", "sq": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nGjej faktorialin e N dhe merr modulo 10007 të rezultatit.\n​    Parametrat:\n- N (int): Një numër i plotë që përfaqëson vlerën hyrëse (N <= 10000).\n​    Kthen:\n​    int: Rezultati pasi të merret modulo 10007 i daljes.\n    >>> f_6(1)\n    1\n*/\nint f_6(int n)", "hy": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nԳտնել N-ի ֆակտորիալը և վերցնել արդյունքի 10007 մոդուլը։\n​    Պարամետրեր:\n- N (int): Ամբողջ թիվ, որը ներկայացնում է մուտքագրված արժեքը (N <= 10000)։\n​    Վերադարձնում է:\n​    int: Արդյունքը 10007 մոդուլից հետո։\n    >>> f_6(1)\n    1\n*/\nint f_6(int n)", "bn": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nN এর ফ্যাক্টোরিয়াল খুঁজে বের করুন এবং ফলাফলের 10007 এর মডুলো নিন।\n​    প্যারামিটারসমূহ:\n- N (int): একটি পূর্ণসংখ্যা যা ইনপুট মানকে উপস্থাপন করে (N <= 10000)।\n​    রিটার্নস:\n​    int: আউটপুটের 10007 এর মডুলো নেওয়ার পরের ফলাফল।\n    >>> f_6(1)\n    1\n*/\nint f_6(int n)", "bg": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nНамерете факториела на N и вземете модуло 10007 от резултата.\n​    Параметри:\n- N (int): Цяло число, представляващо входната стойност (N <= 10000).\n​    Връща:\n​    int: Резултатът след вземане на модуло 10007 от изхода.\n    >>> f_6(1)\n    1\n*/\nint f_6(int n)", "zh": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n找到N的阶乘并对结果取模10007。\n​    参数：\n- N (int): 表示输入值的整数 (N <= 10000)。\n​    返回：\n​    int: 对输出取模10007后的结果。\n    >>> f_6(1)\n    1\n*/\nint f_6(int n)", "fr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nTrouver la factorielle de N et prendre le modulo 10007 du résultat.\n​    Paramètres :\n- N (int) : Un entier représentant la valeur d'entrée (N <= 10000).\n​    Renvoie :\n​    int : Le résultat après avoir pris le modulo 10007 de la sortie.\n    >>> f_6(1)\n    1\n*/\nint f_6(int n)", "de": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nFinde die Fakultät von N und nimm das Modulo 10007 des Ergebnisses.\n​    Parameter:\n- N (int): Eine Ganzzahl, die den Eingabewert darstellt (N <= 10000).\n​    Rückgabe:\n​    int: Das Ergebnis nach dem Nehmen des Modulo 10007 des Ausgabewertes.\n    >>> f_6(1)\n    1\n*/\nint f_6(int n)", "ha": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nNemo factorial na N kuma ɗauki modulo 10007 na sakamakon.\n​    Sigogi:\n- N (int): Wani cikakken lamba da ke wakiltar ƙimar shigarwa (N <= 10000).\n​    Mayar da:\n​    int: Sakamakon bayan ɗaukar modulo 10007 na fitarwa.\n    >>> f_6(1)\n    1\n*/\nint f_6(int n)", "hi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nN का फैक्टरियल खोजें और परिणाम का 10007 से मॉड्यूलो लें।\n    पैरामीटर्स:\n- N (int): इनपुट मान का प्रतिनिधित्व करने वाला एक पूर्णांक (N <= 10000)।\n    रिटर्न्स:\n    int: आउटपुट का 10007 से मॉड्यूलो लेने के बाद का परिणाम।\n    >>> f_6(1)\n    1\n*/\nint f_6(int n)", "hu": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nTaláld meg N faktoriálisát, és vedd az eredmény 10007-es modulóját.\n​    Paraméterek:\n- N (int): Egy egész szám, amely az input értéket jelöli (N <= 10000).\n​    Visszatér:\n​    int: Az eredmény, miután az output 10007-es modulóját vettük.\n    >>> f_6(1)\n    1\n*/\nint f_6(int n)", "es": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nEncuentra el factorial de N y toma el módulo 10007 del resultado.\n    Parámetros:\n- N (int): Un entero que representa el valor de entrada (N <= 10000).\n    Devuelve:\n    int: El resultado después de tomar el módulo 10007 de la salida.\n    >>> f_6(1)\n    1\n*/\nint f_6(int n)", "arb": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nابحث عن مضروب N وخذ باقي القسمة 10007 من النتيجة.\n​    المعاملات:\n- N (int): عدد صحيح يمثل قيمة الإدخال (N <= 10000).\n​    يعيد:\n​    int: النتيجة بعد أخذ باقي القسمة 10007 من الناتج.\n    >>> f_6(1)\n    1\n*/\nint f_6(int n)", "sw": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nPata faktoria ya N na chukua modulo 10007 ya matokeo.\n​    Vigezo:\n- N (int): Nambari nzima inayowakilisha thamani ya ingizo (N <= 10000).\n​    Inarudisha:\n​    int: Matokeo baada ya kuchukua modulo 10007 ya matokeo.\n    >>> f_6(1)\n    1\n*/\nint f_6(int n)", "tr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nN'in faktöriyelini bulun ve sonucun 10007 modunu alın.\n​    Parametreler:\n- N (int): Girdi değerini temsil eden bir tamsayı (N <= 10000).\n​    Döndürür:\n​    int: Çıktının 10007 modunu aldıktan sonraki sonucu.\n    >>> f_6(1)\n    1\n*/\nint f_6(int n)", "vi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nTìm giai thừa của N và lấy phần dư 10007 của kết quả.\n    Tham số:\n- N (int): Một số nguyên đại diện cho giá trị đầu vào (N <= 10000).\n    Trả về:\n    int: Kết quả sau khi lấy phần dư 10007 của đầu ra.\n    >>> f_6(1)\n    1\n*/\nint f_6(int n)", "id": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nTemukan faktorial dari N dan ambil modulo 10007 dari hasilnya.\n​    Parameter:\n- N (int): Sebuah bilangan bulat yang mewakili nilai input (N <= 10000).\n​    Mengembalikan:\n​    int: Hasil setelah mengambil modulo 10007 dari output.\n    >>> f_6(1)\n    1\n*/\nint f_6(int n)", "ja": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nNの階乗を求め、その結果の10007での剰余を取ります。\n​    パラメータ:\n- N (int): 入力値を表す整数 (N <= 10000)。\n​    戻り値:\n​    int: 出力の10007での剰余を取った結果。\n    >>> f_6(1)\n    1\n*/\nint f_6(int n)", "ko": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nN의 팩토리얼을 구하고 결과를 10007로 나눈 나머지를 구합니다.\n​    매개변수:\n- N (int): 입력 값을 나타내는 정수 (N <= 10000).\n​    반환값:\n​    int: 출력 결과를 10007로 나눈 나머지.\n    >>> f_6(1)\n    1\n*/\nint f_6(int n)", "ml": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nN ന്റെ ഫാക്ടോറിയൽ കണ്ടെത്തി ഫലം 10007 ന്റെ മോഡുലോ എടുക്കുക.\n​    പാരാമീറ്ററുകൾ:\n- N (int): ഇൻപുട്ട് മൂല്യം പ്രതിനിധീകരിക്കുന്ന ഒരു പൂർണ്ണസംഖ്യ (N <= 10000).\n​    റിട്ടേൺസ്:\n​    int: ഔട്ട്പുട്ടിന്റെ മോഡുലോ 10007 എടുത്ത后的 ഫലം.\n    >>> f_6(1)\n    1\n*/\nint f_6(int n)", "fa": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nفاکتوریل N را پیدا کنید و باقیمانده تقسیم آن بر 10007 را محاسبه کنید.\n​    پارامترها:\n- N (int): یک عدد صحیح که مقدار ورودی را نشان می‌دهد (N <= 10000).\n​    بازگشت:\n​    int: نتیجه پس از گرفتن باقیمانده تقسیم بر 10007.\n    >>> f_6(1)\n    1\n*/\nint f_6(int n)"}, "canonical_solution": "{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for(register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i-1] * i) % 10007;\n    }\n    return a[n];\n}", "instruction": {"en": "Write a C function `int f_6(int n)` to solve the following problem:\nFind the factorial of N and take the modulo 10007 of the result.\n    Parameters:\n- N (int): An integer representing the input value (N <= 10000).\n    Returns:\n    int: The result after taking the modulo 10007 of the output.\n    >>> f_6(1)\n    1\n", "sq": "Shkruani një funksion në C `int f_6(int n)` për të zgjidhur problemin e mëposhtëm:\nGjeni faktorielin e N dhe merrni modulo 10007 të rezultatit.  \n    Parametrat:  \n- N (int): Një numër i plotë që përfaqëson vlerën hyrëse (N <= 10000).  \n    Kthen:  \n    int: Rezultati pasi të merret modulo 10007 e daljes.  \n    >>> f_6(1)  \n    1  ", "hy": "Գրեք C ֆունկցիա `int f_6(int n)`՝ հետևյալ խնդիրը լուծելու համար:\nԳտնել N-ի ֆակտորիալը և արդյունքը վերցնել 10007 մոդուլով։\n    Պարամետրեր:\n- N (int): Ամբողջ թիվ, որը ներկայացնում է մուտքային արժեքը (N <= 10000)։\n    Վերադարձնում է:\n    int: Արդյունքը՝ 10007 մոդուլով վերցնելուց հետո։\n    >>> f_6(1)\n    1", "bn": "একটি C ফাংশন `int f_6(int n)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nN এর ফ্যাক্টোরিয়াল খুঁজে বের করুন এবং ফলাফলের 10007 এর মডুলো নিন।\n    প্যারামিটারসমূহ:\n- N (int): একটি পূর্ণসংখ্যা যা ইনপুট মানকে উপস্থাপন করে (N <= 10000)।\n    রিটার্নস:\n    int: আউটপুটের 10007 এর মডুলো নেওয়ার পর ফলাফল।\n    >>> f_6(1)\n    1", "bg": "Напишете C функция `int f_6(int n)`, за да решите следния проблем:\nНамерете факториела на N и вземете модуло 10007 от резултата.  \nПараметри:  \n- N (int): Цяло число, представляващо входната стойност (N <= 10000).  \nВръща:  \nint: Резултатът след вземане на модуло 10007 от изхода.  \n>>> f_6(1)  \n1  ", "zh": "编写一个 C 函数 `int f_6(int n)` 来解决以下问题：\n求 N 的阶乘并对结果取模 10007。  \n参数：  \n- N (int): 表示输入值的整数 (N <= 10000)。  \n返回：  \nint: 对输出取模 10007 后的结果。  \n>>> f_6(1)  \n1  ", "fr": "Écrire une fonction C `int f_6(int n)` pour résoudre le problème suivant:\nTrouver la factorielle de N et prendre le modulo 10007 du résultat.  \n    Paramètres :  \n- N (int) : Un entier représentant la valeur d'entrée (N <= 10000).  \n    Renvoie :  \n    int : Le résultat après avoir pris le modulo 10007 de la sortie.  \n    >>> f_6(1)  \n    1  ", "de": "Schreiben Sie eine C-Funktion `int f_6(int n)`, um das folgende Problem zu lösen:\nFinden Sie die Fakultät von N und nehmen Sie das Modulo 10007 des Ergebnisses.\n    Parameter:\n- N (int): Eine ganze Zahl, die den Eingabewert darstellt (N <= 10000).\n    Rückgabewert:\n    int: Das Ergebnis nach dem Nehmen des Modulo 10007 des Outputs.\n    >>> f_6(1)\n    1", "ha": "Rubuta wani aikin C `int f_6(int n)` don magance matsalar mai zuwa:\nNemo factorial na N kuma dauki modulo 10007 na sakamakon.\n    Sigogi:\n- N (int): Wani cikakken lamba da ke wakiltar ƙimar shigarwa (N <= 10000).\n    Mayarwa:\n    int: Sakamakon bayan ɗaukar modulo 10007 na fitarwa.\n    >>> f_6(1)\n    1", "hi": "एक C फ़ंक्शन `int f_6(int n)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nN का फैक्टोरियल खोजें और परिणाम का 10007 से माड्यूलो लें।\n    पैरामीटर्स:\n- N (int): इनपुट मान का प्रतिनिधित्व करने वाला एक पूर्णांक (N <= 10000)।\n    रिटर्न करता है:\n    int: आउटपुट का 10007 से माड्यूलो लेने के बाद का परिणाम।\n    >>> f_6(1)\n    1", "hu": "Írj egy C függvényt `int f_6(int n)` a következő probléma megoldására:\nTaláld meg N faktoriálisát, és vedd az eredmény 10007-es modulóját.  \nParaméterek:  \n- N (int): Egy egész szám, amely az input értéket jelöli (N <= 10000).  \nVisszatér:  \nint: Az eredmény, miután az output 10007-es modulóját vettük.  \n>>> f_6(1)  \n1  ", "es": "Escribe una función en C `int f_6(int n)` para resolver el siguiente problema:\nEncuentra el factorial de N y toma el módulo 10007 del resultado.\n    Parámetros:\n- N (int): Un entero que representa el valor de entrada (N <= 10000).\n    Retorna:\n    int: El resultado después de tomar el módulo 10007 del resultado.\n    >>> f_6(1)\n    1", "arb": "اكتب دالة بلغة C `int f_6(int n)` لحل المشكلة التالية:\nابحث عن مضروب N وخذ باقي القسمة 10007 للنتيجة.\n    المعطيات:\n- N (int): عدد صحيح يمثل قيمة الإدخال (N <= 10000).\n    يعيد:\n    int: النتيجة بعد أخذ باقي القسمة 10007 من المخرجات.\n    >>> f_6(1)\n    1", "sw": "Andika kazi ya C `int f_6(int n)` kutatua tatizo lifuatalo:\nPata faktoria ya N na chukua modulo 10007 ya matokeo.\n    Vigezo:\n- N (int): Nambari kamili inayowakilisha thamani ya ingizo (N <= 10000).\n    Inarudisha:\n    int: Matokeo baada ya kuchukua modulo 10007 ya matokeo.\n    >>> f_6(1)\n    1", "tr": "Bir C fonksiyonu `int f_6(int n)` yazın ve aşağıdaki problemi çözün:\nN faktöriyelini bulun ve sonucu 10007 ile mod alın.\n    Parametreler:\n- N (int): Girdi değerini temsil eden bir tamsayı (N <= 10000).\n    Döndürülen:\n    int: Çıktının 10007 ile mod alınmasından sonra elde edilen sonuç.\n    >>> f_6(1)\n    1", "vi": "Viết một hàm C `int f_6(int n)` để giải quyết vấn đề sau:\nTìm giai thừa của N và lấy modulo 10007 của kết quả.  \n    Tham số:  \n- N (int): Một số nguyên đại diện cho giá trị đầu vào (N <= 10000).  \n    Trả về:  \n    int: Kết quả sau khi lấy modulo 10007 của đầu ra.  \n    >>> f_6(1)  \n    1  ", "id": "Tulis sebuah fungsi C `int f_6(int n)` untuk menyelesaikan masalah berikut:\nTemukan faktorial dari N dan ambil hasil modulo 10007.\n    Parameter:\n- N (int): Sebuah bilangan bulat yang mewakili nilai input (N <= 10000).\n    Mengembalikan:\n    int: Hasil setelah mengambil modulo 10007 dari output.\n    >>> f_6(1)\n    1", "ja": "Cの関数を書け `int f_6(int n)` を作成して、次の問題を解決してください:\nNの階乗を求め、その結果を10007で割った余りを求めます。\n    パラメータ:\n- N (int): 入力値を表す整数 (N <= 10000)。\n    戻り値:\n    int: 出力を10007で割った余りの結果。\n    >>> f_6(1)\n    1", "ko": "C 함수를 작성하세요 `int f_6(int n)` 다음 문제를 해결하기 위해:\nN의 팩토리얼을 구하고 결과를 10007로 나눈 나머지를 구하세요.\n    매개변수:\n- N (int): 입력값을 나타내는 정수 (N <= 10000).\n    반환값:\n    int: 출력 결과를 10007로 나눈 나머지.\n    >>> f_6(1)\n    1", "ml": "C ഭാഷയിൽ ഒരു ഫംഗ്ഷൻ `int f_6(int n)` എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nN ന്റെ ഫാക്ടോറിയൽ കണ്ടെത്തുക, ഫലം 10007 ന്റെ മോഡുലോ എടുക്കുക.\n    പാരാമീറ്ററുകൾ:\n- N (int): ഇൻപുട്ട് മൂല്യം പ്രതിനിധീകരിക്കുന്ന ഒരു പൂർണ്ണസംഖ്യ (N <= 10000).\n    മടക്കുന്നു:\n    int: ഔട്ട്പുട്ടിന്റെ 10007 ന്റെ മോഡുലോ എടുത്ത后的 ഫലം.\n    >>> f_6(1)\n    1", "fa": "یک تابع C به نام `int f_6(int n)` بنویسید تا مسئله زیر را حل کند:\nفاکتوریل N را پیدا کنید و باقیمانده تقسیم بر 10007 را از نتیجه بگیرید.\n    پارامترها:\n- N (int): یک عدد صحیح که مقدار ورودی را نشان می‌دهد (N <= 10000).\n    بازگشت:\n    int: نتیجه پس از گرفتن باقیمانده تقسیم بر 10007 از خروجی.\n    >>> f_6(1)\n    1"}, "level": "easy", "test": "int main()\n{\n    assert(f_6(0) == 1); // Added test for boundary condition\n    assert(f_6(1) == 1);\n    assert(f_6(2) == 2);\n    assert(f_6(3) == 6);\n    assert(f_6(4) == 24);\n    assert(f_6(10) == 6266); // 10! % 10007 = 3628800 % 10007 = 362\n    assert(f_6(10000) == 6991); // Added a test for upper boundary condition\n    // printf(\"All tests passed.\\n\");\n    return 0;\n}", "entry_point": "f_6", "signature": "int f_6(int n)", "docstring": {"en": "Find the factorial of N and take the modulo 10007 of the result.\n    Parameters:\n- N (int): An integer representing the input value (N <= 10000).\n    Returns:\n    int: The result after taking the modulo 10007 of the output.\n    >>> f_6(1)\n    1\n", "sq": "Gjej faktorielin e N dhe merre modulo 10007 të rezultatit.\n    Parametrat:\n- N (int): Një numër i plotë që përfaqëson vlerën e hyrjes (N <= 10000).\n    Kthen:\n    int: Rezultati pas marrjes së modulo 10007 të daljes.\n    >>> f_6(1)\n    1", "hy": "Գտնել N-ի ֆակտորիալը և վերցնել արդյունքի 10007 մոդուլը։\n    Պարամետրեր:\n- N (int): Թիվ, որը ներկայացնում է մուտքային արժեքը (N <= 10000):\n    Վերադարձնում է:\n    int: Արդյունքը 10007 մոդուլով վերցնելուց հետո:\n    >>> f_6(1)\n    1", "bn": "N এর ফ্যাক্টোরিয়াল খুঁজে বের করুন এবং ফলাফলের 10007 এর মডুলো নিন।\n    প্যারামিটারসমূহ:\n- N (int): একটি পূর্ণসংখ্যা যা ইনপুট মানকে উপস্থাপন করে (N <= 10000)।\n    রিটার্নস:\n    int: আউটপুটের মডুলো 10007 নেওয়ার পর ফলাফল।\n    >>> f_6(1)\n    1", "bg": "Намерете факториела на N и вземете модуло 10007 от резултата.\n    Параметри:\n- N (int): Цяло число, представляващо входната стойност (N <= 10000).\n    Връща:\n    int: Резултатът след вземане на модуло 10007 от изхода.\n    >>> f_6(1)\n    1", "zh": "计算N的阶乘，并对结果取模10007。\n    参数:\n- N (int): 表示输入值的整数 (N <= 10000)。\n    返回:\n    int: 对输出取模10007后的结果。\n    >>> f_6(1)\n    1", "fr": "Trouver la factorielle de N et prendre le modulo 10007 du résultat.\n    Paramètres:\n- N (int): Un entier représentant la valeur d'entrée (N <= 10000).\n    Renvoie:\n    int: Le résultat après avoir pris le modulo 10007 de la sortie.\n    >>> f_6(1)\n    1", "de": "Finde die Fakultät von N und nimm das Modulo 10007 des Ergebnisses.\n    Parameter:\n- N (int): Eine ganze Zahl, die den Eingabewert darstellt (N <= 10000).\n    Rückgabewert:\n    int: Das Ergebnis nach der Modulo-Operation mit 10007.\n    >>> f_6(1)\n    1", "ha": "Nemo factorial na N kuma ɗauki modulo 10007 na sakamakon.\n    Sigogi:\n- N (int): Lamba mai nuna darajar shigarwa (N <= 10000).\n    Komawa:\n    int: Sakamakon bayan ɗaukar modulo 10007 na fitarwa.\n    >>> f_6(1)\n    1", "hi": "N का फैक्टरियल खोजें और परिणाम का 10007 से मॉड्यूलो लें।\n    पैरामीटर्स:\n- N (int): इनपुट मान का प्रतिनिधित्व करने वाला एक पूर्णांक (N <= 10000)।\n    रिटर्न्स:\n    int: आउटपुट का 10007 से मॉड्यूलो लेने के बाद का परिणाम।\n    >>> f_6(1)\n    1", "hu": "Találd meg N faktoriálisát, és vedd az eredmény 10007-es modulóját.\n    Paraméterek:\n- N (int): Egy egész szám, amely a bemeneti értéket jelöli (N <= 10000).\n    Visszatérési érték:\n    int: Az eredmény, miután az outputot 10007-tel vettük modulo.\n    >>> f_6(1)\n    1", "es": "Encontrar el factorial de N y tomar el módulo 10007 del resultado.\n    Parámetros:\n- N (int): Un entero que representa el valor de entrada (N <= 10000).\n    Devuelve:\n    int: El resultado después de tomar el módulo 10007 de la salida.\n    >>> f_6(1)\n    1", "arb": "احسب المضروب لـ N وخذ باقي القسمة 10007 من النتيجة.\n    المعاملات:\n- N (int): عدد صحيح يمثل قيمة الإدخال (N <= 10000).\n    يعيد:\n    int: النتيجة بعد أخذ باقي القسمة 10007 من الناتج.\n    >>> f_6(1)\n    1", "sw": "Pata faktoria ya N na chukua modulo 10007 ya matokeo.\n    Vigezo:\n- N (int): Nambari nzima inayowakilisha thamani ya ingizo (N <= 10000).\n    Inarejesha:\n    int: Matokeo baada ya kuchukua modulo 10007 ya matokeo.\n    >>> f_6(1)\n    1", "tr": "N faktöriyelini bulun ve sonucu 10007 ile mod alın.\n    Parametreler:\n- N (int): Girdi değerini temsil eden bir tamsayı (N <= 10000).\n    Döndürür:\n    int: Çıktının 10007 ile modülüsünün alınmasından sonra elde edilen sonuç.\n    >>> f_6(1)\n    1", "vi": "Tìm giai thừa của N và lấy modulo 10007 của kết quả.  \n    Tham số:  \n- N (int): Một số nguyên đại diện cho giá trị đầu vào (N <= 10000).  \n    Trả về:  \n    int: Kết quả sau khi lấy modulo 10007 của đầu ra.  \n    >>> f_6(1)  \n    1  ", "id": "Temukan faktorial dari N dan ambil modulo 10007 dari hasilnya.\n    Parameter:\n- N (int): Sebuah bilangan bulat yang mewakili nilai input (N <= 10000).\n    Mengembalikan:\n    int: Hasil setelah mengambil modulo 10007 dari output.\n    >>> f_6(1)\n    1", "ja": "Nの階乗を求め、その結果を10007で割った余りを取得します。\n    パラメータ:\n- N (int): 入力値を表す整数 (N <= 10000)。\n    戻り値:\n    int: 出力を10007で割った余りの結果。\n    >>> f_6(1)\n    1", "ko": "N의 팩토리얼을 구하고 결과를 10007로 나눈 나머지를 구합니다.\n    매개변수:\n- N (int): 입력 값을 나타내는 정수 (N <= 10000).\n    반환:\n    int: 출력 값을 10007로 나눈 나머지 결과.\n    >>> f_6(1)\n    1", "ml": "Find the factorial of N and take the modulo 10007 of the result.\n    പാരാമീറ്ററുകൾ:\n- N (int): ഇൻപുട്ട് മൂല്യം പ്രതിനിധീകരിക്കുന്ന ഒരു പൂർണ്ണസംഖ്യ (N <= 10000).\n    മടക്കുന്നു:\n    int: ഔട്ട്പുട്ടിന്റെ 10007 മോഡുലോ എടുത്ത后的 ഫലം.\n    >>> f_6(1)\n    1", "fa": "پیدا کردن فاکتوریل N و گرفتن باقیمانده 10007 از نتیجه.\n\nپارامترها:\n- N (int): یک عدد صحیح که نشان‌دهنده مقدار ورودی است (N <= 10000).\n\nبازگشت:\nint: نتیجه پس از گرفتن باقیمانده 10007 از خروجی.\n\n>>> f_6(1)\n1"}}
{"task_id": "C/7", "prompt": {"en": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCalculate the area of a triangle given its base and height.\n​    Parameters:\n- base (int): The base length of the triangle.\n- height (int): The height of the triangle.\n​    Returns:\n​    float: The calculated area of the triangle, rounded to one decimal place.\n\t>>> f_7(1,2)\n\t1.0\n*/\nfloat f_7(int base, int height)", "sq": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nLlogarit sipërfaqen e një trekëndëshi duke pasur bazën dhe lartësinë e tij.\n​    Parametrat:\n- base (int): Gjatësia e bazës së trekëndëshit.\n- height (int): Lartësia e trekëndëshit.\n​    Kthen:\n​    float: Sipërfaqja e llogaritur e trekëndëshit, e rrumbullakosur në një vend dhjetor.\n\t>>> f_7(1,2)\n\t1.0\n*/\nfloat f_7(int base, int height)", "hy": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nՀաշվել եռանկյան մակերեսը, տրված նրա հիմքը և բարձրությունը։\n​    Պարամետրեր:\n- base (int): Եռանկյան հիմքի երկարությունը։\n- height (int): Եռանկյան բարձրությունը։\n​    Վերադարձնում է:\n​    float: Եռանկյան հաշվարկված մակերեսը, կլորացված մինչև մեկ տասնորդական։\n\t>>> f_7(1,2)\n\t1.0\n*/\nfloat f_7(int base, int height)", "bn": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nএকটি ত্রিভুজের ভিত্তি এবং উচ্চতা দেওয়া থাকলে তার ক্ষেত্রফল গণনা করুন।\n    প্যারামিটার:\n- base (int): ত্রিভুজের ভিত্তির দৈর্ঘ্য।\n- height (int): ত্রিভুজের উচ্চতা।\n    রিটার্নস:\n    float: ত্রিভুজের গণনা করা ক্ষেত্রফল, এক দশমিক স্থানে রাউন্ড করা।\n\t>>> f_7(1,2)\n\t1.0\n*/\nfloat f_7(int base, int height)", "bg": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nИзчисляване на лицето на триъгълник, дадени неговата основа и височина.\n​    Параметри:\n- base (int): Дължината на основата на триъгълника.\n- height (int): Височината на триъгълника.\n​    Връща:\n​    float: Изчисленото лице на триъгълника, закръглено до един десетичен знак.\n\t>>> f_7(1,2)\n\t1.0\n*/\nfloat f_7(int base, int height)", "zh": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n计算给定底边和高的三角形面积。\n    参数:\n- base (int): 三角形的底边长度。\n- height (int): 三角形的高度。\n    返回:\n    float: 计算出的三角形面积，四舍五入到小数点后一位。\n\t>>> f_7(1,2)\n\t1.0\n*/\nfloat f_7(int base, int height)", "fr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCalculez l'aire d'un triangle donné sa base et sa hauteur.\n    Paramètres :\n- base (int) : La longueur de la base du triangle.\n- height (int) : La hauteur du triangle.\n    Renvoie :\n    float : L'aire calculée du triangle, arrondie à un chiffre après la virgule.\n\t>>> f_7(1,2)\n\t1.0\n*/\nfloat f_7(int base, int height)", "de": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nBerechnet die Fläche eines Dreiecks, gegeben durch seine Basis und Höhe.\n    Parameter:\n- base (int): Die Basislänge des Dreiecks.\n- height (int): Die Höhe des Dreiecks.\n    Rückgabe:\n    float: Die berechnete Fläche des Dreiecks, gerundet auf eine Dezimalstelle.\n\t>>> f_7(1,2)\n\t1.0\n*/\nfloat f_7(int base, int height)", "ha": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nƘididdige yanki na alwatika la'akari da tushenta da tsayinta.\n​    Sigogi:\n- base (int): Tsawon tushe na alwatika.\n- height (int): Tsayin alwatika.\n​    Mayar da:\n​    float: Yankin da aka ƙididdige na alwatika, an zagaye zuwa wurin goma ɗaya.\n\t>>> f_7(1,2)\n\t1.0\n*/\nfloat f_7(int base, int height)", "hi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nत्रिभुज का क्षेत्रफल इसकी आधार और ऊँचाई के आधार पर गणना करें।\n    पैरामीटर्स:\n- base (int): त्रिभुज की आधार लंबाई।\n- height (int): त्रिभुज की ऊँचाई।\n    रिटर्न:\n    float: त्रिभुज का गणना किया गया क्षेत्रफल, एक दशमलव स्थान तक गोल किया गया।\n\t>>> f_7(1,2)\n\t1.0\n*/\nfloat f_7(int base, int height)", "hu": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nSzámítsa ki egy háromszög területét az alapja és magassága alapján.\n​    Paraméterek:\n- base (int): A háromszög alapjának hossza.\n- height (int): A háromszög magassága.\n​    Visszatér:\n​    float: A kiszámított háromszög területe, egy tizedesjegyre kerekítve.\n\t>>> f_7(1,2)\n\t1.0\n*/\nfloat f_7(int base, int height)", "es": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCalcular el área de un triángulo dado su base y altura.\n    Parámetros:\n- base (int): La longitud de la base del triángulo.\n- height (int): La altura del triángulo.\n    Devuelve:\n    float: El área calculada del triángulo, redondeada a un decimal.\n\t>>> f_7(1,2)\n\t1.0\n*/\nfloat f_7(int base, int height)", "arb": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nاحسب مساحة المثلث المعطى قاعدته وارتفاعه.\n    المعلمات:\n- base (int): طول قاعدة المثلث.\n- height (int): ارتفاع المثلث.\n    يعيد:\n    float: المساحة المحسوبة للمثلث، مقربة إلى منزلة عشرية واحدة.\n\t>>> f_7(1,2)\n\t1.0\n*/\nfloat f_7(int base, int height)", "sw": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nHesabu eneo la pembetatu ukizingatia msingi wake na urefu.\n    Vigezo:\n- base (int): Urefu wa msingi wa pembetatu.\n- height (int): Urefu wa pembetatu.\n    Inarudisha:\n    float: Eneo lililohesabiwa la pembetatu, limezungushwa hadi sehemu moja ya desimali.\n\t>>> f_7(1,2)\n\t1.0\n*/\nfloat f_7(int base, int height)", "tr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nBir üçgenin tabanı ve yüksekliği verildiğinde alanını hesaplayın.\n​    Parametreler:\n- base (int): Üçgenin taban uzunluğu.\n- height (int): Üçgenin yüksekliği.\n​    Döndürür:\n​    float: Üçgenin hesaplanan alanı, bir ondalık basamağa yuvarlanmış.\n\t>>> f_7(1,2)\n\t1.0\n*/\nfloat f_7(int base, int height)", "vi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nTính diện tích của một tam giác dựa trên đáy và chiều cao của nó.\n    Tham số:\n- base (int): Chiều dài đáy của tam giác.\n- height (int): Chiều cao của tam giác.\n    Trả về:\n    float: Diện tích đã tính của tam giác, làm tròn đến một chữ số thập phân.\n\t>>> f_7(1,2)\n\t1.0\n*/\nfloat f_7(int base, int height)", "id": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nMenghitung luas segitiga berdasarkan alas dan tingginya.\n    Parameter:\n- base (int): Panjang alas segitiga.\n- height (int): Tinggi segitiga.\n    Mengembalikan:\n    float: Luas segitiga yang dihitung, dibulatkan ke satu tempat desimal.\n\t>>> f_7(1,2)\n\t1.0\n*/\nfloat f_7(int base, int height)", "ja": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n三角形の底辺と高さが与えられたときの面積を計算します。\n​    パラメータ:\n- base (int): 三角形の底辺の長さ。\n- height (int): 三角形の高さ。\n​    戻り値:\n​    float: 計算された三角形の面積を小数点以下1桁に丸めたもの。\n\t>>> f_7(1,2)\n\t1.0\n*/\nfloat f_7(int base, int height)", "ko": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n삼각형의 밑변과 높이를 주어졌을 때 면적을 계산합니다.\n    매개변수:\n- base (int): 삼각형의 밑변 길이.\n- height (int): 삼각형의 높이.\n    반환값:\n    float: 소수점 한 자리까지 반올림된 삼각형의 계산된 면적.\n\t>>> f_7(1,2)\n\t1.0\n*/\nfloat f_7(int base, int height)", "ml": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nഒരു ത്രികോണത്തിന്റെ അടിയും ഉയരവും നൽകിയാൽ അതിന്റെ വിസ്തീർണ്ണം കണക്കാക്കുക.\n    പാരാമീറ്ററുകൾ:\n- base (int): ത്രികോണത്തിന്റെ അടിയുടെ നീളം.\n- height (int): ത്രികോണത്തിന്റെ ഉയരം.\n    തിരികെ നൽകുന്നത്:\n    float: ത്രികോണത്തിന്റെ കണക്കാക്കിയ വിസ്തീർണ്ണം, ഒരു ദശാംശ സ്ഥാനം വരെ വട്ടമിടുക.\n\t>>> f_7(1,2)\n\t1.0\n*/\nfloat f_7(int base, int height)", "fa": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nمساحت یک مثلث را با توجه به قاعده و ارتفاع آن محاسبه کنید.\n    پارامترها:\n- base (int): طول قاعده مثلث.\n- height (int): ارتفاع مثلث.\n    بازگشت:\n    float: مساحت محاسبه شده مثلث، گرد شده به یک رقم اعشار.\n\t>>> f_7(1,2)\n\t1.0\n*/\nfloat f_7(int base, int height)"}, "canonical_solution": "{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}", "instruction": {"en": "Write a C function `float f_7(int base, int height)` to solve the following problem:\nCalculate the area of a triangle given its base and height.\n    Parameters:\n- base (int): The base length of the triangle.\n- height (int): The height of the triangle.\n    Returns:\n    float: The calculated area of the triangle, rounded to one decimal place.\n    >>> f_7(1,2)\n    1.0\n", "sq": "Shkruani një funksion në C `float f_7(int base, int height)` për të zgjidhur problemin e mëposhtëm:\nLlogaritni sipërfaqen e një trekëndëshi duke pasur bazën dhe lartësinë e tij.\n    Parametrat:\n- base (int): Gjatësia e bazës së trekëndëshit.\n- height (int): Lartësia e trekëndëshit.\n    Kthen:\n    float: Sipërfaqja e llogaritur e trekëndëshit, e rrumbullakosur në një vend dhjetor.\n    >>> f_7(1,2)\n    1.0", "hy": "Գրեք C ֆունկցիա `float f_7(int base, int height)` հետևյալ խնդիրը լուծելու համար:\nՀաշվեք եռանկյան մակերեսը, տրված են նրա հիմքը և բարձրությունը։\n    Պարամետրեր:\n- base (int): Եռանկյան հիմքի երկարությունը։\n- height (int): Եռանկյան բարձրությունը։\n    Վերադարձնում է:\n    float: Հաշվարկված եռանկյան մակերեսը, կլորացված մինչև մեկ տասնորդական։\n    >>> f_7(1,2)\n    1.0", "bn": "একটি C ফাংশন `float f_7(int base, int height)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি ত্রিভুজের ভিত্তি এবং উচ্চতা দেওয়া হলে তার ক্ষেত্রফল গণনা করুন।\n    প্যারামিটারসমূহ:\n- base (int): ত্রিভুজের ভিত্তির দৈর্ঘ্য।\n- height (int): ত্রিভুজের উচ্চতা।\n    রিটার্নস:\n    float: ত্রিভুজের গণনা করা ক্ষেত্রফল, এক দশমিক স্থানে রাউন্ড করা।\n    >>> f_7(1,2)\n    1.0", "bg": "Напишете C функция `float f_7(int base, int height)`, за да решите следния проблем:\nИзчислете площта на триъгълник, дадени неговата основа и височина.\n    Параметри:\n- base (int): Дължината на основата на триъгълника.\n- height (int): Височината на триъгълника.\n    Връща:\n    float: Изчислената площ на триъгълника, закръглена до едно десетично място.\n    >>> f_7(1,2)\n    1.0", "zh": "编写一个 C 函数 `float f_7(int base, int height)` 来解决以下问题：\n计算给定底和高的三角形面积。\n    参数：\n- base (int): 三角形的底边长度。\n- height (int): 三角形的高度。\n    返回：\n    float: 计算出的三角形面积，四舍五入到小数点后一位。", "fr": "Écrire une fonction C `float f_7(int base, int height)` pour résoudre le problème suivant:\nCalculer l'aire d'un triangle donné sa base et sa hauteur.  \n    Paramètres :  \n- base (int) : La longueur de la base du triangle.  \n- height (int) : La hauteur du triangle.  \n    Renvoie :  \n    float : L'aire calculée du triangle, arrondie à une décimale.  \n    >>> f_7(1,2)  \n    1.0  ", "de": "Schreiben Sie eine C-Funktion `float f_7(int base, int height)`, um das folgende Problem zu lösen:\nBerechnen Sie die Fläche eines Dreiecks, gegeben seine Basis und Höhe.\n    Parameter:\n- base (int): Die Basislänge des Dreiecks.\n- height (int): Die Höhe des Dreiecks.\n    Rückgabewert:\n    float: Die berechnete Fläche des Dreiecks, gerundet auf eine Dezimalstelle.\n    >>> f_7(1,2)\n    1.0", "ha": "Rubuta aikin C `float f_7(int base, int height)` don magance matsalar mai zuwa:\nƘididdige yanki na alwatika da aka ba da tushenta da tsayinta.  \n    Sigogi:  \n- base (int): Tsawon tushe na alwatika.  \n- height (int): Tsayin alwatika.  \n    Mayarwa:  \n    float: Yankin da aka ƙididdige na alwatika, an zagaye zuwa wuri ɗaya na goma.  \n    >>> f_7(1,2)  \n    1.0  ", "hi": "C फ़ंक्शन `float f_7(int base, int height)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nत्रिभुज का क्षेत्रफल उसकी आधार और ऊँचाई के आधार पर गणना करें।\n    पैरामीटर्स:\n- base (int): त्रिभुज की आधार लंबाई।\n- height (int): त्रिभुज की ऊँचाई।\n    रिटर्न्स:\n    float: त्रिभुज का गणना किया गया क्षेत्रफल, एक दशमलव स्थान तक गोल किया हुआ।\n    >>> f_7(1,2)\n    1.0", "hu": "Írj egy C függvényt `float f_7(int base, int height)` a következő probléma megoldására:\nSzámítsd ki egy háromszög területét az alapja és magassága alapján.\n    Paraméterek:\n- base (int): A háromszög alapjának hossza.\n- height (int): A háromszög magassága.\n    Visszatérési érték:\n    float: A kiszámított háromszög területe, egy tizedesjegyre kerekítve.\n    >>> f_7(1,2)\n    1.0", "es": "Escribe una función en C `float f_7(int base, int height)` para resolver el siguiente problema:\nCalcular el área de un triángulo dado su base y altura.\n    Parámetros:\n- base (int): La longitud de la base del triángulo.\n- height (int): La altura del triángulo.\n    Retorna:\n    float: El área calculada del triángulo, redondeada a un decimal.\n    >>> f_7(1,2)\n    1.0", "arb": "اكتب دالة C `float f_7(int base, int height)` لحل المشكلة التالية:\nاحسب مساحة المثلث المعطى قاعدته وارتفاعه.  \n    المعاملات:  \n- base (int): طول قاعدة المثلث.  \n- height (int): ارتفاع المثلث.  \n    يعيد:  \n    float: المساحة المحسوبة للمثلث، مقربة إلى منزلة عشرية واحدة.  \n    >>> f_7(1,2)  \n    1.0  ", "sw": "Andika kazi ya C `float f_7(int base, int height)` kutatua tatizo lifuatalo:\nHesabu eneo la pembetatu ukitumia msingi wake na urefu.\n    Vigezo:\n- base (int): Urefu wa msingi wa pembetatu.\n- height (int): Urefu wa pembetatu.\n    Inarejesha:\n    float: Eneo lililohesabiwa la pembetatu, limezungushwa hadi sehemu moja ya desimali.\n    >>> f_7(1,2)\n    1.0", "tr": "Bir C fonksiyonu `float f_7(int base, int height)` yazın ve aşağıdaki problemi çözün:\nÜçgenin tabanı ve yüksekliği verildiğinde alanını hesaplayın.\n    Parametreler:\n- base (int): Üçgenin taban uzunluğu.\n- height (int): Üçgenin yüksekliği.\n    Döndürür:\n    float: Hesaplanan üçgen alanı, bir ondalık basamağa yuvarlanmış.\n    >>> f_7(1,2)\n    1.0", "vi": "Viết hàm C `float f_7(int base, int height)` để giải quyết vấn đề sau:\nTính diện tích của một tam giác khi biết đáy và chiều cao của nó.\n    Tham số:\n- base (int): Chiều dài đáy của tam giác.\n- height (int): Chiều cao của tam giác.\n    Trả về:\n    float: Diện tích đã tính của tam giác, được làm tròn đến một chữ số thập phân.\n    >>> f_7(1,2)\n    1.0", "id": "Tulis sebuah fungsi C `float f_7(int base, int height)` untuk menyelesaikan masalah berikut:\nHitung luas segitiga yang diberikan alas dan tingginya.\n    Parameter:\n- base (int): Panjang alas segitiga.\n- height (int): Tinggi segitiga.\n    Mengembalikan:\n    float: Luas segitiga yang dihitung, dibulatkan ke satu tempat desimal.\n    >>> f_7(1,2)\n    1.0", "ja": "Cの関数を書け `float f_7(int base, int height)` を作成して、次の問題を解決してください:\n三角形の底辺と高さが与えられたとき、その面積を計算します。\n    パラメータ:\n- base (int): 三角形の底辺の長さ。\n- height (int): 三角形の高さ。\n    戻り値:\n    float: 計算された三角形の面積を小数点以下1桁に丸めた値。\n    >>> f_7(1,2)\n    1.0", "ko": "C 함수 `float f_7(int base, int height)`를 작성하여 다음 문제를 해결하십시오:\n삼각형의 밑변과 높이가 주어졌을 때 삼각형의 면적을 계산합니다.\n    매개변수:\n- base (int): 삼각형의 밑변 길이.\n- height (int): 삼각형의 높이.\n    반환값:\n    float: 소수점 한 자리로 반올림된 삼각형의 계산된 면적.\n    >>> f_7(1,2)\n    1.0", "ml": "C ഭാഷയിൽ ഒരു ഫംഗ്ഷൻ `float f_7(int base, int height)` എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nഒരു ത്രികോണത്തിന്റെ അടിസ്ഥാനവും ഉയരവും നൽകിയാൽ അതിന്റെ വിസ്തീർണം കണക്കാക്കുക.\n    പാരാമീറ്ററുകൾ:\n- base (int): ത്രികോണത്തിന്റെ അടിസ്ഥാനത്തിന്റെ നീളം.\n- height (int): ത്രികോണത്തിന്റെ ഉയരം.\n    മടക്കുക:\n    float: കണക്കാക്കിയ ത്രികോണത്തിന്റെ വിസ്തീർണം, ഒരു ദശാംശസ്ഥാനം വരെ പരിമിതപ്പെടുത്തുക.\n    >>> f_7(1,2)\n    1.0", "fa": "یک تابع C بنویسید `float f_7(int base, int height)` برای حل مسئله زیر:\nمحاسبه مساحت یک مثلث با توجه به قاعده و ارتفاع آن.\n    پارامترها:\n- base (int): طول قاعده مثلث.\n- height (int): ارتفاع مثلث.\n    بازگشتی:\n    float: مساحت محاسبه شده مثلث، گرد شده به یک رقم اعشار.\n    >>> f_7(1,2)\n    1.0"}, "level": "easy", "test": "int main()\n{\n    // Adding more comprehensive test cases and correcting the expected values\n    assert(fabs(f_7(1, 2) - 1.0) < 1e-6); // Should assert true with close approximate comparison\n    assert(fabs(f_7(3, 4) - 6.0) < 1e-6); // Should assert true with close approximate comparison\n    assert(fabs(f_7(5, 8) - 20.0) < 1e-6); // Additional test case\n    assert(fabs(f_7(7, 3) - 10.5) < 1e-6); // Additional test case\n    assert(fabs(f_7(10, 10) - 50.0) < 1e-6); // Additional test case\n\n    // printf(\"All tests passed.\\n\");\n    return 0;\n}", "entry_point": "f_7", "signature": "float f_7(int base, int height)", "docstring": {"en": "Calculate the area of a triangle given its base and height.\n    Parameters:\n- base (int): The base length of the triangle.\n- height (int): The height of the triangle.\n    Returns:\n    float: The calculated area of the triangle, rounded to one decimal place.\n    >>> f_7(1,2)\n    1.0\n", "sq": "Llogarit sipërfaqen e një trekëndëshi duke pasur bazën dhe lartësinë e tij.\n    Parametrat:\n- base (int): Gjatësia e bazës së trekëndëshit.\n- height (int): Lartësia e trekëndëshit.\n    Kthen:\n    float: Sipërfaqja e llogaritur e trekëndëshit, e rrumbullakosur në një vend dhjetor.\n    >>> f_7(1,2)\n    1.0", "hy": "Հաշվել եռանկյան մակերեսը՝ հաշվի առնելով նրա հիմքը և բարձրությունը։\n    Պարամետրեր:\n- base (int): Եռանկյան հիմքի երկարությունը։\n- height (int): Եռանկյան բարձրությունը։\n    Վերադարձնում է:\n    float: Եռանկյան հաշվարկված մակերեսը՝ կլորացված մինչև մեկ տասնորդական։\n    >>> f_7(1,2)\n    1.0", "bn": "ত্রিভুজের ভিত্তি এবং উচ্চতা দেওয়া থাকলে এর ক্ষেত্রফল গণনা করুন।\n    Parameters:\n- base (int): ত্রিভুজের ভিত্তির দৈর্ঘ্য।\n- height (int): ত্রিভুজের উচ্চতা।\n    Returns:\n    float: ত্রিভুজের গণনা করা ক্ষেত্রফল, এক দশমিক স্থান পর্যন্ত গোলাকার।\n    >>> f_7(1,2)\n    1.0", "bg": "Изчисляване на лицето на триъгълник, дадени са основата и височината му.\n    Параметри:\n- base (int): Дължината на основата на триъгълника.\n- height (int): Височината на триъгълника.\n    Връща:\n    float: Изчисленото лице на триъгълника, закръглено до първия знак след десетичната запетая.\n    >>> f_7(1,2)\n    1.0", "zh": "计算给定底边和高的三角形面积。\n    参数:\n- base (int): 三角形的底边长度。\n- height (int): 三角形的高度。\n    返回:\n    float: 计算出的三角形面积，四舍五入到小数点后一位。\n    >>> f_7(1,2)\n    1.0", "fr": "Calculer l'aire d'un triangle donné sa base et sa hauteur.\n    Paramètres:\n- base (int): La longueur de la base du triangle.\n- height (int): La hauteur du triangle.\n    Renvoie:\n    float: L'aire calculée du triangle, arrondie à un chiffre après la virgule.\n    >>> f_7(1,2)\n    1.0", "de": "Berechnen Sie die Fläche eines Dreiecks anhand seiner Basis und Höhe.\n    Parameter:\n- base (int): Die Basislänge des Dreiecks.\n- height (int): Die Höhe des Dreiecks.\n    Rückgabewerte:\n    float: Die berechnete Fläche des Dreiecks, auf eine Dezimalstelle gerundet.\n    >>> f_7(1,2)\n    1.0", "ha": "Ƙididdige yanki na alwatika la'akari da tushenta da tsayinta.\n    Sigogi:\n- base (int): Tsawon tushe na alwatika.\n- height (int): Tsawon tsawo na alwatika.\n    Returns:\n    float: An lissafa yankin alwatika, an zagaye zuwa wuri daya na goma.\n    >>> f_7(1,2)\n    1.0", "hi": "त्रिभुज का क्षेत्रफल इसकी आधार और ऊँचाई के आधार पर गणना करें।\n    पैरामीटर्स:\n- base (int): त्रिभुज की आधार लंबाई।\n- height (int): त्रिभुज की ऊँचाई।\n    रिटर्न्स:\n    float: त्रिभुज का गणना किया गया क्षेत्रफल, एक दशमलव स्थान तक गोल किया गया।\n    >>> f_7(1,2)\n    1.0", "hu": "Számítsa ki a háromszög területét az alapja és magassága alapján.\n    Paraméterek:\n- base (int): A háromszög alapjának hossza.\n- height (int): A háromszög magassága.\n    Visszatér:\n    float: A háromszög kiszámított területe, egy tizedesjegyre kerekítve.\n    >>> f_7(1,2)\n    1.0", "es": "Calcular el área de un triángulo dado su base y altura.\n    Parámetros:\n- base (int): La longitud de la base del triángulo.\n- height (int): La altura del triángulo.\n    Devuelve:\n    float: El área calculada del triángulo, redondeada a un decimal.\n    >>> f_7(1,2)\n    1.0", "arb": "حساب مساحة المثلث بناءً على قاعدته وارتفاعه.\n    المعلمات:\n- base (int): طول قاعدة المثلث.\n- height (int): ارتفاع المثلث.\n    يعيد:\n    float: المساحة المحسوبة للمثلث، مقربة إلى منزلة عشرية واحدة.\n    >>> f_7(1,2)\n    1.0", "sw": "Hesabu eneo la pembetatu ukitumia msingi na urefu wake.\n    Vigezo:\n- base (int): Urefu wa msingi wa pembetatu.\n- height (int): Urefu wa pembetatu.\n    Inarejesha:\n    float: Eneo lililohesabiwa la pembetatu, limezungushwa hadi sehemu moja ya desimali.\n    >>> f_7(1,2)\n    1.0", "tr": "Üçgenin taban uzunluğu ve yüksekliği verildiğinde alanını hesaplayın.\n    Parametreler:\n- base (int): Üçgenin taban uzunluğu.\n- height (int): Üçgenin yüksekliği.\n    Döndürülen:\n    float: Üçgenin hesaplanan alanı, bir ondalık basamağa yuvarlanmış olarak.\n    >>> f_7(1,2)\n    1.0", "vi": "Tính diện tích của một tam giác dựa trên độ dài đáy và chiều cao của nó.\n    Tham số:\n- base (int): Độ dài đáy của tam giác.\n- height (int): Chiều cao của tam giác.\n    Trả về:\n    float: Diện tích được tính của tam giác, làm tròn đến một chữ số thập phân.\n    >>> f_7(1,2)\n    1.0", "id": "Hitung luas segitiga yang diberikan alas dan tingginya.\n    Parameter:\n- base (int): Panjang alas segitiga.\n- height (int): Tinggi segitiga.\n    Mengembalikan:\n    float: Luas segitiga yang dihitung, dibulatkan ke satu tempat desimal.\n    >>> f_7(1,2)\n    1.0", "ja": "三角形の面積を、その底辺と高さを指定して計算します。\n    パラメータ:\n- base (int): 三角形の底辺の長さ。\n- height (int): 三角形の高さ。\n    戻り値:\n    float: 計算された三角形の面積を小数点以下1桁に丸めた値。\n    >>> f_7(1,2)\n    1.0", "ko": "삼각형의 밑변과 높이가 주어졌을 때, 삼각형의 넓이를 계산합니다.\n    매개변수:\n- base (int): 삼각형의 밑변 길이.\n- height (int): 삼각형의 높이.\n    반환값:\n    float: 소수점 첫째 자리까지 반올림된 삼각형의 계산된 넓이.\n    >>> f_7(1,2)\n    1.0", "ml": "ത്രികോണത്തിന്റെ അടിസ്ഥാനവും ഉയരവും നൽകിയാൽ അതിന്റെ വിസ്തീർണ്ണം കണക്കാക്കുക.\n    പാരാമീറ്ററുകൾ:\n- base (int): ത്രികോണത്തിന്റെ അടിസ്ഥാനത്തിന്റെ നീളം.\n- height (int): ത്രികോണത്തിന്റെ ഉയരം.\n    മടക്കങ്ങൾ:\n    float: ഒരു ദശാംശ സ്ഥാനത്തേക്ക് വട്ടമിട്ട ത്രികോണത്തിന്റെ കണക്കാക്കിയ വിസ്തീർണ്ണം.\n    >>> f_7(1,2)\n    1.0", "fa": "محاسبه مساحت یک مثلث با توجه به قاعده و ارتفاع آن.\n\nپارامترها:\n- base (int): طول قاعده مثلث.\n- height (int): ارتفاع مثلث.\n\nبازگشت:\nfloat: مساحت محاسبه شده مثلث، گرد شده به یک رقم اعشار.\n\n>>> f_7(1,2)\n1.0"}}
{"task_id": "C/8", "prompt": {"en": "#include <assert.h>\n#include <stdio.h>\n/*\nCalculate the Hamming distance between two integers in binary representation.\n​    Parameters:\n- x (int): The first positive integer (x <= 1,000,000,000).\n- y (int): The second positive integer (y <= 1,000,000,000).\n​    Returns:\n​    int: The Hamming distance between x and y, i.e., the number of bits that need to be flipped\n​         to transform x into y in binary.\n\t>>> f_8(1,2)\n\t2\n*/\nint f_8(int x, int y)", "sq": "#include <assert.h>\n#include <stdio.h>\n/*\nLlogarit distancën Hamming midis dy numrave të plotë në përfaqësimin binar.\n​    Parametrat:\n- x (int): Numri i parë pozitiv (x <= 1,000,000,000).\n- y (int): Numri i dytë pozitiv (y <= 1,000,000,000).\n​    Kthen:\n​    int: Distanca Hamming midis x dhe y, dmth, numri i biteve që duhet të ndryshohen\n​         për të transformuar x në y në binar.\n\t>>> f_8(1,2)\n\t2\n*/\nint f_8(int x, int y)", "hy": "#include <assert.h>\n#include <stdio.h>\n/*\nՀաշվել Հեմինգի հեռավորությունը երկու ամբողջ թվերի միջև երկբայական ներկայացմամբ։\n​    Պարամետրեր:\n- x (int): Առաջին դրական ամբողջ թիվը (x <= 1,000,000,000)։\n- y (int): Երկրորդ դրական ամբողջ թիվը (y <= 1,000,000,000)։\n​    Վերադարձնում է:\n​    int: Հեմինգի հեռավորությունը x-ի և y-ի միջև, այսինքն՝ այն բիթերի քանակը, որոնք պետք է փոխել\n​         x-ը y-ի վերածելու համար երկբայականում։\n\t>>> f_8(1,2)\n\t2\n*/\nint f_8(int x, int y)", "bn": "#include <assert.h>\n#include <stdio.h>\n/*\nদুটি পূর্ণসংখ্যার বাইনারি উপস্থাপনার মধ্যে হ্যামিং দূরত্ব গণনা করুন।\n​    প্যারামিটারসমূহ:\n- x (int): প্রথম ধনাত্মক পূর্ণসংখ্যা (x <= 1,000,000,000)।\n- y (int): দ্বিতীয় ধনাত্মক পূর্ণসংখ্যা (y <= 1,000,000,000)।\n​    রিটার্ন:\n​    int: x এবং y এর মধ্যে হ্যামিং দূরত্ব, অর্থাৎ x কে বাইনারিতে y তে রূপান্তর করতে যে সংখ্যক বিট পরিবর্তন করতে হবে।\n\t>>> f_8(1,2)\n\t2\n*/\nint f_8(int x, int y)", "bg": "#include <assert.h>\n#include <stdio.h>\n/*\nИзчисляване на разстоянието на Хаминг между две цели числа в двоична форма.\n​    Параметри:\n- x (int): Първото положително цяло число (x <= 1,000,000,000).\n- y (int): Второто положително цяло число (y <= 1,000,000,000).\n​    Връща:\n​    int: Разстоянието на Хаминг между x и y, т.е. броят на битовете, които трябва да бъдат обърнати,\n​         за да се трансформира x в y в двоична форма.\n\t>>> f_8(1,2)\n\t2\n*/\nint f_8(int x, int y)", "zh": "#include <assert.h>\n#include <stdio.h>\n/*\n计算两个整数在二进制表示下的汉明距离。\n​    参数:\n- x (int): 第一个正整数 (x <= 1,000,000,000)。\n- y (int): 第二个正整数 (y <= 1,000,000,000)。\n​    返回:\n​    int: x 和 y 之间的汉明距离，即需要翻转的位数以将 x 转换为二进制的 y。\n\t>>> f_8(1,2)\n\t2\n*/\nint f_8(int x, int y)", "fr": "#include <assert.h>\n#include <stdio.h>\n/*\nCalculer la distance de Hamming entre deux entiers en représentation binaire.\n    Paramètres:\n- x (int): Le premier entier positif (x <= 1,000,000,000).\n- y (int): Le deuxième entier positif (y <= 1,000,000,000).\n    Renvoie:\n    int: La distance de Hamming entre x et y, c'est-à-dire le nombre de bits qui doivent être inversés\n         pour transformer x en y en binaire.\n\t>>> f_8(1,2)\n\t2\n*/\nint f_8(int x, int y)", "de": "#include <assert.h>\n#include <stdio.h>\n/*\nBerechne die Hamming-Distanz zwischen zwei ganzen Zahlen in binärer Darstellung.\n​    Parameter:\n- x (int): Die erste positive ganze Zahl (x <= 1,000,000,000).\n- y (int): Die zweite positive ganze Zahl (y <= 1,000,000,000).\n​    Rückgabe:\n​    int: Die Hamming-Distanz zwischen x und y, d.h., die Anzahl der Bits, die umgeklappt werden müssen,\n​         um x in y in binärer Form zu transformieren.\n\t>>> f_8(1,2)\n\t2\n*/\nint f_8(int x, int y)", "ha": "#include <assert.h>\n#include <stdio.h>\n/*\nƘididdige nisan Hamming tsakanin lambobi biyu a cikin wakilcin binary.\n​    Sigogi:\n- x (int): Lamba ta farko mai kyau (x <= 1,000,000,000).\n- y (int): Lamba ta biyu mai kyau (y <= 1,000,000,000).\n​    Komawa:\n​    int: Nisan Hamming tsakanin x da y, wato, adadin bits da ake buƙatar juyawa\n​         don sauya x zuwa y a cikin binary.\n\t>>> f_8(1,2)\n\t2\n*/\nint f_8(int x, int y)", "hi": "#include <assert.h>\n#include <stdio.h>\n/*\nदो पूर्णांकों के द्विआधारी प्रतिनिधित्व के बीच हैमिंग दूरी की गणना करें।\n    पैरामीटर्स:\n- x (int): पहला धनात्मक पूर्णांक (x <= 1,000,000,000)।\n- y (int): दूसरा धनात्मक पूर्णांक (y <= 1,000,000,000)।\n    रिटर्न्स:\n    int: x और y के बीच हैमिंग दूरी, अर्थात् उन बिट्स की संख्या जिन्हें x को y में बदलने के लिए फ्लिप करना आवश्यक है\n         द्विआधारी में।\n\t>>> f_8(1,2)\n\t2\n*/\nint f_8(int x, int y)", "hu": "#include <assert.h>\n#include <stdio.h>\n/*\nSzámítsa ki a Hamming-távolságot két egész szám bináris ábrázolása között.\n​    Paraméterek:\n- x (int): Az első pozitív egész szám (x <= 1,000,000,000).\n- y (int): A második pozitív egész szám (y <= 1,000,000,000).\n​    Visszatér:\n​    int: A Hamming-távolság x és y között, azaz a bitek száma, amelyeket meg kell változtatni\n​         ahhoz, hogy x-et y-ra alakítsuk binárisan.\n\t>>> f_8(1,2)\n\t2\n*/\nint f_8(int x, int y)", "es": "#include <assert.h>\n#include <stdio.h>\n/*\nCalcular la distancia de Hamming entre dos enteros en representación binaria.\n    Parámetros:\n- x (int): El primer entero positivo (x <= 1,000,000,000).\n- y (int): El segundo entero positivo (y <= 1,000,000,000).\n    Retorna:\n    int: La distancia de Hamming entre x e y, es decir, el número de bits que necesitan ser cambiados\n         para transformar x en y en binario.\n\t>>> f_8(1,2)\n\t2\n*/\nint f_8(int x, int y)", "arb": "#include <assert.h>\n#include <stdio.h>\n/*\nاحسب مسافة هامنج بين عددين صحيحين في التمثيل الثنائي.\n    المعاملات:\n- x (int): العدد الصحيح الأول الموجب (x <= 1,000,000,000).\n- y (int): العدد الصحيح الثاني الموجب (y <= 1,000,000,000).\n    يعيد:\n    int: مسافة هامنج بين x و y، أي عدد البتات التي تحتاج إلى قلب\n         لتحويل x إلى y في النظام الثنائي.\n\t>>> f_8(1,2)\n\t2\n*/\nint f_8(int x, int y)", "sw": "#include <assert.h>\n#include <stdio.h>\n/*\nHesabu umbali wa Hamming kati ya nambari mbili katika uwakilishi wa binary.\n​    Vigezo:\n- x (int): Nambari ya kwanza chanya (x <= 1,000,000,000).\n- y (int): Nambari ya pili chanya (y <= 1,000,000,000).\n​    Inarudisha:\n​    int: Umbali wa Hamming kati ya x na y, yaani, idadi ya biti zinazohitajika kubadilishwa\n​         ili kubadilisha x kuwa y katika binary.\n\t>>> f_8(1,2)\n\t2\n*/\nint f_8(int x, int y)", "tr": "#include <assert.h>\n#include <stdio.h>\n/*\nİki tam sayı arasındaki Hamming mesafesini ikili gösterimde hesaplayın.\n​    Parametreler:\n- x (int): İlk pozitif tam sayı (x <= 1,000,000,000).\n- y (int): İkinci pozitif tam sayı (y <= 1,000,000,000).\n​    Döndürür:\n​    int: x ve y arasındaki Hamming mesafesi, yani x'i ikili olarak y'ye dönüştürmek için çevrilmesi gereken bit sayısı.\n\t>>> f_8(1,2)\n\t2\n*/\nint f_8(int x, int y)", "vi": "#include <assert.h>\n#include <stdio.h>\n/*\nTính khoảng cách Hamming giữa hai số nguyên trong biểu diễn nhị phân.\n    Tham số:\n- x (int): Số nguyên dương thứ nhất (x <= 1,000,000,000).\n- y (int): Số nguyên dương thứ hai (y <= 1,000,000,000).\n    Trả về:\n    int: Khoảng cách Hamming giữa x và y, tức là số bit cần phải thay đổi\n         để biến đổi x thành y trong nhị phân.\n\t>>> f_8(1,2)\n\t2\n*/\nint f_8(int x, int y)", "id": "#include <assert.h>\n#include <stdio.h>\n/*\nMenghitung jarak Hamming antara dua bilangan bulat dalam representasi biner.\n​    Parameter:\n- x (int): Bilangan bulat positif pertama (x <= 1,000,000,000).\n- y (int): Bilangan bulat positif kedua (y <= 1,000,000,000).\n​    Mengembalikan:\n​    int: Jarak Hamming antara x dan y, yaitu jumlah bit yang perlu dibalik\n​         untuk mengubah x menjadi y dalam biner.\n\t>>> f_8(1,2)\n\t2\n*/\nint f_8(int x, int y)", "ja": "#include <assert.h>\n#include <stdio.h>\n/*\n2つの整数の2進数表現におけるハミング距離を計算します。\n​    パラメータ:\n- x (int): 最初の正の整数 (x <= 1,000,000,000)。\n- y (int): 2番目の正の整数 (y <= 1,000,000,000)。\n​    戻り値:\n​    int: xとyの間のハミング距離、すなわち、xを2進数でyに変換するために反転する必要があるビットの数。\n\t>>> f_8(1,2)\n\t2\n*/\nint f_8(int x, int y)", "ko": "#include <assert.h>\n#include <stdio.h>\n/*\n두 정수를 이진 표현으로 변환하여 해밍 거리를 계산합니다.\n    매개변수:\n- x (int): 첫 번째 양의 정수 (x <= 1,000,000,000).\n- y (int): 두 번째 양의 정수 (y <= 1,000,000,000).\n    반환값:\n    int: x와 y 사이의 해밍 거리, 즉 x를 이진수로 y로 변환하기 위해 뒤집어야 하는 비트의 수.\n\t>>> f_8(1,2)\n\t2\n*/\nint f_8(int x, int y)", "ml": "#include <assert.h>\n#include <stdio.h>\n/*\nരണ്ട് പൂർണ്ണസംഖ്യകളുടെ ബൈനറി പ്രതിനിധാനത്തിലുള്ള ഹാമിംഗ് ദൂരം കണക്കാക്കുക.\n    പാരാമീറ്ററുകൾ:\n- x (int): ആദ്യത്തെ പോസിറ്റീവ് പൂർണ്ണസംഖ്യ (x <= 1,000,000,000).\n- y (int): രണ്ടാം പോസിറ്റീവ് പൂർണ്ണസംഖ്യ (y <= 1,000,000,000).\n    തിരികെ നൽകുന്നു:\n    int: x നെ y ആക്കി മാറ്റാൻ ആവശ്യമായ ബിറ്റുകളുടെ എണ്ണം, അഥവാ x നും y നും ഇടയിലെ ഹാമിംഗ് ദൂരം.\n\t>>> f_8(1,2)\n\t2\n*/\nint f_8(int x, int y)", "fa": "#include <assert.h>\n#include <stdio.h>\n/*\nمحاسبه فاصله همینگ بین دو عدد صحیح در نمایش باینری.\n​    پارامترها:\n- x (int): اولین عدد صحیح مثبت (x <= 1,000,000,000).\n- y (int): دومین عدد صحیح مثبت (y <= 1,000,000,000).\n​    بازگشت:\n​    int: فاصله همینگ بین x و y، یعنی تعداد بیت‌هایی که باید تغییر کنند\n​         تا x به y در باینری تبدیل شود.\n\t>>> f_8(1,2)\n\t2\n*/\nint f_8(int x, int y)"}, "canonical_solution": "{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}", "instruction": {"en": "Write a C function `int f_8(int x, int y)` to solve the following problem:\nCalculate the Hamming distance between two integers in binary representation.\n    Parameters:\n- x (int): The first positive integer (x <= 1,000,000,000).\n- y (int): The second positive integer (y <= 1,000,000,000).\n    Returns:\n    int: The Hamming distance between x and y, i.e., the number of bits that need to be flipped to transform x into y in binary.\n    >>> f_8(1,2)\n    2\n", "sq": "Shkruani një funksion në C `int f_8(int x, int y)` për të zgjidhur problemin në vijim:\nLlogaritni distancën Hamming midis dy numrave të plotë në përfaqësimin binar.\n    Parametrat:\n- x (int): Numri i parë pozitiv (x <= 1,000,000,000).\n- y (int): Numri i dytë pozitiv (y <= 1,000,000,000).\n    Kthen:\n    int: Distanca Hamming midis x dhe y, dmth, numri i biteve që duhet të ndryshohen për të transformuar x në y në binar.\n    >>> f_8(1,2)\n    2", "hy": "Գրեք C ֆունկցիա `int f_8(int x, int y)` հետևյալ խնդիրը լուծելու համար:\nՀաշվեք Հեմինգի հեռավորությունը երկու ամբողջ թվերի միջև երկբայն ներկայացման մեջ։\n    Պարամետրեր:\n- x (int): Առաջին դրական ամբողջ թիվը (x <= 1,000,000,000)։\n- y (int): Երկրորդ դրական ամբողջ թիվը (y <= 1,000,000,000)։\n    Վերադարձնում է:\n    int: Հեմինգի հեռավորությունը x-ի և y-ի միջև, այսինքն՝ բիթերի քանակը, որոնք պետք է փոխվեն՝ x-ը y-ի վերածելու համար երկբայն։\n    >>> f_8(1,2)\n    2", "bn": "একটি C ফাংশন `int f_8(int x, int y)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nদুটি পূর্ণসংখ্যার বাইনারি উপস্থাপনার মধ্যে হ্যামিং দূরত্ব গণনা করুন।\n    প্যারামিটারসমূহ:\n- x (int): প্রথম ধনাত্মক পূর্ণসংখ্যা (x <= 1,000,000,000)।\n- y (int): দ্বিতীয় ধনাত্মক পূর্ণসংখ্যা (y <= 1,000,000,000)।\n    রিটার্নস:\n    int: x এবং y এর মধ্যে হ্যামিং দূরত্ব, অর্থাৎ x কে বাইনারিতে y তে রূপান্তর করতে যে সংখ্যক বিট পরিবর্তন করতে হবে।\n    >>> f_8(1,2)\n    2", "bg": "Напишете C функция `int f_8(int x, int y)` за решаване на следния проблем:\nИзчислете разстоянието на Хаминг между две цели числа в двоично представяне.\n    Параметри:\n- x (int): Първото положително цяло число (x <= 1,000,000,000).\n- y (int): Второто положително цяло число (y <= 1,000,000,000).\n    Връща:\n    int: Разстоянието на Хаминг между x и y, т.е. броят на битовете, които трябва да бъдат обърнати, за да се трансформира x в y в двоичен вид.\n    >>> f_8(1,2)\n    2", "zh": "编写一个 C 函数 `int f_8(int x, int y)` 来解决以下问题：\n计算两个整数在二进制表示中的汉明距离。  \n参数：  \n- x (int): 第一个正整数 (x <= 1,000,000,000)。  \n- y (int): 第二个正整数 (y <= 1,000,000,000)。  \n返回：  \nint: x 和 y 之间的汉明距离，即需要翻转的位数以将 x 转换为二进制中的 y。  \n>>> f_8(1,2)  \n2  ", "fr": "Écrivez une fonction C `int f_8(int x, int y)` pour résoudre le problème suivant :\nCalculer la distance de Hamming entre deux entiers en représentation binaire.\n    Paramètres :\n- x (int) : Le premier entier positif (x <= 1,000,000,000).\n- y (int) : Le deuxième entier positif (y <= 1,000,000,000).\n    Renvoie :\n    int : La distance de Hamming entre x et y, c'est-à-dire le nombre de bits qui doivent être inversés pour transformer x en y en binaire.\n    >>> f_8(1,2)\n    2", "de": "Schreiben Sie eine C-Funktion `int f_8(int x, int y)`, um das folgende Problem zu lösen:\nBerechnen Sie den Hamming-Abstand zwischen zwei ganzen Zahlen in binärer Darstellung.\n    Parameter:\n- x (int): Die erste positive ganze Zahl (x <= 1,000,000,000).\n- y (int): Die zweite positive ganze Zahl (y <= 1,000,000,000).\n    Rückgabewert:\n    int: Der Hamming-Abstand zwischen x und y, d.h., die Anzahl der Bits, die umgekehrt werden müssen, um x in y in binärer Form zu transformieren.\n    >>> f_8(1,2)\n    2", "ha": "Rubuta aikin C `int f_8(int x, int y)` don warware matsalar mai zuwa:\nƘididdige nisan Hamming tsakanin lambobi biyu a cikin wakilcin binary.  \n   Sigogi:  \n- x (int): Lamba ta farko mai kyau (x <= 1,000,000,000).  \n- y (int): Lamba ta biyu mai kyau (y <= 1,000,000,000).  \n   Dawowa:  \n   int: Nisan Hamming tsakanin x da y, wato, adadin bits da ake buƙatar juyawa don canza x zuwa y a cikin binary.  \n    >>> f_8(1,2)  \n    2  ", "hi": "C फ़ंक्शन `int f_8(int x, int y)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदो पूर्णांकों के द्विआधारी अभ्यावेदन में हैमिंग दूरी की गणना करें।\n    पैरामीटर्स:\n- x (int): पहला धनात्मक पूर्णांक (x <= 1,000,000,000)।\n- y (int): दूसरा धनात्मक पूर्णांक (y <= 1,000,000,000)।\n    रिटर्न्स:\n    int: x और y के बीच हैमिंग दूरी, अर्थात्, x को y में परिवर्तित करने के लिए द्विआधारी में जितने बिट्स को फ्लिप करने की आवश्यकता होती है।\n    >>> f_8(1,2)\n    2", "hu": "Írj egy C függvényt `int f_8(int x, int y)` a következő probléma megoldására:\nSzámítsd ki a Hamming-távolságot két egész szám bináris ábrázolása között.\n    Paraméterek:\n- x (int): Az első pozitív egész szám (x <= 1,000,000,000).\n- y (int): A második pozitív egész szám (y <= 1,000,000,000).\n    Visszatérési érték:\n    int: A Hamming-távolság x és y között, azaz a bitek száma, amelyeket meg kell változtatni ahhoz, hogy x-ből y-t kapjunk binárisan.\n    >>> f_8(1,2)\n    2", "es": "Escribe una función en C `int f_8(int x, int y)` para resolver el siguiente problema:\nCalcular la distancia de Hamming entre dos enteros en representación binaria.\n    Parámetros:\n- x (int): El primer entero positivo (x <= 1,000,000,000).\n- y (int): El segundo entero positivo (y <= 1,000,000,000).\n    Retorna:\n    int: La distancia de Hamming entre x e y, es decir, el número de bits que necesitan ser cambiados para transformar x en y en binario.\n    >>> f_8(1,2)\n    2", "arb": "اكتب دالة بلغة C `int f_8(int x, int y)` لحل المشكلة التالية:\nاحسب مسافة هامنج بين عددين صحيحين في التمثيل الثنائي.\n    المعاملات:\n- x (int): العدد الصحيح الأول الموجب (x <= 1,000,000,000).\n- y (int): العدد الصحيح الثاني الموجب (y <= 1,000,000,000).\n    يعيد:\n    int: مسافة هامنج بين x و y، أي عدد البتات التي تحتاج إلى التغيير لتحويل x إلى y في النظام الثنائي.\n    >>> f_8(1,2)\n    2", "sw": "Andika kazi ya C `int f_8(int x, int y)` kutatua tatizo lifuatalo:\nHesabu umbali wa Hamming kati ya nambari mbili katika uwakilishi wa binary.\n    Vigezo:\n- x (int): Nambari ya kwanza chanya (x <= 1,000,000,000).\n- y (int): Nambari ya pili chanya (y <= 1,000,000,000).\n    Inarejesha:\n    int: Umbali wa Hamming kati ya x na y, yaani, idadi ya biti zinazohitaji kubadilishwa ili kubadilisha x kuwa y katika binary.\n    >>> f_8(1,2)\n    2", "tr": "Bir C fonksiyonu `int f_8(int x, int y)` yazın:\nİki tam sayının ikili gösteriminde Hamming mesafesini hesaplayın.\n    Parametreler:\n- x (int): İlk pozitif tam sayı (x <= 1,000,000,000).\n- y (int): İkinci pozitif tam sayı (y <= 1,000,000,000).\n    Döndürür:\n    int: x ve y arasındaki Hamming mesafesi, yani x'i ikili olarak y'ye dönüştürmek için çevrilmesi gereken bit sayısı.\n    >>> f_8(1,2)\n    2", "vi": "Viết một hàm C `int f_8(int x, int y)` để giải quyết vấn đề sau:\nTính khoảng cách Hamming giữa hai số nguyên trong biểu diễn nhị phân.\n    Tham số:\n- x (int): Số nguyên dương thứ nhất (x <= 1,000,000,000).\n- y (int): Số nguyên dương thứ hai (y <= 1,000,000,000).\n    Trả về:\n    int: Khoảng cách Hamming giữa x và y, tức là số bit cần phải thay đổi để biến đổi x thành y trong nhị phân.\n    >>> f_8(1,2)\n    2", "id": "Tulis fungsi C `int f_8(int x, int y)` untuk menyelesaikan masalah berikut:\nHitung jarak Hamming antara dua bilangan bulat dalam representasi biner.\n    Parameter:\n- x (int): Bilangan bulat positif pertama (x <= 1,000,000,000).\n- y (int): Bilangan bulat positif kedua (y <= 1,000,000,000).\n    Mengembalikan:\n    int: Jarak Hamming antara x dan y, yaitu jumlah bit yang perlu dibalik untuk mengubah x menjadi y dalam biner.\n    >>> f_8(1,2)\n    2", "ja": "Cの関数を書け `int f_8(int x, int y)` を作成して、次の問題を解決してください:\n2つの整数の2進数表現におけるハミング距離を計算します。\n    パラメータ:\n- x (int): 最初の正の整数 (x <= 1,000,000,000)。\n- y (int): 2番目の正の整数 (y <= 1,000,000,000)。\n    戻り値:\n    int: xとyのハミング距離、すなわち、xを2進数でyに変換するために反転する必要があるビットの数。\n    >>> f_8(1,2)\n    2", "ko": "C 함수 `int f_8(int x, int y)`를 작성하여 다음 문제를 해결하십시오:\n두 정수의 이진 표현에서 해밍 거리를 계산합니다.\n    매개변수:\n- x (int): 첫 번째 양의 정수 (x <= 1,000,000,000).\n- y (int): 두 번째 양의 정수 (y <= 1,000,000,000).\n    반환값:\n    int: x와 y 사이의 해밍 거리, 즉 이진수에서 x를 y로 변환하기 위해 뒤집어야 하는 비트 수.\n    >>> f_8(1,2)\n    2", "ml": "C ഫംഗ്ഷൻ `int f_8(int x, int y)` എഴുതുക താഴെ കൊടുത്തിരിക്കുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nരണ്ടു പൂർണ്ണസംഖ്യകളുടെ ബൈനറി പ്രതിനിധാനത്തിൽ ഹാമിംഗ് ദൂരം കണക്കാക്കുക.\n    പാരാമീറ്ററുകൾ:\n- x (int): ആദ്യത്തെ പോസിറ്റീവ് പൂർണ്ണസംഖ്യ (x <= 1,000,000,000).\n- y (int): രണ്ടാമത്തെ പോസിറ്റീവ് പൂർണ്ണസംഖ്യ (y <= 1,000,000,000).\n    മടക്കുന്നു:\n    int: x നും y നും ഇടയിലെ ഹാമിംഗ് ദൂരം, അതായത്, ബൈനറിയിൽ x നെ y ആക്കാൻ മാറ്റേണ്ട ബിറ്റുകളുടെ എണ്ണം.\n    >>> f_8(1,2)\n    2", "fa": "یک تابع C `int f_8(int x, int y)` بنویسید تا مسئله زیر را حل کند:\nفاصله همینگ بین دو عدد صحیح در نمایش دودویی را محاسبه کنید.\nپارامترها:\n- x (int): اولین عدد صحیح مثبت (x <= 1,000,000,000).\n- y (int): دومین عدد صحیح مثبت (y <= 1,000,000,000).\nبازگشت:\nint: فاصله همینگ بین x و y، یعنی تعداد بیت‌هایی که باید برای تبدیل x به y در دودویی تغییر کنند.\n    >>> f_8(1,2)\n    2"}, "level": "middle", "test": "int main() {\n    assert(f_8(1, 2) == 2); // 01 and 10 have 2 different bits\n    assert(f_8(4, 7) == 2); // 100 and 111 have 2 different bits\n    assert(f_8(25, 30) == 3); // Additional test: 11001 and 11110 have 3 different bits\n    assert(f_8(0, 0) == 0); // Additional test: Same numbers have 0 different bits\n    assert(f_8(0xFFFFFFF, 0x0000000) == 28); // Additional test: Max unsigned int and 0 have 32 different bits\n    return 0;\n}", "entry_point": "f_8", "signature": "int f_8(int x, int y)", "docstring": {"en": "Calculate the Hamming distance between two integers in binary representation.\n    Parameters:\n- x (int): The first positive integer (x <= 1,000,000,000).\n- y (int): The second positive integer (y <= 1,000,000,000).\n    Returns:\n    int: The Hamming distance between x and y, i.e., the number of bits that need to be flipped to transform x into y in binary.\n    >>> f_8(1,2)\n    2\n", "sq": "Llogarit distancën Hamming midis dy numrave të plotë në përfaqësimin binar.\n    Parametrat:\n- x (int): Numri i parë pozitiv (x <= 1,000,000,000).\n- y (int): Numri i dytë pozitiv (y <= 1,000,000,000).\n    Kthen:\n    int: Distanca Hamming midis x dhe y, dmth numri i biteve që duhet të ndryshohen për të transformuar x në y në binar.\n    >>> f_8(1,2)\n    2", "hy": "Հաշվարկել Հեմմինգի հեռավորությունը երկու ամբողջ թվերի միջև երկբայական ներկայացմամբ։\n    Պարամետրեր:\n- x (int): Առաջին դրական ամբողջ թիվը (x <= 1,000,000,000)։\n- y (int): Երկրորդ դրական ամբողջ թիվը (y <= 1,000,000,000)։\n    Վերադարձնում է:\n    int: Հեմմինգի հեռավորությունը x-ի և y-ի միջև, այսինքն՝ բիթերի քանակը, որոնք պետք է փոխել՝ x-ը y-ի վերածելու համար երկբայականում։\n    >>> f_8(1,2)\n    2", "bn": "দুটি পূর্ণসংখ্যার মধ্যে বাইনারি উপস্থাপনায় হ্যামিং দূরত্ব গণনা করুন।\n    প্যারামিটারসমূহ:\n- x (int): প্রথম ধনাত্মক পূর্ণসংখ্যা (x <= 1,000,000,000)।\n- y (int): দ্বিতীয় ধনাত্মক পূর্ণসংখ্যা (y <= 1,000,000,000)।\n    রিটার্নস:\n    int: x এবং y এর মধ্যে হ্যামিং দূরত্ব, অর্থাৎ x কে বাইনারিতে y তে রূপান্তর করতে যে সংখ্যক বিট পরিবর্তন করতে হবে।\n    >>> f_8(1,2)\n    2", "bg": "Изчисляване на разстоянието на Хаминг между две цели числа в двоична форма.\n    Параметри:\n- x (int): Първото положително цяло число (x <= 1,000,000,000).\n- y (int): Второто положително цяло число (y <= 1,000,000,000).\n    Връща:\n    int: Разстоянието на Хаминг между x и y, т.е. броят на битовете, които трябва да бъдат променени, за да се преобразува x в y в двоична форма.\n    >>> f_8(1,2)\n    2", "zh": "计算两个整数在二进制表示下的汉明距离。\n    参数：\n- x (int): 第一个正整数 (x <= 1,000,000,000)。\n- y (int): 第二个正整数 (y <= 1,000,000,000)。\n    返回：\n    int: x 和 y 之间的汉明距离，即将 x 转换为 y 所需翻转的位数。\n    >>> f_8(1,2)\n    2", "fr": "Calculer la distance de Hamming entre deux entiers en représentation binaire.\n    Paramètres:\n- x (int): Le premier entier positif (x <= 1,000,000,000).\n- y (int): Le deuxième entier positif (y <= 1,000,000,000).\n    Renvoie:\n    int: La distance de Hamming entre x et y, c'est-à-dire le nombre de bits qui doivent être inversés pour transformer x en y en binaire.\n    >>> f_8(1,2)\n    2", "de": "Berechne die Hamming-Distanz zwischen zwei ganzen Zahlen in binärer Darstellung.\n    Parameter:\n- x (int): Die erste positive ganze Zahl (x <= 1.000.000.000).\n- y (int): Die zweite positive ganze Zahl (y <= 1.000.000.000).\n    Rückgabewert:\n    int: Die Hamming-Distanz zwischen x und y, d.h., die Anzahl der Bits, die umgekehrt werden müssen, um x in y in binär zu transformieren.\n    >>> f_8(1,2)\n    2", "ha": "Ƙididdige nisan Hamming tsakanin lambobi biyu a cikin wakilcin binary.\n    Parameters:\n- x (int): Lamba ta farko mai kyau (x <= 1,000,000,000).\n- y (int): Lamba ta biyu mai kyau (y <= 1,000,000,000).\n    Returns:\n    int: Hamming distance tsakanin x da y, wato, yawan bits da ake buƙatar juyawa don canza x zuwa y a binary.\n    >>> f_8(1,2)\n    2", "hi": "दो पूर्णांकों के बीच बाइनरी प्रतिनिधित्व में हैमिंग दूरी की गणना करें।\n    पैरामीटर्स:\n- x (int): पहला धनात्मक पूर्णांक (x <= 1,000,000,000)।\n- y (int): दूसरा धनात्मक पूर्णांक (y <= 1,000,000,000)।\n    रिटर्न्स:\n    int: x और y के बीच हैमिंग दूरी, अर्थात्, x को बाइनरी में y में बदलने के लिए जिन बिट्स को उलटना आवश्यक है उनकी संख्या।\n    >>> f_8(1,2)\n    2", "hu": "Számítsa ki a Hamming-távolságot két egész szám között a bináris ábrázolásban.\n    Paraméterek:\n- x (int): Az első pozitív egész szám (x <= 1,000,000,000).\n- y (int): A második pozitív egész szám (y <= 1,000,000,000).\n    Visszatérési érték:\n    int: A Hamming-távolság x és y között, azaz azoknak a biteknek a száma, amelyeket meg kell változtatni ahhoz, hogy x-ből y-t alakítsunk binárisan.\n    >>> f_8(1,2)\n    2", "es": "Calcular la distancia de Hamming entre dos enteros en representación binaria.\n    Parámetros:\n- x (int): El primer entero positivo (x <= 1,000,000,000).\n- y (int): El segundo entero positivo (y <= 1,000,000,000).\n    Devuelve:\n    int: La distancia de Hamming entre x e y, es decir, el número de bits que deben ser cambiados para transformar x en y en binario.\n    >>> f_8(1,2)\n    2", "arb": "احسب مسافة هامنج بين عددين صحيحين في التمثيل الثنائي.\n    المعاملات:\n- x (int): العدد الصحيح الأول الموجب (x <= 1,000,000,000).\n- y (int): العدد الصحيح الثاني الموجب (y <= 1,000,000,000).\n    يعيد:\n    int: مسافة هامنج بين x و y، أي عدد البتات التي تحتاج إلى قلبها لتحويل x إلى y في الثنائي.\n    >>> f_8(1,2)\n    2", "sw": "Hesabu umbali wa Hamming kati ya nambari mbili katika uwakilishi wa binary.\n    Vigezo:\n- x (int): Nambari ya kwanza chanya (x <= 1,000,000,000).\n- y (int): Nambari ya pili chanya (y <= 1,000,000,000).\n    Inarejesha:\n    int: Umbali wa Hamming kati ya x na y, yaani, idadi ya biti zinazohitajika kubadilishwa ili kubadilisha x kuwa y katika binary.\n    >>> f_8(1,2)\n    2", "tr": "İkili gösterimde iki tamsayı arasındaki Hamming mesafesini hesaplayın.\n    Parametreler:\n- x (int): İlk pozitif tamsayı (x <= 1,000,000,000).\n- y (int): İkinci pozitif tamsayı (y <= 1,000,000,000).\n    Döndürür:\n    int: x ve y arasındaki Hamming mesafesi, yani x'i ikili olarak y'ye dönüştürmek için çevrilmesi gereken bit sayısı.\n    >>> f_8(1,2)\n    2", "vi": "Tính khoảng cách Hamming giữa hai số nguyên trong biểu diễn nhị phân.\n    Tham số:\n- x (int): Số nguyên dương thứ nhất (x <= 1,000,000,000).\n- y (int): Số nguyên dương thứ hai (y <= 1,000,000,000).\n    Trả về:\n    int: Khoảng cách Hamming giữa x và y, tức là số bit cần phải lật để biến đổi x thành y trong nhị phân.\n    >>> f_8(1,2)\n    2", "id": "Hitung jarak Hamming antara dua bilangan bulat dalam representasi biner.\n    Parameter:\n- x (int): Bilangan bulat positif pertama (x <= 1,000,000,000).\n- y (int): Bilangan bulat positif kedua (y <= 1,000,000,000).\n    Mengembalikan:\n    int: Jarak Hamming antara x dan y, yaitu jumlah bit yang perlu dibalik untuk mengubah x menjadi y dalam biner.\n    >>> f_8(1,2)\n    2", "ja": "2つの整数の2進数表現におけるハミング距離を計算します。\n    パラメータ:\n- x (int): 最初の正の整数 (x <= 1,000,000,000)。\n- y (int): 2番目の正の整数 (y <= 1,000,000,000)。\n    戻り値:\n    int: xとyのハミング距離、すなわち、xを2進数でyに変換するために反転する必要があるビットの数。\n    >>> f_8(1,2)\n    2", "ko": "이진 표현에서 두 정수 사이의 해밍 거리를 계산합니다.\n    매개변수:\n- x (int): 첫 번째 양의 정수 (x <= 1,000,000,000).\n- y (int): 두 번째 양의 정수 (y <= 1,000,000,000).\n    반환값:\n    int: x를 y로 변환하기 위해 뒤집어야 하는 비트 수, 즉 x와 y 사이의 해밍 거리.\n    >>> f_8(1,2)\n    2", "ml": "രണ്ട് പൂർണ്ണസംഖ്യകളുടെ ബൈനറി പ്രതിനിധാനത്തിലുള്ള ഹാമിംഗ് ദൂരം കണക്കാക്കുക.\n    പാരാമീറ്ററുകൾ:\n- x (int): ആദ്യത്തെ പോസിറ്റീവ് പൂർണ്ണസംഖ്യ (x <= 1,000,000,000).\n- y (int): രണ്ടാം പോസിറ്റീവ് പൂർണ്ണസംഖ്യ (y <= 1,000,000,000).\n    തിരികെ നൽകുന്നു:\n    int: x നും y നും ഇടയിലുള്ള ഹാമിംഗ് ദൂരം, അഥവാ, ബൈനറിയിൽ x നെ y ആക്കാൻ മാറ്റേണ്ട ബിറ്റുകളുടെ എണ്ണം.\n    >>> f_8(1,2)\n    2", "fa": "محاسبه فاصله همینگ بین دو عدد صحیح در نمایش دودویی.\n    پارامترها:\n- x (int): اولین عدد صحیح مثبت (x <= 1,000,000,000).\n- y (int): دومین عدد صحیح مثبت (y <= 1,000,000,000).\n    بازگشت:\n    int: فاصله همینگ بین x و y، یعنی تعداد بیت‌هایی که باید تغییر کنند تا x به y در دودویی تبدیل شود.\n    >>> f_8(1,2)\n    2"}}
{"task_id": "C/9", "prompt": {"en": "#include <assert.h>\n#include <stdarg.h>\n\n/*\nCount the number of odd integers in a given list of numbers.\n    Parameters:\n- count (int): The count of numbers to evaluate.\n- ... (int): A sequence of integers.\n    Returns:\n    int: The count of odd numbers in the input list.\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3\n*/\nint f_9(int count, ...)", "sq": "#include <assert.h>\n#include <stdarg.h>\n\n/*\nNumëron numrin e numrave tek në një listë të dhënë numrash.\n    Parametrat:\n- count (int): Numri i numrave për t'u vlerësuar.\n- ... (int): Një sekuencë numrash të plotë.\n    Kthen:\n    int: Numri i numrave tek në listën hyrëse.\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3\n*/\nint f_9(int count, ...)", "hy": "#include <assert.h>\n#include <stdarg.h>\n\n/*\nՀաշվել տրված թվերի ցուցակում կենտ ամբողջ թվերի քանակը։\n    Պարամետրեր:\n- count (int): Գնահատվող թվերի քանակը։\n- ... (int): Ամբողջ թվերի հաջորդականություն։\n    Վերադարձնում է:\n    int: Մուտքային ցուցակում գտնվող կենտ թվերի քանակը։\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3\n*/\nint f_9(int count, ...)", "bn": "#include <assert.h>\n#include <stdarg.h>\n\n/*\nএকটি প্রদত্ত সংখ্যার তালিকায় বিজোড় পূর্ণসংখ্যার সংখ্যা গণনা করুন।\n    Parameters:\n- count (int): মূল্যায়ন করার জন্য সংখ্যার সংখ্যা।\n- ... (int): পূর্ণসংখ্যার একটি ক্রম।\n    Returns:\n    int: ইনপুট তালিকায় বিজোড় সংখ্যার সংখ্যা।\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3\n*/\nint f_9(int count, ...)", "bg": "#include <assert.h>\n#include <stdarg.h>\n\n/*\nБройте броя на нечетните числа в даден списък от числа.\n    Параметри:\n- count (int): Броят на числата за оценка.\n- ... (int): Последователност от цели числа.\n    Връща:\n    int: Броят на нечетните числа в списъка с входни данни.\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3\n*/\nint f_9(int count, ...)", "zh": "#include <assert.h>\n#include <stdarg.h>\n\n/*\n计算给定数字列表中奇数的数量。\n    参数:\n- count (int): 要评估的数字数量。\n- ... (int): 一系列整数。\n    返回:\n    int: 输入列表中奇数的数量。\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3\n*/\nint f_9(int count, ...)", "fr": "#include <assert.h>\n#include <stdarg.h>\n\n/*\nCompter le nombre d'entiers impairs dans une liste donnée de nombres.\n    Paramètres:\n- count (int): Le nombre de nombres à évaluer.\n- ... (int): Une séquence d'entiers.\n    Renvoie:\n    int: Le nombre de nombres impairs dans la liste d'entrée.\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3\n*/\nint f_9(int count, ...)", "de": "#include <assert.h>\n#include <stdarg.h>\n\n/*\nZählt die Anzahl der ungeraden Ganzzahlen in einer gegebenen Liste von Zahlen.\n    Parameter:\n- count (int): Die Anzahl der zu bewertenden Zahlen.\n- ... (int): Eine Sequenz von Ganzzahlen.\n    Rückgabe:\n    int: Die Anzahl der ungeraden Zahlen in der Eingabeliste.\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3\n*/\nint f_9(int count, ...)", "ha": "#include <assert.h>\n#include <stdarg.h>\n\n/*\nƘirga adadin lambobin da ba su da ma'aurata a cikin jerin lambobi da aka bayar.\n    Sigogi:\n- count (int): Adadin lambobin da za a tantance.\n- ... (int): Jerin lambobi.\n    Komawa:\n    int: Adadin lambobin da ba su da ma'aurata a cikin jerin shigarwa.\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3\n*/\nint f_9(int count, ...)", "hi": "#include <assert.h>\n#include <stdarg.h>\n\n/*\nदिए गए संख्याओं की सूची में विषम पूर्णांकों की संख्या गिनें।\n    पैरामीटर्स:\n- count (int): मूल्यांकन करने के लिए संख्याओं की गिनती।\n- ... (int): पूर्णांकों की एक अनुक्रम।\n    रिटर्न करता है:\n    int: इनपुट सूची में विषम संख्याओं की गिनती।\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3\n*/\nint f_9(int count, ...)", "hu": "#include <assert.h>\n#include <stdarg.h>\n\n/*\nSzámolja meg a páratlan egész számok számát egy adott számok listájában.\n    Paraméterek:\n- count (int): Az értékelendő számok száma.\n- ... (int): Egész számok sorozata.\n    Visszatér:\n    int: A páratlan számok száma a bemeneti listában.\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3\n*/\nint f_9(int count, ...)", "es": "#include <assert.h>\n#include <stdarg.h>\n\n/*\nCuenta el número de enteros impares en una lista dada de números.\n    Parámetros:\n- count (int): La cantidad de números a evaluar.\n- ... (int): Una secuencia de enteros.\n    Devuelve:\n    int: La cantidad de números impares en la lista de entrada.\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3\n*/\nint f_9(int count, ...)", "arb": "#include <assert.h>\n#include <stdarg.h>\n\n/*\nاحسب عدد الأعداد الفردية في قائمة معينة من الأرقام.\n    المعاملات:\n- count (int): عدد الأرقام لتقييمها.\n- ... (int): سلسلة من الأعداد الصحيحة.\n    يعيد:\n    int: عدد الأعداد الفردية في قائمة الإدخال.\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3\n*/\nint f_9(int count, ...)", "sw": "#include <assert.h>\n#include <stdarg.h>\n\n/*\nHesabu idadi ya nambari zisizo za jozi katika orodha ya nambari zilizotolewa.\n    Vigezo:\n- count (int): Idadi ya nambari za kutathmini.\n- ... (int): Mfululizo wa nambari za mzima.\n    Inarudisha:\n    int: Idadi ya nambari zisizo za jozi katika orodha ya pembejeo.\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3\n*/\nint f_9(int count, ...)", "tr": "#include <assert.h>\n#include <stdarg.h>\n\n/*\nVerilen bir sayı listesindeki tek sayıların sayısını hesapla.\n    Parametreler:\n- count (int): Değerlendirilecek sayıların sayısı.\n- ... (int): Bir dizi tamsayı.\n    Döndürür:\n    int: Girdi listesindeki tek sayıların sayısı.\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3\n*/\nint f_9(int count, ...)", "vi": "#include <assert.h>\n#include <stdarg.h>\n\n/*\nĐếm số lượng số nguyên lẻ trong một danh sách số đã cho.\n    Tham số:\n- count (int): Số lượng số cần đánh giá.\n- ... (int): Một dãy số nguyên.\n    Trả về:\n    int: Số lượng số lẻ trong danh sách đầu vào.\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3\n*/\nint f_9(int count, ...)", "id": "#include <assert.h>\n#include <stdarg.h>\n\n/*\nMenghitung jumlah bilangan ganjil dalam daftar bilangan yang diberikan.\n    Parameter:\n- count (int): Jumlah bilangan yang akan dievaluasi.\n- ... (int): Urutan bilangan bulat.\n    Mengembalikan:\n    int: Jumlah bilangan ganjil dalam daftar input.\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3\n*/\nint f_9(int count, ...)", "ja": "#include <assert.h>\n#include <stdarg.h>\n\n/*\n与えられた数値のリストの中で奇数の整数の数を数えます。\n    パラメータ:\n- count (int): 評価する数値の数。\n- ... (int): 整数のシーケンス。\n    戻り値:\n    int: 入力リスト内の奇数の数。\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3\n*/\nint f_9(int count, ...)", "ko": "#include <assert.h>\n#include <stdarg.h>\n\n/*\n주어진 숫자 목록에서 홀수 정수의 개수를 계산합니다.\n    매개변수:\n- count (int): 평가할 숫자의 개수.\n- ... (int): 정수의 시퀀스.\n    반환값:\n    int: 입력 목록에서 홀수의 개수.\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3\n*/\nint f_9(int count, ...)", "ml": "#include <assert.h>\n#include <stdarg.h>\n\n/*\nഒരു നൽകിയ ലിസ്റ്റിലെ ഒറ്റ സംഖ്യകളുടെ എണ്ണം എണ്ണുക.\n    പാരാമീറ്ററുകൾ:\n- count (int): വിലയിരുത്താനുള്ള സംഖ്യകളുടെ എണ്ണം.\n- ... (int): ഒരു സംഖ്യകളുടെ ശ്രേണി.\n    മടക്കുക:\n    int: ഇൻപുട്ട് ലിസ്റ്റിലെ ഒറ്റ സംഖ്യകളുടെ എണ്ണം.\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3\n*/\nint f_9(int count, ...)", "fa": "#include <assert.h>\n#include <stdarg.h>\n\n/*\nتعداد اعداد فرد را در یک لیست از اعداد داده شده بشمارید.\n    پارامترها:\n- count (int): تعداد اعدادی که باید ارزیابی شوند.\n- ... (int): دنباله‌ای از اعداد صحیح.\n    بازگشت:\n    int: تعداد اعداد فرد در لیست ورودی.\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3\n*/\nint f_9(int count, ...)"}, "canonical_solution": "{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1)\n            ans++;\n    }\n    va_end(args);\n    return ans;\n}", "instruction": {"en": "Write a C function `int f_9(int count, ...)` to solve the following problem:\nCount the number of odd integers in a given list of numbers.\n    Parameters:\n- count (int): The count of numbers to evaluate.\n- ... (int): A sequence of integers.\n    Returns:\n    int: The count of odd numbers in the input list.\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3\n", "sq": "Shkruani një funksion C `int f_9(int count, ...)` për të zgjidhur problemin e mëposhtëm:\nNumëroni numrin e numrave tek në një listë të dhënë numrash.\n    Parametrat:\n- count (int): Numri i numrave për t'u vlerësuar.\n- ... (int): Një sekuencë e numrave të plotë.\n    Kthen:\n    int: Numri i numrave tek në listën e hyrjes.\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3", "hy": "Գրեք C ֆունկցիա `int f_9(int count, ...)` հետևյալ խնդիրը լուծելու համար:\nՀաշվեք տրված թվերի ցանկում կենտ ամբողջ թվերի քանակը:\n    Պարամետրեր:\n- count (int): Գնահատվող թվերի քանակը:\n- ... (int): Ամբողջ թվերի հաջորդականություն:\n    Վերադարձնում է:\n    int: Մուտքային ցանկում կենտ թվերի քանակը:\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3", "bn": "একটি C ফাংশন `int f_9(int count, ...)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nদেওয়া সংখ্যার তালিকায় বিজোড় পূর্ণসংখ্যার সংখ্যা গণনা করুন।\n    প্যারামিটারসমূহ:\n- count (int): মূল্যায়ন করার জন্য সংখ্যার সংখ্যা।\n- ... (int): পূর্ণসংখ্যার একটি ক্রম।\n    রিটার্নস:\n    int: ইনপুট তালিকায় বিজোড় সংখ্যার সংখ্যা।\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3", "bg": "Напишете C функция `int f_9(int count, ...)`, за да решите следния проблем:\nБройте броя на нечетните цели числа в даден списък от числа.  \n    Параметри:  \n- count (int): Броят на числата за оценка.  \n- ... (int): Последователност от цели числа.  \n    Връща:  \n    int: Броят на нечетните числа в списъка с входни данни.  \n    >>> f_9(5, 1, 4, 3, 2, 5)  \n    3  ", "zh": "编写一个 C 函数 `int f_9(int count, ...)` 来解决以下问题：\n计算给定数字列表中奇数的数量。\n    参数：\n- count (int): 需要评估的数字数量。\n- ... (int): 一系列整数。\n    返回：\n    int: 输入列表中奇数的数量。\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3", "fr": "Écrire une fonction C `int f_9(int count, ...)` pour résoudre le problème suivant :\nCompter le nombre d'entiers impairs dans une liste donnée de nombres.\n    Paramètres :\n- count (int) : Le nombre de nombres à évaluer.\n- ... (int) : Une séquence d'entiers.\n    Renvoie :\n    int : Le nombre de nombres impairs dans la liste d'entrée.\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3", "de": "Schreiben Sie eine C-Funktion `int f_9(int count, ...)`, um das folgende Problem zu lösen:\nZählen Sie die Anzahl der ungeraden ganzen Zahlen in einer gegebenen Liste von Zahlen.\n    Parameter:\n- count (int): Die Anzahl der zu bewertenden Zahlen.\n- ... (int): Eine Sequenz von ganzen Zahlen.\n    Rückgabewert:\n    int: Die Anzahl der ungeraden Zahlen in der Eingabeliste.\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3", "ha": "Rubuta wani aikin C `int f_9(int count, ...)` don warware matsalar mai zuwa:\nƘididdige yawan lambobin da ba su daidai ba a cikin jerin lambobi da aka bayar.\n    Sigogi:\n- count (int): Yawan lambobin da za a tantance.\n- ... (int): Jeri na lambobi.\n    Mayar da:\n    int: Yawan lambobin da ba su daidai ba a cikin jerin shigarwa.\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3", "hi": "एक C फ़ंक्शन `int f_9(int count, ...)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए संख्याओं की सूची में विषम पूर्णांकों की संख्या गिनें।\n    पैरामीटर्स:\n- count (int): मूल्यांकन करने के लिए संख्याओं की गिनती।\n- ... (int): पूर्णांकों का अनुक्रम।\n    रिटर्न करता है:\n    int: इनपुट सूची में विषम संख्याओं की गिनती।\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3", "hu": "Írj egy C függvényt `int f_9(int count, ...)` a következő probléma megoldására:\nSzámold meg a páratlan egész számok számát egy adott számok listájában.\n    Paraméterek:\n- count (int): Az értékelendő számok száma.\n- ... (int): Egész számok sorozata.\n    Visszatérési érték:\n    int: A bemeneti listában található páratlan számok száma.\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3", "es": "Escriba una función en C `int f_9(int count, ...)` para resolver el siguiente problema:\nContar la cantidad de enteros impares en una lista dada de números.\n    Parámetros:\n- count (int): La cantidad de números a evaluar.\n- ... (int): Una secuencia de enteros.\n    Devuelve:\n    int: La cantidad de números impares en la lista de entrada.\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3", "arb": "اكتب دالة C `int f_9(int count, ...)` لحل المشكلة التالية:\nعد عدد الأعداد الفردية في قائمة معينة من الأرقام.\n    المعاملات:\n- count (int): عدد الأرقام لتقييمها.\n- ... (int): سلسلة من الأعداد الصحيحة.\n    يعيد:\n    int: عدد الأعداد الفردية في قائمة الإدخال.\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3", "sw": "Andika kazi ya C `int f_9(int count, ...)` kutatua tatizo lifuatalo:\nHesabu idadi ya namba zisizo za jozi katika orodha iliyotolewa ya namba.\n    Vigezo:\n- count (int): Idadi ya namba za kutathmini.\n- ... (int): Mlolongo wa namba za mzima.\n    Inarudisha:\n    int: Idadi ya namba zisizo za jozi katika orodha ya ingizo.\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3", "tr": "Bir C fonksiyonu `int f_9(int count, ...)` yazın ve aşağıdaki problemi çözün:\nVerilen bir sayı listesindeki tek sayıların sayısını hesaplayın.\n    Parametreler:\n- count (int): Değerlendirilecek sayıların sayısı.\n- ... (int): Bir dizi tam sayı.\n    Döndürür:\n    int: Girdi listesindeki tek sayıların sayısı.\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3", "vi": "Viết một hàm C `int f_9(int count, ...)` để giải quyết vấn đề sau:\nĐếm số lượng số nguyên lẻ trong một danh sách số đã cho.\n    Tham số:\n- count (int): Số lượng số cần đánh giá.\n- ... (int): Một dãy số nguyên.\n    Trả về:\n    int: Số lượng số lẻ trong danh sách đầu vào.\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3", "id": "Tulis sebuah fungsi C `int f_9(int count, ...)` untuk menyelesaikan masalah berikut:\nHitung jumlah bilangan bulat ganjil dalam daftar angka yang diberikan.\n    Parameter:\n- count (int): Jumlah angka yang akan dievaluasi.\n- ... (int): Urutan bilangan bulat.\n    Mengembalikan:\n    int: Jumlah bilangan ganjil dalam daftar input.\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3", "ja": "Cの関数を書け `int f_9(int count, ...)` を作成して、次の問題を解決してください:\n与えられた数のリストの中で奇数の整数の数を数える。\n    パラメータ:\n- count (int): 評価する数の数。\n- ... (int): 整数のシーケンス。\n    戻り値:\n    int: 入力リスト内の奇数の数。\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3", "ko": "C 함수 `int f_9(int count, ...)`를 작성하여 다음 문제를 해결하십시오:\n주어진 숫자 목록에서 홀수 정수의 개수를 세십시오.\n    매개변수:\n- count (int): 평가할 숫자의 개수.\n- ... (int): 정수의 시퀀스.\n    반환:\n    int: 입력 목록에서 홀수의 개수.\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3", "ml": "C ഫംഗ്ഷൻ `int f_9(int count, ...)` എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nനൽകിയിരിക്കുന്ന സംഖ്യകളുടെ പട്ടികയിൽ എത്ര ഒറ്റ സംഖ്യകളുണ്ടെന്ന് എണ്ണുക. \n    പാരാമീറ്ററുകൾ:\n- count (int): വിലയിരുത്താനുള്ള സംഖ്യകളുടെ എണ്ണം.\n- ... (int): ഒരു സംഖ്യകളുടെ അനുക്രമം.\n    മടക്കുന്നു:\n    int: ഇൻപുട്ട് ലിസ്റ്റിലെ ഒറ്റ സംഖ്യകളുടെ എണ്ണം.\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3", "fa": "یک تابع C به نام `int f_9(int count, ...)` بنویسید تا مسئله زیر را حل کند:\nتعداد اعداد فرد در یک لیست از اعداد داده شده را بشمارید.\n    پارامترها:\n- count (int): تعداد اعدادی که باید ارزیابی شوند.\n- ... (int): یک دنباله از اعداد صحیح.\n    بازگشت:\n    int: تعداد اعداد فرد در لیست ورودی.\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3"}, "level": "easy", "test": "int main() {\n    assert(f_9(5, 1, 4, 3, 2, 5) == 3);\n    assert(f_9(4, 2, 2, 0, 0) == 0);\n    assert(f_9(6, 7, 7, 8, 1, 9, 10) == 4); // Additional Test Sample\n    // printf(\"All tests passed!\\n\");\n    return 0;\n}", "entry_point": "f_9", "signature": "int f_9(int count, ...)", "docstring": {"en": "Count the number of odd integers in a given list of numbers.\n    Parameters:\n- count (int): The count of numbers to evaluate.\n- ... (int): A sequence of integers.\n    Returns:\n    int: The count of odd numbers in the input list.\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3\n", "sq": "Numëroni numrin e numrave tek në një listë të dhënë numrash.\n    Parametrat:\n- count (int): Numri i numrave për t'u vlerësuar.\n- ... (int): Një sekuencë e numrave të plotë.\n    Kthen:\n    int: Numri i numrave tek në listën e dhënë.\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3", "hy": "Հաշվել տրված թվերի ցանկում կենտ ամբողջ թվերի քանակը:\n    Պարամետրեր:\n- count (int): Գնահատվող թվերի քանակը:\n- ... (int): Ամբողջ թվերի հաջորդականություն:\n    Վերադարձնում է:\n    int: Մուտքային ցանկում կենտ թվերի քանակը:\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3", "bn": "দেওয়া সংখ্যার তালিকায় বিজোড় পূর্ণসংখ্যার সংখ্যা গণনা করুন।\n    প্যারামিটারসমূহ:\n- count (int): মূল্যায়ন করার জন্য সংখ্যার সংখ্যা।\n- ... (int): পূর্ণসংখ্যার একটি ক্রম।\n    রিটার্নস:\n    int: ইনপুট তালিকায় বিজোড় সংখ্যার সংখ্যা।\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3", "bg": "Бройте броя на нечетните цели числа в даден списък от числа.\n    Параметри:\n- count (int): Броят на числата за оценка.\n- ... (int): Последователност от цели числа.\n    Връща:\n    int: Броят на нечетните числа в списъка на входа.\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3", "zh": "计算给定数字列表中奇数的数量。\n    参数:\n- count (int): 要评估的数字数量。\n- ... (int): 整数序列。\n    返回:\n    int: 输入列表中奇数的数量。\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3", "fr": "Compter le nombre d'entiers impairs dans une liste donnée de nombres.\n    Paramètres:\n- count (int): Le nombre de chiffres à évaluer.\n- ... (int): Une séquence d'entiers.\n    Retourne:\n    int: Le nombre de nombres impairs dans la liste d'entrée.\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3", "de": "Zähle die Anzahl der ungeraden Ganzzahlen in einer gegebenen Liste von Zahlen.\n    Parameter:\n- count (int): Die Anzahl der zu bewertenden Zahlen.\n- ... (int): Eine Sequenz von Ganzzahlen.\n    Rückgabewert:\n    int: Die Anzahl der ungeraden Zahlen in der Eingabeliste.\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3", "ha": "Ƙirga adadin lambobin da ba su da ma'aurata a cikin jerin lambobi da aka bayar.\n    Sigogi:\n- count (int): Adadin lambobin da za a tantance.\n- ... (int): Jerin lambobi.\n    Komawa:\n    int: Adadin lambobin da ba su daidai ba a cikin jerin shigarwa.\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3", "hi": "दिए गए नंबरों की सूची में विषम पूर्णांकों की संख्या गिनें।\n    पैरामीटर्स:\n- count (int): मूल्यांकन के लिए संख्याओं की गणना।\n- ... (int): पूर्णांकों का अनुक्रम।\n    रिटर्न:\n    int: इनपुट सूची में विषम संख्याओं की गणना।\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3", "hu": "Számolja meg a páratlan egész számok számát egy adott számok listájában.\n    Paraméterek:\n- count (int): Az értékelendő számok száma.\n- ... (int): Egész számok sorozata.\n    Visszatér:\n    int: A bemeneti listában található páratlan számok száma.\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3", "es": "Cuenta el número de enteros impares en una lista dada de números.\n    Parámetros:\n- count (int): La cantidad de números a evaluar.\n- ... (int): Una secuencia de enteros.\n    Devuelve:\n    int: La cantidad de números impares en la lista de entrada.\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3", "arb": "احسب عدد الأعداد الفردية في قائمة معينة من الأرقام.\n    المعلمات:\n- count (int): عدد الأرقام لتقييمها.\n- ... (int): تسلسل من الأعداد الصحيحة.\n    يعيد:\n    int: عدد الأعداد الفردية في قائمة الإدخال.\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3", "sw": "Hesabu idadi ya nambari zisizo za kawaida katika orodha iliyotolewa ya nambari.  \n    Vigezo:  \n- count (int): Idadi ya nambari za kutathmini.  \n- ... (int): Mfululizo wa nambari za mzima.  \n    Inarejesha:  \n    int: Idadi ya nambari zisizo za kawaida katika orodha ya ingizo.  \n    >>> f_9(5, 1, 4, 3, 2, 5)  \n    3  ", "tr": "Verilen bir sayı listesindeki tek sayıların sayısını hesaplayın.\n    Parametreler:\n- count (int): Değerlendirilecek sayıların sayısı.\n- ... (int): Bir dizi tam sayı.\n    Döndürülenler:\n    int: Girdi listesindeki tek sayıların sayısı.\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3", "vi": "Đếm số lượng số nguyên lẻ trong một danh sách số đã cho.  \n    Tham số:  \n- count (int): Số lượng số cần đánh giá.  \n- ... (int): Một dãy số nguyên.  \n    Trả về:  \n    int: Số lượng số lẻ trong danh sách đầu vào.  \n    >>> f_9(5, 1, 4, 3, 2, 5)  \n    3  ", "id": "Hitung jumlah bilangan bulat ganjil dalam daftar angka yang diberikan.\n    Parameter:\n- count (int): Jumlah angka yang akan dievaluasi.\n- ... (int): Urutan bilangan bulat.\n    Mengembalikan:\n    int: Jumlah bilangan ganjil dalam daftar input.\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3", "ja": "与えられた数値のリスト内の奇数の整数の数を数えます。\n    パラメータ:\n- count (int): 評価する数値の数。\n- ... (int): 整数のシーケンス。\n    戻り値:\n    int: 入力リスト内の奇数の数。\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3", "ko": "주어진 숫자 목록에서 홀수 정수의 개수를 셉니다.\n    매개변수:\n- count (int): 평가할 숫자의 개수.\n- ... (int): 정수의 시퀀스.\n    반환:\n    int: 입력 목록에서 홀수의 개수.\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3", "ml": "ഒരു നൽകിയിരിക്കുന്ന സംഖ്യകളുടെ പട്ടികയിൽ എത്ര ഒറ്റ സംഖ്യകളുണ്ട് എന്ന് എണ്ണുക.  \n    പാരാമീറ്ററുകൾ:  \n- count (int): വിലയിരുത്തേണ്ട സംഖ്യകളുടെ എണ്ണം.  \n- ... (int): ഒരു പദവിന്യാസം.  \n    മടക്കുന്നു:  \n    int: ഇൻപുട്ട് പട്ടികയിൽ ഉള്ള ഒറ്റ സംഖ്യകളുടെ എണ്ണം.  \n    >>> f_9(5, 1, 4, 3, 2, 5)  \n    3  ", "fa": "تعداد اعداد فرد در یک لیست داده شده از اعداد را بشمارید.\n    پارامترها:\n- count (int): تعداد اعدادی که باید ارزیابی شوند.\n- ... (int): دنباله‌ای از اعداد صحیح.\n    بازمی‌گرداند:\n    int: تعداد اعداد فرد در لیست ورودی.\n    >>> f_9(5, 1, 4, 3, 2, 5)\n    3"}}
{"task_id": "C/10", "prompt": {"en": "#include <assert.h>\n#include <stdio.h>\n/*\nCalculate the sum of even numbers in a given list.\n    Parameters:\n- numbers (list): A list of integers.\n- size (int): The size of the list.\n    Returns:\n    int: The sum of even numbers in the input list.\n    >>> f_10([1,4,3,2,5], 5)\n    6\n*/\nint f_10(int *numbers, int size); // Fixed declaration", "sq": "#include <assert.h>\n#include <stdio.h>\n/*\nLlogarit shumën e numrave çift në një listë të dhënë.\n    Parametrat:\n- numbers (listë): Një listë e numrave të plotë.\n- size (int): Madhësia e listës.\n    Kthen:\n    int: Shuma e numrave çift në listën e hyrjes.\n    >>> f_10([1,4,3,2,5], 5)\n    6\n*/\nint f_10(int *numbers, int size); // Deklarim i rregulluar", "hy": "#include <assert.h>\n#include <stdio.h>\n/*\nՀաշվել զույգ թվերի գումարը տրված ցուցակում։\n    Պարամետրեր:\n- numbers (list): ամբողջ թվերի ցուցակ։\n- size (int): ցուցակի չափը։\n    Վերադարձնում է:\n    int: մուտքային ցուցակում զույգ թվերի գումարը։\n    >>> f_10([1,4,3,2,5], 5)\n    6\n*/\nint f_10(int *numbers, int size); // Fixed declaration", "bn": "#include <assert.h>\n#include <stdio.h>\n/*\nএকটি প্রদত্ত তালিকার জোড় সংখ্যাগুলির যোগফল গণনা করুন।\n    প্যারামিটারসমূহ:\n- numbers (list): পূর্ণসংখ্যার একটি তালিকা।\n- size (int): তালিকার আকার।\n    রিটার্নস:\n    int: ইনপুট তালিকার জোড় সংখ্যাগুলির যোগফল।\n    >>> f_10([1,4,3,2,5], 5)\n    6\n*/\nint f_10(int *numbers, int size); // Fixed declaration", "bg": "#include <assert.h>\n#include <stdio.h>\n/*\nИзчисляване на сумата на четните числа в даден списък.\n    Параметри:\n- numbers (list): Списък от цели числа.\n- size (int): Размерът на списъка.\n    Връща:\n    int: Сумата на четните числа в входния списък.\n    >>> f_10([1,4,3,2,5], 5)\n    6\n*/\nint f_10(int *numbers, int size); // Fixed declaration", "zh": "#include <assert.h>\n#include <stdio.h>\n/*\n计算给定列表中偶数的和。\n    参数:\n- numbers (list): 整数列表。\n- size (int): 列表的大小。\n    返回:\n    int: 输入列表中偶数的和。\n    >>> f_10([1,4,3,2,5], 5)\n    6\n*/\nint f_10(int *numbers, int size); // Fixed declaration", "fr": "#include <assert.h>\n#include <stdio.h>\n/*\nCalculer la somme des nombres pairs dans une liste donnée.\n    Paramètres :\n- numbers (list) : Une liste d'entiers.\n- size (int) : La taille de la liste.\n    Renvoie :\n    int : La somme des nombres pairs dans la liste d'entrée.\n    >>> f_10([1,4,3,2,5], 5)\n    6\n*/\nint f_10(int *numbers, int size); // Fixed declaration", "de": "#include <assert.h>\n#include <stdio.h>\n/*\nBerechne die Summe der geraden Zahlen in einer gegebenen Liste.\n    Parameter:\n- numbers (list): Eine Liste von ganzen Zahlen.\n- size (int): Die Größe der Liste.\n    Rückgabe:\n    int: Die Summe der geraden Zahlen in der Eingabeliste.\n    >>> f_10([1,4,3,2,5], 5)\n    6\n*/\nint f_10(int *numbers, int size); // Feste Deklaration", "ha": "#include <assert.h>\n#include <stdio.h>\n/*\nƘididdige jimillar lambobin da suke ma'aurata a cikin jerin da aka bayar.\n    Sigogi:\n- numbers (list): Jerin lambobi masu cikakken lamba.\n- size (int): Girman jerin.\n    Komawa:\n    int: Jimillar lambobin da suke ma'aurata a cikin jerin shigarwa.\n    >>> f_10([1,4,3,2,5], 5)\n    6\n*/\nint f_10(int *numbers, int size); // Fixed declaration", "hi": "#include <assert.h>\n#include <stdio.h>\n/*\nदिए गए सूची में सम संख्याओं का योग गणना करें।\n    पैरामीटर्स:\n- numbers (list): पूर्णांकों की एक सूची।\n- size (int): सूची का आकार।\n    रिटर्न करता है:\n    int: इनपुट सूची में सम संख्याओं का योग।\n    >>> f_10([1,4,3,2,5], 5)\n    6\n*/\nint f_10(int *numbers, int size); // Fixed declaration", "hu": "#include <assert.h>\n#include <stdio.h>\n/*\nSzámítsa ki a páros számok összegét egy adott listában.\n    Paraméterek:\n- numbers (list): Egész számok listája.\n- size (int): A lista mérete.\n    Visszatér:\n    int: A bemeneti listában lévő páros számok összege.\n    >>> f_10([1,4,3,2,5], 5)\n    6\n*/\nint f_10(int *numbers, int size); // Rögzített deklaráció", "es": "#include <assert.h>\n#include <stdio.h>\n/*\nCalcular la suma de los números pares en una lista dada.\n    Parámetros:\n- numbers (list): Una lista de enteros.\n- size (int): El tamaño de la lista.\n    Devuelve:\n    int: La suma de los números pares en la lista de entrada.\n    >>> f_10([1,4,3,2,5], 5)\n    6\n*/\nint f_10(int *numbers, int size); // Fixed declaration", "arb": "#include <assert.h>\n#include <stdio.h>\n/*\nحساب مجموع الأعداد الزوجية في قائمة معينة.\n    المعاملات:\n- numbers (list): قائمة من الأعداد الصحيحة.\n- size (int): حجم القائمة.\n    يعيد:\n    int: مجموع الأعداد الزوجية في القائمة المدخلة.\n    >>> f_10([1,4,3,2,5], 5)\n    6\n*/\nint f_10(int *numbers, int size); // Fixed declaration", "sw": "#include <assert.h>\n#include <stdio.h>\n/*\nHesabu jumla ya namba shufwa katika orodha iliyotolewa.\n    Vigezo:\n- numbers (list): Orodha ya namba nzima.\n- size (int): Ukubwa wa orodha.\n    Inarudisha:\n    int: Jumla ya namba shufwa katika orodha iliyoingizwa.\n    >>> f_10([1,4,3,2,5], 5)\n    6\n*/\nint f_10(int *numbers, int size); // Tamko lililorekebishwa", "tr": "#include <assert.h>\n#include <stdio.h>\n/*\nVerilen bir listedeki çift sayıların toplamını hesaplayın.\n    Parametreler:\n- numbers (list): Bir tamsayı listesi.\n- size (int): Listenin boyutu.\n    Döndürür:\n    int: Girdi listesindeki çift sayıların toplamı.\n    >>> f_10([1,4,3,2,5], 5)\n    6\n*/\nint f_10(int *numbers, int size); // Sabit bildirim", "vi": "#include <assert.h>\n#include <stdio.h>\n/*\nTính tổng các số chẵn trong một danh sách cho trước.\n    Tham số:\n- numbers (list): Một danh sách các số nguyên.\n- size (int): Kích thước của danh sách.\n    Trả về:\n    int: Tổng các số chẵn trong danh sách đầu vào.\n    >>> f_10([1,4,3,2,5], 5)\n    6\n*/\nint f_10(int *numbers, int size); // Fixed declaration", "id": "#include <assert.h>\n#include <stdio.h>\n/*\nMenghitung jumlah bilangan genap dalam daftar yang diberikan.\n    Parameter:\n- numbers (list): Daftar bilangan bulat.\n- size (int): Ukuran daftar.\n    Mengembalikan:\n    int: Jumlah bilangan genap dalam daftar input.\n    >>> f_10([1,4,3,2,5], 5)\n    6\n*/\nint f_10(int *numbers, int size); // Deklarasi tetap", "ja": "#include <assert.h>\n#include <stdio.h>\n/*\n与えられたリスト内の偶数の合計を計算します。\n    パラメータ:\n- numbers (list): 整数のリスト。\n- size (int): リストのサイズ。\n    戻り値:\n    int: 入力リスト内の偶数の合計。\n    >>> f_10([1,4,3,2,5], 5)\n    6\n*/\nint f_10(int *numbers, int size); // 固定された宣言", "ko": "#include <assert.h>\n#include <stdio.h>\n/*\n주어진 리스트에서 짝수의 합을 계산합니다.\n    매개변수:\n- numbers (list): 정수의 리스트.\n- size (int): 리스트의 크기.\n    반환값:\n    int: 입력 리스트에서 짝수의 합.\n    >>> f_10([1,4,3,2,5], 5)\n    6\n*/\nint f_10(int *numbers, int size); // Fixed declaration", "ml": "#include <assert.h>\n#include <stdio.h>\n/*\nഒരു നൽകിയ ലിസ്റ്റിലെ സമവായ സംഖ്യകളുടെ മൊത്തം കണക്കാക്കുക.\n    പാരാമീറ്ററുകൾ:\n- numbers (list): പൂർണ്ണസംഖ്യകളുടെ ഒരു ലിസ്റ്റ്.\n- size (int): ലിസ്റ്റിന്റെ വലിപ്പം.\n    മടക്കുന്നു:\n    int: ഇൻപുട്ട് ലിസ്റ്റിലെ സമവായ സംഖ്യകളുടെ മൊത്തം.\n    >>> f_10([1,4,3,2,5], 5)\n    6\n*/\nint f_10(int *numbers, int size); // Fixed declaration", "fa": "#include <assert.h>\n#include <stdio.h>\n/*\nمحاسبه مجموع اعداد زوج در یک لیست داده شده.\n    پارامترها:\n- numbers (list): یک لیست از اعداد صحیح.\n- size (int): اندازه لیست.\n    بازگشت:\n    int: مجموع اعداد زوج در لیست ورودی.\n    >>> f_10([1,4,3,2,5], 5)\n    6\n*/\nint f_10(int *numbers, int size); // Fixed declaration"}, "canonical_solution": "int f_10(int *numbers, int size) { // Fixed solution\n    int ans = 0;\n    for (int i = 0; i < size; i++) {\n        if ((numbers[i] & 1) == 0) { // Only sum the even numbers\n            ans += numbers[i];\n        }\n    }\n    return ans;\n}", "instruction": {"en": "Write a C function `int f_10(int *numbers, int size)` to solve the following problem:\nCalculate the sum of even numbers in a given list.\n    Parameters:\n- numbers (list): A list of integers.\n- size (int): The size of the list.\n    Returns:\n    int: The sum of even numbers in the input list.\n    >>> f_10([1,4,3,2,5], 5)\n    6\n", "sq": "Shkruani një funksion në C `int f_10(int *numbers, int size)` për të zgjidhur problemin në vijim:\nLlogaritni shumën e numrave çift në një listë të dhënë.\n    Parametrat:\n- numbers (listë): Një listë me numra të plotë.\n- size (int): Madhësia e listës.\n    Kthen:\n    int: Shuma e numrave çift në listën e dhënë si hyrje.\n    >>> f_10([1,4,3,2,5], 5)\n    6", "hy": "Գրեք C ֆունկցիա `int f_10(int *numbers, int size)` հետևյալ խնդիրը լուծելու համար:\nՀաշվեք զույգ թվերի գումարը տրված ցուցակում:\n    Պարամետրեր:\n- numbers (ցուցակ): ամբողջ թվերի ցուցակ:\n- size (int): ցուցակի չափը:\n    Վերադարձնում է:\n    int: զույգ թվերի գումարը մուտքային ցուցակում:\n    >>> f_10([1,4,3,2,5], 5)\n    6", "bn": "একটি C ফাংশন `int f_10(int *numbers, int size)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nপ্রদত্ত তালিকায় জোড় সংখ্যাগুলোর যোগফল গণনা করুন।\n    প্যারামিটারসমূহ:\n- numbers (list): পূর্ণসংখ্যার একটি তালিকা।\n- size (int): তালিকার আকার।\n    রিটার্নস:\n    int: ইনপুট তালিকায় জোড় সংখ্যাগুলোর যোগফল।\n    >>> f_10([1,4,3,2,5], 5)\n    6", "bg": "Напишете C функция `int f_10(int *numbers, int size)`, за да решите следния проблем:\nИзчислете сумата на четните числа в даден списък.\n    Параметри:\n- numbers (list): Списък от цели числа.\n- size (int): Размерът на списъка.\n    Връща:\n    int: Сумата на четните числа в входния списък.\n    >>> f_10([1,4,3,2,5], 5)\n    6", "zh": "编写一个 C 函数 `int f_10(int *numbers, int size)` 来解决以下问题：\n计算给定列表中偶数的和。\n    参数：\n- numbers (list): 整数列表。\n- size (int): 列表的大小。\n    返回：\n    int: 输入列表中偶数的和。\n    >>> f_10([1,4,3,2,5], 5)\n    6", "fr": "Écrire une fonction C `int f_10(int *numbers, int size)` pour résoudre le problème suivant :\nCalculer la somme des nombres pairs dans une liste donnée.\n    Paramètres :\n- numbers (list) : Une liste d'entiers.\n- size (int) : La taille de la liste.\n    Renvoie :\n    int : La somme des nombres pairs dans la liste d'entrée.\n    >>> f_10([1,4,3,2,5], 5)\n    6", "de": "Schreiben Sie eine C-Funktion `int f_10(int *numbers, int size)`, um das folgende Problem zu lösen:\nBerechnen Sie die Summe der geraden Zahlen in einer gegebenen Liste.\n    Parameter:\n- numbers (list): Eine Liste von ganzen Zahlen.\n- size (int): Die Größe der Liste.\n    Rückgabewert:\n    int: Die Summe der geraden Zahlen in der Eingabeliste.\n    >>> f_10([1,4,3,2,5], 5)\n    6", "ha": "Rubuta wani aikin C `int f_10(int *numbers, int size)` don warware matsalar mai zuwa:\nƘididdige jimillar lambobi masu lamba biyu a cikin jerin da aka bayar.\n    Sigogi:\n- numbers (list): Jerin lambobi masu lamba.\n- size (int): Girman jerin.\n    Mayar da:\n    int: Jimillar lambobi masu lamba biyu a cikin jerin shigarwa.\n    >>> f_10([1,4,3,2,5], 5)\n    6", "hi": "C फ़ंक्शन `int f_10(int *numbers, int size)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए सूची में सम संख्याओं का योग गणना करें।\n    पैरामीटर्स:\n- numbers (list): पूर्णांकों की एक सूची।\n- size (int): सूची का आकार।\n    रिटर्न्स:\n    int: इनपुट सूची में सम संख्याओं का योग।\n    >>> f_10([1,4,3,2,5], 5)\n    6", "hu": "Írj egy C függvényt `int f_10(int *numbers, int size)` a következő probléma megoldására:\nSzámítsd ki a páros számok összegét egy adott listában.\n    Paraméterek:\n- numbers (list): Egész számok listája.\n- size (int): A lista mérete.\n    Visszatérési érték:\n    int: A bemeneti listában található páros számok összege.\n    >>> f_10([1,4,3,2,5], 5)\n    6", "es": "Escribe una función en C `int f_10(int *numbers, int size)` para resolver el siguiente problema:\nCalcular la suma de los números pares en una lista dada.\n    Parámetros:\n- numbers (list): Una lista de enteros.\n- size (int): El tamaño de la lista.\n    Retorna:\n    int: La suma de los números pares en la lista de entrada.\n    >>> f_10([1,4,3,2,5], 5)\n    6", "arb": "اكتب دالة بلغة C `int f_10(int *numbers, int size)` لحل المشكلة التالية:\nاحسب مجموع الأعداد الزوجية في قائمة معينة.\n    المعاملات:\n- numbers (list): قائمة من الأعداد الصحيحة.\n- size (int): حجم القائمة.\n    يعيد:\n    int: مجموع الأعداد الزوجية في القائمة المدخلة.\n    >>> f_10([1,4,3,2,5], 5)\n    6", "sw": "Andika kazi ya C `int f_10(int *numbers, int size)` kutatua tatizo lifuatalo:\nHesabu jumla ya namba shufwa katika orodha iliyotolewa.\n    Vigezo:\n- numbers (list): Orodha ya namba nzima.\n- size (int): Ukubwa wa orodha.\n    Inarejesha:\n    int: Jumla ya namba shufwa katika orodha ya pembejeo.\n    >>> f_10([1,4,3,2,5], 5)\n    6", "tr": "Bir C fonksiyonu `int f_10(int *numbers, int size)` yazın ve aşağıdaki problemi çözün:\nVerilen bir listedeki çift sayıların toplamını hesaplayın.\n    Parametreler:\n- numbers (list): Bir tamsayı listesi.\n- size (int): Listenin boyutu.\n    Döndürür:\n    int: Girdi listesindeki çift sayıların toplamı.\n    >>> f_10([1,4,3,2,5], 5)\n    6", "vi": "Viết một hàm C `int f_10(int *numbers, int size)` để giải quyết vấn đề sau:\nTính tổng các số chẵn trong một danh sách cho trước.\n    Tham số:\n- numbers (list): Một danh sách các số nguyên.\n- size (int): Kích thước của danh sách.\n    Trả về:\n    int: Tổng các số chẵn trong danh sách đầu vào.\n    >>> f_10([1,4,3,2,5], 5)\n    6", "id": "Tulis fungsi C `int f_10(int *numbers, int size)` untuk menyelesaikan masalah berikut:\nHitung jumlah bilangan genap dalam daftar yang diberikan.\n    Parameter:\n- numbers (list): Daftar bilangan bulat.\n- size (int): Ukuran daftar.\n    Mengembalikan:\n    int: Jumlah bilangan genap dalam daftar input.\n    >>> f_10([1,4,3,2,5], 5)\n    6", "ja": "Cの関数を書け `int f_10(int *numbers, int size)` を作成して、次の問題を解決してください:\n与えられたリスト内の偶数の合計を計算します。\n    パラメータ:\n- numbers (list): 整数のリスト。\n- size (int): リストのサイズ。\n    戻り値:\n    int: 入力リスト内の偶数の合計。\n    >>> f_10([1,4,3,2,5], 5)\n    6", "ko": "C 함수 `int f_10(int *numbers, int size)`를 작성하여 다음 문제를 해결하십시오:\n주어진 리스트에서 짝수의 합을 계산합니다.\n    매개변수:\n- numbers (list): 정수 리스트.\n- size (int): 리스트의 크기.\n    반환값:\n    int: 입력 리스트에서 짝수의 합.\n    >>> f_10([1,4,3,2,5], 5)\n    6", "ml": "C ഭാഷയിൽ ഒരു ഫംഗ്ഷൻ `int f_10(int *numbers, int size)` എഴുതുക താഴെ കൊടുത്തിരിക്കുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nഒരു നൽകിയ ലിസ്റ്റിലെ സമസംഖ്യകളുടെ മൊത്തം കണക്കാക്കുക.\n    പാരാമീറ്ററുകൾ:\n- numbers (list): ഒരു പൂർണ്ണസംഖ്യകളുടെ ലിസ്റ്റ്.\n- size (int): ലിസ്റ്റിന്റെ വലിപ്പം.\n    തിരിച്ചുകൊടുക്കുന്നു:\n    int: ഇൻപുട്ട് ലിസ്റ്റിലെ സമസംഖ്യകളുടെ മൊത്തം.\n    >>> f_10([1,4,3,2,5], 5)\n    6", "fa": "یک تابع C به نام `int f_10(int *numbers, int size)` بنویسید تا مسئله زیر را حل کند:\nمجموع اعداد زوج در یک لیست داده شده را محاسبه کنید.\n    پارامترها:\n- numbers (list): یک لیست از اعداد صحیح.\n- size (int): اندازه لیست.\n    بازگشت:\n    int: مجموع اعداد زوج در لیست ورودی.\n    >>> f_10([1,4,3,2,5], 5)\n    6"}, "level": "easy", "test": "int main() {\n    int sample1[] = {1, 4, 3, 2, 5};\n    int sample2[] = {2, 2, 0, 0};\n    int sample3[] = {7, 11, 19}; // Additional test with no even numbers\n    int sample4[] = {12, 14, 16, 18, 20}; // Additional test with all even numbers\n\n    assert(f_10(sample1, 5) == 6);\n    assert(f_10(sample2, 4) == 4);\n    assert(f_10(sample3, 3) == 0); // Should return 0 because there are no even numbers\n    assert(f_10(sample4, 5) == 12 + 14 + 16 + 18 + 20);\n\n    \n\n    return 0;\n}", "entry_point": "f_10", "signature": "int f_10(int *numbers, int size)", "docstring": {"en": "Calculate the sum of even numbers in a given list.\n    Parameters:\n- numbers (list): A list of integers.\n- size (int): The size of the list.\n    Returns:\n    int: The sum of even numbers in the input list.\n    >>> f_10([1,4,3,2,5], 5)\n    6\n", "sq": "Llogarit shumën e numrave çift në një listë të dhënë.\n    Parametrat:\n- numbers (listë): Një listë me numra të plotë.\n- size (int): Madhësia e listës.\n    Kthen:\n    int: Shuma e numrave çift në listën hyrëse.\n    >>> f_10([1,4,3,2,5], 5)\n    6", "hy": "Հաշվել տրված ցուցակի զույգ թվերի գումարը։\n    Պարամետրեր:\n- numbers (list): Թվերի ցուցակ։\n- size (int): Ցուցակի չափը։\n    Վերադարձնում է:\n    int: Մուտքային ցուցակի զույգ թվերի գումարը։\n    >>> f_10([1,4,3,2,5], 5)\n    6", "bn": "সমস্যার বিবরণ: প্রদত্ত তালিকায় সম সংখ্যাগুলির যোগফল গণনা করুন।\n\n    Args:\n    - numbers (list): পূর্ণসংখ্যার একটি তালিকা।\n    - size (int): তালিকার আকার।\n\n    Returns:\n    int: ইনপুট তালিকায় সম সংখ্যাগুলির যোগফল।\n\n    >>> f_10([1,4,3,2,5], 5)\n    6", "bg": "Изчислява сумата на четните числа в даден списък.\n    Параметри:\n- numbers (list): Списък от цели числа.\n- size (int): Размерът на списъка.\n    Връща:\n    int: Сумата на четните числа в входния списък.\n    >>> f_10([1,4,3,2,5], 5)\n    6", "zh": "计算给定列表中偶数的和。\n    参数:\n- numbers (list): 整数列表。\n- size (int): 列表的大小。\n    返回:\n    int: 输入列表中偶数的和。\n    >>> f_10([1,4,3,2,5], 5)\n    6", "fr": "Calculer la somme des nombres pairs dans une liste donnée.\n    Paramètres:\n- numbers (list): Une liste d'entiers.\n- size (int): La taille de la liste.\n    Renvoie:\n    int: La somme des nombres pairs dans la liste d'entrée.\n    >>> f_10([1,4,3,2,5], 5)\n    6", "de": "Berechne die Summe der geraden Zahlen in einer gegebenen Liste.\n    Parameter:\n- numbers (list): Eine Liste von ganzen Zahlen.\n- size (int): Die Größe der Liste.\n    Rückgabewert:\n    int: Die Summe der geraden Zahlen in der Eingabeliste.\n    >>> f_10([1,4,3,2,5], 5)\n    6", "ha": "Ƙididdige jimillar lambobin da suka dace a cikin jerin da aka bayar.\n    Sigogi:\n- numbers (list): Jerin lambobin cikakke.\n- size (int): Girman jerin.\n    Mayarwa:\n    int: Jimillar lambobin da suka dace a cikin jerin shigarwa.\n    >>> f_10([1,4,3,2,5], 5)\n    6", "hi": "दिए गए सूची में सम संख्या का योग गणना करें।\n    पैरामीटर्स:\n- numbers (list): पूर्णांकों की एक सूची।\n- size (int): सूची का आकार।\n    रिटर्न्स:\n    int: इनपुट सूची में सम संख्याओं का योग।\n    >>> f_10([1,4,3,2,5], 5)\n    6", "hu": "Számítsa ki a páros számok összegét egy adott listában.\n    Paraméterek:\n- numbers (list): Egész számok listája.\n- size (int): A lista mérete.\n    Visszatér:\n    int: A bemeneti listában található páros számok összege.\n    >>> f_10([1,4,3,2,5], 5)\n    6", "es": "Calcular la suma de los números pares en una lista dada.\n    Parámetros:\n- numbers (list): Una lista de enteros.\n- size (int): El tamaño de la lista.\n    Devuelve:\n    int: La suma de los números pares en la lista de entrada.\n    >>> f_10([1,4,3,2,5], 5)\n    6", "arb": "حساب مجموع الأعداد الزوجية في قائمة معينة.\n    المعطيات:\n- numbers (list): قائمة من الأعداد الصحيحة.\n- size (int): حجم القائمة.\n    يعيد:\n    int: مجموع الأعداد الزوجية في القائمة المدخلة.\n    >>> f_10([1,4,3,2,5], 5)\n    6", "sw": "Hesabu jumla ya namba shufwa katika orodha iliyotolewa.\n    Vigezo:\n- numbers (list): Orodha ya namba nzima.\n- size (int): Ukubwa wa orodha.\n    Inarejesha:\n    int: Jumla ya namba shufwa katika orodha ya pembejeo.\n    >>> f_10([1,4,3,2,5], 5)\n    6", "tr": "Verilen bir listedeki çift sayıların toplamını hesaplayın.\n    Parametreler:\n- numbers (list): Bir tamsayı listesi.\n- size (int): Listenin boyutu.\n    Dönüş:\n    int: Girdi listesindeki çift sayıların toplamı.\n    >>> f_10([1,4,3,2,5], 5)\n    6", "vi": "Tính tổng các số chẵn trong một danh sách cho trước.\n    Tham số:\n- numbers (list): Một danh sách các số nguyên.\n- size (int): Kích thước của danh sách.\n    Trả về:\n    int: Tổng các số chẵn trong danh sách đầu vào.\n    >>> f_10([1,4,3,2,5], 5)\n    6", "id": "Hitung jumlah bilangan genap dalam daftar yang diberikan.\n    Parameters:\n- numbers (list): Daftar bilangan bulat.\n- size (int): Ukuran daftar.\n    Returns:\n    int: Jumlah bilangan genap dalam daftar input.\n    >>> f_10([1,4,3,2,5], 5)\n    6", "ja": "与えられたリスト内の偶数の合計を計算します。\n    パラメータ:\n- numbers (list): 整数のリスト。\n- size (int): リストのサイズ。\n    戻り値:\n    int: 入力リスト内の偶数の合計。\n    >>> f_10([1,4,3,2,5], 5)\n    6", "ko": "주어진 리스트에서 짝수의 합을 계산합니다.\n    매개변수:\n- numbers (list): 정수의 리스트.\n- size (int): 리스트의 크기.\n    반환값:\n    int: 입력 리스트에서 짝수의 합.\n    >>> f_10([1,4,3,2,5], 5)\n    6", "ml": "Calculate the sum of even numbers in a given list.\n    പാരാമീറ്ററുകൾ:\n- numbers (list): പൂർണ്ണസംഖ്യകളുടെ പട്ടിക.\n- size (int): പട്ടികയുടെ വലിപ്പം.\n    മടക്കുന്നു:\n    int: ഇൻപുട്ട് പട്ടികയിലെ സമസംഖ്യകളുടെ മൊത്തം.\n    >>> f_10([1,4,3,2,5], 5)\n    6", "fa": "محاسبه مجموع اعداد زوج در یک لیست داده شده.\n    پارامترها:\n- numbers (list): یک لیست از اعداد صحیح.\n- size (int): اندازه لیست.\n    بازگشت:\n    int: مجموع اعداد زوج در لیست ورودی.\n    >>> f_10([1,4,3,2,5], 5)\n    6"}}
{"task_id": "C/11", "prompt": {"en": "#include <assert.h>\n#include <stdio.h>\n/*\nDetermine if two closed intervals intersect.\n​    Args:\n​    a, b: Representing the first closed interval [a, b] where 0 <= a <= b <= 1000.\n​    c, d: Representing the second closed interval [c, d] where 0 <= c <= d <= 1000.\n​    Returns:\n​    int: 1 if the intervals intersect, 0 otherwise.\n*/\nint f_11(int a, int b, int c, int d)", "sq": "#include <assert.h>\n#include <stdio.h>\n/*\nPërcaktoni nëse dy intervale të mbyllura ndërpriten.\n​    Argumentet:\n​    a, b: Përfaqësojnë intervalin e parë të mbyllur [a, b] ku 0 <= a <= b <= 1000.\n​    c, d: Përfaqësojnë intervalin e dytë të mbyllur [c, d] ku 0 <= c <= d <= 1000.\n​    Kthen:\n​    int: 1 nëse intervalet ndërpriten, 0 përndryshe.\n*/\nint f_11(int a, int b, int c, int d)", "hy": "#include <assert.h>\n#include <stdio.h>\n/*\nՈրոշել՝ արդյոք երկու փակ միջակայքեր հատվում են:\n​    Արգումենտներ:\n​    a, b: Ներկայացնում են առաջին փակ միջակայքը [a, b], որտեղ 0 <= a <= b <= 1000:\n​    c, d: Ներկայացնում են երկրորդ փակ միջակայքը [c, d], որտեղ 0 <= c <= d <= 1000:\n​    Վերադարձնում է:\n​    int: 1, եթե միջակայքերը հատվում են, 0՝ հակառակ դեպքում:\n*/\nint f_11(int a, int b, int c, int d)", "bn": "#include <assert.h>\n#include <stdio.h>\n/*\nনির্ধারণ করুন দুটি বন্ধ ইন্টারভাল ছেদ করে কিনা।\n​    আর্গুমেন্ট:\n​    a, b: প্রথম বন্ধ ইন্টারভাল [a, b] উপস্থাপন করছে যেখানে 0 <= a <= b <= 1000।\n​    c, d: দ্বিতীয় বন্ধ ইন্টারভাল [c, d] উপস্থাপন করছে যেখানে 0 <= c <= d <= 1000।\n​    রিটার্ন:\n​    int: 1 যদি ইন্টারভালগুলি ছেদ করে, অন্যথায় 0।\n*/\nint f_11(int a, int b, int c, int d)", "bg": "#include <assert.h>\n#include <stdio.h>\n/*\nОпределете дали два затворени интервала се пресичат.\n​    Аргументи:\n​    a, b: Представляват първия затворен интервал [a, b], където 0 <= a <= b <= 1000.\n​    c, d: Представляват втория затворен интервал [c, d], където 0 <= c <= d <= 1000.\n​    Връща:\n​    int: 1 ако интервалите се пресичат, 0 в противен случай.\n*/\nint f_11(int a, int b, int c, int d)", "zh": "#include <assert.h>\n#include <stdio.h>\n/*\n确定两个闭区间是否相交。\n​    参数:\n​    a, b: 表示第一个闭区间 [a, b]，其中 0 <= a <= b <= 1000。\n​    c, d: 表示第二个闭区间 [c, d]，其中 0 <= c <= d <= 1000。\n​    返回:\n​    int: 如果区间相交返回 1，否则返回 0。\n*/\nint f_11(int a, int b, int c, int d)", "fr": "#include <assert.h>\n#include <stdio.h>\n/*\nDéterminer si deux intervalles fermés se croisent.\n​    Args:\n​    a, b: Représentant le premier intervalle fermé [a, b] où 0 <= a <= b <= 1000.\n​    c, d: Représentant le deuxième intervalle fermé [c, d] où 0 <= c <= d <= 1000.\n​    Retourne:\n​    int: 1 si les intervalles se croisent, 0 sinon.\n*/\nint f_11(int a, int b, int c, int d)", "de": "#include <assert.h>\n#include <stdio.h>\n/*\nBestimmen, ob zwei geschlossene Intervalle sich überschneiden.\n​    Argumente:\n​    a, b: Repräsentieren das erste geschlossene Intervall [a, b], wobei 0 <= a <= b <= 1000.\n​    c, d: Repräsentieren das zweite geschlossene Intervall [c, d], wobei 0 <= c <= d <= 1000.\n​    Rückgabewert:\n​    int: 1, wenn die Intervalle sich überschneiden, 0 andernfalls.\n*/\nint f_11(int a, int b, int c, int d)", "ha": "#include <assert.h>\n#include <stdio.h>\n/*\nKayyade idan tsaka-tsakin rufe guda biyu suna haduwa.\n​    Args:\n​    a, b: Wakiltar tsaka-tsakin rufe na farko [a, b] inda 0 <= a <= b <= 1000.\n​    c, d: Wakiltar tsaka-tsakin rufe na biyu [c, d] inda 0 <= c <= d <= 1000.\n​    Returns:\n​    int: 1 idan tsaka-tsakin suna haduwa, 0 in ba haka ba.\n*/\nint f_11(int a, int b, int c, int d)", "hi": "#include <assert.h>\n#include <stdio.h>\n/*\nनिर्धारित करें कि क्या दो बंद अंतराल एक-दूसरे को काटते हैं।\n​    तर्क:\n​    a, b: पहले बंद अंतराल [a, b] का प्रतिनिधित्व करते हैं जहाँ 0 <= a <= b <= 1000।\n​    c, d: दूसरे बंद अंतराल [c, d] का प्रतिनिधित्व करते हैं जहाँ 0 <= c <= d <= 1000।\n​    वापसी:\n​    int: 1 यदि अंतराल एक-दूसरे को काटते हैं, अन्यथा 0।\n*/\nint f_11(int a, int b, int c, int d)", "hu": "#include <assert.h>\n#include <stdio.h>\n/*\nHatározza meg, hogy két zárt intervallum metszi-e egymást.\n​    Args:\n​    a, b: Az első zárt intervallumot [a, b] képviseli, ahol 0 <= a <= b <= 1000.\n​    c, d: A második zárt intervallumot [c, d] képviseli, ahol 0 <= c <= d <= 1000.\n​    Visszatérési érték:\n​    int: 1, ha az intervallumok metszik egymást, különben 0.\n*/\nint f_11(int a, int b, int c, int d)", "es": "#include <assert.h>\n#include <stdio.h>\n/*\nDeterminar si dos intervalos cerrados se intersectan.\n​    Args:\n​    a, b: Representando el primer intervalo cerrado [a, b] donde 0 <= a <= b <= 1000.\n​    c, d: Representando el segundo intervalo cerrado [c, d] donde 0 <= c <= d <= 1000.\n​    Retorna:\n​    int: 1 si los intervalos se intersectan, 0 en caso contrario.\n*/\nint f_11(int a, int b, int c, int d)", "arb": "#include <assert.h>\n#include <stdio.h>\n/*\nتحديد ما إذا كان هناك تقاطع بين مقطعين مغلقين.\n​    Args:\n​    a, b: تمثل المقطع المغلق الأول [a, b] حيث 0 <= a <= b <= 1000.\n​    c, d: تمثل المقطع المغلق الثاني [c, d] حيث 0 <= c <= d <= 1000.\n​    Returns:\n​    int: 1 إذا كانت المقاطع تتقاطع، 0 خلاف ذلك.\n*/\nint f_11(int a, int b, int c, int d)", "sw": "#include <assert.h>\n#include <stdio.h>\n/*\nTambua kama vipindi viwili vilivyofungwa vinakatana.\n​    Args:\n​    a, b: Inawakilisha kipindi cha kwanza kilichofungwa [a, b] ambapo 0 <= a <= b <= 1000.\n​    c, d: Inawakilisha kipindi cha pili kilichofungwa [c, d] ambapo 0 <= c <= d <= 1000.\n​    Returns:\n​    int: 1 ikiwa vipindi vinakatana, 0 vinginevyo.\n*/\nint f_11(int a, int b, int c, int d)", "tr": "#include <assert.h>\n#include <stdio.h>\n/*\nİki kapalı aralığın kesişip kesişmediğini belirleyin.\n​    Args:\n​    a, b: İlk kapalı aralığı temsil eder [a, b] burada 0 <= a <= b <= 1000.\n​    c, d: İkinci kapalı aralığı temsil eder [c, d] burada 0 <= c <= d <= 1000.\n​    Döndürür:\n​    int: Aralıklar kesişiyorsa 1, aksi takdirde 0.\n*/\nint f_11(int a, int b, int c, int d)", "vi": "#include <assert.h>\n#include <stdio.h>\n/*\nXác định xem hai đoạn đóng có giao nhau hay không.\n​    Args:\n​    a, b: Đại diện cho đoạn đóng thứ nhất [a, b] với điều kiện 0 <= a <= b <= 1000.\n​    c, d: Đại diện cho đoạn đóng thứ hai [c, d] với điều kiện 0 <= c <= d <= 1000.\n​    Trả về:\n​    int: 1 nếu các đoạn giao nhau, 0 nếu không.\n*/\nint f_11(int a, int b, int c, int d)", "id": "#include <assert.h>\n#include <stdio.h>\n/*\nMenentukan apakah dua interval tertutup berpotongan.\n​    Argumen:\n​    a, b: Mewakili interval tertutup pertama [a, b] di mana 0 <= a <= b <= 1000.\n​    c, d: Mewakili interval tertutup kedua [c, d] di mana 0 <= c <= d <= 1000.\n​    Mengembalikan:\n​    int: 1 jika interval berpotongan, 0 jika tidak.\n*/\nint f_11(int a, int b, int c, int d)", "ja": "#include <assert.h>\n#include <stdio.h>\n/*\n二つの閉区間が交差するかどうかを判断します。\n​    引数:\n​    a, b: 最初の閉区間 [a, b] を表します。ここで 0 <= a <= b <= 1000。\n​    c, d: 二番目の閉区間 [c, d] を表します。ここで 0 <= c <= d <= 1000。\n​    戻り値:\n​    int: 区間が交差する場合は 1、そうでない場合は 0。\n*/\nint f_11(int a, int b, int c, int d)", "ko": "#include <assert.h>\n#include <stdio.h>\n/*\n두 닫힌 구간이 교차하는지 확인합니다.\n​    매개변수:\n​    a, b: 첫 번째 닫힌 구간 [a, b]를 나타내며, 0 <= a <= b <= 1000입니다.\n​    c, d: 두 번째 닫힌 구간 [c, d]를 나타내며, 0 <= c <= d <= 1000입니다.\n​    반환값:\n​    int: 구간이 교차하면 1을, 그렇지 않으면 0을 반환합니다.\n*/\nint f_11(int a, int b, int c, int d)", "ml": "#include <assert.h>\n#include <stdio.h>\n/*\nരണ്ടു അടച്ച ഇടവേളകൾ തമ്മിൽ മുറുകിയിട്ടുണ്ടോ എന്ന് നിർണ്ണയിക്കുക.\n​    Args:\n​    a, b: 0 <= a <= b <= 1000 എന്നിടത്ത് ആദ്യത്തെ അടച്ച ഇടവേള [a, b] പ്രതിനിധീകരിക്കുന്നു.\n​    c, d: 0 <= c <= d <= 1000 എന്നിടത്ത് രണ്ടാമത്തെ അടച്ച ഇടവേള [c, d] പ്രതിനിധീകരിക്കുന്നു.\n​    Returns:\n​    int: ഇടവേളകൾ മുറുകിയിട്ടുണ്ടെങ്കിൽ 1, അല്ലാത്ത പക്ഷം 0.\n*/\nint f_11(int a, int b, int c, int d)", "fa": "#include <assert.h>\n#include <stdio.h>\n/*\nتعیین کنید که آیا دو بازه بسته با یکدیگر تلاقی دارند یا خیر.\n​    آرگومان‌ها:\n​    a, b: نمایانگر اولین بازه بسته [a, b] که در آن 0 <= a <= b <= 1000.\n​    c, d: نمایانگر دومین بازه بسته [c, d] که در آن 0 <= c <= d <= 1000.\n​    بازگشت:\n​    int: 1 اگر بازه‌ها تلاقی دارند، در غیر این صورت 0.\n*/\nint f_11(int a, int b, int c, int d)"}, "canonical_solution": "{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}", "instruction": {"en": "Write a C function `int f_11(int a, int b, int c, int d)` to solve the following problem:\nDetermine if two closed intervals intersect.\n    Args:\n    a, b: Representing the first closed interval [a, b] where 0 <= a <= b <= 1000.\n    c, d: Representing the second closed interval [c, d] where 0 <= c <= d <= 1000.\n    Returns:\n    int: 1 if the intervals intersect, 0 otherwise.\n", "sq": "Shkruani një funksion në C `int f_11(int a, int b, int c, int d)` për të zgjidhur problemin e mëposhtëm:\nPërcaktoni nëse dy intervale të mbyllura ndërpriten.  \n    Argumentet:  \n    a, b: Përfaqësojnë intervalin e parë të mbyllur [a, b] ku 0 <= a <= b <= 1000.  \n    c, d: Përfaqësojnë intervalin e dytë të mbyllur [c, d] ku 0 <= c <= d <= 1000.  \n    Kthen:  \n    int: 1 nëse intervalet ndërpriten, 0 përndryshe.  ", "hy": "Գրեք C ֆունկցիա `int f_11(int a, int b, int c, int d)՝ հետևյալ խնդիրը լուծելու համար:\nՈրոշեք, արդյոք երկու փակ միջակայքերը հատվում են:\n    Արգումենտներ:\n    a, b: Ներկայացնում են առաջին փակ միջակայքը [a, b], որտեղ 0 <= a <= b <= 1000:\n    c, d: Ներկայացնում են երկրորդ փակ միջակայքը [c, d], որտեղ 0 <= c <= d <= 1000:\n    Վերադարձնում է:\n    int: 1, եթե միջակայքերը հատվում են, 0՝ հակառակ դեպքում.", "bn": "C ফাংশন `int f_11(int a, int b, int c, int d)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nদুটি বন্ধ ইন্টারভাল পরস্পরকে অতিক্রম করে কিনা নির্ধারণ করুন।\n    Args:\n    a, b: প্রথম বন্ধ ইন্টারভাল [a, b] উপস্থাপন করছে যেখানে 0 <= a <= b <= 1000।\n    c, d: দ্বিতীয় বন্ধ ইন্টারভাল [c, d] উপস্থাপন করছে যেখানে 0 <= c <= d <= 1000।\n    Returns:\n    int: যদি ইন্টারভালগুলি অতিক্রম করে তবে 1, অন্যথায় 0।", "bg": "Напишете C функция `int f_11(int a, int b, int c, int d)` за решаване на следния проблем:\nОпределете дали два затворени интервала се пресичат.\n    Args:\n    a, b: Представляващи първия затворен интервал [a, b], където 0 <= a <= b <= 1000.\n    c, d: Представляващи втория затворен интервал [c, d], където 0 <= c <= d <= 1000.\n    Returns:\n    int: 1 ако интервалите се пресичат, 0 в противен случай.", "zh": "编写一个 C 函数 `int f_11(int a, int b, int c, int d)` 来解决以下问题：\n确定两个闭区间是否相交。\n    参数:\n    a, b: 表示第一个闭区间 [a, b]，其中 0 <= a <= b <= 1000。\n    c, d: 表示第二个闭区间 [c, d]，其中 0 <= c <= d <= 1000。\n    返回:\n    int: 如果区间相交返回 1，否则返回 0。", "fr": "Écrire une fonction C `int f_11(int a, int b, int c, int d)` pour résoudre le problème suivant :\nDéterminer si deux intervalles fermés s'intersectent.\n    Args:\n    a, b : Représentant le premier intervalle fermé [a, b] où 0 <= a <= b <= 1000.\n    c, d : Représentant le second intervalle fermé [c, d] où 0 <= c <= d <= 1000.\n    Returns:\n    int : 1 si les intervalles s'intersectent, 0 sinon.", "de": "Schreiben Sie eine C-Funktion `int f_11(int a, int b, int c, int d)`, um das folgende Problem zu lösen:\nBestimmen Sie, ob zwei abgeschlossene Intervalle sich überschneiden.\n    Args:\n    a, b: Repräsentieren das erste abgeschlossene Intervall [a, b], wobei 0 <= a <= b <= 1000.\n    c, d: Repräsentieren das zweite abgeschlossene Intervall [c, d], wobei 0 <= c <= d <= 1000.\n    Returns:\n    int: 1, wenn die Intervalle sich überschneiden, 0 andernfalls.", "ha": "Rubuta wani aikin C `int f_11(int a, int b, int c, int d)` don warware matsalar mai zuwa:\nGano idan wasu tazara biyu masu rufewa suna haduwa.\n    Args:\n    a, b: Wakiltar tazara ta farko mai rufewa [a, b] inda 0 <= a <= b <= 1000.\n    c, d: Wakiltar tazara ta biyu mai rufewa [c, d] inda 0 <= c <= d <= 1000.\n    Returns:\n    int: 1 idan tazarorin suna haduwa, 0 in ba haka ba.", "hi": "C फ़ंक्शन `int f_11(int a, int b, int c, int d)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nनिर्धारित करें कि दो बंद अंतराल परस्पर संबंधित हैं या नहीं।\n    तर्क:\n    a, b: पहले बंद अंतराल [a, b] का प्रतिनिधित्व करते हैं जहाँ 0 <= a <= b <= 1000।\n    c, d: दूसरे बंद अंतराल [c, d] का प्रतिनिधित्व करते हैं जहाँ 0 <= c <= d <= 1000।\n    वापसी:\n    int: 1 यदि अंतराल परस्पर संबंधित हैं, अन्यथा 0।", "hu": "Írj egy C függvényt `int f_11(int a, int b, int c, int d)` a következő probléma megoldására:\nHatározd meg, hogy két zárt intervallum metszi-e egymást.\n    Args:\n    a, b: Az első zárt intervallumot [a, b] képviselik, ahol 0 <= a <= b <= 1000.\n    c, d: A második zárt intervallumot [c, d] képviselik, ahol 0 <= c <= d <= 1000.\n    Returns:\n    int: 1, ha az intervallumok metszik egymást, 0 különben.", "es": "Escribe una función en C `int f_11(int a, int b, int c, int d)` para resolver el siguiente problema:\nDeterminar si dos intervalos cerrados se intersectan.\n    Args:\n    a, b: Representando el primer intervalo cerrado [a, b] donde 0 <= a <= b <= 1000.\n    c, d: Representando el segundo intervalo cerrado [c, d] donde 0 <= c <= d <= 1000.\n    Returns:\n    int: 1 si los intervalos se intersectan, 0 en caso contrario.", "arb": "اكتب دالة C `int f_11(int a, int b, int c, int d)` لحل المشكلة التالية:\nتحديد ما إذا كانت فترتان مغلقتان تتقاطعان.\n    Args:\n    a, b: تمثل الفترة المغلقة الأولى [a, b] حيث 0 <= a <= b <= 1000.\n    c, d: تمثل الفترة المغلقة الثانية [c, d] حيث 0 <= c <= d <= 1000.\n    Returns:\n    int: 1 إذا كانت الفترات تتقاطع، 0 خلاف ذلك.", "sw": "Andika kazi ya C `int f_11(int a, int b, int c, int d)` kutatua tatizo lifuatalo:\nTambua kama vipindi viwili vilivyofungwa vinakatana.\n    Args:\n    a, b: Inawakilisha kipindi cha kwanza kilichofungwa [a, b] ambapo 0 <= a <= b <= 1000.\n    c, d: Inawakilisha kipindi cha pili kilichofungwa [c, d] ambapo 0 <= c <= d <= 1000.\n    Returns:\n    int: 1 ikiwa vipindi vinakatana, 0 vinginevyo.", "tr": "Bir C fonksiyonu `int f_11(int a, int b, int c, int d)` yazın ve aşağıdaki problemi çözün:\nİki kapalı aralığın kesişip kesişmediğini belirleyin.\n    Args:\n    a, b: İlk kapalı aralığı [a, b] temsil eder ve 0 <= a <= b <= 1000.\n    c, d: İkinci kapalı aralığı [c, d] temsil eder ve 0 <= c <= d <= 1000.\n    Returns:\n    int: Aralıklar kesişiyorsa 1, aksi takdirde 0.", "vi": "Viết một hàm C `int f_11(int a, int b, int c, int d)` để giải quyết vấn đề sau:\nXác định xem hai đoạn đóng có giao nhau hay không.\n    Args:\n    a, b: Đại diện cho đoạn đóng thứ nhất [a, b] với điều kiện 0 <= a <= b <= 1000.\n    c, d: Đại diện cho đoạn đóng thứ hai [c, d] với điều kiện 0 <= c <= d <= 1000.\n    Trả về:\n    int: 1 nếu các đoạn giao nhau, 0 nếu không.", "id": "Tulis fungsi C `int f_11(int a, int b, int c, int d)` untuk menyelesaikan masalah berikut:\nMenentukan apakah dua interval tertutup saling berpotongan.\n    Args:\n    a, b: Mewakili interval tertutup pertama [a, b] di mana 0 <= a <= b <= 1000.\n    c, d: Mewakili interval tertutup kedua [c, d] di mana 0 <= c <= d <= 1000.\n    Returns:\n    int: 1 jika interval berpotongan, 0 jika tidak.", "ja": "Cの関数を書け `int f_11(int a, int b, int c, int d)` を作成して、次の問題を解決してください:\n2つの閉区間が交差するかどうかを判断します。\n    引数:\n    a, b: 最初の閉区間 [a, b] を表します。ここで 0 <= a <= b <= 1000。\n    c, d: 2番目の閉区間 [c, d] を表します。ここで 0 <= c <= d <= 1000。\n    戻り値:\n    int: 区間が交差する場合は1、そうでない場合は0。", "ko": "C 함수 `int f_11(int a, int b, int c, int d)`를 작성하여 다음 문제를 해결하십시오:\n두 개의 닫힌 구간이 교차하는지 여부를 결정합니다.\n    Args:\n    a, b: 첫 번째 닫힌 구간 [a, b]를 나타내며, 0 <= a <= b <= 1000입니다.\n    c, d: 두 번째 닫힌 구간 [c, d]를 나타내며, 0 <= c <= d <= 1000입니다.\n    Returns:\n    int: 구간이 교차하면 1을 반환하고, 그렇지 않으면 0을 반환합니다.", "ml": "C ഭാഷയിൽ ഒരു ഫങ്ഷൻ `int f_11(int a, int b, int c, int d)` എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nരണ്ടു അടച്ച ഇടവേളകൾ തമ്മിൽ മുട്ടുന്നുണ്ടോ എന്ന് നിർണയിക്കുക.\n    Args:\n    a, b: ആദ്യത്തെ അടച്ച ഇടവേള [a, b] പ്രതിനിധീകരിക്കുന്നു, ഇവിടെ 0 <= a <= b <= 1000.\n    c, d: രണ്ടാം അടച്ച ഇടവേള [c, d] പ്രതിനിധീകരിക്കുന്നു, ഇവിടെ 0 <= c <= d <= 1000.\n    Returns:\n    int: ഇടവേളകൾ മുട്ടുന്നുണ്ടെങ്കിൽ 1, അല്ലെങ്കിൽ 0.", "fa": "یک تابع C بنویسید `int f_11(int a, int b, int c, int d)` برای حل مشکل زیر:\nتعیین کنید آیا دو بازه بسته با یکدیگر تداخل دارند.\n    آرگومان‌ها:\n    a, b: نشان‌دهنده اولین بازه بسته [a, b] که در آن 0 <= a <= b <= 1000.\n    c, d: نشان‌دهنده دومین بازه بسته [c, d] که در آن 0 <= c <= d <= 1000.\n    بازگشت:\n    int: اگر بازه‌ها تداخل داشته باشند 1 و در غیر این صورت 0."}, "level": "easy", "test": "int main() {\n    assert(f_11(1, 1, 1, 2) == 1);\n    assert(f_11(3, 5, 2, 6) == 1);\n    assert(f_11(3, 5, 4, 7) == 1);\n    assert(f_11(3, 5, 6, 7) == 0);\n    // Additional test cases\n    assert(f_11(0, 0, 0, 0) == 1);\n    assert(f_11(1, 3, 2, 4) == 1);\n    assert(f_11(1, 3, 4, 6) == 0);\n    assert(f_11(10, 20, 20, 30) == 1);\n    assert(f_11(10, 20, 21, 30) == 0);\n    \n    return 0;\n}", "entry_point": "f_11", "signature": "int f_11(int a, int b, int c, int d)", "docstring": {"en": "Determine if two closed intervals intersect.\n    Args:\n    a, b: Representing the first closed interval [a, b] where 0 <= a <= b <= 1000.\n    c, d: Representing the second closed interval [c, d] where 0 <= c <= d <= 1000.\n    Returns:\n    int: 1 if the intervals intersect, 0 otherwise.\n", "sq": "Përcaktoni nëse dy intervale të mbyllura ndërpriten.\n    Argumentet:\n    a, b: Përfaqësojnë intervalin e parë të mbyllur [a, b] ku 0 <= a <= b <= 1000.\n    c, d: Përfaqësojnë intervalin e dytë të mbyllur [c, d] ku 0 <= c <= d <= 1000.\n    Kthen:\n    int: 1 nëse intervalet ndërpriten, 0 përndryshe.", "hy": "Սահմանել, արդյոք երկու փակ միջակայքերը հատվում են:\n    Արձանագրումներ:\n    a, b: Ներկայացնում են առաջին փակ միջակայքը [a, b], որտեղ 0 <= a <= b <= 1000:\n    c, d: Ներկայացնում են երկրորդ փակ միջակայքը [c, d], որտեղ 0 <= c <= d <= 1000:\n    Վերադարձնում է:\n    int: 1, եթե միջակայքերը հատվում են, 0՝ հակառակ դեպքում:", "bn": "নির্ধারণ করুন দুটি বন্ধ ইন্টারভাল ছেদ করে কিনা।\n    আর্গুমেন্ট:\n    a, b: প্রথম বন্ধ ইন্টারভাল [a, b] উপস্থাপন করছে যেখানে 0 <= a <= b <= 1000।\n    c, d: দ্বিতীয় বন্ধ ইন্টারভাল [c, d] উপস্থাপন করছে যেখানে 0 <= c <= d <= 1000।\n    Returns:\n    int: 1 যদি ইন্টারভালগুলি ছেদ করে, অন্যথায় 0।", "bg": "Определете дали два затворени интервала се пресичат.\n    Аргументи:\n    a, b: Представлява първия затворен интервал [a, b], където 0 <= a <= b <= 1000.\n    c, d: Представлява втория затворен интервал [c, d], където 0 <= c <= d <= 1000.\n    Връща:\n    int: 1 ако интервалите се пресичат, 0 в противен случай.", "zh": "确定两个闭区间是否相交。\n    参数:\n    a, b: 表示第一个闭区间 [a, b]，其中 0 <= a <= b <= 1000。\n    c, d: 表示第二个闭区间 [c, d]，其中 0 <= c <= d <= 1000。\n    返回:\n    int: 如果区间相交则返回 1，否则返回 0。", "fr": "Déterminer si deux intervalles fermés s'intersectent.\n    Args:\n    a, b: Représentant le premier intervalle fermé [a, b] où 0 <= a <= b <= 1000.\n    c, d: Représentant le deuxième intervalle fermé [c, d] où 0 <= c <= d <= 1000.\n    Returns:\n    int: 1 si les intervalles s'intersectent, 0 sinon.", "de": "Bestimmen, ob zwei geschlossene Intervalle sich überschneiden.\n    Args:\n    a, b: Repräsentiert das erste geschlossene Intervall [a, b], wobei 0 <= a <= b <= 1000.\n    c, d: Repräsentiert das zweite geschlossene Intervall [c, d], wobei 0 <= c <= d <= 1000.\n    Returns:\n    int: 1, wenn die Intervalle sich überschneiden, 0 andernfalls.", "ha": "Kayyade idan tsaka-tsakin rufe guda biyu suna haduwa.\n    Args:\n    a, b: Wakiltar farkon rufaffen tazara [a, b] inda 0 <= a <= b <= 1000.\n    c, d: Wakiltar na biyu rufaffen tazara [c, d] inda 0 <= c <= d <= 1000.\n    Returns:\n    int: 1 idan tazarar sun haɗu, 0 in ba haka ba.", "hi": "दो बंद अंतरालों के प्रतिच्छेदन का निर्धारण करें।\n    Args:\n    a, b: पहले बंद अंतराल [a, b] का प्रतिनिधित्व करते हैं जहाँ 0 <= a <= b <= 1000।\n    c, d: दूसरे बंद अंतराल [c, d] का प्रतिनिधित्व करते हैं जहाँ 0 <= c <= d <= 1000।\n    Returns:\n    int: 1 यदि अंतराल प्रतिच्छेदित होते हैं, अन्यथा 0।", "hu": "Határozza meg, hogy két zárt intervallum metszi-e egymást.\n    Args:\n    a, b: Az első zárt intervallumot [a, b] jelöli, ahol 0 <= a <= b <= 1000.\n    c, d: A második zárt intervallumot [c, d] jelöli, ahol 0 <= c <= d <= 1000.\n    Returns:\n    int: 1, ha az intervallumok metszik egymást, 0 különben.", "es": "Determinar si dos intervalos cerrados se intersectan.\n    Args:\n    a, b: Representando el primer intervalo cerrado [a, b] donde 0 <= a <= b <= 1000.\n    c, d: Representando el segundo intervalo cerrado [c, d] donde 0 <= c <= d <= 1000.\n    Returns:\n    int: 1 si los intervalos se intersectan, 0 en caso contrario.", "arb": "تحديد ما إذا كان هناك تقاطع بين فترتين مغلقتين.  \n    Args:  \n    a, b: تمثل الفترة المغلقة الأولى [a, b] حيث 0 <= a <= b <= 1000.  \n    c, d: تمثل الفترة المغلقة الثانية [c, d] حيث 0 <= c <= d <= 1000.  \n    Returns:  \n    int: 1 إذا كانت الفترات تتقاطع، 0 خلاف ذلك.  ", "sw": "Tambua kama vipindi viwili vilivyofungwa vinakatana.\n    Args:\n    a, b: Inawakilisha kipengele cha kwanza kilichofungwa [a, b] ambapo 0 <= a <= b <= 1000.\n    c, d: Inawakilisha kipengele cha pili kilichofungwa [c, d] ambapo 0 <= c <= d <= 1000.\n    Returns:\n    int: 1 ikiwa vipengele vinaingiliana, 0 vinginevyo.", "tr": "İki kapalı aralığın kesişip kesişmediğini belirleyin.\n    Args:\n    a, b: İlk kapalı aralığı temsil eden [a, b] burada 0 <= a <= b <= 1000.\n    c, d: İkinci kapalı aralığı temsil eden [c, d] burada 0 <= c <= d <= 1000.\n    Returns:\n    int: Aralıklar kesişiyorsa 1, aksi takdirde 0.", "vi": "Xác định xem hai khoảng đóng có giao nhau hay không.\n    Args:\n    a, b: Đại diện cho khoảng đóng đầu tiên [a, b] với 0 <= a <= b <= 1000.\n    c, d: Đại diện cho khoảng đóng thứ hai [c, d] với 0 <= c <= d <= 1000.\n    Kết quả trả về:\n    int: 1 nếu các khoảng giao nhau, 0 nếu không.", "id": "Menentukan apakah dua interval tertutup berpotongan.\n    Args:\n    a, b: Mewakili interval tertutup pertama [a, b] di mana 0 <= a <= b <= 1000.\n    c, d: Mewakili interval tertutup kedua [c, d] di mana 0 <= c <= d <= 1000.\n    Returns:\n    int: 1 jika interval berpotongan, 0 jika tidak.", "ja": "2つの閉区間が交差するかどうかを判定します。\n    引数:\n    a, b: 最初の閉区間 [a, b] を表します。ここで 0 <= a <= b <= 1000。\n    c, d: 2番目の閉区間 [c, d] を表します。ここで 0 <= c <= d <= 1000。\n    戻り値:\n    int: 区間が交差する場合は1、そうでない場合は0。", "ko": "두 닫힌 구간이 교차하는지 결정합니다.\n    Args:\n    a, b: 첫 번째 닫힌 구간 [a, b]을 나타내며, 0 <= a <= b <= 1000입니다.\n    c, d: 두 번째 닫힌 구간 [c, d]을 나타내며, 0 <= c <= d <= 1000입니다.\n    Returns:\n    int: 구간이 교차하면 1을, 그렇지 않으면 0을 반환합니다.", "ml": "രണ്ട് അടച്ച ഇടവേളകൾ തമ്മിൽ മുട്ടുന്നുണ്ടോ എന്ന് നിർണ്ണയിക്കുക.  \n    Args:  \n    a, b: ആദ്യത്തെ അടച്ച ഇടവേള [a, b] പ്രതിനിധീകരിക്കുന്നു, ഇവിടെ 0 <= a <= b <= 1000.  \n    c, d: രണ്ടാം അടച്ച ഇടവേള [c, d] പ്രതിനിധീകരിക്കുന്നു, ഇവിടെ 0 <= c <= d <= 1000.  \n    Returns:  \n    int: ഇടവേളകൾ തമ്മിൽ മുട്ടുന്നുണ്ടെങ്കിൽ 1, അല്ലെങ്കിൽ 0.  ", "fa": "Determine if two closed intervals intersect.\n    آرگومان‌ها:\n    a, b: نمایانگر اولین بازه بسته [a, b] که در آن 0 <= a <= b <= 1000.\n    c, d: نمایانگر دومین بازه بسته [c, d] که در آن 0 <= c <= d <= 1000.\n    بازگشتی:\n    int: 1 اگر بازه‌ها تلاقی داشته باشند، در غیر این صورت 0."}}
{"task_id": "C/12", "prompt": {"en": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nYou are given three digits a, b, c. Two of them are equal, but the third one is different from the other two. Find the value that occurs exactly once.\n    >>> f_12(0,0,1)\n    1\n    >>> f_12(4,3,4)\n    3\n*/\nint f_12(int a, int b, int c)", "sq": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nJu jepen tre shifra a, b, c. Dy prej tyre janë të barabarta, por e treta është e ndryshme nga dy të tjerat. Gjeni vlerën që ndodh saktësisht një herë.\n    >>> f_12(0,0,1)\n    1\n    >>> f_12(4,3,4)\n    3\n*/\nint f_12(int a, int b, int c)", "hy": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nՁեզ տրվում են երեք թվանշան a, b, c։ Դրանցից երկուսը հավասար են, բայց երրորդը տարբերվում է մյուս երկուսից։ Գտեք այն արժեքը, որը հանդիպում է միայն մեկ անգամ։\n    >>> f_12(0,0,1)\n    1\n    >>> f_12(4,3,4)\n    3\n*/\nint f_12(int a, int b, int c)", "bn": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nতোমাকে তিনটি অঙ্ক দেওয়া হয়েছে a, b, c। এর মধ্যে দুটি সমান, কিন্তু তৃতীয়টি অন্য দুইটির থেকে ভিন্ন। যে মানটি ঠিক একবার ঘটে তা খুঁজে বের করো।\n    >>> f_12(0,0,1)\n    1\n    >>> f_12(4,3,4)\n    3\n*/\nint f_12(int a, int b, int c)", "bg": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nДадени са ви три цифри a, b, c. Две от тях са равни, но третата е различна от другите две. Намерете стойността, която се среща точно веднъж.\n    >>> f_12(0,0,1)\n    1\n    >>> f_12(4,3,4)\n    3\n*/\nint f_12(int a, int b, int c)", "zh": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\n给定三个数字 a, b, c。其中两个是相等的，但第三个与其他两个不同。找出只出现一次的值。\n    >>> f_12(0,0,1)\n    1\n    >>> f_12(4,3,4)\n    3\n*/\nint f_12(int a, int b, int c)", "fr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nOn vous donne trois chiffres a, b, c. Deux d'entre eux sont égaux, mais le troisième est différent des deux autres. Trouvez la valeur qui apparaît exactement une fois.\n    >>> f_12(0,0,1)\n    1\n    >>> f_12(4,3,4)\n    3\n*/\nint f_12(int a, int b, int c)", "de": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nSie haben drei Ziffern a, b, c. Zwei von ihnen sind gleich, aber die dritte unterscheidet sich von den anderen beiden. Finden Sie den Wert, der genau einmal vorkommt.\n    >>> f_12(0,0,1)\n    1\n    >>> f_12(4,3,4)\n    3\n*/\nint f_12(int a, int b, int c)", "ha": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nAn ba ku lambobi uku a, b, c. Biyu daga cikinsu suna daidai, amma na uku ya bambanta da sauran biyun. Nemo ƙimar da ta bayyana sau ɗaya kawai.\n    >>> f_12(0,0,1)\n    1\n    >>> f_12(4,3,4)\n    3\n*/\nint f_12(int a, int b, int c)", "hi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nआपको तीन अंक दिए गए हैं a, b, c। इनमें से दो समान हैं, लेकिन तीसरा अन्य दो से भिन्न है। उस मान को खोजें जो केवल एक बार आता है।\n    >>> f_12(0,0,1)\n    1\n    >>> f_12(4,3,4)\n    3\n*/\nint f_12(int a, int b, int c)", "hu": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nHárom számjegyet kap, a, b, c. Kettő közülük egyenlő, de a harmadik különbözik a másik kettőtől. Keresse meg azt az értéket, amely pontosan egyszer fordul elő.\n    >>> f_12(0,0,1)\n    1\n    >>> f_12(4,3,4)\n    3\n*/\nint f_12(int a, int b, int c)", "es": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nSe te dan tres dígitos a, b, c. Dos de ellos son iguales, pero el tercero es diferente de los otros dos. Encuentra el valor que ocurre exactamente una vez.\n    >>> f_12(0,0,1)\n    1\n    >>> f_12(4,3,4)\n    3\n*/\nint f_12(int a, int b, int c)", "arb": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nيتم إعطاؤك ثلاثة أرقام a و b و c. اثنان منهما متساويان، لكن الثالث مختلف عن الاثنين الآخرين. جد القيمة التي تحدث مرة واحدة فقط.\n    >>> f_12(0,0,1)\n    1\n    >>> f_12(4,3,4)\n    3\n*/\nint f_12(int a, int b, int c)", "sw": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nUmepewa tarakimu tatu a, b, c. Mbili kati ya hizo ni sawa, lakini ya tatu ni tofauti na zile nyingine mbili. Tafuta thamani inayotokea mara moja tu.\n    >>> f_12(0,0,1)\n    1\n    >>> f_12(4,3,4)\n    3\n*/\nint f_12(int a, int b, int c)", "tr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nÜç rakam verilir: a, b, c. Bunlardan ikisi eşittir, ancak üçüncüsü diğer ikisinden farklıdır. Tam olarak bir kez meydana gelen değeri bulun.\n    >>> f_12(0,0,1)\n    1\n    >>> f_12(4,3,4)\n    3\n*/\nint f_12(int a, int b, int c)", "vi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nBạn được cho ba chữ số a, b, c. Hai trong số chúng bằng nhau, nhưng chữ số thứ ba khác với hai chữ số còn lại. Tìm giá trị xuất hiện chính xác một lần.\n    >>> f_12(0,0,1)\n    1\n    >>> f_12(4,3,4)\n    3\n*/\nint f_12(int a, int b, int c)", "id": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nAnda diberikan tiga digit a, b, c. Dua di antaranya sama, tetapi yang ketiga berbeda dari dua lainnya. Temukan nilai yang muncul tepat sekali.\n    >>> f_12(0,0,1)\n    1\n    >>> f_12(4,3,4)\n    3\n*/\nint f_12(int a, int b, int c)", "ja": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\n3つの数字 a, b, c が与えられます。そのうち2つは等しく、残りの1つは他の2つと異なります。ちょうど1回だけ現れる値を見つけてください。\n    >>> f_12(0,0,1)\n    1\n    >>> f_12(4,3,4)\n    3\n*/\nint f_12(int a, int b, int c)", "ko": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\n세 숫자 a, b, c가 주어집니다. 그 중 두 숫자는 같고, 나머지 하나는 다른 두 숫자와 다릅니다. 정확히 한 번만 나타나는 값을 찾으세요.\n    >>> f_12(0,0,1)\n    1\n    >>> f_12(4,3,4)\n    3\n*/\nint f_12(int a, int b, int c)", "ml": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nനിങ്ങൾക്ക് മൂന്ന് അക്കങ്ങൾ a, b, c നൽകിയിരിക്കുന്നു. അവയിൽ രണ്ടെണ്ണം തുല്യമാണ്, പക്ഷേ മൂന്നാമത്തേത് മറ്റവയുമായി വ്യത്യസ്തമാണ്. ഒരിക്കൽ മാത്രം സംഭവിക്കുന്ന മൂല്യം കണ്ടെത്തുക.\n    >>> f_12(0,0,1)\n    1\n    >>> f_12(4,3,4)\n    3\n*/\nint f_12(int a, int b, int c)", "fa": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nسه رقم a، b، c به شما داده شده است. دو تا از آنها برابر هستند، اما سومی با دو تای دیگر متفاوت است. مقداری را پیدا کنید که دقیقاً یک بار ظاهر می‌شود.\n    >>> f_12(0,0,1)\n    1\n    >>> f_12(4,3,4)\n    3\n*/\nint f_12(int a, int b, int c)"}, "canonical_solution": "{\n    if (a == b)\n        return c;\n    else if (a == c)\n        return b;\n    else\n        return a;\n}", "instruction": {"en": "Write a C function `int f_12(int a, int b, int c)` to solve the following problem:\nYou are given three digits a, b, c. Two of them are equal, but the third one is different from the other two. Find the value that occurs exactly once.\n    >>> f_12(0,0,1)\n    1\n    >>> f_12(4,3,4)\n    3\n", "sq": "Shkruani një funksion në C `int f_12(int a, int b, int c)` për të zgjidhur problemin e mëposhtëm:\nJu jepen tre shifra a, b, c. Dy prej tyre janë të barabarta, por e treta është e ndryshme nga dy të tjerat. Gjeni vlerën që ndodh saktësisht një herë.\n    >>> f_12(0,0,1)\n    1\n    >>> f_12(4,3,4)\n    3", "hy": "Գրեք C ֆունկցիա `int f_12(int a, int b, int c)`՝ հետևյալ խնդիրը լուծելու համար:\nՁեզ տրված են երեք թվանշան a, b, c։ Դրանցից երկուսը հավասար են, բայց երրորդը տարբերվում է մյուս երկուսից։ Գտեք այն արժեքը, որը հանդիպում է միայն մեկ անգամ:\n    >>> f_12(0,0,1)\n    1\n    >>> f_12(4,3,4)\n    3", "bn": "একটি C ফাংশন `int f_12(int a, int b, int c)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nআপনাকে তিনটি সংখ্যা a, b, c দেওয়া হয়েছে। এর মধ্যে দুটি সংখ্যা সমান, কিন্তু তৃতীয়টি অন্য দুটি থেকে ভিন্ন। সেই মানটি খুঁজে বের করুন যা ঠিক একবার ঘটে।\n    >>> f_12(0,0,1)\n    1\n    >>> f_12(4,3,4)\n    3", "bg": "Напишете C функция `int f_12(int a, int b, int c)`, за да решите следния проблем:\nДадени са ви три цифри a, b, c. Две от тях са равни, но третата е различна от другите две. Намерете стойността, която се среща точно веднъж.  \n    >>> f_12(0,0,1)  \n    1  \n    >>> f_12(4,3,4)  \n    3  ", "zh": "编写一个 C 函数 `int f_12(int a, int b, int c)` 来解决以下问题：\n给定三个数字 a, b, c。其中两个是相等的，但第三个与其他两个不同。找出只出现一次的值。", "fr": "Écrire une fonction C `int f_12(int a, int b, int c)` pour résoudre le problème suivant:\nOn vous donne trois chiffres a, b, c. Deux d'entre eux sont égaux, mais le troisième est différent des deux autres. Trouvez la valeur qui apparaît exactement une fois.  \n    >>> f_12(0,0,1)  \n    1  \n    >>> f_12(4,3,4)  \n    3  ", "de": "Schreiben Sie eine C-Funktion `int f_12(int a, int b, int c)`, um das folgende Problem zu lösen:\nSie haben drei Ziffern a, b, c. Zwei von ihnen sind gleich, aber die dritte unterscheidet sich von den anderen beiden. Finden Sie den Wert, der genau einmal vorkommt.\n    >>> f_12(0,0,1)\n    1\n    >>> f_12(4,3,4)\n    3", "ha": "Rubuta wani aikin C `int f_12(int a, int b, int c)` don warware matsalar mai zuwa:\nAn ba ku lambobi guda uku a, b, c. Biyu daga cikinsu suna daidai, amma na ukun ya bambanta da sauran biyun. Nemo darajar da ta bayyana sau daya kawai.", "hi": "C फ़ंक्शन `int f_12(int a, int b, int c)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nआपको तीन अंक a, b, c दिए गए हैं। इनमें से दो समान हैं, लेकिन तीसरा अन्य दो से भिन्न है। उस मान को खोजें जो केवल एक बार आता है।", "hu": "Írj egy C függvényt `int f_12(int a, int b, int c)` a következő probléma megoldására:\nHárom számjegy van megadva: a, b, c. Kettő közülük egyenlő, de a harmadik eltér a másik kettőtől. Találd meg azt az értéket, amely pontosan egyszer fordul elő.\n    >>> f_12(0,0,1)\n    1\n    >>> f_12(4,3,4)\n    3", "es": "Escribe una función en C `int f_12(int a, int b, int c)` para resolver el siguiente problema:\nSe te dan tres dígitos a, b, c. Dos de ellos son iguales, pero el tercero es diferente de los otros dos. Encuentra el valor que ocurre exactamente una vez.\n    >>> f_12(0,0,1)\n    1\n    >>> f_12(4,3,4)\n    3", "arb": "اكتب دالة بلغة C `int f_12(int a, int b, int c)` لحل المشكلة التالية:\nأنت مُعطى ثلاثة أرقام a، b، c. اثنان منهما متساويان، لكن الثالث مختلف عن الاثنين الآخرين. جد القيمة التي تظهر مرة واحدة فقط.\n    >>> f_12(0,0,1)\n    1\n    >>> f_12(4,3,4)\n    3", "sw": "Andika kazi ya C `int f_12(int a, int b, int c)` kutatua tatizo lifuatalo:\nUmepewa tarakimu tatu a, b, c. Mbili kati ya hizo ni sawa, lakini ya tatu ni tofauti na zile mbili nyingine. Tafuta thamani inayotokea mara moja tu.\n    >>> f_12(0,0,1)\n    1\n    >>> f_12(4,3,4)\n    3", "tr": "Bir C fonksiyonu `int f_12(int a, int b, int c)` yazın ve aşağıdaki problemi çözün:\nÜç rakam verilir: a, b, c. Bunlardan ikisi eşittir, ancak üçüncüsü diğer ikisinden farklıdır. Tam olarak bir kez meydana gelen değeri bulun.\n    >>> f_12(0,0,1)\n    1\n    >>> f_12(4,3,4)\n    3", "vi": "Viết một hàm C `int f_12(int a, int b, int c)` để giải quyết vấn đề sau:\nBạn được cho ba chữ số a, b, c. Hai trong số chúng bằng nhau, nhưng chữ số thứ ba khác với hai chữ số còn lại. Tìm giá trị xuất hiện chính xác một lần.\n    >>> f_12(0,0,1)\n    1\n    >>> f_12(4,3,4)\n    3", "id": "Tulis fungsi C `int f_12(int a, int b, int c)` untuk menyelesaikan masalah berikut:\nAnda diberikan tiga digit a, b, c. Dua dari mereka sama, tetapi yang ketiga berbeda dari dua lainnya. Temukan nilai yang muncul tepat sekali.\n    >>> f_12(0,0,1)\n    1\n    >>> f_12(4,3,4)\n    3", "ja": "Cの関数を書け `int f_12(int a, int b, int c)` を作成して、次の問題を解決してください:\n3つの数字 a, b, c が与えられます。そのうち2つは等しく、残りの1つは他の2つと異なります。ちょうど1回だけ現れる値を見つけてください。\n    >>> f_12(0,0,1)\n    1\n    >>> f_12(4,3,4)\n    3", "ko": "C 언어 함수 `int f_12(int a, int b, int c)`를 작성하여 다음 문제를 해결하십시오:\n세 개의 숫자 a, b, c가 주어집니다. 이 중 두 개는 같고, 나머지 하나는 다른 두 개와 다릅니다. 정확히 한 번만 나타나는 값을 찾으십시오.\n    >>> f_12(0,0,1)\n    1\n    >>> f_12(4,3,4)\n    3", "ml": "C ഭാഷയിൽ `int f_12(int a, int b, int c)` എന്ന ഫംഗ്ഷൻ എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nനിങ്ങൾക്ക് മൂന്ന് അക്കങ്ങൾ a, b, c ലഭ്യമാണ്. അവയിൽ രണ്ടെണ്ണം തുല്യമാണ്, പക്ഷേ മൂന്നാമത്തേത് മറ്റവയിലേതിനും വ്യത്യസ്തമാണ്. ഒരിക്കൽ മാത്രം സംഭവിക്കുന്ന മൂല്യം കണ്ടെത്തുക.\n    >>> f_12(0,0,1)\n    1\n    >>> f_12(4,3,4)\n    3", "fa": "یک تابع C به نام `int f_12(int a, int b, int c)` بنویسید تا مسئله زیر را حل کند:\nبه شما سه رقم a، b، c داده شده است. دو تا از آنها برابر هستند، اما سومی با دو تای دیگر متفاوت است. مقداری را پیدا کنید که دقیقاً یک بار ظاهر می‌شود.\n    >>> f_12(0,0,1)\n    1\n    >>> f_12(4,3,4)\n    3"}, "level": "easy", "test": "int main()\n{\n    assert(f_12(2, 7, 2) == 7);\n    assert(f_12(3, 2, 2) == 3);\n    assert(f_12(5, 5, 1) == 1);\n    assert(f_12(500000000, 3, 500000000) == 3);\n    assert(f_12(500000000, 500000000, 3) == 3);\n    return 0;\n}", "entry_point": "f_12", "signature": "int f_12(int a, int b, int c)", "docstring": {"en": "You are given three digits a, b, c. Two of them are equal, but the third one is different from the other two. Find the value that occurs exactly once.\n    >>> f_12(0,0,1)\n    1\n    >>> f_12(4,3,4)\n    3\n", "sq": "Ju janë dhënë tre shifra a, b, c. Dy prej tyre janë të barabarta, por e treta është e ndryshme nga dy të tjerat. Gjeni vlerën që ndodh saktësisht një herë.\n    >>> f_12(0,0,1)\n    1\n    >>> f_12(4,3,4)\n    3", "hy": "Ձեզ տրված են երեք թվանշան՝ a, b, c։ Նրանցից երկուսը հավասար են, բայց երրորդը տարբերվում է մյուս երկուսից։ Գտեք այն արժեքը, որը հանդիպում է միայն մեկ անգամ։\n    >>> f_12(0,0,1)\n    1\n    >>> f_12(4,3,4)\n    3", "bn": "তোমাকে তিনটি সংখ্যা দেওয়া হয়েছে a, b, c। এদের মধ্যে দুটি সংখ্যা সমান, কিন্তু তৃতীয়টি অন্য দুইটির থেকে ভিন্ন। যে মানটি ঠিক একবার ঘটে সেটি খুঁজে বের করো।\n    >>> f_12(0,0,1)\n    1\n    >>> f_12(4,3,4)\n    3", "bg": "Дадени са ви три цифри a, b, c. Две от тях са равни, но третата е различна от другите две. Намерете стойността, която се среща точно веднъж.\n    >>> f_12(0,0,1)\n    1\n    >>> f_12(4,3,4)\n    3", "zh": "你有三个数字 a, b, c。其中两个是相等的，但第三个与其他两个不同。找出只出现一次的值。\n    >>> f_12(0,0,1)\n    1\n    >>> f_12(4,3,4)\n    3", "fr": "Vous avez trois chiffres a, b, c. Deux d'entre eux sont égaux, mais le troisième est différent des deux autres. Trouvez la valeur qui apparaît exactement une fois.\n    >>> f_12(0,0,1)\n    1\n    >>> f_12(4,3,4)\n    3", "de": "Du hast drei Ziffern a, b, c. Zwei von ihnen sind gleich, aber die dritte unterscheidet sich von den anderen beiden. Finde den Wert, der genau einmal vorkommt.\n    >>> f_12(0,0,1)\n    1\n    >>> f_12(4,3,4)\n    3", "ha": "An ba ku lambobi uku a, b, c. Biyu daga cikinsu suna daidai, amma na uku ya bambanta da sauran biyun. Nemo ƙimar da ta bayyana sau ɗaya kawai.\n    >>> f_12(0,0,1)\n    1\n    >>> f_12(4,3,4)\n    3", "hi": "आपको तीन अंक दिए गए हैं a, b, c। इनमें से दो समान हैं, लेकिन तीसरा अन्य दो से भिन्न है। उस मान को खोजें जो केवल एक बार आता है।\n    >>> f_12(0,0,1)\n    1\n    >>> f_12(4,3,4)\n    3", "hu": "Három számjegyet kap, a, b, c. Kettő közülük egyenlő, de a harmadik eltér a másik kettőtől. Találja meg azt az értéket, amely pontosan egyszer fordul elő.\n    >>> f_12(0,0,1)\n    1\n    >>> f_12(4,3,4)\n    3", "es": "Se te dan tres dígitos a, b, c. Dos de ellos son iguales, pero el tercero es diferente de los otros dos. Encuentra el valor que ocurre exactamente una vez.\n    >>> f_12(0,0,1)\n    1\n    >>> f_12(4,3,4)\n    3", "arb": "أنت مُعطى ثلاثة أرقام a، b، c. اثنان منهما متساويان، لكن الثالث مختلف عن الاثنين الآخرين. ابحث عن القيمة التي تظهر مرة واحدة فقط.\n    >>> f_12(0,0,1)\n    1\n    >>> f_12(4,3,4)\n    3", "sw": "Umepewa tarakimu tatu a, b, c. Mbili kati ya hizo ni sawa, lakini ya tatu ni tofauti na zile mbili nyingine. Tafuta thamani inayotokea mara moja tu.\n    >>> f_12(0,0,1)\n    1\n    >>> f_12(4,3,4)\n    3", "tr": "Üç basamaklı a, b, c sayıları verilir. Bunlardan ikisi eşittir, ancak üçüncüsü diğer ikisinden farklıdır. Tam olarak bir kez geçen değeri bulun.\n    >>> f_12(0,0,1)\n    1\n    >>> f_12(4,3,4)\n    3", "vi": "Bạn được cho ba chữ số a, b, c. Hai trong số chúng bằng nhau, nhưng chữ số thứ ba khác với hai chữ số còn lại. Tìm giá trị xuất hiện đúng một lần.\n    >>> f_12(0,0,1)\n    1\n    >>> f_12(4,3,4)\n    3", "id": "Anda diberikan tiga digit a, b, c. Dua di antaranya sama, tetapi yang ketiga berbeda dari dua lainnya. Temukan nilai yang muncul tepat sekali.\n    >>> f_12(0,0,1)\n    1\n    >>> f_12(4,3,4)\n    3", "ja": "3つの数字 a, b, c が与えられます。そのうち2つは等しく、残りの1つは他の2つとは異なります。ちょうど1回だけ出現する値を見つけてください。\n    >>> f_12(0,0,1)\n    1\n    >>> f_12(4,3,4)\n    3", "ko": "세 자리 숫자 a, b, c가 주어집니다. 이 중 두 숫자는 같고, 나머지 하나는 다른 두 숫자와 다릅니다. 정확히 한 번만 나타나는 값을 찾으세요.\n    >>> f_12(0,0,1)\n    1\n    >>> f_12(4,3,4)\n    3", "ml": "നിങ്ങൾക്ക് മൂന്ന് അക്കങ്ങൾ a, b, c നൽകിയിരിക്കുന്നു. ഇവയിൽ രണ്ടെണ്ണം തുല്യമാണ്, പക്ഷേ മൂന്നാമത്തെത് മറ്റുള്ള രണ്ടെണ്ണത്തേക്കാൾ വ്യത്യസ്തമാണ്. ഒരിക്കൽ മാത്രം സംഭവിക്കുന്ന മൂല്യം കണ്ടെത്തുക.\n    >>> f_12(0,0,1)\n    1\n    >>> f_12(4,3,4)\n    3", "fa": "شما سه رقم a، b، c دارید. دو تا از آنها برابر هستند، اما سومی با دو تای دیگر متفاوت است. مقداری را پیدا کنید که دقیقاً یک بار ظاهر می‌شود.\n    >>> f_12(0,0,1)\n    1\n    >>> f_12(4,3,4)\n    3"}}
{"task_id": "C/13", "prompt": {"en": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCalculate the total score for a student based on the scores in different subjects.\n    Parameters:\n- subject_scores (list): A list containing the scores for each subject.\n    Returns:\n    int: The total score obtained by summing up the scores in all subjects.\n    >>> f_13(100,100,100,100,100)\n    500\n*/\nint f_13(int score1, int score2, int score3, int score4, int score5)", "sq": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nLlogarit totalin e pikëve për një student bazuar në pikët në lëndë të ndryshme.\n    Parametrat:\n- subject_scores (listë): Një listë që përmban pikët për secilën lëndë.\n    Kthen:\n    int: Totali i pikëve të marra duke mbledhur pikët në të gjitha lëndët.\n    >>> f_13(100,100,100,100,100)\n    500\n*/\nint f_13(int score1, int score2, int score3, int score4, int score5)", "hy": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nՀաշվել ուսանողի ընդհանուր միավորը տարբեր առարկաների միավորների հիման վրա:\n    Պարամետրեր:\n- subject_scores (ցանկ): Ցանկ, որը պարունակում է յուրաքանչյուր առարկայի միավորները:\n    Վերադարձնում է:\n    int: Ընդհանուր միավորը, որը ստացվում է բոլոր առարկաների միավորների գումարով:\n    >>> f_13(100,100,100,100,100)\n    500\n*/\nint f_13(int score1, int score2, int score3, int score4, int score5)", "bn": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nবিভিন্ন বিষয়ে প্রাপ্ত স্কোরের ভিত্তিতে একজন শিক্ষার্থীর মোট স্কোর গণনা করুন।\n    প্যারামিটার:\n- subject_scores (list): প্রতিটি বিষয়ে প্রাপ্ত স্কোরের একটি তালিকা।\n    রিটার্নস:\n    int: সমস্ত বিষয়ের স্কোর যোগ করে প্রাপ্ত মোট স্কোর।\n    >>> f_13(100,100,100,100,100)\n    500\n*/\nint f_13(int score1, int score2, int score3, int score4, int score5)", "bg": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nИзчислете общия резултат за ученик на базата на резултатите в различни предмети.\n    Параметри:\n- subject_scores (list): Списък, съдържащ резултатите за всеки предмет.\n    Връща:\n    int: Общият резултат, получен чрез сумиране на резултатите във всички предмети.\n    >>> f_13(100,100,100,100,100)\n    500\n*/\nint f_13(int score1, int score2, int score3, int score4, int score5)", "zh": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n计算学生在不同科目中的总分。\n    参数：\n- subject_scores (list): 包含每个科目分数的列表。\n    返回：\n    int: 通过将所有科目的分数相加获得的总分。\n    >>> f_13(100,100,100,100,100)\n    500\n*/\nint f_13(int score1, int score2, int score3, int score4, int score5)", "fr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCalcule le score total pour un étudiant basé sur les scores dans différentes matières.\n    Paramètres:\n- subject_scores (list): Une liste contenant les scores pour chaque matière.\n    Renvoie:\n    int: Le score total obtenu en additionnant les scores de toutes les matières.\n    >>> f_13(100,100,100,100,100)\n    500\n*/\nint f_13(int score1, int score2, int score3, int score4, int score5)", "de": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nBerechne die Gesamtpunktzahl für einen Schüler basierend auf den Punktzahlen in verschiedenen Fächern.\n    Parameter:\n- subject_scores (Liste): Eine Liste, die die Punktzahlen für jedes Fach enthält.\n    Rückgabe:\n    int: Die Gesamtpunktzahl, die durch das Summieren der Punktzahlen in allen Fächern erhalten wird.\n    >>> f_13(100,100,100,100,100)\n    500\n*/\nint f_13(int score1, int score2, int score3, int score4, int score5)", "ha": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nƘididdige jimillar maki ga ɗalibi bisa ga maki a fannoni daban-daban.\n    Sigogi:\n- subject_scores (list): Jerin da ke ɗauke da maki na kowane fanni.\n    Abin da ya dawo:\n    int: Jimillar maki da aka samu ta hanyar tara maki a dukkan fannoni.\n    >>> f_13(100,100,100,100,100)\n    500\n*/\nint f_13(int score1, int score2, int score3, int score4, int score5)", "hi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nविभिन्न विषयों में अंकों के आधार पर एक छात्र के लिए कुल अंक की गणना करें।\n    पैरामीटर्स:\n- subject_scores (सूची): प्रत्येक विषय के लिए अंक वाली एक सूची।\n    रिटर्न करता है:\n    int: सभी विषयों में अंकों को जोड़कर प्राप्त कुल अंक।\n    >>> f_13(100,100,100,100,100)\n    500\n*/\nint f_13(int score1, int score2, int score3, int score4, int score5)", "hu": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nSzámítsa ki a diák összpontszámát a különböző tantárgyakban elért pontszámok alapján.\n    Paraméterek:\n- subject_scores (list): Egy lista, amely tartalmazza az egyes tantárgyak pontszámait.\n    Visszatérési érték:\n    int: Az összpontszám, amelyet az összes tantárgy pontszámainak összeadásával kapunk.\n    >>> f_13(100,100,100,100,100)\n    500\n*/\nint f_13(int score1, int score2, int score3, int score4, int score5)", "es": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCalcular la puntuación total para un estudiante basada en las puntuaciones en diferentes materias.\n    Parámetros:\n- subject_scores (list): Una lista que contiene las puntuaciones para cada materia.\n    Devuelve:\n    int: La puntuación total obtenida sumando las puntuaciones en todas las materias.\n    >>> f_13(100,100,100,100,100)\n    500\n*/\nint f_13(int score1, int score2, int score3, int score4, int score5)", "arb": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nاحسب المجموع الكلي للدرجات لطالب بناءً على الدرجات في المواد المختلفة.\n    المعاملات:\n- subject_scores (list): قائمة تحتوي على الدرجات لكل مادة.\n    يعيد:\n    int: المجموع الكلي للدرجات المحصل عليه بجمع الدرجات في جميع المواد.\n    >>> f_13(100,100,100,100,100)\n    500\n*/\nint f_13(int score1, int score2, int score3, int score4, int score5)", "sw": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nHesabu jumla ya alama kwa mwanafunzi kulingana na alama katika masomo tofauti.\n    Vigezo:\n- subject_scores (orodha): Orodha inayojumuisha alama za kila somo.\n    Inarudisha:\n    int: Jumla ya alama zilizopatikana kwa kujumlisha alama katika masomo yote.\n    >>> f_13(100,100,100,100,100)\n    500\n*/\nint f_13(int score1, int score2, int score3, int score4, int score5)", "tr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nBir öğrencinin farklı derslerdeki puanlarına göre toplam puanını hesaplayın.\n    Parametreler:\n- subject_scores (list): Her ders için puanları içeren bir liste.\n    Döndürür:\n    int: Tüm derslerdeki puanların toplamını elde ederek elde edilen toplam puan.\n    >>> f_13(100,100,100,100,100)\n    500\n*/\nint f_13(int score1, int score2, int score3, int score4, int score5)", "vi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nTính tổng điểm cho một học sinh dựa trên điểm số ở các môn học khác nhau.\n    Tham số:\n- subject_scores (list): Một danh sách chứa điểm số cho mỗi môn học.\n    Trả về:\n    int: Tổng điểm đạt được bằng cách cộng các điểm số trong tất cả các môn học.\n    >>> f_13(100,100,100,100,100)\n    500\n*/\nint f_13(int score1, int score2, int score3, int score4, int score5)", "id": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nMenghitung total skor untuk seorang siswa berdasarkan skor dalam berbagai mata pelajaran.\n    Parameter:\n- subject_scores (list): Daftar yang berisi skor untuk setiap mata pelajaran.\n    Mengembalikan:\n    int: Total skor yang diperoleh dengan menjumlahkan skor di semua mata pelajaran.\n    >>> f_13(100,100,100,100,100)\n    500\n*/\nint f_13(int score1, int score2, int score3, int score4, int score5)", "ja": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n異なる科目のスコアに基づいて学生の総合スコアを計算します。\n    パラメータ:\n- subject_scores (list): 各科目のスコアを含むリスト。\n    戻り値:\n    int: すべての科目のスコアを合計して得られる総合スコア。\n    >>> f_13(100,100,100,100,100)\n    500\n*/\nint f_13(int score1, int score2, int score3, int score4, int score5)\n", "ko": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n학생의 다양한 과목 점수를 기반으로 총 점수를 계산합니다.\n    매개변수:\n- subject_scores (list): 각 과목의 점수를 포함하는 리스트입니다.\n    반환값:\n    int: 모든 과목의 점수를 합산하여 얻은 총 점수입니다.\n    >>> f_13(100,100,100,100,100)\n    500\n*/\nint f_13(int score1, int score2, int score3, int score4, int score5)\n", "ml": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nവിവിധ വിഷയങ്ങളിലെ സ്കോറുകൾ അടിസ്ഥാനമാക്കി ഒരു വിദ്യാർത്ഥിയുടെ മൊത്തം സ്കോർ കണക്കാക്കുക.\n    പാരാമീറ്ററുകൾ:\n- subject_scores (list): ഓരോ വിഷയത്തിന്റെയും സ്കോറുകൾ അടങ്ങിയ ഒരു പട്ടിക.\n    തിരികെ നൽകുന്നു:\n    int: എല്ലാ വിഷയങ്ങളിലെ സ്കോറുകൾ കൂട്ടിച്ചേർത്തു ലഭിക്കുന്ന മൊത്തം സ്കോർ.\n    >>> f_13(100,100,100,100,100)\n    500\n*/\nint f_13(int score1, int score2, int score3, int score4, int score5)", "fa": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nمحاسبه امتیاز کل برای یک دانش‌آموز بر اساس امتیازات در موضوعات مختلف.\n    پارامترها:\n- subject_scores (list): یک لیست که شامل امتیازات برای هر موضوع است.\n    بازگشت:\n    int: امتیاز کل به دست آمده با جمع کردن امتیازات در تمام موضوعات.\n    >>> f_13(100,100,100,100,100)\n    500\n*/\nint f_13(int score1, int score2, int score3, int score4, int score5)"}, "canonical_solution": "{\n    return score1 + score2 + score3 + score4 + score5;\n}", "instruction": {"en": "Write a C function `int f_13(int score1, int score2, int score3, int score4, int score5)` to solve the following problem:\nCalculate the total score for a student based on the scores in different subjects.\n    Parameters:\n- subject_scores (list): A list containing the scores for each subject.\n    Returns:\n    int: The total score obtained by summing up the scores in all subjects.\n    >>> f_13(100,100,100,100,100)\n    500\n", "sq": "Shkruani një funksion në C `int f_13(int score1, int score2, int score3, int score4, int score5)` për të zgjidhur problemin e mëposhtëm:\nLlogaritni totalin e pikëve për një student bazuar në pikët në lëndë të ndryshme.\n    Parametrat:\n- subject_scores (listë): Një listë që përmban pikët për secilën lëndë.\n    Kthen:\n    int: Totali i pikëve të marra duke mbledhur pikët në të gjitha lëndët.\n    >>> f_13(100,100,100,100,100)\n    500", "hy": "Գրեք C ֆունկցիա `int f_13(int score1, int score2, int score3, int score4, int score5)` հետևյալ խնդիրը լուծելու համար:\nՀաշվեք ուսանողի ընդհանուր միավորը տարբեր առարկաների գնահատականների հիման վրա։\n    Պարամետրեր:\n- subject_scores (list): Ցանկ, որը պարունակում է յուրաքանչյուր առարկայի գնահատականները։\n    Վերադարձնում է:\n    int: Ընդհանուր միավորը, որը ստացվում է բոլոր առարկաների գնահատականների գումարով։\n    >>> f_13(100,100,100,100,100)\n    500", "bn": "একটি C ফাংশন `int f_13(int score1, int score2, int score3, int score4, int score5)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nবিভিন্ন বিষয়ের স্কোরের উপর ভিত্তি করে একজন শিক্ষার্থীর মোট স্কোর গণনা করুন।\n    প্যারামিটারসমূহ:\n- subject_scores (list): প্রতিটি বিষয়ের স্কোর ধারণকারী একটি তালিকা।\n    রিটার্নস:\n    int: সমস্ত বিষয়ের স্কোর যোগ করে প্রাপ্ত মোট স্কোর।\n    >>> f_13(100,100,100,100,100)\n    500", "bg": "Напишете C функция `int f_13(int score1, int score2, int score3, int score4, int score5)` за решаване на следния проблем:\nИзчислете общия резултат за ученик въз основа на резултатите в различни предмети.\n    Параметри:\n- subject_scores (list): Списък, съдържащ резултатите за всеки предмет.\n    Връща:\n    int: Общият резултат, получен чрез събиране на резултатите от всички предмети.\n    >>> f_13(100,100,100,100,100)\n    500", "zh": "编写一个 C 函数 `int f_13(int score1, int score2, int score3, int score4, int score5)` 来解决以下问题：\n计算学生在不同科目中的总分。\n    参数：\n- subject_scores (list): 包含每个科目分数的列表。\n    返回：\n    int: 通过将所有科目的分数相加得到的总分。\n    >>> f_13(100,100,100,100,100)\n    500", "fr": "Écrire une fonction C `int f_13(int score1, int score2, int score3, int score4, int score5)` pour résoudre le problème suivant :\nCalculer le score total pour un étudiant basé sur les scores dans différentes matières.\n    Paramètres :\n- subject_scores (list): Une liste contenant les scores pour chaque matière.\n    Renvoie :\n    int : Le score total obtenu en additionnant les scores de toutes les matières.\n    >>> f_13(100,100,100,100,100)\n    500", "de": "Schreiben Sie eine C-Funktion `int f_13(int score1, int score2, int score3, int score4, int score5)`, um das folgende Problem zu lösen:\nBerechnen Sie die Gesamtpunktzahl für einen Schüler basierend auf den Punktzahlen in verschiedenen Fächern.\n    Parameter:\n- subject_scores (list): Eine Liste, die die Punktzahlen für jedes Fach enthält.\n    Rückgabe:\n    int: Die Gesamtpunktzahl, die durch das Summieren der Punktzahlen in allen Fächern erhalten wird.\n    >>> f_13(100,100,100,100,100)\n    500", "ha": "Rubuta aikin C `int f_13(int score1, int score2, int score3, int score4, int score5)` don warware matsalar mai zuwa:\nƘididdige jimlar maki ga ɗalibi bisa ga maki a fannoni daban-daban.\n    Sigogi:\n- subject_scores (list): Jerin da ke ɗauke da maki na kowanne fanni.\n    Yana dawowa:\n    int: Jimlar maki da aka samu ta hanyar tara maki a dukkan fannoni.\n    >>> f_13(100,100,100,100,100)\n    500", "hi": "C फ़ंक्शन `int f_13(int score1, int score2, int score3, int score4, int score5)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nविभिन्न विषयों में अंकों के आधार पर छात्र के कुल अंक की गणना करें।\n    पैरामीटर्स:\n- subject_scores (list): प्रत्येक विषय के लिए अंक वाली सूची।\n    रिटर्न करता है:\n    int: सभी विषयों में अंकों को जोड़कर प्राप्त कुल अंक।\n    >>> f_13(100,100,100,100,100)\n    500", "hu": "Írj egy C függvényt `int f_13(int score1, int score2, int score3, int score4, int score5)` a következő probléma megoldására:\nSzámítsd ki a diák összpontszámát a különböző tantárgyakban elért pontszámok alapján.\n    Paraméterek:\n- subject_scores (list): Egy lista, amely tartalmazza az egyes tantárgyak pontszámait.\n    Visszatér:\n    int: Az összpontszám, amelyet az összes tantárgy pontszámainak összegzésével kapunk.\n    >>> f_13(100,100,100,100,100)\n    500", "es": "Escribe una función en C `int f_13(int score1, int score2, int score3, int score4, int score5)` para resolver el siguiente problema:\nCalcular el puntaje total para un estudiante basado en los puntajes en diferentes materias.\n    Parámetros:\n- subject_scores (list): Una lista que contiene los puntajes para cada materia.\n    Retorna:\n    int: El puntaje total obtenido al sumar los puntajes en todas las materias.\n    >>> f_13(100,100,100,100,100)\n    500", "arb": "اكتب دالة بلغة C `int f_13(int score1, int score2, int score3, int score4, int score5)` لحل المشكلة التالية:\nاحسب المجموع الكلي للدرجات لطالب بناءً على الدرجات في مواد مختلفة.\n    المعاملات:\n- subject_scores (list): قائمة تحتوي على الدرجات لكل مادة.\n    يعيد:\n    int: المجموع الكلي للدرجات المحصل عليه بجمع الدرجات في جميع المواد.\n    >>> f_13(100,100,100,100,100)\n    500", "sw": "Andika kazi ya C `int f_13(int score1, int score2, int score3, int score4, int score5)` kutatua tatizo lifuatalo:\nHesabu jumla ya alama kwa mwanafunzi kulingana na alama katika masomo tofauti.\n    Vigezo:\n- subject_scores (list): Orodha inayojumuisha alama za kila somo.\n    Inarudisha:\n    int: Jumla ya alama iliyopatikana kwa kujumlisha alama katika masomo yote.\n    >>> f_13(100,100,100,100,100)\n    500", "tr": "Bir C fonksiyonu `int f_13(int score1, int score2, int score3, int score4, int score5)` yazın ve aşağıdaki problemi çözün:\nFarklı derslerdeki puanlara dayalı olarak bir öğrencinin toplam puanını hesaplayın.\n    Parametreler:\n- subject_scores (list): Her ders için puanları içeren bir liste.\n    Döndürür:\n    int: Tüm derslerdeki puanların toplamını elde ederek elde edilen toplam puan.\n    >>> f_13(100,100,100,100,100)\n    500", "vi": "Viết một hàm C `int f_13(int score1, int score2, int score3, int score4, int score5)` để giải quyết vấn đề sau:\nTính tổng điểm cho một học sinh dựa trên điểm số trong các môn học khác nhau.\n    Tham số:\n- subject_scores (list): Một danh sách chứa điểm số cho mỗi môn học.\n    Trả về:\n    int: Tổng điểm đạt được bằng cách cộng các điểm số trong tất cả các môn học.\n    >>> f_13(100,100,100,100,100)\n    500", "id": "Tulis sebuah fungsi C `int f_13(int score1, int score2, int score3, int score4, int score5)` untuk menyelesaikan masalah berikut:\nHitung total skor untuk seorang siswa berdasarkan skor dalam berbagai mata pelajaran.\n    Parameter:\n- subject_scores (list): Sebuah daftar yang berisi skor untuk setiap mata pelajaran.\n    Mengembalikan:\n    int: Total skor yang diperoleh dengan menjumlahkan skor di semua mata pelajaran.\n    >>> f_13(100,100,100,100,100)\n    500", "ja": "Cの関数を書け `int f_13(int score1, int score2, int score3, int score4, int score5)` を作成して、次の問題を解決してください:\n異なる科目のスコアに基づいて学生の合計スコアを計算します。\n    パラメータ:\n- subject_scores (list): 各科目のスコアを含むリスト。\n    戻り値:\n    int: すべての科目のスコアを合計した合計スコア。\n    >>> f_13(100,100,100,100,100)\n    500", "ko": "C 함수 `int f_13(int score1, int score2, int score3, int score4, int score5)`를 작성하여 다음 문제를 해결하십시오:\n다양한 과목의 점수를 기반으로 학생의 총점을 계산합니다.\n    매개변수:\n- subject_scores (list): 각 과목의 점수를 포함하는 리스트.\n    반환값:\n    int: 모든 과목의 점수를 합산하여 얻은 총점.\n    >>> f_13(100,100,100,100,100)\n    500", "ml": "C പ്രോഗ്രാമിൽ `int f_13(int score1, int score2, int score3, int score4, int score5)` എന്ന ഫംഗ്ഷൻ എഴുതുക താഴെ കാണിച്ചിരിക്കുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nവിവിധ വിഷയങ്ങളിലെ സ്കോറുകൾ അടിസ്ഥാനമാക്കി ഒരു വിദ്യാർത്ഥിയുടെ മൊത്തം സ്കോർ കണക്കാക്കുക.\n    പാരാമീറ്ററുകൾ:\n- subject_scores (list): ഓരോ വിഷയത്തിന്റെയും സ്കോറുകൾ അടങ്ങിയ ഒരു ലിസ്റ്റ്.\n    റിട്ടേൺസ്:\n    int: എല്ലാ വിഷയങ്ങളിലെയും സ്കോറുകൾ കൂട്ടിച്ചേർത്തു ലഭിക്കുന്ന മൊത്തം സ്കോർ.\n    >>> f_13(100,100,100,100,100)\n    500", "fa": "یک تابع C بنویسید `int f_13(int score1, int score2, int score3, int score4, int score5)` برای حل مسئله زیر:\nمحاسبه نمره کل برای یک دانش‌آموز بر اساس نمرات در موضوعات مختلف.\n    پارامترها:\n- subject_scores (list): لیستی که نمرات هر موضوع را شامل می‌شود.\n    بازگشت:\n    int: نمره کل که با جمع کردن نمرات در همه موضوعات به دست می‌آید.\n    >>> f_13(100,100,100,100,100)\n    500"}, "level": "easy", "test": "int main()\n{\n    assert(f_13(100,100,100,100,100) == 500);\n    assert(f_13(0,0,0,0,0) == 0);\n    assert(f_13(20, 30, 40, 10, 50) == 150);\n    assert(f_13(23, 45, 67, 89, 12) == 236);\n    assert(f_13(5, 5, 5, 5, 5) == 25);\n    return 0;\n}", "entry_point": "f_13", "signature": "int f_13(int score1, int score2, int score3, int score4, int score5)", "docstring": {"en": "Calculate the total score for a student based on the scores in different subjects.\n    Parameters:\n- subject_scores (list): A list containing the scores for each subject.\n    Returns:\n    int: The total score obtained by summing up the scores in all subjects.\n    >>> f_13(100,100,100,100,100)\n    500\n", "sq": "Llogaritni rezultatin total për një student bazuar në rezultatet në lëndë të ndryshme.\n    Parametrat:\n- subject_scores (list): Një listë që përmban rezultatet për secilën lëndë.\n    Kthen:\n    int: Rezultati total i marrë duke mbledhur rezultatet në të gjitha lëndët.\n    >>> f_13(100,100,100,100,100)\n    500", "hy": "Հաշվարկել ուսանողի ընդհանուր միավորը տարբեր առարկաներում ստացած միավորների հիման վրա:\n    Պարամետրեր:\n- subject_scores (list): Ցանկ, որը պարունակում է յուրաքանչյուր առարկայի միավորները:\n    Վերադարձնում է:\n    int: Ընդհանուր միավորը, որը ստացվում է բոլոր առարկաների միավորների գումարով:\n    >>> f_13(100,100,100,100,100)\n    500", "bn": "একজন ছাত্রের মোট স্কোর বিভিন্ন বিষয়ের স্কোরের উপর ভিত্তি করে গণনা করুন।\n    প্যারামিটারসমূহ:\n- subject_scores (list): প্রতিটি বিষয়ের স্কোর সম্বলিত একটি তালিকা।\n    রিটার্নস:\n    int: সমস্ত বিষয়ের স্কোর যোগ করে প্রাপ্ত মোট স্কোর।\n    >>> f_13(100,100,100,100,100)\n    500", "bg": "Изчислете общия резултат за ученик въз основа на резултатите по различни предмети.\n    Параметри:\n- subject_scores (list): Списък, съдържащ резултатите за всеки предмет.\n    Връща:\n    int: Общият резултат, получен чрез сумиране на резултатите по всички предмети.\n    >>> f_13(100,100,100,100,100)\n    500", "zh": "计算学生在不同科目中的总分。\n    参数:\n- subject_scores (list): 包含每个科目分数的列表。\n    返回:\n    int: 通过将所有科目的分数相加获得的总分。\n    >>> f_13(100,100,100,100,100)\n    500", "fr": "Calculer le score total pour un étudiant basé sur les scores dans différentes matières.\n    Paramètres:\n- subject_scores (list): Une liste contenant les scores pour chaque matière.\n    Renvoie:\n    int: Le score total obtenu en additionnant les scores de toutes les matières.\n    >>> f_13(100,100,100,100,100)\n    500", "de": "Berechnen Sie die Gesamtpunktzahl für einen Schüler basierend auf den Punktzahlen in verschiedenen Fächern.\n    Parameter:\n- subject_scores (list): Eine Liste, die die Punktzahlen für jedes Fach enthält.\n    Rückgaben:\n    int: Die Gesamtpunktzahl, die durch Summieren der Punktzahlen in allen Fächern erhalten wird.\n    >>> f_13(100,100,100,100,100)\n    500", "ha": "Kalkaleta jimillar maki ga ɗalibi bisa ga maki a fannoni daban-daban.\n    Sigogi:\n- subject_scores (list): Jerin da ke ɗauke da maki na kowanne fanni.\n    Dawowa:\n    int: Jimillar maki da aka samu ta hanyar tara maki a dukkan fannoni.\n    >>> f_13(100,100,100,100,100)\n    500", "hi": "छात्र के लिए विभिन्न विषयों में प्राप्त अंकों के आधार पर कुल अंक की गणना करें।\n    पैरामीटर्स:\n- subject_scores (list): प्रत्येक विषय के लिए अंकों की सूची।\n    रिटर्न्स:\n    int: सभी विषयों में अंकों को जोड़कर प्राप्त कुल अंक।\n    >>> f_13(100,100,100,100,100)\n    500", "hu": "Számítsa ki a diák összpontszámát a különböző tantárgyakban elért pontszámok alapján.\n    Paraméterek:\n- subject_scores (list): Egy lista, amely tartalmazza az egyes tantárgyak pontszámait.\n    Visszatérési érték:\n    int: Az összpontszám, amelyet az összes tantárgy pontszámának összegzésével kapunk.\n    >>> f_13(100,100,100,100,100)\n    500", "es": "Calcular la puntuación total de un estudiante basada en las puntuaciones en diferentes materias.\n    Parámetros:\n- subject_scores (list): Una lista que contiene las puntuaciones para cada materia.\n    Devuelve:\n    int: La puntuación total obtenida al sumar las puntuaciones en todas las materias.\n    >>> f_13(100,100,100,100,100)\n    500", "arb": "احسب المجموع الكلي للدرجات لطالب بناءً على الدرجات في مواد مختلفة.\n    المعلمات:\n- subject_scores (list): قائمة تحتوي على الدرجات لكل مادة.\n    يعيد:\n    int: المجموع الكلي للدرجات المحصل عليه بجمع الدرجات في جميع المواد.\n    >>> f_13(100,100,100,100,100)\n    500", "sw": "Hesabu jumla ya alama kwa mwanafunzi kulingana na alama katika masomo tofauti.\n    Vigezo:\n- subject_scores (list): Orodha inayojumuisha alama za kila somo.\n    Inarejesha:\n    int: Jumla ya alama inayopatikana kwa kujumlisha alama katika masomo yote.\n    >>> f_13(100,100,100,100,100)\n    500", "tr": "Öğrencinin farklı derslerdeki notlarına göre toplam puanını hesaplayın.\n    Parametreler:\n- subject_scores (list): Her ders için puanları içeren bir liste.\n    Döndürülenler:\n    int: Tüm derslerdeki puanların toplanmasıyla elde edilen toplam puan.\n    >>> f_13(100,100,100,100,100)\n    500", "vi": "Tính tổng điểm cho một học sinh dựa trên điểm số trong các môn học khác nhau.\n    Tham số:\n- subject_scores (list): Một danh sách chứa điểm số cho mỗi môn học.\n    Trả về:\n    int: Tổng điểm đạt được bằng cách cộng các điểm số trong tất cả các môn học.\n    >>> f_13(100,100,100,100,100)\n    500", "id": "Hitung total skor untuk seorang siswa berdasarkan skor dalam berbagai mata pelajaran.\n    Parameter:\n- subject_scores (list): Daftar yang berisi skor untuk setiap mata pelajaran.\n    Mengembalikan:\n    int: Total skor yang diperoleh dengan menjumlahkan skor di semua mata pelajaran.\n    >>> f_13(100,100,100,100,100)\n    500", "ja": "学生の異なる科目のスコアに基づいて、総合スコアを計算します。\n    パラメータ:\n- subject_scores (list): 各科目のスコアを含むリスト。\n    戻り値:\n    int: すべての科目のスコアを合計して得られる総合スコア。\n    >>> f_13(100,100,100,100,100)\n    500", "ko": "학생의 다양한 과목 점수를 기반으로 총점을 계산합니다.\n    매개변수:\n- subject_scores (list): 각 과목의 점수를 포함하는 리스트입니다.\n    반환값:\n    int: 모든 과목의 점수를 합산하여 얻은 총점입니다.\n    >>> f_13(100,100,100,100,100)\n    500", "ml": "വിദ്യാർത്ഥിയുടെ വിവിധ വിഷയങ്ങളിലെ മാർക്കുകളുടെ അടിസ്ഥാനത്തിൽ മൊത്തം സ്കോർ കണക്കാക്കുക.\n    പാരാമീറ്ററുകൾ:\n- subject_scores (list): ഓരോ വിഷയത്തിനും ലഭിച്ച മാർക്കുകൾ അടങ്ങിയ ഒരു പട്ടിക.\n    മടക്കങ്ങൾ:\n    int: എല്ലാ വിഷയങ്ങളിലെയും മാർക്കുകൾ കൂട്ടിച്ചേർത്തു ലഭിക്കുന്ന മൊത്തം സ്കോർ.\n    >>> f_13(100,100,100,100,100)\n    500", "fa": "محاسبه امتیاز کل برای یک دانش‌آموز بر اساس امتیازات در موضوعات مختلف.\n    پارامترها:\n- subject_scores (list): یک لیست که شامل امتیازات برای هر موضوع است.\n    بازگشت:\n    int: امتیاز کل که با جمع کردن امتیازات در همه موضوعات به دست می‌آید.\n    >>> f_13(100,100,100,100,100)\n    500"}}
{"task_id": "C/14", "prompt": {"en": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDecode a series of numbers to reveal the pattern and understand the actual values \neach digit represents.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParameters:\n- data_str: A string representing a series of numbers. Length does not exceed 100.\n\nReturns:\nint: The result of each data string corresponding to the right-hand side of the equation.\n\nExample usage:\nassert(f_14(\"0000\") == 4);\n*/\nint f_14(const char* data_str)", "sq": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDekodo një seri numrash për të zbuluar modelin dhe për të kuptuar vlerat aktuale \nqë përfaqëson secila shifër.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParametrat:\n- data_str: Një varg që përfaqëson një seri numrash. Gjatësia nuk i kalon 100.\n\nKthen:\nint: Rezultati i secilit varg të dhënash që korrespondon me anën e djathtë të ekuacionit.\n\nShembull përdorimi:\nassert(f_14(\"0000\") == 4);\n*/\nint f_14(const char* data_str)", "hy": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nՎերծանել թվերի շարք՝ բացահայտելու համար օրինաչափությունը և հասկանալու իրական արժեքները,\nորոնք ներկայացնում է յուրաքանչյուր թվանշան։\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nՊարամետրեր:\n- data_str: Թվերի շարքը ներկայացնող տող։ Երկարությունը չի գերազանցում 100-ը։\n\nՎերադարձնում է:\nint: Յուրաքանչյուր տվյալ տողի արդյունքը, որը համապատասխանում է հավասարման աջ կողմին։\n\nՕգտագործման օրինակ:\nassert(f_14(\"0000\") == 4);\n*/\nint f_14(const char* data_str)", "bn": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nসংখ্যার একটি সিরিজ ডিকোড করুন প্যাটার্নটি প্রকাশ করার জন্য এবং প্রতিটি সংখ্যা আসলে কোন মানটি উপস্থাপন করে তা বোঝার জন্য।\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nপ্যারামিটার:\n- data_str: একটি স্ট্রিং যা সংখ্যার একটি সিরিজ উপস্থাপন করে। দৈর্ঘ্য 100 অতিক্রম করে না।\n\nরিটার্নস:\nint: প্রতিটি ডেটা স্ট্রিং এর ফলাফল যা সমীকরণের ডান দিকের সাথে মিলে যায়।\n\nউদাহরণ ব্যবহার:\nassert(f_14(\"0000\") == 4);\n*/\nint f_14(const char* data_str)", "bg": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nДекодирайте серия от числа, за да разкриете модела и да разберете действителните стойности, \nкоито всяка цифра представлява.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nПараметри:\n- data_str: Низ, представляващ серия от числа. Дължината не надвишава 100.\n\nВръща:\nint: Резултатът от всеки низ от данни, съответстващ на дясната страна на уравнението.\n\nПример за използване:\nassert(f_14(\"0000\") == 4);\n*/\nint f_14(const char* data_str)", "zh": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\n解码一系列数字以揭示模式并理解每个数字实际代表的值。\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\n参数：\n- data_str: 一个表示一系列数字的字符串。长度不超过100。\n\n返回：\nint: 每个数据字符串对应方程右侧的结果。\n\n示例用法：\nassert(f_14(\"0000\") == 4);\n*/\nint f_14(const char* data_str)", "fr": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDécoder une série de chiffres pour révéler le motif et comprendre les valeurs réelles \nque chaque chiffre représente.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParamètres :\n- data_str : Une chaîne représentant une série de chiffres. La longueur ne dépasse pas 100.\n\nRenvoie :\nint : Le résultat de chaque chaîne de données correspondant au côté droit de l'équation.\n\nExemple d'utilisation :\nassert(f_14(\"0000\") == 4);\n*/\nint f_14(const char* data_str)", "de": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDekodiere eine Serie von Zahlen, um das Muster zu erkennen und die tatsächlichen Werte zu verstehen, \ndie jede Ziffer darstellt.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParameter:\n- data_str: Ein String, der eine Serie von Zahlen darstellt. Die Länge überschreitet nicht 100.\n\nRückgabewert:\nint: Das Ergebnis jedes Datenstrings, das der rechten Seite der Gleichung entspricht.\n\nBeispielverwendung:\nassert(f_14(\"0000\") == 4);\n*/\nint f_14(const char* data_str)", "ha": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nFassara jerin lambobi don bayyana tsarin kuma fahimtar ainihin ƙimar da kowace lamba ke wakilta.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nSigogi:\n- data_str: Wani kirtani da ke wakiltar jerin lambobi. Tsawon ba zai wuce 100 ba.\n\nDawo:\nint: Sakamakon kowanne kirtani na bayanai da ya dace da gefen dama na lissafin.\n\nMisalin amfani:\nassert(f_14(\"0000\") == 4);\n*/\nint f_14(const char* data_str)", "hi": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nसंख्याओं की एक श्रृंखला को डिकोड करें ताकि पैटर्न का पता चल सके और समझ सकें कि \nप्रत्येक अंक का वास्तविक मूल्य क्या है।\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nपैरामीटर्स:\n- data_str: एक स्ट्रिंग जो संख्याओं की एक श्रृंखला का प्रतिनिधित्व करती है। लंबाई 100 से अधिक नहीं है।\n\nवापसी:\nint: प्रत्येक डेटा स्ट्रिंग का परिणाम जो समीकरण के दाएँ हाथ की ओर संबंधित है।\n\nउदाहरण उपयोग:\nassert(f_14(\"0000\") == 4);\n*/\nint f_14(const char* data_str)", "hu": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDekódolja a számok sorozatát, hogy felfedje a mintát és megértse, hogy az egyes számjegyek \nmilyen tényleges értékeket képviselnek.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParaméterek:\n- data_str: Egy karakterlánc, amely számok sorozatát képviseli. Hossza nem haladja meg a 100-at.\n\nVisszatérési érték:\nint: Az egyes adatkarakterláncok eredménye, amely megfelel az egyenlet jobb oldalának.\n\nPélda használat:\nassert(f_14(\"0000\") == 4);\n*/\nint f_14(const char* data_str)", "es": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDecodificar una serie de números para revelar el patrón y entender los valores reales \nque representa cada dígito.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParámetros:\n- data_str: Una cadena que representa una serie de números. La longitud no excede 100.\n\nDevuelve:\nint: El resultado de cada cadena de datos correspondiente al lado derecho de la ecuación.\n\nEjemplo de uso:\nassert(f_14(\"0000\") == 4);\n*/\nint f_14(const char* data_str)", "arb": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nفك سلسلة من الأرقام للكشف عن النمط وفهم القيم الفعلية التي يمثلها كل رقم.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nالمعلمات:\n- data_str: سلسلة تمثل سلسلة من الأرقام. الطول لا يتجاوز 100.\n\nالإرجاع:\nint: نتيجة كل سلسلة بيانات تتوافق مع الجانب الأيمن من المعادلة.\n\nمثال على الاستخدام:\nassert(f_14(\"0000\") == 4);\n*/\nint f_14(const char* data_str)", "sw": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nTafsiri mfululizo wa nambari ili kufichua muundo na kuelewa thamani halisi \nambayo kila tarakimu inawakilisha.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nVigezo:\n- data_str: Kamba inayowakilisha mfululizo wa nambari. Urefu hauzidi 100.\n\nInarejesha:\nint: Matokeo ya kila kamba ya data inayolingana na upande wa kulia wa usawa.\n\nMfano wa matumizi:\nassert(f_14(\"0000\") == 4);\n*/\nint f_14(const char* data_str)", "tr": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nBir dizi sayıyı çözerek deseni ortaya çıkarın ve her bir rakamın temsil ettiği gerçek değerleri anlayın.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParametreler:\n- data_str: Bir dizi sayıyı temsil eden bir dize. Uzunluk 100'ü geçmez.\n\nDöndürülenler:\nint: Her veri dizisinin denklemin sağ tarafına karşılık gelen sonucu.\n\nÖrnek kullanım:\nassert(f_14(\"0000\") == 4);\n*/\nint f_14(const char* data_str)", "vi": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nGiải mã một chuỗi các số để tiết lộ mẫu và hiểu các giá trị thực tế\nmỗi chữ số đại diện.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nTham số:\n- data_str: Một chuỗi đại diện cho một chuỗi các số. Độ dài không vượt quá 100.\n\nTrả về:\nint: Kết quả của mỗi chuỗi dữ liệu tương ứng với vế phải của phương trình.\n\nVí dụ sử dụng:\nassert(f_14(\"0000\") == 4);\n*/\nint f_14(const char* data_str)", "id": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDekode serangkaian angka untuk mengungkap pola dan memahami nilai sebenarnya \nyang diwakili oleh setiap digit.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParameter:\n- data_str: Sebuah string yang mewakili serangkaian angka. Panjang tidak melebihi 100.\n\nMengembalikan:\nint: Hasil dari setiap string data yang sesuai dengan sisi kanan persamaan.\n\nContoh penggunaan:\nassert(f_14(\"0000\") == 4);\n*/\nint f_14(const char* data_str)\n", "ja": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\n一連の数字をデコードしてパターンを明らかにし、各桁が表す実際の値を理解します。\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nパラメータ:\n- data_str: 数字の列を表す文字列。長さは100を超えません。\n\n戻り値:\nint: 各データ文字列が方程式の右辺に対応する結果。\n\n使用例:\nassert(f_14(\"0000\") == 4);\n*/\nint f_14(const char* data_str)\n", "ko": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\n숫자 시리즈를 해독하여 패턴을 밝히고 각 자릿수가 실제로 나타내는 값을 이해합니다.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\n매개변수:\n- data_str: 숫자 시리즈를 나타내는 문자열입니다. 길이는 100을 초과하지 않습니다.\n\n반환값:\nint: 각 데이터 문자열이 방정식의 오른쪽에 해당하는 결과입니다.\n\n사용 예:\nassert(f_14(\"0000\") == 4);\n*/\nint f_14(const char* data_str)\n", "ml": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nനമ്പറുകളുടെ ഒരു ശ്രേണി ഡികോഡ് ചെയ്ത് ഓരോ അക്കവും പ്രതിനിധാനം ചെയ്യുന്ന യഥാർത്ഥ മൂല്യങ്ങൾ മനസ്സിലാക്കുക.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nപാരാമീറ്ററുകൾ:\n- data_str: നമ്പറുകളുടെ ഒരു ശ്രേണിയെ പ്രതിനിധീകരിക്കുന്ന ഒരു സ്ട്രിംഗ്. നീളം 100-നെ കവിയില്ല.\n\nമടക്കുക:\nint: സമവാക്യത്തിന്റെ വലതുവശത്തുള്ള ഓരോ ഡാറ്റാ സ്ട്രിംഗിനും അനുയോജ്യമായ ഫലമാണ്.\n\nഉദാഹരണ ഉപയോഗം:\nassert(f_14(\"0000\") == 4);\n*/\nint f_14(const char* data_str)", "fa": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nرمزگشایی یک سری از اعداد برای آشکارسازی الگو و درک مقادیر واقعی که هر رقم نشان می‌دهد.\n\nپارامترها:\n- data_str: یک رشته که یک سری از اعداد را نشان می‌دهد. طول آن از 100 تجاوز نمی‌کند.\n\nبازگشت:\nint: نتیجه هر رشته داده‌ای که با سمت راست معادله مطابقت دارد.\n\nمثال استفاده:\nassert(f_14(\"0000\") == 4);\n*/\nint f_14(const char* data_str)"}, "canonical_solution": "{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}", "instruction": {"en": "Write a C function `int f_14(const char* data_str)` to solve the following problem:\nDecode a series of numbers to reveal the pattern and understand the actual values each digit represents.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParameters:\n- data_str: A string representing a series of numbers. Length does not exceed 100.\n\nReturns:\nint: The result of each data string corresponding to the right-hand side of the equation.\n\nExample usage:\nassert(f_14(\"0000\") == 4);\n", "sq": "Shkruani një funksion C `int f_14(const char* data_str)` për të zgjidhur problemin e mëposhtëm:\nDekodoni një seri numrash për të zbuluar modelin dhe për të kuptuar vlerat aktuale që përfaqëson secila shifër.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParametrat:\n- data_str: Një varg që përfaqëson një seri numrash. Gjatësia nuk i kalon 100.\n\nKthen:\nint: Rezultati i secilës varg të dhënash që korrespondon me anën e djathtë të ekuacionit.\n\nShembull përdorimi:\nassert(f_14(\"0000\") == 4);", "hy": "Գրեք C ֆունկցիա `int f_14(const char* data_str)` հետևյալ խնդիրը լուծելու համար:\nՎերծանել թվերի շարք՝ բացահայտելու օրինաչափությունը և հասկանալու, թե իրականում ինչ արժեքներ են ներկայացնում յուրաքանչյուր թվանշան:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nՊարամետրեր:\n- data_str: Թվերի շարքը ներկայացնող տող։ Երկարությունը չի գերազանցում 100-ը։\n\nՎերադարձնում է:\nint: Յուրաքանչյուր տվյալ տողի արդյունքը, որը համապատասխանում է հավասարման աջ կողմին։\n\nՕրինակ օգտագործում:\nassert(f_14(\"0000\") == 4);", "bn": "একটি C ফাংশন `int f_14(const char* data_str)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nসংখ্যার একটি সিরিজ ডিকোড করুন প্যাটার্নটি প্রকাশ করতে এবং প্রতিটি অঙ্ক আসলে কী মান প্রকাশ করে তা বুঝতে।\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nপ্যারামিটার:\n- data_str: একটি স্ট্রিং যা সংখ্যার একটি সিরিজ উপস্থাপন করে। দৈর্ঘ্য 100 অতিক্রম করে না।\n\nরিটার্ন:\nint: প্রতিটি ডেটা স্ট্রিং এর সমীকরণের ডান দিকের মানের সাথে সম্পর্কিত ফলাফল।\n\nউদাহরণ ব্যবহার:\nassert(f_14(\"0000\") == 4);", "bg": "Напишете C функция `int f_14(const char* data_str)`, за да решите следния проблем:\nДекодирайте серия от числа, за да разкриете модела и да разберете действителните стойности, които всяка цифра представлява.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nПараметри:\n- data_str: Низ, представляващ серия от числа. Дължината не надвишава 100.\n\nВръща:\nint: Резултатът от всеки низ от данни, съответстващ на дясната страна на уравнението.\n\nПример за използване:\nassert(f_14(\"0000\") == 4);", "zh": "编写一个 C 函数 `int f_14(const char* data_str)` 来解决以下问题：\n解码一系列数字以揭示模式并理解每个数字代表的实际值。\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\n参数：\n- data_str: 表示一系列数字的字符串。长度不超过 100。\n\n返回：\nint: 每个数据字符串对应于等式右侧的结果。\n\n示例用法：\nassert(f_14(\"0000\") == 4);", "fr": "Écrire une fonction C `int f_14(const char* data_str)` pour résoudre le problème suivant :\nDécoder une série de chiffres pour révéler le motif et comprendre les valeurs réelles que chaque chiffre représente.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParamètres :\n- data_str : Une chaîne représentant une série de chiffres. La longueur ne dépasse pas 100.\n\nRenvoie :\nint : Le résultat de chaque chaîne de données correspondant au côté droit de l'équation.\n\nExemple d'utilisation :\nassert(f_14(\"0000\") == 4);", "de": "Schreiben Sie eine C-Funktion `int f_14(const char* data_str)`, um das folgende Problem zu lösen:\nDekodieren Sie eine Serie von Zahlen, um das Muster zu erkennen und die tatsächlichen Werte zu verstehen, die jede Ziffer darstellt.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParameter:\n- data_str: Ein String, der eine Serie von Zahlen darstellt. Die Länge überschreitet nicht 100.\n\nRückgabewert:\nint: Das Ergebnis jedes Datenstrings, das der rechten Seite der Gleichung entspricht.\n\nBeispielverwendung:\nassert(f_14(\"0000\") == 4);", "ha": "Rubuta aikin C `int f_14(const char* data_str)` don warware matsalar mai zuwa:\nFassara jerin lambobi don bayyana tsarin kuma fahimtar ainihin ƙimar da kowane lamba ke wakilta.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nSigogi:\n- data_str: Wani kirtani da ke wakiltar jerin lambobi. Tsawon ba zai wuce 100 ba.\n\nDawowa:\nint: Sakamakon kowane kirtani na bayanai da ya dace da gefen dama na daidaitawar.\n\nMisalin amfani:\nassert(f_14(\"0000\") == 4);", "hi": "C फ़ंक्शन `int f_14(const char* data_str)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nसंख्याओं की एक श्रृंखला को डिकोड करें ताकि पैटर्न का पता चल सके और समझ सकें कि प्रत्येक अंक का वास्तविक मूल्य क्या है।\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nपैरामीटर्स:\n- data_str: संख्याओं की एक श्रृंखला का प्रतिनिधित्व करने वाला एक स्ट्रिंग। लंबाई 100 से अधिक नहीं है।\n\nवापसी मान:\nint: प्रत्येक डेटा स्ट्रिंग का परिणाम जो समीकरण के दाहिने हाथ की ओर संबंधित है।\n\nउदाहरण उपयोग:\nassert(f_14(\"0000\") == 4);", "hu": "Írj egy C függvényt `int f_14(const char* data_str)` a következő probléma megoldására:\nDekódolj egy számsorozatot, hogy felfedd a mintát és megértsd, hogy az egyes számjegyek valójában milyen értékeket képviselnek.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParaméterek:\n- data_str: Egy számsorozatot reprezentáló karakterlánc. Hossza nem haladja meg a 100-at.\n\nVisszatérési érték:\nint: Az egyes adatkarakterláncoknak megfelelő eredmény az egyenlet jobb oldalán.\n\nPélda használat:\nassert(f_14(\"0000\") == 4);", "es": "Escriba una función en C `int f_14(const char* data_str)` para resolver el siguiente problema:\nDecodificar una serie de números para revelar el patrón y entender los valores reales que representa cada dígito.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParámetros:\n- data_str: Una cadena que representa una serie de números. La longitud no excede 100.\n\nDevuelve:\nint: El resultado de cada cadena de datos correspondiente al lado derecho de la ecuación.\n\nEjemplo de uso:\nassert(f_14(\"0000\") == 4);", "arb": "اكتب دالة بلغة C `int f_14(const char* data_str)` لحل المشكلة التالية:\nفك شفرة سلسلة من الأرقام للكشف عن النمط وفهم القيم الفعلية التي يمثلها كل رقم.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nالمعطيات:\n- data_str: سلسلة تمثل سلسلة من الأرقام. الطول لا يتجاوز 100.\n\nالإرجاع:\nint: نتيجة كل سلسلة بيانات تقابل الجانب الأيمن من المعادلة.\n\nمثال على الاستخدام:\nassert(f_14(\"0000\") == 4);", "sw": "Andika kazi ya C `int f_14(const char* data_str)` kutatua tatizo lifuatalo:\nFumbua mfululizo wa nambari ili kufichua mpangilio na kuelewa thamani halisi ambayo kila tarakimu inawakilisha.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nVigezo:\n- data_str: Kamba inayowakilisha mfululizo wa nambari. Urefu hauzidi 100.\n\nInarudisha:\nint: Matokeo ya kila kamba ya data inayolingana na upande wa kulia wa mlinganyo.\n\nMfano wa matumizi:\nassert(f_14(\"0000\") == 4);", "tr": "Bir C fonksiyonu `int f_14(const char* data_str)` yazın ve aşağıdaki problemi çözün:\nBir dizi numarayı çözerek deseni ortaya çıkarın ve her bir rakamın temsil ettiği gerçek değerleri anlayın.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParametreler:\n- data_str: Bir dizi numarayı temsil eden bir string. Uzunluğu 100'ü geçmez.\n\nDöndürülen Değer:\nint: Her bir veri stringinin denklemin sağ tarafına karşılık gelen sonucu.\n\nÖrnek kullanım:\nassert(f_14(\"0000\") == 4);", "vi": "Viết một hàm C `int f_14(const char* data_str)` để giải quyết vấn đề sau:\nGiải mã một chuỗi các số để tiết lộ mẫu và hiểu các giá trị thực tế mà mỗi chữ số đại diện.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nTham số:\n- data_str: Một chuỗi đại diện cho một chuỗi các số. Độ dài không vượt quá 100.\n\nTrả về:\nint: Kết quả của mỗi chuỗi dữ liệu tương ứng với vế phải của phương trình.\n\nVí dụ sử dụng:\nassert(f_14(\"0000\") == 4);", "id": "Tulis sebuah fungsi C `int f_14(const char* data_str)` untuk menyelesaikan masalah berikut:\nDekode serangkaian angka untuk mengungkap pola dan memahami nilai sebenarnya yang diwakili oleh setiap digit.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParameter:\n- data_str: Sebuah string yang mewakili serangkaian angka. Panjang tidak melebihi 100.\n\nMengembalikan:\nint: Hasil dari setiap string data yang sesuai dengan sisi kanan persamaan.\n\nContoh penggunaan:\nassert(f_14(\"0000\") == 4);", "ja": "Cの関数を書け `int f_14(const char* data_str)` 次の問題を解くために:\n一連の数字をデコードしてパターンを明らかにし、各桁が表す実際の値を理解します。\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParameters:\n- data_str: 数字の列を表す文字列。長さは100を超えません。\n\nReturns:\nint: 方程式の右辺に対応する各データ文字列の結果。\n\nExample usage:\nassert(f_14(\"0000\") == 4);", "ko": "C 함수 `int f_14(const char* data_str)`를 작성하여 다음 문제를 해결하십시오:\n숫자 시리즈를 디코딩하여 패턴을 밝히고 각 자릿수가 나타내는 실제 값을 이해합니다.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\n매개변수:\n- data_str: 숫자 시리즈를 나타내는 문자열입니다. 길이는 100을 초과하지 않습니다.\n\n반환값:\nint: 방정식의 오른쪽에 해당하는 각 데이터 문자열의 결과입니다.\n\n사용 예:\nassert(f_14(\"0000\") == 4);", "ml": "C ഭാഷയിൽ ഒരു ഫംഗ്ഷൻ `int f_14(const char* data_str)` എഴുതുക താഴെപ്പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nനമ്പറുകളുടെ ഒരു പരമ്പര ഡികോഡ് ചെയ്ത് പാറ്റേൺ വെളിപ്പെടുത്തുകയും ഓരോ അക്കവും പ്രതിനിധാനം ചെയ്യുന്ന യഥാർത്ഥ മൂല്യങ്ങൾ മനസ്സിലാക്കുകയും ചെയ്യുക.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nപാരാമീറ്ററുകൾ:\n- data_str: നമ്പറുകളുടെ ഒരു പരമ്പര പ്രതിനിധീകരിക്കുന്ന ഒരു സ്ട്രിംഗ്. ദൈർഘ്യം 100-നെ കവിയില്ല.\n\nമടക്കം:\nint: സമവാക്യത്തിന്റെ വലതുഭാഗത്തെ ഓരോ ഡാറ്റ സ്ട്രിംഗിനും അനുയോജ്യമായ ഫലത്തെ പ്രതിനിധീകരിക്കുന്നു.\n\nഉദാഹരണ ഉപയോഗം:\nassert(f_14(\"0000\") == 4);", "fa": "یک تابع C به نام `int f_14(const char* data_str)` بنویسید تا مسئله زیر را حل کند:\nیک سری از اعداد را رمزگشایی کنید تا الگو را آشکار کرده و مقادیر واقعی که هر رقم نشان می‌دهد را درک کنید.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nپارامترها:\n- data_str: یک رشته که نشان‌دهنده یک سری از اعداد است. طول آن از 100 تجاوز نمی‌کند.\n\nبرمی‌گرداند:\nint: نتیجه هر رشته داده که با سمت راست معادله مطابقت دارد.\n\nمثال استفاده:\nassert(f_14(\"0000\") == 4);"}, "level": "easy", "test": "int main() {\n    assert(f_14(\"0000\") == 4);\n    assert(f_14(\"8888\") == 8);\n    assert(f_14(\"1234\") == 1);\n    assert(f_14(\"5678\") == 3);\n    assert(f_14(\"9012\") == 2);\n    assert(f_14(\"1357\") == 0);\n    assert(f_14(\"2468\") == 4);\n\n    // Additional test samples\n    assert(f_14(\"9999\") == 4);\n    assert(f_14(\"1111\") == 0);\n    assert(f_14(\"2222\") == 0);\n    assert(f_14(\"3333\") == 0);\n    assert(f_14(\"4444\") == 4);\n    assert(f_14(\"5555\") == 0);\n    assert(f_14(\"6666\") == 4);\n    assert(f_14(\"7777\") == 0);\n    assert(f_14(\"0001\") == 3);\n    assert(f_14(\"2301\") == 1);\n\n    return 0;\n}", "entry_point": "f_14", "signature": "int f_14(const char* data_str)", "docstring": {"en": "Decode a series of numbers to reveal the pattern and understand the actual values each digit represents.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParameters:\n- data_str: A string representing a series of numbers. Length does not exceed 100.\n\nReturns:\nint: The result of each data string corresponding to the right-hand side of the equation.\n\nExample usage:\nassert(f_14(\"0000\") == 4);\n", "sq": "Dekodo një seri numrash për të zbuluar modelin dhe për të kuptuar vlerat aktuale që përfaqëson çdo shifër.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParametrat:\n- data_str: Një varg që përfaqëson një seri numrash. Gjatësia nuk e kalon 100.\n\nKthen:\nint: Rezultati i çdo vargu të dhënash që korrespondon me anën e djathtë të ekuacionit.\n\nShembull përdorimi:\nassert(f_14(\"0000\") == 4);", "hy": "Թվերի շարք ապակոդավորել՝ բացահայտելու համար օրինաչափությունը և հասկանալու, թե իրականում ինչ արժեքներ են ներկայացնում յուրաքանչյուր թվանշան:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nՊարամետրեր:\n- data_str: Թվերի շարքը ներկայացնող տող: Երկարությունը չի գերազանցում 100-ը:\n\nՎերադարձնում է:\nint: Յուրաքանչյուր տվյալ տողի արդյունքը, որը համապատասխանում է հավասարման աջ կողմին:\n\nՕրինակ օգտագործում:\nassert(f_14(\"0000\") == 4);", "bn": "সংখ্যার একটি সিরিজ ডিকোড করে প্যাটার্নটি প্রকাশ করুন এবং প্রতিটি অঙ্ক কী মান উপস্থাপন করে তা বুঝুন।\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nপ্যারামিটারসমূহ:\n- data_str: একটি স্ট্রিং যা সংখ্যার একটি সিরিজ উপস্থাপন করে। দৈর্ঘ্য 100 অতিক্রম করে না।\n\nফেরত দেয়:\nint: প্রতিটি ডেটা স্ট্রিংয়ের ফলাফল যা সমীকরণের ডান দিকের সাথে সম্পর্কিত।\n\nব্যবহারের উদাহরণ:\nassert(f_14(\"0000\") == 4);", "bg": "Декодирайте серия от числа, за да разкриете модела и да разберете действителните стойности, които всяка цифра представлява.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nПараметри:\n- data_str: Низ, представляващ серия от числа. Дължината не надвишава 100.\n\nВръща:\nint: Резултатът от всеки низ от данни, съответстващ на дясната страна на уравнението.\n\nПример за използване:\nassert(f_14(\"0000\") == 4);", "zh": "解码一系列数字以揭示模式并理解每个数字代表的实际值。\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\n参数：\n- data_str: 一个表示一系列数字的字符串。长度不超过100。\n\n返回：\nint: 每个数据字符串对应于等式右侧的结果。\n\n示例用法：\nassert(f_14(\"0000\") == 4);", "fr": "Décoder une série de nombres pour révéler le motif et comprendre les valeurs réelles que chaque chiffre représente.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParamètres:\n- data_str: Une chaîne représentant une série de nombres. La longueur ne dépasse pas 100.\n\nRenvoie:\nint: Le résultat de chaque chaîne de données correspondant au côté droit de l'équation.\n\nExemple d'utilisation:\nassert(f_14(\"0000\") == 4);", "de": "Dekodiere eine Reihe von Zahlen, um das Muster zu erkennen und die tatsächlichen Werte zu verstehen, die jede Ziffer repräsentiert.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParameter:\n- data_str: Ein String, der eine Reihe von Zahlen darstellt. Die Länge überschreitet nicht 100.\n\nRückgabewert:\nint: Das Ergebnis jedes Datenstrings, das der rechten Seite der Gleichung entspricht.\n\nBeispielverwendung:\nassert(f_14(\"0000\") == 4);", "ha": "Fassara jerin lambobi don bayyana tsarin kuma fahimtar ainihin ƙimar da kowace lamba ke wakilta.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nSigogi:\n- data_str: Wani igiyar rubutu da ke wakiltar jerin lambobi. Tsawon ba zai wuce 100 ba.\n\nDawowa:\nint: Sakamakon kowane igiyar rubutu na bayanan da ya dace da gefen dama na daidaitawar.\n\nMisalin amfani:\nassert(f_14(\"0000\") == 4);", "hi": "संख्याओं की एक श्रृंखला को डिकोड करें ताकि पैटर्न का पता चल सके और समझ सकें कि प्रत्येक अंक वास्तव में क्या दर्शाता है।\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nपैरामीटर्स:\n- data_str: एक स्ट्रिंग जो संख्याओं की एक श्रृंखला का प्रतिनिधित्व करती है। लंबाई 100 से अधिक नहीं होती।\n\nवापसी:\nint: प्रत्येक डेटा स्ट्रिंग का परिणाम जो समीकरण के दाईं ओर के अनुरूप होता है।\n\nउदाहरण उपयोग:\nassert(f_14(\"0000\") == 4);", "hu": "Dekódoljon egy számsorozatot, hogy felfedje a mintát és megértse, hogy az egyes számjegyek valójában milyen értékeket képviselnek.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParaméterek:\n- data_str: Egy számsorozatot reprezentáló karakterlánc. Hossza nem haladja meg a 100-at.\n\nVisszatérési érték:\nint: Az egyes adatkarakterláncok eredménye, amely megfelel az egyenlet jobb oldalának.\n\nPélda használat:\nassert(f_14(\"0000\") == 4);", "es": "Decodificar una serie de números para revelar el patrón y entender los valores reales que representa cada dígito.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParámetros:\n- data_str: Una cadena que representa una serie de números. La longitud no excede 100.\n\nDevuelve:\nint: El resultado de cada cadena de datos correspondiente al lado derecho de la ecuación.\n\nEjemplo de uso:\nassert(f_14(\"0000\") == 4);", "arb": "فك سلسلة من الأرقام للكشف عن النمط وفهم القيم الفعلية التي يمثلها كل رقم.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nالمعطيات:\n- data_str: سلسلة نصية تمثل سلسلة من الأرقام. الطول لا يتجاوز 100.\n\nالقيم المعادة:\nint: نتيجة كل سلسلة بيانات تقابل الجانب الأيمن من المعادلة.\n\nمثال على الاستخدام:\nassert(f_14(\"0000\") == 4);", "sw": "Fasiri mfululizo wa nambari ili kufichua muundo na kuelewa thamani halisi ambayo kila tarakimu inawakilisha.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nVigezo:\n- data_str: Kamba inayowakilisha mfululizo wa nambari. Urefu hauzidi 100.\n\nInarejesha:\nint: Matokeo ya kila kamba ya data inayolingana na upande wa kulia wa usawa.\n\nMfano wa matumizi:\nassert(f_14(\"0000\") == 4);", "tr": "Bir dizi sayıyı çözerek deseni ortaya çıkarın ve her bir rakamın temsil ettiği gerçek değerleri anlayın.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParametreler:\n- data_str: Bir dizi sayıyı temsil eden bir string. Uzunluk 100'ü geçmez.\n\nDöndürür:\nint: Her bir veri dizisinin denklemin sağ tarafına karşılık gelen sonucu.\n\nÖrnek kullanım:\nassert(f_14(\"0000\") == 4);", "vi": "Giải mã một chuỗi số để tiết lộ mẫu và hiểu các giá trị thực mà mỗi chữ số đại diện.\n\nTham số:\n- data_str: Một chuỗi đại diện cho một loạt các số. Độ dài không vượt quá 100.\n\nTrả về:\nint: Kết quả của mỗi chuỗi dữ liệu tương ứng với phía bên phải của phương trình.\n\nVí dụ sử dụng:\nassert(f_14(\"0000\") == 4);", "id": "Decode serangkaian angka untuk mengungkap pola dan memahami nilai sebenarnya yang diwakili setiap digit.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParameter:\n- data_str: Sebuah string yang mewakili serangkaian angka. Panjangnya tidak melebihi 100.\n\nMengembalikan:\nint: Hasil dari setiap string data yang sesuai dengan sisi kanan persamaan.\n\nContoh penggunaan:\nassert(f_14(\"0000\") == 4);", "ja": "数字の一連のパターンをデコードして、各桁が表す実際の値を理解します。\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nパラメータ:\n- data_str: 数字の一連を表す文字列。長さは100を超えません。\n\n戻り値:\nint: 方程式の右辺に対応する各データ文字列の結果。\n\n使用例:\nassert(f_14(\"0000\") == 4);", "ko": "숫자 시리즈를 해독하여 패턴을 밝히고 각 숫자가 나타내는 실제 값을 이해합니다.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\n매개변수:\n- data_str: 숫자 시리즈를 나타내는 문자열입니다. 길이는 100을 초과하지 않습니다.\n\n반환:\nint: 방정식의 오른쪽에 해당하는 각 데이터 문자열의 결과입니다.\n\n사용 예:\nassert(f_14(\"0000\") == 4);", "ml": "Decode a series of numbers to reveal the pattern and understand the actual values each digit represents.  \nഒരു സംഖ്യകളുടെ ശ്രേണിയെ ഡികോഡ് ചെയ്ത് മാതൃക വെളിപ്പെടുത്തുകയും ഓരോ അക്കവും പ്രതിനിധാനം ചെയ്യുന്ന യഥാർത്ഥ മൂല്യങ്ങൾ മനസിലാക്കുകയും ചെയ്യുക.  \n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParameters:  \n- data_str: A string representing a series of numbers. Length does not exceed 100.  \n  - data_str: സംഖ്യകളുടെ ഒരു ശ്രേണിയെ പ്രതിനിധീകരിക്കുന്ന ഒരു സ്ട്രിംഗ്. നീളം 100 കവിഞ്ഞുപോവില്ല.\n\nReturns:  \nint: The result of each data string corresponding to the right-hand side of the equation.  \nint: സമവാക്യത്തിന്റെ വലതുവശത്തെ അനുസരിച്ച് ഓരോ ഡാറ്റാ സ്ട്രിംഗിന്റെയും ഫലം.\n\nExample usage:  \nassert(f_14(\"0000\") == 4);  ", "fa": "Decode یک سری از اعداد برای آشکارسازی الگو و درک مقادیر واقعی که هر رقم نشان می‌دهد.\n\nپارامترها:\n- data_str: یک رشته که نمایانگر یک سری از اعداد است. طول آن از 100 تجاوز نمی‌کند.\n\nبازگشت:\nint: نتیجه هر رشته داده که با سمت راست معادله مطابقت دارد.\n\nمثال استفاده:\nassert(f_14(\"0000\") == 4);"}}
{"task_id": "C/15", "prompt": {"en": "#include <assert.h>\n#include <stdio.h>\n/*\nCounts the number of different coloring methods for n squares with m colors,\nconsidering the requirement that adjacent squares and the first/last squares\nmust have different colors.\n    Args:\n- n (int): The number of squares.\n- m (int): The number of colors.\n    Returns:\n    int: The count of different coloring methods satisfying the specified conditions. Result is modulo 1000003.\n    >>> f_15(1,1)\n    1\n*/\nint f_15(int n, int m)", "sq": "#include <assert.h>\n#include <stdio.h>\n/*\nNumëron numrin e metodave të ndryshme të ngjyrosjes për n katrorë me m ngjyra,\nduke konsideruar kërkesën që katrorët ngjitur dhe katrorët e parë/fundit\nduhet të kenë ngjyra të ndryshme.\n    Argumentet:\n- n (int): Numri i katrorëve.\n- m (int): Numri i ngjyrave.\n    Kthen:\n    int: Numri i metodave të ndryshme të ngjyrosjes që plotësojnë kushtet e specifikuara. Rezultati është modulo 1000003.\n    >>> f_15(1,1)\n    1\n*/\nint f_15(int n, int m)", "hy": "#include <assert.h>\n#include <stdio.h>\n/*\nՀաշվում է n քառակուսիների տարբեր գունավորման մեթոդների քանակը m գույներով,\nհաշվի առնելով այն պահանջը, որ հարակից քառակուսիները և առաջին/վերջին քառակուսիները\nպետք է ունենան տարբեր գույներ։\n    Արգումենտներ:\n- n (int): Քառակուսիների քանակը։\n- m (int): Գույների քանակը։\n    Վերադարձնում է:\n    int: Տարբեր գունավորման մեթոդների քանակը, որոնք բավարարում են նշված պայմանները։ Արդյունքը մոդուլո 1000003։\n    >>> f_15(1,1)\n    1\n*/\nint f_15(int n, int m)", "bn": "#include <assert.h>\n#include <stdio.h>\n/*\nnটি বর্গক্ষেত্রের জন্য mটি রঙের বিভিন্ন রঙ করার পদ্ধতির সংখ্যা গণনা করে,\nএই শর্ত বিবেচনা করে যে সংলগ্ন বর্গক্ষেত্র এবং প্রথম/শেষ বর্গক্ষেত্রগুলির রঙ ভিন্ন হতে হবে।\n    Args:\n- n (int): বর্গক্ষেত্রের সংখ্যা।\n- m (int): রঙের সংখ্যা।\n    Returns:\n    int: নির্দিষ্ট শর্তগুলি পূরণ করে এমন বিভিন্ন রঙ করার পদ্ধতির সংখ্যা প্রদান করে। ফলাফল 1000003 দ্বারা মডুলো।\n    >>> f_15(1,1)\n    1\n*/\nint f_15(int n, int m)", "bg": "#include <assert.h>\n#include <stdio.h>\n/*\nБрои броя на различните методи за оцветяване на n квадрата с m цвята,\nкато се взема предвид изискването съседните квадрати и първият/последният квадрат\nда имат различни цветове.\n    Аргументи:\n- n (int): Броят на квадратите.\n- m (int): Броят на цветовете.\n    Връща:\n    int: Броят на различните методи за оцветяване, които удовлетворяват посочените условия. Резултатът е модуло 1000003.\n    >>> f_15(1,1)\n    1\n*/\nint f_15(int n, int m)", "zh": "#include <assert.h>\n#include <stdio.h>\n/*\n计算使用 m 种颜色对 n 个方块进行不同着色的方法数，\n考虑到相邻方块和第一个/最后一个方块必须具有不同颜色的要求。\n    参数:\n- n (int): 方块的数量。\n- m (int): 颜色的数量。\n    返回:\n    int: 满足指定条件的不同着色方法的计数。结果取模 1000003。\n    >>> f_15(1,1)\n    1\n*/\nint f_15(int n, int m)", "fr": "#include <assert.h>\n#include <stdio.h>\n/*\nCompte le nombre de méthodes de coloration différentes pour n carrés avec m couleurs,\nen considérant l'exigence que les carrés adjacents et les premiers/derniers carrés\ndoivent avoir des couleurs différentes.\n    Args:\n- n (int): Le nombre de carrés.\n- m (int): Le nombre de couleurs.\n    Returns:\n    int: Le compte des différentes méthodes de coloration satisfaisant les conditions spécifiées. Le résultat est modulo 1000003.\n    >>> f_15(1,1)\n    1\n*/\nint f_15(int n, int m)", "de": "#include <assert.h>\n#include <stdio.h>\n/*\nZählt die Anzahl der verschiedenen Färbemethoden für n Quadrate mit m Farben,\nunter Berücksichtigung der Anforderung, dass benachbarte Quadrate und die ersten/letzten Quadrate\nunterschiedliche Farben haben müssen.\n    Argumente:\n- n (int): Die Anzahl der Quadrate.\n- m (int): Die Anzahl der Farben.\n    Rückgabe:\n    int: Die Anzahl der verschiedenen Färbemethoden, die die angegebenen Bedingungen erfüllen. Das Ergebnis ist modulo 1000003.\n    >>> f_15(1,1)\n    1\n*/\nint f_15(int n, int m)", "ha": "#include <assert.h>\n#include <stdio.h>\n/*\nYana ƙididdige adadin hanyoyin canza launi daban-daban don murabba'i n tare da launuka m,\nla'akari da buƙatar cewa murabba'ai masu makwabtaka da murabba'i na farko/na ƙarshe\ndole ne su sami launuka daban-daban.\n    Args:\n- n (int): Yawan murabba'ai.\n- m (int): Yawan launuka.\n    Returns:\n    int: Adadin hanyoyin canza launi daban-daban da suka cika ƙa'idodin da aka fayyace. Sakamakon yana cikin modulo 1000003.\n    >>> f_15(1,1)\n    1\n*/\nint f_15(int n, int m)", "hi": "#include <assert.h>\n#include <stdio.h>\n/*\nn वर्गों के लिए m रंगों की विभिन्न रंगाई विधियों की संख्या गिनता है,\nइस आवश्यकता को ध्यान में रखते हुए कि आसन्न वर्गों और पहले/अंतिम वर्गों के\nरंग अलग-अलग होने चाहिए।\n    तर्क:\n- n (int): वर्गों की संख्या।\n- m (int): रंगों की संख्या।\n    लौटाता है:\n    int: निर्दिष्ट शर्तों को संतोषजनक बनाने वाली विभिन्न रंगाई विधियों की संख्या। परिणाम 1000003 के मापांक में है।\n    >>> f_15(1,1)\n    1\n*/\nint f_15(int n, int m)", "hu": "#include <assert.h>\n#include <stdio.h>\n/*\nMegszámolja az n négyzet m színnel való különböző színezési módszereit,\nfigyelembe véve azt a követelményt, hogy a szomszédos négyzetek és az első/utolsó négyzetek\nkülönböző színűek legyenek.\n    Args:\n- n (int): A négyzetek száma.\n- m (int): A színek száma.\n    Returns:\n    int: Az adott feltételeknek megfelelő különböző színezési módszerek száma. Az eredmény modulo 1000003.\n    >>> f_15(1,1)\n    1\n*/\nint f_15(int n, int m)", "es": "#include <assert.h>\n#include <stdio.h>\n/*\nCuenta el número de métodos de coloreado diferentes para n cuadrados con m colores,\nconsiderando el requisito de que los cuadrados adyacentes y los primeros/últimos cuadrados\ndeben tener colores diferentes.\n    Args:\n- n (int): El número de cuadrados.\n- m (int): El número de colores.\n    Returns:\n    int: La cuenta de diferentes métodos de coloreado que satisfacen las condiciones especificadas. El resultado es módulo 1000003.\n    >>> f_15(1,1)\n    1\n*/\nint f_15(int n, int m)", "arb": "#include <assert.h>\n#include <stdio.h>\n/*\nيحسب عدد طرق التلوين المختلفة لمربعات n باستخدام ألوان m،\nمع مراعاة الشرط بأن المربعات المتجاورة والمربعات الأولى/الأخيرة\nيجب أن تكون بألوان مختلفة.\n    Args:\n- n (int): عدد المربعات.\n- m (int): عدد الألوان.\n    Returns:\n    int: عدد طرق التلوين المختلفة التي تلبي الشروط المحددة. النتيجة هي باقي القسمة على 1000003.\n    >>> f_15(1,1)\n    1\n*/\nint f_15(int n, int m)", "sw": "#include <assert.h>\n#include <stdio.h>\n/*\nInahesabu idadi ya mbinu tofauti za kupaka rangi miraba n kwa rangi m,\nikizingatia sharti kwamba miraba iliyo karibu na miraba ya kwanza/mwisho\nlazima iwe na rangi tofauti.\n    Args:\n- n (int): Idadi ya miraba.\n- m (int): Idadi ya rangi.\n    Returns:\n    int: Idadi ya mbinu tofauti za kupaka rangi zinazokidhi masharti maalum. Matokeo ni modulo 1000003.\n    >>> f_15(1,1)\n    1\n*/\nint f_15(int n, int m)", "tr": "#include <assert.h>\n#include <stdio.h>\n/*\nn kare için m renk ile farklı boyama yöntemlerinin sayısını sayar,\nbitişik karelerin ve ilk/son karelerin farklı renklere sahip olması gerektiği şartını dikkate alarak.\n    Argümanlar:\n- n (int): Karelerin sayısı.\n- m (int): Renklerin sayısı.\n    Döndürür:\n    int: Belirtilen koşulları karşılayan farklı boyama yöntemlerinin sayısı. Sonuç 1000003 ile mod alınır.\n    >>> f_15(1,1)\n    1\n*/\nint f_15(int n, int m)", "vi": "#include <assert.h>\n#include <stdio.h>\n/*\nĐếm số lượng phương pháp tô màu khác nhau cho n ô vuông với m màu,\nxét đến yêu cầu rằng các ô vuông liền kề và ô đầu/cuối\nphải có màu khác nhau.\n    Tham số:\n- n (int): Số lượng ô vuông.\n- m (int): Số lượng màu.\n    Trả về:\n    int: Số lượng phương pháp tô màu khác nhau thỏa mãn các điều kiện đã chỉ định. Kết quả là modulo 1000003.\n    >>> f_15(1,1)\n    1\n*/\nint f_15(int n, int m)", "id": "#include <assert.h>\n#include <stdio.h>\n/*\nMenghitung jumlah metode pewarnaan berbeda untuk n kotak dengan m warna,\ndengan mempertimbangkan syarat bahwa kotak yang bersebelahan dan kotak pertama/terakhir\nharus memiliki warna yang berbeda.\n    Args:\n- n (int): Jumlah kotak.\n- m (int): Jumlah warna.\n    Returns:\n    int: Jumlah metode pewarnaan berbeda yang memenuhi kondisi yang ditentukan. Hasil adalah modulo 1000003.\n    >>> f_15(1,1)\n    1\n*/\nint f_15(int n, int m)", "ja": "#include <assert.h>\n#include <stdio.h>\n/*\nn個の正方形をm色で塗り分ける異なる方法の数を数えます。\n隣接する正方形および最初/最後の正方形は異なる色でなければならないという要件を考慮します。\n    引数:\n- n (int): 正方形の数。\n- m (int): 色の数。\n    戻り値:\n    int: 指定された条件を満たす異なる塗り分け方法の数。結果は1000003での剰余です。\n    >>> f_15(1,1)\n    1\n*/\nint f_15(int n, int m)", "ko": "#include <assert.h>\n#include <stdio.h>\n/*\nn개의 사각형을 m개의 색상으로 색칠하는 서로 다른 방법의 수를 계산합니다.\n인접한 사각형과 첫 번째/마지막 사각형이 다른 색상을 가져야 한다는 요구 사항을 고려합니다.\n    인수:\n- n (int): 사각형의 수.\n- m (int): 색상의 수.\n    반환:\n    int: 지정된 조건을 만족하는 서로 다른 색칠 방법의 수. 결과는 1000003으로 나눈 나머지입니다.\n    >>> f_15(1,1)\n    1\n*/\nint f_15(int n, int m)\n", "ml": "#include <assert.h>\n#include <stdio.h>\n/*\nn ചതുരങ്ങൾ m നിറങ്ങളുമായി വ്യത്യസ്തമായ നിറപ്പെടുത്തൽ രീതികളുടെ എണ്ണം എണ്ണുന്നു,\nഅടുത്തുള്ള ചതുരങ്ങൾക്കും ആദ്യ/അവസാന ചതുരങ്ങൾക്കും വ്യത്യസ്ത നിറങ്ങൾ വേണമെന്ന ആവശ്യകത പരിഗണിക്കുന്നു.\n    Args:\n- n (int): ചതുരങ്ങളുടെ എണ്ണം.\n- m (int): നിറങ്ങളുടെ എണ്ണം.\n    Returns:\n    int: നിർദ്ദിഷ്ട നിബന്ധനകൾ പാലിക്കുന്ന വ്യത്യസ്ത നിറപ്പെടുത്തൽ രീതികളുടെ എണ്ണം. ഫലം 1000003 ന്റെ മോഡുലോ ആണ്.\n    >>> f_15(1,1)\n    1\n*/\nint f_15(int n, int m)", "fa": "#include <assert.h>\n#include <stdio.h>\n/*\nتعداد روش‌های مختلف رنگ‌آمیزی برای n مربع با m رنگ را شمارش می‌کند،\nبا در نظر گرفتن این الزام که مربع‌های مجاور و مربع‌های اول/آخر باید رنگ‌های متفاوتی داشته باشند.\n    آرگومان‌ها:\n- n (int): تعداد مربع‌ها.\n- m (int): تعداد رنگ‌ها.\n    بازمی‌گرداند:\n    int: تعداد روش‌های مختلف رنگ‌آمیزی که شرایط مشخص شده را برآورده می‌کند. نتیجه به پیمانه 1000003 است.\n    >>> f_15(1,1)\n    1\n*/\nint f_15(int n, int m)"}, "canonical_solution": "{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return (long long)m * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = (long long)m * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = (long long)f[2] * (m - 2) % 1000003;\n    for(int i = 4; i <= n; i++) {\n        f[i] = ((long long)f[i - 1] * (m - 2) % 1000003 +\n                (long long)f[i - 2] * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}", "instruction": {"en": "Write a C function `int f_15(int n, int m)` to solve the following problem:\nCounts the number of different coloring methods for n squares with m colors, considering the requirement that adjacent squares and the first/last squares must have different colors.\n    Args:\n- n (int): The number of squares.\n- m (int): The number of colors.\n    Returns:\n    int: The count of different coloring methods satisfying the specified conditions. Result is modulo 1000003.\n    >>> f_15(1,1)\n    1\n", "sq": "Shkruani një funksion në C `int f_15(int n, int m)` për të zgjidhur problemin e mëposhtëm:\nNumëron numrin e metodave të ndryshme të ngjyrosjes për n katrorë me m ngjyra, duke marrë parasysh kërkesën që katrorët ngjitur dhe katrorët e parë/fundit duhet të kenë ngjyra të ndryshme.\n    Argumentet:\n- n (int): Numri i katrorëve.\n- m (int): Numri i ngjyrave.\n    Kthen:\n    int: Numri i metodave të ndryshme të ngjyrosjes që plotësojnë kushtet e specifikuara. Rezultati është modulo 1000003.\n    >>> f_15(1,1)\n    1", "hy": "Գրեք C ֆունկցիա `int f_15(int n, int m)`՝ հետևյալ խնդիրը լուծելու համար:\nՀաշվում է տարբեր ներկման մեթոդների քանակը n քառակուսիների համար m գույներով՝ հաշվի առնելով, որ հարակից քառակուսիները և առաջին/վերջին քառակուսիները պետք է ունենան տարբեր գույներ:\n    Արգումենտներ:\n- n (int): Քառակուսիների քանակը:\n- m (int): Գույների քանակը:\n    Վերադարձնում է:\n    int: Տարբեր ներկման մեթոդների քանակը, որը բավարարում է նշված պայմանները: Արդյունքը մոդուլո 1000003:\n    >>> f_15(1,1)\n    1", "bn": "একটি C ফাংশন `int f_15(int n, int m)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\n n টি বর্গক্ষেত্রের জন্য m টি রঙের বিভিন্ন রঙ করার পদ্ধতির সংখ্যা গণনা করে, এই শর্ত বিবেচনা করে যে সংলগ্ন বর্গক্ষেত্র এবং প্রথম/শেষ বর্গক্ষেত্রগুলির রঙ ভিন্ন হতে হবে।\n    আর্গুমেন্টসমূহ:\n- n (int): বর্গক্ষেত্রের সংখ্যা।\n- m (int): রঙের সংখ্যা।\n    রিটার্নস:\n    int: নির্দিষ্ট শর্তাবলী পূরণকারী বিভিন্ন রঙ করার পদ্ধতির সংখ্যা গণনা করে। ফলাফল 1000003 দ্বারা মডুলো।\n    >>> f_15(1,1)\n    1", "bg": "Напишете C функция `int f_15(int n, int m)` за решаване на следния проблем:\nБрои броя на различните методи за оцветяване на n квадрата с m цвята, като се има предвид изискването съседните квадрати и първият/последният квадрат да имат различни цветове.\n    Аргументи:\n- n (int): Броят на квадратите.\n- m (int): Броят на цветовете.\n    Връща:\n    int: Броят на различните методи за оцветяване, които удовлетворяват посочените условия. Резултатът е по модул 1000003.\n    >>> f_15(1,1)\n    1", "zh": "编写一个 C 函数 `int f_15(int n, int m)` 来解决以下问题：\n计算使用 m 种颜色为 n 个方块着色的不同方法数，要求相邻的方块以及第一个和最后一个方块必须使用不同的颜色。\n    参数:\n- n (int): 方块的数量。\n- m (int): 颜色的数量。\n    返回:\n    int: 满足指定条件的不同着色方法的数量。结果对 1000003 取模。\n    >>> f_15(1,1)\n    1", "fr": "Écrire une fonction C `int f_15(int n, int m)` pour résoudre le problème suivant :\nCompte le nombre de méthodes de coloration différentes pour n carrés avec m couleurs, en considérant l'exigence que les carrés adjacents et les premiers/derniers carrés doivent avoir des couleurs différentes.\n    Args:\n- n (int) : Le nombre de carrés.\n- m (int) : Le nombre de couleurs.\n    Returns:\n    int : Le nombre de méthodes de coloration différentes satisfaisant les conditions spécifiées. Le résultat est modulo 1000003.\n    >>> f_15(1,1)\n    1", "de": "Schreiben Sie eine C-Funktion `int f_15(int n, int m)`, um das folgende Problem zu lösen:\nZählt die Anzahl der verschiedenen Färbemethoden für n Quadrate mit m Farben, wobei die Anforderung besteht, dass benachbarte Quadrate und die ersten/letzten Quadrate unterschiedliche Farben haben müssen.\n    Argumente:\n- n (int): Die Anzahl der Quadrate.\n- m (int): Die Anzahl der Farben.\n    Rückgabewert:\n    int: Die Anzahl der verschiedenen Färbemethoden, die die angegebenen Bedingungen erfüllen. Das Ergebnis ist modulo 1000003.\n    >>> f_15(1,1)\n    1", "ha": "Rubuta aikin C `int f_15(int n, int m)` don warware matsalar mai zuwa:\nYana ƙididdige yawan hanyoyin launuka daban-daban don murabba'i n tare da launuka m, la'akari da buƙatar cewa murabba'i masu makwabtaka da murabba'i na farko/na ƙarshe dole ne su sami launuka daban-daban.\n   Args:\n- n (int): Yawan murabba'ai.\n- m (int): Yawan launuka.\n   Returns:\n   int: Yawan hanyoyin launuka daban-daban da suka cika sharuɗɗan da aka fayyace. Sakamako yana daidai da 1000003.\n   >>> f_15(1,1)\n   1", "hi": "C फ़ंक्शन `int f_15(int n, int m)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nn वर्गों के लिए m रंगों के विभिन्न रंगाई तरीकों की संख्या गिनें, इस आवश्यकता को ध्यान में रखते हुए कि आसन्न वर्ग और पहले/अंतिम वर्गों के रंग अलग-अलग होने चाहिए।\n    तर्क:\n- n (int): वर्गों की संख्या।\n- m (int): रंगों की संख्या।\n    रिटर्न करता है:\n    int: निर्दिष्ट शर्तों को संतुष्ट करने वाले विभिन्न रंगाई तरीकों की गिनती। परिणाम 1000003 के मापांक में है।\n    >>> f_15(1,1)\n    1", "hu": "Írj egy C függvényt `int f_15(int n, int m)` a következő probléma megoldására:\nMegszámolja az n négyzet m színnel történő különböző színezési módszereit, figyelembe véve azt a követelményt, hogy a szomszédos négyzetek és az első/utolsó négyzetek különböző színűek legyenek.\n    Args:\n- n (int): A négyzetek száma.\n- m (int): A színek száma.\n    Returns:\n    int: A megadott feltételeknek megfelelő különböző színezési módszerek száma. Az eredmény modulo 1000003.\n    >>> f_15(1,1)\n    1", "es": "Escribe una función en C `int f_15(int n, int m)` para resolver el siguiente problema:\nCuenta el número de diferentes métodos de coloreo para n cuadrados con m colores, considerando el requisito de que los cuadrados adyacentes y los primeros/últimos cuadrados deben tener colores diferentes.\n    Args:\n- n (int): El número de cuadrados.\n- m (int): El número de colores.\n    Returns:\n    int: El conteo de diferentes métodos de coloreo que satisfacen las condiciones especificadas. El resultado es módulo 1000003.\n    >>> f_15(1,1)\n    1", "arb": "اكتب دالة بلغة C `int f_15(int n, int m)` لحل المشكلة التالية:\nتحسب عدد طرق التلوين المختلفة لـ n من المربعات باستخدام m من الألوان، مع مراعاة الشرط بأن المربعات المتجاورة والمربعات الأول/الأخير يجب أن تكون بألوان مختلفة.\n    Args:\n- n (int): عدد المربعات.\n- m (int): عدد الألوان.\n    Returns:\n    int: عدد طرق التلوين المختلفة التي تفي بالشروط المحددة. النتيجة هي باقي القسمة على 1000003.\n    >>> f_15(1,1)\n    1", "sw": "Andika kazi ya C `int f_15(int n, int m)` kutatua tatizo lifuatalo:\nHesabu idadi ya mbinu tofauti za kupaka rangi kwa miraba n na rangi m, ukizingatia sharti kwamba miraba iliyo karibu na miraba ya kwanza/mwisho lazima iwe na rangi tofauti.\n    Args:\n- n (int): Idadi ya miraba.\n- m (int): Idadi ya rangi.\n    Returns:\n    int: Hesabu ya mbinu tofauti za kupaka rangi zinazokidhi masharti maalum. Matokeo ni modulo 1000003.\n    >>> f_15(1,1)\n    1", "tr": "Bir C fonksiyonu `int f_15(int n, int m)` yazın ve aşağıdaki problemi çözün:\nn kareyi m renkle boyamak için farklı yöntemlerin sayısını sayar, bitişik karelerin ve ilk/son karelerin farklı renklere sahip olması gerektiği şartını göz önünde bulundurarak.\n    Args:\n- n (int): Karelerin sayısı.\n- m (int): Renklerin sayısı.\n    Returns:\n    int: Belirtilen koşulları karşılayan farklı boyama yöntemlerinin sayısı. Sonuç 1000003 ile mod alınmıştır.\n    >>> f_15(1,1)\n    1", "vi": "Viết một hàm C `int f_15(int n, int m)` để giải quyết vấn đề sau:\nĐếm số lượng phương pháp tô màu khác nhau cho n ô vuông với m màu, với yêu cầu rằng các ô vuông liền kề và các ô vuông đầu/cuối phải có màu khác nhau.\n   Tham số:\n- n (int): Số lượng ô vuông.\n- m (int): Số lượng màu.\n   Trả về:\n   int: Số lượng phương pháp tô màu khác nhau thỏa mãn các điều kiện đã chỉ định. Kết quả được lấy modulo 1000003.\n   >>> f_15(1,1)\n   1", "id": "Tulis fungsi C `int f_15(int n, int m)` untuk menyelesaikan masalah berikut:\nMenghitung jumlah metode pewarnaan yang berbeda untuk n kotak dengan m warna, dengan mempertimbangkan persyaratan bahwa kotak yang berdekatan dan kotak pertama/terakhir harus memiliki warna yang berbeda.\n    Args:\n- n (int): Jumlah kotak.\n- m (int): Jumlah warna.\n    Returns:\n    int: Jumlah metode pewarnaan berbeda yang memenuhi kondisi yang ditentukan. Hasil adalah modulo 1000003.\n    >>> f_15(1,1)\n    1", "ja": "Cの関数を書け `int f_15(int n, int m)` を使用して次の問題を解決します:\nn 個の正方形を m 色で塗る異なる方法の数を数えます。ただし、隣接する正方形および最初/最後の正方形は異なる色でなければなりません。\n    引数:\n- n (int): 正方形の数。\n- m (int): 色の数。\n    戻り値:\n    int: 指定された条件を満たす異なる塗り方の数。結果は 1000003 での剰余です。\n    >>> f_15(1,1)\n    1", "ko": "C 함수 `int f_15(int n, int m)`을 작성하여 다음 문제를 해결하십시오:\n인접한 사각형과 첫 번째/마지막 사각형이 서로 다른 색이어야 한다는 요구 사항을 고려하여 n개의 사각형에 대해 m개의 색상으로 색칠하는 다양한 방법의 수를 계산합니다.\n    매개변수:\n- n (int): 사각형의 수.\n- m (int): 색상의 수.\n    반환값:\n    int: 지정된 조건을 만족하는 다양한 색칠 방법의 수. 결과는 1000003으로 나눈 나머지입니다.\n    >>> f_15(1,1)\n    1", "ml": "C ഭാഷയിൽ ഒരു ഫംഗ്ഷൻ `int f_15(int n, int m)` എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\n n ചതുരങ്ങൾക്കും m നിറങ്ങൾക്കും വ്യത്യസ്തമായ നിറം നൽകൽ മാർഗങ്ങളുടെ എണ്ണം എണ്ണുക, സമീപ ചതുരങ്ങൾക്കും ആദ്യ/അവസാന ചതുരങ്ങൾക്കും വ്യത്യസ്ത നിറങ്ങൾ വേണമെന്ന ആവശ്യകത പരിഗണിച്ച്.\n    Args:\n- n (int): ചതുരങ്ങളുടെ എണ്ണം.\n- m (int): നിറങ്ങളുടെ എണ്ണം.\n    Returns:\n    int: നിർദ്ദിഷ്ട വ്യവസ്ഥകൾ പാലിക്കുന്ന വ്യത്യസ്ത നിറം നൽകൽ മാർഗങ്ങളുടെ എണ്ണം. ഫലം 1000003 ന്റെ മോഡുലോ ആണ്.\n    >>> f_15(1,1)\n    1", "fa": "یک تابع C بنویسید `int f_15(int n, int m)` برای حل مسئله زیر:\nتعداد روش‌های مختلف رنگ‌آمیزی برای n مربع با m رنگ را می‌شمارد، با در نظر گرفتن این شرط که مربع‌های مجاور و مربع‌های اول/آخر باید رنگ‌های متفاوتی داشته باشند.\n    آرگومان‌ها:\n- n (int): تعداد مربع‌ها.\n- m (int): تعداد رنگ‌ها.\n    بازمی‌گرداند:\n    int: تعداد روش‌های مختلف رنگ‌آمیزی که شرایط مشخص شده را برآورده می‌کند. نتیجه به پیمانه 1000003 است.\n    >>> f_15(1,1)\n    1"}, "level": "hard", "test": "int main() {\n    assert(f_15(1, 1) == 1);\n    assert(f_15(2, 2) == 2);\n    assert(f_15(3, 3) == 6);\n    assert(f_15(4, 2) == 2);\n    assert(f_15(1000, 10) == 566585); // We don't have the expected result for this case\n\n    // Additional test cases\n    assert(f_15(2, 3) == 6);\n    assert(f_15(1000, 1000) == 67911);\n    assert(f_15(999,66) == 501817);\n    assert(f_15(5, 3) == 30); // Example of an expected output\n\n    // printf(\"All tests passed!\\n\");\n    return 0;\n}", "entry_point": "f_15", "signature": "int f_15(int n, int m)", "docstring": {"en": "Counts the number of different coloring methods for n squares with m colors, considering the requirement that adjacent squares and the first/last squares must have different colors.\n    Args:\n- n (int): The number of squares.\n- m (int): The number of colors.\n    Returns:\n    int: The count of different coloring methods satisfying the specified conditions. Result is modulo 1000003.\n    >>> f_15(1,1)\n    1\n", "sq": "Numëron numrin e metodave të ndryshme të ngjyrosjes për n katrorë me m ngjyra, duke marrë parasysh kërkesën që katrorët ngjitur dhe katrorët e parë/fundit duhet të kenë ngjyra të ndryshme.\n    Argumentet:\n- n (int): Numri i katrorëve.\n- m (int): Numri i ngjyrave.\n    Kthen:\n    int: Numri i metodave të ndryshme të ngjyrosjes që plotësojnë kushtet e specifikuara. Rezultati është modulo 1000003.\n    >>> f_15(1,1)\n    1", "hy": "Հաշվում է n քառակուսիների համար m գույներով տարբեր ներկման մեթոդների քանակը՝ հաշվի առնելով, որ հարակից քառակուսիները և առաջին/վերջին քառակուսիները պետք է ունենան տարբեր գույներ:\n    Արգումենտներ:\n- n (int): Քառակուսիների քանակը:\n- m (int): Գույների քանակը:\n    Վերադարձնում է:\n    int: Տարբեր ներկման մեթոդների քանակը, որը բավարարում է նշված պայմանները: Արդյունքը՝ մոդուլո 1000003:\n    >>> f_15(1,1)\n    1", "bn": "nটি বর্গক্ষেত্র এবং mটি রঙের জন্য বিভিন্ন রঙ করার পদ্ধতির সংখ্যা গণনা করে, যেখানে শর্ত হল যে সংলগ্ন বর্গক্ষেত্র এবং প্রথম/শেষ বর্গক্ষেত্রের রঙ ভিন্ন হতে হবে।\n    Args:\n- n (int): বর্গক্ষেত্রের সংখ্যা।\n- m (int): রঙের সংখ্যা।\n    Returns:\n    int: নির্দিষ্ট শর্তগুলি পূরণকারী বিভিন্ন রঙ করার পদ্ধতির সংখ্যা। ফলাফল 1000003 দ্বারা মডুলো।\n    >>> f_15(1,1)\n    1", "bg": "Брои броя на различните методи за оцветяване на n квадрата с m цвята, като се взема предвид изискването съседните квадрати и първият/последният квадрат да имат различни цветове.\n    Аргументи:\n- n (int): Броят на квадратите.\n- m (int): Броят на цветовете.\n    Връща:\n    int: Броят на различните методи за оцветяване, които удовлетворяват посочените условия. Резултатът е модуло 1000003.\n    >>> f_15(1,1)\n    1", "zh": "计算使用 m 种颜色对 n 个方块进行不同着色的方法数，考虑到相邻方块以及第一个/最后一个方块必须具有不同颜色的要求。\n    参数:\n- n (int): 方块的数量。\n- m (int): 颜色的数量。\n    返回:\n    int: 满足指定条件的不同着色方法的计数。结果取模 1000003。\n    >>> f_15(1,1)\n    1", "fr": "Compte le nombre de méthodes de coloration différentes pour n carrés avec m couleurs, en tenant compte de l'exigence que les carrés adjacents et les premiers/derniers carrés doivent avoir des couleurs différentes.\n    Args:\n- n (int): Le nombre de carrés.\n- m (int): Le nombre de couleurs.\n    Returns:\n    int: Le compte des différentes méthodes de coloration satisfaisant les conditions spécifiées. Le résultat est modulo 1000003.\n    >>> f_15(1,1)\n    1", "de": "Zählt die Anzahl der verschiedenen Färbemethoden für n Quadrate mit m Farben, wobei die Anforderung besteht, dass benachbarte Quadrate und die ersten/letzten Quadrate unterschiedliche Farben haben müssen.\n    \nArgs:\n- n (int): Die Anzahl der Quadrate.\n- m (int): Die Anzahl der Farben.\n\nReturns:\n    int: Die Anzahl der verschiedenen Färbemethoden, die die angegebenen Bedingungen erfüllen. Das Ergebnis ist modulo 1000003.\n\n    >>> f_15(1,1)\n    1", "ha": "Yana ƙididdige yawan hanyoyin launuka daban-daban don murabba'i n tare da launuka m, la'akari da buƙatar cewa murabba'i masu makwabtaka da murabba'i na farko/na ƙarshe dole ne su sami launuka daban-daban.\n    Args:\n- n (int): Yawan murabba'ai.\n- m (int): Yawan launuka.\n    Returns:\n    int: Yawan hanyoyin zana launuka daban-daban da suka cika ka'idodin da aka fayyace. Sakamakon yana cikin modulo 1000003.\n    >>> f_15(1,1)\n    1", "hi": "विभिन्न रंगाई विधियों की संख्या की गणना करता है n वर्गों के लिए m रंगों के साथ, इस आवश्यकता को ध्यान में रखते हुए कि आसन्न वर्गों और पहले/अंतिम वर्गों के रंग अलग-अलग होने चाहिए।\n    तर्क:\n- n (int): वर्गों की संख्या।\n- m (int): रंगों की संख्या।\n    वापसी:\n    int: निर्दिष्ट शर्तों को पूरा करने वाली विभिन्न रंगाई विधियों की संख्या। परिणाम 1000003 के मापांक में है।\n    >>> f_15(1,1)\n    1", "hu": "Számolja meg a különböző színezési módszerek számát n négyzetre m színnel, figyelembe véve azt a követelményt, hogy a szomszédos négyzetek és az első/utolsó négyzetek különböző színűek legyenek.\n    Args:\n- n (int): A négyzetek száma.\n- m (int): A színek száma.\n    Returns:\n    int: A különböző színezési módszerek száma, amelyek megfelelnek a megadott feltételeknek. Az eredmény modulo 1000003.\n    >>> f_15(1,1)\n    1", "es": "Cuenta el número de diferentes métodos de coloreado para n cuadrados con m colores, considerando el requisito de que los cuadrados adyacentes y los primeros/últimos cuadrados deben tener diferentes colores.\n    Args:\n- n (int): El número de cuadrados.\n- m (int): El número de colores.\n    Returns:\n    int: El conteo de diferentes métodos de coloreado que satisfacen las condiciones especificadas. El resultado es módulo 1000003.\n    >>> f_15(1,1)\n    1", "arb": "يحسب عدد طرق التلوين المختلفة لـ n من المربعات باستخدام m من الألوان، مع مراعاة الشرط الذي يتطلب أن تكون المربعات المتجاورة والمربعات الأولى/الأخيرة بألوان مختلفة.\n    Args:\n- n (int): عدد المربعات.\n- m (int): عدد الألوان.\n    Returns:\n    int: عدد طرق التلوين المختلفة التي تفي بالشروط المحددة. النتيجة هي باقي القسمة على 1000003.\n    >>> f_15(1,1)\n    1", "sw": "Hesabu idadi ya mbinu tofauti za kupaka rangi kwa miraba n yenye rangi m, ukizingatia hitaji kwamba miraba iliyo karibu na miraba ya kwanza/mwisho lazima iwe na rangi tofauti.\n    Args:\n- n (int): Idadi ya miraba.\n- m (int): Idadi ya rangi.\n    Returns:\n    int: Idadi ya mbinu tofauti za kupaka rangi zinazokidhi masharti yaliyotajwa. Matokeo ni modulo 1000003.\n    >>> f_15(1,1)\n    1", "tr": "Farklı renklendirme yöntemlerinin sayısını, n kare ve m renk ile, bitişik karelerin ve ilk/son karelerin farklı renklere sahip olması gerekliliğini göz önünde bulundurarak sayar.\n    Args:\n- n (int): Karelerin sayısı.\n- m (int): Renklerin sayısı.\n    Returns:\n    int: Belirtilen koşulları karşılayan farklı renklendirme yöntemlerinin sayısı. Sonuç 1000003 ile mod alınır.\n    >>> f_15(1,1)\n    1", "vi": "Đếm số lượng phương pháp tô màu khác nhau cho n ô vuông với m màu, xem xét yêu cầu rằng các ô vuông liền kề và các ô đầu/cuối phải có màu khác nhau.  \n    Args: \n- n (int): Số lượng ô vuông.  \n- m (int): Số lượng màu sắc.  \n    Trả về:  \n    int: Số lượng phương pháp tô màu khác nhau thỏa mãn các điều kiện đã chỉ định. Kết quả là modulo 1000003.  \n    >>> f_15(1,1)  \n    1  ", "id": "Menghitung jumlah metode pewarnaan yang berbeda untuk n kotak dengan m warna, dengan mempertimbangkan persyaratan bahwa kotak yang bersebelahan dan kotak pertama/terakhir harus memiliki warna yang berbeda.\n    Args:\n- n (int): Jumlah kotak.\n- m (int): Jumlah warna.\n    Returns:\n    int: Jumlah metode pewarnaan yang berbeda yang memenuhi kondisi yang ditentukan. Hasil adalah modulo 1000003.\n    >>> f_15(1,1)\n    1", "ja": "n個の正方形をm色で塗り分ける方法の数を数えます。ただし、隣接する正方形と最初/最後の正方形は異なる色でなければならないという条件を考慮します。\n    引数:\n- n (int): 正方形の数。\n- m (int): 色の数。\n    戻り値:\n    int: 指定された条件を満たす異なる塗り分け方法の数。結果は1000003での剰余です。\n    >>> f_15(1,1)\n    1", "ko": "n개의 정사각형을 m개의 색상으로 칠하는 서로 다른 방법의 수를 계산합니다. 인접한 정사각형과 첫 번째/마지막 정사각형은 다른 색상이어야 한다는 요구 사항을 고려합니다.\n    인자:\n- n (int): 정사각형의 수.\n- m (int): 색상의 수.\n    반환값:\n    int: 지정된 조건을 만족하는 서로 다른 색칠 방법의 수. 결과는 1000003으로 나눈 나머지입니다.\n    >>> f_15(1,1)\n    1", "ml": "n ചതുരങ്ങൾ m നിറങ്ങളോടെ വ്യത്യസ്തമായ നിറപ്പെടുത്തൽ രീതികളുടെ എണ്ണം എണ്ണുന്നു, ചേർന്നിരിക്കുന്ന ചതുരങ്ങൾക്കും ആദ്യ/അവസാന ചതുരങ്ങൾക്കും വ്യത്യസ്ത നിറങ്ങൾ വേണമെന്ന ആവശ്യകത പരിഗണിച്ച്.\n    Args:\n- n (int): ചതുരങ്ങളുടെ എണ്ണം.\n- m (int): നിറങ്ങളുടെ എണ്ണം.\n    Returns:\n    int: നിർദ്ദിഷ്ട നിബന്ധനകൾ പാലിക്കുന്ന വ്യത്യസ്ത നിറപ്പെടുത്തൽ രീതികളുടെ എണ്ണം. ഫലം 1000003-ൽ മോദുലോ ആണ്.\n    >>> f_15(1,1)\n    1", "fa": "تعداد روش‌های رنگ‌آمیزی مختلف برای n مربع با m رنگ را محاسبه می‌کند، با در نظر گرفتن این شرط که مربع‌های مجاور و مربع‌های اول/آخر باید رنگ‌های متفاوتی داشته باشند.\n    آرگومان‌ها:\n- n (int): تعداد مربع‌ها.\n- m (int): تعداد رنگ‌ها.\n    بازگشت:\n    int: تعداد روش‌های رنگ‌آمیزی مختلف که شرایط مشخص شده را برآورده می‌کنند. نتیجه به پیمانه 1000003 است.\n    >>> f_15(1,1)\n    1"}}
{"task_id": "C/16", "prompt": {"en": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCount the number of valid coin toss sequences with no consecutive heads in n tosses.\n​    Parameters:\n- n (int): The number of coin tosses.\n​    Returns:\n​    unsigned long long: The count of valid sequences.\n    >>> f_16(1)\n    2\n*/\nunsigned long long f_16(int n)", "sq": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nNumëroni numrin e sekuencave të vlefshme të hedhjeve të monedhës pa koka radhazi në n hedhje.\n​    Parametrat:\n- n (int): Numri i hedhjeve të monedhës.\n​    Kthen:\n​    unsigned long long: Numri i sekuencave të vlefshme.\n    >>> f_16(1)\n    2\n*/\nunsigned long long f_16(int n)", "hy": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nՀաշվել վավեր մետաղադրամի նետման հաջորդականությունների քանակը առանց հաջորդական գլուխների n նետումների դեպքում:\n​    Պարամետրեր:\n- n (int): Մետաղադրամի նետումների քանակը:\n​    Վերադարձնում է:\n​    unsigned long long: Վավեր հաջորդականությունների քանակը:\n    >>> f_16(1)\n    2\n*/\nunsigned long long f_16(int n)", "bn": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nকোনো পরপরের হেড ছাড়াই n বার টস করার বৈধ কয়েন টস সিকোয়েন্সের সংখ্যা গণনা করুন।\n    প্যারামিটার:\n- n (int): কয়েন টসের সংখ্যা।\n    রিটার্নস:\n    unsigned long long: বৈধ সিকোয়েন্সের সংখ্যা।\n    >>> f_16(1)\n    2\n*/\nunsigned long long f_16(int n)", "bg": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nБройте броя на валидните последователности от хвърляния на монета без последователни ези в n хвърляния.\n​    Параметри:\n- n (int): Броят на хвърлянията на монета.\n​    Връща:\n​    unsigned long long: Броят на валидните последователности.\n    >>> f_16(1)\n    2\n*/\nunsigned long long f_16(int n)", "zh": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n计算在n次投掷中没有连续正面的有效硬币投掷序列的数量。\n    参数:\n- n (int): 硬币投掷的次数。\n    返回:\n    unsigned long long: 有效序列的数量。\n    >>> f_16(1)\n    2\n*/\nunsigned long long f_16(int n)", "fr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCompter le nombre de séquences de lancers de pièces valides sans faces consécutives dans n lancers.\n​    Paramètres :\n- n (int) : Le nombre de lancers de pièces.\n​    Renvoie :\n​    unsigned long long : Le nombre de séquences valides.\n    >>> f_16(1)\n    2\n*/\nunsigned long long f_16(int n)", "de": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nZählt die Anzahl der gültigen Münzwurfsequenzen ohne aufeinanderfolgende Köpfe in n Würfen.\n​    Parameter:\n- n (int): Die Anzahl der Münzwürfe.\n​    Rückgabe:\n​    unsigned long long: Die Anzahl der gültigen Sequenzen.\n    >>> f_16(1)\n    2\n*/\nunsigned long long f_16(int n)", "ha": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nƘididdige adadin sahihan jerin jefa tsabar kudi ba tare da kai biyu a jere ba a cikin jefa tsabar kudi n.\n​    Sigogi:\n- n (int): Adadin jefa tsabar kudi.\n​    Yana dawowa:\n​    unsigned long long: Adadin sahihan jerin.\n    >>> f_16(1)\n    2\n*/\nunsigned long long f_16(int n)", "hi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nn उछालों में बिना लगातार हेड्स के वैध सिक्का उछाल अनुक्रमों की संख्या गिनें।\n​    पैरामीटर्स:\n- n (int): सिक्का उछालों की संख्या।\n​    रिटर्न्स:\n​    unsigned long long: वैध अनुक्रमों की गिनती।\n    >>> f_16(1)\n    2\n*/\nunsigned long long f_16(int n)", "hu": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nSzámolja meg az érvényes pénzfeldobás sorozatok számát, ahol nincs egymást követő fej n dobásban.\n​    Paraméterek:\n- n (int): A pénzfeldobások száma.\n​    Visszatér:\n​    unsigned long long: Az érvényes sorozatok száma.\n    >>> f_16(1)\n    2\n*/\nunsigned long long f_16(int n)", "es": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCuenta el número de secuencias válidas de lanzamientos de moneda sin caras consecutivas en n lanzamientos.\n    Parámetros:\n- n (int): El número de lanzamientos de moneda.\n    Devuelve:\n    unsigned long long: El conteo de secuencias válidas.\n    >>> f_16(1)\n    2\n*/\nunsigned long long f_16(int n)", "arb": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nاحسب عدد تسلسلات رمي العملة الصحيحة بدون رؤوس متتالية في n من الرميات.\n    المعلمات:\n- n (int): عدد رميات العملة.\n    يعيد:\n    unsigned long long: عدد التسلسلات الصحيحة.\n    >>> f_16(1)\n    2\n*/\nunsigned long long f_16(int n)", "sw": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nHesabu idadi ya mfuatano halali wa kurusha sarafu bila vichwa vinavyofuatana katika kurusha n.\n​    Vigezo:\n- n (int): Idadi ya kurusha sarafu.\n​    Inarudisha:\n​    unsigned long long: Idadi ya mfuatano halali.\n    >>> f_16(1)\n    2\n*/\nunsigned long long f_16(int n)", "tr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nArdışık yazı gelmeyen geçerli madeni para atış dizilerinin sayısını n atışta sayın.\n​    Parametreler:\n- n (int): Madeni para atışlarının sayısı.\n​    Döndürür:\n​    unsigned long long: Geçerli dizilerin sayısı.\n    >>> f_16(1)\n    2\n*/\nunsigned long long f_16(int n)", "vi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nĐếm số lượng dãy tung đồng xu hợp lệ không có hai mặt ngửa liên tiếp trong n lần tung.\n    Tham số:\n- n (int): Số lần tung đồng xu.\n    Trả về:\n    unsigned long long: Số lượng dãy hợp lệ.\n    >>> f_16(1)\n    2\n*/\nunsigned long long f_16(int n)", "id": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nMenghitung jumlah urutan lemparan koin yang valid tanpa kepala berturut-turut dalam n lemparan.\n    Parameter:\n- n (int): Jumlah lemparan koin.\n    Mengembalikan:\n    unsigned long long: Jumlah urutan yang valid.\n    >>> f_16(1)\n    2\n*/\nunsigned long long f_16(int n)\n", "ja": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nn回のコイントスで連続した表がない有効なコイントスシーケンスの数を数えます。\n​    パラメータ:\n- n (int): コイントスの回数。\n​    戻り値:\n​    unsigned long long: 有効なシーケンスの数。\n    >>> f_16(1)\n    2\n*/\nunsigned long long f_16(int n)", "ko": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n연속된 앞면이 없는 유효한 동전 던지기 시퀀스의 수를 n번 던졌을 때 계산합니다.\n​    매개변수:\n- n (int): 동전 던지기의 횟수.\n​    반환값:\n​    unsigned long long: 유효한 시퀀스의 수.\n    >>> f_16(1)\n    2\n*/\nunsigned long long f_16(int n)", "ml": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nതുടർച്ചയായ തലകളില്ലാതെ n തവണ നാണയം എറിയുമ്പോൾ സാധുവായ നാണയ എറിയൽ ക്രമങ്ങളുടെ എണ്ണം എണ്ണുക.\n    പാരാമീറ്ററുകൾ:\n- n (int): നാണയം എറിയലുകളുടെ എണ്ണം.\n    മടക്കുന്നു:\n    unsigned long long: സാധുവായ ക്രമങ്ങളുടെ എണ്ണം.\n    >>> f_16(1)\n    2\n*/\nunsigned long long f_16(int n)", "fa": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nتعداد دنباله‌های معتبر پرتاب سکه را که در آن‌ها هیچ دو شیر متوالی وجود ندارد در n پرتاب بشمارید.\n    پارامترها:\n- n (int): تعداد پرتاب‌های سکه.\n    بازگشت:\n    unsigned long long: تعداد دنباله‌های معتبر.\n    >>> f_16(1)\n    2\n*/\nunsigned long long f_16(int n)"}, "canonical_solution": "{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n    \n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n    \n    return a[n][0] + a[n][1];\n}", "instruction": {"en": "Write a C function `unsigned long long f_16(int n)` to solve the following problem:\nCount the number of valid coin toss sequences with no consecutive heads in n tosses.\n    Parameters:\n- n (int): The number of coin tosses.\n​    Returns:\n​    unsigned long long: The count of valid sequences.\n    >>> f_16(1)\n    2\n", "sq": "Shkruani një funksion në C `unsigned long long f_16(int n)` për të zgjidhur problemin e mëposhtëm:\nNumëroni numrin e sekuencave të vlefshme të hedhjeve të monedhës pa koka radhazi në n hedhje.\n    Parametrat:\n- n (int): Numri i hedhjeve të monedhës.\n​    Kthen:\n​    unsigned long long: Numri i sekuencave të vlefshme.\n    >>> f_16(1)\n    2", "hy": "Գրեք C ֆունկցիա `unsigned long long f_16(int n)` հետևյալ խնդիրը լուծելու համար:\nՀաշվեք վավեր մետաղադրամի նետումների հաջորդականությունների քանակը առանց հաջորդական գլուխների n նետումների դեպքում։\n    Պարամետրեր:\n- n (int): Մետաղադրամի նետումների քանակը։\n​    Վերադարձնում է:\n​    unsigned long long: Վավեր հաջորդականությունների քանակը։\n    >>> f_16(1)\n    2", "bn": "একটি C ফাংশন `unsigned long long f_16(int n)` লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\nn বার টস করার সময় কোনো পরপর হেড না থাকা বৈধ কয়েন টস সিকোয়েন্সের সংখ্যা গণনা করুন।\n    প্যারামিটার:\n- n (int): কয়েন টসের সংখ্যা।\n​    রিটার্নস:\n​    unsigned long long: বৈধ সিকোয়েন্সের সংখ্যা।\n    >>> f_16(1)\n    2", "bg": "Напишете C функция `unsigned long long f_16(int n)`, за да решите следния проблем:\nПребройте броя на валидните последователности от хвърляния на монета без последователни ези в n хвърляния.\n    Параметри:\n- n (int): Броят на хвърлянията на монетата.\n​    Връща:\n​    unsigned long long: Броят на валидните последователности.\n    >>> f_16(1)\n    2", "zh": "编写一个 C 函数 `unsigned long long f_16(int n)` 来解决以下问题：\n计算在 n 次投掷中没有连续正面的有效投掷序列的数量。\n    参数：\n- n (int): 投掷硬币的次数。\n    返回：\n    unsigned long long: 有效序列的数量。\n    >>> f_16(1)\n    2", "fr": "Écrire une fonction C `unsigned long long f_16(int n)` pour résoudre le problème suivant:\nCompter le nombre de séquences de lancers de pièces valides sans têtes consécutives dans n lancers.  \n    Paramètres :  \n- n (int) : Le nombre de lancers de pièces.  \n​    Renvoie :  \n​    unsigned long long : Le compte des séquences valides.  \n    >>> f_16(1)  \n    2  ", "de": "Schreiben Sie eine C-Funktion `unsigned long long f_16(int n)`, um das folgende Problem zu lösen:\nZählen Sie die Anzahl der gültigen Münzwurfsequenzen ohne aufeinanderfolgende Köpfe in n Würfen.\n    Parameter:\n- n (int): Die Anzahl der Münzwürfe.\n​    Rückgabewert:\n​    unsigned long long: Die Anzahl der gültigen Sequenzen.\n    >>> f_16(1)\n    2", "ha": "Rubuta wani aikin C `unsigned long long f_16(int n)` don warware matsalar mai zuwa:\nƘirga adadin sahihan jerin jefa tsabar kudi ba tare da kai biyu a jere ba a cikin jefa n.\n    Sigogi:\n- n (int): Yawan jefa tsabar kudi.\n​    Mayarwa:\n​    unsigned long long: Adadin sahihan jerin.\n    >>> f_16(1)\n    2", "hi": "एक C फ़ंक्शन `unsigned long long f_16(int n)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nn उछालों में बिना लगातार हेड्स के मान्य सिक्का उछाल अनुक्रमों की संख्या गिनें।\n    पैरामीटर्स:\n- n (int): सिक्का उछालों की संख्या।\n    रिटर्न करता है:\n    unsigned long long: मान्य अनुक्रमों की संख्या।\n    >>> f_16(1)\n    2", "hu": "Írj egy C függvényt `unsigned long long f_16(int n)` a következő probléma megoldására:\nSzámold meg az érvényes pénzfeldobás sorozatok számát, ahol nincs egymást követő fej n dobás esetén.\n    Paraméterek:\n- n (int): A pénzfeldobások száma.\n​    Visszatérési érték:\n​    unsigned long long: Az érvényes sorozatok száma.\n    >>> f_16(1)\n    2", "es": "Escribe una función en C `unsigned long long f_16(int n)` para resolver el siguiente problema:\nCuenta el número de secuencias válidas de lanzamientos de moneda sin caras consecutivas en n lanzamientos.\n    Parámetros:\n- n (int): El número de lanzamientos de moneda.\n​    Retorna:\n​    unsigned long long: La cuenta de secuencias válidas.\n    >>> f_16(1)\n    2", "arb": "اكتب دالة بلغة C `unsigned long long f_16(int n)` لحل المشكلة التالية:\nاحسب عدد تسلسلات رمي العملة الصحيحة بدون رؤوس متتالية في n رميات.\n    المعاملات:\n- n (int): عدد رميات العملة.\n    يعيد:\n    unsigned long long: عدد التسلسلات الصحيحة.\n    >>> f_16(1)\n    2", "sw": "Andika kazi ya C `unsigned long long f_16(int n)` kutatua tatizo lifuatalo:\nHesabu idadi ya mfuatano sahihi wa kurusha sarafu bila vichwa vinavyoendelea katika kurusha n.\n    Vigezo:\n- n (int): Idadi ya kurusha sarafu.\n​    Inarudisha:\n​    unsigned long long: Hesabu ya mfuatano sahihi.\n    >>> f_16(1)\n    2", "tr": "Bir C fonksiyonu `unsigned long long f_16(int n)` yazın ve aşağıdaki problemi çözün:\nArdışık yazı gelmeyen geçerli para atışı dizilerinin sayısını n atışta sayın.\n    Parametreler:\n- n (int): Para atışlarının sayısı.\n​    Döndürür:\n​    unsigned long long: Geçerli dizilerin sayısı.\n    >>> f_16(1)\n    2", "vi": "Viết một hàm C `unsigned long long f_16(int n)` để giải quyết vấn đề sau:\nĐếm số lượng dãy tung đồng xu hợp lệ mà không có hai mặt ngửa liên tiếp trong n lần tung.\n    Tham số:\n- n (int): Số lần tung đồng xu.\n​    Trả về:\n​    unsigned long long: Số lượng dãy hợp lệ.\n    >>> f_16(1)\n    2", "id": "Tulis sebuah fungsi C `unsigned long long f_16(int n)` untuk menyelesaikan masalah berikut:\nHitung jumlah urutan lemparan koin yang valid tanpa kepala berturut-turut dalam n kali lemparan.\n    Parameter:\n- n (int): Jumlah lemparan koin.\n​    Mengembalikan:\n​    unsigned long long: Jumlah urutan yang valid.\n    >>> f_16(1)\n    2", "ja": "Cの関数を書け `unsigned long long f_16(int n)` を作成して、次の問題を解決してください:\nn回のコイントスで連続する表がない有効なコイントスのシーケンスの数を数えます。\n    パラメータ:\n- n (int): コイントスの回数。\n​    戻り値:\n​    unsigned long long: 有効なシーケンスの数。\n    >>> f_16(1)\n    2", "ko": "C 함수 `unsigned long long f_16(int n)`를 작성하여 다음 문제를 해결하십시오:\nn번의 던지기에서 연속된 앞면이 없는 유효한 동전 던지기 시퀀스의 수를 세십시오.\n    매개변수:\n- n (int): 동전 던지기의 횟수.\n​    반환:\n​    unsigned long long: 유효한 시퀀스의 수.\n    >>> f_16(1)\n    2", "ml": "ഒരു C ഫംഗ്ഷൻ `unsigned long long f_16(int n)` എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nതുടർച്ചയായ തലകൾ ഇല്ലാതെ n തവണ തുകൽ എറിയുമ്പോൾ സാധുവായ തുകൽ എറിയൽ ക്രമങ്ങളുടെ എണ്ണം എണ്ണുക.\n    പാരാമീറ്ററുകൾ:\n- n (int): തുകൽ എറിയലുകളുടെ എണ്ണം.\n    റിട്ടേൺസ്:\n    unsigned long long: സാധുവായ ക്രമങ്ങളുടെ എണ്ണം.\n    >>> f_16(1)\n    2", "fa": "یک تابع C بنویسید `unsigned long long f_16(int n)` برای حل مسئله زیر:\nتعداد دنباله‌های معتبر پرتاب سکه را که در آن‌ها هیچ دو شیر متوالی وجود ندارد در n پرتاب بشمارید.\n    پارامترها:\n- n (int): تعداد پرتاب‌های سکه.\n    بازگشت:\n    unsigned long long: تعداد دنباله‌های معتبر.\n    >>> f_16(1)\n    2"}, "level": "easy", "test": "int main() {\n    assert(f_16(1) == 2);\n    assert(f_16(2) == 3);\n    assert(f_16(3) == 5);\n    assert(f_16(4) == 8); // Additional test\n    assert(f_16(5) == 13); // Additional test\n    // Feel free to add more tests here\n    assert(f_16(40) == 267914296); // Additional test\n    assert(f_16(39) == 165580141); \n    assert(f_16(38) == 102334155);\n    // printf(\"All tests passed!\\n\");\n    return 0;\n}", "entry_point": "f_16", "signature": "unsigned long long f_16(int n)", "docstring": {"en": "Count the number of valid coin toss sequences with no consecutive heads in n tosses.\n    Parameters:\n- n (int): The number of coin tosses.\n​    Returns:\n​    unsigned long long: The count of valid sequences.\n    >>> f_16(1)\n    2\n", "sq": "Numëroni numrin e sekuencave të vlefshme të hedhjeve të monedhës pa koka radhazi në n hedhje.\n    Parametrat:\n- n (int): Numri i hedhjeve të monedhës.\n​    Kthen:\n​    unsigned long long: Numri i sekuencave të vlefshme.\n    >>> f_16(1)\n    2", "hy": "Հաշվել վավեր մետաղադրամի նետման հաջորդականությունների քանակը, որտեղ n նետումների դեպքում երկու հաջորդական գլխիկներ չկան:\n    Պարամետրեր:\n- n (int): Մետաղադրամի նետումների քանակը.\n    Վերադարձնում է:\n    unsigned long long: Վավեր հաջորդականությունների քանակը.\n    >>> f_16(1)\n    2", "bn": "n টসের মধ্যে কোন পরপর হেড না থাকা বৈধ কয়েন টস সিকোয়েন্সের সংখ্যা গণনা করুন।\n    প্যারামিটার:\n    - n (int): কয়েন টসের সংখ্যা।\n    রিটার্ন:\n    unsigned long long: বৈধ সিকোয়েন্সের সংখ্যা।\n    >>> f_16(1)\n    2", "bg": "Бройте броя на валидните поредици от хвърляния на монета без последователни ези в n хвърляния.\n    Параметри:\n- n (int): Броят на хвърлянията на монетата.\n    Връща:\n    unsigned long long: Броят на валидните поредици.\n    >>> f_16(1)\n    2", "zh": "计算在 n 次投掷中没有连续正面的有效硬币投掷序列的数量。\n    参数:\n- n (int): 硬币投掷的次数。\n    返回:\n    unsigned long long: 有效序列的数量。\n    >>> f_16(1)\n    2", "fr": "Compter le nombre de séquences de lancers de pièce valides sans faces consécutives dans n lancers.\n    Paramètres:\n- n (int): Le nombre de lancers de pièce.\n    Renvoie:\n    unsigned long long: Le compte des séquences valides.\n    >>> f_16(1)\n    2", "de": "Zähle die Anzahl der gültigen Münzwurfsequenzen ohne aufeinanderfolgende Köpfe in n Würfen.\n    Parameter:\n- n (int): Die Anzahl der Münzwürfe.\n​    Rückgabewert:\n​    unsigned long long: Die Anzahl der gültigen Sequenzen.\n    >>> f_16(1)\n    2", "ha": "Kirga adadin sahihan jerin jefa tsabar kudi ba tare da kai biyu a jere ba a cikin jefa tsabar kudi n.\n    Sigogi:\n- n (int): Yawan jefa tsabar kudi.\n    Mayarwa:\n    unsigned long long: Adadin sahihan jerin.\n    >>> f_16(1)\n    2", "hi": "n उछालों में कोई लगातार हेड्स न होने वाली वैध सिक्का उछाल अनुक्रमों की संख्या गिनें।\n    पैरामीटर्स:\n    - n (int): सिक्का उछालों की संख्या।\n    रिटर्न्स:\n    unsigned long long: वैध अनुक्रमों की गिनती।\n    >>> f_16(1)\n    2", "hu": "Számolja meg az érvényes pénzfeldobás sorozatok számát, amelyekben nincs egymást követő fej n dobás esetén.\n    Paraméterek:\n- n (int): A pénzfeldobások száma.\n​    Visszatér:\n​    unsigned long long: Az érvényes sorozatok száma.\n    >>> f_16(1)\n    2", "es": "Cuenta el número de secuencias válidas de lanzamientos de moneda sin caras consecutivas en n lanzamientos.\n    Parámetros:\n- n (int): El número de lanzamientos de moneda.\n​    Devuelve:\n​    unsigned long long: El conteo de secuencias válidas.\n    >>> f_16(1)\n    2", "arb": "احسب عدد التسلسلات الصحيحة لرمي العملة بدون رؤوس متتالية في n رميات.\n    المعلمات:\n- n (int): عدد رميات العملة.\n    يعيد:\n    unsigned long long: عدد التسلسلات الصحيحة.\n    >>> f_16(1)\n    2", "sw": "Hesabu idadi ya mfuatano halali wa kurusha sarafu bila vichwa mfululizo katika kurusha n.\n    Vigezo:\n- n (int): Idadi ya kurusha sarafu.\n​    Inarejesha:\n​    unsigned long long: Idadi ya mfuatano halali.\n    >>> f_16(1)\n    2", "tr": "n atışında ardışık yazı olmayan geçerli madeni para atış dizilerinin sayısını sayın.\n    Parametreler:\n- n (int): Madeni para atışlarının sayısı.\n    Döndürür:\n    unsigned long long: Geçerli dizilerin sayısı.\n    >>> f_16(1)\n    2", "vi": "Đếm số lượng chuỗi tung đồng xu hợp lệ mà không có hai mặt ngửa liên tiếp trong n lần tung.  \nTham số:  \n- n (int): Số lần tung đồng xu.  \nTrả về:  \nunsigned long long: Số lượng chuỗi hợp lệ.  \n>>> f_16(1)  \n2  ", "id": "Hitung jumlah urutan lemparan koin yang valid tanpa kepala berturut-turut dalam n lemparan.\n    Parameter:\n- n (int): Jumlah lemparan koin.\n​    Mengembalikan:\n​    unsigned long long: Jumlah urutan yang valid.\n    >>> f_16(1)\n    2", "ja": "n回のコイントスで連続する表がない有効なコイントスのシーケンスの数を数えます。\n    パラメータ:\n- n (int): コイントスの回数。\n​    戻り値:\n​    unsigned long long: 有効なシーケンスの数。\n    >>> f_16(1)\n    2", "ko": "n번 던질 때 연속된 앞면이 없는 유효한 동전 던지기 시퀀스의 수를 계산합니다.\n    매개변수:\n- n (int): 동전 던지기의 횟수.\n    반환:\n    unsigned long long: 유효한 시퀀스의 수.\n    >>> f_16(1)\n    2", "ml": "n തവണ എറിയുമ്പോൾ തുടർച്ചയായ തലകളില്ലാത്ത സാധുവായ നാണയ എറിയൽ ക്രമങ്ങളുടെ എണ്ണം എണ്ണുക.\n    പാരാമീറ്ററുകൾ:\n- n (int): നാണയം എറിയുന്ന തവണകൾ.\n    മടക്കുന്നു:\n    unsigned long long: സാധുവായ ക്രമങ്ങളുടെ എണ്ണം.\n    >>> f_16(1)\n    2", "fa": "تعداد دنباله‌های معتبر پرتاب سکه را که در آن‌ها هیچ دو شیر متوالی وجود ندارد، در n پرتاب محاسبه کنید.\n    پارامترها:\n- n (int): تعداد پرتاب‌های سکه.\n    بازگشت:\n    unsigned long long: تعداد دنباله‌های معتبر.\n    >>> f_16(1)\n    2"}}
{"task_id": "C/17", "prompt": {"en": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nFind the length of the longest consecutive sequence of 1s in the binary representation of a non-negative integer.\n​    Parameters:\n- n (unsigned long long): A non-negative integer (0 ≤ n ≤ 2^64 - 1).\n​    Returns:\n​    int: The length of the longest consecutive sequence of 1s in the binary representation of the given integer.\n​    \n    Examples:\n    >>> f_17(7)\n    3\n*/\nint f_17(unsigned long long n)", "sq": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nGjeni gjatësinë e sekuencës më të gjatë të njëshave radhazi në paraqitjen binare të një numri të plotë jo-negativ.\n​    Parametrat:\n- n (unsigned long long): Një numër i plotë jo-negativ (0 ≤ n ≤ 2^64 - 1).\n​    Kthen:\n​    int: Gjatësia e sekuencës më të gjatë të njëshave radhazi në paraqitjen binare të numrit të dhënë.\n​    \n    Shembuj:\n    >>> f_17(7)\n    3\n*/\nint f_17(unsigned long long n)", "hy": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nԳտնել ամենաերկար հաջորդական 1-երի հաջորդականության երկարությունը ոչ բացասական ամբողջ թվի բինար ներկայացման մեջ:\n​    Պարամետրեր:\n- n (unsigned long long): Ոչ բացասական ամբողջ թիվ (0 ≤ n ≤ 2^64 - 1):\n​    Վերադարձնում է:\n​    int: Տրված թվի բինար ներկայացման մեջ ամենաերկար հաջորդական 1-երի հաջորդականության երկարությունը:\n​    \n    Օրինակներ:\n    >>> f_17(7)\n    3\n*/\nint f_17(unsigned long long n)", "bn": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nএকটি অ-ঋণাত্মক পূর্ণসংখ্যার বাইনারি উপস্থাপনার মধ্যে 1 এর দীর্ঘতম ধারাবাহিক ক্রমের দৈর্ঘ্য খুঁজে বের করুন।\n    প্যারামিটার:\n- n (unsigned long long): একটি অ-ঋণাত্মক পূর্ণসংখ্যা (0 ≤ n ≤ 2^64 - 1)।\n    রিটার্নস:\n    int: প্রদত্ত পূর্ণসংখ্যার বাইনারি উপস্থাপনার মধ্যে 1 এর দীর্ঘতম ধারাবাহিক ক্রমের দৈর্ঘ্য।\n    \n    উদাহরণ:\n    >>> f_17(7)\n    3\n*/\nint f_17(unsigned long long n)", "bg": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nНамерете дължината на най-дългата последователна поредица от 1-ци в двоичното представяне на неотрицателно цяло число.\n​    Параметри:\n- n (unsigned long long): Неотрицателно цяло число (0 ≤ n ≤ 2^64 - 1).\n​    Връща:\n​    int: Дължината на най-дългата последователна поредица от 1-ци в двоичното представяне на даденото число.\n​    \n    Примери:\n    >>> f_17(7)\n    3\n*/\nint f_17(unsigned long long n)", "zh": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n找到一个非负整数的二进制表示中最长连续1的序列长度。\n    参数：\n- n (unsigned long long): 一个非负整数 (0 ≤ n ≤ 2^64 - 1)。\n    返回：\n    int: 给定整数的二进制表示中最长连续1的序列长度。\n    \n    示例：\n    >>> f_17(7)\n    3\n*/\nint f_17(unsigned long long n)", "fr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nTrouver la longueur de la plus longue séquence consécutive de 1 dans la représentation binaire d'un entier non négatif.\n​    Paramètres :\n- n (unsigned long long) : Un entier non négatif (0 ≤ n ≤ 2^64 - 1).\n​    Renvoie :\n​    int : La longueur de la plus longue séquence consécutive de 1 dans la représentation binaire de l'entier donné.\n​    \n    Exemples :\n    >>> f_17(7)\n    3\n*/\nint f_17(unsigned long long n)", "de": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nFinde die Länge der längsten aufeinanderfolgenden Sequenz von 1en in der Binärdarstellung einer nicht-negativen ganzen Zahl.\n    Parameter:\n- n (unsigned long long): Eine nicht-negative ganze Zahl (0 ≤ n ≤ 2^64 - 1).\n    Rückgabe:\n    int: Die Länge der längsten aufeinanderfolgenden Sequenz von 1en in der Binärdarstellung der gegebenen Zahl.\n    \n    Beispiele:\n    >>> f_17(7)\n    3\n*/\nint f_17(unsigned long long n)", "ha": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nNemo tsawon jere mafi tsawo na 1s a cikin wakilcin binary na lamba mara kyau.\n​    Sigogi:\n- n (unsigned long long): Lamba mara kyau (0 ≤ n ≤ 2^64 - 1).\n​    Mayar da:\n​    int: Tsawon jere mafi tsawo na 1s a cikin wakilcin binary na lambar da aka bayar.\n​    \n    Misalai:\n    >>> f_17(7)\n    3\n*/\nint f_17(unsigned long long n)", "hi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nएक गैर-ऋणात्मक पूर्णांक के बाइनरी प्रतिनिधित्व में 1s के सबसे लंबे अनुक्रम की लंबाई खोजें।\n    पैरामीटर्स:\n- n (unsigned long long): एक गैर-ऋणात्मक पूर्णांक (0 ≤ n ≤ 2^64 - 1)।\n    रिटर्न करता है:\n    int: दिए गए पूर्णांक के बाइनरी प्रतिनिधित्व में 1s के सबसे लंबे अनुक्रम की लंबाई।\n    \n    उदाहरण:\n    >>> f_17(7)\n    3\n*/\nint f_17(unsigned long long n)", "hu": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nTalálja meg a leghosszabb egymást követő 1-es sorozat hosszát egy nem negatív egész szám bináris ábrázolásában.\n​    Paraméterek:\n- n (unsigned long long): Egy nem negatív egész szám (0 ≤ n ≤ 2^64 - 1).\n​    Visszatérési érték:\n​    int: A leghosszabb egymást követő 1-es sorozat hossza a megadott egész szám bináris ábrázolásában.\n​    \n    Példák:\n    >>> f_17(7)\n    3\n*/\nint f_17(unsigned long long n)", "es": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nEncuentra la longitud de la secuencia consecutiva más larga de 1s en la representación binaria de un entero no negativo.\n    Parámetros:\n- n (unsigned long long): Un entero no negativo (0 ≤ n ≤ 2^64 - 1).\n    Devuelve:\n    int: La longitud de la secuencia consecutiva más larga de 1s en la representación binaria del entero dado.\n    \n    Ejemplos:\n    >>> f_17(7)\n    3\n*/\nint f_17(unsigned long long n)", "arb": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nابحث عن طول أطول تسلسل متتالي من 1s في التمثيل الثنائي لعدد صحيح غير سالب.\n    المعلمات:\n- n (unsigned long long): عدد صحيح غير سالب (0 ≤ n ≤ 2^64 - 1).\n    يعيد:\n    int: طول أطول تسلسل متتالي من 1s في التمثيل الثنائي للعدد الصحيح المعطى.\n    \n    أمثلة:\n    >>> f_17(7)\n    3\n*/\nint f_17(unsigned long long n)", "sw": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nPata urefu wa mlolongo mrefu zaidi wa 1 mfululizo katika uwakilishi wa binary wa nambari isiyo hasi.\n​    Vigezo:\n- n (unsigned long long): Nambari isiyo hasi (0 ≤ n ≤ 2^64 - 1).\n​    Inarejesha:\n​    int: Urefu wa mlolongo mrefu zaidi wa 1 mfululizo katika uwakilishi wa binary wa nambari iliyotolewa.\n​    \n    Mifano:\n    >>> f_17(7)\n    3\n*/\nint f_17(unsigned long long n)", "tr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nNegatif olmayan bir tam sayının ikili gösteriminde ardışık 1'lerin en uzun dizisinin uzunluğunu bulun.\n​    Parametreler:\n- n (unsigned long long): Negatif olmayan bir tam sayı (0 ≤ n ≤ 2^64 - 1).\n​    Döndürülen:\n​    int: Verilen tam sayının ikili gösterimindeki ardışık 1'lerin en uzun dizisinin uzunluğu.\n​    \n    Örnekler:\n    >>> f_17(7)\n    3\n*/\nint f_17(unsigned long long n)", "vi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nTìm độ dài của dãy liên tiếp dài nhất của số 1 trong biểu diễn nhị phân của một số nguyên không âm.\n    Tham số:\n- n (unsigned long long): Một số nguyên không âm (0 ≤ n ≤ 2^64 - 1).\n    Trả về:\n    int: Độ dài của dãy liên tiếp dài nhất của số 1 trong biểu diễn nhị phân của số nguyên đã cho.\n    \n    Ví dụ:\n    >>> f_17(7)\n    3\n*/\nint f_17(unsigned long long n)", "id": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nTemukan panjang urutan 1s terpanjang yang berurutan dalam representasi biner dari bilangan bulat non-negatif.\n    Parameter:\n- n (unsigned long long): Bilangan bulat non-negatif (0 ≤ n ≤ 2^64 - 1).\n    Mengembalikan:\n    int: Panjang urutan 1s terpanjang yang berurutan dalam representasi biner dari bilangan bulat yang diberikan.\n    \n    Contoh:\n    >>> f_17(7)\n    3\n*/\nint f_17(unsigned long long n)", "ja": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n非負整数の2進数表現における1の最長連続シーケンスの長さを見つけます。\n    パラメータ:\n- n (unsigned long long): 非負整数 (0 ≤ n ≤ 2^64 - 1)。\n    戻り値:\n    int: 与えられた整数の2進数表現における1の最長連続シーケンスの長さ。\n    \n    例:\n    >>> f_17(7)\n    3\n*/\nint f_17(unsigned long long n)", "ko": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n비음수가 아닌 정수의 이진 표현에서 1이 연속으로 나타나는 가장 긴 시퀀스의 길이를 찾습니다.\n​    매개변수:\n- n (unsigned long long): 비음수가 아닌 정수 (0 ≤ n ≤ 2^64 - 1).\n​    반환값:\n​    int: 주어진 정수의 이진 표현에서 1이 연속으로 나타나는 가장 긴 시퀀스의 길이.\n​    \n    예시:\n    >>> f_17(7)\n    3\n*/\nint f_17(unsigned long long n)\n", "ml": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nഒരു അനോന്യമായ പൂർണ്ണസംഖ്യയുടെ ബൈനറി പ്രതിനിധാനത്തിൽ 1 കളുടെ ഏറ്റവും നീണ്ട അനന്തര ശ്രേണിയുടെ നീളം കണ്ടെത്തുക.\n    പാരാമീറ്ററുകൾ:\n- n (unsigned long long): ഒരു അനോന്യമായ പൂർണ്ണസംഖ്യ (0 ≤ n ≤ 2^64 - 1).\n    മടക്കുന്നു:\n    int: നൽകിയ പൂർണ്ണസംഖ്യയുടെ ബൈനറി പ്രതിനിധാനത്തിൽ 1 കളുടെ ഏറ്റവും നീണ്ട അനന്തര ശ്രേണിയുടെ നീളം.\n    \n    ഉദാഹരണങ്ങൾ:\n    >>> f_17(7)\n    3\n*/\nint f_17(unsigned long long n)", "fa": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nطولانی‌ترین دنباله متوالی از 1ها را در نمایش باینری یک عدد صحیح غیرمنفی پیدا کنید.\n    پارامترها:\n- n (unsigned long long): یک عدد صحیح غیرمنفی (0 ≤ n ≤ 2^64 - 1).\n    بازمی‌گرداند:\n    int: طولانی‌ترین دنباله متوالی از 1ها در نمایش باینری عدد داده شده.\n\n    مثال‌ها:\n    >>> f_17(7)\n    3\n*/\nint f_17(unsigned long long n)"}, "canonical_solution": "{\n    int max = 0;\n    int ans = 0;\n    while(n){\n        if(n & 1)\n            ans++;\n        else{\n            if(ans > max)\n                max = ans;\n            ans = 0;\n        }\n        n >>= 1;\n    }\n    if(ans > max)\n        max = ans;\n    return max;\n}", "instruction": {"en": "Write a C function `int f_17(unsigned long long n)` to solve the following problem:\nFind the length of the longest consecutive sequence of 1s in the binary representation of a non-negative integer.\n    Parameters:\n- n (unsigned long long): A non-negative integer (0 ≤ n ≤ 2^64 - 1).\n    Returns:\n    int: The length of the longest consecutive sequence of 1s in the binary representation of the given integer.\n    \n    Examples:\n    >>> f_17(7)\n    3\n", "sq": "Shkruani një funksion në C `int f_17(unsigned long long n)` për të zgjidhur problemin në vijim:\nGjeni gjatësinë e sekuencës më të gjatë të njëshave radhazi në paraqitjen binare të një numri të plotë jo-negativ.\n    Parametrat:\n- n (unsigned long long): Një numër i plotë jo-negativ (0 ≤ n ≤ 2^64 - 1).\n    Kthen:\n    int: Gjatësia e sekuencës më të gjatë të njëshave radhazi në paraqitjen binare të numrit të dhënë.\n    \n    Shembuj:\n    >>> f_17(7)\n    3", "hy": "Գրեք C ֆունկցիա `int f_17(unsigned long long n)` հետևյալ խնդիրը լուծելու համար:\nԳտնել ամենաերկար հաջորդական 1-երի հաջորդականության երկարությունը ոչ բացասական ամբողջ թվի բինար ներկայացման մեջ։\n    Պարամետրեր:\n- n (unsigned long long): Ոչ բացասական ամբողջ թիվ (0 ≤ n ≤ 2^64 - 1)։\n    Վերադարձնում է:\n    int: Տրված ամբողջ թվի բինար ներկայացման մեջ ամենաերկար հաջորդական 1-երի հաջորդականության երկարությունը։\n    \n    Օրինակներ:\n    >>> f_17(7)\n    3", "bn": "একটি C ফাংশন `int f_17(unsigned long long n)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি অ-ঋণাত্মক পূর্ণসংখ্যার বাইনারি উপস্থাপনার মধ্যে 1-এর দীর্ঘতম ক্রমাগত ক্রমের দৈর্ঘ্য খুঁজুন।\n    প্যারামিটারসমূহ:\n- n (unsigned long long): একটি অ-ঋণাত্মক পূর্ণসংখ্যা (0 ≤ n ≤ 2^64 - 1)।\n    রিটার্নস:\n    int: প্রদত্ত পূর্ণসংখ্যার বাইনারি উপস্থাপনার মধ্যে 1-এর দীর্ঘতম ক্রমাগত ক্রমের দৈর্ঘ্য।\n\n    উদাহরণ:\n    >>> f_17(7)\n    3", "bg": "Напишете C функция `int f_17(unsigned long long n)`, за да решите следния проблем:\nНамерете дължината на най-дългата последователност от 1-ци в двоичното представяне на неотрицателно цяло число.\n    Параметри:\n- n (unsigned long long): Неотрицателно цяло число (0 ≤ n ≤ 2^64 - 1).\n    Връща:\n    int: Дължината на най-дългата последователност от 1-ци в двоичното представяне на даденото число.\n    \n    Примери:\n    >>> f_17(7)\n    3", "zh": "编写一个 C 函数 `int f_17(unsigned long long n)` 来解决以下问题：\n找到一个非负整数的二进制表示中最长连续 1 序列的长度。\n    参数：\n- n (unsigned long long): 一个非负整数 (0 ≤ n ≤ 2^64 - 1)。\n    返回：\n    int: 给定整数的二进制表示中最长连续 1 序列的长度。\n    \n    示例：\n    >>> f_17(7)\n    3", "fr": "Écrire une fonction C `int f_17(unsigned long long n)` pour résoudre le problème suivant:\nTrouver la longueur de la plus longue séquence consécutive de 1 dans la représentation binaire d'un entier non négatif.  \n    Paramètres :  \n- n (unsigned long long) : Un entier non négatif (0 ≤ n ≤ 2^64 - 1).  \n    Renvoie :  \n    int : La longueur de la plus longue séquence consécutive de 1 dans la représentation binaire de l'entier donné.  \n    \n    Exemples :  \n    >>> f_17(7)  \n    3  ", "de": "Schreiben Sie eine C-Funktion `int f_17(unsigned long long n)`, um das folgende Problem zu lösen:\nFinden Sie die Länge der längsten aufeinanderfolgenden Sequenz von 1en in der Binärdarstellung einer nicht-negativen ganzen Zahl.\n    Parameter:\n- n (unsigned long long): Eine nicht-negative ganze Zahl (0 ≤ n ≤ 2^64 - 1).\n    Rückgabewert:\n    int: Die Länge der längsten aufeinanderfolgenden Sequenz von 1en in der Binärdarstellung der gegebenen ganzen Zahl.\n    \n    Beispiele:\n    >>> f_17(7)\n    3", "ha": "Rubuta wani aikin C `int f_17(unsigned long long n)` don warware matsalar mai zuwa:\nNemo tsawon jerin lambobi 1s mafi tsawo a cikin wakilcin binary na lamba mara kyau.\n    Sigogi:\n- n (unsigned long long): Wata lamba mara kyau (0 ≤ n ≤ 2^64 - 1).\n    Mayar da:\n    int: Tsawon jerin lambobi 1s mafi tsawo a cikin wakilcin binary na lambar da aka bayar.\n    \n    Misalai:\n    >>> f_17(7)\n    3", "hi": "C फ़ंक्शन `int f_17(unsigned long long n)` लिखें ताकि निम्नलिखित समस्या को हल किया जा सके:\nएक गैर-ऋणात्मक पूर्णांक के बाइनरी रूप में 1s के सबसे लंबे अनुक्रम की लंबाई खोजें।\n    पैरामीटर्स:\n- n (unsigned long long): एक गैर-ऋणात्मक पूर्णांक (0 ≤ n ≤ 2^64 - 1)।\n    रिटर्न करता है:\n    int: दिए गए पूर्णांक के बाइनरी रूप में 1s के सबसे लंबे अनुक्रम की लंबाई।\n    \n    उदाहरण:\n    >>> f_17(7)\n    3", "hu": "Írj egy C függvényt `int f_17(unsigned long long n)` a következő probléma megoldására:\nTaláld meg a leghosszabb egymást követő 1-es sorozat hosszát egy nem negatív egész szám bináris ábrázolásában.\n    Paraméterek:\n- n (unsigned long long): Egy nem negatív egész szám (0 ≤ n ≤ 2^64 - 1).\n    Visszatérési érték:\n    int: A leghosszabb egymást követő 1-es sorozat hossza a megadott egész szám bináris ábrázolásában.\n    \n    Példák:\n    >>> f_17(7)\n    3", "es": "Escribe una función en C `int f_17(unsigned long long n)` para resolver el siguiente problema:\nEncuentra la longitud de la secuencia consecutiva más larga de 1s en la representación binaria de un número entero no negativo.\n    Parámetros:\n- n (unsigned long long): Un número entero no negativo (0 ≤ n ≤ 2^64 - 1).\n    Retorna:\n    int: La longitud de la secuencia consecutiva más larga de 1s en la representación binaria del número entero dado.\n    \n    Ejemplos:\n    >>> f_17(7)\n    3", "arb": "اكتب دالة بلغة C `int f_17(unsigned long long n)` لحل المشكلة التالية:\nابحث عن طول أطول تسلسل متتابع من الأرقام 1 في التمثيل الثنائي لعدد صحيح غير سالب.\n    المعاملات:\n- n (unsigned long long): عدد صحيح غير سالب (0 ≤ n ≤ 2^64 - 1).\n    يعيد:\n    int: طول أطول تسلسل متتابع من الأرقام 1 في التمثيل الثنائي للعدد الصحيح المعطى.\n    \n    أمثلة:\n    >>> f_17(7)\n    3", "sw": "Andika kazi ya C `int f_17(unsigned long long n)` kutatua tatizo lifuatalo:\nPata urefu wa mlolongo mrefu zaidi wa 1 katika uwakilishi wa binary wa nambari isiyo hasi.\n    Vigezo:\n- n (unsigned long long): Nambari isiyo hasi (0 ≤ n ≤ 2^64 - 1).\n    Inarejesha:\n    int: Urefu wa mlolongo mrefu zaidi wa 1 katika uwakilishi wa binary wa nambari iliyotolewa.\n    \n    Mifano:\n    >>> f_17(7)\n    3", "tr": "Bir C fonksiyonu `int f_17(unsigned long long n)` yazın ve aşağıdaki problemi çözün:\nBir pozitif olmayan tam sayının ikili gösteriminde en uzun ardışık 1'ler dizisinin uzunluğunu bulun.\n    Parametreler:\n- n (unsigned long long): Pozitif olmayan bir tam sayı (0 ≤ n ≤ 2^64 - 1).\n    Döndürülen:\n    int: Verilen tam sayının ikili gösterimindeki en uzun ardışık 1'ler dizisinin uzunluğu.\n    \n    Örnekler:\n    >>> f_17(7)\n    3", "vi": "Viết một hàm C `int f_17(unsigned long long n)` để giải quyết vấn đề sau:\nTìm độ dài của dãy liên tiếp dài nhất của các số 1 trong biểu diễn nhị phân của một số nguyên không âm.\n    \n    Tham số:\n- n (unsigned long long): Một số nguyên không âm (0 ≤ n ≤ 2^64 - 1).\n    \n    Trả về:\n    int: Độ dài của dãy liên tiếp dài nhất của các số 1 trong biểu diễn nhị phân của số nguyên đã cho.\n    \n    Ví dụ:\n    >>> f_17(7)\n    3", "id": "Tulis fungsi C `int f_17(unsigned long long n)` untuk menyelesaikan masalah berikut:\nTemukan panjang urutan 1 berturut-turut terpanjang dalam representasi biner dari bilangan bulat non-negatif.\n    Parameter:\n- n (unsigned long long): Sebuah bilangan bulat non-negatif (0 ≤ n ≤ 2^64 - 1).\n    Mengembalikan:\n    int: Panjang urutan 1 berturut-turut terpanjang dalam representasi biner dari bilangan bulat yang diberikan.\n    \n    Contoh:\n    >>> f_17(7)\n    3", "ja": "Cの関数を書け `int f_17(unsigned long long n)` を作成して、次の問題を解決してください:\n非負整数の2進数表現における1の最長連続シーケンスの長さを見つけてください。\n    パラメータ:\n- n (unsigned long long): 非負整数 (0 ≤ n ≤ 2^64 - 1)。\n    戻り値:\n    int: 与えられた整数の2進数表現における1の最長連続シーケンスの長さ。\n    \n    例:\n    >>> f_17(7)\n    3", "ko": "C 함수 `int f_17(unsigned long long n)`를 작성하여 다음 문제를 해결하십시오:\n비음수 정수의 이진 표현에서 1의 가장 긴 연속 시퀀스의 길이를 찾으십시오.\n    매개변수:\n- n (unsigned long long): 비음수 정수 (0 ≤ n ≤ 2^64 - 1).\n    반환값:\n    int: 주어진 정수의 이진 표현에서 1의 가장 긴 연속 시퀀스의 길이.\n    \n    예시:\n    >>> f_17(7)\n    3", "ml": "C ഭാഷയിൽ ഒരു ഫംഗ്ഷൻ `int f_17(unsigned long long n)` എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nഒരു അസാധാരണമായ പൂജ്യാത്മക പൂർണ്ണസംഖ്യയുടെ ബൈനറി പ്രതിനിധാനത്തിൽ ഏറ്റവും നീളമുള്ള അനന്തരമായ 1മാരുടെ ശ്രേണിയുടെ നീളം കണ്ടെത്തുക.\n    പാരാമീറ്ററുകൾ:\n- n (unsigned long long): ഒരു അസാധാരണമായ പൂജ്യാത്മക പൂർണ്ണസംഖ്യ (0 ≤ n ≤ 2^64 - 1).\n    മടക്കം:\n    int: നൽകിയിരിക്കുന്ന പൂർണ്ണസംഖ്യയുടെ ബൈനറി പ്രതിനിധാനത്തിൽ ഏറ്റവും നീളമുള്ള അനന്തരമായ 1മാരുടെ ശ്രേണിയുടെ നീളം.\n    \n    ഉദാഹരണങ്ങൾ:\n    >>> f_17(7)\n    3", "fa": "یک تابع C `int f_17(unsigned long long n)` بنویسید تا مسئله زیر را حل کند:\nطول بلندترین دنباله متوالی از 1ها را در نمایش باینری یک عدد صحیح غیرمنفی پیدا کنید.\n    پارامترها:\n- n (unsigned long long): یک عدد صحیح غیرمنفی (0 ≤ n ≤ 2^64 - 1).\n    بازگشتی:\n    int: طول بلندترین دنباله متوالی از 1ها در نمایش باینری عدد داده شده.\n\n    مثال‌ها:\n    >>> f_17(7)\n    3"}, "level": "easy", "test": "int main()\n{\n    assert(f_17(7) == 3);\n    assert(f_17(13) == 2);\n    assert(f_17(12345) == 3); // New test sample\n    assert(f_17(0b11011101111) == 4); // New test sample using binary literal for clarity\n    assert(f_17(0xFFFFFFFF) == 32); // New test sample: all ones for a 32-bit number\n    assert(f_17(0) == 0); // New test sample: no ones in a zero\n\n    // printf(\"All tests passed!\\n\");\n    return 0;\n}", "entry_point": "f_17", "signature": "int f_17(unsigned long long n)", "docstring": {"en": "Find the length of the longest consecutive sequence of 1s in the binary representation of a non-negative integer.\n    Parameters:\n- n (unsigned long long): A non-negative integer (0 ≤ n ≤ 2^64 - 1).\n    Returns:\n    int: The length of the longest consecutive sequence of 1s in the binary representation of the given integer.\n    \n    Examples:\n    >>> f_17(7)\n    3\n", "sq": "Gjeni gjatësinë e sekuencës më të gjatë të njëshave radhazi në përfaqësimin binar të një numri të plotë jo-negativ.\n    Parametra:\n- n (unsigned long long): Një numër i plotë jo-negativ (0 ≤ n ≤ 2^64 - 1).\n    Kthen:\n    int: Gjatësia e sekuencës më të gjatë të njëshave radhazi në përfaqësimin binar të numrit të dhënë.\n    \n    Shembuj:\n    >>> f_17(7)\n    3", "hy": "Գտնել ամենաերկար հաջորդական 1-երի երկարությունը ոչ բացասական ամբողջ թվի երկբայական ներկայացման մեջ։\n    Պարամետրեր:\n- n (unsigned long long): Ոչ բացասական ամբողջ թիվ (0 ≤ n ≤ 2^64 - 1)։\n    Վերադարձնում է:\n    int: Տրված ամբողջ թվի երկբայական ներկայացման մեջ ամենաերկար հաջորդական 1-երի երկարությունը։\n    \n    Օրինակներ:\n    >>> f_17(7)\n    3", "bn": "একটি অ-ঋণাত্মক পূর্ণসংখ্যার বাইনারি উপস্থাপনার মধ্যে 1 এর দীর্ঘতম ধারাবাহিক ক্রমের দৈর্ঘ্য খুঁজে বের করুন।\n    প্যারামিটার:\n- n (unsigned long long): একটি অ-ঋণাত্মক পূর্ণসংখ্যা (0 ≤ n ≤ 2^64 - 1)।\n    রিটার্নস:\n    int: প্রদত্ত পূর্ণসংখ্যার বাইনারি উপস্থাপনায় 1s এর দীর্ঘতম ক্রমাগত ক্রমের দৈর্ঘ্য।\n\n    উদাহরণ:\n    >>> f_17(7)\n    3", "bg": "Намерете дължината на най-дългата последователна поредица от 1 в двоичното представяне на неотрицателно цяло число.\n    Параметри:\n- n (unsigned long long): Неотрицателно цяло число (0 ≤ n ≤ 2^64 - 1).\n    Връща:\n    int: Дължината на най-дългата последователна поредица от 1 в двоичното представяне на даденото число.\n    \n    Примери:\n    >>> f_17(7)\n    3", "zh": "找出非负整数的二进制表示中最长连续1的序列长度。\n    参数：\n- n (unsigned long long): 一个非负整数 (0 ≤ n ≤ 2^64 - 1)。\n    返回：\n    int: 给定整数的二进制表示中最长连续1的序列长度。\n    \n    示例：\n    >>> f_17(7)\n    3", "fr": "Trouver la longueur de la plus longue séquence consécutive de 1 dans la représentation binaire d'un entier non négatif.\n    Paramètres:\n- n (unsigned long long): Un entier non négatif (0 ≤ n ≤ 2^64 - 1).\n    Renvoie:\n    int: La longueur de la plus longue séquence consécutive de 1 dans la représentation binaire de l'entier donné.\n    \n    Exemples:\n    >>> f_17(7)\n    3", "de": "Finde die Länge der längsten aufeinanderfolgenden Sequenz von 1en in der Binärdarstellung einer nicht-negativen ganzen Zahl.\n    Parameter:\n- n (unsigned long long): Eine nicht-negative ganze Zahl (0 ≤ n ≤ 2^64 - 1).\n    Rückgabewert:\n    int: Die Länge der längsten aufeinanderfolgenden Sequenz von 1en in der Binärdarstellung der gegebenen ganzen Zahl.\n    \n    Beispiele:\n    >>> f_17(7)\n    3\n", "ha": "Nemo tsawon jere mafi tsawo na 1s a cikin wakilcin binary na lamba mara kyau.\n    Sigogi:\n- n (unsigned long long): Lamba mara kyau (0 ≤ n ≤ 2^64 - 1).\n    Dawowa:\n    int: Tsawon mafi tsawo jere na 1s a cikin wakilcin binary na lambar da aka bayar.\n    \n    Misalai:\n    >>> f_17(7)\n    3", "hi": "एक गैर-ऋणात्मक पूर्णांक के बाइनरी प्रतिनिधित्व में 1s के सबसे लंबे अनुक्रम की लंबाई खोजें।\n    पैरामीटर्स:\n- n (unsigned long long): एक गैर-ऋणात्मक पूर्णांक (0 ≤ n ≤ 2^64 - 1)।\n    रिटर्न्स:\n    int: दिए गए पूर्णांक के बाइनरी प्रतिनिधित्व में सबसे लंबे लगातार 1s के अनुक्रम की लंबाई।\n    \n    उदाहरण:\n    >>> f_17(7)\n    3", "hu": "Találja meg a leghosszabb egymást követő 1-es sorozat hosszát egy nem negatív egész szám bináris ábrázolásában.\n    Paraméterek:\n- n (unsigned long long): Egy nemnegatív egész szám (0 ≤ n ≤ 2^64 - 1).\n    Visszatérési érték:\n    int: A leghosszabb egymást követő 1-es sorozat hossza a megadott egész szám bináris ábrázolásában.\n    \n    Példák:\n    >>> f_17(7)\n    3", "es": "Encontrar la longitud de la secuencia consecutiva más larga de 1s en la representación binaria de un número entero no negativo.\n    Parámetros:\n- n (unsigned long long): Un número entero no negativo (0 ≤ n ≤ 2^64 - 1).\n    Devuelve:\n    int: La longitud de la secuencia consecutiva más larga de 1s en la representación binaria del número entero dado.\n    \n    Ejemplos:\n    >>> f_17(7)\n    3", "arb": "ابحث عن طول أطول تسلسل متتابع من 1s في التمثيل الثنائي لعدد صحيح غير سالب.\n    المعلمات:\n- n (unsigned long long): عدد صحيح غير سالب (0 ≤ n ≤ 2^64 - 1).\n    يعيد:\n    int: طول أطول تسلسل متتابع من 1s في التمثيل الثنائي للعدد الصحيح المعطى.\n    \n    أمثلة:\n    >>> f_17(7)\n    3", "sw": "Pata urefu wa mlolongo mrefu zaidi wa 1 mfululizo katika uwakilishi wa nambari ya binary ya nambari isiyo hasi.\n    Vigezo:\n- n (unsigned long long): Nambari isiyo hasi (0 ≤ n ≤ 2^64 - 1).\n    Inarejesha:\n    int: Urefu wa mlolongo mrefu zaidi wa 1 mfululizo katika uwakilishi wa binary wa nambari iliyotolewa.\n    \n    Mifano:\n    >>> f_17(7)\n    3", "tr": "Bir pozitif olmayan tam sayının ikili gösteriminde en uzun ardışık 1'ler dizisinin uzunluğunu bulun.\n    Parametreler:\n- n (unsigned long long): Negatif olmayan bir tam sayı (0 ≤ n ≤ 2^64 - 1).\n    Döndürür:\n    int: Verilen tam sayının ikili gösterimindeki en uzun ardışık 1 dizisinin uzunluğu.\n    \n    Örnekler:\n    >>> f_17(7)\n    3", "vi": "Tìm độ dài của dãy liên tiếp dài nhất của các số 1 trong biểu diễn nhị phân của một số nguyên không âm.\n    Tham số:\n- n (unsigned long long): Một số nguyên không âm (0 ≤ n ≤ 2^64 - 1).\n    Trả về:\n    int: Độ dài của dãy liên tiếp dài nhất của các số 1 trong biểu diễn nhị phân của số nguyên đã cho.\n    \n    Ví dụ:\n    >>> f_17(7)\n    3", "id": "Temukan panjang dari urutan 1s berturut-turut terpanjang dalam representasi biner dari bilangan bulat non-negatif.\n    Parameter:\n- n (unsigned long long): Sebuah bilangan bulat non-negatif (0 ≤ n ≤ 2^64 - 1).\n    Mengembalikan:\n    int: Panjang dari urutan 1s berturut-turut terpanjang dalam representasi biner dari bilangan bulat yang diberikan.\n    \n    Contoh:\n    >>> f_17(7)\n    3", "ja": "非負整数の2進数表現における1の最長連続シーケンスの長さを見つけます。\n    パラメータ:\n- n (unsigned long long): 非負の整数 (0 ≤ n ≤ 2^64 - 1)。\n    戻り値:\n    int: 与えられた整数の2進数表現における1の最長連続シーケンスの長さ。\n    \n    例:\n    >>> f_17(7)\n    3", "ko": "비음수가 아닌 정수의 이진 표현에서 1이 연속으로 나타나는 가장 긴 시퀀스의 길이를 찾습니다.\n    매개변수:\n- n (unsigned long long): 음이 아닌 정수 (0 ≤ n ≤ 2^64 - 1).\n    반환값:\n    int: 주어진 정수의 이진 표현에서 가장 긴 연속된 1의 시퀀스의 길이.\n    \n    예시:\n    >>> f_17(7)\n    3", "ml": "ഒരു അനോന്യമായ പൂർണ്ണസംഖ്യയുടെ ബൈനറി പ്രതിനിധാനത്തിൽ 1 കളുടെ ഏറ്റവും നീണ്ട അനന്തര ശ്രേണിയുടെ നീളം കണ്ടെത്തുക.\n    പാരാമീറ്ററുകൾ:\n- n (unsigned long long): ഒരു നെഗറ്റീവ് അല്ലാത്ത പൂർണ്ണസംഖ്യ (0 ≤ n ≤ 2^64 - 1).\n    മടക്കുന്നു:\n    int: നൽകിയ പൂർണ്ണസംഖ്യയുടെ ബൈനറി പ്രതിനിധാനത്തിലെ ഏറ്റവും നീളമുള്ള തുടർച്ചയായ 1കളുടെ ശ്രേണിയുടെ നീളം.\n    \n    ഉദാഹരണങ്ങൾ:\n    >>> f_17(7)\n    3", "fa": "طول بلندترین دنباله متوالی از 1ها در نمایش باینری یک عدد صحیح غیرمنفی را پیدا کنید.\n    پارامترها:\n- n (unsigned long long): یک عدد صحیح غیرمنفی (0 ≤ n ≤ 2^64 - 1).\n    بازمی‌گرداند:\n    int: طول بلندترین دنباله متوالی از 1ها در نمایش باینری عدد داده شده.\n\n    مثال‌ها:\n    >>> f_17(7)\n    3"}}
{"task_id": "C/18", "prompt": {"en": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n/*\nCreates an ID by combining two words in a specific manner.\n​Parameters:\n- word1 (char*): The first word to be used in the ID.\n- word2 (char*): The second word to be used in the ID.\n​Returns:\n​char*: A divine ID formed by reversing every other character of the second \n        word and combining it with the first word.\ne.g.:\n    >>> f_18(fish,cat)\n\tftiasch\n*/\nchar* f_18(const char* word1, const char* word2)", "sq": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n/*\nKrijon një ID duke kombinuar dy fjalë në një mënyrë specifike.\n​Parametrat:\n- word1 (char*): Fjala e parë që do të përdoret në ID.\n- word2 (char*): Fjala e dytë që do të përdoret në ID.\n​Kthen:\n​char*: Një ID hyjnore e formuar duke përmbysur çdo karakter tjetër të fjalës së dytë \n        dhe duke e kombinuar atë me fjalën e parë.\np.sh.:\n    >>> f_18(fish,cat)\n\tftiasch\n*/\nchar* f_18(const char* word1, const char* word2)", "hy": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n/*\nՍտեղծում է ID՝ երկու բառերը հատուկ ձևով համադրելով:\n​Պարամետրեր:\n- word1 (char*): Առաջին բառը, որը կօգտագործվի ID-ի մեջ:\n- word2 (char*): Երկրորդ բառը, որը կօգտագործվի ID-ի մեջ:\n​Վերադարձնում է:\n​char*: Աստվածային ID, որը ձևավորվում է երկրորդ բառի ամեն երկրորդ \n        նիշը շրջելով և այն առաջին բառի հետ համադրելով:\nօր.:\n    >>> f_18(fish,cat)\n\tftiasch\n*/\nchar* f_18(const char* word1, const char* word2)", "bn": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n/*\nদুটি শব্দকে একটি নির্দিষ্ট পদ্ধতিতে একত্রিত করে একটি আইডি তৈরি করে।\n​প্যারামিটারসমূহ:\n- word1 (char*): আইডিতে ব্যবহৃত প্রথম শব্দ।\n- word2 (char*): আইডিতে ব্যবহৃত দ্বিতীয় শব্দ।\n​ফেরত দেয়:\n​char*: দ্বিতীয় শব্দের প্রতিটি বিকল্প অক্ষর উল্টিয়ে এবং প্রথম শব্দের সাথে \n        একত্রিত করে গঠিত একটি অনন্য আইডি।\nউদাহরণ:\n    >>> f_18(fish,cat)\n\tftiasch\n*/\nchar* f_18(const char* word1, const char* word2)", "bg": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n/*\nСъздава ID, като комбинира две думи по специфичен начин.\nПараметри:\n- word1 (char*): Първата дума, която ще се използва в ID.\n- word2 (char*): Втората дума, която ще се използва в ID.\nВръща:\nchar*: Божествено ID, образувано чрез обръщане на всеки втори символ на втората \n        дума и комбинирането му с първата дума.\nнапр.:\n    >>> f_18(fish,cat)\n\tftiasch\n*/\nchar* f_18(const char* word1, const char* word2)", "zh": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n/*\n通过以特定方式组合两个单词来创建ID。\n参数:\n- word1 (char*): 用于ID的第一个单词。\n- word2 (char*): 用于ID的第二个单词。\n返回:\nchar*: 一个神圣的ID，通过反转第二个单词的每隔一个字符并将其与第一个单词组合而成。\n例如:\n    >>> f_18(fish,cat)\n\tftiasch\n*/\nchar* f_18(const char* word1, const char* word2)", "fr": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n/*\nCrée un ID en combinant deux mots d'une manière spécifique.\nParamètres :\n- word1 (char*): Le premier mot à utiliser dans l'ID.\n- word2 (char*): Le deuxième mot à utiliser dans l'ID.\nRenvoie :\nchar*: Un ID divin formé en inversant chaque autre caractère du deuxième \n        mot et en le combinant avec le premier mot.\nex. :\n    >>> f_18(fish,cat)\n\tftiasch\n*/\nchar* f_18(const char* word1, const char* word2)", "de": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n/*\nErstellt eine ID, indem zwei Wörter auf eine bestimmte Weise kombiniert werden.\nParameter:\n- word1 (char*): Das erste Wort, das in der ID verwendet werden soll.\n- word2 (char*): Das zweite Wort, das in der ID verwendet werden soll.\nRückgabewert:\nchar*: Eine göttliche ID, die gebildet wird, indem jeder zweite Buchstabe des \n        zweiten Wortes umgekehrt und mit dem ersten Wort kombiniert wird.\nz.B.:\n    >>> f_18(fish,cat)\n\tftiasch\n*/\nchar* f_18(const char* word1, const char* word2)", "ha": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n/*\nYana ƙirƙirar ID ta hanyar haɗa kalmomi biyu a cikin wata hanya ta musamman.\n​Sigogi:\n- word1 (char*): Kalma ta farko da za a yi amfani da ita a cikin ID.\n- word2 (char*): Kalma ta biyu da za a yi amfani da ita a cikin ID.\n​Yana dawowa:\n​char*: Wani ID mai ban mamaki da aka kafa ta hanyar juyar da kowace harafi ta biyu na kalma ta biyu \n        da haɗa shi da kalma ta farko.\ne.g.:\n    >>> f_18(fish,cat)\n\tftiasch\n*/\nchar* f_18(const char* word1, const char* word2)", "hi": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n/*\nदो शब्दों को एक विशिष्ट तरीके से मिलाकर एक आईडी बनाता है।\nपैरामीटर्स:\n- word1 (char*): आईडी में उपयोग के लिए पहला शब्द।\n- word2 (char*): आईडी में उपयोग के लिए दूसरा शब्द।\nवापसी:\nchar*: एक दिव्य आईडी जो दूसरे शब्द के हर दूसरे अक्षर को उलटकर और पहले शब्द के \n        साथ मिलाकर बनाई जाती है।\nउदाहरण:\n    >>> f_18(fish,cat)\n\tftiasch\n*/\nchar* f_18(const char* word1, const char* word2)", "hu": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n/*\nLétrehoz egy azonosítót két szó egyedi módon történő kombinálásával.\nParaméterek:\n- word1 (char*): Az első szó, amelyet az azonosítóban használunk.\n- word2 (char*): A második szó, amelyet az azonosítóban használunk.\nVisszatérési érték:\nchar*: Egy isteni azonosító, amely a második szó minden második karakterének \n       megfordításával és az első szóval való kombinálásával jön létre.\npl.:\n    >>> f_18(fish,cat)\n\tftiasch\n*/\nchar* f_18(const char* word1, const char* word2)", "es": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n/*\nCrea un ID combinando dos palabras de una manera específica.\nParámetros:\n- word1 (char*): La primera palabra que se usará en el ID.\n- word2 (char*): La segunda palabra que se usará en el ID.\nDevuelve:\nchar*: Un ID divino formado invirtiendo cada otro carácter de la segunda \n       palabra y combinándolo con la primera palabra.\ne.g.:\n    >>> f_18(fish,cat)\n\tftiasch\n*/\nchar* f_18(const char* word1, const char* word2)", "arb": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n/*\nينشئ معرفًا عن طريق دمج كلمتين بطريقة معينة.\nالمعلمات:\n- word1 (char*): الكلمة الأولى التي سيتم استخدامها في المعرف.\n- word2 (char*): الكلمة الثانية التي سيتم استخدامها في المعرف.\nيعيد:\nchar*: معرف إلهي يتكون من عكس كل حرف آخر من الكلمة الثانية ودمجه مع الكلمة الأولى.\nمثال:\n    >>> f_18(fish,cat)\n\tftiasch\n*/\nchar* f_18(const char* word1, const char* word2)", "sw": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n/*\nInaunda kitambulisho kwa kuchanganya maneno mawili kwa njia maalum.\n​Vigezo:\n- word1 (char*): Neno la kwanza litakalotumika kwenye kitambulisho.\n- word2 (char*): Neno la pili litakalotumika kwenye kitambulisho.\n​Inarejesha:\n​char*: Kitambulisho cha kipekee kinachoundwa kwa kubadilisha kila herufi nyingine ya neno la pili \n        na kuichanganya na neno la kwanza.\nmfano:\n    >>> f_18(fish,cat)\n\tftiasch\n*/\nchar* f_18(const char* word1, const char* word2)", "tr": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n/*\nBelirli bir şekilde iki kelimeyi birleştirerek bir kimlik oluşturur.\n​Parametreler:\n- word1 (char*): Kimlikte kullanılacak ilk kelime.\n- word2 (char*): Kimlikte kullanılacak ikinci kelime.\n​Döndürülen:\n​char*: İkinci kelimenin her iki karakterinden birini ters çevirerek ve \n        birinci kelimeyle birleştirerek oluşturulan ilahi bir kimlik.\nÖrnek:\n    >>> f_18(fish,cat)\n\tftiasch\n*/\nchar* f_18(const char* word1, const char* word2)", "vi": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n/*\nTạo một ID bằng cách kết hợp hai từ theo một cách cụ thể.\nTham số:\n- word1 (char*): Từ đầu tiên được sử dụng trong ID.\n- word2 (char*): Từ thứ hai được sử dụng trong ID.\nTrả về:\nchar*: Một ID thần thánh được tạo bằng cách đảo ngược mỗi ký tự khác của từ thứ hai \n        và kết hợp với từ đầu tiên.\nví dụ:\n    >>> f_18(fish,cat)\n\tftiasch\n*/\nchar* f_18(const char* word1, const char* word2)", "id": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n/*\nMembuat ID dengan menggabungkan dua kata dengan cara tertentu.\nParameter:\n- word1 (char*): Kata pertama yang digunakan dalam ID.\n- word2 (char*): Kata kedua yang digunakan dalam ID.\nMengembalikan:\nchar*: ID yang dibentuk dengan membalik setiap karakter kedua dari kata kedua \n       dan menggabungkannya dengan kata pertama.\ncontoh:\n    >>> f_18(fish,cat)\n\tftiasch\n*/\nchar* f_18(const char* word1, const char* word2)", "ja": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n/*\n特定の方法で2つの単語を組み合わせてIDを作成します。\n​パラメータ:\n- word1 (char*): IDに使用する最初の単語。\n- word2 (char*): IDに使用する2番目の単語。\n​戻り値:\n​char*: 2番目の単語の1文字おきに反転させた文字を最初の単語と組み合わせて形成された神聖なID。\n例:\n    >>> f_18(fish,cat)\n\tftiasch\n*/\nchar* f_18(const char* word1, const char* word2)", "ko": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n/*\n특정 방식으로 두 단어를 결합하여 ID를 생성합니다.\n매개변수:\n- word1 (char*): ID에 사용될 첫 번째 단어.\n- word2 (char*): ID에 사용될 두 번째 단어.\n반환:\nchar*: 두 번째 단어의 모든 다른 문자를 뒤집고 첫 번째 단어와 결합하여 형성된 신성한 ID.\n예시:\n    >>> f_18(fish,cat)\n\tftiasch\n*/\nchar* f_18(const char* word1, const char* word2)\n", "ml": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n/*\nഒരു ഐഡി സൃഷ്ടിക്കുന്നു രണ്ട് വാക്കുകൾ പ്രത്യേക രീതിയിൽ സംയോജിപ്പിച്ച്.\nപാരാമീറ്ററുകൾ:\n- word1 (char*): ഐഡിയിൽ ഉപയോഗിക്കേണ്ട ആദ്യ വാക്ക്.\n- word2 (char*): ഐഡിയിൽ ഉപയോഗിക്കേണ്ട രണ്ടാം വാക്ക്.\nമടക്കം:\nchar*: രണ്ടാം വാക്കിന്റെ ഓരോ മറ്റൊരു അക്ഷരവും മറിച്ച് ആദ്യ വാക്കുമായി \n        സംയോജിപ്പിച്ച് രൂപപ്പെടുത്തിയ ഒരു ദിവ്യമായ ഐഡി.\nഉദാ.:\n    >>> f_18(fish,cat)\n\tftiasch\n*/\nchar* f_18(const char* word1, const char* word2)\n", "fa": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n/*\nیک شناسه با ترکیب دو کلمه به روش خاصی ایجاد می‌کند.\nپارامترها:\n- word1 (char*): اولین کلمه‌ای که در شناسه استفاده می‌شود.\n- word2 (char*): دومین کلمه‌ای که در شناسه استفاده می‌شود.\nبرمی‌گرداند:\nchar*: یک شناسه خاص که با معکوس کردن هر کاراکتر دوم از کلمه دوم و ترکیب آن با کلمه اول تشکیل شده است.\nمثال:\n    >>> f_18(fish,cat)\n\tftiasch\n*/\nchar* f_18(const char* word1, const char* word2)"}, "canonical_solution": "{\n    int length1 = strlen(word1);\n    int length2 = strlen(word2);\n    int total_length = length1 + length2;\n    char* id = malloc(sizeof(char) * (total_length + 1)); // +1 for the null-terminator\n\n    for (int i = 0, j = 0, k = length2 - 1; i < total_length; ++i) {\n        if (i & 1) {\n            id[i] = word2[k--]; // Take character from word2 in reverse\n        } else {\n            id[i] = word1[j++]; // Take character from word1\n        }\n    }\n    \n    id[total_length] = '\\0'; // Null-terminate the string\n    return id;\n}", "instruction": {"en": "Write a C function `char* f_18(const char* word1, const char* word2)` to solve the following problem:\nCreates an ID by combining two words in a specific manner.\nParameters:\n- word1 (char*): The first word to be used in the ID.\n- word2 (char*): The second word to be used in the ID.\nReturns:\nchar*: A divine ID formed by reversing every other character of the second word and combining it with the first word.\ne.g.:\n    >>> f_18(fish,cat)\n    ftiasch\n", "sq": "Shkruani një funksion në C `char* f_18(const char* word1, const char* word2)` për të zgjidhur problemin e mëposhtëm:\nKrijon një ID duke kombinuar dy fjalë në një mënyrë specifike.\nParametrat:\n- word1 (char*): Fjala e parë që do të përdoret në ID.\n- word2 (char*): Fjala e dytë që do të përdoret në ID.\nKthen:\nchar*: Një ID hyjnore e formuar duke përmbysur çdo karakter tjetër të fjalës së dytë dhe duke e kombinuar me fjalën e parë.\np.sh.:\n    >>> f_18(fish,cat)\n    ftiasch", "hy": "Գրեք C ֆունկցիա `char* f_18(const char* word1, const char* word2)` հետևյալ խնդիրը լուծելու համար:\nՍտեղծում է ID՝ երկու բառերը հատուկ ձևով համադրելով:\nՊարամետրեր:\n- word1 (char*): Առաջին բառը, որը կօգտագործվի ID-ում:\n- word2 (char*): Երկրորդ բառը, որը կօգտագործվի ID-ում:\nՎերադարձնում է:\nchar*: Աստվածային ID, որը ձևավորվում է երկրորդ բառի ամեն երկրորդ նիշը շրջելով և այն առաջին բառի հետ համադրելով:\nօր.:\n    >>> f_18(fish,cat)\n    ftiasch", "bn": "একটি C ফাংশন `char* f_18(const char* word1, const char* word2)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি নির্দিষ্ট পদ্ধতিতে দুটি শব্দ একত্রিত করে একটি আইডি তৈরি করে।\nপ্যারামিটারসমূহ:\n- word1 (char*): আইডিতে ব্যবহৃত প্রথম শব্দ।\n- word2 (char*): আইডিতে ব্যবহৃত দ্বিতীয় শব্দ।\nরিটার্ন করে:\nchar*: একটি অনন্য আইডি যা দ্বিতীয় শব্দের প্রতিটি বিকল্প অক্ষর উল্টিয়ে এবং প্রথম শব্দের সাথে একত্রিত করে গঠিত হয়।\nযেমন:\n    >>> f_18(fish,cat)\n    ftiasch", "bg": "Напишете C функция `char* f_18(const char* word1, const char* word2)` за решаване на следния проблем:\nСъздава ID, като комбинира две думи по специфичен начин.\nПараметри:\n- word1 (char*): Първата дума, която ще бъде използвана в ID.\n- word2 (char*): Втората дума, която ще бъде използвана в ID.\nВръща:\nchar*: Божествено ID, образувано чрез обръщане на всеки втори символ на втората дума и комбинирането му с първата дума.\nнапр.:\n    >>> f_18(fish,cat)\n    ftiasch", "zh": "编写一个 C 函数 `char* f_18(const char* word1, const char* word2)` 来解决以下问题：\n通过以特定方式组合两个单词来创建一个 ID。\n参数：\n- word1 (char*): 用于 ID 的第一个单词。\n- word2 (char*): 用于 ID 的第二个单词。\n返回：\nchar*: 一个神奇的 ID，通过反转第二个单词的每隔一个字符并将其与第一个单词组合而成。\n例如：\n    >>> f_18(fish,cat)\n    ftiasch", "fr": "Écrire une fonction C `char* f_18(const char* word1, const char* word2)` pour résoudre le problème suivant :\nCrée un identifiant en combinant deux mots d'une manière spécifique.\nParamètres :\n- word1 (char*): Le premier mot à utiliser dans l'identifiant.\n- word2 (char*): Le deuxième mot à utiliser dans l'identifiant.\nRenvoie :\nchar*: Un identifiant divin formé en inversant chaque autre caractère du deuxième mot et en le combinant avec le premier mot.\ne.g.:\n    >>> f_18(fish,cat)\n    ftiasch", "de": "Schreiben Sie eine C-Funktion `char* f_18(const char* word1, const char* word2)`, um das folgende Problem zu lösen:\nErstellt eine ID, indem zwei Wörter auf eine bestimmte Weise kombiniert werden.\nParameter:\n- word1 (char*): Das erste Wort, das in der ID verwendet werden soll.\n- word2 (char*): Das zweite Wort, das in der ID verwendet werden soll.\nRückgabewert:\nchar*: Eine göttliche ID, die gebildet wird, indem jeder zweite Buchstabe des zweiten Wortes umgekehrt und mit dem ersten Wort kombiniert wird.\nz.B.:\n    >>> f_18(fish,cat)\n    ftiasch", "ha": "Rubuta aikin C `char* f_18(const char* word1, const char* word2)` don warware matsalar mai zuwa:\nƘirƙiri ID ta hanyar haɗa kalmomi biyu a cikin wata hanya ta musamman.\nSigogi:\n- word1 (char*): Kalma ta farko da za a yi amfani da ita a cikin ID.\n- word2 (char*): Kalma ta biyu da za a yi amfani da ita a cikin ID.\nDawowa:\nchar*: Wani ID mai ban mamaki da aka ƙirƙira ta hanyar juyar da kowace harafi ta biyu na kalma ta biyu da haɗa shi da kalma ta farko.\nmisali:\n    >>> f_18(fish,cat)\n    ftiasch", "hi": "C में एक फ़ंक्शन `char* f_18(const char* word1, const char* word2)` लिखें ताकि निम्नलिखित समस्या का समाधान हो सके:\nविशिष्ट तरीके से दो शब्दों को मिलाकर एक आईडी बनाता है।\nपैरामीटर्स:\n- word1 (char*): आईडी में उपयोग के लिए पहला शब्द।\n- word2 (char*): आईडी में उपयोग के लिए दूसरा शब्द।\nरिटर्न करता है:\nchar*: एक दिव्य आईडी जो दूसरे शब्द के हर दूसरे अक्षर को उलट कर और पहले शब्द के साथ मिलाकर बनाई जाती है।\nउदाहरण:\n    >>> f_18(fish,cat)\n    ftiasch", "hu": "Írj egy C függvényt `char* f_18(const char* word1, const char* word2)` a következő probléma megoldására:\nLétrehoz egy azonosítót két szó egyedi módon történő kombinálásával.\nParaméterek:\n- word1 (char*): Az első szó, amelyet az azonosítóban használnak.\n- word2 (char*): A második szó, amelyet az azonosítóban használnak.\nVisszatérési érték:\nchar*: Egy isteni azonosító, amelyet a második szó minden második karakterének megfordításával és az első szóval való kombinálásával hoz létre.\npélda:\n    >>> f_18(fish,cat)\n    ftiasch", "es": "Escribe una función en C `char* f_18(const char* word1, const char* word2)` para resolver el siguiente problema:\nCrea un ID combinando dos palabras de una manera específica.\nParámetros:\n- word1 (char*): La primera palabra que se usará en el ID.\n- word2 (char*): La segunda palabra que se usará en el ID.\nDevuelve:\nchar*: Un ID divino formado al invertir cada otro carácter de la segunda palabra y combinándolo con la primera palabra.\ne.g.:\n    >>> f_18(fish,cat)\n    ftiasch", "arb": "اكتب دالة C `char* f_18(const char* word1, const char* word2)` لحل المشكلة التالية:\nينشئ معرفًا عن طريق دمج كلمتين بطريقة محددة.\nالمعلمات:\n- word1 (char*): الكلمة الأولى التي سيتم استخدامها في المعرف.\n- word2 (char*): الكلمة الثانية التي سيتم استخدامها في المعرف.\nالإرجاع:\nchar*: معرف إلهي يتكون من عكس كل حرف آخر من الكلمة الثانية ودمجه مع الكلمة الأولى.\nمثال:\n    >>> f_18(fish,cat)\n    ftiasch", "sw": "Andika kazi ya C `char* f_18(const char* word1, const char* word2)` kutatua tatizo lifuatalo:\nInaunda kitambulisho kwa kuchanganya maneno mawili kwa namna maalum.\nVigezo:\n- word1 (char*): Neno la kwanza litakalotumika katika kitambulisho.\n- word2 (char*): Neno la pili litakalotumika katika kitambulisho.\nInarudisha:\nchar*: Kitambulisho cha kipekee kinachoundwa kwa kurudisha kila herufi nyingine ya neno la pili na kuichanganya na neno la kwanza.\nmfano:\n    >>> f_18(fish,cat)\n    ftiasch", "tr": "Bir C fonksiyonu `char* f_18(const char* word1, const char* word2)` yazın ve aşağıdaki problemi çözün:\nBelirli bir şekilde iki kelimeyi birleştirerek bir ID oluşturur.\nParametreler:\n- word1 (char*): ID'de kullanılacak ilk kelime.\n- word2 (char*): ID'de kullanılacak ikinci kelime.\nDöndürür:\nchar*: İkinci kelimenin her iki karakterini ters çevirerek ve birinci kelimeyle birleştirerek oluşturulan ilahi bir ID.\nörneğin:\n    >>> f_18(fish,cat)\n    ftiasch", "vi": "Viết một hàm C `char* f_18(const char* word1, const char* word2)` để giải quyết vấn đề sau:\nTạo một ID bằng cách kết hợp hai từ theo một cách cụ thể.\nTham số:\n- word1 (char*): Từ đầu tiên được sử dụng trong ID.\n- word2 (char*): Từ thứ hai được sử dụng trong ID.\nTrả về:\nchar*: Một ID thần thánh được tạo ra bằng cách đảo ngược mỗi ký tự khác của từ thứ hai và kết hợp với từ đầu tiên.\nví dụ:\n    >>> f_18(fish,cat)\n    ftiasch", "id": "Tulis fungsi C `char* f_18(const char* word1, const char* word2)` untuk menyelesaikan masalah berikut:\nMembuat ID dengan menggabungkan dua kata dengan cara tertentu.\nParameter:\n- word1 (char*): Kata pertama yang akan digunakan dalam ID.\n- word2 (char*): Kata kedua yang akan digunakan dalam ID.\nMengembalikan:\nchar*: ID yang dibentuk dengan membalik setiap karakter kedua dari kata kedua dan menggabungkannya dengan kata pertama.\ncontoh:\n    >>> f_18(fish,cat)\n    ftiasch", "ja": "Cの関数を書け `char* f_18(const char* word1, const char* word2)` を作成して、次の問題を解決してください:\n特定の方法で2つの単語を組み合わせてIDを作成します。\nパラメータ:\n- word1 (char*): IDで使用する最初の単語。\n- word2 (char*): IDで使用する2番目の単語。\n戻り値:\nchar*: 2番目の単語の1つおきの文字を逆にして最初の単語と組み合わせて形成された神聖なID。\n例:\n    >>> f_18(fish,cat)\n    ftiasch", "ko": "C 함수 `char* f_18(const char* word1, const char* word2)`를 작성하여 다음 문제를 해결하십시오:\n특정 방식으로 두 단어를 결합하여 ID를 생성합니다.\n매개변수:\n- word1 (char*): ID에 사용될 첫 번째 단어입니다.\n- word2 (char*): ID에 사용될 두 번째 단어입니다.\n반환값:\nchar*: 두 번째 단어의 모든 다른 문자를 뒤집고 첫 번째 단어와 결합하여 형성된 신성한 ID입니다.\n예시:\n    >>> f_18(fish,cat)\n    ftiasch", "ml": "C ഫംഗ്ഷൻ `char* f_18(const char* word1, const char* word2)` എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nഒരു ഐഡി സൃഷ്ടിക്കുന്നു പ്രത്യേക രീതിയിൽ രണ്ട് വാക്കുകൾ ചേർത്ത്.\nപാരാമീറ്ററുകൾ:\n- word1 (char*): ഐഡിയിൽ ഉപയോഗിക്കേണ്ട ആദ്യ വാക്ക്.\n- word2 (char*): ഐഡിയിൽ ഉപയോഗിക്കേണ്ട രണ്ടാം വാക്ക്.\nമടക്കം:\nchar*: രണ്ടാം വാക്കിന്റെ ഓരോ മറ്റൊരു അക്ഷരവും മറിച്ച് ആദ്യ വാക്കുമായി ചേർത്ത് രൂപീകരിച്ച ദിവ്യമായ ഐഡി.\nഉദാ.:\n    >>> f_18(fish,cat)\n    ftiasch", "fa": "یک تابع C به نام `char* f_18(const char* word1, const char* word2)` بنویسید تا مسئله زیر را حل کند:\nیک شناسه با ترکیب دو کلمه به روش خاصی ایجاد می‌کند.\nپارامترها:\n- word1 (char*): اولین کلمه‌ای که در شناسه استفاده می‌شود.\n- word2 (char*): دومین کلمه‌ای که در شناسه استفاده می‌شود.\nبازگشت:\nchar*: یک شناسه منحصر به فرد که با برعکس کردن هر کاراکتر دوم از کلمه دوم و ترکیب آن با کلمه اول تشکیل شده است.\nمثال:\n    >>> f_18(fish,cat)\n    ftiasch"}, "level": "hard", "test": "int main() {\n    char* id; // To hold the results from f_18\n\n    id = f_18(\"fish\", \"cat\");\n    assert(strcmp(id, \"ftiasch\") == 0);\n    free(id);\n\n    id = f_18(\"icpc\", \"acm\");\n    assert(strcmp(id, \"imccpac\") == 0);\n    free(id);\n\n    id = f_18(\"oo\", \"w\");\n    assert(strcmp(id, \"owo\") == 0);\n    free(id);\n\n    // Add more test samples\n    id = f_18(\"hello\", \"world\");\n    assert(strcmp(id, \"hdellrloow\") == 0);\n    free(id);\n\n    id = f_18(\"abc\", \"def\");\n    assert(strcmp(id, \"afbecd\") == 0);\n    free(id);\n\n    id = f_18(\"buaanb\", \"nbbuaa\");\n    assert(strcmp(id, \"bauaauabnbbn\") == 0);\n    free(id);\n\n    id = f_18(\"xtuisgood\", \"ilovextu\");\n    assert(strcmp(id, \"xuttuxiesvgooloid\") == 0);\n    free(id);\n\n    return 0;\n}", "entry_point": "f_18", "signature": "char* f_18(const char* word1, const char* word2)", "docstring": {"en": "Creates an ID by combining two words in a specific manner.\nParameters:\n- word1 (char*): The first word to be used in the ID.\n- word2 (char*): The second word to be used in the ID.\nReturns:\nchar*: A divine ID formed by reversing every other character of the second word and combining it with the first word.\ne.g.:\n    >>> f_18(fish,cat)\n    ftiasch\n", "sq": "Krijon një ID duke kombinuar dy fjalë në një mënyrë specifike.  \nParametrat:  \n- word1 (char*): Fjala e parë që do të përdoret në ID.  \n- word2 (char*): Fjala e dytë që do të përdoret në ID.  \nKthen:  \nchar*: Një ID hyjnore e formuar duke përmbysur çdo karakter të dytë të fjalës së dytë dhe duke e kombinuar atë me fjalën e parë.  \np.sh.:  \n    >>> f_18(fish,cat)  \n    ftiasch  ", "hy": "Ստեղծում է ID՝ երկու բառերը հատուկ ձևով համակցելով։  \nՊարամետրեր:  \n- word1 (char*): Առաջին բառը, որը կօգտագործվի ID-ում։  \n- word2 (char*): Երկրորդ բառը, որը կօգտագործվի ID-ում։  \nՎերադարձնում է:  \nchar*: Աստվածային ID, որը ձևավորվում է երկրորդ բառի յուրաքանչյուր երկրորդ նիշը շրջելով և համակցելով այն առաջին բառի հետ։  \nօր.՝  \n    >>> f_18(fish,cat)  \n    ftiasch  ", "bn": "দুটি শব্দকে একটি নির্দিষ্ট পদ্ধতিতে একত্রিত করে একটি আইডি তৈরি করে।\nপ্যারামিটারসমূহ:  \n- word1 (char*): আইডিতে ব্যবহৃত প্রথম শব্দ।  \n- word2 (char*): আইডিতে ব্যবহৃত দ্বিতীয় শব্দ।  \nরিটার্নস:  \nchar*: একটি ঐশ্বরিক আইডি যা দ্বিতীয় শব্দের প্রতিটি বিকল্প অক্ষর উল্টিয়ে প্রথম শব্দের সাথে মিলিয়ে গঠিত হয়।  \nউদাহরণ:  \n    >>> f_18(fish,cat)  \n    ftiasch  ", "bg": "Създава ID, като комбинира две думи по специфичен начин.\nПараметри:\n- word1 (char*): Първата дума, която ще се използва в ID.\n- word2 (char*): Втората дума, която ще се използва в ID.\nВръща:\nchar*: Божествено ID, образувано чрез обръщане на всеки втори символ на втората дума и комбинирането му с първата дума.\nнапр.:\n    >>> f_18(fish,cat)\n    ftiasch", "zh": "通过以特定方式组合两个单词来创建一个ID。\n参数：\n- word1 (char*): 用于ID的第一个单词。\n- word2 (char*): 用于ID的第二个单词。\n返回：\nchar*: 一个神奇的ID，通过反转第二个单词的每隔一个字符并将其与第一个单词组合而成。\n例如：\n    >>> f_18(fish,cat)\n    ftiasch", "fr": "Crée un ID en combinant deux mots d'une manière spécifique.\nParamètres :\n- word1 (char*) : Le premier mot à utiliser dans l'ID.\n- word2 (char*) : Le deuxième mot à utiliser dans l'ID.\nRenvoie :\nchar* : Un ID divin formé en inversant tous les autres caractères du deuxième mot et en le combinant avec le premier mot.\nex. :\n    >>> f_18(fish,cat)\n    ftiasch", "de": "Erstellt eine ID, indem zwei Wörter auf eine bestimmte Weise kombiniert werden.\nParameter:\n- word1 (char*): Das erste Wort, das in der ID verwendet werden soll.\n- word2 (char*): Das zweite Wort, das in der ID verwendet werden soll.\nRückgabewert:\nchar*: Eine göttliche ID, die gebildet wird, indem jeder zweite Buchstabe des zweiten Wortes umgekehrt und mit dem ersten Wort kombiniert wird.\nz.B.:\n    >>> f_18(fish,cat)\n    ftiasch", "ha": "Yana ƙirƙirar ID ta hanyar haɗa kalmomi biyu a cikin wata hanya ta musamman.\n\nSigogi:\n- word1 (char*): Kalma ta farko da za a yi amfani da ita a cikin ID.\n- word2 (char*): Kalma ta biyu da za a yi amfani da ita a cikin ID.\n\nMayar da:\nchar*: Wani ID mai ban mamaki wanda aka ƙirƙira ta hanyar juyar da kowanne na biyu daga cikin haruffan kalma ta biyu sannan a haɗa shi da kalma ta farko.\n\ne.g.:\n    >>> f_18(fish,cat)\n    ftiasch", "hi": "दो शब्दों को एक विशिष्ट तरीके से मिलाकर एक आईडी बनाता है।\nपैरामीटर्स:  \n- word1 (char*): ID में उपयोग के लिए पहला शब्द।  \n- word2 (char*): ID में उपयोग के लिए दूसरा शब्द।  \nरिटर्न्स:  \nchar*: एक दिव्य ID जो दूसरे शब्द के हर दूसरे अक्षर को उलटकर और इसे पहले शब्द के साथ मिलाकर बनाई जाती है।  \nउदाहरण:  \n    >>> f_18(fish,cat)  \n    ftiasch  ", "hu": "Létrehoz egy azonosítót két szó speciális módon történő kombinálásával.\nParaméterek:\n- word1 (char*): Az első szó, amelyet az azonosítóban használunk.\n- word2 (char*): A második szó, amelyet az azonosítóban használunk.\nVisszatér:\nchar*: Egy isteni azonosító, amelyet úgy alakítunk ki, hogy a második szó minden második karakterét megfordítjuk, és kombináljuk az első szóval.\npélda:\n    >>> f_18(fish,cat)\n    ftiasch", "es": "Crea un ID combinando dos palabras de una manera específica.\nParámetros:\n- word1 (char*): La primera palabra que se utilizará en el ID.\n- word2 (char*): La segunda palabra que se utilizará en el ID.\nDevuelve:\nchar*: Un ID divino formado al invertir cada otro carácter de la segunda palabra y combinarlo con la primera palabra.\ne.g.:\n    >>> f_18(fish,cat)\n    ftiasch", "arb": "ينشئ معرفًا عن طريق دمج كلمتين بطريقة معينة.\nالمعلمات:\n- word1 (char*): الكلمة الأولى التي سيتم استخدامها في المعرف.\n- word2 (char*): الكلمة الثانية التي سيتم استخدامها في المعرف.\nالقيم المعادة:\nchar*: معرف إلهي يتكون من عكس كل حرف آخر من الكلمة الثانية ودمجه مع الكلمة الأولى.\nمثال:\n    >>> f_18(fish,cat)\n    ftiasch", "sw": "Inaunda kitambulisho kwa kuchanganya maneno mawili kwa namna maalum. \nVigezo:  \n- word1 (char*): The first word to be used in the ID.  \n  - word1 (char*): Neno la kwanza litakalotumika katika kitambulisho.  \n- word2 (char*): The second word to be used in the ID.  \n  - word2 (char*): Neno la pili litakalotumika katika kitambulisho.  \nReturns:  \nInarejesha:  \nchar*: A divine ID formed by reversing every other character of the second word and combining it with the first word.  \nchar*: Kitambulisho cha kipekee kinachoundwa kwa kubadilisha kila herufi nyingine ya neno la pili na kuichanganya na neno la kwanza.  \ne.g.:  \nmfano:  \n    >>> f_18(fish,cat)  \n    ftiasch  ", "tr": "Belirli bir şekilde iki kelimeyi birleştirerek bir kimlik oluşturur.\nParametreler:\n- word1 (char*): Kimlikte kullanılacak ilk kelime.\n- word2 (char*): Kimlikte kullanılacak ikinci kelime.\nDöndürür:\nchar*: İkinci kelimenin her iki karakterini ters çevirerek ve birinci kelimeyle birleştirerek oluşturulan ilahi bir kimlik.\nörneğin:\n    >>> f_18(fish,cat)\n    ftiasch", "vi": "Tạo một ID bằng cách kết hợp hai từ theo một cách cụ thể.  \nTham số:  \n- word1 (char*): Từ đầu tiên được sử dụng trong ID.  \n- word2 (char*): Từ thứ hai được sử dụng trong ID.  \nTrả về:  \nchar*: Một ID thần thánh được tạo ra bằng cách đảo ngược mỗi ký tự khác của từ thứ hai và kết hợp với từ đầu tiên.  \nví dụ:  \n    >>> f_18(fish,cat)  \n    ftiasch  ", "id": "Membuat ID dengan menggabungkan dua kata dengan cara tertentu.  \nParameter:  \n- word1 (char*): Kata pertama yang akan digunakan dalam ID.  \n- word2 (char*): Kata kedua yang akan digunakan dalam ID.  \nMengembalikan:  \nchar*: ID yang dibentuk dengan membalik setiap karakter kedua dari kata kedua dan menggabungkannya dengan kata pertama.  \ncontoh:  \n    >>> f_18(fish,cat)  \n    ftiasch  ", "ja": "特定の方法で2つの単語を組み合わせてIDを作成します。\n引数:\n- word1 (char*): IDに使用する最初の単語。\n- word2 (char*): IDに使用する2番目の単語。\n戻り値:\nchar*: 2番目の単語の隔文字を逆にして最初の単語と組み合わせた神聖なID。\n例:\n    >>> f_18(fish,cat)\n    ftiasch", "ko": "특정 방식으로 두 단어를 결합하여 ID를 생성합니다.  \n매개변수:  \n- word1 (char*): ID에 사용할 첫 번째 단어입니다.  \n- word2 (char*): ID에 사용할 두 번째 단어입니다.  \n반환값:  \nchar*: 두 번째 단어의 모든 다른 문자를 뒤집고 첫 번째 단어와 결합하여 형성된 신성한 ID입니다.  \n예:  \n    >>> f_18(fish,cat)  \n    ftiasch  ", "ml": "ഒരു ഐഡി സൃഷ്ടിക്കുന്നു രണ്ട് വാക്കുകൾ പ്രത്യേക രീതിയിൽ സംയോജിപ്പിച്ച്.\n- word1 (char*): ID-ൽ ഉപയോഗിക്കുന്ന ആദ്യത്തെ വാക്ക്.\n- word2 (char*): ID-ൽ ഉപയോഗിക്കുന്ന രണ്ടാം വാക്ക്.\nReturns:\nchar*: രണ്ടാം വാക്കിലെ ഓരോ മറ്റൊരു അക്ഷരവും മറിച്ച് ആദ്യത്തെ വാക്കുമായി ചേർത്തുണ്ടാക്കുന്ന ഒരു ദിവ്യമായ ID.\ne.g.:\n    >>> f_18(fish,cat)\n    ftiasch", "fa": "یک شناسه با ترکیب دو کلمه به روش خاصی ایجاد می‌کند.\nپارامترها:  \n- word1 (char*): اولین کلمه‌ای که در شناسه استفاده می‌شود.  \n- word2 (char*): دومین کلمه‌ای که در شناسه استفاده می‌شود.  \nبازگشت:  \nchar*: یک شناسه‌ی خاص که با معکوس کردن هر کاراکتر دوم از کلمه‌ی دوم و ترکیب آن با کلمه‌ی اول تشکیل شده است.  \nمثال:  \n    >>> f_18(fish,cat)  \n    ftiasch  "}}
{"task_id": "C/19", "prompt": {"en": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCount the number of different permutation schemes for a binary string of length n,\nwhere the number of '1's is m and the number of '0's is n - m.\n​    Parameters:\n- n (int): Length of the binary string.\n- m (int): Number of '1's in the binary string.\n​    Returns:\n​    int: The total number of different permutation schemes.\n*/\nint f_19(int n, int m)", "sq": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nNumëroni numrin e skemave të ndryshme të permutimit për një varg binar me gjatësi n,\nku numri i '1'-ve është m dhe numri i '0'-ve është n - m.\n​    Parametrat:\n- n (int): Gjatësia e vargut binar.\n- m (int): Numri i '1'-ve në vargun binar.\n​    Kthen:\n​    int: Numri total i skemave të ndryshme të permutimit.\n*/\nint f_19(int n, int m)", "hy": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nՀաշվել տարբեր տեղափոխման սխեմաների քանակը երկբայական տողի համար, որի երկարությունը n է,\nորտեղ '1'-երի քանակը m է, իսկ '0'-երի քանակը n - m է:\n​    Պարամետրեր:\n- n (int): Երկբայական տողի երկարությունը:\n- m (int): '1'-երի քանակը երկբայական տողի մեջ:\n​    Վերադարձնում է:\n​    int: Տարբեր տեղափոխման սխեմաների ընդհանուր քանակը:\n*/\nint f_19(int n, int m)", "bn": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nএকটি বাইনারি স্ট্রিংয়ের জন্য বিভিন্ন বিন্যাস প্রকল্পের সংখ্যা গণনা করুন যার দৈর্ঘ্য n,\nযেখানে '1' এর সংখ্যা m এবং '0' এর সংখ্যা n - m।\n    প্যারামিটার:\n- n (int): বাইনারি স্ট্রিংয়ের দৈর্ঘ্য।\n- m (int): বাইনারি স্ট্রিংয়ে '1' এর সংখ্যা।\n    রিটার্নস:\n    int: বিভিন্ন বিন্যাস প্রকল্পের মোট সংখ্যা।\n*/\nint f_19(int n, int m)", "bg": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nБрой на различните схеми на пермутация за двоичен низ с дължина n,\nкъдето броят на '1'-ците е m, а броят на '0'-ците е n - m.\n    Параметри:\n- n (int): Дължина на двоичния низ.\n- m (int): Брой на '1'-ците в двоичния низ.\n    Връща:\n    int: Общият брой на различните схеми на пермутация.\n*/\nint f_19(int n, int m)", "zh": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n计算长度为 n 的二进制字符串的不同排列方案数量，\n其中 '1' 的数量为 m，'0' 的数量为 n - m。\n    参数:\n- n (int): 二进制字符串的长度。\n- m (int): 二进制字符串中 '1' 的数量。\n    返回:\n    int: 不同排列方案的总数量。\n*/\nint f_19(int n, int m)", "fr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCompter le nombre de différents schémas de permutation pour une chaîne binaire de longueur n,\noù le nombre de '1' est m et le nombre de '0' est n - m.\n​    Paramètres:\n- n (int): Longueur de la chaîne binaire.\n- m (int): Nombre de '1' dans la chaîne binaire.\n​    Renvoie:\n​    int: Le nombre total de différents schémas de permutation.\n*/\nint f_19(int n, int m)", "de": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nZählt die Anzahl der verschiedenen Permutationsschemata für einen Binärstring der Länge n,\nwobei die Anzahl der '1's m ist und die Anzahl der '0's n - m ist.\n    Parameter:\n- n (int): Länge des Binärstrings.\n- m (int): Anzahl der '1's im Binärstring.\n    Rückgabe:\n    int: Die Gesamtanzahl der verschiedenen Permutationsschemata.\n*/\nint f_19(int n, int m)", "ha": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nƘirga adadin tsarin juyawa daban-daban don igiyar binary mai tsawon n,\ninda adadin '1's shine m kuma adadin '0's shine n - m.\n​    Sigogi:\n- n (int): Tsawon igiyar binary.\n- m (int): Adadin '1's a cikin igiyar binary.\n​    Komawa:\n​    int: Jimlar adadin tsarin juyawa daban-daban.\n*/\nint f_19(int n, int m)", "hi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nएक बाइनरी स्ट्रिंग की विभिन्न क्रमपरिवर्तन योजनाओं की संख्या गिनें जिसकी लंबाई n है,\nजहां '1' की संख्या m है और '0' की संख्या n - m है।\n    पैरामीटर्स:\n- n (int): बाइनरी स्ट्रिंग की लंबाई।\n- m (int): बाइनरी स्ट्रिंग में '1' की संख्या।\n    रिटर्न करता है:\n    int: विभिन्न क्रमपरिवर्तन योजनाओं की कुल संख्या।\n*/\nint f_19(int n, int m)", "hu": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nSzámolja meg a különböző permutációs sémák számát egy n hosszúságú bináris karakterláncra,\nahol az '1'-ek száma m, és a '0'-k száma n - m.\n​    Paraméterek:\n- n (int): A bináris karakterlánc hossza.\n- m (int): Az '1'-ek száma a bináris karakterláncban.\n​    Visszatér:\n​    int: A különböző permutációs sémák teljes száma.\n*/\nint f_19(int n, int m)", "es": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCuenta el número de diferentes esquemas de permutación para una cadena binaria de longitud n,\ndonde el número de '1's es m y el número de '0's es n - m.\n    Parámetros:\n- n (int): Longitud de la cadena binaria.\n- m (int): Número de '1's en la cadena binaria.\n    Devuelve:\n    int: El número total de diferentes esquemas de permutación.\n*/\nint f_19(int n, int m)", "arb": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nاحسب عدد مخططات التبديل المختلفة لسلسلة ثنائية بطول n،\nحيث يكون عدد '1's هو m وعدد '0's هو n - m.\n    المعلمات:\n- n (int): طول السلسلة الثنائية.\n- m (int): عدد '1's في السلسلة الثنائية.\n    يعيد:\n    int: العدد الإجمالي لمخططات التبديل المختلفة.\n*/\nint f_19(int n, int m)", "sw": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nHesabu idadi ya mipango tofauti ya mpangilio kwa kamba ya binary yenye urefu n,\nambapo idadi ya '1's ni m na idadi ya '0's ni n - m.\n​    Vigezo:\n- n (int): Urefu wa kamba ya binary.\n- m (int): Idadi ya '1's katika kamba ya binary.\n​    Inarudisha:\n​    int: Jumla ya idadi ya mipango tofauti ya mpangilio.\n*/\nint f_19(int n, int m)", "tr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nUzunluğu n olan bir ikili dizgi için, '1'lerin sayısının m ve '0'ların sayısının n - m olduğu farklı permütasyon şemalarının sayısını sayın.\n​    Parametreler:\n- n (int): İkili dizginin uzunluğu.\n- m (int): İkili dizgideki '1'lerin sayısı.\n​    Döndürür:\n​    int: Farklı permütasyon şemalarının toplam sayısı.\n*/\nint f_19(int n, int m)", "vi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nĐếm số lượng các sơ đồ hoán vị khác nhau cho một chuỗi nhị phân có độ dài n,\ntrong đó số lượng '1' là m và số lượng '0' là n - m.\n    Tham số:\n- n (int): Độ dài của chuỗi nhị phân.\n- m (int): Số lượng '1' trong chuỗi nhị phân.\n    Trả về:\n    int: Tổng số lượng các sơ đồ hoán vị khác nhau.\n*/\nint f_19(int n, int m)", "id": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nMenghitung jumlah skema permutasi berbeda untuk string biner dengan panjang n,\ndi mana jumlah '1' adalah m dan jumlah '0' adalah n - m.\n    Parameter:\n- n (int): Panjang string biner.\n- m (int): Jumlah '1' dalam string biner.\n    Mengembalikan:\n    int: Jumlah total skema permutasi berbeda.\n*/\nint f_19(int n, int m)", "ja": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n長さnの2進文字列に対する異なる順列スキームの数を数えます。\nここで、'1'の数はmで、'0'の数はn - mです。\n    パラメータ:\n- n (int): 2進文字列の長さ。\n- m (int): 2進文字列内の'1'の数。\n    戻り値:\n    int: 異なる順列スキームの総数。\n*/\nint f_19(int n, int m)", "ko": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n길이가 n인 이진 문자열에 대해 '1'의 개수가 m이고 '0'의 개수가 n - m일 때,\n다양한 순열 방식의 수를 계산합니다.\n​    매개변수:\n- n (int): 이진 문자열의 길이.\n- m (int): 이진 문자열에서 '1'의 개수.\n​    반환값:\n​    int: 다양한 순열 방식의 총 수.\n*/\nint f_19(int n, int m)", "ml": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nഒരു ബൈനറി സ്ട്രിംഗിന്റെ വ്യത്യസ്ത പെർമ്യൂട്ടേഷൻ സ്കീമുകളുടെ എണ്ണം എണ്ണുക, \nഎവിടെ '1' കളുടെ എണ്ണം m ആണ്, '0' കളുടെ എണ്ണം n - m ആണ്.\n    പാരാമീറ്ററുകൾ:\n- n (int): ബൈനറി സ്ട്രിംഗിന്റെ നീളം.\n- m (int): ബൈനറി സ്ട്രിംഗിലെ '1' കളുടെ എണ്ണം.\n    മടക്കുന്നു:\n    int: വ്യത്യസ്ത പെർമ്യൂട്ടേഷൻ സ്കീമുകളുടെ മൊത്തം എണ്ണം.\n*/\nint f_19(int n, int m)", "fa": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nتعداد طرح‌های جایگشت مختلف برای یک رشته باینری با طول n را بشمارید،\nکه تعداد '1'ها برابر m و تعداد '0'ها برابر n - m است.\n    پارامترها:\n- n (int): طول رشته باینری.\n- m (int): تعداد '1'ها در رشته باینری.\n    بازگشت:\n    int: تعداد کل طرح‌های جایگشت مختلف.\n*/\nint f_19(int n, int m)"}, "canonical_solution": "{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    // printf(\"%f %f %f\\n\", numerator, denominator1, denominator2);\n\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // printf(\"%f\\n\", numerator / denominator1 / denominator2);\n        // Calculating the number of permutations using the factorial values\n        return (int)(numerator / denominator1 / denominator2 + 0.5);\n    }\n}", "instruction": {"en": "Write a C function `int f_19(int n, int m)` to solve the following problem:\nCount the number of different permutation schemes for a binary string of length n,\nwhere the number of '1's is m and the number of '0's is n - m.\n​    Parameters:\n- n (int): Length of the binary string.\n- m (int): Number of '1's in the binary string.\n​    Returns:\n​    int: The total number of different permutation schemes.\n", "sq": "Shkruani një funksion në C `int f_19(int n, int m)` për të zgjidhur problemin e mëposhtëm:\nNumëroni numrin e skemave të ndryshme të permutimit për një varg binar me gjatësi n,\nku numri i '1'-ve është m dhe numri i '0'-ve është n - m.\n​    Parametrat:\n- n (int): Gjatësia e vargut binar.\n- m (int): Numri i '1'-ve në vargun binar.\n​    Kthen:\n​    int: Numri total i skemave të ndryshme të permutimit.", "hy": "Գրեք C ֆունկցիա `int f_19(int n, int m)՝ լուծելու համար հետևյալ խնդիրը:\nՀաշվեք տարբեր պերմուտացիոն սխեմաների քանակը երկբանական տողի համար, որի երկարությունը n է,\nորտեղ '1'-երի քանակը m է, իսկ '0'-երի քանակը n - m է։\n​    Պարամետրեր:\n- n (int): Երկբանական տողի երկարությունը։\n- m (int): '1'-երի քանակը երկբանական տողի մեջ։\n​    Վերադարձնում է:\n​    int: Տարբեր պերմուտացիոն սխեմաների ընդհանուր քանակը։", "bn": "একটি C ফাংশন `int f_19(int n, int m)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি বাইনারি স্ট্রিংয়ের জন্য বিভিন্ন বিন্যাস প্রকল্পের সংখ্যা গণনা করুন যার দৈর্ঘ্য n,\nযেখানে '1' এর সংখ্যা m এবং '0' এর সংখ্যা n - m।\n    প্যারামিটারসমূহ:\n- n (int): বাইনারি স্ট্রিংয়ের দৈর্ঘ্য।\n- m (int): বাইনারি স্ট্রিংয়ে '1' এর সংখ্যা।\n    রিটার্নস:\n    int: বিভিন্ন বিন্যাস প্রকল্পের মোট সংখ্যা।", "bg": "Напишете C функция `int f_19(int n, int m)`, за да решите следния проблем:\nПребройте броя на различните схеми на пермутации за двоична низ с дължина n,\nкъдето броят на '1'-ците е m и броят на '0'-ците е n - m.\n​    Параметри:\n- n (int): Дължина на двоичния низ.\n- m (int): Брой на '1'-ците в двоичния низ.\n​    Връща:\n​    int: Общият брой на различните схеми на пермутации.", "zh": "编写一个 C 函数 `int f_19(int n, int m)` 来解决以下问题：\n计算长度为 n 的二进制字符串的不同排列方案的数量，其中 '1' 的数量为 m，'0' 的数量为 n - m。\n​    参数：\n- n (int): 二进制字符串的长度。\n- m (int): 二进制字符串中 '1' 的数量。\n​    返回：\n​    int: 不同排列方案的总数。", "fr": "Écrivez une fonction C `int f_19(int n, int m)` pour résoudre le problème suivant :\nComptez le nombre de différents schémas de permutation pour une chaîne binaire de longueur n,  \noù le nombre de '1' est m et le nombre de '0' est n - m.  \n​    Paramètres :  \n- n (int) : Longueur de la chaîne binaire.  \n- m (int) : Nombre de '1' dans la chaîne binaire.  \n​    Renvoie :  \n​    int : Le nombre total de différents schémas de permutation.  ", "de": "Schreiben Sie eine C-Funktion `int f_19(int n, int m)`, um das folgende Problem zu lösen:\nZählen Sie die Anzahl der verschiedenen Permutationsschemata für einen Binärstring der Länge n,\nwobei die Anzahl der '1's m ist und die Anzahl der '0's n - m.\n​    Parameter:\n- n (int): Länge des Binärstrings.\n- m (int): Anzahl der '1's im Binärstring.\n​    Rückgabewert:\n​    int: Die Gesamtanzahl der verschiedenen Permutationsschemata.", "ha": "Rubuta wani aikin C `int f_19(int n, int m)` don warware matsalar mai zuwa:\nƘididdige yawan tsarin permutation daban-daban na igiyar binary mai tsawon n,\ninda adadin '1's ya zama m kuma adadin '0's ya zama n - m.\n​    Sigogi:\n- n (int): Tsawon igiyar binary.\n- m (int): Adadin '1's a cikin igiyar binary.\n​    Mayar da:\n​    int: Jimillar adadin tsarin permutation daban-daban.", "hi": "C फ़ंक्शन `int f_19(int n, int m)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nएक बाइनरी स्ट्रिंग की विभिन्न क्रमपरिवर्तन योजनाओं की संख्या गिनें जिसकी लंबाई n है,\nजहाँ '1's की संख्या m है और '0's की संख्या n - m है।\n    पैरामीटर्स:\n- n (int): बाइनरी स्ट्रिंग की लंबाई।\n- m (int): बाइनरी स्ट्रिंग में '1's की संख्या।\n    रिटर्न्स:\n    int: विभिन्न क्रमपरिवर्तन योजनाओं की कुल संख्या।", "hu": "Írj egy C függvényt `int f_19(int n, int m)` a következő probléma megoldására:\nSzámold meg a különböző permutációs sémák számát egy n hosszúságú bináris karakterláncra,\nahol az '1'-ek száma m és a '0'-k száma n - m.\n​    Paraméterek:\n- n (int): A bináris karakterlánc hossza.\n- m (int): Az '1'-ek száma a bináris karakterláncban.\n​    Visszatérési érték:\n​    int: A különböző permutációs sémák teljes száma.", "es": "Escribe una función en C `int f_19(int n, int m)` para resolver el siguiente problema:\nCuenta el número de diferentes esquemas de permutación para una cadena binaria de longitud n,\ndonde el número de '1's es m y el número de '0's es n - m.\n​    Parámetros:\n- n (int): Longitud de la cadena binaria.\n- m (int): Número de '1's en la cadena binaria.\n​    Devuelve:\n​    int: El número total de diferentes esquemas de permutación.", "arb": "اكتب دالة بلغة C `int f_19(int n, int m)` لحل المشكلة التالية:\nاحسب عدد مخططات التبديل المختلفة لسلسلة ثنائية بطول n،\nحيث يكون عدد '1's هو m وعدد '0's هو n - m.\n    المعاملات:\n- n (int): طول السلسلة الثنائية.\n- m (int): عدد '1's في السلسلة الثنائية.\n    يعيد:\n    int: العدد الإجمالي لمخططات التبديل المختلفة.", "sw": "Andika kazi ya C `int f_19(int n, int m)` kutatua tatizo lifuatalo:\nHesabu idadi ya mipango tofauti ya mpangilio kwa kamba ya binary yenye urefu n,\nambapo idadi ya '1's ni m na idadi ya '0's ni n - m.\n​    Vigezo:\n- n (int): Urefu wa kamba ya binary.\n- m (int): Idadi ya '1's katika kamba ya binary.\n​    Inarejesha:\n​    int: Jumla ya idadi ya mipango tofauti ya mpangilio.", "tr": "Bir C fonksiyonu `int f_19(int n, int m)` yazın ve aşağıdaki problemi çözün:\nUzunluğu n olan bir ikili dizgi için, '1'lerin sayısının m ve '0'ların sayısının n - m olduğu farklı permütasyon düzenlerinin sayısını sayın.\n​    Parametreler:\n- n (int): İkili dizginin uzunluğu.\n- m (int): İkili dizgideki '1'lerin sayısı.\n​    Döndürür:\n​    int: Farklı permütasyon düzenlerinin toplam sayısı.", "vi": "Viết một hàm C `int f_19(int n, int m)` để giải quyết vấn đề sau:\nĐếm số lượng các sơ đồ hoán vị khác nhau cho một chuỗi nhị phân có độ dài n,\ntrong đó số lượng '1' là m và số lượng '0' là n - m.\n​    Tham số:\n- n (int): Độ dài của chuỗi nhị phân.\n- m (int): Số lượng '1' trong chuỗi nhị phân.\n​    Trả về:\n​    int: Tổng số lượng các sơ đồ hoán vị khác nhau.", "id": "Tulis sebuah fungsi C `int f_19(int n, int m)` untuk menyelesaikan masalah berikut:\nHitung jumlah skema permutasi yang berbeda untuk sebuah string biner dengan panjang n,\ndi mana jumlah '1' adalah m dan jumlah '0' adalah n - m.\n​    Parameter:\n- n (int): Panjang dari string biner.\n- m (int): Jumlah '1' dalam string biner.\n​    Mengembalikan:\n​    int: Jumlah total skema permutasi yang berbeda.", "ja": "Cの関数を書け `int f_19(int n, int m)` を作成して、次の問題を解決してください:\n長さnの2進文字列に対する異なる順列スキームの数を数えます。\nここで、'1'の数はmであり、'0'の数はn - mです。\n​    パラメータ:\n- n (int): 2進文字列の長さ。\n- m (int): 2進文字列内の'1'の数。\n​    戻り値:\n​    int: 異なる順列スキームの総数。", "ko": "C 함수 `int f_19(int n, int m)`을 작성하여 다음 문제를 해결하십시오:\n길이가 n인 이진 문자열에 대해 서로 다른 순열 방식의 수를 계산합니다.\n여기서 '1'의 수는 m이고 '0'의 수는 n - m입니다.\n​    매개변수:\n- n (int): 이진 문자열의 길이.\n- m (int): 이진 문자열에서 '1'의 수.\n​    반환값:\n​    int: 서로 다른 순열 방식의 총 수.", "ml": "ഒരു C ഫംഗ്ഷൻ `int f_19(int n, int m)` എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nനിറം n ആയ ഒരു ബൈനറി സ്ട്രിംഗിന്റെ വ്യത്യസ്തമായ പെർമ്യൂട്ടേഷൻ പദ്ധതികളുടെ എണ്ണം എണ്ണുക, \nഇവിടെ '1'കളുടെ എണ്ണം m ആണ്, '0'കളുടെ എണ്ണം n - m ആണ്.\n    പാരാമീറ്ററുകൾ:\n- n (int): ബൈനറി സ്ട്രിംഗിന്റെ നീളം.\n- m (int): ബൈനറി സ്ട്രിംഗിലുള്ള '1'കളുടെ എണ്ണം.\n    മടക്കുന്നു:\n    int: വ്യത്യസ്തമായ പെർമ്യൂട്ടേഷൻ പദ്ധതികളുടെ മൊത്തം എണ്ണം.", "fa": "یک تابع C بنویسید `int f_19(int n, int m)` برای حل مسئله زیر:\nتعداد طرح‌های مختلف جایگشت برای یک رشته باینری به طول n را بشمارید،\nکه در آن تعداد '1'ها برابر m و تعداد '0'ها برابر n - m است.\n    پارامترها:\n- n (int): طول رشته باینری.\n- m (int): تعداد '1'ها در رشته باینری.\n    بازگشت:\n    int: تعداد کل طرح‌های مختلف جایگشت."}, "level": "hard", "test": "int main() {\n    // printf(\"%d\\n\", f_19(2, 0));\n    assert(f_19(2, 0) == 2);\n    assert(f_19(2, 1) == 0);\n    assert(f_19(3, 0) == 0);\n    assert(f_19(3, 1) == 3);\n    assert(f_19(3, 2) == 0);\n    assert(f_19(30, 2) == 145422675);\n    assert(f_19(4, 2) == 4);\n    assert(f_19(5, 5) == 1);\n    assert(f_19(33, 17) == 13884156);\n    assert(f_19(1000, 1000) == 1);\n    // Add more test cases if necessary\n    return 0;\n}", "entry_point": "f_19", "signature": "int f_19(int n, int m)", "docstring": {"en": "Count the number of different permutation schemes for a binary string of length n,\nwhere the number of '1's is m and the number of '0's is n - m.\n​    Parameters:\n- n (int): Length of the binary string.\n- m (int): Number of '1's in the binary string.\n​    Returns:\n​    int: The total number of different permutation schemes.\n", "sq": "Numëroni numrin e skemave të ndryshme të permutimit për një varg binar me gjatësi n, ku numri i '1'-ve është m dhe numri i '0'-ve është n - m.\n    Parametrat:\n- n (int): Gjatësia e vargut binar.\n- m (int): Numri i '1'-ve në vargun binar.\n    Kthen:\n    int: Numri total i skemave të ndryshme të permutimit.", "hy": "Հաշվել տարբեր վերադասավորման սխեմաների քանակը երկբայական տողի համար, որի երկարությունը n է, որտեղ '1'-երի քանակը m է և '0'-երի քանակը n - m է:\n​    Պարամետրեր:\n- n (int): Երկբայական տողի երկարությունը:\n- m (int): '1'-երի քանակը երկբայական տողի մեջ:\n​    Վերադարձնում է:\n​    int: Տարբեր վերադասավորման սխեմաների ընդհանուր քանակը:", "bn": "বাইনারি স্ট্রিংয়ের দৈর্ঘ্য n এর জন্য বিভিন্ন বিন্যাস স্কিমের সংখ্যা গণনা করুন, যেখানে '1' এর সংখ্যা m এবং '0' এর সংখ্যা n - m।\n\n    প্যারামিটারসমূহ:\n    - n (int): বাইনারি স্ট্রিংয়ের দৈর্ঘ্য।\n    - m (int): বাইনারি স্ট্রিংয়ে '1' এর সংখ্যা।\n\n    রিটার্নস:\n    int: বিভিন্ন বিন্যাস স্কিমের মোট সংখ্যা।", "bg": "Бройте броя на различните схеми на пермутации за двоичен низ с дължина n, където броят на '1' е m и броят на '0' е n - m.\n    Параметри:\n- n (int): Дължина на двоичния низ.\n- m (int): Брой на '1' в двоичния низ.\n    Връща:\n    int: Общият брой на различните схеми на пермутации.", "zh": "计算长度为 n 的二进制字符串的不同排列方案数量，其中 '1' 的数量为 m，'0' 的数量为 n - m。  \n参数:  \n- n (int): 二进制字符串的长度。  \n- m (int): 二进制字符串中 '1' 的数量。  \n返回:  \nint: 不同排列方案的总数量。", "fr": "Compter le nombre de différents schémas de permutation pour une chaîne binaire de longueur n, où le nombre de '1' est m et le nombre de '0' est n - m.\n​    Paramètres:\n- n (int): Longueur de la chaîne binaire.\n- m (int): Nombre de '1' dans la chaîne binaire.\n​    Renvoie:\n​    int: Le nombre total de différents schémas de permutation.", "de": "Zähle die Anzahl der verschiedenen Permutationsschemata für einen Binärstring der Länge n, wobei die Anzahl der '1's m ist und die Anzahl der '0's n - m.\n​    Parameter:\n- n (int): Länge des Binärstrings.\n- m (int): Anzahl der '1's im Binärstring.\n​    Rückgabewert:\n​    int: Die Gesamtanzahl der verschiedenen Permutationsschemata.", "ha": "Ƙirga adadin tsarin juyawa daban-daban don igiyar binary mai tsawon n,\ninda adadin '1's shine m kuma adadin '0's shine n - m.\n    Sigogi:\n- n (int): Tsawon igiyar binary.\n- m (int): Yawan '1's a cikin igiyar binary.\n    Komawa:\n    int: Jimillar adadin tsarin permutation daban-daban.", "hi": "बाइनरी स्ट्रिंग की लंबाई n के लिए विभिन्न क्रमपरिवर्तन योजनाओं की संख्या गिनें, जहाँ '1' की संख्या m है और '0' की संख्या n - m है।\n\nParameters:\n- n (int): बाइनरी स्ट्रिंग की लंबाई।\n- m (int): बाइनरी स्ट्रिंग में '1' की संख्या।\n\nReturns:\nint: विभिन्न क्रमपरिवर्तन योजनाओं की कुल संख्या।", "hu": "Számolja meg a különböző permutációs sémák számát egy n hosszúságú bináris karakterláncra, ahol az '1'-ek száma m, és a '0'-k száma n - m.\n    Paraméterek:\n- n (int): A bináris karakterlánc hossza.\n- m (int): Az '1'-ek száma a bináris karakterláncban.\n    Visszatér:\n    int: A különböző permutációs sémák teljes száma.", "es": "Cuenta el número de diferentes esquemas de permutación para una cadena binaria de longitud n, donde el número de '1's es m y el número de '0's es n - m.\n    Parámetros:\n- n (int): Longitud de la cadena binaria.\n- m (int): Número de '1's en la cadena binaria.\n    Devuelve:\n    int: El número total de diferentes esquemas de permutación.", "arb": "احسب عدد مخططات التبديل المختلفة لسلسلة ثنائية بطول n، حيث يكون عدد '1's هو m وعدد '0's هو n - m.\n    المعلمات:\n- n (int): طول السلسلة الثنائية.\n- m (int): عدد '1's في السلسلة الثنائية.\n    العوائد:\n    int: العدد الإجمالي لمخططات التبديل المختلفة.", "sw": "Hesabu idadi ya mipango tofauti ya mpangilio kwa kamba ya binary yenye urefu n, ambapo idadi ya '1' ni m na idadi ya '0' ni n - m.\n    Vigezo:\n- n (int): Urefu wa kamba ya binary.\n- m (int): Idadi ya '1' katika kamba ya binary.\n    Inarejesha:\n    int: Jumla ya idadi ya mipango tofauti ya mpangilio.", "tr": "İkili bir dizgenin uzunluğu n olan, '1'lerin sayısı m ve '0'ların sayısı n - m olan farklı permütasyon şemalarının sayısını hesaplayın.\n\n    Parametreler:\n    - n (int): İkili dizgenin uzunluğu.\n    - m (int): İkili dizgedeki '1'lerin sayısı.\n\n    Döndürür:\n    int: Farklı permütasyon şemalarının toplam sayısı.", "vi": "Đếm số lượng các sơ đồ hoán vị khác nhau cho một chuỗi nhị phân có độ dài n, trong đó số lượng '1' là m và số lượng '0' là n - m.\n\n    Tham số:\n    - n (int): Độ dài của chuỗi nhị phân.\n    - m (int): Số lượng '1' trong chuỗi nhị phân.\n\n    Trả về:\n    int: Tổng số lượng các sơ đồ hoán vị khác nhau.", "id": "Hitung jumlah skema permutasi berbeda untuk string biner dengan panjang n, di mana jumlah '1' adalah m dan jumlah '0' adalah n - m.  \n​    Parameter:  \n- n (int): Panjang dari string biner.  \n- m (int): Jumlah '1' dalam string biner.  \n​    Mengembalikan:  \n​    int: Jumlah total skema permutasi berbeda.", "ja": "n の長さのバイナリ文字列に対して、'1' の数が m で '0' の数が n - m である異なる順列スキームの数を数えます。\n\n引数:\n- n (int): バイナリ文字列の長さ。\n- m (int): バイナリ文字列中の '1' の数。\n\n戻り値:\nint: 異なる順列スキームの総数。", "ko": "이진 문자열의 길이가 n이고, '1'의 개수가 m이며 '0'의 개수가 n - m일 때, 서로 다른 순열 방식의 수를 계산합니다.\n\n매개변수:\n- n (int): 이진 문자열의 길이.\n- m (int): 이진 문자열에서 '1'의 개수.\n\n반환:\nint: 서로 다른 순열 방식의 총 수.", "ml": "ഒരു ബൈനറി സ്ട്രിംഗിന്റെ വ്യത്യസ്ത പെർമ്യൂട്ടേഷൻ സ്കീമുകളുടെ എണ്ണം എണ്ണുക, \nഎവിടെ '1' കളുടെ എണ്ണം m ആണ്, '0' കളുടെ എണ്ണം n - m ആണ്.\\n\nപാരാമീറ്ററുകൾ:\n- n (int): ബൈനറി സ്ട്രിംഗിന്റെ നീളം.\n- m (int): ബൈനറി സ്ട്രിംഗിലെ '1'കളുടെ എണ്ണം.\n\nമടക്കം:\nint: വ്യത്യസ്തമായ പർമ്യൂട്ടേഷൻ സ്കീമുകളുടെ മൊത്തം എണ്ണം.", "fa": "تعداد طرح‌های جایگشت مختلف برای یک رشته باینری به طول n را بشمارید،\nکه در آن تعداد '1'ها برابر با m و تعداد '0'ها برابر با n - m است.\n    پارامترها:\n- n (int): طول رشته باینری.\n- m (int): تعداد '1'ها در رشته باینری.\n    بازگشت:\n    int: تعداد کل طرح‌های جایگشت مختلف."}}
{"task_id": "C/20", "prompt": {"en": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n​    Answer a series of questions by providing choices A, B, C, or D for each question.\n​    Question 1:\n​    Constants like 1e6 belong to which data type?\n​        A. unsigned int\n​        B. int\n​        C. float\n​        D. double\n​    Question 2:\n​    Given 21! = 51,090,942,171,709,440,000, which data type can be used to store this value?\n​        A. int\n​        B. long long\n​        C. double\n​        D. None of the above\n​    Question 3:\n​    Which statement about left values in expressions is incorrect?\n​        A. Variable name expressions are left values.\n​        B. Increment operation requires the operand to be a left value.\n​        C. Pointer dereference expressions are left values.\n​        D. Prefix increment operation expressions are left values.\n​    Question 4:\n​    Which statement about functions is incorrect?\n​        A. Formal parameters of a function are local variables.\n​        B. Local variables are allocated space in the stack.\n​        C. The function type is the same as the return value type.\n​        D. A function can call itself from within its body.\n​    Question 5:\n​    Which statement about pointers is incorrect?\n​        A. Subtracting two pointers equals the difference in their address values.\n​        B. Pointer dereference involves resolving based on the pointer's type.\n​        C. int *p[4], p is an array of int pointers.\n​        D. Function names can be assigned to function pointers.\n\t>>> f_20()\n\tAAAAA\nYou're supposed to only return strings similar to \"AAAAA\", which stand for the choices of the question.\n*/\nconst char* f_20()", "sq": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n​    Përgjigju një serie pyetjesh duke ofruar zgjedhjet A, B, C, ose D për secilën pyetje.\n​    Pyetja 1:\n​    Konstantet si 1e6 i përkasin cilit lloj të dhënash?\n​        A. unsigned int\n​        B. int\n​        C. float\n​        D. double\n​    Pyetja 2:\n​    Duke dhënë 21! = 51,090,942,171,709,440,000, cili lloj i të dhënave mund të përdoret për të ruajtur këtë vlerë?\n​        A. int\n​        B. long long\n​        C. double\n​        D. Asnjë nga të mësipërmet\n​    Pyetja 3:\n​    Cila deklaratë për vlerat e majta në shprehje është e pasaktë?\n​        A. Shprehjet e emrave të variablave janë vlera të majta.\n​        B. Operacioni i inkrementimit kërkon që operandi të jetë një vlerë e majtë.\n​        C. Shprehjet e dereferencimit të treguesve janë vlera të majta.\n​        D. Shprehjet e operacionit të inkrementimit prefiks janë vlera të majta.\n​    Pyetja 4:\n​    Cila deklaratë për funksionet është e pasaktë?\n​        A. Parametrat formalë të një funksioni janë variabla lokale.\n​        B. Variablat lokale alokohen hapësirë në stack.\n​        C. Lloji i funksionit është i njëjtë me llojin e vlerës së kthimit.\n​        D. Një funksion mund të thërrasë vetveten nga brenda trupit të tij.\n​    Pyetja 5:\n​    Cila deklaratë për treguesit është e pasaktë?\n​        A. Zbritja e dy treguesve është e barabartë me diferencën në vlerat e adresave të tyre.\n​        B. Dereferencimi i treguesve përfshin zgjidhjen bazuar në llojin e treguesit.\n​        C. int *p[4], p është një varg treguesish int.\n​        D. Emrat e funksioneve mund të caktohen tek treguesit e funksioneve.\n\t>>> f_20()\n\tAAAAA\nDuhet të ktheni vetëm vargje të ngjashme me \"AAAAA\", të cilat përfaqësojnë zgjedhjet e pyetjes.\n*/\nconst char* f_20()", "hy": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n​    Պատասխանեք մի շարք հարցերի՝ յուրաքանչյուր հարցի համար տրամադրելով A, B, C կամ D ընտրանքները:\n​    Հարց 1:\n​    1e6 նման հաստատունները որ տվյալների տիպին են պատկանում?\n​        A. unsigned int\n​        B. int\n​        C. float\n​        D. double\n​    Հարց 2:\n​    Տրված է 21! = 51,090,942,171,709,440,000, որ տվյալների տիպը կարող է պահել այս արժեքը?\n​        A. int\n​        B. long long\n​        C. double\n​        D. Վերը նշվածներից ոչ մեկը\n​    Հարց 3:\n​    Որ արտահայտությունը ձախ արժեքների մասին սխալ է?\n​        A. Փոփոխականի անվան արտահայտությունները ձախ արժեքներ են:\n​        B. Ինկրեմենտ գործողությունը պահանջում է, որ օպերանդը լինի ձախ արժեք:\n​        C. Ցուցիչի ապահավաքման արտահայտությունները ձախ արժեքներ են:\n​        D. Նախածանց ինկրեմենտ գործողության արտահայտությունները ձախ արժեքներ են:\n​    Հարց 4:\n​    Որ արտահայտությունը ֆունկցիաների մասին սխալ է?\n​        A. Ֆունկցիայի ֆորմալ պարամետրերը տեղական փոփոխականներ են:\n​        B. Տեղական փոփոխականները տեղադրվում են ստեկում:\n​        C. Ֆունկցիայի տիպը նույնն է, ինչ վերադարձվող արժեքի տիպը:\n​        D. Ֆունկցիան կարող է ինքն իրեն կանչել իր մարմնից:\n​    Հարց 5:\n​    Որ արտահայտությունը ցուցիչների մասին սխալ է?\n​        A. Երկու ցուցիչների հանումը հավասար է նրանց հասցեների արժեքների տարբերությանը:\n​        B. Ցուցիչի ապահավաքումը ներառում է լուծում ցուցիչի տիպի հիման վրա:\n​        C. int *p[4], p-ն int ցուցիչների զանգված է:\n​        D. Ֆունկցիայի անունները կարող են վերագրվել ֆունկցիայի ցուցիչներին:\n\t>>> f_20()\n\tAAAAA\nԴուք պետք է վերադարձնեք միայն \"AAAAA\" նման տողեր, որոնք ներկայացնում են հարցի ընտրանքները:\n*/\nconst char* f_20()", "bn": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n​    প্রতিটি প্রশ্নের জন্য A, B, C, বা D বিকল্প প্রদান করে প্রশ্নগুলোর উত্তর দিন।\n​    প্রশ্ন ১:\n​    1e6 এর মত ধ্রুবক কোন ডেটা টাইপের অন্তর্গত?\n​        A. unsigned int\n​        B. int\n​        C. float\n​        D. double\n​    প্রশ্ন ২:\n​    21! = 51,090,942,171,709,440,000 দেওয়া হলে, কোন ডেটা টাইপ এই মান সংরক্ষণ করতে ব্যবহার করা যেতে পারে?\n​        A. int\n​        B. long long\n​        C. double\n​        D. উপরোক্ত কোনোটিই নয়\n​    প্রশ্ন ৩:\n​    এক্সপ্রেশনে বাম মান সম্পর্কে কোন বিবৃতি ভুল?\n​        A. ভেরিয়েবল নামের এক্সপ্রেশনগুলি বাম মান।\n​        B. ইনক্রিমেন্ট অপারেশনটির জন্য অপারেন্ডকে বাম মান হতে হবে।\n​        C. পয়েন্টার ডিরেফারেন্স এক্সপ্রেশনগুলি বাম মান।\n​        D. প্রিফিক্স ইনক্রিমেন্ট অপারেশন এক্সপ্রেশনগুলি বাম মান।\n​    প্রশ্ন ৪:\n​    ফাংশন সম্পর্কে কোন বিবৃতি ভুল?\n​        A. একটি ফাংশনের আনুষ্ঠানিক প্যারামিটারগুলি স্থানীয় ভেরিয়েবল।\n​        B. স্থানীয় ভেরিয়েবলগুলি স্ট্যাকে স্থান বরাদ্দ করা হয়।\n​        C. ফাংশন টাইপ এবং রিটার্ন ভ্যালু টাইপ একই।\n​        D. একটি ফাংশন তার শরীরের ভিতরে নিজেকে কল করতে পারে।\n​    প্রশ্ন ৫:\n​    পয়েন্টার সম্পর্কে কোন বিবৃতি ভুল?\n​        A. দুটি পয়েন্টার বিয়োগ করলে তাদের ঠিকানা মানের পার্থক্য হয়।\n​        B. পয়েন্টার ডিরেফারেন্স পয়েন্টারের টাইপের উপর ভিত্তি করে সমাধান করা হয়।\n​        C. int *p[4], p একটি int পয়েন্টারের অ্যারে।\n​        D. ফাংশনের নাম ফাংশন পয়েন্টারগুলিতে বরাদ্দ করা যেতে পারে।\n\t>>> f_20()\n\tAAAAA\nআপনাকে শুধুমাত্র \"AAAAA\" এর মত স্ট্রিং ফেরত দিতে হবে, যা প্রশ্নের বিকল্পগুলোর জন্য দাঁড়ায়।\n*/\nconst char* f_20()", "bg": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n​    Отговорете на серия от въпроси, като предоставите избори A, B, C или D за всеки въпрос.\n​    Въпрос 1:\n​    Константи като 1e6 принадлежат към кой тип данни?\n​        A. unsigned int\n​        B. int\n​        C. float\n​        D. double\n​    Въпрос 2:\n​    Дадено е 21! = 51,090,942,171,709,440,000, кой тип данни може да се използва за съхранение на тази стойност?\n​        A. int\n​        B. long long\n​        C. double\n​        D. Нито едно от горепосочените\n​    Въпрос 3:\n​    Кое твърдение за левите стойности в изразите е неправилно?\n​        A. Изразите с имена на променливи са леви стойности.\n​        B. Операцията за инкрементиране изисква операндът да бъде лява стойност.\n​        C. Изразите за дереференция на указатели са леви стойности.\n​        D. Изразите за префикс инкрементиране са леви стойности.\n​    Въпрос 4:\n​    Кое твърдение за функциите е неправилно?\n​        A. Формалните параметри на функцията са локални променливи.\n​        B. Локалните променливи се разпределят в стека.\n​        C. Типът на функцията е същият като типа на връщаната стойност.\n​        D. Функцията може да извика сама себе си в тялото си.\n​    Въпрос 5:\n​    Кое твърдение за указателите е неправилно?\n​        A. Изваждането на два указателя е равно на разликата в техните адресни стойности.\n​        B. Дереференцията на указател включва разрешаване на базата на типа на указателя.\n​        C. int *p[4], p е масив от указатели към int.\n​        D. Имената на функциите могат да бъдат присвоени на указатели към функции.\n\t>>> f_20()\n\tAAAAA\nТрябва да върнете само низове, подобни на \"AAAAA\", които представляват изборите на въпросите.\n*/\nconst char* f_20()", "zh": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n​    通过为每个问题提供选项 A、B、C 或 D 来回答一系列问题。\n​    问题 1：\n​    像 1e6 这样的常量属于哪种数据类型？\n​        A. unsigned int\n​        B. int\n​        C. float\n​        D. double\n​    问题 2：\n​    给定 21! = 51,090,942,171,709,440,000，哪种数据类型可以用来存储这个值？\n​        A. int\n​        B. long long\n​        C. double\n​        D. 以上都不是\n​    问题 3：\n​    关于表达式中的左值，哪个说法不正确？\n​        A. 变量名表达式是左值。\n​        B. 增量操作要求操作数是左值。\n​        C. 指针解引用表达式是左值。\n​        D. 前缀增量操作表达式是左值。\n​    问题 4：\n​    关于函数，哪个说法不正确？\n​        A. 函数的形式参数是局部变量。\n​        B. 局部变量在栈中分配空间。\n​        C. 函数类型与返回值类型相同。\n​        D. 函数可以在其内部调用自身。\n​    问题 5：\n​    关于指针，哪个说法不正确？\n​        A. 两个指针相减等于它们地址值的差。\n​        B. 指针解引用涉及根据指针的类型进行解析。\n​        C. int *p[4], p 是一个 int 指针数组。\n​        D. 函数名可以赋值给函数指针。\n\t>>> f_20()\n\tAAAAA\n你应该只返回类似 \"AAAAA\" 的字符串，代表问题的选择。\n*/\nconst char* f_20()", "fr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n​    Répondez à une série de questions en fournissant les choix A, B, C ou D pour chaque question.\n​    Question 1 :\n​    Les constantes comme 1e6 appartiennent à quel type de données ?\n​        A. unsigned int\n​        B. int\n​        C. float\n​        D. double\n​    Question 2 :\n​    Étant donné 21! = 51,090,942,171,709,440,000, quel type de données peut être utilisé pour stocker cette valeur ?\n​        A. int\n​        B. long long\n​        C. double\n​        D. Aucun des précédents\n​    Question 3 :\n​    Quelle affirmation concernant les valeurs à gauche dans les expressions est incorrecte ?\n​        A. Les expressions de nom de variable sont des valeurs à gauche.\n​        B. L'opération d'incrément nécessite que l'opérande soit une valeur à gauche.\n​        C. Les expressions de déréférencement de pointeur sont des valeurs à gauche.\n​        D. Les expressions d'opération d'incrémentation préfixée sont des valeurs à gauche.\n​    Question 4 :\n​    Quelle affirmation concernant les fonctions est incorrecte ?\n​        A. Les paramètres formels d'une fonction sont des variables locales.\n​        B. Les variables locales sont allouées dans la pile.\n​        C. Le type de la fonction est le même que le type de la valeur de retour.\n​        D. Une fonction peut s'appeler elle-même depuis son corps.\n​    Question 5 :\n​    Quelle affirmation concernant les pointeurs est incorrecte ?\n​        A. Soustraire deux pointeurs équivaut à la différence de leurs valeurs d'adresse.\n​        B. Le déréférencement de pointeur implique une résolution basée sur le type du pointeur.\n​        C. int *p[4], p est un tableau de pointeurs int.\n​        D. Les noms de fonctions peuvent être assignés à des pointeurs de fonction.\n\t>>> f_20()\n\tAAAAA\nVous êtes censé ne retourner que des chaînes similaires à \"AAAAA\", qui représentent les choix de la question.\n*/\nconst char* f_20()", "de": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n​    Beantworten Sie eine Reihe von Fragen, indem Sie für jede Frage die Auswahlmöglichkeiten A, B, C oder D angeben.\n​    Frage 1:\n​    Konstanten wie 1e6 gehören zu welchem Datentyp?\n​        A. unsigned int\n​        B. int\n​        C. float\n​        D. double\n​    Frage 2:\n​    Gegeben 21! = 51,090,942,171,709,440,000, welcher Datentyp kann verwendet werden, um diesen Wert zu speichern?\n​        A. int\n​        B. long long\n​        C. double\n​        D. Keine der oben genannten\n​    Frage 3:\n​    Welche Aussage über linke Werte in Ausdrücken ist falsch?\n​        A. Variablennamen-Ausdrücke sind linke Werte.\n​        B. Der Inkrement-Operator erfordert, dass der Operand ein linker Wert ist.\n​        C. Pointer-Dereferenz-Ausdrücke sind linke Werte.\n​        D. Präfix-Inkrement-Operator-Ausdrücke sind linke Werte.\n​    Frage 4:\n​    Welche Aussage über Funktionen ist falsch?\n​        A. Formale Parameter einer Funktion sind lokale Variablen.\n​        B. Lokale Variablen werden im Stack Speicherplatz zugewiesen.\n​        C. Der Funktionstyp ist derselbe wie der Rückgabewerttyp.\n​        D. Eine Funktion kann sich selbst innerhalb ihres Körpers aufrufen.\n​    Frage 5:\n​    Welche Aussage über Zeiger ist falsch?\n​        A. Das Subtrahieren von zwei Zeigern ergibt die Differenz ihrer Adresswerte.\n​        B. Die Dereferenzierung eines Zeigers erfolgt basierend auf dem Typ des Zeigers.\n​        C. int *p[4], p ist ein Array von int-Zeigern.\n​        D. Funktionsnamen können Funktionszeigern zugewiesen werden.\n\t>>> f_20()\n\tAAAAA\nSie sollen nur Zeichenfolgen ähnlich wie \"AAAAA\" zurückgeben, die für die Auswahlmöglichkeiten der Frage stehen.\n*/\nconst char* f_20()", "ha": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n​    Amsa jerin tambayoyi ta hanyar bayar da zaɓuɓɓuka A, B, C, ko D don kowace tambaya.\n​    Tambaya ta 1:\n​    Kwatankwacin kamar 1e6 suna cikin wane irin bayanai?\n​        A. unsigned int\n​        B. int\n​        C. float\n​        D. double\n​    Tambaya ta 2:\n​    An ba da 21! = 51,090,942,171,709,440,000, wane irin bayanai za a iya amfani da shi don adana wannan ƙima?\n​        A. int\n​        B. long long\n​        C. double\n​        D. Babu ɗaya daga cikin waɗanda ke sama\n​    Tambaya ta 3:\n​    Wane bayani game da ƙimar hagu a cikin maganganu ba daidai bane?\n​        A. Maganganun sunayen canji ƙimar hagu ne.\n​        B. Aiki na ƙara yana buƙatar mai aiki ya zama ƙimar hagu.\n​        C. Maganganun cire alamar mai nuna hanya ƙimar hagu ne.\n​        D. Maganganun aiki na ƙara na farko ƙimar hagu ne.\n​    Tambaya ta 4:\n​    Wane bayani game da ayyuka ba daidai bane?\n​        A. Sigogin tsari na aiki canje-canje na gida ne.\n​        B. Canje-canje na gida ana ware musu sarari a cikin faifai.\n​        C. Nau'in aiki yana daidai da nau'in ƙimar dawowa.\n​        D. Aiki na iya kiran kansa daga cikin jikinsa.\n​    Tambaya ta 5:\n​    Wane bayani game da masu nuna hanya ba daidai bane?\n​        A. Cire masu nuna hanya biyu yana daidai da bambanci a cikin ƙimar adireshinsu.\n​        B. Cire alamar mai nuna hanya yana buƙatar warwarewa bisa nau'in mai nuna hanya.\n​        C. int *p[4], p tsari ne na masu nuna hanya na int.\n​        D. Ana iya ba da sunayen ayyuka ga masu nuna hanya na aiki.\n\t>>> f_20()\n\tAAAAA\nAna tsammanin ku dawo da kirtani kamar \"AAAAA\", wanda ke nufin zaɓuɓɓukan tambayar.\n*/\nconst char* f_20()", "hi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n​    प्रत्येक प्रश्न के लिए विकल्प A, B, C, या D प्रदान करके प्रश्नों की एक श्रृंखला का उत्तर दें।\n​    प्रश्न 1:\n​    1e6 जैसी स्थिरांक किस डेटा प्रकार से संबंधित हैं?\n​        A. unsigned int\n​        B. int\n​        C. float\n​        D. double\n​    प्रश्न 2:\n​    दिए गए 21! = 51,090,942,171,709,440,000, इस मान को संग्रहीत करने के लिए किस डेटा प्रकार का उपयोग किया जा सकता है?\n​        A. int\n​        B. long long\n​        C. double\n​        D. उपरोक्त में से कोई नहीं\n​    प्रश्न 3:\n​    अभिव्यक्तियों में बाएँ मानों के बारे में कौन सा कथन गलत है?\n​        A. वेरिएबल नाम अभिव्यक्तियाँ बाएँ मान हैं।\n​        B. वृद्धि संचालन के लिए ऑपरेन्ड का बाएँ मान होना आवश्यक है।\n​        C. पॉइंटर डिरेफरेंस अभिव्यक्तियाँ बाएँ मान हैं।\n​        D. उपसर्ग वृद्धि संचालन अभिव्यक्तियाँ बाएँ मान हैं।\n​    प्रश्न 4:\n​    कार्यों के बारे में कौन सा कथन गलत है?\n​        A. एक फ़ंक्शन के औपचारिक पैरामीटर स्थानीय वेरिएबल होते हैं।\n​        B. स्थानीय वेरिएबल स्टैक में स्थान आवंटित करते हैं।\n​        C. फ़ंक्शन प्रकार उसी प्रकार का होता है जैसे रिटर्न मान प्रकार।\n​        D. एक फ़ंक्शन अपने शरीर के भीतर से स्वयं को कॉल कर सकता है।\n​    प्रश्न 5:\n​    पॉइंटर्स के बारे में कौन सा कथन गलत है?\n​        A. दो पॉइंटर्स को घटाने से उनके पते के मानों में अंतर होता है।\n​        B. पॉइंटर डिरेफरेंस में पॉइंटर के प्रकार के आधार पर समाधान शामिल होता है।\n​        C. int *p[4], p int पॉइंटर्स की एक सरणी है।\n​        D. फ़ंक्शन नामों को फ़ंक्शन पॉइंटर्स को सौंपा जा सकता है।\n\t>>> f_20()\n\tAAAAA\nआपको केवल \"AAAAA\" जैसे स्ट्रिंग्स लौटाने हैं, जो प्रश्न के विकल्पों के लिए खड़े होते हैं।\n*/\nconst char* f_20()", "hu": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n​    Válaszolj egy sor kérdésre az A, B, C vagy D választási lehetőségek megadásával minden kérdésnél.\n​    1. kérdés:\n​    Az olyan konstansok, mint az 1e6, melyik adattípushoz tartoznak?\n​        A. unsigned int\n​        B. int\n​        C. float\n​        D. double\n​    2. kérdés:\n​    Tekintve, hogy 21! = 51,090,942,171,709,440,000, melyik adattípus használható ennek az értéknek a tárolására?\n​        A. int\n​        B. long long\n​        C. double\n​        D. Egyik sem a fentiek közül\n​    3. kérdés:\n​    Melyik állítás helytelen a balértékekről a kifejezésekben?\n​        A. A változónév kifejezések balértékek.\n​        B. Az inkrementáló művelet megköveteli, hogy az operandus balérték legyen.\n​        C. A pointer dereferencia kifejezések balértékek.\n​        D. A prefix inkrementáló művelet kifejezések balértékek.\n​    4. kérdés:\n​    Melyik állítás helytelen a függvényekről?\n​        A. A függvény formális paraméterei lokális változók.\n​        B. A lokális változók helyet foglalnak a veremben.\n​        C. A függvény típusa megegyezik a visszatérési érték típusával.\n​        D. Egy függvény meghívhatja önmagát a saját törzsén belül.\n​    5. kérdés:\n​    Melyik állítás helytelen a pointerekről?\n​        A. Két pointer kivonása egyenlő a címértékeik különbségével.\n​        B. A pointer dereferencia a pointer típusán alapuló feloldást igényel.\n​        C. int *p[4], p egy int pointerek tömbje.\n​        D. A függvénynevek hozzárendelhetők függvény pointerekhez.\n\t>>> f_20()\n\tAAAAA\nCsak olyan karakterláncokat kell visszaadnod, mint az \"AAAAA\", amelyek a kérdések választási lehetőségeit jelölik.\n*/\nconst char* f_20()", "es": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n​    Responder a una serie de preguntas proporcionando opciones A, B, C o D para cada pregunta.\n​    Pregunta 1:\n​    ¿Constantes como 1e6 pertenecen a qué tipo de dato?\n​        A. unsigned int\n​        B. int\n​        C. float\n​        D. double\n​    Pregunta 2:\n​    Dado 21! = 51,090,942,171,709,440,000, ¿qué tipo de dato se puede usar para almacenar este valor?\n​        A. int\n​        B. long long\n​        C. double\n​        D. Ninguna de las anteriores\n​    Pregunta 3:\n​    ¿Cuál afirmación sobre los valores a la izquierda en expresiones es incorrecta?\n​        A. Las expresiones de nombres de variables son valores a la izquierda.\n​        B. La operación de incremento requiere que el operando sea un valor a la izquierda.\n​        C. Las expresiones de desreferencia de punteros son valores a la izquierda.\n​        D. Las expresiones de operación de incremento prefijo son valores a la izquierda.\n​    Pregunta 4:\n​    ¿Cuál afirmación sobre las funciones es incorrecta?\n​        A. Los parámetros formales de una función son variables locales.\n​        B. Las variables locales se asignan espacio en la pila.\n​        C. El tipo de la función es el mismo que el tipo de valor de retorno.\n​        D. Una función puede llamarse a sí misma desde dentro de su cuerpo.\n​    Pregunta 5:\n​    ¿Cuál afirmación sobre los punteros es incorrecta?\n​        A. Restar dos punteros equivale a la diferencia en sus valores de dirección.\n​        B. La desreferencia de punteros implica resolver basado en el tipo del puntero.\n​        C. int *p[4], p es un arreglo de punteros a int.\n​        D. Los nombres de funciones se pueden asignar a punteros de funciones.\n\t>>> f_20()\n\tAAAAA\nSe supone que solo debes devolver cadenas similares a \"AAAAA\", que representan las opciones de la pregunta.\n*/\nconst char* f_20()", "arb": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n​    أجب عن سلسلة من الأسئلة بتقديم الخيارات A، B، C، أو D لكل سؤال.\n​    السؤال 1:\n​    الثوابت مثل 1e6 تنتمي إلى أي نوع من البيانات؟\n​        A. unsigned int\n​        B. int\n​        C. float\n​        D. double\n​    السؤال 2:\n​    بالنظر إلى 21! = 51,090,942,171,709,440,000، أي نوع من البيانات يمكن استخدامه لتخزين هذه القيمة؟\n​        A. int\n​        B. long long\n​        C. double\n​        D. لا شيء مما سبق\n​    السؤال 3:\n​    أي عبارة عن القيم اليسرى في التعبيرات غير صحيحة؟\n​        A. تعبيرات أسماء المتغيرات هي قيم يسرى.\n​        B. عملية الزيادة تتطلب أن يكون المعامل قيمة يسرى.\n​        C. تعبيرات إلغاء الإشارة للمؤشر هي قيم يسرى.\n​        D. تعبيرات عملية الزيادة السابقة هي قيم يسرى.\n​    السؤال 4:\n​    أي عبارة عن الدوال غير صحيحة؟\n​        A. المعاملات الرسمية للدالة هي متغيرات محلية.\n​        B. يتم تخصيص مساحة للمتغيرات المحلية في المكدس.\n​        C. نوع الدالة هو نفسه نوع قيمة الإرجاع.\n​        D. يمكن للدالة أن تستدعي نفسها من داخل جسمها.\n​    السؤال 5:\n​    أي عبارة عن المؤشرات غير صحيحة؟\n​        A. طرح مؤشرين يساوي الفرق في قيم عناوينهما.\n​        B. إلغاء إشارة المؤشر يتضمن الحل بناءً على نوع المؤشر.\n​        C. int *p[4]، p هو مصفوفة من مؤشرات int.\n​        D. يمكن تعيين أسماء الدوال إلى مؤشرات الدوال.\n\t>>> f_20()\n\tAAAAA\nمن المفترض أن تعيد فقط سلاسل مشابهة لـ \"AAAAA\"، والتي تمثل خيارات السؤال.\n*/\nconst char* f_20()", "sw": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n​    Jibu mfululizo wa maswali kwa kutoa chaguo A, B, C, au D kwa kila swali.\n​    Swali la 1:\n​    Vigezo vya kudumu kama 1e6 vinatoka kwa aina gani ya data?\n​        A. unsigned int\n​        B. int\n​        C. float\n​        D. double\n​    Swali la 2:\n​    Ikitolewa 21! = 51,090,942,171,709,440,000, ni aina gani ya data inaweza kutumika kuhifadhi thamani hii?\n​        A. int\n​        B. long long\n​        C. double\n​        D. Hakuna kati ya hapo juu\n​    Swali la 3:\n​    Ni kauli gani kuhusu thamani za kushoto katika maelezo si sahihi?\n​        A. Maelezo ya majina ya vigezo ni thamani za kushoto.\n​        B. Operesheni ya kuongeza inahitaji operand kuwa thamani ya kushoto.\n​        C. Maelezo ya kufuta pointer ni thamani za kushoto.\n​        D. Maelezo ya operesheni ya kuongeza awali ni thamani za kushoto.\n​    Swali la 4:\n​    Ni kauli gani kuhusu kazi si sahihi?\n​        A. Vigezo rasmi vya kazi ni vigezo vya ndani.\n​        B. Vigezo vya ndani vinapewa nafasi katika stack.\n​        C. Aina ya kazi ni sawa na aina ya thamani ya kurudi.\n​        D. Kazi inaweza kujita kutoka ndani ya mwili wake.\n​    Swali la 5:\n​    Ni kauli gani kuhusu pointers si sahihi?\n​        A. Kutoa tofauti ya anwani mbili za pointers ni sawa na tofauti katika thamani za anwani zao.\n​        B. Kufuta pointer kunahusisha kutatua kulingana na aina ya pointer.\n​        C. int *p[4], p ni safu ya pointers za int.\n​        D. Majina ya kazi yanaweza kupewa kwa pointers za kazi.\n\t>>> f_20()\n\tAAAAA\nUnatakiwa kurudisha tu mistari inayofanana na \"AAAAA\", ambayo inawakilisha chaguo za swali.\n*/\nconst char* f_20()", "tr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n​    Her bir soru için A, B, C veya D seçeneklerini sağlayarak bir dizi soruyu cevaplayın.\n​    Soru 1:\n​    1e6 gibi sabitler hangi veri tipine aittir?\n​        A. unsigned int\n​        B. int\n​        C. float\n​        D. double\n​    Soru 2:\n​    21! = 51,090,942,171,709,440,000 verildiğinde, bu değeri saklamak için hangi veri tipi kullanılabilir?\n​        A. int\n​        B. long long\n​        C. double\n​        D. Yukarıdakilerin hiçbiri\n​    Soru 3:\n​    İfadelerdeki sol değerler hakkında hangi ifade yanlıştır?\n​        A. Değişken adı ifadeleri sol değerlerdir.\n​        B. Artırma işlemi, operandın bir sol değer olmasını gerektirir.\n​        C. Gösterici çözme ifadeleri sol değerlerdir.\n​        D. Ön ek artırma işlemi ifadeleri sol değerlerdir.\n​    Soru 4:\n​    Fonksiyonlar hakkında hangi ifade yanlıştır?\n​        A. Bir fonksiyonun resmi parametreleri yerel değişkenlerdir.\n​        B. Yerel değişkenler yığında yer kaplar.\n​        C. Fonksiyon tipi, dönüş değeri tipi ile aynıdır.\n​        D. Bir fonksiyon, gövdesi içinden kendisini çağırabilir.\n​    Soru 5:\n​    Göstericiler hakkında hangi ifade yanlıştır?\n​        A. İki göstericinin çıkarılması, adres değerlerindeki farkı eşittir.\n​        B. Gösterici çözme, göstericinin türüne göre çözümlemeyi içerir.\n​        C. int *p[4], p bir int gösterici dizisidir.\n​        D. Fonksiyon isimleri, fonksiyon göstericilerine atanabilir.\n\t>>> f_20()\n\tAAAAA\nSadece soruların seçeneklerini temsil eden \"AAAAA\" gibi dizeler döndürmeniz bekleniyor.\n*/\nconst char* f_20()", "vi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n​    Trả lời một loạt câu hỏi bằng cách cung cấp các lựa chọn A, B, C, hoặc D cho mỗi câu hỏi.\n​    Câu hỏi 1:\n​    Hằng số như 1e6 thuộc kiểu dữ liệu nào?\n​        A. unsigned int\n​        B. int\n​        C. float\n​        D. double\n​    Câu hỏi 2:\n​    Cho 21! = 51,090,942,171,709,440,000, kiểu dữ liệu nào có thể được sử dụng để lưu trữ giá trị này?\n​        A. int\n​        B. long long\n​        C. double\n​        D. Không có cái nào ở trên\n​    Câu hỏi 3:\n​    Câu nào về giá trị trái trong biểu thức là không đúng?\n​        A. Biểu thức tên biến là giá trị trái.\n​        B. Phép toán tăng yêu cầu toán hạng phải là giá trị trái.\n​        C. Biểu thức giải tham chiếu con trỏ là giá trị trái.\n​        D. Biểu thức phép toán tăng tiền tố là giá trị trái.\n​    Câu hỏi 4:\n​    Câu nào về hàm là không đúng?\n​        A. Tham số hình thức của một hàm là biến cục bộ.\n​        B. Biến cục bộ được cấp phát không gian trong ngăn xếp.\n​        C. Kiểu hàm giống với kiểu giá trị trả về.\n​        D. Một hàm có thể tự gọi từ bên trong thân của nó.\n​    Câu hỏi 5:\n​    Câu nào về con trỏ là không đúng?\n​        A. Trừ hai con trỏ bằng với sự khác biệt trong giá trị địa chỉ của chúng.\n​        B. Giải tham chiếu con trỏ liên quan đến việc giải quyết dựa trên kiểu của con trỏ.\n​        C. int *p[4], p là một mảng con trỏ int.\n​        D. Tên hàm có thể được gán cho con trỏ hàm.\n\t>>> f_20()\n\tAAAAA\nBạn chỉ cần trả về các chuỗi tương tự như \"AAAAA\", đại diện cho các lựa chọn của câu hỏi.\n*/\nconst char* f_20()", "id": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n​    Jawab serangkaian pertanyaan dengan memberikan pilihan A, B, C, atau D untuk setiap pertanyaan.\n​    Pertanyaan 1:\n​    Konstanta seperti 1e6 termasuk dalam tipe data apa?\n​        A. unsigned int\n​        B. int\n​        C. float\n​        D. double\n​    Pertanyaan 2:\n​    Diberikan 21! = 51,090,942,171,709,440,000, tipe data apa yang dapat digunakan untuk menyimpan nilai ini?\n​        A. int\n​        B. long long\n​        C. double\n​        D. Tidak ada di atas\n​    Pertanyaan 3:\n​    Pernyataan mana tentang nilai kiri dalam ekspresi yang salah?\n​        A. Ekspresi nama variabel adalah nilai kiri.\n​        B. Operasi inkrement memerlukan operan menjadi nilai kiri.\n​        C. Ekspresi dereferensi pointer adalah nilai kiri.\n​        D. Ekspresi operasi inkrement prefiks adalah nilai kiri.\n​    Pertanyaan 4:\n​    Pernyataan mana tentang fungsi yang salah?\n​        A. Parameter formal dari sebuah fungsi adalah variabel lokal.\n​        B. Variabel lokal dialokasikan ruang di stack.\n​        C. Tipe fungsi sama dengan tipe nilai kembalian.\n​        D. Sebuah fungsi dapat memanggil dirinya sendiri dari dalam tubuhnya.\n​    Pertanyaan 5:\n​    Pernyataan mana tentang pointer yang salah?\n​        A. Mengurangi dua pointer sama dengan perbedaan dalam nilai alamat mereka.\n​        B. Dereferensi pointer melibatkan penyelesaian berdasarkan tipe pointer.\n​        C. int *p[4], p adalah array dari pointer int.\n​        D. Nama fungsi dapat ditetapkan ke pointer fungsi.\n\t>>> f_20()\n\tAAAAA\nAnda seharusnya hanya mengembalikan string yang mirip dengan \"AAAAA\", yang mewakili pilihan dari pertanyaan.\n*/\nconst char* f_20()\n", "ja": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n​    各質問に対して選択肢 A、B、C、または D を提供して一連の質問に答えてください。\n​    質問 1:\n​    1e6 のような定数はどのデータ型に属しますか？\n​        A. unsigned int\n​        B. int\n​        C. float\n​        D. double\n​    質問 2:\n​    21! = 51,090,942,171,709,440,000 が与えられた場合、この値を格納するために使用できるデータ型はどれですか？\n​        A. int\n​        B. long long\n​        C. double\n​        D. 上記のいずれでもない\n​    質問 3:\n​    式の左値に関するどの文が正しくありませんか？\n​        A. 変数名の式は左値です。\n​        B. インクリメント操作にはオペランドが左値であることが必要です。\n​        C. ポインタの逆参照式は左値です。\n​        D. プレフィックスインクリメント操作の式は左値です。\n​    質問 4:\n​    関数に関するどの文が正しくありませんか？\n​        A. 関数の形式パラメータはローカル変数です。\n​        B. ローカル変数はスタックにスペースが割り当てられます。\n​        C. 関数の型は戻り値の型と同じです。\n​        D. 関数はその本体内から自分自身を呼び出すことができます。\n​    質問 5:\n​    ポインタに関するどの文が正しくありませんか？\n​        A. 2 つのポインタを引くと、それらのアドレス値の差になります。\n​        B. ポインタの逆参照は、ポインタの型に基づいて解決されます。\n​        C. int *p[4], p は int ポインタの配列です。\n​        D. 関数名は関数ポインタに代入できます。\n\t>>> f_20()\n\tAAAAA\n質問の選択肢を表す \"AAAAA\" のような文字列のみを返すことになっています。\n*/\nconst char* f_20()", "ko": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n​    각 질문에 대해 선택지 A, B, C, 또는 D를 제공하여 일련의 질문에 답하십시오.\n​    질문 1:\n​    1e6과 같은 상수는 어떤 데이터 유형에 속합니까?\n​        A. unsigned int\n​        B. int\n​        C. float\n​        D. double\n​    질문 2:\n​    21! = 51,090,942,171,709,440,000이 주어졌을 때, 이 값을 저장할 수 있는 데이터 유형은 무엇입니까?\n​        A. int\n​        B. long long\n​        C. double\n​        D. 위의 것들 중 어느 것도 아님\n​    질문 3:\n​    표현식의 왼쪽 값에 대한 설명 중 틀린 것은 무엇입니까?\n​        A. 변수 이름 표현식은 왼쪽 값입니다.\n​        B. 증가 연산은 피연산자가 왼쪽 값이어야 합니다.\n​        C. 포인터 역참조 표현식은 왼쪽 값입니다.\n​        D. 접두사 증가 연산 표현식은 왼쪽 값입니다.\n​    질문 4:\n​    함수에 대한 설명 중 틀린 것은 무엇입니까?\n​        A. 함수의 형식 매개변수는 지역 변수입니다.\n​        B. 지역 변수는 스택에 공간이 할당됩니다.\n​        C. 함수 유형은 반환 값 유형과 동일합니다.\n​        D. 함수는 본문 내에서 자신을 호출할 수 있습니다.\n​    질문 5:\n​    포인터에 대한 설명 중 틀린 것은 무엇입니까?\n​        A. 두 포인터를 빼면 주소 값의 차이가 됩니다.\n​        B. 포인터 역참조는 포인터의 유형에 따라 해결됩니다.\n​        C. int *p[4], p는 int 포인터의 배열입니다.\n​        D. 함수 이름은 함수 포인터에 할당될 수 있습니다.\n\t>>> f_20()\n\tAAAAA\n문제의 선택지를 나타내는 \"AAAAA\"와 유사한 문자열만 반환해야 합니다.\n*/\nconst char* f_20()\n", "ml": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n​    ഓരോ ചോദ്യത്തിനും A, B, C, അല്ലെങ്കിൽ D എന്നിങ്ങനെ തിരഞ്ഞെടുപ്പുകൾ നൽകിക്കൊണ്ട് ചോദ്യങ്ങൾക്ക് ഉത്തരം നൽകുക.\n​    ചോദ്യ 1:\n​    1e6 പോലുള്ള സ്ഥിരാങ്കങ്ങൾ ഏത് ഡാറ്റാ തരം ആണുൾപ്പെടുന്നത്?\n​        A. unsigned int\n​        B. int\n​        C. float\n​        D. double\n​    ചോദ്യ 2:\n​    21! = 51,090,942,171,709,440,000 എന്നത് നൽകപ്പെട്ടാൽ, ഈ മൂല്യം സംഭരിക്കാൻ ഏത് ഡാറ്റാ തരം ഉപയോഗിക്കാം?\n​        A. int\n​        B. long long\n​        C. double\n​        D. മുകളിൽ പറയുന്നവയൊന്നുമല്ല\n​    ചോദ്യ 3:\n​    പ്രകടനങ്ങളിൽ ഇടത് മൂല്യങ്ങളെക്കുറിച്ചുള്ള ഏത് പ്രസ്താവന തെറ്റാണ്?\n​        A. വേരിയബിൾ നാമ പ്രകടനങ്ങൾ ഇടത് മൂല്യങ്ങളാണ്.\n​        B. വർദ്ധന പ്രവർത്തനം ഇടത് മൂല്യമായ ഓപ്പറാൻഡ് ആവശ്യപ്പെടുന്നു.\n​        C. പോയിന്റർ ഡീരഫറൻസ് പ്രകടനങ്ങൾ ഇടത് മൂല്യങ്ങളാണ്.\n​        D. പ്രിഫിക്സ് വർദ്ധന പ്രവർത്തന പ്രകടനങ്ങൾ ഇടത് മൂല്യങ്ങളാണ്.\n​    ചോദ്യ 4:\n​    ഫംഗ്ഷനുകളെക്കുറിച്ചുള്ള ഏത് പ്രസ്താവന തെറ്റാണ്?\n​        A. ഒരു ഫംഗ്ഷന്റെ ഔപചാരിക പാരാമീറ്ററുകൾ പ്രാദേശിക വേരിയബിൾസ് ആണ്.\n​        B. പ്രാദേശിക വേരിയബിൾസിന് സ്റ്റാക്കിൽ സ്ഥലം അനുവദിച്ചിരിക്കുന്നു.\n​        C. ഫംഗ്ഷൻ തരം മടക്ക മൂല്യ തരം പോലെയാണ്.\n​        D. ഒരു ഫംഗ്ഷൻ അതിന്റെ ശരീരത്തിനുള്ളിൽ നിന്ന് തന്നെ വിളിക്കാം.\n​    ചോദ്യ 5:\n​    പോയിന്ററുകളെക്കുറിച്ചുള്ള ഏത് പ്രസ്താവന തെറ്റാണ്?\n​        A. രണ്ട് പോയിന്ററുകൾ കുറയ്ക്കുന്നത് അവരുടെ വിലാസ മൂല്യങ്ങളിൽ വ്യത്യാസം തുല്യമാണ്.\n​        B. പോയിന്റർ ഡീരഫറൻസ്, പോയിന്ററിന്റെ തരം അടിസ്ഥാനമാക്കി പരിഹരിക്കുന്നു.\n​        C. int *p[4], p ഒരു int പോയിന്ററുകളുടെ നിരയാണ്.\n​        D. ഫംഗ്ഷൻ നാമങ്ങൾ ഫംഗ്ഷൻ പോയിന്ററുകൾക്ക് നിയോഗിക്കാം.\n\t>>> f_20()\n\tAAAAA\nനിങ്ങൾ \"AAAAA\" പോലുള്ള സ്ട്രിംഗുകൾ മാത്രമേ മടക്കേണ്ടതുള്ളൂ, ഇത് ചോദ്യത്തിന്റെ തിരഞ്ഞെടുപ്പുകൾക്ക് വേണ്ടി നിൽക്കുന്നു.\n*/\nconst char* f_20()\n", "fa": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n​    به یک سری سوال با ارائه گزینه‌های A، B، C یا D برای هر سوال پاسخ دهید.\n​    سوال 1:\n​    ثابت‌هایی مانند 1e6 به کدام نوع داده تعلق دارند؟\n​        A. unsigned int\n​        B. int\n​        C. float\n​        D. double\n​    سوال 2:\n​    با توجه به 21! = 51,090,942,171,709,440,000، از کدام نوع داده می‌توان برای ذخیره این مقدار استفاده کرد؟\n​        A. int\n​        B. long long\n​        C. double\n​        D. هیچ‌کدام از موارد بالا\n​    سوال 3:\n​    کدام عبارت درباره مقادیر چپ در عبارات نادرست است؟\n​        A. عبارات نام متغیر مقادیر چپ هستند.\n​        B. عملیات افزایش نیاز دارد که عملوند یک مقدار چپ باشد.\n​        C. عبارات اشاره‌گر به مقادیر چپ هستند.\n​        D. عبارات عملیات پیش‌افزایش مقادیر چپ هستند.\n​    سوال 4:\n​    کدام عبارت درباره توابع نادرست است؟\n​        A. پارامترهای رسمی یک تابع متغیرهای محلی هستند.\n​        B. متغیرهای محلی در پشته فضا تخصیص داده می‌شوند.\n​        C. نوع تابع همان نوع مقدار بازگشتی است.\n​        D. یک تابع می‌تواند خود را از درون بدنه‌اش فراخوانی کند.\n​    سوال 5:\n​    کدام عبارت درباره اشاره‌گرها نادرست است؟\n​        A. تفریق دو اشاره‌گر برابر با تفاوت در مقادیر آدرس آن‌ها است.\n​        B. رفع ارجاع اشاره‌گر شامل حل بر اساس نوع اشاره‌گر است.\n​        C. int *p[4]، p یک آرایه از اشاره‌گرهای int است.\n​        D. نام‌های تابع می‌توانند به اشاره‌گرهای تابع اختصاص داده شوند.\n\t>>> f_20()\n\tAAAAA\nشما باید فقط رشته‌هایی مشابه \"AAAAA\" را برگردانید که نشان‌دهنده انتخاب‌های سوال است.\n*/\nconst char* f_20()\n"}, "canonical_solution": "{\n    return \"DDDBA\";\n}", "instruction": {"en": "Write a C function `const char* f_20()` to solve the following problem:\nAnswer a series of questions by providing choices A, B, C, or D for each question.\n\nQuestion 1:\nConstants like 1e6 belong to which data type?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nQuestion 2:\nGiven 21! = 51,090,942,171,709,440,000, which data type can be used to store this value?\n    A. int\n    B. long long\n    C. double\n    D. None of the above\n\nQuestion 3:\nWhich statement about left values in expressions is incorrect?\n    A. Variable name expressions are left values.\n    B. Increment operation requires the operand to be a left value.\n    C. Pointer dereference expressions are left values.\n    D. Prefix increment operation expressions are left values.\n\nQuestion 4:\nWhich statement about functions is incorrect?\n    A. Formal parameters of a function are local variables.\n    B. Local variables are allocated space in the stack.\n    C. The function type is the same as the return value type.\n    D. A function can call itself from within its body.\n\nQuestion 5:\nWhich statement about pointers is incorrect?\n    A. Subtracting two pointers equals the difference in their address values.\n    B. Pointer dereference involves resolving based on the pointer's type.\n    C. int *p[4], p is an array of int pointers.\n    D. Function names can be assigned to function pointers.\n\n>>> f_20()\nAAAAA\nYou're supposed to only return strings similar to \"AAAAA\", which stand for the choices of the question.", "sq": "Shkruani një funksion C `const char* f_20()` për të zgjidhur problemin e mëposhtëm:\nPërgjigjuni një serie pyetjesh duke ofruar zgjedhje A, B, C, ose D për secilën pyetje.\n\nPyetja 1:\nKonstantet si 1e6 i përkasin cilit lloj të dhënash?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nPyetja 2:\nDuke pasur parasysh 21! = 51,090,942,171,709,440,000, cili lloj të dhënash mund të përdoret për të ruajtur këtë vlerë?\n    A. int\n    B. long long\n    C. double\n    D. Asnjë nga më sipër\n\nPyetja 3:\nCila deklaratë rreth vlerave të majta në shprehje është e pasaktë?\n    A. Shprehjet me emra variablash janë vlera të majta.\n    B. Operacioni i inkrementimit kërkon që operandi të jetë një vlerë e majtë.\n    C. Shprehjet e dereferencimit të treguesve janë vlera të majta.\n    D. Shprehjet e operacionit të inkrementimit prefiks janë vlera të majta.\n\nPyetja 4:\nCila deklaratë rreth funksioneve është e pasaktë?\n    A. Parametrat formalë të një funksioni janë variabla lokale.\n    B. Variablat lokale kanë hapësirë të caktuar në stack.\n    C. Lloji i funksionit është i njëjtë me llojin e vlerës së kthimit.\n    D. Një funksion mund të thërrasë vetveten nga brenda trupit të tij.\n\nPyetja 5:\nCila deklaratë rreth treguesve është e pasaktë?\n    A. Zbritja e dy treguesve është e barabartë me diferencën në vlerat e adresave të tyre.\n    B. Dereferencimi i treguesit përfshin zgjidhjen bazuar në llojin e treguesit.\n    C. int *p[4], p është një varg treguesish int.\n    D. Emrat e funksioneve mund t'u caktohen treguesve të funksioneve.\n\n>>> f_20()\nAAAAA\nJu duhet të ktheni vetëm vargje të ngjashme me \"AAAAA\", të cilat përfaqësojnë zgjedhjet e pyetjeve.", "hy": "Գրեք C ֆունկցիա `const char* f_20()` հետևյալ խնդիրը լուծելու համար:\nՊատասխանեք մի շարք հարցերի՝ տրամադրելով A, B, C կամ D ընտրանքները յուրաքանչյուր հարցի համար:\n\nՀարց 1:\nՆման 1e6 հաստատունները որ տվյալների տիպին են պատկանում?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nՀարց 2:\nԵթե 21! = 51,090,942,171,709,440,000, ապա որ տվյալների տիպը կարող է օգտագործվել այս արժեքը պահելու համար?\n    A. int\n    B. long long\n    C. double\n    D. Վերոնշյալներից ոչ մեկը\n\nՀարց 3:\nՈր հայտարարությունն է սխալ ձախ արժեքների մասին արտահայտություններում?\n    A. Փոփոխականի անվան արտահայտությունները ձախ արժեքներ են։\n    B. Ինկրեմենտի գործողությունը պահանջում է, որ օպերանդը լինի ձախ արժեք։\n    C. Ցուցիչի դերեֆերենսի արտահայտությունները ձախ արժեքներ են։\n    D. Նախածանց ինկրեմենտի գործողության արտահայտությունները ձախ արժեքներ են։\n\nՀարց 4:\nՈր հայտարարությունն է սխալ ֆունկցիաների մասին?\n    A. Ֆունկցիայի ֆորմալ պարամետրերը տեղական փոփոխականներ են։\n    B. Տեղական փոփոխականները հատկացվում են կույտում։\n    C. Ֆունկցիայի տիպը նույնն է, ինչ վերադարձվող արժեքի տիպը։\n    D. Ֆունկցիան կարող է ինքն իրեն կանչել իր մարմնից։\n\nՀարց 5:\nՈր հայտարարությունն է սխալ ցուցիչների մասին?\n    A. Երկու ցուցիչների հանումը հավասար է նրանց հասցեների արժեքների տարբերությանը։\n    B. Ցուցիչի դերեֆերենսը ներառում է լուծում ցուցիչի տիպի հիման վրա։\n    C. int *p[4], p-ն int ցուցիչների զանգված է։\n    D. Ֆունկցիաների անունները կարող են վերագրվել ֆունկցիայի ցուցիչներին։\n\n>>> f_20()\nAAAAA\nԴուք պետք է միայն վերադարձնեք տողեր, որոնք նման են \"AAAAA\"-ին, որոնք ներկայացնում են հարցերի ընտրանքները։", "bn": "C ফাংশন `const char* f_20()` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nপ্রতিটি প্রশ্নের জন্য A, B, C, বা D বিকল্প প্রদান করে প্রশ্নগুলির একটি সিরিজের উত্তর দিন।\n\nপ্রশ্ন 1:\n1e6 এর মতো ধ্রুবক কোন ডেটা টাইপের অন্তর্গত?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nপ্রশ্ন 2:\nযদি 21! = 51,090,942,171,709,440,000 হয়, তাহলে কোন ডেটা টাইপ এই মানটি সংরক্ষণ করতে ব্যবহার করা যেতে পারে?\n    A. int\n    B. long long\n    C. double\n    D. উপরের কোনোটিই নয়\n\nপ্রশ্ন 3:\nএক্সপ্রেশনে বাম মান সম্পর্কে কোন বিবৃতিটি ভুল?\n    A. ভেরিয়েবল নাম এক্সপ্রেশনগুলি বাম মান।\n    B. ইনক্রিমেন্ট অপারেশনটির জন্য অপারেন্ডটি একটি বাম মান হতে হবে।\n    C. পয়েন্টার ডেরেফারেন্স এক্সপ্রেশনগুলি বাম মান।\n    D. প্রিফিক্স ইনক্রিমেন্ট অপারেশন এক্সপ্রেশনগুলি বাম মান।\n\nপ্রশ্ন 4:\nফাংশন সম্পর্কে কোন বিবৃতিটি ভুল?\n    A. একটি ফাংশনের আনুষ্ঠানিক প্যারামিটারগুলি স্থানীয় ভেরিয়েবল।\n    B. স্থানীয় ভেরিয়েবলগুলি স্ট্যাকে স্থান বরাদ্দ করে।\n    C. ফাংশনের ধরনটি রিটার্ন মানের ধরন হিসাবে একই।\n    D. একটি ফাংশন তার দেহের ভিতর থেকে নিজেকে কল করতে পারে।\n\nপ্রশ্ন 5:\nপয়েন্টার সম্পর্কে কোন বিবৃতিটি ভুল?\n    A. দুটি পয়েন্টার বিয়োগ করলে তাদের ঠিকানা মানের পার্থক্য হয়।\n    B. পয়েন্টার ডেরেফারেন্স পয়েন্টারের টাইপের উপর ভিত্তি করে সমাধান করে।\n    C. int *p[4], p একটি int পয়েন্টারের অ্যারে।\n    D. ফাংশনের নামগুলি ফাংশন পয়েন্টারগুলিতে বরাদ্দ করা যেতে পারে।\n\n>>> f_20()\nAAAAA\nআপনাকে শুধুমাত্র \"AAAAA\" এর মতো স্ট্রিংগুলি ফেরত দিতে হবে, যা প্রশ্নের বিকল্পগুলির জন্য দাঁড়ায়।", "bg": "Напишете C функция `const char* f_20()`, за да решите следния проблем:\nОтговорете на серия от въпроси, като предоставите избори A, B, C или D за всеки въпрос.\n\nВъпрос 1:\nКонстантите като 1e6 принадлежат към кой тип данни?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nВъпрос 2:\nДадено е 21! = 51,090,942,171,709,440,000, кой тип данни може да се използва за съхранение на тази стойност?\n    A. int\n    B. long long\n    C. double\n    D. Нито едно от горните\n\nВъпрос 3:\nКое твърдение за левите стойности в изразите е неправилно?\n    A. Изразите с имена на променливи са леви стойности.\n    B. Операцията на инкрементиране изисква операндът да е лява стойност.\n    C. Изразите за разименуване на указател са леви стойности.\n    D. Изразите за префиксно инкрементиране са леви стойности.\n\nВъпрос 4:\nКое твърдение за функциите е неправилно?\n    A. Формалните параметри на функцията са локални променливи.\n    B. Локалните променливи се заделят в стека.\n    C. Типът на функцията е същият като типа на връщаната стойност.\n    D. Функцията може да извика себе си от тялото си.\n\nВъпрос 5:\nКое твърдение за указателите е неправилно?\n    A. Изваждането на два указателя е равно на разликата в техните адресни стойности.\n    B. Разименуването на указател включва разрешаване въз основа на типа на указателя.\n    C. int *p[4], p е масив от указатели към int.\n    D. Имената на функции могат да бъдат присвоени на указатели към функции.\n\n>>> f_20()\nAAAAA\nТрябва да върнете само низове, подобни на \"AAAAA\", които представляват изборите на въпросите.", "zh": "编写一个 C 函数 `const char* f_20()` 来解决以下问题：\n通过为每个问题提供选项 A、B、C 或 D 来回答一系列问题。\n\n问题 1：\n像 1e6 这样的常量属于哪种数据类型？\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\n问题 2：\n给定 21! = 51,090,942,171,709,440,000，哪种数据类型可以用来存储这个值？\n    A. int\n    B. long long\n    C. double\n    D. 以上都不是\n\n问题 3：\n关于表达式中的左值，哪个说法不正确？\n    A. 变量名表达式是左值。\n    B. 增量操作要求操作数是左值。\n    C. 指针解引用表达式是左值。\n    D. 前缀增量操作表达式是左值。\n\n问题 4：\n关于函数，哪个说法不正确？\n    A. 函数的形式参数是局部变量。\n    B. 局部变量在栈中分配空间。\n    C. 函数类型与返回值类型相同。\n    D. 函数可以在其内部调用自身。\n\n问题 5：\n关于指针，哪个说法不正确？\n    A. 两个指针相减等于它们地址值的差。\n    B. 指针解引用涉及根据指针的类型进行解析。\n    C. int *p[4], p 是一个 int 指针数组。\n    D. 函数名可以赋值给函数指针。\n\n>>> f_20()\nAAAAA\n你应该只返回类似 \"AAAAA\" 的字符串，代表问题的选择。", "fr": "Écrire une fonction C `const char* f_20()` pour résoudre le problème suivant :\nRépondre à une série de questions en fournissant des choix A, B, C ou D pour chaque question.\n\nQuestion 1 :  \nLes constantes comme 1e6 appartiennent à quel type de données ?  \n    A. unsigned int  \n    B. int  \n    C. float  \n    D. double  \n\nQuestion 2 :  \nÉtant donné 21! = 51,090,942,171,709,440,000, quel type de données peut être utilisé pour stocker cette valeur ?  \n    A. int  \n    B. long long  \n    C. double  \n    D. Aucun des précédents  \n\nQuestion 3 :  \nQuelle affirmation concernant les valeurs à gauche dans les expressions est incorrecte ?  \n    A. Les expressions de noms de variables sont des valeurs à gauche.  \n    B. L'opération d'incrémentation nécessite que l'opérande soit une valeur à gauche.  \n    C. Les expressions de déréférencement de pointeur sont des valeurs à gauche.  \n    D. Les expressions d'opération d'incrémentation préfixée sont des valeurs à gauche.  \n\nQuestion 4 :  \nQuelle affirmation concernant les fonctions est incorrecte ?  \n    A. Les paramètres formels d'une fonction sont des variables locales.  \n    B. Les variables locales sont allouées dans la pile.  \n    C. Le type de la fonction est le même que le type de la valeur de retour.  \n    D. Une fonction peut s'appeler elle-même à l'intérieur de son corps.  \n\nQuestion 5 :  \nQuelle affirmation concernant les pointeurs est incorrecte ?  \n    A. Soustraire deux pointeurs équivaut à la différence de leurs valeurs d'adresse.  \n    B. Le déréférencement de pointeur implique une résolution basée sur le type du pointeur.  \n    C. int *p[4], p est un tableau de pointeurs int.  \n    D. Les noms de fonctions peuvent être assignés à des pointeurs de fonction.  \n\n>>> f_20()  \nAAAAA  \nVous êtes censé uniquement retourner des chaînes similaires à \"AAAAA\", qui représentent les choix des questions.", "de": "Schreiben Sie eine C-Funktion `const char* f_20()`, um das folgende Problem zu lösen:\nBeantworten Sie eine Reihe von Fragen, indem Sie für jede Frage die Auswahlmöglichkeiten A, B, C oder D angeben.\n\nFrage 1:\nKonstanten wie 1e6 gehören zu welchem Datentyp?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nFrage 2:\nAngesichts 21! = 51,090,942,171,709,440,000, welcher Datentyp kann verwendet werden, um diesen Wert zu speichern?\n    A. int\n    B. long long\n    C. double\n    D. Keine der oben genannten\n\nFrage 3:\nWelche Aussage über linke Werte in Ausdrücken ist falsch?\n    A. Variablennamen-Ausdrücke sind linke Werte.\n    B. Der Inkrementoperator erfordert, dass der Operand ein linker Wert ist.\n    C. Pointer-Dereferenzierungs-Ausdrücke sind linke Werte.\n    D. Präfix-Inkrementoperator-Ausdrücke sind linke Werte.\n\nFrage 4:\nWelche Aussage über Funktionen ist falsch?\n    A. Formale Parameter einer Funktion sind lokale Variablen.\n    B. Lokale Variablen werden im Stack Speicherplatz zugewiesen.\n    C. Der Funktionstyp ist derselbe wie der Rückgabewerttyp.\n    D. Eine Funktion kann sich selbst aus ihrem Körper heraus aufrufen.\n\nFrage 5:\nWelche Aussage über Zeiger ist falsch?\n    A. Das Subtrahieren zweier Zeiger entspricht der Differenz ihrer Adresswerte.\n    B. Die Dereferenzierung eines Zeigers erfolgt basierend auf dem Typ des Zeigers.\n    C. int *p[4], p ist ein Array von int-Zeigern.\n    D. Funktionsnamen können Funktionszeigern zugewiesen werden.\n\n>>> f_20()\nAAAAA\nSie sollen nur Zeichenfolgen ähnlich wie \"AAAAA\" zurückgeben, die für die Auswahlmöglichkeiten der Frage stehen.", "ha": "Rubuta aikin C `const char* f_20()` don warware matsalar mai zuwa:\nAmsa jerin tambayoyi ta hanyar bayar da zaɓuɓɓuka A, B, C, ko D ga kowace tambaya.\n\nTambaya ta 1:\nConstant kamar 1e6 yana cikin wane nau'in bayanai?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nTambaya ta 2:\nAn ba da 21! = 51,090,942,171,709,440,000, wane nau'in bayanai za a iya amfani da shi don adana wannan ƙima?\n    A. int\n    B. long long\n    C. double\n    D. Babu ɗaya daga cikin waɗannan\n\nTambaya ta 3:\nWane bayani game da ƙimar hagu a cikin maganganu ba daidai ba ne?\n    A. Maganganun sunayen canji ƙimar hagu ne.\n    B. Aiki na ƙaruwa yana buƙatar operand ya zama ƙimar hagu.\n    C. Maganganun cirewa mai nuna alama ƙimar hagu ne.\n    D. Maganganun aiki na ƙaruwa na farko ƙimar hagu ne.\n\nTambaya ta 4:\nWane bayani game da ayyuka ba daidai ba ne?\n    A. Sigogin tsari na aiki canje-canje na gida ne.\n    B. Canje-canje na gida ana ware su a cikin faifai.\n    C. Nau'in aiki iri ɗaya ne da nau'in ƙimar dawowa.\n    D. Aiki na iya kiran kansa daga cikin jikinsa.\n\nTambaya ta 5:\nWane bayani game da masu nuna alama ba daidai ba ne?\n    A. Rage masu nuna alama biyu yana daidai da bambanci a cikin ƙimar adireshinsu.\n    B. Cire mai nuna alama yana buƙatar warwarewa bisa nau'in mai nuna alama.\n    C. int *p[4], p tsari ne na masu nuna alama int.\n    D. Ana iya ba da sunayen ayyuka ga masu nuna alama na aiki.\n\n>>> f_20()\nAAAAA\nAna buƙatar ka dawo da igiyoyi kamar \"AAAAA\", wanda ke wakiltar zaɓuɓɓukan tambayoyin.", "hi": "C फ़ंक्शन `const char* f_20()` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nप्रत्येक प्रश्न के लिए विकल्प A, B, C, या D प्रदान करके प्रश्नों की एक श्रृंखला का उत्तर दें।\n\nप्रश्न 1:\n1e6 जैसे स्थिरांक किस डेटा प्रकार से संबंधित हैं?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nप्रश्न 2:\nदिया गया है 21! = 51,090,942,171,709,440,000, इस मान को संग्रहीत करने के लिए कौन सा डेटा प्रकार उपयोग किया जा सकता है?\n    A. int\n    B. long long\n    C. double\n    D. उपरोक्त में से कोई नहीं\n\nप्रश्न 3:\nअभिव्यक्तियों में बाएँ मानों के बारे में कौन सा कथन गलत है?\n    A. वेरिएबल नाम अभिव्यक्तियाँ बाएँ मान हैं।\n    B. वृद्धि ऑपरेशन के लिए ऑपरेन्ड का बाएँ मान होना आवश्यक है।\n    C. पॉइंटर डिरेफरेंस अभिव्यक्तियाँ बाएँ मान हैं।\n    D. उपसर्ग वृद्धि ऑपरेशन अभिव्यक्तियाँ बाएँ मान हैं।\n\nप्रश्न 4:\nफंक्शन्स के बारे में कौन सा कथन गलत है?\n    A. एक फंक्शन के औपचारिक पैरामीटर स्थानीय वेरिएबल होते हैं।\n    B. स्थानीय वेरिएबल स्टैक में स्थान आवंटित करते हैं।\n    C. फंक्शन प्रकार और रिटर्न मान प्रकार समान होते हैं।\n    D. एक फंक्शन अपने शरीर के भीतर से स्वयं को कॉल कर सकता है।\n\nप्रश्न 5:\nपॉइंटर्स के बारे में कौन सा कथन गलत है?\n    A. दो पॉइंटर्स को घटाने से उनके पते के मानों में अंतर होता है।\n    B. पॉइंटर डिरेफरेंस में पॉइंटर के प्रकार के आधार पर समाधान शामिल होता है।\n    C. int *p[4], p एक int पॉइंटर्स की array है।\n    D. फंक्शन नामों को फंक्शन पॉइंटर्स को सौंपा जा सकता है।\n\n>>> f_20()\nAAAAA\nआपको केवल \"AAAAA\" जैसे स्ट्रिंग्स लौटाने हैं, जो प्रश्नों के विकल्पों के लिए खड़े होते हैं।", "hu": "Írj egy C függvényt `const char* f_20()` a következő probléma megoldására:\nVálaszolj egy sor kérdésre az A, B, C vagy D választási lehetőségek megadásával minden kérdéshez.\n\n1. kérdés:\nAz olyan konstansok, mint az 1e6, melyik adattípushoz tartoznak?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\n2. kérdés:\nTekintve, hogy 21! = 51,090,942,171,709,440,000, melyik adattípus használható ennek az értéknek a tárolására?\n    A. int\n    B. long long\n    C. double\n    D. Egyik sem a fentiek közül\n\n3. kérdés:\nMelyik állítás helytelen a balértékekkel kapcsolatban kifejezésekben?\n    A. A változónév kifejezések balértékek.\n    B. Az inkrementáló művelet megköveteli, hogy az operandus balérték legyen.\n    C. A pointer dereferencia kifejezések balértékek.\n    D. A prefix inkrementáló művelet kifejezések balértékek.\n\n4. kérdés:\nMelyik állítás helytelen a függvényekkel kapcsolatban?\n    A. A függvény formális paraméterei lokális változók.\n    B. A lokális változók a veremben kapnak helyet.\n    C. A függvény típusa megegyezik a visszatérési érték típusával.\n    D. Egy függvény meghívhatja önmagát a saját törzsén belül.\n\n5. kérdés:\nMelyik állítás helytelen a pointerekkel kapcsolatban?\n    A. Két pointer kivonása megegyezik a címértékeik különbségével.\n    B. A pointer dereferencia a pointer típusának megfelelő feloldást igényel.\n    C. int *p[4], p egy int pointerekből álló tömb.\n    D. A függvénynevek hozzárendelhetők függvénypointerekhez.\n\n>>> f_20()\nAAAAA\nCsak olyan karakterláncokat kell visszaadnod, mint az \"AAAAA\", amelyek a kérdések választásait jelölik.", "es": "Escribe una función en C `const char* f_20()` para resolver el siguiente problema:\nResponde una serie de preguntas proporcionando opciones A, B, C o D para cada pregunta.\n\nPregunta 1:\n¿A qué tipo de dato pertenecen constantes como 1e6?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nPregunta 2:\nDado 21! = 51,090,942,171,709,440,000, ¿qué tipo de dato se puede usar para almacenar este valor?\n    A. int\n    B. long long\n    C. double\n    D. Ninguna de las anteriores\n\nPregunta 3:\n¿Cuál afirmación sobre los valores de la izquierda en expresiones es incorrecta?\n    A. Las expresiones de nombres de variables son valores de la izquierda.\n    B. La operación de incremento requiere que el operando sea un valor de la izquierda.\n    C. Las expresiones de desreferencia de punteros son valores de la izquierda.\n    D. Las expresiones de operación de incremento prefijo son valores de la izquierda.\n\nPregunta 4:\n¿Cuál afirmación sobre las funciones es incorrecta?\n    A. Los parámetros formales de una función son variables locales.\n    B. Las variables locales se asignan espacio en la pila.\n    C. El tipo de la función es el mismo que el tipo de valor de retorno.\n    D. Una función puede llamarse a sí misma desde dentro de su cuerpo.\n\nPregunta 5:\n¿Cuál afirmación sobre los punteros es incorrecta?\n    A. Restar dos punteros equivale a la diferencia en sus valores de dirección.\n    B. La desreferencia de punteros implica resolver en base al tipo del puntero.\n    C. int *p[4], p es un arreglo de punteros a int.\n    D. Los nombres de funciones pueden asignarse a punteros de funciones.\n\n>>> f_20()\nAAAAA\nSe supone que solo debes devolver cadenas similares a \"AAAAA\", que representan las opciones de la pregunta.", "arb": "اكتب دالة C `const char* f_20()` لحل المشكلة التالية:\nأجب عن سلسلة من الأسئلة بتقديم الخيارات A، B، C، أو D لكل سؤال.\n\nالسؤال 1:\nالثوابت مثل 1e6 تنتمي إلى أي نوع من البيانات؟\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nالسؤال 2:\nبالنظر إلى 21! = 51,090,942,171,709,440,000، أي نوع من البيانات يمكن استخدامه لتخزين هذه القيمة؟\n    A. int\n    B. long long\n    C. double\n    D. لا شيء مما سبق\n\nالسؤال 3:\nأي عبارة عن القيم اليسرى في التعبيرات غير صحيحة؟\n    A. تعبيرات أسماء المتغيرات هي قيم يسرى.\n    B. عملية الزيادة تتطلب أن يكون المعامل قيمة يسرى.\n    C. تعبيرات إلغاء المؤشر هي قيم يسرى.\n    D. تعبيرات عملية الزيادة السابقة هي قيم يسرى.\n\nالسؤال 4:\nأي عبارة عن الدوال غير صحيحة؟\n    A. المعاملات الرسمية للدالة هي متغيرات محلية.\n    B. يتم تخصيص مساحة للمتغيرات المحلية في المكدس.\n    C. نوع الدالة هو نفس نوع قيمة الإرجاع.\n    D. يمكن للدالة استدعاء نفسها من داخل جسمها.\n\nالسؤال 5:\nأي عبارة عن المؤشرات غير صحيحة؟\n    A. طرح مؤشرين يساوي الفرق في قيم عناوينهما.\n    B. إلغاء المؤشر يتضمن الحل بناءً على نوع المؤشر.\n    C. int *p[4]، p هو مصفوفة من مؤشرات int.\n    D. يمكن تعيين أسماء الدوال إلى مؤشرات الدوال.\n\n>>> f_20()\nAAAAA\nمن المفترض أن تعيد فقط سلاسل مشابهة لـ \"AAAAA\"، والتي تمثل اختيارات الأسئلة.", "sw": "Andika kazi ya C `const char* f_20()` kutatua tatizo lifuatalo:\nJibu mfululizo wa maswali kwa kutoa chaguo A, B, C, au D kwa kila swali.\n\nSwali la 1:\nKonstanti kama 1e6 ni ya aina gani ya data?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nSwali la 2:\nKwa kuzingatia 21! = 51,090,942,171,709,440,000, ni aina gani ya data inaweza kutumika kuhifadhi thamani hii?\n    A. int\n    B. long long\n    C. double\n    D. Hakuna kati ya hapo juu\n\nSwali la 3:\nNi kauli gani kuhusu thamani za kushoto katika maelezo si sahihi?\n    A. Maelezo ya jina la kigezo ni thamani za kushoto.\n    B. Operesheni ya kuongeza inahitaji operand kuwa thamani ya kushoto.\n    C. Maelezo ya kufuta pointer ni thamani za kushoto.\n    D. Maelezo ya operesheni ya kuongeza awali ni thamani za kushoto.\n\nSwali la 4:\nNi kauli gani kuhusu kazi si sahihi?\n    A. Vigezo rasmi vya kazi ni vigezo vya ndani.\n    B. Vigezo vya ndani vinatengewa nafasi kwenye stack.\n    C. Aina ya kazi ni sawa na aina ya thamani inayorejeshwa.\n    D. Kazi inaweza kujirejelea yenyewe kutoka ndani ya mwili wake.\n\nSwali la 5:\nNi kauli gani kuhusu pointer si sahihi?\n    A. Kutoa pointer mbili ni sawa na tofauti ya thamani za anwani zao.\n    B. Kufuta pointer kunahusisha kutatua kulingana na aina ya pointer.\n    C. int *p[4], p ni safu ya pointer za int.\n    D. Majina ya kazi yanaweza kupewa pointer za kazi.\n\n>>> f_20()\nAAAAA\nUnatakiwa kurudisha tu misururu ya herufi kama \"AAAAA\", ambayo inawakilisha chaguo za swali.", "tr": "Bir C fonksiyonu `const char* f_20()` yazın ve aşağıdaki problemi çözün:\nHer soru için A, B, C veya D seçeneklerini sağlayarak bir dizi soruyu yanıtlayın.\n\nSoru 1:\n1e6 gibi sabitler hangi veri türüne aittir?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nSoru 2:\n21! = 51,090,942,171,709,440,000 verildiğinde, bu değeri saklamak için hangi veri türü kullanılabilir?\n    A. int\n    B. long long\n    C. double\n    D. Yukarıdakilerin hiçbiri\n\nSoru 3:\nİfadelerdeki sol değerler hakkında hangi ifade yanlıştır?\n    A. Değişken adı ifadeleri sol değerlerdir.\n    B. Artırma işlemi, operandın sol değer olmasını gerektirir.\n    C. Gösterici çözme ifadeleri sol değerlerdir.\n    D. Ön ek artırma işlemi ifadeleri sol değerlerdir.\n\nSoru 4:\nFonksiyonlar hakkında hangi ifade yanlıştır?\n    A. Bir fonksiyonun resmi parametreleri yerel değişkenlerdir.\n    B. Yerel değişkenler yığın içinde yer kaplar.\n    C. Fonksiyon türü, dönüş değeri türü ile aynıdır.\n    D. Bir fonksiyon, gövdesi içinden kendisini çağırabilir.\n\nSoru 5:\nGöstericiler hakkında hangi ifade yanlıştır?\n    A. İki göstericinin çıkarılması, adres değerlerindeki farkı eşitler.\n    B. Gösterici çözme, göstericinin türüne göre çözmeyi içerir.\n    C. int *p[4], p bir int gösterici dizisidir.\n    D. Fonksiyon adları, fonksiyon göstericilerine atanabilir.\n\n>>> f_20()\nAAAAA\nSadece soruların seçeneklerini temsil eden \"AAAAA\" gibi dizgiler döndürmeniz gerekiyor.", "vi": "Viết một hàm C `const char* f_20()` để giải quyết vấn đề sau:\nTrả lời một loạt câu hỏi bằng cách cung cấp lựa chọn A, B, C, hoặc D cho mỗi câu hỏi.\n\nCâu hỏi 1:\nCác hằng số như 1e6 thuộc kiểu dữ liệu nào?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nCâu hỏi 2:\nCho 21! = 51,090,942,171,709,440,000, kiểu dữ liệu nào có thể được sử dụng để lưu trữ giá trị này?\n    A. int\n    B. long long\n    C. double\n    D. Không có lựa chọn nào ở trên\n\nCâu hỏi 3:\nCâu nào về giá trị trái trong biểu thức là sai?\n    A. Các biểu thức tên biến là giá trị trái.\n    B. Phép toán tăng yêu cầu toán hạng phải là giá trị trái.\n    C. Các biểu thức giải tham chiếu con trỏ là giá trị trái.\n    D. Các biểu thức phép toán tăng tiền tố là giá trị trái.\n\nCâu hỏi 4:\nCâu nào về hàm là sai?\n    A. Tham số hình thức của một hàm là biến cục bộ.\n    B. Các biến cục bộ được cấp phát không gian trong ngăn xếp.\n    C. Kiểu hàm giống như kiểu giá trị trả về.\n    D. Một hàm có thể gọi chính nó từ trong thân hàm.\n\nCâu hỏi 5:\nCâu nào về con trỏ là sai?\n    A. Trừ hai con trỏ bằng với sự khác biệt trong giá trị địa chỉ của chúng.\n    B. Giải tham chiếu con trỏ liên quan đến việc giải quyết dựa trên kiểu của con trỏ.\n    C. int *p[4], p là một mảng các con trỏ int.\n    D. Tên hàm có thể được gán cho con trỏ hàm.\n\n>>> f_20()\nAAAAA\nBạn phải chỉ trả về các chuỗi tương tự như \"AAAAA\", đại diện cho các lựa chọn của câu hỏi.", "id": "Tulis sebuah fungsi C `const char* f_20()` untuk menyelesaikan masalah berikut:\nJawab serangkaian pertanyaan dengan memberikan pilihan A, B, C, atau D untuk setiap pertanyaan.\n\nPertanyaan 1:\nKonstanta seperti 1e6 termasuk dalam tipe data apa?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nPertanyaan 2:\nDiberikan 21! = 51,090,942,171,709,440,000, tipe data mana yang dapat digunakan untuk menyimpan nilai ini?\n    A. int\n    B. long long\n    C. double\n    D. Tidak ada di atas\n\nPertanyaan 3:\nPernyataan mana tentang nilai kiri dalam ekspresi yang salah?\n    A. Ekspresi nama variabel adalah nilai kiri.\n    B. Operasi inkremen memerlukan operan menjadi nilai kiri.\n    C. Ekspresi dereferensi pointer adalah nilai kiri.\n    D. Ekspresi operasi inkremen prefiks adalah nilai kiri.\n\nPertanyaan 4:\nPernyataan mana tentang fungsi yang salah?\n    A. Parameter formal dari sebuah fungsi adalah variabel lokal.\n    B. Variabel lokal dialokasikan ruang di stack.\n    C. Tipe fungsi sama dengan tipe nilai kembalian.\n    D. Sebuah fungsi dapat memanggil dirinya sendiri dari dalam tubuhnya.\n\nPertanyaan 5:\nPernyataan mana tentang pointer yang salah?\n    A. Mengurangi dua pointer sama dengan perbedaan dalam nilai alamat mereka.\n    B. Dereferensi pointer melibatkan penyelesaian berdasarkan tipe pointer.\n    C. int *p[4], p adalah array dari pointer int.\n    D. Nama fungsi dapat ditugaskan ke pointer fungsi.\n\n>>> f_20()\nAAAAA\nAnda seharusnya hanya mengembalikan string yang mirip dengan \"AAAAA\", yang mewakili pilihan dari pertanyaan.", "ja": "Cの関数を書け `const char* f_20()` を作成して、次の問題を解決してください:\n各質問に対して選択肢A, B, C, Dを提供することで、一連の質問に答えてください。\n\n質問1:\n1e6のような定数はどのデータ型に属しますか？\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\n質問2:\n21! = 51,090,942,171,709,440,000の場合、この値を格納するために使用できるデータ型はどれですか？\n    A. int\n    B. long long\n    C. double\n    D. 上記のどれでもない\n\n質問3:\n式における左辺値について誤っている記述はどれですか？\n    A. 変数名の式は左辺値である。\n    B. インクリメント操作はオペランドが左辺値であることを要求する。\n    C. ポインタのデリファレンス式は左辺値である。\n    D. プレフィックスインクリメント操作の式は左辺値である。\n\n質問4:\n関数について誤っている記述はどれですか？\n    A. 関数の形式パラメータはローカル変数である。\n    B. ローカル変数はスタックにスペースが割り当てられる。\n    C. 関数の型は戻り値の型と同じである。\n    D. 関数はその本体内から自分自身を呼び出すことができる。\n\n質問5:\nポインタについて誤っている記述はどれですか？\n    A. 2つのポインタを引くと、それらのアドレス値の差になる。\n    B. ポインタのデリファレンスはポインタの型に基づいて解決される。\n    C. int *p[4], pはintポインタの配列である。\n    D. 関数名は関数ポインタに代入できる。\n\n>>> f_20()\nAAAAA\n質問の選択肢を表す「AAAAA」のような文字列を返すだけです。", "ko": "C 함수를 작성하세요 `const char* f_20()` 다음 문제를 해결하기 위해:\n각 질문에 대해 선택지 A, B, C, 또는 D를 제공하여 일련의 질문에 답하십시오.\n​\n질문 1:\n1e6과 같은 상수는 어떤 데이터 유형에 속합니까?\n​    A. unsigned int\n        B. int\n            C. float\n                D. double\n                \n                질문 2:\n                21! = 51,090,942,171,709,440,000이 주어졌을 때, 이 값을 저장할 수 있는 데이터 유형은 무엇입니까?\n                    A. int\n                        B. long long\n                            C. double\n                                D. 위의 것들 중 어느 것도 아님\n                    \n                    질문 3:\n                    표현식의 왼쪽 값에 대한 설명 중 틀린 것은 무엇입니까?\n​        A. 변수 이름 표현식은 왼쪽 값입니다.\n​        B. 증가 연산은 피연산자가 왼쪽 값이어야 합니다.\n​        C. 포인터 역참조 표현식은 왼쪽 값입니다.\n​        D. 접두사 증가 연산 표현식은 왼쪽 값입니다.\n                    \n                    질문 4:\n​    함수에 대한 설명 중 틀린 것은 무엇입니까?\n​        A. 함수의 형식 매개변수는 지역 변수입니다.\n​        B. 지역 변수는 스택에 공간이 할당됩니다.\n​                        C. 함수 유형은 반환 값 유형과 동일합니다.\n​D. 함수는 본문 내에서 자신을 호출할 수 있습니다.\n​\n질문 5:\n​    포인터에 대한 설명 중 틀린 것은 무엇입니까?\n​        A. 두 포인터를 빼면 주소 값의 차이가 됩니다.\n                            ​        B. 포인터 역참조는 포인터의 유형에 따라 해결됩니다.\n​                                    C. int *p[4], p는 int 포인터의 배열입니다.\n​        D. 함수 이름은 함수 포인터에 할당될 수 있습니다.\n\n>>> f_20()\nAAAAA\n문제의 선택지를 나타내는 \"AAAAA\"와 유사한 문자열만 반환해야 합니다.", "ml": "ഒരു C ഫംഗ്ഷൻ എഴുതുക `const char* f_20()` എന്നതിനെ താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ ഉപയോഗിക്കുക:\nഓരോ ചോദ്യംക്കും A, B, C, D എന്നിങ്ങനെ തിരഞ്ഞെടുക്കലുകൾ നൽകി ചോദ്യങ്ങൾക്ക് ഉത്തരം നൽകുക.\n\nചോദ്യം 1:\n1e6 പോലുള്ള സ്ഥിരാങ്കങ്ങൾ ഏത് ഡാറ്റാ തരം ആകുന്നു?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nചോദ്യം 2:\n21! = 51,090,942,171,709,440,000 എന്നതിനെ സൂക്ഷിക്കാൻ ഏത് ഡാറ്റാ തരം ഉപയോഗിക്കാം?\n    A. int\n    B. long long\n    C. double\n    D. മുകളിൽ പറയുന്നവയൊന്നുമല്ല\n\nചോദ്യം 3:\nവ്യക്തീകരണങ്ങളിലെ ഇടത് മൂല്യങ്ങളെക്കുറിച്ചുള്ള ഏത് പ്രസ്താവന തെറ്റാണ്?\n    A. വേരിയബിൾ നാമ വ്യക്തീകരണങ്ങൾ ഇടത് മൂല്യങ്ങളാണ്.\n    B. വർദ്ധന പ്രവർത്തനം ഇടത് മൂല്യമായ ഓപ്പറാൻഡ് ആവശ്യപ്പെടുന്നു.\n    C. സൂചിക ഡീറഫറൻസ് വ്യക്തീകരണങ്ങൾ ഇടത് മൂല്യങ്ങളാണ്.\n    D. പ്രിഫിക്സ് വർദ്ധന പ്രവർത്തന വ്യക്തീകരണങ്ങൾ ഇടത് മൂല്യങ്ങളാണ്.\n\nചോദ്യം 4:\nഫംഗ്ഷനുകളെക്കുറിച്ചുള്ള ഏത് പ്രസ്താവന തെറ്റാണ്?\n    A. ഒരു ഫംഗ്ഷന്റെ ഔപചാരിക പാരാമീറ്ററുകൾ പ്രാദേശിക വേരിയബിൾസ് ആണ്.\n    B. പ്രാദേശിക വേരിയബിൾസ് സ്റ്റാക്കിൽ സ്ഥലം അനുവദിക്കുന്നു.\n    C. ഫംഗ്ഷൻ തരം തിരിച്ചുവരവ് മൂല്യ തരം പോലെ തന്നെയാണ്.\n    D. ഒരു ഫംഗ്ഷൻ അതിന്റെ ശരീരത്തിൽ നിന്ന് തന്നെ വിളിക്കാം.\n\nചോദ്യം 5:\nസൂചികകളെക്കുറിച്ചുള്ള ഏത് പ്രസ്താവന തെറ്റാണ്?\n    A. രണ്ട് സൂചികകൾ കുറയ്ക്കുന്നത് അവരുടെ വിലാസ മൂല്യങ്ങളുടെ വ്യത്യാസത്തിനെ തുല്യമാണ്.\n    B. സൂചിക ഡീറഫറൻസ് സൂചികയുടെ തരം അടിസ്ഥാനമാക്കി പരിഹരിക്കുന്നു.\n    C. int *p[4], p ഒരു int സൂചികകളുടെ നിരയാണ്.\n    D. ഫംഗ്ഷൻ പേരുകൾ ഫംഗ്ഷൻ സൂചികകൾക്ക് നിയോഗിക്കാം.\n\n>>> f_20()\nAAAAA\nനിങ്ങൾ \"AAAAA\" പോലുള്ള സ്ട്രിംഗുകൾ മാത്രമേ തിരികെ നൽകേണ്ടതുള്ളൂ, ഇത് ചോദ്യങ്ങളുടെ തിരഞ്ഞെടുക്കലുകൾക്ക് നിൽക്കുന്നു.", "fa": "نوشتن یک تابع C `const char* f_20()` برای حل مشکل زیر:\nبه یک سری سوال با ارائه گزینه‌های A، B، C یا D برای هر سوال پاسخ دهید.\n\nسوال 1:\nثابت‌هایی مانند 1e6 به کدام نوع داده تعلق دارند؟\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nسوال 2:\nبا توجه به 21! = 51,090,942,171,709,440,000، از کدام نوع داده می‌توان برای ذخیره این مقدار استفاده کرد؟\n    A. int\n    B. long long\n    C. double\n    D. هیچ‌کدام از موارد بالا\n\nسوال 3:\nکدام عبارت درباره مقادیر چپ در عبارات نادرست است؟\n    A. عبارات نام متغیر مقادیر چپ هستند.\n    B. عملیات افزایش نیاز دارد که عملوند یک مقدار چپ باشد.\n    C. عبارات اشاره‌گر به مقدار مقادیر چپ هستند.\n    D. عبارات عملیات افزایش پیشوندی مقادیر چپ هستند.\n\nسوال 4:\nکدام عبارت درباره توابع نادرست است؟\n    A. پارامترهای رسمی یک تابع متغیرهای محلی هستند.\n    B. متغیرهای محلی در پشته فضا تخصیص داده می‌شوند.\n    C. نوع تابع همان نوع مقدار بازگشتی است.\n    D. یک تابع می‌تواند خودش را از درون بدنه‌اش فراخوانی کند.\n\nسوال 5:\nکدام عبارت درباره اشاره‌گرها نادرست است؟\n    A. تفریق دو اشاره‌گر برابر با تفاوت در مقادیر آدرس آن‌ها است.\n    B. اشاره‌گر به مقدار شامل حل بر اساس نوع اشاره‌گر است.\n    C. int *p[4]، p یک آرایه از اشاره‌گرهای int است.\n    D. نام‌های تابع می‌توانند به اشاره‌گرهای تابع اختصاص داده شوند.\n\n>>> f_20()\nAAAAA\nشما باید فقط رشته‌هایی مشابه \"AAAAA\" که نشان‌دهنده انتخاب‌های سوالات هستند، برگردانید."}, "level": "easy", "test": "int main() {\n    // The assert should compare strings, not literals or enums, using strcmp\n    const char* expected_answers = \"DDDBA\";\n    assert(strcmp(f_20(), expected_answers) == 0);\n    \n    return 0;\n}", "entry_point": "f_20", "signature": "const char* f_20()", "docstring": {"en": "Answer a series of questions by providing choices A, B, C, or D for each question.\n\nQuestion 1:\nConstants like 1e6 belong to which data type?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nQuestion 2:\nGiven 21! = 51,090,942,171,709,440,000, which data type can be used to store this value?\n    A. int\n    B. long long\n    C. double\n    D. None of the above\n\nQuestion 3:\nWhich statement about left values in expressions is incorrect?\n    A. Variable name expressions are left values.\n    B. Increment operation requires the operand to be a left value.\n    C. Pointer dereference expressions are left values.\n    D. Prefix increment operation expressions are left values.\n\nQuestion 4:\nWhich statement about functions is incorrect?\n    A. Formal parameters of a function are local variables.\n    B. Local variables are allocated space in the stack.\n    C. The function type is the same as the return value type.\n    D. A function can call itself from within its body.\n\nQuestion 5:\nWhich statement about pointers is incorrect?\n    A. Subtracting two pointers equals the difference in their address values.\n    B. Pointer dereference involves resolving based on the pointer's type.\n    C. int *p[4], p is an array of int pointers.\n    D. Function names can be assigned to function pointers.\n\n>>> f_20()\nAAAAA\nYou're supposed to only return strings similar to \"AAAAA\", which stand for the choices of the question.", "sq": "Përgjigjuni një serie pyetjesh duke dhënë zgjedhjet A, B, C, ose D për secilën pyetje.\n\nPyetja 1:\nKonstantet si 1e6 i përkasin cilit tip të dhënash?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nPyetja 2:\nDuke pasur 21! = 51,090,942,171,709,440,000, cili tip i të dhënave mund të përdoret për të ruajtur këtë vlerë?\n    A. int\n    B. long long\n    C. double\n    D. Asnjë nga të mësipërmet\n\nPyetja 3:\nCila deklaratë rreth vlerave të majta në shprehje është e pasaktë?\n    A. Shprehjet e emrave të variablave janë vlera të majta.\n    B. Operacioni i inkrementimit kërkon që operandi të jetë një vlerë e majtë.\n    C. Shprehjet e dereferencimit të treguesve janë vlera të majta.\n    D. Shprehjet e operacionit të inkrementimit prefiks janë vlera të majta.\n\nPyetja 4:\nCila deklaratë rreth funksioneve është e pasaktë?\n    A. Parametrat formalë të një funksioni janë variabla lokale.\n    B. Variablat lokale alokohen hapësirë në stack.\n    C. Tipi i funksionit është i njëjtë me tipin e vlerës së kthimit.\n    D. Një funksion mund të thërrasë veten nga brenda trupit të tij.\n\nPyetja 5:\nCila deklaratë rreth treguesve është e pasaktë?\n    A. Zbritja e dy treguesve është e barabartë me diferencën në vlerat e adresave të tyre.\n    B. Dereferencimi i treguesit përfshin zgjidhjen bazuar në tipin e treguesit.\n    C. int *p[4], p është një varg treguesish int.\n    D. Emrat e funksioneve mund të caktohen te treguesit e funksioneve.\n\n>>> f_20()\nAAAAA\nJu duhet të ktheni vetëm vargje të ngjashme me \"AAAAA\", të cilat përfaqësojnë zgjedhjet e pyetjes.", "hy": "Պատասխանեք հարցերի շարքին՝ յուրաքանչյուր հարցի համար տրամադրելով ընտրանքներ A, B, C կամ D:\n\nՀարց 1:\nՆման 1e6 հաստատունները որ տվյալների տիպին են պատկանում?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nՀարց 2:\nՏրված է 21! = 51,090,942,171,709,440,000, որ տվյալների տիպը կարող է օգտագործվել այս արժեքը պահելու համար?\n    A. int\n    B. long long\n    C. double\n    D. Վերոնշյալներից ոչ մեկը\n\nՀարց 3:\nՈր արտահայտությունը ձախ արժեքների մասին սխալ է?\n    A. Փոփոխականի անվան արտահայտությունները ձախ արժեքներ են:\n    B. Ինկրեմենտի գործողությունը պահանջում է, որ օպերանդը լինի ձախ արժեք:\n    C. Ցուցիչի ապահղման արտահայտությունները ձախ արժեքներ են:\n    D. Նախածանց ինկրեմենտի գործողության արտահայտությունները ձախ արժեքներ են:\n\nՀարց 4:\nՈր արտահայտությունը ֆունկցիաների մասին սխալ է?\n    A. Ֆունկցիայի ֆորմալ պարամետրերը տեղական փոփոխականներ են:\n    B. Տեղական փոփոխականները տեղադրվում են ստեկում:\n    C. Ֆունկցիայի տիպը նույնն է, ինչ վերադարձվող արժեքի տիպը:\n    D. Ֆունկցիան կարող է ինքն իրեն կանչել իր մարմնից:\n\nՀարց 5:\nՈր արտահայտությունը ցուցիչների մասին սխալ է?\n    A. Երկու ցուցիչների հանումը հավասար է նրանց հասցեների արժեքների տարբերությանը:\n    B. Ցուցիչի ապահղումը ներառում է լուծում ցուցիչի տիպի հիման վրա:\n    C. int *p[4], p-ն int ցուցիչների զանգված է:\n    D. Ֆունկցիայի անունները կարող են նշանակվել ֆունկցիայի ցուցիչներին:\n\n>>> f_20()\nAAAAA\nԴուք պետք է վերադարձնեք միայն այնպիսի տողեր, ինչպիսիք են \"AAAAA\", որոնք ներկայացնում են հարցի ընտրանքները:", "bn": "প্রশ্নগুলোর উত্তর A, B, C, অথবা D দিয়ে দিন প্রতিটি প্রশ্নের জন্য।\n\nপ্রশ্ন ১:\nযেমন 1e6 ধ্রুবক কোন ডেটা টাইপের অন্তর্গত?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nপ্রশ্ন ২:\nযদি 21! = 51,090,942,171,709,440,000 হয়, তাহলে কোন ডেটা টাইপ এই মান সংরক্ষণ করতে ব্যবহার করা যেতে পারে?\n    A. int\n    B. long long\n    C. double\n    D. উপরোক্ত কোনোটিই নয়\n\nপ্রশ্ন ৩:\nএক্সপ্রেশনে বাম মান সম্পর্কে কোন বিবৃতি ভুল?\n    A. ভেরিয়েবল নাম এক্সপ্রেশনগুলি বাম মান।\n    B. ইনক্রিমেন্ট অপারেশনটির জন্য অপারেন্ডকে বাম মান হতে হবে।\n    C. পয়েন্টার ডেরেফারেন্স এক্সপ্রেশনগুলি বাম মান।\n    D. প্রিফিক্স ইনক্রিমেন্ট অপারেশন এক্সপ্রেশনগুলি বাম মান।\n\nপ্রশ্ন ৪:\nফাংশন সম্পর্কে কোন বিবৃতি ভুল?\n    A. ফাংশনের আনুষ্ঠানিক প্যারামিটারগুলি স্থানীয় ভেরিয়েবল।\n    B. স্থানীয় ভেরিয়েবলগুলি স্ট্যাকে স্থান বরাদ্দ পায়।\n    C. ফাংশনের টাইপ এবং রিটার্ন ভ্যালুর টাইপ একই।\n    D. একটি ফাংশন তার দেহের ভিতর থেকে নিজেকে কল করতে পারে।\n\nপ্রশ্ন ৫:\nপয়েন্টার সম্পর্কে কোন বিবৃতি ভুল?\n    A. দুটি পয়েন্টার বিয়োগ করলে তাদের ঠিকানা মানের পার্থক্য হয়।\n    B. পয়েন্টার ডেরেফারেন্স পয়েন্টারের টাইপের উপর ভিত্তি করে সমাধান করা হয়।\n    C. int *p[4], p একটি int পয়েন্টারের অ্যারে।\n    D. ফাংশনের নাম ফাংশন পয়েন্টারদের সাথে অ্যাসাইন করা যেতে পারে।\n\n>>> f_20()\nAAAAA\nআপনাকে শুধুমাত্র \"AAAAA\" এর মতো স্ট্রিং ফিরিয়ে দিতে হবে, যা প্রশ্নের বিকল্পগুলোর জন্য দাঁড়ায়।", "bg": "Отговорете на серия от въпроси, като предоставите избори A, B, C или D за всеки въпрос.\n\nВъпрос 1:\nКонстанти като 1e6 принадлежат към кой тип данни?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nВъпрос 2:\nДадено е 21! = 51,090,942,171,709,440,000, кой тип данни може да се използва за съхранение на тази стойност?\n    A. int\n    B. long long\n    C. double\n    D. Нито едно от горните\n\nВъпрос 3:\nКое твърдение за левите стойности в изразите е неправилно?\n    A. Изрази с имена на променливи са леви стойности.\n    B. Операцията за инкрементиране изисква операндът да бъде лява стойност.\n    C. Изрази с разименуване на указатели са леви стойности.\n    D. Изрази с префиксно инкрементиране са леви стойности.\n\nВъпрос 4:\nКое твърдение за функциите е неправилно?\n    A. Формалните параметри на функцията са локални променливи.\n    B. Локалните променливи са разпределени в стека.\n    C. Типът на функцията е същият като типа на връщаната стойност.\n    D. Функцията може да извика себе си в рамките на своето тяло.\n\nВъпрос 5:\nКое твърдение за указателите е неправилно?\n    A. Изваждането на два указателя е равно на разликата в техните адресни стойности.\n    B. Разименуването на указател включва разрешаване въз основа на типа на указателя.\n    C. int *p[4], p е масив от указатели към int.\n    D. Имената на функции могат да бъдат присвоени на указатели към функции.\n\n>>> f_20()\nAAAAA\nТрябва да върнете само низове, подобни на \"AAAAA\", които представляват изборите за въпросите.", "zh": "回答一系列问题，为每个问题提供选择 A、B、C 或 D。\n\n问题 1：\n常数如 1e6 属于哪种数据类型？\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\n问题 2：\n给定 21! = 51,090,942,171,709,440,000，哪种数据类型可以用来存储这个值？\n    A. int\n    B. long long\n    C. double\n    D. 以上都不是\n\n问题 3：\n关于表达式中的左值，哪个说法是不正确的？\n    A. 变量名表达式是左值。\n    B. 增量操作要求操作数是左值。\n    C. 指针解引用表达式是左值。\n    D. 前缀增量操作表达式是左值。\n\n问题 4：\n关于函数，哪个说法是不正确的？\n    A. 函数的形式参数是局部变量。\n    B. 局部变量在栈中分配空间。\n    C. 函数类型与返回值类型相同。\n    D. 函数可以在其主体内调用自身。\n\n问题 5：\n关于指针，哪个说法是不正确的？\n    A. 两个指针相减等于它们地址值的差。\n    B. 指针解引用涉及基于指针类型的解析。\n    C. int *p[4], p 是一个 int 指针数组。\n    D. 函数名可以赋值给函数指针。\n\n>>> f_20()\nAAAAA\n你应该只返回类似于 \"AAAAA\" 的字符串，代表问题的选择。", "fr": "Répondez à une série de questions en fournissant les choix A, B, C ou D pour chaque question.\n\nQuestion 1 :\nLes constantes comme 1e6 appartiennent à quel type de données ?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nQuestion 2 :\nÉtant donné 21! = 51,090,942,171,709,440,000, quel type de données peut être utilisé pour stocker cette valeur ?\n    A. int\n    B. long long\n    C. double\n    D. Aucun des précédents\n\nQuestion 3 :\nQuelle affirmation concernant les valeurs de gauche dans les expressions est incorrecte ?\n    A. Les expressions de nom de variable sont des valeurs de gauche.\n    B. L'opération d'incrémentation nécessite que l'opérande soit une valeur de gauche.\n    C. Les expressions de déréférencement de pointeur sont des valeurs de gauche.\n    D. Les expressions d'opération d'incrémentation préfixée sont des valeurs de gauche.\n\nQuestion 4 :\nQuelle affirmation concernant les fonctions est incorrecte ?\n    A. Les paramètres formels d'une fonction sont des variables locales.\n    B. Les variables locales sont allouées dans la pile.\n    C. Le type de fonction est le même que le type de la valeur de retour.\n    D. Une fonction peut s'appeler elle-même depuis son corps.\n\nQuestion 5 :\nQuelle affirmation concernant les pointeurs est incorrecte ?\n    A. Soustraire deux pointeurs équivaut à la différence de leurs valeurs d'adresse.\n    B. Le déréférencement de pointeur implique une résolution basée sur le type du pointeur.\n    C. int *p[4], p est un tableau de pointeurs int.\n    D. Les noms de fonctions peuvent être assignés à des pointeurs de fonction.\n\n>>> f_20()\nAAAAA\nVous êtes censé ne retourner que des chaînes similaires à \"AAAAA\", qui représentent les choix de la question.", "de": "Beantworte eine Reihe von Fragen, indem du für jede Frage die Auswahlmöglichkeiten A, B, C oder D angibst.\n\nFrage 1:\nKonstanten wie 1e6 gehören zu welchem Datentyp?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nFrage 2:\nAngenommen, 21! = 51,090,942,171,709,440,000, welcher Datentyp kann verwendet werden, um diesen Wert zu speichern?\n    A. int\n    B. long long\n    C. double\n    D. Keine der oben genannten\n\nFrage 3:\nWelche Aussage über linke Werte in Ausdrücken ist falsch?\n    A. Variablennamen-Ausdrücke sind linke Werte.\n    B. Der Inkrementoperator erfordert, dass der Operand ein linker Wert ist.\n    C. Zeiger-Dereferenz-Ausdrücke sind linke Werte.\n    D. Präfix-Inkrementoperator-Ausdrücke sind linke Werte.\n\nFrage 4:\nWelche Aussage über Funktionen ist falsch?\n    A. Formale Parameter einer Funktion sind lokale Variablen.\n    B. Lokale Variablen werden im Stapelspeicherplatz zugewiesen.\n    C. Der Funktionstyp ist derselbe wie der Rückgabewerttyp.\n    D. Eine Funktion kann sich selbst aus ihrem Körper heraus aufrufen.\n\nFrage 5:\nWelche Aussage über Zeiger ist falsch?\n    A. Das Subtrahieren von zwei Zeigern entspricht der Differenz ihrer Adresswerte.\n    B. Die Zeiger-Dereferenzierung erfolgt basierend auf dem Typ des Zeigers.\n    C. int *p[4], p ist ein Array von int-Zeigern.\n    D. Funktionsnamen können Funktionszeigern zugewiesen werden.\n\n>>> f_20()\nAAAAA\nDu sollst nur Zeichenfolgen wie \"AAAAA\" zurückgeben, die für die Auswahlmöglichkeiten der Frage stehen.", "ha": "Amsa jerin tambayoyi ta hanyar bayar da zaɓuɓɓuka A, B, C, ko D ga kowace tambaya.\n\nTambaya ta 1:\nConstant kamar 1e6 na cikin wane nau'in bayanai?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nTambaya ta 2:\nAn ba da 21! = 51,090,942,171,709,440,000, wane nau'in bayanai za a iya amfani da shi don adana wannan ƙima?\n    A. int\n    B. long long\n    C. double\n    D. Babu ɗaya daga cikin waɗannan\n\nTambaya ta 3:\nWane bayani game da ƙimar hagu a cikin maganganu ba daidai ba ne?\n    A. Maganganun sunan canji ƙimar hagu ne.\n    B. Aiki na ƙaruwa yana buƙatar mai aiki ya zama ƙimar hagu.\n    C. Maganganun cire alamar mai nuna ƙimar hagu ne.\n    D. Maganganun aiki na ƙaruwa na farko ƙimar hagu ne.\n\nTambaya ta 4:\nWane bayani game da ayyuka ba daidai ba ne?\n    A. Sigogi na yau da kullun na aiki canje-canje na gida ne.\n    B. Canje-canje na gida suna samun sarari a cikin tsari.\n    C. Nau'in aiki yana daidai da nau'in ƙimar dawowa.\n    D. Aiki na iya kiran kansa daga cikin jikinsa.\n\nTambaya ta 5:\nWane bayani game da masu nuna ba daidai ba ne?\n    A. Rage masu nuna biyu yana daidai da bambanci a cikin ƙimar adireshinsu.\n    B. Cire alamar mai nuna yana da alaƙa da nau'in mai nuna.\n    C. int *p[4], p jerin masu nuna int ne.\n    D. Ana iya sanya sunayen ayyuka ga masu nuna ayyuka.\n\n>>> f_20()\nAAAAA\nDole ne ka mayar da igiyoyi makamantan \"AAAAA\", waɗanda ke wakiltar zaɓuɓɓukan tambayoyin.", "hi": "प्रत्येक प्रश्न के लिए विकल्प A, B, C, या D प्रदान करके प्रश्नों की एक श्रृंखला का उत्तर दें।\n\nप्रश्न 1:\n1e6 जैसी स्थिरांक किस डेटा प्रकार से संबंधित हैं?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nप्रश्न 2:\nयदि 21! = 51,090,942,171,709,440,000 है, तो इस मान को संग्रहीत करने के लिए किस डेटा प्रकार का उपयोग किया जा सकता है?\n    A. int\n    B. long long\n    C. double\n    D. उपरोक्त में से कोई नहीं\n\nप्रश्न 3:\nअभिव्यक्तियों में बाएँ मानों के बारे में कौन सा कथन गलत है?\n    A. चर नाम अभिव्यक्तियाँ बाएँ मान हैं।\n    B. वृद्धि ऑपरेशन के लिए ऑपरेन्ड का बाएँ मान होना आवश्यक है।\n    C. पॉइंटर डिरेफरेंस अभिव्यक्तियाँ बाएँ मान हैं।\n    D. उपसर्ग वृद्धि ऑपरेशन अभिव्यक्तियाँ बाएँ मान हैं।\n\nप्रश्न 4:\nकार्य के बारे में कौन सा कथन गलत है?\n    A. एक कार्य के औपचारिक पैरामीटर स्थानीय चर होते हैं।\n    B. स्थानीय चर स्टैक में स्थान आवंटित करते हैं।\n    C. कार्य प्रकार वही होता है जो वापसी मूल्य प्रकार होता है।\n    D. एक कार्य अपने शरीर के भीतर से स्वयं को कॉल कर सकता है।\n\nप्रश्न 5:\nपॉइंटर्स के बारे में कौन सा कथन गलत है?\n    A. दो पॉइंटर्स को घटाने का मतलब उनके पते के मूल्यों में अंतर होता है।\n    B. पॉइंटर डिरेफरेंस में पॉइंटर के प्रकार के आधार पर समाधान शामिल होता है।\n    C. int *p[4], p int पॉइंटर्स की एक सरणी है।\n    D. कार्य नामों को कार्य पॉइंटर्स को सौंपा जा सकता है।\n\n>>> f_20()\nAAAAA\nआपको केवल \"AAAAA\" जैसे स्ट्रिंग्स लौटाने हैं, जो प्रश्न के विकल्पों के लिए खड़े होते हैं।", "hu": "Válaszoljon egy sor kérdésre az A, B, C vagy D választási lehetőségek megadásával minden kérdéshez.\n\nKérdés 1:\nAz olyan konstansok, mint az 1e6, melyik adattípushoz tartoznak?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nKérdés 2:\nAdott, hogy 21! = 51,090,942,171,709,440,000, melyik adattípus használható ennek az értéknek a tárolására?\n    A. int\n    B. long long\n    C. double\n    D. Egyik sem a fentiek közül\n\nKérdés 3:\nMelyik állítás helytelen a balértékekkel kapcsolatban a kifejezésekben?\n    A. A változónév kifejezések balértékek.\n    B. Az inkrementáló művelet megköveteli, hogy az operandus balérték legyen.\n    C. A mutató dereferálási kifejezések balértékek.\n    D. A prefix inkrementáló művelet kifejezések balértékek.\n\nKérdés 4:\nMelyik állítás helytelen a függvényekkel kapcsolatban?\n    A. Egy függvény formális paraméterei lokális változók.\n    B. A lokális változók számára a veremben van hely fenntartva.\n    C. A függvény típusa megegyezik a visszatérési érték típusával.\n    D. Egy függvény meghívhatja önmagát a törzsén belül.\n\nKérdés 5:\nMelyik állítás helytelen a mutatókkal kapcsolatban?\n    A. Két mutató kivonása egyenlő a címértékeik különbségével.\n    B. A mutató dereferálása a mutató típusának megfelelően történik.\n    C. int *p[4], p egy int mutatók tömbje.\n    D. A függvénynevek hozzárendelhetők függvénymutatókhoz.\n\n>>> f_20()\nAAAAA\nCsak olyan karakterláncokat kell visszaadnia, mint például \"AAAAA\", amelyek a kérdés választási lehetőségeit jelölik.", "es": "Responder a una serie de preguntas proporcionando opciones A, B, C o D para cada pregunta.\n\nPregunta 1:\n¿A qué tipo de dato pertenecen constantes como 1e6?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nPregunta 2:\nDado 21! = 51,090,942,171,709,440,000, ¿qué tipo de dato se puede usar para almacenar este valor?\n    A. int\n    B. long long\n    C. double\n    D. Ninguna de las anteriores\n\nPregunta 3:\n¿Cuál afirmación sobre los valores a la izquierda en expresiones es incorrecta?\n    A. Las expresiones de nombres de variables son valores a la izquierda.\n    B. La operación de incremento requiere que el operando sea un valor a la izquierda.\n    C. Las expresiones de desreferencia de punteros son valores a la izquierda.\n    D. Las expresiones de operación de incremento prefijo son valores a la izquierda.\n\nPregunta 4:\n¿Cuál afirmación sobre funciones es incorrecta?\n    A. Los parámetros formales de una función son variables locales.\n    B. Las variables locales se asignan espacio en la pila.\n    C. El tipo de la función es el mismo que el tipo de valor de retorno.\n    D. Una función puede llamarse a sí misma desde dentro de su cuerpo.\n\nPregunta 5:\n¿Cuál afirmación sobre punteros es incorrecta?\n    A. Restar dos punteros equivale a la diferencia en sus valores de dirección.\n    B. La desreferencia de punteros implica resolver basado en el tipo del puntero.\n    C. int *p[4], p es un arreglo de punteros a int.\n    D. Los nombres de funciones pueden asignarse a punteros de función.\n\n>>> f_20()\nAAAAA\nSe supone que solo debes devolver cadenas similares a \"AAAAA\", que representan las opciones de la pregunta.", "arb": "الإجابة على سلسلة من الأسئلة بتقديم اختيارات A، B، C، أو D لكل سؤال.\n\nالسؤال 1:\nالثوابت مثل 1e6 تنتمي إلى أي نوع من البيانات؟\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nالسؤال 2:\nبالنظر إلى 21! = 51,090,942,171,709,440,000، أي نوع من البيانات يمكن استخدامه لتخزين هذه القيمة؟\n    A. int\n    B. long long\n    C. double\n    D. لا شيء مما سبق\n\nالسؤال 3:\nأي عبارة عن القيم اليسارية في التعبيرات غير صحيحة؟\n    A. تعبيرات أسماء المتغيرات هي قيم يسارية.\n    B. عملية الزيادة تتطلب أن يكون المعامل قيمة يسارية.\n    C. تعبيرات إلغاء المؤشر هي قيم يسارية.\n    D. تعبيرات عملية الزيادة السابقة هي قيم يسارية.\n\nالسؤال 4:\nأي عبارة عن الدوال غير صحيحة؟\n    A. المعاملات الرسمية للدالة هي متغيرات محلية.\n    B. يتم تخصيص مساحة للمتغيرات المحلية في المكدس.\n    C. نوع الدالة هو نفسه نوع قيمة الإرجاع.\n    D. يمكن للدالة أن تستدعي نفسها من داخل جسمها.\n\nالسؤال 5:\nأي عبارة عن المؤشرات غير صحيحة؟\n    A. طرح مؤشرين يساوي الفرق في قيم عناوينهما.\n    B. إلغاء المؤشر يتضمن الحل بناءً على نوع المؤشر.\n    C. int *p[4]، p هو مصفوفة من مؤشرات int.\n    D. يمكن تعيين أسماء الدوال إلى مؤشرات الدوال.\n\n>>> f_20()\nAAAAA\nمن المفترض أن تعيد فقط سلاسل مشابهة لـ \"AAAAA\"، والتي تمثل اختيارات السؤال.", "sw": "Jibu maswali kadhaa kwa kutoa chaguo A, B, C, au D kwa kila swali.\n\nSwali la 1:\nKonstanti kama 1e6 ni ya aina gani ya data?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nSwali la 2:\nIkizingatiwa 21! = 51,090,942,171,709,440,000, ni aina gani ya data inaweza kutumika kuhifadhi thamani hii?\n    A. int\n    B. long long\n    C. double\n    D. Hakuna kati ya hizi\n\nSwali la 3:\nNi kauli gani kuhusu thamani za kushoto katika maneno ni isiyo sahihi?\n    A. Maneno ya jina la variable ni thamani za kushoto.\n    B. Operesheni ya kuongeza inahitaji operand kuwa thamani ya kushoto.\n    C. Maneno ya kufuta pointer ni thamani za kushoto.\n    D. Maneno ya operesheni ya kuongeza awali ni thamani za kushoto.\n\nSwali la 4:\nNi kauli gani kuhusu kazi ni isiyo sahihi?\n    A. Vigezo rasmi vya kazi ni variable za ndani.\n    B. Variable za ndani zinatengewa nafasi kwenye stack.\n    C. Aina ya kazi ni sawa na aina ya thamani ya kurudi.\n    D. Kazi inaweza kujita kutoka ndani ya mwili wake.\n\nSwali la 5:\nNi kauli gani kuhusu pointers ni isiyo sahihi?\n    A. Kutoa pointers mbili ni sawa na tofauti katika thamani za anwani zao.\n    B. Kufuta pointer kunahusisha kutatua kulingana na aina ya pointer.\n    C. int *p[4], p ni safu ya pointers za int.\n    D. Majina ya kazi yanaweza kupewa pointers za kazi.\n\n>>> f_20()\nAAAAA\nUnatakiwa kurudisha tu mistari inayofanana na \"AAAAA\", ambayo inawakilisha chaguo za swali.", "tr": "Sorulara A, B, C veya D seçeneklerini vererek cevap verin.\n\nSoru 1:\n1e6 gibi sabitler hangi veri tipine aittir?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nSoru 2:\n21! = 51,090,942,171,709,440,000 verildiğinde, bu değeri saklamak için hangi veri tipi kullanılabilir?\n    A. int\n    B. long long\n    C. double\n    D. Yukarıdakilerin hiçbiri\n\nSoru 3:\nİfadelerdeki sol değerler hakkında hangi ifade yanlıştır?\n    A. Değişken adı ifadeleri sol değerlerdir.\n    B. Artırma işlemi, operandın sol değer olmasını gerektirir.\n    C. Gösterici çözme ifadeleri sol değerlerdir.\n    D. Ön ek artırma işlemi ifadeleri sol değerlerdir.\n\nSoru 4:\nFonksiyonlar hakkında hangi ifade yanlıştır?\n    A. Bir fonksiyonun resmi parametreleri yerel değişkenlerdir.\n    B. Yerel değişkenler yığında yer kaplar.\n    C. Fonksiyon türü, dönüş değeri türü ile aynıdır.\n    D. Bir fonksiyon, gövdesi içinde kendisini çağırabilir.\n\nSoru 5:\nGöstericiler hakkında hangi ifade yanlıştır?\n    A. İki göstericinin çıkarılması, adres değerlerindeki farkı eşittir.\n    B. Gösterici çözme, göstericinin türüne göre çözümlemeyi içerir.\n    C. int *p[4], p bir dizi int göstericisidir.\n    D. Fonksiyon adları, fonksiyon göstericilerine atanabilir.\n\n>>> f_20()\nAAAAA\nSoruların seçeneklerini temsil eden \"AAAAA\" gibi dizgiler döndürmelisiniz.", "vi": "Trả lời một loạt câu hỏi bằng cách cung cấp lựa chọn A, B, C, hoặc D cho mỗi câu hỏi.\n\nCâu hỏi 1:\nHằng số như 1e6 thuộc kiểu dữ liệu nào?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nCâu hỏi 2:\nCho 21! = 51,090,942,171,709,440,000, kiểu dữ liệu nào có thể được sử dụng để lưu trữ giá trị này?\n    A. int\n    B. long long\n    C. double\n    D. Không có loại nào ở trên\n\nCâu hỏi 3:\nPhát biểu nào về giá trị bên trái trong biểu thức là không đúng?\n    A. Biểu thức tên biến là giá trị bên trái.\n    B. Phép toán tăng yêu cầu toán hạng là một giá trị bên trái.\n    C. Biểu thức giải tham chiếu con trỏ là giá trị bên trái.\n    D. Biểu thức phép toán tăng trước là giá trị bên trái.\n\nCâu hỏi 4:\nPhát biểu nào về hàm là không đúng?\n    A. Tham số hình thức của một hàm là biến cục bộ.\n    B. Biến cục bộ được cấp phát không gian trong ngăn xếp.\n    C. Kiểu hàm giống như kiểu giá trị trả về.\n    D. Một hàm có thể tự gọi chính nó từ trong thân hàm.\n\nCâu hỏi 5:\nPhát biểu nào về con trỏ là không đúng?\n    A. Trừ hai con trỏ bằng với sự khác biệt trong giá trị địa chỉ của chúng.\n    B. Giải tham chiếu con trỏ liên quan đến việc giải quyết dựa trên kiểu của con trỏ.\n    C. int *p[4], p là một mảng các con trỏ int.\n    D. Tên hàm có thể được gán cho con trỏ hàm.\n\n>>> f_20()\nAAAAA\nBạn cần chỉ trả về chuỗi tương tự như \"AAAAA\", đại diện cho các lựa chọn của câu hỏi.", "id": "Menjawab serangkaian pertanyaan dengan memberikan pilihan A, B, C, atau D untuk setiap pertanyaan.\n\nPertanyaan 1:\nKonstanta seperti 1e6 termasuk dalam tipe data apa?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nPertanyaan 2:\nDiberikan 21! = 51,090,942,171,709,440,000, tipe data mana yang dapat digunakan untuk menyimpan nilai ini?\n    A. int\n    B. long long\n    C. double\n    D. Tidak ada dari yang di atas\n\nPertanyaan 3:\nPernyataan mana tentang nilai kiri dalam ekspresi yang salah?\n    A. Ekspresi nama variabel adalah nilai kiri.\n    B. Operasi peningkatan memerlukan operan untuk menjadi nilai kiri.\n    C. Ekspresi dereferensi pointer adalah nilai kiri.\n    D. Ekspresi operasi peningkatan prefiks adalah nilai kiri.\n\nPertanyaan 4:\nPernyataan mana tentang fungsi yang salah?\n    A. Parameter formal dari sebuah fungsi adalah variabel lokal.\n    B. Variabel lokal dialokasikan ruang di stack.\n    C. Tipe fungsi sama dengan tipe nilai pengembalian.\n    D. Sebuah fungsi dapat memanggil dirinya sendiri dari dalam tubuhnya.\n\nPertanyaan 5:\nPernyataan mana tentang pointer yang salah?\n    A. Mengurangi dua pointer sama dengan selisih nilai alamat mereka.\n    B. Dereferensi pointer melibatkan penyelesaian berdasarkan tipe pointer.\n    C. int *p[4], p adalah array dari pointer int.\n    D. Nama fungsi dapat ditugaskan ke pointer fungsi.\n\n>>> f_20()\nAAAAA\nAnda seharusnya hanya mengembalikan string yang mirip dengan \"AAAAA\", yang mewakili pilihan dari pertanyaan.", "ja": "質問に対して、各質問に対して選択肢A、B、C、またはDを提供して答えてください。\n\n質問1:\n1e6のような定数はどのデータ型に属しますか？\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\n質問2:\n21! = 51,090,942,171,709,440,000の場合、この値を格納するためにどのデータ型を使用できますか？\n    A. int\n    B. long long\n    C. double\n    D. 上記のいずれでもない\n\n質問3:\n式における左辺値について誤っているのはどれですか？\n    A. 変数名の式は左辺値である。\n    B. インクリメント操作はオペランドが左辺値であることを要求する。\n    C. ポインタのデリファレンス式は左辺値である。\n    D. プレフィックスインクリメント操作の式は左辺値である。\n\n質問4:\n関数について誤っているのはどれですか？\n    A. 関数の形式パラメータはローカル変数である。\n    B. ローカル変数はスタックにスペースが割り当てられる。\n    C. 関数の型は戻り値の型と同じである。\n    D. 関数はその本体内から自身を呼び出すことができる。\n\n質問5:\nポインタについて誤っているのはどれですか？\n    A. 2つのポインタを引くと、それらのアドレス値の差になる。\n    B. ポインタのデリファレンスはポインタの型に基づいて解決される。\n    C. int *p[4], pはintポインタの配列である。\n    D. 関数名は関数ポインタに代入できる。\n\n>>> f_20()\nAAAAA\n質問の選択肢を表す「AAAAA」のような文字列のみを返すことになっています。", "ko": "질문에 대한 답변을 각 질문에 대해 선택지 A, B, C 또는 D로 제공하십시오.\n\n질문 1:\n1e6과 같은 상수는 어떤 데이터 유형에 속합니까?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\n질문 2:\n21! = 51,090,942,171,709,440,000일 때, 이 값을 저장할 수 있는 데이터 유형은 무엇입니까?\n    A. int\n    B. long long\n    C. double\n    D. 위의 것들 중 아무것도 아님\n\n질문 3:\n표현식에서 왼쪽 값에 대한 설명 중 틀린 것은 무엇입니까?\n    A. 변수 이름 표현식은 왼쪽 값이다.\n    B. 증가 연산은 피연산자가 왼쪽 값이어야 한다.\n    C. 포인터 역참조 표현식은 왼쪽 값이다.\n    D. 전위 증가 연산 표현식은 왼쪽 값이다.\n\n질문 4:\n함수에 대한 설명 중 틀린 것은 무엇입니까?\n    A. 함수의 형식 매개변수는 지역 변수이다.\n    B. 지역 변수는 스택에 공간이 할당된다.\n    C. 함수 유형은 반환 값 유형과 동일하다.\n    D. 함수는 본문 내에서 자신을 호출할 수 있다.\n\n질문 5:\n포인터에 대한 설명 중 틀린 것은 무엇입니까?\n    A. 두 포인터를 빼면 주소 값의 차이가 된다.\n    B. 포인터 역참조는 포인터의 유형에 따라 해석된다.\n    C. int *p[4], p는 int 포인터의 배열이다.\n    D. 함수 이름은 함수 포인터에 할당될 수 있다.\n\n>>> f_20()\nAAAAA\n당신은 질문의 선택지를 나타내는 \"AAAAA\"와 유사한 문자열만 반환해야 합니다.", "ml": "ചോദ്യങ്ങൾക്ക് A, B, C, അല്ലെങ്കിൽ D എന്നിങ്ങനെ ഓരോ ചോദ്യത്തിനും തിരഞ്ഞെടുപ്പുകൾ നൽകുക.\n\nചോദ്യം 1:\n1e6 പോലുള്ള സ്ഥിരാങ്കങ്ങൾ ഏത് ഡാറ്റാ തരം ആണെന്ന് കാണിക്കുന്നു?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nചോദ്യം 2:\n21! = 51,090,942,171,709,440,000 എന്നതിനാൽ, ഈ മൂല്യം സൂക്ഷിക്കാൻ ഏത് ഡാറ്റാ തരം ഉപയോഗിക്കാം?\n    A. int\n    B. long long\n    C. double\n    D. മുകളിൽ പറയാത്തവ\n\nചോദ്യം 3:\nവ്യക്തീകരണങ്ങളിലെ ഇടത് മൂല്യങ്ങളെക്കുറിച്ചുള്ള ഏത് പ്രസ്താവന തെറ്റാണ്?\n    A. വേരിയബിൾ നെയിം വ്യക്തീകരണങ്ങൾ ഇടത് മൂല്യങ്ങളാണ്.\n    B. വർദ്ധന പ്രവർത്തനം ഇടത് മൂല്യമായ ഓപ്പറാൻഡ് ആവശ്യമാണ്.\n    C. പോയിന്റർ ഡീറഫറൻസ് വ്യക്തീകരണങ്ങൾ ഇടത് മൂല്യങ്ങളാണ്.\n    D. പ്രിഫിക്സ് വർദ്ധന പ്രവർത്തന വ്യക്തീകരണങ്ങൾ ഇടത് മൂല്യങ്ങളാണ്.\n\nചോദ്യം 4:\nഫംഗ്ഷനുകളെക്കുറിച്ചുള്ള ഏത് പ്രസ്താവന തെറ്റാണ്?\n    A. ഒരു ഫംഗ്ഷന്റെ ഔപചാരിക പാരാമീറ്ററുകൾ പ്രാദേശിക വേരിയബിൾസ് ആണ്.\n    B. പ്രാദേശിക വേരിയബിൾസിന് സ്റ്റാക്കിൽ സ്ഥലം അനുവദിക്കുന്നു.\n    C. ഫംഗ്ഷൻ തരം തിരിച്ചറിയൽ മൂല്യ തരം പോലെ തന്നെയാണ്.\n    D. ഒരു ഫംഗ്ഷൻ അതിന്റെ ശരീരത്തിൽ നിന്ന് തന്നെ വിളിക്കാൻ കഴിയും.\n\nചോദ്യം 5:\nപോയിന്ററുകളെക്കുറിച്ചുള്ള ഏത് പ്രസ്താവന തെറ്റാണ്?\n    A. രണ്ട് പോയിന്ററുകൾ കുറയ്ക്കുന്നത് അവരുടെ വിലാസ മൂല്യങ്ങളിലെ വ്യത്യാസമാണ്.\n    B. പോയിന്റർ ഡീറഫറൻസ്, പോയിന്ററിന്റെ തരം അടിസ്ഥാനമാക്കി പരിഹരിക്കുന്നു.\n    C. int *p[4], p ഒരു int പോയിന്ററുകളുടെ നിരയാണ്.\n    D. ഫംഗ്ഷൻ പേരുകൾ ഫംഗ്ഷൻ പോയിന്ററുകൾക്ക് നിയോഗിക്കാം.\n\n>>> f_20()\nAAAAA\nനിങ്ങൾ \"AAAAA\" പോലുള്ള സ്ട്രിംഗുകൾ മാത്രം മടക്കേണ്ടതാണ്, ഇത് ചോദ്യത്തിന്റെ തിരഞ്ഞെടുപ്പുകൾക്കായി നിൽക്കുന്നു.", "fa": "پاسخ به یک سری سوال با ارائه گزینه‌های A، B، C یا D برای هر سوال.\n\nسوال 1:\nثابت‌هایی مانند 1e6 به کدام نوع داده تعلق دارند؟\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nسوال 2:\nبا توجه به 21! = 51,090,942,171,709,440,000، از کدام نوع داده می‌توان برای ذخیره این مقدار استفاده کرد؟\n    A. int\n    B. long long\n    C. double\n    D. هیچ‌کدام از موارد بالا\n\nسوال 3:\nکدام عبارت درباره مقادیر چپ در عبارات نادرست است؟\n    A. عبارات نام متغیر مقادیر چپ هستند.\n    B. عملیات افزایش نیاز دارد که عملوند یک مقدار چپ باشد.\n    C. عبارات اشاره‌گر به مقادیر چپ هستند.\n    D. عبارات عملیات افزایش پیشوندی مقادیر چپ هستند.\n\nسوال 4:\nکدام عبارت درباره توابع نادرست است؟\n    A. پارامترهای رسمی یک تابع متغیرهای محلی هستند.\n    B. متغیرهای محلی در پشته فضا اختصاص می‌دهند.\n    C. نوع تابع همان نوع مقدار بازگشتی است.\n    D. یک تابع می‌تواند از درون بدنه خود را فراخوانی کند.\n\nسوال 5:\nکدام عبارت درباره اشاره‌گرها نادرست است؟\n    A. تفریق دو اشاره‌گر برابر با تفاوت در مقادیر آدرس آنها است.\n    B. اشاره‌گر به نوع اشاره‌گر برای حل و فصل متکی است.\n    C. int *p[4]، p یک آرایه از اشاره‌گرهای int است.\n    D. نام‌های تابع می‌توانند به اشاره‌گرهای تابع اختصاص داده شوند.\n\n>>> f_20()\nAAAAA\nشما باید فقط رشته‌هایی مشابه \"AAAAA\" را برگردانید، که نشان‌دهنده انتخاب‌های سوال هستند."}}
{"task_id": "C/21", "prompt": {"en": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nThe task is to determine if it is possible to assemble the wooden squares from n buckets,\nwhere each bucket contains $a_i$ squares with a side length of 1, into a single larger square.\nInput: length of list, array of numbers\n    >>> f_21(1, (int[]){9})\n    1\n*/\nint f_21(int length, int squares[])", "sq": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDetyra është të përcaktohet nëse është e mundur të mblidhen katrorët prej druri nga n kovë,\nku secila kovë përmban $a_i$ katrorë me një gjatësi anësore prej 1, në një katror më të madh.\nInput: gjatësia e listës, vargu i numrave\n    >>> f_21(1, (int[]){9})\n    1\n*/\nint f_21(int length, int squares[])", "hy": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nԽնդիրը հետևյալն է՝ որոշել, արդյոք հնարավոր է n դույլերից հավաքել փայտե քառակուսիներ,\nորտեղ յուրաքանչյուր դույլում կա $a_i$ քառակուսի կողքի երկարությունը 1, մեկ մեծ քառակուսի մեջ:\nՄուտքագրում՝ ցուցակի երկարություն, թվերի զանգված\n    >>> f_21(1, (int[]){9})\n    1\n*/\nint f_21(int length, int squares[])", "bn": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nকাজটি হল nটি বালতি থেকে কাঠের বর্গক্ষেত্রগুলি একত্রিত করা সম্ভব কিনা তা নির্ধারণ করা,\nযেখানে প্রতিটি বালতিতে $a_i$ সংখ্যা 1 পার্শ্ব দৈর্ঘ্যের বর্গক্ষেত্র রয়েছে, একটি বড় বর্গক্ষেত্রে।\nইনপুট: তালিকার দৈর্ঘ্য, সংখ্যার অ্যারে\n    >>> f_21(1, (int[]){9})\n    1\n*/\nint f_21(int length, int squares[])", "bg": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nЗадачата е да се определи дали е възможно да се сглобят дървените квадрати от n кофи,\nкъдето всяка кофа съдържа $a_i$ квадрати със страна с дължина 1, в един по-голям квадрат.\nВход: дължина на списъка, масив от числа\n    >>> f_21(1, (int[]){9})\n    1\n*/\nint f_21(int length, int squares[])", "zh": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n任务是确定是否可以从 n 个桶中组装木制正方形，\n其中每个桶包含 $a_i$ 个边长为 1 的正方形，组装成一个更大的正方形。\n输入：列表长度，数字数组\n    >>> f_21(1, (int[]){9})\n    1\n*/\nint f_21(int length, int squares[])", "fr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nLa tâche consiste à déterminer s'il est possible d'assembler les carrés en bois à partir de n seaux,\noù chaque seau contient $a_i$ carrés avec une longueur de côté de 1, en un seul carré plus grand.\nEntrée : longueur de la liste, tableau de nombres\n    >>> f_21(1, (int[]){9})\n    1\n*/\nint f_21(int length, int squares[])", "de": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDie Aufgabe besteht darin, festzustellen, ob es möglich ist, die Holzquadrate aus n Eimern,\nwobei jeder Eimer $a_i$ Quadrate mit einer Seitenlänge von 1 enthält, zu einem einzigen größeren Quadrat zusammenzusetzen.\nEingabe: Länge der Liste, Array von Zahlen\n    >>> f_21(1, (int[]){9})\n    1\n*/\nint f_21(int length, int squares[])", "ha": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nAikin shi ne a tantance ko yana yiwuwa a tara murabba'ai na katako daga guga n,\ninda kowace guga tana dauke da $a_i$ murabba'ai tare da tsayin gefe 1, zuwa murabba'i mafi girma.\nShigarwa: tsawon jerin, jeri na lambobi\n    >>> f_21(1, (int[]){9})\n    1\n*/\nint f_21(int length, int squares[])", "hi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nकार्य यह निर्धारित करना है कि क्या n बाल्टियों से लकड़ी के वर्गों को इकट्ठा करना संभव है,\nजहां प्रत्येक बाल्टी में $a_i$ वर्ग होते हैं जिनकी भुजा की लंबाई 1 होती है, एक बड़े वर्ग में।\nइनपुट: सूची की लंबाई, संख्याओं की श्रृंखला\n    >>> f_21(1, (int[]){9})\n    1\n*/\nint f_21(int length, int squares[])", "hu": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nA feladat annak meghatározása, hogy lehetséges-e a fa négyzeteket n vödörből összeállítani,\nahol minden vödör $a_i$ darab, 1 oldalhosszúságú négyzetet tartalmaz, egyetlen nagyobb négyzetté.\nBemenet: lista hossza, számok tömbje\n    >>> f_21(1, (int[]){9})\n    1\n*/\nint f_21(int length, int squares[])", "es": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nLa tarea es determinar si es posible ensamblar los cuadrados de madera de n cubos,\ndonde cada cubo contiene $a_i$ cuadrados con un lado de longitud 1, en un solo cuadrado más grande.\nEntrada: longitud de la lista, array de números\n    >>> f_21(1, (int[]){9})\n    1\n*/\nint f_21(int length, int squares[])", "arb": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nالمهمة هي تحديد ما إذا كان من الممكن تجميع المربعات الخشبية من n دلاء،\nحيث يحتوي كل دلو على $a_i$ مربعات بطول ضلع 1، في مربع أكبر واحد.\nالمدخلات: طول القائمة، مصفوفة الأرقام\n    >>> f_21(1, (int[]){9})\n    1\n*/\nint f_21(int length, int squares[])", "sw": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nKazi ni kuamua ikiwa inawezekana kuunganisha miraba ya mbao kutoka kwenye n ndoo,\nambapo kila ndoo ina $a_i$ miraba yenye urefu wa upande wa 1, kuwa mraba mmoja mkubwa zaidi.\nIngizo: urefu wa orodha, safu ya nambari\n    >>> f_21(1, (int[]){9})\n    1\n*/\nint f_21(int length, int squares[])", "tr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nGörev, her kovada kenar uzunluğu 1 olan $a_i$ kareler bulunan n kovasından ahşap kareleri\ntek bir büyük kareye monte etmenin mümkün olup olmadığını belirlemektir.\nGirdi: liste uzunluğu, sayıların dizisi\n    >>> f_21(1, (int[]){9})\n    1\n*/\nint f_21(int length, int squares[])", "vi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nNhiệm vụ là xác định xem có thể lắp ráp các hình vuông gỗ từ n thùng,\ntrong đó mỗi thùng chứa $a_i$ hình vuông với độ dài cạnh là 1, thành một hình vuông lớn hơn duy nhất hay không.\nĐầu vào: độ dài của danh sách, mảng số\n    >>> f_21(1, (int[]){9})\n    1\n*/\nint f_21(int length, int squares[])", "id": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nTugasnya adalah menentukan apakah mungkin untuk merakit kotak kayu dari n ember,\ndi mana setiap ember berisi $a_i$ kotak dengan panjang sisi 1, menjadi satu kotak yang lebih besar.\nInput: panjang daftar, array angka\n    >>> f_21(1, (int[]){9})\n    1\n*/\nint f_21(int length, int squares[])", "ja": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nこのタスクは、n個のバケツから木製の正方形を組み立てることが可能かどうかを判断することです。\n各バケツには、1の辺の長さを持つ$a_i$個の正方形が含まれています。それを1つの大きな正方形に組み立てます。\n入力: リストの長さ、数値の配列\n    >>> f_21(1, (int[]){9})\n    1\n*/\nint f_21(int length, int squares[])", "ko": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n작업은 각 버킷에 한 변의 길이가 1인 $a_i$ 정사각형이 들어 있는 n개의 버킷에서 나무 정사각형을 조립하여 더 큰 정사각형을 만들 수 있는지 여부를 결정하는 것입니다.\n입력: 리스트의 길이, 숫자 배열\n    >>> f_21(1, (int[]){9})\n    1\n*/\nint f_21(int length, int squares[])", "ml": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nലക്ഷ്യം n ബക്കറ്റുകളിൽ നിന്ന് മരംചതുരങ്ങൾ ഒന്നിച്ചു ചേർത്ത് ഒരു വലിയ ചതുരം ഉണ്ടാക്കാൻ കഴിയുമോ എന്ന് നിർണ്ണയിക്കുകയാണ്,\nഓരോ ബക്കറ്റിലും 1 നീളമുള്ള വശമുള്ള $a_i$ ചതുരങ്ങൾ അടങ്ങിയിരിക്കുന്നു.\nഇൻപുട്ട്: ലിസ്റ്റിന്റെ നീളം, സംഖ്യകളുടെ അറെ\n    >>> f_21(1, (int[]){9})\n    1\n*/\nint f_21(int length, int squares[])", "fa": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nوظیفه این است که تعیین کنیم آیا ممکن است مربع‌های چوبی را از n سطل که هر سطل شامل $a_i$ مربع با طول ضلع 1 است، به یک مربع بزرگتر تبدیل کنیم.\nورودی: طول لیست، آرایه‌ای از اعداد\n    >>> f_21(1, (int[]){9})\n    1\n*/\nint f_21(int length, int squares[])"}, "canonical_solution": "{\n    long long sum = 0;\n    for (int i = 0; i < length; ++i) {\n        sum += squares[i]; // 求和\n    }\n    int root = (int)sqrt(sum);\n    return root * root == sum; // 是某个整数的平方\n}", "instruction": {"en": "Write a C function `int f_21(int length, int squares[])` to solve the following problem:\nThe task is to determine if it is possible to assemble the wooden squares from n buckets, where each bucket contains $a_i$ squares with a side length of 1, into a single larger square.\nInput: length of list, array of numbers\n    >>> f_21(1, (int[]){9})\n    1\n", "sq": "Shkruani një funksion në C `int f_21(int length, int squares[])` për të zgjidhur problemin e mëposhtëm:\nDetyra është të përcaktohet nëse është e mundur të montohet katrorët prej druri nga k kovë, ku secila kovë përmban $a_i$ katrorë me një gjatësi anësore prej 1, në një katror më të madh.  \nHyrja: gjatësia e listës, vargu i numrave  \n    >>> f_21(1, (int[]){9})  \n    1  ", "hy": "Գրեք C ֆունկցիա `int f_21(int length, int squares[])` հետևյալ խնդիրը լուծելու համար:\nԽնդիրը որոշելն է, թե արդյոք հնարավոր է n դույլերից, որտեղ յուրաքանչյուր դույլում կա $a_i$ քառակուսի 1 կողմի երկարությամբ, հավաքել մեկ մեծ քառակուսի:\nՄուտքագրում: ցուցակի երկարություն, թվերի զանգված\n    >>> f_21(1, (int[]){9})\n    1", "bn": "একটি C ফাংশন `int f_21(int length, int squares[])` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nকাজটি হল n বালতি থেকে কাঠের বর্গক্ষেত্রগুলি একত্রিত করা সম্ভব কিনা তা নির্ধারণ করা, যেখানে প্রতিটি বালতিতে $a_i$ বর্গক্ষেত্র রয়েছে যাদের পার্শ্ব দৈর্ঘ্য 1, একটি একক বড় বর্গক্ষেত্রে।\nইনপুট: তালিকার দৈর্ঘ্য, সংখ্যার অ্যারে\n    >>> f_21(1, (int[]){9})\n    1", "bg": "Напишете C функция `int f_21(int length, int squares[])`, за да решите следния проблем:\nЗадачата е да се определи дали е възможно да се сглобят дървените квадрати от n кофи, където всяка кофа съдържа $a_i$ квадрати със страна с дължина 1, в един по-голям квадрат.\nВход: дължина на списъка, масив от числа\n    >>> f_21(1, (int[]){9})\n    1", "zh": "编写一个 C 函数 `int f_21(int length, int squares[])` 来解决以下问题：\n任务是确定是否可以将 n 个桶中的木块组装成一个更大的正方形，其中每个桶包含 $a_i$ 个边长为 1 的正方形。  \n输入：列表长度，数字数组  \n    >>> f_21(1, (int[]){9})  \n    1  ", "fr": "Écrire une fonction C `int f_21(int length, int squares[])` pour résoudre le problème suivant :\nLa tâche consiste à déterminer s'il est possible d'assembler les carrés en bois provenant de n seaux, où chaque seau contient $a_i$ carrés avec une longueur de côté de 1, en un seul carré plus grand.  \nEntrée : longueur de la liste, tableau de nombres  \n    >>> f_21(1, (int[]){9})  \n    1  ", "de": "Schreiben Sie eine C-Funktion `int f_21(int length, int squares[])`, um das folgende Problem zu lösen:\nDie Aufgabe besteht darin, festzustellen, ob es möglich ist, die Holzquadrate aus n Eimern, wobei jeder Eimer $a_i$ Quadrate mit einer Seitenlänge von 1 enthält, zu einem einzigen größeren Quadrat zusammenzusetzen.  \nEingabe: Länge der Liste, Array von Zahlen  \n    >>> f_21(1, (int[]){9})  \n    1  ", "ha": "Rubuta aikin C `int f_21(int length, int squares[])` don warware matsalar mai zuwa:\nAikin shi ne a tantance ko yana yiwuwa a tara katakon murabba'i daga kwanduna n, inda kowanne kwando ke dauke da $a_i$ murabba'i da tsawon gefe 1, cikin murabba'i guda mafi girma.  \nShigarwa: tsawon jerin, jerin lambobi  \n    >>> f_21(1, (int[]){9})  \n    1  ", "hi": "C फ़ंक्शन `int f_21(int length, int squares[])` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nकार्य यह निर्धारित करना है कि क्या यह संभव है कि n बाल्टियों से लकड़ी के वर्गों को, जहाँ प्रत्येक बाल्टी में $a_i$ वर्ग होते हैं जिनकी भुजा की लंबाई 1 होती है, एक बड़े वर्ग में इकट्ठा किया जा सके।\nइनपुट: सूची की लंबाई, संख्याओं की array\n    >>> f_21(1, (int[]){9})\n    1", "hu": "Írj egy C függvényt `int f_21(int length, int squares[])` a következő probléma megoldására:\nA feladat annak meghatározása, hogy lehetséges-e az n vödörből származó fa négyzetekből, ahol minden vödör $a_i$ darab, 1 oldalhosszúságú négyzetet tartalmaz, egyetlen nagyobb négyzetet összeállítani.\nBemenet: lista hossza, számok tömbje\n    >>> f_21(1, (int[]){9})\n    1", "es": "Escriba una función en C `int f_21(int length, int squares[])` para resolver el siguiente problema:\nLa tarea es determinar si es posible ensamblar los cuadrados de madera de n cubos, donde cada cubo contiene $a_i$ cuadrados con un lado de longitud 1, en un solo cuadrado más grande.\nEntrada: longitud de la lista, arreglo de números\n    >>> f_21(1, (int[]){9})\n    1", "arb": "اكتب دالة C `int f_21(int length, int squares[])` لحل المشكلة التالية:\nالمهمة هي تحديد ما إذا كان من الممكن تجميع المربعات الخشبية من n دلوًا، حيث يحتوي كل دلو على $a_i$ مربعات بطول ضلع 1، في مربع أكبر واحد.\nالمدخلات: طول القائمة، مصفوفة الأرقام\n    >>> f_21(1, (int[]){9})\n    1", "sw": "Andika kazi ya C `int f_21(int length, int squares[])` kutatua tatizo lifuatalo:\nKazi ni kuamua kama inawezekana kuunganisha miraba ya mbao kutoka kwenye ndoo n, ambapo kila ndoo ina miraba $a_i$ yenye urefu wa upande wa 1, kuwa mraba mmoja mkubwa.\nIngizo: urefu wa orodha, safu ya namba\n    >>> f_21(1, (int[]){9})\n    1", "tr": "Bir C fonksiyonu `int f_21(int length, int squares[])` yazın ve aşağıdaki problemi çözün:\nGörev, her kovada bir kenar uzunluğu 1 olan $a_i$ kareleri içeren n kovasından ahşap kareleri tek bir büyük kareye monte etmenin mümkün olup olmadığını belirlemektir.\nGirdi: liste uzunluğu, sayıların dizisi\n    >>> f_21(1, (int[]){9})\n    1", "vi": "Viết một hàm C `int f_21(int length, int squares[])` để giải quyết vấn đề sau:\nNhiệm vụ là xác định xem có thể lắp ráp các hình vuông gỗ từ n thùng, trong đó mỗi thùng chứa $a_i$ hình vuông với độ dài cạnh là 1, thành một hình vuông lớn hơn duy nhất hay không.  \nĐầu vào: độ dài của danh sách, mảng số  \n    >>> f_21(1, (int[]){9})  \n    1  ", "id": "Tulis fungsi C `int f_21(int length, int squares[])` untuk menyelesaikan masalah berikut:\nTugasnya adalah untuk menentukan apakah mungkin untuk menyusun kotak kayu dari n ember, di mana setiap ember berisi $a_i$ kotak dengan panjang sisi 1, menjadi satu kotak yang lebih besar.\nInput: panjang daftar, array angka\n    >>> f_21(1, (int[]){9})\n    1", "ja": "Cの関数を書け `int f_21(int length, int squares[])` を作成して、次の問題を解決してください:\nタスクは、n個のバケツから、それぞれのバケツに1辺が1の正方形が$a_i$個入っているとき、それらを1つの大きな正方形に組み立てることが可能かどうかを判断することです。\n入力: リストの長さ、数値の配列\n    >>> f_21(1, (int[]){9})\n    1", "ko": "C 함수 `int f_21(int length, int squares[])`를 작성하여 다음 문제를 해결하십시오:\nn개의 버킷에서 각 버킷이 한 변의 길이가 1인 $a_i$ 개의 정사각형을 포함하고 있을 때, 이 목재 정사각형들을 하나의 더 큰 정사각형으로 조립할 수 있는지 여부를 결정하는 작업입니다.  \n입력: 리스트의 길이, 숫자의 배열  \n    >>> f_21(1, (int[]){9})  \n    1  ", "ml": "`int f_21(int length, int squares[])` എന്ന C ഫങ്ഷൻ എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nപ്രശ്നം: n ബക്കറ്റുകളിൽ നിന്ന് കഷ്ണങ്ങൾ ചേർത്ത് ഒരു വലിയ ചതുരം ഉണ്ടാക്കാൻ കഴിയുമോ എന്ന് കണ്ടെത്തുക, ഇവിടെ ഓരോ ബക്കറ്റിലും 1 നീളമുള്ള $a_i$ ചതുരങ്ങൾ ഉണ്ട്.  \nഇൻപുട്ട്: ലിസ്റ്റിന്റെ നീളം, സംഖ്യകളുടെ അറേ  \n    >>> f_21(1, (int[]){9})  \n    1  ", "fa": "یک تابع C به نام `int f_21(int length, int squares[])` بنویسید تا مسئله زیر را حل کند:\nوظیفه این است که تعیین کنید آیا ممکن است مربع‌های چوبی را از n سطل، که هر سطل شامل $a_i$ مربع با طول ضلع 1 است، به یک مربع بزرگتر مونتاژ کرد.\nورودی: طول لیست، آرایه‌ای از اعداد\n    >>> f_21(1, (int[]){9})\n    1"}, "level": "easy", "test": "int main() {\n    assert(f_21(1, (int[]){9}) == 1);\n    assert(f_21(2, (int[]){14, 2}) == 1);\n    assert(f_21(2, (int[]){7, 7}) == 0);\n    assert(f_21(7, (int[]){1, 2, 3, 4, 5, 6, 7}) == 0);\n    assert(f_21(6, (int[]){1, 3, 5, 7, 9, 11}) == 1);\n    assert(f_21(4, (int[]){2, 2, 2, 2}) == 0);\n\n    // Additional test cases\n    assert(f_21(3, (int[]){4, 5, 6}) == 0);\n    assert(f_21(4, (int[]){16, 9, 4, 1}) == 0);\n    assert(f_21(5, (int[]){1, 1, 1, 1, 1}) == 0);\n    assert(f_21(2, (int[]){25, 25}) == 0);\n    assert(f_21(3, (int[]){10, 10, 5}) == 1);\n\n    // printf(\"All tests passed!\\n\");\n    return 0;\n}", "entry_point": "f_21", "signature": "int f_21(int length, int squares[])", "docstring": {"en": "The task is to determine if it is possible to assemble the wooden squares from n buckets, where each bucket contains $a_i$ squares with a side length of 1, into a single larger square.\nInput: length of list, array of numbers\n    >>> f_21(1, (int[]){9})\n    1\n", "sq": "Detyra është të përcaktohet nëse është e mundur të montohen katrorët prej druri nga n kovë, ku secila kovë përmban $a_i$ katrorë me një gjatësi anësore prej 1, në një katror më të madh.\nInput: gjatësia e listës, vargu i numrave\n    >>> f_21(1, (int[]){9})\n    1", "hy": "Առաջադրանքը որոշելն է՝ արդյոք հնարավոր է հավաքել փայտե քառակուսիները n դույլերից, որտեղ յուրաքանչյուր դույլ պարունակում է $a_i$ կողմի երկարությամբ 1 քառակուսի, մեկ մեծ քառակուսու մեջ:\nՄուտքագրում: ցուցակի երկարություն, թվերի զանգված\n    >>> f_21(1, (int[]){9})\n    1", "bn": "কাজটি হল নির্ধারণ করা সম্ভব কিনা n বালতি থেকে কাঠের বর্গক্ষেত্রগুলি একত্রিত করা, যেখানে প্রতিটি বালতিতে $a_i$ সংখ্যক 1 পার্শ্ব দৈর্ঘ্যের বর্গক্ষেত্র রয়েছে, একটি বড় বর্গক্ষেত্রে।\nInput: তালিকার দৈর্ঘ্য, সংখ্যার অ্যারে\n    >>> f_21(1, (int[]){9})\n    1", "bg": "Задачата е да се определи дали е възможно да се сглобят дървените квадрати от n кофи, където всяка кофа съдържа $a_i$ квадрати със страна с дължина 1, в един по-голям квадрат.\nВход: дължина на списъка, масив от числа\n    >>> f_21(1, (int[]){9})\n    1", "zh": "任务是确定是否可以从 n 个桶中组装木方块，其中每个桶包含 $a_i$ 个边长为 1 的方块，组装成一个更大的方块。\n输入：列表长度，数字数组\n    >>> f_21(1, (int[]){9})\n    1", "fr": "La tâche consiste à déterminer s'il est possible d'assembler les carrés en bois à partir de n seaux, où chaque seau contient $a_i$ carrés avec un côté de longueur 1, en un seul carré plus grand.\nEntrée : longueur de la liste, tableau de nombres\n    >>> f_21(1, (int[]){9})\n    1", "de": "Die Aufgabe besteht darin, zu bestimmen, ob es möglich ist, die Holzquadrate aus n Eimern, wobei jeder Eimer $a_i$ Quadrate mit einer Seitenlänge von 1 enthält, zu einem einzigen größeren Quadrat zusammenzusetzen.\nEingabe: Länge der Liste, Array von Zahlen\n    >>> f_21(1, (int[]){9})\n    1", "ha": "Aikin shine a tantance ko yana yiwuwa a tara murabba'ai na katako daga guga n, inda kowanne guga yana dauke da $a_i$ murabba'ai masu tsawon gefe 1, cikin babban murabba'i guda.\nShigarwa: tsawon jerin, jerin lambobi\n    >>> f_21(1, (int[]){9})\n    1", "hi": "कार्य यह निर्धारित करना है कि क्या n बाल्टियों से लकड़ी के वर्गों को एकत्र करना संभव है, जहाँ प्रत्येक बाल्टी में $a_i$ वर्ग होते हैं जिनकी भुजा की लंबाई 1 होती है, एक बड़े वर्ग में।\n\nइनपुट: सूची की लंबाई, संख्याओं की श्रृंखला\n    >>> f_21(1, (int[]){9})\n    1", "hu": "A feladat annak meghatározása, hogy lehetséges-e az n vödörből származó fa négyzeteket, ahol minden vödör $a_i$ darab, 1 oldalhosszúságú négyzetet tartalmaz, egyetlen nagyobb négyzetté összeállítani.\nBemenet: lista hossza, számok tömbje\n    >>> f_21(1, (int[]){9})\n    1", "es": "La tarea es determinar si es posible ensamblar los cuadrados de madera de n cubetas, donde cada cubeta contiene $a_i$ cuadrados con un lado de longitud 1, en un solo cuadrado más grande.\nEntrada: longitud de la lista, array de números\n    >>> f_21(1, (int[]){9})\n    1", "arb": "المهمة هي تحديد ما إذا كان من الممكن تجميع المربعات الخشبية من n دلاء، حيث يحتوي كل دلو على $a_i$ مربعات بطول ضلع 1، في مربع أكبر واحد.\n\nالمدخلات: طول القائمة، مصفوفة من الأرقام\n    >>> f_21(1, (int[]){9})\n    1", "sw": "Kazi ni kubaini kama inawezekana kuunganisha miraba ya mbao kutoka kwenye ndoo n, ambapo kila ndoo ina $a_i$ miraba yenye urefu wa upande wa 1, kuwa mraba mmoja mkubwa zaidi.\nIngizo: urefu wa orodha, safu ya nambari\n    >>> f_21(1, (int[]){9})\n    1", "tr": "Görev, her kovada kenar uzunluğu 1 olan $a_i$ karelerin bulunduğu n kovadan, tek bir büyük kare oluşturmanın mümkün olup olmadığını belirlemektir.\nGirdi: liste uzunluğu, sayıların dizisi\n    >>> f_21(1, (int[]){9})\n    1", "vi": "Nhiệm vụ là xác định xem có thể lắp ráp các hình vuông gỗ từ n thùng, mỗi thùng chứa $a_i$ hình vuông có cạnh dài 1, thành một hình vuông lớn hơn duy nhất hay không.\nĐầu vào: độ dài của danh sách, mảng số\n    >>> f_21(1, (int[]){9})\n    1", "id": "Tugasnya adalah untuk menentukan apakah mungkin untuk merakit kotak kayu dari n ember, di mana setiap ember berisi $a_i$ kotak dengan panjang sisi 1, menjadi satu kotak yang lebih besar.\nMasukan: panjang daftar, array angka\n    >>> f_21(1, (int[]){9})\n    1", "ja": "タスクは、各バケツに1辺の長さが1の正方形が$a_i$個入っているn個のバケツから、1つの大きな正方形を組み立てることが可能かどうかを判断することです。\n入力: リストの長さ、数値の配列\n    >>> f_21(1, (int[]){9})\n    1", "ko": "작업은 각 양동이에 한 변의 길이가 1인 $a_i$ 개의 정사각형이 들어 있는 n개의 양동이에서 나무 정사각형을 하나의 더 큰 정사각형으로 조립할 수 있는지 여부를 결정하는 것입니다.\n입력: 리스트의 길이, 숫자 배열\n    >>> f_21(1, (int[]){9})\n    1", "ml": "പ്രവർത്തി n ബക്കറ്റുകളിൽ നിന്ന് മരം ചതുരങ്ങൾ ഒന്നിച്ചുകൂട്ടാൻ സാധ്യമാണോ എന്ന് നിർണയിക്കുകയാണ്, ഓരോ ബക്കറ്റിലും 1 നീളമുള്ള $a_i$ ചതുരങ്ങൾ അടങ്ങിയിരിക്കുന്നു, ഒരു വലിയ ചതുരത്തിലേക്ക്.\nInput: length of list, array of numbers\n    >>> f_21(1, (int[]){9})\n    1", "fa": "وظیفه این است که تعیین کنید آیا ممکن است مربع‌های چوبی را از n سطل که هر کدام شامل $a_i$ مربع با طول ضلع 1 است، به یک مربع بزرگتر تبدیل کنید یا خیر.\nورودی: طول لیست، آرایه‌ای از اعداد\n    >>> f_21(1, (int[]){9})\n    1"}}
{"task_id": "C/22", "prompt": {"en": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nGiven integers c and d, where a + b = c and a * b = d, find and return the possible value of a (a <= b). If there are multiple groups, output the group with the smallest a.\n    Parameters:\n    - c (int): The sum of a and b.\n    - d (int): The product of a and b.\n\n    Returns:\n    Optional[int]: A possible value of a. Returns -1 if valid values do not exist,\n\\\n    >>> f_22(7,11)\n    -1\n*/\nint f_22(int c, int d)", "sq": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDuke pasur parasysh numrat e plotë c dhe d, ku a + b = c dhe a * b = d, gjeni dhe ktheni vlerën e mundshme të a (a <= b). Nëse ka grupe të shumta, jepni grupin me a më të vogël.\n    Parametrat:\n    - c (int): Shuma e a dhe b.\n    - d (int): Produkti i a dhe b.\n\n    Kthen:\n    Optional[int]: Një vlerë e mundshme e a. Kthen -1 nëse vlerat e vlefshme nuk ekzistojnë,\n\\\n    >>> f_22(7,11)\n    -1\n*/\nint f_22(int c, int d)", "hy": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nՏրված են ամբողջ թվեր c և d, որտեղ a + b = c և a * b = d, գտնել և վերադարձնել a-ի հնարավոր արժեքը (a <= b): Եթե կան բազմաթիվ խմբեր, արտածել խումբը ամենափոքր a-ով:\n    Պարամետրեր:\n    - c (int): a-ի և b-ի գումարը:\n    - d (int): a-ի և b-ի արտադրյալը:\n\n    Վերադարձնում է:\n    Optional[int]: a-ի հնարավոր արժեքը: Վերադարձնում է -1, եթե վավեր արժեքներ չեն գոյություն ունենում,\n\\\n    >>> f_22(7,11)\n    -1\n*/\nint f_22(int c, int d)", "bn": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nপ্রদত্ত পূর্ণসংখ্যা c এবং d, যেখানে a + b = c এবং a * b = d, a এর সম্ভাব্য মান খুঁজে বের করুন এবং ফেরত দিন (a <= b)। যদি একাধিক গ্রুপ থাকে, তাহলে সবচেয়ে ছোট a সহ গ্রুপটি আউটপুট করুন।\n    প্যারামিটার:\n    - c (int): a এবং b এর যোগফল।\n    - d (int): a এবং b এর গুণফল।\n\n    রিটার্নস:\n    Optional[int]: a এর একটি সম্ভাব্য মান। যদি বৈধ মান বিদ্যমান না থাকে, তাহলে -1 ফেরত দেয়।\n\n    >>> f_22(7,11)\n    -1\n*/\nint f_22(int c, int d)", "bg": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nДадени са цели числа c и d, където a + b = c и a * b = d, намерете и върнете възможната стойност на a (a <= b). Ако има множество групи, изведете групата с най-малката a.\n    Параметри:\n    - c (int): Сумата на a и b.\n    - d (int): Произведението на a и b.\n\n    Връща:\n    Optional[int]: Възможна стойност на a. Връща -1, ако не съществуват валидни стойности.\n\n    >>> f_22(7,11)\n    -1\n*/\nint f_22(int c, int d)", "zh": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n给定整数 c 和 d，其中 a + b = c 且 a * b = d，找到并返回 a 的可能值 (a <= b)。如果有多个组合，输出 a 最小的组合。\n    参数:\n    - c (int): a 和 b 的和。\n    - d (int): a 和 b 的积。\n\n    返回:\n    Optional[int]: a 的一个可能值。如果不存在有效值，则返回 -1。\n\\\n    >>> f_22(7,11)\n    -1\n*/\nint f_22(int c, int d)", "fr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nÉtant donné des entiers c et d, où a + b = c et a * b = d, trouver et retourner la valeur possible de a (a <= b). S'il existe plusieurs groupes, afficher le groupe avec le plus petit a.\n    Paramètres:\n    - c (int): La somme de a et b.\n    - d (int): Le produit de a et b.\n\n    Renvoie:\n    Optional[int]: Une valeur possible de a. Renvoie -1 si des valeurs valides n'existent pas,\n\\\n    >>> f_22(7,11)\n    -1\n*/\nint f_22(int c, int d)", "de": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nGegeben sind ganze Zahlen c und d, wobei a + b = c und a * b = d, finde und gib den möglichen Wert von a zurück (a <= b). Wenn es mehrere Gruppen gibt, gib die Gruppe mit dem kleinsten a aus.\n    Parameter:\n    - c (int): Die Summe von a und b.\n    - d (int): Das Produkt von a und b.\n\n    Rückgabewert:\n    Optional[int]: Ein möglicher Wert von a. Gibt -1 zurück, wenn keine gültigen Werte existieren.\n\\\n    >>> f_22(7,11)\n    -1\n*/\nint f_22(int c, int d)", "ha": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nAn ba lambobin c da d, inda a + b = c kuma a * b = d, nemo kuma dawo da yiwuwar ƙimar a (a <= b). Idan akwai kungiyoyi da yawa, fitar da ƙungiyar da ke da ƙaramin a.\n    Sigogi:\n    - c (int): Jimillar a da b.\n    - d (int): Samfurin a da b.\n\n    Returns:\n    Optional[int]: Yiwuwar ƙimar a. Yana dawowa -1 idan ƙimomi masu inganci ba su wanzu,\n\\\n    >>> f_22(7,11)\n    -1\n*/\nint f_22(int c, int d)", "hi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nदिए गए पूर्णांक c और d, जहाँ a + b = c और a * b = d, a का संभावित मान खोजें और लौटाएं (a <= b)। यदि कई समूह हैं, तो सबसे छोटे a वाले समूह को आउटपुट करें।\n    पैरामीटर्स:\n    - c (int): a और b का योग।\n    - d (int): a और b का गुणनफल।\n\n    रिटर्न्स:\n    Optional[int]: a का एक संभावित मान। यदि मान्य मान मौजूद नहीं हैं, तो -1 लौटाता है।\n\\\n    >>> f_22(7,11)\n    -1\n*/\nint f_22(int c, int d)", "hu": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nAdott két egész szám, c és d, ahol a + b = c és a * b = d, találja meg és adja vissza a lehetséges a értékét (a <= b). Ha több csoport is van, adja vissza a legkisebb a értékkel rendelkező csoportot.\n    Paraméterek:\n    - c (int): Az a és b összege.\n    - d (int): Az a és b szorzata.\n\n    Visszatérési érték:\n    Optional[int]: Egy lehetséges a érték. -1-et ad vissza, ha nem léteznek érvényes értékek.\n\\\n    >>> f_22(7,11)\n    -1\n*/\nint f_22(int c, int d)", "es": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDados los enteros c y d, donde a + b = c y a * b = d, encuentra y devuelve el valor posible de a (a <= b). Si hay múltiples grupos, muestra el grupo con el menor a.\n    Parámetros:\n    - c (int): La suma de a y b.\n    - d (int): El producto de a y b.\n\n    Devuelve:\n    Optional[int]: Un valor posible de a. Devuelve -1 si no existen valores válidos.\n\n    >>> f_22(7,11)\n    -1\n*/\nint f_22(int c, int d)", "arb": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nمعطى عددين صحيحين c و d، حيث a + b = c و a * b = d، ابحث وأعد القيمة الممكنة لـ a (a <= b). إذا كانت هناك مجموعات متعددة، قم بإخراج المجموعة التي تحتوي على أصغر قيمة لـ a.\n    المعطيات:\n    - c (int): مجموع a و b.\n    - d (int): حاصل ضرب a و b.\n\n    يعيد:\n    Optional[int]: قيمة ممكنة لـ a. يعيد -1 إذا لم تكن هناك قيم صحيحة موجودة.\n\n    >>> f_22(7,11)\n    -1\n*/\nint f_22(int c, int d)", "sw": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nUkipiwa namba nzima c na d, ambapo a + b = c na a * b = d, tafuta na rudisha thamani inayowezekana ya a (a <= b). Ikiwa kuna makundi mengi, toa kundi lenye a ndogo zaidi.\n    Vigezo:\n    - c (int): Jumla ya a na b.\n    - d (int): Bidhaa ya a na b.\n\n    Inarudisha:\n    Optional[int]: Thamani inayowezekana ya a. Inarudisha -1 ikiwa thamani halali hazipo,\n\\\n    >>> f_22(7,11)\n    -1\n*/\nint f_22(int c, int d)", "tr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nVerilen c ve d tamsayıları için, a + b = c ve a * b = d olduğunda, a'nın olası değerini bulun ve döndürün (a <= b). Birden fazla grup varsa, en küçük a'ya sahip olan grubu çıktı olarak verin.\n    Parametreler:\n    - c (int): a ve b'nin toplamı.\n    - d (int): a ve b'nin çarpımı.\n\n    Döndürür:\n    Optional[int]: a'nın olası bir değeri. Geçerli değerler yoksa -1 döndürür.\n\\\n    >>> f_22(7,11)\n    -1\n*/\nint f_22(int c, int d)", "vi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCho các số nguyên c và d, trong đó a + b = c và a * b = d, tìm và trả về giá trị có thể của a (a <= b). Nếu có nhiều nhóm, xuất nhóm có a nhỏ nhất.\n    Tham số:\n    - c (int): Tổng của a và b.\n    - d (int): Tích của a và b.\n\n    Trả về:\n    Optional[int]: Một giá trị có thể của a. Trả về -1 nếu không tồn tại giá trị hợp lệ,\n\\\n    >>> f_22(7,11)\n    -1\n*/\nint f_22(int c, int d)", "id": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDiberikan bilangan bulat c dan d, di mana a + b = c dan a * b = d, temukan dan kembalikan nilai yang mungkin dari a (a <= b). Jika ada beberapa kelompok, keluarkan kelompok dengan a terkecil.\n    Parameter:\n    - c (int): Jumlah dari a dan b.\n    - d (int): Hasil kali dari a dan b.\n\n    Mengembalikan:\n    Optional[int]: Nilai yang mungkin dari a. Mengembalikan -1 jika nilai yang valid tidak ada.\n\n    >>> f_22(7,11)\n    -1\n*/\nint f_22(int c, int d)\n", "ja": " c\n#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n整数 c と d が与えられたとき、a + b = c および a * b = d である a の可能な値を見つけて返します (a <= b)。複数のグループがある場合は、a が最小のグループを出力します。\n    パラメータ:\n    - c (int): a と b の合計。\n    - d (int): a と b の積。\n\n    戻り値:\n    Optional[int]: a の可能な値。 有効な値が存在しない場合は -1 を返します。\n\\\n    >>> f_22(7,11)\n    -1\n*/\nint f_22(int c, int d)\n", "ko": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n정수 c와 d가 주어졌을 때, a + b = c이고 a * b = d인 a의 가능한 값을 찾아 반환합니다 (a <= b). 여러 그룹이 있는 경우, a가 가장 작은 그룹을 출력합니다.\n    매개변수:\n    - c (int): a와 b의 합.\n    - d (int): a와 b의 곱.\n\n    반환:\n    Optional[int]: a의 가능한 값. 유효한 값이 존재하지 않으면 -1을 반환합니다.\n\n    >>> f_22(7,11)\n    -1\n*/\nint f_22(int c, int d)\n", "ml": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nഇന്റീജറുകൾ c, d നൽകുമ്പോൾ, a + b = c കൂടാതെ a * b = d ആയിടത്ത്, a യുടെ സാധ്യതയുള്ള മൂല്യം കണ്ടെത്തി മടക്കുക (a <= b). നിരവധി ഗ്രൂപ്പുകൾ ഉണ്ടെങ്കിൽ, ഏറ്റവും ചെറിയ a ഉള്ള ഗ്രൂപ്പ് ഔട്ട്പുട്ട് ചെയ്യുക.\n    പാരാമീറ്ററുകൾ:\n    - c (int): a, b എന്നിവയുടെ സമാഹാരം.\n    - d (int): a, b എന്നിവയുടെ ഗുണഫലം.\n\n    മടക്കുന്നു:\n    Optional[int]: a യുടെ സാധ്യതയുള്ള മൂല്യം. സാധുവായ മൂല്യങ്ങൾ നിലവിലില്ലെങ്കിൽ -1 മടക്കുന്നു,\n\\\n    >>> f_22(7,11)\n    -1\n*/\nint f_22(int c, int d)", "fa": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nاعداد صحیح c و d داده شده‌اند، به طوری که a + b = c و a * b = d، مقدار ممکن a (a <= b) را پیدا کرده و برگردانید. اگر گروه‌های متعددی وجود دارند، گروهی را که a کوچکترین است خروجی دهید.\n    پارامترها:\n    - c (int): مجموع a و b.\n    - d (int): حاصل‌ضرب a و b.\n\n    بازگشت:\n    Optional[int]: مقدار ممکن a. اگر مقادیر معتبر وجود نداشته باشند، -1 برمی‌گرداند.\n\\\n    >>> f_22(7,11)\n    -1\n*/\nint f_22(int c, int d)\n"}, "canonical_solution": "{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i;\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}", "instruction": {"en": "Write a C function `int f_22(int c, int d)` to solve the following problem:\nGiven integers c and d, where a + b = c and a * b = d, find and return the possible value of a (a <= b). If there are multiple groups, output the group with the smallest a.\n    Parameters:\n    - c (int): The sum of a and b.\n    - d (int): The product of a and b.\n\n    Returns:\n    Optional[int]: A possible value of a. Returns -1 if valid values do not exist,\n\n    >>> f_22(7,11)\n    -1\n", "sq": "Shkruani një funksion në C `int f_22(int c, int d)` për të zgjidhur problemin në vijim:\nDuke pasur parasysh numrat e plotë c dhe d, ku a + b = c dhe a * b = d, gjeni dhe ktheni vlerën e mundshme të a (a <= b). Nëse ka disa grupe, jepni grupin me vlerën më të vogël të a.\n    Parametrat:\n    - c (int): Shuma e a dhe b.\n    - d (int): Produkti i a dhe b.\n\n    Kthen:\n    Optional[int]: Një vlerë e mundshme e a. Kthen -1 nëse vlerat e vlefshme nuk ekzistojnë,\n\n    >>> f_22(7,11)\n    -1", "hy": "Գրեք C ֆունկցիա `int f_22(int c, int d)` հետևյալ խնդիրը լուծելու համար:\nՏրված են ամբողջ թվեր c և d, որտեղ a + b = c և a * b = d, գտնել և վերադարձնել a-ի հնարավոր արժեքը (a <= b): Եթե կան բազմաթիվ խմբեր, արտածել այն խումբը, որտեղ a-ն ամենափոքրն է:\n    Պարամետրեր:\n    - c (int): a-ի և b-ի գումարը:\n    - d (int): a-ի և b-ի արտադրյալը:\n\n    Վերադարձնում է:\n    Optional[int]: a-ի հնարավոր արժեքը: Վերադարձնում է -1, եթե վավեր արժեքներ չկան,\n\n    >>> f_22(7,11)\n    -1", "bn": "একটি C ফাংশন `int f_22(int c, int d)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nপ্রদত্ত পূর্ণসংখ্যা c এবং d, যেখানে a + b = c এবং a * b = d, a এর সম্ভাব্য মান খুঁজে বের করুন এবং ফেরত দিন (a <= b)। যদি একাধিক গ্রুপ থাকে, তবে সবচেয়ে ছোট a সহ গ্রুপটি আউটপুট করুন।\n    প্যারামিটারসমূহ:\n    - c (int): a এবং b এর যোগফল।\n    - d (int): a এবং b এর গুণফল।\n\n    রিটার্নস:\n    Optional[int]: a এর একটি সম্ভাব্য মান। যদি বৈধ মান বিদ্যমান না থাকে তবে -1 ফেরত দেয়,\n\n    >>> f_22(7,11)\n    -1", "bg": "Напишете C функция `int f_22(int c, int d)`, за да решите следния проблем:\nДадени са цели числа c и d, където a + b = c и a * b = d, намерете и върнете възможната стойност на a (a <= b). Ако има множество групи, изведете групата с най-малката a.\n    Параметри:\n    - c (int): Сумата на a и b.\n    - d (int): Произведението на a и b.\n\n    Връща:\n    Optional[int]: Възможна стойност на a. Връща -1, ако не съществуват валидни стойности,\n\n    >>> f_22(7,11)\n    -1", "zh": "编写一个 C 函数 `int f_22(int c, int d)` 来解决以下问题：\n给定整数 c 和 d，其中 a + b = c 且 a * b = d，找到并返回可能的 a 的值 (a <= b)。如果有多个组合，输出 a 最小的组合。  \n参数:  \n- c (int): a 和 b 的和。  \n- d (int): a 和 b 的积。  \n\n返回:  \nOptional[int]: a 的可能值。如果不存在有效值，则返回 -1。  \n\n    >>> f_22(7,11)\n    -1  ", "fr": "Écrire une fonction C `int f_22(int c, int d)` pour résoudre le problème suivant :\nÉtant donné les entiers c et d, où a + b = c et a * b = d, trouver et retourner la valeur possible de a (a <= b). S'il y a plusieurs groupes, afficher le groupe avec le plus petit a.  \n    Paramètres :  \n    - c (int) : La somme de a et b.  \n    - d (int) : Le produit de a et b.  \n\n    Renvoie :  \n    Optional[int] : Une valeur possible de a. Renvoie -1 si des valeurs valides n'existent pas,  \n\n    >>> f_22(7,11)  \n    -1  ", "de": "Schreiben Sie eine C-Funktion `int f_22(int c, int d)`, um das folgende Problem zu lösen:\nGegeben sind die Ganzzahlen c und d, wobei a + b = c und a * b = d, finde und gib den möglichen Wert von a zurück (a <= b). Wenn es mehrere Gruppen gibt, gib die Gruppe mit dem kleinsten a aus.\n    Parameter:\n    - c (int): Die Summe von a und b.\n    - d (int): Das Produkt von a und b.\n\n    Rückgabewert:\n    Optional[int]: Ein möglicher Wert von a. Gibt -1 zurück, wenn keine gültigen Werte existieren,\n\n    >>> f_22(7,11)\n    -1", "ha": "Rubuta aikin C `int f_22(int c, int d)` don warware matsalar mai zuwa:\nAn ba da lambobin c da d, inda a + b = c da a * b = d, nemo kuma dawo da yiwuwar ƙimar a (a <= b). Idan akwai kungiyoyi da yawa, fitar da ƙungiyar tare da mafi ƙarancin a.\n    Sigogi:\n    - c (int): Jimillar a da b.\n    - d (int): Samfurin a da b.\n\n    Returns:\n    Optional[int]: Iwuwar ƙimar a. Yana dawowa -1 idan ƙimomin da suka dace ba su wanzu,\n\n    >>> f_22(7,11)\n    -1", "hi": "C फ़ंक्शन `int f_22(int c, int d)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए पूर्णांक c और d, जहाँ a + b = c और a * b = d, a का संभावित मान खोजें और लौटाएं (a <= b)। यदि कई समूह हैं, तो सबसे छोटे a वाले समूह को आउटपुट करें।\n    पैरामीटर्स:\n    - c (int): a और b का योग।\n    - d (int): a और b का गुणनफल।\n\n    रिटर्न्स:\n    Optional[int]: a का एक संभावित मान। यदि मान्य मान मौजूद नहीं हैं तो -1 लौटाता है,\n\n    >>> f_22(7,11)\n    -1", "hu": "Írj egy C függvényt `int f_22(int c, int d)` a következő probléma megoldására:\nAdott c és d egész számok, ahol a + b = c és a * b = d, találd meg és add vissza a lehetséges a értéket (a <= b). Ha több csoport van, add vissza azt a csoportot, amelyikben a legkisebb a.\n\nParaméterek:\n- c (int): a és b összege.\n- d (int): a és b szorzata.\n\nVisszatérési érték:\nOpcionális[int]: a lehetséges a érték. -1-et ad vissza, ha nem léteznek érvényes értékek.\n\n    >>> f_22(7,11)\n    -1", "es": "Escribe una función en C `int f_22(int c, int d)` para resolver el siguiente problema:\nDado los enteros c y d, donde a + b = c y a * b = d, encuentra y devuelve el valor posible de a (a <= b). Si hay múltiples grupos, devuelve el grupo con el menor a.\n    Parámetros:\n    - c (int): La suma de a y b.\n    - d (int): El producto de a y b.\n\n    Retorna:\n    Optional[int]: Un valor posible de a. Devuelve -1 si no existen valores válidos,\n\n    >>> f_22(7,11)\n    -1", "arb": "اكتب دالة بلغة C `int f_22(int c, int d)` لحل المشكلة التالية:\nبالنظر إلى الأعداد الصحيحة c و d، حيث a + b = c و a * b = d، ابحث وأرجع القيمة الممكنة لـ a (حيث a <= b). إذا كانت هناك مجموعات متعددة، أعطِ المجموعة التي تحتوي على أصغر قيمة لـ a.\n    المعاملات:\n    - c (int): مجموع a و b.\n    - d (int): حاصل ضرب a و b.\n\n    العائدات:\n    Optional[int]: قيمة ممكنة لـ a. يرجع -1 إذا لم تكن هناك قيم صالحة موجودة.\n\n    >>> f_22(7,11)\n    -1", "sw": "Andika kazi ya C `int f_22(int c, int d)` kutatua tatizo lifuatalo:\nKwa kupewa nambari za c na d, ambapo a + b = c na a * b = d, tafuta na rudisha thamani inayowezekana ya a (a <= b). Ikiwa kuna makundi mengi, toa kundi lenye a ndogo zaidi.\n    Vigezo:\n    - c (int): Jumla ya a na b.\n    - d (int): Bidhaa ya a na b.\n\n    Inarudisha:\n    Optional[int]: Thamani inayowezekana ya a. Inarudisha -1 ikiwa thamani halali hazipo,\n\n    >>> f_22(7,11)\n    -1", "tr": "Bir C fonksiyonu `int f_22(int c, int d)` yazın ve aşağıdaki problemi çözün:\nVerilen tamsayılar c ve d için, burada a + b = c ve a * b = d, a'nın olası değerini bulun ve döndürün (a <= b). Birden fazla grup varsa, en küçük a'ya sahip olan grubu çıktılayın.\n    Parametreler:\n    - c (int): a ve b'nin toplamı.\n    - d (int): a ve b'nin çarpımı.\n\n    Dönüş:\n    Optional[int]: a'nın olası bir değeri. Geçerli değerler yoksa -1 döner.\n\n    >>> f_22(7,11)\n    -1", "vi": "Viết một hàm C `int f_22(int c, int d)` để giải quyết vấn đề sau:\nCho các số nguyên c và d, trong đó a + b = c và a * b = d, tìm và trả về giá trị có thể của a (a <= b). Nếu có nhiều nhóm, xuất nhóm với a nhỏ nhất.\n    \n    Tham số:\n    - c (int): Tổng của a và b.\n    - d (int): Tích của a và b.\n\n    Trả về:\n    Optional[int]: Một giá trị có thể của a. Trả về -1 nếu không tồn tại giá trị hợp lệ,\n\n    >>> f_22(7,11)\n    -1", "id": "Tulis sebuah fungsi C `int f_22(int c, int d)` untuk menyelesaikan masalah berikut:\nDiberikan bilangan bulat c dan d, di mana a + b = c dan a * b = d, temukan dan kembalikan nilai yang mungkin dari a (a <= b). Jika ada beberapa kelompok, keluarkan kelompok dengan a terkecil.\n    Parameter:\n    - c (int): Jumlah dari a dan b.\n    - d (int): Hasil kali dari a dan b.\n\n    Mengembalikan:\n    Optional[int]: Nilai yang mungkin dari a. Mengembalikan -1 jika nilai yang valid tidak ada,\n\n    >>> f_22(7,11)\n    -1", "ja": "Cの関数を書け `int f_22(int c, int d)` を作成して、次の問題を解決してください:\n整数 c と d が与えられたとき、a + b = c および a * b = d となる a の可能な値を見つけて返します (a <= b)。複数の組み合わせがある場合は、a が最小となる組み合わせを出力してください。\n    パラメータ:\n    - c (int): a と b の和。\n    - d (int): a と b の積。\n\n    戻り値:\n    Optional[int]: a の可能な値。適切な値が存在しない場合は -1 を返します。\n\n    >>> f_22(7,11)\n    -1", "ko": "C 함수 `int f_22(int c, int d)`를 작성하여 다음 문제를 해결하십시오:\n정수 c와 d가 주어졌을 때, a + b = c이고 a * b = d인 a의 가능한 값을 찾고 반환합니다 (a <= b). 여러 그룹이 있는 경우, a가 가장 작은 그룹을 출력합니다.\n    \n    매개변수:\n    - c (int): a와 b의 합.\n    - d (int): a와 b의 곱.\n\n    반환값:\n    Optional[int]: a의 가능한 값. 유효한 값이 존재하지 않으면 -1을 반환합니다.\n\n    >>> f_22(7,11)\n    -1", "ml": "C ഫംഗ്ഷൻ `int f_22(int c, int d)` എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nഇൻറിജറുകൾ c, d നൽകിയിരിക്കുന്നു, ഇവിടെ a + b = c കൂടാതെ a * b = d, a (a <= b) യുടെ സാധ്യതയുള്ള മൂല്യം കണ്ടെത്തി മടക്കുക. ഒരേ സമയം നിരവധി ഗ്രൂപ്പുകൾ ഉണ്ടെങ്കിൽ, ഏറ്റവും ചെറിയ a ഉള്ള ഗ്രൂപ്പ് ഔട്ട്‌പുട്ട് ചെയ്യുക.\n    പാരാമീറ്ററുകൾ:\n    - c (int): a, b യുടെ ആകെ ഫലം.\n    - d (int): a, b യുടെ ഗുണഫലം.\n\n    മടക്കൽ: \n    ഓപ്ഷണൽ[int]: a യുടെ സാധ്യതയുള്ള മൂല്യം. സാധുവായ മൂല്യങ്ങൾ ഇല്ലെങ്കിൽ -1 മടക്കുന്നു,\n\n    >>> f_22(7,11)\n    -1", "fa": "یک تابع C به نام `int f_22(int c, int d)` بنویسید تا مسئله زیر را حل کند:\nبا توجه به اعداد صحیح c و d، که در آن a + b = c و a * b = d، مقدار ممکن a را پیدا کرده و برگردانید (a <= b). اگر گروه‌های متعددی وجود دارند، گروهی را که کوچکترین a را دارد خروجی دهید.\n    پارامترها:\n    - c (int): مجموع a و b.\n    - d (int): حاصل‌ضرب a و b.\n\n    بازگشت:\n    Optional[int]: یک مقدار ممکن از a. اگر مقادیر معتبر وجود نداشته باشند، -1 را برمی‌گرداند.\n\n    >>> f_22(7,11)\n    -1"}, "level": "easy", "test": "int main() {\n    assert(f_22(5, 6) == 2);\n    assert(f_22(6, 9) == 3);\n    assert(f_22(7, 12) == 3);\n    assert(f_22(7, 11) == -1);\n    assert(f_22(9, 8) == 1);\n    assert(f_22(10, 25) == 5);\n    assert(f_22(10000, 8765) == -1);\n\n    \n\n    return 0;\n}", "entry_point": "f_22", "signature": "int f_22(int c, int d)", "docstring": {"en": "Given integers c and d, where a + b = c and a * b = d, find and return the possible value of a (a <= b). If there are multiple groups, output the group with the smallest a.\n    Parameters:\n    - c (int): The sum of a and b.\n    - d (int): The product of a and b.\n\n    Returns:\n    Optional[int]: A possible value of a. Returns -1 if valid values do not exist,\n\n    >>> f_22(7,11)\n    -1\n", "sq": "Duke pasur parasysh numrat e plotë c dhe d, ku a + b = c dhe a * b = d, gjeni dhe ktheni vlerën e mundshme të a (a <= b). Nëse ka grupe të shumta, jepni grupin me vlerën më të vogël të a.\n    \n    Parametrat:\n    - c (int): Shuma e a dhe b.\n    - d (int): Produkti i a dhe b.\n\n    Kthen:\n    Optional[int]: Një vlerë e mundshme e a. Kthen -1 nëse vlerat e vlefshme nuk ekzistojnë,\n\n    >>> f_22(7,11)\n    -1", "hy": "Տրված են ամբողջ թվեր c և d, որտեղ a + b = c և a * b = d, գտնել և վերադարձնել a-ի հնարավոր արժեքը (a <= b): Եթե կան բազմաթիվ խմբեր, վերադարձնել այն խումբը, որտեղ a-ն ամենափոքրն է:\n    \n    Պարամետրեր:\n    - c (int): a-ի և b-ի գումարը:\n    - d (int): a-ի և b-ի արտադրյալը:\n\n    Վերադարձնում է:\n    Optional[int]: a-ի հնարավոր արժեք: Վերադարձնում է -1, եթե վավեր արժեքներ չկան,\n\n    >>> f_22(7,11)\n    -1", "bn": "দেওয়া পূর্ণসংখ্যা c এবং d এর জন্য, যেখানে a + b = c এবং a * b = d, a এর সম্ভাব্য মান খুঁজে বের করুন এবং ফেরত দিন (a <= b)। যদি একাধিক গ্রুপ থাকে, তাহলে সবচেয়ে ছোট a সহ গ্রুপটি আউটপুট করুন।\n    \n    প্যারামিটারসমূহ:\n    - c (int): a এবং b এর যোগফল।\n    - d (int): a এবং b এর গুণফল।\n\n    রিটার্নস:\n    Optional[int]: a এর একটি সম্ভাব্য মান। যদি বৈধ মান বিদ্যমান না থাকে, তাহলে -1 ফেরত দেয়,\n\n    >>> f_22(7,11)\n    -1", "bg": "Дадени са цели числа c и d, където a + b = c и a * b = d, намерете и върнете възможната стойност на a (a <= b). Ако има няколко групи, изведете групата с най-малката a.\n    Параметри:\n    - c (int): Сумата на a и b.\n    - d (int): Произведението на a и b.\n\n    Връща:\n    Optional[int]: Възможна стойност на a. Връща -1, ако не съществуват валидни стойности.\n\n    >>> f_22(7,11)\n    -1", "zh": "给定整数 c 和 d，其中 a + b = c 且 a * b = d，找出并返回可能的 a 的值（a <= b）。如果有多个组合，输出 a 最小的组合。\n    参数:\n    - c (int): a 和 b 的和。\n    - d (int): a 和 b 的积。\n\n    返回:\n    Optional[int]: a 的一个可能值。如果不存在有效值，则返回 -1。\n\n    >>> f_22(7,11)\n    -1", "fr": "Étant donné des entiers c et d, où a + b = c et a * b = d, trouver et retourner la valeur possible de a (a <= b). S'il y a plusieurs groupes, sortir le groupe avec le plus petit a.\n    Paramètres:\n    - c (int): La somme de a et b.\n    - d (int): Le produit de a et b.\n\n    Renvoie:\n    Optional[int]: Une valeur possible de a. Renvoie -1 si des valeurs valides n'existent pas,\n\n    >>> f_22(7,11)\n    -1", "de": "Gegeben sind die Ganzzahlen c und d, wobei a + b = c und a * b = d, finde und gib den möglichen Wert von a zurück (a <= b). Wenn es mehrere Gruppen gibt, gib die Gruppe mit dem kleinsten a aus.\n    \nParameter:\n- c (int): Die Summe von a und b.\n- d (int): Das Produkt von a und b.\n\nRückgabe:\nOptional[int]: Ein möglicher Wert von a. Gibt -1 zurück, wenn keine gültigen Werte existieren.\n\n>>> f_22(7,11)\n-1", "ha": "An ba da lambobin c da d, inda a + b = c da a * b = d, nemo kuma dawo da yiwuwar ƙimar a (a <= b). Idan akwai rukuni da yawa, fitar da rukuni tare da ƙaramin a.\n    \n    Sigogi:\n    - c (int): Jimillar a da b.\n    - d (int): Samfurin a da b.\n\n    Komawa:\n    Optional[int]: Iwuwar ƙimar a. Yana dawowa -1 idan ba a sami ingantattun ƙima ba,\n\n    >>> f_22(7,11)\n    -1", "hi": "दिए गए पूर्णांक c और d, जहाँ a + b = c और a * b = d, a का संभावित मान खोजें और लौटाएं (a <= b)। यदि कई समूह हैं, तो सबसे छोटे a वाले समूह को आउटपुट करें।\n\n    पैरामीटर्स:\n    - c (int): a और b का योग।\n    - d (int): a और b का गुणनफल।\n\n    रिटर्न्स:\n    Optional[int]: a का एक संभावित मान। यदि मान्य मान मौजूद नहीं हैं, तो -1 लौटाता है।\n\n    >>> f_22(7,11)\n    -1", "hu": "Adott c és d egész számok, ahol a + b = c és a * b = d, találja meg és adja vissza a lehetséges a értékét (a <= b). Ha több csoport van, adja vissza azt a csoportot, amelyikben a legkisebb a.\n    Paraméterek:\n    - c (int): a és b összege.\n    - d (int): a és b szorzata.\n\n    Visszatérési érték:\n    Optional[int]: a lehetséges a értéke. -1-et ad vissza, ha nem léteznek érvényes értékek.\n\n    >>> f_22(7,11)\n    -1", "es": "Dado enteros c y d, donde a + b = c y a * b = d, encuentra y devuelve el valor posible de a (a <= b). Si hay múltiples grupos, devuelve el grupo con el menor a.\n    Parámetros:\n    - c (int): La suma de a y b.\n    - d (int): El producto de a y b.\n\n    Devuelve:\n    Optional[int]: Un valor posible de a. Devuelve -1 si no existen valores válidos,\n\n    >>> f_22(7,11)\n    -1", "arb": "نظرًا للأعداد الصحيحة c و d، حيث a + b = c و a * b = d، ابحث وأعد القيمة المحتملة لـ a (حيث a <= b). إذا كانت هناك مجموعات متعددة، قم بإخراج المجموعة ذات القيمة الأصغر لـ a.\n    المعاملات:\n    - c (int): مجموع a و b.\n    - d (int): حاصل ضرب a و b.\n\n    يعيد:\n    Optional[int]: قيمة محتملة لـ a. يعيد -1 إذا لم تكن هناك قيم صالحة موجودة.\n\n    >>> f_22(7,11)\n    -1", "sw": "Kwa kupewa nambari za mzima c na d, ambapo a + b = c na a * b = d, tafuta na rudisha thamani inayowezekana ya a (a <= b). Ikiwa kuna makundi mengi, toa kundi lenye a ndogo zaidi.\n    \n    Vigezo:\n    - c (int): Jumla ya a na b.\n    - d (int): Bidhaa ya a na b.\n\n    Inarudisha:\n    Optional[int]: Thamani inayowezekana ya a. Inarudisha -1 ikiwa thamani halali hazipo,\n\n    >>> f_22(7,11)\n    -1", "tr": "Verilen c ve d tamsayıları için, burada a + b = c ve a * b = d, a'nın olası değerini bulun ve döndürün (a <= b). Birden fazla grup varsa, en küçük a'ya sahip grubu çıktılayın.\n    Parametreler:\n    - c (int): a ve b'nin toplamı.\n    - d (int): a ve b'nin çarpımı.\n\n    Döndürür:\n    Optional[int]: a'nın olası bir değeri. Geçerli değerler yoksa -1 döner.\n\n    >>> f_22(7,11)\n    -1", "vi": "Cho các số nguyên c và d, trong đó a + b = c và a * b = d, tìm và trả về giá trị có thể của a (a <= b). Nếu có nhiều nhóm, xuất nhóm với a nhỏ nhất.\n    Tham số:\n    - c (int): Tổng của a và b.\n    - d (int): Tích của a và b.\n\n    Trả về:\n    Optional[int]: Một giá trị có thể có của a. Trả về -1 nếu không tồn tại giá trị hợp lệ,\n\n    >>> f_22(7,11)\n    -1", "id": "Diberikan bilangan bulat c dan d, di mana a + b = c dan a * b = d, temukan dan kembalikan nilai a yang mungkin (a <= b). Jika ada beberapa kelompok, keluarkan kelompok dengan a terkecil.\n    \n    Parameter:\n    - c (int): Jumlah dari a dan b.\n    - d (int): Hasil kali dari a dan b.\n\n    Mengembalikan:\n    Optional[int]: Nilai a yang mungkin. Mengembalikan -1 jika nilai yang valid tidak ada,\n\n    >>> f_22(7,11)\n    -1", "ja": "整数 c と d が与えられたとき、a + b = c かつ a * b = d となる a の可能な値を見つけて返します (a <= b)。複数のグループがある場合は、a が最小のグループを出力します。\n    パラメータ:\n    - c (int): a と b の和。\n    - d (int): a と b の積。\n\n    戻り値:\n    Optional[int]: a の可能な値。妥当な値が存在しない場合は -1 を返します。\n\n    >>> f_22(7,11)\n    -1", "ko": "주어진 정수 c와 d에 대해, a + b = c이고 a * b = d인 가능한 a의 값을 찾고 반환합니다 (a <= b). 여러 그룹이 있는 경우, a가 가장 작은 그룹을 출력합니다.\n    \n    매개변수:\n    - c (int): a와 b의 합.\n    - d (int): a와 b의 곱.\n\n    반환값:\n    Optional[int]: 가능한 a의 값. 유효한 값이 존재하지 않으면 -1을 반환합니다.\n\n    >>> f_22(7,11)\n    -1", "ml": "ഇന്റീജറുകൾ c, d നൽകുമ്പോൾ, a + b = c കൂടാതെ a * b = d ആയിടത്ത്, a യുടെ സാധ്യതയുള്ള മൂല്യം കണ്ടെത്തി മടക്കുക (a <= b). നിരവധി ഗ്രൂപ്പുകൾ ഉണ്ടെങ്കിൽ, ഏറ്റവും ചെറിയ a ഉള്ള ഗ്രൂപ്പ് ഔട്ട്പുട്ട് ചെയ്യുക.\n\n    പാരാമീറ്ററുകൾ:\n    - c (int): aയും bയും ചേർന്നുള്ള മൊത്തം.\n    - d (int): aയും bയും ചേർന്നുള്ള ഗുണനം.\n\n    മടക്കുന്നു:\n    Optional[int]: aയുടെ ഒരു സാധ്യമായ മൂല്യം. സാധുവായ മൂല്യങ്ങൾ ഇല്ലെങ്കിൽ -1 മടക്കുന്നു,\n\n    >>> f_22(7,11)\n    -1", "fa": "با توجه به اعداد صحیح c و d، که در آن a + b = c و a * b = d، مقدار ممکن a را پیدا کرده و برگردانید (a <= b). اگر گروه‌های متعددی وجود داشته باشد، گروهی را که کوچکترین a را دارد، خروجی دهید.\n    \n    پارامترها:\n    - c (int): مجموع a و b.\n    - d (int): حاصل‌ضرب a و b.\n\n    بازگشت:\n    Optional[int]: یک مقدار ممکن از a. اگر مقادیر معتبر وجود نداشته باشد، -1 برمی‌گرداند.\n\n    >>> f_22(7,11)\n    -1"}}
{"task_id": "C/23", "prompt": {"en": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n/*\nCount the number of acute-angled triangles that can be formed by selecting any 3 edges out of a given set of edges.\n    \nArgs:\n- edges_count: The number of edges passed.\n- An arbitrary number of integer arguments representing the lengths of the edges.\n    \nReturns:\nint: The count of distinct acute-angled triangles that can be formed.\n    \nExamples:\n>>> f_23(4, 1, 1, 1, 1)\n4\n*/\nint f_23(int edges_count, ...)", "sq": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n/*\nNumëroni numrin e trekëndëshave me kënd të mprehtë që mund të formohen duke zgjedhur çdo 3 brinjë nga një grup i dhënë brinjësh.\n    \nArgumentet:\n- edges_count: Numri i brinjëve të dhëna.\n- Një numër arbitrar i argumenteve të tipit integer që përfaqësojnë gjatësitë e brinjëve.\n    \nKthen:\nint: Numri i trekëndëshave të dallueshëm me kënd të mprehtë që mund të formohen.\n    \nShembuj:\n>>> f_23(4, 1, 1, 1, 1)\n4\n*/\nint f_23(int edges_count, ...)", "hy": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n/*\nՀաշվել սուրանկյուն եռանկյունների քանակը, որոնք կարող են կազմվել ընտրելով ցանկացած 3 կողեր տրված կողերի հավաքածուից։\n    \nԱրգումենտներ:\n- edges_count: Անցկացված կողերի քանակը։\n- Կողերի երկարությունները ներկայացնող ամբողջ թվային կամայական քանակի արգումենտներ։\n    \nՎերադարձնում է:\nint: Տարբեր սուրանկյուն եռանկյունների քանակը, որոնք կարող են կազմվել։\n    \nՕրինակներ:\n>>> f_23(4, 1, 1, 1, 1)\n4\n*/\nint f_23(int edges_count, ...)", "bn": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n/*\nপ্রদত্ত প্রান্তের একটি সেট থেকে যেকোনো ৩টি প্রান্ত নির্বাচন করে কতগুলি তীক্ষ্ণ-কোণী ত্রিভুজ তৈরি করা যেতে পারে তা গণনা করুন।\n    \nআর্গুমেন্টসমূহ:\n- edges_count: প্রেরিত প্রান্তের সংখ্যা।\n- প্রান্তের দৈর্ঘ্য প্রতিনিধিত্বকারী একটি স্বেচ্ছামূলক সংখ্যক পূর্ণসংখ্যা আর্গুমেন্ট।\n    \nফেরত দেয়:\nint: গঠিত পৃথক তীক্ষ্ণ-কোণী ত্রিভুজের সংখ্যা।\n    \nউদাহরণ:\n>>> f_23(4, 1, 1, 1, 1)\n4\n*/\nint f_23(int edges_count, ...)", "bg": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n/*\nБройте броя на остроъгълните триъгълници, които могат да бъдат образувани чрез избиране на произволни 3 ръба от даден набор от ръбове.\n    \nАргументи:\n- edges_count: Броят на предадените ръбове.\n- Произволен брой цели аргументи, представляващи дължините на ръбовете.\n    \nВръща:\nint: Броят на различните остроъгълни триъгълници, които могат да бъдат образувани.\n    \nПримери:\n>>> f_23(4, 1, 1, 1, 1)\n4\n*/\nint f_23(int edges_count, ...)", "zh": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n/*\n计算可以通过从给定的一组边中选择任意3条边形成的锐角三角形的数量。\n    \n参数：\n- edges_count: 传递的边的数量。\n- 任意数量的整数参数，表示边的长度。\n    \n返回：\nint: 可以形成的不同锐角三角形的数量。\n    \n示例：\n>>> f_23(4, 1, 1, 1, 1)\n4\n*/\nint f_23(int edges_count, ...)", "fr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n/*\nCompter le nombre de triangles acutangles qui peuvent être formés en sélectionnant 3 arêtes parmi un ensemble donné d'arêtes.\n    \nArguments:\n- edges_count: Le nombre d'arêtes passées.\n- Un nombre arbitraire d'arguments entiers représentant les longueurs des arêtes.\n    \nRenvoie:\nint: Le nombre de triangles acutangles distincts qui peuvent être formés.\n    \nExemples:\n>>> f_23(4, 1, 1, 1, 1)\n4\n*/\nint f_23(int edges_count, ...)", "de": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n/*\nZählt die Anzahl der spitzwinkligen Dreiecke, die gebildet werden können, indem beliebige 3 Kanten aus einem gegebenen Satz von Kanten ausgewählt werden.\n\nArgumente:\n- edges_count: Die Anzahl der übergebenen Kanten.\n- Eine beliebige Anzahl von ganzzahligen Argumenten, die die Längen der Kanten darstellen.\n\nRückgabewert:\nint: Die Anzahl der verschiedenen spitzwinkligen Dreiecke, die gebildet werden können.\n\nBeispiele:\n>>> f_23(4, 1, 1, 1, 1)\n4\n*/\nint f_23(int edges_count, ...)", "ha": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n/*\nƘirga adadin kusurwoyi masu kaifi waɗanda za a iya samarwa ta zaɓar kowane 3 gefuna daga cikin wani saiti na gefuna.\n\nArgs:\n- edges_count: Yawan gefuna da aka gabatar.\n- Adadin hujjoji na lamba masu zaman kansu waɗanda ke wakiltar tsawon gefuna.\n\nReturns:\nint: Adadin kusurwoyi masu kaifi masu bambanci waɗanda za a iya samarwa.\n\nMisalai:\n>>> f_23(4, 1, 1, 1, 1)\n4\n*/\nint f_23(int edges_count, ...)", "hi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n/*\nदिए गए किनारों के सेट में से किसी भी 3 किनारों का चयन करके बनने वाले तीव्रकोण त्रिभुजों की संख्या गिनें।\n\nआर्ग्स:\n- edges_count: पास किए गए किनारों की संख्या।\n- किनारों की लंबाई का प्रतिनिधित्व करने वाले कई पूर्णांक तर्क।\n\nवापसी:\nint: बनने वाले विशिष्ट तीव्रकोण त्रिभुजों की संख्या।\n\nउदाहरण:\n>>> f_23(4, 1, 1, 1, 1)\n4\n*/\nint f_23(int edges_count, ...)", "hu": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n/*\nSzámolja meg a hegyesszögű háromszögek számát, amelyek úgy képezhetők, hogy bármely 3 élt kiválasztunk a megadott élek halmazából.\n    \nArgok:\n- edges_count: Az átadott élek száma.\n- Tetszőleges számú egész szám argumentum, amelyek az élek hosszát képviselik.\n    \nVisszatér:\nint: Az elkülöníthető hegyesszögű háromszögek száma, amelyek képezhetők.\n    \nPéldák:\n>>> f_23(4, 1, 1, 1, 1)\n4\n*/\nint f_23(int edges_count, ...)", "es": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n/*\nCuenta el número de triángulos acutángulos que se pueden formar seleccionando cualquier 3 lados de un conjunto dado de lados.\n    \nArgs:\n- edges_count: El número de lados pasados.\n- Un número arbitrario de argumentos enteros que representan las longitudes de los lados.\n    \nReturns:\nint: La cantidad de triángulos acutángulos distintos que se pueden formar.\n    \nExamples:\n>>> f_23(4, 1, 1, 1, 1)\n4\n*/\nint f_23(int edges_count, ...)", "arb": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n/*\nاحسب عدد المثلثات الحادة الزاوية التي يمكن تشكيلها عن طريق اختيار أي 3 حواف من مجموعة معينة من الحواف.\n\nالمعطيات:\n- edges_count: عدد الحواف الممررة.\n- عدد تعسفي من المعطيات الصحيحة التي تمثل أطوال الحواف.\n\nالقيم المعادة:\nint: عدد المثلثات الحادة الزاوية المميزة التي يمكن تشكيلها.\n\nأمثلة:\n>>> f_23(4, 1, 1, 1, 1)\n4\n*/\nint f_23(int edges_count, ...)", "sw": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n/*\nHesabu idadi ya pembetatu zenye pembe kali ambazo zinaweza kuundwa kwa kuchagua pande 3 zozote kutoka kwenye seti ya pande zilizotolewa.\n    \nArgs:\n- edges_count: Idadi ya pande zilizopitishwa.\n- Idadi isiyo ya kawaida ya hoja za nambari nzima zinazowakilisha urefu wa pande.\n    \nReturns:\nint: Idadi ya pembetatu tofauti zenye pembe kali ambazo zinaweza kuundwa.\n    \nExamples:\n>>> f_23(4, 1, 1, 1, 1)\n4\n*/\nint f_23(int edges_count, ...)", "tr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n/*\nVerilen bir dizi kenardan herhangi 3 kenar seçilerek oluşturulabilecek dik açılı üçgenlerin sayısını sayar.\n    \nArgümanlar:\n- edges_count: Geçilen kenarların sayısı.\n- Kenarların uzunluklarını temsil eden rastgele sayıda tamsayı argümanı.\n    \nDöndürür:\nint: Oluşturulabilecek farklı dik açılı üçgenlerin sayısı.\n    \nÖrnekler:\n>>> f_23(4, 1, 1, 1, 1)\n4\n*/\nint f_23(int edges_count, ...)", "vi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n/*\nĐếm số lượng tam giác nhọn có thể được tạo thành bằng cách chọn bất kỳ 3 cạnh nào từ một tập hợp các cạnh đã cho.\n    \nTham số:\n- edges_count: Số lượng cạnh được truyền vào.\n- Một số lượng tùy ý các tham số kiểu số nguyên đại diện cho độ dài của các cạnh.\n    \nTrả về:\nint: Số lượng tam giác nhọn khác nhau có thể được tạo thành.\n    \nVí dụ:\n>>> f_23(4, 1, 1, 1, 1)\n4\n*/\nint f_23(int edges_count, ...)", "id": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n/*\nHitung jumlah segitiga lancip yang dapat dibentuk dengan memilih 3 sisi dari sekumpulan sisi yang diberikan.\n    \nArgumen:\n- edges_count: Jumlah sisi yang diberikan.\n- Sejumlah argumen integer yang mewakili panjang sisi-sisi tersebut.\n    \nMengembalikan:\nint: Jumlah segitiga lancip yang berbeda yang dapat dibentuk.\n    \nContoh:\n>>> f_23(4, 1, 1, 1, 1)\n4\n*/\nint f_23(int edges_count, ...)", "ja": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n/*\n与えられたエッジのセットから任意の3つのエッジを選択することによって形成できる鋭角三角形の数を数えます。\n    \n引数:\n- edges_count: 渡されたエッジの数。\n- エッジの長さを表す任意の数の整数引数。\n    \n戻り値:\nint: 形成できる異なる鋭角三角形の数。\n    \n例:\n>>> f_23(4, 1, 1, 1, 1)\n4\n*/\nint f_23(int edges_count, ...)\n", "ko": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n/*\n주어진 변 집합에서 임의의 3개의 변을 선택하여 만들 수 있는 예각 삼각형의 개수를 계산합니다.\n    \n매개변수:\n- edges_count: 전달된 변의 수.\n- 변의 길이를 나타내는 임의의 개수의 정수 인수.\n    \n반환:\nint: 만들 수 있는 서로 다른 예각 삼각형의 개수.\n    \n예시:\n>>> f_23(4, 1, 1, 1, 1)\n4\n*/\nint f_23(int edges_count, ...)\n", "ml": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n/*\nനൽകിയിരിക്കുന്ന എഡ്ജുകളുടെ ഒരു സെറ്റിൽ നിന്ന് ഏതെങ്കിലും 3 എഡ്ജുകൾ തിരഞ്ഞെടുക്കുന്നതിലൂടെ രൂപീകരിക്കാവുന്ന മൂർച്ചയുള്ള മൂലമുള്ള ത്രികോണങ്ങളുടെ എണ്ണം എണ്ണുക.\n    \nആർഗ്സ്:\n- edges_count: പാസ്സായ എഡ്ജുകളുടെ എണ്ണം.\n- എഡ്ജുകളുടെ നീളങ്ങളെ പ്രതിനിധീകരിക്കുന്ന അനിയന്ത്രിതമായ സംഖ്യയുടെ പാരാമീറ്ററുകൾ.\n    \nമടക്കുന്നു:\nint: രൂപീകരിക്കാവുന്ന വ്യത്യസ്തമായ മൂർച്ചയുള്ള മൂലമുള്ള ത്രികോണങ്ങളുടെ എണ്ണം.\n    \nഉദാഹരണങ്ങൾ:\n>>> f_23(4, 1, 1, 1, 1)\n4\n*/\nint f_23(int edges_count, ...)", "fa": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n/*\nتعداد مثلث‌های تیزگوشه که می‌توان با انتخاب هر 3 ضلع از مجموعه‌ای از اضلاع تشکیل داد را بشمارید.\n    \nآرگومان‌ها:\n- edges_count: تعداد اضلاعی که داده شده است.\n- تعداد دلخواهی از آرگومان‌های عدد صحیح که طول اضلاع را نشان می‌دهند.\n    \nبازگشت:\nint: تعداد مثلث‌های تیزگوشه متمایزی که می‌توان تشکیل داد.\n    \nمثال‌ها:\n>>> f_23(4, 1, 1, 1, 1)\n4\n*/\nint f_23(int edges_count, ...)"}, "canonical_solution": "{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}", "instruction": {"en": "Write a C function `int f_23(int edges_count, ...)` to solve the following problem:\nCount the number of acute-angled triangles that can be formed by selecting any 3 edges out of a given set of edges.\n\nArgs:\n- edges_count: The number of edges passed.\n- An arbitrary number of integer arguments representing the lengths of the edges.\n\nReturns:\nint: The count of distinct acute-angled triangles that can be formed.\n\nExamples:\n>>> f_23(4, 1, 1, 1, 1)\n4\n", "sq": "Shkruani një funksion në C `int f_23(int edges_count, ...)` për të zgjidhur problemin e mëposhtëm:\nNumëroni numrin e trekëndëshave me kënd të mprehtë që mund të formohen duke zgjedhur çdo 3 brinjë nga një grup i dhënë brinjësh.\n\nArgumentet:\n- edges_count: Numri i brinjëve të dhëna.\n- Një numër arbitrar argumentesh të tipit integer që përfaqësojnë gjatësitë e brinjëve.\n\nKthen:\nint: Numri i trekëndëshave të dallueshëm me kënd të mprehtë që mund të formohen.\n\nShembuj:\n>>> f_23(4, 1, 1, 1, 1)\n4", "hy": "Գրեք C ֆունկցիա `int f_23(int edges_count, ...)` հետևյալ խնդիրը լուծելու համար:\nՀաշվեք սուրանկյուն եռանկյունիների քանակը, որոնք կարող են կազմվել տրված կողերից ցանկացած 3-ը ընտրելով:\n\nԱրգումենտներ:\n- edges_count: Անցկացվող կողերի քանակը:\n- Կողերի երկարությունները ներկայացնող ամբողջ թվերի կամայական քանակի արգումենտներ:\n\nՎերադարձնում է:\nint: Տարբեր սուրանկյուն եռանկյունիների քանակը, որոնք կարող են կազմվել:\n\nՕրինակներ:\n>>> f_23(4, 1, 1, 1, 1)\n4", "bn": "একটি C ফাংশন `int f_23(int edges_count, ...)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nপ্রদত্ত প্রান্তগুলির একটি সেট থেকে যেকোনো ৩টি প্রান্ত নির্বাচন করে কতগুলি তীক্ষ্ণ-কোণী ত্রিভুজ গঠন করা যেতে পারে তা গণনা করুন।\n\nআর্গুমেন্টসমূহ:\n- edges_count: পাস করা প্রান্তগুলির সংখ্যা।\n- প্রান্তগুলির দৈর্ঘ্য উপস্থাপনকারী একটি নির্বিচারে সংখ্যক পূর্ণসংখ্যার আর্গুমেন্ট।\n\nরিটার্নস:\nint: গঠিত হতে পারে এমন স্বতন্ত্র তীক্ষ্ণ-কোণী ত্রিভুজের সংখ্যা।\n\nউদাহরণ:\n>>> f_23(4, 1, 1, 1, 1)\n4", "bg": "Напишете C функция `int f_23(int edges_count, ...)`, за да решите следния проблем:\nПребройте броя на острите триъгълници, които могат да бъдат образувани чрез избиране на произволни 3 ръба от даден набор от ръбове.\n\nАргументи:\n- edges_count: Броят на предадените ръбове.\n- Произволен брой цели аргументи, представляващи дължините на ръбовете.\n\nВръща:\nint: Броят на различните остри триъгълници, които могат да бъдат образувани.\n\nПримери:\n>>> f_23(4, 1, 1, 1, 1)\n4", "zh": "编写一个 C 函数 `int f_23(int edges_count, ...)` 来解决以下问题：\n计算可以通过从给定的边集中选择任意 3 条边形成的锐角三角形的数量。\n\n参数：\n- edges_count: 传递的边的数量。\n- 任意数量的整数参数，表示边的长度。\n\n返回：\nint: 可以形成的不同锐角三角形的数量。\n\n示例：\n>>> f_23(4, 1, 1, 1, 1)\n4", "fr": "Écrire une fonction C `int f_23(int edges_count, ...)` pour résoudre le problème suivant :\nCompter le nombre de triangles acutangles qui peuvent être formés en sélectionnant n'importe quels 3 côtés parmi un ensemble donné de côtés.\n\nArgs:  \n- edges_count: Le nombre de côtés passés.  \n- Un nombre arbitraire d'arguments entiers représentant les longueurs des côtés.\n\nRetourne :  \nint : Le nombre de triangles acutangles distincts qui peuvent être formés.\n\nExemples :  \n>>> f_23(4, 1, 1, 1, 1)  \n4  ", "de": "Schreiben Sie eine C-Funktion `int f_23(int edges_count, ...)`, um das folgende Problem zu lösen:\nZählen Sie die Anzahl der spitzwinkligen Dreiecke, die gebildet werden können, indem Sie 3 Kanten aus einer gegebenen Menge von Kanten auswählen.\n\nArgumente:\n- edges_count: Die Anzahl der übergebenen Kanten.\n- Eine beliebige Anzahl von ganzzahligen Argumenten, die die Längen der Kanten darstellen.\n\nRückgabewert:\nint: Die Anzahl der verschiedenen spitzwinkligen Dreiecke, die gebildet werden können.\n\nBeispiele:\n>>> f_23(4, 1, 1, 1, 1)\n4", "ha": "Rubuta aikin C `int f_23(int edges_count, ...)` don warware matsalar mai zuwa:\nƘirga adadin kusurwoyi masu kaifi waɗanda za a iya samarwa ta hanyar zaɓar kowane 3 gefuna daga cikin wani saiti na gefuna.\n\nArgs:\n- edges_count: Yawan gefuna da aka gabatar.\n- Yawan hujjojin lamba masu zaman kansu waɗanda ke wakiltar tsawon gefuna.\n\nReturns:\nint: Adadin kusurwoyi masu kaifi daban-daban waɗanda za a iya samarwa.\n\nMisalai:\n>>> f_23(4, 1, 1, 1, 1)\n4", "hi": "एक C फ़ंक्शन `int f_23(int edges_count, ...)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए किनारों के सेट में से किसी भी 3 किनारों का चयन करके बनने वाले तीव्रकोण त्रिभुजों की संख्या गिनें।\n\nआर्ग्स:\n- edges_count: पास किए गए किनारों की संख्या।\n- किनारों की लंबाई का प्रतिनिधित्व करने वाले पूर्णांक तर्कों की एक मनमानी संख्या।\n\nवापसी:\nint: विशिष्ट तीव्रकोण त्रिभुजों की संख्या जो बनाई जा सकती है।\n\nउदाहरण:\n>>> f_23(4, 1, 1, 1, 1)\n4", "hu": "Írj egy C függvényt `int f_23(int edges_count, ...)` a következő probléma megoldására:\nSzámold meg a hegyesszögű háromszögek számát, amelyeket a megadott élek halmazából bármely 3 él kiválasztásával lehet kialakítani.\n\nArgs:\n- edges_count: Az átadott élek száma.\n- Tetszőleges számú egész számú argumentum, amelyek az élek hosszát képviselik.\n\nVisszatér:\nint: Azoknak a különböző hegyesszögű háromszögeknek a száma, amelyek kialakíthatók.\n\nPéldák:\n>>> f_23(4, 1, 1, 1, 1)\n4", "es": "Escribe una función en C `int f_23(int edges_count, ...)` para resolver el siguiente problema:\nCuenta el número de triángulos acutángulos que se pueden formar seleccionando cualquier 3 lados de un conjunto dado de lados.\n\nArgs:\n- edges_count: El número de lados pasados.\n- Un número arbitrario de argumentos enteros que representan las longitudes de los lados.\n\nReturns:\nint: La cantidad de triángulos acutángulos distintos que se pueden formar.\n\nExamples:\n>>> f_23(4, 1, 1, 1, 1)\n4", "arb": "اكتب دالة بلغة C `int f_23(int edges_count, ...)` لحل المشكلة التالية:\nاحسب عدد المثلثات الحادة الزوايا التي يمكن تشكيلها عن طريق اختيار أي 3 أضلاع من مجموعة الأضلاع المعطاة.\n\nArgs:\n- edges_count: عدد الأضلاع الممررة.\n- عدد تعسفي من المعطيات الصحيحة التي تمثل أطوال الأضلاع.\n\nالقيم المعادة:\nint: عدد المثلثات الحادة الزوايا المميزة التي يمكن تشكيلها.\n\nأمثلة:\n>>> f_23(4, 1, 1, 1, 1)\n4", "sw": "Andika kazi ya C `int f_23(int edges_count, ...)` kutatua tatizo lifuatalo:\nHesabu idadi ya pembetatu zenye pembe kali zinazoweza kuundwa kwa kuchagua pande 3 kutoka kwenye seti ya pande zilizotolewa.\n\nArgs:\n- edges_count: Idadi ya pande zilizopitishwa.\n- Idadi isiyo ya kawaida ya hoja za nambari za mzima zinazowakilisha urefu wa pande.\n\nReturns:\nint: Idadi ya pembetatu tofauti zenye pembe kali zinazoweza kuundwa.\n\nExamples:\n>>> f_23(4, 1, 1, 1, 1)\n4", "tr": "Bir C fonksiyonu `int f_23(int edges_count, ...)` yazın:\nVerilen bir dizi kenardan herhangi 3 kenar seçilerek oluşturulabilecek dar açılı üçgenlerin sayısını sayın.\n\nArgs:\n- edges_count: Geçilen kenarların sayısı.\n- Kenarların uzunluklarını temsil eden keyfi sayıda tamsayı argümanı.\n\nReturns:\nint: Oluşturulabilecek farklı dar açılı üçgenlerin sayısı.\n\nÖrnekler:\n>>> f_23(4, 1, 1, 1, 1)\n4", "vi": "Viết một hàm C `int f_23(int edges_count, ...)` để giải quyết vấn đề sau:\nĐếm số lượng tam giác nhọn có thể được tạo thành bằng cách chọn bất kỳ 3 cạnh nào từ một tập hợp các cạnh cho trước.\n\nArgs:\n- edges_count: Số lượng cạnh được truyền vào.\n- Một số lượng tùy ý các tham số nguyên đại diện cho độ dài của các cạnh.\n\nTrả về:\nint: Số lượng tam giác nhọn khác nhau có thể được tạo thành.\n\nVí dụ:\n>>> f_23(4, 1, 1, 1, 1)\n4", "id": "Tulis sebuah fungsi C `int f_23(int edges_count, ...)` untuk menyelesaikan masalah berikut:\nHitung jumlah segitiga lancip yang dapat dibentuk dengan memilih 3 sisi dari sekumpulan sisi yang diberikan.\n\nArgs:\n- edges_count: Jumlah sisi yang diberikan.\n- Sejumlah argumen bilangan bulat yang mewakili panjang sisi-sisi tersebut.\n\nMengembalikan:\nint: Jumlah segitiga lancip yang berbeda yang dapat dibentuk.\n\nContoh:\n>>> f_23(4, 1, 1, 1, 1)\n4", "ja": "Cの関数を書け `int f_23(int edges_count, ...)` を作成して、次の問題を解決してください:\n与えられたエッジのセットから任意の3つのエッジを選択して形成できる鋭角三角形の数を数えます。\n\n引数:\n- edges_count: 渡されるエッジの数。\n- エッジの長さを表す任意の数の整数引数。\n\n戻り値:\nint: 形成できる異なる鋭角三角形の数。\n\n例:\n>>> f_23(4, 1, 1, 1, 1)\n4", "ko": "C 함수 `int f_23(int edges_count, ...)`를 작성하여 다음 문제를 해결하십시오:\n주어진 모서리 집합에서 3개의 모서리를 선택하여 형성할 수 있는 예각 삼각형의 수를 계산합니다.\n\n인수:\n- edges_count: 전달된 모서리의 수.\n- 모서리의 길이를 나타내는 임의의 개수의 정수 인수.\n\n반환:\nint: 형성할 수 있는 고유한 예각 삼각형의 수.\n\n예시:\n>>> f_23(4, 1, 1, 1, 1)\n4", "ml": "ഒരു C ഫംഗ്ഷൻ `int f_23(int edges_count, ...)` എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nനൽകിയിരിക്കുന്ന ഒരു എഡ്ജുകളുടെ സെറ്റിൽ നിന്ന് ഏതെങ്കിലും 3 എഡ്ജുകൾ തിരഞ്ഞെടുക്കുന്നതിലൂടെ രൂപീകരിക്കാവുന്ന മൂർച്ചയുള്ള കോണുള്ള ത്രികോണങ്ങളുടെ എണ്ണം എണ്ണുക.\n\nആർഗ്യുമെന്റുകൾ:\n- edges_count: പാസ്സായ എഡ്ജുകളുടെ എണ്ണം.\n- എഡ്ജുകളുടെ നീളങ്ങൾ പ്രതിനിധീകരിക്കുന്ന ഒരു 任意整数 的数量 的 参数.\n\nമടക്കിക്കൊടുക്കുന്നു:\nint: രൂപീകരിക്കാവുന്ന വ്യത്യസ്തമായ മൂർച്ചയുള്ള കോണുള്ള ത്രികോണങ്ങളുടെ എണ്ണം.\n\nഉദാഹരണങ്ങൾ:\n>>> f_23(4, 1, 1, 1, 1)\n4", "fa": "یک تابع C بنویسید `int f_23(int edges_count, ...)` برای حل مسئله زیر:\nتعداد مثلث‌های تیزگوشه‌ای را که می‌توان با انتخاب هر ۳ ضلع از مجموعه‌ای از اضلاع تشکیل داد، بشمارید.\n\nآرگومان‌ها:\n- edges_count: تعداد اضلاعی که ارسال شده‌اند.\n- تعداد دلخواهی از آرگومان‌های صحیح که طول اضلاع را نشان می‌دهند.\n\nبرمی‌گرداند:\nint: تعداد مثلث‌های تیزگوشه متمایزی که می‌توان تشکیل داد.\n\nمثال‌ها:\n>>> f_23(4, 1, 1, 1, 1)\n4"}, "level": "hard", "test": "int main()\n{\n    assert(f_23(4, 1, 1, 1, 1) == 4);\n    assert(f_23(3, 1, 2, 3) == 0);\n    // Additional tests to ensure correctness\n    assert(f_23(5, 3, 4, 5, 7, 10) == 0);\n    assert(f_23(6, 6, 8, 10, 5, 5, 5) == 4);\n    return 0;\n}", "entry_point": "f_23", "signature": "int f_23(int edges_count, ...)", "docstring": {"en": "Count the number of acute-angled triangles that can be formed by selecting any 3 edges out of a given set of edges.\n\nArgs:\n- edges_count: The number of edges passed.\n- An arbitrary number of integer arguments representing the lengths of the edges.\n\nReturns:\nint: The count of distinct acute-angled triangles that can be formed.\n\nExamples:\n>>> f_23(4, 1, 1, 1, 1)\n4\n", "sq": "Numëroni numrin e trekëndëshave këndakut që mund të formohen duke zgjedhur çdo 3 brinjë nga një grup i dhënë brinjësh.\n\nArgs:\n- edges_count: Numri i brinjëve të dhëna.\n- Një numër arbitrar argumentesh të tipit integer që përfaqësojnë gjatësitë e brinjëve.\n\nReturns:\nint: Numri i trekëndëshave të ndryshëm këndakut që mund të formohen.\n\nExamples:\n>>> f_23(4, 1, 1, 1, 1)\n4", "hy": "Հաշվել սուրանկյուն եռանկյունիների քանակը, որոնք կարող են ձևավորվել՝ ընտրելով ցանկացած 3 կողերից տրված կողերի հավաքածուից:\n\nԱրգումենտներ:\n- edges_count: Փոխանցված կողերի քանակը:\n- Կողերի երկարությունները ներկայացնող ամբողջ թվերի կամայական քանակով արգումենտներ:\n\nՎերադարձնում է:\nint: Տարբեր սուրանկյուն եռանկյունիների քանակը, որոնք կարող են ձևավորվել:\n\nՕրինակներ:\n>>> f_23(4, 1, 1, 1, 1)\n4", "bn": "প্রদত্ত প্রান্তগুলির একটি সেট থেকে যেকোনো ৩টি প্রান্ত নির্বাচন করে কতগুলো তীক্ষ্ণ-কোণী ত্রিভুজ গঠন করা যেতে পারে তা গণনা করুন।\n\nআর্গস:\n- edges_count: প্রেরিত প্রান্তগুলির সংখ্যা।\n- প্রান্তগুলির দৈর্ঘ্য উপস্থাপনকারী যেকোনো সংখ্যক পূর্ণসংখ্যার আর্গুমেন্ট।\n\nরিটার্নস:\nint: গঠিত হতে পারে এমন স্বতন্ত্র তীক্ষ্ণ-কোণী ত্রিভুজের সংখ্যা।\n\nউদাহরণ:\n>>> f_23(4, 1, 1, 1, 1)\n4", "bg": "Бройте броя на острите триъгълници, които могат да бъдат образувани чрез избиране на произволни 3 ръба от даден набор от ръбове.\n\nАргументи:\n- edges_count: Броят на предадените ръбове.\n- Произволен брой цели аргументи, представляващи дължините на ръбовете.\n\nВръща:\nint: Броят на различните остри триъгълници, които могат да бъдат образувани.\n\nПримери:\n>>> f_23(4, 1, 1, 1, 1)\n4", "zh": "计算可以通过从给定的一组边中选择任意3条边形成的锐角三角形的数量。\n\n参数：\n- edges_count: 传递的边的数量。\n- 任意数量的整数参数，表示边的长度。\n\n返回：\nint: 可以形成的不同锐角三角形的数量。\n\n示例：\n>>> f_23(4, 1, 1, 1, 1)\n4", "fr": "Compter le nombre de triangles acutangles qui peuvent être formés en sélectionnant 3 arêtes parmi un ensemble donné d'arêtes.\n\nArgs:\n- edges_count: Le nombre d'arêtes passées.\n- Un nombre arbitraire d'arguments entiers représentant les longueurs des arêtes.\n\nReturns:\nint: Le nombre de triangles acutangles distincts qui peuvent être formés.\n\nExamples:\n>>> f_23(4, 1, 1, 1, 1)\n4", "de": "Zähle die Anzahl der spitzwinkligen Dreiecke, die gebildet werden können, indem beliebige 3 Kanten aus einer gegebenen Menge von Kanten ausgewählt werden.\n\nArgs:\n- edges_count: Die Anzahl der übergebenen Kanten.\n- Eine beliebige Anzahl von ganzzahligen Argumenten, die die Längen der Kanten darstellen.\n\nReturns:\nint: Die Anzahl der verschiedenen spitzwinkligen Dreiecke, die gebildet werden können.\n\nExamples:\n>>> f_23(4, 1, 1, 1, 1)\n4", "ha": "Count adadin kusurwoyi masu kaifi waɗanda za a iya samarwa ta zaɓar kowane 3 gefuna daga cikin wani saiti na gefuna.\n\nArgs:\n- edges_count: Adadin gefuna da aka bayar.\n- Yawan hujjojin lamba masu zaman kansu da ke wakiltar tsawon gefuna.\n\nReturns:\nint: Adadin kusurwoyi masu kaifi daban-daban da za a iya samarwa.\n\nExamples:\n>>> f_23(4, 1, 1, 1, 1)\n4", "hi": "तीक्ष्ण कोण वाले त्रिभुजों की संख्या गिनें जो दिए गए किनारों के सेट में से किसी भी 3 किनारों का चयन करके बनाए जा सकते हैं।\n\nआर्ग्स:\n- edges_count: पास किए गए किनारों की संख्या।\n- किनारों की लंबाई का प्रतिनिधित्व करने वाले पूर्णांक तर्कों की एक मनमानी संख्या।\n\nवापसी:\nint: विशिष्ट तीक्ष्ण कोण वाले त्रिभुजों की संख्या जो बनाई जा सकती है।\n\nउदाहरण:\n>>> f_23(4, 1, 1, 1, 1)\n4", "hu": "Számolja meg a hegyesszögű háromszögek számát, amelyek a megadott élek halmazából bármely 3 él kiválasztásával képezhetők.\n\nArgs:\n- edges_count: Az átadott élek száma.\n- Tetszőleges számú egész szám argumentum, amelyek az élek hosszát képviselik.\n\nReturns:\nint: A képezhető különböző hegyesszögű háromszögek száma.\n\nExamples:\n>>> f_23(4, 1, 1, 1, 1)\n4", "es": "Cuenta el número de triángulos acutángulos que se pueden formar seleccionando cualquier 3 lados de un conjunto dado de lados.\n\nArgs:\n- edges_count: El número de lados pasados.\n- Un número arbitrario de argumentos enteros que representan las longitudes de los lados.\n\nReturns:\nint: La cantidad de triángulos acutángulos distintos que se pueden formar.\n\nExamples:\n>>> f_23(4, 1, 1, 1, 1)\n4", "arb": "احسب عدد المثلثات الحادة الزوايا التي يمكن تشكيلها عن طريق اختيار أي 3 حواف من مجموعة الحواف المعطاة.\n\nArgs:\n- edges_count: عدد الحواف الممررة.\n- عدد تعسفي من الوسيطات الصحيحة التي تمثل أطوال الحواف.\n\nالقيم المعادة:\nint: عدد المثلثات الحادة الزوايا المختلفة التي يمكن تشكيلها.\n\nأمثلة:\n>>> f_23(4, 1, 1, 1, 1)\n4", "sw": "Hesabu idadi ya pembetatu zenye pembe kali zinazoweza kuundwa kwa kuchagua pande 3 zozote kutoka kwenye seti iliyotolewa ya pande.\n\nArgs:\n- edges_count: Idadi ya pande zilizopitishwa.\n- Idadi yoyote ya hoja za nambari nzima zinazowakilisha urefu wa pande.\n\nReturns:\nint: Idadi ya pembetatu tofauti zenye pembe kali zinazoweza kuundwa.\n\nExamples:\n>>> f_23(4, 1, 1, 1, 1)\n4", "tr": "Verilen bir dizi kenardan herhangi 3 kenar seçilerek oluşturulabilecek dar açılı üçgenlerin sayısını sayın.\n\nArgs:\n- edges_count: Geçilen kenarların sayısı.\n- Kenarların uzunluklarını temsil eden rastgele sayıda tamsayı argümanı.\n\nReturns:\nint: Oluşturulabilecek farklı dar açılı üçgenlerin sayısı.\n\nExamples:\n>>> f_23(4, 1, 1, 1, 1)\n4", "vi": "Đếm số lượng tam giác nhọn có thể được tạo thành bằng cách chọn bất kỳ 3 cạnh nào từ một tập hợp các cạnh đã cho.\n\nArgs:\n- edges_count: Số lượng cạnh được truyền vào.\n- Một số lượng tùy ý các đối số kiểu số nguyên đại diện cho độ dài của các cạnh.\n\nTrả về:\nint: Số lượng tam giác nhọn khác nhau có thể được tạo thành.\n\nVí dụ:\n>>> f_23(4, 1, 1, 1, 1)\n4", "id": "Hitung jumlah segitiga lancip yang dapat dibentuk dengan memilih sembarang 3 sisi dari sekumpulan sisi yang diberikan.\n\nArgs:\n- edges_count: Jumlah sisi yang diberikan.\n- Sejumlah argumen bilangan bulat yang mewakili panjang sisi-sisi tersebut.\n\nReturns:\nint: Jumlah segitiga lancip yang berbeda yang dapat dibentuk.\n\nExamples:\n>>> f_23(4, 1, 1, 1, 1)\n4\n", "ja": "鋭角三角形を形成できるように、与えられた辺のセットから任意の3つの辺を選択することで形成できる鋭角三角形の数を数えます。\n\n引数:\n- edges_count: 渡された辺の数。\n- 辺の長さを表す任意の数の整数引数。\n\n戻り値:\nint: 形成できる異なる鋭角三角形の数。\n\n例:\n>>> f_23(4, 1, 1, 1, 1)\n4", "ko": "주어진 변의 집합에서 임의의 3개의 변을 선택하여 만들 수 있는 예각 삼각형의 수를 계산합니다.\n\nArgs:\n- edges_count: 전달된 변의 수.\n- 변의 길이를 나타내는 임의의 수의 정수 인수.\n\nReturns:\nint: 만들 수 있는 서로 다른 예각 삼각형의 수.\n\nExamples:\n>>> f_23(4, 1, 1, 1, 1)\n4", "ml": "നൽകിയിരിക്കുന്ന എഡ്ജുകളുടെ ഒരു സെറ്റിൽ നിന്ന് ഏതെങ്കിലും 3 എഡ്ജുകൾ തിരഞ്ഞെടുക്കുന്നതിലൂടെ രൂപീകരിക്കാവുന്ന മൂർച്ചയുള്ള മൂലമുള്ള ത്രികോണങ്ങളുടെ എണ്ണം എണ്ണുക.\n- edges_count: പാസ്സായ എഡ്ജുകളുടെ എണ്ണം.\n- എഡ്ജുകളുടെ നീളങ്ങൾ പ്രതിനിധീകരിക്കുന്ന ഒരു യാദൃച്ഛികമായ സംഖ്യയുടെ പാരാമീറ്ററുകൾ.\n\nമടക്കം:\nint: രൂപപ്പെടുത്താവുന്ന വ്യത്യസ്തമായ മൂർച്ചയുള്ള കോണുകളുള്ള ത്രികോണങ്ങളുടെ എണ്ണം.\n\nഉദാഹരണങ്ങൾ:\n>>> f_23(4, 1, 1, 1, 1)\n4", "fa": "تعداد مثلث‌های تیزگوشه‌ای را که می‌توان با انتخاب هر 3 ضلع از مجموعه‌ای از اضلاع تشکیل داد، بشمارید.\n\nآرگومان‌ها:\n- edges_count: تعداد اضلاعی که داده شده است.\n- تعداد دلخواهی از آرگومان‌های صحیح که طول اضلاع را نشان می‌دهند.\n\nبازگشت:\nint: تعداد مثلث‌های تیزگوشه‌ی متمایزی که می‌توان تشکیل داد.\n\nمثال‌ها:\n>>> f_23(4, 1, 1, 1, 1)\n4"}}
{"task_id": "C/24", "prompt": {"en": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/*\nReads an integer and a character, then returns them as a formatted string separated by a comma.\nParameters:\n- integer_value (int): The input integer.\n- char_value (char): The input character.\nReturns:\n- char*: A string containing the integer and character separated by a comma.\n>>> f_24(234,H)\n\t234,H\n*/\nchar* f_24(int integer_value, char char_value)", "sq": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/*\nLexon një numër të plotë dhe një karakter, pastaj i kthen ato si një varg i formatuar i ndarë nga një presje.\nParametrat:\n- integer_value (int): Numri i plotë i dhënë si hyrje.\n- char_value (char): Karakteri i dhënë si hyrje.\nKthen:\n- char*: Një varg që përmban numrin e plotë dhe karakterin e ndarë nga një presje.\n>>> f_24(234,H)\n\t234,H\n*/\nchar* f_24(int integer_value, char char_value)", "hy": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/*\nԿարդում է ամբողջ թիվ և սիմվոլ, այնուհետև վերադարձնում է դրանք որպես ձևաչափված տող, որոնք բաժանված են ստորակետով։\nՊարամետրեր:\n- integer_value (int): Մուտքային ամբողջ թիվը։\n- char_value (char): Մուտքային սիմվոլը։\nՎերադարձնում է:\n- char*: Տող, որը պարունակում է ամբողջ թիվը և սիմվոլը, բաժանված ստորակետով։\n>>> f_24(234,H)\n\t234,H\n*/\nchar* f_24(int integer_value, char char_value)", "bn": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/*\nএকটি পূর্ণসংখ্যা এবং একটি অক্ষর পড়ে, তারপর সেগুলিকে একটি কমা দ্বারা পৃথক করা ফরম্যাট করা স্ট্রিং হিসাবে ফেরত দেয়।\nপ্যারামিটার:\n- integer_value (int): ইনপুট পূর্ণসংখ্যা।\n- char_value (char): ইনপুট অক্ষর।\nফেরত দেয়:\n- char*: একটি স্ট্রিং যা পূর্ণসংখ্যা এবং অক্ষরকে একটি কমা দ্বারা পৃথক করে ধারণ করে।\n>>> f_24(234,H)\n\t234,H\n*/\nchar* f_24(int integer_value, char char_value)", "bg": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/*\nЧете цяло число и символ, след което ги връща като форматиран низ, разделен със запетая.\nПараметри:\n- integer_value (int): Входното цяло число.\n- char_value (char): Входният символ.\nВръща:\n- char*: Низ, съдържащ цялото число и символа, разделени със запетая.\n>>> f_24(234,H)\n\t234,H\n*/\nchar* f_24(int integer_value, char char_value)", "zh": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/*\n读取一个整数和一个字符，然后将它们作为用逗号分隔的格式化字符串返回。\n参数：\n- integer_value (int): 输入的整数。\n- char_value (char): 输入的字符。\n返回：\n- char*: 包含整数和字符并用逗号分隔的字符串。\n>>> f_24(234,H)\n\t234,H\n*/\nchar* f_24(int integer_value, char char_value)", "fr": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/*\nLit un entier et un caractère, puis les retourne sous forme de chaîne formatée séparée par une virgule.\nParamètres :\n- integer_value (int) : L'entier d'entrée.\n- char_value (char) : Le caractère d'entrée.\nRetourne :\n- char* : Une chaîne contenant l'entier et le caractère séparés par une virgule.\n>>> f_24(234,H)\n\t234,H\n*/", "de": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/*\nLiest eine Ganzzahl und ein Zeichen und gibt sie dann als formatierte Zeichenkette getrennt durch ein Komma zurück.\nParameter:\n- integer_value (int): Die Eingabeganzzahl.\n- char_value (char): Das Eingabezeichen.\nRückgabewert:\n- char*: Eine Zeichenkette, die die Ganzzahl und das Zeichen getrennt durch ein Komma enthält.\n>>> f_24(234,H)\n\t234,H\n*/\nchar* f_24(int integer_value, char char_value)", "ha": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/*\nKaranta lamba mai cikakken adadi da wata alama, sannan ya mayar da su a matsayin jeren rubutu da aka raba da alamar koma.\nSigogi:\n- integer_value (int): Lambar da aka shigar.\n- char_value (char): Harafin da aka shigar.\nMayarwa:\n- char*: Jeren rubutu da ke dauke da lambar da harafin da aka raba da alamar koma.\n>>> f_24(234,H)\n\t234,H\n*/\nchar* f_24(int integer_value, char char_value)", "hi": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/*\nएक पूर्णांक और एक वर्ण पढ़ता है, फिर उन्हें एक स्वरूपित स्ट्रिंग के रूप में अल्पविराम से अलग करके लौटाता है।\nपैरामीटर्स:\n- integer_value (int): इनपुट पूर्णांक।\n- char_value (char): इनपुट वर्ण।\nरिटर्न्स:\n- char*: एक स्ट्रिंग जिसमें पूर्णांक और वर्ण अल्पविराम से अलग होते हैं।\n>>> f_24(234,H)\n\t234,H\n*/\nchar* f_24(int integer_value, char char_value)", "hu": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/*\nBeolvas egy egész számot és egy karaktert, majd visszaadja őket egy formázott, vesszővel elválasztott karakterláncként.\nParaméterek:\n- integer_value (int): A bemeneti egész szám.\n- char_value (char): A bemeneti karakter.\nVisszatérési érték:\n- char*: Egy karakterlánc, amely az egész számot és a karaktert vesszővel elválasztva tartalmazza.\n>>> f_24(234,H)\n\t234,H\n*/\nchar* f_24(int integer_value, char char_value)", "es": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/*\nLee un entero y un carácter, luego los devuelve como una cadena formateada separada por una coma.\nParámetros:\n- integer_value (int): El entero de entrada.\n- char_value (char): El carácter de entrada.\nDevuelve:\n- char*: Una cadena que contiene el entero y el carácter separados por una coma.\n>>> f_24(234,H)\n\t234,H\n*/\nchar* f_24(int integer_value, char char_value)", "arb": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/*\nيقرأ عددًا صحيحًا وحرفًا، ثم يعيدهما كسلسلة منسقة مفصولة بفاصلة.\nالمعلمات:\n- integer_value (int): العدد الصحيح المدخل.\n- char_value (char): الحرف المدخل.\nيعيد:\n- char*: سلسلة تحتوي على العدد الصحيح والحرف مفصولين بفاصلة.\n>>> f_24(234,H)\n\t234,H\n*/\nchar* f_24(int integer_value, char char_value)", "sw": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/*\nHusoma nambari nzima na herufi, kisha kuzirudisha kama mfuatano wa herufi uliopangwa kwa koma.\nVigezo:\n- integer_value (int): Nambari nzima ya ingizo.\n- char_value (char): Herufi ya ingizo.\nInarudisha:\n- char*: Mfuatano wa herufi unao na nambari nzima na herufi zilizotenganishwa kwa koma.\n>>> f_24(234,H)\n\t234,H\n*/\nchar* f_24(int integer_value, char char_value)", "tr": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/*\nBir tam sayı ve bir karakter okur, ardından bunları virgülle ayrılmış biçimlendirilmiş bir dize olarak döndürür.\nParametreler:\n- integer_value (int): Girdi tam sayısı.\n- char_value (char): Girdi karakteri.\nDöndürülen:\n- char*: Tam sayı ve karakteri virgülle ayrılmış bir dize içeren bir karakter dizisi.\n>>> f_24(234,H)\n\t234,H\n*/\nchar* f_24(int integer_value, char char_value)", "vi": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/*\nĐọc một số nguyên và một ký tự, sau đó trả về chúng dưới dạng một chuỗi định dạng được phân tách bằng dấu phẩy.\nTham số:\n- integer_value (int): Số nguyên đầu vào.\n- char_value (char): Ký tự đầu vào.\nTrả về:\n- char*: Một chuỗi chứa số nguyên và ký tự được phân tách bằng dấu phẩy.\n>>> f_24(234,H)\n\t234,H\n*/\nchar* f_24(int integer_value, char char_value)", "id": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/*\nMembaca sebuah bilangan bulat dan sebuah karakter, kemudian mengembalikannya sebagai string terformat yang dipisahkan oleh koma.\nParameter:\n- integer_value (int): Bilangan bulat yang diinput.\n- char_value (char): Karakter yang diinput.\nMengembalikan:\n- char*: Sebuah string yang mengandung bilangan bulat dan karakter yang dipisahkan oleh koma.\n>>> f_24(234,H)\n\t234,H\n*/\nchar* f_24(int integer_value, char char_value)", "ja": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/*\n整数と文字を読み取り、それらをカンマで区切られたフォーマットされた文字列として返します。\nパラメータ:\n- integer_value (int): 入力された整数。\n- char_value (char): 入力された文字。\n戻り値:\n- char*: 整数と文字がカンマで区切られた文字列。\n>>> f_24(234,H)\n\t234,H\n*/\nchar* f_24(int integer_value, char char_value)", "ko": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/*\n정수와 문자를 읽은 후, 쉼표로 구분된 형식의 문자열로 반환합니다.\n매개변수:\n- integer_value (int): 입력 정수.\n- char_value (char): 입력 문자.\n반환값:\n- char*: 정수와 문자가 쉼표로 구분된 문자열.\n>>> f_24(234,H)\n\t234,H\n*/\nchar* f_24(int integer_value, char char_value)", "ml": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/*\nഒരു പൂർണ്ണസംഖ്യയും ഒരു അക്ഷരവും വായിച്ച ശേഷം അവയെ കോമയാൽ വേർതിരിച്ച ഫോർമാറ്റ് ചെയ്ത സ്ട്രിംഗായി മടക്കിനൽകുന്നു.\nപാരാമീറ്ററുകൾ:\n- integer_value (int): ഇൻപുട്ട് പൂർണ്ണസംഖ്യ.\n- char_value (char): ഇൻപുട്ട് അക്ഷരം.\nമടക്കിനൽകുന്നത്:\n- char*: കോമയാൽ വേർതിരിച്ച പൂർണ്ണസംഖ്യയും അക്ഷരവും അടങ്ങിയ ഒരു സ്ട്രിംഗ്.\n>>> f_24(234,H)\n\t234,H\n*/\nchar* f_24(int integer_value, char char_value)", "fa": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/*\nیک عدد صحیح و یک کاراکتر را می‌خواند، سپس آنها را به صورت یک رشته قالب‌بندی شده که با کاما جدا شده‌اند برمی‌گرداند.\nپارامترها:\n- integer_value (int): عدد صحیح ورودی.\n- char_value (char): کاراکتر ورودی.\nبرمی‌گرداند:\n- char*: رشته‌ای که حاوی عدد صحیح و کاراکتر است که با کاما جدا شده‌اند.\n>>> f_24(234,H)\n\t234,H\n*/\nchar* f_24(int integer_value, char char_value)"}, "canonical_solution": "{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}", "instruction": {"en": "Write a C function `char* f_24(int integer_value, char char_value)` to solve the following problem:\nReads an integer and a character, then returns them as a formatted string separated by a comma.\nParameters:\n- integer_value (int): The input integer.\n- char_value (char): The input character.\nReturns:\n- char*: A string containing the integer and character separated by a comma.\n>>> f_24(234,H)\n\t234,H\n", "sq": "Shkruani një funksion në C `char* f_24(int integer_value, char char_value)` për të zgjidhur problemin e mëposhtëm:\nLexon një numër të plotë dhe një karakter, pastaj i kthen ato si një varg i formatuar i ndarë nga një presje.\nParametrat:\n- integer_value (int): Numri i plotë i dhënë si hyrje.\n- char_value (char): Karakteri i dhënë si hyrje.\nKthen:\n- char*: Një varg që përmban numrin e plotë dhe karakterin e ndarë nga një presje.\n>>> f_24(234,H)\n\t234,H", "hy": "Գրեք C ֆունկցիա `char* f_24(int integer_value, char char_value)` հետևյալ խնդիրը լուծելու համար:\nԿարդում է ամբողջ թիվ և սիմվոլ, ապա վերադարձնում է դրանք որպես ձևաչափված տող, որը բաժանված է ստորակետով։\nՊարամետրեր:\n- integer_value (int): Մուտքային ամբողջ թիվը։\n- char_value (char): Մուտքային սիմվոլը։\nՎերադարձնում է:\n- char*: Տող, որը պարունակում է ամբողջ թիվը և սիմվոլը, բաժանված ստորակետով։\n", "bn": "একটি C ফাংশন `char* f_24(int integer_value, char char_value)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি পূর্ণসংখ্যা এবং একটি অক্ষর পড়ে, তারপর সেগুলিকে একটি ফরম্যাট করা স্ট্রিং হিসেবে কমা দ্বারা পৃথক করে ফেরত দেয়।\nপ্যারামিটার:\n- integer_value (int): ইনপুট পূর্ণসংখ্যা।\n- char_value (char): ইনপুট অক্ষর।\nফেরত দেয়:\n- char*: একটি স্ট্রিং যা পূর্ণসংখ্যা এবং অক্ষরকে কমা দ্বারা পৃথক করে ধারণ করে।\n>>> f_24(234,H)\n\t234,H", "bg": "Напишете C функция `char* f_24(int integer_value, char char_value)`, за да решите следния проблем:\nЧете цяло число и символ, след което ги връща като форматиран низ, разделен със запетая.\nПараметри:\n- integer_value (int): Входното цяло число.\n- char_value (char): Входният символ.\nВръща:\n- char*: Низ, съдържащ цялото число и символа, разделени със запетая.", "zh": "编写一个 C 函数 `char* f_24(int integer_value, char char_value)` 来解决以下问题：\n读取一个整数和一个字符，然后将它们作为一个用逗号分隔的格式化字符串返回。\n参数：\n- integer_value (int): 输入的整数。\n- char_value (char): 输入的字符。\n返回：\n- char*: 一个包含整数和字符并用逗号分隔的字符串。", "fr": "Écrire une fonction C `char* f_24(int integer_value, char char_value)` pour résoudre le problème suivant :\nLit un entier et un caractère, puis les renvoie sous forme de chaîne formatée séparée par une virgule.\nParamètres :\n- integer_value (int) : L'entier d'entrée.\n- char_value (char) : Le caractère d'entrée.\nRenvoie :\n- char* : Une chaîne contenant l'entier et le caractère séparés par une virgule.\n>>> f_24(234,H)\n\t234,H", "de": "Schreiben Sie eine C-Funktion `char* f_24(int integer_value, char char_value)`, um das folgende Problem zu lösen:\nLiest eine Ganzzahl und ein Zeichen und gibt sie dann als formatierte Zeichenkette, getrennt durch ein Komma, zurück.\nParameter:\n- integer_value (int): Die Eingabeganzzahl.\n- char_value (char): Das Eingabezeichen.\nRückgabewert:\n- char*: Eine Zeichenkette, die die Ganzzahl und das Zeichen durch ein Komma getrennt enthält.", "ha": "Rubuta aikin C `char* f_24(int integer_value, char char_value)` don warware matsalar mai zuwa:\nKaranta lamba da harafi, sannan ya mayar da su a matsayin jeren haruffa da aka tsara wanda aka raba da alamar rubutu.\nSigogi:\n- integer_value (int): Lambar shigarwa.\n- char_value (char): Harafin shigarwa.\nMayarwa:\n- char*: Jeren haruffa da ke dauke da lamba da harafi da aka raba da alamar rubutu.\n>>> f_24(234,H)\n\t234,H", "hi": "C फ़ंक्शन `char* f_24(int integer_value, char char_value)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nएक पूर्णांक और एक अक्षर पढ़ता है, फिर उन्हें एक फॉर्मेटेड स्ट्रिंग के रूप में लौटाता है जो अल्पविराम द्वारा अलग होता है।\nपैरामीटर्स:\n- integer_value (int): इनपुट पूर्णांक।\n- char_value (char): इनपुट अक्षर।\nवापसी:\n- char*: एक स्ट्रिंग जिसमें पूर्णांक और अक्षर अल्पविराम से अलग होते हैं।\n>>> f_24(234,H)\n\t234,H", "hu": "Írj egy C függvényt `char* f_24(int integer_value, char char_value)` a következő probléma megoldására:\nBeolvas egy egész számot és egy karaktert, majd visszaadja őket egy formázott karakterláncként, vesszővel elválasztva.\nParaméterek:\n- integer_value (int): A bemeneti egész szám.\n- char_value (char): A bemeneti karakter.\nVisszatérési érték:\n- char*: Egy karakterlánc, amely az egész számot és a karaktert tartalmazza, vesszővel elválasztva.", "es": "Escribe una función en C `char* f_24(int integer_value, char char_value)` para resolver el siguiente problema:\nLee un entero y un carácter, luego los devuelve como una cadena formateada separada por una coma.\nParámetros:\n- integer_value (int): El entero de entrada.\n- char_value (char): El carácter de entrada.\nDevuelve:\n- char*: Una cadena que contiene el entero y el carácter separados por una coma.\n>>> f_24(234,H)\n\t234,H", "arb": "اكتب دالة C `char* f_24(int integer_value, char char_value)` لحل المشكلة التالية:\nيقرأ عددًا صحيحًا وحرفًا، ثم يعيدهما كسلسلة منسقة مفصولة بفاصلة.\nالمعلمات:\n- integer_value (int): العدد الصحيح المدخل.\n- char_value (char): الحرف المدخل.\nيعيد:\n- char*: سلسلة تحتوي على العدد الصحيح والحرف مفصولين بفاصلة.\n>>> f_24(234,H)\n\t234,H", "sw": "Andika kazi ya C `char* f_24(int integer_value, char char_value)` kutatua tatizo lifuatalo:\nSoma nambari nzima na herufi, kisha zirudishe kama kamba iliyopangwa ikitenganishwa na koma.\nVigezo:\n- integer_value (int): Nambari nzima ya pembejeo.\n- char_value (char): Herufi ya pembejeo.\nRudisha:\n- char*: Kamba inayo na nambari nzima na herufi zikitenganishwa na koma.\n>>> f_24(234,H)\n\t234,H", "tr": "Bir C fonksiyonu `char* f_24(int integer_value, char char_value)` yazın:\nBir tam sayı ve bir karakter okur, ardından bunları virgülle ayrılmış biçimlendirilmiş bir dize olarak döndürür.\nParametreler:\n- integer_value (int): Girdi tam sayısı.\n- char_value (char): Girdi karakteri.\nDöndürür:\n- char*: Virgülle ayrılmış tam sayı ve karakter içeren bir dize.\n>>> f_24(234,H)\n\t234,H", "vi": "Viết một hàm C `char* f_24(int integer_value, char char_value)` để giải quyết vấn đề sau:\nĐọc một số nguyên và một ký tự, sau đó trả về chúng dưới dạng một chuỗi định dạng được phân tách bằng dấu phẩy.\nTham số:\n- integer_value (int): Số nguyên đầu vào.\n- char_value (char): Ký tự đầu vào.\nTrả về:\n- char*: Một chuỗi chứa số nguyên và ký tự được phân tách bằng dấu phẩy.\n>>> f_24(234,H)\n\t234,H", "id": "Tulis sebuah fungsi C `char* f_24(int integer_value, char char_value)` untuk menyelesaikan masalah berikut:\nMembaca sebuah bilangan bulat dan sebuah karakter, kemudian mengembalikannya sebagai string yang diformat dipisahkan oleh koma.\nParameter:\n- integer_value (int): Bilangan bulat masukan.\n- char_value (char): Karakter masukan.\nMengembalikan:\n- char*: Sebuah string yang berisi bilangan bulat dan karakter dipisahkan oleh koma.\n>>> f_24(234,H)\n\t234,H", "ja": "Cの関数を書け `char* f_24(int integer_value, char char_value)` を作成して、次の問題を解決してください:\n整数と文字を読み取り、それらをカンマで区切ったフォーマットされた文字列として返します。\nパラメータ:\n- integer_value (int): 入力整数。\n- char_value (char): 入力文字。\n戻り値:\n- char*: 整数と文字をカンマで区切った文字列。\n>>> f_24(234,H)\n\t234,H", "ko": "C 함수 `char* f_24(int integer_value, char char_value)`를 작성하여 다음 문제를 해결하십시오:\n정수와 문자를 읽은 후 쉼표로 구분된 형식의 문자열로 반환합니다.\n매개변수:\n- integer_value (int): 입력 정수.\n- char_value (char): 입력 문자.\n반환:\n- char*: 쉼표로 구분된 정수와 문자를 포함하는 문자열.\n>>> f_24(234,H)\n\t234,H", "ml": "C ഭാഷയിൽ ഒരു ഫംഗ്ഷൻ `char* f_24(int integer_value, char char_value)` എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nഒരു പൂർണ്ണസംഖ്യയും ഒരു അക്ഷരവും വായിച്ച് അവയെ കോമ കൊണ്ട് വേർതിരിച്ച ഫോർമാറ്റ് ചെയ്ത സ്ട്രിംഗ് ആയി തിരികെ നൽകുന്നു.\nപാരാമീറ്ററുകൾ:\n- integer_value (int): ഇൻപുട്ട് പൂർണ്ണസംഖ്യ.\n- char_value (char): ഇൻപുട്ട് അക്ഷരം.\nതിരികെ നൽകുന്നു:\n- char*: കോമ ഉപയോഗിച്ച് വേർതിരിച്ച പൂർണ്ണസംഖ്യയും അക്ഷരവും അടങ്ങിയ ഒരു സ്ട്രിംഗ്.\n>>> f_24(234,H)\n\t234,H", "fa": "یک تابع C بنویسید `char* f_24(int integer_value, char char_value)` برای حل مشکل زیر:\nیک عدد صحیح و یک کاراکتر را می‌خواند، سپس آن‌ها را به صورت یک رشته قالب‌بندی شده که با کاما جدا شده‌اند، برمی‌گرداند.\nپارامترها:\n- integer_value (int): عدد صحیح ورودی.\n- char_value (char): کاراکتر ورودی.\nبرمی‌گرداند:\n- char*: یک رشته که شامل عدد صحیح و کاراکتر است که با کاما جدا شده‌اند.\n>>> f_24(234,H)\n\t234,H"}, "level": "middle", "test": "int main()\n{\n    // Test 1\n    char* output1 = f_24(234, 'H');\n    assert(strcmp(output1, \"234,H\") == 0);\n    free(output1); // Don't forget to free the allocated memory\n\n    // Additional tests can be added here with different input values\n    // Test 2\n    char* output2 = f_24(123, 'A');\n    assert(strcmp(output2, \"123,A\") == 0);\n    free(output2);\n\n    // Test 3\n    char* output3 = f_24(0, 'Z');\n    assert(strcmp(output3, \"0,Z\") == 0);\n    free(output3);\n\n    return 0;\n}", "entry_point": "f_24", "signature": "char* f_24(int integer_value, char char_value)", "docstring": {"en": "Reads an integer and a character, then returns them as a formatted string separated by a comma.\nParameters:\n- integer_value (int): The input integer.\n- char_value (char): The input character.\nReturns:\n- char*: A string containing the integer and character separated by a comma.\n>>> f_24(234,H)\n\t234,H\n", "sq": "Lexon një numër të plotë dhe një karakter, pastaj i kthen ato si një varg i formatuar i ndarë nga një presje.\nParametrat:\n- integer_value (int): Numri i plotë i dhënë si hyrje.\n- char_value (char): Karakteri i dhënë si hyrje.\nKthen:\n- char*: Një varg që përmban numrin e plotë dhe karakterin e ndarë nga një presje.\n>>> f_24(234,H)\n\t234,H", "hy": "Կարդում է ամբողջ թիվ և սիմվոլ, այնուհետև վերադարձնում է դրանք որպես ձևաչափված տող, որը բաժանված է ստորակետով։  \nՊարամետրեր:  \n- integer_value (int): Մուտքային ամբողջ թիվը։  \n- char_value (char): Մուտքային սիմվոլը։  \nՎերադարձնում է:  \n- char*: Տող, որը պարունակում է ամբողջ թիվը և սիմվոլը, բաժանված ստորակետով։  \n>>> f_24(234,H)  \n\t234,H", "bn": "Reads an integer and a character, then returns them as a formatted string separated by a comma.  \nপ্যারামিটারসমূহ:  \n- integer_value (int): ইনপুট পূর্ণসংখ্যা।  \n- char_value (char): ইনপুট অক্ষর।  \nরিটার্নস:  \n- char*: একটি স্ট্রিং যা পূর্ণসংখ্যা এবং অক্ষরকে কমা দ্বারা পৃথক করে।  \n>>> f_24(234,H)  \n\t234,H  ", "bg": "Чете цяло число и символ, след което ги връща като форматиран низ, разделен със запетая.\nПараметри:\n- integer_value (int): Входното цяло число.\n- char_value (char): Входният символ.\nВръща:\n- char*: Низ, съдържащ цялото число и символа, разделени със запетая.\n>>> f_24(234,H)\n\t234,H", "zh": "读取一个整数和一个字符，然后将它们作为用逗号分隔的格式化字符串返回。\n参数：\n- integer_value (int): 输入的整数。\n- char_value (char): 输入的字符。\n返回：\n- char*: 包含整数和字符并用逗号分隔的字符串。\n>>> f_24(234,H)\n\t234,H", "fr": "Lit un entier et un caractère, puis les renvoie sous forme de chaîne formatée séparée par une virgule.\nParamètres :\n- integer_value (int) : L'entier d'entrée.\n- char_value (char) : Le caractère d'entrée.\nRenvoie :\n- char* : Une chaîne contenant l'entier et le caractère séparés par une virgule.\n>>> f_24(234,H)\n\t234,H", "de": "Liest eine ganze Zahl und ein Zeichen und gibt sie dann als formatierte Zeichenkette getrennt durch ein Komma zurück.\nParameter:\n- integer_value (int): Die Eingabe-Ganzzahl.\n- char_value (char): Das Eingabe-Zeichen.\nRückgabewert:\n- char*: Eine Zeichenkette, die die Ganzzahl und das Zeichen durch ein Komma getrennt enthält.\n>>> f_24(234,H)\n\t234,H", "ha": "Karanta wata lamba kuma wata alama, sannan ya mayar da su a matsayin jeren rubutu da aka tsara wanda aka raba da alama.\nSigogi:\n- integer_value (int): Lambar da aka shigar.\n- char_value (char): Alamar da aka shigar.\nDawowa:\n- char*: Jeren rubutu wanda ke dauke da lambar da alama da aka raba da alama.\n>>> f_24(234,H)\n\t234,H", "hi": "Reads an integer and a character, then returns them as a formatted string separated by a comma.  \nपैरामीटर्स:  \n- integer_value (int): इनपुट पूर्णांक।  \n- char_value (char): इनपुट वर्ण।  \nरिटर्न्स:  \n- char*: एक स्ट्रिंग जिसमें पूर्णांक और वर्ण अल्पविराम से अलग होते हैं।  \n>>> f_24(234,H)  \n\t234,H  ", "hu": "Beolvas egy egész számot és egy karaktert, majd visszaadja őket egy formázott karakterláncként, vesszővel elválasztva.\nParaméterek:\n- integer_value (int): A bemeneti egész szám.\n- char_value (char): A bemeneti karakter.\nVisszatérési érték:\n- char*: Egy karakterlánc, amely az egész számot és a karaktert vesszővel elválasztva tartalmazza.\n>>> f_24(234,H)\n\t234,H", "es": "Lee un entero y un carácter, luego los devuelve como una cadena formateada separada por una coma.\nParámetros:\n- integer_value (int): El entero de entrada.\n- char_value (char): El carácter de entrada.\nDevuelve:\n- char*: Una cadena que contiene el entero y el carácter separados por una coma.\n>>> f_24(234,H)\n\t234,H", "arb": "يقرأ عددًا صحيحًا وحرفًا، ثم يعيدهما كسلسلة منسقة مفصولة بفاصلة.\nالمعلمات:\n- integer_value (int): العدد الصحيح المدخل.\n- char_value (char): الحرف المدخل.\nالقيم المعادة:\n- char*: سلسلة تحتوي على العدد الصحيح والحرف مفصولين بفاصلة.\n>>> f_24(234,H)\n\t234,H", "sw": "Husoma nambari kamili na herufi, kisha inazirudisha kama kamba iliyopangwa kwa mpangilio ikitenganishwa na koma.\nVigezo:\n- integer_value (int): Nambari kamili ya pembejeo.\n- char_value (char): Herufi ya pembejeo.\nInarejesha:\n- char*: Kamba inayojumuisha nambari kamili na herufi iliyotenganishwa na koma.\n>>> f_24(234,H)\n\t234,H", "tr": "Bir tam sayı ve bir karakter okur, ardından bunları virgülle ayrılmış biçimlendirilmiş bir dize olarak döndürür.\nParametreler:\n- integer_value (int): Girdi tam sayısı.\n- char_value (char): Girdi karakteri.\nDöndürür:\n- char*: Tam sayı ve karakteri virgülle ayrılmış bir dize içeren bir string.\n>>> f_24(234,H)\n\t234,H", "vi": "Đọc một số nguyên và một ký tự, sau đó trả về chúng dưới dạng một chuỗi định dạng được phân tách bằng dấu phẩy.  \nTham số:  \n- integer_value (int): Số nguyên đầu vào.  \n- char_value (char): Ký tự đầu vào.  \nTrả về:  \n- char*: Một chuỗi chứa số nguyên và ký tự được phân tách bằng dấu phẩy.  \n>>> f_24(234,H)  \n\t234,H  ", "id": "Membaca sebuah bilangan bulat dan sebuah karakter, kemudian mengembalikannya sebagai string yang diformat dipisahkan oleh koma.\nParameter:\n- integer_value (int): Bilangan bulat yang dimasukkan.\n- char_value (char): Karakter yang dimasukkan.\nMengembalikan:\n- char*: Sebuah string yang berisi bilangan bulat dan karakter yang dipisahkan oleh koma.\n>>> f_24(234,H)\n\t234,H", "ja": "整数と文字を読み取り、それらをカンマで区切ったフォーマットされた文字列として返します。\n引数:\n- integer_value (int): 入力された整数。\n- char_value (char): 入力された文字。\n戻り値:\n- char*: 整数と文字をカンマで区切った文字列。\n>>> f_24(234,H)\n\t234,H", "ko": "정수와 문자를 읽고, 쉼표로 구분된 형식의 문자열로 반환합니다.\n매개변수:\n- integer_value (int): 입력 정수.\n- char_value (char): 입력 문자.\n반환:\n- char*: 쉼표로 구분된 정수와 문자를 포함하는 문자열.\n>>> f_24(234,H)\n\t234,H", "ml": "ഒരു പൂർണ്ണസംഖ്യയും ഒരു അക്ഷരവും വായിച്ച ശേഷം അവയെ കോമയാൽ വേർതിരിച്ച ഫോർമാറ്റ് ചെയ്ത സ്ട്രിംഗായി മടക്കിനൽകുന്നു.\nവ്യത്യസ്തമാക്കുന്ന കോമയിലൂടെ വേർതിരിച്ച ഫോർമാറ്റ് ചെയ്ത സ്ട്രിംഗായി integer, character എന്നിവ തിരികെ നൽകുന്നു.\n\nParameters:  \n- integer_value (int): ഇൻപുട്ട് ഇന്റിജർ.  \n- char_value (char): ഇൻപുട്ട് കാറക്ടർ.  \n\nReturns:  \n- char*: കോമയിലൂടെ വേർതിരിച്ച ഇന്റിജറും കാറക്ടറും അടങ്ങിയ സ്ട്രിംഗ്.  \n\n>>> f_24(234,H)  \n\t234,H", "fa": "یک عدد صحیح و یک کاراکتر را می‌خواند، سپس آن‌ها را به‌صورت یک رشته قالب‌بندی‌شده که با کاما جدا شده‌اند، برمی‌گرداند.\nپارامترها:\n- integer_value (int): عدد صحیح ورودی.\n- char_value (char): کاراکتر ورودی.\nبازگشتی:\n- char*: یک رشته که شامل عدد صحیح و کاراکتر است و با کاما جدا شده‌اند.\n>>> f_24(234,H)\n\t234,H"}}
{"task_id": "C/25", "prompt": {"en": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nShifts all characters by 5 positions in alphabetical order. Only letters are replaced, and all letters are in uppercase.\n​    Parameters:\n​    text (str): The input text to be processed.\n​\n​    Returns:\n​    str: The transformed text with characters shifted by 5 positions.\n\t>>> f_25(NS,BFW,,JAJSYX,TK,NRUTWYFSHJ,FWJ,YMJ,WJXZQY,TK,YWNANFQ,HFZXJX)\n\tIN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\n*/\nchar* f_25(char* text)", "sq": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nZhvendos të gjitha karakteret me 5 pozicione në rend alfabetik. Vetëm shkronjat zëvendësohen, dhe të gjitha shkronjat janë me shkronja të mëdha.\n​    Parametrat:\n​    text (str): Teksti hyrës që do të përpunohet.\n​\n​    Kthen:\n​    str: Teksti i transformuar me karaktere të zhvendosura me 5 pozicione.\n\t>>> f_25(NS,BFW,,JAJSYX,TK,NRUTWYFSHJ,FWJ,YMJ,WJXZQY,TK,YWNANFQ,HFZXJX)\n\tIN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\n*/\nchar* f_25(char* text)", "hy": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nՏեղափոխում է բոլոր տառերը 5 դիրքով այբբենական կարգով: Միայն տառերն են փոխարինվում, և բոլոր տառերը մեծատառ են:\n​    Պարամետրեր:\n​    text (str): Մուտքային տեքստը, որը պետք է մշակվի:\n​\n​    Վերադարձնում է:\n​    str: Փոխակերպված տեքստը, որտեղ տառերը տեղափոխված են 5 դիրքով:\n\t>>> f_25(NS,BFW,,JAJSYX,TK,NRUTWYFSHJ,FWJ,YMJ,WJXZQY,TK,YWNANFQ,HFZXJX)\n\tIN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\n*/\nchar* f_25(char* text)", "bn": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nসমস্ত অক্ষর বর্ণানুক্রমিক ক্রমে ৫টি অবস্থান দ্বারা স্থানান্তরিত হয়। শুধুমাত্র অক্ষরগুলি প্রতিস্থাপিত হয় এবং সমস্ত অক্ষর বড় হাতের অক্ষরে থাকে।\n​    প্যারামিটার:\n​    text (str): প্রক্রিয়াকরণের জন্য ইনপুট টেক্সট।\n​\n​    রিটার্নস:\n​    str: রূপান্তরিত টেক্সট যা অক্ষরগুলি ৫টি অবস্থান দ্বারা স্থানান্তরিত।\n\t>>> f_25(NS,BFW,,JAJSYX,TK,NRUTWYFSHJ,FWJ,YMJ,WJXZQY,TK,YWNANFQ,HFZXJX)\n\tIN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\n*/\nchar* f_25(char* text)", "bg": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nИзместете всички символи с 5 позиции в азбучен ред. Само буквите се заменят и всички букви са с главни букви.\n​    Параметри:\n​    text (str): Входният текст за обработка.\n​\n​    Връща:\n​    str: Преобразуваният текст със символи, изместени с 5 позиции.\n\t>>> f_25(NS,BFW,,JAJSYX,TK,NRUTWYFSHJ,FWJ,YMJ,WJXZQY,TK,YWNANFQ,HFZXJX)\n\tIN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\n*/\nchar* f_25(char* text)", "zh": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n将所有字符在字母表中向后移动5个位置。仅替换字母，且所有字母均为大写。\n    参数：\n    text (str): 要处理的输入文本。\n​\n    返回：\n    str: 字符被移动5个位置后的转换文本。\n\t>>> f_25(NS,BFW,,JAJSYX,TK,NRUTWYFSHJ,FWJ,YMJ,WJXZQY,TK,YWNANFQ,HFZXJX)\n\tIN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\n*/\nchar* f_25(char* text)", "fr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDécale tous les caractères de 5 positions dans l'ordre alphabétique. Seules les lettres sont remplacées, et toutes les lettres sont en majuscules.\n​    Paramètres:\n​    text (str): Le texte d'entrée à traiter.\n​\n​    Renvoie:\n​    str: Le texte transformé avec les caractères décalés de 5 positions.\n\t>>> f_25(NS,BFW,,JAJSYX,TK,NRUTWYFSHJ,FWJ,YMJ,WJXZQY,TK,YWNANFQ,HFZXJX)\n\tIN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\n*/\nchar* f_25(char* text)", "de": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nVerschiebt alle Zeichen um 5 Positionen in alphabetischer Reihenfolge. Nur Buchstaben werden ersetzt, und alle Buchstaben sind in Großbuchstaben.\n​    Parameter:\n​    text (str): Der Eingabetext, der verarbeitet werden soll.\n​\n​    Rückgabe:\n​    str: Der transformierte Text mit um 5 Positionen verschobenen Zeichen.\n\t>>> f_25(NS,BFW,,JAJSYX,TK,NRUTWYFSHJ,FWJ,YMJ,WJXZQY,TK,YWNANFQ,HFZXJX)\n\tIN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\n*/\nchar* f_25(char* text)", "ha": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCanza duk haruffa ta wurin matsar da su wurare 5 a cikin tsarin haruffa. Ana maye gurbin haruffa kawai, kuma duk haruffa suna cikin manyan baki.\n​    Sigogi:\n​    text (str): Rubutun shigar da za a sarrafa.\n​\n​    Komawa:\n​    str: Rubutun da aka canza tare da haruffa da aka matsar da su wurare 5.\n\t>>> f_25(NS,BFW,,JAJSYX,TK,NRUTWYFSHJ,FWJ,YMJ,WJXZQY,TK,YWNANFQ,HFZXJX)\n\tIN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\n*/\nchar* f_25(char* text)", "hi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nसभी वर्णों को वर्णमाला क्रम में 5 स्थानों से स्थानांतरित करता है। केवल अक्षरों को बदला जाता है, और सभी अक्षर बड़े अक्षरों में होते हैं।\n​    पैरामीटर्स:\n​    text (str): इनपुट टेक्स्ट जिसे प्रोसेस किया जाना है।\n​\n​    रिटर्न्स:\n​    str: परिवर्तित टेक्स्ट जिसमें वर्ण 5 स्थानों से स्थानांतरित होते हैं।\n\t>>> f_25(NS,BFW,,JAJSYX,TK,NRUTWYFSHJ,FWJ,YMJ,WJXZQY,TK,YWNANFQ,HFZXJX)\n\tIN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\n*/\nchar* f_25(char* text)", "hu": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nMinden karaktert 5 pozícióval eltol az ábécében. Csak a betűk kerülnek cserére, és minden betű nagybetűs.\n​    Paraméterek:\n​    text (str): A feldolgozandó bemeneti szöveg.\n​\n​    Visszatér:\n​    str: Az átalakított szöveg, amelynek karakterei 5 pozícióval eltolva.\n\t>>> f_25(NS,BFW,,JAJSYX,TK,NRUTWYFSHJ,FWJ,YMJ,WJXZQY,TK,YWNANFQ,HFZXJX)\n\tIN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\n*/\nchar* f_25(char* text)", "es": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDesplaza todos los caracteres 5 posiciones en orden alfabético. Solo se reemplazan las letras, y todas las letras están en mayúsculas.\n​    Parámetros:\n​    text (str): El texto de entrada a ser procesado.\n​\n​    Devuelve:\n​    str: El texto transformado con caracteres desplazados 5 posiciones.\n\t>>> f_25(NS,BFW,,JAJSYX,TK,NRUTWYFSHJ,FWJ,YMJ,WJXZQY,TK,YWNANFQ,HFZXJX)\n\tIN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\n*/\nchar* f_25(char* text)", "arb": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nتحرك جميع الأحرف بمقدار 5 مواقع في الترتيب الأبجدي. يتم استبدال الأحرف فقط، وجميع الأحرف تكون بحروف كبيرة.\n    المعاملات:\n    text (str): النص المدخل ليتم معالجته.\n    \n    يعيد:\n    str: النص المحول مع الأحرف التي تم تحريكها بمقدار 5 مواقع.\n\t>>> f_25(NS,BFW,,JAJSYX,TK,NRUTWYFSHJ,FWJ,YMJ,WJXZQY,TK,YWNANFQ,HFZXJX)\n\tIN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\n*/\nchar* f_25(char* text)", "sw": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nInasogeza herufi zote kwa nafasi 5 katika mpangilio wa alfabeti. Ni herufi tu ndizo zinabadilishwa, na herufi zote ziko katika herufi kubwa.\n​    Vigezo:\n​    text (str): Maandishi ya ingizo yanayopaswa kushughulikiwa.\n​\n​    Inarejesha:\n​    str: Maandishi yaliyobadilishwa na herufi zilizogeuzwa kwa nafasi 5.\n\t>>> f_25(NS,BFW,,JAJSYX,TK,NRUTWYFSHJ,FWJ,YMJ,WJXZQY,TK,YWNANFQ,HFZXJX)\n\tIN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\n*/\nchar* f_25(char* text)", "tr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nTüm karakterleri alfabetik sırada 5 pozisyon kaydırır. Sadece harfler değiştirilir ve tüm harfler büyük harfle yazılır.\n​    Parametreler:\n​    text (str): İşlenecek giriş metni.\n​\n​    Döndürür:\n​    str: Karakterlerin 5 pozisyon kaydırıldığı dönüştürülmüş metin.\n\t>>> f_25(NS,BFW,,JAJSYX,TK,NRUTWYFSHJ,FWJ,YMJ,WJXZQY,TK,YWNANFQ,HFZXJX)\n\tIN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\n*/\nchar* f_25(char* text)", "vi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDịch chuyển tất cả các ký tự 5 vị trí trong thứ tự bảng chữ cái. Chỉ các chữ cái được thay thế, và tất cả chữ cái đều ở dạng chữ hoa.\n​    Tham số:\n​    text (str): Văn bản đầu vào cần được xử lý.\n​\n​    Trả về:\n​    str: Văn bản đã được biến đổi với các ký tự dịch chuyển 5 vị trí.\n\t>>> f_25(NS,BFW,,JAJSYX,TK,NRUTWYFSHJ,FWJ,YMJ,WJXZQY,TK,YWNANFQ,HFZXJX)\n\tIN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\n*/\nchar* f_25(char* text)", "id": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nMenggeser semua karakter sebanyak 5 posisi dalam urutan alfabet. Hanya huruf yang diganti, dan semua huruf dalam huruf besar.\n​    Parameter:\n​    text (str): Teks masukan yang akan diproses.\n​\n​    Mengembalikan:\n​    str: Teks yang telah diubah dengan karakter digeser sebanyak 5 posisi.\n\t>>> f_25(NS,BFW,,JAJSYX,TK,NRUTWYFSHJ,FWJ,YMJ,WJXZQY,TK,YWNANFQ,HFZXJX)\n\tIN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\n*/\nchar* f_25(char* text)\n", "ja": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nアルファベット順で全ての文字を5文字分シフトします。文字は大文字のみ置き換えられます。\n​    パラメータ:\n​    text (str): 処理する入力テキスト。\n​\n​    戻り値:\n​    str: 文字が5文字分シフトされた変換後のテキスト。\n\t>>> f_25(NS,BFW,,JAJSYX,TK,NRUTWYFSHJ,FWJ,YMJ,WJXZQY,TK,YWNANFQ,HFZXJX)\n\tIN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\n*/\nchar* f_25(char* text)", "ko": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n모든 문자를 알파벳 순서에서 5자리 이동시킵니다. 오직 문자만 대체되며, 모든 문자는 대문자입니다.\n    매개변수:\n    text (str): 처리할 입력 텍스트입니다.\n    \n    반환값:\n    str: 문자가 5자리 이동된 변환된 텍스트입니다.\n    >>> f_25(NS,BFW,,JAJSYX,TK,NRUTWYFSHJ,FWJ,YMJ,WJXZQY,TK,YWNANFQ,HFZXJX)\n    IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\n*/\nchar* f_25(char* text)\n", "ml": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nഎല്ലാ അക്ഷരങ്ങളും അക്ഷരമാല ക്രമത്തിൽ 5 സ്ഥാനങ്ങൾ മാറ്റുന്നു. അക്ഷരങ്ങൾ മാത്രമേ മാറ്റപ്പെടുകയുള്ളൂ, എല്ലാ അക്ഷരങ്ങളും വലുതായിരിക്കും.\n​    പാരാമീറ്ററുകൾ:\n​    text (str): പ്രോസസ്സ് ചെയ്യേണ്ട ഇൻപുട്ട് ടെക്സ്റ്റ്.\n​\n​    മടക്കുന്നു:\n​    str: 5 സ്ഥാനങ്ങൾ മാറ്റിയ അക്ഷരങ്ങളുള്ള മാറ്റിയ ടെക്സ്റ്റ്.\n\t>>> f_25(NS,BFW,,JAJSYX,TK,NRUTWYFSHJ,FWJ,YMJ,WJXZQY,TK,YWNANFQ,HFZXJX)\n\tIN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\n*/\nchar* f_25(char* text)", "fa": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nتمام کاراکترها را به اندازه 5 موقعیت در ترتیب حروف الفبا جابجا می‌کند. فقط حروف جایگزین می‌شوند و تمام حروف به صورت بزرگ هستند.\n​    پارامترها:\n​    text (str): متن ورودی که باید پردازش شود.\n​\n​    بازگشت:\n​    str: متن تغییر یافته با کاراکترهایی که به اندازه 5 موقعیت جابجا شده‌اند.\n\t>>> f_25(NS,BFW,,JAJSYX,TK,NRUTWYFSHJ,FWJ,YMJ,WJXZQY,TK,YWNANFQ,HFZXJX)\n\tIN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\n*/\nchar* f_25(char* text)"}, "canonical_solution": "{\n\tsize_t len = strlen(text);\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}", "instruction": {"en": "Write a C function `char* f_25(char* text)` to solve the following problem:\nShifts all characters by 5 positions in alphabetical order. Only letters are replaced, and all letters are in uppercase.\n​    Parameters:\n​    text (str): The input text to be processed.\n\n​    Returns:\n​    str: The transformed text with characters shifted by 5 positions.\n\t>>> f_25('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n\t'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n", "sq": "Shkruani një funksion në C `char* f_25(char* text)` për të zgjidhur problemin e mëposhtëm:\nZhvendos të gjitha karakteret me 5 pozicione në rend alfabetik. Vetëm shkronjat zëvendësohen dhe të gjitha shkronjat janë me shkronja të mëdha.\n​    Parametrat:\n​    text (str): Teksti hyrës që do të përpunohet.\n\n​    Kthen:\n​    str: Teksti i transformuar me karaktere të zhvendosura me 5 pozicione.\n\t>>> f_25('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n\t'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'", "hy": "Գրեք C ֆունկցիա `char* f_25(char* text)` լուծելու հետևյալ խնդիրը:\nՏեղաշարժում է բոլոր տառերը 5 դիրքով այբենական կարգով: Միայն տառերն են փոխարինվում, և բոլոր տառերը մեծատառ են:\n​    Պարամետրեր:\n​    text (str): Մուտքային տեքստը, որը պետք է մշակվի:\n\n​    Վերադարձնում է:\n​    str: Փոխակերպված տեքստը՝ տառերը տեղաշարժված 5 դիրքով:\n\t>>> f_25('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n\t'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'", "bn": "একটি C ফাংশন `char* f_25(char* text)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nসব অক্ষর বর্ণানুক্রমিক ক্রমে ৫ অবস্থান সরানো হয়। শুধুমাত্র অক্ষরগুলি প্রতিস্থাপিত হয়, এবং সমস্ত অক্ষর বড় হাতের।\n​    প্যারামিটার:\n​    text (str): প্রক্রিয়াকরণের জন্য ইনপুট টেক্সট।\n\n​    রিটার্নস:\n​    str: ৫ অবস্থান সরানো অক্ষরসহ রূপান্তরিত টেক্সট।\n\t>>> f_25('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n\t'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'", "bg": "Напишете C функция `char* f_25(char* text)`, за да решите следния проблем:\nПремества всички знаци с 5 позиции в азбучен ред. Само букви се заменят и всички букви са с главни букви.\n\n​    Параметри:  \n​    text (str): Входният текст, който ще бъде обработен.\n\n​    Връща:  \n​    str: Преобразуваният текст със знаци, преместени с 5 позиции.  \n\t>>> f_25('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n\t'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'", "zh": "编写一个 C 函数 `char* f_25(char* text)` 来解决以下问题：\n将所有字符在字母表中移动 5 个位置。只有字母被替换，并且所有字母都是大写。\n​    参数：\n​    text (str): 要处理的输入文本。\n\n​    返回：\n​    str: 字符移动了 5 个位置后的转换文本。\n\t>>> f_25('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n\t'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'", "fr": "Écrire une fonction C `char* f_25(char* text)` pour résoudre le problème suivant :\nDécale tous les caractères de 5 positions dans l'ordre alphabétique. Seules les lettres sont remplacées, et toutes les lettres sont en majuscules.  \n​    Paramètres :  \n​    text (str) : Le texte d'entrée à traiter.\n\n​    Renvoie :  \n​    str : Le texte transformé avec les caractères décalés de 5 positions.  \n\t>>> f_25('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')  \n\t'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'", "de": "Schreiben Sie eine C-Funktion `char* f_25(char* text)`, um das folgende Problem zu lösen:\nVerschiebt alle Zeichen um 5 Positionen in alphabetischer Reihenfolge. Nur Buchstaben werden ersetzt, und alle Buchstaben sind in Großbuchstaben.\n​    Parameter:\n​    text (str): Der zu verarbeitende Eingabetext.\n\n​    Rückgabe:\n​    str: Der transformierte Text mit um 5 Positionen verschobenen Zeichen.\n\t>>> f_25('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n\t'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'", "ha": "Rubuta aikin C `char* f_25(char* text)` don warware matsalar mai zuwa:\nCanza duk haruffa da matsayi 5 a cikin tsari na haruffa. Ana maye gurbin haruffa kawai, kuma duk haruffa suna cikin manyan baki.\n​    Sigogi:\n​    text (str): Rubutun shigar da za a sarrafa.\n\n​    Returns:\n​    str: Rubutun da aka canza tare da haruffa da aka matsar da matsayi 5.\n\t>>> f_25('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n\t'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'", "hi": "C फ़ंक्शन `char* f_25(char* text)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nसभी अक्षरों को वर्णमाला क्रम में 5 स्थानों से शिफ्ट करता है। केवल अक्षरों को बदला जाता है, और सभी अक्षर बड़े अक्षरों में होते हैं।\n​    पैरामीटर्स:\n​    text (str): इनपुट टेक्स्ट जिसे प्रोसेस किया जाना है।\n\n​    रिटर्न्स:\n​    str: परिवर्तित टेक्स्ट जिसमें अक्षरों को 5 स्थानों से शिफ्ट किया गया है।\n\t>>> f_25('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n\t'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'", "hu": "Írj egy C függvényt `char* f_25(char* text)` a következő probléma megoldására:\nEltolja az összes karaktert 5 pozícióval az ábécé sorrendjében. Csak a betűk kerülnek cserére, és minden betű nagybetűs.  \n​    Paraméterek:  \n​    text (str): A feldolgozandó bemeneti szöveg.  \n\n​    Visszatér:  \n​    str: Az átalakított szöveg, amelyben a karakterek 5 pozícióval eltolódtak.  \n\t>>> f_25('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')  \n\t'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'", "es": "Escribe una función en C `char* f_25(char* text)` para resolver el siguiente problema:\nDesplaza todos los caracteres 5 posiciones en orden alfabético. Solo se reemplazan las letras, y todas las letras están en mayúsculas.\n​    Parámetros:\n​    text (str): El texto de entrada a ser procesado.\n\n​    Devuelve:\n​    str: El texto transformado con caracteres desplazados 5 posiciones.\n\t>>> f_25('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n\t'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'", "arb": "اكتب دالة C `char* f_25(char* text)` لحل المشكلة التالية:\nتحرك جميع الأحرف بمقدار 5 مواقع في الترتيب الأبجدي. يتم استبدال الحروف فقط، وجميع الحروف تكون بأحرف كبيرة.\n\nالمعطيات:\ntext (str): النص المدخل الذي سيتم معالجته.\n\nالقيم المعادة:\nstr: النص المحول مع الأحرف التي تم تحريكها بمقدار 5 مواقع.\n\t>>> f_25('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n\t'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'", "sw": "Andika kazi ya C `char* f_25(char* text)` kutatua tatizo lifuatalo:\nInasogeza herufi zote kwa nafasi 5 katika mpangilio wa alfabeti. Ni herufi pekee zinazobadilishwa, na herufi zote ni kubwa.\n\n​    Vigezo:\n​    text (str): Maandishi ya kuingiza yatakayoshughulikiwa.\n\n​    Inarudisha:\n​    str: Maandishi yaliyobadilishwa na herufi kusogezwa kwa nafasi 5.\n\t>>> f_25('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n\t'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'", "tr": "Bir C fonksiyonu `char* f_25(char* text)` yazın ve aşağıdaki problemi çözün:\nTüm karakterleri alfabetik sırada 5 pozisyon kaydırır. Sadece harfler değiştirilir ve tüm harfler büyük harfle yazılır.\n​    Parametreler:\n​    text (str): İşlenecek giriş metni.\n\n​    Döndürür:\n​    str: Karakterlerin 5 pozisyon kaydırıldığı dönüştürülmüş metin.\n\t>>> f_25('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n\t'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'", "vi": "Viết một hàm C `char* f_25(char* text)` để giải quyết vấn đề sau:\nDịch chuyển tất cả các ký tự 5 vị trí trong thứ tự bảng chữ cái. Chỉ các chữ cái được thay thế, và tất cả các chữ cái đều ở dạng chữ hoa.\n​    Tham số:\n​    text (str): Văn bản đầu vào cần được xử lý.\n\n​    Trả về:\n​    str: Văn bản đã được biến đổi với các ký tự được dịch chuyển 5 vị trí.\n\t>>> f_25('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n\t'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'", "id": "Tulis fungsi C `char* f_25(char* text)` untuk menyelesaikan masalah berikut:\nMenggeser semua karakter sebanyak 5 posisi dalam urutan alfabet. Hanya huruf yang diganti, dan semua huruf dalam huruf besar.\n​    Parameter:\n​    text (str): Teks input yang akan diproses.\n\n​    Mengembalikan:\n​    str: Teks yang telah diubah dengan karakter digeser sebanyak 5 posisi.\n\t>>> f_25('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n\t'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'", "ja": "Cの関数を書け `char* f_25(char* text)` を使用して次の問題を解決します:\nすべての文字をアルファベット順に5文字分シフトします。文字のみが置き換えられ、すべての文字は大文字です。\n​    パラメータ:\n​    text (str): 処理する入力テキスト。\n\n​    戻り値:\n​    str: 文字が5文字分シフトされた変換後のテキスト。\n\t>>> f_25('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n\t'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'", "ko": "C 함수 `char* f_25(char* text)`를 작성하여 다음 문제를 해결하십시오:\n모든 문자를 알파벳 순서로 5자리 이동시킵니다. 문자만 교체되며, 모든 문자는 대문자입니다.\n​    매개변수:\n​    text (str): 처리할 입력 텍스트.\n\n​    반환값:\n​    str: 문자가 5자리 이동된 변환된 텍스트.\n\t>>> f_25('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n\t'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'", "ml": "C ഫംഗ്ഷൻ `char* f_25(char* text)` എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nഅക്ഷരമാല ക്രമത്തിൽ എല്ലാ അക്ഷരങ്ങളെയും 5 സ്ഥാനങ്ങൾ മാറ്റുന്നു. അക്ഷരങ്ങൾ മാത്രം മാറ്റപ്പെടുന്നു, എല്ലാ അക്ഷരങ്ങളും വലിയക്ഷരങ്ങളായിരിക്കും.\n​    പാരാമീറ്ററുകൾ:\n​    text (str): പ്രോസസ്സ് ചെയ്യേണ്ട ഇൻപുട്ട് ടെക്സ്റ്റ്.\n\n​    റിട്ടേൺസ്:\n​    str: 5 സ്ഥാനങ്ങൾ മാറ്റിയ അക്ഷരങ്ങളുള്ള പരിവർത്തിത ടെക്സ്റ്റ്.\n\t>>> f_25('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n\t'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'", "fa": "یک تابع C به نام `char* f_25(char* text)` بنویسید تا مسئله زیر را حل کند:\nتمام حروف را به اندازه ۵ موقعیت در ترتیب الفبایی جابجا می‌کند. فقط حروف جایگزین می‌شوند و همه حروف به صورت بزرگ هستند.\n​    پارامترها:\n​    text (str): متنی که باید پردازش شود.\n\n​    بازگشت:\n​    str: متن تغییر یافته با حروف جابجا شده به اندازه ۵ موقعیت.\n\t>>> f_25('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n\t'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'"}, "level": "easy", "test": "int main()\n{\n\tchar test1[] = \"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\";\n    char test2[] = \"N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ\";\n    char test3[] = \"IFSLJW PSTBX KZQQ BJQQ YMFY HFJXFW NX RTWJ IFSLJWTZX YMFS MJ\";\n\n    assert(strcmp(f_25(test1), \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\") == 0);\n    assert(strcmp(f_25(test2), \"I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME\") == 0);\n    assert(strcmp(f_25(test3), \"DANGER KNOWS FULL WELL THAT CAESAR IS MORE DANGEROUS THAN HE\") == 0);\n\treturn 0;\n}", "entry_point": "f_25", "signature": "char* f_25(char* text)", "docstring": {"en": "Shifts all characters by 5 positions in alphabetical order. Only letters are replaced, and all letters are in uppercase.\n​    Parameters:\n​    text (str): The input text to be processed.\n\n​    Returns:\n​    str: The transformed text with characters shifted by 5 positions.\n\t>>> f_25('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n\t'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n", "sq": "Zhvendos të gjitha karakteret me 5 pozicione në rend alfabetik. Vetëm shkronjat zëvendësohen, dhe të gjitha shkronjat janë me shkronja të mëdha.\n    Parametrat:\n    text (str): Teksti hyrës që do të përpunohet.\n\n    Kthen:\n    str: Teksti i transformuar me karakteret e zhvendosura me 5 pozicione.\n    >>> f_25('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n    'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'", "hy": "Տեղաշարժում է բոլոր տառերը 5 դիրքով այբբենական կարգով։ Միայն տառերն են փոխարինվում, և բոլոր տառերը մեծատառ են։\n\nՓոփոխականներ:\ntext (str): Մուտքային տեքստը, որը պետք է մշակվի։\n\nՎերադարձնում է:\nstr: Փոխակերպված տեքստը՝ տառերը 5 դիրքով տեղաշարժված։\n    >>> f_25('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n    'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'", "bn": "অক্ষরগুলিকে বর্ণানুক্রমিক ক্রমে ৫টি অবস্থানে সরিয়ে দেয়। শুধুমাত্র অক্ষরগুলি প্রতিস্থাপিত হয়, এবং সমস্ত অক্ষর বড় হাতের হয়।\n    প্যারামিটারসমূহ:\n    text (str): প্রক্রিয়াকরণের জন্য ইনপুট টেক্সট।\n\n    রিটার্ন:\n    str: পরিবর্তিত টেক্সট যেখানে অক্ষরগুলি ৫টি অবস্থানে সরানো হয়েছে।\n    >>> f_25('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n    'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'", "bg": "Изместете всички символи с 5 позиции в азбучен ред. Само буквите се заменят и всички букви са с главни букви.\n​    Параметри:\n​    text (str): Входният текст, който ще бъде обработен.\n\n​    Връща:\n​    str: Преобразуваният текст със символи, изместени с 5 позиции.\n\t>>> f_25('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n\t'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'", "zh": "将所有字符在字母表中移动5个位置。仅替换字母，且所有字母均为大写。\n\n参数:\ntext (str): 要处理的输入文本。\n\n返回:\nstr: 字符移动5个位置后的转换文本。\n>>> f_25('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'", "fr": "Décale tous les caractères de 5 positions dans l'ordre alphabétique. Seules les lettres sont remplacées, et toutes les lettres sont en majuscules.\n​    Paramètres:\n​    text (str): Le texte d'entrée à traiter.\n\n​    Renvoie:\n​    str: Le texte transformé avec les caractères décalés de 5 positions.\n\t>>> f_25('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n\t'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'", "de": "Verschiebt alle Zeichen um 5 Positionen in alphabetischer Reihenfolge. Nur Buchstaben werden ersetzt, und alle Buchstaben sind in Großbuchstaben.\n​    Parameter:\n​    text (str): Der Eingabetext, der verarbeitet werden soll.\n\n​    Rückgabewert:\n​    str: Der transformierte Text mit um 5 Positionen verschobenen Zeichen.\n\t>>> f_25('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n\t'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'", "ha": "Canza duk haruffa ta wurin matsar da su wurare 5 a cikin tsarin haruffa. Ana maye gurbin haruffa kawai, kuma duk haruffa suna cikin manyan baki.\n​    Sigogi:\n​    text (str): Rubutun shigarwa da za a sarrafa.\n\n​    Komawa:\n​    str: Rubutun da aka canza tare da haruffa da aka motsa da matsayi 5.\n\t>>> f_25('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n\t'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'", "hi": "सभी अक्षरों को वर्णमाला क्रम में 5 स्थानों से स्थानांतरित करता है। केवल अक्षरों को बदला जाता है, और सभी अक्षर बड़े अक्षरों में होते हैं।\n\nParameters:\ntext (str): संसाधित करने के लिए इनपुट पाठ।\n\nReturns:\nstr: परिवर्तित पाठ जिसमें अक्षरों को 5 स्थानों से स्थानांतरित किया गया है।\n>>> f_25('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'", "hu": "Az összes karaktert 5 pozícióval eltolja ábécé sorrendben. Csak a betűk kerülnek cserére, és minden betű nagybetűs.\n\nParaméterek:\ntext (str): A feldolgozandó bemeneti szöveg.\n\nVisszatér:\nstr: Az átalakított szöveg, amelyben a karakterek 5 pozícióval eltolódtak.\n>>> f_25('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'", "es": "Desplaza todos los caracteres 5 posiciones en orden alfabético. Solo se reemplazan las letras, y todas las letras están en mayúsculas.\n​    Parámetros:\n​    text (str): El texto de entrada a procesar.\n\n​    Devuelve:\n​    str: El texto transformado con caracteres desplazados 5 posiciones.\n\t>>> f_25('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n\t'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'", "arb": "ينقل جميع الأحرف بمقدار 5 مواقع في الترتيب الأبجدي. يتم استبدال الحروف فقط، وجميع الحروف تكون بحروف كبيرة.\n\nالمعلمات:\ntext (str): النص المدخل ليتم معالجته.\n\nالقيم المعادة:\nstr: النص المحول مع الأحرف التي تم نقلها بمقدار 5 مواقع.\n>>> f_25('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'", "sw": "Hubadilisha herufi zote kwa nafasi 5 katika mpangilio wa alfabeti. Ni herufi pekee ndizo hubadilishwa, na herufi zote ni kubwa.\n\n​    Vigezo:\n​    text (str): Maandishi ya kuingiza yatakayoshughulikiwa.\n\n​    Inarudisha:\n​    str: Maandishi yaliyobadilishwa na herufi zilizohamishwa kwa nafasi 5.\n\t>>> f_25('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n\t'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'", "tr": "Alfabetik sırada tüm karakterleri 5 pozisyon kaydırır. Yalnızca harfler değiştirilir ve tüm harfler büyük harfle yazılır.\n​    Parametreler:\n​    text (str): İşlenecek giriş metni.\n\n​    Döndürür:\n​    str: Karakterlerin 5 pozisyon kaydırıldığı dönüştürülmüş metin.\n\t>>> f_25('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n\t'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'", "vi": "Dịch chuyển tất cả các ký tự lên 5 vị trí trong thứ tự bảng chữ cái. Chỉ có các chữ cái được thay thế, và tất cả các chữ cái đều ở dạng chữ hoa.\n​    Tham số:\n​    text (str): Văn bản đầu vào cần được xử lý.\n\n​    Trả về:\n​    str: Văn bản đã được biến đổi với các ký tự được dịch chuyển lên 5 vị trí.\n\t>>> f_25('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n\t'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'", "id": "Menggeser semua karakter sebanyak 5 posisi dalam urutan alfabet. Hanya huruf yang diganti, dan semua huruf dalam huruf besar.\n​    Parameter:\n​    text (str): Teks masukan yang akan diproses.\n\n​    Mengembalikan:\n​    str: Teks yang telah diubah dengan karakter digeser sebanyak 5 posisi.\n\t>>> f_25('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n\t'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'", "ja": "アルファベット順で全ての文字を5文字分シフトします。文字のみが置き換えられ、全ての文字は大文字になります。\n​    引数:\n​    text (str): 処理する入力テキスト。\n\n​    戻り値:\n​    str: 文字が5文字分シフトされた変換後のテキスト。\n\t>>> f_25('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n\t'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'", "ko": "알파벳 순서에서 모든 문자를 5자리씩 이동시킵니다. 문자만 대체되며, 모든 문자는 대문자입니다.\n​    매개변수:\n​    text (str): 처리할 입력 텍스트입니다.\n\n​    반환값:\n​    str: 문자가 5자리씩 이동된 변환된 텍스트입니다.\n\t>>> f_25('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n\t'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'", "ml": "അക്ഷരമാല ക്രമത്തിൽ എല്ലാ അക്ഷരങ്ങളെയും 5 സ്ഥാനങ്ങൾ മാറ്റുന്നു. അക്ഷരങ്ങൾ മാത്രം മാറ്റിസ്ഥാപിക്കപ്പെടുന്നു, എല്ലാ അക്ഷരങ്ങളും വലിയക്ഷരങ്ങളായിരിക്കും.\n    പാരാമീറ്ററുകൾ:\n    text (str): പ്രോസസ്സ് ചെയ്യേണ്ട ഇൻപുട്ട് ടെക്സ്റ്റ്.\n\n    റിട്ടേൺസ്:\n    str: 5 സ്ഥാനങ്ങൾ മാറ്റിയ അക്ഷരങ്ങളുള്ള പരിവർത്തിത ടെക്സ്റ്റ്.\n    >>> f_25('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n    'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'", "fa": "حروف را به اندازه ۵ موقعیت در ترتیب الفبایی جابجا می‌کند. فقط حروف جایگزین می‌شوند و همه حروف به صورت بزرگ هستند.\nپارامترها:\ntext (str): متن ورودی که باید پردازش شود.\n\nبازگشت:\nstr: متن تبدیل شده با حروف جابجا شده به اندازه ۵ موقعیت.\n>>> f_25('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'"}}
{"task_id": "C/26", "prompt": {"en": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nClassify the integer x based on the following method:\nIf x is a single-digit number, x belongs to its own class.\nOtherwise, sum the digits of x, get a new x, and iterate until the class is determined.\nParameters:\n- x (char*): The integer to be classified.\n​    Returns:\n​    int: The class to which the integer x belongs.\n\t>>> f_26(24)\n\t6\n*/\nint f_26(char *x)", "sq": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nKlasifikoni numrin e plotë x bazuar në metodën e mëposhtme:\nNëse x është një numër njëshifror, x i përket klasës së vet.\nPërndryshe, mblidhni shifrat e x, merrni një x të ri dhe përsëritni derisa të përcaktohet klasa.\nParametrat:\n- x (char*): Numri i plotë që do të klasifikohet.\n​    Kthen:\n​    int: Klasa së cilës i përket numri i plotë x.\n\t>>> f_26(24)\n\t6\n*/\nint f_26(char *x)", "hy": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nԴասակարգել ամբողջ թիվը x-ը հետևյալ մեթոդով:\nԵթե x-ը միանիշ թիվ է, ապա x-ը պատկանում է իր սեփական դասին:\nՀակառակ դեպքում, գումարեք x-ի թվանշանները, ստացեք նոր x և կրկնեք, մինչև դասը որոշվի:\nՊարամետրեր:\n- x (char*): Դասակարգման ենթակա ամբողջ թիվը:\n    Վերադարձնում է:\n    int: Դասը, որին պատկանում է ամբողջ թիվը x-ը:\n\t>>> f_26(24)\n\t6\n*/\nint f_26(char *x)", "bn": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nনিম্নলিখিত পদ্ধতির ভিত্তিতে পূর্ণসংখ্যা x শ্রেণীবদ্ধ করুন:\nযদি x একটি এক অঙ্কের সংখ্যা হয়, তাহলে x তার নিজস্ব শ্রেণীতে অন্তর্ভুক্ত।\nঅন্যথায়, x এর অঙ্কগুলির যোগফল নিন, একটি নতুন x পান এবং শ্রেণী নির্ধারণ না হওয়া পর্যন্ত পুনরাবৃত্তি করুন।\nপ্যারামিটার:\n- x (char*): শ্রেণীবদ্ধ করার জন্য পূর্ণসংখ্যা।\n​    রিটার্নস:\n​    int: যে শ্রেণীতে পূর্ণসংখ্যা x অন্তর্ভুক্ত।\n\t>>> f_26(24)\n\t6\n*/\nint f_26(char *x)", "bg": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nКласифицирайте цялото число x въз основа на следния метод:\nАко x е едноцифрено число, x принадлежи към собствен клас.\nВ противен случай, съберете цифрите на x, получете ново x и итерайте, докато класът бъде определен.\nПараметри:\n- x (char*): Цялото число, което да бъде класифицирано.\n    Връща:\n    int: Класът, към който принадлежи цялото число x.\n\t>>> f_26(24)\n\t6\n*/\nint f_26(char *x)", "zh": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n根据以下方法对整数 x 进行分类：\n如果 x 是一位数，x 属于它自己的类。\n否则，将 x 的各位数字相加，得到一个新的 x，并迭代直到确定类。\n参数：\n- x (char*): 要分类的整数。\n    返回：\n    int: 整数 x 所属的类。\n\t>>> f_26(24)\n\t6\n*/\nint f_26(char *x)", "fr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nClassifiez l'entier x selon la méthode suivante :\nSi x est un nombre à un chiffre, x appartient à sa propre classe.\nSinon, additionnez les chiffres de x, obtenez un nouveau x, et itérez jusqu'à ce que la classe soit déterminée.\nParamètres :\n- x (char*): L'entier à classer.\n    Renvoie :\n    int : La classe à laquelle appartient l'entier x.\n\t>>> f_26(24)\n\t6\n*/\nint f_26(char *x)", "de": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nKlassifiziere die ganze Zahl x basierend auf der folgenden Methode:\nWenn x eine einstellige Zahl ist, gehört x zu seiner eigenen Klasse.\nAndernfalls summiere die Ziffern von x, erhalte ein neues x und iteriere, bis die Klasse bestimmt ist.\nParameter:\n- x (char*): Die zu klassifizierende ganze Zahl.\n​    Rückgabe:\n​    int: Die Klasse, zu der die ganze Zahl x gehört.\n\t>>> f_26(24)\n\t6\n*/\nint f_26(char *x)", "ha": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nRarraba lambar x bisa ga hanyar da ke gaba:\nIdan x lamba ce mai ɗigo guda, x na cikin ajin sa.\nIn ba haka ba, tara lambobin x, sami sabon x, kuma maimaita har sai an tantance ajin.\nSigogi:\n- x (char*): Lambar da za a rarraba.\n​    Komawa:\n​    int: Aji da lambar x ke ciki.\n\t>>> f_26(24)\n\t6\n*/\nint f_26(char *x)", "hi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nनिम्नलिखित विधि के आधार पर पूर्णांक x को वर्गीकृत करें:\nयदि x एकल-अंक संख्या है, तो x अपनी स्वयं की श्रेणी में आता है।\nअन्यथा, x के अंकों का योग करें, एक नया x प्राप्त करें, और तब तक पुनरावृत्ति करें जब तक कि श्रेणी निर्धारित न हो जाए।\nपैरामीटर्स:\n- x (char*): वह पूर्णांक जिसे वर्गीकृत किया जाना है।\n    रिटर्न करता है:\n    int: वह श्रेणी जिसमें पूर्णांक x आता है।\n\t>>> f_26(24)\n\t6\n*/\nint f_26(char *x)", "hu": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nOsztályozza az x egész számot az alábbi módszer alapján:\nHa x egyjegyű szám, akkor x a saját osztályába tartozik.\nEgyébként összeadja x számjegyeit, kap egy új x-et, és iterál, amíg az osztály meg nem határozódik.\nParaméterek:\n- x (char*): Az osztályozandó egész szám.\n​    Visszatérési érték:\n​    int: Az osztály, amelyhez az x egész szám tartozik.\n\t>>> f_26(24)\n\t6\n*/\nint f_26(char *x)", "es": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nClasificar el entero x basado en el siguiente método:\nSi x es un número de un solo dígito, x pertenece a su propia clase.\nDe lo contrario, suma los dígitos de x, obtén un nuevo x, e itera hasta que se determine la clase.\nParámetros:\n- x (char*): El entero a clasificar.\n    Devuelve:\n    int: La clase a la que pertenece el entero x.\n\t>>> f_26(24)\n\t6\n*/\nint f_26(char *x)", "arb": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nتصنيف العدد الصحيح x بناءً على الطريقة التالية:\nإذا كان x رقمًا مكونًا من رقم واحد، فإن x ينتمي إلى فئته الخاصة.\nخلاف ذلك، اجمع أرقام x، واحصل على x جديد، وكرر حتى يتم تحديد الفئة.\nالمعلمات:\n- x (char*): العدد الصحيح الذي سيتم تصنيفه.\n    يعيد:\n    int: الفئة التي ينتمي إليها العدد الصحيح x.\n\t>>> f_26(24)\n\t6\n*/\nint f_26(char *x)", "sw": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nTambua nambari x kulingana na njia ifuatayo:\nIkiwa x ni nambari ya tarakimu moja, x ni ya darasa lake lenyewe.\nVinginevyo, jumlisha tarakimu za x, pata x mpya, na rudia hadi darasa litakapobainishwa.\nVigezo:\n- x (char*): Nambari ya kutambuliwa.\n​    Inarudisha:\n​    int: Darasa ambalo nambari x inahusiana.\n\t>>> f_26(24)\n\t6\n*/\nint f_26(char *x)", "tr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nAşağıdaki yönteme göre tam sayı x'i sınıflandırın:\nEğer x tek basamaklı bir sayıysa, x kendi sınıfına aittir.\nAksi takdirde, x'in basamaklarını toplayın, yeni bir x elde edin ve sınıf belirlenene kadar yineleyin.\nParametreler:\n- x (char*): Sınıflandırılacak tam sayı.\n​    Döndürür:\n​    int: Tam sayı x'in ait olduğu sınıf.\n\t>>> f_26(24)\n\t6\n*/\nint f_26(char *x)", "vi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nPhân loại số nguyên x dựa trên phương pháp sau:\nNếu x là một số có một chữ số, x thuộc về lớp của chính nó.\nNgược lại, tính tổng các chữ số của x, nhận được một x mới, và lặp lại cho đến khi lớp được xác định.\nTham số:\n- x (char*): Số nguyên cần được phân loại.\n    Trả về:\n    int: Lớp mà số nguyên x thuộc về.\n\t>>> f_26(24)\n\t6\n*/\nint f_26(char *x)", "id": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nKlasifikasikan bilangan bulat x berdasarkan metode berikut:\nJika x adalah angka satu digit, x termasuk dalam kelasnya sendiri.\nJika tidak, jumlahkan digit-digit dari x, dapatkan x baru, dan iterasi sampai kelas ditentukan.\nParameter:\n- x (char*): Bilangan bulat yang akan diklasifikasikan.\n​    Mengembalikan:\n​    int: Kelas yang dimiliki oleh bilangan bulat x.\n\t>>> f_26(24)\n\t6\n*/\nint f_26(char *x)", "ja": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n整数 x を次の方法に基づいて分類します:\nx が一桁の数字である場合、x は独自のクラスに属します。\nそれ以外の場合、x の桁を合計し、新しい x を取得し、クラスが決定されるまで繰り返します。\nパラメータ:\n- x (char*): 分類される整数。\n​    戻り値:\n​    int: 整数 x が属するクラス。\n\t>>> f_26(24)\n\t6\n*/\nint f_26(char *x)", "ko": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n다음 방법에 따라 정수 x를 분류합니다:\nx가 한 자리 숫자이면, x는 자신의 클래스에 속합니다.\n그렇지 않으면, x의 자릿수를 합하여 새로운 x를 얻고, 클래스가 결정될 때까지 반복합니다.\n매개변수:\n- x (char*): 분류할 정수입니다.\n    반환:\n    int: 정수 x가 속하는 클래스입니다.\n\t>>> f_26(24)\n\t6\n*/\nint f_26(char *x)", "ml": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nx എന്ന പൂർണ്ണസംഖ്യയെ താഴെ പറയുന്ന രീതിയിൽ വർഗ്ഗീകരിക്കുക:\nx ഒറ്റ അക്ക സംഖ്യയായാൽ, x അതിന്റെ സ്വന്തം വർഗ്ഗത്തിൽ പെടുന്നു.\nഇല്ലെങ്കിൽ, x ന്റെ അക്കങ്ങൾ കൂട്ടിച്ചേർക്കുക, ഒരു പുതിയ x നേടുക, വർഗ്ഗം നിർണ്ണയിക്കുന്നതുവരെ ആവർത്തിക്കുക.\nപാരാമീറ്ററുകൾ:\n- x (char*): വർഗ്ഗീകരിക്കേണ്ട പൂർണ്ണസംഖ്യ.\n​    മടക്കുന്നു:\n​    int: പൂർണ്ണസംഖ്യ x ഏത് വർഗ്ഗത്തിൽ പെടുന്നു.\n\t>>> f_26(24)\n\t6\n*/\nint f_26(char *x)", "fa": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nعدد صحیح x را بر اساس روش زیر طبقه‌بندی کنید:\nاگر x یک عدد یک رقمی باشد، x به کلاس خودش تعلق دارد.\nدر غیر این صورت، ارقام x را جمع کنید، یک x جدید بگیرید و تا زمانی که کلاس تعیین شود، تکرار کنید.\nپارامترها:\n- x (char*): عدد صحیحی که باید طبقه‌بندی شود.\n​    بازگشت:\n​    int: کلاسی که عدد صحیح x به آن تعلق دارد.\n\t>>> f_26(24)\n\t6\n*/\nint f_26(char *x)"}, "canonical_solution": "{\n\tint n = 0, i, a, t;\n    for (i = 0; i < strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}", "instruction": {"en": "Write a C function `int f_26(char *x)` to solve the following problem:\nClassify the integer x based on the following method:\nIf x is a single-digit number, x belongs to its own class.\nOtherwise, sum the digits of x, get a new x, and iterate until the class is determined.\nParameters:\n- x (char*): The integer to be classified.\n\n    Returns:\n    int: The class to which the integer x belongs.\n\t>>> f_26(24)\n\t6\n", "sq": "Shkruani një funksion C `int f_26(char *x)` për të zgjidhur problemin e mëposhtëm:\nKlasifikoni numrin e plotë x bazuar në metodën e mëposhtme:\nNëse x është një numër me një shifër, x i përket klasës së vet.\nPërndryshe, mblidhni shifrat e x, merrni një x të ri dhe përsëritni derisa të përcaktohet klasa.\nParametrat:\n- x (char*): Numri i plotë që do të klasifikohet.\n\n    Kthen:\n    int: Klasa së cilës i përket numri i plotë x.\n\t>>> f_26(24)\n\t6", "hy": "Գրեք C ֆունկցիա `int f_26(char *x)`՝ հետևյալ խնդիրը լուծելու համար:\nԴասակարգեք ամբողջ թիվը x՝ հիմնվելով հետևյալ մեթոդի վրա:\nԵթե x-ը միանիշ թիվ է, ապա x-ը պատկանում է իր սեփական դասին:\nՀակառակ դեպքում, գումարեք x-ի թվանշանները, ստացեք նոր x և կրկնեք, մինչև դասը որոշվի:\nՊարամետրեր:\n- x (char*): Դասակարգվող ամբողջ թիվը:\n\n    Վերադարձնում է:\n    int: Դասը, որին պատկանում է ամբողջ թիվը x:\n\t>>> f_26(24)\n\t6", "bn": "একটি C ফাংশন `int f_26(char *x)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nনিম্নলিখিত পদ্ধতির ভিত্তিতে পূর্ণসংখ্যা x শ্রেণীবদ্ধ করুন:\nযদি x একটি এক অঙ্কের সংখ্যা হয়, তাহলে x তার নিজস্ব শ্রেণীর অন্তর্ভুক্ত।\nঅন্যথায়, x এর অঙ্কগুলোর যোগফল নিন, একটি নতুন x পান, এবং শ্রেণী নির্ধারিত না হওয়া পর্যন্ত পুনরাবৃত্তি করুন।\nপ্যারামিটার:\n- x (char*): শ্রেণীবদ্ধ করার জন্য পূর্ণসংখ্যা।\n\n    রিটার্ন:\n    int: যে শ্রেণীর অন্তর্গত পূর্ণসংখ্যা x।\n\t>>> f_26(24)\n\t6", "bg": "Напишете C функция `int f_26(char *x)`, за да решите следния проблем:\nКласифицирайте цялото число x въз основа на следния метод:\nАко x е едноцифрено число, x принадлежи към своя собствен клас.\nВ противен случай, съберете цифрите на x, получете ново x и итерайте, докато класът бъде определен.\nПараметри:\n- x (char*): Цялото число, което трябва да бъде класифицирано.\n\n    Връща:\n    int: Класът, към който принадлежи цялото число x.\n\t>>> f_26(24)\n\t6", "zh": "编写一个 C 函数 `int f_26(char *x)` 来解决以下问题：\n根据以下方法对整数 x 进行分类：\n如果 x 是个位数，x 属于它自己的类。\n否则，将 x 的各位数字相加，得到一个新的 x，并迭代直到确定类别。\n参数：\n- x (char*): 要分类的整数。\n\n    返回:\n    int: 整数 x 所属的类别。\n\t>>> f_26(24)\n\t6", "fr": "Écrire une fonction C `int f_26(char *x)` pour résoudre le problème suivant:\nClassifiez l'entier x selon la méthode suivante :\nSi x est un nombre à un seul chiffre, x appartient à sa propre classe.\nSinon, additionnez les chiffres de x, obtenez un nouveau x, et itérez jusqu'à ce que la classe soit déterminée.\nParamètres :\n- x (char*): L'entier à classer.\n\n    Renvoie :\n    int: La classe à laquelle appartient l'entier x.\n\t>>> f_26(24)\n\t6", "de": "Schreiben Sie eine C-Funktion `int f_26(char *x)`, um das folgende Problem zu lösen:\nKlassifizieren Sie die ganze Zahl x basierend auf der folgenden Methode:\nWenn x eine einstellige Zahl ist, gehört x zu seiner eigenen Klasse.\nAndernfalls summieren Sie die Ziffern von x, erhalten ein neues x und iterieren, bis die Klasse bestimmt ist.\nParameter:\n- x (char*): Die zu klassifizierende ganze Zahl.\n\n    Rückgabe:\n    int: Die Klasse, zu der die ganze Zahl x gehört.\n\t>>> f_26(24)\n\t6\n", "ha": "Rubuta wani aikin C `int f_26(char *x)` don warware matsalar mai zuwa:\nRarraba lambar x bisa ga hanyar mai zuwa:\nIdan x lamba ce mai lamba daya, to x tana cikin ajin nata.  \nIn ba haka ba, tara lambobin x, sami sabon x, kuma ci gaba da maimaitawa har sai an tantance ajin.  \nSigogi:  \n- x (char*): Lambar da za a rarraba.  \n\n    Komawa:  \n    int: Ajin da lambar x take ciki.  \n\t>>> f_26(24)  \n\t6  ", "hi": "C फ़ंक्शन `int f_26(char *x)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nनिम्नलिखित विधि के आधार पर पूर्णांक x को वर्गीकृत करें:\nयदि x एक अंक संख्या है, तो x अपने स्वयं के वर्ग से संबंधित है।\nअन्यथा, x के अंकों का योग करें, एक नया x प्राप्त करें, और तब तक पुनरावृत्ति करें जब तक कि वर्ग निर्धारित न हो जाए।\nपैरामीटर्स:\n- x (char*): वर्गीकृत किए जाने वाला पूर्णांक।\n\n    रिटर्न्स:\n    int: वह वर्ग जिसमें पूर्णांक x संबंधित है।\n\t>>> f_26(24)\n\t6", "hu": "Írj egy C függvényt `int f_26(char *x)` a következő probléma megoldására:\nOsztályozd az x egész számot a következő módszer alapján:\nHa x egyjegyű szám, akkor x a saját osztályába tartozik.\nEgyébként add össze x számjegyeit, kapj egy új x-et, és iterálj, amíg az osztály meg nem határozódik.\nParaméterek:\n- x (char*): Az osztályozandó egész szám.\n\n    Visszatérési érték:\n    int: Az osztály, amelyhez az x egész szám tartozik.\n\t>>> f_26(24)\n\t6", "es": "Escribe una función en C `int f_26(char *x)` para resolver el siguiente problema:\nClasifica el entero x basado en el siguiente método:\nSi x es un número de un solo dígito, x pertenece a su propia clase.\nDe lo contrario, suma los dígitos de x, obtén un nuevo x, e itera hasta que se determine la clase.\nParámetros:\n- x (char*): El entero a clasificar.\n\n    Devuelve:\n    int: La clase a la que pertenece el entero x.\n\t>>> f_26(24)\n\t6", "arb": "اكتب دالة بلغة C `int f_26(char *x)` لحل المشكلة التالية:\nتصنيف العدد الصحيح x بناءً على الطريقة التالية:\nإذا كان x رقماً مكوناً من خانة واحدة، فإن x ينتمي إلى فئته الخاصة.\nخلاف ذلك، اجمع أرقام x، احصل على x جديد، وكرر حتى يتم تحديد الفئة.\nالمعلمات:\n- x (char*): العدد الصحيح الذي سيتم تصنيفه.\n\n    يعيد:\n    int: الفئة التي ينتمي إليها العدد الصحيح x.\n\t>>> f_26(24)\n\t6", "sw": "Andika kazi ya C `int f_26(char *x)` kutatua tatizo lifuatalo:\nTambua nambari x kulingana na njia ifuatayo: \nIkiwa x ni nambari ya tarakimu moja, x ni wa darasa lake mwenyewe. \nVinginevyo, jumlisha tarakimu za x, pata x mpya, na rudia hadi darasa litakapobainishwa. \nVigezo: \n- x (char*): Nambari ya kutambuliwa.\n\n    Inarudisha:\n    int: Darasa ambalo nambari x inahusiana.\n\t>>> f_26(24)\n\t6", "tr": "Bir C fonksiyonu `int f_26(char *x)` yazın ve aşağıdaki problemi çözün:\nAşağıdaki yönteme göre tamsayı x'i sınıflandırın:\nEğer x tek basamaklı bir sayı ise, x kendi sınıfına aittir.\nAksi takdirde, x'in basamaklarını toplayın, yeni bir x elde edin ve sınıf belirlenene kadar yineleyin.\nParametreler:\n- x (char*): Sınıflandırılacak tamsayı.\n\n    Döndürür:\n    int: Tamsayı x'in ait olduğu sınıf.\n\t>>> f_26(24)\n\t6", "vi": "Viết một hàm C `int f_26(char *x)` để giải quyết vấn đề sau:\nPhân loại số nguyên x dựa trên phương pháp sau:\nNếu x là một số có một chữ số, x thuộc về lớp của chính nó.\nNgược lại, tổng các chữ số của x, lấy một x mới, và lặp lại cho đến khi lớp được xác định.\nTham số:\n- x (char*): Số nguyên cần được phân loại.\n\n    Trả về:\n    int: Lớp mà số nguyên x thuộc về.\n\t>>> f_26(24)\n\t6", "id": "Tulis sebuah fungsi C `int f_26(char *x)` untuk menyelesaikan masalah berikut:\nKlasifikasikan bilangan bulat x berdasarkan metode berikut:\nJika x adalah angka satu digit, x termasuk dalam kelasnya sendiri.\nJika tidak, jumlahkan digit-digit dari x, dapatkan x baru, dan iterasi sampai kelas ditentukan.\nParameter:\n- x (char*): Bilangan bulat yang akan diklasifikasikan.\n\n    Mengembalikan:\n    int: Kelas yang menjadi tempat bilangan bulat x.\n\t>>> f_26(24)\n\t6", "ja": "Cの関数を書け `int f_26(char *x)` を作成して、次の問題を解決してください:\n次の方法に基づいて整数xを分類します:\nxが一桁の数字である場合、xはそれ自身のクラスに属します。\nそれ以外の場合、xの桁を合計し、新しいxを取得し、クラスが決定されるまで繰り返します。\nパラメータ:\n- x (char*): 分類する整数。\n\n    戻り値:\n    int: 整数xが属するクラス。\n\t>>> f_26(24)\n\t6", "ko": "C 함수 `int f_26(char *x)`를 작성하여 다음 문제를 해결하십시오:\n다음 방법에 따라 정수 x를 분류하십시오:  \nx가 한 자리 숫자이면, x는 자체 클래스에 속합니다.  \n그렇지 않으면, x의 자릿수를 합산하여 새로운 x를 얻고, 클래스가 결정될 때까지 반복합니다.  \n매개변수:  \n- x (char*): 분류할 정수.\n\n    반환:\n    int: 정수 x가 속하는 클래스.\n\t>>> f_26(24)\n\t6", "ml": "C ഫംഗ്ഷൻ `int f_26(char *x)` എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nഇനിപ്പറയുന്ന രീതിയിൽ പൂർണ്ണസംഖ്യ x-നെ വർഗ്ഗീകരിക്കുക:\nx ഒറ്റ അക്ക സംഖ്യയായാൽ, x തന്റെ സ്വന്തം വർഗ്ഗത്തിൽ പെട്ടതാണ്.\nഅതല്ലെങ്കിൽ, x-ന്റെ അക്കങ്ങൾ കൂട്ടിച്ചേർക്കുക, ഒരു പുതിയ x നേടുക, വർഗ്ഗം നിർണ്ണയിക്കപ്പെടുന്നതുവരെ ആവർത്തിക്കുക.\nപാരാമീറ്ററുകൾ:\n- x (char*): വർഗ്ഗീകരിക്കേണ്ട പൂർണ്ണസംഖ്യ.\n\n    മടക്കുന്നു:\n    int: പൂർണ്ണസംഖ്യ x പെട്ട വർഗ്ഗം.\n\t>>> f_26(24)\n\t6", "fa": "یک تابع C `int f_26(char *x)` بنویسید تا مسئله زیر را حل کند:\nعدد صحیح x را بر اساس روش زیر طبقه‌بندی کنید:\nاگر x یک عدد یک‌رقمی است، x به کلاس خود تعلق دارد.\nدر غیر این صورت، ارقام x را جمع کنید، یک x جدید بگیرید و تکرار کنید تا کلاس تعیین شود.\nپارامترها:\n- x (char*): عدد صحیحی که باید طبقه‌بندی شود.\n\n    بازگشت:\n    int: کلاسی که عدد صحیح x به آن تعلق دارد.\n\t>>> f_26(24)\n\t6"}, "level": "easy", "test": "int main()\n{\n\tassert(f_26(\"24\") == 6);\n\tassert(f_26(\"39\") == 3);\n\tassert(f_26(\"123456789\") == 9);\n\tassert(f_26(\"123456789012345678901234567890\") == 9);\n\tassert(f_26(\"12345\") == 6);\n    assert(f_26(\"999999999\") == 9);\n    return 0;\n}", "entry_point": "f_26", "signature": "int f_26(char *x)", "docstring": {"en": "Classify the integer x based on the following method:\nIf x is a single-digit number, x belongs to its own class.\nOtherwise, sum the digits of x, get a new x, and iterate until the class is determined.\nParameters:\n- x (char*): The integer to be classified.\n\n    Returns:\n    int: The class to which the integer x belongs.\n\t>>> f_26(24)\n\t6\n", "sq": "Klasifikoni numrin e plotë x bazuar në metodën e mëposhtme:\nNëse x është një numër me një shifër, x i përket klasës së vet.\nPërndryshe, mblidhni shifrat e x, merrni një x të ri dhe përsëritni derisa klasa të përcaktohet.\nParametrat:\n- x (char*): Numri i plotë që do të klasifikohet.\n\n    Kthen:\n    int: Klasa së cilës i përket numri i plotë x.\n\t>>> f_26(24)\n\t6", "hy": "Դասակարգեք ամբողջ թիվ x-ը հետևյալ մեթոդով:\nԵթե x-ը միանիշ թիվ է, ապա x-ը պատկանում է իր սեփական դասին:\nՀակառակ դեպքում, գումարեք x-ի թվանշանները, ստացեք նոր x և կրկնեք, մինչև դասը որոշվի:\nՊարամետրեր:\n- x (char*): Դասակարգման ենթակա ամբողջ թիվը:\n\n    Վերադարձնում է:\n    int: Դասը, որին պատկանում է ամբողջ թիվ x-ը:\n\t>>> f_26(24)\n\t6", "bn": "ইন্টিজার x নিম্নলিখিত পদ্ধতির ভিত্তিতে শ্রেণীবদ্ধ করুন:\nযদি x একটি এক অঙ্কের সংখ্যা হয়, তাহলে x তার নিজস্ব শ্রেণীর অন্তর্ভুক্ত।\nঅন্যথায়, x এর অঙ্কগুলোর যোগফল নিন, একটি নতুন x পান এবং শ্রেণী নির্ধারণ না হওয়া পর্যন্ত পুনরাবৃত্তি করুন।\nপ্যারামিটারসমূহ:\n- x (char*): শ্রেণীবদ্ধ করার জন্য ইন্টিজার।\n\n    রিটার্নস:\n    int: যে শ্রেণীর অন্তর্ভুক্ত ইন্টিজার x।\n\t>>> f_26(24)\n\t6", "bg": "Класифицирайте цялото число x въз основа на следния метод:  \nАко x е едноцифрено число, x принадлежи към своя собствен клас.  \nВ противен случай, съберете цифрите на x, получете ново x и итерайте, докато класът бъде определен.  \nПараметри:  \n- x (char*): Цялото число, което трябва да бъде класифицирано.\n\n    Връща:  \n    int: Класът, към който принадлежи цялото число x.  \n\t>>> f_26(24)\n\t6", "zh": "将整数 x 根据以下方法分类：  \n如果 x 是一位数，x 属于它自己的类。  \n否则，将 x 的各位数字相加，得到一个新的 x，并迭代直到确定类。  \n参数：  \n- x (char*): 要分类的整数。\n\n返回：  \nint: 整数 x 所属的类。  \n\t>>> f_26(24)  \n\t6  ", "fr": "Classifiez l'entier x selon la méthode suivante :  \nSi x est un nombre à un chiffre, x appartient à sa propre classe.  \nSinon, additionnez les chiffres de x, obtenez un nouveau x, et itérez jusqu'à ce que la classe soit déterminée.  \nParamètres :  \n- x (char*) : L'entier à classifier.\n\n    Retourne :\n    int : La classe à laquelle appartient l'entier x.\n\t>>> f_26(24)\n\t6", "de": "Klassifizieren Sie die ganze Zahl x anhand der folgenden Methode:\nWenn x eine einstellige Zahl ist, gehört x zu seiner eigenen Klasse.\nAndernfalls summieren Sie die Ziffern von x, erhalten ein neues x und iterieren, bis die Klasse bestimmt ist.\nParameter:\n- x (char*): Die zu klassifizierende ganze Zahl.\n\n    Rückgabewert:\n    int: Die Klasse, zu der die ganze Zahl x gehört.\n\t>>> f_26(24)\n\t6", "ha": "Rarraba lambar x bisa ga hanyar mai zuwa:\nIdan x lamba ce mai ɗaya, x yana cikin ajinsa.\nIn ba haka ba, tara lambobin x, sami sabon x, kuma ci gaba har sai an tantance ajin.\nParameters:\n- x (char*): Lambar da za a tantance.\n\n    Returns:\n    int: Aji wanda lambar x take ciki.\n\t>>> f_26(24)\n\t6", "hi": "पूर्णांक x को निम्नलिखित विधि के आधार पर वर्गीकृत करें:\nयदि x एकल-अंक संख्या है, तो x अपनी स्वयं की श्रेणी में आता है।\nअन्यथा, x के अंकों का योग करें, एक नया x प्राप्त करें, और तब तक दोहराएं जब तक कि श्रेणी निर्धारित न हो जाए।\nपैरामीटर्स:\n- x (char*): वह पूर्णांक जिसे वर्गीकृत किया जाना है।\n\n    रिटर्न्स:\n    int: वह श्रेणी जिसमें पूर्णांक x आता है।\n\t>>> f_26(24)\n\t6", "hu": "Osztályozza az x egész számot a következő módszer alapján:\nHa x egyjegyű szám, akkor x a saját osztályába tartozik.\nEgyébként összeadja x számjegyeit, kap egy új x-et, és iterál, amíg az osztály meg nem határozódik.\nParaméterek:\n- x (char*): Az osztályozandó egész szám.\n\n    Visszatér:\n    int: Az osztály, amelyhez az x egész szám tartozik.\n\t>>> f_26(24)\n\t6", "es": "Clasificar el entero x basado en el siguiente método:\nSi x es un número de un solo dígito, x pertenece a su propia clase.\nDe lo contrario, suma los dígitos de x, obtén un nuevo x, e itera hasta que se determine la clase.\nParámetros:\n- x (char*): El entero a clasificar.\n\n    Devuelve:\n    int: La clase a la que pertenece el entero x.\n\t>>> f_26(24)\n\t6", "arb": "تصنيف العدد الصحيح x بناءً على الطريقة التالية:\nإذا كان x رقمًا مكونًا من رقم واحد، فإن x ينتمي إلى فئته الخاصة.\nخلاف ذلك، اجمع أرقام x، واحصل على x جديد، واستمر في التكرار حتى يتم تحديد الفئة.\n\nالمعلمات:\n- x (char*): العدد الصحيح الذي سيتم تصنيفه.\n\n    يعيد:\n    int: الفئة التي ينتمي إليها العدد الصحيح x.\n\t>>> f_26(24)\n\t6", "sw": "Tambua nambari x kulingana na njia ifuatayo:\nIkiwa x ni nambari ya tarakimu moja, x ni ya darasa lake lenyewe.\nVinginevyo, jumlisha tarakimu za x, pata x mpya, na rudia hadi darasa litakapobainishwa.\nVigezo:\n- x (char*): Nambari ya kuainishwa.\n\n    Inarejesha:\n    int: Darasa ambalo nambari x inahusiana.\n\t>>> f_26(24)\n\t6", "tr": "Tam sayı x'i aşağıdaki yönteme göre sınıflandırın:\nEğer x tek basamaklı bir sayı ise, x kendi sınıfına aittir.\nAksi takdirde, x'in basamaklarını toplayın, yeni bir x elde edin ve sınıf belirlenene kadar yineleyin.\nParametreler:\n- x (char*): Sınıflandırılacak tam sayı.\n\n    Döndürür:\n    int: Tam sayı x'in ait olduğu sınıf.\n\t>>> f_26(24)\n\t6", "vi": "Phân loại số nguyên x dựa trên phương pháp sau:\nNếu x là một số có một chữ số, x thuộc về lớp của chính nó.\nNgược lại, cộng các chữ số của x, lấy một x mới, và lặp lại cho đến khi lớp được xác định.\nTham số:\n- x (char*): Số nguyên cần được phân loại.\n\n    Trả về:\n    int: Lớp mà số nguyên x thuộc về.\n\t>>> f_26(24)\n\t6", "id": "Klasifikasikan bilangan bulat x berdasarkan metode berikut:\nJika x adalah angka satu digit, x termasuk dalam kelasnya sendiri.\nJika tidak, jumlahkan digit-digit dari x, dapatkan x baru, dan ulangi sampai kelas ditentukan.\nParameter:\n- x (char*): Bilangan bulat yang akan diklasifikasikan.\n\n    Mengembalikan:\n    int: Kelas di mana bilangan bulat x termasuk.\n\t>>> f_26(24)\n\t6", "ja": "整数 x を次の方法で分類します:\nx が一桁の数であれば、x はそれ自身のクラスに属します。\nそれ以外の場合、x の桁を合計し、新しい x を取得して、クラスが決定されるまで繰り返します。\nパラメータ:\n- x (char*): 分類される整数。\n\n    戻り値:\n    int: 整数 x が属するクラス。\n\t>>> f_26(24)\n\t6", "ko": "정수 x를 다음 방법에 따라 분류합니다:\nx가 한 자리 숫자이면, x는 자신의 클래스에 속합니다.\n그렇지 않으면, x의 각 자릿수를 더하여 새로운 x를 얻고, 클래스가 결정될 때까지 반복합니다.\n매개변수:\n- x (char*): 분류할 정수입니다.\n\n    반환:\n    int: 정수 x가 속하는 클래스입니다.\n\t>>> f_26(24)\n\t6", "ml": "പിന്തുടരുന്ന രീതിയിൽ പൂർണ്ണസംഖ്യ x ന്റെ വർഗ്ഗീകരണം ചെയ്യുക:\nx ഒരു ഒറ്റ അക്ക സംഖ്യയായാൽ, x സ്വന്തം വർഗ്ഗത്തിൽ പെടുന്നു.\nഅല്ലെങ്കിൽ, x ന്റെ അക്കങ്ങൾ കൂട്ടിച്ചേർക്കുക, ഒരു പുതിയ x നേടുക, വർഗ്ഗം നിർണ്ണയിക്കപ്പെടും വരെ ആവർത്തിക്കുക.\nപാരാമീറ്ററുകൾ:\n- x (char*): വർഗ്ഗീകരിക്കേണ്ട പൂർണ്ണസംഖ്യ.\n\n    മടക്കുന്നു:\n    int: പൂർണ്ണസംഖ്യ x ഏത് വർഗ്ഗത്തിൽ പെടുന്നു.\n\t>>> f_26(24)\n\t6", "fa": "طبقه‌بندی عدد صحیح x بر اساس روش زیر:\nاگر x یک عدد یک‌رقمی باشد، x به کلاس خودش تعلق دارد.\nدر غیر این صورت، ارقام x را جمع کنید، یک x جدید بگیرید و تکرار کنید تا کلاس تعیین شود.\nپارامترها:\n- x (char*): عدد صحیحی که باید طبقه‌بندی شود.\n\n    بازگشت:\n    int: کلاسی که عدد صحیح x به آن تعلق دارد.\n\t>>> f_26(24)\n\t6"}}
{"task_id": "C/27", "prompt": {"en": "#include <assert.h>\n#include <stdio.h>\n/*\nTransforms the case of a given letter.\n    Parameters:\n- letter (char): The input letter to be transformed.\n    Returns:\n- char: The letter with its case reversed. If the input is lowercase, it returns the uppercase version,\nand if the input is uppercase, it returns the lowercase version.\n    >>> f_27('b')\n    'Z'\n*/\nchar f_27(char letter);", "sq": "#include <assert.h>\n#include <stdio.h>\n/*\nTransformon rastin e një shkronje të dhënë.\n    Parametrat:\n- letter (char): Shkronja hyrëse që do të transformohet.\n    Kthen:\n- char: Shkronja me rastin e saj të kthyer. Nëse hyrja është me shkronja të vogla, kthen versionin me shkronja të mëdha,\ndhe nëse hyrja është me shkronja të mëdha, kthen versionin me shkronja të vogla.\n    >>> f_27('b')\n    'Z'\n*/\nchar f_27(char letter);", "hy": "#include <assert.h>\n#include <stdio.h>\n/*\nՓոխակերպում է տրված տառի ռեգիստրը։\n    Պարամետրեր:\n- letter (char): Մուտքային տառը, որը պետք է փոխակերպվի։\n    Վերադարձնում է:\n- char: Տառը՝ իր ռեգիստրը փոխված։ Եթե մուտքը փոքրատառ է, վերադարձնում է մեծատառ տարբերակը,\nիսկ եթե մուտքը մեծատառ է, վերադարձնում է փոքրատառ տարբերակը։\n    >>> f_27('b')\n    'Z'\n*/\nchar f_27(char letter);", "bn": "#include <assert.h>\n#include <stdio.h>\n/*\nএকটি প্রদত্ত অক্ষরের কেস পরিবর্তন করে।\n    প্যারামিটার:\n- letter (char): পরিবর্তন করার জন্য ইনপুট অক্ষর।\n    রিটার্নস:\n- char: অক্ষরটি যার কেস বিপরীত হয়েছে। যদি ইনপুটটি ছোট হাতের হয়, এটি বড় হাতের সংস্করণ রিটার্ন করে,\nএবং যদি ইনপুটটি বড় হাতের হয়, এটি ছোট হাতের সংস্করণ রিটার্ন করে।\n    >>> f_27('b')\n    'Z'\n*/\nchar f_27(char letter);", "bg": "#include <assert.h>\n#include <stdio.h>\n/*\nПреобразува регистъра на дадена буква.\n    Параметри:\n- letter (char): Входната буква, която ще бъде преобразувана.\n    Връща:\n- char: Буквата с обърнат регистър. Ако входът е с малки букви, връща версията с главни букви,\nа ако входът е с главни букви, връща версията с малки букви.\n    >>> f_27('b')\n    'Z'\n*/\nchar f_27(char letter);", "zh": "#include <assert.h>\n#include <stdio.h>\n/*\n转换给定字母的大小写。\n    参数:\n- letter (char): 要转换的输入字母。\n    返回:\n- char: 大小写反转后的字母。如果输入为小写，则返回大写版本，\n如果输入为大写，则返回小写版本。\n    >>> f_27('b')\n    'Z'\n*/\nchar f_27(char letter);", "fr": "#include <assert.h>\n#include <stdio.h>\n/*\nTransforme la casse d'une lettre donnée.\n    Paramètres :\n- letter (char) : La lettre d'entrée à transformer.\n    Renvoie :\n- char : La lettre avec sa casse inversée. Si l'entrée est en minuscule, elle renvoie la version majuscule,\net si l'entrée est en majuscule, elle renvoie la version minuscule.\n    >>> f_27('b')\n    'Z'\n*/\nchar f_27(char letter);", "de": "#include <assert.h>\n#include <stdio.h>\n/*\nVerändert die Groß-/Kleinschreibung eines gegebenen Buchstabens.\n    Parameter:\n- letter (char): Der Eingabebuchstabe, der umgewandelt werden soll.\n    Rückgabe:\n- char: Der Buchstabe mit umgekehrter Groß-/Kleinschreibung. Wenn die Eingabe klein geschrieben ist, wird die Großbuchstabenversion zurückgegeben,\nund wenn die Eingabe groß geschrieben ist, wird die Kleinbuchstabenversion zurückgegeben.\n    >>> f_27('b')\n    'Z'\n*/\nchar f_27(char letter);", "ha": "#include <assert.h>\n#include <stdio.h>\n/*\nCanza yanayin harafin da aka bayar.\n    Sigogi:\n- letter (char): Harafin shigarwa da za a canza.\n    Yana Mayarwa:\n- char: Harafin tare da yanayinsa da aka juyar. Idan shigarwar tana cikin ƙananan baƙaƙe, yana mayar da babba,\nkuma idan shigarwar tana cikin babba, yana mayar da ƙananan baƙaƙe.\n    >>> f_27('b')\n    'Z'\n*/\nchar f_27(char letter);", "hi": "#include <assert.h>\n#include <stdio.h>\n/*\nदिए गए अक्षर का केस बदलता है।\n    पैरामीटर्स:\n- letter (char): इनपुट अक्षर जिसे बदला जाना है।\n    रिटर्न करता है:\n- char: अक्षर जिसका केस उलट दिया गया है। यदि इनपुट लोअरकेस है, तो यह अपरकेस संस्करण लौटाता है,\nऔर यदि इनपुट अपरकेस है, तो यह लोअरकेस संस्करण लौटाता है।\n    >>> f_27('b')\n    'Z'\n*/\nchar f_27(char letter);", "hu": "#include <assert.h>\n#include <stdio.h>\n/*\nÁtalakítja egy adott betű esetét.\n    Paraméterek:\n- letter (char): Az átalakítandó bemeneti betű.\n    Visszatér:\n- char: A betű az esetének megfordításával. Ha a bemenet kisbetűs, akkor a nagybetűs változatot adja vissza,\nés ha a bemenet nagybetűs, akkor a kisbetűs változatot adja vissza.\n    >>> f_27('b')\n    'Z'\n*/\nchar f_27(char letter);", "es": "#include <assert.h>\n#include <stdio.h>\n/*\nTransforma el caso de una letra dada.\n    Parámetros:\n- letter (char): La letra de entrada que se va a transformar.\n    Devuelve:\n- char: La letra con su caso invertido. Si la entrada es minúscula, devuelve la versión en mayúscula,\ny si la entrada es mayúscula, devuelve la versión en minúscula.\n    >>> f_27('b')\n    'Z'\n*/\nchar f_27(char letter);", "arb": "#include <assert.h>\n#include <stdio.h>\n/*\nيحول حالة حرف معين.\n    المعاملات:\n- letter (char): الحرف المدخل الذي سيتم تحويله.\n    يعيد:\n- char: الحرف مع عكس حالته. إذا كان المدخل بحروف صغيرة، فإنه يعيد النسخة الكبيرة،\nوإذا كان المدخل بحروف كبيرة، فإنه يعيد النسخة الصغيرة.\n    >>> f_27('b')\n    'Z'\n*/\nchar f_27(char letter);", "sw": "#include <assert.h>\n#include <stdio.h>\n/*\nHubadilisha herufi kubwa na ndogo ya herufi iliyotolewa.\n    Vigezo:\n- letter (char): Herufi ya kuingiza inayopaswa kubadilishwa.\n    Inarudisha:\n- char: Herufi ikiwa na herufi kubwa na ndogo zimebadilishwa. Ikiwa ingizo ni herufi ndogo, inarudisha toleo la herufi kubwa,\nna ikiwa ingizo ni herufi kubwa, inarudisha toleo la herufi ndogo.\n    >>> f_27('b')\n    'Z'\n*/\nchar f_27(char letter);", "tr": "#include <assert.h>\n#include <stdio.h>\n/*\nVerilen bir harfin durumunu dönüştürür.\n    Parametreler:\n- letter (char): Dönüştürülecek giriş harfi.\n    Döndürür:\n- char: Harfin durumu ters çevrilmiş hali. Eğer giriş küçük harfse, büyük harf versiyonunu döndürür,\nve eğer giriş büyük harfse, küçük harf versiyonunu döndürür.\n    >>> f_27('b')\n    'Z'\n*/\nchar f_27(char letter);", "vi": "#include <assert.h>\n#include <stdio.h>\n/*\nChuyển đổi chữ hoa/thường của một chữ cái cho trước.\n    Tham số:\n- letter (char): Chữ cái đầu vào cần được chuyển đổi.\n    Trả về:\n- char: Chữ cái với chữ hoa/thường đã được đảo ngược. Nếu đầu vào là chữ thường, nó trả về phiên bản chữ hoa,\nvà nếu đầu vào là chữ hoa, nó trả về phiên bản chữ thường.\n    >>> f_27('b')\n    'Z'\n*/\nchar f_27(char letter);", "id": "#include <assert.h>\n#include <stdio.h>\n/*\nMengubah huruf menjadi huruf dengan kasus yang berbeda.\n    Parameter:\n- letter (char): Huruf masukan yang akan diubah.\n    Mengembalikan:\n- char: Huruf dengan kasus yang dibalik. Jika masukan adalah huruf kecil, akan mengembalikan versi huruf besar,\ndan jika masukan adalah huruf besar, akan mengembalikan versi huruf kecil.\n    >>> f_27('b')\n    'Z'\n*/\nchar f_27(char letter);", "ja": "#include <assert.h>\n#include <stdio.h>\n/*\n指定された文字の大文字小文字を変換します。\n    パラメータ:\n- letter (char): 変換する入力文字。\n    戻り値:\n- char: 大文字小文字が反転された文字。入力が小文字の場合は大文字に変換され、\n入力が大文字の場合は小文字に変換されます。\n    >>> f_27('b')\n    'Z'\n*/\nchar f_27(char letter);", "ko": "#include <assert.h>\n#include <stdio.h>\n/*\n주어진 문자의 대소문자를 변환합니다.\n    매개변수:\n- letter (char): 변환할 입력 문자.\n    반환값:\n- char: 대소문자가 반전된 문자. 입력이 소문자이면 대문자 버전을 반환하고,\n입력이 대문자이면 소문자 버전을 반환합니다.\n    >>> f_27('b')\n    'Z'\n*/\nchar f_27(char letter);", "ml": "#include <assert.h>\n#include <stdio.h>\n/*\nഒരു നൽകിയ അക്ഷരത്തിന്റെ കേസിനെ മാറ്റുന്നു.\n    പാരാമീറ്ററുകൾ:\n- letter (char): മാറ്റാൻ ഉദ്ദേശിക്കുന്ന ഇൻപുട്ട് അക്ഷരം.\n    തിരികെ നൽകുന്നു:\n- char: അക്ഷരത്തിന്റെ കേസ് മറിച്ചിരിക്കുന്നു. ഇൻപുട്ട് ചെറിയ അക്ഷരമെങ്കിൽ, അത് വലിയ അക്ഷരമാക്കിയാണ് തിരികെ നൽകുന്നത്,\nമറ്റുപക്ഷം ഇൻപുട്ട് വലിയ അക്ഷരമെങ്കിൽ, അത് ചെറിയ അക്ഷരമാക്കിയാണ് തിരികെ നൽകുന്നത്.\n    >>> f_27('b')\n    'Z'\n*/\nchar f_27(char letter);", "fa": "#include <assert.h>\n#include <stdio.h>\n/*\nتبدیل حالت یک حرف داده شده.\n    پارامترها:\n- letter (char): حرف ورودی که باید تبدیل شود.\n    بازگشت:\n- char: حرف با حالت معکوس شده. اگر ورودی با حروف کوچک باشد، نسخه بزرگ آن را برمی‌گرداند،\nو اگر ورودی با حروف بزرگ باشد، نسخه کوچک آن را برمی‌گرداند.\n    >>> f_27('b')\n    'Z'\n*/\nchar f_27(char letter);"}, "canonical_solution": "char f_27(char letter) {\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    } else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}", "instruction": {"en": "Write a C function `char f_27(char letter)` to solve the following problem:\nTransforms the case of a given letter.\n    Parameters:\n- letter (char): The input letter to be transformed.\n    Returns:\n- char: The letter with its case reversed. If the input is lowercase, it returns the uppercase version,\nand if the input is uppercase, it returns the lowercase version.\n    >>> f_27('b')\n    'Z'\n", "sq": "Shkruani një funksion në C `char f_27(char letter)` për të zgjidhur problemin në vijim:\nTransformon rastin e një shkronje të dhënë.  \n    Parametrat:  \n- letter (char): Shkronja hyrëse që do të transformohet.  \n    Kthen:  \n- char: Shkronja me rastin e saj të kthyer. Nëse hyrja është me shkronja të vogla, ajo kthen versionin me shkronja të mëdha,  \ndhe nëse hyrja është me shkronja të mëdha, ajo kthen versionin me shkronja të vogla.  \n    >>> f_27('b')  \n    'Z'  ", "hy": "Գրեք C ֆունկցիա `char f_27(char letter)`՝ հետևյալ խնդիրը լուծելու համար:\nՓոխակերպում է տրված տառի ռեգիստրը:\n    Պարամետրեր:\n- letter (char): Մուտքային տառը, որը պետք է փոխակերպվի:\n    Վերադարձնում է:\n- char: Տառը՝ իր ռեգիստրը փոխված: Եթե մուտքը փոքրատառ է, վերադարձնում է մեծատառ տարբերակը,\nիսկ եթե մուտքը մեծատառ է, վերադարձնում է փոքրատառ տարբերակը:\n    >>> f_27('b')\n    'Z'", "bn": "একটি C ফাংশন `char f_27(char letter)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি প্রদত্ত অক্ষরের কেস পরিবর্তন করে।\n    প্যারামিটারসমূহ:\n- letter (char): পরিবর্তন করার জন্য ইনপুট অক্ষর।\n    রিটার্ন করে:\n- char: অক্ষরটি যার কেস বিপরীত করা হয়েছে। যদি ইনপুট ছোট হাতের হয়, এটি বড় হাতের সংস্করণ রিটার্ন করে,\nএবং যদি ইনপুট বড় হাতের হয়, এটি ছোট হাতের সংস্করণ রিটার্ন করে।\n    >>> f_27('b')\n    'Z'", "bg": "Напишете C функция `char f_27(char letter)`, за да решите следния проблем:\nПреобразува регистъра на дадена буква.\n    Параметри:\n- letter (char): Входната буква, която ще бъде преобразувана.\n    Връща:\n- char: Буквата с обърнат регистър. Ако входът е с малки букви, връща версията с главни букви,\nи ако входът е с главни букви, връща версията с малки букви.\n    >>> f_27('b')\n    'Z'", "zh": "编写一个C函数 `char f_27(char letter)` 来解决以下问题：\n将给定字母的大小写转换。\n    参数：\n- letter (char): 要转换的输入字母。\n    返回：\n- char: 大小写已反转的字母。如果输入是小写字母，则返回大写版本；如果输入是大写字母，则返回小写版本。\n    >>> f_27('b')\n    'Z'", "fr": "Écrire une fonction C `char f_27(char letter)` pour résoudre le problème suivant:\nTransforme la casse d'une lettre donnée.\n    Paramètres :\n- letter (char) : La lettre d'entrée à transformer.\n    Renvoie :\n- char : La lettre avec sa casse inversée. Si l'entrée est en minuscule, elle renvoie la version majuscule,\net si l'entrée est en majuscule, elle renvoie la version minuscule.\n    >>> f_27('b')\n    'Z'", "de": "Schreiben Sie eine C-Funktion `char f_27(char letter)`, um das folgende Problem zu lösen:\nTransformiert die Groß-/Kleinschreibung eines gegebenen Buchstabens.\n    Parameter:\n- letter (char): Der Eingabebuchstabe, der transformiert werden soll.\n    Rückgabewert:\n- char: Der Buchstabe mit umgekehrter Groß-/Kleinschreibung. Wenn die Eingabe klein geschrieben ist, wird die Großbuchstabenversion zurückgegeben, und wenn die Eingabe groß geschrieben ist, wird die Kleinbuchstabenversion zurückgegeben.\n    >>> f_27('b')\n    'Z'", "ha": "Rubuta aikin C `char f_27(char letter)` don warware matsalar mai zuwa:\nCanza yanayin harafin da aka bayar.\n    Sigogi:\n- letter (char): Harafin shigarwa da za a canza.\n    Mayarwa:\n- char: Harafin tare da yanayin sa da aka juya. Idan shigarwar tana cikin ƙananan haruffa, yana mayar da sigar manyan haruffa,\nkuma idan shigarwar tana cikin manyan haruffa, yana mayar da sigar ƙananan haruffa.\n    >>> f_27('b')\n    'Z'", "hi": "C फ़ंक्शन `char f_27(char letter)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए अक्षर का केस बदलता है।\n    पैरामीटर्स:\n- letter (char): परिवर्तित किया जाने वाला इनपुट अक्षर।\n    रिटर्न्स:\n- char: अक्षर जिसका केस उलट दिया गया है। यदि इनपुट लोअरकेस है, तो यह अपरकेस संस्करण लौटाता है,\nऔर यदि इनपुट अपरकेस है, तो यह लोअरकेस संस्करण लौटाता है।\n    >>> f_27('b')\n    'Z'", "hu": "Írj egy C függvényt `char f_27(char letter)` a következő probléma megoldására:\nÁtalakítja egy adott betű kis- és nagybetűs formáját.  \nParaméterek:  \n- letter (char): Az átalakítandó bemeneti betű.  \nVisszatérési érték:  \n- char: A betű, amelynek kis- és nagybetűs formája meg van fordítva. Ha a bemenet kisbetűs, akkor a nagybetűs verziót adja vissza, és ha a bemenet nagybetűs, akkor a kisbetűs verziót adja vissza.  \n    >>> f_27('b')  \n    'Z'  ", "es": "Escribe una función en C `char f_27(char letter)` para resolver el siguiente problema:\nTransforma el caso de una letra dada.\n    Parámetros:\n- letter (char): La letra de entrada a ser transformada.\n    Devuelve:\n- char: La letra con su caso invertido. Si la entrada es minúscula, devuelve la versión en mayúscula,\ny si la entrada es mayúscula, devuelve la versión en minúscula.\n    >>> f_27('b')\n    'Z'", "arb": "اكتب دالة C `char f_27(char letter)` لحل المشكلة التالية:\nتحول حالة الحرف المعطى.\n    المعاملات:\n- letter (char): الحرف المدخل الذي سيتم تحويله.\n    يعيد:\n- char: الحرف مع عكس حالته. إذا كان المدخل بحروف صغيرة، فإنه يعيد النسخة الكبيرة،\nوإذا كان المدخل بحروف كبيرة، فإنه يعيد النسخة الصغيرة.\n    >>> f_27('b')\n    'Z'", "sw": "Andika kazi ya C `char f_27(char letter)` kutatua tatizo lifuatalo:\nHubadilisha herufi kubwa au ndogo ya herufi iliyotolewa.  \n    Vigezo:  \n- letter (char): Herufi ya kuingiza inayopaswa kubadilishwa.  \n    Inarejesha:  \n- char: Herufi ikiwa na herufi kubwa au ndogo imebadilishwa. Ikiwa ingizo ni herufi ndogo, inarejesha toleo la herufi kubwa,  \nna ikiwa ingizo ni herufi kubwa, inarejesha toleo la herufi ndogo.  \n    >>> f_27('b')  \n    'Z'  ", "tr": "Bir C fonksiyonu `char f_27(char letter)` yazın:\nVerilen bir harfin büyük/küçük harf durumunu dönüştürür.\n    Parametreler:\n- letter (char): Dönüştürülecek giriş harfi.\n    Döndürür:\n- char: Harfin büyük/küçük harf durumu ters çevrilmiş hali. Eğer giriş küçük harf ise, büyük harf versiyonunu döndürür,\nve eğer giriş büyük harf ise, küçük harf versiyonunu döndürür.\n    >>> f_27('b')\n    'Z'", "vi": "Viết một hàm C `char f_27(char letter)` để giải quyết vấn đề sau:\nChuyển đổi chữ hoa thành chữ thường hoặc ngược lại của một chữ cái đã cho.\n    Tham số:\n- letter (char): Chữ cái đầu vào cần được chuyển đổi.\n    Trả về:\n- char: Chữ cái với dạng chữ hoa hoặc chữ thường được đảo ngược. Nếu đầu vào là chữ thường, nó trả về phiên bản chữ hoa,\nvà nếu đầu vào là chữ hoa, nó trả về phiên bản chữ thường.\n    >>> f_27('b')\n    'Z'", "id": "Tulis fungsi C `char f_27(char letter)` untuk menyelesaikan masalah berikut:\nMengubah huruf besar/kecil dari huruf yang diberikan.  \n   Parameter:  \n- letter (char): Huruf masukan yang akan diubah.  \n   Mengembalikan:  \n- char: Huruf dengan huruf besar/kecil dibalik. Jika masukan adalah huruf kecil, ia mengembalikan versi huruf besar, dan jika masukan adalah huruf besar, ia mengembalikan versi huruf kecil.  \n    >>> f_27('b')  \n    'Z'  ", "ja": "Cの関数を書け `char f_27(char letter)` を作成して、次の問題を解決してください:\n与えられた文字の大文字小文字を変換します。\n    パラメータ:\n- letter (char): 変換する入力文字。\n    戻り値:\n- char: 大文字小文字が反転された文字。入力が小文字の場合は大文字版を返し、入力が大文字の場合は小文字版を返します。\n    >>> f_27('b')\n    'Z'", "ko": "C 함수 `char f_27(char letter)`를 작성하여 다음 문제를 해결하십시오:\n주어진 문자의 대소문자를 변환합니다.\n    매개변수:\n- letter (char): 변환할 입력 문자입니다.\n    반환값:\n- char: 대소문자가 반전된 문자입니다. 입력이 소문자이면 대문자 버전을 반환하고,\n입력이 대문자이면 소문자 버전을 반환합니다.\n    >>> f_27('b')\n    'Z'", "ml": "C ഭാഷയിൽ ഒരു ഫംഗ്ഷൻ `char f_27(char letter)` എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nഒരു നൽകിയ അക്ഷരത്തിന്റെ കേസ് മാറ്റുന്നു.\n    പാരാമീറ്ററുകൾ:\n- letter (char): മാറ്റേണ്ട ഇൻപുട്ട് അക്ഷരം.\n    തിരികെ നൽകുന്നു:\n- char: അക്ഷരം അതിന്റെ കേസ് മറിച്ചാണ് തിരികെ നൽകുന്നത്. ഇൻപുട്ട് ചെറിയക്ഷരമാണെങ്കിൽ, അത് വലിയക്ഷര രൂപം തിരികെ നൽകുന്നു, കൂടാതെ ഇൻപുട്ട് വലിയക്ഷരമാണെങ്കിൽ, അത് ചെറിയക്ഷര രൂപം തിരികെ നൽകുന്നു.\n    >>> f_27('b')\n    'Z'", "fa": "یک تابع C به نام `char f_27(char letter)` بنویسید تا مسئله زیر را حل کند:\nتبدیل حالت حروف داده شده.\n    پارامترها:\n- letter (char): حرف ورودی که باید تبدیل شود.\n    بازگشتی:\n- char: حرف با حالت معکوس شده. اگر ورودی حروف کوچک باشد، نسخه بزرگ آن را برمی‌گرداند،\nو اگر ورودی حروف بزرگ باشد، نسخه کوچک آن را برمی‌گرداند.\n    >>> f_27('b')\n    'Z'"}, "level": "easy", "test": "int main() {\n    assert(f_27('b') == 'B');\n    assert(f_27('B') == 'b');\n\n    // Additional test cases\n    assert(f_27('z') == 'Z');\n    assert(f_27('Z') == 'z');\n    assert(f_27('m') == 'M');\n    assert(f_27('M') == 'm');\n    assert(f_27('1') == '1'); // Non-alphabetic, should be unchanged\n    assert(f_27('!') == '!'); // Non-alphabetic, should be unchanged\n    return 0;\n}", "entry_point": "f_27", "signature": "char f_27(char letter)", "docstring": {"en": "Transforms the case of a given letter.\n    Parameters:\n- letter (char): The input letter to be transformed.\n    Returns:\n- char: The letter with its case reversed. If the input is lowercase, it returns the uppercase version,\nand if the input is uppercase, it returns the lowercase version.\n    >>> f_27('b')\n    'Z'\n", "sq": "Transformon rastin e një shkronje të dhënë.\n    Parametrat:\n- letter (char): Shkronja hyrëse që do të transformohet.\n    Kthen:\n- char: Shkronja me rastin e saj të kthyer. Nëse hyrja është me shkronja të vogla, kthen versionin me shkronja të mëdha,\ndhe nëse hyrja është me shkronja të mëdha, kthen versionin me shkronja të vogla.\n    >>> f_27('b')\n    'Z'", "hy": "Փոխակերպում է տրված տառի ռեգիստրը։\n    Պարամետրեր:\n- letter (char): Մուտքային տառը, որը պետք է փոխակերպվի։\n    Վերադարձնում է:\n- char: Տառը՝ իր ռեգիստրը փոխված։ Եթե մուտքը փոքրատառ է, վերադարձնում է մեծատառ տարբերակը,\nիսկ եթե մուտքը մեծատառ է, վերադարձնում է փոքրատառ տարբերակը։\n    >>> f_27('b')\n    'Z'", "bn": "একটি প্রদত্ত অক্ষরের কেস পরিবর্তন করে।\n    প্যারামিটার:\n- letter (char): পরিবর্তিত হওয়ার জন্য ইনপুট অক্ষর।\n    Returns:\n- char: অক্ষরটি যার কেস বিপরীত হয়েছে। যদি ইনপুট ছোট হাতের হয়, এটি বড় হাতের সংস্করণ ফেরত দেয়,\nএবং যদি ইনপুট বড় হাতের হয়, এটি ছোট হাতের সংস্করণ ফেরত দেয়।\n    >>> f_27('b')\n    'Z'", "bg": "Преобразува регистъра на дадена буква.\n    Параметри:\n- letter (char): Входната буква, която ще бъде преобразувана.\n    Връща:\n- char: Буквата с обърнат регистър. Ако входът е с малки букви, връща версията с главни букви,\nи ако входът е с главни букви, връща версията с малки букви.\n    >>> f_27('b')\n    'Z'", "zh": "将给定字母的大小写转换。\n    参数:\n- letter (char): 要转换的输入字母。\n    返回:\n- char: 大小写反转后的字母。如果输入是小写字母，则返回大写版本；如果输入是大写字母，则返回小写版本。\n    >>> f_27('b')\n    'Z'", "fr": "Transforme la casse d'une lettre donnée.\n    Paramètres :\n- letter (char) : La lettre d'entrée à transformer.\n    Renvoie :\n- char : La lettre avec sa casse inversée. Si l'entrée est en minuscule, elle renvoie la version majuscule,\net si l'entrée est en majuscule, elle renvoie la version minuscule.\n    >>> f_27('b')\n    'Z'", "de": "Verändert die Groß-/Kleinschreibung eines gegebenen Buchstabens.\n    Parameter:\n- letter (char): Der Eingabebuchstabe, der umgewandelt werden soll.\n    Rückgabe:\n- char: Der Buchstabe mit umgekehrter Groß-/Kleinschreibung. Wenn die Eingabe klein geschrieben ist, wird die Großbuchstabenversion zurückgegeben, und wenn die Eingabe groß geschrieben ist, wird die Kleinbuchstabenversion zurückgegeben.\n    >>> f_27('b')\n    'Z'", "ha": "Canza yanayin harafin da aka bayar.\n    Sigogi:\n- letter (char): Harafin shigar da za a canza.\n    Returns:\n- char: Harafin tare da canza yanayin rubutu. Idan shigar harafi ne a ƙananan rubutu, zai dawo da babba,\nkuma idan shigar harafi ne a babba, zai dawo da ƙananan rubutu.\n    >>> f_27('b')\n    'Z'", "hi": "दिए गए अक्षर का केस बदलता है।\n    पैरामीटर्स:\n- letter (char): परिवर्तित होने वाला इनपुट अक्षर।\n    रिटर्न्स:\n- char: अक्षर जिसका केस उलट दिया गया है। यदि इनपुट लोअरकेस है, तो यह अपरकेस संस्करण लौटाता है,\nऔर यदि इनपुट अपरकेस है, तो यह लोअरकेस संस्करण लौटाता है।\n    >>> f_27('b')\n    'Z'", "hu": "Átalakítja egy adott betű esetét.\n    Paraméterek:\n- letter (char): Az átalakítandó bemeneti betű.\n    Visszatér:\n- char: A betű az ellentétes esettel. Ha a bemenet kisbetűs, akkor a nagybetűs változatot adja vissza,\nés ha a bemenet nagybetűs, akkor a kisbetűs változatot adja vissza.\n    >>> f_27('b')\n    'Z'", "es": "Transforma el caso de una letra dada.\n    Parámetros:\n- letter (char): La letra de entrada a ser transformada.\n    Retorna:\n- char: La letra con su caso invertido. Si la entrada es minúscula, devuelve la versión en mayúscula,\ny si la entrada es mayúscula, devuelve la versión en minúscula.\n    >>> f_27('b')\n    'Z'", "arb": "يحول حالة الحرف المعطى.\n    Args:\n- letter (char): الحرف المدخل الذي سيتم تحويله.\n    Returns:\n- char: الحرف مع عكس حالته. إذا كان المدخل بحروف صغيرة، فإنه يعيد النسخة الكبيرة،\nوإذا كان المدخل بحروف كبيرة، فإنه يعيد النسخة الصغيرة.\n    >>> f_27('b')\n    'Z'", "sw": "Hubadilisha herufi ya herufi iliyotolewa.\n    Vigezo:\n- letter (char): Herufi ya kuingiza inayopaswa kubadilishwa.\n    Inarejesha:\n- char: Herufi ikiwa na herufi zake zimebadilishwa. Ikiwa ingizo ni herufi ndogo, inarejesha toleo la herufi kubwa,\nna ikiwa ingizo ni herufi kubwa, inarejesha toleo la herufi ndogo.\n    >>> f_27('b')\n    'Z'", "tr": "Verilen bir harfin büyük/küçük harf durumunu değiştirir.\n    Parametreler:\n- letter (char): Dönüştürülecek giriş harfi.\n    Döndürür:\n- char: Harfin büyük/küçük harf durumu ters çevrilmiş hali. Eğer giriş küçük harfse, büyük harf versiyonunu döndürür,\nve eğer giriş büyük harfse, küçük harf versiyonunu döndürür.\n    >>> f_27('b')\n    'Z'", "vi": "Chuyển đổi chữ hoa/thường của một chữ cái đã cho.\n    Tham số:\n- letter (char): Chữ cái đầu vào cần được chuyển đổi.\n    Trả về:\n- char: Chữ cái với chữ hoa/thường được đảo ngược. Nếu đầu vào là chữ thường, nó trả về phiên bản chữ hoa,\nvà nếu đầu vào là chữ hoa, nó trả về phiên bản chữ thường.\n    >>> f_27('b')\n    'Z'", "id": "Mengubah huruf dari sebuah huruf yang diberikan.\n    Parameter:\n- letter (char): Huruf input yang akan diubah.\n    Mengembalikan:\n- char: Huruf dengan huruf besar-kecil yang dibalik. Jika input adalah huruf kecil, maka akan mengembalikan versi huruf besar, dan jika input adalah huruf besar, maka akan mengembalikan versi huruf kecil.\n    >>> f_27('b')\n    'Z'", "ja": "与えられた文字の大文字小文字を変換します。\n    引数:\n- letter (char): 変換される入力文字。\n    戻り値:\n- char: 大文字小文字が反転された文字。入力が小文字の場合、大文字バージョンを返し、入力が大文字の場合、小文字バージョンを返します。\n    >>> f_27('b')\n    'Z'", "ko": "주어진 문자의 대소문자를 변환합니다.\n    매개변수:\n- letter (char): 변환할 입력 문자입니다.\n    반환값:\n- char: 대소문자가 반전된 문자입니다. 입력이 소문자일 경우 대문자로 변환하여 반환하고, 입력이 대문자일 경우 소문자로 변환하여 반환합니다.\n    >>> f_27('b')\n    'Z'", "ml": "ഒരു നൽകിയ അക്ഷരത്തിന്റെ കേസിനെ മാറ്റുന്നു.\n    Parameters:\n- letter (char): മാറ്റേണ്ട ഇൻപുട്ട് അക്ഷരം.\n    Returns:\n- char: അക്ഷരത്തിന്റെ കേസ് മറിച്ചിരിക്കുന്നു. ഇൻപുട്ട് ലൊവർകേസ് ആണെങ്കിൽ, അത് അപ്പർകേസ് പതിപ്പ് തിരികെ നൽകുന്നു, \nമറ്റുവശത്ത് ഇൻപുട്ട് അപ്പർകേസ് ആണെങ്കിൽ, അത് ലൊവർകേസ് പതിപ്പ് തിരികെ നൽകുന്നു.\n    >>> f_27('b')\n    'Z'", "fa": "تبدیل حالت یک حرف داده شده.\n    پارامترها:\n- letter (char): حرف ورودی که باید تبدیل شود.\n    بازگشت:\n- char: حرف با حالت برعکس شده. اگر ورودی با حروف کوچک باشد، نسخه بزرگ آن را برمی‌گرداند،\nو اگر ورودی با حروف بزرگ باشد، نسخه کوچک آن را برمی‌گرداند.\n    >>> f_27('b')\n    'Z'"}}
{"task_id": "C/28", "prompt": {"en": "#include <stdio.h>\n#include <assert.h>\n/*\nDisplay the ASCII information for a given character.\n​    Parameters:\n- character (char): The input character for which ASCII information is to be displayed.\n​    Returns:\n- int: corresponding ASCII code\n    >>> f_28('A')\n    65\n*/\nint f_28(char character)\n{", "sq": "#include <stdio.h>\n#include <assert.h>\n/*\nShfaq informacionin ASCII për një karakter të dhënë.\n​    Parametrat:\n- character (char): Karakteri i dhënë për të cilin do të shfaqet informacioni ASCII.\n​    Kthen:\n- int: kodi përkatës ASCII\n    >>> f_28('A')\n    65\n*/\nint f_28(char character)\n{", "hy": "#include <stdio.h>\n#include <assert.h>\n/*\nՑուցադրել ASCII տեղեկատվությունը տրված սիմվոլի համար։\n​    Պարամետրեր:\n- character (char): Մուտքային սիմվոլը, որի համար պետք է ցուցադրվի ASCII տեղեկատվությունը։\n​    Վերադարձնում է:\n- int: համապատասխան ASCII կոդը\n    >>> f_28('A')\n    65\n*/\nint f_28(char character)\n{", "bn": "#include <stdio.h>\n#include <assert.h>\n/*\nএকটি প্রদত্ত চরিত্রের জন্য ASCII তথ্য প্রদর্শন করুন।\n​    প্যারামিটার:\n- character (char): ইনপুট চরিত্র যার জন্য ASCII তথ্য প্রদর্শন করা হবে।\n​    রিটার্নস:\n- int: সংশ্লিষ্ট ASCII কোড\n    >>> f_28('A')\n    65\n*/\nint f_28(char character)\n{", "bg": "#include <stdio.h>\n#include <assert.h>\n/*\nПоказва ASCII информацията за даден символ.\n​    Параметри:\n- character (char): Входният символ, за който ще се покаже ASCII информацията.\n​    Връща:\n- int: съответстващ ASCII код\n    >>> f_28('A')\n    65\n*/\nint f_28(char character)\n{", "zh": "#include <stdio.h>\n#include <assert.h>\n/*\n显示给定字符的ASCII信息。\n    参数:\n- character (char): 要显示ASCII信息的输入字符。\n    返回:\n- int: 对应的ASCII代码\n    >>> f_28('A')\n    65\n*/\nint f_28(char character)\n{", "fr": "#include <stdio.h>\n#include <assert.h>\n/*\nAfficher les informations ASCII pour un caractère donné.\n​    Paramètres :\n- character (char) : Le caractère d'entrée pour lequel les informations ASCII doivent être affichées.\n​    Renvoie :\n- int : code ASCII correspondant\n    >>> f_28('A')\n    65\n*/\nint f_28(char character)\n{", "de": "#include <stdio.h>\n#include <assert.h>\n/*\nZeigt die ASCII-Informationen für ein gegebenes Zeichen an.\n​    Parameter:\n- character (char): Das Eingabezeichen, für das die ASCII-Informationen angezeigt werden sollen.\n​    Rückgabe:\n- int: entsprechender ASCII-Code\n    >>> f_28('A')\n    65\n*/\nint f_28(char character)\n{", "ha": "#include <stdio.h>\n#include <assert.h>\n/*\nNuna bayanin ASCII don wata alama da aka bayar.\n​    Sigogi:\n- character (char): Alamar shigarwa wanda za a nuna bayanin ASCII.\n​    Komawa:\n- int: lambar ASCII mai dacewa\n    >>> f_28('A')\n    65\n*/\nint f_28(char character)\n{", "hi": "#include <stdio.h>\n#include <assert.h>\n/*\nदिए गए वर्ण के लिए ASCII जानकारी प्रदर्शित करें।\n    पैरामीटर्स:\n- character (char): इनपुट वर्ण जिसके लिए ASCII जानकारी प्रदर्शित की जानी है।\n    रिटर्न्स:\n- int: संबंधित ASCII कोड\n    >>> f_28('A')\n    65\n*/\nint f_28(char character)\n{", "hu": "#include <stdio.h>\n#include <assert.h>\n/*\nMegjeleníti a megadott karakter ASCII információit.\n​    Paraméterek:\n- character (char): Az a bemeneti karakter, amelynek az ASCII információit meg kell jeleníteni.\n​    Visszatér:\n- int: a megfelelő ASCII kód\n    >>> f_28('A')\n    65\n*/\nint f_28(char character)\n{", "es": "#include <stdio.h>\n#include <assert.h>\n/*\nMostrar la información ASCII para un carácter dado.\n    Parámetros:\n- character (char): El carácter de entrada para el cual se mostrará la información ASCII.\n    Retorna:\n- int: código ASCII correspondiente\n    >>> f_28('A')\n    65\n*/\nint f_28(char character)\n{", "arb": "#include <stdio.h>\n#include <assert.h>\n/*\nعرض معلومات ASCII لحرف معين.\n​    المعلمات:\n- character (char): الحرف المدخل الذي سيتم عرض معلومات ASCII له.\n​    يعيد:\n- int: كود ASCII المقابل\n    >>> f_28('A')\n    65\n*/\nint f_28(char character)\n{", "sw": "#include <stdio.h>\n#include <assert.h>\n/*\nOnyesha taarifa za ASCII kwa herufi iliyotolewa.\n​    Vigezo:\n- character (char): Herufi ya kuingiza ambayo taarifa za ASCII zinapaswa kuonyeshwa.\n​    Inarejesha:\n- int: msimbo wa ASCII unaolingana\n    >>> f_28('A')\n    65\n*/\nint f_28(char character)\n{", "tr": "#include <stdio.h>\n#include <assert.h>\n/*\nBelirtilen bir karakter için ASCII bilgisini görüntüle.\n​    Parametreler:\n- character (char): ASCII bilgisinin görüntüleneceği giriş karakteri.\n​    Döndürür:\n- int: Karşılık gelen ASCII kodu\n    >>> f_28('A')\n    65\n*/\nint f_28(char character)\n{", "vi": "#include <stdio.h>\n#include <assert.h>\n/*\nHiển thị thông tin ASCII cho một ký tự cho trước.\n    Tham số:\n- character (char): Ký tự đầu vào mà thông tin ASCII cần được hiển thị.\n    Trả về:\n- int: mã ASCII tương ứng\n    >>> f_28('A')\n    65\n*/\nint f_28(char character)\n{", "id": "#include <stdio.h>\n#include <assert.h>\n/*\nMenampilkan informasi ASCII untuk karakter yang diberikan.\n    Parameter:\n- character (char): Karakter input yang informasi ASCII-nya akan ditampilkan.\n    Mengembalikan:\n- int: kode ASCII yang sesuai\n    >>> f_28('A')\n    65\n*/\nint f_28(char character)\n{", "ja": "#include <stdio.h>\n#include <assert.h>\n/*\n指定された文字のASCII情報を表示します。\n​    パラメータ:\n- character (char): ASCII情報を表示するための入力文字。\n​    戻り値:\n- int: 対応するASCIIコード\n    >>> f_28('A')\n    65\n*/\nint f_28(char character)\n{\n", "ko": "#include <stdio.h>\n#include <assert.h>\n/*\n주어진 문자에 대한 ASCII 정보를 표시합니다.\n​    매개변수:\n- character (char): ASCII 정보를 표시할 입력 문자.\n​    반환:\n- int: 해당 ASCII 코드\n    >>> f_28('A')\n    65\n*/\nint f_28(char character)\n{", "ml": "#include <stdio.h>\n#include <assert.h>\n/*\nഒരു നൽകിയ അക്ഷരത്തിന് ASCII വിവരങ്ങൾ പ്രദർശിപ്പിക്കുക.\n​    പാരാമീറ്ററുകൾ:\n- character (char): ASCII വിവരങ്ങൾ പ്രദർശിപ്പിക്കേണ്ട ഇൻപുട്ട് അക്ഷരം.\n​    മടക്കുന്നു:\n- int: അനുബന്ധ ASCII കോഡ്\n    >>> f_28('A')\n    65\n*/\nint f_28(char character)\n{", "fa": "#include <stdio.h>\n#include <assert.h>\n/*\nنمایش اطلاعات ASCII برای یک کاراکتر داده شده.\n​    پارامترها:\n- character (char): کاراکتر ورودی که اطلاعات ASCII برای آن نمایش داده می‌شود.\n​    بازگشت:\n- int: کد ASCII متناظر\n    >>> f_28('A')\n    65\n*/\nint f_28(char character)\n{"}, "canonical_solution": "return character;\n}", "instruction": {"en": "Write a C function `int f_28(char character)` to solve the following problem:\nDisplay the ASCII information for a given character.\n\n    Parameters:\n- character (char): The input character for which ASCII information is to be displayed.\n\n    Returns:\n- int: corresponding ASCII code\n    >>> f_28('A')\n    65\n", "sq": "Shkruani një funksion në C `int f_28(char character)` për të zgjidhur problemin e mëposhtëm:\nShfaq informacionin ASCII për një karakter të dhënë.\n\n    Parametrat:\n- character (char): Karakteri i hyrjes për të cilin do të shfaqet informacioni ASCII.\n\n    Kthen:\n- int: kodi përkatës ASCII\n    >>> f_28('A')\n    65", "hy": "Գրեք C ֆունկցիա `int f_28(char character)` հետևյալ խնդիրը լուծելու համար:\nՑուցադրել տրված սիմվոլի ASCII տեղեկատվությունը:\n\n    Պարամետրեր:\n- character (char): Մուտքային սիմվոլ, որի համար պետք է ցուցադրվի ASCII տեղեկատվությունը:\n\n    Վերադարձնում է:\n- int: համապատասխան ASCII կոդը\n    >>> f_28('A')\n    65", "bn": "একটি C ফাংশন `int f_28(char character)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি প্রদত্ত অক্ষরের জন্য ASCII তথ্য প্রদর্শন করুন।\n\n    প্যারামিটারসমূহ:\n- character (char): ইনপুট অক্ষর যার জন্য ASCII তথ্য প্রদর্শন করা হবে।\n\n    রিটার্নস:\n- int: সংশ্লিষ্ট ASCII কোড\n    >>> f_28('A')\n    65", "bg": "Напишете C функция `int f_28(char character)`, за да решите следния проблем:\nПоказване на ASCII информацията за даден символ.\n\n    Параметри:\n- character (char): Входният символ, за който трябва да се покаже ASCII информацията.\n\n    Връща:\n- int: съответстващ ASCII код\n    >>> f_28('A')\n    65", "zh": "编写一个 C 函数 `int f_28(char character)` 来解决以下问题：\n显示给定字符的 ASCII 信息。\n\n    参数:\n- character (char): 要显示 ASCII 信息的输入字符。\n\n    返回:\n- int: 对应的 ASCII 代码\n    >>> f_28('A')\n    65", "fr": "Écrire une fonction C `int f_28(char character)` pour résoudre le problème suivant:\nAfficher les informations ASCII pour un caractère donné.\n\n    Paramètres :\n- character (char) : Le caractère d'entrée pour lequel les informations ASCII doivent être affichées.\n\n    Renvoie :\n- int : code ASCII correspondant\n    >>> f_28('A')\n    65", "de": "Schreiben Sie eine C-Funktion `int f_28(char character)`, um das folgende Problem zu lösen:\nZeigen Sie die ASCII-Informationen für ein gegebenes Zeichen an.\n\n    Parameter:\n- character (char): Das Eingabezeichen, für das die ASCII-Informationen angezeigt werden sollen.\n\n    Rückgabewert:\n- int: entsprechender ASCII-Code\n    >>> f_28('A')\n    65", "ha": "Rubuta aikin C `int f_28(char character)` don warware matsalar mai zuwa:\n Nuna bayanin ASCII don wata alama da aka bayar.\n\n   Sigogi:\n- character (char): Alamar shigarwa wadda za a nuna bayanin ASCII nata.\n\n   Komawa:\n- int: lambar ASCII da ta dace\n    >>> f_28('A')\n    65", "hi": "एक C फ़ंक्शन `int f_28(char character)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए अक्षर के लिए ASCII जानकारी प्रदर्शित करें।\n\n    पैरामीटर्स:\n- character (char): इनपुट अक्षर जिसके लिए ASCII जानकारी प्रदर्शित की जानी है।\n\n    रिटर्न्स:\n- int: संबंधित ASCII कोड\n    >>> f_28('A')\n    65", "hu": "Írj egy C függvényt `int f_28(char character)` a következő probléma megoldására:\nJelenítsd meg egy adott karakter ASCII információját.\n\n    Paraméterek:\n- character (char): Az a bemeneti karakter, amelynek az ASCII információját meg kell jeleníteni.\n\n    Visszatérési érték:\n- int: a megfelelő ASCII kód\n    >>> f_28('A')\n    65", "es": "Escribe una función en C `int f_28(char character)` para resolver el siguiente problema:\nMostrar la información ASCII para un carácter dado.\n\n    Parámetros:\n- character (char): El carácter de entrada para el cual se mostrará la información ASCII.\n\n    Retorna:\n- int: código ASCII correspondiente\n    >>> f_28('A')\n    65", "arb": "اكتب دالة C `int f_28(char character)` لحل المشكلة التالية:\nعرض معلومات ASCII لحرف معين.\n\n    المعاملات:\n- character (char): الحرف المدخل الذي سيتم عرض معلومات ASCII له.\n\n    يعيد:\n- int: رمز ASCII المقابل\n    >>> f_28('A')\n    65", "sw": "Andika kazi ya C `int f_28(char character)` kutatua tatizo lifuatalo:\nOnyesha taarifa za ASCII kwa herufi iliyotolewa.\n\n    Vigezo:\n- character (char): Herufi ya ingizo ambayo taarifa za ASCII zinaonyeshwa.\n\n    Inarejesha:\n- int: msimbo wa ASCII unaolingana\n    >>> f_28('A')\n    65", "tr": "Bir C fonksiyonu `int f_28(char character)` yazın ve aşağıdaki problemi çözün:\nBelirtilen bir karakter için ASCII bilgisini görüntüleyin.\n\n    Parametreler:\n- character (char): ASCII bilgisinin görüntüleneceği giriş karakteri.\n\n    Döndürür:\n- int: Karşılık gelen ASCII kodu\n    >>> f_28('A')\n    65", "vi": "Viết một hàm C `int f_28(char character)` để giải quyết vấn đề sau:\nHiển thị thông tin ASCII cho một ký tự được cung cấp.\n\n    Tham số:\n- character (char): Ký tự đầu vào mà thông tin ASCII cần được hiển thị.\n\n    Trả về:\n- int: mã ASCII tương ứng\n    >>> f_28('A')\n    65", "id": "Tulis sebuah fungsi C `int f_28(char character)` untuk menyelesaikan masalah berikut:\nTampilkan informasi ASCII untuk karakter yang diberikan.\n\n    Parameter:\n- character (char): Karakter input yang informasi ASCII-nya akan ditampilkan.\n\n    Mengembalikan:\n- int: kode ASCII yang sesuai\n    >>> f_28('A')\n    65", "ja": "Cの関数を書け `int f_28(char character)` を作成して、次の問題を解決してください:\n指定された文字のASCII情報を表示します。\n\n    パラメータ:\n- character (char): ASCII情報を表示するための入力文字。\n\n    戻り値:\n- int: 対応するASCIIコード\n    >>> f_28('A')\n    65", "ko": "C 함수 `int f_28(char character)`를 작성하여 다음 문제를 해결하십시오:\n주어진 문자에 대한 ASCII 정보를 표시합니다.\n\n    매개변수:\n- character (char): ASCII 정보를 표시할 입력 문자입니다.\n\n    반환값:\n- int: 해당하는 ASCII 코드\n    >>> f_28('A')\n    65", "ml": "C ഫംഗ്ഷൻ `int f_28(char character)` എഴുതുക താഴെക്കൊടുത്തിരിക്കുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nഒരു നൽകിയിരിക്കുന്ന അക്ഷരത്തിന്റെ ASCII വിവരങ്ങൾ പ്രദർശിപ്പിക്കുക.\n\n    പാരാമീറ്ററുകൾ:\n- character (char): ASCII വിവരങ്ങൾ പ്രദർശിപ്പിക്കേണ്ട ഇൻപുട്ട് അക്ഷരം.\n\n    റിട്ടേൺസ്:\n- int: അനുബന്ധ ASCII കോഡ്\n    >>> f_28('A')\n    65", "fa": "یک تابع C `int f_28(char character)` بنویسید تا مسئله زیر را حل کند:\nنمایش اطلاعات ASCII برای یک کاراکتر داده شده.\n\n    پارامترها:\n- character (char): کاراکتر ورودی که اطلاعات ASCII آن باید نمایش داده شود.\n\n    بازگشتی:\n- int: کد ASCII متناظر\n    >>> f_28('A')\n    65"}, "level": "easy", "test": "int main() {\n    assert(f_28('A') == 65);\n    assert(f_28('B') == 66); // Additional test case\n    assert(f_28('0') == 48); // Additional test case\n    assert(f_28(' ') == 32); // Additional test case\n    // printf(\"All tests passed.\\n\");\n    return 0;\n}", "entry_point": "f_28", "signature": "int f_28(char character)", "docstring": {"en": "Display the ASCII information for a given character.\n\n    Parameters:\n- character (char): The input character for which ASCII information is to be displayed.\n\n    Returns:\n- int: corresponding ASCII code\n    >>> f_28('A')\n    65\n", "sq": "Shfaq informacionin ASCII për një karakter të dhënë.\n\n    Parametrat:\n- character (char): Karakteri hyrës për të cilin do të shfaqet informacioni ASCII.\n\n    Kthen:\n- int: kodi përkatës ASCII\n    >>> f_28('A')\n    65", "hy": "ASCII տեղեկատվությունը ցուցադրել տրված սիմվոլի համար։\n\n    Պարամետրեր:\n- character (char): Մուտքային սիմվոլը, որի համար պետք է ցուցադրվի ASCII տեղեկատվությունը։\n\n    Վերադարձնում է:\n- int: համապատասխան ASCII կոդը\n    >>> f_28('A')\n    65", "bn": "একটি প্রদত্ত অক্ষরের জন্য ASCII তথ্য প্রদর্শন করুন।\n\n    প্যারামিটারসমূহ:\n- character (char): ইনপুট অক্ষর যার জন্য ASCII তথ্য প্রদর্শন করা হবে।\n\n    রিটার্নস:\n- int: সংশ্লিষ্ট ASCII কোড\n    >>> f_28('A')\n    65", "bg": "Показва ASCII информацията за даден символ.\n\n    Параметри:\n- character (char): Входният символ, за който трябва да се покаже ASCII информация.\n\n    Връща:\n- int: съответстващ ASCII код\n    >>> f_28('A')\n    65", "zh": "显示给定字符的ASCII信息。\n\n    参数:\n- character (char): 要显示其ASCII信息的输入字符。\n\n    返回:\n- int: 对应的ASCII码\n    >>> f_28('A')\n    65", "fr": "Afficher les informations ASCII pour un caractère donné.\n\n    Paramètres:\n- character (char): Le caractère d'entrée pour lequel les informations ASCII doivent être affichées.\n\n    Renvoie:\n- int: code ASCII correspondant\n    >>> f_28('A')\n    65", "de": "Zeige die ASCII-Informationen für ein gegebenes Zeichen an.\n\n    Parameter:\n- character (char): Das Eingabezeichen, für das die ASCII-Informationen angezeigt werden sollen.\n\n    Rückgabewerte:\n- int: entsprechender ASCII-Code\n    >>> f_28('A')\n    65", "ha": "Nuna bayanin ASCII don wata alama da aka bayar.\n\n    Sigogi:\n- character (char): Alamar shigarwa wadda za a nuna bayanin ASCII dinta.\n\n    Komawa:\n- int: lambar ASCII da ta dace\n    >>> f_28('A')\n    65", "hi": "दिए गए वर्ण के लिए ASCII जानकारी प्रदर्शित करें।\n\n    पैरामीटर्स:\n- character (char): वह इनपुट वर्ण जिसके लिए ASCII जानकारी प्रदर्शित की जानी है।\n\n    रिटर्न्स:\n- int: संबंधित ASCII कोड\n    >>> f_28('A')\n    65", "hu": "Jelenítse meg a megadott karakter ASCII információját.\n\n    Paraméterek:\n- character (char): Az a bemeneti karakter, amelynek az ASCII információját meg kell jeleníteni.\n\n    Visszatér:\n- int: a megfelelő ASCII kód\n    >>> f_28('A')\n    65", "es": "Mostrar la información ASCII para un carácter dado.\n\n    Parámetros:\n- character (char): El carácter de entrada para el cual se mostrará la información ASCII.\n\n    Devuelve:\n- int: código ASCII correspondiente\n    >>> f_28('A')\n    65", "arb": "عرض معلومات ASCII لحرف معين.\n\n    المعلمات:\n- character (char): الحرف المدخل الذي سيتم عرض معلومات ASCII له.\n\n    يعيد:\n- int: رمز ASCII المقابل\n    >>> f_28('A')\n    65", "sw": "Onyesha taarifa za ASCII kwa herufi iliyopewa.\n\n    Vigezo:\n- character (char): Herufi ya ingizo ambayo taarifa za ASCII zitaonyeshwa.\n\n    Inarejesha:\n- int: nambari ya ASCII inayolingana\n    >>> f_28('A')\n    65", "tr": "Belirtilen karakter için ASCII bilgisini görüntüleyin.\n\n    Parametreler:\n- character (char): ASCII bilgisinin görüntüleneceği giriş karakteri.\n\n    Döndürür:\n- int: karşılık gelen ASCII kodu\n    >>> f_28('A')\n    65", "vi": "Hiển thị thông tin ASCII cho một ký tự cho trước.\n\n    Tham số:\n- character (char): Ký tự đầu vào mà thông tin ASCII cần được hiển thị.\n\n    Trả về:\n- int: mã ASCII tương ứng\n    >>> f_28('A')\n    65", "id": "Tampilkan informasi ASCII untuk karakter yang diberikan.\n\n    Parameter:\n- character (char): Karakter input yang akan ditampilkan informasi ASCII-nya.\n\n    Mengembalikan:\n- int: kode ASCII yang sesuai\n    >>> f_28('A')\n    65", "ja": "与えられた文字のASCII情報を表示します。\n\n    パラメータ:\n- character (char): ASCII情報を表示するための入力文字。\n\n    戻り値:\n- int: 対応するASCIIコード\n    >>> f_28('A')\n    65", "ko": "주어진 문자에 대한 ASCII 정보를 표시합니다.\n\n    매개변수:\n- character (char): ASCII 정보를 표시할 입력 문자입니다.\n\n    반환값:\n- int: 해당하는 ASCII 코드\n    >>> f_28('A')\n    65", "ml": "ഒരു നൽകിയ അക്ഷരത്തിനുള്ള ASCII വിവരങ്ങൾ പ്രദർശിപ്പിക്കുക.\n\n    പാരാമീറ്ററുകൾ:\n- character (char): ASCII വിവരങ്ങൾ പ്രദർശിപ്പിക്കേണ്ട ഇൻപുട്ട് അക്ഷരം.\n\n    റിട്ടേൺസ്:\n- int: അനുബന്ധ ASCII കോഡ്\n    >>> f_28('A')\n    65", "fa": "نمایش اطلاعات ASCII برای یک کاراکتر داده شده.\n\n    پارامترها:\n- character (char): کاراکتر ورودی که اطلاعات ASCII برای آن نمایش داده می‌شود.\n\n    بازگشت:\n- int: کد ASCII مربوطه\n    >>> f_28('A')\n    65"}}
{"task_id": "C/29", "prompt": {"en": "#include <assert.h> // Used for testing the function with assertions\n#include <math.h> // Not needed for this function\n#include <stdbool.h> // Not needed for this function\n#include <stdio.h> // Needed for input/output functions\n#include <string.h> // Not needed for this function\n/*\nEvaluate the grade for an input integer.\n    Parameters:\n- score (int): The integer score to be evaluated.\n    Returns:\n​​    char: The grade corresponding to the input score.\n​​         If the score is between 90 and 100 (inclusive), returns 'A'.\n​​         Otherwise, returns 'B'.\n>>> f_29(90)\nA\n*/\nchar f_29(int score)", "sq": "#include <assert.h> // Përdoret për të testuar funksionin me pohime\n#include <math.h> // Nuk nevojitet për këtë funksion\n#include <stdbool.h> // Nuk nevojitet për këtë funksion\n#include <stdio.h> // Nevojitet për funksionet e hyrje/dalje\n#include <string.h> // Nuk nevojitet për këtë funksion\n/*\nVlerëson notën për një numër të plotë hyrës.\n    Parametrat:\n- score (int): Nota e plotë që do të vlerësohet.\n    Kthen:\n​​    char: Nota që korrespondon me notën hyrëse.\n​​         Nëse nota është midis 90 dhe 100 (përfshirë), kthen 'A'.\n​​         Përndryshe, kthen 'B'.\n>>> f_29(90)\nA\n*/\nchar f_29(int score)", "hy": "#include <assert.h> // Օգտագործվում է ֆունկցիան ստուգելու համար հաստատումներով\n#include <math.h> // Անհրաժեշտ չէ այս ֆունկցիայի համար\n#include <stdbool.h> // Անհրաժեշտ չէ այս ֆունկցիայի համար\n#include <stdio.h> // Անհրաժեշտ է մուտք/ելքի ֆունկցիաների համար\n#include <string.h> // Անհրաժեշտ չէ այս ֆունկցիայի համար\n/*\nԳնահատել մուտքագրված ամբողջ թվի գնահատականը:\n    Պարամետրեր:\n- score (int): Գնահատվող ամբողջ թիվը:\n    Վերադարձնում է:\n​​    char: Մուտքագրված գնահատականին համապատասխանող նշանը:\n​​         Եթե գնահատականը 90-ից 100 միջակայքում է (ներառյալ), վերադարձնում է 'A':\n​​         Հակառակ դեպքում, վերադարձնում է 'B':\n>>> f_29(90)\nA\n*/\nchar f_29(int score)", "bn": "#include <assert.h> // ফাংশনটি পরীক্ষার জন্য assertions ব্যবহার করা হয়\n#include <math.h> // এই ফাংশনের জন্য প্রয়োজন নেই\n#include <stdbool.h> // এই ফাংশনের জন্য প্রয়োজন নেই\n#include <stdio.h> // ইনপুট/আউটপুট ফাংশনের জন্য প্রয়োজন\n#include <string.h> // এই ফাংশনের জন্য প্রয়োজন নেই\n/*\nএকটি ইনপুট পূর্ণসংখ্যার জন্য গ্রেড মূল্যায়ন করুন।\n    প্যারামিটার:\n- score (int): মূল্যায়ন করার জন্য পূর্ণসংখ্যার স্কোর।\n    রিটার্নস:\n​​    char: ইনপুট স্কোরের সাথে সম্পর্কিত গ্রেড।\n​​         যদি স্কোর 90 এবং 100 এর মধ্যে (অন্তর্ভুক্ত) হয়, তবে 'A' রিটার্ন করে।\n​​         অন্যথায়, 'B' রিটার্ন করে।\n>>> f_29(90)\nA\n*/\nchar f_29(int score)", "bg": "#include <assert.h> // Използва се за тестване на функцията с твърдения\n#include <math.h> // Не е необходимо за тази функция\n#include <stdbool.h> // Не е необходимо за тази функция\n#include <stdio.h> // Необходимо за входно/изходни функции\n#include <string.h> // Не е необходимо за тази функция\n/*\nОценете оценката за входно цяло число.\n    Параметри:\n- score (int): Цялото число, което трябва да бъде оценено.\n    Връща:\n​​    char: Оценката, съответстваща на входното число.\n​​         Ако числото е между 90 и 100 (включително), връща 'A'.\n​​         В противен случай връща 'B'.\n>>> f_29(90)\nA\n*/\nchar f_29(int score)", "zh": "#include <assert.h> // 用于使用断言测试函数\n#include <math.h> // 这个函数不需要\n#include <stdbool.h> // 这个函数不需要\n#include <stdio.h> // 需要用于输入/输出函数\n#include <string.h> // 这个函数不需要\n/*\n评估输入整数的等级。\n    参数:\n- score (int): 要评估的整数分数。\n    返回:\n​​    char: 与输入分数对应的等级。\n​​         如果分数在90到100之间（包括90和100），返回 'A'。\n​​         否则，返回 'B'。\n>>> f_29(90)\nA\n*/\nchar f_29(int score)", "fr": "#include <assert.h> // Utilisé pour tester la fonction avec des assertions\n#include <math.h> // Pas nécessaire pour cette fonction\n#include <stdbool.h> // Pas nécessaire pour cette fonction\n#include <stdio.h> // Nécessaire pour les fonctions d'entrée/sortie\n#include <string.h> // Pas nécessaire pour cette fonction\n/*\nÉvaluer la note pour un entier en entrée.\n    Paramètres:\n- score (int): Le score entier à évaluer.\n    Renvoie:\n​​    char: La note correspondant au score en entrée.\n​​         Si le score est entre 90 et 100 (inclus), renvoie 'A'.\n​​         Sinon, renvoie 'B'.\n>>> f_29(90)\nA\n*/\nchar f_29(int score)", "de": "#include <assert.h> // Wird verwendet, um die Funktion mit Assertions zu testen\n#include <math.h> // Nicht benötigt für diese Funktion\n#include <stdbool.h> // Nicht benötigt für diese Funktion\n#include <stdio.h> // Benötigt für Ein-/Ausgabefunktionen\n#include <string.h> // Nicht benötigt für diese Funktion\n/*\nBewertet die Note für eine Eingabe als Ganzzahl.\n    Parameter:\n- score (int): Die zu bewertende Ganzzahl.\n    Rückgabewert:\n​​    char: Die Note, die der Eingabewertung entspricht.\n​​         Wenn die Bewertung zwischen 90 und 100 (einschließlich) liegt, wird 'A' zurückgegeben.\n​​         Andernfalls wird 'B' zurückgegeben.\n>>> f_29(90)\nA\n*/\nchar f_29(int score)", "ha": "#include <assert.h> // Ana amfani da wannan don gwada aikin tare da tabbaci\n#include <math.h> // Ba a bukata don wannan aikin\n#include <stdbool.h> // Ba a bukata don wannan aikin\n#include <stdio.h> // Ana bukata don ayyukan shigarwa/fitarwa\n#include <string.h> // Ba a bukata don wannan aikin\n/*\nKimanta darajar don wani cikakken lamba.\n    Sigogi:\n- score (int): Cikakken maki da za a kimanta.\n    Komawa:\n​​    char: Darajar da ta dace da maki da aka shigar.\n​​         Idan maki yana tsakanin 90 da 100 (ciki har da), yana dawowa 'A'.\n​​         In ba haka ba, yana dawowa 'B'.\n>>> f_29(90)\nA\n*/\nchar f_29(int score)", "hi": "#include <assert.h> // assert के साथ फ़ंक्शन का परीक्षण करने के लिए उपयोग किया जाता है\n#include <math.h> // इस फ़ंक्शन के लिए आवश्यक नहीं है\n#include <stdbool.h> // इस फ़ंक्शन के लिए आवश्यक नहीं है\n#include <stdio.h> // इनपुट/आउटपुट फ़ंक्शन के लिए आवश्यक है\n#include <string.h> // इस फ़ंक्शन के लिए आवश्यक नहीं है\n/*\nएक इनपुट पूर्णांक के लिए ग्रेड का मूल्यांकन करें।\n    पैरामीटर:\n- score (int): मूल्यांकन के लिए पूर्णांक स्कोर।\n    लौटाता है:\n​​    char: इनपुट स्कोर के अनुरूप ग्रेड।\n​​         यदि स्कोर 90 और 100 (समावेशी) के बीच है, तो 'A' लौटाता है।\n​​         अन्यथा, 'B' लौटाता है।\n>>> f_29(90)\nA\n*/\nchar f_29(int score)", "hu": "#include <assert.h> // Használva a függvény tesztelésére állításokkal\n#include <math.h> // Nem szükséges ehhez a függvényhez\n#include <stdbool.h> // Nem szükséges ehhez a függvényhez\n#include <stdio.h> // Szükséges a bemeneti/kimeneti függvényekhez\n#include <string.h> // Nem szükséges ehhez a függvényhez\n/*\nÉrtékeli a bemeneti egész szám osztályzatát.\n    Paraméterek:\n- score (int): Az értékelendő egész szám pontszám.\n    Visszatér:\n​​    char: A bemeneti pontszámnak megfelelő osztályzat.\n​​         Ha a pontszám 90 és 100 között van (beleértve), 'A'-t ad vissza.\n​​         Egyébként 'B'-t ad vissza.\n>>> f_29(90)\nA\n*/\nchar f_29(int score)", "es": "#include <assert.h> // Usado para probar la función con afirmaciones\n#include <math.h> // No necesario para esta función\n#include <stdbool.h> // No necesario para esta función\n#include <stdio.h> // Necesario para funciones de entrada/salida\n#include <string.h> // No necesario para esta función\n/*\nEvalúa la calificación para un entero de entrada.\n    Parámetros:\n- score (int): La puntuación entera a evaluar.\n    Devuelve:\n​​    char: La calificación correspondiente a la puntuación de entrada.\n​​         Si la puntuación está entre 90 y 100 (inclusive), devuelve 'A'.\n​​         De lo contrario, devuelve 'B'.\n>>> f_29(90)\nA\n*/\nchar f_29(int score)", "arb": "#include <assert.h> // تُستخدم لاختبار الدالة باستخدام التأكيدات\n#include <math.h> // غير مطلوب لهذه الدالة\n#include <stdbool.h> // غير مطلوب لهذه الدالة\n#include <stdio.h> // مطلوب لوظائف الإدخال/الإخراج\n#include <string.h> // غير مطلوب لهذه الدالة\n/*\nتقييم الدرجة لعدد صحيح مُدخل.\n    المعاملات:\n- score (int): الدرجة الصحيحة التي سيتم تقييمها.\n    يعيد:\n​​    char: الدرجة المقابلة للدرجة المُدخلة.\n​​         إذا كانت الدرجة بين 90 و 100 (شاملة)، تعيد 'A'.\n​​         خلاف ذلك، تعيد 'B'.\n>>> f_29(90)\nA\n*/\nchar f_29(int score)", "sw": "#include <assert.h> // Inatumika kwa kupima kazi na uthibitisho\n#include <math.h> // Haitajiki kwa kazi hii\n#include <stdbool.h> // Haitajiki kwa kazi hii\n#include <stdio.h> // Inahitajika kwa kazi za kuingiza/kutoa\n#include <string.h> // Haitajiki kwa kazi hii\n/*\nTambua daraja kwa namba kamili ya pembejeo.\n    Vigezo:\n- score (int): Alama ya namba kamili inayopaswa kutambuliwa.\n    Inarudisha:\n​​    char: Daraja linalolingana na alama ya pembejeo.\n​​         Ikiwa alama iko kati ya 90 na 100 (pamoja), inarudisha 'A'.\n​​         Vinginevyo, inarudisha 'B'.\n>>> f_29(90)\nA\n*/\nchar f_29(int score)", "tr": "#include <assert.h> // Fonksiyonu test etmek için assert'ler kullanılır\n#include <math.h> // Bu fonksiyon için gerekli değil\n#include <stdbool.h> // Bu fonksiyon için gerekli değil\n#include <stdio.h> // Giriş/çıkış fonksiyonları için gerekli\n#include <string.h> // Bu fonksiyon için gerekli değil\n/*\nBir tamsayı notunu değerlendir.\n    Parametreler:\n- score (int): Değerlendirilecek tamsayı notu.\n    Döndürür:\n​​    char: Girdi notuna karşılık gelen harf notu.\n​​         Eğer not 90 ile 100 arasında (dahil), 'A' döndürür.\n​​         Aksi takdirde, 'B' döndürür.\n>>> f_29(90)\nA\n*/\nchar f_29(int score)", "vi": "#include <assert.h> // Được sử dụng để kiểm tra hàm với các khẳng định\n#include <math.h> // Không cần thiết cho hàm này\n#include <stdbool.h> // Không cần thiết cho hàm này\n#include <stdio.h> // Cần thiết cho các hàm nhập/xuất\n#include <string.h> // Không cần thiết cho hàm này\n/*\nĐánh giá điểm cho một số nguyên đầu vào.\n    Tham số:\n- score (int): Điểm số nguyên cần được đánh giá.\n    Trả về:\n​​    char: Điểm tương ứng với điểm số đầu vào.\n​​         Nếu điểm số nằm trong khoảng từ 90 đến 100 (bao gồm), trả về 'A'.\n​​         Ngược lại, trả về 'B'.\n>>> f_29(90)\nA\n*/\nchar f_29(int score)", "id": "#include <assert.h> // Digunakan untuk menguji fungsi dengan asersi\n#include <math.h> // Tidak diperlukan untuk fungsi ini\n#include <stdbool.h> // Tidak diperlukan untuk fungsi ini\n#include <stdio.h> // Diperlukan untuk fungsi input/output\n#include <string.h> // Tidak diperlukan untuk fungsi ini\n/*\nEvaluasi nilai untuk bilangan bulat masukan.\n    Parameter:\n- score (int): Skor bilangan bulat yang akan dievaluasi.\n    Mengembalikan:\n​​    char: Nilai yang sesuai dengan skor masukan.\n​​         Jika skor antara 90 dan 100 (inklusif), mengembalikan 'A'.\n​​         Jika tidak, mengembalikan 'B'.\n>>> f_29(90)\nA\n*/\nchar f_29(int score)", "ja": "#include <assert.h> // アサーションで関数をテストするために使用\n#include <math.h> // この関数には不要\n#include <stdbool.h> // この関数には不要\n#include <stdio.h> // 入出力関数に必要\n#include <string.h> // この関数には不要\n/*\n入力整数の評価を行う。\n    パラメータ:\n- score (int): 評価する整数スコア。\n    戻り値:\n​​    char: 入力スコアに対応するグレード。\n​​         スコアが90から100の間（含む）の場合、'A'を返す。\n​​         それ以外の場合は、'B'を返す。\n>>> f_29(90)\nA\n*/\nchar f_29(int score)", "ko": "#include <assert.h> // 함수 테스트를 위한 assert 사용\n#include <math.h> // 이 함수에는 필요하지 않음\n#include <stdbool.h> // 이 함수에는 필요하지 않음\n#include <stdio.h> // 입출력 함수에 필요\n#include <string.h> // 이 함수에는 필요하지 않음\n/*\n입력 정수에 대한 등급 평가.\n    매개변수:\n- score (int): 평가할 정수 점수.\n    반환값:\n​​    char: 입력 점수에 해당하는 등급.\n​​         점수가 90에서 100 사이(포함)인 경우 'A'를 반환.\n​​         그렇지 않으면 'B'를 반환.\n>>> f_29(90)\nA\n*/\nchar f_29(int score)", "ml": "#include <assert.h> // assertions ഉപയോഗിച്ച് ഫംഗ്ഷൻ പരിശോധിക്കാൻ ഉപയോഗിക്കുന്നു\n#include <math.h> // ഈ ഫംഗ്ഷനു വേണ്ടിയില്ല\n#include <stdbool.h> // ഈ ഫംഗ്ഷനു വേണ്ടിയില്ല\n#include <stdio.h> // ഇൻപുട്ട്/ഔട്ട്പുട്ട് ഫംഗ്ഷനുകൾക്കായി ആവശ്യമാണ്\n#include <string.h> // ഈ ഫംഗ്ഷനു വേണ്ടിയില്ല\n/*\nഒരു ഇൻപുട്ട് ഇൻറീജറിന് ഗ്രേഡ് വിലയിരുത്തുക.\n    പാരാമീറ്ററുകൾ:\n- score (int): വിലയിരുത്തേണ്ട ഇൻറീജർ സ്കോർ.\n    മടക്കുന്നു:\n​​    char: ഇൻപുട്ട് സ്കോറിന് അനുയോജ്യമായ ഗ്രേഡ്.\n​​         സ്കോർ 90 മുതൽ 100 വരെയാണെങ്കിൽ (ഉൾപ്പെടെ), 'A' മടക്കുന്നു.\n​​         അല്ലെങ്കിൽ, 'B' മടക്കുന്നു.\n>>> f_29(90)\nA\n*/\nchar f_29(int score)", "fa": "#include <assert.h> // برای آزمایش تابع با استفاده از ادعاها استفاده می‌شود\n#include <math.h> // برای این تابع لازم نیست\n#include <stdbool.h> // برای این تابع لازم نیست\n#include <stdio.h> // برای توابع ورودی/خروجی لازم است\n#include <string.h> // برای این تابع لازم نیست\n/*\nارزیابی نمره برای یک عدد صحیح ورودی.\n    پارامترها:\n- score (int): نمره صحیحی که باید ارزیابی شود.\n    بازگشت:\n​​    char: نمره‌ای که با نمره ورودی مطابقت دارد.\n​​         اگر نمره بین 90 و 100 (شامل) باشد، 'A' را برمی‌گرداند.\n​​         در غیر این صورت، 'B' را برمی‌گرداند.\n>>> f_29(90)\nA\n*/\nchar f_29(int score)"}, "canonical_solution": "{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}", "instruction": {"en": "Write a C function `char f_29(int score)` to solve the following problem:\nEvaluate the grade for an input integer.\n    Parameters:\n- score (int): The integer score to be evaluated.\n    Returns:\n    char: The grade corresponding to the input score.\n    If the score is between 90 and 100 (inclusive), returns 'A'.\n    Otherwise, returns 'B'.\n>>> f_29(90)\nA\n", "sq": "Shkruani një funksion në C `char f_29(int score)` për të zgjidhur problemin e mëposhtëm:\nVlerësoni notën për një numër të plotë të dhënë.\n    Parametrat:\n- score (int): Nota e plotë që do të vlerësohet.\n    Kthen:\n    char: Nota që korrespondon me notën e dhënë.\n    Nëse nota është midis 90 dhe 100 (përfshirë), kthen 'A'.\n    Përndryshe, kthen 'B'.\n>>> f_29(90)\nA", "hy": "Գրեք C ֆունկցիա `char f_29(int score)` հետևյալ խնդիրը լուծելու համար:\nԳնահատել մուտքային ամբողջ թվի գնահատականը:\n    Պարամետրեր:\n- score (int): Գնահատվող ամբողջ թիվը:\n    Վերադարձնում է:\n    char: Մուտքային գնահատականին համապատասխանող գնահատականը:\n    Եթե գնահատականը 90-ից 100 միջակայքում է (ներառյալ), վերադարձնում է 'A':\n    Հակառակ դեպքում, վերադարձնում է 'B':\n>>> f_29(90)\nA", "bn": "একটি C ফাংশন `char f_29(int score)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি পূর্ণসংখ্যা গ্রেড মূল্যায়ন করুন।\n    প্যারামিটারসমূহ:\n- score (int): মূল্যায়নের জন্য পূর্ণসংখ্যা স্কোর।\n    রিটার্নস:\n    char: ইনপুট স্কোরের সাথে সম্পর্কিত গ্রেড।\n    যদি স্কোর 90 এবং 100 এর মধ্যে (অন্তর্ভুক্ত) হয়, তাহলে 'A' রিটার্ন করে।\n    অন্যথায়, 'B' রিটার্ন করে।\n>>> f_29(90)\nA", "bg": "Напишете C функция `char f_29(int score)` за решаване на следния проблем:\nОценете оценката за входящо цяло число.  \nПараметри:  \n- score (int): Целочислената оценка, която трябва да бъде оценена.  \nВръща:  \nchar: Оценката, съответстваща на входната оценка.  \nАко оценката е между 90 и 100 (включително), връща 'A'.  \nВ противен случай връща 'B'.  \n>>> f_29(90)  \nA  ", "zh": "编写一个C函数 `char f_29(int score)` 来解决以下问题：\n评估输入整数的等级。\n    参数：\n- score (int): 要评估的整数分数。\n    返回：\n    char: 与输入分数对应的等级。\n    如果分数在90到100之间（包括90和100），返回 'A'。\n    否则，返回 'B'。\n>>> f_29(90)\nA", "fr": "Écrire une fonction C `char f_29(int score)` pour résoudre le problème suivant :\nÉvaluer la note pour un entier en entrée.\n    Paramètres :\n- score (int) : Le score entier à évaluer.\n    Renvoie :\n    char : La note correspondant au score en entrée.\n    Si le score est entre 90 et 100 (inclus), renvoie 'A'.\n    Sinon, renvoie 'B'.\n>>> f_29(90)\nA", "de": "Schreiben Sie eine C-Funktion `char f_29(int score)`, um das folgende Problem zu lösen:\nBewerten Sie die Note für eine eingegebene Ganzzahl.\n    Parameter:\n- score (int): Die zu bewertende Ganzzahl.\n    Rückgabe:\n    char: Die Note, die der eingegebenen Punktzahl entspricht.\n    Wenn die Punktzahl zwischen 90 und 100 (einschließlich) liegt, wird 'A' zurückgegeben.\n    Andernfalls wird 'B' zurückgegeben.\n>>> f_29(90)\nA", "ha": "Rubuta aikin C `char f_29(int score)` don warware matsalar mai zuwa:\nKimanta darajar don shigarwar lamba. Ma'auni: - score (int): Lambar da za a kimanta. Komawa: char: Darajar da ta dace da shigarwar lamba. Idan lambar tana tsakanin 90 da 100 (ciki har da), ya dawo 'A'. In ba haka ba, ya dawo 'B'. >>> f_29(90) A", "hi": "C फ़ंक्शन `char f_29(int score)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nइनपुट पूर्णांक के लिए ग्रेड का मूल्यांकन करें।\n    पैरामीटर्स:\n- score (int): मूल्यांकन के लिए पूर्णांक स्कोर।\n    रिटर्न करता है:\n    char: इनपुट स्कोर के अनुरूप ग्रेड।\n    यदि स्कोर 90 और 100 (समावेशी) के बीच है, तो 'A' लौटाता है।\n    अन्यथा, 'B' लौटाता है।\n>>> f_29(90)\nA", "hu": "Írj egy C függvényt `char f_29(int score)` a következő probléma megoldására:\nÉrtékeld ki egy egész szám osztályzatát.  \nParaméterek:  \n- score (int): Az értékelendő egész szám.  \nVisszatérési érték:  \nchar: Az osztályzat, amely megfelel a bemeneti pontszámnak.  \nHa a pontszám 90 és 100 között van (beleértve), 'A'-t ad vissza.  \nEgyébként 'B'-t ad vissza.  \n>>> f_29(90)  \nA  ", "es": "Escriba una función en C `char f_29(int score)` para resolver el siguiente problema:\nEvalúe la calificación para un entero de entrada.  \nParámetros:  \n- score (int): La puntuación entera a evaluar.  \nDevuelve:  \nchar: La calificación correspondiente a la puntuación de entrada.  \nSi la puntuación está entre 90 y 100 (inclusive), devuelve 'A'.  \nDe lo contrario, devuelve 'B'.  \n>>> f_29(90)  \nA  ", "arb": "اكتب دالة C `char f_29(int score)` لحل المشكلة التالية:\nتقييم الدرجة لعدد صحيح مدخل.\n    المعاملات:\n- score (int): الدرجة الصحيحة التي سيتم تقييمها.\n    يعيد:\n    char: الدرجة المقابلة للدرجة المدخلة.\n    إذا كانت الدرجة بين 90 و 100 (شاملة)، تعيد 'A'.\n    خلاف ذلك، تعيد 'B'.\n>>> f_29(90)\nA", "sw": "Andika kazi ya C `char f_29(int score)` kutatua tatizo lifuatalo:\nTambua alama kwa namba kamili iliyoingizwa.\n    Vigezo:\n- score (int): Alama ya namba kamili itakayopimwa.\n    Inarudisha:\n    char: Alama inayolingana na alama iliyoingizwa.\n    Ikiwa alama iko kati ya 90 na 100 (ikijumuishwa), inarudisha 'A'.\n    Vinginevyo, inarudisha 'B'.\n>>> f_29(90)\nA", "tr": "Bir C fonksiyonu `char f_29(int score)` yazın: Aşağıdaki problemi çözmek için:\nBir tamsayı notunu değerlendirin.\n    Parametreler:\n- score (int): Değerlendirilecek tamsayı notu.\n    Döndürür:\n    char: Girdi notuna karşılık gelen harf notu.\n    Eğer not 90 ile 100 arasında (dahil) ise, 'A' döndürür.\n    Aksi takdirde, 'B' döndürür.\n>>> f_29(90)\nA", "vi": "Viết một hàm C `char f_29(int score)` để giải quyết vấn đề sau:\nĐánh giá điểm cho một số nguyên đầu vào.  \nTham số:  \n- score (int): Điểm số nguyên cần được đánh giá.  \nTrả về:  \nchar: Điểm tương ứng với điểm số đầu vào.  \nNếu điểm số nằm trong khoảng từ 90 đến 100 (bao gồm cả 90 và 100), trả về 'A'.  \nNgược lại, trả về 'B'.  \n>>> f_29(90)  \nA  ", "id": "Tulis sebuah fungsi C `char f_29(int score)` untuk menyelesaikan masalah berikut:\nEvaluasi nilai untuk sebuah bilangan bulat masukan.\n    Parameter:\n- score (int): Skor bilangan bulat yang akan dievaluasi.\n    Mengembalikan:\n    char: Nilai yang sesuai dengan skor masukan.\n    Jika skor berada di antara 90 dan 100 (inklusif), mengembalikan 'A'.\n    Jika tidak, mengembalikan 'B'.\n>>> f_29(90)\nA", "ja": "Cの関数を書け `char f_29(int score)` を作成して、次の問題を解決してください:\n入力された整数の評価を行います。\n    パラメータ:\n- score (int): 評価される整数のスコア。\n    戻り値:\n    char: 入力されたスコアに対応するグレード。\n    スコアが90から100の範囲（含む）の場合、'A'を返します。\n    それ以外の場合は、'B'を返します。\n>>> f_29(90)\nA", "ko": "C 함수 `char f_29(int score)`를 작성하여 다음 문제를 해결하십시오:\n입력 정수에 대한 등급을 평가합니다.\n    매개변수:\n- score (int): 평가할 정수 점수.\n    반환값:\n    char: 입력 점수에 해당하는 등급.\n    점수가 90에서 100 사이(포함)인 경우 'A'를 반환합니다.\n    그렇지 않으면 'B'를 반환합니다.\n>>> f_29(90)\nA", "ml": "C ഫംഗ്ഷൻ `char f_29(int score)` എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nഇൻപുട്ട് ഇന്റിജർ ഗ്രേഡ് വിലയിരുത്തുക.\n    പാരാമീറ്ററുകൾ:\n- score (int): വിലയിരുത്താനുള്ള ഇന്റിജർ സ്കോർ.\n    റിട്ടേൺസ്:\n    char: ഇൻപുട്ട് സ്കോറിനോട് അനുബന്ധിച്ച ഗ്രേഡ്.\n    സ്കോർ 90 നും 100 നും ഇടയിൽ (ഉൾപ്പെടെ) ആണെങ്കിൽ, 'A' റിട്ടേൺ ചെയ്യും.\n    അല്ലെങ്കിൽ, 'B' റിട്ടേൺ ചെയ്യും.\n>>> f_29(90)\nA", "fa": "یک تابع C به نام `char f_29(int score)` بنویسید تا مسئله زیر را حل کند:\nارزیابی نمره برای یک عدد صحیح ورودی.\n    پارامترها:\n- score (int): نمره صحیحی که باید ارزیابی شود.\n    بازگشت:\n    char: نمره‌ای که به نمره ورودی مربوط می‌شود.\n    اگر نمره بین 90 و 100 (شامل) باشد، 'A' را برمی‌گرداند.\n    در غیر این صورت، 'B' را برمی‌گرداند.\n>>> f_29(90)\nA"}, "level": "easy", "test": "int main() // Updated test function to reflect the correct usage of the f_29 function\n{\n    assert(f_29(90) == 'A'); // Corrected the assertion to compare against character literals\n    assert(f_29(89) == 'B'); // Additional test for a score less than 90\n    assert(f_29(95) == 'A'); // Additional test within the 'A' range\n    assert(f_29(100) == 'A'); // Additional test for the boundary condition\n    assert(f_29(101) == 'B'); // Additional test for a score greater than 100\n\n    // Print \"All tests passed\" if all assertions hold true (optional)\n    // printf(\"All tests passed\\n\");\n\n    return 0;\n}", "entry_point": "f_29", "signature": "char f_29(int score)", "docstring": {"en": "Evaluate the grade for an input integer.\n    Parameters:\n- score (int): The integer score to be evaluated.\n    Returns:\n    char: The grade corresponding to the input score.\n    If the score is between 90 and 100 (inclusive), returns 'A'.\n    Otherwise, returns 'B'.\n>>> f_29(90)\nA\n", "sq": "Vlerësoni notën për një numër të plotë të dhënë si hyrje.\n    Parametrat:\n- score (int): Nota e plotë që do të vlerësohet.\n    Kthen:\n    char: Nota që korrespondon me notën e dhënë si hyrje.\n    Nëse nota është midis 90 dhe 100 (përfshirë), kthen 'A'.\n    Përndryshe, kthen 'B'.\n>>> f_29(90)\nA", "hy": "Մուտքային ամբողջ թիվի գնահատականի գնահատում։  \n    Պարամետրեր:\n- score (int): Գնահատվող ամբողջ թիվը։\n    Վերադարձնում է:\n    char: Մուտքային գնահատականին համապատասխանող գնահատականը։\n    Եթե գնահատականը 90-ից 100 (ներառյալ) միջակայքում է, վերադարձնում է 'A'։\n    Հակառակ դեպքում, վերադարձնում է 'B'։\n>>> f_29(90)\nA", "bn": "ইনপুট পূর্ণসংখ্যার জন্য গ্রেড মূল্যায়ন করুন।\n    Parameters:\n- score (int): মূল্যায়ন করার জন্য পূর্ণসংখ্যার স্কোর।\n    Returns:\n    char: ইনপুট স্কোরের সাথে সম্পর্কিত গ্রেড।\n    যদি স্কোর 90 এবং 100 এর মধ্যে হয় (অন্তর্ভুক্ত), তাহলে 'A' ফেরত দেয়।\n    অন্যথায়, 'B' ফেরত দেয়।\n>>> f_29(90)\nA", "bg": "Оценете оценката за входящо цяло число.\n    Параметри:\n- score (int): Целочислената оценка, която ще бъде оценена.\n    Връща:\n    char: Оценката, съответстваща на входящата оценка.\n    Ако оценката е между 90 и 100 (включително), връща 'A'.\n    В противен случай, връща 'B'.\n>>> f_29(90)\nA", "zh": "评估输入整数的等级。\n    参数：\n- score (int): 要评估的整数分数。\n    返回：\n    char: 与输入分数对应的等级。\n    如果分数在90到100之间（包括90和100），返回 'A'。\n    否则，返回 'B'。\n>>> f_29(90)\nA", "fr": "Évaluer la note pour un entier en entrée.\n    Paramètres:\n- score (int): Le score entier à évaluer.\n    Renvoie:\n    char: La note correspondant au score d'entrée.\n    Si le score est entre 90 et 100 (inclus), renvoie 'A'.\n    Sinon, renvoie 'B'.\n>>> f_29(90)\nA", "de": "Bewerten Sie die Note für eine eingegebene ganze Zahl.\n    Parameter:\n- score (int): Die zu bewertende ganze Zahl.\n    Rückgabe:\n    char: Die Note, die dem eingegebenen Punktestand entspricht.\n    Wenn der Punktestand zwischen 90 und 100 (einschließlich) liegt, wird 'A' zurückgegeben.\n    Andernfalls wird 'B' zurückgegeben.\n>>> f_29(90)\nA", "ha": "Duba darajar don wani lamba mai shigarwa.\n    Sigogi:\n- score (int): Lambar da za a duba.\n    Dawowa:\n    char: Darajar da ta dace da lambar da aka shigar.\n    Idan lambar tana tsakanin 90 da 100 (ciki har), yana dawowa 'A'.\n    In ba haka ba, yana dawowa 'B'.\n>>> f_29(90)\nA", "hi": "इनपुट पूर्णांक के लिए ग्रेड का मूल्यांकन करें।\n    Parameters:\n- score (int): मूल्यांकन के लिए पूर्णांक स्कोर।\n    Returns:\n    char: इनपुट स्कोर के अनुरूप ग्रेड।\n    यदि स्कोर 90 और 100 (समावेशी) के बीच है, तो 'A' लौटाता है।\n    अन्यथा, 'B' लौटाता है।\n>>> f_29(90)\nA", "hu": "Értékeli a jegyet egy bemeneti egész számhoz.\n    Paraméterek:\n- score (int): Az értékelendő egész szám pontszám.\n    Visszatér:\n    char: A bemeneti pontszámnak megfelelő jegy.\n    Ha a pontszám 90 és 100 között van (beleértve), 'A'-t ad vissza.\n    Egyébként 'B'-t ad vissza.\n>>> f_29(90)\nA", "es": "Evalúa la calificación para un número entero de entrada.\n    Parámetros:\n- score (int): La puntuación entera a evaluar.\n    Devuelve:\n    char: La calificación correspondiente a la puntuación de entrada.\n    Si la puntuación está entre 90 y 100 (inclusive), devuelve 'A'.\n    De lo contrario, devuelve 'B'.\n>>> f_29(90)\nA", "arb": "تقييم الدرجة لعدد صحيح مُدخل.\n    المعلمات:\n- score (int): الدرجة الصحيحة التي سيتم تقييمها.\n    يعيد:\n    char: الدرجة المقابلة للدرجة المُدخلة.\n    إذا كانت الدرجة بين 90 و 100 (شاملة)، يعيد 'A'.\n    خلاف ذلك، يعيد 'B'.\n>>> f_29(90)\nA", "sw": "Tambua daraja kwa nambari kamili iliyoingizwa.\n    Vigezo:\n- score (int): Alama ya nambari kamili itakayopimwa.\n    Inarudisha:\n    char: Daraja linalolingana na alama iliyoingizwa.\n    Ikiwa alama iko kati ya 90 na 100 (ikijumuisha), inarudisha 'A'.\n    Vinginevyo, inarudisha 'B'.\n>>> f_29(90)\nA", "tr": "Girdi tam sayısı için notu değerlendirin.\n    Parametreler:\n- score (int): Değerlendirilecek tam sayı puanı.\n    Döndürür:\n    char: Girdi puanına karşılık gelen not.\n    Eğer puan 90 ile 100 arasında (dahil) ise, 'A' döndürür.\n    Aksi takdirde, 'B' döndürür.\n>>> f_29(90)\nA", "vi": "Đánh giá điểm cho một số nguyên đầu vào.  \n    Tham số:  \n- score (int): Điểm số nguyên cần được đánh giá.  \n    Trả về:  \n    char: Điểm tương ứng với điểm số đầu vào.  \n    Nếu điểm số nằm trong khoảng từ 90 đến 100 (bao gồm cả 90 và 100), trả về 'A'.  \n    Ngược lại, trả về 'B'.  \n>>> f_29(90)  \nA  ", "id": "Evaluasi nilai untuk bilangan bulat masukan.\n    Parameter:\n- score (int): Skor bilangan bulat yang akan dievaluasi.\n    Mengembalikan:\n    char: Nilai yang sesuai dengan skor masukan.\n    Jika skor antara 90 dan 100 (inklusif), mengembalikan 'A'.\n    Jika tidak, mengembalikan 'B'.\n>>> f_29(90)\nA", "ja": "入力された整数の評価を行います。\n    引数:\n- score (int): 評価する整数のスコア。\n    戻り値:\n    char: 入力スコアに対応する成績。\n    スコアが90から100の間（含む）の場合、'A'を返します。\n    それ以外の場合は、'B'を返します。\n>>> f_29(90)\nA", "ko": "입력 정수에 대한 등급을 평가합니다.\n    매개변수:\n- score (int): 평가할 정수 점수입니다.\n    반환:\n    char: 입력 점수에 해당하는 등급입니다.\n    점수가 90과 100 사이(포함)인 경우 'A'를 반환합니다.\n    그렇지 않으면 'B'를 반환합니다.\n>>> f_29(90)\nA", "ml": "ഇൻപുട്ട് ഇന്റിജറിന് ഗ്രേഡ് വിലയിരുത്തുക.  \n    പാരാമീറ്ററുകൾ:  \n- score (int): വിലയിരുത്തേണ്ട ഇന്റിജർ സ്കോർ.  \n    റിട്ടേൺസ്:  \n    char: ഇൻപുട്ട് സ്കോറിനൊത്തുള്ള ഗ്രേഡ്.  \n    സ്കോർ 90നും 100നും (ഉൾപ്പെടെ) ഇടയിൽ ആണെങ്കിൽ, 'A' റിട്ടേൺ ചെയ്യുന്നു.  \n    അല്ലെങ്കിൽ, 'B' റിട്ടേൺ ചെയ്യുന്നു.  \n>>> f_29(90)  \nA  ", "fa": "ارزیابی نمره برای یک عدد صحیح ورودی.\n\nپارامترها:\n- score (int): نمره صحیحی که باید ارزیابی شود.\n\nبازگشت:\nchar: نمره‌ای که با نمره ورودی مطابقت دارد.\nاگر نمره بین 90 و 100 (شامل) باشد، 'A' را برمی‌گرداند.\nدر غیر این صورت، 'B' را برمی‌گرداند.\n\n>>> f_29(90)\nA"}}
{"task_id": "C/30", "prompt": {"en": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nChecks if a three-character string has exactly two characters that are the same.\n​\nArgs:\n    s (char array): The three-character string to be checked.\n​\nReturns:\n    str: Returns 'Yes' if the input has exactly two equal characters, otherwise 'No'.\n\t>>> f_30(112)\n\tYes\n*/\nconst char* f_30(const char s[4])", "sq": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nKontrollon nëse një varg me tre karaktere ka saktësisht dy karaktere që janë të njëjta.\n\nArgumentet:\n    s (varg karakteresh): Vargu me tre karaktere që do të kontrollohet.\n\nKthen:\n    str: Kthen 'Yes' nëse hyrja ka saktësisht dy karaktere të barabarta, përndryshe 'No'.\n\t>>> f_30(112)\n\tYes\n*/\nconst char* f_30(const char s[4])", "hy": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nՍտուգում է, արդյոք երեք նիշից բաղկացած տողում կա՞ն երկու նույնական նիշեր:\n​\nԱրգումենտներ:\n    s (char array): Երեք նիշից բաղկացած տողը, որը պետք է ստուգել:\n​\nՎերադարձնում է:\n    str: Վերադարձնում է 'Yes', եթե մուտքում կա երկու նույնական նիշ, հակառակ դեպքում՝ 'No':\n\t>>> f_30(112)\n\tYes\n*/\nconst char* f_30(const char s[4])", "bn": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nপরীক্ষা করে যে একটি তিন-অক্ষরের স্ট্রিং-এ ঠিক দুটি অক্ষর একই আছে কিনা।\n\nআর্গুমেন্ট:\n    s (char array): তিন-অক্ষরের স্ট্রিং যা পরীক্ষা করা হবে।\n\nফেরত দেয়:\n    str: 'Yes' ফেরত দেয় যদি ইনপুটে ঠিক দুটি সমান অক্ষর থাকে, অন্যথায় 'No'।\n\t>>> f_30(112)\n\tYes\n*/\nconst char* f_30(const char s[4])", "bg": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nПроверява дали низ от три знака има точно два еднакви знака.\n​\nАргументи:\n    s (масив от знаци): Низът от три знака, който трябва да бъде проверен.\n​\nВръща:\n    str: Връща 'Yes', ако входът има точно два еднакви знака, в противен случай 'No'.\n\t>>> f_30(112)\n\tYes\n*/\nconst char* f_30(const char s[4])", "zh": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n检查一个三字符字符串是否恰好有两个相同的字符。\n\n参数:\n    s (char array): 要检查的三字符字符串。\n\n返回:\n    str: 如果输入恰好有两个相同的字符，则返回 'Yes'，否则返回 'No'。\n\t>>> f_30(112)\n\tYes\n*/\nconst char* f_30(const char s[4])", "fr": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nVérifie si une chaîne de trois caractères a exactement deux caractères identiques.\n\nArgs:\n    s (char array): La chaîne de trois caractères à vérifier.\n\nReturns:\n    str: Retourne 'Yes' si l'entrée a exactement deux caractères égaux, sinon 'No'.\n\t>>> f_30(112)\n\tYes\n*/\nconst char* f_30(const char s[4])", "de": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nPrüft, ob ein dreistelliger String genau zwei gleiche Zeichen hat.\n\nArgumente:\n    s (char array): Der zu überprüfende dreistellige String.\n\nRückgabewerte:\n    str: Gibt 'Yes' zurück, wenn der Eingabewert genau zwei gleiche Zeichen hat, andernfalls 'No'.\n\t>>> f_30(112)\n\tYes\n*/\nconst char* f_30(const char s[4])", "ha": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDuba idan kirtani mai haruffa uku yana da daidai haruffa biyu da suke iri ɗaya.\n​\nArgs:\n    s (char array): Kirtani mai haruffa uku da za a duba.\n​\nReturns:\n    str: Ya dawo da 'Yes' idan shigarwar tana da daidai haruffa biyu masu daidaituwa, in ba haka ba 'No'.\n\t>>> f_30(112)\n\tYes\n*/\nconst char* f_30(const char s[4])", "hi": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nजांचता है कि क्या तीन-अक्षरों की स्ट्रिंग में ठीक दो अक्षर समान हैं।\n\nआर्ग्स:\n    s (char array): तीन-अक्षरों की स्ट्रिंग जिसे जांचा जाना है।\n\nरिटर्न्स:\n    str: 'Yes' लौटाता है यदि इनपुट में ठीक दो समान अक्षर हैं, अन्यथा 'No'।\n\t>>> f_30(112)\n\tYes\n*/\nconst char* f_30(const char s[4])", "hu": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nEllenőrzi, hogy egy három karakterből álló karakterláncban pontosan két azonos karakter van-e.\n\nArgumentumok:\n    s (karakter tömb): Az ellenőrizendő három karakterből álló karakterlánc.\n\nVisszatér:\n    str: 'Yes'-t ad vissza, ha a bemenetben pontosan két egyenlő karakter van, különben 'No'-t.\n\t>>> f_30(112)\n\tYes\n*/\nconst char* f_30(const char s[4])", "es": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nVerifica si una cadena de tres caracteres tiene exactamente dos caracteres que son iguales.\n\nArgs:\n    s (char array): La cadena de tres caracteres a verificar.\n\nReturns:\n    str: Devuelve 'Yes' si la entrada tiene exactamente dos caracteres iguales, de lo contrario 'No'.\n\t>>> f_30(112)\n\tYes\n*/\nconst char* f_30(const char s[4])", "arb": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nيتحقق مما إذا كانت سلسلة مكونة من ثلاثة أحرف تحتوي على حرفين متشابهين بالضبط.\n\nArgs:\n    s (مصفوفة char): السلسلة المكونة من ثلاثة أحرف التي سيتم التحقق منها.\n\nالإرجاع:\n    str: يعيد 'Yes' إذا كانت المدخلات تحتوي على حرفين متساويين بالضبط، وإلا يعيد 'No'.\n\t>>> f_30(112)\n\tYes\n*/\nconst char* f_30(const char s[4])", "sw": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nHukagua kama mfuatano wa herufi tatu una herufi mbili ambazo ni sawa.\n​\nArgs:\n    s (char array): Mfuatano wa herufi tatu unaopaswa kukaguliwa.\n​\nReturns:\n    str: Inarudisha 'Yes' ikiwa ingizo lina herufi mbili sawa, vinginevyo 'No'.\n\t>>> f_30(112)\n\tYes\n*/\nconst char* f_30(const char s[4])", "tr": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nÜç karakterli bir dizgede tam olarak iki karakterin aynı olup olmadığını kontrol eder.\n\nArgs:\n    s (char dizisi): Kontrol edilecek üç karakterli dizge.\n\nDöndürür:\n    str: Girdi tam olarak iki eşit karaktere sahipse 'Yes' döndürür, aksi takdirde 'No' döndürür.\n\t>>> f_30(112)\n\tYes\n*/\nconst char* f_30(const char s[4])", "vi": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nKiểm tra xem một chuỗi ba ký tự có chính xác hai ký tự giống nhau hay không.\n\nArgs:\n    s (mảng char): Chuỗi ba ký tự cần được kiểm tra.\n\nTrả về:\n    str: Trả về 'Yes' nếu đầu vào có chính xác hai ký tự giống nhau, nếu không thì 'No'.\n\t>>> f_30(112)\n\tYes\n*/\nconst char* f_30(const char s[4])", "id": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nMemeriksa apakah sebuah string tiga karakter memiliki tepat dua karakter yang sama.\n\nArgumen:\n    s (array char): String tiga karakter yang akan diperiksa.\n\nMengembalikan:\n    str: Mengembalikan 'Yes' jika input memiliki tepat dua karakter yang sama, jika tidak 'No'.\n\t>>> f_30(112)\n\tYes\n*/\nconst char* f_30(const char s[4])", "ja": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n3文字の文字列に、正確に2つの同じ文字が含まれているかを確認します。\n\n引数:\n    s (char array): チェックする3文字の文字列。\n\n戻り値:\n    str: 入力に正確に2つの等しい文字が含まれている場合は 'Yes' を返し、それ以外の場合は 'No' を返します。\n\t>>> f_30(112)\n\tYes\n*/\nconst char* f_30(const char s[4])", "ko": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n세 문자로 구성된 문자열에 정확히 두 개의 동일한 문자가 있는지 확인합니다.\n​\n인수:\n    s (char array): 확인할 세 문자로 구성된 문자열입니다.\n​\n반환:\n    str: 입력에 정확히 두 개의 동일한 문자가 있으면 'Yes'를 반환하고, 그렇지 않으면 'No'를 반환합니다.\n\t>>> f_30(112)\n\tYes\n*/\nconst char* f_30(const char s[4])", "ml": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nമൂന്ന് അക്ഷരങ്ങളുള്ള ഒരു സ്ട്രിംഗ് കൃത്യമായി രണ്ട് അക്ഷരങ്ങൾ ഒരേപോലെയാണോ എന്ന് പരിശോധിക്കുന്നു.\n\nആർഗ്യുമെന്റുകൾ:\n    s (char array): പരിശോധിക്കേണ്ട മൂന്ന് അക്ഷരങ്ങളുള്ള സ്ട്രിംഗ്.\n\nമടക്കുന്നു:\n    str: ഇൻപുട്ടിൽ കൃത്യമായി രണ്ട് സമാന അക്ഷരങ്ങൾ ഉണ്ടെങ്കിൽ 'Yes' മടക്കുന്നു, അല്ലെങ്കിൽ 'No'.\n\t>>> f_30(112)\n\tYes\n*/\nconst char* f_30(const char s[4])", "fa": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nبررسی می‌کند که آیا یک رشته سه‌کاراکتری دقیقاً دو کاراکتر مشابه دارد یا خیر.\n\nآرگومان‌ها:\n    s (آرایه کاراکتر): رشته سه‌کاراکتری که باید بررسی شود.\n\nبازگشت:\n    str: 'Yes' را برمی‌گرداند اگر ورودی دقیقاً دو کاراکتر برابر داشته باشد، در غیر این صورت 'No'.\n\t>>> f_30(112)\n\tYes\n*/\nconst char* f_30(const char s[4])\n"}, "canonical_solution": "{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}", "instruction": {"en": "Write a C function `const char* f_30(const char s[4])` to solve the following problem:\nChecks if a three-character string has exactly two characters that are the same.\n\nArgs:\n    s (char array): The three-character string to be checked.\n\nReturns:\n    str: Returns 'Yes' if the input has exactly two equal characters, otherwise 'No'.\n    >>> f_30(112)\n    Yes\n", "sq": "Shkruani një funksion në C `const char* f_30(const char s[4])` për të zgjidhur problemin në vijim:\nKontrollon nëse një varg me tre karaktere ka saktësisht dy karaktere që janë të njëjta.\n\nArgumentet:\n    s (varg karakteresh): Vargu me tre karaktere që do të kontrollohet.\n\nKthen:\n    str: Kthen 'Yes' nëse hyrja ka saktësisht dy karaktere të barabarta, përndryshe 'No'.\n    >>> f_30(112)\n    Yes", "hy": "Գրեք C ֆունկցիա `const char* f_30(const char s[4])` հետևյալ խնդիրը լուծելու համար:\nՍտուգում է, արդյոք երեք նիշից բաղկացած տողը ունի՞ հենց երկու նույն նիշ:\n\nԱրձագանքներ:\n    s (char զանգված): Երեք նիշից բաղկացած տողը, որը պետք է ստուգել:\n\nՎերադարձնում է:\n    str: Վերադարձնում է 'Yes', եթե մուտքում կա հենց երկու նույն նիշ, հակառակ դեպքում՝ 'No':\n    >>> f_30(112)\n    Yes", "bn": "একটি C ফাংশন `const char* f_30(const char s[4])` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nপরীক্ষা করে যে একটি তিন-অক্ষরের স্ট্রিং-এ ঠিক দুটি অক্ষর একই কিনা।\n\nআর্গুমেন্টসমূহ:\n    s (char array): তিন-অক্ষরের স্ট্রিং যা পরীক্ষা করা হবে।\n\nরিটার্নস:\n    str: 'Yes' রিটার্ন করে যদি ইনপুটে ঠিক দুটি সমান অক্ষর থাকে, অন্যথায় 'No'।\n    >>> f_30(112)\n    Yes", "bg": "Напишете C функция `const char* f_30(const char s[4])`, за да решите следния проблем:\nПроверява дали низ с три знака има точно два еднакви знака.\n\nАргументи:\n    s (char array): Низът с три знака, който трябва да бъде проверен.\n\nВръща:\n    str: Връща 'Yes', ако входът има точно два еднакви знака, в противен случай 'No'.\n    >>> f_30(112)\n    Yes", "zh": "编写一个 C 函数 `const char* f_30(const char s[4])` 来解决以下问题：\n检查一个三字符字符串是否有且仅有两个字符相同。\n\n参数:\n    s (char array): 要检查的三字符字符串。\n\n返回:\n    str: 如果输入有且仅有两个相同的字符，则返回 'Yes'，否则返回 'No'。\n    >>> f_30(112)\n    Yes", "fr": "Écrire une fonction C `const char* f_30(const char s[4])` pour résoudre le problème suivant:\nVérifie si une chaîne de trois caractères a exactement deux caractères identiques.\n\nArgs :  \n    s (tableau de char) : La chaîne de trois caractères à vérifier.\n\nRenvoie :  \n    str : Renvoie 'Yes' si l'entrée a exactement deux caractères égaux, sinon 'No'.  \n    >>> f_30(112)  \n    Yes  ", "de": "Schreiben Sie eine C-Funktion `const char* f_30(const char s[4])`, um das folgende Problem zu lösen:\nÜberprüft, ob ein drei Zeichen langer String genau zwei gleiche Zeichen hat.\n\nArgumente:\n    s (char array): Der drei Zeichen lange String, der überprüft werden soll.\n\nRückgabewerte:\n    str: Gibt 'Yes' zurück, wenn der Eingabewert genau zwei gleiche Zeichen hat, ansonsten 'No'.\n    >>> f_30(112)\n    Yes", "ha": "Rubuta aikin C `const char* f_30(const char s[4])` don warware matsalar mai zuwa:\nDuba idan wani kirtani mai haruffa uku yana da daidai haruffa biyu da suke iri ɗaya.\n\nArgs:\n    s (char array): Kirtani mai haruffa uku da za a duba.\n\nReturns:\n    str: Ya dawo da 'Yes' idan shigarwar tana da daidai haruffa biyu iri ɗaya, in ba haka ba 'No'.\n    >>> f_30(112)\n    Yes", "hi": "C फ़ंक्शन `const char* f_30(const char s[4])` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nजाँच करता है कि क्या तीन-अक्षर की स्ट्रिंग में ठीक दो अक्षर समान हैं।\n\nआर्ग्स:\n    s (char array): तीन-अक्षर की स्ट्रिंग जिसे जाँचना है।\n\nरिटर्न्स:\n    str: 'Yes' लौटाता है यदि इनपुट में ठीक दो समान अक्षर हैं, अन्यथा 'No'।\n    >>> f_30(112)\n    Yes", "hu": "Írj egy C függvényt `const char* f_30(const char s[4])` a következő probléma megoldására:\nEllenőrzi, hogy egy három karakterből álló stringben pontosan két azonos karakter van-e.\n\nArgs:\n    s (char array): Az ellenőrizendő három karakterből álló string.\n\nReturns:\n    str: 'Yes'-t ad vissza, ha a bemenetnek pontosan két egyenlő karaktere van, különben 'No'-t.\n    >>> f_30(112)\n    Yes", "es": "Escribe una función en C `const char* f_30(const char s[4])` para resolver el siguiente problema:\nVerifica si una cadena de tres caracteres tiene exactamente dos caracteres que son iguales.\n\nArgs:\n    s (char array): La cadena de tres caracteres a verificar.\n\nReturns:\n    str: Devuelve 'Yes' si la entrada tiene exactamente dos caracteres iguales, de lo contrario 'No'.\n    >>> f_30(112)\n    Yes", "arb": "اكتب دالة بلغة C `const char* f_30(const char s[4])` لحل المشكلة التالية:\nيتحقق مما إذا كانت سلسلة مكونة من ثلاثة أحرف تحتوي على حرفين متطابقين بالضبط.\n\nArgs:\n    s (char array): السلسلة المكونة من ثلاثة أحرف التي سيتم التحقق منها.\n\nReturns:\n    str: يعيد 'Yes' إذا كانت المدخلات تحتوي على حرفين متطابقين بالضبط، وإلا يعيد 'No'.\n    >>> f_30(112)\n    Yes", "sw": "Andika kazi ya C `const char* f_30(const char s[4])` kutatua tatizo lifuatalo:\nInakagua kama kamba yenye herufi tatu ina herufi mbili ambazo ni sawa.\n\nArgs:\n    s (char array): Kamba yenye herufi tatu itakayokaguliwa.\n\nReturns:\n    str: Inarudisha 'Yes' ikiwa ingizo lina herufi mbili sawa, vinginevyo 'No'.\n    >>> f_30(112)\n    Yes", "tr": "Bir C fonksiyonu `const char* f_30(const char s[4])` yazın:\nÜç karakterli bir dizgede tam olarak iki karakterin aynı olup olmadığını kontrol eder.\n\nArgs:\n    s (char array): Kontrol edilecek üç karakterli dizge.\n\nReturns:\n    str: Girdi tam olarak iki eşit karaktere sahipse 'Yes' döndürür, aksi takdirde 'No' döndürür.\n    >>> f_30(112)\n    Yes", "vi": "Viết một hàm C `const char* f_30(const char s[4])` để giải quyết vấn đề sau:\nKiểm tra xem một chuỗi ba ký tự có chính xác hai ký tự giống nhau hay không.\n\nArgs:\n    s (mảng ký tự): Chuỗi ba ký tự cần được kiểm tra.\n\nReturns:\n    str: Trả về 'Yes' nếu đầu vào có chính xác hai ký tự giống nhau, ngược lại 'No'.\n    >>> f_30(112)\n    Yes", "id": "Tulis fungsi C `const char* f_30(const char s[4])` untuk menyelesaikan masalah berikut:\nMemeriksa apakah sebuah string tiga karakter memiliki tepat dua karakter yang sama.\n\nArgumen:\n    s (char array): String tiga karakter yang akan diperiksa.\n\nMengembalikan:\n    str: Mengembalikan 'Yes' jika input memiliki tepat dua karakter yang sama, jika tidak 'No'.\n    >>> f_30(112)\n    Yes", "ja": "Cの関数を書け `const char* f_30(const char s[4])` を作成して、次の問題を解決してください:\n3文字の文字列に、正確に2つの同じ文字が含まれているかどうかを確認します。\n\n引数:\n    s (char配列): チェックする3文字の文字列。\n\n戻り値:\n    str: 入力に正確に2つの同じ文字が含まれている場合は 'Yes' を返し、それ以外の場合は 'No' を返します。\n    >>> f_30(112)\n    Yes", "ko": "C 함수 `const char* f_30(const char s[4])`를 작성하여 다음 문제를 해결하십시오:\n세 문자로 구성된 문자열에 정확히 두 개의 동일한 문자가 있는지 확인합니다.\n\n매개변수:\n    s (char 배열): 확인할 세 문자로 구성된 문자열입니다.\n\n반환값:\n    str: 입력에 정확히 두 개의 동일한 문자가 있으면 'Yes'를 반환하고, 그렇지 않으면 'No'를 반환합니다.\n    >>> f_30(112)\n    Yes", "ml": "C ഭാഷയിൽ ഒരു ഫംഗ്ഷൻ `const char* f_30(const char s[4])` എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nമൂന്ന് അക്ഷരങ്ങളുള്ള ഒരു സ്ട്രിംഗ്‌ക്ക് കൃത്യമായി രണ്ട് അക്ഷരങ്ങൾ ഒരേപോലെയാണോ എന്ന് പരിശോധിക്കുന്നു.\n\nആർഗുകൾ:\n    s (char array): പരിശോധിക്കേണ്ട മൂന്ന് അക്ഷരങ്ങളുള്ള സ്ട്രിംഗ്.\n\nമടക്കുക:\n    str: ഇൻപുട്ടിന് കൃത്യമായി രണ്ട് സമാനമായ അക്ഷരങ്ങൾ ഉണ്ടെങ്കിൽ 'Yes' മടക്കുന്നു, അല്ലെങ്കിൽ 'No'.\n    >>> f_30(112)\n    Yes", "fa": "یک تابع C به نام `const char* f_30(const char s[4])` بنویسید تا مسئله زیر را حل کند:\nبررسی می‌کند که آیا یک رشته سه‌کاراکتری دقیقاً دو کاراکتر مشابه دارد یا خیر.\n\nآرگومان‌ها:\n    s (آرایه کاراکتر): رشته سه‌کاراکتری که باید بررسی شود.\n\nبازگشت:\n    str: 'Yes' را برمی‌گرداند اگر ورودی دقیقاً دو کاراکتر برابر داشته باشد، در غیر این صورت 'No' را برمی‌گرداند.\n    >>> f_30(112)\n    Yes"}, "level": "easy", "test": "int main() {\n    // Testing the logic with various cases and using string comparison for assert.\n    assert(strcmp(f_30(\"112\"), \"Yes\") == 0);\n    assert(strcmp(f_30(\"123\"), \"No\") == 0);\n    assert(strcmp(f_30(\"232\"), \"Yes\") == 0);\n    assert(strcmp(f_30(\"444\"), \"No\") == 0); // All three characters are equal, not two.\n    assert(strcmp(f_30(\"121\"), \"Yes\") == 0);\n\n    // Additional test cases to cover more scenarios\n    assert(strcmp(f_30(\"787\"), \"Yes\") == 0);\n    assert(strcmp(f_30(\"999\"), \"No\") == 0); // All three characters are equal\n    assert(strcmp(f_30(\"890\"), \"No\") == 0);\n    assert(strcmp(f_30(\"556\"), \"Yes\") == 0);\n    assert(strcmp(f_30(\"353\"), \"Yes\") == 0); // No two characters are equal\n\n    \n    return 0;\n}", "entry_point": "f_30", "signature": "const char* f_30(const char s[4])", "docstring": {"en": "Checks if a three-character string has exactly two characters that are the same.\n\nArgs:\n    s (char array): The three-character string to be checked.\n\nReturns:\n    str: Returns 'Yes' if the input has exactly two equal characters, otherwise 'No'.\n    >>> f_30(112)\n    Yes\n", "sq": "Kontrollon nëse një varg me tre karaktere ka saktësisht dy karaktere që janë të njëjta.\n\nArgs:\n    s (char array): Vargu me tre karaktere që do të kontrollohet.\n\nReturns:\n    str: Kthen 'Yes' nëse inputi ka saktësisht dy karaktere të barabarta, përndryshe 'No'.\n    >>> f_30(112)\n    Yes", "hy": "Երեք նիշից բաղկացած տողում ստուգում է, արդյոք կա՞ն երկու նույնական նիշեր։\n\nԱրձ.:\n    s (char array): Երեք նիշից բաղկացած տողը, որը պետք է ստուգել։\n\nՎերադարձնում է:\n    str: Վերադարձնում է 'Yes', եթե մուտքագրումը ունի երկու նույնական նիշ, հակառակ դեպքում՝ 'No'։\n    >>> f_30(112)\n    Yes", "bn": "তিন-অক্ষরের একটি স্ট্রিং-এ ঠিক দুটি অক্ষর একই আছে কিনা তা পরীক্ষা করে।\n\nArgs:\n    s (char array): যে তিন-অক্ষরের স্ট্রিংটি পরীক্ষা করা হবে।\n\nReturns:\n    str: যদি ইনপুটে ঠিক দুটি সমান অক্ষর থাকে তবে 'Yes' ফেরত দেয়, অন্যথায় 'No'।\n    >>> f_30(112)\n    Yes", "bg": "Проверява дали низ с три знака има точно два еднакви знака.\n\nАргументи:\n    s (char array): Тристепенният низ, който трябва да бъде проверен.\n\nВръща:\n    str: Връща 'Yes', ако входът има точно два еднакви знака, в противен случай 'No'.\n    >>> f_30(112)\n    Yes", "zh": "检查一个三字符字符串是否恰好有两个字符相同。\n\n参数：\n    s (char array): 要检查的三字符字符串。\n\n返回：\n    str: 如果输入恰好有两个相同的字符，则返回 'Yes'，否则返回 'No'。\n    >>> f_30(112)\n    Yes", "fr": "Vérifie si une chaîne de trois caractères a exactement deux caractères identiques.\n\nArgs:\n    s (char array): La chaîne de trois caractères à vérifier.\n\nReturns:\n    str: Renvoie 'Yes' si l'entrée a exactement deux caractères égaux, sinon 'No'.\n    >>> f_30(112)\n    Yes", "de": "Prüft, ob ein dreistelliger String genau zwei gleiche Zeichen hat.\n\nArgs:\n    s (char array): Der dreistellige String, der überprüft werden soll.\n\nReturns:\n    str: Gibt 'Yes' zurück, wenn der Eingabewert genau zwei gleiche Zeichen hat, andernfalls 'No'.\n    >>> f_30(112)\n    Yes", "ha": "Duba idan wani igiyar haruffa mai haruffa uku yana daidai da haruffa biyu waɗanda suke daidai.\n\nArgs:\n    s (char array): Igiyar haruffa mai haruffa uku da za a duba.\n\nReturns:\n    str: Ya dawo da 'Yes' idan shigarwar tana daidai da haruffa biyu masu daidai, in ba haka ba 'No'.\n    >>> f_30(112)\n    Yes", "hi": "तीन-अक्षरों की स्ट्रिंग में जांच करता है कि क्या इसमें ठीक दो अक्षर समान हैं।\n\nआर्ग्स:\n    s (char array): तीन-अक्षरों की स्ट्रिंग जिसे जांचा जाना है।\n\nरिटर्न्स:\n    str: 'Yes' लौटाता है यदि इनपुट में ठीक दो समान अक्षर हैं, अन्यथा 'No'।\n    >>> f_30(112)\n    Yes", "hu": "Ellenőrzi, hogy egy három karakteres karakterláncban pontosan két azonos karakter van-e.\n\nArgs:\n    s (char array): A három karakteres karakterlánc, amelyet ellenőrizni kell.\n\nReturns:\n    str: 'Yes' értéket ad vissza, ha a bemenetben pontosan két egyenlő karakter van, különben 'No'.\n    >>> f_30(112)\n    Yes", "es": "Verifica si una cadena de tres caracteres tiene exactamente dos caracteres que son iguales.\n\nArgs:\n    s (char array): La cadena de tres caracteres que se va a verificar.\n\nReturns:\n    str: Devuelve 'Yes' si la entrada tiene exactamente dos caracteres iguales, de lo contrario 'No'.\n    >>> f_30(112)\n    Yes", "arb": "يتحقق مما إذا كانت سلسلة مكونة من ثلاثة أحرف تحتوي على حرفين متطابقين بالضبط.\n\nArgs:\n    s (char array): سلسلة مكونة من ثلاثة أحرف للتحقق منها.\n\nReturns:\n    str: يعيد 'Yes' إذا كانت المدخلات تحتوي على حرفين متساويين بالضبط، وإلا يعيد 'No'.\n    >>> f_30(112)\n    Yes", "sw": "Hukagua kama mfuatano wa herufi tatu una herufi mbili sawa.\n\nArgs:\n    s (char array): Mfuatano wa herufi tatu unaopaswa kukaguliwa.\n\nReturns:\n    str: Inarudisha 'Yes' ikiwa ingizo lina herufi mbili sawa, vinginevyo 'No'.\n    >>> f_30(112)\n    Yes", "tr": "Üç karakterli bir dizgide tam olarak iki karakterin aynı olup olmadığını kontrol eder.\n\nArgs:\n    s (char array): Kontrol edilecek üç karakterli dizi.\n\nReturns:\n    str: Girdi tam olarak iki eşit karaktere sahipse 'Yes' döner, aksi takdirde 'No' döner.\n    >>> f_30(112)\n    Yes", "vi": "Kiểm tra xem một chuỗi ba ký tự có chính xác hai ký tự giống nhau hay không.\n\nArgs:\n    s (char array): Chuỗi ba ký tự cần được kiểm tra.\n\nReturns:\n    str: Trả về 'Yes' nếu đầu vào có chính xác hai ký tự bằng nhau, nếu không thì 'No'.\n    >>> f_30(112)\n    Yes", "id": "Memeriksa apakah string tiga karakter memiliki tepat dua karakter yang sama.\n\nArgs:\n    s (char array): String tiga karakter yang akan diperiksa.\n\nReturns:\n    str: Mengembalikan 'Yes' jika input memiliki tepat dua karakter yang sama, jika tidak 'No'.\n    >>> f_30(112)\n    Yes", "ja": "3文字の文字列に、正確に2つの同じ文字が含まれているかどうかを確認します。\n\n引数:\n    s (char array): チェックする3文字の文字列。\n\n戻り値:\n    str: 入力に正確に2つの等しい文字が含まれている場合は 'Yes' を返し、それ以外の場合は 'No' を返します。\n    >>> f_30(112)\n    Yes", "ko": "세 글자 문자열에 정확히 두 문자가 같은지 확인합니다.\n\n인수:\n    s (char array): 확인할 세 글자 문자열입니다.\n\n반환:\n    str: 입력에 정확히 두 개의 동일한 문자가 있으면 'Yes'를 반환하고, 그렇지 않으면 'No'를 반환합니다.\n    >>> f_30(112)\n    Yes", "ml": "മൂന്ന് അക്ഷരങ്ങളുള്ള ഒരു സ്ട്രിംഗിൽ കൃത്യമായി രണ്ട് അക്ഷരങ്ങൾ ഒരേപോലെയാണോ എന്ന് പരിശോധിക്കുന്നു.\n\nആർഗ്സ്:\n    s (char array): പരിശോധിക്കേണ്ട മൂന്ന് അക്ഷരങ്ങളുള്ള സ്ട്രിംഗ്.\n\nമടക്കം:\n    str: ഇൻപുട്ടിൽ കൃത്യമായി രണ്ട് സമാനമായ അക്ഷരങ്ങൾ ഉണ്ടെങ്കിൽ 'Yes' മടക്കുന്നു, അല്ലെങ്കിൽ 'No'.\n    >>> f_30(112)\n    Yes", "fa": "بررسی می‌کند که آیا یک رشته سه‌کاراکتری دقیقاً دو کاراکتر مشابه دارد یا خیر.\n\nآرگومان‌ها:\n    s (char array): رشته سه‌کاراکتری که باید بررسی شود.\n\nبازگشت:\n    str: 'Yes' را برمی‌گرداند اگر ورودی دقیقاً دو کاراکتر برابر داشته باشد، در غیر این صورت 'No'.\n    >>> f_30(112)\n    Yes"}}
{"task_id": "C/31", "prompt": {"en": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nGiven a string consisting of lowercase English letters, in each round you can change one of the characters to another character. The question is: what is the minimum number of rounds needed to make the string composed of the same character?\nFor example:\n    >>> f_31(\"aab\")\n    1\n    >>> f_31(\"abc\")\n    2\n    >>> f_31(\"aaa\")\n    0\n*/\nint f_31(const char* s)", "sq": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDuke pasur një varg që përbëhet nga shkronja të vogla të anglishtes, në çdo raund mund të ndryshoni njërin nga karakteret në një karakter tjetër. Pyetja është: cili është numri minimal i raundeve të nevojshme për ta bërë vargun të përbërë nga i njëjti karakter?\nPër shembull:\n    >>> f_31(\"aab\")\n    1\n    >>> f_31(\"abc\")\n    2\n    >>> f_31(\"aaa\")\n    0\n*/\nint f_31(const char* s)", "hy": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nՈւնենալով տող, որը բաղկացած է փոքրատառ անգլերեն տառերից, յուրաքանչյուր փուլում դուք կարող եք փոխել տառերից մեկը մեկ այլ տառով: Հարցն այն է՝ ինչքա՞ն է նվազագույն փուլերի քանակը, որը անհրաժեշտ է դարձնելու համար տողը բաղկացած նույն տառից:\nՕրինակ՝\n    >>> f_31(\"aab\")\n    1\n    >>> f_31(\"abc\")\n    2\n    >>> f_31(\"aaa\")\n    0\n*/\nint f_31(const char* s)", "bn": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nএকটি স্ট্রিং দেওয়া হয়েছে যা ছোট হাতের ইংরেজি অক্ষর নিয়ে গঠিত, প্রতিটি রাউন্ডে আপনি একটি অক্ষরকে অন্য অক্ষরে পরিবর্তন করতে পারেন। প্রশ্ন হল: স্ট্রিংটিকে একই অক্ষর দিয়ে গঠিত করতে ন্যূনতম কত রাউন্ড প্রয়োজন?\nউদাহরণস্বরূপ:\n    >>> f_31(\"aab\")\n    1\n    >>> f_31(\"abc\")\n    2\n    >>> f_31(\"aaa\")\n    0\n*/\nint f_31(const char* s)", "bg": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nДаден е низ, състоящ се от малки английски букви, като във всеки рунд можете да промените един от символите на друг символ. Въпросът е: какъв е минималният брой рундове, необходими, за да се направи низът съставен от един и същ символ?\nНапример:\n    >>> f_31(\"aab\")\n    1\n    >>> f_31(\"abc\")\n    2\n    >>> f_31(\"aaa\")\n    0\n*/\nint f_31(const char* s)", "zh": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\n给定一个由小写英文字母组成的字符串，每一轮你可以将其中一个字符更改为另一个字符。问题是：使字符串由相同字符组成所需的最少轮数是多少？\n例如：\n    >>> f_31(\"aab\")\n    1\n    >>> f_31(\"abc\")\n    2\n    >>> f_31(\"aaa\")\n    0\n*/\nint f_31(const char* s)", "fr": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nÉtant donné une chaîne composée de lettres minuscules anglaises, à chaque tour, vous pouvez changer l'un des caractères en un autre caractère. La question est : quel est le nombre minimum de tours nécessaires pour que la chaîne soit composée du même caractère ?\nPar exemple :\n    >>> f_31(\"aab\")\n    1\n    >>> f_31(\"abc\")\n    2\n    >>> f_31(\"aaa\")\n    0\n*/\nint f_31(const char* s)", "de": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nGegeben ist ein String, der aus Kleinbuchstaben des englischen Alphabets besteht. In jeder Runde kann man eines der Zeichen in ein anderes Zeichen ändern. Die Frage ist: Was ist die minimale Anzahl von Runden, die benötigt werden, um den String aus demselben Zeichen bestehen zu lassen?\nZum Beispiel:\n    >>> f_31(\"aab\")\n    1\n    >>> f_31(\"abc\")\n    2\n    >>> f_31(\"aaa\")\n    0\n*/\nint f_31(const char* s)", "ha": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nAn ba da wani kirtani da ya ƙunshi ƙananan haruffan Ingilishi, a kowace zagaye za ka iya canza ɗaya daga cikin haruffan zuwa wani harafi. Tambayar ita ce: menene mafi ƙarancin adadin zagaye da ake buƙata don sanya kirtani ya ƙunshi harafi ɗaya kawai?\nAlal misali:\n    >>> f_31(\"aab\")\n    1\n    >>> f_31(\"abc\")\n    2\n    >>> f_31(\"aaa\")\n    0\n*/\nint f_31(const char* s)", "hi": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nदिए गए स्ट्रिंग में छोटे अंग्रेजी अक्षर होते हैं, प्रत्येक राउंड में आप एक अक्षर को दूसरे अक्षर में बदल सकते हैं। प्रश्न यह है: स्ट्रिंग को एक ही अक्षर से मिलकर बनाने के लिए न्यूनतम कितने राउंड की आवश्यकता है?\nउदाहरण के लिए:\n    >>> f_31(\"aab\")\n    1\n    >>> f_31(\"abc\")\n    2\n    >>> f_31(\"aaa\")\n    0\n*/\nint f_31(const char* s)", "hu": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nAdott egy kisbetűs angol betűkből álló karakterlánc, minden körben megváltoztathatod az egyik karaktert egy másik karakterre. A kérdés az: mi a minimális körök száma, amely szükséges ahhoz, hogy a karakterlánc ugyanabból a karakterből álljon?\nPéldául:\n    >>> f_31(\"aab\")\n    1\n    >>> f_31(\"abc\")\n    2\n    >>> f_31(\"aaa\")\n    0\n*/\nint f_31(const char* s)", "es": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDada una cadena compuesta por letras minúsculas del alfabeto inglés, en cada ronda puedes cambiar uno de los caracteres a otro carácter. La pregunta es: ¿cuál es el número mínimo de rondas necesarias para hacer que la cadena esté compuesta por el mismo carácter?\nPor ejemplo:\n    >>> f_31(\"aab\")\n    1\n    >>> f_31(\"abc\")\n    2\n    >>> f_31(\"aaa\")\n    0\n*/\nint f_31(const char* s)", "arb": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nبالنظر إلى سلسلة تتكون من أحرف إنجليزية صغيرة، في كل جولة يمكنك تغيير أحد الأحرف إلى حرف آخر. السؤال هو: ما هو الحد الأدنى لعدد الجولات اللازمة لجعل السلسلة مكونة من نفس الحرف؟\nعلى سبيل المثال:\n    >>> f_31(\"aab\")\n    1\n    >>> f_31(\"abc\")\n    2\n    >>> f_31(\"aaa\")\n    0\n*/\nint f_31(const char* s)", "sw": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nUkipiwa kamba inayojumuisha herufi ndogo za Kiingereza, katika kila raundi unaweza kubadilisha moja ya herufi kuwa herufi nyingine. Swali ni: ni idadi gani ndogo ya raundi zinazohitajika ili kufanya kamba iwe na herufi sawa?\nKwa mfano:\n    >>> f_31(\"aab\")\n    1\n    >>> f_31(\"abc\")\n    2\n    >>> f_31(\"aaa\")\n    0\n*/\nint f_31(const char* s)", "tr": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nKüçük İngiliz harflerinden oluşan bir dize verildiğinde, her turda karakterlerden birini başka bir karakterle değiştirebilirsiniz. Soru şu: Diziyi aynı karakterden oluşacak şekilde yapmak için gereken minimum tur sayısı nedir?\nÖrneğin:\n    >>> f_31(\"aab\")\n    1\n    >>> f_31(\"abc\")\n    2\n    >>> f_31(\"aaa\")\n    0\n*/\nint f_31(const char* s)", "vi": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCho một chuỗi bao gồm các chữ cái tiếng Anh viết thường, trong mỗi lượt bạn có thể thay đổi một trong các ký tự thành ký tự khác. Câu hỏi là: cần tối thiểu bao nhiêu lượt để làm cho chuỗi được tạo thành từ cùng một ký tự?\nVí dụ:\n    >>> f_31(\"aab\")\n    1\n    >>> f_31(\"abc\")\n    2\n    >>> f_31(\"aaa\")\n    0\n*/\nint f_31(const char* s)", "id": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDiberikan sebuah string yang terdiri dari huruf kecil bahasa Inggris, dalam setiap putaran Anda dapat mengubah salah satu karakter menjadi karakter lain. Pertanyaannya adalah: berapa jumlah putaran minimum yang diperlukan untuk membuat string tersebut terdiri dari karakter yang sama?\nSebagai contoh:\n    >>> f_31(\"aab\")\n    1\n    >>> f_31(\"abc\")\n    2\n    >>> f_31(\"aaa\")\n    0\n*/\nint f_31(const char* s)", "ja": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\n小文字の英字からなる文字列が与えられたとき、各ラウンドで文字の1つを別の文字に変更することができます。質問は、文字列を同じ文字で構成するために必要な最小ラウンド数は何ですか？\n例えば:\n    >>> f_31(\"aab\")\n    1\n    >>> f_31(\"abc\")\n    2\n    >>> f_31(\"aaa\")\n    0\n*/\nint f_31(const char* s)", "ko": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\n소문자 영어 문자로 구성된 문자열이 주어졌을 때, 각 라운드마다 문자 중 하나를 다른 문자로 변경할 수 있습니다. 문자열을 동일한 문자로 구성하기 위해 필요한 최소 라운드 수는 얼마입니까?\n예를 들어:\n    >>> f_31(\"aab\")\n    1\n    >>> f_31(\"abc\")\n    2\n    >>> f_31(\"aaa\")\n    0\n*/\nint f_31(const char* s)", "ml": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nലോവർകേസ് ഇംഗ്ലീഷ് അക്ഷരങ്ങൾ അടങ്ങിയ ഒരു സ്ട്രിംഗ് നൽകിയിരിക്കുന്നു, ഓരോ റൗണ്ടിലും നിങ്ങൾക്ക് ഒരു അക്ഷരം മറ്റൊരു അക്ഷരമായി മാറ്റാൻ കഴിയും. സ്ട്രിംഗ് ഒരേ അക്ഷരത്തിൽ നിന്നു നിർമ്മിക്കാൻ ആവശ്യമായ കുറഞ്ഞ റൗണ്ടുകളുടെ എണ്ണം എത്രയാണ്?\nഉദാഹരണത്തിന്:\n    >>> f_31(\"aab\")\n    1\n    >>> f_31(\"abc\")\n    2\n    >>> f_31(\"aaa\")\n    0\n*/\nint f_31(const char* s)", "fa": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nبا توجه به یک رشته که از حروف کوچک انگلیسی تشکیل شده است، در هر دور می‌توانید یکی از کاراکترها را به کاراکتری دیگر تغییر دهید. سوال این است: حداقل تعداد دورهای لازم برای اینکه رشته از یک کاراکتر یکسان تشکیل شود چقدر است؟\nبرای مثال:\n    >>> f_31(\"aab\")\n    1\n    >>> f_31(\"abc\")\n    2\n    >>> f_31(\"aaa\")\n    0\n*/\nint f_31(const char* s)"}, "canonical_solution": "{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}", "instruction": {"en": "Write a C function `int f_31(const char* s)` to solve the following problem:\nGiven a string consisting of lowercase English letters, in each round you can change one of the characters to another character. The question is: what is the minimum number of rounds needed to make the string composed of the same character?\nFor example:\n    >>> f_31(\"aab\")\n    1\n    >>> f_31(\"abc\")\n    2\n    >>> f_31(\"aaa\")\n    0\n", "sq": "Shkruani një funksion në C `int f_31(const char* s)` për të zgjidhur problemin e mëposhtëm:\nDuke pasur një varg që përbëhet nga shkronjat e vogla të anglishtes, në çdo raund mund të ndryshoni një nga karakteret në një karakter tjetër. Pyetja është: sa është numri minimal i raundeve të nevojshme për ta bërë vargun të përbërë nga i njëjti karakter?  \nPër shembull:  \n    >>> f_31(\"aab\")  \n    1  \n    >>> f_31(\"abc\")  \n    2  \n    >>> f_31(\"aaa\")  \n    0  ", "hy": "Գրեք C ֆունկցիա `int f_31(const char* s)` հետևյալ խնդիրը լուծելու համար:\nՏրված է փոքրատառ անգլերեն տառերից կազմված տող, յուրաքանչյուր փուլում դուք կարող եք փոխել տառերից մեկը մեկ այլ տառով: Հարցն այն է՝ ինչքա՞ն է նվազագույն փուլերի քանակը, որպեսզի տողը կազմված լինի նույն տառից:\nՕրինակ:\n    >>> f_31(\"aab\")\n    1\n    >>> f_31(\"abc\")\n    2\n    >>> f_31(\"aaa\")\n    0", "bn": "একটি C ফাংশন `int f_31(const char* s)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি স্ট্রিং দেওয়া আছে যা ছোট হাতের ইংরেজি অক্ষর নিয়ে গঠিত, প্রতিটি রাউন্ডে আপনি একটি অক্ষরকে অন্য অক্ষরে পরিবর্তন করতে পারেন। প্রশ্ন হল: স্ট্রিংটিকে একই অক্ষর দিয়ে তৈরি করতে ন্যূনতম কত রাউন্ড প্রয়োজন?\nউদাহরণস্বরূপ:\n    >>> f_31(\"aab\")\n    1\n    >>> f_31(\"abc\")\n    2\n    >>> f_31(\"aaa\")\n    0", "bg": "Напишете C функция `int f_31(const char* s)`, за да решите следния проблем:\nДаден е низ, състоящ се от малки букви на английската азбука, като във всеки рунд можете да промените един от символите на друг символ. Въпросът е: какъв е минималният брой рундове, необходими, за да направите низа съставен от един и същ символ?  \nНапример:  \n    >>> f_31(\"aab\")  \n    1  \n    >>> f_31(\"abc\")  \n    2  \n    >>> f_31(\"aaa\")  \n    0  ", "zh": "编写一个 C 函数 `int f_31(const char* s)` 来解决以下问题：\n给定一个由小写英文字母组成的字符串，在每一轮中，你可以将其中一个字符更改为另一个字符。问题是：需要多少轮才能使字符串由相同的字符组成？  \n例如：  \n    >>> f_31(\"aab\")  \n    1  \n    >>> f_31(\"abc\")  \n    2  \n    >>> f_31(\"aaa\")  \n    0  ", "fr": "Écrire une fonction C `int f_31(const char* s)` pour résoudre le problème suivant :\nÉtant donné une chaîne composée de lettres minuscules anglaises, à chaque tour, vous pouvez changer l'un des caractères en un autre caractère. La question est : quel est le nombre minimum de tours nécessaires pour que la chaîne soit composée du même caractère ?  \nPar exemple :  \n    >>> f_31(\"aab\")  \n    1  \n    >>> f_31(\"abc\")  \n    2  \n    >>> f_31(\"aaa\")  \n    0  ", "de": "Schreiben Sie eine C-Funktion `int f_31(const char* s)`, um das folgende Problem zu lösen:\nGegeben ist ein String, der aus Kleinbuchstaben des englischen Alphabets besteht. In jeder Runde können Sie eines der Zeichen in ein anderes Zeichen ändern. Die Frage ist: Was ist die minimale Anzahl von Runden, die benötigt werden, um den String aus demselben Zeichen zu komponieren?\nZum Beispiel:\n    >>> f_31(\"aab\")\n    1\n    >>> f_31(\"abc\")\n    2\n    >>> f_31(\"aaa\")\n    0", "ha": "Rubuta aikin C `int f_31(const char* s)` don warware matsalar mai zuwa:\nAn ba da wani kirtani da ya ƙunshi ƙananan haruffan Ingilishi, a kowace zagaye za ka iya canza ɗaya daga cikin haruffan zuwa wani harafi. Tambayar ita ce: menene mafi ƙarancin adadin zagaye da ake buƙata don sanya kirtani ya ƙunshi harafi ɗaya?  \nMisali:  \n    >>> f_31(\"aab\")  \n    1  \n    >>> f_31(\"abc\")  \n    2  \n    >>> f_31(\"aaa\")  \n    0  ", "hi": "C फ़ंक्शन `int f_31(const char* s)` लिखें ताकि निम्नलिखित समस्या को हल किया जा सके:\nदिए गए स्ट्रिंग में छोटे अंग्रेजी अक्षरों का समावेश होता है, प्रत्येक राउंड में आप एक अक्षर को दूसरे अक्षर में बदल सकते हैं। प्रश्न यह है: स्ट्रिंग को एक ही अक्षर से मिलकर बनाने के लिए न्यूनतम कितने राउंड की आवश्यकता है?\nउदाहरण के लिए:\n    >>> f_31(\"aab\")\n    1\n    >>> f_31(\"abc\")\n    2\n    >>> f_31(\"aaa\")\n    0", "hu": "Írj egy C függvényt `int f_31(const char* s)` a következő probléma megoldására:\nAdott egy kisbetűs angol betűkből álló string, minden körben megváltoztathatsz egy karaktert egy másik karakterre. A kérdés az: mi a minimális körök száma, amely szükséges ahhoz, hogy a string ugyanabból a karakterből álljon?\nPéldául:\n    >>> f_31(\"aab\")\n    1\n    >>> f_31(\"abc\")\n    2\n    >>> f_31(\"aaa\")\n    0", "es": "Escribe una función en C `int f_31(const char* s)` para resolver el siguiente problema:\nDada una cadena que consiste en letras minúsculas del alfabeto inglés, en cada ronda puedes cambiar uno de los caracteres por otro carácter. La pregunta es: ¿cuál es el número mínimo de rondas necesarias para que la cadena esté compuesta por el mismo carácter?\nPor ejemplo:\n    >>> f_31(\"aab\")\n    1\n    >>> f_31(\"abc\")\n    2\n    >>> f_31(\"aaa\")\n    0", "arb": "اكتب دالة بلغة C `int f_31(const char* s)` لحل المشكلة التالية:\nبالنظر إلى سلسلة تتكون من أحرف إنجليزية صغيرة، في كل جولة يمكنك تغيير أحد الأحرف إلى حرف آخر. السؤال هو: ما هو الحد الأدنى لعدد الجولات اللازمة لجعل السلسلة مكونة من نفس الحرف؟  \nعلى سبيل المثال:  \n    >>> f_31(\"aab\")  \n    1  \n    >>> f_31(\"abc\")  \n    2  \n    >>> f_31(\"aaa\")  \n    0  ", "sw": "Andika kazi ya C `int f_31(const char* s)` kutatua tatizo lifuatalo:\nUkipiwa kamba inayojumuisha herufi ndogo za Kiingereza, katika kila raundi unaweza kubadilisha moja ya herufi kuwa herufi nyingine. Swali ni: ni idadi gani ndogo ya raundi inayohitajika ili kufanya kamba iwe na herufi sawa?  \nKwa mfano:  \n    >>> f_31(\"aab\")  \n    1  \n    >>> f_31(\"abc\")  \n    2  \n    >>> f_31(\"aaa\")  \n    0  ", "tr": "Bir C fonksiyonu `int f_31(const char* s)` yazın. Aşağıdaki problemi çözmek için:\nKüçük İngilizce harflerden oluşan bir dizi verildiğinde, her turda karakterlerden birini başka bir karaktere değiştirebilirsiniz. Soru şu: Diziyi aynı karakterden oluşacak şekilde yapmak için gereken minimum tur sayısı nedir?\nÖrneğin:\n    >>> f_31(\"aab\")\n    1\n    >>> f_31(\"abc\")\n    2\n    >>> f_31(\"aaa\")\n    0", "vi": "Viết một hàm C `int f_31(const char* s)` để giải quyết vấn đề sau:\nCho một chuỗi gồm các chữ cái tiếng Anh viết thường, trong mỗi lượt bạn có thể thay đổi một trong các ký tự thành ký tự khác. Câu hỏi là: số lượt tối thiểu cần thiết để làm cho chuỗi được tạo thành từ cùng một ký tự là bao nhiêu?  \nVí dụ:  \n    >>> f_31(\"aab\")  \n    1  \n    >>> f_31(\"abc\")  \n    2  \n    >>> f_31(\"aaa\")  \n    0  ", "id": "Tulis fungsi C `int f_31(const char* s)` untuk menyelesaikan masalah berikut:\nDiberikan sebuah string yang terdiri dari huruf kecil bahasa Inggris, pada setiap putaran Anda dapat mengubah salah satu karakter menjadi karakter lain. Pertanyaannya adalah: berapa jumlah putaran minimum yang diperlukan untuk membuat string tersebut terdiri dari karakter yang sama?\nSebagai contoh:\n    >>> f_31(\"aab\")\n    1\n    >>> f_31(\"abc\")\n    2\n    >>> f_31(\"aaa\")\n    0", "ja": "Cの関数を書け `int f_31(const char* s)` を作成して、次の問題を解決してください:\n小文字の英字からなる文字列が与えられたとき、各ラウンドで1つの文字を別の文字に変更することができます。質問は、文字列を同じ文字で構成するために必要な最小ラウンド数は何かということです。  \n例えば:  \n    >>> f_31(\"aab\")  \n    1  \n    >>> f_31(\"abc\")  \n    2  \n    >>> f_31(\"aaa\")  \n    0  ", "ko": "C 함수 `int f_31(const char* s)`를 작성하여 다음 문제를 해결하십시오:\n소문자 영어 문자로 구성된 문자열이 주어질 때, 각 라운드마다 하나의 문자를 다른 문자로 변경할 수 있습니다. 질문은: 문자열을 동일한 문자로 구성되도록 만드는 데 필요한 최소 라운드 수는 얼마입니까?\n예를 들어:\n    >>> f_31(\"aab\")\n    1\n    >>> f_31(\"abc\")\n    2\n    >>> f_31(\"aaa\")\n    0", "ml": "C ഫംഗ്ഷൻ `int f_31(const char* s)` എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nചെറിയ ഇംഗ്ലീഷ് അക്ഷരങ്ങൾ ഉൾക്കൊള്ളുന്ന ഒരു സ്ട്രിംഗ് നൽകിയിരിക്കുന്നു, ഓരോ റൗണ്ടിലും നിങ്ങൾക്ക് ഒരു അക്ഷരം മറ്റൊരു അക്ഷരമായി മാറ്റാം. ചോദ്യം: സ്ട്രിംഗ് ഒരേ അക്ഷരത്തിൽ നിന്നു നിർമ്മിക്കാൻ വേണ്ട കുറഞ്ഞ റൗണ്ടുകൾ എത്രയാണ്?\nഉദാഹരണത്തിന്:\n    >>> f_31(\"aab\")\n    1\n    >>> f_31(\"abc\")\n    2\n    >>> f_31(\"aaa\")\n    0", "fa": "یک تابع C به نام `int f_31(const char* s)` بنویسید تا مسئله زیر را حل کند:\nبا توجه به یک رشته که از حروف کوچک انگلیسی تشکیل شده است، در هر دور می‌توانید یکی از کاراکترها را به کاراکتر دیگری تغییر دهید. سوال این است: حداقل تعداد دورهای مورد نیاز برای ساختن رشته‌ای که از یک کاراکتر مشابه تشکیل شده باشد، چقدر است؟\nبرای مثال:\n    >>> f_31(\"aab\")\n    1\n    >>> f_31(\"abc\")\n    2\n    >>> f_31(\"aaa\")\n    0"}, "level": "middle", "test": "int main() {\n    assert(f_31(\"aab\") == 1);\n    assert(f_31(\"abc\") == 2);\n    assert(f_31(\"aaa\") == 0);\n    assert(f_31(\"abab\") == 1);\n    assert(f_31(\"zzzzz\") == 0);\n    return 0;\n}", "entry_point": "f_31", "signature": "int f_31(const char* s)", "docstring": {"en": "Given a string consisting of lowercase English letters, in each round you can change one of the characters to another character. The question is: what is the minimum number of rounds needed to make the string composed of the same character?\nFor example:\n    >>> f_31(\"aab\")\n    1\n    >>> f_31(\"abc\")\n    2\n    >>> f_31(\"aaa\")\n    0\n", "sq": "Duke pasur një varg që përbëhet nga shkronja të vogla të anglishtes, në secilën raund ju mund të ndryshoni një nga karakteret në një karakter tjetër. Pyetja është: cili është numri minimal i raundeve të nevojshme për ta bërë vargun të përbërë nga i njëjti karakter?\nPër shembull:\n    >>> f_31(\"aab\")\n    1\n    >>> f_31(\"abc\")\n    2\n    >>> f_31(\"aaa\")\n    0", "hy": "Տրված է փոքրատառ անգլերեն տառերից կազմված տող, յուրաքանչյուր փուլում դուք կարող եք փոխել տառերից մեկը մեկ այլ տառով: Հարցն այն է՝ ինչքա՞ն է նվազագույն փուլերի քանակը, որը անհրաժեշտ է, որպեսզի տողը կազմված լինի նույն տառից:\nՕրինակ՝\n    >>> f_31(\"aab\")\n    1\n    >>> f_31(\"abc\")\n    2\n    >>> f_31(\"aaa\")\n    0", "bn": "একটি স্ট্রিং দেওয়া হয়েছে যা ছোট হাতের ইংরেজি অক্ষর নিয়ে গঠিত, প্রতিটি রাউন্ডে আপনি একটি অক্ষরকে অন্য একটি অক্ষরে পরিবর্তন করতে পারেন। প্রশ্ন হল: স্ট্রিংটিকে একই অক্ষর দিয়ে গঠিত করতে ন্যূনতম কত রাউন্ড প্রয়োজন?\n\nউদাহরণস্বরূপ:\n    >>> f_31(\"aab\")\n    1\n    >>> f_31(\"abc\")\n    2\n    >>> f_31(\"aaa\")\n    0", "bg": "Даден е низ, състоящ се от малки латински букви, като във всеки рунд можете да промените един от символите на друг символ. Въпросът е: какъв е минималният брой рундове, необходими, за да се направи низът съставен от един и същ символ?\nНапример:\n    >>> f_31(\"aab\")\n    1\n    >>> f_31(\"abc\")\n    2\n    >>> f_31(\"aaa\")\n    0", "zh": "给定一个由小写英文字母组成的字符串，在每一轮中，你可以将其中一个字符更改为另一个字符。问题是：使字符串由相同字符组成所需的最小轮数是多少？\n例如：\n    >>> f_31(\"aab\")\n    1\n    >>> f_31(\"abc\")\n    2\n    >>> f_31(\"aaa\")\n    0", "fr": "Étant donné une chaîne composée de lettres minuscules anglaises, à chaque tour, vous pouvez changer l'un des caractères en un autre caractère. La question est : quel est le nombre minimum de tours nécessaires pour que la chaîne soit composée du même caractère ?\nPar exemple :\n    >>> f_31(\"aab\")\n    1\n    >>> f_31(\"abc\")\n    2\n    >>> f_31(\"aaa\")\n    0", "de": "Angenommen, ein String besteht aus Kleinbuchstaben des englischen Alphabets. In jeder Runde kann man eines der Zeichen in ein anderes Zeichen ändern. Die Frage ist: Wie viele Runden sind mindestens erforderlich, um den String aus demselben Zeichen bestehen zu lassen?\nZum Beispiel:\n    >>> f_31(\"aab\")\n    1\n    >>> f_31(\"abc\")\n    2\n    >>> f_31(\"aaa\")\n    0", "ha": "An ba da wata igiyar rubutu da ta ƙunshi ƙananan haruffan Ingilishi, a kowane zagaye za ka iya canza ɗaya daga cikin haruffan zuwa wani harafi. Tambayar ita ce: menene mafi ƙarancin adadin zagaye da ake buƙata don sanya igiyar rubutu ta ƙunshi harafi ɗaya?\nMisali:\n    >>> f_31(\"aab\")\n    1\n    >>> f_31(\"abc\")\n    2\n    >>> f_31(\"aaa\")\n    0", "hi": "दिए गए स्ट्रिंग में छोटे अंग्रेजी अक्षरों का उपयोग किया गया है, प्रत्येक राउंड में आप एक अक्षर को दूसरे अक्षर में बदल सकते हैं। प्रश्न यह है: स्ट्रिंग को एक ही अक्षर से मिलकर बनाने के लिए न्यूनतम कितने राउंड की आवश्यकता है?\n\nउदाहरण के लिए:\n    >>> f_31(\"aab\")\n    1\n    >>> f_31(\"abc\")\n    2\n    >>> f_31(\"aaa\")\n    0", "hu": "Adott egy kisbetűs angol betűkből álló karakterlánc, minden körben megváltoztathatod az egyik karaktert egy másik karakterre. A kérdés az: mi a minimális körök száma, amely szükséges ahhoz, hogy a karakterlánc ugyanabból a karakterből álljon?\nPéldául:\n    >>> f_31(\"aab\")\n    1\n    >>> f_31(\"abc\")\n    2\n    >>> f_31(\"aaa\")\n    0", "es": "Dada una cadena compuesta por letras minúsculas del alfabeto inglés, en cada ronda puedes cambiar uno de los caracteres por otro carácter. La pregunta es: ¿cuál es el número mínimo de rondas necesarias para que la cadena esté compuesta por el mismo carácter?\nPor ejemplo:\n    >>> f_31(\"aab\")\n    1\n    >>> f_31(\"abc\")\n    2\n    >>> f_31(\"aaa\")\n    0", "arb": "نظرًا لسلسلة تتكون من أحرف إنجليزية صغيرة، في كل جولة يمكنك تغيير أحد الأحرف إلى حرف آخر. السؤال هو: ما هو الحد الأدنى لعدد الجولات اللازمة لجعل السلسلة مكونة من نفس الحرف؟\n\nعلى سبيل المثال:\n    >>> f_31(\"aab\")\n    1\n    >>> f_31(\"abc\")\n    2\n    >>> f_31(\"aaa\")\n    0", "sw": "Kwa kuzingatia mfuatano wa herufi ndogo za Kiingereza, katika kila raundi unaweza kubadilisha moja ya herufi kuwa herufi nyingine. Swali ni: ni idadi ndogo zaidi ya raundi zinazohitajika ili kufanya mfuatano huo uwe na herufi sawa?\n\nKwa mfano:\n    >>> f_31(\"aab\")\n    1\n    >>> f_31(\"abc\")\n    2\n    >>> f_31(\"aaa\")\n    0", "tr": "Verilen bir küçük İngiliz harflerinden oluşan bir dize için, her turda karakterlerden birini başka bir karakterle değiştirebilirsiniz. Soru şu: Diziyi aynı karakterden oluşacak şekilde yapmak için gereken minimum tur sayısı nedir?\nÖrneğin:\n    >>> f_31(\"aab\")\n    1\n    >>> f_31(\"abc\")\n    2\n    >>> f_31(\"aaa\")\n    0", "vi": "Cho một chuỗi bao gồm các chữ cái tiếng Anh viết thường, trong mỗi lượt bạn có thể thay đổi một trong các ký tự thành ký tự khác. Câu hỏi là: cần tối thiểu bao nhiêu lượt để làm cho chuỗi được tạo thành từ cùng một ký tự?\nVí dụ:\n    >>> f_31(\"aab\")\n    1\n    >>> f_31(\"abc\")\n    2\n    >>> f_31(\"aaa\")\n    0", "id": "Diberikan sebuah string yang terdiri dari huruf kecil bahasa Inggris, dalam setiap putaran Anda dapat mengubah salah satu karakter menjadi karakter lain. Pertanyaannya adalah: berapa jumlah putaran minimum yang diperlukan untuk membuat string terdiri dari karakter yang sama?\nSebagai contoh:\n    >>> f_31(\"aab\")\n    1\n    >>> f_31(\"abc\")\n    2\n    >>> f_31(\"aaa\")\n    0", "ja": "小文字の英字で構成された文字列が与えられたとき、各ラウンドで文字の1つを別の文字に変更することができます。質問は、文字列を同じ文字で構成されるようにするために必要な最小ラウンド数は何かということです。\n例えば:\n    >>> f_31(\"aab\")\n    1\n    >>> f_31(\"abc\")\n    2\n    >>> f_31(\"aaa\")\n    0", "ko": "주어진 문자열이 소문자 영어 문자로 구성되어 있을 때, 각 라운드마다 하나의 문자를 다른 문자로 변경할 수 있습니다. 질문은: 문자열을 동일한 문자로 구성하기 위해 필요한 최소 라운드 수는 얼마입니까?\n\n예를 들어:\n    >>> f_31(\"aab\")\n    1\n    >>> f_31(\"abc\")\n    2\n    >>> f_31(\"aaa\")\n    0", "ml": "ഒരു ചെറിയ ഇംഗ്ലീഷ് അക്ഷരങ്ങളടങ്ങിയ സ്ട്രിംഗ് നൽകിയാൽ, ഓരോ റൗണ്ടിലും നിങ്ങൾക്ക് ഒരു അക്ഷരം മറ്റൊരു അക്ഷരമായി മാറ്റാൻ കഴിയും. സ്ട്രിംഗ് ഒരേ അക്ഷരത്തിൽ നിന്നുണ്ടാക്കാൻ ആവശ്യമായ കുറഞ്ഞ റൗണ്ടുകളുടെ എണ്ണം എത്രയാണ് എന്നതാണ് ചോദ്യം. ഉദാഹരണത്തിന്:\n\n    >>> f_31(\"aab\")\n    1\n    >>> f_31(\"abc\")\n    2\n    >>> f_31(\"aaa\")\n    0", "fa": "با توجه به یک رشته که از حروف کوچک انگلیسی تشکیل شده است، در هر دور می‌توانید یکی از کاراکترها را به کاراکتر دیگری تغییر دهید. سوال این است: حداقل تعداد دورهایی که لازم است تا رشته‌ای تشکیل شده از یک کاراکتر مشابه باشد، چقدر است؟\nبرای مثال:\n    >>> f_31(\"aab\")\n    1\n    >>> f_31(\"abc\")\n    2\n    >>> f_31(\"aaa\")\n    0"}}
{"task_id": "C/32", "prompt": {"en": "#include <assert.h>\n#include <stdio.h>\n/*\nGiven a sequence of n events, each occurring with a periodicity of a_i years, the problem is to find the year Y_n when the n-th event occurs, under the condition that the countdown for event i+1 can only commence in the year immediately following the occurrence of event i. \n    >>> f_32(6, (int[]){3,2,4,5,9,18})\n    36\n*/\nint f_32(int n, int signs[])", "sq": "#include <assert.h>\n#include <stdio.h>\n/*\nDuke pasur një sekuencë prej n ngjarjesh, secila që ndodh me një periodicitet prej a_i vitesh, problemi është të gjejmë vitin Y_n kur ndodh ngjarja e n-të, me kushtin që numërimi mbrapsht për ngjarjen i+1 mund të fillojë vetëm në vitin menjëherë pas ndodhjes së ngjarjes i. \n    >>> f_32(6, (int[]){3,2,4,5,9,18})\n    36\n*/\nint f_32(int n, int signs[])", "hy": "#include <assert.h>\n#include <stdio.h>\n/*\nՈւնենալով n իրադարձությունների հաջորդականություն, որոնցից յուրաքանչյուրը տեղի է ունենում a_i տարիների պարբերականությամբ, խնդիրը կայանում է գտնել Y_n տարին, երբ տեղի է ունենում n-րդ իրադարձությունը, այն պայմանով, որ i+1 իրադարձության հետհաշվարկը կարող է սկսվել միայն i իրադարձության տեղի ունենալուց անմիջապես հետո:\n    >>> f_32(6, (int[]){3,2,4,5,9,18})\n    36\n*/\nint f_32(int n, int signs[])", "bn": "#include <assert.h>\n#include <stdio.h>\n/*\nnটি ঘটনার একটি ক্রম দেওয়া হয়েছে, প্রতিটি a_i বছর পরপর ঘটে, সমস্যাটি হল Y_n বছরটি খুঁজে বের করা যখন n-তম ঘটনা ঘটে, এই শর্তে যে ঘটনা i+1 এর জন্য কাউন্টডাউন কেবলমাত্র ঘটনা i এর ঘটনার পরের বছরেই শুরু হতে পারে।\n    >>> f_32(6, (int[]){3,2,4,5,9,18})\n    36\n*/\nint f_32(int n, int signs[])", "bg": "#include <assert.h>\n#include <stdio.h>\n/*\nДадена е последователност от n събития, всяко от които се случва с периодичност от a_i години, проблемът е да се намери годината Y_n, когато се случва n-тото събитие, при условие че отброяването за събитие i+1 може да започне само в годината, непосредствено следваща след случването на събитие i.\n    >>> f_32(6, (int[]){3,2,4,5,9,18})\n    36\n*/\nint f_32(int n, int signs[])", "zh": "#include <assert.h>\n#include <stdio.h>\n/*\n给定一个长度为 n 的事件序列，每个事件以 a_i 年为周期发生，问题是找到第 n 个事件发生的年份 Y_n，条件是事件 i+1 的倒计时只能在事件 i 发生的下一年开始。\n    >>> f_32(6, (int[]){3,2,4,5,9,18})\n    36\n*/\nint f_32(int n, int signs[])", "fr": "#include <assert.h>\n#include <stdio.h>\n/*\nÉtant donné une séquence de n événements, chacun se produisant avec une périodicité de a_i années, le problème est de trouver l'année Y_n lorsque le n-ième événement se produit, sous la condition que le compte à rebours pour l'événement i+1 ne peut commencer que l'année suivant immédiatement la survenue de l'événement i.\n    >>> f_32(6, (int[]){3,2,4,5,9,18})\n    36\n*/\nint f_32(int n, int signs[])", "de": "#include <assert.h>\n#include <stdio.h>\n/*\nGegeben eine Sequenz von n Ereignissen, die jeweils mit einer Periodizität von a_i Jahren auftreten, besteht das Problem darin, das Jahr Y_n zu finden, in dem das n-te Ereignis eintritt, unter der Bedingung, dass der Countdown für Ereignis i+1 erst im Jahr unmittelbar nach dem Auftreten von Ereignis i beginnen kann.\n    >>> f_32(6, (int[]){3,2,4,5,9,18})\n    36\n*/\nint f_32(int n, int signs[])", "ha": "#include <assert.h>\n#include <stdio.h>\n/*\nAn ba da jerin abubuwan n, kowanne yana faruwa tare da maimaitawa na a_i shekaru, matsalar ita ce gano shekarar Y_n lokacin da abin n-th ya faru, a ƙarƙashin yanayin cewa ƙidayar don abin i+1 na iya farawa kawai a shekarar da ke biye da faruwar abin i. \n    >>> f_32(6, (int[]){3,2,4,5,9,18})\n    36\n*/\nint f_32(int n, int signs[])", "hi": "#include <assert.h>\n#include <stdio.h>\n/*\nn घटनाओं के अनुक्रम को दिया गया है, प्रत्येक a_i वर्षों की आवधिकता के साथ घटित होती है, समस्या यह है कि वर्ष Y_n का पता लगाना है जब n-वीं घटना घटित होती है, इस शर्त के तहत कि घटना i+1 की उलटी गिनती केवल घटना i के घटित होने के तुरंत बाद वाले वर्ष में ही शुरू हो सकती है।\n    >>> f_32(6, (int[]){3,2,4,5,9,18})\n    36\n*/\nint f_32(int n, int signs[])", "hu": "#include <assert.h>\n#include <stdio.h>\n/*\nAdott egy n eseményből álló sorozat, amelyek mindegyike a_i évenkénti periodicitással fordul elő, a feladat az Y_n év megtalálása, amikor az n-edik esemény bekövetkezik, azzal a feltétellel, hogy az i+1-edik esemény visszaszámlálása csak az i-edik esemény bekövetkezését követő évben kezdődhet meg. \n    >>> f_32(6, (int[]){3,2,4,5,9,18})\n    36\n*/\nint f_32(int n, int signs[])", "es": "#include <assert.h>\n#include <stdio.h>\n/*\nDada una secuencia de n eventos, cada uno ocurriendo con una periodicidad de a_i años, el problema es encontrar el año Y_n cuando ocurre el n-ésimo evento, bajo la condición de que la cuenta regresiva para el evento i+1 solo puede comenzar en el año inmediatamente siguiente a la ocurrencia del evento i.\n    >>> f_32(6, (int[]){3,2,4,5,9,18})\n    36\n*/\nint f_32(int n, int signs[])", "arb": "#include <assert.h>\n#include <stdio.h>\n/*\nبالنظر إلى تسلسل من n أحداث، كل منها يحدث بشكل دوري كل a_i سنوات، المشكلة هي إيجاد السنة Y_n عندما يحدث الحدث n، تحت شرط أن العد التنازلي للحدث i+1 يمكن أن يبدأ فقط في السنة التي تلي مباشرة حدوث الحدث i.\n    >>> f_32(6, (int[]){3,2,4,5,9,18})\n    36\n*/\nint f_32(int n, int signs[])", "sw": "#include <assert.h>\n#include <stdio.h>\n/*\nIkizingatiwa mlolongo wa matukio n, kila moja likitokea kwa vipindi vya miaka a_i, tatizo ni kupata mwaka Y_n ambapo tukio la n linatokea, chini ya sharti kwamba kuhesabu kwa tukio i+1 kunaweza kuanza tu katika mwaka unaofuata mara tu baada ya tukio i kutokea.\n    >>> f_32(6, (int[]){3,2,4,5,9,18})\n    36\n*/\nint f_32(int n, int signs[])", "tr": "#include <assert.h>\n#include <stdio.h>\n/*\nn olaydan oluşan bir dizi verildiğinde, her biri a_i yıllık bir periyodiklikle meydana gelir, sorun, i+1. olayın geri sayımının yalnızca i. olayın meydana gelmesinden hemen sonraki yılda başlayabileceği koşulu altında n. olayın meydana geldiği Y_n yılını bulmaktır.\n    >>> f_32(6, (int[]){3,2,4,5,9,18})\n    36\n*/\nint f_32(int n, int signs[])", "vi": "#include <assert.h>\n#include <stdio.h>\n/*\nCho một dãy gồm n sự kiện, mỗi sự kiện xảy ra với chu kỳ a_i năm, vấn đề là tìm năm Y_n khi sự kiện thứ n xảy ra, với điều kiện rằng đếm ngược cho sự kiện i+1 chỉ có thể bắt đầu vào năm ngay sau khi sự kiện i xảy ra.\n    >>> f_32(6, (int[]){3,2,4,5,9,18})\n    36\n*/\nint f_32(int n, int signs[])", "id": "#include <assert.h>\n#include <stdio.h>\n/*\nDiberikan sebuah urutan dari n kejadian, masing-masing terjadi dengan periodisitas a_i tahun, masalahnya adalah untuk menemukan tahun Y_n ketika kejadian ke-n terjadi, dengan kondisi bahwa hitungan mundur untuk kejadian i+1 hanya dapat dimulai pada tahun segera setelah kejadian i terjadi.\n    >>> f_32(6, (int[]){3,2,4,5,9,18})\n    36\n*/\nint f_32(int n, int signs[])", "ja": "#include <assert.h>\n#include <stdio.h>\n/*\nn個のイベントのシーケンスがあり、それぞれがa_i年の周期で発生する場合、問題はn番目のイベントが発生する年Y_nを見つけることです。ただし、イベントi+1のカウントダウンは、イベントiが発生した直後の年にのみ開始できるという条件があります。\n    >>> f_32(6, (int[]){3,2,4,5,9,18})\n    36\n*/\nint f_32(int n, int signs[])", "ko": "#include <assert.h>\n#include <stdio.h>\n/*\nn개의 이벤트 시퀀스가 주어졌을 때, 각각의 이벤트는 a_i년의 주기로 발생합니다. 문제는 이벤트 i+1의 카운트다운이 이벤트 i가 발생한 직후의 해에만 시작할 수 있다는 조건 하에 n번째 이벤트가 발생하는 해 Y_n을 찾는 것입니다.\n    >>> f_32(6, (int[]){3,2,4,5,9,18})\n    36\n*/\nint f_32(int n, int signs[])", "ml": "#include <assert.h>\n#include <stdio.h>\n/*\nn സംഭവങ്ങളുടെ ഒരു ശ്രേണിയ്ക്ക്, ഓരോന്നും a_i വർഷങ്ങളുടെ കാലപരിധിയോടെ സംഭവിക്കുമ്പോൾ, n-മത്തെ സംഭവം സംഭവിക്കുന്ന Y_n വർഷം കണ്ടെത്തുക എന്നതാണ് പ്രശ്നം, i+1-മത്തെ സംഭവത്തിനായുള്ള കൗണ്ട്ഡൗൺ, i-മത്തെ സംഭവം സംഭവിക്കുന്ന വർഷത്തിന് തൊട്ടുപിന്നാലെ മാത്രമേ ആരംഭിക്കാവൂ എന്ന വ്യവസ്ഥയിൽ. \n    >>> f_32(6, (int[]){3,2,4,5,9,18})\n    36\n*/\nint f_32(int n, int signs[])", "fa": "#include <assert.h>\n#include <stdio.h>\n/*\nبا توجه به دنباله‌ای از n رویداد، که هر کدام با دوره تناوب a_i سال رخ می‌دهند، مسئله این است که سال Y_n را پیدا کنیم که در آن n-امین رویداد رخ می‌دهد، با این شرط که شمارش معکوس برای رویداد i+1 تنها می‌تواند در سال بلافاصله پس از وقوع رویداد i آغاز شود.\n    >>> f_32(6, (int[]){3,2,4,5,9,18})\n    36\n*/\nint f_32(int n, int signs[])"}, "canonical_solution": "{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        int nextOccurrence = (year / period + 1) * period;\n        year = nextOccurrence;\n    }\n    return year;\n}", "instruction": {"en": "Write a C function `int f_32(int n, int signs[])` to solve the following problem:\nGiven a sequence of n events, each occurring with a periodicity of a_i years, the problem is to find the year Y_n when the n-th event occurs, under the condition that the countdown for event i+1 can only commence in the year immediately following the occurrence of event i. \n    >>> f_32(6, (int[]){3,2,4,5,9,18})\n    36\n", "sq": "Shkruani një funksion në C `int f_32(int n, int signs[])` për të zgjidhur problemin në vijim:\nDuke pasur një sekuencë prej n ngjarjesh, secila që ndodh me një periodicitet prej a_i vitesh, problemi është të gjendet viti Y_n kur ndodh ngjarja e n-të, nën kushtin që numërimi mbrapsht për ngjarjen i+1 mund të fillojë vetëm në vitin menjëherë pas ndodhjes së ngjarjes i.  \n    >>> f_32(6, (int[]){3,2,4,5,9,18})\n    36", "hy": "Գրեք C ֆունկցիա `int f_32(int n, int signs[])` հետևյալ խնդիրը լուծելու համար:\nՏրված է n իրադարձությունների հաջորդականություն, որոնցից յուրաքանչյուրը տեղի է ունենում a_i տարիների պարբերականությամբ, խնդիրը գտնել Y_n տարին, երբ տեղի կունենա n-րդ իրադարձությունը, այն պայմանով, որ i+1 իրադարձության հետհաշվարկը կարող է սկսվել միայն i իրադարձության տեղի ունենալուց անմիջապես հետո:\n    >>> f_32(6, (int[]){3,2,4,5,9,18})\n    36", "bn": "C ফাংশন `int f_32(int n, int signs[])` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\n n ঘটনাগুলির একটি ক্রম দেওয়া হয়েছে, প্রতিটি a_i বছরগুলির একটি পর্যায়ক্রমিকতার সাথে সংঘটিত হয়, সমস্যাটি হল Y_n বছর খুঁজে বের করা যখন n-তম ঘটনা ঘটে, এই শর্তের অধীনে যে ঘটনা i+1 এর জন্য কাউন্টডাউন শুধুমাত্র ঘটনা i এর সংঘটনের পরের বছরেই শুরু হতে পারে।", "bg": "Напишете C функция `int f_32(int n, int signs[])`, за да решите следния проблем:\nДадена е последователност от n събития, всяко от които се случва с периодичност от a_i години, проблемът е да се намери годината Y_n, когато се случва n-тото събитие, при условие че обратното броене за събитие i+1 може да започне само в годината, непосредствено следваща след настъпването на събитие i.", "zh": "编写一个 C 函数 `int f_32(int n, int signs[])` 来解决以下问题：\n给定一个由 n 个事件组成的序列，每个事件以 a_i 年为周期发生，问题是找到第 n 个事件发生的年份 Y_n，条件是事件 i+1 的倒计时只能在事件 i 发生后的下一年开始。", "fr": "Écrire une fonction C `int f_32(int n, int signs[])` pour résoudre le problème suivant :\nÉtant donné une séquence de n événements, chacun se produisant avec une périodicité de a_i années, le problème est de trouver l'année Y_n lorsque le n-ième événement se produit, à condition que le compte à rebours pour l'événement i+1 ne puisse commencer que l'année suivant immédiatement la survenue de l'événement i.", "de": "Schreiben Sie eine C-Funktion `int f_32(int n, int signs[])`, um das folgende Problem zu lösen:\nGegeben ist eine Sequenz von n Ereignissen, die jeweils mit einer Periodizität von a_i Jahren auftreten. Das Problem besteht darin, das Jahr Y_n zu finden, in dem das n-te Ereignis eintritt, unter der Bedingung, dass der Countdown für das Ereignis i+1 erst im Jahr unmittelbar nach dem Auftreten des Ereignisses i beginnen kann.\n    >>> f_32(6, (int[]){3,2,4,5,9,18})\n    36", "ha": "Rubuta aikin C `int f_32(int n, int signs[])` don warware matsalar mai zuwa:\nAn ba da jerin abubuwan n, kowanne yana faruwa tare da maimaitawa na shekaru a_i, matsalar ita ce nemo shekarar Y_n lokacin da abin n-th ya faru, a ƙarƙashin yanayin cewa ƙidayar don abin i+1 na iya farawa kawai a cikin shekarar da ke biye da faruwar abin i.", "hi": "C फ़ंक्शन `int f_32(int n, int signs[])` लिखें ताकि निम्नलिखित समस्या को हल किया जा सके:\nदिए गए n घटनाओं के अनुक्रम में, प्रत्येक घटना a_i वर्षों की आवृत्ति के साथ होती है, समस्या यह है कि वर्ष Y_n का पता लगाना है जब n-वीं घटना होती है, इस शर्त के तहत कि घटना i+1 की उलटी गिनती केवल घटना i के घटित होने के तुरंत बाद के वर्ष में ही शुरू हो सकती है।", "hu": "Írj egy C függvényt `int f_32(int n, int signs[])`, hogy megoldja a következő problémát:\nAdott egy n eseményből álló sorozat, ahol minden esemény a_i évenként ismétlődik, a feladat az Y_n év megtalálása, amikor az n-edik esemény bekövetkezik, azzal a feltétellel, hogy az i+1-edik esemény visszaszámlálása csak az i-edik esemény bekövetkezését követő évben kezdődhet meg.  \n    >>> f_32(6, (int[]){3,2,4,5,9,18})  \n    36  ", "es": "Escribe una función en C `int f_32(int n, int signs[])` para resolver el siguiente problema:\nDada una secuencia de n eventos, cada uno ocurriendo con una periodicidad de a_i años, el problema es encontrar el año Y_n cuando ocurre el n-ésimo evento, bajo la condición de que la cuenta regresiva para el evento i+1 solo puede comenzar en el año inmediatamente posterior a la ocurrencia del evento i.\n    >>> f_32(6, (int[]){3,2,4,5,9,18})\n    36", "arb": "اكتب دالة بلغة C `int f_32(int n, int signs[])` لحل المشكلة التالية:\nبالنظر إلى تسلسل من n أحداث، كل منها يحدث بتكرار a_i سنوات، المشكلة هي إيجاد السنة Y_n عندما يحدث الحدث n، تحت شرط أن العد التنازلي للحدث i+1 يمكن أن يبدأ فقط في السنة التي تلي مباشرة حدوث الحدث i.\n    >>> f_32(6, (int[]){3,2,4,5,9,18})\n    36", "sw": "Andika kazi ya C `int f_32(int n, int signs[])` kutatua tatizo lifuatalo:\nUkipatiwa mlolongo wa matukio n, kila moja likitokea kwa kipindi cha miaka a_i, tatizo ni kupata mwaka Y_n ambapo tukio la n linatokea, chini ya sharti kwamba kuhesabu kwa tukio i+1 kunaweza tu kuanza katika mwaka unaofuata mara baada ya tukio i kutokea. \n    >>> f_32(6, (int[]){3,2,4,5,9,18})\n    36", "tr": "Bir C fonksiyonu `int f_32(int n, int signs[])` yazın ve aşağıdaki problemi çözün:\nn olayından oluşan bir dizi verildiğinde, her biri a_i yıllık bir periyodiklikle gerçekleşen, problem n. olayın gerçekleştiği Y_n yılını bulmaktır. Bu, i+1 olayının geri sayımının yalnızca i olayının gerçekleştiği yılın hemen sonrasında başlayabileceği koşulu altında yapılmalıdır.\n    >>> f_32(6, (int[]){3,2,4,5,9,18})\n    36", "vi": "Viết một hàm C `int f_32(int n, int signs[])` để giải quyết vấn đề sau:\nCho một dãy gồm n sự kiện, mỗi sự kiện xảy ra với chu kỳ a_i năm, vấn đề là tìm năm Y_n khi sự kiện thứ n xảy ra, với điều kiện rằng đếm ngược cho sự kiện i+1 chỉ có thể bắt đầu vào năm ngay sau khi sự kiện i xảy ra.\n    >>> f_32(6, (int[]){3,2,4,5,9,18})\n    36", "id": "Tulis sebuah fungsi C `int f_32(int n, int signs[])` untuk menyelesaikan masalah berikut:\nDiberikan sebuah urutan dari n kejadian, masing-masing terjadi dengan periodisitas a_i tahun, masalahnya adalah untuk menemukan tahun Y_n ketika kejadian ke-n terjadi, dengan syarat bahwa hitungan mundur untuk kejadian i+1 hanya dapat dimulai pada tahun segera setelah terjadinya kejadian i.\n    >>> f_32(6, (int[]){3,2,4,5,9,18})\n    36", "ja": "Cの関数を書け `int f_32(int n, int signs[])` を作成して、次の問題を解決してください:\nn個のイベントのシーケンスが与えられ、それぞれがa_i年の周期で発生します。この問題は、n番目のイベントが発生する年Y_nを見つけることです。ただし、イベントi+1のカウントダウンは、イベントiが発生した直後の年にのみ開始できるという条件があります。\n    >>> f_32(6, (int[]){3,2,4,5,9,18})\n    36", "ko": "C 함수 `int f_32(int n, int signs[])`를 작성하여 다음 문제를 해결하십시오:\nn개의 사건으로 구성된 시퀀스가 주어졌을 때, 각 사건은 a_i년의 주기로 발생합니다. 문제는 n번째 사건이 발생하는 연도 Y_n을 찾는 것입니다. 단, 사건 i+1의 카운트다운은 사건 i가 발생한 직후의 해에만 시작할 수 있습니다.\n    >>> f_32(6, (int[]){3,2,4,5,9,18})\n    36", "ml": "C ഫംഗ്ഷൻ `int f_32(int n, int signs[])` എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\n n സംഭവങ്ങളുടെ ഒരു നിര നൽകിയിരിക്കുന്നു, ഓരോന്നും a_i വർഷങ്ങളുടെ കാലപരിധിയോടെ സംഭവിക്കുന്നു, പ്രശ്നം n-ആമത്തെ സംഭവം Y_n വർഷത്തിൽ സംഭവിക്കുമ്പോൾ കണ്ടെത്തുക, സംഭവ i+1-ന്റെ കൗണ്ട്ഡൗൺ സംഭവ i സംഭവിക്കുന്ന വർഷത്തിന് തൊട്ടുപിന്നാലെ മാത്രമേ ആരംഭിക്കാവൂ എന്ന വ്യവസ്ഥയിൽ. \n    >>> f_32(6, (int[]){3,2,4,5,9,18})\n    36", "fa": "یک تابع C `int f_32(int n, int signs[])` بنویسید تا مسئله زیر را حل کند:\nبا توجه به دنباله‌ای از n رویداد، که هر کدام با دوره تناوب a_i سال رخ می‌دهند، مسئله این است که سال Y_n را پیدا کنید که در آن n-امین رویداد رخ می‌دهد، با این شرط که شمارش معکوس برای رویداد i+1 تنها می‌تواند در سال بلافاصله پس از وقوع رویداد i آغاز شود.\n    >>> f_32(6, (int[]){3,2,4,5,9,18})\n    36"}, "level": "easy", "test": "int main() {\n    assert(f_32(6, (int[]){3,2,4,5,9,18}) == 36);\n    assert(f_32(5, (int[]){1, 2,3,4,5}) == 5);\n    assert(f_32(5, (int[]){1,1,1,1,1}) == 5);\n    assert(f_32(6, (int[]){50,30,711,200,503,1006}) == 2012);\n    assert(f_32(2, (int[]){1, 2}) == 2);\n    assert(f_32(3, (int[]){3, 1, 2}) == 6);\n    assert(f_32(3, (int[]){2, 3, 4}) == 4);\n    assert(f_32(4, (int[]){1, 2, 3, 4}) == 4);\n    assert(f_32(4, (int[]){5, 7, 11, 13}) == 13);\n    assert(f_32(5, (int[]){2, 2, 2, 2, 2}) == 10);\n    assert(f_32(3, (int[]){6, 10, 15}) == 15);\n    assert(f_32(3, (int[]){4, 6, 14}) == 14);\n    assert(f_32(4, (int[]){50, 30, 711, 200}) == 800);\n    assert(f_32(6, (int[]){1, 1, 1, 1, 1, 1}) == 6);\n    assert(f_32(2, (int[]){1000000, 999999}) == 1999998);\n    return 0;\n}", "entry_point": "f_32", "signature": "int f_32(int n, int signs[])", "docstring": {"en": "Given a sequence of n events, each occurring with a periodicity of a_i years, the problem is to find the year Y_n when the n-th event occurs, under the condition that the countdown for event i+1 can only commence in the year immediately following the occurrence of event i. \n    >>> f_32(6, (int[]){3,2,4,5,9,18})\n    36\n", "sq": "Duke pasur një sekuencë prej n ngjarjesh, secila që ndodh me një periodicitet prej a_i vitesh, problemi është të gjendet viti Y_n kur ndodh ngjarja e n-të, me kushtin që numërimi mbrapsht për ngjarjen i+1 mund të fillojë vetëm në vitin menjëherë pas ndodhjes së ngjarjes i.\n    >>> f_32(6, (int[]){3,2,4,5,9,18})\n    36", "hy": "Տրված է n իրադարձությունների հաջորդականություն, որոնցից յուրաքանչյուրը տեղի է ունենում a_i տարիների պարբերականությամբ, խնդիրը գտնել Y_n տարին, երբ տեղի կունենա n-րդ իրադարձությունը, այն պայմանով, որ i+1 իրադարձության հաշվարկը կարող է սկսվել միայն i իրադարձության տեղի ունենալուց անմիջապես հետո տարում:\n    >>> f_32(6, (int[]){3,2,4,5,9,18})\n    36", "bn": "একটি n ঘটনাবলীর ক্রম দেওয়া হয়েছে, প্রতিটি a_i বছর পরপর ঘটে, সমস্যাটি হল n-তম ঘটনা যে বছর Y_n এ ঘটে তা খুঁজে বের করা, এই শর্তের অধীনে যে ঘটনা i+1 এর জন্য কাউন্টডাউন শুধুমাত্র ঘটনা i ঘটার পরবর্তী বছরেই শুরু হতে পারে। \n    >>> f_32(6, (int[]){3,2,4,5,9,18})\n    36", "bg": "Като се даде последователност от n събития, всяко от които се случва с периодичност от a_i години, задачата е да се намери годината Y_n, когато се случва n-тото събитие, при условие че отброяването за събитие i+1 може да започне само в годината, непосредствено следваща настъпването на събитие i.\n    >>> f_32(6, (int[]){3,2,4,5,9,18})\n    36", "zh": "给定一个长度为 n 的事件序列，每个事件以 a_i 年的周期发生，问题是找出第 n 个事件发生的年份 Y_n，条件是事件 i+1 的倒计时只能在事件 i 发生后的下一年开始。\n    >>> f_32(6, (int[]){3,2,4,5,9,18})\n    36", "fr": "Étant donné une séquence de n événements, chacun se produisant avec une périodicité de a_i années, le problème est de trouver l'année Y_n lorsque le n-ième événement se produit, sous la condition que le compte à rebours pour l'événement i+1 ne peut commencer que l'année suivant immédiatement la survenue de l'événement i.\n    >>> f_32(6, (int[]){3,2,4,5,9,18})\n    36", "de": "Angenommen, es gibt eine Sequenz von n Ereignissen, die jeweils mit einer Periodizität von a_i Jahren auftreten, besteht das Problem darin, das Jahr Y_n zu finden, in dem das n-te Ereignis eintritt, unter der Bedingung, dass der Countdown für das Ereignis i+1 erst im Jahr unmittelbar nach dem Eintreten des Ereignisses i beginnen kann. \n    >>> f_32(6, (int[]){3,2,4,5,9,18})\n    36", "ha": "An ba da jerin abubuwan n, kowanne yana faruwa tare da maimaitawa na a_i shekaru, matsalar ita ce gano shekarar Y_n lokacin da abin n-th ya faru, a karkashin yanayin cewa ƙidayar don abin i+1 na iya farawa kawai a shekarar da ke biye da faruwar abin i.\n    >>> f_32(6, (int[]){3,2,4,5,9,18})\n    36", "hi": "दिए गए n घटनाओं के अनुक्रम में, प्रत्येक घटना a_i वर्षों की आवृत्ति के साथ होती है, समस्या यह है कि nवीं घटना के घटित होने वाले वर्ष Y_n को खोजना है, इस शर्त के तहत कि घटना i+1 की उलटी गिनती केवल घटना i के घटित होने के तुरंत बाद वाले वर्ष में ही शुरू हो सकती है। \n    >>> f_32(6, (int[]){3,2,4,5,9,18})\n    36", "hu": "Adott egy n eseményből álló sorozat, amelyek mindegyike a_i évek periodicitással következik be, a feladat az Y_n év megtalálása, amikor az n-edik esemény bekövetkezik, azzal a feltétellel, hogy az i+1 esemény visszaszámlálása csak az i esemény bekövetkezését követő évben kezdődhet meg.\n    >>> f_32(6, (int[]){3,2,4,5,9,18})\n    36", "es": "Dada una secuencia de n eventos, cada uno ocurriendo con una periodicidad de a_i años, el problema es encontrar el año Y_n cuando ocurre el n-ésimo evento, bajo la condición de que la cuenta regresiva para el evento i+1 solo puede comenzar en el año inmediatamente siguiente a la ocurrencia del evento i.\n    >>> f_32(6, (int[]){3,2,4,5,9,18})\n    36", "arb": "بالنظر إلى تسلسل من n أحداث، كل منها يحدث بتواتر a_i سنوات، تكمن المشكلة في إيجاد السنة Y_n عندما يحدث الحدث n، تحت شرط أن العد التنازلي للحدث i+1 يمكن أن يبدأ فقط في السنة التي تلي مباشرة حدوث الحدث i. \n    >>> f_32(6, (int[]){3,2,4,5,9,18})\n    36", "sw": "Kwa kuzingatia mlolongo wa matukio n, kila moja likitokea kwa kipindi cha miaka a_i, tatizo ni kupata mwaka Y_n ambapo tukio la n linatokea, chini ya sharti kwamba kuhesabu kwa tukio i+1 kunaweza kuanza tu katika mwaka unaofuata mara baada ya tukio i kutokea. \n    >>> f_32(6, (int[]){3,2,4,5,9,18})\n    36", "tr": "Verilen n olayından oluşan bir dizide, her biri a_i yıl periyoduyla gerçekleşen olaylar için, n'inci olayın gerçekleştiği Y_n yılını bulma problemi, i+1 olayının geri sayımının yalnızca i olayının gerçekleştiği yılın hemen ardından başlayabileceği koşulu altında çözülmelidir. \n    >>> f_32(6, (int[]){3,2,4,5,9,18})\n    36", "vi": "Cho một dãy gồm n sự kiện, mỗi sự kiện xảy ra với chu kỳ a_i năm, vấn đề là tìm năm Y_n khi sự kiện thứ n xảy ra, với điều kiện rằng việc đếm ngược cho sự kiện i+1 chỉ có thể bắt đầu vào năm ngay sau khi sự kiện i xảy ra.\n    >>> f_32(6, (int[]){3,2,4,5,9,18})\n    36", "id": "Diberikan sebuah urutan dari n kejadian, masing-masing terjadi dengan periodisitas a_i tahun, masalahnya adalah menemukan tahun Y_n ketika kejadian ke-n terjadi, dengan kondisi bahwa hitungan mundur untuk kejadian i+1 hanya dapat dimulai pada tahun segera setelah terjadinya kejadian i.\n    >>> f_32(6, (int[]){3,2,4,5,9,18})\n    36", "ja": "n個のイベントのシーケンスが与えられ、それぞれがa_i年の周期で発生する場合、問題はn番目のイベントが発生する年Y_nを見つけることです。条件として、イベントi+1のカウントダウンは、イベントiが発生した直後の年にのみ開始できるとします。\n    >>> f_32(6, (int[]){3,2,4,5,9,18})\n    36", "ko": "주어진 n개의 사건 시퀀스에서 각 사건은 a_i년의 주기로 발생하며, 문제는 n번째 사건이 발생하는 연도 Y_n을 찾는 것입니다. 여기서 사건 i+1의 카운트다운은 사건 i가 발생한 다음 해에만 시작할 수 있는 조건이 있습니다.\n    >>> f_32(6, (int[]){3,2,4,5,9,18})\n    36", "ml": "നിർദ്ദിഷ്ടമായ n സംഭവങ്ങളുടെ ഒരു നിര നൽകിയിരിക്കുമ്പോൾ, ഓരോത് a_i വർഷങ്ങളുടെ കാലക്രമത്തിൽ സംഭവിക്കുന്നു, n-ആമത്തെ സംഭവം Y_n വർഷത്തിൽ സംഭവിക്കുന്ന വർഷം കണ്ടെത്തുക എന്നതാണ് പ്രശ്നം. ഇവിടെയുള്ള വ്യവസ്ഥയനുസരിച്ച്, i+1-ആമത്തെ സംഭവത്തിന്റെ കൌണ്ട്ഡൗൺ, i-ആമത്തെ സംഭവം നടന്ന വർഷത്തിന് തൊട്ടടുത്ത വർഷം മാത്രമേ ആരംഭിക്കാവൂ. \n    >>> f_32(6, (int[]){3,2,4,5,9,18})\n    36", "fa": "با توجه به دنباله‌ای از n رویداد، که هر کدام با دوره تناوب a_i سال رخ می‌دهند، مسئله این است که سال Y_n را پیدا کنیم که در آن n-امین رویداد رخ می‌دهد، تحت این شرط که شمارش معکوس برای رویداد i+1 تنها می‌تواند در سال بلافاصله پس از وقوع رویداد i آغاز شود.\n    >>> f_32(6, (int[]){3,2,4,5,9,18})\n    36"}}
{"task_id": "C/33", "prompt": {"en": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nThis problem introduces a new modulo operation, denoted by the symbol \"⊕\". When calculating x ⊕ y, if x is not a multiple of y, the result is the remainder of x divided by y. Otherwise, divide x by y repeatedly until x is no longer a multiple of y, denoting the final value as x'. Then the result is the remainder of x' divided by y. For example, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nGiven a prime number p, there will be several queries. For each query, an integer n is given, and you need to compute the value of n! ⊕ p, where n! is the factorial of n, i.e., the product of all positive integers less than or equal to n.\n    >>> f_33(3, 7)\n    6\n*/\nunsigned long long f_33(unsigned long long n, unsigned long long p)", "sq": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nKy problem prezanton një operacion të ri modulo, i shënuar me simbolin \"⊕\". Kur llogaritni x ⊕ y, nëse x nuk është shumëfish i y, rezultati është mbetja e x e ndarë me y. Përndryshe, ndani x me y vazhdimisht derisa x të mos jetë më shumëfish i y, duke e shënuar vlerën përfundimtare si x'. Atëherë rezultati është mbetja e x' e ndarë me y. Për shembull, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nDuke pasur një numër të thjeshtë p, do të ketë disa kërkesa. Për secilën kërkesë, jepet një numër i plotë n, dhe ju duhet të llogaritni vlerën e n! ⊕ p, ku n! është faktoriali i n, dmth., prodhimi i të gjithë numrave të plotë pozitivë më të vegjël ose të barabartë me n.\n    >>> f_33(3, 7)\n    6\n*/\nunsigned long long f_33(unsigned long long n, unsigned long long p)", "hy": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nԱյս խնդիրը ներկայացնում է նոր մնացորդային գործողություն, որը նշված է \"⊕\" սիմվոլով: Երբ հաշվարկում ենք x ⊕ y, եթե x-ը y-ի բազմապատիկ չէ, արդյունքը x-ի բաժանումից y-ի մնացորդն է: Հակառակ դեպքում, բազմիցս բաժանեք x-ը y-ի վրա, մինչև x-ը այլևս y-ի բազմապատիկ չլինի, վերջնական արժեքը նշելով որպես x': Ապա արդյունքը x'-ի բաժանումից y-ի մնացորդն է: Օրինակ, 4⊕5=4, 20⊕5=4, 100⊕5=4:\nՏրված է p պարզ թիվը, և լինելու են մի քանի հարցումներ: Յուրաքանչյուր հարցման համար տրված է n ամբողջ թիվը, և դուք պետք է հաշվարկեք n! ⊕ p արժեքը, որտեղ n! n-ի ֆակտորիալն է, այսինքն՝ n-ից փոքր կամ հավասար բոլոր դրական ամբողջ թվերի արտադրյալը:\n    >>> f_33(3, 7)\n    6\n*/\nunsigned long long f_33(unsigned long long n, unsigned long long p)", "bn": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nএই সমস্যাটি একটি নতুন মডুলো অপারেশন পরিচয় করিয়ে দেয়, যা \"⊕\" প্রতীক দ্বারা চিহ্নিত। যখন x ⊕ y গণনা করা হয়, যদি x y এর গুণিতক না হয়, তাহলে ফলাফল হবে x কে y দ্বারা ভাগ করলে যে অবশিষ্টাংশ থাকে তা। অন্যথায়, x কে y দ্বারা বারবার ভাগ করুন যতক্ষণ না x আর y এর গুণিতক থাকে, চূড়ান্ত মানটিকে x' হিসাবে চিহ্নিত করুন। তারপর ফলাফল হবে x' কে y দ্বারা ভাগ করলে যে অবশিষ্টাংশ থাকে তা। উদাহরণস্বরূপ, 4⊕5=4, 20⊕5=4, 100⊕5=4।\nএকটি মৌলিক সংখ্যা p দেওয়া হলে, বেশ কয়েকটি প্রশ্ন থাকবে। প্রতিটি প্রশ্নের জন্য, একটি পূর্ণসংখ্যা n দেওয়া হবে, এবং আপনাকে n! ⊕ p এর মান গণনা করতে হবে, যেখানে n! হল n এর ফ্যাক্টোরিয়াল, অর্থাৎ n এর চেয়ে ছোট বা সমান সমস্ত ধনাত্মক পূর্ণসংখ্যার গুণফল।\n    >>> f_33(3, 7)\n    6\n*/\nunsigned long long f_33(unsigned long long n, unsigned long long p)", "bg": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nТози проблем въвежда нова операция модуло, означена със символа \"⊕\". При изчисляване на x ⊕ y, ако x не е кратно на y, резултатът е остатъкът от делението на x на y. В противен случай, разделяйте x на y многократно, докато x вече не е кратно на y, като отбелязвате крайната стойност като x'. Тогава резултатът е остатъкът от делението на x' на y. Например, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nДадено е просто число p, ще има няколко заявки. За всяка заявка е дадено цяло число n, и трябва да изчислите стойността на n! ⊕ p, където n! е факториелът на n, т.е. произведението на всички положителни цели числа, по-малки или равни на n.\n    >>> f_33(3, 7)\n    6\n*/\nunsigned long long f_33(unsigned long long n, unsigned long long p)", "zh": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\n这个问题引入了一种新的模运算，用符号“⊕”表示。计算 x ⊕ y 时，如果 x 不是 y 的倍数，结果是 x 除以 y 的余数。否则，反复将 x 除以 y，直到 x 不再是 y 的倍数，记最终值为 x'。然后结果是 x' 除以 y 的余数。例如，4⊕5=4，20⊕5=4，100⊕5=4。\n给定一个素数 p，会有若干查询。对于每个查询，给定一个整数 n，你需要计算 n! ⊕ p 的值，其中 n! 是 n 的阶乘，即小于或等于 n 的所有正整数的乘积。\n    >>> f_33(3, 7)\n    6\n*/\nunsigned long long f_33(unsigned long long n, unsigned long long p)", "fr": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nCe problème introduit une nouvelle opération modulo, notée par le symbole \"⊕\". Lors du calcul de x ⊕ y, si x n'est pas un multiple de y, le résultat est le reste de la division de x par y. Sinon, divisez x par y de manière répétée jusqu'à ce que x ne soit plus un multiple de y, en désignant la valeur finale par x'. Ensuite, le résultat est le reste de la division de x' par y. Par exemple, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nÉtant donné un nombre premier p, il y aura plusieurs requêtes. Pour chaque requête, un entier n est donné, et vous devez calculer la valeur de n! ⊕ p, où n! est la factorielle de n, c'est-à-dire le produit de tous les entiers positifs inférieurs ou égaux à n.\n    >>> f_33(3, 7)\n    6\n*/\nunsigned long long f_33(unsigned long long n, unsigned long long p)", "de": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nDieses Problem führt eine neue Modulo-Operation ein, die durch das Symbol \"⊕\" dargestellt wird. Bei der Berechnung von x ⊕ y, wenn x kein Vielfaches von y ist, ist das Ergebnis der Rest von x geteilt durch y. Andernfalls teilen Sie x wiederholt durch y, bis x kein Vielfaches von y mehr ist, und bezeichnen den Endwert als x'. Dann ist das Ergebnis der Rest von x' geteilt durch y. Zum Beispiel, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nGegeben ist eine Primzahl p, es wird mehrere Anfragen geben. Für jede Anfrage wird eine ganze Zahl n gegeben, und Sie müssen den Wert von n! ⊕ p berechnen, wobei n! die Fakultät von n ist, d.h. das Produkt aller positiven ganzen Zahlen kleiner oder gleich n.\n    >>> f_33(3, 7)\n    6\n*/\nunsigned long long f_33(unsigned long long n, unsigned long long p)", "ha": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nWannan matsalar tana gabatar da sabon aikin modulo, wanda aka nuna da alamar \"⊕\". Lokacin da ake lissafin x ⊕ y, idan x ba shi ne sau na y ba, sakamakon shi ne saura na x raba da y. In ba haka ba, raba x da y akai-akai har sai x ba shi ne sau na y ba, yana nuna ƙimar ƙarshe a matsayin x'. Sannan sakamakon shi ne saura na x' raba da y. Alal misali, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nAn ba da lambar farko p, za a sami tambayoyi da yawa. Ga kowace tambaya, ana ba da cikakken lamba n, kuma kuna buƙatar lissafin ƙimar n! ⊕ p, inda n! shine factorial na n, wato, samfurin duk lambobin da suka fi n ƙasa ko daidai da n.\n    >>> f_33(3, 7)\n    6\n*/\nunsigned long long f_33(unsigned long long n, unsigned long long p)", "hi": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nयह समस्या एक नया माड्यूलो ऑपरेशन प्रस्तुत करती है, जिसे प्रतीक \"⊕\" द्वारा दर्शाया गया है। जब x ⊕ y की गणना की जाती है, यदि x, y का गुणज नहीं है, तो परिणाम x को y से विभाजित करने का शेषफल होता है। अन्यथा, x को y से बार-बार विभाजित करें जब तक कि x अब y का गुणज न हो, अंतिम मान को x' के रूप में दर्शाते हुए। फिर परिणाम x' को y से विभाजित करने का शेषफल होता है। उदाहरण के लिए, 4⊕5=4, 20⊕5=4, 100⊕5=4।\nदिए गए एक अभाज्य संख्या p के लिए, कई प्रश्न होंगे। प्रत्येक प्रश्न के लिए, एक पूर्णांक n दिया गया है, और आपको n! ⊕ p का मान गणना करने की आवश्यकता है, जहाँ n! n का फैक्टोरियल है, अर्थात् n से कम या उसके बराबर सभी धनात्मक पूर्णांकों का गुणनफल।\n    >>> f_33(3, 7)\n    6\n*/\nunsigned long long f_33(unsigned long long n, unsigned long long p)", "hu": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nEz a probléma egy új modulo műveletet vezet be, amelyet a \"⊕\" szimbólum jelöl. Amikor az x ⊕ y-t számítjuk, ha x nem osztható y-nal, az eredmény x maradéka y osztásakor. Ellenkező esetben osszuk el x-et y-nal ismételten, amíg x már nem osztható y-nal, és jelöljük a végső értéket x'-ként. Ekkor az eredmény x' maradéka y osztásakor. Például, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nAdott egy prímszám p, és több lekérdezés lesz. Minden lekérdezéshez adott egy egész szám n, és ki kell számítani az n! ⊕ p értékét, ahol n! az n faktoriálisa, azaz az összes pozitív egész szám szorzata, amelyek kisebbek vagy egyenlők n-nél.\n    >>> f_33(3, 7)\n    6\n*/\nunsigned long long f_33(unsigned long long n, unsigned long long p)", "es": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nEste problema introduce una nueva operación de módulo, denotada por el símbolo \"⊕\". Al calcular x ⊕ y, si x no es un múltiplo de y, el resultado es el residuo de x dividido por y. De lo contrario, divide x por y repetidamente hasta que x ya no sea un múltiplo de y, denotando el valor final como x'. Entonces, el resultado es el residuo de x' dividido por y. Por ejemplo, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nDado un número primo p, habrá varias consultas. Para cada consulta, se da un número entero n, y necesitas calcular el valor de n! ⊕ p, donde n! es el factorial de n, es decir, el producto de todos los enteros positivos menores o iguales a n.\n    >>> f_33(3, 7)\n    6\n*/\nunsigned long long f_33(unsigned long long n, unsigned long long p)", "arb": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nهذه المسألة تقدم عملية جديدة تسمى \"⊕\". عند حساب x ⊕ y، إذا لم يكن x مضاعفًا لـ y، تكون النتيجة هي باقي قسمة x على y. أما إذا كان x مضاعفًا لـ y، نقوم بقسمة x على y بشكل متكرر حتى لا يكون x مضاعفًا لـ y، ونرمز للقيمة النهائية بـ x'. ثم تكون النتيجة هي باقي قسمة x' على y. على سبيل المثال، 4⊕5=4، 20⊕5=4، 100⊕5=4.\nبالنظر إلى عدد أولي p، سيكون هناك عدة استفسارات. لكل استفسار، يُعطى عدد صحيح n، وتحتاج إلى حساب قيمة n! ⊕ p، حيث n! هو مضروب n، أي حاصل ضرب جميع الأعداد الصحيحة الموجبة الأقل من أو تساوي n.\n    >>> f_33(3, 7)\n    6\n*/\nunsigned long long f_33(unsigned long long n, unsigned long long p)", "sw": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nTatizo hili linaanzisha operesheni mpya ya modulo, inayojulikana kwa alama \"⊕\". Wakati wa kuhesabu x ⊕ y, ikiwa x si kigezo cha y, matokeo ni baki ya x iliyogawanywa na y. Vinginevyo, gawanya x kwa y mara kwa mara hadi x isiwe tena kigezo cha y, ukionyesha thamani ya mwisho kama x'. Kisha matokeo ni baki ya x' iliyogawanywa na y. Kwa mfano, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nUkipiwa nambari ya kwanza p, kutakuwa na maswali kadhaa. Kwa kila swali, nambari kamili n inatolewa, na unahitaji kuhesabu thamani ya n! ⊕ p, ambapo n! ni factorial ya n, yaani, bidhaa ya nambari zote kamili chanya zilizo chini au sawa na n.\n    >>> f_33(3, 7)\n    6\n*/\nunsigned long long f_33(unsigned long long n, unsigned long long p)", "tr": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nBu problem, \"⊕\" sembolü ile gösterilen yeni bir modül işlemi tanıtmaktadır. x ⊕ y hesaplanırken, x y'nin katı değilse, sonuç x'in y'ye bölünmesinden kalan değerdir. Aksi takdirde, x y'nin katı olmayana kadar x'i y'ye tekrar tekrar bölün, son değeri x' olarak belirtin. Sonuç, x' in y'ye bölünmesinden kalan değerdir. Örneğin, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nVerilen bir asal sayı p için, birkaç sorgu olacaktır. Her sorgu için bir tamsayı n verilir ve n! ⊕ p değerini hesaplamanız gerekir, burada n! n'nin faktöriyelidir, yani n'ye eşit veya daha küçük olan tüm pozitif tamsayıların çarpımıdır.\n    >>> f_33(3, 7)\n    6\n*/\nunsigned long long f_33(unsigned long long n, unsigned long long p)", "vi": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nVấn đề này giới thiệu một phép toán modulo mới, được ký hiệu bằng biểu tượng \"⊕\". Khi tính toán x ⊕ y, nếu x không phải là bội số của y, kết quả là phần dư của x chia cho y. Ngược lại, chia x cho y liên tục cho đến khi x không còn là bội số của y, ký hiệu giá trị cuối cùng là x'. Sau đó, kết quả là phần dư của x' chia cho y. Ví dụ, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nCho một số nguyên tố p, sẽ có một số truy vấn. Đối với mỗi truy vấn, một số nguyên n được đưa ra, và bạn cần tính giá trị của n! ⊕ p, trong đó n! là giai thừa của n, tức là tích của tất cả các số nguyên dương nhỏ hơn hoặc bằng n.\n    >>> f_33(3, 7)\n    6\n*/\nunsigned long long f_33(unsigned long long n, unsigned long long p)", "id": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nMasalah ini memperkenalkan operasi modulo baru, yang dilambangkan dengan simbol \"⊕\". Ketika menghitung x ⊕ y, jika x bukan kelipatan dari y, hasilnya adalah sisa dari x dibagi y. Jika tidak, bagi x dengan y berulang kali sampai x tidak lagi menjadi kelipatan dari y, menandai nilai akhir sebagai x'. Kemudian hasilnya adalah sisa dari x' dibagi y. Sebagai contoh, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nDiberikan sebuah bilangan prima p, akan ada beberapa kueri. Untuk setiap kueri, diberikan sebuah bilangan bulat n, dan Anda perlu menghitung nilai dari n! ⊕ p, di mana n! adalah faktorial dari n, yaitu hasil kali dari semua bilangan bulat positif yang kurang dari atau sama dengan n.\n    >>> f_33(3, 7)\n    6\n*/\nunsigned long long f_33(unsigned long long n, unsigned long long p)", "ja": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nこの問題では、新しい剰余演算「⊕」を導入します。x ⊕ y を計算する際、x が y の倍数でない場合、結果は x を y で割った余りです。そうでない場合、x を y で割り続け、x が y の倍数でなくなるまで繰り返し、最終的な値を x' とします。そして、結果は x' を y で割った余りです。例えば、4⊕5=4, 20⊕5=4, 100⊕5=4 です。\n素数 p が与えられたとき、いくつかのクエリがあります。各クエリでは整数 n が与えられ、n! ⊕ p の値を計算する必要があります。ここで、n! は n の階乗であり、n 以下のすべての正の整数の積です。\n    >>> f_33(3, 7)\n    6\n*/\nunsigned long long f_33(unsigned long long n, unsigned long long p)", "ko": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\n이 문제는 \"⊕\" 기호로 표시되는 새로운 모듈로 연산을 도입합니다. x ⊕ y를 계산할 때, x가 y의 배수가 아닌 경우 결과는 x를 y로 나눈 나머지입니다. 그렇지 않으면 x를 y로 반복적으로 나누어 x가 더 이상 y의 배수가 아닐 때까지 나누고, 최종 값을 x'로 표시합니다. 그런 다음 결과는 x'를 y로 나눈 나머지입니다. 예를 들어, 4⊕5=4, 20⊕5=4, 100⊕5=4입니다.\n소수 p가 주어지면 여러 쿼리가 있을 것입니다. 각 쿼리에 대해 정수 n이 주어지며, n! ⊕ p의 값을 계산해야 합니다. 여기서 n!은 n보다 작거나 같은 모든 양의 정수의 곱인 팩토리얼입니다.\n    >>> f_33(3, 7)\n    6\n*/\nunsigned long long f_33(unsigned long long n, unsigned long long p)\n", "ml": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nഈ പ്രശ്നം \"⊕\" എന്ന ചിഹ്നം ഉപയോഗിച്ച് ഒരു പുതിയ മോഡുലോ ഓപ്പറേഷൻ പരിചയപ്പെടുത്തുന്നു. x ⊕ y കണക്കാക്കുമ്പോൾ, x y-ന്റെ ഗുണിതമല്ലെങ്കിൽ, ഫലം x y-ൽ വിഭജിച്ച ശേഷമുള്ള ശേഷമാണ്. അല്ലെങ്കിൽ, x y-ൽ നിന്ന് ഗുണിതമല്ലാത്തതുവരെ x ആവർത്തിച്ച് വിഭജിക്കുക, അന്തിമ മൂല്യം x' ആയി രേഖപ്പെടുത്തുക. തുടർന്ന് ഫലം x' y-ൽ വിഭജിച്ച ശേഷമുള്ള ശേഷമാണ്. ഉദാഹരണത്തിന്, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nഒരു പ്രൈം നമ്പർ p നൽകിയാൽ, നിരവധി ക്വറിയുകൾ ഉണ്ടാകും. ഓരോ ക്വറിയിനും, ഒരു പൂർണ്ണസംഖ്യ n നൽകപ്പെടുന്നു, നിങ്ങൾ n! ⊕ p-ന്റെ മൂല്യം കണക്കാക്കണം, n! എന്നത് n-നേക്കാൾ കുറവോ തുല്യമായോ ആയ എല്ലാ ധനാത്മക പൂർണ്ണസംഖ്യകളുടെ ഗുണഫലമാണ്.\n    >>> f_33(3, 7)\n    6\n*/\nunsigned long long f_33(unsigned long long n, unsigned long long p)", "fa": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nاین مسئله یک عملگر جدید باقیمانده را معرفی می‌کند که با نماد \"⊕\" نشان داده می‌شود. هنگام محاسبه x ⊕ y، اگر x مضربی از y نباشد، نتیجه باقیمانده تقسیم x بر y است. در غیر این صورت، x را به طور مکرر بر y تقسیم کنید تا زمانی که x دیگر مضربی از y نباشد، مقدار نهایی را به عنوان x' نشان دهید. سپس نتیجه باقیمانده x' تقسیم بر y است. برای مثال، 4⊕5=4، 20⊕5=4، 100⊕5=4.\nبا توجه به یک عدد اول p، چندین پرسش وجود خواهد داشت. برای هر پرسش، یک عدد صحیح n داده می‌شود و شما باید مقدار n! ⊕ p را محاسبه کنید، که در آن n! فاکتوریل n است، یعنی حاصل‌ضرب تمام اعداد صحیح مثبت کمتر یا مساوی n.\n    >>> f_33(3, 7)\n    6\n*/\nunsigned long long f_33(unsigned long long n, unsigned long long p)\n"}, "canonical_solution": "{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n    \n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}", "instruction": {"en": "Write a C function `unsigned long long f_33(unsigned long long n, unsigned long long p)` to solve the following problem:\nThis problem introduces a new modulo operation, denoted by the symbol \"⊕\". When calculating x ⊕ y, if x is not a multiple of y, the result is the remainder of x divided by y. Otherwise, divide x by y repeatedly until x is no longer a multiple of y, denoting the final value as x'. Then the result is the remainder of x' divided by y. For example, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nGiven a prime number p, there will be several queries. For each query, an integer n is given, and you need to compute the value of n! ⊕ p, where n! is the factorial of n, i.e., the product of all positive integers less than or equal to n.\n    >>> f_33(3, 7)\n    6\n", "sq": "Shkruani një funksion në C `unsigned long long f_33(unsigned long long n, unsigned long long p)` për të zgjidhur problemin e mëposhtëm:\nKy problem prezanton një operacion të ri modulo, i shënuar me simbolin \"⊕\". Kur llogaritni x ⊕ y, nëse x nuk është shumëfish i y, rezultati është mbetja e x pjesëtuar me y. Përndryshe, ndani x me y në mënyrë të përsëritur derisa x të mos jetë më shumëfish i y, duke e shënuar vlerën përfundimtare si x'. Pastaj rezultati është mbetja e x' pjesëtuar me y. Për shembull, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nDuke pasur një numër të plotë prim p, do të ketë disa kërkesa. Për çdo kërkesë, jepet një numër i plotë n, dhe ju duhet të llogaritni vlerën e n! ⊕ p, ku n! është faktoriali i n, dmth, prodhimi i të gjithë numrave të plotë pozitivë më të vegjël ose të barabartë me n.\n    >>> f_33(3, 7)\n    6", "hy": "Գրեք C ֆունկցիա `unsigned long long f_33(unsigned long long n, unsigned long long p)`՝ հետևյալ խնդիրը լուծելու համար:\nԱյս խնդիրը ներմուծում է նոր մոդուլո գործողություն, որը նշվում է \"⊕\" նշանով: Երբ հաշվարկում ենք x ⊕ y, եթե x-ը y-ի բազմապատիկ չէ, արդյունքը x-ի y-ով բաժանման մնացորդն է: Հակառակ դեպքում, բաժանեք x-ը y-ով կրկնակիորեն, մինչև x-ը այլևս y-ի բազմապատիկ չլինի, վերջնական արժեքը նշելով որպես x': Ապա արդյունքը x'-ի y-ով բաժանման մնացորդն է: Օրինակ, 4⊕5=4, 20⊕5=4, 100⊕5=4:\nՏրված է p պարզ թիվը, և կլինեն մի քանի հարցումներ: Յուրաքանչյուր հարցման համար տրված է n ամբողջ թիվը, և դուք պետք է հաշվեք n! ⊕ p արժեքը, որտեղ n! n-ի ֆակտորիալն է, այսինքն՝ n-ից փոքր կամ հավասար բոլոր դրական ամբողջ թվերի արտադրյալը:\n    >>> f_33(3, 7)\n    6", "bn": "একটি C ফাংশন `unsigned long long f_33(unsigned long long n, unsigned long long p)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএই সমস্যাটি একটি নতুন মডুলো অপারেশন প্রবর্তন করে, যা \"⊕\" প্রতীকে চিহ্নিত। যখন x ⊕ y গণনা করা হয়, যদি x y এর গুণিতক না হয়, তাহলে ফলাফল হল x কে y দ্বারা ভাগ করার পরে যে ভাগশেষ থাকে। অন্যথায়, x কে y দ্বারা বারবার ভাগ করুন যতক্ষণ না x আর y এর গুণিতক থাকে, চূড়ান্ত মানটিকে x' হিসাবে চিহ্নিত করুন। তারপর ফলাফল হল x' কে y দ্বারা ভাগ করার পরে যে ভাগশেষ থাকে। উদাহরণস্বরূপ, 4⊕5=4, 20⊕5=4, 100⊕5=4।\nএকটি মৌলিক সংখ্যা p দেওয়া হয়েছে, এবং বেশ কয়েকটি অনুসন্ধান থাকবে। প্রতিটি অনুসন্ধানের জন্য, একটি পূর্ণসংখ্যা n দেওয়া হয়, এবং আপনাকে n! ⊕ p এর মান গণনা করতে হবে, যেখানে n! হল n এর ফ্যাক্টোরিয়াল, অর্থাৎ n এর চেয়ে ছোট বা সমান সমস্ত ধনাত্মক পূর্ণসংখ্যার গুণফল।\n    >>> f_33(3, 7)\n    6", "bg": "Напишете C функция `unsigned long long f_33(unsigned long long n, unsigned long long p)`, за да решите следния проблем:\nТози проблем въвежда нова операция за модул, обозначена със символа \"⊕\". Когато изчислявате x ⊕ y, ако x не е кратно на y, резултатът е остатъкът от x, разделен на y. В противен случай разделяйте x на y многократно, докато x вече не е кратно на y, като крайната стойност се обозначава като x'. Тогава резултатът е остатъкът от x', разделен на y. Например, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nДадено е просто число p, ще има няколко заявки. За всяка заявка е дадено цяло число n, и трябва да изчислите стойността на n! ⊕ p, където n! е факториелът на n, т.е. произведението на всички положителни цели числа, по-малки или равни на n.\n    >>> f_33(3, 7)\n    6", "zh": "编写一个 C 函数 `unsigned long long f_33(unsigned long long n, unsigned long long p)` 来解决以下问题：\n此问题引入了一种新的模运算，用符号“⊕”表示。当计算 x ⊕ y 时，如果 x 不是 y 的倍数，则结果是 x 除以 y 的余数。否则，反复将 x 除以 y，直到 x 不再是 y 的倍数，将最终值记为 x'。然后结果是 x' 除以 y 的余数。例如，4⊕5=4，20⊕5=4，100⊕5=4。\n给定一个素数 p，将会有若干查询。对于每个查询，给定一个整数 n，你需要计算 n! ⊕ p 的值，其中 n! 是 n 的阶乘，即小于或等于 n 的所有正整数的乘积。\n    >>> f_33(3, 7)\n    6", "fr": "Écrire une fonction C `unsigned long long f_33(unsigned long long n, unsigned long long p)` pour résoudre le problème suivant :\nCe problème introduit une nouvelle opération modulo, notée par le symbole \"⊕\". Lors du calcul de x ⊕ y, si x n'est pas un multiple de y, le résultat est le reste de x divisé par y. Sinon, divisez x par y de manière répétée jusqu'à ce que x ne soit plus un multiple de y, en désignant la valeur finale par x'. Ensuite, le résultat est le reste de x' divisé par y. Par exemple, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nÉtant donné un nombre premier p, il y aura plusieurs requêtes. Pour chaque requête, un entier n est donné, et vous devez calculer la valeur de n! ⊕ p, où n! est la factorielle de n, c'est-à-dire le produit de tous les entiers positifs inférieurs ou égaux à n.\n    >>> f_33(3, 7)\n    6", "de": "Schreiben Sie eine C-Funktion `unsigned long long f_33(unsigned long long n, unsigned long long p)`, um das folgende Problem zu lösen:\nDieses Problem führt eine neue Modulo-Operation ein, die durch das Symbol \"⊕\" dargestellt wird. Bei der Berechnung von x ⊕ y, wenn x kein Vielfaches von y ist, ist das Ergebnis der Rest von x geteilt durch y. Andernfalls teilen Sie x wiederholt durch y, bis x kein Vielfaches von y mehr ist, und bezeichnen den Endwert als x'. Dann ist das Ergebnis der Rest von x' geteilt durch y. Zum Beispiel, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nGegeben ist eine Primzahl p, es wird mehrere Abfragen geben. Für jede Abfrage wird eine ganze Zahl n gegeben, und Sie müssen den Wert von n! ⊕ p berechnen, wobei n! die Fakultät von n ist, d.h. das Produkt aller positiven ganzen Zahlen kleiner oder gleich n.\n    >>> f_33(3, 7)\n    6", "ha": "Rubuta aikin C `unsigned long long f_33(unsigned long long n, unsigned long long p)` don warware matsalar mai zuwa:\nWannan matsalar tana gabatar da sabon aiki na modulo, wanda aka nuna da alamar \"⊕\". Lokacin da ake lissafin x ⊕ y, idan x ba sau biyu na y ba ne, sakamakon shine saura na x raba da y. In ba haka ba, a raba x da y akai-akai har sai x ba sau biyu na y ba ne, sannan a nuna ƙimar ƙarshe a matsayin x'. Sannan sakamakon shine saura na x' raba da y. Alal misali, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nAn ba da lambar farko p, za a sami tambayoyi da dama. Ga kowace tambaya, an ba da cikakken lamba n, kuma kuna buƙatar lissafin ƙimar n! ⊕ p, inda n! shine factorial na n, wato, samfurin duk lambobi masu kyau da suka fi ko daidai da n.", "hi": "C फ़ंक्शन `unsigned long long f_33(unsigned long long n, unsigned long long p)` लिखें ताकि निम्नलिखित समस्या को हल किया जा सके:\nयह समस्या एक नए मोड्यूलो ऑपरेशन को प्रस्तुत करती है, जिसे प्रतीक \"⊕\" द्वारा दर्शाया गया है। जब x ⊕ y की गणना की जाती है, यदि x, y का गुणज नहीं है, तो परिणाम x को y से भाग देने पर शेषफल होता है। अन्यथा, x को y से बार-बार भाग दें जब तक कि x अब y का गुणज न हो, अंतिम मान को x' के रूप में दर्शाते हुए। फिर परिणाम x' को y से भाग देने पर शेषफल होता है। उदाहरण के लिए, 4⊕5=4, 20⊕5=4, 100⊕5=4।\nएक अभाज्य संख्या p दी गई है, और कई क्वेरीज़ होंगी। प्रत्येक क्वेरी के लिए, एक पूर्णांक n दिया गया है, और आपको n! ⊕ p का मान निकालने की आवश्यकता है, जहाँ n! n का फैक्टोरियल है, अर्थात n से कम या बराबर सभी धनात्मक पूर्णांकों का गुणनफल।\n    >>> f_33(3, 7)\n    6", "hu": "Írj egy C függvényt `unsigned long long f_33(unsigned long long n, unsigned long long p)` a következő probléma megoldására:\nEz a probléma egy új modulo műveletet vezet be, amelyet a \"⊕\" szimbólum jelöl. Amikor x ⊕ y-t számítunk, ha x nem osztható y-nal, az eredmény x maradéka y-nal osztva. Ellenkező esetben osszuk el x-et y-nal ismételten, amíg x már nem osztható y-nal, és jelöljük az utolsó értéket x'-ként. Ekkor az eredmény x' maradéka y-nal osztva. Például, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nAdott egy prímszám p, és több lekérdezés lesz. Minden lekérdezéshez adott egy egész szám n, és ki kell számítanod n! ⊕ p értékét, ahol n! az n faktoriálisa, azaz az összes pozitív egész szám szorzata, amely kisebb vagy egyenlő n-nel.\n    >>> f_33(3, 7)\n    6", "es": "Escribe una función en C `unsigned long long f_33(unsigned long long n, unsigned long long p)` para resolver el siguiente problema:\nEste problema introduce una nueva operación de módulo, denotada por el símbolo \"⊕\". Al calcular x ⊕ y, si x no es un múltiplo de y, el resultado es el resto de x dividido por y. De lo contrario, divide x por y repetidamente hasta que x ya no sea un múltiplo de y, denotando el valor final como x'. Entonces, el resultado es el resto de x' dividido por y. Por ejemplo, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nDado un número primo p, habrá varias consultas. Para cada consulta, se da un entero n, y necesitas calcular el valor de n! ⊕ p, donde n! es el factorial de n, es decir, el producto de todos los enteros positivos menores o iguales a n.\n    >>> f_33(3, 7)\n    6", "arb": "اكتب دالة بلغة C `unsigned long long f_33(unsigned long long n, unsigned long long p)` لحل المشكلة التالية:\nتقدم هذه المشكلة عملية جديدة للمودولو، يرمز لها بالرمز \"⊕\". عند حساب x ⊕ y، إذا لم يكن x مضاعفًا لـ y، تكون النتيجة هي باقي قسمة x على y. أما إذا كان x مضاعفًا لـ y، فقم بقسمة x على y بشكل متكرر حتى لا يعود x مضاعفًا لـ y، ويُرمز للقيمة النهائية بـ x'. ثم تكون النتيجة هي باقي قسمة x' على y. على سبيل المثال، 4⊕5=4، 20⊕5=4، 100⊕5=4.\nبالنظر إلى عدد أولي p، سيكون هناك عدة استفسارات. لكل استفسار، يُعطى عدد صحيح n، وتحتاج إلى حساب قيمة n! ⊕ p، حيث n! هو مضروب n، أي حاصل ضرب جميع الأعداد الصحيحة الموجبة الأقل من أو تساوي n.\n    >>> f_33(3, 7)\n    6", "sw": "Andika kazi ya C `unsigned long long f_33(unsigned long long n, unsigned long long p)` kutatua tatizo lifuatalo:\nTatizo hili linaanzisha operesheni mpya ya modulo, inayojulikana kwa alama \"⊕\". Wakati wa kuhesabu x ⊕ y, ikiwa x si kigezo cha y, matokeo ni bakio la x kugawanywa na y. Vinginevyo, gawanya x kwa y mara kwa mara hadi x haiko tena kigezo cha y, na kuweka thamani ya mwisho kama x'. Kisha matokeo ni bakio la x' kugawanywa na y. Kwa mfano, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nUkipiwa nambari ya kwanza p, kutakuwa na maswali kadhaa. Kwa kila swali, nambari kamili n inapewa, na unahitaji kuhesabu thamani ya n! ⊕ p, ambapo n! ni faktoria ya n, yaani, bidhaa ya nambari zote chanya zilizo chini au sawa na n.\n    >>> f_33(3, 7)\n    6", "tr": "Bir C fonksiyonu `unsigned long long f_33(unsigned long long n, unsigned long long p)` yazın ve aşağıdaki problemi çözün:\nBu problem, \"⊕\" sembolü ile gösterilen yeni bir modül işlemi tanıtmaktadır. x ⊕ y hesaplanırken, eğer x, y'nin katı değilse, sonuç x'in y'ye bölümünden kalan olur. Aksi takdirde, x artık y'nin katı olmayana kadar x'i y'ye tekrar tekrar bölün, son değeri x' olarak belirtin. Sonuç, x' in y'ye bölümünden kalan olur. Örneğin, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nVerilen bir asal sayı p için, birkaç sorgu olacaktır. Her sorgu için bir tamsayı n verilir ve n! ⊕ p değerini hesaplamanız gerekir, burada n! n faktöriyelidir, yani n'den küçük veya eşit tüm pozitif tam sayıların çarpımıdır.\n    >>> f_33(3, 7)\n    6", "vi": "Viết một hàm C `unsigned long long f_33(unsigned long long n, unsigned long long p)` để giải quyết vấn đề sau:\nVấn đề này giới thiệu một phép toán modulo mới, được ký hiệu bằng biểu tượng \"⊕\". Khi tính toán x ⊕ y, nếu x không phải là bội số của y, kết quả là phần dư của x chia cho y. Ngược lại, chia x cho y liên tục cho đến khi x không còn là bội số của y, ký hiệu giá trị cuối cùng là x'. Sau đó kết quả là phần dư của x' chia cho y. Ví dụ, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nCho một số nguyên tố p, sẽ có nhiều truy vấn. Đối với mỗi truy vấn, một số nguyên n được cho, và bạn cần tính giá trị của n! ⊕ p, trong đó n! là giai thừa của n, tức là tích của tất cả các số nguyên dương nhỏ hơn hoặc bằng n.\n    >>> f_33(3, 7)\n    6", "id": "Tulis sebuah fungsi C `unsigned long long f_33(unsigned long long n, unsigned long long p)` untuk menyelesaikan masalah berikut:\nMasalah ini memperkenalkan operasi modulo baru, yang dilambangkan dengan simbol \"⊕\". Ketika menghitung x ⊕ y, jika x bukan kelipatan dari y, hasilnya adalah sisa dari x dibagi y. Jika tidak, bagi x dengan y berulang kali sampai x tidak lagi menjadi kelipatan dari y, menandai nilai akhir sebagai x'. Kemudian hasilnya adalah sisa dari x' dibagi y. Sebagai contoh, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nDiberikan sebuah bilangan prima p, akan ada beberapa kueri. Untuk setiap kueri, diberikan sebuah bilangan bulat n, dan Anda perlu menghitung nilai dari n! ⊕ p, di mana n! adalah faktorial dari n, yaitu produk dari semua bilangan bulat positif yang kurang dari atau sama dengan n.\n    >>> f_33(3, 7)\n    6", "ja": "Cの関数を書け `unsigned long long f_33(unsigned long long n, unsigned long long p)` を作成して、次の問題を解決してください:\nこの問題では、新しい剰余演算を導入します。これは記号 \"⊕\" で表されます。x ⊕ y を計算するとき、もし x が y の倍数でない場合、結果は x を y で割った余りです。そうでない場合、x を y で割り続け、x がもはや y の倍数でなくなるまで続け、その最終値を x' とします。そして結果は x' を y で割った余りです。例えば、4⊕5=4, 20⊕5=4, 100⊕5=4です。\n素数 p が与えられたとき、いくつかのクエリがあります。各クエリでは整数 n が与えられ、n! ⊕ p の値を計算する必要があります。ここで n! は n の階乗であり、n 以下のすべての正の整数の積です。\n    >>> f_33(3, 7)\n    6", "ko": "C 함수 `unsigned long long f_33(unsigned long long n, unsigned long long p)`를 작성하여 다음 문제를 해결하십시오:\n이 문제는 \"⊕\" 기호로 표시되는 새로운 모듈로 연산을 도입합니다. x ⊕ y를 계산할 때, x가 y의 배수가 아니면 결과는 x를 y로 나눈 나머지입니다. 그렇지 않으면, x가 더 이상 y의 배수가 아닐 때까지 x를 y로 반복적으로 나누고, 최종 값을 x'로 나타냅니다. 그런 다음 결과는 x'를 y로 나눈 나머지입니다. 예를 들어, 4⊕5=4, 20⊕5=4, 100⊕5=4입니다.\n소수 p가 주어지면 여러 쿼리가 있을 것입니다. 각 쿼리마다 정수 n이 주어지며, n! ⊕ p의 값을 계산해야 합니다. 여기서 n!은 n의 팩토리얼로, n 이하의 모든 양의 정수의 곱입니다.\n    >>> f_33(3, 7)\n    6", "ml": "ഒരു C ഫംഗ്ഷൻ എഴുതുക `unsigned long long f_33(unsigned long long n, unsigned long long p)` ചുവടെയുള്ള പ്രശ്നം പരിഹരിക്കാൻ:\nഈ പ്രശ്നം പുതിയൊരു മോഡുലോ ഓപ്പറേഷൻ അവതരിപ്പിക്കുന്നു, \"⊕\" എന്ന ചിഹ്നം ഉപയോഗിച്ച്. x ⊕ y കണക്കാക്കുമ്പോൾ, x y-ന്റെ ഗുണിതമല്ലെങ്കിൽ, ഫലം x y-ൽ വിഭജിക്കുമ്പോൾ ലഭിക്കുന്ന ശേഷമാണ്. അല്ലെങ്കിൽ, x y-ൽ വിഭജിക്കുമ്പോൾ x y-ന്റെ ഗുണിതമല്ലാതാകുന്നത് വരെ x y-ൽ പിരിച്ചെടുക്കുക, അന്തിമ മൂല്യം x' ആയി സൂചിപ്പിക്കുക. പിന്നീടുള്ള ഫലം x' y-ൽ വിഭജിക്കുമ്പോൾ ലഭിക്കുന്ന ശേഷമാണ്. ഉദാഹരണത്തിന്, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nഒരു പ്രധാന സംഖ്യ p നൽകിയാൽ, പല ക്വറിയുകളും ഉണ്ടായിരിക്കും. ഓരോ ക്വറിയിനും, ഒരു പൂർണ്ണസംഖ്യ n നൽകിയിരിക്കും, നിങ്ങൾ n! ⊕ p-ന്റെ മൂല്യം കണക്കാക്കേണ്ടതുണ്ട്, ഇവിടെ n! എന്നത് n-നോ അതിൽ കുറവോ തുല്യമായ എല്ലാ പോസിറ്റീവ് പൂർണ്ണസംഖ്യകളുടെ ഗുണിതമാണ്.\n    >>> f_33(3, 7)\n    6", "fa": "یک تابع C به نام `unsigned long long f_33(unsigned long long n, unsigned long long p)` بنویسید تا مسئله زیر را حل کند:\nاین مسئله یک عملگر جدید به نام \"مدولوی جدید\" معرفی می‌کند که با نماد \"⊕\" نشان داده می‌شود. هنگام محاسبه x ⊕ y، اگر x مضربی از y نباشد، نتیجه باقی‌مانده تقسیم x بر y است. در غیر این صورت، x را مکرراً بر y تقسیم کنید تا زمانی که x دیگر مضربی از y نباشد، و مقدار نهایی را x' بنامید. سپس نتیجه باقی‌مانده تقسیم x' بر y است. برای مثال، 4⊕5=4، 20⊕5=4، 100⊕5=4.\nبا توجه به یک عدد اول p، چندین پرسش وجود خواهد داشت. برای هر پرسش، یک عدد صحیح n داده می‌شود و شما باید مقدار n! ⊕ p را محاسبه کنید، که در آن n! فاکتوریل n است، یعنی حاصل‌ضرب تمام اعداد صحیح مثبت کمتر یا مساوی n.\n    >>> f_33(3, 7)\n    6"}, "level": "easy", "test": "int main() {\n    // Test cases\n    assert(f_33(3, 7) == 6);\n    assert(f_33(10, 3) == 1);\n    assert(f_33(11, 7) == 4);\n    assert(f_33(45, 7) == 1);\n    assert(f_33(14, 7) == 2);\n    assert(f_33(1919, 10007) == 3152);\n    assert(f_33(810, 10007) == 3679);\n    assert(f_33(3, 7) == 6);\n    assert(f_33(10, 3) == 1);\n    assert(f_33(1, 2) == 1);\n    assert(f_33(5, 11) == 10);\n    assert(f_33(6, 13) == 5);\n    assert(f_33(8, 17) == 13);\n    assert(f_33(15, 19) == 16);\n    assert(f_33(21, 23) == 1);\n    assert(f_33(30, 29) == 28);\n    assert(f_33(100, 101) == 100);\n    return 0;\n}", "entry_point": "f_33", "signature": "unsigned long long f_33(unsigned long long n, unsigned long long p)", "docstring": {"en": "This problem introduces a new modulo operation, denoted by the symbol \"⊕\". When calculating x ⊕ y, if x is not a multiple of y, the result is the remainder of x divided by y. Otherwise, divide x by y repeatedly until x is no longer a multiple of y, denoting the final value as x'. Then the result is the remainder of x' divided by y. For example, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nGiven a prime number p, there will be several queries. For each query, an integer n is given, and you need to compute the value of n! ⊕ p, where n! is the factorial of n, i.e., the product of all positive integers less than or equal to n.\n    >>> f_33(3, 7)\n    6\n", "sq": "Ky problem prezanton një operacion të ri modulo, i shënuar me simbolin \"⊕\". Kur llogarit x ⊕ y, nëse x nuk është shumëfish i y, rezultati është mbetja e x e ndarë me y. Përndryshe, ndaj x me y vazhdimisht derisa x të mos jetë më shumëfish i y, duke shënuar vlerën përfundimtare si x'. Pastaj rezultati është mbetja e x' e ndarë me y. Për shembull, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nDuke pasur një numër të thjeshtë p, do të ketë disa pyetje. Për çdo pyetje, jepet një numër i plotë n, dhe ju duhet të llogaritni vlerën e n! ⊕ p, ku n! është faktoriali i n, dmth. prodhimi i të gjithë numrave të plotë pozitivë më të vegjël ose të barabartë me n.\n    >>> f_33(3, 7)\n    6", "hy": "Այս խնդիրը ներկայացնում է նոր մնացորդային գործողություն, որը նշվում է \"⊕\" սիմվոլով։ Երբ հաշվարկում ենք x ⊕ y, եթե x-ը y-ի բազմապատիկ չէ, արդյունքը x-ի y-ով բաժանման մնացորդն է։ Հակառակ դեպքում, բաժանեք x-ը y-ի վրա բազմիցս, մինչև x-ը այլևս y-ի բազմապատիկ չլինի, վերջնական արժեքը նշելով որպես x'։ Ապա արդյունքը x'-ի y-ով բաժանման մնացորդն է։ Օրինակ, 4⊕5=4, 20⊕5=4, 100⊕5=4։ Տրված է p պարզ թիվը, և կլինեն մի քանի հարցումներ։ Յուրաքանչյուր հարցման համար տրված է n ամբողջ թիվը, և դուք պետք է հաշվարկեք n! ⊕ p արժեքը, որտեղ n! n-ի ֆակտորիալն է, այսինքն՝ n-ից փոքր կամ հավասար բոլոր դրական ամբողջ թվերի արտադրյալը։\n    >>> f_33(3, 7)\n    6", "bn": "এই সমস্যাটি একটি নতুন মডুলো অপারেশন পরিচয় করিয়ে দেয়, যা \"⊕\" প্রতীক দ্বারা চিহ্নিত। যখন x ⊕ y গণনা করা হয়, যদি x y-এর গুণিতক না হয়, তাহলে ফলাফল হয় x কে y দ্বারা ভাগ করার পরে অবশিষ্টাংশ। অন্যথায়, x কে y দ্বারা বারবার ভাগ করুন যতক্ষণ না x আর y-এর গুণিতক থাকে না, চূড়ান্ত মানটিকে x' হিসাবে চিহ্নিত করুন। তারপর ফলাফল হয় x' কে y দ্বারা ভাগ করার পরে অবশিষ্টাংশ। উদাহরণস্বরূপ, 4⊕5=4, 20⊕5=4, 100⊕5=4।\nএকটি মৌলিক সংখ্যা p দেওয়া হলে, বেশ কয়েকটি প্রশ্ন থাকবে। প্রতিটি প্রশ্নের জন্য, একটি পূর্ণসংখ্যা n দেওয়া হয়, এবং আপনাকে n! ⊕ p এর মান গণনা করতে হবে, যেখানে n! হল n এর ফ্যাক্টোরিয়াল, অর্থাৎ n এর চেয়ে ছোট বা সমান সমস্ত ধনাত্মক পূর্ণসংখ্যার গুণফল।\n\n    >>> f_33(3, 7)\n    6", "bg": "Този проблем въвежда нова операция за модуло, обозначена със символа \"⊕\". При изчисляване на x ⊕ y, ако x не е кратно на y, резултатът е остатъкът от x, разделен на y. В противен случай, разделяйте x на y многократно, докато x вече не е кратно на y, като отбелязвате крайната стойност като x'. Тогава резултатът е остатъкът от x', разделен на y. Например, 4⊕5=4, 20⊕5=4, 100⊕5=4. Дадено е просто число p, ще има няколко заявки. За всяка заявка е дадено цяло число n, и трябва да изчислите стойността на n! ⊕ p, където n! е факториалът на n, т.е. произведението на всички положителни цели числа, по-малки или равни на n.\n    >>> f_33(3, 7)\n    6", "zh": "这个问题引入了一种新的取模运算，用符号“⊕”表示。当计算 x ⊕ y 时，如果 x 不是 y 的倍数，结果是 x 除以 y 的余数。否则，重复将 x 除以 y，直到 x 不再是 y 的倍数，将最终值记为 x'。然后结果是 x' 除以 y 的余数。例如，4⊕5=4，20⊕5=4，100⊕5=4。\n给定一个素数 p，会有若干查询。对于每个查询，给定一个整数 n，你需要计算 n! ⊕ p 的值，其中 n! 是 n 的阶乘，即小于或等于 n 的所有正整数的乘积。\n    >>> f_33(3, 7)\n    6", "fr": "Ce problème introduit une nouvelle opération modulo, notée par le symbole \"⊕\". Lors du calcul de x ⊕ y, si x n'est pas un multiple de y, le résultat est le reste de x divisé par y. Sinon, divisez x par y de manière répétée jusqu'à ce que x ne soit plus un multiple de y, en désignant la valeur finale par x'. Ensuite, le résultat est le reste de x' divisé par y. Par exemple, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nÉtant donné un nombre premier p, il y aura plusieurs requêtes. Pour chaque requête, un entier n est donné, et vous devez calculer la valeur de n! ⊕ p, où n! est la factorielle de n, c'est-à-dire le produit de tous les entiers positifs inférieurs ou égaux à n.\n    >>> f_33(3, 7)\n    6", "de": "Dieses Problem führt eine neue Modulo-Operation ein, die durch das Symbol \"⊕\" bezeichnet wird. Bei der Berechnung von x ⊕ y, wenn x kein Vielfaches von y ist, ist das Ergebnis der Rest von x geteilt durch y. Andernfalls wird x wiederholt durch y geteilt, bis x kein Vielfaches von y mehr ist, wobei der Endwert als x' bezeichnet wird. Dann ist das Ergebnis der Rest von x' geteilt durch y. Zum Beispiel, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nGegeben eine Primzahl p, wird es mehrere Anfragen geben. Für jede Anfrage wird eine ganze Zahl n gegeben, und Sie müssen den Wert von n! ⊕ p berechnen, wobei n! die Fakultät von n ist, d.h. das Produkt aller positiven ganzen Zahlen kleiner oder gleich n.\n    >>> f_33(3, 7)\n    6", "ha": "Wannan matsala ta gabatar da sabon aikin modulo, wanda aka nuna da alamar \"⊕\". Lokacin da ake lissafin x ⊕ y, idan x ba shi ne sau na y ba, sakamakon shi ne saura na x da aka raba da y. In ba haka ba, a raba x da y akai-akai har sai x ba shi ne sau na y ba, ana nuna ƙimar ƙarshe da x'. Sannan sakamakon shi ne saura na x' da aka raba da y. Alal misali, 4⊕5=4, 20⊕5=4, 100⊕5=4. Idan aka ba da lambar firam p, za a sami tambayoyi da yawa. Ga kowace tambaya, ana ba da cikakken lamba n, kuma kuna buƙatar lissafin ƙimar n! ⊕ p, inda n! shine factorial na n, wato, samfurin duk lambobi masu kyau waɗanda suka fi ƙarami ko daidai da n.\n    >>> f_33(3, 7)\n    6", "hi": "यह समस्या एक नए माड्यूलो ऑपरेशन को प्रस्तुत करती है, जिसे प्रतीक \"⊕\" द्वारा दर्शाया गया है। जब x ⊕ y की गणना की जाती है, यदि x y का गुणज नहीं है, तो परिणाम x को y से भाग देने पर शेषफल होता है। अन्यथा, x को y से बार-बार भाग दें जब तक कि x अब y का गुणज न हो, अंतिम मान को x' के रूप में दर्शाते हुए। फिर परिणाम x' को y से भाग देने पर शेषफल होता है। उदाहरण के लिए, 4⊕5=4, 20⊕5=4, 100⊕5=4।\nएक अभाज्य संख्या p दी गई है, और कई क्वेरीज़ होंगी। प्रत्येक क्वेरी के लिए, एक पूर्णांक n दिया गया है, और आपको n! ⊕ p का मान निकालना है, जहाँ n! n का फैक्टोरियल है, यानी n से कम या बराबर सभी धनात्मक पूर्णांकों का गुणनफल।\n    >>> f_33(3, 7)\n    6", "hu": "Ez a probléma egy új modulo műveletet vezet be, amelyet a \"⊕\" szimbólum jelöl. Amikor az x ⊕ y értéket számítjuk ki, ha x nem osztható y-nal, az eredmény x maradéka y-val osztva. Ellenkező esetben osszuk el x-et y-nal ismételten, amíg x már nem osztható y-nal, és jelöljük a végső értéket x'-vel. Ekkor az eredmény x' maradéka y-val osztva. Például, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nAdott egy prímszám p, több lekérdezés lesz. Minden lekérdezéshez adott egy n egész szám, és ki kell számítanod az n! ⊕ p értékét, ahol n! az n faktoriálisa, azaz az összes pozitív egész szám szorzata, amely kisebb vagy egyenlő n-nél.\n    >>> f_33(3, 7)\n    6", "es": "Este problema introduce una nueva operación de módulo, denotada por el símbolo \"⊕\". Al calcular x ⊕ y, si x no es un múltiplo de y, el resultado es el resto de x dividido por y. De lo contrario, divide x por y repetidamente hasta que x ya no sea un múltiplo de y, denotando el valor final como x'. Entonces, el resultado es el resto de x' dividido por y. Por ejemplo, 4⊕5=4, 20⊕5=4, 100⊕5=4. Dado un número primo p, habrá varias consultas. Para cada consulta, se da un número entero n, y necesitas calcular el valor de n! ⊕ p, donde n! es el factorial de n, es decir, el producto de todos los enteros positivos menores o iguales a n.\n    >>> f_33(3, 7)\n    6", "arb": "هذه المشكلة تقدم عملية جديدة للباقي، يرمز لها بالرمز \"⊕\". عند حساب x ⊕ y، إذا لم يكن x مضاعفًا لـ y، تكون النتيجة هي باقي قسمة x على y. وإلا، يتم قسمة x على y بشكل متكرر حتى لا يعود x مضاعفًا لـ y، ويتم الإشارة إلى القيمة النهائية بـ x'. ثم تكون النتيجة هي باقي قسمة x' على y. على سبيل المثال، 4⊕5=4، 20⊕5=4، 100⊕5=4. \nبالنظر إلى عدد أولي p، سيكون هناك عدة استفسارات. لكل استفسار، يُعطى عدد صحيح n، وتحتاج إلى حساب قيمة n! ⊕ p، حيث n! هو مضروب n، أي حاصل ضرب جميع الأعداد الصحيحة الموجبة الأقل من أو تساوي n.\n    >>> f_33(3, 7)\n    6", "sw": "Tatizo hili linaanzisha operesheni mpya ya modulo, inayojulikana kwa alama \"⊕\". Wakati wa kuhesabu x ⊕ y, ikiwa x si kigezo cha y, matokeo ni baki ya x iliyogawanywa na y. Vinginevyo, gawanya x kwa y mara kwa mara hadi x isiwe tena kigezo cha y, ukionyesha thamani ya mwisho kama x'. Kisha matokeo ni baki ya x' iliyogawanywa na y. Kwa mfano, 4⊕5=4, 20⊕5=4, 100⊕5=4. Ukipewa nambari ya kwanza p, kutakuwa na maswali kadhaa. Kwa kila swali, nambari nzima n inatolewa, na unahitaji kuhesabu thamani ya n! ⊕ p, ambapo n! ni faktoria ya n, yaani, bidhaa ya nambari zote chanya zilizo chini au sawa na n.\n    >>> f_33(3, 7)\n    6", "tr": "Bu problem, \"⊕\" sembolü ile gösterilen yeni bir modül işlemi tanıtmaktadır. x ⊕ y hesaplanırken, eğer x, y'nin katı değilse, sonuç x'in y'ye bölümünden kalan olur. Aksi takdirde, x artık y'nin katı olmayana kadar x'i y'ye tekrar tekrar bölün, son değeri x' olarak belirtin. Sonra sonuç, x'in y'ye bölümünden kalan olur. Örneğin, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nVerilen bir asal sayı p ile birkaç sorgu olacaktır. Her sorgu için bir tamsayı n verilir ve n! ⊕ p değerini hesaplamanız gerekir, burada n! n'nin faktöriyelidir, yani n'ye eşit veya daha küçük olan tüm pozitif tamsayıların çarpımıdır.\n    >>> f_33(3, 7)\n    6", "vi": "Vấn đề này giới thiệu một phép toán modulo mới, được ký hiệu bằng ký hiệu \"⊕\". Khi tính toán x ⊕ y, nếu x không phải là bội số của y, kết quả là phần dư của x chia cho y. Ngược lại, chia x cho y liên tục cho đến khi x không còn là bội số của y, ký hiệu giá trị cuối cùng là x'. Sau đó kết quả là phần dư của x' chia cho y. Ví dụ, 4⊕5=4, 20⊕5=4, 100⊕5=4. Cho một số nguyên tố p, sẽ có một số truy vấn. Đối với mỗi truy vấn, một số nguyên n được cho, và bạn cần tính giá trị của n! ⊕ p, trong đó n! là giai thừa của n, tức là tích của tất cả các số nguyên dương nhỏ hơn hoặc bằng n.\n    >>> f_33(3, 7)\n    6", "id": "Masalah ini memperkenalkan operasi modulo baru, yang dilambangkan dengan simbol \"⊕\". Ketika menghitung x ⊕ y, jika x bukan kelipatan dari y, hasilnya adalah sisa dari x dibagi y. Jika tidak, bagi x dengan y berulang kali sampai x tidak lagi menjadi kelipatan dari y, menandai nilai akhir sebagai x'. Kemudian hasilnya adalah sisa dari x' dibagi y. Sebagai contoh, 4⊕5=4, 20⊕5=4, 100⊕5=4. Diberikan sebuah bilangan prima p, akan ada beberapa kueri. Untuk setiap kueri, diberikan sebuah bilangan bulat n, dan Anda perlu menghitung nilai dari n! ⊕ p, di mana n! adalah faktorial dari n, yaitu hasil kali dari semua bilangan bulat positif yang kurang dari atau sama dengan n.\n    >>> f_33(3, 7)\n    6", "ja": "この問題では、新しい剰余演算「⊕」が導入されています。x ⊕ y を計算する際、x が y の倍数でない場合、結果は x を y で割った余りです。そうでない場合、x を y で割り続け、x が y の倍数でなくなるまで繰り返し、最終的な値を x' とします。その後、結果は x' を y で割った余りです。例えば、4⊕5=4、20⊕5=4、100⊕5=4 です。\n素数 p が与えられ、いくつかのクエリがあります。各クエリでは整数 n が与えられ、n! ⊕ p の値を計算する必要があります。ここで n! は n の階乗であり、n 以下のすべての正の整数の積です。\n    >>> f_33(3, 7)\n    6", "ko": "이 문제는 \"⊕\" 기호로 표시되는 새로운 모듈로 연산을 도입합니다. x ⊕ y를 계산할 때, x가 y의 배수가 아니면 결과는 x를 y로 나눈 나머지입니다. 그렇지 않으면, x를 y로 반복해서 나누어 x가 더 이상 y의 배수가 아닐 때까지 나누고, 최종 값을 x'로 표시합니다. 그런 다음 결과는 x'를 y로 나눈 나머지입니다. 예를 들어, 4⊕5=4, 20⊕5=4, 100⊕5=4입니다.\n소수 p가 주어지면, 여러 쿼리가 있을 것입니다. 각 쿼리마다 정수 n이 주어지며, n! ⊕ p의 값을 계산해야 합니다. 여기서 n!은 n 이하의 모든 양의 정수의 곱인 팩토리얼입니다.\n    >>> f_33(3, 7)\n    6", "ml": "ഈ പ്രശ്നം \"⊕\" എന്ന ചിഹ്നം കൊണ്ട് സൂചിപ്പിക്കുന്ന ഒരു പുതിയ മോഡുലോ ഓപ്പറേഷൻ പരിചയപ്പെടുത്തുന്നു. x ⊕ y കണക്കാക്കുമ്പോൾ, x y-ന്റെ ഗുണിതമല്ലെങ്കിൽ, ഫലം x y-ൽ വിഭജിക്കുമ്പോൾ ലഭിക്കുന്ന ശേഷമാണ്. അല്ലാത്തപക്ഷം, x y-ൽ നിന്ന് ഗുണിതമല്ലാതാകുന്നത് വരെ x y-ൽ നിന്ന് ആവർത്തിച്ച് വിഭജിക്കുക, അന്തിമ മൂല്യം x' ആയി സൂചിപ്പിക്കുക. തുടർന്ന് ഫലം x' y-ൽ വിഭജിക്കുമ്പോൾ ലഭിക്കുന്ന ശേഷമാണ്. ഉദാഹരണത്തിന്, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nഒരു പ്രധാന സംഖ്യയായ p നൽകിയാൽ, നിരവധി ചോദ്യങ്ങൾ ഉണ്ടാകും. ഓരോ ചോദ്യത്തിനും, ഒരു പൂർണ്ണസംഖ്യ n നൽകപ്പെടും, n! ⊕ p-ന്റെ മൂല്യം നിങ്ങൾ കണക്കാക്കണം, n! എന്നത് n-ൽ കുറവോ തുല്യമോ ആയ എല്ലാ ധനപരമായ പൂർണ്ണസംഖ്യകളുടെ ഗുണിതമാണ്.\n    >>> f_33(3, 7)\n    6", "fa": "این مسئله یک عملگر جدید به نام \"⊕\" معرفی می‌کند. هنگام محاسبه x ⊕ y، اگر x مضربی از y نباشد، نتیجه باقی‌مانده تقسیم x بر y است. در غیر این صورت، x را به طور مکرر بر y تقسیم کنید تا زمانی که x دیگر مضربی از y نباشد، و مقدار نهایی را به عنوان x' نشان دهید. سپس نتیجه باقی‌مانده تقسیم x' بر y است. برای مثال، 4⊕5=4، 20⊕5=4، 100⊕5=4.\nبا توجه به یک عدد اول p، چندین پرسش وجود خواهد داشت. برای هر پرسش، یک عدد صحیح n داده می‌شود و شما باید مقدار n! ⊕ p را محاسبه کنید، که n! فاکتوریل n است، یعنی حاصل‌ضرب تمام اعداد صحیح مثبت کمتر یا مساوی n.\n    >>> f_33(3, 7)\n    6"}}
{"task_id": "C/34", "prompt": {"en": "#include <stdio.h>\n#include <assert.h>\n/*\nYou are given an array a of n integers. You can perform at most one operation where you select three integers i, j, x (1 <= i <= j <= n) and replace all elements from a[i] to a[j] with x, at a cost of (j - i + 1).\nFind the minimum cost to make all elements in the array equal.\n    >>> f_34(3, (int[]){1, 2, 1})\n    1\n*/\nint f_34(int n, int a[])", "sq": "#include <stdio.h>\n#include <assert.h>\n/*\nJu jepet një varg a me n numra të plotë. Ju mund të kryeni maksimumi një operacion ku zgjidhni tre numra të plotë i, j, x (1 <= i <= j <= n) dhe zëvendësoni të gjitha elementet nga a[i] deri te a[j] me x, me një kosto prej (j - i + 1).\nGjeni koston minimale për të bërë që të gjitha elementet në varg të jenë të barabarta.\n    >>> f_34(3, (int[]){1, 2, 1})\n    1\n*/\nint f_34(int n, int a[])", "hy": "#include <stdio.h>\n#include <assert.h>\n/*\nՁեզ տրված է n ամբողջ թվերի զանգված a։ Դուք կարող եք կատարել առավելագույնը մեկ գործողություն, որտեղ ընտրում եք երեք ամբողջ թվեր i, j, x (1 <= i <= j <= n) և փոխարինում a[i]-ից a[j] բոլոր տարրերը x-ով, արժեքով (j - i + 1):\nԳտեք նվազագույն արժեքը, որպեսզի զանգվածի բոլոր տարրերը դառնան հավասար:\n    >>> f_34(3, (int[]){1, 2, 1})\n    1\n*/\nint f_34(int n, int a[])", "bn": "#include <stdio.h>\n#include <assert.h>\n/*\nতোমাকে n পূর্ণসংখ্যার একটি অ্যারে a দেওয়া হয়েছে। তুমি সর্বাধিক একটি অপারেশন করতে পারো যেখানে তুমি তিনটি পূর্ণসংখ্যা i, j, x (1 <= i <= j <= n) নির্বাচন কর এবং a[i] থেকে a[j] পর্যন্ত সমস্ত উপাদান x দিয়ে প্রতিস্থাপন কর, যার খরচ (j - i + 1)।\nঅ্যারের সমস্ত উপাদান সমান করতে সর্বনিম্ন খরচ খুঁজে বের কর।\n    >>> f_34(3, (int[]){1, 2, 1})\n    1\n*/\nint f_34(int n, int a[])", "bg": "#include <stdio.h>\n#include <assert.h>\n/*\nДаден ви е масив a от n цели числа. Можете да извършите най-много една операция, при която избирате три цели числа i, j, x (1 <= i <= j <= n) и заменяте всички елементи от a[i] до a[j] с x, на цена (j - i + 1).\nНамерете минималната цена, за да направите всички елементи в масива равни.\n    >>> f_34(3, (int[]){1, 2, 1})\n    1\n*/\nint f_34(int n, int a[])", "zh": "#include <stdio.h>\n#include <assert.h>\n/*\n给定一个包含 n 个整数的数组 a。你可以最多执行一次操作，其中你选择三个整数 i, j, x (1 <= i <= j <= n)，并将从 a[i] 到 a[j] 的所有元素替换为 x，代价为 (j - i + 1)。\n找到使数组中所有元素相等的最小代价。\n    >>> f_34(3, (int[]){1, 2, 1})\n    1\n*/\nint f_34(int n, int a[])", "fr": "#include <stdio.h>\n#include <assert.h>\n/*\nOn vous donne un tableau a de n entiers. Vous pouvez effectuer au plus une opération où vous sélectionnez trois entiers i, j, x (1 <= i <= j <= n) et remplacez tous les éléments de a[i] à a[j] par x, à un coût de (j - i + 1).\nTrouvez le coût minimum pour rendre tous les éléments du tableau égaux.\n    >>> f_34(3, (int[]){1, 2, 1})\n    1\n*/\nint f_34(int n, int a[])", "de": "#include <stdio.h>\n#include <assert.h>\n/*\nSie haben ein Array a mit n Ganzzahlen. Sie können höchstens eine Operation ausführen, bei der Sie drei Ganzzahlen i, j, x (1 <= i <= j <= n) auswählen und alle Elemente von a[i] bis a[j] durch x ersetzen, zu Kosten von (j - i + 1).\nFinden Sie die minimalen Kosten, um alle Elemente im Array gleich zu machen.\n    >>> f_34(3, (int[]){1, 2, 1})\n    1\n*/\nint f_34(int n, int a[])", "ha": "#include <stdio.h>\n#include <assert.h>\n/*\nAn ba ku wani tsari a na lambobi n. Kuna iya aiwatar da aiki daya kawai inda kuka zaɓi lambobi uku i, j, x (1 <= i <= j <= n) kuma ku maye gurbin dukkan abubuwa daga a[i] zuwa a[j] da x, a farashin (j - i + 1).\nNemo mafi ƙarancin farashi don sanya duk abubuwan cikin tsari su zama daidai.\n    >>> f_34(3, (int[]){1, 2, 1})\n    1\n*/\nint f_34(int n, int a[])", "hi": "#include <stdio.h>\n#include <assert.h>\n/*\nआपको n पूर्णांकों का एक array a दिया गया है। आप अधिकतम एक ऑपरेशन कर सकते हैं जहाँ आप तीन पूर्णांक i, j, x (1 <= i <= j <= n) चुनते हैं और a[i] से a[j] तक के सभी तत्वों को x से बदलते हैं, जिसकी लागत (j - i + 1) होती है।\nसभी तत्वों को array में समान बनाने की न्यूनतम लागत खोजें।\n    >>> f_34(3, (int[]){1, 2, 1})\n    1\n*/\nint f_34(int n, int a[])", "hu": "#include <stdio.h>\n#include <assert.h>\n/*\nAdott egy n egész számot tartalmazó tömb. Legfeljebb egy műveletet hajthatsz végre, ahol kiválasztasz három egész számot i, j, x (1 <= i <= j <= n), és az a[i] és a[j] közötti összes elemet x-re cseréled, (j - i + 1) költséggel.\nTaláld meg a minimális költséget, hogy a tömb összes eleme egyenlő legyen.\n    >>> f_34(3, (int[]){1, 2, 1})\n    1\n*/\nint f_34(int n, int a[])", "es": "#include <stdio.h>\n#include <assert.h>\n/*\nSe te da un arreglo a de n enteros. Puedes realizar como máximo una operación donde seleccionas tres enteros i, j, x (1 <= i <= j <= n) y reemplazas todos los elementos desde a[i] hasta a[j] con x, a un costo de (j - i + 1).\nEncuentra el costo mínimo para hacer que todos los elementos en el arreglo sean iguales.\n    >>> f_34(3, (int[]){1, 2, 1})\n    1\n*/\nint f_34(int n, int a[])", "arb": "#include <stdio.h>\n#include <assert.h>\n/*\nلديك مصفوفة a تحتوي على n من الأعداد الصحيحة. يمكنك تنفيذ عملية واحدة على الأكثر حيث تختار ثلاثة أعداد صحيحة i، j، x (1 <= i <= j <= n) وتستبدل جميع العناصر من a[i] إلى a[j] بـ x، بتكلفة (j - i + 1).\nابحث عن الحد الأدنى للتكلفة لجعل جميع العناصر في المصفوفة متساوية.\n    >>> f_34(3, (int[]){1, 2, 1})\n    1\n*/\nint f_34(int n, int a[])", "sw": "#include <stdio.h>\n#include <assert.h>\n/*\nUmepewa safu a ya n nambari za mzima. Unaweza kufanya operesheni moja tu ambapo unachagua nambari tatu i, j, x (1 <= i <= j <= n) na kubadilisha vipengele vyote kutoka a[i] hadi a[j] na x, kwa gharama ya (j - i + 1).\nPata gharama ndogo zaidi ya kufanya vipengele vyote kwenye safu kuwa sawa.\n    >>> f_34(3, (int[]){1, 2, 1})\n    1\n*/\nint f_34(int n, int a[])", "tr": "#include <stdio.h>\n#include <assert.h>\n/*\nSize n olan bir tamsayı dizisi a verilmektedir. En fazla bir işlem yapabilirsiniz; burada i, j, x (1 <= i <= j <= n) üç tamsayısını seçer ve a[i] ile a[j] arasındaki tüm elemanları x ile değiştirirsiniz, bu işlem (j - i + 1) maliyetindedir.\nDizideki tüm elemanları eşit yapmak için minimum maliyeti bulun.\n    >>> f_34(3, (int[]){1, 2, 1})\n    1\n*/\nint f_34(int n, int a[])", "vi": "#include <stdio.h>\n#include <assert.h>\n/*\nBạn được cho một mảng a gồm n số nguyên. Bạn có thể thực hiện tối đa một thao tác, trong đó bạn chọn ba số nguyên i, j, x (1 <= i <= j <= n) và thay thế tất cả các phần tử từ a[i] đến a[j] bằng x, với chi phí là (j - i + 1).\nTìm chi phí tối thiểu để làm cho tất cả các phần tử trong mảng bằng nhau.\n    >>> f_34(3, (int[]){1, 2, 1})\n    1\n*/\nint f_34(int n, int a[])", "id": "#include <stdio.h>\n#include <assert.h>\n/*\nAnda diberikan sebuah array a yang terdiri dari n bilangan bulat. Anda dapat melakukan paling banyak satu operasi di mana Anda memilih tiga bilangan bulat i, j, x (1 <= i <= j <= n) dan mengganti semua elemen dari a[i] hingga a[j] dengan x, dengan biaya (j - i + 1).\nTemukan biaya minimum untuk membuat semua elemen dalam array menjadi sama.\n    >>> f_34(3, (int[]){1, 2, 1})\n    1\n*/\nint f_34(int n, int a[])", "ja": "#include <stdio.h>\n#include <assert.h>\n/*\n配列 a が n 個の整数で与えられます。1 回だけ操作を行うことができ、3 つの整数 i, j, x (1 <= i <= j <= n) を選択し、a[i] から a[j] までのすべての要素を x に置き換えます。そのコストは (j - i + 1) です。\n配列内のすべての要素を等しくするための最小コストを求めてください。\n    >>> f_34(3, (int[]){1, 2, 1})\n    1\n*/\nint f_34(int n, int a[])", "ko": "#include <stdio.h>\n#include <assert.h>\n/*\n정수 n개의 배열 a가 주어집니다. 최대 한 번의 연산을 수행할 수 있으며, 여기서 세 개의 정수 i, j, x (1 <= i <= j <= n)를 선택하고 a[i]부터 a[j]까지의 모든 요소를 x로 대체합니다. 이때 비용은 (j - i + 1)입니다.\n배열의 모든 요소를 같게 만드는 최소 비용을 찾으세요.\n    >>> f_34(3, (int[]){1, 2, 1})\n    1\n*/\nint f_34(int n, int a[])", "ml": "#include <stdio.h>\n#include <assert.h>\n/*\nനിങ്ങൾക്ക് n പൂർണ്ണസംഖ്യകളുടെ ഒരു നിര a നൽകിയിരിക്കുന്നു. നിങ്ങൾക്ക് പരമാവധി ഒരു പ്രവർത്തനം നടത്താം, അതിൽ നിങ്ങൾ മൂന്നു പൂർണ്ണസംഖ്യകൾ i, j, x (1 <= i <= j <= n) തിരഞ്ഞെടുക്കുകയും a[i] മുതൽ a[j] വരെയുള്ള എല്ലാ മൂല്യങ്ങളും x-ആയി മാറ്റുകയും ചെയ്യാം, (j - i + 1) എന്ന ചെലവിൽ.\nഎല്ലാ മൂല്യങ്ങളും സമാനമാക്കുന്നതിനുള്ള കുറഞ്ഞ ചെലവ് കണ്ടെത്തുക.\n    >>> f_34(3, (int[]){1, 2, 1})\n    1\n*/\nint f_34(int n, int a[])", "fa": "#include <stdio.h>\n#include <assert.h>\n/*\nشما یک آرایه a از n عدد صحیح دارید. شما می‌توانید حداکثر یک عملیات انجام دهید که در آن سه عدد صحیح i، j، x (1 <= i <= j <= n) را انتخاب کرده و تمام عناصر از a[i] تا a[j] را با x جایگزین کنید، با هزینه (j - i + 1).\nکمترین هزینه برای برابر کردن تمام عناصر در آرایه را پیدا کنید.\n    >>> f_34(3, (int[]){1, 2, 1})\n    1\n*/\nint f_34(int n, int a[])\n"}, "canonical_solution": "{\n    int p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}", "instruction": {"en": "Write a C function `int f_34(int n, int a[])` to solve the following problem:\nYou are given an array a of n integers. You can perform at most one operation where you select three integers i, j, x (1 <= i <= j <= n) and replace all elements from a[i] to a[j] with x, at a cost of (j - i + 1).\nFind the minimum cost to make all elements in the array equal.\n    >>> f_34(3, (int[]){1, 2, 1})\n    1\n", "sq": "Shkruani një funksion në C `int f_34(int n, int a[])` për të zgjidhur problemin e mëposhtëm:\nJu jepet një varg a me n numra të plotë. Ju mund të kryeni në maksimum një operacion ku zgjidhni tre numra të plotë i, j, x (1 <= i <= j <= n) dhe zëvendësoni të gjitha elementet nga a[i] deri te a[j] me x, me një kosto prej (j - i + 1).\nGjeni koston minimale për të bërë të gjitha elementet në varg të barabarta.\n    >>> f_34(3, (int[]){1, 2, 1})\n    1", "hy": "Գրեք C ֆունկցիա `int f_34(int n, int a[])`՝ լուծելու հետևյալ խնդիրը:\nՁեզ տրված է n ամբողջ թվերի զանգված a։ Դուք կարող եք կատարել առավելագույնը մեկ գործողություն, որտեղ ընտրում եք երեք ամբողջ թվեր i, j, x (1 <= i <= j <= n) և փոխարինում a[i]-ից a[j] բոլոր տարրերը x-ով, արժեքով (j - i + 1)։\nԳտեք նվազագույն արժեքը, որպեսզի զանգվածի բոլոր տարրերը դառնան հավասար:\n    >>> f_34(3, (int[]){1, 2, 1})\n    1", "bn": "C ফাংশন `int f_34(int n, int a[])` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nআপনাকে n পূর্ণসংখ্যার একটি অ্যারে a দেওয়া হয়েছে। আপনি সর্বাধিক একটি অপারেশন করতে পারেন যেখানে আপনি তিনটি পূর্ণসংখ্যা i, j, x (1 <= i <= j <= n) নির্বাচন করেন এবং a[i] থেকে a[j] পর্যন্ত সমস্ত উপাদান x দিয়ে প্রতিস্থাপন করেন, যার খরচ (j - i + 1)।\nঅ্যারের সমস্ত উপাদান সমান করতে ন্যূনতম খরচ খুঁজুন।", "bg": "Напишете C функция `int f_34(int n, int a[])`, за да решите следния проблем:\nДаден ви е масив a от n цели числа. Можете да извършите най-много една операция, при която избирате три цели числа i, j, x (1 <= i <= j <= n) и заменяте всички елементи от a[i] до a[j] с x, на цена (j - i + 1).\nНамерете минималната цена, за да направите всички елементи в масива равни.\n    >>> f_34(3, (int[]){1, 2, 1})\n    1", "zh": "编写一个 C 函数 `int f_34(int n, int a[])` 来解决以下问题：\n给定一个包含 n 个整数的数组 a。你可以执行最多一次操作，其中你选择三个整数 i, j, x (1 <= i <= j <= n)，并将从 a[i] 到 a[j] 的所有元素替换为 x，代价为 (j - i + 1)。  \n找出使数组中所有元素相等的最小代价。  \n    >>> f_34(3, (int[]){1, 2, 1})  \n    1  ", "fr": "Écrivez une fonction C `int f_34(int n, int a[])` pour résoudre le problème suivant :\nOn vous donne un tableau a de n entiers. Vous pouvez effectuer au plus une opération où vous sélectionnez trois entiers i, j, x (1 <= i <= j <= n) et remplacez tous les éléments de a[i] à a[j] par x, à un coût de (j - i + 1).  \nTrouvez le coût minimum pour rendre tous les éléments du tableau égaux.  \n    >>> f_34(3, (int[]){1, 2, 1})  \n    1  ", "de": "Schreiben Sie eine C-Funktion `int f_34(int n, int a[])`, um das folgende Problem zu lösen:\nSie haben ein Array a mit n ganzen Zahlen. Sie können höchstens eine Operation durchführen, bei der Sie drei ganze Zahlen i, j, x (1 <= i <= j <= n) auswählen und alle Elemente von a[i] bis a[j] durch x ersetzen, zu einem Kostenaufwand von (j - i + 1).\nFinden Sie die minimalen Kosten, um alle Elemente im Array gleich zu machen.\n    >>> f_34(3, (int[]){1, 2, 1})\n    1", "ha": "Rubuta aikin C `int f_34(int n, int a[])` don magance matsalar mai zuwa:\nAn ba ku wani tsari a na lambobi n. Kuna iya aiwatar da mafi yawan aiki daya inda kuka zaɓi lambobi uku i, j, x (1 <= i <= j <= n) kuma ku maye gurbin dukkan abubuwa daga a[i] zuwa a[j] da x, a kan farashi na (j - i + 1).\nNemo mafi ƙarancin farashi don sanya duk abubuwan cikin jerin su zama daidai.\n    >>> f_34(3, (int[]){1, 2, 1})\n    1", "hi": "C फ़ंक्शन `int f_34(int n, int a[])` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nआपको n पूर्णांकों का एक array a दिया गया है। आप अधिकतम एक ऑपरेशन कर सकते हैं जहाँ आप तीन पूर्णांक i, j, x (1 <= i <= j <= n) चुनते हैं और a[i] से a[j] तक के सभी तत्वों को x से बदलते हैं, जिसकी लागत (j - i + 1) होती है।\nसभी तत्वों को array में समान बनाने की न्यूनतम लागत खोजें।", "hu": "Írj egy C függvényt `int f_34(int n, int a[])` a következő probléma megoldására:\nAdott egy n egész számot tartalmazó tömb a. Legfeljebb egy műveletet hajthatsz végre, ahol kiválasztasz három egész számot i, j, x (1 <= i <= j <= n), és az a[i] és a[j] közötti összes elemet x-re cseréled, (j - i + 1) költséggel.\nTaláld meg a minimális költséget, hogy a tömb összes eleme egyenlő legyen.\n    >>> f_34(3, (int[]){1, 2, 1})\n    1", "es": "Escribe una función en C `int f_34(int n, int a[])` para resolver el siguiente problema:\nSe te da un arreglo a de n enteros. Puedes realizar como máximo una operación donde seleccionas tres enteros i, j, x (1 <= i <= j <= n) y reemplazas todos los elementos desde a[i] hasta a[j] con x, a un costo de (j - i + 1).\nEncuentra el costo mínimo para hacer que todos los elementos en el arreglo sean iguales.\n    >>> f_34(3, (int[]){1, 2, 1})\n    1", "arb": "اكتب دالة بلغة C `int f_34(int n, int a[])` لحل المشكلة التالية:\nلديك مصفوفة a تحتوي على n عدد صحيح. يمكنك تنفيذ عملية واحدة على الأكثر حيث تختار ثلاثة أعداد صحيحة i، j، x (1 <= i <= j <= n) وتستبدل جميع العناصر من a[i] إلى a[j] بـ x، بتكلفة (j - i + 1).\nاعثر على الحد الأدنى للتكلفة لجعل جميع العناصر في المصفوفة متساوية.\n    >>> f_34(3, (int[]){1, 2, 1})\n    1", "sw": "Andika kazi ya C `int f_34(int n, int a[])` kutatua tatizo lifuatalo:\nUmepewa safu a ya n nambari za mzima. Unaweza kufanya operesheni moja tu ambapo unachagua nambari tatu i, j, x (1 <= i <= j <= n) na kubadilisha vipengele vyote kutoka a[i] hadi a[j] na x, kwa gharama ya (j - i + 1).\nPata gharama ndogo zaidi ya kufanya vipengele vyote katika safu kuwa sawa.\n    >>> f_34(3, (int[]){1, 2, 1})\n    1", "tr": "Bir C fonksiyonu `int f_34(int n, int a[])` yazın ve aşağıdaki problemi çözün:\nn tamsayısından oluşan bir dizi a verilmektedir. En fazla bir işlem gerçekleştirebilirsiniz, bu işlemde i, j, x (1 <= i <= j <= n) üç tamsayısını seçer ve a[i] ile a[j] arasındaki tüm elemanları x ile değiştirirsiniz, bu işlemin maliyeti (j - i + 1) olur.\nDizideki tüm elemanları eşit hale getirmek için minimum maliyeti bulun.\n    >>> f_34(3, (int[]){1, 2, 1})\n    1", "vi": "Viết một hàm C `int f_34(int n, int a[])` để giải quyết vấn đề sau:\nBạn được cho một mảng a gồm n số nguyên. Bạn có thể thực hiện tối đa một thao tác, trong đó bạn chọn ba số nguyên i, j, x (1 <= i <= j <= n) và thay thế tất cả các phần tử từ a[i] đến a[j] bằng x, với chi phí là (j - i + 1).\nTìm chi phí tối thiểu để làm cho tất cả các phần tử trong mảng bằng nhau.\n    >>> f_34(3, (int[]){1, 2, 1})\n    1", "id": "Tulis sebuah fungsi C `int f_34(int n, int a[])` untuk menyelesaikan masalah berikut:\nAnda diberikan sebuah array a yang terdiri dari n bilangan bulat. Anda dapat melakukan paling banyak satu operasi di mana Anda memilih tiga bilangan bulat i, j, x (1 <= i <= j <= n) dan mengganti semua elemen dari a[i] hingga a[j] dengan x, dengan biaya (j - i + 1).\nTemukan biaya minimum untuk membuat semua elemen dalam array menjadi sama.\n    >>> f_34(3, (int[]){1, 2, 1})\n    1", "ja": "Cの関数を書け `int f_34(int n, int a[])` を作成して、次の問題を解決してください:\n配列 a が n 個の整数から成るとします。最大で1回の操作を行うことができ、3つの整数 i, j, x (1 <= i <= j <= n) を選択し、a[i] から a[j] までのすべての要素を x に置き換えることができます。この操作のコストは (j - i + 1) です。\n配列内のすべての要素を等しくするための最小コストを求めてください。\n    >>> f_34(3, (int[]){1, 2, 1})\n    1", "ko": "C 함수 `int f_34(int n, int a[])`를 작성하여 다음 문제를 해결하십시오:\n정수 n개의 배열 a가 주어집니다. 최대 한 번의 연산을 수행할 수 있으며, 여기서 세 개의 정수 i, j, x (1 <= i <= j <= n)를 선택하고 a[i]에서 a[j]까지의 모든 요소를 x로 교체할 수 있습니다. 이때 비용은 (j - i + 1)입니다.\n배열의 모든 요소를 같게 만드는 최소 비용을 찾으십시오.\n    >>> f_34(3, (int[]){1, 2, 1})\n    1", "ml": "ഒരു C ഫംഗ്ഷൻ എഴുതുക `int f_34(int n, int a[])` താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nനിങ്ങൾക്ക് n പൂർണ്ണസംഖ്യകളുടെ ഒരു നിര a ലഭിക്കുന്നു. നിങ്ങൾക്ക് i, j, x (1 <= i <= j <= n) എന്ന മൂന്ന് പൂർണ്ണസംഖ്യകൾ തിരഞ്ഞെടുക്കാൻ കഴിയുന്ന പരമാവധി ഒരു പ്രവർത്തനം നടത്താം, അതിനുശേഷം a[i] മുതൽ a[j] വരെയുള്ള എല്ലാ മൂല്യങ്ങളും x കൊണ്ട് മാറ്റിസ്ഥാപിക്കാം, (j - i + 1) എന്ന ചെലവിൽ.  \nഎല്ലാ മൂല്യങ്ങളും നിരയിൽ തുല്യമായിരിക്കാനുള്ള കുറഞ്ഞ ചെലവ് കണ്ടെത്തുക.  \n    >>> f_34(3, (int[]){1, 2, 1})  \n    1  ", "fa": "یک تابع C به نام `int f_34(int n, int a[])` بنویسید تا مسئله زیر را حل کند:\nشما یک آرایه a از n عدد صحیح دارید. شما می‌توانید حداکثر یک عملیات انجام دهید که در آن سه عدد صحیح i، j، x (1 <= i <= j <= n) را انتخاب کرده و تمام عناصر از a[i] تا a[j] را با x جایگزین کنید، با هزینه (j - i + 1).\nحداقل هزینه برای برابر کردن تمام عناصر در آرایه را پیدا کنید.\n    >>> f_34(3, (int[]){1, 2, 1})\n    1"}, "level": "middle", "test": "int main() {\n    int test1[] = {1, 2, 1};\n    int test2[] = {5, 5, 1, 5, 5};\n    int test3[] = {1, 1, 1, 1};\n    int test4[] = {2, 2, 2, 3, 2, 2};\n    int test5[] = {1};\n    int test6[] = {1, 2};\n    int test7[] = {1, 2, 2, 1};\n    int test8[] = {4, 4, 4, 3, 3, 4, 4};\n    int test9[] = {5, 4, 4, 4, 5, 5};\n    int test10[] = {1, 2, 1, 2, 1, 2, 1};\n    int a1[] = {1,2,3,4,5,1};\n    int a2[] = {1,1,1,1,1,1,1};\n    int a3[] = {8,8,8,1,2,8,8,8};\n    int a4[] = {1,2,3};\n    int a5[] = {4,3,2,7,1,1,3};\n    int a6[] = {9,9,2,9,2,5,5,5,3};\n    assert(f_34(6, a1) == 4);\n    assert(f_34(7, a2) == 0);\n    assert(f_34(8, a3) == 2);\n    assert(f_34(3, a4) == 2);\n    assert(f_34(7, a5) == 6);\n    assert(f_34(9, a6) == 7);\n\n    assert(f_34(3, test1) == 1);\n    assert(f_34(5, test2) == 1);\n    assert(f_34(4, test3) == 0);\n    assert(f_34(6, test4) == 1);\n    assert(f_34(1, test5) == 0);\n    assert(f_34(2, test6) == 1);\n    assert(f_34(4, test7) == 2);\n    assert(f_34(7, test8) == 2);\n    assert(f_34(6, test9) == 3);\n    assert(f_34(7, test10) == 5);\n\n    return 0;\n}", "entry_point": "f_34", "signature": "int f_34(int n, int a[])", "docstring": {"en": "You are given an array a of n integers. You can perform at most one operation where you select three integers i, j, x (1 <= i <= j <= n) and replace all elements from a[i] to a[j] with x, at a cost of (j - i + 1).\nFind the minimum cost to make all elements in the array equal.\n    >>> f_34(3, (int[]){1, 2, 1})\n    1\n", "sq": "Ju jepet një varg a me n numra të plotë. Ju mund të kryeni më së shumti një operacion ku zgjidhni tre numra të plotë i, j, x (1 <= i <= j <= n) dhe zëvendësoni të gjitha elementet nga a[i] deri te a[j] me x, me një kosto prej (j - i + 1).\nGjeni koston minimale për të bërë të gjitha elementet në varg të barabarta.\n    >>> f_34(3, (int[]){1, 2, 1})\n    1", "hy": "Ձեզ տրված է n ամբողջ թվերի զանգված a։ Դուք կարող եք կատարել առավելագույնը մեկ գործողություն, որտեղ ընտրում եք երեք ամբողջ թվեր i, j, x (1 <= i <= j <= n) և փոխարինում եք a[i]-ից a[j]-ը բոլոր տարրերը x-ով, արժեքով (j - i + 1)։ Գտեք նվազագույն արժեքը, որպեսզի զանգվածի բոլոր տարրերը հավասար լինեն։\n    >>> f_34(3, (int[]){1, 2, 1})\n    1", "bn": "আপনাকে n পূর্ণসংখ্যার একটি অ্যারে a দেওয়া হয়েছে। আপনি সর্বাধিক একটি অপারেশন করতে পারেন যেখানে আপনি তিনটি পূর্ণসংখ্যা i, j, x (1 <= i <= j <= n) নির্বাচন করেন এবং a[i] থেকে a[j] পর্যন্ত সব উপাদানকে x দিয়ে প্রতিস্থাপন করেন, যার খরচ (j - i + 1) হয়। অ্যারের সব উপাদান সমান করতে ন্যূনতম খরচ খুঁজে বের করুন।\n    >>> f_34(3, (int[]){1, 2, 1})\n    1", "bg": "Даден ви е масив a от n цели числа. Можете да извършите най-много една операция, при която избирате три цели числа i, j, x (1 <= i <= j <= n) и заменяте всички елементи от a[i] до a[j] с x, на цена (j - i + 1). Намерете минималната цена, за да направите всички елементи в масива равни.\n    >>> f_34(3, (int[]){1, 2, 1})\n    1", "zh": "你有一个包含 n 个整数的数组 a。你可以执行最多一次操作，其中你选择三个整数 i, j, x (1 <= i <= j <= n)，并将 a[i] 到 a[j] 的所有元素替换为 x，代价为 (j - i + 1)。\n找到使数组中所有元素相等的最小代价。\n    >>> f_34(3, (int[]){1, 2, 1})\n    1", "fr": "Vous avez un tableau a de n entiers. Vous pouvez effectuer au plus une opération où vous sélectionnez trois entiers i, j, x (1 <= i <= j <= n) et remplacez tous les éléments de a[i] à a[j] par x, à un coût de (j - i + 1). Trouvez le coût minimum pour rendre tous les éléments du tableau égaux.\n    >>> f_34(3, (int[]){1, 2, 1})\n    1", "de": "Du hast ein Array a mit n ganzen Zahlen. Du kannst höchstens eine Operation durchführen, bei der du drei ganze Zahlen i, j, x (1 <= i <= j <= n) auswählst und alle Elemente von a[i] bis a[j] durch x ersetzt, zu Kosten von (j - i + 1).\nFinde die minimalen Kosten, um alle Elemente im Array gleich zu machen.\n    >>> f_34(3, (int[]){1, 2, 1})\n    1", "ha": "An a ba ka wani tsari a na n lambobi. Za ka iya aiwatar da akalla daya aiki inda ka zaɓi lambobi uku i, j, x (1 <= i <= j <= n) kuma ka maye gurbin dukkan abubuwa daga a[i] zuwa a[j] da x, a kan farashi na (j - i + 1). Nemo mafi ƙarancin farashi don sanya dukkan abubuwa a cikin jerin su zama daidai.\n    >>> f_34(3, (int[]){1, 2, 1})\n    1", "hi": "आपको n पूर्णांकों का एक array a दिया गया है। आप अधिकतम एक ऑपरेशन कर सकते हैं जहाँ आप तीन पूर्णांक i, j, x (1 <= i <= j <= n) का चयन करते हैं और a[i] से a[j] तक के सभी तत्वों को x से बदलते हैं, जिसकी लागत (j - i + 1) होती है। सभी तत्वों को array में समान बनाने की न्यूनतम लागत का पता लगाएं।\n    >>> f_34(3, (int[]){1, 2, 1})\n    1", "hu": "Meg van adva egy n egész számot tartalmazó tömb, a. Legfeljebb egy műveletet hajthatsz végre, ahol kiválasztasz három egész számot i, j, x (1 <= i <= j <= n), és az a[i]-től a[j]-ig terjedő összes elemet x-re cseréled, (j - i + 1) költséggel. Találd meg a minimális költséget, hogy az összes elem a tömbben egyenlő legyen.\n    >>> f_34(3, (int[]){1, 2, 1})\n    1", "es": "Se te da un array a de n enteros. Puedes realizar como máximo una operación donde seleccionas tres enteros i, j, x (1 <= i <= j <= n) y reemplazas todos los elementos desde a[i] hasta a[j] con x, a un costo de (j - i + 1).\nEncuentra el costo mínimo para hacer que todos los elementos en el array sean iguales.\n    >>> f_34(3, (int[]){1, 2, 1})\n    1", "arb": "تم إعطاؤك مصفوفة a تحتوي على n من الأعداد الصحيحة. يمكنك تنفيذ عملية واحدة على الأكثر حيث تختار ثلاثة أعداد صحيحة i، j، x (1 <= i <= j <= n) وتستبدل جميع العناصر من a[i] إلى a[j] بـ x، بتكلفة (j - i + 1).  \nابحث عن الحد الأدنى للتكلفة لجعل جميع العناصر في المصفوفة متساوية.\n    >>> f_34(3, (int[]){1, 2, 1})\n    1", "sw": "Umepewa safu a ya n nambari za mzima. Unaweza kufanya operesheni moja tu ambapo unachagua nambari tatu i, j, x (1 <= i <= j <= n) na kubadilisha vipengele vyote kutoka a[i] hadi a[j] na x, kwa gharama ya (j - i + 1). \nPata gharama ya chini ya kufanya vipengele vyote katika safu kuwa sawa.\n    >>> f_34(3, (int[]){1, 2, 1})\n    1", "tr": "Verilen n tam sayısından oluşan bir dizi a bulunmaktadır. En fazla bir işlem gerçekleştirebilirsiniz; burada i, j, x (1 <= i <= j <= n) üç tam sayısını seçer ve a[i] ile a[j] arasındaki tüm elemanları x ile değiştirirsiniz, bu işlemin maliyeti (j - i + 1) olur. Dizideki tüm elemanları eşit yapmak için minimum maliyeti bulun.\n    >>> f_34(3, (int[]){1, 2, 1})\n    1", "vi": "Bạn được cung cấp một mảng a gồm n số nguyên. Bạn có thể thực hiện tối đa một thao tác, trong đó bạn chọn ba số nguyên i, j, x (1 <= i <= j <= n) và thay thế tất cả các phần tử từ a[i] đến a[j] bằng x, với chi phí là (j - i + 1). Tìm chi phí tối thiểu để làm cho tất cả các phần tử trong mảng bằng nhau.\n    >>> f_34(3, (int[]){1, 2, 1})\n    1", "id": "Anda diberikan sebuah array a yang terdiri dari n bilangan bulat. Anda dapat melakukan paling banyak satu operasi di mana Anda memilih tiga bilangan bulat i, j, x (1 <= i <= j <= n) dan mengganti semua elemen dari a[i] hingga a[j] dengan x, dengan biaya (j - i + 1). Temukan biaya minimum untuk membuat semua elemen dalam array menjadi sama.\n    >>> f_34(3, (int[]){1, 2, 1})\n    1", "ja": "配列 a が n 個の整数を持っています。最大で1回の操作を行うことができます。この操作では、3つの整数 i, j, x (1 <= i <= j <= n) を選択し、a[i] から a[j] までのすべての要素を x に置き換えます。この操作のコストは (j - i + 1) です。\n配列内のすべての要素を等しくするための最小コストを求めてください。\n    >>> f_34(3, (int[]){1, 2, 1})\n    1", "ko": "당신에게 n개의 정수로 이루어진 배열 a가 주어집니다. 최대 한 번의 연산을 수행할 수 있으며, 여기서 세 개의 정수 i, j, x (1 <= i <= j <= n)를 선택하고 a[i]부터 a[j]까지의 모든 요소를 x로 바꿉니다. 이때 비용은 (j - i + 1)입니다. 배열의 모든 요소를 같게 만드는 최소 비용을 찾으세요.\n    >>> f_34(3, (int[]){1, 2, 1})\n    1", "ml": "നിങ്ങൾക്ക് n പൂർണ്ണസംഖ്യകളുടെ ഒരു നിര ലഭിച്ചിട്ടുണ്ട്. നിങ്ങൾക്ക് പരമാവധി ഒരു പ്രവർത്തനം നടത്താം, അവിടെ നിങ്ങൾ മൂന്നു പൂർണ്ണസംഖ്യകളെ തിരഞ്ഞെടുക്കുന്നു i, j, x (1 <= i <= j <= n) കൂടാതെ a[i] മുതൽ a[j] വരെയുള്ള എല്ലാ മൂല്യങ്ങളും x കൊണ്ട് മാറ്റിസ്ഥാപിക്കുന്നു, (j - i + 1) എന്ന ചെലവിൽ. നിരയിലെ എല്ലാ മൂല്യങ്ങളും തുല്യമായാക്കാൻ കുറഞ്ഞ ചെലവ് കണ്ടെത്തുക.\n    >>> f_34(3, (int[]){1, 2, 1})\n    1", "fa": "شما یک آرایه a از n عدد صحیح دارید. شما می‌توانید حداکثر یک عملیات انجام دهید که در آن سه عدد صحیح i، j، x (1 <= i <= j <= n) را انتخاب کرده و تمام عناصر از a[i] تا a[j] را با x جایگزین کنید، با هزینه (j - i + 1).\nکمترین هزینه برای برابر کردن تمام عناصر در آرایه را پیدا کنید.\n    >>> f_34(3, (int[]){1, 2, 1})\n    1"}}
{"task_id": "C/35", "prompt": {"en": "#include <assert.h>\n#include <stdio.h>\n/*\nGiven a sequence of N piles of stones numbered from 1 to N, with each pile containing a positive number of stones, determine the winner of a game played by Charlie and Dan. Charlie goes first, and they take turns moving a positive number of stones from the leftmost non-empty pile to the adjacent right pile. The player who can only move stones in the last pile loses. Assuming both players use the best possible strategy, find out who will win the game.\n    >>> f_35(3, 1, 2, 2)\n    \"Dan\"\n*/\nconst char* f_35(int n, int piles[])", "sq": "#include <assert.h>\n#include <stdio.h>\n/*\nDuke pasur një sekuencë prej N grumbujsh gurësh të numëruar nga 1 deri në N, ku secili grumbull përmban një numër pozitiv gurësh, përcaktoni fituesin e një loje të luajtur nga Charlie dhe Dan. Charlie fillon i pari, dhe ata marrin kthesa duke lëvizur një numër pozitiv gurësh nga grumbulli më i majtë jo bosh në grumbullin fqinj në të djathtë. Lojtari që mund të lëvizë gurë vetëm në grumbullin e fundit humbet. Duke supozuar se të dy lojtarët përdorin strategjinë më të mirë të mundshme, zbuloni kush do të fitojë lojën.\n    >>> f_35(3, 1, 2, 2)\n    \"Dan\"\n*/\nconst char* f_35(int n, int piles[])", "hy": "#include <assert.h>\n#include <stdio.h>\n/*\nՏրված է N քարերի կույտերի հաջորդականություն, որոնք համարակալված են 1-ից N, և յուրաքանչյուր կույտ պարունակում է դրական քանակությամբ քարեր, որոշեք խաղի հաղթողին, որը խաղում են Չարլին և Դենը։ Չարլին առաջինն է խաղում, և նրանք հերթով տեղափոխում են դրական քանակությամբ քարեր ձախից ամենաառաջին ոչ դատարկ կույտից դեպի հարակից աջ կույտ։ Խաղացողը, որը կարող է միայն քարեր տեղափոխել վերջին կույտում, պարտվում է։ Ենթադրելով, որ երկու խաղացողներն էլ օգտագործում են լավագույն հնարավոր ռազմավարությունը, պարզեք, թե ով կհաղթի խաղը։\n    >>> f_35(3, 1, 2, 2)\n    \"Dan\"\n*/\nconst char* f_35(int n, int piles[])", "bn": "#include <assert.h>\n#include <stdio.h>\n/*\nধরা যাক একটি N সংখ্যক পাথরের স্তূপের ক্রম আছে যা 1 থেকে N পর্যন্ত নম্বরযুক্ত, প্রতিটি স্তূপে একটি ধনাত্মক সংখ্যক পাথর রয়েছে, চার্লি এবং ড্যান দ্বারা খেলা একটি গেমের বিজয়ী নির্ধারণ করুন। চার্লি প্রথমে যায়, এবং তারা পালাক্রমে বামদিকের প্রথম খালি নয় এমন স্তূপ থেকে ডানদিকে সংলগ্ন স্তূপে একটি ধনাত্মক সংখ্যক পাথর সরায়। যে খেলোয়াড় কেবলমাত্র শেষ স্তূপে পাথর সরাতে পারে সে হেরে যায়। ধরে নেওয়া হয় উভয় খেলোয়াড়ই সর্বোত্তম কৌশল ব্যবহার করে, খুঁজে বের করুন কে গেমটি জিতবে।\n    >>> f_35(3, 1, 2, 2)\n    \"Dan\"\n*/\nconst char* f_35(int n, int piles[])", "bg": "#include <assert.h>\n#include <stdio.h>\n/*\nДадена е последователност от N купчини камъни, номерирани от 1 до N, като всяка купчина съдържа положителен брой камъни. Определете победителя в игра, играна от Чарли и Дан. Чарли започва пръв и те се редуват да преместват положителен брой камъни от най-лявата непразна купчина към съседната дясна купчина. Играчът, който може да премести камъни само в последната купчина, губи. Предполагайки, че и двамата играчи използват най-добрата възможна стратегия, разберете кой ще спечели играта.\n    >>> f_35(3, 1, 2, 2)\n    \"Dan\"\n*/\nconst char* f_35(int n, int piles[])", "zh": "#include <assert.h>\n#include <stdio.h>\n/*\n给定一个编号从1到N的石堆序列，每堆包含一个正数的石头，确定由Charlie和Dan进行的游戏的获胜者。Charlie先开始，他们轮流将正数的石头从最左边的非空堆移动到相邻的右边堆。只能在最后一堆移动石头的玩家输掉比赛。假设两位玩家都使用最佳策略，找出谁将赢得比赛。\n    >>> f_35(3, 1, 2, 2)\n    \"Dan\"\n*/\nconst char* f_35(int n, int piles[])", "fr": "#include <assert.h>\n#include <stdio.h>\n/*\nÉtant donné une séquence de N tas de pierres numérotés de 1 à N, chaque tas contenant un nombre positif de pierres, déterminez le gagnant d'un jeu joué par Charlie et Dan. Charlie commence, et ils jouent à tour de rôle en déplaçant un nombre positif de pierres du tas non vide le plus à gauche vers le tas adjacent à droite. Le joueur qui ne peut déplacer des pierres que dans le dernier tas perd. En supposant que les deux joueurs utilisent la meilleure stratégie possible, découvrez qui gagnera le jeu.\n    >>> f_35(3, 1, 2, 2)\n    \"Dan\"\n*/\nconst char* f_35(int n, int piles[])", "de": "#include <assert.h>\n#include <stdio.h>\n/*\nGegeben eine Sequenz von N Steinhaufen, nummeriert von 1 bis N, wobei jeder Haufen eine positive Anzahl von Steinen enthält, bestimmen Sie den Gewinner eines Spiels, das von Charlie und Dan gespielt wird. Charlie beginnt, und sie ziehen abwechselnd eine positive Anzahl von Steinen vom linken, nicht leeren Haufen zum benachbarten rechten Haufen. Der Spieler, der nur noch Steine im letzten Haufen bewegen kann, verliert. Angenommen, beide Spieler verwenden die bestmögliche Strategie, finden Sie heraus, wer das Spiel gewinnen wird.\n    >>> f_35(3, 1, 2, 2)\n    \"Dan\"\n*/\nconst char* f_35(int n, int piles[])", "ha": "#include <assert.h>\n#include <stdio.h>\n/*\nAn ba da jerin N na tarin duwatsu da aka lissafa daga 1 zuwa N, tare da kowanne tarin yana dauke da adadin duwatsu masu kyau, tantance wanda zai ci nasara a wani wasa da Charlie da Dan suka buga. Charlie ne zai fara, kuma suna jujjuya daukar adadin duwatsu daga tarin da ba komai a hagu zuwa tarin dama kusa da shi. Dan wasan da zai iya motsa duwatsu kawai a cikin tarin karshe zai yi rashin nasara. Ana tsammanin duka 'yan wasan suna amfani da mafi kyawun dabaru, gano wanda zai ci nasara a wasan.\n    >>> f_35(3, 1, 2, 2)\n    \"Dan\"\n*/\nconst char* f_35(int n, int piles[])", "hi": "#include <assert.h>\n#include <stdio.h>\n/*\nदी गई N पत्थरों के ढेरों की अनुक्रमणिका, जिन्हें 1 से N तक क्रमांकित किया गया है, प्रत्येक ढेर में पत्थरों की एक सकारात्मक संख्या है, चार्ली और डैन द्वारा खेले गए एक खेल के विजेता का निर्धारण करें। चार्ली पहले जाता है, और वे बारी-बारी से बाईं ओर के सबसे पहले गैर-खाली ढेर से दाईं ओर के सटे हुए ढेर में पत्थरों की एक सकारात्मक संख्या ले जाते हैं। वह खिलाड़ी जो केवल अंतिम ढेर में पत्थरों को ले जा सकता है, हार जाता है। मान लें कि दोनों खिलाड़ी सर्वोत्तम संभव रणनीति का उपयोग करते हैं, यह पता करें कि खेल कौन जीतेगा।\n    >>> f_35(3, 1, 2, 2)\n    \"Dan\"\n*/\nconst char* f_35(int n, int piles[])", "hu": "#include <assert.h>\n#include <stdio.h>\n/*\nAdott egy N halomból álló kőhalom sorozat, amelyeket 1-től N-ig számoztak meg, és mindegyik halom pozitív számú követ tartalmaz. Határozza meg a Charlie és Dan által játszott játék nyertesét. Charlie kezd, és felváltva mozgatnak pozitív számú követ a bal szélső nem üres halomból a szomszédos jobb oldali halomba. Az a játékos veszít, aki csak az utolsó halomban tud köveket mozgatni. Feltételezve, hogy mindkét játékos a lehető legjobb stratégiát alkalmazza, derítse ki, ki nyeri meg a játékot.\n    >>> f_35(3, 1, 2, 2)\n    \"Dan\"\n*/\nconst char* f_35(int n, int piles[])", "es": "#include <assert.h>\n#include <stdio.h>\n/*\nDada una secuencia de N pilas de piedras numeradas del 1 al N, con cada pila conteniendo un número positivo de piedras, determina el ganador de un juego jugado por Charlie y Dan. Charlie comienza primero, y se turnan moviendo un número positivo de piedras de la pila más a la izquierda no vacía a la pila adyacente a la derecha. El jugador que solo puede mover piedras en la última pila pierde. Suponiendo que ambos jugadores usan la mejor estrategia posible, averigua quién ganará el juego.\n    >>> f_35(3, 1, 2, 2)\n    \"Dan\"\n*/\nconst char* f_35(int n, int piles[])", "arb": "#include <assert.h>\n#include <stdio.h>\n/*\nبالنظر إلى تسلسل من N أكوام من الحجارة مرقمة من 1 إلى N، حيث يحتوي كل كومة على عدد إيجابي من الحجارة، حدد الفائز في لعبة يلعبها تشارلي ودان. يبدأ تشارلي أولاً، ويتناوبان في نقل عدد إيجابي من الحجارة من الكومة غير الفارغة الأكثر يسارًا إلى الكومة المجاورة على اليمين. اللاعب الذي لا يمكنه سوى نقل الحجارة في الكومة الأخيرة يخسر. بافتراض أن كلا اللاعبين يستخدمان أفضل استراتيجية ممكنة، اكتشف من سيفوز في اللعبة.\n    >>> f_35(3, 1, 2, 2)\n    \"Dan\"\n*/\nconst char* f_35(int n, int piles[])", "sw": "#include <assert.h>\n#include <stdio.h>\n/*\nIkizingatiwa mlolongo wa mirundo N ya mawe iliyoorodheshwa kutoka 1 hadi N, ambapo kila rundo lina idadi chanya ya mawe, bainisha mshindi wa mchezo unaochezwa na Charlie na Dan. Charlie anaanza kwanza, na wanachukua zamu kuhamisha idadi chanya ya mawe kutoka kwenye rundo la kwanza lisilo tupu kwenda kwenye rundo la kulia lililo karibu. Mchezaji ambaye anaweza tu kuhamisha mawe kwenye rundo la mwisho anapoteza. Tukidhani wachezaji wote wanatumia mkakati bora zaidi, gundua ni nani atakayeshinda mchezo.\n    >>> f_35(3, 1, 2, 2)\n    \"Dan\"\n*/\nconst char* f_35(int n, int piles[])", "tr": "#include <assert.h>\n#include <stdio.h>\n/*\n1'den N'e kadar numaralandırılmış N taş yığını dizisi verildiğinde, her yığın pozitif sayıda taş içerir, Charlie ve Dan tarafından oynanan bir oyunun kazananını belirleyin. Charlie ilk başlar ve sırayla soldaki en dolu olmayan yığından sağdaki bitişik yığına pozitif sayıda taş taşırlar. Sadece son yığındaki taşları hareket ettirebilen oyuncu kaybeder. Her iki oyuncunun da en iyi stratejiyi kullandığını varsayarak, oyunu kimin kazanacağını bulun.\n    >>> f_35(3, 1, 2, 2)\n    \"Dan\"\n*/\nconst char* f_35(int n, int piles[])", "vi": "#include <assert.h>\n#include <stdio.h>\n/*\nCho một dãy N đống đá được đánh số từ 1 đến N, với mỗi đống chứa một số lượng đá dương, xác định người chiến thắng của trò chơi được chơi bởi Charlie và Dan. Charlie đi trước, và họ lần lượt di chuyển một số lượng đá dương từ đống không rỗng bên trái nhất sang đống liền kề bên phải. Người chơi chỉ có thể di chuyển đá trong đống cuối cùng sẽ thua. Giả sử cả hai người chơi đều sử dụng chiến lược tốt nhất có thể, hãy tìm ra ai sẽ thắng trò chơi.\n    >>> f_35(3, 1, 2, 2)\n    \"Dan\"\n*/\nconst char* f_35(int n, int piles[])", "id": "#include <assert.h>\n#include <stdio.h>\n/*\nDiberikan urutan N tumpukan batu bernomor dari 1 hingga N, dengan setiap tumpukan berisi sejumlah batu positif, tentukan pemenang dari permainan yang dimainkan oleh Charlie dan Dan. Charlie pergi lebih dulu, dan mereka bergantian memindahkan sejumlah batu positif dari tumpukan paling kiri yang tidak kosong ke tumpukan kanan yang berdekatan. Pemain yang hanya dapat memindahkan batu di tumpukan terakhir kalah. Dengan asumsi kedua pemain menggunakan strategi terbaik, cari tahu siapa yang akan memenangkan permainan.\n    >>> f_35(3, 1, 2, 2)\n    \"Dan\"\n*/\nconst char* f_35(int n, int piles[])\n", "ja": "#include <assert.h>\n#include <stdio.h>\n/*\n1からNまで番号が付けられたN個の石の山の列が与えられ、それぞれの山には正の数の石が含まれています。チャーリーとダンが行うゲームの勝者を決定します。チャーリーが最初に行動し、彼らは交互に左端の空でない山から隣接する右の山に正の数の石を移動します。最後の山でしか石を動かせないプレイヤーが負けます。両方のプレイヤーが最適な戦略を使用すると仮定して、誰がゲームに勝つかを見つけてください。\n    >>> f_35(3, 1, 2, 2)\n    \"Dan\"\n*/\nconst char* f_35(int n, int piles[])", "ko": "#include <assert.h>\n#include <stdio.h>\n/*\nN개의 돌무더기가 1부터 N까지 번호가 매겨져 있고, 각 무더기에는 양의 개수의 돌이 들어 있습니다. Charlie와 Dan이 게임을 하여 승자를 결정합니다. Charlie가 먼저 시작하며, 그들은 차례로 왼쪽에서 가장 왼쪽에 있는 비어 있지 않은 무더기에서 인접한 오른쪽 무더기로 양의 개수의 돌을 옮깁니다. 마지막 무더기에서만 돌을 옮길 수 있는 플레이어가 패배합니다. 두 플레이어 모두 최선의 전략을 사용할 경우, 누가 게임에서 승리할지 알아내십시오.\n    >>> f_35(3, 1, 2, 2)\n    \"Dan\"\n*/\nconst char* f_35(int n, int piles[])", "ml": "#include <assert.h>\n#include <stdio.h>\n/*\n1 മുതൽ N വരെ നമ്പർ ചെയ്ത N കൂമ്പാരങ്ങളിലായി കല്ലുകൾ അടങ്ങിയ ഒരു നിര നൽകിയിരിക്കുന്നു, ഓരോ കൂമ്പാരത്തിലും ഒരു പോസിറ്റീവ് എണ്ണം കല്ലുകൾ അടങ്ങിയിരിക്കുന്നു, ചാർളിയും ഡാനും കളിക്കുന്ന ഒരു ഗെയിമിന്റെ വിജയിയെ നിർണ്ണയിക്കുക. ചാർളി ആദ്യം പോകുന്നു, അവർ മാറി മാറി ഇടതുവശത്തെ ശൂന്യമല്ലാത്ത കൂമ്പാരത്തിൽ നിന്ന് അടുത്ത വലതുവശത്തെ കൂമ്പാരത്തിലേക്ക് പോസിറ്റീവ് എണ്ണം കല്ലുകൾ നീക്കുന്നു. അവസാന കൂമ്പാരത്തിൽ മാത്രം കല്ലുകൾ നീക്കാൻ കഴിയുന്ന കളിക്കാരൻ തോൽക്കും. ഇരുവരും മികച്ച സാധ്യതയുള്ള തന്ത്രം ഉപയോഗിക്കുന്നതായി കരുതുമ്പോൾ, ഗെയിം ആരാണ് ജയിക്കുക എന്ന് കണ്ടെത്തുക.\n    >>> f_35(3, 1, 2, 2)\n    \"Dan\"\n*/\nconst char* f_35(int n, int piles[])", "fa": "#include <assert.h>\n#include <stdio.h>\n/*\nبا توجه به دنباله‌ای از N توده سنگ شماره‌گذاری شده از 1 تا N، که هر توده شامل تعداد مثبتی از سنگ‌ها است، برنده بازی که توسط چارلی و دن انجام می‌شود را تعیین کنید. چارلی اول می‌رود و آنها به نوبت تعداد مثبتی از سنگ‌ها را از توده غیرخالی سمت چپ به توده مجاور سمت راست منتقل می‌کنند. بازیکنی که فقط می‌تواند سنگ‌ها را در توده آخر حرکت دهد، بازنده است. با فرض اینکه هر دو بازیکن از بهترین استراتژی ممکن استفاده می‌کنند، مشخص کنید چه کسی برنده بازی خواهد شد.\n    >>> f_35(3, 1, 2, 2)\n    \"Dan\"\n*/\nconst char* f_35(int n, int piles[])"}, "canonical_solution": "{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}", "instruction": {"en": "Write a C function `const char* f_35(int n, int piles[])` to solve the following problem:\nGiven a sequence of N piles of stones numbered from 1 to N, with each pile containing a positive number of stones, determine the winner of a game played by Charlie and Dan. Charlie goes first, and they take turns moving a positive number of stones from the leftmost non-empty pile to the adjacent right pile. The player who can only move stones in the last pile loses. Assuming both players use the best possible strategy, find out who will win the game.\n    >>> f_35(3, 1, 2, 2)\n    \"Dan\"\n", "sq": "Shkruani një funksion në C `const char* f_35(int n, int piles[])` për të zgjidhur problemin e mëposhtëm:\nDuke pasur një sekuencë prej N grumbujsh gurësh të numëruar nga 1 deri në N, me secilin grumbull që përmban një numër pozitiv gurësh, përcaktoni fituesin e një loje të luajtur nga Charlie dhe Dan. Charlie fillon i pari, dhe ata marrin kthesa duke lëvizur një numër pozitiv gurësh nga grumbulli më i majtë jo bosh në grumbullin ngjitur në të djathtë. Lojtari që mund të lëvizë gurë vetëm në grumbullin e fundit humbet. Duke supozuar se të dy lojtarët përdorin strategjinë më të mirë të mundshme, zbuloni kush do të fitojë lojën.\n    >>> f_35(3, 1, 2, 2)\n    \"Dan\"", "hy": "Գրեք C ֆունկցիա `const char* f_35(int n, int piles[])`՝ հետևյալ խնդիրը լուծելու համար:\nՏրված է N քարերի կույտերի հաջորդականություն, որոնք համարակալված են 1-ից մինչև N, և յուրաքանչյուր կույտ պարունակում է դրական քանակությամբ քարեր, որոշեք խաղի հաղթողին, որը խաղում են Չարլին և Դանը: Չարլին առաջինն է գնում, և նրանք հերթով տեղափոխում են դրական քանակությամբ քարեր ձախից աջ հարևան կույտ: Խաղացողը, որը կարող է միայն տեղափոխել քարերը վերջին կույտում, պարտվում է: Ենթադրելով, որ երկու խաղացողներն էլ օգտագործում են հնարավոր լավագույն ռազմավարությունը, պարզեք, թե ով կհաղթի խաղը.\n    >>> f_35(3, 1, 2, 2)\n    \"Dan\"", "bn": "C ফাংশন `const char* f_35(int n, int piles[])` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nপ্রতিটি পাইল একটি পজিটিভ সংখ্যক পাথর ধারণ করে, 1 থেকে N পর্যন্ত নম্বরযুক্ত পাথরের N পাইলের একটি ক্রম দেওয়া হয়েছে, চার্লি এবং ড্যান দ্বারা খেলা একটি গেমের বিজয়ী নির্ধারণ করুন। চার্লি প্রথমে যায়, এবং তারা পালাক্রমে বামদিকের প্রথম খালি না হওয়া পাইল থেকে ডানপাশের সংলগ্ন পাইলে একটি পজিটিভ সংখ্যক পাথর সরায়। যে খেলোয়াড় শুধুমাত্র শেষ পাইলে পাথর সরাতে পারে সে হেরে যায়। ধরে নেওয়া হয় উভয় খেলোয়াড়ই সর্বোত্তম কৌশল ব্যবহার করে, খেলা কে জিতবে তা খুঁজে বের করুন।", "bg": "Напишете C функция `const char* f_35(int n, int piles[])`, за да решите следния проблем:\nДадена е последователност от N купчини камъни, номерирани от 1 до N, като всяка купчина съдържа положителен брой камъни, определете победителя в игра, играна от Чарли и Дан. Чарли започва пръв, и те се редуват да преместват положителен брой камъни от най-лявата непразна купчина към съседната дясна купчина. Играчът, който може да премести камъни само в последната купчина, губи. Приемайки, че и двамата играчи използват най-добрата възможна стратегия, разберете кой ще спечели играта.", "zh": "编写一个 C 函数 `const char* f_35(int n, int piles[])` 来解决以下问题：\n给定一个编号从 1 到 N 的石堆序列，每堆包含正数的石头，确定由 Charlie 和 Dan 玩的游戏的获胜者。Charlie 先开始，他们轮流将正数的石头从最左边的非空堆移动到相邻的右边堆。只能在最后一堆移动石头的玩家输掉比赛。假设两位玩家都使用最佳策略，找出谁将赢得比赛。  \n    >>> f_35(3, 1, 2, 2)  \n    \"Dan\"", "fr": "Écrire une fonction C `const char* f_35(int n, int piles[])` pour résoudre le problème suivant :\nÉtant donné une séquence de N tas de pierres numérotés de 1 à N, chaque tas contenant un nombre positif de pierres, déterminez le gagnant d'un jeu joué par Charlie et Dan. Charlie commence, et ils jouent à tour de rôle en déplaçant un nombre positif de pierres du tas non vide le plus à gauche vers le tas adjacent à droite. Le joueur qui ne peut déplacer des pierres que dans le dernier tas perd. En supposant que les deux joueurs utilisent la meilleure stratégie possible, découvrez qui gagnera le jeu.\n    >>> f_35(3, 1, 2, 2)\n    \"Dan\"", "de": "Schreiben Sie eine C-Funktion `const char* f_35(int n, int piles[])`, um das folgende Problem zu lösen:\nGegeben ist eine Sequenz von N Steinhaufen, nummeriert von 1 bis N, wobei jeder Haufen eine positive Anzahl von Steinen enthält. Bestimmen Sie den Gewinner eines Spiels, das von Charlie und Dan gespielt wird. Charlie beginnt, und sie ziehen abwechselnd eine positive Anzahl von Steinen vom linken, nicht leeren Haufen zum benachbarten rechten Haufen. Der Spieler, der nur noch Steine im letzten Haufen bewegen kann, verliert. Angenommen, beide Spieler verwenden die bestmögliche Strategie, finden Sie heraus, wer das Spiel gewinnen wird.\n    >>> f_35(3, 1, 2, 2)\n    \"Dan\"", "ha": "Rubuta aikin C `const char* f_35(int n, int piles[])` don warware matsalar mai zuwa:\nAn ba da jerin N na tarkon duwatsu da aka lamba daga 1 zuwa N, tare da kowanne tarin yana dauke da adadi mai kyau na duwatsu, tantance wanda zai ci nasara a wasan da Charlie da Dan suka buga. Charlie yana farawa, kuma suna juyawa suna motsa adadi mai kyau na duwatsu daga tarkon da ba komai a hagu zuwa tarkon da ke makwabta a dama. Dan wasan da kawai zai iya motsa duwatsu a cikin tarkon karshe ya rasa. Ana tsammanin duk 'yan wasan suna amfani da mafi kyawun dabaru, gano wanda zai ci nasara a wasan.", "hi": "C फ़ंक्शन `const char* f_35(int n, int piles[])` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए पत्थरों के N ढेरों की एक श्रृंखला, जिन्हें 1 से N तक क्रमांकित किया गया है, जिसमें प्रत्येक ढेर में पत्थरों की एक सकारात्मक संख्या है, उस खेल के विजेता का निर्धारण करें जो चार्ली और डैन द्वारा खेला जाता है। चार्ली पहले जाता है, और वे बारी-बारी से बाईं ओर के सबसे पहले गैर-खाली ढेर से दाईं ओर के सटे हुए ढेर में पत्थरों की एक सकारात्मक संख्या को स्थानांतरित करते हैं। वह खिलाड़ी जो केवल अंतिम ढेर में पत्थरों को स्थानांतरित कर सकता है, हार जाता है। मान लीजिए कि दोनों खिलाड़ी सबसे अच्छी संभव रणनीति का उपयोग करते हैं, पता लगाएं कि खेल कौन जीतेगा।\n    >>> f_35(3, 1, 2, 2)\n    \"Dan\"", "hu": "Írj egy C függvényt `const char* f_35(int n, int piles[])` a következő probléma megoldására:\nAdott egy N kövekből álló halom sorozat, amelyeket 1-től N-ig számoztak, és mindegyik halom pozitív számú követ tartalmaz. Határozd meg a Charlie és Dan által játszott játék győztesét. Charlie kezd, és felváltva mozgatnak pozitív számú követ a legbaloldalibb nem üres halomból a szomszédos jobb oldali halomba. Az a játékos veszít, aki csak az utolsó halomban tud követ mozgatni. Feltételezve, hogy mindkét játékos a lehető legjobb stratégiát alkalmazza, derítsd ki, ki fogja megnyerni a játékot.\n    >>> f_35(3, 1, 2, 2)\n    \"Dan\"", "es": "Escribe una función en C `const char* f_35(int n, int piles[])` para resolver el siguiente problema:\nDada una secuencia de N pilas de piedras numeradas del 1 al N, con cada pila conteniendo un número positivo de piedras, determina el ganador de un juego jugado por Charlie y Dan. Charlie comienza primero, y se turnan moviendo un número positivo de piedras de la pila más a la izquierda que no esté vacía a la pila adyacente a la derecha. El jugador que solo pueda mover piedras en la última pila pierde. Suponiendo que ambos jugadores usan la mejor estrategia posible, averigua quién ganará el juego.\n    >>> f_35(3, 1, 2, 2)\n    \"Dan\"", "arb": "اكتب دالة C `const char* f_35(int n, int piles[])` لحل المشكلة التالية:\nبالنظر إلى تسلسل من N أكوام من الحجارة مرقمة من 1 إلى N، حيث يحتوي كل كومة على عدد موجب من الحجارة، حدد الفائز في لعبة يلعبها تشارلي ودان. يبدأ تشارلي أولاً، ويتناوبون في نقل عدد موجب من الحجارة من الكومة غير الفارغة الأقصى إلى اليسار إلى الكومة المجاورة على اليمين. اللاعب الذي يمكنه فقط نقل الحجارة في الكومة الأخيرة يخسر. بافتراض أن كلا اللاعبين يستخدمان أفضل استراتيجية ممكنة، اكتشف من سيفوز في اللعبة.\n    >>> f_35(3, 1, 2, 2)\n    \"Dan\"", "sw": "Andika kazi ya C `const char* f_35(int n, int piles[])` kutatua tatizo lifuatalo:\nUkipatiwa mlolongo wa N wa marundo ya mawe yaliyohesabiwa kutoka 1 hadi N, ambapo kila rundo lina idadi chanya ya mawe, bainisha mshindi wa mchezo unaochezwa na Charlie na Dan. Charlie anaanza, na wanachukua zamu kuhamisha idadi chanya ya mawe kutoka kwenye rundo la kwanza lenye mawe kwenda kwenye rundo la kulia lililo karibu. Mchezaji ambaye anaweza tu kuhamisha mawe kwenye rundo la mwisho anapoteza. Tukizingatia kuwa wachezaji wote wanatumia mkakati bora zaidi, gundua ni nani atakayeshinda mchezo.\n    >>> f_35(3, 1, 2, 2)\n    \"Dan\"", "tr": "Bir C fonksiyonu `const char* f_35(int n, int piles[])` yazın ve aşağıdaki problemi çözün:\n1'den N'e kadar numaralandırılmış N taş yığını dizisi verildiğinde, her yığın pozitif sayıda taş içerir, Charlie ve Dan tarafından oynanan bir oyunun kazananını belirleyin. Charlie önce başlar ve sırayla en soldaki boş olmayan yığından bitişik sağ yığına pozitif sayıda taş taşırlar. Sadece son yığındaki taşları hareket ettirebilen oyuncu kaybeder. Her iki oyuncunun da en iyi stratejiyi kullandığını varsayarak, oyunu kimin kazanacağını bulun.\n    >>> f_35(3, 1, 2, 2)\n    \"Dan\"", "vi": "Viết một hàm C `const char* f_35(int n, int piles[])` để giải quyết vấn đề sau:\nCho một dãy N đống đá được đánh số từ 1 đến N, với mỗi đống chứa một số lượng đá dương, xác định người chiến thắng của một trò chơi được chơi bởi Charlie và Dan. Charlie đi trước, và họ lần lượt di chuyển một số lượng đá dương từ đống không rỗng bên trái nhất sang đống liền kề bên phải. Người chơi chỉ có thể di chuyển đá trong đống cuối cùng sẽ thua. Giả sử cả hai người chơi đều sử dụng chiến lược tốt nhất có thể, hãy tìm ra ai sẽ thắng trò chơi.\n    >>> f_35(3, 1, 2, 2)\n    \"Dan\"", "id": "Tulis sebuah fungsi C `const char* f_35(int n, int piles[])` untuk menyelesaikan masalah berikut:\nDiberikan sebuah urutan N tumpukan batu yang diberi nomor dari 1 hingga N, dengan setiap tumpukan berisi sejumlah batu positif, tentukan pemenang dari permainan yang dimainkan oleh Charlie dan Dan. Charlie pergi lebih dulu, dan mereka bergiliran memindahkan sejumlah batu positif dari tumpukan paling kiri yang tidak kosong ke tumpukan kanan yang berdekatan. Pemain yang hanya dapat memindahkan batu di tumpukan terakhir kalah. Dengan asumsi kedua pemain menggunakan strategi terbaik yang mungkin, cari tahu siapa yang akan memenangkan permainan.\n    >>> f_35(3, 1, 2, 2)\n    \"Dan\"", "ja": "Cの関数を書け `const char* f_35(int n, int piles[])` を作成して、次の問題を解決してください:\n1からNまで番号が付けられたN個の石の山があり、それぞれの山には正の数の石が含まれています。チャーリーとダンがプレイするゲームの勝者を決定します。チャーリーが最初に行動し、彼らは交互に左端の空でない山から隣接する右の山に正の数の石を移動します。最後の山でしか石を動かせないプレイヤーが負けます。両方のプレイヤーが可能な限り最善の戦略を使用すると仮定して、誰がゲームに勝つかを見つけてください。\n    >>> f_35(3, 1, 2, 2)\n    \"Dan\"", "ko": "C 함수 `const char* f_35(int n, int piles[])`를 작성하여 다음 문제를 해결하십시오:\nN개의 돌 무더기가 1부터 N까지 번호가 매겨져 있으며, 각 무더기에는 양의 개수의 돌이 포함되어 있습니다. Charlie와 Dan이 플레이하는 게임의 승자를 결정하십시오. Charlie가 먼저 시작하고, 그들은 차례로 왼쪽에서 가장 가까운 비어 있지 않은 무더기에서 인접한 오른쪽 무더기로 양의 개수의 돌을 이동시킵니다. 마지막 무더기에서만 돌을 이동할 수 있는 플레이어가 게임에서 집니다. 두 플레이어 모두 최선의 전략을 사용한다고 가정할 때, 누가 게임에서 승리할지 알아보십시오.\n    >>> f_35(3, 1, 2, 2)\n    \"Dan\"", "ml": "ഒരു C ഫംഗ്ഷൻ എഴുതുക `const char* f_35(int n, int piles[])` ഈ പ്രശ്നം പരിഹരിക്കാൻ:\nN കല്ലുകളുടെ കൂമ്പാരങ്ങളുടെ ഒരു നിര നൽകിയിരിക്കുന്നു, 1 മുതൽ N വരെ നമ്പർ ചെയ്തിരിക്കുന്നു, ഓരോ കൂമ്പാരവും ഒരു പോസിറ്റീവ് കല്ലുകളുടെ എണ്ണം അടങ്ങിയിരിക്കുന്നു, ചാർളിയും ഡാനും കളിക്കുന്ന ഒരു ഗെയിമിന്റെ വിജയിയെ നിർണ്ണയിക്കുക. ചാർളി ആദ്യം പോകുന്നു, അവർ ഇടത് വശത്തെ ശൂന്യമല്ലാത്ത കൂമ്പാരത്തിൽ നിന്ന് സമീപ വലത് കൂമ്പാരത്തിലേക്ക് ഒരു പോസിറ്റീവ് കല്ലുകളുടെ എണ്ണം നീക്കുന്നു. അവസാന കൂമ്പാരത്തിൽ മാത്രം കല്ലുകൾ നീക്കാൻ കഴിയുന്ന കളിക്കാരൻ തോൽക്കും. ഇരുവരും ഏറ്റവും മികച്ച തന്ത്രം ഉപയോഗിക്കുന്നതായി കരുതിയാൽ, ഗെയിം ആരാണ് ജയിക്കുക എന്ന് കണ്ടെത്തുക.\n    >>> f_35(3, 1, 2, 2)\n    \"Dan\"", "fa": "یک تابع C به نام `const char* f_35(int n, int piles[])` بنویسید تا مسئله زیر را حل کند:\nبا توجه به دنباله‌ای از N توده سنگ شماره‌گذاری شده از 1 تا N، که هر توده شامل تعداد مثبتی از سنگ‌ها است، برنده بازی که توسط چارلی و دن انجام می‌شود را تعیین کنید. چارلی اول می‌رود و آنها به نوبت تعداد مثبتی از سنگ‌ها را از توده غیر خالی سمت چپ‌ترین به توده مجاور راست منتقل می‌کنند. بازیکنی که فقط می‌تواند سنگ‌ها را در توده آخر حرکت دهد، بازنده است. با فرض اینکه هر دو بازیکن از بهترین استراتژی ممکن استفاده می‌کنند، مشخص کنید که چه کسی بازی را خواهد برد.\n    >>> f_35(3, 1, 2, 2)\n    \"Dan\""}, "level": "middle", "test": "int main() {\n    int test1[] = {1, 2, 2};\n    int test2[] = {5, 5, 5, 5, 5};\n    int test3[] = {2, 1, 2};\n    int test4[] = {3, 3, 3, 3};\n    int test5[] = {1, 1};\n    int test6[] = {2, 1};\n    int test7[] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};\n    int test8[] = {2, 2, 2, 2, 2, 2, 2, 2, 2, 1};\n    int test9[] = {10, 10, 10, 10, 10, 10, 10, 10, 10, 10};\n    int test10[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n\n    assert(f_35(3, test1) == \"Dan\");\n    assert(f_35(5, test2) == \"Charlie\");\n    assert(f_35(3, test3) == \"Charlie\");\n    assert(f_35(4, test4) == \"Charlie\");\n    assert(f_35(2, test5) == \"Charlie\");\n    assert(f_35(2, test6) == \"Charlie\");\n    assert(f_35(11, test7) == \"Dan\");\n    assert(f_35(10, test8) == \"Charlie\");\n    assert(f_35(10, test9) == \"Charlie\");\n    assert(f_35(10, test10) == \"Dan\");\n\n    return 0;\n}", "entry_point": "f_35", "signature": "const char* f_35(int n, int piles[])", "docstring": {"en": "Given a sequence of N piles of stones numbered from 1 to N, with each pile containing a positive number of stones, determine the winner of a game played by Charlie and Dan. Charlie goes first, and they take turns moving a positive number of stones from the leftmost non-empty pile to the adjacent right pile. The player who can only move stones in the last pile loses. Assuming both players use the best possible strategy, find out who will win the game.\n    >>> f_35(3, 1, 2, 2)\n    \"Dan\"\n", "sq": "Duke pasur një sekuencë prej N grumbuj gurësh të numëruar nga 1 deri në N, me secilin grumbull që përmban një numër pozitiv gurësh, përcaktoni fituesin e një loje të luajtur nga Charlie dhe Dan. Charlie fillon i pari dhe ata marrin radhën duke lëvizur një numër pozitiv gurësh nga grumbulli më i majtë jo bosh në grumbullin fqinjë në të djathtë. Lojtari që mund të lëvizë gurë vetëm në grumbullin e fundit humbet. Duke supozuar se të dy lojtarët përdorin strategjinë më të mirë të mundshme, zbuloni se kush do të fitojë lojën.\n    >>> f_35(3, 1, 2, 2)\n    \"Dan\"", "hy": "Տրված է N քարերի կույտերի հաջորդականություն, որոնք համարակալված են 1-ից N, և յուրաքանչյուր կույտ պարունակում է քարերի դրական քանակ: Պետք է որոշել, թե ով կհաղթի խաղում, որը խաղում են Չարլին և Դենը: Չարլին առաջինն է խաղում, և նրանք հերթով տեղափոխում են քարերի դրական քանակ ձախից ամենաառաջին ոչ դատարկ կույտից դեպի հարևան աջ կույտ: Այն խաղացողը, որը կարող է միայն տեղափոխել քարեր վերջին կույտում, պարտվում է: Ենթադրելով, որ երկու խաղացողներն էլ օգտագործում են հնարավոր լավագույն ռազմավարությունը, պարզեք, թե ով կհաղթի խաղը:\n    >>> f_35(3, 1, 2, 2)\n    \"Dan\"", "bn": "একটি N সংখ্যক পাথরের স্তূপের ক্রম দেওয়া হয়েছে, যেগুলি 1 থেকে N পর্যন্ত নম্বরযুক্ত, প্রতিটি স্তূপে একটি ধনাত্মক সংখ্যক পাথর রয়েছে, চার্লি এবং ড্যান দ্বারা খেলা একটি গেমের বিজয়ী নির্ধারণ করুন। চার্লি প্রথমে যায়, এবং তারা পালাক্রমে বামদিকের প্রথম খালি না থাকা স্তূপ থেকে ডানদিকে সংলগ্ন স্তূপে একটি ধনাত্মক সংখ্যক পাথর সরিয়ে নেয়। যে খেলোয়াড় কেবলমাত্র শেষ স্তূপে পাথর সরাতে পারে সে হেরে যায়। ধরে নেওয়া হয় উভয় খেলোয়াড়ই সর্বোত্তম কৌশল ব্যবহার করে, খুঁজে বের করুন কে গেমটি জিতবে।\n    >>> f_35(3, 1, 2, 2)\n    \"Dan\"", "bg": "Дадена е последователност от N купчини камъни, номерирани от 1 до N, като всяка купчина съдържа положителен брой камъни, определете победителя в игра, играна от Чарли и Дан. Чарли започва пръв и те се редуват да преместват положителен брой камъни от най-лявата непразна купчина в съседната дясна купчина. Играчът, който може да премести камъни само в последната купчина, губи. Приемайки, че и двамата играчи използват възможно най-добрата стратегия, разберете кой ще спечели играта.\n    >>> f_35(3, 1, 2, 2)\n    \"Dan\"", "zh": "给定一个编号为1到N的石堆序列，每堆包含一个正数的石头，确定由Charlie和Dan进行的游戏的获胜者。Charlie先开始，他们轮流从最左边的非空堆中移动正数的石头到相邻的右边堆。只能在最后一堆移动石头的玩家输掉比赛。假设两位玩家都使用最佳策略，找出谁将赢得比赛。\n    >>> f_35(3, 1, 2, 2)\n    \"Dan\"", "fr": "Étant donné une séquence de N tas de pierres numérotés de 1 à N, chaque tas contenant un nombre positif de pierres, déterminez le gagnant d'un jeu joué par Charlie et Dan. Charlie commence, et ils jouent à tour de rôle en déplaçant un nombre positif de pierres du tas le plus à gauche non vide vers le tas adjacent à droite. Le joueur qui ne peut déplacer des pierres que dans le dernier tas perd. En supposant que les deux joueurs utilisent la meilleure stratégie possible, découvrez qui gagnera le jeu.\n    >>> f_35(3, 1, 2, 2)\n    \"Dan\"", "de": "Angenommen, es gibt eine Sequenz von N Steinhaufen, die von 1 bis N nummeriert sind, wobei jeder Haufen eine positive Anzahl von Steinen enthält. Bestimmen Sie den Gewinner eines Spiels, das von Charlie und Dan gespielt wird. Charlie beginnt, und sie wechseln sich ab, indem sie eine positive Anzahl von Steinen vom linken, nicht leeren Haufen zum benachbarten rechten Haufen bewegen. Der Spieler, der nur noch Steine im letzten Haufen bewegen kann, verliert. Angenommen, beide Spieler verwenden die bestmögliche Strategie, finden Sie heraus, wer das Spiel gewinnen wird.\n    >>> f_35(3, 1, 2, 2)\n    \"Dan\"", "ha": "An ba da jerin N na tarin duwatsu da aka lamba daga 1 zuwa N, tare da kowanne tarin dauke da adadin duwatsu masu kyau, tantance wanda zai ci wasa da Charlie da Dan suka buga. Charlie yana farawa, kuma suna juyawa suna motsa adadin duwatsu masu kyau daga tarin da ba komai a hagu zuwa tarin da ke kusa a dama. Dan wasan da zai iya motsa duwatsu kawai a cikin tarin karshe zai rasa. Ana tsammanin duka 'yan wasan suna amfani da mafi kyawun dabaru mai yiwuwa, gano wanda zai ci wasan.\n    >>> f_35(3, 1, 2, 2)\n    \"Dan\"", "hi": "दी गई N पत्थरों के ढेरों की अनुक्रमणिका, जो 1 से N तक क्रमांकित हैं, और प्रत्येक ढेर में सकारात्मक संख्या में पत्थर हैं, यह निर्धारित करें कि चार्ली और डैन द्वारा खेले गए खेल का विजेता कौन होगा। चार्ली पहले जाता है, और वे बारी-बारी से बाईं ओर के सबसे पहले गैर-खाली ढेर से दाईं ओर के सटे हुए ढेर में सकारात्मक संख्या में पत्थर ले जाते हैं। वह खिलाड़ी जो केवल अंतिम ढेर में पत्थरों को ले जा सकता है, हार जाता है। मान लें कि दोनों खिलाड़ी सबसे अच्छी संभव रणनीति का उपयोग करते हैं, पता करें कि खेल कौन जीतेगा।\n    >>> f_35(3, 1, 2, 2)\n    \"Dan\"", "hu": "Adott egy N kövekből álló sorozat, amelyeket 1-től N-ig számoznak, és minden halom pozitív számú követ tartalmaz. Határozza meg a Charlie és Dan által játszott játék győztesét. Charlie kezd, és felváltva mozgatnak egy pozitív számú követ a legbaloldalibb nem üres halomból a szomszédos jobb oldali halomba. Az a játékos veszít, aki csak az utolsó halomban tud köveket mozgatni. Feltételezve, hogy mindkét játékos a lehető legjobb stratégiát alkalmazza, derítse ki, ki nyeri meg a játékot.\n    >>> f_35(3, 1, 2, 2)\n    \"Dan\"", "es": "Dada una secuencia de N pilas de piedras numeradas del 1 al N, con cada pila conteniendo un número positivo de piedras, determina el ganador de un juego jugado por Charlie y Dan. Charlie va primero, y se turnan moviendo un número positivo de piedras de la pila más a la izquierda que no esté vacía a la pila adyacente a la derecha. El jugador que solo pueda mover piedras en la última pila pierde. Suponiendo que ambos jugadores usan la mejor estrategia posible, averigua quién ganará el juego.\n    >>> f_35(3, 1, 2, 2)\n    \"Dan\"", "arb": "بالنظر إلى تسلسل مكون من N كومة من الحجارة مرقمة من 1 إلى N، مع احتواء كل كومة على عدد موجب من الحجارة، حدد الفائز في لعبة يلعبها تشارلي ودان. يبدأ تشارلي أولاً، ويتناوبان في نقل عدد موجب من الحجارة من الكومة غير الفارغة الأكثر يسارًا إلى الكومة المجاورة على اليمين. اللاعب الذي لا يمكنه سوى نقل الحجارة في الكومة الأخيرة يخسر. بافتراض أن كلا اللاعبين يستخدمان أفضل استراتيجية ممكنة، اكتشف من سيفوز في اللعبة.\n    >>> f_35(3, 1, 2, 2)\n    \"Dan\"", "sw": "Kwa kuzingatia mlolongo wa marundo N ya mawe yaliyohesabiwa kutoka 1 hadi N, ambapo kila rundo lina idadi chanya ya mawe, bainisha mshindi wa mchezo unaochezwa na Charlie na Dan. Charlie anaanza, na wanachukua zamu kuhamisha idadi chanya ya mawe kutoka kwenye rundo la kwanza lisilo tupu kwenda kwenye rundo la kulia lililo karibu. Mchezaji ambaye anaweza tu kuhamisha mawe kwenye rundo la mwisho anapoteza. Tukichukulia kwamba wachezaji wote wanatumia mkakati bora zaidi, gundua ni nani atakayeshinda mchezo.\n    >>> f_35(3, 1, 2, 2)\n    \"Dan\"", "tr": "Verilen N taş yığınından oluşan bir dizide, her yığın pozitif sayıda taş içermektedir ve 1'den N'e kadar numaralandırılmıştır. Charlie ve Dan tarafından oynanan bir oyunun kazananını belirleyin. Charlie ilk hamleyi yapar ve sırayla en soldaki boş olmayan yığından bitişik sağdaki yığına pozitif sayıda taş taşırlar. Sadece son yığındaki taşları hareket ettirebilen oyuncu kaybeder. Her iki oyuncunun da en iyi stratejiyi kullandığını varsayarak, oyunu kimin kazanacağını bulun.\n    >>> f_35(3, 1, 2, 2)\n    \"Dan\"", "vi": "Cho một dãy N đống đá được đánh số từ 1 đến N, với mỗi đống chứa một số lượng đá dương, xác định người chiến thắng của trò chơi được chơi bởi Charlie và Dan. Charlie đi trước, và họ lần lượt di chuyển một số lượng đá dương từ đống không trống bên trái nhất sang đống liền kề bên phải. Người chơi chỉ có thể di chuyển đá trong đống cuối cùng sẽ thua. Giả sử cả hai người chơi đều sử dụng chiến lược tốt nhất có thể, hãy tìm ra ai sẽ thắng trò chơi.\n    >>> f_35(3, 1, 2, 2)\n    \"Dan\"", "id": "Diberikan urutan N tumpukan batu yang diberi nomor dari 1 hingga N, dengan setiap tumpukan berisi sejumlah batu positif, tentukan pemenang dari permainan yang dimainkan oleh Charlie dan Dan. Charlie pergi lebih dulu, dan mereka bergantian memindahkan sejumlah batu positif dari tumpukan paling kiri yang tidak kosong ke tumpukan kanan yang berdekatan. Pemain yang hanya dapat memindahkan batu di tumpukan terakhir kalah. Dengan asumsi kedua pemain menggunakan strategi terbaik yang mungkin, cari tahu siapa yang akan memenangkan permainan.\n    >>> f_35(3, 1, 2, 2)\n    \"Dan\"", "ja": "N個の石の山が1からNまで番号付けられており、それぞれの山には正の数の石が含まれています。チャーリーとダンがプレイするゲームの勝者を決定します。チャーリーが最初に行動し、彼らは交互に左端の空でない山から隣接する右の山に正の数の石を移動します。最後の山でしか石を動かせないプレイヤーが負けます。両方のプレイヤーが最善の戦略を使用すると仮定して、誰がゲームに勝つかを見つけます。\n    >>> f_35(3, 1, 2, 2)\n    \"Dan\"", "ko": "돌무더기 N개가 1번부터 N번까지 번호가 매겨져 있으며, 각 무더기에는 양의 개수의 돌이 들어 있습니다. Charlie와 Dan이 하는 게임의 승자를 결정하세요. Charlie가 먼저 시작하며, 그들은 차례로 가장 왼쪽의 비어 있지 않은 무더기에서 양의 개수의 돌을 인접한 오른쪽 무더기로 옮깁니다. 마지막 무더기에서만 돌을 옮길 수 있는 플레이어가 패배합니다. 두 플레이어 모두 최상의 전략을 사용한다고 가정할 때, 누가 게임에서 승리할지 알아보세요.\n    >>> f_35(3, 1, 2, 2)\n    \"Dan\"", "ml": "N കല്ലുകളുടെ കൂമ്പാരങ്ങളുടെ ഒരു പരമ്പര നൽകിയിരിക്കുന്നു, 1 മുതൽ N വരെ നമ്പർ ചെയ്തിരിക്കുന്നു, ഓരോ കൂമ്പാരത്തിലും ഒരു പോസിറ്റീവ് എണ്ണം കല്ലുകൾ അടങ്ങിയിരിക്കുന്നു, ചാർളിയും ഡാനും കളിക്കുന്ന ഒരു ഗെയിമിന്റെ വിജയിയെ നിർണയിക്കുക. ചാർളി ആദ്യം പോകുന്നു, അവർ മാറി മാറി ഇടതുവശത്തെ ഒഴിഞ്ഞുകിടക്കുന്ന കൂമ്പാരത്തിൽ നിന്ന് അടുത്ത വലതുവശത്തെ കൂമ്പാരത്തിലേക്ക് ഒരു പോസിറ്റീവ് എണ്ണം കല്ലുകൾ നീക്കുന്നു. അവസാനത്തെ കൂമ്പാരത്തിൽ മാത്രം കല്ലുകൾ നീക്കാൻ കഴിയുന്ന കളിക്കാരൻ തോൽക്കും. ഇരുവരും ഏറ്റവും നല്ല തന്ത്രം ഉപയോഗിക്കുന്നതായി കരുതുമ്പോൾ, ഗെയിം ആരാണ് ജയിക്കുക എന്ന് കണ്ടെത്തുക.\n    >>> f_35(3, 1, 2, 2)\n    \"Dan\"", "fa": "با توجه به دنباله‌ای از N توده سنگ شماره‌گذاری شده از 1 تا N، که هر توده شامل تعداد مثبتی از سنگ‌ها است، برنده بازی که توسط چارلی و دن انجام می‌شود را تعیین کنید. چارلی اول شروع می‌کند و آنها به نوبت تعداد مثبتی از سنگ‌ها را از توده غیرخالی سمت چپ به توده مجاور راست منتقل می‌کنند. بازیکنی که تنها می‌تواند سنگ‌ها را در توده آخر حرکت دهد، بازنده است. با فرض اینکه هر دو بازیکن از بهترین استراتژی ممکن استفاده می‌کنند، مشخص کنید چه کسی برنده بازی خواهد بود.\n    >>> f_35(3, 1, 2, 2)\n    \"Dan\""}}
{"task_id": "C/36", "prompt": {"en": "#include <assert.h>\n#include <stdio.h>\n/*\nGiven n doors arranged in a circle, the player starts in front of door 1. Each turn, the player can choose a number i and pay a cost C_i to move i steps to the right and then open the door at that position. It is guaranteed that C_i >= C_{i+1} for 1 <= i < n.\nThe task is to determine the minimum total cost required to open all doors.\n\nExample:\n    >>> f_36(3, (1, 1, 1))\n    3\n*/\nlong long f_36(int n, int *C)", "sq": "#include <assert.h>\n#include <stdio.h>\n/*\nDuke pasur parasysh n dyer të renditura në një rreth, lojtari fillon përpara derës 1. Çdo radhë, lojtari mund të zgjedhë një numër i dhe të paguajë një kosto C_i për të lëvizur i hapa djathtas dhe pastaj të hapë derën në atë pozicion. Është e garantuar që C_i >= C_{i+1} për 1 <= i < n.\nDetyra është të përcaktohet kostoja totale minimale e kërkuar për të hapur të gjitha dyert.\n\nShembull:\n    >>> f_36(3, (1, 1, 1))\n    3\n*/\nlong long f_36(int n, int *C)", "hy": "#include <assert.h>\n#include <stdio.h>\n/*\nՈւնենալով n դռներ, որոնք դասավորված են շրջանաձև, խաղացողը սկսում է դուռ 1-ի դիմացից։ Յուրաքանչյուր քայլում խաղացողը կարող է ընտրել թիվ i և վճարել C_i արժեքը՝ i քայլ աջ շարժվելու և այդ դիրքում դուռը բացելու համար։ Երաշխավորված է, որ C_i >= C_{i+1} 1 <= i < n-ի համար։\nԽնդիրը կայանում է որոշել բոլոր դռները բացելու համար պահանջվող նվազագույն ընդհանուր արժեքը։\n\nՕրինակ:\n    >>> f_36(3, (1, 1, 1))\n    3\n*/\nlong long f_36(int n, int *C)", "bn": "#include <assert.h>\n#include <stdio.h>\n/*\nবৃত্তাকারে সাজানো n টি দরজা দেওয়া আছে, খেলোয়াড় দরজা 1 এর সামনে থেকে শুরু করে। প্রতিটি পালায়, খেলোয়াড় একটি সংখ্যা i নির্বাচন করতে পারে এবং i ধাপ ডানদিকে যেতে এবং তারপর সেই অবস্থানের দরজা খুলতে C_i খরচ দিতে পারে। এটি নিশ্চিত করা হয়েছে যে C_i >= C_{i+1} যেখানে 1 <= i < n।\nসমস্ত দরজা খোলার জন্য প্রয়োজনীয় সর্বনিম্ন মোট খরচ নির্ধারণ করার কাজ।\n\nউদাহরণ:\n    >>> f_36(3, (1, 1, 1))\n    3\n*/\nlong long f_36(int n, int *C)", "bg": "#include <assert.h>\n#include <stdio.h>\n/*\nДадени са n врати, подредени в кръг, играчът започва пред врата 1. Всеки ход играчът може да избере число i и да плати цена C_i, за да се премести i стъпки надясно и след това да отвори вратата на тази позиция. Гарантирано е, че C_i >= C_{i+1} за 1 <= i < n.\nЗадачата е да се определи минималната обща цена, необходима за отваряне на всички врати.\n\nПример:\n    >>> f_36(3, (1, 1, 1))\n    3\n*/\nlong long f_36(int n, int *C)", "zh": "#include <assert.h>\n#include <stdio.h>\n/*\n给定 n 个门按圆形排列，玩家从门 1 前面开始。每一回合，玩家可以选择一个数字 i 并支付一个代价 C_i 向右移动 i 步，然后打开该位置的门。保证 C_i >= C_{i+1} 对于 1 <= i < n。\n任务是确定打开所有门所需的最小总成本。\n\n示例：\n    >>> f_36(3, (1, 1, 1))\n    3\n*/\nlong long f_36(int n, int *C)", "fr": "#include <assert.h>\n#include <stdio.h>\n/*\nÉtant donné n portes disposées en cercle, le joueur commence devant la porte 1. À chaque tour, le joueur peut choisir un nombre i et payer un coût C_i pour avancer de i pas vers la droite puis ouvrir la porte à cette position. Il est garanti que C_i >= C_{i+1} pour 1 <= i < n.\nLa tâche consiste à déterminer le coût total minimum nécessaire pour ouvrir toutes les portes.\n\nExemple :\n    >>> f_36(3, (1, 1, 1))\n    3\n*/\nlong long f_36(int n, int *C)", "de": "#include <assert.h>\n#include <stdio.h>\n/*\nGegeben sind n Türen, die in einem Kreis angeordnet sind. Der Spieler beginnt vor Tür 1. In jedem Zug kann der Spieler eine Zahl i wählen und einen Kostenbetrag C_i zahlen, um i Schritte nach rechts zu gehen und dann die Tür an dieser Position zu öffnen. Es ist garantiert, dass C_i >= C_{i+1} für 1 <= i < n.\nDie Aufgabe besteht darin, die minimalen Gesamtkosten zu bestimmen, die erforderlich sind, um alle Türen zu öffnen.\n\nBeispiel:\n    >>> f_36(3, (1, 1, 1))\n    3\n*/\nlong long f_36(int n, int *C)", "ha": "#include <assert.h>\n#include <stdio.h>\n/*\nAn ba da ƙofofi n da aka shirya a cikin da'ira, ɗan wasa yana farawa a gaban ƙofa ta 1. Kowace juyawa, ɗan wasa zai iya zaɓar lamba i kuma ya biya farashi C_i don matsawa matakai i zuwa dama sannan ya buɗe ƙofar a wannan matsayi. An tabbatar da cewa C_i >= C_{i+1} don 1 <= i < n.\nAikin shi ne a tantance mafi ƙarancin jimillar farashi da ake buƙata don buɗe duk ƙofofin.\n\nMisali:\n    >>> f_36(3, (1, 1, 1))\n    3\n*/\nlong long f_36(int n, int *C)", "hi": "#include <assert.h>\n#include <stdio.h>\n/*\nदिए गए n दरवाजों को एक वृत्त में व्यवस्थित किया गया है, खिलाड़ी दरवाजा 1 के सामने से शुरू करता है। प्रत्येक चाल में, खिलाड़ी एक संख्या i चुन सकता है और i कदम दाईं ओर जाने के लिए C_i लागत का भुगतान कर सकता है और फिर उस स्थिति पर दरवाजा खोल सकता है। यह गारंटी है कि C_i >= C_{i+1} है जहाँ 1 <= i < n।\nकार्य यह निर्धारित करना है कि सभी दरवाजे खोलने के लिए न्यूनतम कुल लागत क्या होगी।\n\nउदाहरण:\n    >>> f_36(3, (1, 1, 1))\n    3\n*/\nlong long f_36(int n, int *C)", "hu": "#include <assert.h>\n#include <stdio.h>\n/*\nAdott n ajtó, amelyek körben vannak elrendezve, a játékos az 1. ajtó előtt kezd. Minden körben a játékos választhat egy számot i, és fizet egy C_i költséget, hogy i lépést jobbra lépjen, majd kinyissa az adott pozíción lévő ajtót. Garantált, hogy C_i >= C_{i+1} minden 1 <= i < n esetén.\nA feladat annak meghatározása, hogy mi a minimális összköltség az összes ajtó kinyitásához.\n\nPélda:\n    >>> f_36(3, (1, 1, 1))\n    3\n*/\nlong long f_36(int n, int *C)", "es": "#include <assert.h>\n#include <stdio.h>\n/*\nDado n puertas dispuestas en un círculo, el jugador comienza frente a la puerta 1. En cada turno, el jugador puede elegir un número i y pagar un costo C_i para moverse i pasos a la derecha y luego abrir la puerta en esa posición. Se garantiza que C_i >= C_{i+1} para 1 <= i < n.\nLa tarea es determinar el costo total mínimo requerido para abrir todas las puertas.\n\nEjemplo:\n    >>> f_36(3, (1, 1, 1))\n    3\n*/\nlong long f_36(int n, int *C)", "arb": "#include <assert.h>\n#include <stdio.h>\n/*\nبالنظر إلى n أبواب مرتبة في دائرة، يبدأ اللاعب أمام الباب 1. في كل دور، يمكن للاعب اختيار رقم i ودفع تكلفة C_i للتحرك i خطوات إلى اليمين ثم فتح الباب في ذلك الموضع. من المضمون أن C_i >= C_{i+1} لـ 1 <= i < n.\nالمهمة هي تحديد الحد الأدنى للتكلفة الإجمالية المطلوبة لفتح جميع الأبواب.\n\nمثال:\n    >>> f_36(3, (1, 1, 1))\n    3\n*/\nlong long f_36(int n, int *C)", "sw": "#include <assert.h>\n#include <stdio.h>\n/*\nUkipewa milango n iliyopangwa katika mduara, mchezaji huanza mbele ya mlango wa 1. Kila zamu, mchezaji anaweza kuchagua nambari i na kulipa gharama C_i ili kusonga hatua i kwenda kulia na kisha kufungua mlango katika nafasi hiyo. Imethibitishwa kuwa C_i >= C_{i+1} kwa 1 <= i < n.\nKazi ni kubaini gharama ya chini kabisa inayohitajika kufungua milango yote.\n\nMfano:\n    >>> f_36(3, (1, 1, 1))\n    3\n*/\nlong long f_36(int n, int *C)", "tr": "#include <assert.h>\n#include <stdio.h>\n/*\nBir çemberde düzenlenmiş n kapı verildiğinde, oyuncu kapı 1'in önünde başlar. Her turda, oyuncu bir sayı i seçebilir ve i adım sağa hareket etmek ve ardından o konumdaki kapıyı açmak için bir maliyet C_i ödeyebilir. C_i >= C_{i+1} olduğu garanti edilir, 1 <= i < n için.\nGörev, tüm kapıları açmak için gereken minimum toplam maliyeti belirlemektir.\n\nÖrnek:\n    >>> f_36(3, (1, 1, 1))\n    3\n*/\nlong long f_36(int n, int *C)", "vi": "#include <assert.h>\n#include <stdio.h>\n/*\nCho n cánh cửa được sắp xếp thành một vòng tròn, người chơi bắt đầu trước cửa số 1. Mỗi lượt, người chơi có thể chọn một số i và trả một chi phí C_i để di chuyển i bước sang phải và sau đó mở cánh cửa ở vị trí đó. Đảm bảo rằng C_i >= C_{i+1} với 1 <= i < n.\nNhiệm vụ là xác định tổng chi phí tối thiểu cần thiết để mở tất cả các cửa.\n\nVí dụ:\n    >>> f_36(3, (1, 1, 1))\n    3\n*/\nlong long f_36(int n, int *C)", "id": "#include <assert.h>\n#include <stdio.h>\n/*\nDiberikan n pintu yang diatur dalam lingkaran, pemain mulai di depan pintu 1. Setiap giliran, pemain dapat memilih angka i dan membayar biaya C_i untuk bergerak i langkah ke kanan dan kemudian membuka pintu di posisi tersebut. Dijamin bahwa C_i >= C_{i+1} untuk 1 <= i < n.\nTugasnya adalah menentukan total biaya minimum yang diperlukan untuk membuka semua pintu.\n\nContoh:\n    >>> f_36(3, (1, 1, 1))\n    3\n*/\nlong long f_36(int n, int *C)", "ja": "#include <assert.h>\n#include <stdio.h>\n/*\nn 個のドアが円形に配置されているとき、プレイヤーはドア1の前からスタートします。各ターンで、プレイヤーは数 i を選び、コスト C_i を支払って右に i ステップ移動し、その位置のドアを開けることができます。1 <= i < n に対して C_i >= C_{i+1} が保証されています。\nすべてのドアを開けるために必要な最小の総コストを求めることが課題です。\n\n例:\n    >>> f_36(3, (1, 1, 1))\n    3\n*/\nlong long f_36(int n, int *C)", "ko": "#include <assert.h>\n#include <stdio.h>\n/*\nn개의 문이 원형으로 배열되어 있을 때, 플레이어는 문 1 앞에서 시작합니다. 각 턴마다 플레이어는 숫자 i를 선택하고 비용 C_i를 지불하여 i단계 오른쪽으로 이동한 다음 해당 위치의 문을 엽니다. C_i >= C_{i+1}이 1 <= i < n에 대해 보장됩니다.\n모든 문을 여는 데 필요한 최소 총 비용을 결정하는 것이 과제입니다.\n\n예시:\n    >>> f_36(3, (1, 1, 1))\n    3\n*/\nlong long f_36(int n, int *C)", "ml": "#include <assert.h>\n#include <stdio.h>\n/*\nn വാതിലുകൾ ഒരു വൃത്തത്തിൽ ക്രമീകരിച്ചിരിക്കുന്ന സാഹചര്യത്തിൽ, കളിക്കാരൻ വാതിൽ 1-ന്റെ മുന്നിൽ നിന്ന് ആരംഭിക്കുന്നു. ഓരോ തവണയും, കളിക്കാരൻ ഒരു സംഖ്യ i തിരഞ്ഞെടുക്കുകയും i ഘട്ടങ്ങൾ വലത്തേക്ക് നീങ്ങി ആ സ്ഥാനത്തെ വാതിൽ തുറക്കാൻ C_i ചെലവ് നൽകുകയും ചെയ്യാം. 1 <= i < n എന്നതിനായി C_i >= C_{i+1} എന്ന് ഉറപ്പാണ്.\nഎല്ലാ വാതിലുകളും തുറക്കാൻ ആവശ്യമായ കുറഞ്ഞ മൊത്തം ചെലവ് നിർണയിക്കേണ്ടതാണ്.\n\nഉദാഹരണം:\n    >>> f_36(3, (1, 1, 1))\n    3\n*/\nlong long f_36(int n, int *C)", "fa": "#include <assert.h>\n#include <stdio.h>\n/*\nبا توجه به n در که به صورت دایره‌ای چیده شده‌اند، بازیکن در مقابل در 1 شروع می‌کند. در هر نوبت، بازیکن می‌تواند عددی i را انتخاب کند و هزینه C_i را بپردازد تا i قدم به سمت راست حرکت کند و سپس در را در آن موقعیت باز کند. تضمین شده است که C_i >= C_{i+1} برای 1 <= i < n.\nوظیفه این است که حداقل هزینه کل مورد نیاز برای باز کردن همه درها را تعیین کنید.\n\nمثال:\n    >>> f_36(3, (1, 1, 1))\n    3\n*/\nlong long f_36(int n, int *C)\n"}, "canonical_solution": "{\n   return (long long)(C[n-2]) * (n - 1) + C[n-1];\n}", "instruction": {"en": "Write a C function `long long f_36(int n, int *C)` to solve the following problem:\nGiven n doors arranged in a circle, the player starts in front of door 1. Each turn, the player can choose a number i and pay a cost C_i to move i steps to the right and then open the door at that position. It is guaranteed that C_i >= C_{i+1} for 1 <= i < n.\nThe task is to determine the minimum total cost required to open all doors.\n\nExample:\n    >>> f_36(3, (1, 1, 1))\n    3\n", "sq": "Shkruani një funksion në C `long long f_36(int n, int *C)` për të zgjidhur problemin e mëposhtëm:\nDuke pasur parasysh n dyer të rregulluara në një rreth, lojtari fillon përpara derës 1. Çdo radhë, lojtari mund të zgjedhë një numër i dhe të paguajë një kosto C_i për të lëvizur i hapa djathtas dhe pastaj të hapë derën në atë pozicion. Është e garantuar që C_i >= C_{i+1} për 1 <= i < n.\nDetyra është të përcaktohet kostoja totale minimale e kërkuar për të hapur të gjitha dyert.\n\nShembull:\n    >>> f_36(3, (1, 1, 1))\n    3", "hy": "Գրեք C ֆունկցիա `long long f_36(int n, int *C)`՝ լուծելու հետևյալ խնդիրը:\nՏրված են n դռներ, որոնք դասավորված են շրջանաձև: Խաղացողը սկսում է դուռ 1-ի դիմաց: Յուրաքանչյուր քայլի ժամանակ խաղացողը կարող է ընտրել թիվ i և վճարել արժեք C_i՝ i քայլ աջ շարժվելու և այնուհետև այդ դիրքում գտնվող դուռը բացելու համար: Երաշխավորված է, որ C_i >= C_{i+1} 1 <= i < n-ի համար:\nԽնդիրը կայանում է որոշելու բոլոր դռները բացելու համար անհրաժեշտ նվազագույն ընդհանուր արժեքը:\n\nՕրինակ:\n    >>> f_36(3, (1, 1, 1))\n    3", "bn": "একটি C ফাংশন `long long f_36(int n, int *C)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nn টি দরজা একটি বৃত্তে সাজানো আছে, খেলোয়াড় দরজা 1 এর সামনে থেকে শুরু করে। প্রতিটি পালায়, খেলোয়াড় একটি সংখ্যা i বেছে নিতে পারে এবং i ধাপ ডানে যেতে এবং তারপর সেই অবস্থানের দরজা খুলতে C_i খরচ দিতে পারে। এটা নিশ্চিত যে C_i >= C_{i+1} যেখানে 1 <= i < n।\nকাজটি হল সমস্ত দরজা খোলার জন্য প্রয়োজনীয় সর্বনিম্ন মোট খরচ নির্ধারণ করা।\n\nউদাহরণ:\n    >>> f_36(3, (1, 1, 1))\n    3", "bg": "Напишете C функция `long long f_36(int n, int *C)`, за да решите следния проблем:\nДадени са n врати, подредени в кръг, играчът започва пред врата 1. Всеки ход играчът може да избере число i и да плати цена C_i, за да се премести i стъпки надясно и след това да отвори вратата на тази позиция. Гарантирано е, че C_i >= C_{i+1} за 1 <= i < n.  \nЗадачата е да се определи минималната обща цена, необходима за отваряне на всички врати.\n\nПример:\n    >>> f_36(3, (1, 1, 1))\n    3", "zh": "编写一个 C 函数 `long long f_36(int n, int *C)` 来解决以下问题：\n给定 n 扇门排列成一个圆圈，玩家从门 1 前面开始。每回合，玩家可以选择一个数字 i 并支付一个代价 C_i 向右移动 i 步，然后打开该位置的门。保证 C_i >= C_{i+1} 对于 1 <= i < n。  \n任务是确定打开所有门所需的最小总成本。\n\n示例：  \n    >>> f_36(3, (1, 1, 1))  \n    3  ", "fr": "Écrire une fonction C `long long f_36(int n, int *C)` pour résoudre le problème suivant :\nÉtant donné n portes disposées en cercle, le joueur commence devant la porte 1. À chaque tour, le joueur peut choisir un nombre i et payer un coût C_i pour avancer de i pas vers la droite puis ouvrir la porte à cette position. Il est garanti que C_i >= C_{i+1} pour 1 <= i < n.  \nLa tâche consiste à déterminer le coût total minimum nécessaire pour ouvrir toutes les portes.\n\nExemple :\n    >>> f_36(3, (1, 1, 1))\n    3", "de": "Schreiben Sie eine C-Funktion `long long f_36(int n, int *C)`, um das folgende Problem zu lösen:\nGegeben sind n Türen, die in einem Kreis angeordnet sind, und der Spieler beginnt vor Tür 1. In jedem Zug kann der Spieler eine Zahl i wählen und die Kosten C_i zahlen, um i Schritte nach rechts zu gehen und dann die Tür an dieser Position zu öffnen. Es ist garantiert, dass C_i >= C_{i+1} für 1 <= i < n.\nDie Aufgabe besteht darin, die minimalen Gesamtkosten zu bestimmen, die erforderlich sind, um alle Türen zu öffnen.\n\nBeispiel:\n    >>> f_36(3, (1, 1, 1))\n    3", "ha": "Rubuta aikin C `long long f_36(int n, int *C)` don warware matsalar mai zuwa:\nAn ba da ƙofofi n waɗanda aka shirya a cikin madauwari, ɗan wasa yana farawa a gaban ƙofa ta 1. Kowanne juyi, ɗan wasa zai iya zaɓar lamba i kuma ya biya kuɗin C_i don matsawa matakai i zuwa dama sannan ya buɗe ƙofar a wannan matsayi. An tabbatar da cewa C_i >= C_{i+1} don 1 <= i < n.\nAikin shi ne ƙayyade mafi ƙarancin jimillar kuɗin da ake buƙata don buɗe duk ƙofofi.\n\nMisali:\n    >>> f_36(3, (1, 1, 1))\n    3", "hi": "C फ़ंक्शन `long long f_36(int n, int *C)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए n दरवाजे जो एक वृत्त में व्यवस्थित हैं, खिलाड़ी दरवाजा 1 के सामने से शुरू करता है। प्रत्येक चाल में, खिलाड़ी एक संख्या i चुन सकता है और उस स्थिति पर दरवाजा खोलने के लिए i कदम दाईं ओर जाने के लिए लागत C_i का भुगतान कर सकता है। यह गारंटी है कि C_i >= C_{i+1} जहाँ 1 <= i < n।\nकार्य यह निर्धारित करना है कि सभी दरवाजे खोलने के लिए न्यूनतम कुल लागत क्या होगी।\n\nउदाहरण:\n    >>> f_36(3, (1, 1, 1))\n    3", "hu": "Írj egy C függvényt `long long f_36(int n, int *C)` a következő probléma megoldására:\nAdott n ajtó, amelyek körben vannak elrendezve, a játékos az 1-es ajtó előtt kezd. Minden körben a játékos választhat egy i számot, és kifizethet egy C_i költséget, hogy i lépést tegyen jobbra, majd kinyissa az adott pozíción lévő ajtót. Garantált, hogy C_i >= C_{i+1} minden 1 <= i < n esetén.\nA feladat az, hogy meghatározzuk a minimális összköltséget, amely szükséges az összes ajtó kinyitásához.\n\nPélda:\n    >>> f_36(3, (1, 1, 1))\n    3", "es": "Escribe una función en C `long long f_36(int n, int *C)` para resolver el siguiente problema:\nDadas n puertas dispuestas en un círculo, el jugador comienza frente a la puerta 1. En cada turno, el jugador puede elegir un número i y pagar un costo C_i para moverse i pasos a la derecha y luego abrir la puerta en esa posición. Se garantiza que C_i >= C_{i+1} para 1 <= i < n.\nLa tarea es determinar el costo total mínimo requerido para abrir todas las puertas.\n\nEjemplo:\n    >>> f_36(3, (1, 1, 1))\n    3", "arb": "اكتب دالة بلغة C `long long f_36(int n, int *C)` لحل المشكلة التالية:\nمعطى n من الأبواب مرتبة في دائرة، يبدأ اللاعب أمام الباب 1. في كل دور، يمكن للاعب اختيار رقم i ودفع تكلفة C_i للتحرك i خطوات إلى اليمين ثم فتح الباب في ذلك الموقع. يُضمن أن C_i >= C_{i+1} لـ 1 <= i < n.\nالمهمة هي تحديد الحد الأدنى من التكلفة الإجمالية المطلوبة لفتح جميع الأبواب.\n\nمثال:\n    >>> f_36(3, (1, 1, 1))\n    3", "sw": "Andika kazi ya C `long long f_36(int n, int *C)` kutatua tatizo lifuatalo:\nUkipiwa milango n iliyopangwa katika mduara, mchezaji anaanza mbele ya mlango wa 1. Kila zamu, mchezaji anaweza kuchagua namba i na kulipa gharama C_i ili kusonga hatua i kwenda kulia na kisha kufungua mlango katika nafasi hiyo. Imethibitishwa kuwa C_i >= C_{i+1} kwa 1 <= i < n.\nKazi ni kuamua gharama ndogo kabisa inayohitajika kufungua milango yote.\n\nMfano:\n    >>> f_36(3, (1, 1, 1))\n    3", "tr": "Bir C fonksiyonu `long long f_36(int n, int *C)` yazın ve aşağıdaki problemi çözün:\nBir çember şeklinde düzenlenmiş n kapısı verildiğinde, oyuncu kapı 1'in önünde başlar. Her turda, oyuncu bir sayı i seçebilir ve i adım sağa hareket etmek ve ardından o konumdaki kapıyı açmak için bir maliyet C_i ödeyebilir. C_i >= C_{i+1} olduğu garanti edilmektedir, 1 <= i < n için.\nGörev, tüm kapıları açmak için gereken minimum toplam maliyeti belirlemektir.\n\nÖrnek:\n    >>> f_36(3, (1, 1, 1))\n    3", "vi": "Viết một hàm C `long long f_36(int n, int *C)` để giải quyết vấn đề sau:\nCho n cánh cửa được sắp xếp thành một vòng tròn, người chơi bắt đầu trước cửa số 1. Mỗi lượt, người chơi có thể chọn một số i và trả một chi phí C_i để di chuyển i bước sang phải và sau đó mở cánh cửa tại vị trí đó. Đảm bảo rằng C_i >= C_{i+1} cho 1 <= i < n.\nNhiệm vụ là xác định tổng chi phí tối thiểu cần thiết để mở tất cả các cửa.\n\nVí dụ:\n    >>> f_36(3, (1, 1, 1))\n    3", "id": "Tulis sebuah fungsi C `long long f_36(int n, int *C)` untuk menyelesaikan masalah berikut:\nDiberikan n pintu yang disusun dalam lingkaran, pemain memulai di depan pintu 1. Setiap giliran, pemain dapat memilih sebuah angka i dan membayar biaya C_i untuk bergerak i langkah ke kanan dan kemudian membuka pintu pada posisi tersebut. Dijamin bahwa C_i >= C_{i+1} untuk 1 <= i < n.\nTugasnya adalah menentukan biaya total minimum yang diperlukan untuk membuka semua pintu.\n\nContoh:\n    >>> f_36(3, (1, 1, 1))\n    3\n", "ja": "Cの関数を書け `long long f_36(int n, int *C)` を作成して、次の問題を解決してください:\nn 個のドアが円形に配置されており、プレイヤーはドア1の前からスタートします。各ターンで、プレイヤーは数iを選び、コストC_iを支払って右にiステップ移動し、その位置のドアを開けることができます。C_i >= C_{i+1} が 1 <= i < n の範囲で保証されています。\nすべてのドアを開けるために必要な最小の総コストを求めることが課題です。\n\n例:\n    >>> f_36(3, (1, 1, 1))\n    3", "ko": "C 함수 `long long f_36(int n, int *C)`를 작성하여 다음 문제를 해결하십시오:\nn개의 문이 원형으로 배열되어 있을 때, 플레이어는 문 1 앞에서 시작합니다. 각 턴마다 플레이어는 숫자 i를 선택하고 비용 C_i를 지불하여 오른쪽으로 i 걸음 이동한 후 해당 위치의 문을 엽니다. C_i >= C_{i+1}이 1 <= i < n에 대해 보장됩니다.\n모든 문을 여는 데 필요한 최소 총 비용을 결정하는 것이 과제입니다.\n\n예시:\n    >>> f_36(3, (1, 1, 1))\n    3", "ml": "ഒരു C ഫംഗ്ഷൻ എഴുതുക `long long f_36(int n, int *C)` ഈ പ്രശ്നം പരിഹരിക്കാൻ:\nn വാതിലുകൾ ഒരു വൃത്തത്തിൽ ക്രമീകരിച്ചിരിക്കുന്നു, കളിക്കാരൻ വാതിൽ 1-ന്റെ മുന്നിൽ നിന്ന് ആരംഭിക്കുന്നു. ഓരോ തവണയും, കളിക്കാരൻ ഒരു സംഖ്യ i തിരഞ്ഞെടുക്കുകയും i ഘട്ടങ്ങൾ വലത്തേക്ക് നീങ്ങി ആ സ്ഥാനത്തുള്ള വാതിൽ തുറക്കാൻ C_i ചെലവ് നൽകുകയും ചെയ്യാം. 1 <= i < n എന്നതിനായി C_i >= C_{i+1} എന്ന് ഉറപ്പാണ്.\nഎല്ലാ വാതിലുകളും തുറക്കാൻ ആവശ്യമായ കുറഞ്ഞ മൊത്തം ചെലവ് നിർണയിക്കേണ്ടതാണ്.\n\nഉദാഹരണം:\n    >>> f_36(3, (1, 1, 1))\n    3", "fa": "یک تابع C به نام `long long f_36(int n, int *C)` بنویسید تا مسئله‌ی زیر را حل کند:\nبا توجه به n در که به صورت دایره‌ای چیده شده‌اند، بازیکن در مقابل در شماره 1 شروع می‌کند. در هر نوبت، بازیکن می‌تواند یک عدد i انتخاب کند و هزینه C_i را بپردازد تا i قدم به سمت راست حرکت کند و سپس در آن موقعیت در را باز کند. تضمین شده است که C_i >= C_{i+1} برای 1 <= i < n.\nوظیفه این است که حداقل هزینه کل مورد نیاز برای باز کردن همه درها را تعیین کنید.\n\nمثال:\n    >>> f_36(3, (1, 1, 1))\n    3"}, "level": "easy", "test": "int main() {\n    int costs1[] = {4, 3, 3, 3, 3}; // 1-indexed array\n    assert(f_36(5, costs1) == 15);\n\n    int costs2[] = {1, 1, 1};\n    assert(f_36(3, costs2) == 3);\n\n    int costs3[] = {5, 4, 3, 2};\n    assert(f_36(4, costs3) == 11);\n\n    int costs4[] = {100, 99, 98, 97};\n    assert(f_36(4, costs4) == 391);\n\n    int costs5[] = {10, 9, 8, 7, 6, 5};\n    assert(f_36(6, costs5) == 35);\n\n    int costs6[] = {2, 2, 2, 2, 2, 2, 2};\n    assert(f_36(7, costs6) == 14);\n\n    int costs7[] = {9, 7, 7, 7, 7, 7, 7, 7};\n    assert(f_36(8, costs7) == 56);\n\n    int costs8[] = {3, 2, 2, 2, 2, 2, 2, 2, 2};\n    assert(f_36(9, costs8) == 18);\n\n    int costs9[] = {6, 5, 5, 5, 5, 5, 5, 5, 5, 5};\n    assert(f_36(10, costs9) == 50);\n\n    int costs10[] = {8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};\n    assert(f_36(11, costs10) == 11);\n\n    return 0;\n}", "entry_point": "f_36", "signature": "long long f_36(int n, int *C)", "docstring": {"en": "Given n doors arranged in a circle, the player starts in front of door 1. Each turn, the player can choose a number i and pay a cost C_i to move i steps to the right and then open the door at that position. It is guaranteed that C_i >= C_{i+1} for 1 <= i < n.\nThe task is to determine the minimum total cost required to open all doors.\n\nExample:\n    >>> f_36(3, (1, 1, 1))\n    3\n", "sq": "Duke pasur parasysh n dyer të vendosura në një rreth, lojtari fillon përpara derës 1. Çdo herë, lojtari mund të zgjedhë një numër i dhe të paguajë një kosto C_i për të lëvizur i hapa djathtas dhe pastaj të hapë derën në atë pozicion. Është e garantuar që C_i >= C_{i+1} për 1 <= i < n. Detyra është të përcaktohet kostoja totale minimale e nevojshme për të hapur të gjitha dyert.\n\nShembull:\n    >>> f_36(3, (1, 1, 1))\n    3", "hy": "Տրված են n դռներ, որոնք դասավորված են շրջանաձև, խաղացողը սկսում է դուռ 1-ի դիմաց: Յուրաքանչյուր քայլի, խաղացողը կարող է ընտրել թիվ i և վճարել արժեք C_i՝ i քայլ աջ շարժվելու և այդ դիրքում գտնվող դուռը բացելու համար: Երաշխավորված է, որ C_i >= C_{i+1} 1 <= i < n-ի համար:\nԽնդիրը կայանում է բոլոր դռները բացելու համար պահանջվող նվազագույն ընդհանուր արժեքը որոշելու մեջ:\n\nՕրինակ:\n    >>> f_36(3, (1, 1, 1))\n    3", "bn": "nটি দরজা একটি বৃত্তে সাজানো আছে, খেলোয়াড় দরজা 1 এর সামনে থেকে শুরু করে। প্রতিটি পালায়, খেলোয়াড় একটি সংখ্যা i বেছে নিতে পারে এবং i ধাপ ডান দিকে যেতে এবং তারপর সেই অবস্থানের দরজা খুলতে C_i খরচ দিতে হয়। এটি নিশ্চিত যে C_i >= C_{i+1} যেখানে 1 <= i < n। \nকাজটি হল সমস্ত দরজা খোলার জন্য প্রয়োজনীয় সর্বনিম্ন মোট খরচ নির্ধারণ করা।\n\nউদাহরণ:\n    >>> f_36(3, (1, 1, 1))\n    3", "bg": "Дадени са n врати, подредени в кръг, играчът започва пред врата 1. На всеки ход играчът може да избере число i и да плати цена C_i, за да се премести i стъпки надясно и след това да отвори вратата на тази позиция. Гарантирано е, че C_i >= C_{i+1} за 1 <= i < n. Задачата е да се определи минималната обща цена, необходима за отваряне на всички врати.\n\nПример:\n    >>> f_36(3, (1, 1, 1))\n    3", "zh": "给定 n 个按圆形排列的门，玩家从门 1 前开始。每一回合，玩家可以选择一个数字 i，并支付一个代价 C_i 向右移动 i 步，然后打开该位置的门。保证 C_i >= C_{i+1} 对于 1 <= i < n。\n任务是确定打开所有门所需的最小总成本。\n\n示例：\n    >>> f_36(3, (1, 1, 1))\n    3", "fr": "Étant donné n portes disposées en cercle, le joueur commence devant la porte 1. À chaque tour, le joueur peut choisir un nombre i et payer un coût C_i pour avancer de i pas vers la droite, puis ouvrir la porte à cette position. Il est garanti que C_i >= C_{i+1} pour 1 <= i < n.  \nLa tâche consiste à déterminer le coût total minimum nécessaire pour ouvrir toutes les portes.\n\nExemple :\n    >>> f_36(3, (1, 1, 1))\n    3", "de": "Gegeben n Türen, die in einem Kreis angeordnet sind, beginnt der Spieler vor Tür 1. Bei jedem Zug kann der Spieler eine Zahl i wählen und die Kosten C_i bezahlen, um i Schritte nach rechts zu gehen und dann die Tür an dieser Position zu öffnen. Es ist garantiert, dass C_i >= C_{i+1} für 1 <= i < n.\n\nDie Aufgabe besteht darin, die minimalen Gesamtkosten zu bestimmen, die erforderlich sind, um alle Türen zu öffnen.\n\nBeispiel:\n    >>> f_36(3, (1, 1, 1))\n    3", "ha": "An ba da ƙofofi n da aka shirya a cikin madauwari, mai kunnawa yana farawa a gaban ƙofa ta 1. Kowanne juyi, mai kunnawa zai iya zaɓar lamba i kuma ya biya farashi C_i don matsawa matakai i zuwa dama sannan ya buɗe ƙofar a wannan matsayi. An tabbatar da cewa C_i >= C_{i+1} don 1 <= i < n. Aikin shi ne ƙayyade mafi ƙarancin jimlar kuɗin da ake buƙata don buɗe duk ƙofofi.\n\nMisali:\n    >>> f_36(3, (1, 1, 1))\n    3", "hi": "n दरवाजों को एक वृत्त में व्यवस्थित किया गया है, खिलाड़ी दरवाजा 1 के सामने से शुरू करता है। प्रत्येक चाल में, खिलाड़ी एक संख्या i चुन सकता है और i कदम दाईं ओर जाने के लिए लागत C_i का भुगतान कर सकता है और फिर उस स्थिति पर दरवाजा खोल सकता है। यह सुनिश्चित किया गया है कि C_i >= C_{i+1} जहाँ 1 <= i < n।  \nकार्य यह निर्धारित करना है कि सभी दरवाजे खोलने के लिए न्यूनतम कुल लागत क्या होगी।\n\nउदाहरण:\n    >>> f_36(3, (1, 1, 1))\n    3", "hu": "Adott n ajtó, amelyek körben vannak elrendezve, a játékos az 1-es ajtó előtt kezd. Minden körben a játékos választhat egy i számot, és kifizet egy C_i költséget, hogy i lépést jobbra lépjen, majd kinyissa az adott pozíción lévő ajtót. Garantált, hogy C_i >= C_{i+1} minden 1 <= i < n esetén. A feladat az, hogy meghatározzuk az összes ajtó kinyitásához szükséges minimális összköltséget.\n\nPélda:\n    >>> f_36(3, (1, 1, 1))\n    3", "es": "Dado n puertas dispuestas en un círculo, el jugador comienza frente a la puerta 1. En cada turno, el jugador puede elegir un número i y pagar un costo C_i para moverse i pasos a la derecha y luego abrir la puerta en esa posición. Se garantiza que C_i >= C_{i+1} para 1 <= i < n.  \nLa tarea es determinar el costo total mínimo requerido para abrir todas las puertas.\n\nEjemplo:\n    >>> f_36(3, (1, 1, 1))\n    3", "arb": "معطى n أبواب مرتبة في دائرة، يبدأ اللاعب أمام الباب 1. في كل دور، يمكن للاعب اختيار رقم i ودفع تكلفة C_i للتحرك i خطوات إلى اليمين ثم فتح الباب في ذلك الموقع. من المضمون أن C_i >= C_{i+1} لـ 1 <= i < n. المهمة هي تحديد الحد الأدنى للتكلفة الإجمالية المطلوبة لفتح جميع الأبواب.\n\nمثال:\n    >>> f_36(3, (1, 1, 1))\n    3", "sw": "Kwa kuzingatia milango n iliyopangwa katika mduara, mchezaji huanza mbele ya mlango wa 1. Kila zamu, mchezaji anaweza kuchagua namba i na kulipa gharama C_i ili kusogea hatua i kwenda kulia na kisha kufungua mlango katika nafasi hiyo. Inahakikishwa kuwa C_i >= C_{i+1} kwa 1 <= i < n. Kazi ni kubaini gharama ndogo kabisa inayohitajika kufungua milango yote.\n\nMfano:\n    >>> f_36(3, (1, 1, 1))\n    3", "tr": "Verilen n kapı bir çember şeklinde düzenlenmiştir, oyuncu 1 numaralı kapının önünde başlar. Her turda, oyuncu bir sayı i seçebilir ve i adım sağa hareket etmek ve ardından o konumdaki kapıyı açmak için bir maliyet C_i öder. C_i >= C_{i+1} olduğu garanti edilir, 1 <= i < n için.\nGörev, tüm kapıları açmak için gereken minimum toplam maliyeti belirlemektir.\n\nÖrnek:\n    >>> f_36(3, (1, 1, 1))\n    3", "vi": "Cho n cánh cửa được sắp xếp thành vòng tròn, người chơi bắt đầu trước cửa số 1. Mỗi lượt, người chơi có thể chọn một số i và trả một chi phí C_i để di chuyển i bước sang phải và sau đó mở cánh cửa tại vị trí đó. Đảm bảo rằng C_i >= C_{i+1} cho 1 <= i < n. Nhiệm vụ là xác định tổng chi phí tối thiểu cần thiết để mở tất cả các cửa.\n\nVí dụ:\n    >>> f_36(3, (1, 1, 1))\n    3", "id": "Diberikan n pintu yang disusun dalam lingkaran, pemain mulai di depan pintu 1. Setiap giliran, pemain dapat memilih angka i dan membayar biaya C_i untuk bergerak i langkah ke kanan dan kemudian membuka pintu di posisi tersebut. Dijamin bahwa C_i >= C_{i+1} untuk 1 <= i < n. Tugasnya adalah menentukan total biaya minimum yang diperlukan untuk membuka semua pintu.\n\nContoh:\n    >>> f_36(3, (1, 1, 1))\n    3\n", "ja": "与えられたn個のドアが円形に配置されており、プレイヤーはドア1の前に立っています。各ターンで、プレイヤーは数iを選び、コストC_iを支払って右にiステップ移動し、その位置のドアを開けることができます。C_i >= C_{i+1}が1 <= i < nの範囲で保証されています。\nすべてのドアを開けるために必要な最小の総コストを求めることが課題です。\n\n例:\n    >>> f_36(3, (1, 1, 1))\n    3", "ko": "n개의 문이 원형으로 배열되어 있을 때, 플레이어는 문 1 앞에서 시작합니다. 각 턴마다 플레이어는 숫자 i를 선택하고 비용 C_i를 지불하여 오른쪽으로 i단계 이동한 후 해당 위치의 문을 엽니다. C_i >= C_{i+1}이 1 <= i < n에 대해 보장됩니다. 모든 문을 여는 데 필요한 최소 총 비용을 결정하는 것이 과제입니다.\n\n예시:\n    >>> f_36(3, (1, 1, 1))\n    3", "ml": "n വാതിലുകൾ ഒരു വൃത്തത്തിൽ ക്രമീകരിച്ചിരിക്കുന്നപ്പോൾ, കളിക്കാരൻ വാതിൽ 1-ന്റെ മുൻപിൽ നിന്ന് തുടങ്ങുന്നു. ഓരോ തവണയും, കളിക്കാരൻ ഒരു സംഖ്യ i തിരഞ്ഞെടുക്കുകയും i വലത്തേക്ക് ചുവടുകൾ നീക്കാൻ C_i ചെലവ് നൽകുകയും ആ സ്ഥാനത്തെ വാതിൽ തുറക്കുകയും ചെയ്യാം. 1 <= i < n എന്നതിനായി C_i >= C_{i+1} എന്ന് ഉറപ്പാക്കുന്നു.  \nThe task is to determine the minimum total cost required to open all doors.  \nഎല്ലാ വാതിലുകളും തുറക്കാൻ ആവശ്യമായ കുറഞ്ഞ മൊത്തം ചെലവ് നിർണയിക്കുകയാണ് ഈ പ്രവർത്തനം.  \n\nExample:  \nഉദാഹരണം:  \n    >>> f_36(3, (1, 1, 1))  \n    3  ", "fa": "با توجه به n درب که به صورت دایره‌ای چیده شده‌اند، بازیکن در مقابل درب 1 شروع می‌کند. در هر نوبت، بازیکن می‌تواند یک عدد i انتخاب کند و هزینه C_i را بپردازد تا i قدم به سمت راست حرکت کند و سپس درب در آن موقعیت را باز کند. تضمین شده است که C_i >= C_{i+1} برای 1 <= i < n.\n\nوظیفه این است که حداقل هزینه کل مورد نیاز برای باز کردن همه درها را تعیین کنید.\n\nمثال:\n    >>> f_36(3, (1, 1, 1))\n    3"}}
{"task_id": "C/37", "prompt": {"en": "#include <assert.h>\n#include <stdio.h>\n/*\nGiven a sequence of student IDs entering a classroom, where the IDs range from 0 to N-1, calculate the total number of handshakes that occur. Each student will shake hands with every student already in the classroom with a smaller ID number. The sequence represents the order in which students enter the classroom.\n\nExamples:\n    >>> f_37(3, (2, 1, 0))\n    0\n*/\nlong long f_37(int n, int order[])", "sq": "#include <assert.h>\n#include <stdio.h>\n/*\nDuke pasur një sekuencë të ID-ve të studentëve që hyjnë në një klasë, ku ID-të variojnë nga 0 deri në N-1, llogaritni numrin total të shtrëngimeve të duarve që ndodhin. Çdo student do të shtrëngojë duart me çdo student që tashmë është në klasë me një numër ID më të vogël. Sekuenca përfaqëson rendin në të cilin studentët hyjnë në klasë.\n\nShembuj:\n    >>> f_37(3, (2, 1, 0))\n    0\n*/\nlong long f_37(int n, int order[])", "hy": "#include <assert.h>\n#include <stdio.h>\n/*\nՈւնենալով ուսանողների ID-ների հաջորդականություն, որոնք մտնում են դասարան, որտեղ ID-ները տատանվում են 0-ից մինչև N-1, հաշվարկեք ձեռքսեղմումների ընդհանուր քանակը։ Յուրաքանչյուր ուսանող ձեռք կսեղմի դասարանում արդեն գտնվող յուրաքանչյուր ուսանողի հետ, ում ID-ն ավելի փոքր է։ Հաջորդականությունը ներկայացնում է այն կարգը, որով ուսանողները մտնում են դասարան։\n\nՕրինակներ:\n    >>> f_37(3, (2, 1, 0))\n    0\n*/\nlong long f_37(int n, int order[])", "bn": "#include <assert.h>\n#include <stdio.h>\n/*\nশ্রেণীকক্ষে প্রবেশ করা ছাত্রদের আইডির একটি ক্রম দেওয়া হয়েছে, যেখানে আইডিগুলি 0 থেকে N-1 পর্যন্ত বিস্তৃত, মোট কতগুলি হ্যান্ডশেক হয় তা গণনা করুন। প্রতিটি ছাত্র ইতিমধ্যে শ্রেণীকক্ষে থাকা প্রতিটি ছাত্রের সাথে হ্যান্ডশেক করবে যার আইডি নম্বর ছোট। ক্রমটি ছাত্ররা শ্রেণীকক্ষে প্রবেশ করার ক্রমকে উপস্থাপন করে।\n\nউদাহরণ:\n    >>> f_37(3, (2, 1, 0))\n    0\n*/\nlong long f_37(int n, int order[])", "bg": "#include <assert.h>\n#include <stdio.h>\n/*\nДадена е последователност от студентски ID-та, влизащи в класната стая, където ID-тата варират от 0 до N-1, изчислете общия брой ръкостискания, които се случват. Всеки студент ще се ръкува с всеки студент, който вече е в класната стая с по-малък ID номер. Последователността представлява реда, в който студентите влизат в класната стая.\n\nПримери:\n    >>> f_37(3, (2, 1, 0))\n    0\n*/\nlong long f_37(int n, int order[])", "zh": "#include <assert.h>\n#include <stdio.h>\n/*\n给定一个进入教室的学生ID序列，其中ID范围从0到N-1，计算发生的握手总数。每个学生将与教室中ID号较小的每个学生握手。序列表示学生进入教室的顺序。\n\n例子:\n    >>> f_37(3, (2, 1, 0))\n    0\n*/\nlong long f_37(int n, int order[])", "fr": "#include <assert.h>\n#include <stdio.h>\n/*\nÉtant donné une séquence d'IDs d'étudiants entrant dans une salle de classe, où les IDs vont de 0 à N-1, calculez le nombre total de poignées de main qui se produisent. Chaque étudiant serrera la main de chaque étudiant déjà dans la salle de classe avec un numéro d'ID plus petit. La séquence représente l'ordre dans lequel les étudiants entrent dans la salle de classe.\n\nExemples :\n    >>> f_37(3, (2, 1, 0))\n    0\n*/\nlong long f_37(int n, int order[])", "de": "#include <assert.h>\n#include <stdio.h>\n/*\nGegeben eine Sequenz von Studenten-IDs, die einen Klassenraum betreten, wobei die IDs von 0 bis N-1 reichen, berechne die Gesamtanzahl der stattfindenden Händeschütteln. Jeder Student wird jedem Studenten, der sich bereits im Klassenraum befindet und eine kleinere ID-Nummer hat, die Hand schütteln. Die Sequenz repräsentiert die Reihenfolge, in der die Studenten den Klassenraum betreten.\n\nBeispiele:\n    >>> f_37(3, (2, 1, 0))\n    0\n*/\nlong long f_37(int n, int order[])", "ha": "#include <assert.h>\n#include <stdio.h>\n/*\nAn ba da jerin lambobin ID na ɗalibai masu shiga aji, inda lambobin ID ke tsakanin 0 zuwa N-1, a lissafta jimillar yawan musabaha da ke faruwa. Kowane ɗalibi zai yi musabaha da kowane ɗalibi da ke cikin aji wanda ke da ƙaramin lamba ID. Jerin yana wakiltar tsarin da ɗalibai ke shiga aji.\n\nMisalai:\n    >>> f_37(3, (2, 1, 0))\n    0\n*/\nlong long f_37(int n, int order[])", "hi": "#include <assert.h>\n#include <stdio.h>\n/*\nछात्र आईडी की एक अनुक्रम को देखते हुए जो एक कक्षा में प्रवेश कर रहे हैं, जहाँ आईडी 0 से N-1 तक होती हैं, कुल हैंडशेक की संख्या की गणना करें जो होती है। प्रत्येक छात्र हर उस छात्र से हाथ मिलाएगा जो पहले से ही कक्षा में है और जिसका आईडी नंबर छोटा है। अनुक्रम उस क्रम का प्रतिनिधित्व करता है जिसमें छात्र कक्षा में प्रवेश करते हैं।\n\nउदाहरण:\n    >>> f_37(3, (2, 1, 0))\n    0\n*/\nlong long f_37(int n, int order[])", "hu": "#include <assert.h>\n#include <stdio.h>\n/*\nEgy osztályterembe belépő diákok azonosítóinak sorozata alapján, ahol az azonosítók 0-tól N-1-ig terjednek, számítsd ki a kézfogások összes számát. Minden diák kezet fog minden már a teremben lévő diákkal, akinek kisebb az azonosító száma. A sorozat azt a sorrendet képviseli, amelyben a diákok belépnek a terembe.\n\nPéldák:\n    >>> f_37(3, (2, 1, 0))\n    0\n*/\nlong long f_37(int n, int order[])", "es": "#include <assert.h>\n#include <stdio.h>\n/*\nDada una secuencia de IDs de estudiantes que entran a un aula, donde los IDs van de 0 a N-1, calcula el número total de apretones de manos que ocurren. Cada estudiante dará la mano a cada estudiante que ya esté en el aula con un número de ID menor. La secuencia representa el orden en que los estudiantes entran al aula.\n\nEjemplos:\n    >>> f_37(3, (2, 1, 0))\n    0\n*/\nlong long f_37(int n, int order[])", "arb": "#include <assert.h>\n#include <stdio.h>\n/*\nبالنظر إلى تسلسل معرفات الطلاب الذين يدخلون الفصل الدراسي، حيث تتراوح المعرفات من 0 إلى N-1، احسب العدد الإجمالي للمصافحات التي تحدث. كل طالب سيصافح كل طالب موجود بالفعل في الفصل بمعرف أصغر. يمثل التسلسل ترتيب دخول الطلاب إلى الفصل.\n\nأمثلة:\n    >>> f_37(3, (2, 1, 0))\n    0\n*/\nlong long f_37(int n, int order[])", "sw": "#include <assert.h>\n#include <stdio.h>\n/*\nUkitolewa mlolongo wa nambari za wanafunzi wanaoingia darasani, ambapo nambari hizo ni kati ya 0 hadi N-1, hesabu jumla ya mikono iliyoshikwa. Kila mwanafunzi atashikana mikono na kila mwanafunzi aliyeko darasani tayari mwenye nambari ndogo. Mlolongo unawakilisha mpangilio ambao wanafunzi wanaingia darasani.\n\nMifano:\n    >>> f_37(3, (2, 1, 0))\n    0\n*/\nlong long f_37(int n, int order[])", "tr": "#include <assert.h>\n#include <stdio.h>\n/*\nBir sınıfa giren öğrenci kimliklerinin bir dizisi verildiğinde, kimliklerin 0'dan N-1'e kadar değiştiği varsayılır, gerçekleşen toplam tokalaşma sayısını hesaplayın. Her öğrenci, sınıfta zaten bulunan ve daha küçük bir kimlik numarasına sahip olan her öğrenciyle tokalaşacaktır. Dizi, öğrencilerin sınıfa giriş sırasını temsil eder.\n\nÖrnekler:\n    >>> f_37(3, (2, 1, 0))\n    0\n*/\nlong long f_37(int n, int order[])", "vi": "#include <assert.h>\n#include <stdio.h>\n/*\nCho một dãy số ID của học sinh khi vào lớp học, trong đó các ID có giá trị từ 0 đến N-1, tính tổng số lần bắt tay xảy ra. Mỗi học sinh sẽ bắt tay với mọi học sinh đã có mặt trong lớp với số ID nhỏ hơn. Dãy số đại diện cho thứ tự mà học sinh vào lớp.\n\nVí dụ:\n    >>> f_37(3, (2, 1, 0))\n    0\n*/\nlong long f_37(int n, int order[])", "id": "#include <assert.h>\n#include <stdio.h>\n/*\nDiberikan urutan ID siswa yang memasuki kelas, di mana ID berkisar dari 0 hingga N-1, hitung jumlah total jabat tangan yang terjadi. Setiap siswa akan berjabat tangan dengan setiap siswa yang sudah ada di kelas dengan nomor ID yang lebih kecil. Urutan tersebut mewakili urutan di mana siswa memasuki kelas.\n\nContoh:\n    >>> f_37(3, (2, 1, 0))\n    0\n*/\nlong long f_37(int n, int order[])", "ja": "#include <assert.h>\n#include <stdio.h>\n/*\n教室に入る学生IDのシーケンスが与えられたとき、IDは0からN-1の範囲で、発生する握手の総数を計算します。各学生は、教室にすでにいる自分より小さいID番号を持つすべての学生と握手をします。このシーケンスは、学生が教室に入る順序を表しています。\n\n例:\n    >>> f_37(3, (2, 1, 0))\n    0\n*/\nlong long f_37(int n, int order[])", "ko": "#include <assert.h>\n#include <stdio.h>\n/*\n학생 ID가 교실에 들어오는 순서가 주어졌을 때, ID는 0에서 N-1까지의 범위를 가지며, 발생하는 악수의 총 수를 계산합니다. 각 학생은 이미 교실에 있는 자신보다 작은 ID 번호를 가진 모든 학생과 악수를 합니다. 이 순서는 학생들이 교실에 들어오는 순서를 나타냅니다.\n\n예시:\n    >>> f_37(3, (2, 1, 0))\n    0\n*/\nlong long f_37(int n, int order[])", "ml": "#include <assert.h>\n#include <stdio.h>\n/*\nക്ലാസ്‌റൂമിലേക്ക് പ്രവേശിക്കുന്ന വിദ്യാർത്ഥികളുടെ ഐഡി ക്രമം നൽകിയിരിക്കുന്നു, ഇവിടെ ഐഡികൾ 0 മുതൽ N-1 വരെയാണ്, ഉണ്ടാകുന്ന ആകെ കൈകുലുക്കങ്ങളുടെ എണ്ണം കണക്കാക്കുക. ഓരോ വിദ്യാർത്ഥിയും, ക്ലാസ്‌റൂമിൽ ഇതിനകം പ്രവേശിച്ച, തനിക്കു കിഴിവായ ഐഡി നമ്പർ ഉള്ള എല്ലാ വിദ്യാർത്ഥികളുമായും കൈകുലുക്കം നടത്തും. ഈ ക്രമം വിദ്യാർത്ഥികൾ ക്ലാസ്‌റൂമിലേക്ക് പ്രവേശിക്കുന്ന ക്രമം പ്രതിനിധീകരിക്കുന്നു.\n\nഉദാഹരണങ്ങൾ:\n    >>> f_37(3, (2, 1, 0))\n    0\n*/\nlong long f_37(int n, int order[])", "fa": "#include <assert.h>\n#include <stdio.h>\n/*\nبا توجه به دنباله‌ای از شناسه‌های دانش‌آموزانی که وارد کلاس می‌شوند، که شناسه‌ها از 0 تا N-1 هستند، تعداد کل دست دادن‌هایی که اتفاق می‌افتد را محاسبه کنید. هر دانش‌آموز با هر دانش‌آموزی که قبلاً با شناسه کوچکتر در کلاس حضور دارد، دست می‌دهد. دنباله نشان‌دهنده ترتیب ورود دانش‌آموزان به کلاس است.\n\nمثال‌ها:\n    >>> f_37(3, (2, 1, 0))\n    0\n*/\nlong long f_37(int n, int order[])"}, "canonical_solution": "{\n    long long ans = 0;\n    int tr[10000] = {0}; // N should be defined as a constant representing the maximum possible value of n\n    for (int i = 0; i < 10000; ++i) {\n        tr[i] = 0;\n    }\n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n    return ans;\n}", "instruction": {"en": "Write a C function `long long f_37(int n, int order[])` to solve the following problem:\nGiven a sequence of student IDs entering a classroom, where the IDs range from 0 to N-1, calculate the total number of handshakes that occur. Each student will shake hands with every student already in the classroom with a smaller ID number. The sequence represents the order in which students enter the classroom.\n\nExamples:\n    >>> f_37(3, (2, 1, 0))\n    0\n", "sq": "Shkruani një funksion C `long long f_37(int n, int order[])` për të zgjidhur problemin e mëposhtëm:\nDuke pasur një sekuencë të ID-ve të studentëve që hyjnë në një klasë, ku ID-të variojnë nga 0 deri në N-1, llogaritni numrin total të shtrëngimeve të duarve që ndodhin. Çdo student do të shtrëngojë duart me çdo student që tashmë është në klasë me një numër më të vogël ID-je. Sekuenca përfaqëson rendin në të cilin studentët hyjnë në klasë.\n\nShembuj:\n    >>> f_37(3, (2, 1, 0))\n    0", "hy": "Գրեք C ֆունկցիա `long long f_37(int n, int order[])`՝ լուծելու համար հետևյալ խնդիրը:\nՈւնենալով ուսանողների ID-ների հաջորդականություն, որոնք մտնում են դասասենյակ, որտեղ ID-ները տատանվում են 0-ից մինչև N-1, հաշվեք ընդհանուր ձեռքսեղմումների քանակը։ Յուրաքանչյուր ուսանող ձեռք կսեղմի դասասենյակում արդեն եղած յուրաքանչյուր ուսանողի հետ, որի ID-ն ավելի փոքր է։ Հաջորդականությունը ներկայացնում է ուսանողների դասասենյակ մտնելու կարգը։\n\nՕրինակներ:\n    >>> f_37(3, (2, 1, 0))\n    0", "bn": "একটি C ফাংশন `long long f_37(int n, int order[])` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি শ্রেণীকক্ষে প্রবেশ করা ছাত্রদের আইডির একটি ক্রম দেওয়া হয়েছে, যেখানে আইডিগুলি 0 থেকে N-1 পর্যন্ত বিস্তৃত। মোট কতগুলি হ্যান্ডশেক হয় তা গণনা করুন। প্রতিটি ছাত্র তার চেয়ে ছোট আইডি নম্বরের সাথে ইতিমধ্যে শ্রেণীকক্ষে থাকা প্রতিটি ছাত্রের সাথে হ্যান্ডশেক করবে। ক্রমটি শ্রেণীকক্ষে প্রবেশের ক্রমকে উপস্থাপন করে।\n\nউদাহরণ:\n    >>> f_37(3, (2, 1, 0))\n    0", "bg": "Напишете C функция `long long f_37(int n, int order[])`, за да решите следния проблем:\nДадена е последователност от ID на ученици, които влизат в класната стая, където ID-тата варират от 0 до N-1, изчислете общия брой ръкостискания, които се случват. Всеки ученик ще се ръкува с всеки ученик, който вече е в класната стая с по-малък номер на ID. Последователността представлява реда, в който учениците влизат в класната стая.\n\nПримери:\n    >>> f_37(3, (2, 1, 0))\n    0", "zh": "编写一个 C 函数 `long long f_37(int n, int order[])` 来解决以下问题：\n给定一个进入教室的学生 ID 序列，其中 ID 范围从 0 到 N-1，计算发生的握手总数。每个学生将与教室中所有 ID 小于自己的学生握手。该序列表示学生进入教室的顺序。  \n\n示例:  \n    >>> f_37(3, (2, 1, 0))  \n    0  ", "fr": "Écrire une fonction C `long long f_37(int n, int order[])` pour résoudre le problème suivant :\nÉtant donné une séquence d'identifiants d'étudiants entrant dans une salle de classe, où les identifiants vont de 0 à N-1, calculer le nombre total de poignées de main qui ont lieu. Chaque étudiant serrera la main de chaque étudiant déjà dans la salle de classe avec un identifiant plus petit. La séquence représente l'ordre dans lequel les étudiants entrent dans la salle de classe.\n\nExemples :\n    >>> f_37(3, (2, 1, 0))\n    0", "de": "Schreiben Sie eine C-Funktion `long long f_37(int n, int order[])`, um das folgende Problem zu lösen:\nGegeben ist eine Sequenz von Schüler-IDs, die ein Klassenzimmer betreten, wobei die IDs von 0 bis N-1 reichen. Berechnen Sie die Gesamtanzahl der stattfindenden Händedrucke. Jeder Schüler wird mit jedem Schüler, der sich bereits im Klassenzimmer befindet und eine kleinere ID-Nummer hat, die Hand schütteln. Die Sequenz repräsentiert die Reihenfolge, in der die Schüler das Klassenzimmer betreten.\n\nBeispiele:\n    >>> f_37(3, (2, 1, 0))\n    0", "ha": "Rubuta aikin C `long long f_37(int n, int order[])` don warware matsalar mai zuwa:\nAn ba da jerin lambobin ID ɗalibai masu shiga aji, inda lambobin ID ke tsakanin 0 zuwa N-1, ƙididdige jimillar yawan musabaha da ke faruwa. Kowane ɗalibi zai yi musabaha da kowane ɗalibi da ke cikin aji wanda ke da ƙaramin lamba na ID. Jerin yana wakiltar tsarin da ɗalibai ke shiga aji.\n\nMisalai:\n    >>> f_37(3, (2, 1, 0))\n    0", "hi": "C फ़ंक्शन `long long f_37(int n, int order[])` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nछात्र आईडी के अनुक्रम को देखते हुए जो एक कक्षा में प्रवेश कर रहे हैं, जहाँ आईडी 0 से N-1 तक होती हैं, कुल हैंडशेक की संख्या की गणना करें। प्रत्येक छात्र उन सभी छात्रों से हाथ मिलाएगा जो पहले से ही कक्षा में हैं और जिनकी आईडी संख्या छोटी है। अनुक्रम उस क्रम का प्रतिनिधित्व करता है जिसमें छात्र कक्षा में प्रवेश करते हैं।\n\nउदाहरण:\n    >>> f_37(3, (2, 1, 0))\n    0", "hu": "Írj egy C függvényt `long long f_37(int n, int order[])`, hogy megoldja a következő problémát:\nEgy osztályterembe belépő diákok azonosítóinak sorozata adott, ahol az azonosítók 0-tól N-1-ig terjednek. Számold ki a kézfogások összesített számát. Minden diák kezet fog minden már az osztályteremben lévő diákkal, akinek az azonosítója kisebb. A sorozat azt az sorrendet képviseli, amelyben a diákok belépnek az osztályterembe.\n\nPéldák:\n    >>> f_37(3, (2, 1, 0))\n    0", "es": "Escribe una función en C `long long f_37(int n, int order[])` para resolver el siguiente problema:\nDada una secuencia de identificaciones de estudiantes que ingresan a un aula, donde las identificaciones varían de 0 a N-1, calcula el número total de apretones de manos que ocurren. Cada estudiante estrechará la mano con cada estudiante que ya esté en el aula con un número de identificación menor. La secuencia representa el orden en que los estudiantes ingresan al aula.\n\nEjemplos:\n    >>> f_37(3, (2, 1, 0))\n    0", "arb": "اكتب دالة بلغة C `long long f_37(int n, int order[])` لحل المشكلة التالية:\nبالنظر إلى تسلسل معرفات الطلاب الذين يدخلون الفصل، حيث تتراوح المعرفات من 0 إلى N-1، احسب العدد الإجمالي للمصافحات التي تحدث. كل طالب سوف يصافح كل طالب موجود بالفعل في الفصل بمعرف أصغر. يمثل التسلسل الترتيب الذي يدخل فيه الطلاب إلى الفصل.\n\nأمثلة:\n    >>> f_37(3, (2, 1, 0))\n    0", "sw": "Andika kazi ya C `long long f_37(int n, int order[])` kutatua tatizo lifuatalo:\nUkipatiwa mlolongo wa nambari za kitambulisho cha wanafunzi wanaoingia darasani, ambapo nambari za kitambulisho zinatoka 0 hadi N-1, hesabu jumla ya mikono iliyoshikwa. Kila mwanafunzi atashikana mikono na kila mwanafunzi aliyeko darasani tayari mwenye nambari ya kitambulisho ndogo zaidi. Mlolongo unawakilisha mpangilio ambao wanafunzi wanaingia darasani.\n\nMifano:\n    >>> f_37(3, (2, 1, 0))\n    0", "tr": "Bir C fonksiyonu `long long f_37(int n, int order[])` yazın ve aşağıdaki problemi çözün:\nBir sınıfa giren öğrenci kimlik numaralarının bir dizisi verildiğinde, kimlik numaraları 0'dan N-1'e kadar değişmektedir, toplam tokalaşma sayısını hesaplayın. Her öğrenci, sınıfta zaten bulunan ve daha küçük bir kimlik numarasına sahip olan her öğrenciyle tokalaşacaktır. Dizi, öğrencilerin sınıfa giriş sırasını temsil eder.\n\nÖrnekler:\n    >>> f_37(3, (2, 1, 0))\n    0", "vi": "Viết một hàm C `long long f_37(int n, int order[])` để giải quyết vấn đề sau:\nCho một dãy số ID của học sinh khi vào lớp học, trong đó các ID từ 0 đến N-1, tính tổng số cái bắt tay xảy ra. Mỗi học sinh sẽ bắt tay với mọi học sinh đã có mặt trong lớp với số ID nhỏ hơn. Dãy số đại diện cho thứ tự học sinh vào lớp.\n\nVí dụ:  \n    >>> f_37(3, (2, 1, 0))  \n    0  ", "id": "Tulis sebuah fungsi C `long long f_37(int n, int order[])` untuk menyelesaikan masalah berikut:\nDiberikan sebuah urutan ID siswa yang memasuki kelas, di mana ID berkisar dari 0 hingga N-1, hitung jumlah total jabat tangan yang terjadi. Setiap siswa akan berjabat tangan dengan setiap siswa yang sudah ada di kelas dengan nomor ID yang lebih kecil. Urutan tersebut mewakili urutan di mana siswa memasuki kelas.\n\nContoh:\n    >>> f_37(3, (2, 1, 0))\n    0\n", "ja": "Cの関数を書け `long long f_37(int n, int order[])` を作成して、次の問題を解決してください:\n教室に入る学生IDのシーケンスが与えられたとき、IDは0からN-1までの範囲で、発生する握手の総数を計算します。各学生は、教室に既にいる自分より小さいID番号のすべての学生と握手します。このシーケンスは、学生が教室に入る順序を表しています。\n\n例:\n    >>> f_37(3, (2, 1, 0))\n    0", "ko": "C 함수를 작성하세요 `long long f_37(int n, int order[])` 다음 문제를 해결하기 위해:\n학생 ID가 0부터 N-1까지 범위에 있는 교실에 들어오는 순서가 주어졌을 때, 발생하는 총 악수의 수를 계산하세요. 각 학생은 이미 교실에 있는 자신보다 작은 ID 번호를 가진 모든 학생과 악수를 할 것입니다. 이 순서는 학생들이 교실에 들어오는 순서를 나타냅니다.\n\n예시:\n    >>> f_37(3, (2, 1, 0))\n    0", "ml": "C ഭാഷയിൽ ഒരു ഫംഗ്ഷൻ `long long f_37(int n, int order[])` എഴുതുക താഴെക്കൊടുത്തിരിക്കുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nഒരു ക്ലാസ് മുറിയിൽ പ്രവേശിക്കുന്ന വിദ്യാർത്ഥികളുടെ ഐഡി ക്രമം നൽകിയിരിക്കുന്നു, ഇവിടെ ഐഡികൾ 0 മുതൽ N-1 വരെ ആണ്. ഉണ്ടാകുന്ന ആകെ കൈകുലുക്കലുകളുടെ എണ്ണം കണക്കാക്കുക. ഓരോ വിദ്യാർത്ഥിയും ക്ലാസ് മുറിയിൽ ഇതിനകം പ്രവേശിച്ച, തങ്ങൾക്കു മുമ്പുള്ള ഐഡി നമ്പർ ഉള്ള എല്ലാ വിദ്യാർത്ഥികളുമായി കൈകുലുക്കും. ഈ ക്രമം വിദ്യാർത്ഥികൾ ക്ലാസ് മുറിയിൽ പ്രവേശിക്കുന്ന ക്രമം പ്രതിനിധീകരിക്കുന്നു.\n\nഉദാഹരണങ്ങൾ:\n    >>> f_37(3, (2, 1, 0))\n    0", "fa": "یک تابع C به نام `long long f_37(int n, int order[])` بنویسید تا مسئله زیر را حل کند:\nبا توجه به یک دنباله از شناسه‌های دانش‌آموزان که وارد کلاس می‌شوند، که شناسه‌ها از 0 تا N-1 متغیر هستند، تعداد کل دست‌دادن‌هایی که رخ می‌دهد را محاسبه کنید. هر دانش‌آموز با هر دانش‌آموزی که قبلاً با شناسه کوچکتر وارد کلاس شده است، دست می‌دهد. دنباله نشان‌دهنده ترتیب ورود دانش‌آموزان به کلاس است.\n\nمثال‌ها:\n    >>> f_37(3, (2, 1, 0))\n    0"}, "level": "middle", "test": "int main() {\n    int or1[] = {2, 1, 3, 0};\n    assert(f_37(4, or1) == 2);\n    int or2[] = {0, 1, 2, 3, 4, 5};\n    assert(f_37(6, or2) == 15);\n    int order1[] = {1, 2, 0};\n    assert(f_37(3, order1) == 1);\n\n    int order2[] = {3, 2, 1, 0};\n    assert(f_37(4, order2) == 0);\n\n    int order3[] = {0, 1, 2, 3};\n    assert(f_37(4, order3) == 6);\n\n    int order4[] = {5, 4, 3, 2, 1, 0};\n    assert(f_37(6, order4) == 0);\n\n    int order5[] = {0, 2, 1, 3};\n    assert(f_37(4, order5) == 5);\n\n    int order6[] = {3, 1, 4, 2, 0};\n    assert(f_37(5, order6) == 3);\n\n    int order7[] = {1, 0, 3, 2};\n    assert(f_37(4, order7) == 4);\n\n    int order8[] = {2, 0, 1};\n    assert(f_37(3, order8) == 1);\n\n    int order9[] = {1, 3, 0, 2, 4};\n    assert(f_37(5, order9) == 7);\n\n    int order10[] = {4, 3, 2, 1, 0};\n    assert(f_37(5, order10) == 0);\n\n    return 0;\n}", "entry_point": "f_37", "signature": "long long f_37(int n, int order[])", "docstring": {"en": "Given a sequence of student IDs entering a classroom, where the IDs range from 0 to N-1, calculate the total number of handshakes that occur. Each student will shake hands with every student already in the classroom with a smaller ID number. The sequence represents the order in which students enter the classroom.\n\nExamples:\n    >>> f_37(3, (2, 1, 0))\n    0\n", "sq": "Duke pasur një sekuencë të ID-ve të studentëve që hyjnë në një klasë, ku ID-të variojnë nga 0 deri në N-1, llogaritni numrin total të shtrëngimeve të duarve që ndodhin. Çdo student do të shtrëngojë duart me çdo student që tashmë është në klasë me një numër ID më të vogël. Sekuenca përfaqëson rendin në të cilin studentët hyjnë në klasë.\n\nShembuj:\n    >>> f_37(3, (2, 1, 0))\n    0", "hy": "Տրված է ուսանողների ID-ների հաջորդականություն, որոնք մտնում են դասարան, որտեղ ID-ները տատանվում են 0-ից մինչև N-1, հաշվեք տեղի ունեցող ողջունումների ընդհանուր քանակը։ Յուրաքանչյուր ուսանող ողջունում է յուրաքանչյուր ուսանողի, ով արդեն դասարանում է ավելի փոքր ID-ով։ Հաջորդականությունը ներկայացնում է այն կարգը, որով ուսանողները մտնում են դասարան։\n\nՕրինակներ:\n    >>> f_37(3, (2, 1, 0))\n    0", "bn": "একটি শ্রেণীকক্ষে প্রবেশ করা ছাত্রদের আইডির একটি ক্রম দেওয়া হয়েছে, যেখানে আইডিগুলি 0 থেকে N-1 পর্যন্ত বিস্তৃত। মোট কতগুলি হ্যান্ডশেক হয় তা গণনা করুন। প্রতিটি ছাত্র শ্রেণীকক্ষে ইতিমধ্যে উপস্থিত প্রতিটি ছাত্রের সাথে হ্যান্ডশেক করবে যার আইডি নম্বর ছোট। ক্রমটি ছাত্রদের শ্রেণীকক্ষে প্রবেশের ক্রমকে উপস্থাপন করে।\n\nউদাহরণ:\n    >>> f_37(3, (2, 1, 0))\n    0", "bg": "Дадена е последователност от идентификатори на ученици, влизащи в класната стая, където идентификаторите варират от 0 до N-1, изчислете общия брой ръкостискания, които се случват. Всеки ученик ще се ръкува с всеки ученик, който вече е в класната стая с по-малък идентификационен номер. Последователността представлява реда, в който учениците влизат в класната стая.\n\nПримери:\n    >>> f_37(3, (2, 1, 0))\n    0", "zh": "给定一个进入教室的学生ID序列，其中ID范围从0到N-1，计算发生的握手总数。每个学生将与教室中ID号较小的每个学生握手。序列表示学生进入教室的顺序。\n\n示例：\n    >>> f_37(3, (2, 1, 0))\n    0", "fr": "Étant donné une séquence d'IDs d'étudiants entrant dans une salle de classe, où les IDs vont de 0 à N-1, calculez le nombre total de poignées de main qui se produisent. Chaque étudiant serrera la main de chaque étudiant déjà dans la salle de classe avec un numéro d'ID plus petit. La séquence représente l'ordre dans lequel les étudiants entrent dans la salle de classe.\n\nExemples :\n    >>> f_37(3, (2, 1, 0))\n    0", "de": "Gegeben ist eine Sequenz von Schüler-IDs, die ein Klassenzimmer betreten, wobei die IDs von 0 bis N-1 reichen. Berechnen Sie die Gesamtanzahl der stattfindenden Händedrucke. Jeder Schüler wird mit jedem Schüler, der sich bereits im Klassenzimmer befindet und eine kleinere ID-Nummer hat, die Hand schütteln. Die Sequenz repräsentiert die Reihenfolge, in der die Schüler das Klassenzimmer betreten.\n\nBeispiele:\n    >>> f_37(3, (2, 1, 0))\n    0", "ha": "An ba da jerin lambobin dalibai masu shiga aji, inda lambobin ke tsakanin 0 zuwa N-1, a lissafta jimillar yawan gaisuwar hannu da ke faruwa. Kowanne dalibi zai gaisa hannu da kowanne dalibi da ke cikin aji wanda ke da karamin lamba. Jerin yana wakiltar tsarin da dalibai ke shiga aji.\n\nMisalai:\n    >>> f_37(3, (2, 1, 0))\n    0", "hi": "छात्र आईडी के अनुक्रम को ध्यान में रखते हुए जो एक कक्षा में प्रवेश कर रहे हैं, जहाँ आईडी 0 से N-1 तक होती हैं, कुल हैंडशेक की संख्या की गणना करें। प्रत्येक छात्र उन सभी छात्रों से हाथ मिलाएगा जो पहले से ही कक्षा में हैं और जिनका आईडी नंबर उससे छोटा है। अनुक्रम यह दर्शाता है कि छात्र किस क्रम में कक्षा में प्रवेश करते हैं।\n\nउदाहरण:\n    >>> f_37(3, (2, 1, 0))\n    0", "hu": "Adott egy diákazonosítókból álló sorozat, akik belépnek egy tanterembe, ahol az azonosítók 0-tól N-1-ig terjednek. Számítsd ki a kézfogások teljes számát, amelyek előfordulnak. Minden diák kezet fog minden már a tanteremben lévő diákkal, akinek kisebb azonosító száma van. A sorozat azt a sorrendet képviseli, amelyben a diákok belépnek a tanterembe.\n\nPéldák:\n    >>> f_37(3, (2, 1, 0))\n    0", "es": "Dada una secuencia de identificaciones de estudiantes que ingresan a un aula, donde los identificadores varían de 0 a N-1, calcula el número total de apretones de manos que ocurren. Cada estudiante estrechará la mano con cada estudiante que ya esté en el aula con un número de identificación menor. La secuencia representa el orden en que los estudiantes ingresan al aula.\n\nEjemplos:\n    >>> f_37(3, (2, 1, 0))\n    0", "arb": "بالنظر إلى تسلسل معرفات الطلاب الذين يدخلون إلى الفصل، حيث تتراوح المعرفات من 0 إلى N-1، احسب العدد الإجمالي للمصافحات التي تحدث. كل طالب سوف يصافح كل طالب موجود بالفعل في الفصل بمعرف أصغر. يمثل التسلسل ترتيب دخول الطلاب إلى الفصل.\n\nأمثلة:\n    >>> f_37(3, (2, 1, 0))\n    0", "sw": "Kutolewa mlolongo wa vitambulisho vya wanafunzi wanaoingia darasani, ambapo vitambulisho vinatoka 0 hadi N-1, hesabu jumla ya mikono iliyoshikanwa inayotokea. Kila mwanafunzi atashikana mikono na kila mwanafunzi ambaye tayari yuko darasani mwenye namba ndogo ya kitambulisho. Mlolongo unawakilisha mpangilio ambao wanafunzi wanaingia darasani.\n\nMifano:\n    >>> f_37(3, (2, 1, 0))\n    0", "tr": "Verilen bir sınıfa giren öğrenci kimlik numaralarının sırası, kimlik numaralarının 0'dan N-1'e kadar olduğu bir dizidir. Gerçekleşen toplam tokalaşma sayısını hesaplayın. Her öğrenci, sınıfta zaten bulunan ve daha küçük kimlik numarasına sahip olan her öğrenciyle tokalaşacaktır. Dizi, öğrencilerin sınıfa giriş sırasını temsil eder.\n\nÖrnekler:\n    >>> f_37(3, (2, 1, 0))\n    0", "vi": "Given a sequence of student IDs entering a classroom, where the IDs range from 0 to N-1, calculate the total number of handshakes that occur. Mỗi học sinh sẽ bắt tay với mọi học sinh đã có mặt trong lớp với số ID nhỏ hơn. Dãy số đại diện cho thứ tự mà học sinh vào lớp.\n\nVí dụ:\n    >>> f_37(3, (2, 1, 0))\n    0", "id": "Diberikan urutan ID siswa yang memasuki ruang kelas, di mana ID berkisar dari 0 hingga N-1, hitung jumlah total jabat tangan yang terjadi. Setiap siswa akan berjabat tangan dengan setiap siswa yang sudah ada di ruang kelas dengan nomor ID yang lebih kecil. Urutan tersebut mewakili urutan di mana siswa memasuki ruang kelas.\n\nContoh:\n    >>> f_37(3, (2, 1, 0))\n    0", "ja": "学生IDが教室に入る順序が与えられたとき、IDは0からN-1の範囲であるとします。発生する握手の総数を計算します。各学生は、教室にすでにいる自分より小さいID番号を持つすべての学生と握手をします。この順序は、学生が教室に入る順番を表しています。\n\n例:\n    >>> f_37(3, (2, 1, 0))\n    0", "ko": "학생 ID가 0부터 N-1까지 범위에 있는 교실에 들어오는 순서가 주어졌을 때, 발생하는 총 악수의 수를 계산합니다. 각 학생은 이미 교실에 있는 자신보다 작은 ID 번호를 가진 모든 학생과 악수를 합니다. 이 순서는 학생들이 교실에 들어오는 순서를 나타냅니다.\n\n예시:\n    >>> f_37(3, (2, 1, 0))\n    0", "ml": "ക്ലാസ്‌റൂമിലേക്ക് പ്രവേശിക്കുന്ന വിദ്യാർത്ഥികളുടെ ഐഡി ക്രമം നൽകിയിരിക്കുന്നു, ഇവിടെ ഐഡികൾ 0 മുതൽ N-1 വരെയാണ്, ഉണ്ടാകുന്ന ആകെ കൈകുലുക്കങ്ങളുടെ എണ്ണം കണക്കാക്കുക. ഓരോ വിദ്യാർത്ഥിയും, ക്ലാസ്‌റൂമിൽ ഇതിനകം പ്രവേശിച്ച, തനിക്കു കിഴിവായ ഐഡി നമ്പർ ഉള്ള എല്ലാ വിദ്യാർത്ഥികളുമായും കൈകുലുക്കം നടത്തും. ഈ ക്രമം വിദ്യാർത്ഥികൾ ക്ലാസ്‌റൂമിലേക്ക് പ്രവേശിക്കുന്ന ക്രമം പ്രതിനിധീകരിക്കുന്നു.\n\nഉദാഹരണങ്ങൾ:\n    >>> f_37(3, (2, 1, 0))\n    0", "fa": "با توجه به دنباله‌ای از شناسه‌های دانش‌آموزانی که وارد کلاس می‌شوند، که شناسه‌ها در بازه 0 تا N-1 قرار دارند، تعداد کل دست دادن‌هایی که اتفاق می‌افتد را محاسبه کنید. هر دانش‌آموز با هر دانش‌آموزی که قبلاً با شناسه کوچکتر در کلاس بوده دست می‌دهد. دنباله نشان‌دهنده ترتیب ورود دانش‌آموزان به کلاس است.\n\nمثال‌ها:\n    >>> f_37(3, (2, 1, 0))\n    0\n"}}
{"task_id": "C/38", "prompt": {"en": "#include <assert.h>\n#include <stdio.h>\n/*\nGiven n positive integers representing the count of each number from 1 to n, \nfind the maximum sum of the mode (most frequent element) for all prefixes of \na sequence constructed from these numbers. The mode is the largest number among \nthe most frequent elements in a sequence.\n    >>> f_38(3, (int[]){1, 2, 3})\n    17\n    A sequence that reaches its maximum value is (3,2,3,1,2,2).\n*/\nlong long f_38(int n, const int* counts)", "sq": "#include <assert.h>\n#include <stdio.h>\n/*\nDuke pasur n numra të plotë pozitivë që përfaqësojnë numrin e çdo numri nga 1 deri në n,\ngjeni shumën maksimale të modës (elementi më i shpeshtë) për të gjitha parashtesat e\nnjë sekuence të ndërtuar nga këta numra. Moda është numri më i madh ndër elementët më të shpeshtë në një sekuencë.\n    >>> f_38(3, (int[]){1, 2, 3})\n    17\n    Një sekuencë që arrin vlerën e saj maksimale është (3,2,3,1,2,2).\n*/\nlong long f_38(int n, const int* counts)", "hy": "#include <assert.h>\n#include <stdio.h>\n/*\nՏրված են n դրական ամբողջ թվեր, որոնք ներկայացնում են 1-ից n յուրաքանչյուր թվի քանակը,\nգտնել մոդի (ամենահաճախ հանդիպող տարրը) առավելագույն գումարը բոլոր նախածանցների համար\nայս թվերից կառուցված հաջորդականության։ Մոդը ամենամեծ թիվն է հաջորդականության ամենահաճախ հանդիպող տարրերի մեջ։\n    >>> f_38(3, (int[]){1, 2, 3})\n    17\n    Առավելագույն արժեքին հասնող հաջորդականությունը (3,2,3,1,2,2) է։\n*/\nlong long f_38(int n, const int* counts)", "bn": "#include <assert.h>\n#include <stdio.h>\n/*\nপ্রতিটি সংখ্যা 1 থেকে n পর্যন্ত গণনা উপস্থাপনকারী n টি ধনাত্মক পূর্ণসংখ্যা দেওয়া হয়েছে,\nএই সংখ্যাগুলি থেকে গঠিত একটি ক্রমের সমস্ত উপসর্গের জন্য মোডের (সর্বাধিক ঘন ঘন উপাদান) \nসর্বাধিক যোগফল খুঁজে বের করুন। মোড হল একটি ক্রমের সর্বাধিক ঘন ঘন উপাদানগুলির মধ্যে \nবৃহত্তম সংখ্যা।\n    >>> f_38(3, (int[]){1, 2, 3})\n    17\n    একটি ক্রম যা তার সর্বাধিক মানে পৌঁছায় তা হল (3,2,3,1,2,2)।\n*/\nlong long f_38(int n, const int* counts)", "bg": "#include <assert.h>\n#include <stdio.h>\n/*\nДадени са n положителни цели числа, представляващи броя на всяко число от 1 до n,\nнамерете максималната сума на модата (най-често срещания елемент) за всички префикси на\nпоследователност, конструирана от тези числа. Модата е най-голямото число сред\nнай-често срещаните елементи в последователност.\n    >>> f_38(3, (int[]){1, 2, 3})\n    17\n    Последователност, която достига максималната си стойност, е (3,2,3,1,2,2).\n*/\nlong long f_38(int n, const int* counts)", "zh": "#include <assert.h>\n#include <stdio.h>\n/*\n给定 n 个正整数，表示从 1 到 n 的每个数字的计数，\n找出从这些数字构造的序列的所有前缀的众数（最频繁元素）的最大和。\n众数是序列中最频繁元素中最大的数字。\n    >>> f_38(3, (int[]){1, 2, 3})\n    17\n    达到其最大值的序列是 (3,2,3,1,2,2)。\n*/\nlong long f_38(int n, const int* counts)", "fr": "#include <assert.h>\n#include <stdio.h>\n/*\nÉtant donné n entiers positifs représentant le nombre de chaque nombre de 1 à n,\ntrouvez la somme maximale de la mode (élément le plus fréquent) pour tous les préfixes d'une\nséquence construite à partir de ces nombres. La mode est le plus grand nombre parmi\nles éléments les plus fréquents dans une séquence.\n    >>> f_38(3, (int[]){1, 2, 3})\n    17\n    Une séquence qui atteint sa valeur maximale est (3,2,3,1,2,2).\n*/\nlong long f_38(int n, const int* counts)", "de": "#include <assert.h>\n#include <stdio.h>\n/*\nGegeben n positive ganze Zahlen, die die Anzahl jedes Zahl von 1 bis n darstellen,\nfinden Sie die maximale Summe des Modus (häufigstes Element) für alle Präfixe einer \nSequenz, die aus diesen Zahlen konstruiert wurde. Der Modus ist die größte Zahl unter \nden häufigsten Elementen in einer Sequenz.\n    >>> f_38(3, (int[]){1, 2, 3})\n    17\n    Eine Sequenz, die ihren maximalen Wert erreicht, ist (3,2,3,1,2,2).\n*/\nlong long f_38(int n, const int* counts)", "ha": "#include <assert.h>\n#include <stdio.h>\n/*\nAn ba da lambobin n masu kyau waɗanda ke wakiltar adadin kowace lamba daga 1 zuwa n,\nnemo mafi girman jimlar yanayin (abin da aka fi samu) don dukkanin farkon jerin\nda aka gina daga waɗannan lambobin. Yanayin shine mafi girman lamba a cikin\nabin da aka fi samu a cikin jerin.\n    >>> f_38(3, (int[]){1, 2, 3})\n    17\n    Jerin da ya kai darajarsa mafi girma shine (3,2,3,1,2,2).\n*/\nlong long f_38(int n, const int* counts)", "hi": "#include <assert.h>\n#include <stdio.h>\n/*\nदिए गए n धनात्मक पूर्णांक जो 1 से n तक प्रत्येक संख्या की गिनती का प्रतिनिधित्व करते हैं,\nइन संख्याओं से निर्मित अनुक्रम के सभी उपसर्गों के लिए मोड (सबसे अधिक बार आने वाला तत्व) का अधिकतम योग खोजें।\nमोड अनुक्रम में सबसे अधिक बार आने वाले तत्वों में सबसे बड़ी संख्या है।\n    >>> f_38(3, (int[]){1, 2, 3})\n    17\n    एक अनुक्रम जो अपने अधिकतम मान तक पहुँचता है वह है (3,2,3,1,2,2)।\n*/\nlong long f_38(int n, const int* counts)", "hu": "#include <assert.h>\n#include <stdio.h>\n/*\nAdott n pozitív egész szám, amelyek az 1-től n-ig terjedő számok számosságát képviselik,\nkeresse meg a módusz (leggyakoribb elem) maximális összegét az ezekből a számokból\nfelépített sorozat összes prefixére. A módusz a legnagyobb szám a sorozat\nleggyakoribb elemei között.\n    >>> f_38(3, (int[]){1, 2, 3})\n    17\n    Egy sorozat, amely eléri a maximális értékét: (3,2,3,1,2,2).\n*/\nlong long f_38(int n, const int* counts)", "es": "#include <assert.h>\n#include <stdio.h>\n/*\nDado n números enteros positivos que representan la cantidad de cada número de 1 a n,\nencuentra la suma máxima de la moda (elemento más frecuente) para todos los prefijos de\nuna secuencia construida a partir de estos números. La moda es el número más grande entre\nlos elementos más frecuentes en una secuencia.\n    >>> f_38(3, (int[]){1, 2, 3})\n    17\n    Una secuencia que alcanza su valor máximo es (3,2,3,1,2,2).\n*/\nlong long f_38(int n, const int* counts)", "arb": "#include <assert.h>\n#include <stdio.h>\n/*\nبالنظر إلى n من الأعداد الصحيحة الموجبة التي تمثل عدد كل رقم من 1 إلى n،\nابحث عن الحد الأقصى لمجموع النمط (العنصر الأكثر تكرارًا) لجميع البادئات \nلسلسلة مكونة من هذه الأرقام. النمط هو أكبر عدد بين العناصر الأكثر تكرارًا في سلسلة.\n    >>> f_38(3, (int[]){1, 2, 3})\n    17\n    سلسلة تصل إلى قيمتها القصوى هي (3,2,3,1,2,2).\n*/\nlong long f_38(int n, const int* counts)", "sw": "#include <assert.h>\n#include <stdio.h>\n/*\nUkipiwa n nambari chanya zinazowakilisha idadi ya kila nambari kutoka 1 hadi n,\ntafuta jumla ya juu zaidi ya hali (kipengele kinachojitokeza mara nyingi zaidi) kwa viambishi vyote vya \nmlolongo ulioundwa kutoka kwa nambari hizi. Hali ni nambari kubwa zaidi kati ya \nvipengele vinavyojitokeza mara nyingi zaidi katika mlolongo.\n    >>> f_38(3, (int[]){1, 2, 3})\n    17\n    Mlolongo unaofikia thamani yake ya juu zaidi ni (3,2,3,1,2,2).\n*/\nlong long f_38(int n, const int* counts)", "tr": "#include <assert.h>\n#include <stdio.h>\n/*\n1'den n'e kadar her bir sayının sayısını temsil eden n pozitif tamsayı verildiğinde,\nbu sayılardan oluşturulan bir dizinin tüm önekleri için modun (en sık görülen eleman) \nmaksimum toplamını bulun. Mod, bir dizideki en sık görülen elemanlar arasında en büyük sayıdır.\n    >>> f_38(3, (int[]){1, 2, 3})\n    17\n    Maksimum değerine ulaşan bir dizi (3,2,3,1,2,2) şeklindedir.\n*/\nlong long f_38(int n, const int* counts)", "vi": "#include <assert.h>\n#include <stdio.h>\n/*\nCho n số nguyên dương đại diện cho số lượng của mỗi số từ 1 đến n,\ntìm tổng lớn nhất của mode (phần tử xuất hiện nhiều nhất) cho tất cả các tiền tố của\nmột dãy được tạo từ những số này. Mode là số lớn nhất trong số các phần tử xuất hiện nhiều nhất trong một dãy.\n    >>> f_38(3, (int[]){1, 2, 3})\n    17\n    Một dãy đạt giá trị tối đa là (3,2,3,1,2,2).\n*/\nlong long f_38(int n, const int* counts)", "id": "#include <assert.h>\n#include <stdio.h>\n/*\nDiberikan n bilangan bulat positif yang mewakili jumlah setiap angka dari 1 hingga n,\ntemukan jumlah maksimum dari modus (elemen yang paling sering muncul) untuk semua awalan dari\nsebuah urutan yang dibangun dari angka-angka ini. Modus adalah angka terbesar di antara\nelemen yang paling sering muncul dalam sebuah urutan.\n    >>> f_38(3, (int[]){1, 2, 3})\n    17\n    Sebuah urutan yang mencapai nilai maksimumnya adalah (3,2,3,1,2,2).\n*/\nlong long f_38(int n, const int* counts)\n", "ja": "#include <assert.h>\n#include <stdio.h>\n/*\nn 個の正の整数が与えられ、それぞれが 1 から n までの数の出現回数を表します。\nこれらの数から構成されるシーケンスのすべての接頭辞に対して、モード（最も頻繁に出現する要素）の最大合計を見つけてください。\nモードは、シーケンス内で最も頻繁に出現する要素の中で最大の数です。\n    >>> f_38(3, (int[]){1, 2, 3})\n    17\n    最大値に達するシーケンスは (3,2,3,1,2,2) です。\n*/\nlong long f_38(int n, const int* counts)", "ko": "#include <assert.h>\n#include <stdio.h>\n/*\nn개의 양의 정수가 1부터 n까지의 각 숫자의 개수를 나타낼 때, \n이 숫자들로 구성된 시퀀스의 모든 접두사에 대해 최빈값(가장 빈번한 요소)의 최대 합을 찾습니다. \n최빈값은 시퀀스에서 가장 빈번한 요소 중 가장 큰 숫자입니다.\n    >>> f_38(3, (int[]){1, 2, 3})\n    17\n    최대값에 도달하는 시퀀스는 (3,2,3,1,2,2)입니다.\n*/\nlong long f_38(int n, const int* counts)\n", "ml": "#include <assert.h>\n#include <stdio.h>\n/*\n1 മുതൽ n വരെ ഓരോ സംഖ്യയുടെ എണ്ണവും പ്രതിനിധീകരിക്കുന്ന n അനുകൂല സമ്പൂർണ്ണ സംഖ്യകൾ നൽകിയാൽ, \nഈ സംഖ്യകളിൽ നിന്ന് നിർമ്മിച്ച ഒരു ക്രമത്തിന്റെ എല്ലാ പ്രിഫിക്സുകളുടെയും മോഡ് (ഏറ്റവും അധികം ആവർത്തിക്കുന്ന ഘടകം) \nപരമാവധി തുക കണ്ടെത്തുക. ഒരു ക്രമത്തിലെ ഏറ്റവും അധികം ആവർത്തിക്കുന്ന ഘടകങ്ങളിൽ ഏറ്റവും വലിയ സംഖ്യയാണ് മോഡ്.\n    >>> f_38(3, (int[]){1, 2, 3})\n    17\n    പരമാവധി മൂല്യം എത്തുന്ന ഒരു ക്രമം (3,2,3,1,2,2) ആണ്.\n*/\nlong long f_38(int n, const int* counts)", "fa": "#include <assert.h>\n#include <stdio.h>\n/*\nبا داشتن n عدد صحیح مثبت که نشان‌دهنده تعداد هر عدد از 1 تا n هستند، \nبیشترین مجموع حالت (عنصر پرتکرار) را برای تمام پیشوندهای \nیک دنباله ساخته شده از این اعداد پیدا کنید. حالت، بزرگترین عدد در میان \nعناصر پرتکرار در یک دنباله است.\n    >>> f_38(3, (int[]){1, 2, 3})\n    17\n    دنباله‌ای که به بیشترین مقدار خود می‌رسد (3,2,3,1,2,2) است.\n*/\nlong long f_38(int n, const int* counts)"}, "canonical_solution": "{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}", "instruction": {"en": "Write a C function `long long f_38(int n, const int* counts)` to solve the following problem:\nGiven n positive integers representing the count of each number from 1 to n, \nfind the maximum sum of the mode (most frequent element) for all prefixes of \na sequence constructed from these numbers. The mode is the largest number among \nthe most frequent elements in a sequence.\n    >>> f_38(3, (int[]){1, 2, 3})\n    17\n    A sequence that reaches its maximum value is (3,2,3,1,2,2).\n", "sq": "Shkruani një funksion në C `long long f_38(int n, const int* counts)` për të zgjidhur problemin e mëposhtëm:\nDuke pasur n numra të plotë pozitivë që përfaqësojnë numrin e secilit numër nga 1 deri në n,  \ngjeni shumën maksimale të modës (elementi më i shpeshtë) për të gjitha parashtesat e  \nnjë sekuence të ndërtuar nga këta numra. Moda është numri më i madh ndër elementët më të shpeshtë në një sekuencë.  \n    >>> f_38(3, (int[]){1, 2, 3})  \n    17  \n    Një sekuencë që arrin vlerën e saj maksimale është (3,2,3,1,2,2).", "hy": "Գրեք C ֆունկցիա `long long f_38(int n, const int* counts)` հետևյալ խնդիրը լուծելու համար:\nՏրված են n դրական ամբողջ թվեր, որոնք ներկայացնում են 1-ից n թվերի քանակը, \nգտեք մոդի (ամենահաճախ հանդիպող տարր) առավելագույն գումարը բոլոր նախածանցների համար \nայդ թվերից կառուցված հաջորդականության: Մոդը հաջորդականության ամենահաճախ հանդիպող տարրերի \nմեջ ամենամեծ թիվն է:\n    >>> f_38(3, (int[]){1, 2, 3})\n    17\n    Հաջորդականություն, որը հասնում է իր առավելագույն արժեքին, (3,2,3,1,2,2) է:", "bn": "একটি C ফাংশন `long long f_38(int n, const int* counts)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nপ্রতিটি সংখ্যা 1 থেকে n পর্যন্ত গণনার প্রতিনিধিত্বকারী n টি ধনাত্মক পূর্ণসংখ্যা দেওয়া হয়েছে, \nএই সংখ্যাগুলি থেকে নির্মিত একটি ক্রমের সমস্ত উপসর্গের জন্য মোডের (সবচেয়ে ঘন ঘন উপাদান) সর্বাধিক যোগফল খুঁজে বের করুন। \nমোড হল একটি ক্রমের সবচেয়ে ঘন ঘন উপাদানগুলির মধ্যে বৃহত্তম সংখ্যা।\n    >>> f_38(3, (int[]){1, 2, 3})\n    17\n    একটি ক্রম যা তার সর্বাধিক মানে পৌঁছায় তা হল (3,2,3,1,2,2)।", "bg": "Напишете C функция `long long f_38(int n, const int* counts)`, за да решите следния проблем:\nДадени са n положителни цели числа, представляващи броя на всяко число от 1 до n,  \nнамерете максималната сума на модата (най-често срещания елемент) за всички префикси на  \nпоследователност, конструирана от тези числа. Модата е най-голямото число сред  \nнай-често срещаните елементи в последователност.  \n    >>> f_38(3, (int[]){1, 2, 3})  \n    17  \n    Последователност, която достига максималната си стойност, е (3,2,3,1,2,2).  ", "zh": "编写一个 C 函数 `long long f_38(int n, const int* counts)` 来解决以下问题：\n给定 n 个正整数，表示从 1 到 n 的每个数字的计数，  \n找到从这些数字构建的序列的所有前缀的众数（最频繁元素）的最大和。众数是在序列中最频繁元素中最大的数字。  \n    >>> f_38(3, (int[]){1, 2, 3})  \n    17  \n    一个达到其最大值的序列是 (3,2,3,1,2,2)。  ", "fr": "Écrire une fonction C `long long f_38(int n, const int* counts)` pour résoudre le problème suivant:\nÉtant donné n entiers positifs représentant le compte de chaque nombre de 1 à n,  \ntrouver la somme maximale du mode (élément le plus fréquent) pour tous les préfixes d'une séquence construite à partir de ces nombres. Le mode est le plus grand nombre parmi les éléments les plus fréquents dans une séquence.  \n    >>> f_38(3, (int[]){1, 2, 3})  \n    17  \n    Une séquence qui atteint sa valeur maximale est (3,2,3,1,2,2).  ", "de": "Schreiben Sie eine C-Funktion `long long f_38(int n, const int* counts)`, um das folgende Problem zu lösen:\nGegeben sind n positive ganze Zahlen, die die Anzahl jedes Zahl von 1 bis n darstellen.  \nFinden Sie die maximale Summe des Modus (häufigstes Element) für alle Präfixe einer Sequenz, die aus diesen Zahlen konstruiert wurde. Der Modus ist die größte Zahl unter den häufigsten Elementen in einer Sequenz.  \n    >>> f_38(3, (int[]){1, 2, 3})  \n    17  \n    Eine Sequenz, die ihren Maximalwert erreicht, ist (3,2,3,1,2,2).  ", "ha": "Rubuta aikin C `long long f_38(int n, const int* counts)` don warware matsalar mai zuwa:\nAn ba da lambobi masu kyau n waɗanda ke wakiltar adadin kowace lamba daga 1 zuwa n,\nnemo mafi girman jumlar yanayin (mafi yawan abu) don dukkan farkon\nwani jere da aka gina daga waɗannan lambobin. Yanayin shine mafi girman lamba a cikin\nmafi yawan abubuwa a cikin jere.\n    >>> f_38(3, (int[]){1, 2, 3})\n    17\n    Jere wanda ya kai darajarsa mafi girma shine (3,2,3,1,2,2).", "hi": "C फ़ंक्शन `long long f_38(int n, const int* counts)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए n धनात्मक पूर्णांक जो 1 से n तक प्रत्येक संख्या की गिनती का प्रतिनिधित्व करते हैं, \nउन सभी अनुक्रमों के उपसर्गों के लिए मोड (सबसे अधिक बार आने वाला तत्व) का अधिकतम योग खोजें \nजो इन संख्याओं से निर्मित होते हैं। मोड एक अनुक्रम में सबसे अधिक बार आने वाले तत्वों में सबसे बड़ी संख्या है।\n    >>> f_38(3, (int[]){1, 2, 3})\n    17\n    एक अनुक्रम जो अपने अधिकतम मान तक पहुँचता है वह है (3,2,3,1,2,2)।", "hu": "Írj egy C függvényt `long long f_38(int n, const int* counts)` a következő probléma megoldására:\nAdott n pozitív egész szám, amelyek az 1-től n-ig terjedő számok előfordulásainak számát képviselik,  \ntaláld meg a módusz (a leggyakrabban előforduló elem) maximális összegét az  \nezekből a számokból felépített sorozat minden prefixére. A módusz a sorozatban  \nleggyakrabban előforduló elemek közül a legnagyobb szám.  \n    >>> f_38(3, (int[]){1, 2, 3})  \n    17  \n    Egy sorozat, amely eléri a maximális értékét: (3,2,3,1,2,2).  ", "es": "Escribe una función en C `long long f_38(int n, const int* counts)` para resolver el siguiente problema:\nDado n enteros positivos que representan la cantidad de cada número del 1 al n, \nencuentra la suma máxima del modo (elemento más frecuente) para todos los prefijos de \nuna secuencia construida a partir de estos números. El modo es el número más grande entre \nlos elementos más frecuentes en una secuencia.\n    >>> f_38(3, (int[]){1, 2, 3})\n    17\n    Una secuencia que alcanza su valor máximo es (3,2,3,1,2,2).", "arb": "اكتب دالة بلغة C `long long f_38(int n, const int* counts)` لحل المشكلة التالية:\nمعطى n من الأعداد الصحيحة الموجبة التي تمثل عدد كل رقم من 1 إلى n، \nابحث عن الحد الأقصى لمجموع النمط (العنصر الأكثر تكرارًا) لجميع البادئات \nلسلسلة تم إنشاؤها من هذه الأرقام. النمط هو أكبر رقم بين العناصر الأكثر تكرارًا في سلسلة.\n    >>> f_38(3, (int[]){1, 2, 3})\n    17\n    سلسلة تصل إلى قيمتها القصوى هي (3,2,3,1,2,2).", "sw": "Andika kazi ya C `long long f_38(int n, const int* counts)` kutatua tatizo lifuatalo:\nUkipiwa n nambari chanya zinazowakilisha idadi ya kila nambari kutoka 1 hadi n,\ntafuta jumla ya juu zaidi ya hali (kipengele kinachojitokeza mara nyingi zaidi) kwa viambishi vyote vya\nmlolongo ulioundwa kutoka kwa nambari hizi. Hali ni nambari kubwa zaidi kati ya\nvipengele vinavyojitokeza mara nyingi zaidi katika mlolongo.\n    >>> f_38(3, (int[]){1, 2, 3})\n    17\n    Mlolongo unaofikia thamani yake ya juu ni (3,2,3,1,2,2).", "tr": "Bir C fonksiyonu `long long f_38(int n, const int* counts)` yazın ve aşağıdaki problemi çözün:\n1'den n'ye kadar olan her sayının sayısını temsil eden n pozitif tamsayı verildiğinde, \nbu sayılardan oluşturulan bir dizinin tüm önekleri için modun (en sık görülen eleman) maksimum toplamını bulun. \nMod, bir dizideki en sık görülen elemanlar arasında en büyük sayıdır.\n    >>> f_38(3, (int[]){1, 2, 3})\n    17\n    Maksimum değerine ulaşan bir dizi (3,2,3,1,2,2) şeklindedir.", "vi": "Viết một hàm C `long long f_38(int n, const int* counts)` để giải quyết vấn đề sau:\nCho n số nguyên dương đại diện cho số lượng của mỗi số từ 1 đến n, \ntìm tổng lớn nhất của mode (phần tử xuất hiện nhiều nhất) cho tất cả các tiền tố của \nmột dãy được tạo từ các số này. Mode là số lớn nhất trong số các phần tử xuất hiện nhiều nhất trong một dãy.\n    >>> f_38(3, (int[]){1, 2, 3})\n    17\n    Một dãy đạt giá trị tối đa là (3,2,3,1,2,2).", "id": "Tulis fungsi C `long long f_38(int n, const int* counts)` untuk menyelesaikan masalah berikut:\nDiberikan n bilangan bulat positif yang mewakili jumlah setiap angka dari 1 hingga n,  \ntemukan jumlah maksimum dari modus (elemen yang paling sering muncul) untuk semua awalan dari  \nsebuah urutan yang dibangun dari angka-angka ini. Modus adalah angka terbesar di antara  \nelemen-elemen yang paling sering muncul dalam sebuah urutan.\n    >>> f_38(3, (int[]){1, 2, 3})\n    17\n    Urutan yang mencapai nilai maksimumnya adalah (3,2,3,1,2,2).", "ja": "Cの関数を書け `long long f_38(int n, const int* counts)`  次の問題を解くために:\nn 個の正の整数が与えられ、それぞれが 1 から n までの数の出現回数を表しています。  \nこれらの数から構成されるシーケンスのすべての接頭辞に対して、モード（最頻要素）の最大合計を見つけます。  \nモードは、シーケンス内の最頻要素の中で最大の数です。  \n    >>> f_38(3, (int[]){1, 2, 3})  \n    17  \n    最大値に達するシーケンスは (3,2,3,1,2,2) です。  ", "ko": "C 함수를 작성하세요 `long long f_38(int n, const int* counts)` 다음 문제를 해결하기 위해:\n양의 정수 n이 주어지면, 1부터 n까지의 각 숫자의 개수를 나타냅니다. \n이 숫자들로 구성된 시퀀스의 모든 접두사에 대해 최빈값(가장 빈번한 요소)의 최대 합을 찾으세요. \n최빈값은 시퀀스에서 가장 빈번한 요소 중 가장 큰 숫자입니다.\n    >>> f_38(3, (int[]){1, 2, 3})\n    17\n    최대값에 도달하는 시퀀스는 (3,2,3,1,2,2)입니다.", "ml": "C ഫംഗ്ഷൻ `long long f_38(int n, const int* counts)` എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\n1 മുതൽ n വരെ ഓരോ സംഖ്യയുടെ എണ്ണവും പ്രതിനിധീകരിക്കുന്ന n അനുകൂല സംഖ്യകൾ നൽകിയിരിക്കുന്നു, \nഈ സംഖ്യകളിൽ നിന്ന് നിർമ്മിച്ച ഒരു ശ്രേണിയുടെ എല്ലാ പ്രിഫിക്സുകൾക്കും \nമോഡിന്റെ (ഏറ്റവും അധികം ആവർത്തിക്കുന്ന മൂല്യം) പരമാവധി തുക കണ്ടെത്തുക. \nമോഡ് ഒരു ശ്രേണിയിലെ ഏറ്റവും അധികം ആവർത്തിക്കുന്ന മൂല്യങ്ങളിൽ ഏറ്റവും വലിയ സംഖ്യയാണ്.\n    >>> f_38(3, (int[]){1, 2, 3})\n    17\n    പരമാവധി മൂല്യത്തിലെത്തുന്ന ഒരു ശ്രേണി (3,2,3,1,2,2) ആണ്.", "fa": "یک تابع C به نام `long long f_38(int n, const int* counts)` بنویسید تا مسئله زیر را حل کند:\nبا توجه به n عدد مثبت که نمایانگر تعداد هر عدد از 1 تا n هستند، \nحداکثر مجموع مد (عنصر با بیشترین تکرار) را برای تمام پیشوندهای \nیک دنباله ساخته شده از این اعداد پیدا کنید. مد بزرگترین عدد در میان \nعناصر با بیشترین تکرار در یک دنباله است.\n    >>> f_38(3, (int[]){1, 2, 3})\n    17\n    یک دنباله که به حداکثر مقدار خود می‌رسد (3,2,3,1,2,2) است."}, "level": "easy", "test": "int main() {\n    assert(f_38(3, (int[]){1, 3, 2}) == 17);\n    assert(f_38(4, (int[]){4, 1, 2, 3}) == 37);\n    assert(f_38(2, (int[]){1, 1}) == 4);\n    assert(f_38(5, (int[]){1, 2, 3, 4, 5}) == 75);\n    assert(f_38(1, (int[]){100000}) == 100000);\n    assert(f_38(5, (int[]){5, 3, 2, 4, 1}) == 62);\n    assert(f_38(3, (int[]){100000, 100000, 100000}) == 900000);\n    assert(f_38(3, (int[]){2, 2, 5}) == 27);\n    assert(f_38(4, (int[]){4, 4, 4, 4}) == 64);\n    assert(f_38(6, (int[]){1, 2, 3, 4, 5, 6}) == 126);\n    assert(f_38(3, (int[]){3, 1, 2}) == 16);\n    return 0;\n}", "entry_point": "f_38", "signature": "long long f_38(int n, const int* counts)", "docstring": {"en": "Given n positive integers representing the count of each number from 1 to n, \nfind the maximum sum of the mode (most frequent element) for all prefixes of \na sequence constructed from these numbers. The mode is the largest number among \nthe most frequent elements in a sequence.\n    >>> f_38(3, (int[]){1, 2, 3})\n    17\n    A sequence that reaches its maximum value is (3,2,3,1,2,2).\n", "sq": "Duke pasur n numra të plotë pozitivë që përfaqësojnë numrin e secilit numër nga 1 deri në n, \ngjeni shumën maksimale të modës (elementi më i shpeshtë) për të gjitha prefikset e \nnjë sekuence të ndërtuar nga këta numra. Moda është numri më i madh ndër elementet më të shpeshta në një sekuencë.\n    >>> f_38(3, (int[]){1, 2, 3})\n    17\n    Një sekuencë që arrin vlerën e saj maksimale është (3,2,3,1,2,2).", "hy": "Տրված են n դրական ամբողջ թվեր, որոնք ներկայացնում են 1-ից n թվերի քանակը, \nգտնել բոլոր նախածանցների համար ռեժիմի (ամենահաճախ հանդիպող տարր) առավելագույն գումարը \nայդ թվերից կառուցված հաջորդականության։ Ռեժիմը հաջորդականության ամենահաճախ հանդիպող տարրերի \nմեջ ամենամեծ թիվն է։\n    >>> f_38(3, (int[]){1, 2, 3})\n    17\n    Հաջորդականությունը, որը հասնում է իր առավելագույն արժեքին, (3,2,3,1,2,2) է։", "bn": "n টি ধনাত্মক পূর্ণসংখ্যা দেওয়া আছে যা 1 থেকে n পর্যন্ত প্রতিটি সংখ্যার গণনা উপস্থাপন করে, \nএই সংখ্যাগুলি থেকে নির্মিত একটি ক্রমের সমস্ত উপসর্গের জন্য মোডের (সবচেয়ে ঘন ঘন উপাদান) সর্বাধিক যোগফল খুঁজে বের করুন। \nমোড হল একটি ক্রমে সবচেয়ে ঘন ঘন উপাদানগুলির মধ্যে বৃহত্তম সংখ্যা।\n    >>> f_38(3, (int[]){1, 2, 3})\n    17\n    একটি ক্রম যা তার সর্বাধিক মানে পৌঁছায় তা হল (3,2,3,1,2,2)।", "bg": "Дадени са n положителни цели числа, представляващи броя на всяко число от 1 до n, \nнамерете максималната сума на модата (най-често срещания елемент) за всички префикси на \nпоследователност, съставена от тези числа. Модата е най-голямото число сред \nнай-често срещаните елементи в последователност.\n    >>> f_38(3, (int[]){1, 2, 3})\n    17\n    Последователност, която достига максималната си стойност, е (3,2,3,1,2,2).", "zh": "给定 n 个正整数，表示从 1 到 n 的每个数字的计数，找出从这些数字构造的序列的所有前缀中众数（出现频率最高的元素）的最大和。众数是序列中出现频率最高的元素中最大的数字。\n    >>> f_38(3, (int[]){1, 2, 3})\n    17\n    达到最大值的序列是 (3,2,3,1,2,2)。", "fr": "Étant donné n entiers positifs représentant le compte de chaque nombre de 1 à n, trouvez la somme maximale du mode (élément le plus fréquent) pour tous les préfixes d'une séquence construite à partir de ces nombres. Le mode est le plus grand nombre parmi les éléments les plus fréquents dans une séquence.\n    >>> f_38(3, (int[]){1, 2, 3})\n    17\n    Une séquence qui atteint sa valeur maximale est (3,2,3,1,2,2).", "de": "Gegeben sind n positive ganze Zahlen, die die Anzahl jedes einzelnen Wertes von 1 bis n darstellen. \nFinden Sie die maximale Summe des Modus (häufigstes Element) für alle Präfixe einer Sequenz, die aus diesen Zahlen konstruiert wurde. Der Modus ist die größte Zahl unter den häufigsten Elementen in einer Sequenz.\n    >>> f_38(3, (int[]){1, 2, 3})\n    17\n    Eine Sequenz, die ihren Maximalwert erreicht, ist (3,2,3,1,2,2).", "ha": "An bayar da n lambobi masu kyau waɗanda ke wakiltar adadin kowace lamba daga 1 zuwa n, \nnemo mafi girman jimlar yanayin (abin da aka fi samu) don dukkan farkon jerin \nda aka gina daga waɗannan lambobin. Yanayin shine mafi girman lamba tsakanin \nabin da aka fi samu a cikin jerin.\n    >>> f_38(3, (int[]){1, 2, 3})\n    17\n    Wani jerin da ya kai darajarsa mafi girma shine (3,2,3,1,2,2).", "hi": "दिए गए n धनात्मक पूर्णांक जो 1 से n तक प्रत्येक संख्या की गिनती का प्रतिनिधित्व करते हैं, \nउन संख्याओं से निर्मित अनुक्रम के सभी उपसर्गों के लिए मोड (सबसे अधिक बार आने वाला तत्व) का अधिकतम योग खोजें। \nमोड एक अनुक्रम में सबसे अधिक बार आने वाले तत्वों में सबसे बड़ा संख्या होता है।\n    >>> f_38(3, (int[]){1, 2, 3})\n    17\n    एक अनुक्रम जो अपने अधिकतम मान तक पहुँचता है वह है (3,2,3,1,2,2)।", "hu": "Adott n pozitív egész szám, amelyek az 1-től n-ig terjedő számok számosságát jelölik, \nkeresse meg az összes prefixum móduszának (leggyakoribb elemének) maximális összegét \negy ezekből a számokból felépített sorozat esetén. A módusz a legnagyobb szám a sorozat \nleggyakoribb elemei között.\n    >>> f_38(3, (int[]){1, 2, 3})\n    17\n    Egy sorozat, amely eléri a maximális értékét: (3,2,3,1,2,2).", "es": "Dado n enteros positivos que representan la cantidad de cada número de 1 a n, \nencuentra la suma máxima del modo (elemento más frecuente) para todos los prefijos de \nuna secuencia construida a partir de estos números. El modo es el número más grande entre \nlos elementos más frecuentes en una secuencia.\n    >>> f_38(3, (int[]){1, 2, 3})\n    17\n    Una secuencia que alcanza su valor máximo es (3,2,3,1,2,2).", "arb": "بالنظر إلى n من الأعداد الصحيحة الموجبة التي تمثل عدد كل رقم من 1 إلى n، \nابحث عن أكبر مجموع للوضع (العنصر الأكثر تكرارًا) لجميع البادئات في \nتسلسل مُنشأ من هذه الأرقام. الوضع هو أكبر رقم بين العناصر الأكثر تكرارًا في تسلسل.\n    >>> f_38(3, (int[]){1, 2, 3})\n    17\n    تسلسل يصل إلى قيمته القصوى هو (3,2,3,1,2,2).", "sw": "Ukitolewa n nambari chanya zinazowakilisha idadi ya kila nambari kutoka 1 hadi n, \ntafuta jumla ya juu zaidi ya modi (kipengele kinachojitokeza mara nyingi zaidi) kwa viambishi vyote vya \nmlolongo uliotengenezwa kutoka kwa nambari hizi. Modi ni nambari kubwa zaidi kati ya \nvipengele vinavyojitokeza mara nyingi zaidi katika mlolongo.\n    >>> f_38(3, (int[]){1, 2, 3})\n    17\n    Mlolongo unaofikia thamani yake ya juu zaidi ni (3,2,3,1,2,2).", "tr": "Verilen n pozitif tamsayı, 1'den n'ye kadar her sayının sayısını temsil eder, bu sayılardan oluşturulan bir dizinin tüm önekleri için modun (en sık görülen eleman) maksimum toplamını bulun. Mod, bir dizideki en sık görülen elemanlar arasında en büyük sayıdır.\n    >>> f_38(3, (int[]){1, 2, 3})\n    17\n    Maksimum değerine ulaşan bir dizi (3,2,3,1,2,2) şeklindedir.", "vi": "Được cung cấp n số nguyên dương đại diện cho số lượng của mỗi số từ 1 đến n, \ntìm tổng lớn nhất của mode (phần tử xuất hiện nhiều nhất) cho tất cả các tiền tố của \nmột dãy được tạo từ các số này. Mode là số lớn nhất trong số các phần tử xuất hiện nhiều nhất trong một dãy.\n    >>> f_38(3, (int[]){1, 2, 3})\n    17\n    Một dãy đạt giá trị tối đa của nó là (3,2,3,1,2,2).", "id": "Diberikan n bilangan bulat positif yang mewakili jumlah setiap angka dari 1 hingga n, \ntemukan jumlah maksimum dari modus (elemen yang paling sering muncul) untuk semua awalan dari \nsebuah urutan yang dibangun dari angka-angka ini. Modus adalah angka terbesar di antara \nelemen-elemen yang paling sering muncul dalam sebuah urutan.\n    >>> f_38(3, (int[]){1, 2, 3})\n    17\n    Sebuah urutan yang mencapai nilai maksimumnya adalah (3,2,3,1,2,2).", "ja": "与えられた n 個の正の整数は、1 から n までの各数のカウントを表します。これらの数から構成されるシーケンスのすべての接頭辞に対して、モード（最頻要素）の最大合計を見つけます。モードは、シーケンス内の最頻要素の中で最大の数です。\n    >>> f_38(3, (int[]){1, 2, 3})\n    17\n    最大値に達するシーケンスは (3,2,3,1,2,2) です。", "ko": "n개의 양의 정수가 1부터 n까지의 각 숫자의 개수를 나타낼 때, \n이 숫자들로 구성된 시퀀스의 모든 접두사의 최빈값(가장 빈번한 요소)의 최대 합을 찾습니다. \n최빈값은 시퀀스에서 가장 빈번한 요소 중 가장 큰 숫자입니다.\n    >>> f_38(3, (int[]){1, 2, 3})\n    17\n    최대값에 도달하는 시퀀스는 (3,2,3,1,2,2)입니다.", "ml": "1 മുതൽ n വരെ ഓരോ സംഖ്യയുടെ എണ്ണവും പ്രതിനിധീകരിക്കുന്ന n അനുകൂല സമ്പൂർണ്ണ സംഖ്യകൾ നൽകിയാൽ, \nഈ സംഖ്യകളിൽ നിന്ന് നിർമ്മിച്ച ഒരു ക്രമത്തിന്റെ എല്ലാ പ്രിഫിക്സുകളുടെയും മോഡ് (ഏറ്റവും അധികം ആവർത്തിക്കുന്ന ഘടകം) \nപരമാവധി തുക കണ്ടെത്തുക. ഒരു ക്രമത്തിലെ ഏറ്റവും അധികം ആവർത്തിക്കുന്ന ഘടകങ്ങളിൽ ഏറ്റവും വലിയ സംഖ്യയാണ് മോഡ്.\n    >>> f_38(3, (int[]){1, 2, 3})\n    17\n    പരമാവധി മൂല്യത്തിലെത്തുന്ന ഒരു ക്രമം (3,2,3,1,2,2) ആണ്.", "fa": "با توجه به n عدد صحیح مثبت که نشان‌دهنده تعداد هر عدد از 1 تا n هستند، \nبیشترین مجموع مد (عنصر پرتکرار) را برای تمام پیشوندهای \nیک دنباله ساخته شده از این اعداد پیدا کنید. مد بزرگترین عدد در میان \nعناصر پرتکرار در یک دنباله است.\n    >>> f_38(3, (int[]){1, 2, 3})\n    17\n    دنباله‌ای که به بیشترین مقدار خود می‌رسد (3,2,3,1,2,2) است."}}
{"task_id": "C/39", "prompt": {"en": "#include <assert.h>\n#include <stdio.h>\n/*\nGiven an array A of integers, the task is to calculate the sum of the XOR of all subarrays.\nA subarray is defined by a pair of indices (L, R) such that 1 <= L <= R <= n, where n is the size of the array.\nThe XOR sum of a subarray is the result of XORing all elements from L to R.\nThe final result is the sum of the XOR sums for all possible subarrays.\n\nExample cases:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39\n*/\nlong long f_39(int A[], int n)", "sq": "#include <assert.h>\n#include <stdio.h>\n/*\nDuke pasur një varg A të numrave të plotë, detyra është të llogaritet shuma e XOR-it të të gjitha nënvargjeve.\nNjë nënvarg përcaktohet nga një çift indeksesh (L, R) të tilla që 1 <= L <= R <= n, ku n është madhësia e vargut.\nShuma XOR e një nënvargu është rezultati i XOR-it të të gjithë elementeve nga L deri në R.\nRezultati përfundimtar është shuma e shumave XOR për të gjitha nënvargjet e mundshme.\n\nRastet e shembullit:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39\n*/\nlong long f_39(int A[], int n)", "hy": "#include <assert.h>\n#include <stdio.h>\n/*\nՈւնենալով ամբողջ թվերի զանգված A, խնդիրը հաշվարկել է բոլոր ենթազանգվածների XOR-ի գումարը:\nԵնթազանգվածը սահմանվում է (L, R) զույգ ինդեքսներով, այնպես որ 1 <= L <= R <= n, որտեղ n-ը զանգվածի չափն է:\nԵնթազանգվածի XOR-ի գումարը L-ից R բոլոր տարրերի XOR-ի արդյունքն է:\nՎերջնական արդյունքը բոլոր հնարավոր ենթազանգվածների XOR գումարների գումարն է:\n\nՕրինակ դեպքեր:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39\n*/\nlong long f_39(int A[], int n)", "bn": "#include <assert.h>\n#include <stdio.h>\n/*\nএকটি পূর্ণসংখ্যার অ্যারে A দেওয়া হয়েছে, কাজটি হল সমস্ত উপ-অ্যারের XOR এর যোগফল গণনা করা।\nএকটি উপ-অ্যারে (L, R) জোড়া দ্বারা সংজ্ঞায়িত করা হয় যেখানে 1 <= L <= R <= n, যেখানে n হল অ্যারের আকার।\nএকটি উপ-অ্যারের XOR যোগফল হল L থেকে R পর্যন্ত সমস্ত উপাদান XOR করার ফলাফল।\nচূড়ান্ত ফলাফল হল সমস্ত সম্ভাব্য উপ-অ্যারের জন্য XOR যোগফলের যোগফল।\n\nউদাহরণ কেস:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39\n*/\nlong long f_39(int A[], int n)", "bg": "#include <assert.h>\n#include <stdio.h>\n/*\nДаден е масив A от цели числа, задачата е да се изчисли сумата от XOR на всички подмасиви.\nПодмасив се дефинира чрез двойка индекси (L, R), така че 1 <= L <= R <= n, където n е размерът на масива.\nXOR сумата на подмасив е резултатът от XOR на всички елементи от L до R.\nКрайният резултат е сумата от XOR сумите за всички възможни подмасиви.\n\nПримерни случаи:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39\n*/\nlong long f_39(int A[], int n)", "zh": "#include <assert.h>\n#include <stdio.h>\n/*\n给定一个整数数组A，任务是计算所有子数组的异或和的总和。\n子数组由一对索引(L, R)定义，其中1 <= L <= R <= n，n是数组的大小。\n子数组的异或和是从L到R的所有元素的异或结果。\n最终结果是所有可能子数组的异或和的总和。\n\n示例案例:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39\n*/\nlong long f_39(int A[], int n)", "fr": "#include <assert.h>\n#include <stdio.h>\n/*\nÉtant donné un tableau A d'entiers, la tâche consiste à calculer la somme du XOR de tous les sous-tableaux.\nUn sous-tableau est défini par une paire d'indices (L, R) telle que 1 <= L <= R <= n, où n est la taille du tableau.\nLa somme XOR d'un sous-tableau est le résultat du XOR de tous les éléments de L à R.\nLe résultat final est la somme des sommes XOR pour tous les sous-tableaux possibles.\n\nExemples de cas :\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39\n*/\nlong long f_39(int A[], int n)", "de": "#include <assert.h>\n#include <stdio.h>\n/*\nGegeben ein Array A von ganzen Zahlen, besteht die Aufgabe darin, die Summe des XOR aller Teilarrays zu berechnen.\nEin Teilarray wird durch ein Paar von Indizes (L, R) definiert, so dass 1 <= L <= R <= n, wobei n die Größe des Arrays ist.\nDie XOR-Summe eines Teilarrays ist das Ergebnis des XORs aller Elemente von L bis R.\nDas Endergebnis ist die Summe der XOR-Summen für alle möglichen Teilarrays.\n\nBeispielhafte Fälle:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39\n*/\nlong long f_39(int A[], int n)", "ha": "#include <assert.h>\n#include <stdio.h>\n/*\nAn ba da wani tsari A na lambobin cikakke, aikin shi ne a ƙididdige jumlar XOR na dukkan ƙananan tsaruka.\nAna ayyana ƙaramin tsari ta hanyar ma'aurata na alamomin (L, R) inda 1 <= L <= R <= n, inda n shine girman tsari.\nJumlar XOR na ƙaramin tsari shine sakamakon XORing dukkan abubuwa daga L zuwa R.\nSakamakon ƙarshe shine jumlar XOR sums don dukkan yiwuwar ƙananan tsaruka.\n\nMisalan lokuta:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39\n*/\nlong long f_39(int A[], int n)", "hi": "#include <assert.h>\n#include <stdio.h>\n/*\nदिए गए पूर्णांकों के एक array A के लिए, कार्य सभी उप-समुच्चयों के XOR का योग गणना करना है।\nएक उप-समुच्चय को (L, R) युग्म द्वारा परिभाषित किया जाता है जहाँ 1 <= L <= R <= n, जहाँ n array का आकार है।\nएक उप-समुच्चय का XOR योग L से R तक के सभी तत्वों का XOR करने का परिणाम है।\nअंतिम परिणाम सभी संभावित उप-समुच्चयों के XOR योगों का योग है।\n\nउदाहरण मामले:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39\n*/\nlong long f_39(int A[], int n)", "hu": "#include <assert.h>\n#include <stdio.h>\n/*\nAdott egy A egész számokat tartalmazó tömb, a feladat az összes részhalmaz XOR összegének kiszámítása.\nEgy részhalmazt egy (L, R) indexpár határoz meg, ahol 1 <= L <= R <= n, ahol n a tömb mérete.\nEgy részhalmaz XOR összege az L-től R-ig terjedő összes elem XOR-olásának eredménye.\nA végső eredmény az összes lehetséges részhalmaz XOR összegeinek összege.\n\nPélda esetek:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39\n*/\nlong long f_39(int A[], int n)", "es": "#include <assert.h>\n#include <stdio.h>\n/*\nDado un array A de enteros, la tarea es calcular la suma del XOR de todos los subarrays.\nUn subarray se define por un par de índices (L, R) tal que 1 <= L <= R <= n, donde n es el tamaño del array.\nLa suma XOR de un subarray es el resultado de aplicar XOR a todos los elementos desde L hasta R.\nEl resultado final es la suma de las sumas XOR para todos los subarrays posibles.\n\nCasos de ejemplo:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39\n*/\nlong long f_39(int A[], int n)", "arb": "#include <assert.h>\n#include <stdio.h>\n/*\nبالنظر إلى مصفوفة A من الأعداد الصحيحة، المهمة هي حساب مجموع XOR لجميع المصفوفات الجزئية.\nيتم تعريف المصفوفة الجزئية بواسطة زوج من الفهارس (L, R) بحيث 1 <= L <= R <= n، حيث n هو حجم المصفوفة.\nمجموع XOR لمصفوفة جزئية هو نتيجة XOR لجميع العناصر من L إلى R.\nالنتيجة النهائية هي مجموع نتائج XOR لجميع المصفوفات الجزئية الممكنة.\n\nأمثلة على الحالات:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39\n*/\nlong long f_39(int A[], int n)", "sw": "#include <assert.h>\n#include <stdio.h>\n/*\nIkizingatiwa safu A ya nambari za mzima, kazi ni kuhesabu jumla ya XOR ya sehemu ndogo zote.\nSehemu ndogo inafafanuliwa na jozi ya fahirisi (L, R) ambapo 1 <= L <= R <= n, ambapo n ni ukubwa wa safu.\nJumla ya XOR ya sehemu ndogo ni matokeo ya XOR ya vipengele vyote kutoka L hadi R.\nMatokeo ya mwisho ni jumla ya jumla za XOR kwa sehemu ndogo zote zinazowezekana.\n\nMifano ya kesi:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39\n*/\nlong long f_39(int A[], int n)", "tr": "#include <assert.h>\n#include <stdio.h>\n/*\nBir tamsayı dizisi A verildiğinde, görev tüm alt dizilerin XOR toplamını hesaplamaktır.\nBir alt dizi, 1 <= L <= R <= n olan bir (L, R) indeks çifti ile tanımlanır, burada n dizinin boyutudur.\nBir alt dizinin XOR toplamı, L'den R'ye kadar olan tüm elemanların XOR işlemi sonucudur.\nSonuç, tüm olası alt dizilerin XOR toplamlarının toplamıdır.\n\nÖrnek durumlar:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39\n*/\nlong long f_39(int A[], int n)", "vi": "#include <assert.h>\n#include <stdio.h>\n/*\nCho một mảng A gồm các số nguyên, nhiệm vụ là tính tổng của XOR của tất cả các mảng con.\nMột mảng con được định nghĩa bởi một cặp chỉ số (L, R) sao cho 1 <= L <= R <= n, trong đó n là kích thước của mảng.\nTổng XOR của một mảng con là kết quả của việc XOR tất cả các phần tử từ L đến R.\nKết quả cuối cùng là tổng của các tổng XOR cho tất cả các mảng con có thể.\n\nCác trường hợp ví dụ:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39\n*/\nlong long f_39(int A[], int n)", "id": "#include <assert.h>\n#include <stdio.h>\n/*\nDiberikan sebuah array A dari bilangan bulat, tugasnya adalah menghitung jumlah dari XOR semua subarray.\nSebuah subarray didefinisikan oleh sepasang indeks (L, R) di mana 1 <= L <= R <= n, di mana n adalah ukuran array.\nJumlah XOR dari sebuah subarray adalah hasil dari XOR semua elemen dari L hingga R.\nHasil akhirnya adalah jumlah dari semua jumlah XOR untuk semua subarray yang mungkin.\n\nContoh kasus:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39\n*/\nlong long f_39(int A[], int n)", "ja": "#include <assert.h>\n#include <stdio.h>\n/*\n整数の配列Aが与えられたとき、すべての部分配列のXORの合計を計算することが課題です。\n部分配列は、1 <= L <= R <= n のように定義されるインデックスのペア (L, R) によって定義されます。ここで、nは配列のサイズです。\n部分配列のXORの合計は、LからRまでのすべての要素をXORした結果です。\n最終的な結果は、すべての可能な部分配列のXORの合計の合計です。\n\n例:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39\n*/\nlong long f_39(int A[], int n)", "ko": "#include <assert.h>\n#include <stdio.h>\n/*\n정수 배열 A가 주어졌을 때, 모든 부분 배열의 XOR 합을 계산하는 작업입니다.\n부분 배열은 인덱스 쌍 (L, R)에 의해 정의되며, 여기서 1 <= L <= R <= n이고, n은 배열의 크기입니다.\n부분 배열의 XOR 합은 L에서 R까지의 모든 요소를 XOR한 결과입니다.\n최종 결과는 가능한 모든 부분 배열의 XOR 합의 합입니다.\n\n예제 사례:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39\n*/\nlong long f_39(int A[], int n)", "ml": "#include <assert.h>\n#include <stdio.h>\n/*\nഒരു പൂർണ്ണസംഖ്യകളുടെ നിരയായ A നൽകിയിരിക്കുന്നപ്പോൾ, എല്ലാ ഉപനിരകളുടെയും XOR യുടെ മൊത്തം കണക്ക് ചെയ്യുക എന്നതാണ് പ്രവർത്തനം.\nഒരു ഉപനിര 1 <= L <= R <= n എന്നിങ്ങനെ 1 മുതൽ n വരെയുള്ള സൂചികകളാൽ നിർവചിക്കപ്പെട്ടിരിക്കുന്നു, ഇവിടെ n ആറേയുടെ വലിപ്പമാണ്.\nഒരു ഉപനിരയുടെ XOR മൊത്തം L മുതൽ R വരെയുള്ള എല്ലാ ഘടകങ്ങളുടെയും XOR ഫലമാണ്.\nഎല്ലാ സാധ്യതയുള്ള ഉപനിരകളുടെയും XOR മൊത്തങ്ങളുടെ മൊത്തം ഫലമാണ് അന്തിമ ഫലം.\n\nഉദാഹരണ കേസുകൾ:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39\n*/\nlong long f_39(int A[], int n)", "fa": "#include <assert.h>\n#include <stdio.h>\n/*\nبا توجه به یک آرایه A از اعداد صحیح، وظیفه این است که مجموع XOR تمام زیرآرایه‌ها را محاسبه کنید.\nیک زیرآرایه با یک جفت شاخص (L, R) تعریف می‌شود به طوری که 1 <= L <= R <= n، که n اندازه آرایه است.\nمجموع XOR یک زیرآرایه نتیجه‌ی XOR کردن تمام عناصر از L تا R است.\nنتیجه نهایی مجموع مقادیر XOR برای تمام زیرآرایه‌های ممکن است.\n\nنمونه موارد:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39\n*/\nlong long f_39(int A[], int n)"}, "canonical_solution": "{\n    long long q[100010] = {0}, w[100010][2] = {{0}}, ans = 0;\n    for (int i = 1; i <= n; i++) q[i] = q[i - 1] ^ A[i - 1];\n    for (int i = 0; i <= n; i++)\n        for (int j = 20; j >= 0; j--)\n            w[j][(q[i] >> j) & 1]++;\n    for (int i = 0; i <= 20; i++)\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    return ans;\n}", "instruction": {"en": "Write a C function `long long f_39(int A[], int n)` to solve the following problem:\nGiven an array A of integers, the task is to calculate the sum of the XOR of all subarrays.\nA subarray is defined by a pair of indices (L, R) such that 1 <= L <= R <= n, where n is the size of the array.\nThe XOR sum of a subarray is the result of XORing all elements from L to R.\nThe final result is the sum of the XOR sums for all possible subarrays.\n\nExample cases:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39\n", "sq": "Shkruani një funksion në C `long long f_39(int A[], int n)` për të zgjidhur problemin e mëposhtëm:\nDuke pasur një varg A me numra të plotë, detyra është të llogaritet shuma e XOR të të gjitha nënvargjeve.\nNjë nënvarg përcaktohet nga një çift indeksesh (L, R) të tilla që 1 <= L <= R <= n, ku n është madhësia e vargut.\nShuma XOR e një nënvargu është rezultati i XOR-it të të gjithë elementeve nga L në R.\nRezultati përfundimtar është shuma e shumave XOR për të gjitha nënvargjet e mundshme.\n\nShembuj rastesh:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "hy": "Գրեք C ֆունկցիա `long long f_39(int A[], int n)`՝ հետևյալ խնդիրը լուծելու համար:\nՏրված է ամբողջ թվերի A զանգված, խնդիրն է հաշվարկել բոլոր ենթազանգվածների XOR-ի գումարը:\nԵնթազանգվածը սահմանվում է (L, R) ինդեքսների զույգով, այնպես որ 1 <= L <= R <= n, որտեղ n-ը զանգվածի չափն է:\nԵնթազանգվածի XOR գումարը արդյունքն է, որը ստացվում է L-ից R բոլոր տարրերի XOR-ով:\nՎերջնական արդյունքը բոլոր հնարավոր ենթազանգվածների համար XOR գումարների գումարն է:\n\nՕրինակ դեպքեր:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "bn": "একটি C ফাংশন `long long f_39(int A[], int n)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি পূর্ণসংখ্যার অ্যারে A দেওয়া হয়েছে, কাজটি হল সমস্ত উপঅ্যারের XOR এর যোগফল গণনা করা।\nএকটি উপঅ্যারে একটি জোড়া সূচক (L, R) দ্বারা সংজ্ঞায়িত করা হয় যেখানে 1 <= L <= R <= n, যেখানে n হল অ্যারের আকার।\nএকটি উপঅ্যারের XOR যোগফল হল L থেকে R পর্যন্ত সমস্ত উপাদান XOR করার ফলাফল।\nচূড়ান্ত ফলাফল হল সমস্ত সম্ভাব্য উপঅ্যারের জন্য XOR যোগফলের যোগফল।\n\nউদাহরণ কেস:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "bg": "Напишете C функция `long long f_39(int A[], int n)`, за да решите следния проблем:\nДаден е масив A от цели числа, задачата е да се изчисли сумата от XOR на всички подмасиви.\nПодмасив се дефинира от двойка индекси (L, R), така че 1 <= L <= R <= n, където n е размерът на масива.\nXOR сумата на подмасив е резултатът от XOR на всички елементи от L до R.\nКрайният резултат е сумата от XOR сумите за всички възможни подмасиви.\n\nПримерни случаи:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "zh": "编写一个C函数 `long long f_39(int A[], int n)` 来解决以下问题：\n给定一个整数数组A，任务是计算所有子数组的异或和的总和。  \n子数组由一对索引(L, R)定义，其中1 <= L <= R <= n，n是数组的大小。  \n子数组的异或和是从L到R的所有元素进行异或运算的结果。  \n最终结果是所有可能子数组的异或和的总和。\n\n示例案例:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "fr": "Écrire une fonction C `long long f_39(int A[], int n)` pour résoudre le problème suivant :\nÉtant donné un tableau A d'entiers, la tâche consiste à calculer la somme du XOR de tous les sous-tableaux.  \nUn sous-tableau est défini par une paire d'indices (L, R) telle que 1 <= L <= R <= n, où n est la taille du tableau.  \nLa somme XOR d'un sous-tableau est le résultat du XOR de tous les éléments de L à R.  \nLe résultat final est la somme des sommes XOR pour tous les sous-tableaux possibles.\n\nCas d'exemple :\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "de": "Schreiben Sie eine C-Funktion `long long f_39(int A[], int n)`, um das folgende Problem zu lösen:\nGegeben ein Array A von ganzen Zahlen, besteht die Aufgabe darin, die Summe des XOR aller Teilarrays zu berechnen.\nEin Teilarray wird durch ein Paar von Indizes (L, R) definiert, so dass 1 <= L <= R <= n, wobei n die Größe des Arrays ist.\nDie XOR-Summe eines Teilarrays ist das Ergebnis des XOR aller Elemente von L bis R.\nDas Endergebnis ist die Summe der XOR-Summen für alle möglichen Teilarrays.\n\nBeispielhafte Fälle:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "ha": "Rubuta aikin C `long long f_39(int A[], int n)` don warware matsalar mai zuwa:\nAn ba da jerin A na lambobi, aikin shi ne a ƙididdige jimillar XOR na dukkan ƙananan jerin.  \nAna ayyana ƙaramar jeri ta hanyar ma'aurata na alamomi (L, R) inda 1 <= L <= R <= n, inda n shine girman jerin.  \nJimillar XOR na ƙaramar jeri shine sakamakon XORing dukkan abubuwa daga L zuwa R.  \nSakamakon ƙarshe shine jimillar XOR na dukkan yiwuwar ƙananan jerin.  \n\nMisalan lokuta:  \n    >>> f_39({1, 2, 3, 4, 5}, 5)  \n    39  ", "hi": "C फ़ंक्शन `long long f_39(int A[], int n)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए पूर्णांकों की एक array A के लिए, कार्य यह है कि सभी subarrays के XOR का योग गणना करें।\nएक subarray को (L, R) सूचकांक की एक जोड़ी द्वारा परिभाषित किया जाता है, जहाँ 1 <= L <= R <= n, जहाँ n array का आकार है।\nएक subarray का XOR योग L से R तक के सभी तत्वों का XOR करने का परिणाम है।\nअंतिम परिणाम सभी संभावित subarrays के लिए XOR योगों का योग है।\n\nउदाहरण मामले:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "hu": "Írj egy C függvényt `long long f_39(int A[], int n)` a következő probléma megoldására:\nAdott egy A egész számokat tartalmazó tömb, a feladat az összes részhalmaz XOR összegének kiszámítása.\nEgy részhalmazt egy (L, R) indexpár határoz meg, ahol 1 <= L <= R <= n, ahol n a tömb mérete.\nEgy részhalmaz XOR összege az L-től R-ig terjedő összes elem XOR-olásának eredménye.\nA végső eredmény az összes lehetséges részhalmaz XOR összegeinek összege.\n\nPélda esetek:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "es": "Escribe una función en C `long long f_39(int A[], int n)` para resolver el siguiente problema:\nDado un array A de enteros, la tarea es calcular la suma del XOR de todos los subarrays.\nUn subarray se define por un par de índices (L, R) tal que 1 <= L <= R <= n, donde n es el tamaño del array.\nLa suma XOR de un subarray es el resultado de aplicar XOR a todos los elementos desde L hasta R.\nEl resultado final es la suma de las sumas XOR para todos los subarrays posibles.\n\nCasos de ejemplo:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "arb": "اكتب دالة بلغة C `long long f_39(int A[], int n)` لحل المشكلة التالية:\nمعطى مصفوفة A من الأعداد الصحيحة، المهمة هي حساب مجموع XOR لجميع المصفوفات الفرعية.\nيتم تعريف المصفوفة الفرعية بواسطة زوج من الفهارس (L, R) بحيث 1 <= L <= R <= n، حيث n هو حجم المصفوفة.\nمجموع XOR للمصفوفة الفرعية هو نتيجة XOR لجميع العناصر من L إلى R.\nالنتيجة النهائية هي مجموع نتائج XOR لجميع المصفوفات الفرعية الممكنة.\n\nحالات المثال:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "sw": "Andika kazi ya C `long long f_39(int A[], int n)` kutatua tatizo lifuatalo:\nUkipiwa safu A ya nambari za mzima, kazi ni kuhesabu jumla ya XOR ya sehemu zote ndogo za safu.\nSehemu ndogo ya safu inafafanuliwa na jozi ya fahirisi (L, R) kama 1 <= L <= R <= n, ambapo n ni ukubwa wa safu.\nJumla ya XOR ya sehemu ndogo ya safu ni matokeo ya XOR ya vipengele vyote kutoka L hadi R.\nMatokeo ya mwisho ni jumla ya XOR za sehemu ndogo zote zinazowezekana.\n\nMifano ya kesi:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "tr": "Bir C fonksiyonu `long long f_39(int A[], int n)` yazın ve aşağıdaki problemi çözün:\nVerilen bir tamsayı dizisi A için, tüm alt dizilerin XOR toplamını hesaplama görevi.\nBir alt dizi, 1 <= L <= R <= n olacak şekilde bir (L, R) indeks çifti ile tanımlanır, burada n dizinin boyutudur.\nBir alt dizinin XOR toplamı, L'den R'ye kadar olan tüm elemanların XOR'lanması sonucudur.\nNihai sonuç, tüm olası alt diziler için XOR toplamlarının toplamıdır.\n\nÖrnek durumlar:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "vi": "Viết một hàm C `long long f_39(int A[], int n)` để giải quyết vấn đề sau:\nCho một mảng A gồm các số nguyên, nhiệm vụ là tính tổng của XOR của tất cả các mảng con.\nMột mảng con được định nghĩa bởi một cặp chỉ số (L, R) sao cho 1 <= L <= R <= n, trong đó n là kích thước của mảng.\nTổng XOR của một mảng con là kết quả của việc XOR tất cả các phần tử từ L đến R.\nKết quả cuối cùng là tổng của các tổng XOR cho tất cả các mảng con có thể.\n\nCác trường hợp ví dụ:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "id": "Tulis sebuah fungsi C `long long f_39(int A[], int n)` untuk menyelesaikan masalah berikut:\nDiberikan sebuah array A yang berisi bilangan bulat, tugasnya adalah menghitung jumlah dari XOR semua subarray.\nSebuah subarray didefinisikan oleh sepasang indeks (L, R) sehingga 1 <= L <= R <= n, di mana n adalah ukuran array.\nJumlah XOR dari sebuah subarray adalah hasil dari operasi XOR semua elemen dari L hingga R.\nHasil akhirnya adalah jumlah dari semua jumlah XOR untuk semua kemungkinan subarray.\n\nContoh kasus:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "ja": "Cの関数を書け `long long f_39(int A[], int n)` を作成して、次の問題を解決してください:\n整数の配列 A が与えられたとき、すべての部分配列の XOR の合計を計算するタスクです。\n部分配列は、1 <= L <= R <= n のようなインデックスのペア (L, R) によって定義されます。ここで、n は配列のサイズです。\n部分配列の XOR 合計は、L から R までのすべての要素を XOR した結果です。\n最終的な結果は、すべての可能な部分配列の XOR 合計の合計です。\n\n例:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "ko": "C 함수 `long long f_39(int A[], int n)`를 작성하여 다음 문제를 해결하십시오:\n정수 배열 A가 주어졌을 때, 모든 부분 배열의 XOR 합의 합계를 계산하는 작업입니다.\n부분 배열은 1 <= L <= R <= n인 인덱스 쌍 (L, R)에 의해 정의되며, 여기서 n은 배열의 크기입니다.\n부분 배열의 XOR 합은 L에서 R까지의 모든 요소를 XOR한 결과입니다.\n최종 결과는 가능한 모든 부분 배열에 대한 XOR 합의 합입니다.\n\n예제 사례:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "ml": "C ഫംഗ്ഷൻ `long long f_39(int A[], int n)` എഴുതുക താഴെ കൊടുത്തിരിക്കുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nഒരു പൂർണ്ണസംഖ്യകളുടെ നിര A നൽകിയിരിക്കുമ്പോൾ, എല്ലാ ഉപനിരകളുടെയും XOR യുടെ തുക കണക്കാക്കുക എന്നതാണ് പ്രവർത്തി.\nഒരു ഉപനിര (L, R) എന്ന സൂചികകളുടെ ഒരു ജോഡിയാൽ നിർവ്വചിക്കപ്പെട്ടിരിക്കുന്നു, 1 <= L <= R <= n, ഇവിടെ n നിരയുടെ വലുപ്പമാണ്.\nഒരു ഉപനിരയുടെ XOR തുക L മുതൽ R വരെ എല്ലാ ഘടകങ്ങളും XOR ചെയ്യുന്നതിന്റെ ഫലമാണ്.\nഎല്ലാ സാധ്യതയുള്ള ഉപനിരകളുടെയും XOR തുകകളുടെ തുകയാണ് അന്തിമ ഫലം.\n\nഉദാഹരണ കേസുകൾ:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "fa": "یک تابع C به نام `long long f_39(int A[], int n)` بنویسید تا مسئله‌ی زیر را حل کند:\nبا توجه به یک آرایه A از اعداد صحیح، وظیفه این است که مجموع XOR تمام زیرآرایه‌ها را محاسبه کنید.\nیک زیرآرایه با یک جفت اندیس (L, R) تعریف می‌شود به طوری که 1 <= L <= R <= n، که n اندازه آرایه است.\nمجموع XOR یک زیرآرایه نتیجه‌ی XOR کردن تمام عناصر از L تا R است.\nنتیجه نهایی مجموع مقادیر XOR برای تمام زیرآرایه‌های ممکن است.\n\nمثال‌ها:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39"}, "level": "middle", "test": "int main() {\n    int test[] = {1,2, 3, 4, 5};\n    assert(f_39(test, 5) == 39);\n    int test1[] = {1, 1, 1};\n    assert(f_39(test1, 3) == 4);\n    \n    int test2[] = {2, 3, 1};\n    assert(f_39(test2, 3) == 9);\n    \n    int test3[] = {4, 5, 7, 9};\n    assert(f_39(test3, 4) == 74);\n    \n    int test4[] = {0, 0, 0, 0};\n    assert(f_39(test4, 4) == 0);\n    \n    int test5[] = {8, 8, 8, 8, 8};\n    assert(f_39(test5, 5) == 72);\n    \n    int test6[] = {3, 6, 9, 12, 15};\n    assert(f_39(test6, 5) == 125);\n    \n    int test7[] = {10, 20, 30, 40, 50};\n    assert(f_39(test7, 5) == 390);\n    \n    int test8[] = {16, 16, 16, 16, 16, 16};\n    assert(f_39(test8, 6) == 192);\n    \n    int test9[] = {1, 3, 5, 7, 9, 11, 13};\n    assert(f_39(test9, 7) == 192);\n    \n    int test10[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n    assert(f_39(test10, 10) == 218);\n    \n    return 0;\n}", "entry_point": "f_39", "signature": "long long f_39(int A[], int n)", "docstring": {"en": "Given an array A of integers, the task is to calculate the sum of the XOR of all subarrays.\nA subarray is defined by a pair of indices (L, R) such that 1 <= L <= R <= n, where n is the size of the array.\nThe XOR sum of a subarray is the result of XORing all elements from L to R.\nThe final result is the sum of the XOR sums for all possible subarrays.\n\nExample cases:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39\n", "sq": "Duke pasur një varg A të numrave të plotë, detyra është të llogaritet shuma e XOR-it të të gjitha nënvargjeve. Një nënvarg përcaktohet nga një palë indeksesh (L, R) të tilla që 1 <= L <= R <= n, ku n është madhësia e vargut. Shuma XOR e një nënvargu është rezultati i XOR-it të të gjithë elementeve nga L në R. Rezultati përfundimtar është shuma e shumave XOR për të gjitha nënvargjet e mundshme.\n\nShembuj rastesh:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "hy": "Տրված է ամբողջ թվերի A զանգվածը, խնդիրը բոլոր ենթազանգվածների XOR-ի գումարը հաշվարկելն է:\nԵնթազանգվածը սահմանվում է (L, R) ինդեքսների զույգով, այնպես որ 1 <= L <= R <= n, որտեղ n-ը զանգվածի չափն է:\nԵնթազանգվածի XOR գումարը L-ից R բոլոր տարրերի XOR-ի արդյունքն է:\nՎերջնական արդյունքը բոլոր հնարավոր ենթազանգվածների XOR գումարների գումարն է:\n\nՕրինակ դեպքեր:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "bn": "ইন্টিজারগুলির একটি অ্যারে A দেওয়া হয়েছে, কাজটি হল সমস্ত সাবঅ্যারের XOR এর যোগফল গণনা করা। একটি সাবঅ্যারে একটি জোড়া সূচক (L, R) দ্বারা সংজ্ঞায়িত করা হয় যেটি 1 <= L <= R <= n, যেখানে n হল অ্যারের আকার। একটি সাবঅ্যারের XOR যোগফল হল L থেকে R পর্যন্ত সমস্ত উপাদানের XOR এর ফলাফল। চূড়ান্ত ফলাফল হল সমস্ত সম্ভাব্য সাবঅ্যারের জন্য XOR যোগফলের যোগফল।\n\nউদাহরণ কেস:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "bg": "Даден е масив A от цели числа, задачата е да се изчисли сумата на XOR на всички подмасиви. Подмасив се определя от двойка индекси (L, R) такива, че 1 <= L <= R <= n, където n е размерът на масива. XOR сумата на подмасив е резултатът от XOR на всички елементи от L до R. Крайният резултат е сумата на XOR сумите за всички възможни подмасиви.\n\nПримерни случаи:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "zh": "给定一个整数数组A，任务是计算所有子数组的异或和的总和。  \n子数组由一对索引(L, R)定义，其中1 <= L <= R <= n，n是数组的大小。  \n子数组的异或和是从L到R的所有元素的异或结果。  \n最终结果是所有可能子数组的异或和的总和。\n\n示例案例:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "fr": "Étant donné un tableau A d'entiers, la tâche consiste à calculer la somme du XOR de tous les sous-tableaux.  \nUn sous-tableau est défini par une paire d'indices (L, R) telle que 1 <= L <= R <= n, où n est la taille du tableau.  \nLa somme XOR d'un sous-tableau est le résultat du XOR de tous les éléments de L à R.  \nLe résultat final est la somme des sommes XOR pour tous les sous-tableaux possibles.\n\nCas d'exemple:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "de": "Gegeben ein Array A von ganzen Zahlen, besteht die Aufgabe darin, die Summe des XOR aller Teilarrays zu berechnen.\nEin Teilarray wird durch ein Paar von Indizes (L, R) definiert, so dass 1 <= L <= R <= n, wobei n die Größe des Arrays ist.\nDie XOR-Summe eines Teilarrays ist das Ergebnis des XOR aller Elemente von L bis R.\nDas Endergebnis ist die Summe der XOR-Summen für alle möglichen Teilarrays.\n\nBeispielhafte Fälle:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "ha": "An ba da jerin A na lambobin cikakkun lamba, aikin shi ne a ƙididdige jimillar XOR na dukkan ƙananan jerin.\nAna ayyana ƙaramin jeri ta hanyar ma'aurata na alamomi (L, R) inda 1 <= L <= R <= n, inda n shine girman jerin.\nJimillar XOR na ƙaramin jeri shine sakamakon XORing dukkan abubuwa daga L zuwa R.\nSakamakon ƙarshe shine jimillar XOR na dukkan yiwuwar ƙananan jerin.\n\nMisalan lokuta:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "hi": "दिए गए पूर्णांकों के एक array A के लिए, कार्य सभी उप-ऐरे के XOR का योग गणना करना है।\nएक उप-ऐरे को (L, R) सूचकांक की एक जोड़ी द्वारा परिभाषित किया जाता है, जहाँ 1 <= L <= R <= n, और n array का आकार है।\nएक उप-ऐरे का XOR योग L से R तक के सभी तत्वों का XOR करने का परिणाम है।\nअंतिम परिणाम सभी संभावित उप-ऐरे के XOR योगों का योग है।\n\nउदाहरण मामले:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "hu": "Egy egész számokat tartalmazó A tömb esetén a feladat az összes részarray XOR összegének kiszámítása.  \nEgy részarray-t egy (L, R) indexpár határoz meg, ahol 1 <= L <= R <= n, ahol n a tömb mérete.  \nEgy részarray XOR összege az L-től R-ig terjedő összes elem XOR-olásának eredménye.  \nA végső eredmény az összes lehetséges részarray XOR összegeinek az összege.\n\nPélda esetek:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "es": "Dado un array A de enteros, la tarea es calcular la suma del XOR de todos los subarrays.  \nUn subarray se define por un par de índices (L, R) tal que 1 <= L <= R <= n, donde n es el tamaño del array.  \nLa suma XOR de un subarray es el resultado de aplicar XOR a todos los elementos desde L hasta R.  \nEl resultado final es la suma de las sumas XOR para todos los subarrays posibles.\n\nCasos de ejemplo:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "arb": "معطى مصفوفة A من الأعداد الصحيحة، المهمة هي حساب مجموع XOR لجميع القطع الفرعية.\nيتم تعريف القطعة الفرعية بواسطة زوج من الفهارس (L, R) بحيث 1 <= L <= R <= n، حيث n هو حجم المصفوفة.\nمجموع XOR للقطعة الفرعية هو نتيجة XOR لجميع العناصر من L إلى R.\nالنتيجة النهائية هي مجموع مجموعات XOR لجميع القطع الفرعية الممكنة.\n\nأمثلة على الحالات:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "sw": "Kutolewa safu A ya nambari za mzima, kazi ni kuhesabu jumla ya XOR ya vipengele vidogo vyote.\nKipengele kidogo kinafafanuliwa na jozi ya fahirisi (L, R) ambapo 1 <= L <= R <= n, ambapo n ni ukubwa wa safu.\nJumla ya XOR ya kipengele kidogo ni matokeo ya XOR ya vipengele vyote kutoka L hadi R.\nMatokeo ya mwisho ni jumla ya jumla za XOR kwa vipengele vidogo vyote vinavyowezekana.\n\nMifano ya kesi:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "tr": "Verilen bir tamsayı dizisi A için görev, tüm alt dizilerin XOR toplamını hesaplamaktır. \nBir alt dizi, 1 <= L <= R <= n olacak şekilde bir (L, R) indeks çifti ile tanımlanır, burada n dizinin boyutudur. \nBir alt dizinin XOR toplamı, L'den R'ye kadar olan tüm elemanların XOR işlemi sonucudur. \nSonuç, tüm olası alt dizilerin XOR toplamlarının toplamıdır.\n\nÖrnek durumlar:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "vi": "Cho một mảng A gồm các số nguyên, nhiệm vụ là tính tổng của XOR của tất cả các mảng con.  \nMột mảng con được định nghĩa bởi một cặp chỉ số (L, R) sao cho 1 <= L <= R <= n, trong đó n là kích thước của mảng.  \nTổng XOR của một mảng con là kết quả của việc XOR tất cả các phần tử từ L đến R.  \nKết quả cuối cùng là tổng của các tổng XOR cho tất cả các mảng con có thể có.\n\nCác trường hợp ví dụ:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "id": "Diberikan sebuah array A yang berisi bilangan bulat, tugasnya adalah menghitung jumlah dari XOR semua subarray.  \nSebuah subarray didefinisikan oleh sepasang indeks (L, R) sehingga 1 <= L <= R <= n, di mana n adalah ukuran array.  \nJumlah XOR dari sebuah subarray adalah hasil dari XOR semua elemen dari L hingga R.  \nHasil akhirnya adalah jumlah dari semua jumlah XOR untuk semua subarray yang mungkin.  \n\nContoh kasus:  \n    >>> f_39({1, 2, 3, 4, 5}, 5)  \n    39  ", "ja": "整数の配列Aが与えられたとき、すべての部分配列のXORの合計を計算することが課題です。\n部分配列は、1 <= L <= R <= n というインデックスのペア (L, R) によって定義されます。ここで、n は配列のサイズです。\n部分配列のXORの合計は、LからRまでのすべての要素をXORした結果です。\n最終的な結果は、可能なすべての部分配列のXOR合計の合計です。\n\n例:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "ko": "주어진 정수 배열 A에 대해, 모든 부분 배열의 XOR 합을 계산하는 작업입니다.\n부분 배열은 인덱스 쌍 (L, R)에 의해 정의되며, 1 <= L <= R <= n, 여기서 n은 배열의 크기입니다.\n부분 배열의 XOR 합은 L에서 R까지의 모든 요소를 XOR한 결과입니다.\n최종 결과는 가능한 모든 부분 배열의 XOR 합의 합입니다.\n\n예제 사례:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "ml": "Integerകളുടെ ഒരു നിര A നൽകിയാൽ, എല്ലാ ഉപനിരകളുടെയും XOR യുടെ മൊത്തം കൂട്ടം കണക്കാക്കുകയാണ് ഈ പ്രവർത്തിയുടെ ലക്ഷ്യം. \nഒരു ഉപനിരയെ (L, R) എന്ന സൂചികകളുടെ ജോഡിയാൽ നിർവചിക്കുന്നു, 1 <= L <= R <= n, ഇവിടെ n ആണ് നിരയുടെ വലുപ്പം. \nഒരു ഉപനിരയുടെ XOR കൂട്ടം L മുതൽ R വരെയുള്ള എല്ലാ ഘടകങ്ങളുടെയും XOR ഫലമാണ്. \nഅവസാന ഫലം എല്ലാ സാധ്യതയുള്ള ഉപനിരകളുടെയും XOR കൂട്ടങ്ങളുടെ മൊത്തം കൂട്ടമാണ്.\n\nഉദാഹരണ കേസുകൾ:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "fa": "با توجه به آرایه A از اعداد صحیح، وظیفه محاسبه مجموع XOR تمام زیرآرایه‌ها است.  \nیک زیرآرایه با یک جفت اندیس (L, R) تعریف می‌شود به طوری که 1 <= L <= R <= n، که n اندازه آرایه است.  \nمجموع XOR یک زیرآرایه نتیجه‌ی XOR کردن تمام عناصر از L تا R است.  \nنتیجه نهایی، مجموع مقادیر XOR برای تمام زیرآرایه‌های ممکن است.\n\nموارد مثال:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39"}}
{"task_id": "C/40", "prompt": {"en": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n/*\nGiven two positive integers n and k, find the number of positive integers x, where 1 <= x <= n, that can be expressed as x = a^b with a and b being positive integers and b >= k.\nDifferent legal representations of the same number are counted only once.\n    >>> f_40(99, 1)\n    99\n*/\nint f_40(int n, int k)", "sq": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n/*\nDuke pasur dy numra të plotë pozitivë n dhe k, gjeni numrin e numrave të plotë pozitivë x, ku 1 <= x <= n, që mund të shprehen si x = a^b me a dhe b që janë numra të plotë pozitivë dhe b >= k.\nPërfaqësimet e ndryshme të ligjshme të të njëjtit numër numërohen vetëm një herë.\n    >>> f_40(99, 1)\n    99\n*/\nint f_40(int n, int k)", "hy": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n/*\nՏրված է երկու դրական ամբողջ թիվ n և k, գտնել դրական ամբողջ թվերի x քանակը, որտեղ 1 <= x <= n, որոնք կարող են արտահայտվել որպես x = a^b, որտեղ a և b դրական ամբողջ թվեր են և b >= k:\nՆույն թվի տարբեր օրինական ներկայացումները հաշվում են միայն մեկ անգամ:\n    >>> f_40(99, 1)\n    99\n*/\nint f_40(int n, int k)", "bn": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n/*\nদুটি ধনাত্মক পূর্ণসংখ্যা n এবং k দেওয়া আছে, ধনাত্মক পূর্ণসংখ্যা x-এর সংখ্যা খুঁজে বের করুন, যেখানে 1 <= x <= n, যা x = a^b হিসাবে প্রকাশ করা যায় যেখানে a এবং b ধনাত্মক পূর্ণসংখ্যা এবং b >= k।\nএকই সংখ্যার বিভিন্ন বৈধ উপস্থাপনাকে শুধুমাত্র একবার গণনা করা হয়।\n    >>> f_40(99, 1)\n    99\n*/\nint f_40(int n, int k)", "bg": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n/*\nДадени са две положителни цели числа n и k, намерете броя на положителните цели числа x, където 1 <= x <= n, които могат да бъдат изразени като x = a^b с a и b, които са положителни цели числа и b >= k.\nРазличните легални представяния на едно и също число се броят само веднъж.\n    >>> f_40(99, 1)\n    99\n*/\nint f_40(int n, int k)", "zh": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n/*\n给定两个正整数 n 和 k，找出有多少个正整数 x，其中 1 <= x <= n，可以表示为 x = a^b，a 和 b 是正整数且 b >= k。\n同一个数字的不同合法表示只计数一次。\n    >>> f_40(99, 1)\n    99\n*/\nint f_40(int n, int k)", "fr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n/*\nÉtant donné deux entiers positifs n et k, trouvez le nombre d'entiers positifs x, où 1 <= x <= n, qui peuvent être exprimés comme x = a^b avec a et b étant des entiers positifs et b >= k.\nDifférentes représentations légales du même nombre sont comptées une seule fois.\n    >>> f_40(99, 1)\n    99\n*/\nint f_40(int n, int k)", "de": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n/*\nGegeben zwei positive ganze Zahlen n und k, finde die Anzahl der positiven ganzen Zahlen x, wobei 1 <= x <= n, die als x = a^b ausgedrückt werden können, wobei a und b positive ganze Zahlen sind und b >= k.\nVerschiedene zulässige Darstellungen derselben Zahl werden nur einmal gezählt.\n    >>> f_40(99, 1)\n    99\n*/\nint f_40(int n, int k)", "ha": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n/*\nAn ba lambobi masu kyau guda biyu n da k, nemo yawan lambobi masu kyau x, inda 1 <= x <= n, waɗanda za a iya bayyana su a matsayin x = a^b tare da a da b suna kasancewa lambobi masu kyau kuma b >= k.\nDaban-daban bayyanar doka na lamba ɗaya ana ƙidaya su sau ɗaya kawai.\n    >>> f_40(99, 1)\n    99\n*/\nint f_40(int n, int k)", "hi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n/*\nदो धनात्मक पूर्णांक n और k दिए गए हैं, उन धनात्मक पूर्णांकों x की संख्या ज्ञात करें, जहाँ 1 <= x <= n, जिन्हें x = a^b के रूप में व्यक्त किया जा सकता है जहाँ a और b धनात्मक पूर्णांक हैं और b >= k है।\nएक ही संख्या के विभिन्न वैध अभ्यावेदन केवल एक बार गिने जाते हैं।\n    >>> f_40(99, 1)\n    99\n*/\nint f_40(int n, int k)", "hu": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n/*\nKét pozitív egész szám, n és k adott. Találjuk meg azon pozitív egész számok x számát, ahol 1 <= x <= n, amelyek kifejezhetők x = a^b alakban, ahol a és b pozitív egész számok és b >= k.\nUgyanazon szám különböző érvényes ábrázolásai csak egyszer számítanak.\n    >>> f_40(99, 1)\n    99\n*/\nint f_40(int n, int k)", "es": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n/*\nDado dos enteros positivos n y k, encuentra el número de enteros positivos x, donde 1 <= x <= n, que pueden expresarse como x = a^b con a y b siendo enteros positivos y b >= k.\nDiferentes representaciones legales del mismo número se cuentan solo una vez.\n    >>> f_40(99, 1)\n    99\n*/\nint f_40(int n, int k)", "arb": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n/*\nمعطى عددين صحيحين موجبين n و k، أوجد عدد الأعداد الصحيحة الموجبة x، حيث 1 <= x <= n، والتي يمكن التعبير عنها كـ x = a^b مع كون a و b أعداد صحيحة موجبة و b >= k.\nيتم احتساب التمثيلات القانونية المختلفة لنفس الرقم مرة واحدة فقط.\n    >>> f_40(99, 1)\n    99\n*/\nint f_40(int n, int k)", "sw": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n/*\nUkipiwa nambari mbili nzima chanya n na k, tafuta idadi ya nambari chanya x, ambapo 1 <= x <= n, ambazo zinaweza kuonyeshwa kama x = a^b huku a na b wakiwa nambari nzima chanya na b >= k.\nUwiano tofauti halali wa nambari sawa huhesabiwa mara moja tu.\n    >>> f_40(99, 1)\n    99\n*/\nint f_40(int n, int k)", "tr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n/*\nVerilen iki pozitif tamsayı n ve k için, 1 <= x <= n aralığında, x = a^b şeklinde ifade edilebilen pozitif tamsayı x sayısını bulun, burada a ve b pozitif tamsayılardır ve b >= k.\nAynı sayının farklı yasal temsilleri yalnızca bir kez sayılır.\n    >>> f_40(99, 1)\n    99\n*/\nint f_40(int n, int k)", "vi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n/*\nCho hai số nguyên dương n và k, tìm số lượng số nguyên dương x, với 1 <= x <= n, có thể được biểu diễn dưới dạng x = a^b với a và b là các số nguyên dương và b >= k.\nCác biểu diễn hợp lệ khác nhau của cùng một số chỉ được đếm một lần.\n    >>> f_40(99, 1)\n    99\n*/\nint f_40(int n, int k)", "id": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n/*\nDiberikan dua bilangan bulat positif n dan k, temukan jumlah bilangan bulat positif x, di mana 1 <= x <= n, yang dapat dinyatakan sebagai x = a^b dengan a dan b adalah bilangan bulat positif dan b >= k.\nRepresentasi legal yang berbeda dari angka yang sama dihitung hanya sekali.\n    >>> f_40(99, 1)\n    99\n*/\nint f_40(int n, int k)", "ja": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n/*\n2つの正の整数nとkが与えられたとき、1 <= x <= nの範囲で、x = a^bとして表現できる正の整数xの数を求めます。ただし、aとbは正の整数であり、b >= kです。\n同じ数の異なる合法的な表現は一度だけカウントされます。\n    >>> f_40(99, 1)\n    99\n*/\nint f_40(int n, int k)", "ko": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n/*\n두 개의 양의 정수 n과 k가 주어졌을 때, 1 <= x <= n 범위의 양의 정수 x 중에서 x = a^b로 표현될 수 있는 수의 개수를 찾으시오. 여기서 a와 b는 양의 정수이고 b >= k입니다.\n같은 수의 다른 합법적인 표현은 한 번만 계산됩니다.\n    >>> f_40(99, 1)\n    99\n*/\nint f_40(int n, int k)", "ml": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n/*\nരണ്ട് പോസിറ്റീവ് പൂർണ്ണസംഖ്യകൾ n, k എന്നിവ നൽകിയാൽ, 1 <= x <= n എന്നിടത്ത്, x = a^b എന്ന രൂപത്തിൽ പ്രകടിപ്പിക്കാവുന്ന പോസിറ്റീവ് പൂർണ്ണസംഖ്യകളുടെ എണ്ണം കണ്ടെത്തുക, ഇവിടെ a, b എന്നിവ പോസിറ്റീവ് പൂർണ്ണസംഖ്യകളാണ്, b >= k.\nഅതേ സംഖ്യയുടെ വ്യത്യസ്ത നിയമാനുസൃതമായ പ്രതിനിധാനങ്ങൾ ഒരിക്കൽ മാത്രമേ എണ്ണപ്പെടുകയുള്ളൂ.\n    >>> f_40(99, 1)\n    99\n*/\nint f_40(int n, int k)", "fa": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n/*\nبا داشتن دو عدد صحیح مثبت n و k، تعداد اعداد صحیح مثبت x را بیابید، به طوری که 1 <= x <= n، که می‌توان آن را به صورت x = a^b بیان کرد که a و b اعداد صحیح مثبت هستند و b >= k.\nنمایش‌های قانونی مختلف از یک عدد مشابه فقط یک بار شمارش می‌شوند.\n    >>> f_40(99, 1)\n    99\n*/\nint f_40(int n, int k)"}, "canonical_solution": "{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += (int)sqrt(n) - x;\n    }\n    free(mp);\n    return count;\n}", "instruction": {"en": "Write a C function `int f_40(int n, int k)` to solve the following problem:\nGiven two positive integers n and k, find the number of positive integers x, where 1 <= x <= n, that can be expressed as x = a^b with a and b being positive integers and b >= k.\nDifferent legal representations of the same number are counted only once.\n    >>> f_40(99, 1)\n    99\n", "sq": "Shkruani një funksion në C `int f_40(int n, int k)` për të zgjidhur problemin e mëposhtëm:\nDuke pasur dy numra të plotë pozitivë n dhe k, gjeni numrin e numrave të plotë pozitivë x, ku 1 <= x <= n, që mund të shprehen si x = a^b me a dhe b që janë numra të plotë pozitivë dhe b >= k.  \nPërfaqësimet e ndryshme të ligjshme të të njëjtit numër numërohen vetëm një herë.  \n    >>> f_40(99, 1)  \n    99  ", "hy": "Գրեք C ֆունկցիա `int f_40(int n, int k)` հետևյալ խնդիրը լուծելու համար:\nՏրված են n և k դրական ամբողջ թվերը, գտնել այն դրական ամբողջ թվերի քանակը x, որտեղ 1 <= x <= n, որոնք կարող են արտահայտվել որպես x = a^b, որտեղ a և b դրական ամբողջ թվեր են և b >= k:\nՆույն թվի տարբեր թույլատրելի ներկայացումները հաշվում են միայն մեկ անգամ:", "bn": "একটি C ফাংশন `int f_40(int n, int k)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nদুটি ধনাত্মক পূর্ণসংখ্যা n এবং k দেওয়া আছে, 1 <= x <= n এর মধ্যে কতগুলি ধনাত্মক পূর্ণসংখ্যা x আছে তা খুঁজে বের করুন, যা x = a^b হিসাবে প্রকাশ করা যায় যেখানে a এবং b ধনাত্মক পূর্ণসংখ্যা এবং b >= k।\nএকই সংখ্যার বিভিন্ন বৈধ উপস্থাপনাগুলি কেবল একবার গণনা করা হয়।\n    >>> f_40(99, 1)\n    99", "bg": "Напишете C функция `int f_40(int n, int k)`, за да решите следния проблем:\nДадени са две положителни цели числа n и k, намерете броя на положителните цели числа x, където 1 <= x <= n, които могат да бъдат изразени като x = a^b, като a и b са положителни цели числа и b >= k.  \nРазличните легални представяния на едно и също число се броят само веднъж.", "zh": "编写一个 C 函数 `int f_40(int n, int k)` 来解决以下问题：\n给定两个正整数 n 和 k，找到满足 1 <= x <= n 的正整数 x 的数量，使得 x 可以表示为 x = a^b，其中 a 和 b 为正整数且 b >= k。  \n同一个数字的不同合法表示只计算一次。  \n    >>> f_40(99, 1)  \n    99  ", "fr": "Écrire une fonction C `int f_40(int n, int k)` pour résoudre le problème suivant:\nÉtant donné deux entiers positifs n et k, trouver le nombre d'entiers positifs x, où 1 <= x <= n, qui peuvent être exprimés comme x = a^b avec a et b étant des entiers positifs et b >= k.  \nDifférentes représentations légales du même nombre sont comptées une seule fois.  \n    >>> f_40(99, 1)  \n    99  ", "de": "Schreiben Sie eine C-Funktion `int f_40(int n, int k)`, um das folgende Problem zu lösen:\nGegeben sind zwei positive ganze Zahlen n und k. Finden Sie die Anzahl der positiven ganzen Zahlen x, wobei 1 <= x <= n, die als x = a^b ausgedrückt werden können, wobei a und b positive ganze Zahlen sind und b >= k.\nVerschiedene zulässige Darstellungen derselben Zahl werden nur einmal gezählt.", "ha": "Rubuta aikin C `int f_40(int n, int k)` don warware matsalar mai zuwa:\nAn ba da lambobi biyu masu kyau n da k, nemo adadin lambobin da suka dace x, inda 1 <= x <= n, wanda za a iya bayyana shi a matsayin x = a^b tare da a da b suna kasancewa lambobi masu kyau kuma b >= k.\nAna ƙidaya wakilci daban-daban na doka na lamba ɗaya sau ɗaya kawai.", "hi": "C फ़ंक्शन `int f_40(int n, int k)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए दो धनात्मक पूर्णांक n और k, ऐसे धनात्मक पूर्णांकों x की संख्या खोजें, जहाँ 1 <= x <= n, जिसे x = a^b के रूप में व्यक्त किया जा सकता है, जहाँ a और b धनात्मक पूर्णांक हैं और b >= k है।\nएक ही संख्या के विभिन्न वैध अभ्यावेदन को केवल एक बार गिना जाता है।", "hu": "Írj egy C függvényt `int f_40(int n, int k)` a következő probléma megoldására:\nAdott két pozitív egész szám, n és k, találd meg azon pozitív egész számok x számát, ahol 1 <= x <= n, amelyek kifejezhetők x = a^b alakban, ahol a és b pozitív egész számok és b >= k.\nUgyanazon szám különböző legális ábrázolásai csak egyszer számítanak.\n    >>> f_40(99, 1)\n    99", "es": "Escribe una función en C `int f_40(int n, int k)` para resolver el siguiente problema:\nDado dos enteros positivos n y k, encuentra el número de enteros positivos x, donde 1 <= x <= n, que pueden expresarse como x = a^b con a y b siendo enteros positivos y b >= k.\nDiferentes representaciones legales del mismo número se cuentan solo una vez.\n    >>> f_40(99, 1)\n    99", "arb": "اكتب دالة C `int f_40(int n, int k)` لحل المشكلة التالية:\nمعطى عددين صحيحين موجبين n و k، أوجد عدد الأعداد الصحيحة الموجبة x، حيث 1 <= x <= n، التي يمكن التعبير عنها كـ x = a^b حيث a و b هما عددان صحيحان موجبان و b >= k.  \nيتم احتساب التمثيلات القانونية المختلفة لنفس الرقم مرة واحدة فقط.  \n    >>> f_40(99, 1)  \n    99  ", "sw": "Andika kazi ya C `int f_40(int n, int k)` kutatua tatizo lifuatalo:\nUkipewa nambari mbili chanya n na k, tafuta idadi ya nambari chanya x, ambapo 1 <= x <= n, ambazo zinaweza kuonyeshwa kama x = a^b huku a na b wakiwa nambari chanya na b >= k.\nUwakilishi tofauti wa kisheria wa nambari sawa unahesabiwa mara moja tu.\n    >>> f_40(99, 1)\n    99", "tr": "Bir C fonksiyonu `int f_40(int n, int k)` yazın ve aşağıdaki problemi çözün:\nVerilen iki pozitif tam sayı n ve k ile, 1 <= x <= n aralığında, x = a^b şeklinde ifade edilebilen pozitif tam sayı x'lerin sayısını bulun. Burada a ve b pozitif tam sayılar ve b >= k.\nAynı sayının farklı yasal gösterimleri yalnızca bir kez sayılır.\n    >>> f_40(99, 1)\n    99", "vi": "Viết một hàm C `int f_40(int n, int k)` để giải quyết vấn đề sau:\nCho hai số nguyên dương n và k, tìm số lượng số nguyên dương x, với 1 <= x <= n, có thể được biểu diễn dưới dạng x = a^b với a và b là các số nguyên dương và b >= k.  \nCác biểu diễn hợp lệ khác nhau của cùng một số chỉ được đếm một lần.  \n    >>> f_40(99, 1)  \n    99  ", "id": "Tulis sebuah fungsi C `int f_40(int n, int k)` untuk menyelesaikan masalah berikut:\nDiberikan dua bilangan bulat positif n dan k, temukan jumlah bilangan bulat positif x, di mana 1 <= x <= n, yang dapat dinyatakan sebagai x = a^b dengan a dan b adalah bilangan bulat positif dan b >= k.\nRepresentasi legal yang berbeda dari angka yang sama hanya dihitung sekali.\n    >>> f_40(99, 1)\n    99", "ja": "Cの関数を書け `int f_40(int n, int k)` を作成して、次の問題を解決してください:\n2つの正の整数 n と k が与えられたとき、1 <= x <= n の範囲で、x = a^b として表現できる正の整数 x の数を求めます。ただし、a と b は正の整数であり、b >= k です。\n同じ数の異なる合法的な表現は1回だけカウントされます。\n    >>> f_40(99, 1)\n    99", "ko": "C 함수 `int f_40(int n, int k)`를 작성하여 다음 문제를 해결하십시오:\n두 개의 양의 정수 n과 k가 주어졌을 때, 1 <= x <= n 범위의 양의 정수 x 중에서 x = a^b로 표현될 수 있는 수의 개수를 찾으십시오. 여기서 a와 b는 양의 정수이며 b >= k입니다.\n같은 수의 다른 합법적인 표현은 한 번만 계산됩니다.\n    >>> f_40(99, 1)\n    99", "ml": "C ഫംഗ്ഷൻ `int f_40(int n, int k)` എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nരണ്ട് പോസിറ്റീവ് പൂർണ്ണസംഖ്യകൾ n, k നൽകിയാൽ, 1 <= x <= n എന്ന വ്യവസ്ഥയിൽ, x = a^b എന്ന രൂപത്തിൽ രേഖപ്പെടുത്താവുന്ന പോസിറ്റീവ് പൂർണ്ണസംഖ്യകളുടെ എണ്ണം കണ്ടെത്തുക, ഇവിടെ a, b പോസിറ്റീവ് പൂർണ്ണസംഖ്യകളാണ്, കൂടാതെ b >= k. ഒരേ സംഖ്യയുടെ വ്യത്യസ്തമായ നിയമപരമായ പ്രതിനിധാനങ്ങൾ ഒരിക്കൽ മാത്രം എണ്ണപ്പെടും.\n    >>> f_40(99, 1)\n    99", "fa": "یک تابع C به نام `int f_40(int n, int k)` بنویسید تا مسئله زیر را حل کند:\nبا داشتن دو عدد صحیح مثبت n و k، تعداد اعداد صحیح مثبت x را پیدا کنید، به طوری که 1 <= x <= n و بتوان آن را به صورت x = a^b با a و b به عنوان اعداد صحیح مثبت و b >= k بیان کرد.\nنمایش‌های قانونی مختلف از یک عدد مشابه فقط یک بار شمارش می‌شوند.\n    >>> f_40(99, 1)\n    99"}, "level": "hard", "test": "int main() {\n    assert(f_40(99, 1) == 99);\n    assert(f_40(99, 3) == 7);\n    assert(f_40(99, 2) == 12);\n    assert(f_40(10, 1) == 10);\n    assert(f_40(10, 2) == 4);\n    assert(f_40(500, 1) == 500);\n    assert(f_40(500, 2) == 30);\n    assert(f_40(500, 3) == 13);\n    assert(f_40(1000, 1) == 1000);\n    assert(f_40(1000, 2) == 41);\n    assert(f_40(1000, 3) == 17);\n    assert(f_40(1000, 93) == 1);\n    assert(f_40(50, 2) == 10);\n    assert(f_40(50, 3) == 5);\n    assert(f_40(2, 3) == 1);\n    return 0;\n}", "entry_point": "f_40", "signature": "int f_40(int n, int k)", "docstring": {"en": "Given two positive integers n and k, find the number of positive integers x, where 1 <= x <= n, that can be expressed as x = a^b with a and b being positive integers and b >= k.\nDifferent legal representations of the same number are counted only once.\n    >>> f_40(99, 1)\n    99\n", "sq": "Duke pasur dy numra të plotë pozitivë n dhe k, gjeni numrin e numrave të plotë pozitivë x, ku 1 <= x <= n, që mund të shprehen si x = a^b me a dhe b që janë numra të plotë pozitivë dhe b >= k.\nPërfaqësimet e ndryshme të ligjshme të të njëjtit numër numërohen vetëm një herë.\n    >>> f_40(99, 1)\n    99", "hy": "Երկու դրական ամբողջ թիվ n և k ունենալով, գտնել դրական ամբողջ թվերի x քանակը, որտեղ 1 <= x <= n, որոնք կարող են արտահայտվել որպես x = a^b, որտեղ a և b դրական ամբողջ թվեր են և b >= k:\nՆույն թվի տարբեր թույլատրելի ներկայացումները հաշվում են միայն մեկ անգամ:\n    >>> f_40(99, 1)\n    99", "bn": "দুটি ধনাত্মক পূর্ণসংখ্যা n এবং k দেওয়া আছে, 1 <= x <= n শর্তে কতগুলি ধনাত্মক পূর্ণসংখ্যা x পাওয়া যাবে তা খুঁজে বের করুন, যা x = a^b আকারে প্রকাশ করা যায় যেখানে a এবং b ধনাত্মক পূর্ণসংখ্যা এবং b >= k। একই সংখ্যার বিভিন্ন বৈধ উপস্থাপনাকে কেবল একবারই গণনা করা হয়।\n    >>> f_40(99, 1)\n    99", "bg": "Дадени са две положителни цели числа n и k, намерете броя на положителните цели числа x, където 1 <= x <= n, които могат да бъдат изразени като x = a^b с a и b като положителни цели числа и b >= k. Различните легални представяния на едно и също число се броят само веднъж.\n    >>> f_40(99, 1)\n    99", "zh": "给定两个正整数 n 和 k，找出有多少个正整数 x，其中 1 <= x <= n，可以表示为 x = a^b，其中 a 和 b 是正整数且 b >= k。\n相同数字的不同合法表示仅计数一次。\n    >>> f_40(99, 1)\n    99", "fr": "Étant donnés deux entiers positifs n et k, trouvez le nombre d'entiers positifs x, où 1 <= x <= n, qui peuvent être exprimés comme x = a^b avec a et b étant des entiers positifs et b >= k.\nLes différentes représentations légales du même nombre sont comptées une seule fois.\n    >>> f_40(99, 1)\n    99", "de": "Gegeben zwei positive ganze Zahlen n und k, finde die Anzahl der positiven ganzen Zahlen x, wobei 1 <= x <= n, die als x = a^b ausgedrückt werden können, wobei a und b positive ganze Zahlen sind und b >= k.\nVerschiedene gültige Darstellungen derselben Zahl werden nur einmal gezählt.\n    >>> f_40(99, 1)\n    99", "ha": "An ba lambobi masu kyau guda biyu n da k, nemo adadin lambobi masu kyau x, inda 1 <= x <= n, waɗanda za a iya bayyana su a matsayin x = a^b tare da a da b suna kasancewa lambobi masu kyau kuma b >= k. Ana ƙidaya wakilcin doka daban-daban na lamba ɗaya sau ɗaya kawai.\n    >>> f_40(99, 1)\n    99", "hi": "दो सकारात्मक पूर्णांक n और k दिए गए हैं, उन सकारात्मक पूर्णांकों x की संख्या खोजें, जहाँ 1 <= x <= n, जिन्हें x = a^b के रूप में व्यक्त किया जा सकता है, जहाँ a और b सकारात्मक पूर्णांक हैं और b >= k है। एक ही संख्या के विभिन्न वैध अभ्यावेदन को केवल एक बार गिना जाता है।\n    >>> f_40(99, 1)\n    99", "hu": "Két pozitív egész szám, n és k esetén találjuk meg azon pozitív egész számok x számát, ahol 1 <= x <= n, és amelyek kifejezhetők x = a^b alakban, ahol a és b pozitív egész számok, és b >= k. Ugyanazon szám különböző jogszerű ábrázolásai csak egyszer számítanak.\n    >>> f_40(99, 1)\n    99", "es": "Dado dos enteros positivos n y k, encuentra el número de enteros positivos x, donde 1 <= x <= n, que pueden expresarse como x = a^b con a y b siendo enteros positivos y b >= k.\nDiferentes representaciones legales del mismo número se cuentan solo una vez.\n    >>> f_40(99, 1)\n    99", "arb": "معطى عددان صحيحان موجبان n و k، ابحث عن عدد الأعداد الصحيحة الموجبة x، حيث 1 <= x <= n، التي يمكن التعبير عنها كـ x = a^b مع كون a و b أعداد صحيحة موجبة و b >= k. يتم احتساب التمثيلات القانونية المختلفة لنفس الرقم مرة واحدة فقط.\n    >>> f_40(99, 1)\n    99", "sw": "Kwa kupewa nambari mbili nzima chanya n na k, pata idadi ya nambari chanya x, ambapo 1 <= x <= n, ambazo zinaweza kuonyeshwa kama x = a^b huku a na b zikiwa nambari nzima chanya na b >= k. \nMwakilishi tofauti halali wa nambari ile ile unahesabiwa mara moja tu.\n    >>> f_40(99, 1)\n    99", "tr": "Verilen iki pozitif tamsayı n ve k için, 1 <= x <= n olacak şekilde, x = a^b şeklinde ifade edilebilen pozitif tamsayı x'lerin sayısını bulun. Burada a ve b pozitif tamsayılar ve b >= k olmalıdır. Aynı sayının farklı yasal gösterimleri yalnızca bir kez sayılır.\n    >>> f_40(99, 1)\n    99", "vi": "Cho hai số nguyên dương n và k, tìm số lượng số nguyên dương x, với 1 <= x <= n, có thể được biểu diễn dưới dạng x = a^b với a và b là các số nguyên dương và b >= k. Các biểu diễn hợp lệ khác nhau của cùng một số chỉ được đếm một lần.\n    >>> f_40(99, 1)\n    99", "id": "Diberikan dua bilangan bulat positif n dan k, temukan jumlah bilangan bulat positif x, di mana 1 <= x <= n, yang dapat dinyatakan sebagai x = a^b dengan a dan b adalah bilangan bulat positif dan b >= k. Representasi legal yang berbeda dari angka yang sama hanya dihitung sekali.\n    >>> f_40(99, 1)\n    99", "ja": "2つの正の整数 n と k が与えられたとき、1 <= x <= n の範囲で、x = a^b と表現できる正の整数 x の数を求めます。ただし、a と b は正の整数であり、b >= k です。\n同じ数の異なる合法的な表現は一度だけカウントされます。\n    >>> f_40(99, 1)\n    99", "ko": "두 개의 양의 정수 n과 k가 주어졌을 때, 1 <= x <= n 범위 내의 양의 정수 x 중에서 x = a^b로 표현될 수 있는 수의 개수를 찾으시오. 여기서 a와 b는 양의 정수이며 b >= k입니다. 같은 수에 대한 서로 다른 합법적인 표현은 한 번만 계산됩니다.\n    >>> f_40(99, 1)\n    99", "ml": "രണ്ടു പോസിറ്റീവ് പൂർണ്ണസംഖ്യകൾ n, k എന്നിവ നൽകിയാൽ, 1 <= x <= n എന്ന നിലയിൽ x = a^b എന്ന രൂപത്തിൽ പ്രകടിപ്പിക്കാവുന്ന പോസിറ്റീവ് പൂർണ്ണസംഖ്യകളുടെ എണ്ണം കണ്ടെത്തുക, ഇവിടെ a, b എന്നിവ പോസിറ്റീവ് പൂർണ്ണസംഖ്യകളാണ്, b >= k. ഒരേ സംഖ്യയുടെ വ്യത്യസ്തമായ നിയമാനുസൃത പ്രതിനിധാനങ്ങൾ ഒരിക്കൽ മാത്രമേ എണ്ണപ്പെടൂ. \n    >>> f_40(99, 1)\n    99", "fa": "با توجه به دو عدد صحیح مثبت n و k، تعداد اعداد صحیح مثبت x را پیدا کنید، به طوری که 1 <= x <= n، که می‌توان آن‌ها را به صورت x = a^b با a و b به عنوان اعداد صحیح مثبت و b >= k بیان کرد.\nنمایش‌های قانونی مختلف از یک عدد مشابه فقط یک بار شمرده می‌شوند.\n    >>> f_40(99, 1)\n    99"}}
{"task_id": "C/41", "prompt": {"en": "#include <stdio.h>\n#include <assert.h>\n/*\nGiven three integers n, m, and k, find the number of sequences consisting of n '(' and m ')', such that the longest balanced subsequence is of length 2 * k. The result should be calculated modulo 1,000,000,007 (10^9 + 7).\n\nFor example:\n    >>> f_41(2, 2, 2)\n    2\n*/\nlong long f_41(long long n, long long m, long long k)", "sq": "#include <stdio.h>\n#include <assert.h>\n/*\nDuke pasur tre numra të plotë n, m, dhe k, gjeni numrin e sekuencave që përbëhen nga n '(' dhe m ')', të tilla që nënsekuenca më e gjatë e balancuar është me gjatësi 2 * k. Rezultati duhet të llogaritet modulo 1,000,000,007 (10^9 + 7).\n\nPër shembull:\n    >>> f_41(2, 2, 2)\n    2\n*/\nlong long f_41(long long n, long long m, long long k)", "hy": "#include <stdio.h>\n#include <assert.h>\n/*\nԵրեք ամբողջ թիվ n, m և k տրված են, գտնել հաջորդականությունների քանակը, որոնք բաղկացած են n '(' և m ')' նշաններից, այնպես, որ ամենաերկար հավասարակշռված ենթահաջորդականությունը լինի 2 * k երկարությամբ։ Արդյունքը պետք է հաշվել 1,000,000,007 (10^9 + 7) մոդուլով։\n\nՕրինակ:\n    >>> f_41(2, 2, 2)\n    2\n*/\nlong long f_41(long long n, long long m, long long k)", "bn": "#include <stdio.h>\n#include <assert.h>\n/*\nতিনটি পূর্ণসংখ্যা n, m, এবং k দেওয়া আছে, n '(' এবং m ')' নিয়ে গঠিত কতগুলি ক্রম আছে তা খুঁজে বের করুন, যাতে দীর্ঘতম সুষম উপধারা 2 * k দৈর্ঘ্যের হয়। ফলাফলটি 1,000,000,007 (10^9 + 7) মডুলোতে গণনা করা উচিত।\n\nউদাহরণস্বরূপ:\n    >>> f_41(2, 2, 2)\n    2\n*/\nlong long f_41(long long n, long long m, long long k)", "bg": "#include <stdio.h>\n#include <assert.h>\n/*\nДадени са три цели числа n, m и k, намерете броя на последователностите, състоящи се от n '(' и m ')', така че най-дългата балансирана подредба да е с дължина 2 * k. Резултатът трябва да се изчисли по модул 1,000,000,007 (10^9 + 7).\n\nНапример:\n    >>> f_41(2, 2, 2)\n    2\n*/\nlong long f_41(long long n, long long m, long long k)", "zh": "#include <stdio.h>\n#include <assert.h>\n/*\n给定三个整数 n, m 和 k，找出由 n 个 '(' 和 m 个 ')' 组成的序列的数量，使得最长的平衡子序列的长度为 2 * k。结果应以 1,000,000,007 (10^9 + 7) 取模计算。\n\n例如：\n    >>> f_41(2, 2, 2)\n    2\n*/\nlong long f_41(long long n, long long m, long long k)", "fr": "#include <stdio.h>\n#include <assert.h>\n/*\nÉtant donné trois entiers n, m et k, trouvez le nombre de séquences composées de n '(' et m ')', telles que la plus longue sous-séquence équilibrée soit de longueur 2 * k. Le résultat doit être calculé modulo 1,000,000,007 (10^9 + 7).\n\nPar exemple :\n    >>> f_41(2, 2, 2)\n    2\n*/\nlong long f_41(long long n, long long m, long long k)", "de": "#include <stdio.h>\n#include <assert.h>\n/*\nGegeben sind drei ganze Zahlen n, m und k. Finde die Anzahl der Sequenzen, die aus n '(' und m ')' bestehen, sodass die längste ausgeglichene Teilsequenz die Länge 2 * k hat. Das Ergebnis sollte modulo 1.000.000.007 (10^9 + 7) berechnet werden.\n\nZum Beispiel:\n    >>> f_41(2, 2, 2)\n    2\n*/\nlong long f_41(long long n, long long m, long long k)", "ha": "#include <stdio.h>\n#include <assert.h>\n/*\nAn ba lambobi guda uku n, m, da k, nemo adadin jerin lambobi masu kunshe da n '(' da m ')', ta yadda mafi tsawon jerin lambobi masu daidaituwa zai kasance mai tsawon 2 * k. Ya kamata a lissafta sakamakon daidai da 1,000,000,007 (10^9 + 7).\n\nMisali:\n    >>> f_41(2, 2, 2)\n    2\n*/\nlong long f_41(long long n, long long m, long long k)", "hi": "#include <stdio.h>\n#include <assert.h>\n/*\nदिए गए तीन पूर्णांक n, m, और k के लिए, उन अनुक्रमों की संख्या खोजें जो n '(' और m ')' से बने होते हैं, ताकि सबसे लंबा संतुलित उप-अनुक्रम 2 * k की लंबाई का हो। परिणाम को 1,000,000,007 (10^9 + 7) के मापांक में गणना की जानी चाहिए।\n\nउदाहरण के लिए:\n    >>> f_41(2, 2, 2)\n    2\n*/\nlong long f_41(long long n, long long m, long long k)", "hu": "#include <stdio.h>\n#include <assert.h>\n/*\nAdott három egész szám: n, m és k. Találja meg azon sorozatok számát, amelyek n '(' és m ')' karakterből állnak, úgy, hogy a leghosszabb kiegyensúlyozott részsorozat hossza 2 * k. Az eredményt 1,000,000,007 (10^9 + 7) modulo szerint kell kiszámítani.\n\nPéldául:\n    >>> f_41(2, 2, 2)\n    2\n*/\nlong long f_41(long long n, long long m, long long k)", "es": "#include <stdio.h>\n#include <assert.h>\n/*\nDado tres enteros n, m y k, encuentra el número de secuencias que consisten en n '(' y m ')', tal que la subsecuencia balanceada más larga sea de longitud 2 * k. El resultado debe calcularse módulo 1,000,000,007 (10^9 + 7).\n\nPor ejemplo:\n    >>> f_41(2, 2, 2)\n    2\n*/\nlong long f_41(long long n, long long m, long long k)", "arb": "#include <stdio.h>\n#include <assert.h>\n/*\nمعطى ثلاثة أعداد صحيحة n و m و k، ابحث عن عدد التسلسلات التي تتكون من n '(' و m ')', بحيث يكون أطول تسلسل متوازن بطول 2 * k. يجب حساب النتيجة بتطبيق باقي القسمة على 1,000,000,007 (10^9 + 7).\n\nعلى سبيل المثال:\n    >>> f_41(2, 2, 2)\n    2\n*/\nlong long f_41(long long n, long long m, long long k)", "sw": "#include <stdio.h>\n#include <assert.h>\n/*\nUkipiwa nambari tatu n, m, na k, pata idadi ya mlolongo unaojumuisha n '(' na m ')', kiasi kwamba mlolongo mrefu zaidi ulio na usawa ni wa urefu wa 2 * k. Matokeo yanapaswa kuhesabiwa kwa moduli 1,000,000,007 (10^9 + 7).\n\nKwa mfano:\n    >>> f_41(2, 2, 2)\n    2\n*/\nlong long f_41(long long n, long long m, long long k)", "tr": "#include <stdio.h>\n#include <assert.h>\n/*\nÜç tamsayı n, m ve k verildiğinde, n '(' ve m ')' karakterlerinden oluşan dizilerin sayısını bulun, öyle ki en uzun dengeli alt dizi uzunluğu 2 * k olsun. Sonuç 1,000,000,007 (10^9 + 7) ile modulo alınarak hesaplanmalıdır.\n\nÖrneğin:\n    >>> f_41(2, 2, 2)\n    2\n*/\nlong long f_41(long long n, long long m, long long k)", "vi": "#include <stdio.h>\n#include <assert.h>\n/*\nCho ba số nguyên n, m và k, tìm số lượng dãy bao gồm n '(' và m ')', sao cho dãy con cân bằng dài nhất có độ dài 2 * k. Kết quả nên được tính theo modulo 1,000,000,007 (10^9 + 7).\n\nVí dụ:\n    >>> f_41(2, 2, 2)\n    2\n*/\nlong long f_41(long long n, long long m, long long k)", "id": "#include <stdio.h>\n#include <assert.h>\n/*\nDiberikan tiga bilangan bulat n, m, dan k, temukan jumlah urutan yang terdiri dari n '(' dan m ')', sedemikian rupa sehingga subsekuens seimbang terpanjang memiliki panjang 2 * k. Hasilnya harus dihitung dengan modulo 1,000,000,007 (10^9 + 7).\n\nSebagai contoh:\n    >>> f_41(2, 2, 2)\n    2\n*/\nlong long f_41(long long n, long long m, long long k)", "ja": "#include <stdio.h>\n#include <assert.h>\n/*\n3つの整数 n, m, k が与えられたとき、n 個の '(' と m 個の ')' からなるシーケンスのうち、最長のバランスの取れた部分列が長さ 2 * k であるものの数を求めます。結果は1,000,000,007 (10^9 + 7) で計算する必要があります。\n\n例えば:\n    >>> f_41(2, 2, 2)\n    2\n*/\nlong long f_41(long long n, long long m, long long k)", "ko": "#include <stdio.h>\n#include <assert.h>\n/*\n세 개의 정수 n, m, k가 주어졌을 때, n개의 '('와 m개의 ')'로 구성된 시퀀스 중 가장 긴 균형 잡힌 부분 시퀀스의 길이가 2 * k인 경우의 수를 찾으십시오. 결과는 1,000,000,007 (10^9 + 7)로 나눈 나머지로 계산되어야 합니다.\n\n예를 들어:\n    >>> f_41(2, 2, 2)\n    2\n*/\nlong long f_41(long long n, long long m, long long k)", "ml": "#include <stdio.h>\n#include <assert.h>\n/*\nമൂന്ന് പൂർണ്ണസംഖ്യകൾ n, m, k നൽകിയാൽ, n '(' മത്തും m ')' മത്തും അടങ്ങിയ അനുബന്ധങ്ങൾ എത്രയാണെന്ന് കണ്ടെത്തുക, അങ്ങനെ ഏറ്റവും നീളമുള്ള ബാലൻസ്ഡ് ഉപക്രമം 2 * k നീളമുള്ളതായിരിക്കും. ഫലം 1,000,000,007 (10^9 + 7) മോഡുലോയിൽ കണക്കാക്കണം.\n\nഉദാഹരണത്തിന്:\n    >>> f_41(2, 2, 2)\n    2\n*/\nlong long f_41(long long n, long long m, long long k)", "fa": "#include <stdio.h>\n#include <assert.h>\n/*\nبا داشتن سه عدد صحیح n، m و k، تعداد دنباله‌هایی را بیابید که از n '(' و m ')' تشکیل شده‌اند، به طوری که طولانی‌ترین زیر دنباله متوازن دارای طول 2 * k باشد. نتیجه باید به پیمانه 1,000,000,007 (10^9 + 7) محاسبه شود.\n\nبرای مثال:\n    >>> f_41(2, 2, 2)\n    2\n*/\nlong long f_41(long long n, long long m, long long k)"}, "canonical_solution": "{\n    const long long P = 1e9 + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}", "instruction": {"en": "Write a C function `long long f_41(long long n, long long m, long long k)` to solve the following problem:\nGiven three integers n, m, and k, find the number of sequences consisting of n '(' and m ')', such that the longest balanced subsequence is of length 2 * k. The result should be calculated modulo 1,000,000,007 (10^9 + 7).\n\nFor example:\n    >>> f_41(2, 2, 2)\n    2\n", "sq": "Shkruani një funksion në C `long long f_41(long long n, long long m, long long k)` për të zgjidhur problemin në vijim:\nDuke pasur tre numra të plotë n, m, dhe k, gjeni numrin e sekuencave që përbëhen nga n '(' dhe m ')', të tilla që nënsekuenca më e gjatë e balancuar të jetë me gjatësi 2 * k. Rezultati duhet të llogaritet modulo 1,000,000,007 (10^9 + 7).\n\nPër shembull:\n    >>> f_41(2, 2, 2)\n    2", "hy": "Գրեք C ֆունկցիա `long long f_41(long long n, long long m, long long k)` հետևյալ խնդիրը լուծելու համար:\nԵրեք ամբողջ n, m և k թվերի դեպքում, գտնել n '(' և m ')' բաղկացած հաջորդականությունների քանակը, այնպես, որ ամենաերկար հավասարակշռված ենթահաջորդականությունը լինի 2 * k երկարությամբ: Արդյունքը պետք է հաշվարկել 1,000,000,007 (10^9 + 7) մոդուլով: \n\nՕրինակ:\n    >>> f_41(2, 2, 2)\n    2", "bn": "একটি C ফাংশন `long long f_41(long long n, long long m, long long k)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nতিনটি পূর্ণসংখ্যা n, m, এবং k দেওয়া আছে, n টি '(' এবং m টি ')' নিয়ে গঠিত এমন ক্রমের সংখ্যা খুঁজে বের করুন, যাতে দীর্ঘতম ব্যালেন্সড সাবসিকোয়েন্সের দৈর্ঘ্য 2 * k হয়। ফলাফলটি 1,000,000,007 (10^9 + 7) দ্বারা মডুলো গণনা করা উচিত।\n\nউদাহরণস্বরূপ:\n    >>> f_41(2, 2, 2)\n    2", "bg": "Напишете C функция `long long f_41(long long n, long long m, long long k)`, за да решите следния проблем:\nДадени са три цели числа n, m и k, намерете броя на последователностите, състоящи се от n '(' и m ')', така че най-дългата балансирана подредена последователност да е с дължина 2 * k. Резултатът трябва да бъде изчислен по модул 1,000,000,007 (10^9 + 7).\n\nНапример:\n    >>> f_41(2, 2, 2)\n    2", "zh": "编写一个 C 函数 `long long f_41(long long n, long long m, long long k)` 来解决以下问题：\n给定三个整数 n、m 和 k，找出由 n 个 '(' 和 m 个 ')' 组成的序列的数量，使得最长的平衡子序列的长度为 2 * k。结果应以 1,000,000,007 (10^9 + 7) 为模进行计算。  \n\n例如：  \n    >>> f_41(2, 2, 2)  \n    2  ", "fr": "Écrire une fonction C `long long f_41(long long n, long long m, long long k)` pour résoudre le problème suivant :\nÉtant donné trois entiers n, m et k, trouver le nombre de séquences composées de n '(' et m ')', de sorte que la plus longue sous-séquence équilibrée soit de longueur 2 * k. Le résultat doit être calculé modulo 1,000,000,007 (10^9 + 7).\n\nPar exemple :\n    >>> f_41(2, 2, 2)\n    2", "de": "Schreiben Sie eine C-Funktion `long long f_41(long long n, long long m, long long k)`, um das folgende Problem zu lösen:\nGegeben sind drei ganze Zahlen n, m und k. Finden Sie die Anzahl der Sequenzen, die aus n '(' und m ')' bestehen, so dass die längste balancierte Teilsequenz die Länge 2 * k hat. Das Ergebnis sollte modulo 1.000.000.007 (10^9 + 7) berechnet werden.\n\nZum Beispiel:\n    >>> f_41(2, 2, 2)\n    2", "ha": "Rubuta wani aikin C `long long f_41(long long n, long long m, long long k)` don warware matsalar mai zuwa:\nAn ba da lambobi guda uku n, m, da k, gano yawan jerin da suka ƙunshi n '(' da m ')', ta yadda mafi tsawon jerin da aka daidaita shine tsawon 2 * k. Sakamakon ya kamata a lasafta shi modulo 1,000,000,007 (10^9 + 7).\n\nMisali:\n    >>> f_41(2, 2, 2)\n    2", "hi": "C फ़ंक्शन `long long f_41(long long n, long long m, long long k)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए तीन पूर्णांक n, m, और k के लिए, n '(' और m ')' से बनी अनुक्रमों की संख्या खोजें, ताकि सबसे लंबा संतुलित उप-अनुक्रम की लंबाई 2 * k हो। परिणाम को 1,000,000,007 (10^9 + 7) के मापांक में गणना की जानी चाहिए।\n\nउदाहरण के लिए:\n    >>> f_41(2, 2, 2)\n    2", "hu": "Írj egy C függvényt `long long f_41(long long n, long long m, long long k)` a következő probléma megoldására:\nAdott három egész szám: n, m és k. Találd meg azon sorozatok számát, amelyek n darab '(' és m darab ')' karakterből állnak, úgy hogy a leghosszabb kiegyensúlyozott részszekvencia hossza 2 * k. Az eredményt 1,000,000,007 (10^9 + 7) modulo szerint kell kiszámítani.\n\nPéldául:\n    >>> f_41(2, 2, 2)\n    2", "es": "Escribe una función en C `long long f_41(long long n, long long m, long long k)` para resolver el siguiente problema:\nDado tres enteros n, m, y k, encuentra el número de secuencias que consisten en n '(' y m ')', tal que la subsecuencia balanceada más larga tiene una longitud de 2 * k. El resultado debe ser calculado módulo 1,000,000,007 (10^9 + 7).\n\nPor ejemplo:\n    >>> f_41(2, 2, 2)\n    2", "arb": "اكتب دالة بلغة C `long long f_41(long long n, long long m, long long k)` لحل المشكلة التالية:\nمعطى ثلاثة أعداد صحيحة n، m، و k، ابحث عن عدد التتابعات المكونة من n '(' و m ')', بحيث يكون أطول تتابع متوازن بطول 2 * k. يجب حساب النتيجة بتطبيق باقي القسمة على 1,000,000,007 (10^9 + 7).\n\nعلى سبيل المثال:\n    >>> f_41(2, 2, 2)\n    2", "sw": "Andika kazi ya C `long long f_41(long long n, long long m, long long k)` kutatua tatizo lifuatalo:\nUkipiwa nambari tatu n, m, na k, pata idadi ya mlolongo unaojumuisha n '(' na m ')', ili kwamba mlolongo mrefu zaidi ulio na usawa uwe na urefu wa 2 * k. Matokeo yanapaswa kuhesabiwa kwa modulo 1,000,000,007 (10^9 + 7).\n\nKwa mfano:\n    >>> f_41(2, 2, 2)\n    2", "tr": "Bir C fonksiyonu `long long f_41(long long n, long long m, long long k)` yazın ve aşağıdaki problemi çözün:\nVerilen üç tamsayı n, m ve k için, n '(' ve m ')' karakterlerinden oluşan dizilerin sayısını bulun, öyle ki en uzun dengeli alt dizi uzunluğu 2 * k olsun. Sonuç 1,000,000,007 (10^9 + 7) modunda hesaplanmalıdır.\n\nÖrneğin:\n    >>> f_41(2, 2, 2)\n    2", "vi": "Viết một hàm C `long long f_41(long long n, long long m, long long k)` để giải quyết vấn đề sau:\nCho ba số nguyên n, m và k, tìm số lượng dãy gồm n '(' và m ')', sao cho dãy con cân bằng dài nhất có độ dài 2 * k. Kết quả nên được tính theo modulo 1,000,000,007 (10^9 + 7).\n\nVí dụ:\n    >>> f_41(2, 2, 2)\n    2", "id": "Tulis sebuah fungsi C `long long f_41(long long n, long long m, long long k)` untuk menyelesaikan masalah berikut:\nDiberikan tiga bilangan bulat n, m, dan k, temukan jumlah urutan yang terdiri dari n '(' dan m ')', sedemikian rupa sehingga subsekuens seimbang terpanjang memiliki panjang 2 * k. Hasilnya harus dihitung modulo 1,000,000,007 (10^9 + 7).\n\nSebagai contoh:\n    >>> f_41(2, 2, 2)\n    2", "ja": "Cの関数を書け `long long f_41(long long n, long long m, long long k)` を作成して、次の問題を解決してください:\n3つの整数 n, m, k が与えられたとき、n 個の '(' と m 個の ')' からなるシーケンスのうち、最長のバランスの取れた部分シーケンスが長さ 2 * k であるものの数を求めます。結果は 1,000,000,007 (10^9 + 7) で計算してください。\n\n例えば:\n    >>> f_41(2, 2, 2)\n    2", "ko": "C 함수 `long long f_41(long long n, long long m, long long k)`를 작성하여 다음 문제를 해결하십시오:\n세 정수 n, m, k가 주어졌을 때, n개의 '('와 m개의 ')'로 구성된 시퀀스 중 가장 긴 균형 잡힌 부분 시퀀스의 길이가 2 * k인 경우의 수를 찾으십시오. 결과는 1,000,000,007 (10^9 + 7)로 모듈로 계산되어야 합니다.\n\n예를 들어:\n    >>> f_41(2, 2, 2)\n    2", "ml": "C ഫംഗ്ഷൻ `long long f_41(long long n, long long m, long long k)` എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nമൂന്ന് പൂർണ്ണസംഖ്യകൾ n, m, k നൽകിയാൽ, n '('  മും m ')' മും അടങ്ങിയ സീക്വൻസുകളുടെ എണ്ണം കണ്ടെത്തുക, അങ്ങനെ ഏറ്റവും നീളമുള്ള ബാലൻസ്ഡ് സബ്‌സീക്വൻസ് 2 * k നീളമുള്ളതാണ്. ഫലം 1,000,000,007 (10^9 + 7) മൂല്യം കൊണ്ട് മോഡുലോ കണക്കാക്കണം.\n\nഉദാഹരണത്തിന്:\n    >>> f_41(2, 2, 2)\n    2", "fa": "یک تابع C به نام `long long f_41(long long n, long long m, long long k)` بنویسید تا مسئله زیر را حل کند:\nبا توجه به سه عدد صحیح n، m و k، تعداد دنباله‌هایی را پیدا کنید که از n '(' و m ')' تشکیل شده‌اند، به طوری که طولانی‌ترین زیر دنباله متعادل دارای طول 2 * k باشد. نتیجه باید به پیمانه 1,000,000,007 (10^9 + 7) محاسبه شود.\n\nبرای مثال:\n    >>> f_41(2, 2, 2)\n    2"}, "level": "hard", "test": "int main() {\n    assert(f_41(2, 2, 2) == 2);\n    assert(f_41(3, 2, 3) == 0);\n    assert(f_41(3, 2, 1) == 4);\n    assert(f_41(4, 3, 2) == 14);\n    assert(f_41(5, 5, 2) == 35);\n    assert(f_41(6, 1, 1) == 6);\n    assert(f_41(1, 6, 1) == 6);\n    assert(f_41(7, 2, 2) == 27);\n    assert(f_41(8, 3, 3) == 110);\n    assert(f_41(10, 10, 5) == 10659);\n    assert(f_41(20, 20, 10) == 574221648);\n    assert(f_41(2000, 2000, 1000) == 854104531);\n    assert(f_41(2000, 1999, 1000) == 334874485);\n    assert(f_41(2000, 2000, 1999) == 259428024);\n    return 0;\n}", "entry_point": "f_41", "signature": "long long f_41(long long n, long long m, long long k)", "docstring": {"en": "Given three integers n, m, and k, find the number of sequences consisting of n '(' and m ')', such that the longest balanced subsequence is of length 2 * k. The result should be calculated modulo 1,000,000,007 (10^9 + 7).\n\nFor example:\n    >>> f_41(2, 2, 2)\n    2\n", "sq": "Duke pasur tre numra të plotë n, m, dhe k, gjeni numrin e sekuencave që përbëhen nga n '(' dhe m ')', të tilla që nënsekuenca më e gjatë e balancuar është me gjatësi 2 * k. Rezultati duhet të llogaritet modulo 1,000,000,007 (10^9 + 7).\n\nPër shembull:\n    >>> f_41(2, 2, 2)\n    2", "hy": "Երեք ամբողջ թիվ n, m և k ունենալով, գտնել n '(' և m ')' բաղկացած հաջորդականությունների քանակը, այնպես, որ ամենաերկար հավասարակշռված ենթահաջորդականությունը լինի 2 * k երկարությամբ։ Արդյունքը պետք է հաշվարկվի 1,000,000,007 (10^9 + 7) մոդուլով։\n\nՕրինակ:\n    >>> f_41(2, 2, 2)\n    2", "bn": "তিনটি পূর্ণসংখ্যা n, m, এবং k দেওয়া আছে, n '(' এবং m ')' নিয়ে গঠিত সিকোয়েন্সের সংখ্যা খুঁজে বের করুন, যাতে দীর্ঘতম ব্যালেন্সড সাবসিকোয়েন্সের দৈর্ঘ্য হয় 2 * k। ফলাফলটি 1,000,000,007 (10^9 + 7) দ্বারা মডুলো গণনা করা উচিত।\n\nউদাহরণস্বরূপ:\n    >>> f_41(2, 2, 2)\n    2", "bg": "Дадени са три цели числа n, m и k, намерете броя на последователностите, състоящи се от n '(' и m ')', така че най-дългата балансирана подредена последователност да е с дължина 2 * k. Резултатът трябва да бъде изчислен по модул 1,000,000,007 (10^9 + 7).\n\nНапример:\n    >>> f_41(2, 2, 2)\n    2", "zh": "给定三个整数 n、m 和 k，找出由 n 个 '(' 和 m 个 ')' 组成的序列的数量，使得最长的平衡子序列的长度为 2 * k。结果应以 1,000,000,007 (10^9 + 7) 为模进行计算。\n\n例如：\n    >>> f_41(2, 2, 2)\n    2", "fr": "Étant donné trois entiers n, m, et k, trouvez le nombre de séquences composées de n '(' et m ')', telles que la plus longue sous-séquence équilibrée soit de longueur 2 * k. Le résultat doit être calculé modulo 1,000,000,007 (10^9 + 7).\n\nPar exemple :\n    >>> f_41(2, 2, 2)\n    2", "de": "Gegeben drei ganze Zahlen n, m und k, finde die Anzahl der Sequenzen, die aus n '(' und m ')' bestehen, sodass die längste ausgeglichene Teilsequenz die Länge 2 * k hat. Das Ergebnis sollte modulo 1.000.000.007 (10^9 + 7) berechnet werden.\n\nZum Beispiel:\n    >>> f_41(2, 2, 2)\n    2", "ha": "An ba da lambobi guda uku n, m, da k, nemo adadin jerin lambobi da suka ƙunshi n '(' da m ')', ta yadda mafi tsawon jerin lambobi masu daidaito zai kasance mai tsawon 2 * k. Ya kamata a lissafa sakamakon modulo 1,000,000,007 (10^9 + 7).\n\nMisali:\n    >>> f_41(2, 2, 2)\n    2", "hi": "तीन पूर्णांक n, m, और k दिए गए हैं, उन अनुक्रमों की संख्या खोजें जिनमें n '(' और m ')' शामिल हैं, ताकि सबसे लंबा संतुलित उप-अनुक्रम की लंबाई 2 * k हो। परिणाम को 1,000,000,007 (10^9 + 7) के मापांक में गणना की जानी चाहिए।\n\nउदाहरण के लिए:\n    >>> f_41(2, 2, 2)\n    2", "hu": "Három egész szám, n, m és k megadása esetén találja meg az n '(' és m ')' karakterekből álló sorozatok számát úgy, hogy a leghosszabb kiegyensúlyozott részszekvencia hossza 2 * k legyen. Az eredményt 1,000,000,007 (10^9 + 7) modulo szerint kell kiszámítani.\n\nPéldául:\n    >>> f_41(2, 2, 2)\n    2", "es": "Dado tres enteros n, m, y k, encuentra el número de secuencias que consisten en n '(' y m ')', tal que la subsecuencia balanceada más larga sea de longitud 2 * k. El resultado debe calcularse módulo 1,000,000,007 (10^9 + 7).\n\nPor ejemplo:\n    >>> f_41(2, 2, 2)\n    2", "arb": "معطى ثلاثة أعداد صحيحة n و m و k، ابحث عن عدد التتابعات المكونة من n '(' و m ')', بحيث يكون أطول تتابع متوازن بطول 2 * k. يجب حساب النتيجة بتطبيق باقي القسمة على 1,000,000,007 (10^9 + 7).\n\nعلى سبيل المثال:\n    >>> f_41(2, 2, 2)\n    2", "sw": "Kwa kuzingatia nambari tatu nzima n, m, na k, pata idadi ya mlolongo unaojumuisha n '(' na m ')', ili kwamba mlolongo mrefu zaidi ulio na uwiano sawa uwe na urefu wa 2 * k. Matokeo yanapaswa kuhesabiwa kwa moduli 1,000,000,007 (10^9 + 7).\n\nKwa mfano:\n    >>> f_41(2, 2, 2)\n    2", "tr": "Üç tamsayı n, m ve k verildiğinde, n '(' ve m ')' karakterlerinden oluşan dizilerin sayısını bulun, öyle ki en uzun dengeli alt dizi uzunluğu 2 * k olsun. Sonuç 1,000,000,007 (10^9 + 7) modunda hesaplanmalıdır.\n\nÖrneğin:\n    >>> f_41(2, 2, 2)\n    2", "vi": "Cho ba số nguyên n, m và k, tìm số lượng dãy bao gồm n '(' và m ')', sao cho dãy con cân bằng dài nhất có độ dài 2 * k. Kết quả nên được tính theo modulo 1,000,000,007 (10^9 + 7).\n\nVí dụ:\n    >>> f_41(2, 2, 2)\n    2", "id": "Diberikan tiga bilangan bulat n, m, dan k, temukan jumlah urutan yang terdiri dari n '(' dan m ')', sedemikian rupa sehingga subsekuens seimbang terpanjang memiliki panjang 2 * k. Hasilnya harus dihitung dengan modulo 1,000,000,007 (10^9 + 7).\n\nSebagai contoh:\n    >>> f_41(2, 2, 2)\n    2", "ja": "3つの整数 n、m、k が与えられたとき、n 個の '(' と m 個の ')' からなるシーケンスのうち、最も長いバランスの取れた部分列の長さが 2 * k であるものの数を求めます。結果は 1,000,000,007 (10^9 + 7) で計算する必要があります。\n\n例:\n    >>> f_41(2, 2, 2)\n    2", "ko": "세 개의 정수 n, m, k가 주어졌을 때, n개의 '('와 m개의 ')'로 구성된 시퀀스 중에서 가장 긴 균형 잡힌 부분 시퀀스의 길이가 2 * k인 경우의 수를 찾으십시오. 결과는 1,000,000,007 (10^9 + 7)로 나눈 나머지로 계산되어야 합니다.\n\n예를 들어:\n    >>> f_41(2, 2, 2)\n    2", "ml": "മൂന്ന് പൂർണ്ണസംഖ്യകൾ n, m, k എന്നിവ നൽകിയാൽ, n '(' മുകളിലും m ')' മുകളിലും ഉള്ള അനുക്രമങ്ങളുടെ എണ്ണം കണ്ടെത്തുക, ഏറ്റവും നീളമുള്ള ബാലൻസ്ഡ് ഉപക്രമം 2 * k നീളമുള്ളതായിരിക്കണം. ഫലം 1,000,000,007 (10^9 + 7) മോടുലോയിൽ കണക്കാക്കണം.\n\nഉദാഹരണത്തിന്:\n    >>> f_41(2, 2, 2)\n    2", "fa": "با توجه به سه عدد صحیح n، m و k، تعداد دنباله‌هایی را پیدا کنید که شامل n '(' و m ')' باشند، به طوری که طولانی‌ترین زیر دنباله متوازن دارای طول 2 * k باشد. نتیجه باید به پیمانه 1,000,000,007 (10^9 + 7) محاسبه شود.\n\nبرای مثال:\n    >>> f_41(2, 2, 2)\n    2"}}
{"task_id": "C/42", "prompt": {"en": "#include <stdio.h>\n#include <assert.h>\n/*\nGiven a rectangle paper of size n x m placed on a plane Cartesian coordinate system with its bottom-left corner at (0,0) and top-right corner at (n,m), \nyou need to calculate the expected number of operations to cut the paper such that the remaining area is less than k. \nIn each operation, a line is randomly chosen that is parallel to the axes, passes through points with integer coordinates, and cuts through (not just touching the edge) the paper. The bottom or right part of the paper along this line is then discarded.\nThe answer should be modulo 10^9+7.\n\nFor example:\n    >>> f_42(3, 3, 4)\n    3\n*/\nlong long f_42(int n, int m, long long k)", "sq": "#include <stdio.h>\n#include <assert.h>\n/*\nDuke pasur një letër drejtkëndore me madhësi n x m të vendosur në një sistem koordinativ Kartesian të planit me këndin e poshtëm të majtë në (0,0) dhe këndin e sipërm të djathtë në (n,m),\nju duhet të llogaritni numrin e pritur të operacioneve për të prerë letrën në mënyrë që sipërfaqja e mbetur të jetë më pak se k.\nNë çdo operacion, një vijë zgjidhet në mënyrë të rastësishme që është paralele me boshtet, kalon nëpër pika me koordinata të plota, dhe pret (jo vetëm prek skajin) letrën. Pjesa e poshtme ose e djathtë e letrës përgjatë kësaj vije pastaj hidhet poshtë.\nPërgjigjja duhet të jetë modulo 10^9+7.\n\nPër shembull:\n    >>> f_42(3, 3, 4)\n    3\n*/\nlong long f_42(int n, int m, long long k)", "hy": "#include <stdio.h>\n#include <assert.h>\n/*\nՏրված է n x m չափսի ուղղանկյուն թուղթ, որը տեղադրված է հարթության դեկարտյան կոորդինատային համակարգում՝ իր ներքևի ձախ անկյունը (0,0)-ում և վերևի աջ անկյունը (n,m)-ում,\nպետք է հաշվարկել սպասվող գործողությունների քանակը, որպեսզի թղթի մնացած տարածքը լինի k-ից փոքր:\nՅուրաքանչյուր գործողության ժամանակ պատահականորեն ընտրվում է գիծ, որը զուգահեռ է առանցքներին, անցնում է ամբողջ թվային կոորդինատներով կետերով և կտրում է թուղթը (ոչ միայն եզրին դիպչելով): Թղթի այդ գծի երկայնքով ներքևի կամ աջ հատվածը ապա հեռացվում է:\nՊատասխանը պետք է լինի 10^9+7 մոդուլով:\n\nՕրինակ:\n    >>> f_42(3, 3, 4)\n    3\n*/\nlong long f_42(int n, int m, long long k)", "bn": "#include <stdio.h>\n#include <assert.h>\n/*\nএকটি আয়তাকার কাগজ যার আকার n x m, একটি সমতল কার্টেসিয়ান স্থানাঙ্ক পদ্ধতিতে রাখা হয়েছে যার নিচের-বাম কোণ (0,0) এবং উপরের-ডান কোণ (n,m) এ রয়েছে,\nআপনাকে কাগজটি কাটার জন্য প্রত্যাশিত অপারেশনের সংখ্যা গণনা করতে হবে যাতে অবশিষ্ট এলাকা k এর চেয়ে কম হয়।\nপ্রতিটি অপারেশনে, একটি লাইন এলোমেলোভাবে নির্বাচন করা হয় যা অক্ষের সমান্তরাল, পূর্ণসংখ্যা স্থানাঙ্ক সহ বিন্দুগুলির মধ্য দিয়ে যায় এবং কাগজের মধ্য দিয়ে কেটে যায় (শুধু প্রান্ত স্পর্শ করে না)। এই লাইনের সাথে কাগজের নিচের বা ডান অংশটি তারপর বাতিল করা হয়।\nউত্তরটি 10^9+7 মডুলোতে হওয়া উচিত।\n\nউদাহরণস্বরূপ:\n    >>> f_42(3, 3, 4)\n    3\n*/\nlong long f_42(int n, int m, long long k)", "bg": "#include <stdio.h>\n#include <assert.h>\n/*\nДаден е правоъгълен лист хартия с размер n x m, разположен в равнинна декартова координатна система с долния ляв ъгъл в (0,0) и горния десен ъгъл в (n,m),\nтрябва да изчислите очаквания брой операции за рязане на хартията така, че оставащата площ да е по-малка от k.\nПри всяка операция се избира случайна линия, която е успоредна на осите, минава през точки с цели координати и пресича (не само докосва ръба) хартията. Долната или дясната част на хартията по тази линия след това се изхвърля.\nОтговорът трябва да бъде модул 10^9+7.\n\nНапример:\n    >>> f_42(3, 3, 4)\n    3\n*/\nlong long f_42(int n, int m, long long k)", "zh": "#include <stdio.h>\n#include <assert.h>\n/*\n给定一个大小为 n x m 的矩形纸张，放置在平面直角坐标系中，其左下角位于 (0,0)，右上角位于 (n,m)，\n你需要计算切割纸张的期望操作次数，使得剩余面积小于 k。\n在每次操作中，随机选择一条与坐标轴平行的线，该线通过整数坐标的点，并切割（不仅仅是接触边缘）纸张。然后沿着这条线丢弃纸张的底部或右侧部分。\n答案应对 10^9+7 取模。\n\n例如:\n    >>> f_42(3, 3, 4)\n    3\n*/\nlong long f_42(int n, int m, long long k)", "fr": "#include <stdio.h>\n#include <assert.h>\n/*\nÉtant donné un papier rectangulaire de taille n x m placé sur un système de coordonnées cartésiennes avec son coin inférieur gauche à (0,0) et son coin supérieur droit à (n,m),\nvous devez calculer le nombre attendu d'opérations pour couper le papier de sorte que la surface restante soit inférieure à k.\nÀ chaque opération, une ligne est choisie au hasard, parallèle aux axes, passant par des points avec des coordonnées entières, et coupant (pas seulement touchant le bord) le papier. La partie inférieure ou droite du papier le long de cette ligne est alors jetée.\nLa réponse doit être modulo 10^9+7.\n\nPar exemple :\n    >>> f_42(3, 3, 4)\n    3\n*/\nlong long f_42(int n, int m, long long k)", "de": "#include <stdio.h>\n#include <assert.h>\n/*\nGegeben ist ein rechteckiges Papier der Größe n x m, das in einem kartesischen Koordinatensystem mit seiner unteren linken Ecke bei (0,0) und der oberen rechten Ecke bei (n,m) platziert ist. \nSie müssen die erwartete Anzahl von Operationen berechnen, um das Papier so zu schneiden, dass die verbleibende Fläche kleiner als k ist. \nBei jeder Operation wird zufällig eine Linie gewählt, die parallel zu den Achsen verläuft, durch Punkte mit ganzzahligen Koordinaten geht und das Papier durchschneidet (nicht nur den Rand berührt). Der untere oder rechte Teil des Papiers entlang dieser Linie wird dann verworfen.\nDie Antwort sollte modulo 10^9+7 sein.\n\nZum Beispiel:\n    >>> f_42(3, 3, 4)\n    3\n*/\nlong long f_42(int n, int m, long long k)", "ha": "#include <stdio.h>\n#include <assert.h>\n/*\nAna ba da takarda mai kusurwa huɗu mai girman n x m da aka sanya a kan tsarin daidaitawar Cartesian tare da kusurwar ƙasa-hagu a (0,0) da kusurwar sama-dama a (n,m),\ndole ne ku lissafa yawan ayyukan da ake tsammani don yanke takardar ta yadda yankin da ya rage ya zama ƙasa da k.\nA kowane aiki, ana zaɓar layi a bazuwar wanda yake daidai da ginshiƙai, yana wucewa ta wuraren da ke da daidaitattun lambobi, kuma yana yanke (ba kawai taɓa gefen ba) takardar. Ana watsar da ɓangaren ƙasa ko dama na takardar tare da wannan layin.\nAmsar ya kamata ta zama modulo 10^9+7.\n\nMisali:\n    >>> f_42(3, 3, 4)\n    3\n*/\nlong long f_42(int n, int m, long long k)", "hi": "#include <stdio.h>\n#include <assert.h>\n/*\nदिए गए एक आयताकार कागज का आकार n x m है जो एक समतल कार्टेशियन निर्देशांक प्रणाली पर रखा गया है, \nजिसका निचला-बायां कोना (0,0) पर है और ऊपरी-दायां कोना (n,m) पर है, \nआपको यह गणना करने की आवश्यकता है कि कागज को काटने के लिए अपेक्षित ऑपरेशनों की संख्या कितनी है ताकि शेष क्षेत्रफल k से कम हो। \nप्रत्येक ऑपरेशन में, एक रेखा यादृच्छिक रूप से चुनी जाती है जो अक्षों के समानांतर होती है, पूर्णांक निर्देशांक वाले बिंदुओं से गुजरती है, \nऔर कागज को काटती है (सिर्फ किनारे को छूने के बजाय)। इस रेखा के साथ कागज का निचला या दायां भाग फिर त्याग दिया जाता है।\nउत्तर 10^9+7 के मापांक में होना चाहिए।\n\nउदाहरण के लिए:\n    >>> f_42(3, 3, 4)\n    3\n*/\nlong long f_42(int n, int m, long long k)", "hu": "#include <stdio.h>\n#include <assert.h>\n/*\nAdott egy n x m méretű téglalap alakú papír, amely a sík Descartes-féle koordinátarendszerben helyezkedik el, bal alsó sarka a (0,0) pontban, jobb felső sarka pedig az (n,m) pontban van. \nKi kell számítani a várható műveletek számát ahhoz, hogy a papírt úgy vágjuk, hogy a megmaradt terület kisebb legyen, mint k. \nMinden művelet során véletlenszerűen választunk egy vonalat, amely párhuzamos a tengelyekkel, egész koordinátájú pontokon halad át, és átvágja (nem csak érinti a szélét) a papírt. A papír ezen vonal mentén lévő alsó vagy jobb részét eldobhatjuk.\nAz eredménynek 10^9+7 modulo szerint kell lennie.\n\nPéldául:\n    >>> f_42(3, 3, 4)\n    3\n*/\nlong long f_42(int n, int m, long long k)", "es": "#include <stdio.h>\n#include <assert.h>\n/*\nDado un papel rectangular de tamaño n x m colocado en un sistema de coordenadas Cartesianas en un plano con su esquina inferior izquierda en (0,0) y la esquina superior derecha en (n,m),\nnecesitas calcular el número esperado de operaciones para cortar el papel de tal manera que el área restante sea menor que k.\nEn cada operación, se elige aleatoriamente una línea que es paralela a los ejes, pasa por puntos con coordenadas enteras, y corta (no solo toca el borde) el papel. La parte inferior o derecha del papel a lo largo de esta línea se descarta.\nLa respuesta debe ser módulo 10^9+7.\n\nPor ejemplo:\n    >>> f_42(3, 3, 4)\n    3\n*/\nlong long f_42(int n, int m, long long k)", "arb": "#include <stdio.h>\n#include <assert.h>\n/*\nمعطى ورقة مستطيلة بحجم n x m موضوعة على نظام إحداثيات ديكارتي مستوي مع الزاوية السفلية اليسرى عند (0,0) والزاوية العلوية اليمنى عند (n,m)، \nتحتاج إلى حساب العدد المتوقع من العمليات لقطع الورقة بحيث تكون المساحة المتبقية أقل من k.\nفي كل عملية، يتم اختيار خط بشكل عشوائي يكون موازياً للمحاور، ويمر عبر نقاط ذات إحداثيات صحيحة، ويقطع الورقة (وليس فقط لمس الحافة). يتم بعد ذلك التخلص من الجزء السفلي أو الأيمن من الورقة على طول هذا الخط.\nيجب أن تكون الإجابة موديولو 10^9+7.\n\nعلى سبيل المثال:\n    >>> f_42(3, 3, 4)\n    3\n*/\nlong long f_42(int n, int m, long long k)", "sw": "#include <stdio.h>\n#include <assert.h>\n/*\nUkiwa na karatasi ya mstatili ya ukubwa n x m iliyowekwa kwenye mfumo wa kuratibu wa Cartesian kwenye ndege ikiwa kona yake ya chini-kushoto iko kwenye (0,0) na kona ya juu-kulia iko kwenye (n,m), \nunahitaji kuhesabu idadi inayotarajiwa ya operesheni za kukata karatasi ili eneo linalobaki liwe chini ya k. \nKatika kila operesheni, mstari unachaguliwa kwa nasibu ambao ni sambamba na mhimili, unapita kupitia pointi zenye kuratibu za nambari kamili, na unakata (si kugusa tu ukingo) karatasi. Sehemu ya chini au kulia ya karatasi kando ya mstari huu kisha inatupwa.\nJibu linapaswa kuwa moduli ya 10^9+7.\n\nKwa mfano:\n    >>> f_42(3, 3, 4)\n    3\n*/\nlong long f_42(int n, int m, long long k)", "tr": "#include <stdio.h>\n#include <assert.h>\n/*\nn x m boyutunda bir dikdörtgen kağıt, alt-sol köşesi (0,0) ve üst-sağ köşesi (n,m) olan bir Kartezyen koordinat sistemine yerleştirilmiştir. \nKağıdın kalan alanının k'dan küçük olacak şekilde kesilmesi için beklenen işlem sayısını hesaplamanız gerekiyor. \nHer işlemde, eksenlere paralel, tam sayı koordinatlarına sahip noktalardan geçen ve kağıdı kesen (sadece kenara dokunmayan) bir çizgi rastgele seçilir. Bu çizgi boyunca kağıdın alt veya sağ kısmı atılır.\nCevap 10^9+7 ile mod alınmış olmalıdır.\n\nÖrneğin:\n    >>> f_42(3, 3, 4)\n    3\n*/\nlong long f_42(int n, int m, long long k)", "vi": "#include <stdio.h>\n#include <assert.h>\n/*\nCho một tờ giấy hình chữ nhật kích thước n x m đặt trên hệ tọa độ phẳng Đề-các với góc dưới bên trái tại (0,0) và góc trên bên phải tại (n,m),\nbạn cần tính số lượng thao tác kỳ vọng để cắt tờ giấy sao cho diện tích còn lại nhỏ hơn k.\nTrong mỗi thao tác, một đường thẳng được chọn ngẫu nhiên song song với các trục, đi qua các điểm có tọa độ nguyên, và cắt qua (không chỉ chạm vào cạnh) tờ giấy. Phần dưới hoặc bên phải của tờ giấy dọc theo đường này sau đó bị loại bỏ.\nCâu trả lời phải lấy modulo 10^9+7.\n\nVí dụ:\n    >>> f_42(3, 3, 4)\n    3\n*/\nlong long f_42(int n, int m, long long k)", "id": "#include <stdio.h>\n#include <assert.h>\n/*\nDiberikan selembar kertas berbentuk persegi panjang berukuran n x m yang ditempatkan pada sistem koordinat Kartesius dengan sudut kiri bawah di (0,0) dan sudut kanan atas di (n,m),\nAnda perlu menghitung jumlah operasi yang diharapkan untuk memotong kertas sehingga area yang tersisa kurang dari k.\nDalam setiap operasi, sebuah garis dipilih secara acak yang sejajar dengan sumbu, melewati titik-titik dengan koordinat bilangan bulat, dan memotong (bukan hanya menyentuh tepi) kertas. Bagian bawah atau kanan dari kertas sepanjang garis ini kemudian dibuang.\nJawabannya harus dalam bentuk modulo 10^9+7.\n\nSebagai contoh:\n    >>> f_42(3, 3, 4)\n    3\n*/\nlong long f_42(int n, int m, long long k)\n", "ja": "#include <stdio.h>\n#include <assert.h>\n/*\nn x mのサイズの長方形の紙が、(0,0)を左下の角、(n,m)を右上の角とする平面のデカルト座標系上に置かれています。\nこの紙を切る操作を行い、残りの面積がk未満になるまでの期待される操作回数を計算する必要があります。\n各操作では、軸に平行で、整数座標を持つ点を通り、紙を切断する（端に触れるだけではない）線がランダムに選ばれます。この線に沿った紙の下または右の部分が破棄されます。\n答えは10^9+7での剰余として返す必要があります。\n\n例えば:\n    >>> f_42(3, 3, 4)\n    3\n*/\nlong long f_42(int n, int m, long long k)\n", "ko": "#include <stdio.h>\n#include <assert.h>\n/*\n주어진 크기 n x m의 직사각형 종이가 평면 데카르트 좌표계에 놓여 있으며, \n그의 왼쪽 아래 모서리는 (0,0)에, 오른쪽 위 모서리는 (n,m)에 위치해 있습니다. \n남은 면적이 k보다 작아지도록 종이를 자르는 데 필요한 예상 작업 수를 계산해야 합니다. \n각 작업에서, 축에 평행하고 정수 좌표를 지나는 선이 무작위로 선택되어 종이를 자릅니다(단순히 가장자리를 터치하는 것이 아님). \n이 선을 따라 종이의 아래쪽 또는 오른쪽 부분이 버려집니다.\n답은 10^9+7로 나눈 나머지여야 합니다.\n\n예를 들어:\n    >>> f_42(3, 3, 4)\n    3\n*/\nlong long f_42(int n, int m, long long k)\n", "ml": "#include <stdio.h>\n#include <assert.h>\n/*\nഒരു n x m വലിപ്പമുള്ള ചതുരാകൃതിയിലുള്ള കാഗിതം (0,0) ലെ അടിഭാഗം-ഇടത് കോണിലും (n,m) ലെ മുകളിൽ-വലത് കോണിലും ഉള്ള പ്ലെയിൻ കാർട്ടീസിയൻ കോഓർഡിനേറ്റ് സിസ്റ്റത്തിൽ സ്ഥിതിചെയ്യുന്ന, \nശേഷിക്കുന്ന വിസ്തീർണം k-ൽ കുറവായിരിക്ക하도록 കാഗിതം മുറിക്കാൻ പ്രതീക്ഷിക്കപ്പെടുന്ന പ്രവർത്തനങ്ങളുടെ എണ്ണം കണക്കാക്കേണ്ടതുണ്ട്. \nഓരോ പ്രവർത്തനത്തിലും, അച്ചുതണ്ടുകളോട് സമാന്തരമായ, പൂർണ്ണസംഖ്യാ കോഓർഡിനേറ്റുകളുള്ള പോയിന്റുകളിലൂടെ കടന്നുപോകുന്ന ഒരു രേഖ യാദൃശ്ചികമായി തിരഞ്ഞെടുത്ത്, കാഗിതം മുറിക്കുന്നു (അറ്റത്തോട് മാത്രം സ്പർശിക്കുന്നതല്ല). ഈ രേഖയോടൊപ്പം കാഗിതത്തിന്റെ അടിഭാഗം അല്ലെങ്കിൽ വലത് ഭാഗം പിന്നീട് ഉപേക്ഷിക്കുന്നു.\nഉത്തരം 10^9+7 മോഡുലോ ആയിരിക്കണം.\n\nഉദാഹരണത്തിന്:\n    >>> f_42(3, 3, 4)\n    3\n*/\nlong long f_42(int n, int m, long long k)", "fa": "#include <stdio.h>\n#include <assert.h>\n/*\nبا توجه به یک کاغذ مستطیلی به ابعاد n x m که در یک سیستم مختصات دکارتی صفحه‌ای قرار دارد و گوشه پایین-چپ آن در نقطه (0,0) و گوشه بالا-راست آن در نقطه (n,m) است،\nشما باید تعداد عملیات مورد انتظار برای بریدن کاغذ را محاسبه کنید به طوری که مساحت باقی‌مانده کمتر از k باشد.\nدر هر عملیات، یک خط به صورت تصادفی انتخاب می‌شود که موازی با محورها است، از نقاط با مختصات صحیح عبور می‌کند و از کاغذ می‌گذرد (نه فقط لبه را لمس کند). سپس قسمت پایین یا راست کاغذ در امتداد این خط دور ریخته می‌شود.\nپاسخ باید به صورت مدولوی 10^9+7 باشد.\n\nبرای مثال:\n    >>> f_42(3, 3, 4)\n    3\n*/\nlong long f_42(int n, int m, long long k)\n"}, "canonical_solution": "{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n    if (k > (long long)n * m) {\n        return 0;\n    }\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}", "instruction": {"en": "Write a C function `long long f_42(int n, int m, long long k)` to solve the following problem:\nGiven a rectangle paper of size n x m placed on a plane Cartesian coordinate system with its bottom-left corner at (0,0) and top-right corner at (n,m), \nyou need to calculate the expected number of operations to cut the paper such that the remaining area is less than k. \nIn each operation, a line is randomly chosen that is parallel to the axes, passes through points with integer coordinates, and cuts through (not just touching the edge) the paper. The bottom or right part of the paper along this line is then discarded.\nThe answer should be modulo 10^9+7.\n\nFor example:\n    >>> f_42(3, 3, 4)\n    3\n", "sq": "Shkruani një funksion në C `long long f_42(int n, int m, long long k)` për të zgjidhur problemin e mëposhtëm:\nDuke pasur një letër drejtkëndëshe me madhësi n x m të vendosur në një sistem koordinativ kartesian të planit me këndin e poshtëm të majtë në (0,0) dhe këndin e sipërm të djathtë në (n,m),\nduhet të llogaritni numrin e pritur të operacioneve për të prerë letrën në mënyrë që sipërfaqja e mbetur të jetë më pak se k.\nNë secilën operacion, zgjidhet rastësisht një vijë që është paralele me boshtet, kalon nëpër pika me koordinata të plota dhe pret (jo vetëm prek buzën) letrën. Pjesa e poshtme ose e djathtë e letrës përgjatë kësaj vije pastaj hidhet.\nPërgjigjja duhet të jetë modulo 10^9+7.\n\nPër shembull:\n    >>> f_42(3, 3, 4)\n    3", "hy": "Գրեք C ֆունկցիա `long long f_42(int n, int m, long long k)` հետևյալ խնդիրը լուծելու համար:\nՈւնենալով n x m չափսի ուղղանկյուն թուղթ, որը տեղադրված է հարթության Կարտեզյան համակարգում՝ իր ներքևի ձախ անկյունը (0,0) կետում և վերևի աջ անկյունը (n,m) կետում, \nպետք է հաշվարկել գործողությունների սպասվող քանակը՝ թուղթը կտրելու համար այնպես, որ մնացած տարածքը լինի փոքր քան k: \nՅուրաքանչյուր գործողության ժամանակ պատահականորեն ընտրվում է գիծ, որը զուգահեռ է առանցքներին, անցնում է ամբողջ թվային կոորդինատներով կետերով և կտրում է թուղթը (ոչ միայն հպվում է եզրին): Թղթի այս գծի երկայնքով ներքևի կամ աջ մասը ապա հեռացվում է:\nՊատասխանը պետք է լինի 10^9+7 մոդուլով:\n\nՕրինակ:\n    >>> f_42(3, 3, 4)\n    3", "bn": "একটি C ফাংশন `long long f_42(int n, int m, long long k)` লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\nএকটি আয়তাকার কাগজের টুকরো, আকার n x m, একটি সমতল কার্টেসিয়ান স্থানাঙ্ক পদ্ধতিতে রাখা হয়েছে যার নিচের-বাম কোণ (0,0) এবং উপরের-ডান কোণ (n,m) এ অবস্থিত,\nআপনাকে কাগজ কাটার প্রত্যাশিত সংখ্যক অপারেশন গণনা করতে হবে যাতে অবশিষ্ট এলাকা k এর চেয়ে কম হয়।\nপ্রতিটি অপারেশনে, একটি লাইন এলোমেলোভাবে বেছে নেওয়া হয় যা অক্ষের সমান্তরাল, পূর্ণসংখ্যা স্থানাঙ্ক সহ বিন্দুগুলির মধ্য দিয়ে যায়, এবং কাগজের মধ্য দিয়ে কেটে যায় (শুধুমাত্র প্রান্ত স্পর্শ নয়)। এই লাইনের বরাবর কাগজের নিচের বা ডান দিকের অংশটি তারপর বাতিল করা হয়।\nউত্তরটি 10^9+7 মডুলোতে হওয়া উচিত।\n\nউদাহরণস্বরূপ:\n    >>> f_42(3, 3, 4)\n    3", "bg": "Напишете C функция `long long f_42(int n, int m, long long k)`, за да решите следния проблем:\nДаден е правоъгълен лист хартия с размер n x m, разположен в равнинна декартова координатна система с долния ляв ъгъл в (0,0) и горния десен ъгъл в (n,m),\nтрябва да изчислите очаквания брой операции за рязане на хартията така, че оставащата площ да е по-малка от k.\nПри всяка операция се избира на случаен принцип линия, която е успоредна на осите, минава през точки с цели координати и пресича (не само докосва ръба) хартията. Долната или дясната част на хартията по тази линия след това се изхвърля.\nОтговорът трябва да бъде модул 10^9+7.\n\nНапример:\n    >>> f_42(3, 3, 4)\n    3", "zh": "编写一个 C 函数 `long long f_42(int n, int m, long long k)` 来解决以下问题：\n给定一个大小为 n x m 的矩形纸张，放置在平面笛卡尔坐标系中，其左下角在 (0,0)，右上角在 (n,m)，  \n你需要计算切割纸张的期望操作次数，使得剩余面积小于 k。  \n在每次操作中，随机选择一条平行于坐标轴的线，该线通过具有整数坐标的点，并切割（不仅仅是接触边缘）纸张。然后沿着这条线丢弃纸张的底部或右侧部分。  \n答案应对 10^9+7 取模。  \n\n例如：  \n    >>> f_42(3, 3, 4)  \n    3  ", "fr": "Écrire une fonction C `long long f_42(int n, int m, long long k)` pour résoudre le problème suivant :\nÉtant donné un papier rectangulaire de taille n x m placé sur un système de coordonnées cartésiennes avec son coin inférieur gauche à (0,0) et son coin supérieur droit à (n,m), \nvous devez calculer le nombre attendu d'opérations pour couper le papier de sorte que la surface restante soit inférieure à k. \nÀ chaque opération, une ligne est choisie au hasard, parallèle aux axes, passant par des points avec des coordonnées entières, et coupant (pas seulement touchant le bord) le papier. La partie inférieure ou droite du papier le long de cette ligne est alors jetée.\nLa réponse doit être modulo 10^9+7.\n\nPar exemple :\n    >>> f_42(3, 3, 4)\n    3", "de": "Schreiben Sie eine C-Funktion `long long f_42(int n, int m, long long k)`, um das folgende Problem zu lösen:\nGegeben ist ein rechteckiges Papier der Größe n x m, das in einem kartesischen Koordinatensystem auf einer Ebene liegt, mit seiner unteren linken Ecke bei (0,0) und der oberen rechten Ecke bei (n,m). \nSie müssen die erwartete Anzahl von Operationen berechnen, um das Papier so zu schneiden, dass die verbleibende Fläche kleiner als k ist. \nBei jeder Operation wird eine Linie zufällig gewählt, die parallel zu den Achsen verläuft, durch Punkte mit ganzzahligen Koordinaten geht und das Papier durchschneidet (nicht nur den Rand berührt). Der untere oder rechte Teil des Papiers entlang dieser Linie wird dann verworfen.\nDie Antwort sollte modulo 10^9+7 sein.\n\nZum Beispiel:\n    >>> f_42(3, 3, 4)\n    3", "ha": "Rubuta aikin C `long long f_42(int n, int m, long long k)` don warware matsalar mai zuwa:\nAn ba da takarda murabba'i mai girman n x m da aka sanya a kan tsarin daidaitawa na Cartesian tare da kusurwar ƙasa-hagu a (0,0) da kusurwar sama-dama a (n,m), \ndole ne ka ƙididdige adadin ayyukan da ake tsammani don yanke takardar ta yadda yankin da ya rage ya kasance ƙasa da k. \nA kowane aiki, ana zaɓar layi da bazuwar wanda yake daidai da ginshiƙai, yana wucewa ta wuraren da ke da daidaitattun lambobi, kuma yana yanke (ba kawai taɓa gefen ba) takardar. Ana watsar da ɓangaren ƙasa ko dama na takardar tare da wannan layin.\nAmsar ya kamata ta kasance modulo 10^9+7.\n\nMisali:\n    >>> f_42(3, 3, 4)\n    3", "hi": "C फ़ंक्शन `long long f_42(int n, int m, long long k)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिया गया एक आयताकार कागज़ जिसका आकार n x m है, जो एक समतल कार्टेशियन निर्देशांक प्रणाली पर रखा गया है, जिसका निचला-बायां कोना (0,0) पर है और ऊपरी-दायां कोना (n,m) पर है, \nआपको उन ऑपरेशनों की अपेक्षित संख्या की गणना करने की आवश्यकता है ताकि कागज़ को इस प्रकार काटा जा सके कि शेष क्षेत्रफल k से कम हो। \nप्रत्येक ऑपरेशन में, एक रेखा यादृच्छिक रूप से चुनी जाती है जो अक्षों के समानांतर होती है, पूर्णांक निर्देशांक वाले बिंदुओं से होकर गुजरती है, और कागज़ को काटती है (सिर्फ किनारे को छूने तक नहीं)। इस रेखा के साथ कागज़ का निचला या दायां भाग तब हटा दिया जाता है।\nउत्तर 10^9+7 के मापांक में होना चाहिए।\n\nउदाहरण के लिए:\n    >>> f_42(3, 3, 4)\n    3", "hu": "Írj egy C függvényt `long long f_42(int n, int m, long long k)` a következő probléma megoldására:\nAdott egy n x m méretű téglalap alakú papír, amely egy síkbeli derékszögű koordináta-rendszerben helyezkedik el, az alsó-bal sarka a (0,0) pontban, és a felső-jobb sarka az (n,m) pontban van. \nKi kell számítanod a várható műveletek számát, hogy a papírt úgy vágd el, hogy a megmaradt terület kisebb legyen, mint k. \nMinden művelet során véletlenszerűen választunk egy vonalat, amely párhuzamos a tengelyekkel, egész koordinátájú pontokon halad át, és átvágja (nem csak érinti a szélét) a papírt. A papír ezen vonal mentén lévő alsó vagy jobb részét eldobja.\nA válasznak modulo 10^9+7 kell lennie.\n\nPéldául:\n    >>> f_42(3, 3, 4)\n    3", "es": "Escribe una función en C `long long f_42(int n, int m, long long k)` para resolver el siguiente problema:\nDado un papel rectangular de tamaño n x m colocado en un sistema de coordenadas Cartesianas en el plano con su esquina inferior izquierda en (0,0) y la esquina superior derecha en (n,m),\nnecesitas calcular el número esperado de operaciones para cortar el papel de tal manera que el área restante sea menor que k.\nEn cada operación, se elige aleatoriamente una línea que es paralela a los ejes, pasa por puntos con coordenadas enteras, y corta (no solo toca el borde) el papel. La parte inferior o derecha del papel a lo largo de esta línea es entonces descartada.\nLa respuesta debe ser módulo 10^9+7.\n\nPor ejemplo:\n    >>> f_42(3, 3, 4)\n    3", "arb": "اكتب دالة بلغة C `long long f_42(int n, int m, long long k)` لحل المشكلة التالية:\nبالنظر إلى ورقة مستطيلة بحجم n x m موضوعة على نظام إحداثيات ديكارتي مستوٍ مع وجود زاويتها السفلية اليسرى عند (0,0) والزاوية العلوية اليمنى عند (n,m)،\nتحتاج إلى حساب العدد المتوقع من العمليات لقطع الورقة بحيث تكون المساحة المتبقية أقل من k.\nفي كل عملية، يتم اختيار خط عشوائيًا يكون موازيًا للمحاور، ويمر عبر نقاط ذات إحداثيات صحيحة، ويقطع (وليس فقط يلامس الحافة) الورقة. ثم يتم التخلص من الجزء السفلي أو الأيمن من الورقة على طول هذا الخط.\nيجب أن تكون الإجابة موديولو 10^9+7.\n\nعلى سبيل المثال:\n    >>> f_42(3, 3, 4)\n    3", "sw": "Andika kazi ya C `long long f_42(int n, int m, long long k)` kutatua tatizo lifuatalo:\nUkipatiwa karatasi ya mstatili yenye ukubwa wa n x m iliyowekwa kwenye mfumo wa kuratibu wa Cartesian kwenye ndege na kona yake ya chini-kushoto iko kwenye (0,0) na kona ya juu-kulia iko kwenye (n,m), unahitaji kuhesabu idadi inayotarajiwa ya operesheni za kukata karatasi ili eneo lililobaki liwe chini ya k.  \nKatika kila operesheni, mstari unachaguliwa kwa nasibu ambao ni sambamba na mhimili, unapita kwenye pointi zenye kuratibu za namba kamili, na unakata (sio tu kugusa ukingo) karatasi. Sehemu ya chini au ya kulia ya karatasi kando ya mstari huu kisha inatupwa.  \nJibu linapaswa kuwa modulo 10^9+7.  \n\nKwa mfano:\n    >>> f_42(3, 3, 4)\n    3", "tr": "Bir C fonksiyonu `long long f_42(int n, int m, long long k)` yazın ve aşağıdaki problemi çözün:\nn x m boyutunda bir dikdörtgen kağıt, alt-sol köşesi (0,0) ve üst-sağ köşesi (n,m) olan bir Kartezyen koordinat sistemine yerleştirilmiştir. \nKağıdın kalan alanının k'dan küçük olması için gereken işlemlerin beklenen sayısını hesaplamanız gerekiyor. \nHer işlemde, eksenlere paralel olan, tam sayı koordinatlarına sahip noktalardan geçen ve kağıdı kesen (sadece kenara dokunmayan) bir çizgi rastgele seçilir. Bu çizgi boyunca kağıdın alt veya sağ kısmı atılır.\nCevap 10^9+7 ile mod alınmalıdır.\n\nÖrneğin:\n    >>> f_42(3, 3, 4)\n    3", "vi": "Viết một hàm C `long long f_42(int n, int m, long long k)` để giải quyết vấn đề sau:\nCho một tờ giấy hình chữ nhật kích thước n x m đặt trên hệ tọa độ phẳng Cartesian với góc dưới bên trái tại (0,0) và góc trên bên phải tại (n,m), bạn cần tính số lượng thao tác kỳ vọng để cắt tờ giấy sao cho diện tích còn lại nhỏ hơn k. \nTrong mỗi thao tác, một đường thẳng được chọn ngẫu nhiên song song với các trục, đi qua các điểm có tọa độ nguyên, và cắt qua (không chỉ chạm vào cạnh) tờ giấy. Phần dưới hoặc bên phải của tờ giấy dọc theo đường này sau đó bị loại bỏ.\nCâu trả lời phải được tính theo modulo 10^9+7.\n\nVí dụ:\n    >>> f_42(3, 3, 4)\n    3", "id": "Tulis sebuah fungsi C `long long f_42(int n, int m, long long k)` untuk menyelesaikan masalah berikut:\nDiberikan sebuah kertas persegi panjang berukuran n x m yang ditempatkan pada sistem koordinat Kartesius dengan sudut kiri bawah di (0,0) dan sudut kanan atas di (n,m),\nAnda perlu menghitung jumlah operasi yang diharapkan untuk memotong kertas sehingga area yang tersisa kurang dari k.\nDalam setiap operasi, sebuah garis dipilih secara acak yang sejajar dengan sumbu, melewati titik-titik dengan koordinat bilangan bulat, dan memotong (bukan hanya menyentuh tepi) kertas. Bagian bawah atau kanan dari kertas sepanjang garis ini kemudian dibuang.\nJawabannya harus dalam modulo 10^9+7.\n\nSebagai contoh:\n    >>> f_42(3, 3, 4)\n    3", "ja": "Cの関数を書け `long long f_42(int n, int m, long long k)` を作成して、次の問題を解決してください:\nn x m のサイズの長方形の紙が、(0,0) に左下の角があり、(n,m) に右上の角がある平面直交座標系上に置かれています。紙を切る操作の期待回数を計算する必要があります。その結果、残りの面積が k 未満になるようにします。\n各操作では、軸に平行で、整数座標を持つ点を通り、紙を切断する（エッジに触れるだけではない）線がランダムに選ばれます。この線に沿って紙の下部または右側が破棄されます。\n答えは 10^9+7 での剰余として求める必要があります。\n\n例えば:\n    >>> f_42(3, 3, 4)\n    3", "ko": "C 함수 `long long f_42(int n, int m, long long k)`를 작성하여 다음 문제를 해결하십시오:\n크기가 n x m인 직사각형 종이가 평면 직교 좌표계에 놓여 있으며, 왼쪽 아래 모퉁이는 (0,0)에, 오른쪽 위 모퉁이는 (n,m)에 있습니다. \n남은 면적이 k보다 작아지도록 종이를 자르는 작업의 기대 횟수를 계산해야 합니다. \n각 작업에서, 축에 평행하고 정수 좌표를 지나는 선이 무작위로 선택되어 종이를 자릅니다(단순히 가장자리를 만지는 것이 아님). 그런 다음 이 선을 따라 종이의 아래쪽 또는 오른쪽 부분이 버려집니다.\n답은 10^9+7로 나눈 나머지여야 합니다.\n\n예를 들어:\n    >>> f_42(3, 3, 4)\n    3", "ml": "ഒരു C ഫംഗ്ഷൻ എഴുതുക `long long f_42(int n, int m, long long k)` ചുവടെയുള്ള പ്രശ്നം പരിഹരിക്കാൻ:\nഒരു n x m വലിപ്പമുള്ള ചതുരാകൃതിയിലുള്ള പേപ്പർ ഒരു പ്ലെയിൻ കാർട്ടീഷ്യൻ കോഓർഡിനേറ്റ് സിസ്റ്റത്തിൽ (0,0) എന്ന ബോട്ടം-ലെഫ്റ്റ് കോർണറും (n,m) എന്ന ടോപ്പ്-റൈറ്റ് കോർണറും ഉള്ളതായി നൽകിയിരിക്കുന്നു, \nനിലവിലുള്ള വിസ്തീർണ്ണം k-ൽ കുറവായിരിക്കാനുള്ള പ്രവർത്തനങ്ങളുടെ പ്രതീക്ഷിത സംഖ്യ കണക്കാക്കേണ്ടതുണ്ട്. \nഓരോ പ്രവർത്തനത്തിലും, ആക്സിസുകളോട് സമാന്തരമായ, പൂർണ്ണസംഖ്യാ കോഓർഡിനേറ്റുകളുള്ള പോയിന്റുകൾ വഴി കടന്നുപോകുന്ന ഒരു വരി യാദൃശ്ചികമായി തിരഞ്ഞെടുക്കപ്പെടുന്നു, അത് പേപ്പറിലൂടെ (വരമ്പ് മാത്രം സ്പർശിക്കുന്നതല്ല) കടക്കുന്നു. ഈ വരിയോടൊപ്പം പേപ്പറിന്റെ ബോട്ടം അല്ലെങ്കിൽ റൈറ്റ് ഭാഗം പിന്നീട് ഉപേക്ഷിക്കപ്പെടുന്നു.\nഉത്തരം 10^9+7 നു മോഡുലോ ആയിരിക്കണം.\n\nഉദാഹരണത്തിന്:\n    >>> f_42(3, 3, 4)\n    3", "fa": "یک تابع C به نام `long long f_42(int n, int m, long long k)` بنویسید تا مسئله زیر را حل کند:\nبا توجه به یک کاغذ مستطیلی به اندازه n x m که در یک سیستم مختصات دکارتی صفحه قرار دارد و گوشه پایین-چپ آن در (0,0) و گوشه بالا-راست آن در (n,m) است، \nشما باید تعداد عملیات مورد انتظار برای بریدن کاغذ را محاسبه کنید به طوری که مساحت باقی‌مانده کمتر از k باشد. \nدر هر عملیات، یک خط به صورت تصادفی انتخاب می‌شود که موازی با محور‌ها است، از نقاط با مختصات صحیح عبور می‌کند و از کاغذ عبور می‌کند (نه فقط لبه را لمس کند). قسمت پایین یا راست کاغذ در امتداد این خط سپس دور انداخته می‌شود.\nپاسخ باید به صورت مدولوی 10^9+7 باشد.\n\nبرای مثال:\n    >>> f_42(3, 3, 4)\n    3"}, "level": "hard", "test": "int main() {\n    assert(f_42(2, 4, 10) == 0);\n    assert(f_42(2, 4, 8) == 1);\n    assert(f_42(2, 4, 2) == 833333342);\n    assert(f_42(2, 4, 6) == 250000003);\n    assert(f_42(3, 3, 4) == 666666673);\n    assert(f_42(5, 5, 12) == 666666673);\n    assert(f_42(6, 7, 20) == 722222229);\n    assert(f_42(8, 8, 30) == 72727275);\n    assert(f_42(10, 10, 50) == 714285721);\n    assert(f_42(1, 10, 5) == 945634929);\n    assert(f_42(10, 1, 5) == 945634929);\n    return 0;\n}", "entry_point": "f_42", "signature": "long long f_42(int n, int m, long long k)", "docstring": {"en": "Given a rectangle paper of size n x m placed on a plane Cartesian coordinate system with its bottom-left corner at (0,0) and top-right corner at (n,m), \nyou need to calculate the expected number of operations to cut the paper such that the remaining area is less than k. \nIn each operation, a line is randomly chosen that is parallel to the axes, passes through points with integer coordinates, and cuts through (not just touching the edge) the paper. The bottom or right part of the paper along this line is then discarded.\nThe answer should be modulo 10^9+7.\n\nFor example:\n    >>> f_42(3, 3, 4)\n    3\n", "sq": "Duke pasur një letër drejtkëndëshe me përmasa n x m të vendosur në një sistem koordinativ Kartezian në plan me këndin e poshtëm të majtë në (0,0) dhe këndin e sipërm të djathtë në (n,m), ju duhet të llogaritni numrin e pritur të operacioneve për të prerë letrën në mënyrë që sipërfaqja e mbetur të jetë më pak se k. Në çdo operacion, zgjidhet rastësisht një vijë që është paralele me boshtet, kalon nëpër pika me koordinata të plota, dhe pret (jo vetëm duke prekur skajin) letrën. Pjesa e poshtme ose e djathtë e letrës përgjatë kësaj vije pastaj hidhet poshtë. Përgjigja duhet të jetë modulo 10^9+7.\n\nPër shembull:\n    >>> f_42(3, 3, 4)\n    3", "hy": "Ունենալով n x m չափսի ուղղանկյուն թուղթ, որը տեղադրված է հարթության Կարտեզյան կոորդինատային համակարգում՝ իր ներքևի ձախ անկյունով (0,0) կետում և վերևի աջ անկյունով (n,m) կետում, \nպետք է հաշվարկել սպասվող գործողությունների քանակը՝ թուղթը կտրելու համար այնպես, որ մնացած մակերեսը լինի k-ից փոքր։ \nՅուրաքանչյուր գործողության ժամանակ պատահականորեն ընտրվում է մի գիծ, որը զուգահեռ է առանցքներին, անցնում է ամբողջ թվային կոորդինատներով կետերով և կտրում է թուղթը (ոչ միայն եզրին դիպչելով)։ Թղթի այդ գծի երկայնքով ներքևի կամ աջ մասը ապա հեռացվում է։\nՊատասխանը պետք է լինի 10^9+7 մոդուլով։\n\nՕրինակ:\n    >>> f_42(3, 3, 4)\n    3", "bn": "একটি আয়তাকার কাগজের আকার n x m একটি সমতল কার্টেসিয়ান স্থানাঙ্ক পদ্ধতিতে রাখা হয়েছে যার নিচের-বাম কোণ (0,0) এবং উপরের-ডান কোণ (n,m) এ, \nআপনাকে এমনভাবে কাগজ কাটার প্রত্যাশিত সংখ্যক অপারেশন গণনা করতে হবে যাতে অবশিষ্ট এলাকা k এর চেয়ে কম হয়। \nপ্রতিটি অপারেশনে, একটি লাইন এলোমেলোভাবে নির্বাচিত হয় যা অক্ষের সমান্তরাল, পূর্ণসংখ্যা স্থানাঙ্ক সহ বিন্দুগুলির মধ্য দিয়ে যায়, এবং কাগজের মধ্য দিয়ে কাটে (শুধুমাত্র প্রান্ত স্পর্শ নয়)। এই লাইনের বরাবর কাগজের নিচের বা ডান অংশটি তখন বাতিল করা হয়।\nউত্তরটি 10^9+7 দ্বারা মডুলো হতে হবে।\n\nউদাহরণস্বরূপ:\n    >>> f_42(3, 3, 4)\n    3", "bg": "Даден е правоъгълен лист хартия с размер n x m, поставен в равнинна декартова координатна система с долен ляв ъгъл в (0,0) и горен десен ъгъл в (n,m), \nтрябва да изчислите очаквания брой операции за изрязване на хартията така, че оставащата площ да е по-малка от k. \nПри всяка операция се избира произволна линия, която е успоредна на осите, минава през точки с цели координати и пресича (не само докосва ръба) хартията. Долната или дясната част на хартията по тази линия след това се изхвърля.\nОтговорът трябва да бъде модул 10^9+7.\n\nНапример:\n    >>> f_42(3, 3, 4)\n    3", "zh": "给定一个大小为 n x m 的矩形纸张，放置在平面直角坐标系中，其左下角在 (0,0)，右上角在 (n,m)。你需要计算切割纸张的期望操作次数，使得剩余面积小于 k。在每次操作中，随机选择一条与坐标轴平行的线，该线通过整数坐标的点，并切割（不仅仅是触及边缘）纸张。然后沿着这条线丢弃纸张的底部或右侧部分。答案应对 10^9+7 取模。\n\n例如：\n    >>> f_42(3, 3, 4)\n    3", "fr": "Étant donné un papier rectangulaire de taille n x m placé sur un système de coordonnées cartésiennes avec son coin inférieur gauche à (0,0) et son coin supérieur droit à (n,m), vous devez calculer le nombre attendu d'opérations pour couper le papier de sorte que la surface restante soit inférieure à k. \nDans chaque opération, une ligne est choisie aléatoirement, parallèle aux axes, passant par des points avec des coordonnées entières, et coupant (pas seulement touchant le bord) le papier. La partie inférieure ou droite du papier le long de cette ligne est ensuite jetée.\nLa réponse doit être modulo 10^9+7.\n\nPar exemple :\n    >>> f_42(3, 3, 4)\n    3", "de": "Gegeben ist ein rechteckiges Papier der Größe n x m, das in einem kartesischen Koordinatensystem auf einer Ebene liegt, mit seiner unteren linken Ecke bei (0,0) und der oberen rechten Ecke bei (n,m). \nSie müssen die erwartete Anzahl von Operationen berechnen, um das Papier so zu schneiden, dass die verbleibende Fläche kleiner als k ist. \nBei jeder Operation wird eine Linie zufällig gewählt, die parallel zu den Achsen verläuft, durch Punkte mit ganzzahligen Koordinaten geht und das Papier durchschneidet (nicht nur den Rand berührt). Der untere oder rechte Teil des Papiers entlang dieser Linie wird dann verworfen.\nDie Antwort sollte modulo 10^9+7 sein.\n\nZum Beispiel:\n    >>> f_42(3, 3, 4)\n    3", "ha": "An ba takardar murabba'i mai girman n x m da aka sanya a tsarin daidaitawar Cartesian tare da kusurwar ƙasa-hagu a (0,0) da kusurwar sama-dama a (n,m), \nkana buƙatar lissafin yawan ayyukan da ake tsammani don yanke takardar ta yadda yankin da ya rage ya zama ƙasa da k. \nA kowane aiki, ana zaɓar wata layi da ba a san ta ba wadda ke daidai da ginshiƙai, ta wuce ta wuraren da ke da daidaitawa na lamba, kuma ta yanke (ba kawai ta taɓa gefen ba) takardar. Ana watsar da ɓangaren ƙasa ko dama na takardar tare da wannan layin.\nAmsar ya kamata ta zama modulo 10^9+7.\n\nMisali:\n    >>> f_42(3, 3, 4)\n    3", "hi": "एक n x m आकार के आयताकार कागज को एक समतल कार्टेशियन निर्देशांक प्रणाली पर रखा गया है, जिसकी निचली-बाईं कोने पर स्थिति (0,0) और ऊपरी-दाईं कोने पर स्थिति (n,m) है। \nआपको उन ऑपरेशनों की अपेक्षित संख्या की गणना करनी है ताकि कागज का शेष क्षेत्रफल k से कम हो जाए। \nप्रत्येक ऑपरेशन में, एक रेखा को यादृच्छिक रूप से चुना जाता है जो अक्षों के समानांतर होती है, पूर्णांक निर्देशांक वाले बिंदुओं से गुजरती है, और कागज को काटती है (सिर्फ किनारे को छूने वाली नहीं)। इस रेखा के साथ कागज का निचला या दायां हिस्सा फिर त्याग दिया जाता है।\nउत्तर 10^9+7 के मापांक में होना चाहिए।\n\nउदाहरण के लिए:\n    >>> f_42(3, 3, 4)\n    3", "hu": "Adott egy n x m méretű téglalap alakú papír, amely a sík Descartes-koordináta-rendszerben helyezkedik el, az alsó-bal sarka a (0,0) pontban, a felső-jobb sarka pedig az (n,m) pontban van. \nKi kell számítani a várható műveletek számát, hogy a papírt úgy vágjuk el, hogy a megmaradt terület kisebb legyen, mint k. \nMinden művelet során véletlenszerűen választunk egy vonalat, amely párhuzamos a tengelyekkel, egész koordinátájú pontokon halad át, és átvágja (nem csak érinti a szélét) a papírt. A papír ezen vonal mentén lévő alsó vagy jobb része ezután el lesz dobva.\nA válasz legyen 10^9+7 modulo.\n\nPéldául:\n    >>> f_42(3, 3, 4)\n    3", "es": "Dado un papel rectangular de tamaño n x m colocado en un sistema de coordenadas cartesianas en un plano con su esquina inferior izquierda en (0,0) y la esquina superior derecha en (n,m), \nnecesitas calcular el número esperado de operaciones para cortar el papel de tal manera que el área restante sea menor que k. \nEn cada operación, se elige aleatoriamente una línea que es paralela a los ejes, pasa por puntos con coordenadas enteras, y corta (no solo toca el borde) el papel. La parte inferior o derecha del papel a lo largo de esta línea es entonces descartada.\nLa respuesta debe ser módulo 10^9+7.\n\nPor ejemplo:\n    >>> f_42(3, 3, 4)\n    3", "arb": "معطى ورقة مستطيلة بحجم n x m موضوعة على نظام إحداثيات ديكارتي مستوي مع وجود الزاوية السفلية اليسرى عند (0,0) والزواية العلوية اليمنى عند (n,m)، \nتحتاج إلى حساب العدد المتوقع من العمليات لقطع الورقة بحيث تكون المساحة المتبقية أقل من k. \nفي كل عملية، يتم اختيار خط عشوائي موازي للمحاور، يمر بنقاط ذات إحداثيات صحيحة، ويقطع (وليس فقط يلامس الحافة) الورقة. يتم بعد ذلك التخلص من الجزء السفلي أو الأيمن من الورقة على طول هذا الخط.\nيجب أن تكون الإجابة موديولو 10^9+7.\n\nعلى سبيل المثال:\n    >>> f_42(3, 3, 4)\n    3", "sw": "Ukipata karatasi ya mstatili ya ukubwa n x m iliyowekwa kwenye mfumo wa kuratibu wa Cartesian wa ndege na kona yake ya chini-kushoto iko kwenye (0,0) na kona ya juu-kulia iko kwenye (n,m), unahitaji kuhesabu idadi inayotarajiwa ya operesheni za kukata karatasi ili eneo lililobaki liwe chini ya k. Katika kila operesheni, mstari unachaguliwa kwa nasibu ambao ni sambamba na mhimili, unapita kwenye pointi zilizo na kuratibu za nambari nzima, na unakata (si kugusa tu ukingo) karatasi. Sehemu ya chini au ya kulia ya karatasi kando ya mstari huu kisha hutupwa. Jibu linapaswa kuwa modulo 10^9+7.\n\nKwa mfano:\n    >>> f_42(3, 3, 4)\n    3", "tr": "Verilen bir dikdörtgen kağıt, bir düzlem Kartezyen koordinat sisteminde (0,0) noktasında alt-sol köşesi ve (n,m) noktasında üst-sağ köşesi olacak şekilde yerleştirilmiştir. \nKağıdın kalan alanının k'dan küçük olması için gereken beklenen işlem sayısını hesaplamanız gerekmektedir. \nHer işlemde, eksenlere paralel olan, tam sayı koordinatlarına sahip noktalardan geçen ve kağıdı kesen (sadece kenara dokunmayan) bir çizgi rastgele seçilir. Bu çizgi boyunca kağıdın alt veya sağ kısmı atılır.\nCevap 10^9+7 ile mod alınmalıdır.\n\nÖrneğin:\n    >>> f_42(3, 3, 4)\n    3", "vi": "Cho một tờ giấy hình chữ nhật kích thước n x m đặt trên hệ tọa độ phẳng Descartes với góc dưới bên trái tại (0,0) và góc trên bên phải tại (n,m), bạn cần tính số lần cắt kỳ vọng để cắt giấy sao cho diện tích còn lại nhỏ hơn k. Trong mỗi lần cắt, một đường thẳng được chọn ngẫu nhiên, song song với các trục, đi qua các điểm có tọa độ nguyên, và cắt qua (không chỉ chạm vào cạnh) tờ giấy. Phần dưới hoặc bên phải của tờ giấy dọc theo đường này sau đó bị loại bỏ. Câu trả lời nên được tính theo modulo 10^9+7.\n\nVí dụ:\n    >>> f_42(3, 3, 4)\n    3", "id": "Diberikan selembar kertas berbentuk persegi panjang berukuran n x m yang ditempatkan pada sistem koordinat Kartesius dengan sudut kiri bawah di (0,0) dan sudut kanan atas di (n,m), Anda perlu menghitung jumlah operasi yang diharapkan untuk memotong kertas sedemikian rupa sehingga area yang tersisa kurang dari k. Dalam setiap operasi, sebuah garis dipilih secara acak yang sejajar dengan sumbu, melewati titik dengan koordinat bilangan bulat, dan memotong (tidak hanya menyentuh tepi) kertas. Bagian bawah atau kanan dari kertas sepanjang garis ini kemudian dibuang. Jawabannya harus dalam bentuk modulo 10^9+7.\n\nSebagai contoh:\n    >>> f_42(3, 3, 4)\n    3", "ja": "与えられた長方形の紙のサイズが n x m で、平面直交座標系に配置されており、その左下の角が (0,0)、右上の角が (n,m) にあるとします。紙の残りの面積が k 未満になるように切るための操作の期待回数を計算する必要があります。各操作では、軸に平行で、整数座標を持つ点を通り、紙を切断する（端に触れるだけではない）線がランダムに選ばれます。この線に沿った紙の下または右の部分は破棄されます。答えは 10^9+7 での剰余として求める必要があります。\n\n例:\n    >>> f_42(3, 3, 4)\n    3", "ko": "주어진 크기가 n x m인 직사각형 종이가 평면 직교 좌표계에 놓여 있으며, 왼쪽 아래 모서리는 (0,0)에, 오른쪽 위 모서리는 (n,m)에 있습니다. \n남은 면적이 k보다 작아지도록 종이를 자르는 작업의 기대 횟수를 계산해야 합니다. \n각 작업에서, 축에 평행하고 정수 좌표를 지나는 선이 무작위로 선택되어 종이를 자릅니다(단순히 가장자리를 만지는 것이 아님). 그런 다음 이 선을 따라 종이의 아래쪽 또는 오른쪽 부분이 버려집니다.\n답은 10^9+7로 나눈 나머지여야 합니다.\n\n예를 들어:\n    >>> f_42(3, 3, 4)\n    3", "ml": "ഒരു n x m വലിപ്പമുള്ള ചതുരശ്രാകൃതത്തിലുള്ള പേപ്പർ (0,0) എന്ന ബോട്ടം-ലെഫ്റ്റ് കോർണറിൽ നിന്നും (n,m) എന്ന ടോപ്പ്-റൈറ്റ് കോർണറിൽ വരെ ഒരു പ്ലെയിൻ കാർട്ടീഷ്യൻ കോഓർഡിനേറ്റ് സിസ്റ്റത്തിൽ വച്ച്, \nശേഷിക്കുന്ന വിസ്തീർണ്ണം k-ൽ കുറവായിരിക്കാനായി പേപ്പർ മുറിക്കാൻ ആവശ്യമായ പ്രതീക്ഷിക്കുന്ന പ്രവർത്തനങ്ങളുടെ എണ്ണം കണക്കാക്കേണ്ടതുണ്ട്. \nഓരോ പ്രവർത്തനത്തിലും, അച്ചുതണ്ടുകളോട് സമാന്തരമായ, പൂർണ്ണസംഖ്യാ കോഓർഡിനേറ്റുകളുള്ള പോയിന്റുകൾ വഴി കടക്കുന്ന, പേപ്പർ മുറിക്കുന്ന (വരമ്പിൽ മാത്രം സ്പർശിക്കുന്നതല്ല) ഒരു വരി യാദൃശ്ചികമായി തിരഞ്ഞെടുക്കപ്പെടുന്നു. ഈ വരിയോടൊപ്പം പേപ്പറിന്റെ ബോട്ടം അല്ലെങ്കിൽ റൈറ്റ് ഭാഗം പിന്നീട് ഉപേക്ഷിക്കുന്നു.\nഉത്തരം 10^9+7-ന്റെ മോഡുലോ ആയിരിക്കണം.\n\nഉദാഹരണത്തിന്:\n    >>> f_42(3, 3, 4)\n    3", "fa": "با توجه به یک کاغذ مستطیلی به ابعاد n x m که در یک سیستم مختصات دکارتی صفحه قرار دارد و گوشه پایین-چپ آن در نقطه (0,0) و گوشه بالا-راست آن در نقطه (n,m) قرار دارد، \nشما باید تعداد عملیات‌های مورد انتظار برای بریدن کاغذ را محاسبه کنید به طوری که مساحت باقی‌مانده کمتر از k باشد. \nدر هر عملیات، یک خط به صورت تصادفی انتخاب می‌شود که موازی با محور‌ها است، از نقاطی با مختصات صحیح عبور می‌کند و از کاغذ عبور می‌کند (نه فقط لبه را لمس کند). سپس قسمت پایین یا راست کاغذ در امتداد این خط حذف می‌شود.\nپاسخ باید به پیمانه 10^9+7 باشد.\n\nبرای مثال:\n    >>> f_42(3, 3, 4)\n    3"}}
{"task_id": "C/43", "prompt": {"en": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n/*\nGiven a permutation q of n elements and an integer k, find the number of permutations p of n elements such that f(p) = q, where f(p) is the lexicographically smallest permutation that can be obtained by dividing p into exactly k non-empty contiguous segments and sorting each segment(that is, choose $ k-1 $ breakpoints $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, and divide it into $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). The result should be modulo 998244353.\n    >>> f_43(2, 1, [1, 2])\n    2\n\n*/\nint f_43(int n, int k, int qq[])", "sq": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n/*\nDuke pasur një permutacion q të n elementeve dhe një numër të plotë k, gjeni numrin e permutacioneve p të n elementeve të tilla që f(p) = q, ku f(p) është permutacioni më i vogël leksikografik që mund të merret duke e ndarë p në saktësisht k segmente të pandashme dhe duke renditur secilin segment (kjo është, zgjidhni $ k-1 $ pika ndarjeje $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, dhe ndajeni në $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). Rezultati duhet të jetë modulo 998244353.\n    >>> f_43(2, 1, [1, 2])\n    2\n\n*/\nint f_43(int n, int k, int qq[])", "hy": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n/*\nՏրված է n տարրերի q փոխատեղումը և k ամբողջ թիվը, գտնել n տարրերի p փոխատեղումների քանակը, այնպես որ f(p) = q, որտեղ f(p)-ն լեքսիկոգրաֆիկորեն ամենափոքր փոխատեղումն է, որը կարելի է ստանալ p-ն ճշգրիտ k ոչ դատարկ հարակից հատվածների բաժանելով և յուրաքանչյուր հատվածը սորտավորելով (այսինքն, ընտրել $ k-1 $ կոտրման կետեր $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, և բաժանել այն $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $): Արդյունքը պետք է լինի 998244353 մոդուլով:\n    >>> f_43(2, 1, [1, 2])\n    2\n\n*/\nint f_43(int n, int k, int qq[])", "bn": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n/*\nn উপাদানের একটি permutation q এবং একটি পূর্ণসংখ্যা k দেওয়া আছে, এমন n উপাদানের কতগুলি permutation p আছে তা খুঁজে বের করুন যাতে f(p) = q, যেখানে f(p) হল lexicographically সবচেয়ে ছোট permutation যা ঠিক k টি non-empty contiguous segment এ p কে ভাগ করে এবং প্রতিটি segment কে sort করে পাওয়া যেতে পারে (অর্থাৎ, $ k-1 $ টি breakpoints $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $ নির্বাচন করুন, এবং এটিকে $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $ এ ভাগ করুন)। ফলাফলটি 998244353 দ্বারা modulo করা উচিত।\n    >>> f_43(2, 1, [1, 2])\n    2\n\n*/\nint f_43(int n, int k, int qq[])", "bg": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n/*\nДадена е пермутация q от n елемента и цяло число k, намерете броя на пермутациите p от n елемента, такива че f(p) = q, където f(p) е лексикографски най-малката пермутация, която може да бъде получена чрез разделяне на p на точно k непразни съседни сегменти и сортиране на всеки сегмент (т.е. изберете $ k-1 $ точки на прекъсване $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, и го разделете на $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). Резултатът трябва да бъде модуло 998244353.\n    >>> f_43(2, 1, [1, 2])\n    2\n\n*/\nint f_43(int n, int k, int qq[])", "zh": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n/*\n给定一个由 n 个元素组成的排列 q 和一个整数 k，找出有多少个排列 p 满足 f(p) = q，其中 f(p) 是通过将 p 精确地分成 k 个非空连续段并对每个段进行排序后得到的字典序最小的排列（即选择 $ k-1 $ 个断点 $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $，并将其分为 $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $）。结果应对 998244353 取模。\n    >>> f_43(2, 1, [1, 2])\n    2\n\n*/\nint f_43(int n, int k, int qq[])", "fr": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n/*\nÉtant donné une permutation q de n éléments et un entier k, trouvez le nombre de permutations p de n éléments telles que f(p) = q, où f(p) est la permutation lexicographiquement la plus petite qui peut être obtenue en divisant p en exactement k segments contigus non vides et en triant chaque segment (c'est-à-dire, choisissez $ k-1 $ points de rupture $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, et divisez-le en $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). Le résultat doit être modulo 998244353.\n    >>> f_43(2, 1, [1, 2])\n    2\n\n*/\nint f_43(int n, int k, int qq[])", "de": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n/*\nGegeben eine Permutation q von n Elementen und eine ganze Zahl k, finde die Anzahl der Permutationen p von n Elementen, so dass f(p) = q, wobei f(p) die lexikographisch kleinste Permutation ist, die durch Aufteilen von p in genau k nicht-leere zusammenhängende Segmente und Sortieren jedes Segments erhalten werden kann (das heißt, wähle $ k-1 $ Trennpunkte $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, und teile es in $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). Das Ergebnis sollte modulo 998244353 sein.\n    >>> f_43(2, 1, [1, 2])\n    2\n\n*/\nint f_43(int n, int k, int qq[])", "ha": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n/*\nAn ba da permutation q na abubuwa n da kuma lamba k, nemo yawan permutations p na abubuwa n irin cewa f(p) = q, inda f(p) shine permutation mafi ƙarami a cikin tsari na lexicographically wanda za a iya samu ta hanyar raba p zuwa daidai k sassa masu cike da abubuwa kuma a tsara kowane sashe (wato, zaɓi $ k-1 $ wuraren karya $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, kuma a raba shi zuwa $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). Sakamakon ya zama modulo 998244353.\n    >>> f_43(2, 1, [1, 2])\n    2\n\n*/\nint f_43(int n, int k, int qq[])", "hi": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n/*\nदिए गए n तत्वों के एक क्रमचय q और एक पूर्णांक k के लिए, n तत्वों के क्रमचयों की संख्या खोजें p ताकि f(p) = q, जहाँ f(p) वह शब्दकोशानुसार सबसे छोटा क्रमचय है जो p को ठीक k गैर-खाली संलग्न खंडों में विभाजित करके और प्रत्येक खंड को क्रमबद्ध करके प्राप्त किया जा सकता है (अर्थात, $ k-1 $ ब्रेकपॉइंट्स चुनें $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, और इसे $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $ में विभाजित करें)। परिणाम 998244353 के मापांक में होना चाहिए।\n    >>> f_43(2, 1, [1, 2])\n    2\n\n*/\nint f_43(int n, int k, int qq[])", "hu": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n/*\nAdott egy q permutáció n elemre és egy egész szám k, keresse meg azon p permutációk számát n elemre, amelyekre f(p) = q, ahol f(p) a lexikografikusan legkisebb permutáció, amelyet úgy kaphatunk meg, hogy p-t pontosan k nem üres szomszédos szegmensre osztjuk, és minden szegmenst sorba rendezünk (vagyis válasszuk ki a $ k-1 $ töréspontot $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, és osszuk fel $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $ részekre). Az eredménynek 998244353-mal vett maradéka legyen.\n    >>> f_43(2, 1, [1, 2])\n    2\n\n*/\nint f_43(int n, int k, int qq[])", "es": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n/*\nDada una permutación q de n elementos y un entero k, encuentra el número de permutaciones p de n elementos tal que f(p) = q, donde f(p) es la permutación lexicográficamente más pequeña que se puede obtener dividiendo p en exactamente k segmentos contiguos no vacíos y ordenando cada segmento (es decir, elige $ k-1 $ puntos de ruptura $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, y divídelo en $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). El resultado debe ser módulo 998244353.\n    >>> f_43(2, 1, [1, 2])\n    2\n\n*/\nint f_43(int n, int k, int qq[])", "arb": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n/*\nمعطى تبديل q لعناصر n وعدد صحيح k، ابحث عن عدد التبديلات p لعناصر n بحيث f(p) = q، حيث f(p) هو التبديل الأصغر لغوياً الذي يمكن الحصول عليه عن طريق تقسيم p إلى k مقاطع متجاورة غير فارغة وترتيب كل مقطع (أي، اختر $ k-1 $ نقاط توقف $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $، وقسمها إلى $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). يجب أن تكون النتيجة موديولو 998244353.\n    >>> f_43(2, 1, [1, 2])\n    2\n\n*/\nint f_43(int n, int k, int qq[])", "sw": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n/*\nIkizingatiwa mpangilio q wa vipengele n na nambari k, tafuta idadi ya mipangilio p ya vipengele n kama f(p) = q, ambapo f(p) ni mpangilio mdogo zaidi wa lexicographically ambao unaweza kupatikana kwa kugawanya p katika sehemu k zisizo tupu na kupanga kila sehemu (yaani, chagua $ k-1 $ sehemu za kuvunja $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, na igawanye katika $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). Matokeo yanapaswa kuwa modulo 998244353.\n    >>> f_43(2, 1, [1, 2])\n    2\n\n*/\nint f_43(int n, int k, int qq[])", "tr": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n/*\nn elemanlı bir q permütasyonu ve bir k tam sayısı verildiğinde, f(p) = q olacak şekilde n elemanlı kaç tane p permütasyonu olduğunu bulun, burada f(p), p'yi tam olarak k boş olmayan ardışık segmente bölerek ve her segmenti sıralayarak elde edilebilecek sözlük sırasına göre en küçük permütasyondur (yani, $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $ olacak şekilde $ k-1 $ kırılma noktası seçin ve bunu $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $ olarak bölün). Sonuç 998244353 ile mod alınmalıdır.\n    >>> f_43(2, 1, [1, 2])\n    2\n\n*/\nint f_43(int n, int k, int qq[])", "vi": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n/*\nCho một hoán vị q của n phần tử và một số nguyên k, tìm số lượng hoán vị p của n phần tử sao cho f(p) = q, trong đó f(p) là hoán vị nhỏ nhất theo thứ tự từ điển có thể thu được bằng cách chia p thành chính xác k đoạn liên tiếp không rỗng và sắp xếp từng đoạn (tức là, chọn $ k-1 $ điểm ngắt $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, và chia nó thành $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). Kết quả nên được lấy modulo 998244353.\n    >>> f_43(2, 1, [1, 2])\n    2\n\n*/\nint f_43(int n, int k, int qq[])", "id": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n/*\nDiberikan sebuah permutasi q dari n elemen dan sebuah bilangan bulat k, temukan jumlah permutasi p dari n elemen sedemikian rupa sehingga f(p) = q, di mana f(p) adalah permutasi terkecil secara leksikografis yang dapat diperoleh dengan membagi p menjadi tepat k segmen kontigu yang tidak kosong dan mengurutkan setiap segmen (yaitu, pilih $ k-1 $ titik putus $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, dan bagi menjadi $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). Hasilnya harus dalam modulo 998244353.\n    >>> f_43(2, 1, [1, 2])\n    2\n\n*/\nint f_43(int n, int k, int qq[])", "ja": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n/*\nn個の要素の順列qと整数kが与えられたとき、f(p) = qとなるn個の要素の順列pの数を求めます。ここで、f(p)はpをちょうどk個の非空の連続したセグメントに分割し、各セグメントをソートすることで得られる辞書順で最小の順列です（つまり、$ k-1 $のブレークポイント$ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $を選び、それを$ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $に分割します）。結果は998244353でのモジュロとします。\n    >>> f_43(2, 1, [1, 2])\n    2\n\n*/\nint f_43(int n, int k, int qq[])", "ko": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n/*\n주어진 n 요소의 순열 q와 정수 k가 주어졌을 때, f(p) = q인 n 요소의 순열 p의 개수를 찾으시오. 여기서 f(p)는 p를 정확히 k개의 비어 있지 않은 연속된 구간으로 나누고 각 구간을 정렬하여 얻을 수 있는 사전식으로 가장 작은 순열입니다(즉, $ k-1 $ 개의 분할점 $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $을 선택하고, $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $으로 나눕니다). 결과는 998244353로 나눈 나머지여야 합니다.\n    >>> f_43(2, 1, [1, 2])\n    2\n\n*/\nint f_43(int n, int k, int qq[])\n", "ml": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n/*\nn ഘടകങ്ങളുടെ ഒരു permutation q, ഒരു പൂർണ്ണസംഖ്യ k എന്നിവ നൽകിയാൽ, n ഘടകങ്ങളുടെ permutation p-കളുടെ എണ്ണം കണ്ടെത്തുക, f(p) = q ആകുന്നു, ഇവിടെ f(p) എന്നത് p-നെ കൃത്യമായി k ശൂന്യമല്ലാത്ത തുടർച്ചയായ സെഗ്മെന്റുകളായി വിഭജിച്ച് ഓരോ സെഗ്മെന്റും ക്രമീകരിച്ച് ലഭിക്കാവുന്ന ലെക്സികോഗ്രാഫിക്‌മായി ഏറ്റവും ചെറിയ permutation ആണ് (അത്, $ k-1 $ ബ്രേക്ക്പോയിന്റുകൾ $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $ തിരഞ്ഞെടുക്കുക, അതിനെ $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $ ആയി വിഭജിക്കുക). ഫലം 998244353-ന് മോഡുലോ ആയിരിക്കണം.\n    >>> f_43(2, 1, [1, 2])\n    2\n\n*/\nint f_43(int n, int k, int qq[])", "fa": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n/*\nبا توجه به جایگشت q از n عنصر و یک عدد صحیح k، تعداد جایگشت‌های p از n عنصر را پیدا کنید به طوری که f(p) = q، که در آن f(p) کوچک‌ترین جایگشت لغت‌نامه‌ای است که می‌توان با تقسیم p به دقیقا k بخش متوالی غیر خالی و مرتب‌سازی هر بخش به دست آورد (یعنی، $ k-1 $ نقاط شکست $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $ را انتخاب کنید و آن را به $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $ تقسیم کنید). نتیجه باید به پیمانه 998244353 باشد.\n    >>> f_43(2, 1, [1, 2])\n    2\n\n*/\nint f_43(int n, int k, int qq[])\n"}, "canonical_solution": "{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i ^ m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}", "instruction": {"en": "Write a C function `int f_43(int n, int k, int qq[])` to solve the following problem:\nGiven a permutation q of n elements and an integer k, find the number of permutations p of n elements such that f(p) = q, where f(p) is the lexicographically smallest permutation that can be obtained by dividing p into exactly k non-empty contiguous segments and sorting each segment(that is, choose $ k-1 $ breakpoints $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, and divide it into $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). The result should be modulo 998244353.\n    >>> f_43(2, 1, [1, 2])\n    2\n", "sq": "Shkruani një funksion në C `int f_43(int n, int k, int qq[])` për të zgjidhur problemin e mëposhtëm:\nDuke pasur parasysh një permutacion q të n elementeve dhe një numër të plotë k, gjeni numrin e permutacioneve p të n elementeve të tilla që f(p) = q, ku f(p) është permutacioni leksikografikisht më i vogël që mund të merret duke ndarë p në saktësisht k segmente të pandara jo-bosh dhe duke renditur secilin segment (domethënë, zgjidhni $ k-1 $ pika ndarëse $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, dhe ndajeni atë në $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). Rezultati duhet të jetë modulo 998244353.\n    >>> f_43(2, 1, [1, 2])\n    2", "hy": "Գրեք C ֆունկցիա `int f_43(int n, int k, int qq[])` հետևյալ խնդիրը լուծելու համար:\nՏրված է n տարրերի q փոխատեղումը և ամբողջ թիվ k, գտնել n տարրերի p փոխատեղումների քանակը, այնպես, որ f(p) = q, որտեղ f(p)-ն ամենափոքր լեքսիկոգրաֆիկ փոխատեղումն է, որը կարելի է ստանալ p-ն բաժանելով ճիշտ k ոչ դատարկ հարակից հատվածների և դասավորելով յուրաքանչյուր հատվածը (այսինքն, ընտրել $ k-1 $ կոտրման կետեր $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, և բաժանել այն $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $): Արդյունքը պետք է լինի 998244353 մոդուլով:\n    >>> f_43(2, 1, [1, 2])\n    2", "bn": "C ফাংশন `int f_43(int n, int k, int qq[])` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি n উপাদানের permutation q এবং একটি পূর্ণসংখ্যা k দেওয়া আছে, n উপাদানের কতগুলো permutation p আছে তা খুঁজে বের করুন যাতে f(p) = q হয়, যেখানে f(p) হল lexicographically সবচেয়ে ছোট permutation যা p কে ঠিক k টি খালি নয় এমন সংলগ্ন segment এ ভাগ করে এবং প্রতিটি segment sort করে পাওয়া যায় (অর্থাৎ, $ k-1 $ breakpoints $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $ বেছে নিন, এবং এটিকে $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $ এ ভাগ করুন)। ফলাফলটি 998244353 মডুলোতে হওয়া উচিত।\n    >>> f_43(2, 1, [1, 2])\n    2", "bg": "Напишете C функция `int f_43(int n, int k, int qq[])`, за да решите следния проблем:\nДадена е пермутация q от n елемента и цяло число k, намерете броя на пермутациите p от n елемента, такива че f(p) = q, където f(p) е лексикографски най-малката пермутация, която може да се получи чрез разделяне на p на точно k непразни съседни сегмента и сортиране на всеки сегмент (т.е. изберете $ k-1 $ точки на прекъсване $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, и го разделете на $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). Резултатът трябва да бъде модуло 998244353.\n    >>> f_43(2, 1, [1, 2])\n    2", "zh": "编写一个C函数 `int f_43(int n, int k, int qq[])` 来解决以下问题：\n给定一个由n个元素组成的排列q和一个整数k，找出n个元素的排列p的数量，使得f(p) = q，其中f(p)是通过将p分成恰好k个非空连续段并对每个段进行排序可以获得的字典序最小的排列（即，选择 $ k-1 $ 个断点 $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $，并将其划分为 $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $）。结果应对998244353取模。\n    >>> f_43(2, 1, [1, 2])\n    2", "fr": "Écrire une fonction C `int f_43(int n, int k, int qq[])` pour résoudre le problème suivant :\nÉtant donné une permutation q de n éléments et un entier k, trouver le nombre de permutations p de n éléments telles que f(p) = q, où f(p) est la permutation lexicographiquement la plus petite qui peut être obtenue en divisant p en exactement k segments contigus non vides et en triant chaque segment (c'est-à-dire, choisir $ k-1 $ points de rupture $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, et le diviser en $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). Le résultat doit être modulo 998244353.\n    >>> f_43(2, 1, [1, 2])\n    2", "de": "Schreiben Sie eine C-Funktion `int f_43(int n, int k, int qq[])`, um das folgende Problem zu lösen:\nGegeben eine Permutation q von n Elementen und eine ganze Zahl k, finde die Anzahl der Permutationen p von n Elementen, so dass f(p) = q, wobei f(p) die lexikographisch kleinste Permutation ist, die erhalten werden kann, indem man p in genau k nicht-leere zusammenhängende Segmente unterteilt und jedes Segment sortiert (das heißt, wähle $ k-1 $ Trennpunkte $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, und teile es in $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). Das Ergebnis sollte modulo 998244353 sein.\n    >>> f_43(2, 1, [1, 2])\n    2", "ha": "Rubuta aikin C `int f_43(int n, int k, int qq[])` don warware matsalar mai zuwa:\nAn ba da permutation q na abubuwa n da kuma cikakken lamba k, nemo adadin permutations p na abubuwa n irin wanda f(p) = q, inda f(p) shine mafi ƙarancin permutation na lexicographically wanda za a iya samu ta hanyar raba p zuwa daidai k sassa masu ci gaba da ba komai ba kuma a tsara kowane sashi (wato, zaɓi $ k-1 $ wuraren tsayawa $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, kuma a raba shi zuwa $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). Sakamakon ya zama modulo 998244353.\n    >>> f_43(2, 1, [1, 2])\n    2", "hi": "C फ़ंक्शन `int f_43(int n, int k, int qq[])` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए n तत्वों के एक क्रमचय q और एक पूर्णांक k के लिए, n तत्वों के क्रमचयों की संख्या खोजें ताकि f(p) = q, जहाँ f(p) वह शब्दकोशीय रूप से सबसे छोटा क्रमचय है जिसे p को ठीक k गैर-खाली सतत खंडों में विभाजित करके और प्रत्येक खंड को क्रमबद्ध करके प्राप्त किया जा सकता है (अर्थात, $ k-1 $ ब्रेकपॉइंट्स $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $ चुनें, और इसे $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $ में विभाजित करें)। परिणाम 998244353 से मापांकित होना चाहिए।\n    >>> f_43(2, 1, [1, 2])\n    2", "hu": "Írj egy C függvényt `int f_43(int n, int k, int qq[])` a következő probléma megoldására:\nAdott egy q permutáció n elemről és egy egész szám k, találd meg azon p permutációk számát n elemről, amelyekre f(p) = q, ahol f(p) az a lexikografikusan legkisebb permutáció, amelyet úgy lehet megkapni, hogy p-t pontosan k nem üres, összefüggő szegmensre osztjuk, és minden szegmenst sorba rendezünk (azaz válasszunk $ k-1 $ töréspontot $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, és osszuk fel $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $ részekre). Az eredményt 998244353-mal vett maradékként kell megadni.\n    >>> f_43(2, 1, [1, 2])\n    2", "es": "Escribe una función en C `int f_43(int n, int k, int qq[])` para resolver el siguiente problema:\nDada una permutación q de n elementos y un entero k, encuentra el número de permutaciones p de n elementos tal que f(p) = q, donde f(p) es la permutación lexicográficamente más pequeña que se puede obtener dividiendo p en exactamente k segmentos contiguos no vacíos y ordenando cada segmento (es decir, elige $ k-1 $ puntos de ruptura $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, y divídelo en $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). El resultado debe ser módulo 998244353.\n    >>> f_43(2, 1, [1, 2])\n    2", "arb": "اكتب دالة بلغة C `int f_43(int n, int k, int qq[])` لحل المشكلة التالية:\nمعطى ترتيب q مكون من n عنصرًا وعدد صحيح k، ابحث عن عدد التباديل p المكونة من n عنصرًا بحيث f(p) = q، حيث f(p) هو الترتيب المعجمي الأصغر الذي يمكن الحصول عليه عن طريق تقسيم p إلى k مقاطع متجاورة غير فارغة تمامًا وترتيب كل مقطع (أي اختيار $ k-1 $ نقاط توقف $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $، وتقسيمها إلى $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). يجب أن تكون النتيجة موديولو 998244353.\n    >>> f_43(2, 1, [1, 2])\n    2", "sw": "Andika kazi ya C `int f_43(int n, int k, int qq[])` kutatua tatizo lifuatalo:\nUkipiwa mpangilio q wa vipengele n na nambari k, pata idadi ya mipangilio p ya vipengele n kama f(p) = q, ambapo f(p) ni mpangilio mdogo zaidi kwa mpangilio wa lexicographically ambao unaweza kupatikana kwa kugawanya p katika sehemu k zisizo tupu na kupanga kila sehemu (yaani, chagua $ k-1 $ alama za kuvunja $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, na igawanye katika $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). Matokeo yanapaswa kuwa modulo 998244353.\n    >>> f_43(2, 1, [1, 2])\n    2", "tr": "Bir C fonksiyonu `int f_43(int n, int k, int qq[])` yazın ve aşağıdaki problemi çözün:\nn elemanlı bir q permütasyonu ve bir tamsayı k verildiğinde, f(p) = q olacak şekilde n elemanlı kaç tane p permütasyonu olduğunu bulun. Burada f(p), p'yi tam olarak k boş olmayan ardışık segmente bölerek ve her segmenti sıralayarak elde edilebilecek sözlük sırasına göre en küçük permütasyondur (yani, $ k-1 $ kesme noktası $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $ seçin ve bunu $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $ olarak bölün). Sonuç 998244353 ile mod alınmalıdır.\n    >>> f_43(2, 1, [1, 2])\n    2", "vi": "Viết một hàm C `int f_43(int n, int k, int qq[])` để giải quyết vấn đề sau:\nCho một hoán vị q của n phần tử và một số nguyên k, tìm số lượng hoán vị p của n phần tử sao cho f(p) = q, trong đó f(p) là hoán vị nhỏ nhất theo từ điển có thể thu được bằng cách chia p thành chính xác k đoạn liên tiếp không rỗng và sắp xếp từng đoạn (tức là, chọn $ k-1 $ điểm ngắt $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, và chia nó thành $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). Kết quả phải được lấy modulo 998244353.\n    >>> f_43(2, 1, [1, 2])\n    2", "id": "Tulis sebuah fungsi C `int f_43(int n, int k, int qq[])` untuk menyelesaikan masalah berikut:\nDiberikan sebuah permutasi q dari n elemen dan sebuah bilangan bulat k, temukan jumlah permutasi p dari n elemen sedemikian rupa sehingga f(p) = q, di mana f(p) adalah permutasi terkecil secara leksikografis yang dapat diperoleh dengan membagi p menjadi tepat k segmen berurutan yang tidak kosong dan mengurutkan setiap segmen (yaitu, pilih $ k-1 $ titik putus $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, dan bagi menjadi $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). Hasilnya harus dalam modulo 998244353.\n    >>> f_43(2, 1, [1, 2])\n    2", "ja": "Cの関数を書け `int f_43(int n, int k, int qq[])` を作成して、次の問題を解決してください:\nn個の要素の順列qと整数kが与えられたとき、f(p) = qとなるn個の要素の順列pの数を求めます。ここで、f(p)は、pをちょうどk個の空でない連続したセグメントに分割し、各セグメントをソートすることで得られる辞書式で最小の順列です（つまり、$ k-1 $個のブレークポイント $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $ を選び、$ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $ に分割します）。結果は998244353で割った余りとします。\n    >>> f_43(2, 1, [1, 2])\n    2", "ko": "C 함수 `int f_43(int n, int k, int qq[])`를 작성하여 다음 문제를 해결하십시오:\nn개의 요소로 이루어진 순열 q와 정수 k가 주어졌을 때, f(p) = q인 n개의 요소로 이루어진 순열 p의 개수를 찾으십시오. 여기서 f(p)는 p를 정확히 k개의 비어 있지 않은 연속 구간으로 나누고 각 구간을 정렬하여 얻을 수 있는 사전식으로 가장 작은 순열입니다(즉, $ k-1 $개의 분할점 $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $을 선택하고, $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $으로 나눕니다). 결과는 998244353로 나눈 나머지가 되어야 합니다.\n    >>> f_43(2, 1, [1, 2])\n    2", "ml": "C ഭാഷയിൽ ഒരു ഫംഗ്ഷൻ `int f_43(int n, int k, int qq[])` എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nഒരു n ഘടകങ്ങളുടെ പരിമാണം qയും ഒരു പൂർണ്ണസംഖ്യ kയും നൽകിയാൽ, n ഘടകങ്ങളുടെ p എന്ന പരിമാണങ്ങളുടെ എണ്ണം കണ്ടെത്തുക, അങ്ങനെ f(p) = q, ഇവിടെ f(p) എന്നത് കൃത്യമായി k ശൂന്യമല്ലാത്ത തുടർച്ചയായ വിഭാഗങ്ങളായി pനെ വിഭജിച്ച് ഓരോ വിഭാഗവും ക്രമീകരിച്ച് ലഭിക്കാവുന്ന ലെക്സികോഗ്രാഫിക്കായി ഏറ്റവും ചെറിയ പരിമാണമാണ് (അത്, $ k-1 $ ബ്രേക്ക്പോയിന്റുകൾ $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $ തിരഞ്ഞെടുക്കുക, അത് $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $ ആയി വിഭജിക്കുക). ഫലം 998244353 ന്റെ മോഡുലോ ആയിരിക്കണം.\n    >>> f_43(2, 1, [1, 2])\n    2", "fa": "یک تابع C به نام `int f_43(int n, int k, int qq[])` بنویسید تا مسئله زیر را حل کند:\nبا توجه به یک جایگشت q از n عنصر و یک عدد صحیح k، تعداد جایگشت‌های p از n عنصر را بیابید به طوری که f(p) = q، که در آن f(p) کوچک‌ترین جایگشت لغت‌نامه‌ای است که می‌توان با تقسیم p به دقیقاً k بخش متوالی غیر خالی و مرتب‌سازی هر بخش به دست آورد (یعنی، $ k-1 $ نقطه شکست $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $ را انتخاب کنید و آن را به $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $ تقسیم کنید). نتیجه باید به پیمانه 998244353 باشد.\n    >>> f_43(2, 1, [1, 2])\n    2"}, "level": "hard", "test": "int main() {\n    int q1[] = {1, 2};\n    assert(f_43(2, 1, q1) == 2);\n\n    int q2[] = {3, 1, 2};\n    assert(f_43(3, 3, q2) == 1);\n\n    int q3[] = {1, 2, 3, 6, 5, 4};\n    assert(f_43(6, 3, q3) == 13);\n\n    int q4[] = {1, 2, 3, 4, 5, 6};\n    assert(f_43(6, 1, q4) == 720);\n\n    int q5[] = {1, 2, 5, 3, 4, 5};\n    assert(f_43(6, 3, q5) == 0);\n\n    int q6[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n    assert(f_43(9, 9, q6) == 1);\n\n    int q7[] = {1, 2, 3, 4, 5, 6, 7, 9, 8};\n    assert(f_43(9, 2, q7) == 29093);\n    return 0;}", "entry_point": "f_43", "signature": "int f_43(int n, int k, int qq[])", "docstring": {"en": "Given a permutation q of n elements and an integer k, find the number of permutations p of n elements such that f(p) = q, where f(p) is the lexicographically smallest permutation that can be obtained by dividing p into exactly k non-empty contiguous segments and sorting each segment(that is, choose $ k-1 $ breakpoints $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, and divide it into $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). The result should be modulo 998244353.\n    >>> f_43(2, 1, [1, 2])\n    2\n", "sq": "Duke pasur një permutacion q të n elementeve dhe një numër të plotë k, gjeni numrin e permutacioneve p të n elementeve të tilla që f(p) = q, ku f(p) është permutacioni më i vogël leksikografik që mund të merret duke ndarë p në saktësisht k segmente të pandryshuara dhe duke renditur secilin segment (kjo është, zgjidhni $ k-1 $ pika ndarjeje $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, dhe ndajeni në $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). Rezultati duhet të jetë modulo 998244353.\n    >>> f_43(2, 1, [1, 2])\n    2", "hy": "Տրված է n տարրերի q փոխատեղումը և k ամբողջ թիվը, գտնել n տարրերի p փոխատեղումների քանակը, այնպես որ f(p) = q, որտեղ f(p)-ն այն լեքսիկոգրաֆիկորեն ամենափոքր փոխատեղումն է, որը կարելի է ստանալ p-ն ճշգրիտ k ոչ դատարկ հարակից հատվածների բաժանելով և յուրաքանչյուր հատվածը դասավորելով (այսինքն, ընտրել $ k-1 $ կոտրման կետեր $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, և բաժանել այն $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $): Արդյունքը պետք է լինի 998244353 մոդուլով:\n    >>> f_43(2, 1, [1, 2])\n    2", "bn": "একটি n উপাদানের permutation q এবং একটি পূর্ণসংখ্যা k দেওয়া আছে, এমন n উপাদানের কতগুলো permutation p আছে তা খুঁজে বের করুন যাতে f(p) = q হয়, যেখানে f(p) হল lexicographically সবচেয়ে ছোট permutation যা p কে ঠিক k টি খালি না থাকা সংলগ্ন অংশে ভাগ করে এবং প্রতিটি অংশকে সাজিয়ে পাওয়া যায় (অর্থাৎ, $ k-1 $ ব্রেকপয়েন্ট $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $ নির্বাচন করুন, এবং এটিকে $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $ এ ভাগ করুন)। ফলাফলটি 998244353 দ্বারা মডুলো করা উচিত।\n    >>> f_43(2, 1, [1, 2])\n    2", "bg": "Дадена е пермутация q от n елемента и цяло число k, намерете броя на пермутациите p от n елемента, такива че f(p) = q, където f(p) е лексикографски най-малката пермутация, която може да бъде получена чрез разделяне на p на точно k непразни съседни сегмента и сортиране на всеки сегмент (т.е. изберете $ k-1 $ точки на прекъсване $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, и го разделете на $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). Резултатът трябва да бъде модуло 998244353.\n    >>> f_43(2, 1, [1, 2])\n    2", "zh": "给定一个 n 元素的排列 q 和一个整数 k，找出 n 元素的排列 p 的数量，使得 f(p) = q，其中 f(p) 是通过将 p 精确地分成 k 个非空连续段并对每个段进行排序后可以得到的字典序最小的排列（即，选择 $ k-1 $ 个断点 $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $，并将其分为 $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $）。结果应对 998244353 取模。\n    >>> f_43(2, 1, [1, 2])\n    2", "fr": "Étant donné une permutation q de n éléments et un entier k, trouvez le nombre de permutations p de n éléments telles que f(p) = q, où f(p) est la permutation lexicographiquement la plus petite qui peut être obtenue en divisant p en exactement k segments contigus non vides et en triant chaque segment (c'est-à-dire, choisissez $ k-1 $ points de rupture $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, et divisez-le en $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). Le résultat doit être modulo 998244353.\n    >>> f_43(2, 1, [1, 2])\n    2", "de": "Gegeben eine Permutation q von n Elementen und eine ganze Zahl k, finde die Anzahl der Permutationen p von n Elementen, so dass f(p) = q, wobei f(p) die lexikographisch kleinste Permutation ist, die erhalten werden kann, indem p in genau k nicht-leere zusammenhängende Segmente unterteilt und jedes Segment sortiert wird (das heißt, wähle $ k-1 $ Trennpunkte $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, und teile es in $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). Das Ergebnis sollte modulo 998244353 sein.\n    >>> f_43(2, 1, [1, 2])\n    2", "ha": "An ba da permutation q na abubuwa n da kuma integer k, nemo yawan permutations p na abubuwa n irin cewa f(p) = q, inda f(p) shine permutation mafi ƙarancin lexicographically wanda za'a iya samu ta hanyar raba p zuwa daidai k sassa masu ci gaba da ba komai kuma a tsara kowane sashe (wato, zaɓi $ k-1 $ wuraren tsagewa $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, kuma raba shi zuwa $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). Sakamakon ya zama modulo 998244353.\n    >>> f_43(2, 1, [1, 2])\n    2", "hi": "दी गई क्रमचय q के n तत्वों और एक पूर्णांक k के लिए, n तत्वों के क्रमचयों की संख्या ज्ञात करें ताकि f(p) = q हो, जहाँ f(p) वह शब्दकोशानुसार सबसे छोटी क्रमचय है जो p को ठीक k गैर-खाली निरंतर खंडों में विभाजित करके और प्रत्येक खंड को क्रमबद्ध करके प्राप्त की जा सकती है (अर्थात, $ k-1 $ ब्रेकपॉइंट्स $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $ चुनें, और इसे $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $ में विभाजित करें)। परिणाम 998244353 के मापांक में होना चाहिए।\n    >>> f_43(2, 1, [1, 2])\n    2", "hu": "Adott egy q permutáció n elemre és egy egész szám k, találd meg azon p permutációk számát n elemre, amelyekre f(p) = q, ahol f(p) a lexikografikusan legkisebb permutáció, amelyet úgy lehet előállítani, hogy p-t pontosan k nem üres, összefüggő szegmensre osztjuk és minden szegmenst sorba rendezünk (azaz válasszunk $ k-1 $ töréspontot $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, és osszuk fel $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $ részekre). Az eredményt 998244353-mal modulozva kell megadni.\n    >>> f_43(2, 1, [1, 2])\n    2", "es": "Dada una permutación q de n elementos y un entero k, encuentra el número de permutaciones p de n elementos tal que f(p) = q, donde f(p) es la permutación lexicográficamente más pequeña que se puede obtener dividiendo p en exactamente k segmentos contiguos no vacíos y ordenando cada segmento (es decir, elige $ k-1 $ puntos de ruptura $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, y divídelo en $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). El resultado debe ser módulo 998244353.\n    >>> f_43(2, 1, [1, 2])\n    2", "arb": "بالنظر إلى ترتيب q من n عنصر وعدد صحيح k، جد عدد التباديل p من n عنصر بحيث f(p) = q، حيث f(p) هو الترتيب المعجمي الأصغر الذي يمكن الحصول عليه عن طريق تقسيم p إلى k مقاطع متجاورة غير فارغة وترتيب كل مقطع (أي، اختر $ k-1 $ نقاط تقاطع $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $، وقسمها إلى $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). يجب أن تكون النتيجة موديولو 998244353.\n    >>> f_43(2, 1, [1, 2])\n    2", "sw": "Kwa kupewa mpangilio q wa vipengele n na nambari k, pata idadi ya mipangilio p ya vipengele n kama f(p) = q, ambapo f(p) ni mpangilio mdogo zaidi kwa mpangilio wa lexicographically ambao unaweza kupatikana kwa kugawanya p katika sehemu k zisizo tupu za mfululizo na kupanga kila sehemu (yaani, chagua $ k-1 $ sehemu za kuvunja $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, na igawanye katika $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). Matokeo yanapaswa kuwa modulo 998244353.\n    >>> f_43(2, 1, [1, 2])\n    2", "tr": "Verilen n elemanlı bir q permütasyonu ve bir k tam sayısı için, f(p) = q olacak şekilde n elemanlı kaç tane p permütasyonu olduğunu bulun, burada f(p), p'yi tam olarak k boş olmayan ardışık parçaya bölerek ve her parçayı sıralayarak elde edilebilecek sözlük sırasına göre en küçük permütasyondur (yani, $ k-1 $ kesme noktası $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $ seçin ve bunu $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $ olarak bölün). Sonuç 998244353 ile mod alınmalıdır.\n    >>> f_43(2, 1, [1, 2])\n    2", "vi": "Đưa ra một hoán vị q của n phần tử và một số nguyên k, tìm số lượng hoán vị p của n phần tử sao cho f(p) = q, trong đó f(p) là hoán vị nhỏ nhất theo thứ tự từ điển có thể thu được bằng cách chia p thành chính xác k đoạn liên tiếp không rỗng và sắp xếp từng đoạn (tức là, chọn $ k-1 $ điểm ngắt $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, và chia nó thành $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). Kết quả nên được lấy theo modulo 998244353.\n    >>> f_43(2, 1, [1, 2])\n    2", "id": "Diberikan sebuah permutasi q dari n elemen dan sebuah bilangan bulat k, temukan jumlah permutasi p dari n elemen sedemikian rupa sehingga f(p) = q, di mana f(p) adalah permutasi terkecil secara leksikografis yang dapat diperoleh dengan membagi p menjadi tepat k segmen kontigu yang tidak kosong dan mengurutkan setiap segmen (yaitu, pilih $ k-1 $ titik pemisah $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, dan bagi menjadi $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). Hasilnya harus dalam modulo 998244353.\n    >>> f_43(2, 1, [1, 2])\n    2", "ja": "与えられたn要素の順列qと整数kに対して、f(p) = qとなるn要素の順列pの数を求めます。ここでf(p)は、pを正確にk個の空でない連続したセグメントに分割し、各セグメントをソートすることによって得られる辞書順で最小の順列です（つまり、$ k-1 $個のブレークポイント $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $ を選び、それを $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $ に分割します）。結果は998244353でのモジュロとします。\n    >>> f_43(2, 1, [1, 2])\n    2", "ko": "주어진 n 요소의 순열 q와 정수 k가 있을 때, n 요소의 순열 p 중에서 f(p) = q인 순열의 수를 찾으시오. 여기서 f(p)는 p를 정확히 k개의 비어 있지 않은 연속된 구간으로 나누고 각 구간을 정렬하여 얻을 수 있는 사전식으로 가장 작은 순열입니다(즉, $ k-1 $개의 분할점 $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $을 선택하고, $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $으로 나눕니다). 결과는 998244353로 나눈 나머지가 되어야 합니다.\n    >>> f_43(2, 1, [1, 2])\n    2", "ml": "നൽകിയിരിക്കുന്ന n ഘടകങ്ങളുടെ ഒരു ക്രമവിന്യാസവും ഒരു പൂർണ്ണസംഖ്യ k ഉം നൽകിയാൽ, f(p) = q ആയ n ഘടകങ്ങളുടെ ക്രമവിന്യാസങ്ങളുടെ എണ്ണം കണ്ടെത്തുക, ഇവിടെ f(p) എന്നത് p നെ കൃത്യമായി k ശൂന്യമല്ലാത്ത തുടർച്ചയായ വിഭാഗങ്ങളായി വിഭജിച്ച് ഓരോ വിഭാഗവും ക്രമീകരിച്ച് ലഭിക്കാവുന്ന ലെക്സികോഗ്രാഫിക്കായി ഏറ്റവും ചെറിയ ക്രമവിന്യാസമാണ് (അത്, $ k-1 $ ബ്രേക്ക്പോയിന്റുകൾ $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $ തിരഞ്ഞെടുത്ത്, അതിനെ $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $ ആയി വിഭജിക്കുക). ഫലം 998244353 ന് മോഡുലോ ആയിരിക്കണം.\n    >>> f_43(2, 1, [1, 2])\n    2", "fa": "با توجه به یک جایگشت q از n عنصر و یک عدد صحیح k، تعداد جایگشت‌های p از n عنصر را پیدا کنید به طوری که f(p) = q، که در آن f(p) کوچکترین جایگشت لغت‌نامه‌ای است که می‌توان با تقسیم p به دقیقاً k بخش متوالی غیر خالی و مرتب کردن هر بخش به دست آورد (یعنی، $ k-1 $ نقطه شکست $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $ را انتخاب کنید و آن را به $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $ تقسیم کنید). نتیجه باید به پیمانه 998244353 باشد.\n    >>> f_43(2, 1, [1, 2])\n    2"}}
{"task_id": "C/44", "prompt": {"en": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nGiven an array of n distinct integers representing the heights of Kira's friends, \nfind the number of ways to choose a triplet (a, b, c) such that the greatest common divisor (GCD) \nof the maximum and minimum values of the triplet is 1.\n    >>> f_44([1, 5, 7])\n    1\n*/\nint f_44(int heights[], int n)", "sq": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nDuke pasur një varg prej n të plotë të ndryshëm që përfaqësojnë lartësitë e miqve të Kirës,\ngjeni numrin e mënyrave për të zgjedhur një treshe (a, b, c) të tillë që maksimumi dhe minimumi i treshes të kenë përbashkët më të madhin pjesëtues (GCD) 1.\n    >>> f_44([1, 5, 7])\n    1\n*/\nint f_44(int heights[], int n)", "hy": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nՏրված է n տարբեր ամբողջ թվերից բաղկացած զանգված, որը ներկայացնում է Կիրայի ընկերների բարձրությունները,\nգտնել եռյակի (a, b, c) ընտրելու եղանակների քանակը այնպես, որ եռյակի առավելագույն և նվազագույն արժեքների \nամենամեծ ընդհանուր բաժանարարը (GCD) լինի 1:\n    >>> f_44([1, 5, 7])\n    1\n*/\nint f_44(int heights[], int n)", "bn": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nকিরার বন্ধুদের উচ্চতা প্রতিনিধিত্বকারী n টি ভিন্ন পূর্ণসংখ্যার একটি অ্যারে দেওয়া হয়েছে,\nতিনটি (a, b, c) বেছে নেওয়ার উপায়ের সংখ্যা খুঁজুন যাতে ট্রিপলেটের সর্বাধিক এবং সর্বনিম্ন মানের \nসর্বাধিক সাধারণ গুণক (GCD) 1 হয়।\n    >>> f_44([1, 5, 7])\n    1\n*/\nint f_44(int heights[], int n)", "bg": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nДаден е масив от n различни цели числа, представляващи височините на приятелите на Кира,\nнамерете броя на начините да изберете тройка (a, b, c) така, че най-големият общ делител (НОД)\nна максималната и минималната стойност на тройката да е 1.\n    >>> f_44([1, 5, 7])\n    1\n*/\nint f_44(int heights[], int n)", "zh": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\n给定一个由 n 个不同整数组成的数组，表示 Kira 朋友的身高，\n找出选择一个三元组 (a, b, c) 的方法数，使得该三元组的最大值和最小值的最大公约数 (GCD) 为 1。\n    >>> f_44([1, 5, 7])\n    1\n*/\nint f_44(int heights[], int n)", "fr": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nÉtant donné un tableau de n entiers distincts représentant les hauteurs des amis de Kira,\ntrouvez le nombre de façons de choisir un triplet (a, b, c) tel que le plus grand commun diviseur (PGCD)\ndes valeurs maximale et minimale du triplet soit 1.\n    >>> f_44([1, 5, 7])\n    1\n*/\nint f_44(int heights[], int n)", "de": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nGegeben ein Array von n verschiedenen ganzen Zahlen, die die Größen von Kiras Freunden darstellen,\nfinde die Anzahl der Möglichkeiten, ein Tripel (a, b, c) zu wählen, so dass der größte gemeinsame Teiler (GCD)\nder maximalen und minimalen Werte des Tripels 1 ist.\n    >>> f_44([1, 5, 7])\n    1\n*/\nint f_44(int heights[], int n)", "ha": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nAn ba da wani tsari na lambobi daban-daban n da ke wakiltar tsayin abokan Kira,\nnemo yawan hanyoyin zaɓar triplet (a, b, c) ta yadda mafi girman abin da ke raba su (GCD)\nna mafi girma da ƙananan ƙimomin triplet ɗin ya zama 1.\n    >>> f_44([1, 5, 7])\n    1\n*/\nint f_44(int heights[], int n)", "hi": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nकिरा के दोस्तों की ऊंचाइयों का प्रतिनिधित्व करने वाले n भिन्न पूर्णांकों की एक सरणी दी गई है,\nऐसे ट्रिपलेट (a, b, c) को चुनने के तरीकों की संख्या खोजें ताकि ट्रिपलेट के अधिकतम और न्यूनतम मानों का महत्तम समापवर्तक (GCD) 1 हो।\n    >>> f_44([1, 5, 7])\n    1\n*/\nint f_44(int heights[], int n)", "hu": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nAdott egy n különböző egész számot tartalmazó tömb, amely Kira barátainak magasságát reprezentálja,\ntaláljuk meg, hányféleképpen lehet kiválasztani egy hármas (a, b, c) úgy, hogy a hármas maximális és minimális értékeinek legnagyobb közös osztója (GCD) 1 legyen.\n    >>> f_44([1, 5, 7])\n    1\n*/\nint f_44(int heights[], int n)", "es": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nDado un array de n enteros distintos que representan las alturas de los amigos de Kira,\nencuentra el número de formas de elegir un trío (a, b, c) tal que el máximo común divisor (GCD)\nde los valores máximo y mínimo del trío sea 1.\n    >>> f_44([1, 5, 7])\n    1\n*/\nint f_44(int heights[], int n)", "arb": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nمعطى مصفوفة من n عدد صحيح مميز تمثل أطوال أصدقاء كيرا،\nابحث عن عدد الطرق لاختيار ثلاثي (a, b, c) بحيث يكون القاسم المشترك الأكبر (GCD)\nللقيمتين العظمى والصغرى للثلاثي هو 1.\n    >>> f_44([1, 5, 7])\n    1\n*/\nint f_44(int heights[], int n)", "sw": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nUkipiwa safu ya n ya nambari tofauti zinazoashiria urefu wa marafiki wa Kira, \ntafuta idadi ya njia za kuchagua tatu (a, b, c) kama kwamba mgawanyiko mkuu wa pamoja (GCD) \nwa thamani ya juu na ya chini ya tatu ni 1.\n    >>> f_44([1, 5, 7])\n    1\n*/\nint f_44(int heights[], int n)", "tr": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nKira'nın arkadaşlarının yüksekliklerini temsil eden n farklı tam sayıdan oluşan bir dizi verildiğinde,\nbir üçlü (a, b, c) seçmenin kaç yolu olduğunu bulun, öyle ki üçlünün maksimum ve minimum değerlerinin \nen büyük ortak böleni (GCD) 1 olsun.\n    >>> f_44([1, 5, 7])\n    1\n*/\nint f_44(int heights[], int n)", "vi": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nCho một mảng gồm n số nguyên khác nhau đại diện cho chiều cao của bạn bè Kira,\ntìm số cách chọn một bộ ba (a, b, c) sao cho ước số chung lớn nhất (GCD)\ncủa giá trị lớn nhất và nhỏ nhất của bộ ba là 1.\n    >>> f_44([1, 5, 7])\n    1\n*/\nint f_44(int heights[], int n)", "id": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nDiberikan sebuah array dari n bilangan bulat berbeda yang mewakili tinggi teman-teman Kira,\ntemukan jumlah cara untuk memilih triplet (a, b, c) sedemikian rupa sehingga pembagi terbesar \n(GCD) dari nilai maksimum dan minimum triplet adalah 1.\n    >>> f_44([1, 5, 7])\n    1\n*/\nint f_44(int heights[], int n)", "ja": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nKiraの友人の身長を表すn個の異なる整数の配列が与えられたとき、\n最大値と最小値の最大公約数（GCD）が1であるような三つ組 (a, b, c) を選ぶ方法の数を求めます。\n    >>> f_44([1, 5, 7])\n    1\n*/\nint f_44(int heights[], int n)", "ko": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nKira의 친구들의 키를 나타내는 n개의 서로 다른 정수 배열이 주어졌을 때, \n최대값과 최소값의 최대 공약수(GCD)가 1인 세 쌍 (a, b, c)을 선택하는 방법의 수를 찾으시오.\n    >>> f_44([1, 5, 7])\n    1\n*/\nint f_44(int heights[], int n)", "ml": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nകിരയുടെ സുഹൃത്തുക്കളുടെ ഉയരങ്ങളെ പ്രതിനിധീകരിക്കുന്ന n വ്യത്യസ്ത പൂർണ്ണസംഖ്യകളുടെ ഒരു നിര നൽകിയിരിക്കുന്നു, \nട്രിപ്പ്ലെറ്റ് (a, b, c) തിരഞ്ഞെടുക്കാനുള്ള മാർഗങ്ങളുടെ എണ്ണം കണ്ടെത്തുക, \nഅതിനുള്ള പരമാവധി, കുറഞ്ഞ മൂല്യങ്ങളുടെ മഹത്തായ പൊതു ഗുണക (GCD) 1 ആകുന്നു.\n    >>> f_44([1, 5, 7])\n    1\n*/\nint f_44(int heights[], int n)", "fa": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nبا توجه به آرایه‌ای از n عدد صحیح متمایز که نمایانگر قد دوستان کیرا هستند،\nتعداد روش‌های انتخاب یک سه‌تایی (a, b, c) را پیدا کنید به طوری که بزرگ‌ترین مقسوم‌علیه مشترک (GCD)\nبیشترین و کمترین مقادیر سه‌تایی برابر با 1 باشد.\n    >>> f_44([1, 5, 7])\n    1\n*/\nint f_44(int heights[], int n)"}, "canonical_solution": "{\n    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = (heights[i] < heights[j]) ? ((heights[i] < heights[k]) ? heights[i] : heights[k]) : ((heights[j] < heights[k]) ? heights[j] : heights[k]);\n                int maxVal = (heights[i] > heights[j]) ? ((heights[i] > heights[k]) ? heights[i] : heights[k]) : ((heights[j] > heights[k]) ? heights[j] : heights[k]);\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}", "instruction": {"en": "Write a C function `int f_44(int heights[], int n)` to solve the following problem:\nGiven an array of n distinct integers representing the heights of Kira's friends, find the number of ways to choose a triplet (a, b, c) such that the greatest common divisor (GCD) of the maximum and minimum values of the triplet is 1.\n    >>> f_44([1, 5, 7])\n    1\n", "sq": "Shkruani një funksion në C `int f_44(int heights[], int n)` për të zgjidhur problemin e mëposhtëm:\nDuke pasur një varg me n numra të plotë të ndryshëm që përfaqësojnë lartësitë e miqve të Kirës, gjeni numrin e mënyrave për të zgjedhur një treshe (a, b, c) të tillë që maksimumi dhe minimumi i vlerave të treshes të kenë përbashkët vetëm 1 si pjesëtues më të madh të përbashkët (GCD).  \n    >>> f_44([1, 5, 7])  \n    1", "hy": "Գրեք C ֆունկցիա `int f_44(int heights[], int n)` հետևյալ խնդիրը լուծելու համար:\nՏրված է n տարբեր ամբողջ թվերից կազմված զանգված, որը ներկայացնում է Կիրայի ընկերների բարձրությունները, գտնել եղանակների քանակը, որով հնարավոր է ընտրել եռյակ (a, b, c) այնպես, որ եռյակի առավելագույն և նվազագույն արժեքների մեծագույն ընդհանուր բաժանարարը (GCD) լինի 1:\n    >>> f_44([1, 5, 7])\n    1", "bn": "একটি C ফাংশন `int f_44(int heights[], int n)` লিখুন নিম্নলিখিত সমস্যাটি সমাধান করার জন্য:\nকিরার বন্ধুদের উচ্চতা প্রতিনিধিত্বকারী n টি পৃথক পূর্ণসংখ্যার একটি অ্যারে দেওয়া হয়েছে, ট্রিপলেট (a, b, c) বেছে নেওয়ার কতগুলি উপায় আছে তা খুঁজে বের করুন যাতে ট্রিপলেটের সর্বাধিক এবং সর্বনিম্ন মানের গ্রেটেস্ট কমন ডিভাইসর (GCD) 1 হয়।\n    >>> f_44([1, 5, 7])\n    1", "bg": "Напишете C функция `int f_44(int heights[], int n)`, за да решите следния проблем:\nДаден е масив от n различни цели числа, представляващи височините на приятелите на Кира, намерете броя на начините за избор на тройка (a, b, c) така, че най-големият общ делител (НОД) на максималната и минималната стойност на тройката да е 1.  \n    >>> f_44([1, 5, 7])  \n    1", "zh": "编写一个 C 函数 `int f_44(int heights[], int n)` 来解决以下问题：\n给定一个包含 n 个不同整数的数组，表示 Kira 朋友的身高，找出选择三元组 (a, b, c) 的方法数，使得该三元组的最大值和最小值的最大公约数 (GCD) 为 1。  \n    >>> f_44([1, 5, 7])  \n    1  ", "fr": "Écrire une fonction C `int f_44(int heights[], int n)` pour résoudre le problème suivant :\nÉtant donné un tableau de n entiers distincts représentant les hauteurs des amis de Kira, trouver le nombre de façons de choisir un triplet (a, b, c) tel que le plus grand commun diviseur (PGCD) des valeurs maximale et minimale du triplet soit 1.\n    >>> f_44([1, 5, 7])\n    1", "de": "Schreiben Sie eine C-Funktion `int f_44(int heights[], int n)`, um das folgende Problem zu lösen:\nGegeben ist ein Array von n verschiedenen ganzen Zahlen, die die Höhen von Kiras Freunden darstellen. Finden Sie die Anzahl der Möglichkeiten, ein Tripel (a, b, c) so auszuwählen, dass der größte gemeinsame Teiler (GCD) der maximalen und minimalen Werte des Tripels 1 ist.\n    >>> f_44([1, 5, 7])\n    1", "ha": "Rubuta wani aikin C `int f_44(int heights[], int n)` don warware matsalar mai zuwa:\nAn ba da wani tsari na lambobi daban-daban n waɗanda ke wakiltar tsayin abokan Kira, nemo yawan hanyoyin zaɓar triplet (a, b, c) ta yadda mafi girman mai raba kowa da kowa (GCD) na mafi girma da ƙananan ƙimar triplet ɗin ya zama 1.\n    >>> f_44([1, 5, 7])\n    1", "hi": "C फ़ंक्शन `int f_44(int heights[], int n)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nकिरा के दोस्तों की ऊँचाईयों का प्रतिनिधित्व करने वाले n भिन्न पूर्णांकों की एक array दी गई है, उन तरीकों की संख्या खोजें जिनसे एक त्रिक (a, b, c) चुना जा सके ताकि त्रिक के अधिकतम और न्यूनतम मानों का महत्तम समापवर्तक (GCD) 1 हो।\n    >>> f_44([1, 5, 7])\n    1", "hu": "Írj egy C függvényt `int f_44(int heights[], int n)` a következő probléma megoldására:\nAdott egy n különböző egész számot tartalmazó tömb, amely Kira barátainak magasságát jelképezi. Találd meg, hányféleképpen lehet kiválasztani egy hármast (a, b, c) úgy, hogy a hármas maximális és minimális értékeinek legnagyobb közös osztója (GCD) 1 legyen.  \n    >>> f_44([1, 5, 7])  \n    1  ", "es": "Escribe una función en C `int f_44(int heights[], int n)` para resolver el siguiente problema:\nDado un arreglo de n enteros distintos que representan las alturas de los amigos de Kira, encuentra el número de formas de elegir un triplete (a, b, c) tal que el máximo común divisor (GCD) de los valores máximo y mínimo del triplete sea 1.\n    >>> f_44([1, 5, 7])\n    1", "arb": "اكتب دالة بلغة C `int f_44(int heights[], int n)` لحل المشكلة التالية:\nبالنظر إلى مصفوفة تحتوي على n عدد صحيح مميز تمثل أطوال أصدقاء كيرا، ابحث عن عدد الطرق لاختيار ثلاثية (a, b, c) بحيث يكون القاسم المشترك الأكبر (GCD) للقيمتين العظمى والصغرى في الثلاثية هو 1.\n    >>> f_44([1, 5, 7])\n    1", "sw": "Andika kazi ya C `int f_44(int heights[], int n)` kutatua tatizo lifuatalo:\nUkipiwa safu ya n ya nambari tofauti zinazoashiria urefu wa marafiki wa Kira, tafuta idadi ya njia za kuchagua tatu (a, b, c) ili kwamba mgawanyiko mkuu zaidi (GCD) wa thamani ya juu na ya chini ya tatu hiyo ni 1.\n    >>> f_44([1, 5, 7])\n    1", "tr": "Bir C fonksiyonu `int f_44(int heights[], int n)` yazın ve aşağıdaki problemi çözün:\nKira'nın arkadaşlarının yüksekliklerini temsil eden n farklı tam sayıdan oluşan bir dizi verildiğinde, bir üçlü (a, b, c) seçmenin kaç yolu olduğunu bulun, öyle ki üçlünün maksimum ve minimum değerlerinin en büyük ortak böleni (EBOB) 1 olsun.\n    >>> f_44([1, 5, 7])\n    1", "vi": "Viết một hàm C `int f_44(int heights[], int n)` để giải quyết vấn đề sau:\nCho một mảng gồm n số nguyên khác nhau đại diện cho chiều cao của bạn bè Kira, tìm số cách chọn một bộ ba (a, b, c) sao cho ước số chung lớn nhất (GCD) của giá trị lớn nhất và nhỏ nhất của bộ ba là 1.\n    >>> f_44([1, 5, 7])\n    1", "id": "Tulis sebuah fungsi C `int f_44(int heights[], int n)` untuk menyelesaikan masalah berikut:\nDiberikan sebuah array dari n bilangan bulat berbeda yang mewakili tinggi teman-teman Kira, temukan jumlah cara untuk memilih triplet (a, b, c) sedemikian rupa sehingga pembagi bersama terbesar (GCD) dari nilai maksimum dan minimum dari triplet tersebut adalah 1.\n    >>> f_44([1, 5, 7])\n    1", "ja": "Cの関数を書け `int f_44(int heights[], int n)` を作成して、次の問題を解決してください:\nKiraの友人の身長を表すn個の異なる整数の配列が与えられたとき、トリプレット (a, b, c) を選ぶ方法の数を見つけてください。このトリプレットの最大値と最小値の最大公約数 (GCD) が1である必要があります。\n    >>> f_44([1, 5, 7])\n    1", "ko": "C 함수 `int f_44(int heights[], int n)`를 작성하여 다음 문제를 해결하십시오:\nKira의 친구들의 키를 나타내는 n개의 서로 다른 정수 배열이 주어졌을 때, 최대값과 최소값의 최대공약수(GCD)가 1인 삼중항 (a, b, c)을 선택하는 방법의 수를 찾으십시오.\n    >>> f_44([1, 5, 7])\n    1", "ml": "C ഭാഷയിൽ ഒരു ഫംഗ്ഷൻ `int f_44(int heights[], int n)` എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nകിരയുടെ സുഹൃത്തുക്കളുടെ ഉയരങ്ങളെ പ്രതിനിധീകരിക്കുന്ന n വ്യത്യസ്ത പൂർണ്ണസംഖ്യകളുള്ള ഒരു നിര നൽകിയിരിക്കുമ്പോൾ, ഒരു ത്രയി (a, b, c) തിരഞ്ഞെടുക്കാനുള്ള മാർഗങ്ങളുടെ എണ്ണം കണ്ടെത്തുക, അത്തരം ത്രയിയുടെ പരമാവധി, കുറഞ്ഞ മൂല്യങ്ങളുടെ മഹത്തര പൊതുഹരവും (GCD) 1 ആകണം.\n    >>> f_44([1, 5, 7])\n    1", "fa": "یک تابع C به نام `int f_44(int heights[], int n)` بنویسید تا مسئله زیر را حل کند:\nبا توجه به یک آرایه از n عدد صحیح متمایز که نمایانگر قد دوستان کیرا هستند، تعداد روش‌های انتخاب یک سه‌تایی (a, b, c) را پیدا کنید به‌طوری‌که بزرگترین مقسوم‌علیه مشترک (GCD) مقادیر حداکثر و حداقل سه‌تایی برابر ۱ باشد.\n    >>> f_44([1, 5, 7])\n    1"}, "level": "hard", "test": "int main() {\n    int heights1[] = {1, 5, 7};\n    assert(f_44(heights1, 3) == 1);\n\n    int heights2[] = {1, 6, 2, 3};\n    assert(f_44(heights2, 4) == 3);\n\n    int heights3[] = {16, 4, 8, 2};\n    assert(f_44(heights3, 4) == 0);\n\n    int heights4[] = {10, 1, 6, 7, 9, 8, 4, 3, 5, 2};\n    assert(f_44(heights4, 10) == 77);\n\n    int heights5[] = {4, 5, 9, 11, 14};\n    assert(f_44(heights5, 5) == 7);\n\n    int heights6[] = {15, 10, 6, 9, 7, 3, 12, 8, 11, 1, 2};\n    assert(f_44(heights6, 11) == 104);\n\n    int heights7[] = {3, 7, 11, 13};\n    assert(f_44(heights7, 4) == 4);\n\n    int heights8[] = {5, 12, 13, 17, 19};\n    assert(f_44(heights8, 5) == 10);\n\n    int heights9[] = {2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12};\n    assert(f_44(heights9, 11) == 87);\n\n    int heights10[] = {1, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17};\n    assert(f_44(heights10, 11) == 122);\n\n    return 0;\n}", "entry_point": "f_44", "signature": "int f_44(int heights[], int n)", "docstring": {"en": "Given an array of n distinct integers representing the heights of Kira's friends, find the number of ways to choose a triplet (a, b, c) such that the greatest common divisor (GCD) of the maximum and minimum values of the triplet is 1.\n    >>> f_44([1, 5, 7])\n    1\n", "sq": "Duke pasur një varg prej n të plotë të ndryshëm që përfaqësojnë lartësitë e miqve të Kirës, gjeni numrin e mënyrave për të zgjedhur një treshe (a, b, c) të tillë që faktori më i madh i përbashkët (GCD) i vlerave maksimale dhe minimale të tresheve të jetë 1.\n    >>> f_44([1, 5, 7])\n    1", "hy": "Տրված է n տարբեր ամբողջ թվերից կազմված զանգված, որը ներկայացնում է Կիրայի ընկերների բարձրությունները, գտնել, թե քանի եղանակով կարելի է ընտրել եռյակ (a, b, c) այնպես, որ եռյակի առավելագույն և նվազագույն արժեքների ամենամեծ ընդհանուր բաժանարարը (GCD) լինի 1:\n    >>> f_44([1, 5, 7])\n    1", "bn": "একটি n সংখ্যক ভিন্ন পূর্ণসংখ্যার অ্যারে দেওয়া হয়েছে যা কিরার বন্ধুদের উচ্চতা উপস্থাপন করে, এমন একটি ত্রয়ী (a, b, c) বেছে নেওয়ার উপায়ের সংখ্যা খুঁজে বের করুন যাতে ত্রয়ীর সর্বাধিক এবং সর্বনিম্ন মানের গ্রেটেস্ট কমন ডিভিসর (GCD) 1 হয়।\n    >>> f_44([1, 5, 7])\n    1", "bg": "Даден е масив от n различни цели числа, представляващи височините на приятелите на Кира, намерете броя на начините да изберете тройка (a, b, c) така, че най-големият общ делител (НОД) на максималната и минималната стойности на тройката да е 1.\n    >>> f_44([1, 5, 7])\n    1", "zh": "给定一个由 n 个不同整数组成的数组，表示 Kira 朋友的身高，找出选择一个三元组 (a, b, c) 的方法数，使得该三元组的最大值和最小值的最大公约数 (GCD) 为 1。\n    >>> f_44([1, 5, 7])\n    1", "fr": "Étant donné un tableau de n entiers distincts représentant les hauteurs des amis de Kira, trouvez le nombre de façons de choisir un triplet (a, b, c) tel que le plus grand commun diviseur (PGCD) des valeurs maximale et minimale du triplet soit 1.\n    >>> f_44([1, 5, 7])\n    1", "de": "Gegeben ein Array von n verschiedenen ganzen Zahlen, die die Größen von Kiras Freunden darstellen, finde die Anzahl der Möglichkeiten, ein Tripel (a, b, c) zu wählen, so dass der größte gemeinsame Teiler (GCD) der maximalen und minimalen Werte des Tripels 1 ist.\n    >>> f_44([1, 5, 7])\n    1", "ha": "An ba da wani tsararren lambobi na n masu bambanta da ke wakiltar tsayin abokan Kira, gano yawan hanyoyin zaɓar triplet (a, b, c) ta yadda mafi girman mai raba kowa da kowa (GCD) na mafi girma da mafi ƙanƙanta na triplet ɗin zai zama 1.\n    >>> f_44([1, 5, 7])\n    1", "hi": "दिए गए n भिन्न पूर्णांकों के एक array में, जो कि किरा के दोस्तों की ऊँचाई का प्रतिनिधित्व करते हैं, उन तरीकों की संख्या खोजें जिनसे एक त्रिक (a, b, c) चुना जा सके ताकि त्रिक के अधिकतम और न्यूनतम मान का महत्तम समापवर्तक (GCD) 1 हो।\n    >>> f_44([1, 5, 7])\n    1", "hu": "Adott egy tömb n különböző egész számmal, amelyek Kira barátainak magasságát képviselik, meg kell találni, hányféleképpen lehet kiválasztani egy hármast (a, b, c) úgy, hogy a hármas maximális és minimális értékeinek legnagyobb közös osztója (GCD) 1 legyen.\n    >>> f_44([1, 5, 7])\n    1", "es": "Dado un array de n enteros distintos que representan las alturas de los amigos de Kira, encuentra el número de formas de elegir un triplete (a, b, c) tal que el máximo común divisor (GCD) de los valores máximo y mínimo del triplete sea 1.\n    >>> f_44([1, 5, 7])\n    1", "arb": "نظرًا لمصفوفة تحتوي على n من الأعداد الصحيحة المميزة التي تمثل أطوال أصدقاء كيرا، ابحث عن عدد الطرق لاختيار ثلاثية (a, b, c) بحيث يكون القاسم المشترك الأكبر (GCD) للقيمتين العظمى والصغرى في الثلاثية هو 1.\n    >>> f_44([1, 5, 7])\n    1", "sw": "Ukipiwa safu ya nambari tofauti za n zinazowakilisha urefu wa marafiki wa Kira, pata idadi ya njia za kuchagua tatu (a, b, c) ili kwamba mgawanyiko mkubwa wa kawaida (GCD) wa thamani za juu na za chini za tatu hiyo ni 1.\n    >>> f_44([1, 5, 7])\n    1", "tr": "Verilen, Kira'nın arkadaşlarının yüksekliklerini temsil eden n farklı tamsayıdan oluşan bir dizi göz önüne alındığında, bir üçlü (a, b, c) seçmenin kaç yolu olduğunu bulun, öyle ki üçlünün maksimum ve minimum değerlerinin en büyük ortak böleni (EBOB) 1 olsun.\n    >>> f_44([1, 5, 7])\n    1", "vi": "Cho một mảng gồm n số nguyên phân biệt đại diện cho chiều cao của bạn bè Kira, tìm số cách chọn một bộ ba (a, b, c) sao cho ước số chung lớn nhất (GCD) của giá trị lớn nhất và nhỏ nhất của bộ ba là 1.\n    >>> f_44([1, 5, 7])\n    1", "id": "Diberikan array dari n bilangan bulat berbeda yang mewakili tinggi teman-teman Kira, temukan jumlah cara untuk memilih triplet (a, b, c) sedemikian rupa sehingga pembagi persekutuan terbesar (GCD) dari nilai maksimum dan minimum dari triplet adalah 1.\n    >>> f_44([1, 5, 7])\n    1", "ja": "与えられた n 個の異なる整数の配列が Kira の友人の身長を表しているとき、三つ組 (a, b, c) を選ぶ方法の数を見つけます。その際、三つ組の最大値と最小値の最大公約数 (GCD) が 1 である必要があります。\n    >>> f_44([1, 5, 7])\n    1", "ko": "주어진 배열은 Kira의 친구들의 키를 나타내는 n개의 서로 다른 정수들로 구성됩니다. 배열에서 최대값과 최소값의 최대공약수(GCD)가 1이 되는 세 개의 숫자 (a, b, c)를 선택하는 방법의 수를 찾으세요.\n    >>> f_44([1, 5, 7])\n    1", "ml": "കിരയുടെ സുഹൃത്തുക്കളുടെ ഉയരങ്ങളെ പ്രതിനിധീകരിക്കുന്ന n വ്യത്യസ്ത പൂർണ്ണസംഖ്യകളുടെ ഒരു നിര നൽകിയിരിക്കുന്നു, \nട്രിപ്പ്ലെറ്റ് (a, b, c) തിരഞ്ഞെടുക്കാനുള്ള മാർഗങ്ങളുടെ എണ്ണം കണ്ടെത്തുക, \nഅതിനുള്ള പരമാവധി, കുറഞ്ഞ മൂല്യങ്ങളുടെ മഹത്തായ പൊതു ഗുണക (GCD) 1 ആകുന്നു.\n    >>> f_44([1, 5, 7])\n    1", "fa": "با توجه به یک آرایه از n عدد صحیح متمایز که نشان‌دهنده ارتفاع دوستان کیرا است، تعداد روش‌های انتخاب یک سه‌تایی (a, b, c) را بیابید به‌طوری‌که بزرگ‌ترین مقسوم‌علیه مشترک (GCD) مقادیر حداکثر و حداقل سه‌تایی برابر با 1 باشد.\n    >>> f_44([1, 5, 7])\n    1"}}
{"task_id": "C/45", "prompt": {"en": "#include <stdio.h>\n#include <assert.h>\n/*\nYou are given a 1 by n pixel image, where each pixel has a color represented by an integer. You can perform an operation where you pick a color and change all connected pixels of the same color to the chosen color. Two pixels are connected if they are adjacent and have the same color. Find the minimum number of operations required to make all pixels the same color.\n\nNote: For each color, there are at most 20 pixels of that color.\n\nExamples:\n    >>> f_45(5, (int[]){1, 2, 3, 2, 1})\n    2\n*/\nint f_45(int n, int* pixels)", "sq": "#include <stdio.h>\n#include <assert.h>\n/*\nJu jepet një imazh 1 me n piksel, ku secili piksel ka një ngjyrë të përfaqësuar nga një numër i plotë. Ju mund të kryeni një operacion ku zgjidhni një ngjyrë dhe ndryshoni të gjithë piksela të lidhur të së njëjtës ngjyrë në ngjyrën e zgjedhur. Dy piksela janë të lidhur nëse janë ngjitur dhe kanë të njëjtën ngjyrë. Gjeni numrin minimal të operacioneve të nevojshme për të bërë që të gjithë piksela të kenë të njëjtën ngjyrë.\n\nShënim: Për çdo ngjyrë, ka maksimumi 20 piksela të asaj ngjyre.\n\nShembuj:\n    >>> f_45(5, (int[]){1, 2, 3, 2, 1})\n    2\n*/\nint f_45(int n, int* pixels)", "hy": "#include <stdio.h>\n#include <assert.h>\n/*\nՁեզ տրված է 1x n պիքսել պատկեր, որտեղ յուրաքանչյուր պիքսել ունի գույն, որը ներկայացված է ամբողջ թվով։ Դուք կարող եք կատարել գործողություն, որտեղ ընտրում եք գույն և փոխում նույն գույնի բոլոր կապված պիքսելները ընտրված գույնով։ Երկու պիքսելներ կապված են, եթե նրանք հարևան են և ունեն նույն գույնը։ Գտեք նվազագույն գործողությունների քանակը, որը պահանջվում է, որպեսզի բոլոր պիքսելները ունենան նույն գույնը։\n\nՆշում. Յուրաքանչյուր գույնի համար առավելագույնը կա 20 պիքսել։\n\nՕրինակներ:\n    >>> f_45(5, (int[]){1, 2, 3, 2, 1})\n    2\n*/\nint f_45(int n, int* pixels)", "bn": "#include <stdio.h>\n#include <assert.h>\n/*\nআপনাকে একটি 1 বাই n পিক্সেল চিত্র দেওয়া হয়েছে, যেখানে প্রতিটি পিক্সেলের একটি রঙ একটি পূর্ণসংখ্যা দ্বারা উপস্থাপিত হয়। আপনি একটি অপারেশন সম্পাদন করতে পারেন যেখানে আপনি একটি রঙ বেছে নেন এবং একই রঙের সমস্ত সংযুক্ত পিক্সেলগুলিকে নির্বাচিত রঙে পরিবর্তন করেন। দুটি পিক্সেল সংযুক্ত থাকে যদি তারা সংলগ্ন হয় এবং একই রঙের হয়। সমস্ত পিক্সেলকে একই রঙে পরিণত করতে প্রয়োজনীয় সর্বনিম্ন সংখ্যক অপারেশন খুঁজুন।\n\nবিঃদ্রঃ: প্রতিটি রঙের জন্য, ঐ রঙের সর্বাধিক ২০টি পিক্সেল রয়েছে।\n\nউদাহরণ:\n    >>> f_45(5, (int[]){1, 2, 3, 2, 1})\n    2\n*/\nint f_45(int n, int* pixels)", "bg": "#include <stdio.h>\n#include <assert.h>\n/*\nДадено ви е изображение с размер 1 на n пиксела, където всеки пиксел има цвят, представен с цяло число. Можете да извършите операция, при която избирате цвят и променяте всички свързани пиксели със същия цвят на избрания цвят. Два пиксела са свързани, ако са съседни и имат същия цвят. Намерете минималния брой операции, необходими, за да направите всички пиксели с един и същ цвят.\n\nЗабележка: За всеки цвят има най-много 20 пиксела с този цвят.\n\nПримери:\n    >>> f_45(5, (int[]){1, 2, 3, 2, 1})\n    2\n*/\nint f_45(int n, int* pixels)", "zh": "#include <stdio.h>\n#include <assert.h>\n/*\n给定一个1x n像素的图像，其中每个像素的颜色由一个整数表示。你可以执行一个操作，选择一种颜色并将所有连接的相同颜色的像素更改为所选颜色。如果两个像素是相邻的并且具有相同的颜色，则它们是连接的。找出使所有像素颜色相同所需的最小操作次数。\n\n注意：对于每种颜色，最多有20个像素。\n\n例子：\n    >>> f_45(5, (int[]){1, 2, 3, 2, 1})\n    2\n*/\nint f_45(int n, int* pixels)", "fr": "#include <stdio.h>\n#include <assert.h>\n/*\nVous avez une image de 1 par n pixels, où chaque pixel a une couleur représentée par un entier. Vous pouvez effectuer une opération où vous choisissez une couleur et changez tous les pixels connectés de la même couleur en la couleur choisie. Deux pixels sont connectés s'ils sont adjacents et ont la même couleur. Trouvez le nombre minimum d'opérations nécessaires pour que tous les pixels soient de la même couleur.\n\nRemarque : Pour chaque couleur, il y a au plus 20 pixels de cette couleur.\n\nExemples :\n    >>> f_45(5, (int[]){1, 2, 3, 2, 1})\n    2\n*/\nint f_45(int n, int* pixels)", "de": "#include <stdio.h>\n#include <assert.h>\n/*\nSie haben ein 1 mal n Pixelbild, wobei jedes Pixel eine Farbe hat, die durch eine Ganzzahl dargestellt wird. Sie können eine Operation durchführen, bei der Sie eine Farbe auswählen und alle verbundenen Pixel derselben Farbe in die gewählte Farbe ändern. Zwei Pixel sind verbunden, wenn sie benachbart sind und die gleiche Farbe haben. Finden Sie die minimale Anzahl von Operationen, die erforderlich sind, um alle Pixel in dieselbe Farbe zu ändern.\n\nHinweis: Für jede Farbe gibt es höchstens 20 Pixel dieser Farbe.\n\nBeispiele:\n    >>> f_45(5, (int[]){1, 2, 3, 2, 1})\n    2\n*/\nint f_45(int n, int* pixels)", "ha": "#include <stdio.h>\n#include <assert.h>\n/*\nAn ba ku hoton pixel 1 ta n, inda kowanne pixel yana da launi da aka wakilta da lamba. Kuna iya aiwatar da aiki inda kuke ɗaukar launi kuma ku canza duk pixels da aka haɗa na launi ɗaya zuwa launi da aka zaɓa. Ana haɗa pixels biyu idan suna kusa kuma suna da launi ɗaya. Nemo mafi ƙarancin adadin ayyuka da ake buƙata don sanya duk pixels su zama launi ɗaya.\n\nLura: Ga kowanne launi, akwai akalla pixels 20 na wannan launi.\n\nMisalai:\n    >>> f_45(5, (int[]){1, 2, 3, 2, 1})\n    2\n*/\nint f_45(int n, int* pixels)", "hi": "#include <stdio.h>\n#include <assert.h>\n/*\nआपको 1 बाई n पिक्सेल की छवि दी गई है, जहाँ प्रत्येक पिक्सेल का रंग एक पूर्णांक द्वारा दर्शाया गया है। आप एक ऑपरेशन कर सकते हैं जहाँ आप एक रंग चुनते हैं और उसी रंग के सभी जुड़े पिक्सेल को चुने गए रंग में बदल देते हैं। दो पिक्सेल जुड़े होते हैं यदि वे आसन्न होते हैं और उनका रंग समान होता है। सभी पिक्सेल को एक ही रंग में बदलने के लिए आवश्यक न्यूनतम ऑपरेशनों की संख्या ज्ञात करें।\n\nध्यान दें: प्रत्येक रंग के लिए, उस रंग के अधिकतम 20 पिक्सेल होते हैं।\n\nउदाहरण:\n    >>> f_45(5, (int[]){1, 2, 3, 2, 1})\n    2\n*/\nint f_45(int n, int* pixels)", "hu": "#include <stdio.h>\n#include <assert.h>\n/*\nEgy 1 x n pixel méretű képet kap, ahol minden pixel színét egy egész szám képviseli. Végrehajthat egy műveletet, ahol kiválaszt egy színt, és az összes összekapcsolt, azonos színű pixelt a választott színre változtatja. Két pixel akkor van összekapcsolva, ha szomszédosak és azonos színűek. Határozza meg a minimális műveletek számát, amelyek szükségesek ahhoz, hogy az összes pixel azonos színű legyen.\n\nMegjegyzés: Minden színhez legfeljebb 20 pixel tartozik.\n\nPéldák:\n    >>> f_45(5, (int[]){1, 2, 3, 2, 1})\n    2\n*/\nint f_45(int n, int* pixels)", "es": "#include <stdio.h>\n#include <assert.h>\n/*\nSe te da una imagen de 1 por n píxeles, donde cada píxel tiene un color representado por un número entero. Puedes realizar una operación donde eliges un color y cambias todos los píxeles conectados del mismo color al color elegido. Dos píxeles están conectados si son adyacentes y tienen el mismo color. Encuentra el número mínimo de operaciones requeridas para hacer que todos los píxeles tengan el mismo color.\n\nNota: Para cada color, hay como máximo 20 píxeles de ese color.\n\nEjemplos:\n    >>> f_45(5, (int[]){1, 2, 3, 2, 1})\n    2\n*/\nint f_45(int n, int* pixels)", "arb": "#include <stdio.h>\n#include <assert.h>\n/*\nلديك صورة مكونة من 1 في n بكسل، حيث يتم تمثيل كل بكسل بلون يمثل برقم صحيح. يمكنك إجراء عملية حيث تختار لونًا وتغير جميع البكسلات المتصلة من نفس اللون إلى اللون المختار. يعتبر البكسلان متصلان إذا كانا متجاورين ولهما نفس اللون. جد الحد الأدنى لعدد العمليات المطلوبة لجعل جميع البكسلات بنفس اللون.\n\nملاحظة: لكل لون، هناك بحد أقصى 20 بكسل من ذلك اللون.\n\nأمثلة:\n    >>> f_45(5, (int[]){1, 2, 3, 2, 1})\n    2\n*/\nint f_45(int n, int* pixels)", "sw": "#include <stdio.h>\n#include <assert.h>\n/*\nUmepewa picha ya pikseli 1 kwa n, ambapo kila pikseli ina rangi inayowakilishwa na nambari nzima. Unaweza kufanya operesheni ambapo unachagua rangi na kubadilisha pikseli zote zilizounganishwa za rangi sawa na rangi iliyochaguliwa. Pikseli mbili zimeunganishwa ikiwa ziko karibu na zina rangi sawa. Pata idadi ndogo ya operesheni zinazohitajika kufanya pikseli zote ziwe na rangi sawa.\n\nKumbuka: Kwa kila rangi, kuna pikseli zisizozidi 20 za rangi hiyo.\n\nMifano:\n    >>> f_45(5, (int[]){1, 2, 3, 2, 1})\n    2\n*/\nint f_45(int n, int* pixels)", "tr": "#include <stdio.h>\n#include <assert.h>\n/*\n1'e n pikselden oluşan bir görüntü veriliyor, burada her piksel bir tamsayı ile temsil edilen bir renge sahiptir. Bir renk seçip aynı renkteki tüm bağlı pikselleri seçilen renge değiştirebileceğiniz bir işlem gerçekleştirebilirsiniz. İki piksel, bitişik ve aynı renkte olduklarında bağlı kabul edilir. Tüm pikselleri aynı renge getirmek için gereken minimum işlem sayısını bulun.\n\nNot: Her renk için en fazla 20 piksel bulunmaktadır.\n\nÖrnekler:\n    >>> f_45(5, (int[]){1, 2, 3, 2, 1})\n    2\n*/\nint f_45(int n, int* pixels)", "vi": "#include <stdio.h>\n#include <assert.h>\n/*\nBạn được cung cấp một hình ảnh 1 x n pixel, trong đó mỗi pixel có một màu được biểu diễn bằng một số nguyên. Bạn có thể thực hiện một thao tác mà bạn chọn một màu và thay đổi tất cả các pixel kết nối có cùng màu thành màu đã chọn. Hai pixel được kết nối nếu chúng liền kề và có cùng màu. Tìm số lượng thao tác tối thiểu cần thiết để làm cho tất cả các pixel có cùng màu.\n\nLưu ý: Đối với mỗi màu, có tối đa 20 pixel của màu đó.\n\nVí dụ:\n    >>> f_45(5, (int[]){1, 2, 3, 2, 1})\n    2\n*/\nint f_45(int n, int* pixels)", "id": "#include <stdio.h>\n#include <assert.h>\n/*\nAnda diberikan gambar 1 kali n piksel, di mana setiap piksel memiliki warna yang diwakili oleh sebuah bilangan bulat. Anda dapat melakukan operasi di mana Anda memilih sebuah warna dan mengubah semua piksel yang terhubung dengan warna yang sama menjadi warna yang dipilih. Dua piksel terhubung jika mereka bersebelahan dan memiliki warna yang sama. Temukan jumlah minimum operasi yang diperlukan untuk membuat semua piksel memiliki warna yang sama.\n\nCatatan: Untuk setiap warna, ada paling banyak 20 piksel dengan warna tersebut.\n\nContoh:\n    >>> f_45(5, (int[]){1, 2, 3, 2, 1})\n    2\n*/\nint f_45(int n, int* pixels)", "ja": "#include <stdio.h>\n#include <assert.h>\n/*\n1行nピクセルの画像が与えられ、それぞれのピクセルは整数で表される色を持っています。色を選び、同じ色の連結したピクセルすべてを選んだ色に変更する操作を行うことができます。2つのピクセルは、隣接していて同じ色である場合に連結しています。すべてのピクセルを同じ色にするために必要な最小の操作回数を求めてください。\n\n注意: 各色について、その色のピクセルは最大で20個です。\n\n例:\n    >>> f_45(5, (int[]){1, 2, 3, 2, 1})\n    2\n*/\nint f_45(int n, int* pixels)", "ko": "#include <stdio.h>\n#include <assert.h>\n/*\n1 x n 픽셀 이미지가 주어지며, 각 픽셀은 정수로 표현된 색상을 가지고 있습니다. 색상을 선택하여 동일한 색상의 연결된 모든 픽셀을 선택한 색상으로 변경하는 작업을 수행할 수 있습니다. 두 픽셀이 연결되려면 인접하고 동일한 색상을 가져야 합니다. 모든 픽셀을 동일한 색상으로 만들기 위해 필요한 최소 작업 수를 찾으십시오.\n\n참고: 각 색상에 대해 최대 20개의 픽셀이 존재합니다.\n\n예시:\n    >>> f_45(5, (int[]){1, 2, 3, 2, 1})\n    2\n*/\nint f_45(int n, int* pixels)", "ml": "#include <stdio.h>\n#include <assert.h>\n/*\nനിങ്ങൾക്ക് 1 by n പിക്സൽ ഇമേജ് നൽകിയിരിക്കുന്നു, ഓരോ പിക്സലിനും ഒരു പൂർണ്ണസംഖ്യയാൽ പ്രതിനിധീകരിക്കുന്ന ഒരു നിറമുണ്ട്. നിങ്ങൾക്ക് ഒരു നിറം തിരഞ്ഞെടുക്കുകയും അതേ നിറത്തിലുള്ള എല്ലാ ബന്ധിപ്പിച്ചിരിക്കുന്ന പിക്സലുകളെയും തിരഞ്ഞെടുക്കപ്പെട്ട നിറത്തിലേക്ക് മാറ്റുകയും ചെയ്യാം. രണ്ട് പിക്സലുകൾ ബന്ധിപ്പിച്ചിരിക്കുന്നതായി കണക്കാക്കുന്നത് അവ ചേർന്നിരിക്കുന്നതും ഒരേ നിറത്തിലുള്ളതുമായിരിക്കുമ്പോഴാണ്. എല്ലാ പിക്സലുകളും ഒരേ നിറത്തിലാക്കാൻ ആവശ്യമായ കുറഞ്ഞ പ്രവർത്തനങ്ങളുടെ എണ്ണം കണ്ടെത്തുക.\n\nകുറിപ്പ്: ഓരോ നിറത്തിനും ആ നിറത്തിലുള്ള പരമാവധി 20 പിക്സലുകൾ മാത്രമേയുള്ളൂ.\n\nഉദാഹരണങ്ങൾ:\n    >>> f_45(5, (int[]){1, 2, 3, 2, 1})\n    2\n*/\nint f_45(int n, int* pixels)", "fa": "#include <stdio.h>\n#include <assert.h>\n/*\nبه شما یک تصویر 1 در n پیکسلی داده شده است، که هر پیکسل دارای رنگی است که با یک عدد صحیح نمایش داده می‌شود. شما می‌توانید عملیاتی انجام دهید که در آن یک رنگ انتخاب کرده و تمام پیکسل‌های متصل با همان رنگ را به رنگ انتخاب شده تغییر دهید. دو پیکسل متصل هستند اگر مجاور باشند و رنگ یکسانی داشته باشند. حداقل تعداد عملیات مورد نیاز برای یکسان کردن رنگ تمام پیکسل‌ها را پیدا کنید.\n\nتوجه: برای هر رنگ، حداکثر 20 پیکسل از آن رنگ وجود دارد.\n\nمثال‌ها:\n    >>> f_45(5, (int[]){1, 2, 3, 2, 1})\n    2\n*/\nint f_45(int n, int* pixels)"}, "canonical_solution": "{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}", "instruction": {"en": "Write a C function `int f_45(int n, int* pixels)` to solve the following problem:\nYou are given a 1 by n pixel image, where each pixel has a color represented by an integer. You can perform an operation where you pick a color and change all connected pixels of the same color to the chosen color. Two pixels are connected if they are adjacent and have the same color. Find the minimum number of operations required to make all pixels the same color.\n\nNote: For each color, there are at most 20 pixels of that color.\n\nExamples:\n    >>> f_45(5, (int[]){1, 2, 3, 2, 1})\n    2\n", "sq": "Shkruani një funksion në C `int f_45(int n, int* pixels)` për të zgjidhur problemin e mëposhtëm:\nJu jepet një imazh 1 me n pikselë, ku secili piksel ka një ngjyrë të përfaqësuar nga një numër i plotë. Ju mund të kryeni një operacion ku zgjidhni një ngjyrë dhe ndryshoni të gjithë pikselët e lidhur të së njëjtës ngjyrë në ngjyrën e zgjedhur. Dy pikselë janë të lidhur nëse janë ngjitur dhe kanë të njëjtën ngjyrë. Gjeni numrin minimal të operacioneve të nevojshme për të bërë që të gjithë pikselët të kenë të njëjtën ngjyrë.\n\nShënim: Për çdo ngjyrë, ka maksimumi 20 pikselë të asaj ngjyre.\n\nShembuj:\n    >>> f_45(5, (int[]){1, 2, 3, 2, 1})\n    2", "hy": "Գրեք C ֆունկցիա `int f_45(int n, int* pixels)` հետևյալ խնդիրը լուծելու համար:\nՁեզ տրված է 1 ըստ n պիքսել պատկեր, որտեղ յուրաքանչյուր պիքսել ունի գույն, որը ներկայացված է ամբողջ թվով։ Դուք կարող եք կատարել գործողություն, որտեղ ընտրում եք գույն և փոխում նույն գույնի բոլոր միացված պիքսելները ընտրված գույնով։ Երկու պիքսել միացված են, եթե նրանք հարակից են և ունեն նույն գույնը։ Գտեք նվազագույն գործողությունների քանակը, որը պահանջվում է բոլոր պիքսելները նույն գույնի դարձնելու համար։\n\nՆշում: Յուրաքանչյուր գույնի համար առավելագույնը կա 20 պիքսել։\n\nՕրինակներ:\n    >>> f_45(5, (int[]){1, 2, 3, 2, 1})\n    2", "bn": "একটি C ফাংশন `int f_45(int n, int* pixels)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nআপনাকে একটি 1 বাই n পিক্সেল চিত্র দেওয়া হয়েছে, যেখানে প্রতিটি পিক্সেলের একটি রঙ একটি পূর্ণসংখ্যা দ্বারা উপস্থাপিত হয়। আপনি একটি অপারেশন সম্পাদন করতে পারেন যেখানে আপনি একটি রঙ বাছাই করেন এবং একই রঙের সমস্ত সংযুক্ত পিক্সেলগুলিকে নির্বাচিত রঙে পরিবর্তন করেন। দুটি পিক্সেল সংযুক্ত যদি তারা সংলগ্ন হয় এবং একই রঙের হয়। সমস্ত পিক্সেলকে একই রঙে রূপান্তর করতে প্রয়োজনীয় সর্বনিম্ন সংখ্যক অপারেশন খুঁজে বের করুন।\n\nনোট: প্রতিটি রঙের জন্য, সেই রঙের সর্বাধিক 20টি পিক্সেল রয়েছে।\n\nউদাহরণ:\n    >>> f_45(5, (int[]){1, 2, 3, 2, 1})\n    2", "bg": "Напишете C функция `int f_45(int n, int* pixels)`, за да решите следния проблем:\nДадено ви е изображение с размер 1 на n пиксела, където всеки пиксел има цвят, представен чрез цяло число. Можете да извършите операция, при която избирате цвят и променяте всички свързани пиксели със същия цвят на избрания цвят. Два пиксела са свързани, ако са съседни и имат същия цвят. Намерете минималния брой операции, необходими, за да направите всички пиксели с един и същ цвят.\n\nЗабележка: За всеки цвят има най-много 20 пиксела с този цвят.\n\nПримери:\n    >>> f_45(5, (int[]){1, 2, 3, 2, 1})\n    2", "zh": "编写一个C函数 `int f_45(int n, int* pixels)` 来解决以下问题：\n给定一个1乘n的像素图像，其中每个像素的颜色由一个整数表示。你可以执行一个操作，选择一种颜色并将所有连接的相同颜色的像素更改为所选颜色。如果两个像素相邻且颜色相同，则它们是连接的。找出使所有像素颜色相同所需的最小操作次数。\n\n注意：对于每种颜色，最多有20个该颜色的像素。\n\n示例:\n    >>> f_45(5, (int[]){1, 2, 3, 2, 1})\n    2", "fr": "Écrire une fonction C `int f_45(int n, int* pixels)` pour résoudre le problème suivant :\nVous avez une image de 1 par n pixels, où chaque pixel a une couleur représentée par un entier. Vous pouvez effectuer une opération où vous choisissez une couleur et changez tous les pixels connectés de la même couleur en la couleur choisie. Deux pixels sont connectés s'ils sont adjacents et ont la même couleur. Trouvez le nombre minimum d'opérations nécessaires pour que tous les pixels aient la même couleur.\n\nRemarque : Pour chaque couleur, il y a au plus 20 pixels de cette couleur.\n\nExemples :\n    >>> f_45(5, (int[]){1, 2, 3, 2, 1})\n    2", "de": "Schreiben Sie eine C-Funktion `int f_45(int n, int* pixels)`, um das folgende Problem zu lösen:\nSie haben ein 1x n Pixel-Bild, bei dem jedes Pixel eine durch eine ganze Zahl dargestellte Farbe hat. Sie können eine Operation durchführen, bei der Sie eine Farbe auswählen und alle verbundenen Pixel derselben Farbe in die gewählte Farbe ändern. Zwei Pixel sind verbunden, wenn sie benachbart sind und die gleiche Farbe haben. Finden Sie die minimale Anzahl von Operationen, die erforderlich sind, um alle Pixel in die gleiche Farbe zu bringen.\n\nHinweis: Für jede Farbe gibt es höchstens 20 Pixel dieser Farbe.\n\nBeispiele:\n    >>> f_45(5, (int[]){1, 2, 3, 2, 1})\n    2", "ha": "Rubuta aikin C `int f_45(int n, int* pixels)` don warware matsalar mai zuwa:\nAn ba ku hoton pixel 1 ta n, inda kowanne pixel yana da launi da aka wakilta da lamba. Kuna iya aiwatar da aiki inda kuke zaɓar launi kuma ku canza duk pixels masu alaƙa na launi ɗaya zuwa launin da aka zaɓa. Pixels biyu suna da alaƙa idan suna kusa kuma suna da launi ɗaya. Nemo mafi ƙarancin adadin ayyuka da ake buƙata don sanya duk pixels su zama launi ɗaya.\n\nLura: Ga kowane launi, akwai akalla pixels 20 na wannan launi.\n\nMisalai:\n    >>> f_45(5, (int[]){1, 2, 3, 2, 1})\n    2", "hi": "C फ़ंक्शन `int f_45(int n, int* pixels)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nआपको 1 बाय n पिक्सल की छवि दी गई है, जहाँ प्रत्येक पिक्सल का रंग एक पूर्णांक द्वारा दर्शाया गया है। आप एक ऑपरेशन कर सकते हैं जहाँ आप एक रंग चुनते हैं और उसी रंग के सभी जुड़े पिक्सल को चुने गए रंग में बदल देते हैं। दो पिक्सल जुड़े हुए हैं यदि वे आसन्न हैं और उनका रंग समान है। सभी पिक्सल को एक ही रंग में बनाने के लिए आवश्यक न्यूनतम ऑपरेशन्स की संख्या खोजें।\n\nध्यान दें: प्रत्येक रंग के लिए, उस रंग के अधिकतम 20 पिक्सल होते हैं।\n\nउदाहरण:\n    >>> f_45(5, (int[]){1, 2, 3, 2, 1})\n    2", "hu": "Írj egy C függvényt `int f_45(int n, int* pixels)` a következő probléma megoldására:\nAdott egy 1 x n pixel kép, ahol minden pixel színét egy egész szám képviseli. Végrehajthatsz egy műveletet, ahol kiválasztasz egy színt, és az összes összekapcsolt, azonos színű pixelt megváltoztatod a választott színre. Két pixel akkor kapcsolódik egymáshoz, ha szomszédosak és azonos színűek. Találd meg a minimális műveletek számát, amely szükséges ahhoz, hogy az összes pixel azonos színű legyen.\n\nMegjegyzés: Minden szín esetében legfeljebb 20 pixel van abból a színből.\n\nPéldák:\n    >>> f_45(5, (int[]){1, 2, 3, 2, 1})\n    2", "es": "Escribe una función en C `int f_45(int n, int* pixels)` para resolver el siguiente problema:\nSe te da una imagen de 1 por n píxeles, donde cada píxel tiene un color representado por un número entero. Puedes realizar una operación donde eliges un color y cambias todos los píxeles conectados del mismo color al color elegido. Dos píxeles están conectados si son adyacentes y tienen el mismo color. Encuentra el número mínimo de operaciones requeridas para hacer que todos los píxeles sean del mismo color.\n\nNota: Para cada color, hay como máximo 20 píxeles de ese color.\n\nEjemplos:\n    >>> f_45(5, (int[]){1, 2, 3, 2, 1})\n    2", "arb": "اكتب دالة C `int f_45(int n, int* pixels)` لحل المشكلة التالية:\nلديك صورة مكونة من 1 في n بكسل، حيث يتم تمثيل كل بكسل بلون يمثل برقم صحيح. يمكنك تنفيذ عملية حيث تختار لونًا وتغير جميع البكسلات المتصلة من نفس اللون إلى اللون المختار. يعتبر البكسلان متصلان إذا كانا متجاورين ولهما نفس اللون. جد الحد الأدنى لعدد العمليات المطلوبة لجعل جميع البكسلات بنفس اللون.\n\nملاحظة: لكل لون، هناك بحد أقصى 20 بكسل من ذلك اللون.\n\nأمثلة:\n    >>> f_45(5, (int[]){1, 2, 3, 2, 1})\n    2", "sw": "Andika kazi ya C `int f_45(int n, int* pixels)` kutatua tatizo lifuatalo:\nUmepewa picha ya pikseli 1 kwa n, ambapo kila pikseli ina rangi inayowakilishwa na nambari nzima. Unaweza kufanya operesheni ambapo unachagua rangi na kubadilisha pikseli zote zilizounganishwa za rangi sawa kuwa rangi iliyochaguliwa. Pikseli mbili zimeunganishwa ikiwa ziko karibu na zina rangi sawa. Tafuta idadi ndogo ya operesheni zinazohitajika kufanya pikseli zote ziwe na rangi sawa.\n\nKumbuka: Kwa kila rangi, kuna pikseli zisizozidi 20 za rangi hiyo.\n\nMifano:\n    >>> f_45(5, (int[]){1, 2, 3, 2, 1})\n    2\n", "tr": "Bir C fonksiyonu `int f_45(int n, int* pixels)` yazın ve aşağıdaki problemi çözün:\nSize her pikselin bir tamsayı ile temsil edildiği 1'e n piksel bir görüntü veriliyor. Bir renk seçip aynı renkteki tüm bağlantılı pikselleri seçilen renge değiştirebileceğiniz bir işlem gerçekleştirebilirsiniz. İki piksel, bitişikse ve aynı renkteyse bağlantılıdır. Tüm pikselleri aynı renge getirmek için gereken minimum işlem sayısını bulun.\n\nNot: Her renk için en fazla 20 piksel vardır.\n\nÖrnekler:\n    >>> f_45(5, (int[]){1, 2, 3, 2, 1})\n    2", "vi": "Viết một hàm C `int f_45(int n, int* pixels)` để giải quyết vấn đề sau:\nBạn được cung cấp một hình ảnh 1 x n pixel, trong đó mỗi pixel có một màu được biểu diễn bằng một số nguyên. Bạn có thể thực hiện một thao tác trong đó bạn chọn một màu và thay đổi tất cả các pixel kết nối có cùng màu thành màu đã chọn. Hai pixel được kết nối nếu chúng liền kề và có cùng màu. Tìm số lượng thao tác tối thiểu cần thiết để làm cho tất cả các pixel có cùng màu.\n\nLưu ý: Đối với mỗi màu, có tối đa 20 pixel của màu đó.\n\nVí dụ:\n    >>> f_45(5, (int[]){1, 2, 3, 2, 1})\n    2", "id": "Tulis fungsi C `int f_45(int n, int* pixels)` untuk menyelesaikan masalah berikut:\nAnda diberikan gambar 1 kali n piksel, di mana setiap piksel memiliki warna yang diwakili oleh sebuah bilangan bulat. Anda dapat melakukan operasi di mana Anda memilih sebuah warna dan mengubah semua piksel yang terhubung dengan warna yang sama menjadi warna yang dipilih. Dua piksel terhubung jika mereka berdekatan dan memiliki warna yang sama. Temukan jumlah operasi minimum yang diperlukan untuk membuat semua piksel memiliki warna yang sama.\n\nCatatan: Untuk setiap warna, terdapat paling banyak 20 piksel dengan warna tersebut.\n\nContoh:\n    >>> f_45(5, (int[]){1, 2, 3, 2, 1})\n    2", "ja": "Cの関数を書け `int f_45(int n, int* pixels)` を作成して、次の問題を解決してください:\n1 by nのピクセル画像が与えられます。各ピクセルは整数で表される色を持っています。ある色を選び、その色と同じ色の隣接したピクセルをすべて選んだ色に変更する操作を行うことができます。2つのピクセルは、隣接していて同じ色である場合に接続されているとみなされます。すべてのピクセルを同じ色にするために必要な最小の操作回数を求めてください。\n\n注意: 各色について、その色のピクセルは最大で20個です。\n\n例:\n    >>> f_45(5, (int[]){1, 2, 3, 2, 1})\n    2", "ko": "C 함수 `int f_45(int n, int* pixels)`를 작성하여 다음 문제를 해결하십시오:\n1 by n 픽셀 이미지가 주어지며, 각 픽셀은 정수로 표현된 색상을 가지고 있습니다. 색상을 선택하여 같은 색상의 연결된 모든 픽셀을 선택한 색상으로 변경하는 작업을 수행할 수 있습니다. 두 픽셀이 연결되려면 인접해 있어야 하며 같은 색상을 가져야 합니다. 모든 픽셀이 동일한 색상이 되도록 하는 데 필요한 최소 작업 수를 찾으십시오.\n\n참고: 각 색상에 대해 최대 20개의 픽셀이 존재합니다.\n\n예시:\n    >>> f_45(5, (int[]){1, 2, 3, 2, 1})\n    2", "ml": "C ഭാഷയിൽ ഒരു ഫംഗ്ഷൻ `int f_45(int n, int* pixels)` എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nനിങ്ങൾക്ക് 1 by n പിക്‌സൽ ഇമേജ് നൽകിയിരിക്കുന്നു, ഇവിടെ ഓരോ പിക്‌സലിനും ഒരു പൂജ്യം പ്രതിനിധാനം ചെയ്യുന്ന ഒരു പൂർണ്ണസംഖ്യയാൽ പ്രതിനിധീകരിക്കുന്നു. നിങ്ങൾക്ക് ഒരു പ്രവർത്തനം നടത്താം, അതായത് നിങ്ങൾ ഒരു പൂജ്യം തിരഞ്ഞെടുക്കുകയും അതേ പൂജ്യം ഉള്ള എല്ലാ ബന്ധിപ്പിച്ച പിക്‌സലുകളെയും തിരഞ്ഞെടുത്ത പൂജ്യമായി മാറ്റുകയും ചെയ്യാം. രണ്ട് പിക്‌സലുകൾ ബന്ധിപ്പിച്ചിരിക്കുന്നു എങ്കിൽ അവർ അടുത്തടുത്തും ഒരേ പൂജ്യം ഉള്ളതുമാണ്. എല്ലാ പിക്‌സലുകളും ഒരേ പൂജ്യം ആക്കാൻ ആവശ്യമായ കുറഞ്ഞ പ്രവർത്തനങ്ങളുടെ എണ്ണം കണ്ടെത്തുക.\n\nകുറിപ്പ്: ഓരോ പൂജ്യത്തിനും അതേ പൂജ്യം ഉള്ള പരമാവധി 20 പിക്‌സലുകൾ മാത്രമേ ഉണ്ടാകൂ.\n\nഉദാഹരണങ്ങൾ:\n    >>> f_45(5, (int[]){1, 2, 3, 2, 1})\n    2", "fa": "یک تابع C به نام `int f_45(int n, int* pixels)` بنویسید تا مسئله زیر را حل کند:\nشما یک تصویر ۱ در n پیکسل دارید که هر پیکسل دارای رنگی است که با یک عدد صحیح نشان داده می‌شود. شما می‌توانید عملیاتی انجام دهید که در آن یک رنگ انتخاب کرده و تمام پیکسل‌های متصل با همان رنگ را به رنگ انتخابی تغییر دهید. دو پیکسل متصل هستند اگر مجاور باشند و رنگ یکسانی داشته باشند. حداقل تعداد عملیات مورد نیاز برای یکسان کردن رنگ تمام پیکسل‌ها را پیدا کنید.\n\nتوجه: برای هر رنگ، حداکثر ۲۰ پیکسل با آن رنگ وجود دارد.\n\nمثال‌ها:\n    >>> f_45(5, (int[]){1, 2, 3, 2, 1})\n    2"}, "level": "hard", "test": "int main() {\n    assert(f_45(5, (int[]){1, 2, 3, 2, 1}) == 2);\n    assert(f_45(4, (int[]){1, 1, 2, 2}) == 1);\n    assert(f_45(5, (int[]){1, 2, 1, 4, 2}) == 3);\n    assert(f_45(5, (int[]){5, 5, 5, 5, 5}) == 0);\n    assert(f_45(6, (int[]){1, 1, 1, 2, 2, 2}) == 1);\n    assert(f_45(7, (int[]){1, 3, 3, 3, 2, 2, 2}) == 2);\n    assert(f_45(8, (int[]){4, 4, 4, 4, 3, 3, 3, 3}) == 1);\n    assert(f_45(9, (int[]){1, 2, 3, 4, 5, 6, 7, 8, 9}) == 8);\n    assert(f_45(10, (int[]){1, 2, 1, 2, 1, 2, 1, 2, 1, 2}) == 5);\n    assert(f_45(3, (int[]){3, 3, 3}) == 0);\n    assert(f_45(4, (int[]){2, 1, 1, 2}) == 1);\n    return 0;\n}", "entry_point": "f_45", "signature": "int f_45(int n, int* pixels)", "docstring": {"en": "You are given a 1 by n pixel image, where each pixel has a color represented by an integer. You can perform an operation where you pick a color and change all connected pixels of the same color to the chosen color. Two pixels are connected if they are adjacent and have the same color. Find the minimum number of operations required to make all pixels the same color.\n\nNote: For each color, there are at most 20 pixels of that color.\n\nExamples:\n    >>> f_45(5, (int[]){1, 2, 3, 2, 1})\n    2\n", "sq": "Ju jepet një imazh 1 me n piksel, ku secili piksel ka një ngjyrë të përfaqësuar nga një numër i plotë. Ju mund të kryeni një operacion ku zgjidhni një ngjyrë dhe ndryshoni të gjithë piksela të lidhur të së njëjtës ngjyrë në ngjyrën e zgjedhur. Dy piksela janë të lidhur nëse janë ngjitur dhe kanë të njëjtën ngjyrë. Gjeni numrin minimal të operacioneve të nevojshme për t'i bërë të gjithë piksela të së njëjtës ngjyrë.\n\nShënim: Për çdo ngjyrë, ka maksimumi 20 piksela të asaj ngjyre.\n\nShembuj:\n    >>> f_45(5, (int[]){1, 2, 3, 2, 1})\n    2\n", "hy": "Ձեզ տրված է 1 x n պիքսել պատկեր, որտեղ յուրաքանչյուր պիքսել ունի գույն, որը ներկայացված է ամբողջ թվով: Դուք կարող եք կատարել գործողություն, որտեղ ընտրում եք գույն և փոխում նույն գույնի բոլոր միացած պիքսելները ընտրված գույնով: Երկու պիքսել միացած են, եթե նրանք հարևան են և ունեն նույն գույնը: Գտեք նվազագույն գործողությունների քանակը, որը պահանջվում է, որպեսզի բոլոր պիքսելները ունենան նույն գույնը:\n\nՆշում: Յուրաքանչյուր գույնի համար առավելագույնը կա 20 պիքսել:\n\nՕրինակներ:\n    >>> f_45(5, (int[]){1, 2, 3, 2, 1})\n    2", "bn": "আপনাকে একটি 1 বাই n পিক্সেল ইমেজ দেওয়া হয়েছে, যেখানে প্রতিটি পিক্সেলের একটি রঙ একটি পূর্ণসংখ্যা দ্বারা প্রতিনিধিত্ব করা হয়। আপনি একটি অপারেশন সম্পাদন করতে পারেন যেখানে আপনি একটি রঙ বেছে নেন এবং একই রঙের সমস্ত সংযুক্ত পিক্সেলগুলি নির্বাচিত রঙে পরিবর্তন করেন। দুটি পিক্সেল সংযুক্ত থাকে যদি তারা সংলগ্ন হয় এবং একই রঙের হয়। সমস্ত পিক্সেলকে একই রঙে পরিবর্তন করতে প্রয়োজনীয় সর্বনিম্ন সংখ্যক অপারেশন খুঁজে বের করুন।\n\nবিঃদ্রঃ: প্রতিটি রঙের জন্য, সেই রঙের সর্বাধিক ২০টি পিক্সেল রয়েছে।\n\nউদাহরণ:\n    >>> f_45(5, (int[]){1, 2, 3, 2, 1})\n    2", "bg": "Дадено ви е изображение с размер 1 на n пиксела, където всеки пиксел има цвят, представен чрез цяло число. Можете да извършите операция, при която избирате цвят и променяте всички свързани пиксели със същия цвят на избрания цвят. Два пиксела са свързани, ако са съседни и имат същия цвят. Намерете минималния брой операции, необходими, за да направите всички пиксели с един и същ цвят.\n\nЗабележка: За всеки цвят има най-много 20 пиксела от този цвят.\n\nПримери:\n    >>> f_45(5, (int[]){1, 2, 3, 2, 1})\n    2", "zh": "你有一个 1 x n 像素的图像，其中每个像素的颜色由一个整数表示。你可以执行一个操作，选择一种颜色并将所有连接的相同颜色的像素更改为所选颜色。如果两个像素相邻并且具有相同的颜色，则它们是连接的。找出使所有像素颜色相同所需的最小操作次数。\n\n注意：对于每种颜色，最多有 20 个该颜色的像素。\n\n示例：\n    >>> f_45(5, (int[]){1, 2, 3, 2, 1})\n    2", "fr": "Vous avez une image de 1 par n pixels, où chaque pixel a une couleur représentée par un entier. Vous pouvez effectuer une opération où vous choisissez une couleur et changez tous les pixels connectés de la même couleur en la couleur choisie. Deux pixels sont connectés s'ils sont adjacents et ont la même couleur. Trouvez le nombre minimum d'opérations nécessaires pour que tous les pixels aient la même couleur.\n\nRemarque : Pour chaque couleur, il y a au plus 20 pixels de cette couleur.\n\nExemples :\n    >>> f_45(5, (int[]){1, 2, 3, 2, 1})\n    2", "de": "Du hast ein 1 mal n Pixel-Bild, wobei jeder Pixel eine Farbe hat, die durch eine ganze Zahl dargestellt wird. Du kannst eine Operation durchführen, bei der du eine Farbe auswählst und alle verbundenen Pixel derselben Farbe in die gewählte Farbe änderst. Zwei Pixel sind verbunden, wenn sie benachbart sind und die gleiche Farbe haben. Finde die minimale Anzahl von Operationen, die erforderlich sind, um alle Pixel in die gleiche Farbe zu bringen.\n\nHinweis: Für jede Farbe gibt es höchstens 20 Pixel dieser Farbe.\n\nBeispiele:\n    >>> f_45(5, (int[]){1, 2, 3, 2, 1})\n    2", "ha": "An ba ku hoton pixel 1 ta n, inda kowanne pixel yana da launi da aka wakilta da lamba. Kuna iya aiwatar da aiki inda kuke zaɓar launi kuma ku canza duk pixels masu alaƙa na launi ɗaya zuwa launin da aka zaɓa. Pixels biyu suna da alaƙa idan suna kusa da juna kuma suna da launi ɗaya. Nemo mafi ƙarancin adadin ayyuka da ake buƙata don sanya duk pixels su zama launi ɗaya.\n\nLura: Ga kowane launi, akwai a kalla pixels 20 na wannan launi.\n\nMisalai:\n    >>> f_45(5, (int[]){1, 2, 3, 2, 1})\n    2", "hi": "आपको एक 1 बाय n पिक्सल छवि दी गई है, जहाँ प्रत्येक पिक्सल का रंग एक पूर्णांक द्वारा दर्शाया गया है। आप एक ऑपरेशन कर सकते हैं जहाँ आप एक रंग चुनते हैं और उसी रंग के सभी जुड़े पिक्सल्स को चुने गए रंग में बदल देते हैं। दो पिक्सल जुड़े होते हैं यदि वे आसन्न हैं और उनका रंग समान है। सभी पिक्सल्स को एक ही रंग में बनाने के लिए आवश्यक न्यूनतम ऑपरेशनों की संख्या ज्ञात करें।\n\nध्यान दें: प्रत्येक रंग के लिए, उस रंग के अधिकतम 20 पिक्सल होते हैं।\n\nउदाहरण:\n    >>> f_45(5, (int[]){1, 2, 3, 2, 1})\n    2", "hu": "Egy 1 x n pixeles képet kap, ahol minden pixel színe egy egész számmal van reprezentálva. Végrehajthat egy műveletet, amely során kiválaszt egy színt, és megváltoztatja az összes összekapcsolt azonos színű pixelt a kiválasztott színre. Két pixel akkor van összekapcsolva, ha szomszédosak és azonos színűek. Keresse meg a minimális műveletek számát, amelyek szükségesek ahhoz, hogy az összes pixel azonos színű legyen.\n\nMegjegyzés: Minden színhez legfeljebb 20 pixel tartozik.\n\nPéldák:\n    >>> f_45(5, (int[]){1, 2, 3, 2, 1})\n    2", "es": "Se le da una imagen de 1 por n píxeles, donde cada píxel tiene un color representado por un entero. Puede realizar una operación en la que elige un color y cambia todos los píxeles conectados del mismo color al color elegido. Dos píxeles están conectados si son adyacentes y tienen el mismo color. Encuentre el número mínimo de operaciones necesarias para hacer que todos los píxeles sean del mismo color.\n\nNota: Para cada color, hay como máximo 20 píxeles de ese color.\n\nEjemplos:\n    >>> f_45(5, (int[]){1, 2, 3, 2, 1})\n    2", "arb": "أنت لديك صورة بحجم 1 في n بكسل، حيث كل بكسل له لون ممثل برقم صحيح. يمكنك تنفيذ عملية حيث تختار لونًا وتغير جميع البكسلات المتصلة من نفس اللون إلى اللون المختار. يعتبر البكسلان متصلان إذا كانا متجاورين ولهما نفس اللون. جد الحد الأدنى لعدد العمليات المطلوبة لجعل جميع البكسلات بنفس اللون.\n\nملاحظة: لكل لون، هناك بحد أقصى 20 بكسل من ذلك اللون.\n\nأمثلة:\n    >>> f_45(5, (int[]){1, 2, 3, 2, 1})\n    2", "sw": "Unapewa picha ya pikseli 1 kwa n, ambapo kila pikseli ina rangi inayowakilishwa na nambari. Unaweza kufanya operesheni ambapo unachagua rangi na kubadilisha pikseli zote zilizounganishwa za rangi hiyo kuwa rangi iliyochaguliwa. Pikseli mbili zimeunganishwa ikiwa ziko karibu na zina rangi sawa. Tafuta idadi ndogo ya operesheni zinazohitajika kufanya pikseli zote ziwe na rangi sawa.\n\nKumbuka: Kwa kila rangi, kuna pikseli zisizozidi 20 za rangi hiyo.\n\nMifano:\n    >>> f_45(5, (int[]){1, 2, 3, 2, 1})\n    2\n", "tr": "1'e n piksel boyutunda bir görüntü veriliyor ve her piksel bir tamsayı ile temsil edilen bir renge sahip. Bir renk seçip, aynı renge sahip tüm bağlı pikselleri seçilen renge değiştirebileceğiniz bir işlem gerçekleştirebilirsiniz. İki piksel, bitişik ve aynı renge sahiplerse bağlıdır. Tüm pikselleri aynı renge getirmek için gereken minimum işlem sayısını bulun.\n\nNot: Her renk için en fazla 20 piksel vardır.\n\nÖrnekler:\n    >>> f_45(5, (int[]){1, 2, 3, 2, 1})\n    2", "vi": "Bạn được cung cấp một hình ảnh 1 x n pixel, trong đó mỗi pixel có một màu được biểu diễn bằng một số nguyên. Bạn có thể thực hiện một thao tác trong đó bạn chọn một màu và thay đổi tất cả các pixel kết nối có cùng màu thành màu đã chọn. Hai pixel được kết nối nếu chúng liền kề và có cùng màu. Tìm số lượng thao tác tối thiểu cần thiết để làm cho tất cả các pixel có cùng màu.\n\nLưu ý: Đối với mỗi màu, có tối đa 20 pixel của màu đó.\n\nVí dụ:\n    >>> f_45(5, (int[]){1, 2, 3, 2, 1})\n    2", "id": "Anda diberikan gambar 1 x n piksel, di mana setiap piksel memiliki warna yang diwakili oleh sebuah bilangan bulat. Anda dapat melakukan operasi di mana Anda memilih sebuah warna dan mengubah semua piksel yang terhubung dengan warna yang sama menjadi warna yang dipilih. Dua piksel terhubung jika mereka bersebelahan dan memiliki warna yang sama. Temukan jumlah operasi minimum yang diperlukan untuk membuat semua piksel memiliki warna yang sama.\n\nCatatan: Untuk setiap warna, terdapat paling banyak 20 piksel dengan warna tersebut.\n\nContoh:\n    >>> f_45(5, (int[]){1, 2, 3, 2, 1})\n    2\n", "ja": "1行nピクセルの画像が与えられます。各ピクセルは整数で表される色を持っています。ある色を選び、同じ色の隣接するすべてのピクセルを選んだ色に変更する操作を行うことができます。2つのピクセルは、隣接していて同じ色である場合に接続されています。すべてのピクセルを同じ色にするために必要な操作の最小数を求めます。\n\n注意: 各色について、その色のピクセルは最大で20個です。\n\n例:\n    >>> f_45(5, (int[]){1, 2, 3, 2, 1})\n    2", "ko": "1 by n 픽셀 이미지가 주어지며, 각 픽셀은 정수로 표현된 색상을 가지고 있습니다. 색상을 선택하고 동일한 색상의 연결된 모든 픽셀을 선택한 색상으로 변경하는 작업을 수행할 수 있습니다. 두 픽셀이 연결되었다는 것은 인접해 있고 같은 색상을 가지고 있다는 것을 의미합니다. 모든 픽셀을 동일한 색상으로 만들기 위해 필요한 최소 작업 수를 찾으십시오.\n\n참고: 각 색상에 대해 해당 색상의 픽셀은 최대 20개입니다.\n\n예시:\n    >>> f_45(5, (int[]){1, 2, 3, 2, 1})\n    2", "ml": "നിങ്ങൾക്ക് 1 by n പിക്സൽ ഇമേജ് നൽകിയിരിക്കുന്നു, ഇവിടെ ഓരോ പിക്സലിനും ഒരു പൂർണ്ണസംഖ്യയാൽ പ്രതിനിധീകരിക്കുന്ന ഒരു നിറം ഉണ്ട്. നിങ്ങൾക്ക് ഒരു നിറം തിരഞ്ഞെടുക്കുകയും, അതേ നിറമുള്ള എല്ലാ ബന്ധിപ്പിച്ചിരിക്കുന്ന പിക്സലുകളും തിരഞ്ഞെടുക്കപ്പെട്ട നിറത്തിലേക്ക് മാറ്റുകയും ചെയ്യുന്ന ഒരു പ്രവർത്തനം നടത്താൻ കഴിയും. രണ്ട് പിക്സലുകൾ ബന്ധിപ്പിക്കപ്പെട്ടിരിക്കുന്നതാകുന്നത് അവർ സമീപത്തുള്ളതും അതേ നിറമുള്ളതും ആണെങ്കിൽ മാത്രമേയുള്ളൂ. എല്ലാ പിക്സലുകളും ഒരേ നിറത്തിലാക്കാൻ ആവശ്യമായ കുറഞ്ഞ പ്രവർത്തനങ്ങളുടെ എണ്ണം കണ്ടെത്തുക.\n\nകുറിപ്പ്: ഓരോ നിറത്തിനും ആ നിറത്തിലുള്ള പരമാവധി 20 പിക്സലുകൾ മാത്രമേയുള്ളൂ.\n\nഉദാഹരണങ്ങൾ:\n    >>> f_45(5, (int[]){1, 2, 3, 2, 1})\n    2", "fa": "شما یک تصویر 1 در n پیکسلی دارید که هر پیکسل دارای رنگی است که با یک عدد صحیح نشان داده می‌شود. شما می‌توانید عملیاتی انجام دهید که در آن یک رنگ را انتخاب کرده و تمام پیکسل‌های متصل با همان رنگ را به رنگ انتخاب شده تغییر دهید. دو پیکسل متصل هستند اگر مجاور باشند و رنگ یکسانی داشته باشند. حداقل تعداد عملیات مورد نیاز برای یکسان کردن رنگ همه پیکسل‌ها را بیابید.\n\nتوجه: برای هر رنگ، حداکثر 20 پیکسل با آن رنگ وجود دارد.\n\nمثال‌ها:\n    >>> f_45(5, (int[]){1, 2, 3, 2, 1})\n    2"}}
{"task_id": "C/46", "prompt": {"en": "#include <assert.h>\n#include <stdio.h>\n/*\nGiven an integer n, write a function to compute the sum of all numbers from 1 to n that are multiples of either 3 or 5. If a number is a multiple of both 3 and 5, it should only be counted once.\nFor example:\n    >>> f_46(10)\n    33 // (3 + 5 + 6 + 9 + 10)\n*/\nint f_46(int n)", "sq": "#include <assert.h>\n#include <stdio.h>\n/*\nDuke pasur një numër të plotë n, shkruani një funksion për të llogaritur shumën e të gjithë numrave nga 1 deri në n që janë shumëfish i 3 ose 5. Nëse një numër është shumëfish i të dyjave 3 dhe 5, ai duhet të numërohet vetëm një herë.\nPër shembull:\n    >>> f_46(10)\n    33 // (3 + 5 + 6 + 9 + 10)\n*/\nint f_46(int n)", "hy": "#include <assert.h>\n#include <stdio.h>\n/*\nՏրված է ամբողջ թիվ n, գրեք ֆունկցիա՝ հաշվելու համար 1-ից n բոլոր այն թվերի գումարը, որոնք բազմապատիկ են 3-ի կամ 5-ի։ Եթե թիվը բազմապատիկ է և՛ 3-ի, և՛ 5-ի, այն պետք է հաշվել միայն մեկ անգամ։\nՕրինակ:\n    >>> f_46(10)\n    33 // (3 + 5 + 6 + 9 + 10)\n*/\nint f_46(int n)", "bn": "#include <assert.h>\n#include <stdio.h>\n/*\nএকটি পূর্ণসংখ্যা n দেওয়া হলে, এমন একটি ফাংশন লিখুন যা 1 থেকে n পর্যন্ত সমস্ত সংখ্যার যোগফল গণনা করে যা 3 বা 5 এর গুণিতক। যদি কোনো সংখ্যা 3 এবং 5 উভয়ের গুণিতক হয়, তবে এটি কেবল একবার গণনা করা উচিত।\nউদাহরণস্বরূপ:\n    >>> f_46(10)\n    33 // (3 + 5 + 6 + 9 + 10)\n*/\nint f_46(int n)", "bg": "#include <assert.h>\n#include <stdio.h>\n/*\nДадено е цяло число n, напишете функция за изчисляване на сумата на всички числа от 1 до n, които са кратни на 3 или 5. Ако едно число е кратно и на 3, и на 5, то трябва да бъде преброено само веднъж.\nНапример:\n    >>> f_46(10)\n    33 // (3 + 5 + 6 + 9 + 10)\n*/\nint f_46(int n)", "zh": "#include <assert.h>\n#include <stdio.h>\n/*\n给定一个整数 n，编写一个函数来计算从 1 到 n 之间所有是 3 或 5 的倍数的数字之和。如果一个数字同时是 3 和 5 的倍数，则它只应被计算一次。\n例如：\n    >>> f_46(10)\n    33 // (3 + 5 + 6 + 9 + 10)\n*/\nint f_46(int n)", "fr": "#include <assert.h>\n#include <stdio.h>\n/*\nÉtant donné un entier n, écrivez une fonction pour calculer la somme de tous les nombres de 1 à n qui sont des multiples de 3 ou 5. Si un nombre est un multiple à la fois de 3 et de 5, il ne doit être compté qu'une seule fois.\nPar exemple :\n    >>> f_46(10)\n    33 // (3 + 5 + 6 + 9 + 10)\n*/\nint f_46(int n)", "de": "#include <assert.h>\n#include <stdio.h>\n/*\nGegeben eine ganze Zahl n, schreibe eine Funktion, um die Summe aller Zahlen von 1 bis n zu berechnen, die Vielfache von entweder 3 oder 5 sind. Wenn eine Zahl ein Vielfaches von sowohl 3 als auch 5 ist, sollte sie nur einmal gezählt werden.\nZum Beispiel:\n    >>> f_46(10)\n    33 // (3 + 5 + 6 + 9 + 10)\n*/\nint f_46(int n)", "ha": "#include <assert.h>\n#include <stdio.h>\n/*\nAn ba da wani lamba n, rubuta wata aiki don lissafin jimillar duk lambobi daga 1 zuwa n waɗanda suke ninki na 3 ko 5. Idan lamba tana ninki na duka 3 da 5, ya kamata a ƙirga ta sau ɗaya kawai.\nMisali:\n    >>> f_46(10)\n    33 // (3 + 5 + 6 + 9 + 10)\n*/\nint f_46(int n)", "hi": "#include <assert.h>\n#include <stdio.h>\n/*\nदिए गए पूर्णांक n के लिए, एक फ़ंक्शन लिखें जो 1 से n तक के उन सभी संख्याओं का योग गणना करे जो 3 या 5 के गुणज हैं। यदि कोई संख्या 3 और 5 दोनों की गुणज है, तो उसे केवल एक बार गिना जाना चाहिए।\nउदाहरण के लिए:\n    >>> f_46(10)\n    33 // (3 + 5 + 6 + 9 + 10)\n*/\nint f_46(int n)", "hu": "#include <assert.h>\n#include <stdio.h>\n/*\nAdott egy egész szám n, írj egy függvényt, amely kiszámítja az összes olyan szám összegét 1-től n-ig, amelyek 3 vagy 5 többszörösei. Ha egy szám mind a 3, mind az 5 többszöröse, akkor azt csak egyszer kell számolni.\nPéldául:\n    >>> f_46(10)\n    33 // (3 + 5 + 6 + 9 + 10)\n*/\nint f_46(int n)", "es": "#include <assert.h>\n#include <stdio.h>\n/*\nDado un entero n, escribe una función para calcular la suma de todos los números desde 1 hasta n que sean múltiplos de 3 o 5. Si un número es múltiplo de ambos 3 y 5, solo debe contarse una vez.\nPor ejemplo:\n    >>> f_46(10)\n    33 // (3 + 5 + 6 + 9 + 10)\n*/\nint f_46(int n)", "arb": "#include <assert.h>\n#include <stdio.h>\n/*\nمعطى عدد صحيح n، اكتب دالة لحساب مجموع كل الأرقام من 1 إلى n التي هي مضاعفات لـ 3 أو 5. إذا كان الرقم مضاعفًا لكل من 3 و 5، فيجب احتسابه مرة واحدة فقط.\nعلى سبيل المثال:\n    >>> f_46(10)\n    33 // (3 + 5 + 6 + 9 + 10)\n*/\nint f_46(int n)", "sw": "#include <assert.h>\n#include <stdio.h>\n/*\nUkipiwa nambari nzima n, andika kazi ya kuhesabu jumla ya nambari zote kutoka 1 hadi n ambazo ni vizidisho vya ama 3 au 5. Ikiwa nambari ni kizidisho cha 3 na 5, inapaswa kuhesabiwa mara moja tu.\nKwa mfano:\n    >>> f_46(10)\n    33 // (3 + 5 + 6 + 9 + 10)\n*/\nint f_46(int n)", "tr": "#include <assert.h>\n#include <stdio.h>\n/*\nVerilen bir tamsayı n için, 1'den n'ye kadar olan ve 3 veya 5'in katı olan tüm sayıların toplamını hesaplayan bir fonksiyon yazın. Bir sayı hem 3 hem de 5'in katıysa, yalnızca bir kez sayılmalıdır.\nÖrneğin:\n    >>> f_46(10)\n    33 // (3 + 5 + 6 + 9 + 10)\n*/\nint f_46(int n)", "vi": "#include <assert.h>\n#include <stdio.h>\n/*\nCho một số nguyên n, viết một hàm để tính tổng của tất cả các số từ 1 đến n mà là bội số của 3 hoặc 5. Nếu một số là bội số của cả 3 và 5, nó chỉ nên được đếm một lần.\nVí dụ:\n    >>> f_46(10)\n    33 // (3 + 5 + 6 + 9 + 10)\n*/\nint f_46(int n)", "id": "#include <assert.h>\n#include <stdio.h>\n/*\nDiberikan sebuah bilangan bulat n, tulislah sebuah fungsi untuk menghitung jumlah semua angka dari 1 hingga n yang merupakan kelipatan dari 3 atau 5. Jika sebuah angka merupakan kelipatan dari 3 dan 5, angka tersebut hanya dihitung sekali.\nSebagai contoh:\n    >>> f_46(10)\n    33 // (3 + 5 + 6 + 9 + 10)\n*/\nint f_46(int n)", "ja": "#include <assert.h>\n#include <stdio.h>\n/*\n整数 n が与えられたとき、3 または 5 の倍数である 1 から n までのすべての数の合計を計算する関数を書いてください。3 と 5 の両方の倍数である数は、一度だけカウントされるべきです。\n例えば:\n    >>> f_46(10)\n    33 // (3 + 5 + 6 + 9 + 10)\n*/\nint f_46(int n)\n", "ko": "#include <assert.h>\n#include <stdio.h>\n/*\n정수 n이 주어졌을 때, 1부터 n까지의 숫자 중 3 또는 5의 배수인 모든 숫자의 합을 계산하는 함수를 작성하세요. 숫자가 3과 5의 공배수인 경우, 한 번만 계산되어야 합니다.\n예를 들어:\n    >>> f_46(10)\n    33 // (3 + 5 + 6 + 9 + 10)\n*/\nint f_46(int n)", "ml": "#include <assert.h>\n#include <stdio.h>\n/*\nഒരു പൂർണ്ണസംഖ്യ n നൽകിയാൽ, 3 അല്ലെങ്കിൽ 5 യുടെ ഗുണിതകങ്ങൾ ആയ 1 മുതൽ n വരെ ഉള്ള എല്ലാ സംഖ്യകളുടെയും മൊത്തം കണക്കാക്കുന്നതിനുള്ള ഒരു ഫംഗ്ഷൻ എഴുതുക. ഒരു സംഖ്യ 3 നും 5 നും ഗുണിതകമായാൽ, അത് ഒരിക്കൽ മാത്രമേ എണ്ണിക്കൊള്ളൂ.\nഉദാഹരണത്തിന്:\n    >>> f_46(10)\n    33 // (3 + 5 + 6 + 9 + 10)\n*/\nint f_46(int n)", "fa": "#include <assert.h>\n#include <stdio.h>\n/*\nبا توجه به یک عدد صحیح n، یک تابع بنویسید که مجموع تمام اعداد از 1 تا n که مضربی از 3 یا 5 هستند را محاسبه کند. اگر عددی مضربی از هر دو 3 و 5 باشد، باید فقط یک بار شمارش شود.\nبرای مثال:\n    >>> f_46(10)\n    33 // (3 + 5 + 6 + 9 + 10)\n*/\nint f_46(int n)"}, "canonical_solution": "{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}", "instruction": {"en": "Write a C function `int f_46(int n)` to solve the following problem:\nGiven an integer n, write a function to compute the sum of all numbers from 1 to n that are multiples of either 3 or 5. If a number is a multiple of both 3 and 5, it should only be counted once.\nFor example:\n    >>> f_46(10)\n    33 // (3 + 5 + 6 + 9 + 10)\n", "sq": "Shkruani një funksion në C `int f_46(int n)` për të zgjidhur problemin në vijim:\nDuke pasur një numër të plotë n, shkruani një funksion për të llogaritur shumën e të gjithë numrave nga 1 deri në n që janë shumëfish i 3 ose 5. Nëse një numër është shumëfish i të dyve, 3 dhe 5, ai duhet të numërohet vetëm një herë.  \nPër shembull:  \n    >>> f_46(10)  \n    33 // (3 + 5 + 6 + 9 + 10)", "hy": "Գրեք C ֆունկցիա `int f_46(int n)` հետևյալ խնդիրը լուծելու համար:\nՏրված է ամբողջ թիվ n, գրեք ֆունկցիա՝ հաշվելու համար 1-ից n բոլոր այն թվերի գումարը, որոնք բազմապատիկ են 3-ի կամ 5-ի: Եթե թիվը բազմապատիկ է և՛ 3-ի, և՛ 5-ի, այն պետք է հաշվել միայն մեկ անգամ:\nՕրինակ:\n    >>> f_46(10)\n    33 // (3 + 5 + 6 + 9 + 10)", "bn": "একটি C ফাংশন `int f_46(int n)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি পূর্ণসংখ্যা n দেওয়া হলে, একটি ফাংশন লিখুন যা 1 থেকে n পর্যন্ত সমস্ত সংখ্যার যোগফল গণনা করবে যা 3 বা 5 এর গুণিতক। যদি কোনো সংখ্যা 3 এবং 5 উভয়ের গুণিতক হয়, তবে এটি কেবল একবার গণনা করা উচিত।\nউদাহরণস্বরূপ:\n    >>> f_46(10)\n    33 // (3 + 5 + 6 + 9 + 10)", "bg": "Напишете C функция `int f_46(int n)`, за да решите следния проблем:\nДадено е цяло число n, напишете функция за изчисляване на сумата на всички числа от 1 до n, които са кратни на 3 или 5. Ако едно число е кратно и на 3, и на 5, то трябва да бъде преброено само веднъж.  \nНапример:  \n    >>> f_46(10)  \n    33 // (3 + 5 + 6 + 9 + 10)", "zh": "编写一个 C 函数 `int f_46(int n)` 来解决以下问题：\n给定一个整数 n，编写一个函数计算从 1 到 n 的所有 3 或 5 的倍数的和。如果一个数字同时是 3 和 5 的倍数，它应该只被计算一次。  \n例如：  \n    >>> f_46(10)  \n    33 // (3 + 5 + 6 + 9 + 10)  ", "fr": "Écrire une fonction C `int f_46(int n)` pour résoudre le problème suivant :\nÉtant donné un entier n, écrire une fonction pour calculer la somme de tous les nombres de 1 à n qui sont des multiples de 3 ou 5. Si un nombre est un multiple à la fois de 3 et de 5, il ne doit être compté qu'une seule fois.  \nPar exemple :  \n    >>> f_46(10)  \n    33 // (3 + 5 + 6 + 9 + 10)  ", "de": "Schreiben Sie eine C-Funktion `int f_46(int n)`, um das folgende Problem zu lösen:\nGegeben eine ganze Zahl n, schreiben Sie eine Funktion, um die Summe aller Zahlen von 1 bis n zu berechnen, die Vielfache von entweder 3 oder 5 sind. Wenn eine Zahl ein Vielfaches von sowohl 3 als auch 5 ist, sollte sie nur einmal gezählt werden.  \nZum Beispiel:  \n    >>> f_46(10)  \n    33 // (3 + 5 + 6 + 9 + 10)  ", "ha": "Rubuta aikin C `int f_46(int n)` don warware matsalar mai zuwa:\nAn ba da lamba n, rubuta aiki don lissafin jimillar duk lambobi daga 1 zuwa n waɗanda suke masu yawa na 3 ko 5. Idan lamba tana da yawa na duka 3 da 5, ya kamata a ƙirga ta sau ɗaya kawai.  \nMisali:  \n    >>> f_46(10)  \n    33 // (3 + 5 + 6 + 9 + 10)  ", "hi": "C फ़ंक्शन `int f_46(int n)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए पूर्णांक n के लिए, एक फ़ंक्शन लिखें जो 1 से n तक के उन सभी संख्याओं का योग गणना करे जो 3 या 5 के गुणज हैं। यदि कोई संख्या 3 और 5 दोनों का गुणज है, तो उसे केवल एक बार गिना जाना चाहिए।\nउदाहरण के लिए:\n    >>> f_46(10)\n    33 // (3 + 5 + 6 + 9 + 10)", "hu": "Írj egy C függvényt `int f_46(int n)` a következő probléma megoldására:\nAdott egy egész szám n, írj egy függvényt, amely kiszámítja az összes 1-től n-ig terjedő szám összegét, amelyek 3 vagy 5 többszörösei. Ha egy szám mind 3-nak, mind 5-nek többszöröse, akkor azt csak egyszer kell számolni.\nPéldául:\n    >>> f_46(10)\n    33 // (3 + 5 + 6 + 9 + 10)", "es": "Escribe una función en C `int f_46(int n)` para resolver el siguiente problema:\nDado un entero n, escribe una función para calcular la suma de todos los números desde 1 hasta n que sean múltiplos de 3 o 5. Si un número es múltiplo de ambos 3 y 5, solo debe contarse una vez.\nPor ejemplo:\n    >>> f_46(10)\n    33 // (3 + 5 + 6 + 9 + 10)", "arb": "اكتب دالة بلغة C `int f_46(int n)` لحل المشكلة التالية:\nمعطى عدد صحيح n، اكتب دالة لحساب مجموع جميع الأرقام من 1 إلى n التي هي مضاعفات لـ 3 أو 5. إذا كان الرقم مضاعفًا لكل من 3 و 5، فيجب أن يُحسب مرة واحدة فقط.\nعلى سبيل المثال:\n    >>> f_46(10)\n    33 // (3 + 5 + 6 + 9 + 10)", "sw": "Andika kazi ya C `int f_46(int n)` kutatua tatizo lifuatalo:\nUkipiwa nambari nzima n, andika kazi ya kuhesabu jumla ya nambari zote kutoka 1 hadi n ambazo ni vizidisho vya 3 au 5. Ikiwa nambari ni kizidisho cha 3 na 5, inapaswa kuhesabiwa mara moja tu.\nKwa mfano:\n    >>> f_46(10)\n    33 // (3 + 5 + 6 + 9 + 10)", "tr": "Bir C fonksiyonu `int f_46(int n)` yazın ve aşağıdaki problemi çözün:\nVerilen bir tamsayı n için, 1'den n'ye kadar olan sayılardan 3 veya 5'in katı olanların toplamını hesaplayan bir fonksiyon yazın. Bir sayı hem 3 hem de 5'in katı ise, yalnızca bir kez sayılmalıdır.\nÖrneğin:\n    >>> f_46(10)\n    33 // (3 + 5 + 6 + 9 + 10)", "vi": "Viết một hàm C `int f_46(int n)` để giải quyết vấn đề sau:\nCho một số nguyên n, viết một hàm để tính tổng của tất cả các số từ 1 đến n mà là bội số của 3 hoặc 5. Nếu một số là bội số của cả 3 và 5, nó chỉ nên được tính một lần.  \nVí dụ:  \n    >>> f_46(10)  \n    33 // (3 + 5 + 6 + 9 + 10)  ", "id": "Tulis sebuah fungsi C `int f_46(int n)` untuk menyelesaikan masalah berikut:\nDiberikan sebuah bilangan bulat n, tulis sebuah fungsi untuk menghitung jumlah dari semua angka dari 1 hingga n yang merupakan kelipatan dari 3 atau 5. Jika sebuah angka adalah kelipatan dari 3 dan 5, angka tersebut hanya dihitung sekali.\nSebagai contoh:\n    >>> f_46(10)\n    33 // (3 + 5 + 6 + 9 + 10)", "ja": "Cの関数を書け `int f_46(int n)` を作成して、次の問題を解決してください:\n整数nが与えられたとき、1からnまでの数のうち、3または5の倍数である数の合計を計算する関数を書いてください。ある数が3と5の両方の倍数である場合、それは一度だけカウントされるべきです。\n例えば:\n    >>> f_46(10)\n    33 // (3 + 5 + 6 + 9 + 10)", "ko": "C 함수 `int f_46(int n)`을 작성하여 다음 문제를 해결하십시오:\n정수 n이 주어졌을 때, 1부터 n까지의 숫자 중 3 또는 5의 배수인 모든 숫자의 합을 계산하는 함수를 작성하십시오. 숫자가 3과 5의 공배수인 경우에는 한 번만 계산해야 합니다.\n예를 들어:\n    >>> f_46(10)\n    33 // (3 + 5 + 6 + 9 + 10)", "ml": "C ഭാഷയിൽ ഒരു ഫംഗ്ഷൻ `int f_46(int n)` എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nഒരു പൂർണ്ണസംഖ്യ n നൽകിയാൽ, 1 മുതൽ n വരെ 3 അല്ലെങ്കിൽ 5 ന്റെ ഗുണിതങ്ങൾ ആയ എല്ലാ സംഖ്യകളുടെയും മൊത്തം ചേരുക. ഒരു സംഖ്യ 3 ന്റെയും 5 ന്റെയും ഗുണിതമാണെങ്കിൽ, അത് ഒരിക്കൽ മാത്രം എണ്ണണം.\nഉദാഹരണത്തിന്:\n    >>> f_46(10)\n    33 // (3 + 5 + 6 + 9 + 10)", "fa": "یک تابع C به نام `int f_46(int n)` بنویسید تا مسئله زیر را حل کند:\nبا توجه به یک عدد صحیح n، تابعی بنویسید که مجموع تمام اعداد از 1 تا n که مضرب 3 یا 5 هستند را محاسبه کند. اگر عددی مضرب هر دو 3 و 5 باشد، باید فقط یک بار شمرده شود.\nبرای مثال:\n    >>> f_46(10)\n    33 // (3 + 5 + 6 + 9 + 10)"}, "level": "easy", "test": "int main()\n{\n    assert(f_46(10) == 33);\n    assert(f_46(15) == 60);\n    assert(f_46(20) == 98);\n    assert(f_46(5) == 8);\n    assert(f_46(3) == 3);\n    assert(f_46(6) == 14);\n    assert(f_46(9) == 23);\n    assert(f_46(12) == 45);\n    assert(f_46(17) == 60);\n    assert(f_46(21) == 119);\n    assert(f_46(25) == 168);\n    return 0;\n}", "entry_point": "f_46", "signature": "int f_46(int n)", "docstring": {"en": "Given an integer n, write a function to compute the sum of all numbers from 1 to n that are multiples of either 3 or 5. If a number is a multiple of both 3 and 5, it should only be counted once.\nFor example:\n    >>> f_46(10)\n    33 // (3 + 5 + 6 + 9 + 10)\n", "sq": "Duke pasur një numër të plotë n, shkruani një funksion për të llogaritur shumën e të gjithë numrave nga 1 deri në n që janë shumëfish i 3 ose 5. Nëse një numër është shumëfish i të dyve, 3 dhe 5, ai duhet të numërohet vetëm një herë.\nPër shembull:\n    >>> f_46(10)\n    33 // (3 + 5 + 6 + 9 + 10)", "hy": "Տրված ամբողջ թիվ n-ի դեպքում, գրեք ֆունկցիա՝ հաշվելու համար 1-ից n բոլոր այն թվերի գումարը, որոնք բազմապատիկ են կամ 3-ի, կամ 5-ի։ Եթե թիվը բազմապատիկ է և՛ 3-ի, և՛ 5-ի, այն պետք է հաշվել միայն մեկ անգամ։\nՕրինակ՝\n    >>> f_46(10)\n    33 // (3 + 5 + 6 + 9 + 10)", "bn": "একটি পূর্ণসংখ্যা n দেওয়া হলে, ১ থেকে n পর্যন্ত সমস্ত সংখ্যার যোগফল গণনা করার জন্য একটি ফাংশন লিখুন যা ৩ অথবা ৫ এর গুণিতক। যদি কোনো সংখ্যা ৩ এবং ৫ উভয়েরই গুণিতক হয়, তবে তা কেবল একবার গণনা করা উচিত।\n\nউদাহরণস্বরূপ:\n    >>> f_46(10)\n    33 // (3 + 5 + 6 + 9 + 10)", "bg": "Дадено е цяло число n, напишете функция за изчисляване на сумата на всички числа от 1 до n, които са кратни на 3 или 5. Ако едно число е кратно и на 3, и на 5, то трябва да се брои само веднъж.\nНапример:\n    >>> f_46(10)\n    33 // (3 + 5 + 6 + 9 + 10)", "zh": "给定一个整数 n，编写一个函数来计算从 1 到 n 之间所有是 3 或 5 的倍数的数字之和。如果一个数字同时是 3 和 5 的倍数，则只应计算一次。\n例如：\n    >>> f_46(10)\n    33 // (3 + 5 + 6 + 9 + 10)", "fr": "Étant donné un entier n, écrivez une fonction pour calculer la somme de tous les nombres de 1 à n qui sont des multiples de 3 ou 5. Si un nombre est un multiple à la fois de 3 et de 5, il ne doit être compté qu'une seule fois.  \nPar exemple :  \n    >>> f_46(10)  \n    33 // (3 + 5 + 6 + 9 + 10)  ", "de": "Geben Sie eine ganze Zahl n an, und schreiben Sie eine Funktion, um die Summe aller Zahlen von 1 bis n zu berechnen, die Vielfache von entweder 3 oder 5 sind. Wenn eine Zahl ein Vielfaches von sowohl 3 als auch 5 ist, sollte sie nur einmal gezählt werden.\nZum Beispiel:\n    >>> f_46(10)\n    33 // (3 + 5 + 6 + 9 + 10)", "ha": "An ba da wani lamba n, rubuta wani aiki don lissafin jimillar duk lambobin daga 1 zuwa n waɗanda suke masu yawa na ko dai 3 ko 5. Idan lamba tana da yawa na duka 3 da 5, ya kamata a ƙirga ta sau ɗaya kawai.\nMisali:\n    >>> f_46(10)\n    33 // (3 + 5 + 6 + 9 + 10)", "hi": "दिए गए पूर्णांक n के लिए, एक फ़ंक्शन लिखें जो 1 से n तक के उन सभी संख्याओं का योग गणना करे जो या तो 3 या 5 के गुणज हैं। यदि कोई संख्या 3 और 5 दोनों का गुणज है, तो उसे केवल एक बार गिना जाना चाहिए।\nउदाहरण के लिए:\n    >>> f_46(10)\n    33 // (3 + 5 + 6 + 9 + 10)", "hu": "Adott egy egész szám n, írj egy függvényt, amely kiszámítja az összes olyan szám összegét 1-től n-ig, amelyek 3 vagy 5 többszörösei. Ha egy szám 3-nak és 5-nek is többszöröse, akkor azt csak egyszer kell számolni.\nPéldául:\n    >>> f_46(10)\n    33 // (3 + 5 + 6 + 9 + 10)", "es": "Dado un entero n, escribe una función para calcular la suma de todos los números desde 1 hasta n que son múltiplos de 3 o 5. Si un número es múltiplo de ambos 3 y 5, debe contarse solo una vez.\nPor ejemplo:\n    >>> f_46(10)\n    33 // (3 + 5 + 6 + 9 + 10)", "arb": "بالنظر إلى عدد صحيح n، اكتب دالة لحساب مجموع كل الأرقام من 1 إلى n التي هي مضاعفات إما لـ 3 أو 5. إذا كان الرقم مضاعفًا لكل من 3 و5، فيجب احتسابه مرة واحدة فقط.\nعلى سبيل المثال:\n    >>> f_46(10)\n    33 // (3 + 5 + 6 + 9 + 10)", "sw": "Kwa kupewa nambari nzima n, andika kazi ya kuhesabu jumla ya nambari zote kutoka 1 hadi n ambazo ni maradufu ya 3 au 5. Ikiwa nambari ni maradufu ya 3 na 5, inapaswa kuhesabiwa mara moja tu. \nKwa mfano:\n    >>> f_46(10)\n    33 // (3 + 5 + 6 + 9 + 10)", "tr": "Verilen bir tam sayı n için, 1'den n'e kadar olan ve 3 veya 5'in katı olan tüm sayıların toplamını hesaplayan bir fonksiyon yazın. Bir sayı hem 3 hem de 5'in katıysa, yalnızca bir kez sayılmalıdır.\nÖrneğin:\n    >>> f_46(10)\n    33 // (3 + 5 + 6 + 9 + 10)", "vi": "Cho một số nguyên n, viết một hàm để tính tổng của tất cả các số từ 1 đến n mà là bội số của 3 hoặc 5. Nếu một số là bội số của cả 3 và 5, nó chỉ nên được tính một lần.  \nVí dụ:  \n    >>> f_46(10)  \n    33 // (3 + 5 + 6 + 9 + 10)  ", "id": "Diberikan sebuah bilangan bulat n, tulislah sebuah fungsi untuk menghitung jumlah semua angka dari 1 hingga n yang merupakan kelipatan dari 3 atau 5. Jika sebuah angka merupakan kelipatan dari 3 dan 5, angka tersebut hanya dihitung sekali saja.\nSebagai contoh:\n    >>> f_46(10)\n    33 // (3 + 5 + 6 + 9 + 10)", "ja": "整数 n が与えられたとき、3 または 5 のいずれかの倍数である 1 から n までのすべての数の合計を計算する関数を書いてください。数が 3 と 5 の両方の倍数である場合、それは一度だけカウントされるべきです。\n\n例えば:\n    >>> f_46(10)\n    33 // (3 + 5 + 6 + 9 + 10)", "ko": "주어진 정수 n에 대해, 1부터 n까지의 숫자 중 3 또는 5의 배수인 모든 숫자의 합을 계산하는 함수를 작성하세요. 숫자가 3과 5의 공배수인 경우에는 한 번만 계산되어야 합니다.\n예를 들어:\n    >>> f_46(10)\n    33 // (3 + 5 + 6 + 9 + 10)", "ml": "ഒരു പൂർണ്ണസംഖ്യയായ n ലഭിച്ചാൽ, 3 അല്ലെങ്കിൽ 5 ന്റെ ഗുണിതകങ്ങൾ ആയ 1 മുതൽ n വരെ ഉള്ള എല്ലാ സംഖ്യകളുടെയും മൊത്തം കണക്കാക്കാനുള്ള ഒരു ഫംഗ്ഷൻ എഴുതുക. ഒരു സംഖ്യ 3 നും 5 നും ഗുണിതകമാണെങ്കിൽ, അത് ഒരിക്കൽ മാത്രമേ എണ്ണിക്കൊള്ളൂ. \n\nഉദാഹരണത്തിന്:\n    >>> f_46(10)\n    33 // (3 + 5 + 6 + 9 + 10)", "fa": "با توجه به یک عدد صحیح n، تابعی بنویسید که مجموع تمام اعداد از 1 تا n که مضرب 3 یا 5 هستند را محاسبه کند. اگر عددی مضرب هر دو 3 و 5 باشد، باید فقط یک بار شمرده شود.\nبرای مثال:\n\n    >>> f_46(10)\n    33 // (3 + 5 + 6 + 9 + 10)"}}
{"task_id": "C/47", "prompt": {"en": "#include <assert.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDetermine if a given string is a palindrome. A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward (ignoring spaces, punctuation, and capitalization).\n    >>> f_47(\"racecar\")\n    true\n    >>> f_47(\"hello\")\n    false\n*/\nbool f_47(const char* str);", "sq": "#include <assert.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nPërcaktoni nëse një varg i dhënë është një palindrom. Një palindrom është një fjalë, frazë, numër, ose sekuencë tjetër karakteresh që lexohet njësoj përpara dhe prapa (duke injoruar hapësirat, shenjat e pikësimit dhe shkronjat e mëdha).\n    >>> f_47(\"racecar\")\n    true\n    >>> f_47(\"hello\")\n    false\n*/\nbool f_47(const char* str);", "hy": "#include <assert.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nՍահմանել, արդյոք տրված տողը պալինդրոմ է։ Պալինդրոմը բառ է, արտահայտություն, թիվ կամ այլ նիշերի հաջորդականություն, որը կարդացվում է նույն կերպ առաջ և հետ (անտեսելով բացատները, կետադրությունը և մեծատառերը):\n    >>> f_47(\"racecar\")\n    true\n    >>> f_47(\"hello\")\n    false\n*/\nbool f_47(const char* str);", "bn": "#include <assert.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nনির্ধারণ করুন একটি প্রদত্ত স্ট্রিং প্যালিনড্রোম কিনা। একটি প্যালিনড্রোম হল একটি শব্দ, বাক্যাংশ, সংখ্যা, বা অন্যান্য অক্ষরের ক্রম যা সামনের দিক থেকে এবং পিছনের দিক থেকে একইভাবে পড়া যায় (স্পেস, বিরামচিহ্ন, এবং বড় হাতের অক্ষর উপেক্ষা করে)।\n    >>> f_47(\"racecar\")\n    true\n    >>> f_47(\"hello\")\n    false\n*/\nbool f_47(const char* str);", "bg": "#include <assert.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nОпределете дали даден низ е палиндром. Палиндром е дума, фраза, число или друга последователност от символи, която се чете еднакво напред и назад (като се игнорират интервалите, пунктуацията и главните букви).\n    >>> f_47(\"racecar\")\n    true\n    >>> f_47(\"hello\")\n    false\n*/\nbool f_47(const char* str);", "zh": "#include <assert.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n确定给定的字符串是否是回文。回文是指正读和反读都相同的单词、短语、数字或其他字符序列（忽略空格、标点和大小写）。\n    >>> f_47(\"racecar\")\n    true\n    >>> f_47(\"hello\")\n    false\n*/\nbool f_47(const char* str);", "fr": "#include <assert.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDéterminer si une chaîne donnée est un palindrome. Un palindrome est un mot, une phrase, un nombre ou une autre séquence de caractères qui se lit de la même manière à l'endroit et à l'envers (en ignorant les espaces, la ponctuation et la capitalisation).\n    >>> f_47(\"racecar\")\n    true\n    >>> f_47(\"hello\")\n    false\n*/\nbool f_47(const char* str);", "de": "#include <assert.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nBestimmen, ob ein gegebener String ein Palindrom ist. Ein Palindrom ist ein Wort, ein Satz, eine Zahl oder eine andere Zeichenfolge, die vorwärts und rückwärts gleich gelesen wird (unter Ignorierung von Leerzeichen, Interpunktion und Groß-/Kleinschreibung).\n    >>> f_47(\"racecar\")\n    true\n    >>> f_47(\"hello\")\n    false\n*/\nbool f_47(const char* str);", "ha": "#include <assert.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nGano idan wani kirtani da aka bayar palindrome ne. Palindrome kalma ce, jimla, lamba, ko wata jerin haruffa da ake karantawa iri ɗaya gaba da baya (ba tare da la'akari da sarari, rubutu, da manyan ba).\n    >>> f_47(\"racecar\")\n    true\n    >>> f_47(\"hello\")\n    false\n*/\nbool f_47(const char* str);", "hi": "#include <assert.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nनिर्धारित करें कि कोई दिया गया स्ट्रिंग एक पालिंड्रोम है या नहीं। एक पालिंड्रोम एक शब्द, वाक्यांश, संख्या, या अन्य वर्णों का अनुक्रम है जो आगे और पीछे से समान पढ़ता है (स्पेस, विराम चिह्न, और कैपिटलाइज़ेशन को अनदेखा करते हुए)।\n    >>> f_47(\"racecar\")\n    true\n    >>> f_47(\"hello\")\n    false\n*/\nbool f_47(const char* str);", "hu": "#include <assert.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nHatározza meg, hogy egy adott sztring palindróm-e. A palindróm olyan szó, kifejezés, szám vagy más karakterlánc, amely előre és hátra olvasva is ugyanaz (figyelmen kívül hagyva a szóközöket, írásjeleket és a nagybetűket).\n    >>> f_47(\"racecar\")\n    true\n    >>> f_47(\"hello\")\n    false\n*/\nbool f_47(const char* str);", "es": "#include <assert.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDeterminar si una cadena dada es un palíndromo. Un palíndromo es una palabra, frase, número u otra secuencia de caracteres que se lee igual de adelante hacia atrás (ignorando espacios, puntuación y mayúsculas).\n    >>> f_47(\"racecar\")\n    true\n    >>> f_47(\"hello\")\n    false\n*/\nbool f_47(const char* str);", "arb": "#include <assert.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nتحديد ما إذا كانت سلسلة معينة هي كلمة متكاملة. الكلمة المتكاملة هي كلمة أو عبارة أو رقم أو تسلسل آخر من الأحرف التي تقرأ بنفس الطريقة للأمام والخلف (مع تجاهل المسافات وعلامات الترقيم والحروف الكبيرة).\n    >>> f_47(\"racecar\")\n    true\n    >>> f_47(\"hello\")\n    false\n*/\nbool f_47(const char* str);", "sw": "#include <assert.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nTambua kama mfuatano wa herufi uliotolewa ni palindrome. Palindrome ni neno, kifungu, nambari, au mfuatano mwingine wa herufi unaosomwa sawa mbele na nyuma (kupuuza nafasi, alama za uakifishaji, na herufi kubwa).\n    >>> f_47(\"racecar\")\n    true\n    >>> f_47(\"hello\")\n    false\n*/\nbool f_47(const char* str);", "tr": "#include <assert.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nVerilen bir dizgenin palindrom olup olmadığını belirleyin. Palindrom, ileri ve geri okunduğunda aynı olan (boşluklar, noktalama işaretleri ve büyük/küçük harf farkı göz ardı edilerek) bir kelime, ifade, sayı veya diğer karakter dizisidir.\n    >>> f_47(\"racecar\")\n    true\n    >>> f_47(\"hello\")\n    false\n*/\nbool f_47(const char* str);", "vi": "#include <assert.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nXác định xem một chuỗi cho trước có phải là palindrome hay không. Palindrome là một từ, cụm từ, số, hoặc chuỗi ký tự khác mà khi đọc xuôi hay ngược đều giống nhau (bỏ qua khoảng trắng, dấu câu và chữ hoa chữ thường).\n    >>> f_47(\"racecar\")\n    true\n    >>> f_47(\"hello\")\n    false\n*/\nbool f_47(const char* str);", "id": "#include <assert.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nMenentukan apakah string yang diberikan adalah palindrom. Palindrom adalah kata, frasa, angka, atau urutan karakter lain yang dibaca sama maju dan mundur (mengabaikan spasi, tanda baca, dan kapitalisasi).\n    >>> f_47(\"racecar\")\n    true\n    >>> f_47(\"hello\")\n    false\n*/\nbool f_47(const char* str);", "ja": "#include <assert.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n与えられた文字列が回文かどうかを判断します。回文とは、前から読んでも後ろから読んでも同じになる単語、フレーズ、数字、または他の文字列のことです（スペース、句読点、大文字小文字は無視します）。\n    >>> f_47(\"racecar\")\n    true\n    >>> f_47(\"hello\")\n    false\n*/\nbool f_47(const char* str);", "ko": "#include <assert.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n주어진 문자열이 회문인지 확인합니다. 회문은 앞뒤로 같은 방식으로 읽히는 단어, 구, 숫자 또는 다른 문자 시퀀스입니다 (공백, 구두점 및 대소문자는 무시합니다).\n    >>> f_47(\"racecar\")\n    true\n    >>> f_47(\"hello\")\n    false\n*/\nbool f_47(const char* str);", "ml": "#include <assert.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nഒരു നൽകിയ സ്ട്രിംഗ് പലിൻഡ്രോമാണോ എന്ന് നിർണയിക്കുക. ഒരു പലിൻഡ്രോം എന്നത് ഒരു വാക്ക്, വാചകം, സംഖ്യ, അല്ലെങ്കിൽ മറ്റ് പ്രതീകങ്ങളുടെ ക്രമമാണ്, അത് മുന്നോട്ടും പിന്നോട്ടും ഒരേപോലെ വായിക്കപ്പെടുന്നു (ഇടവേളകൾ, ചിഹ്നങ്ങൾ, തലക്കെട്ടുകൾ എന്നിവ അവഗണിക്കുന്നു).\n    >>> f_47(\"racecar\")\n    true\n    >>> f_47(\"hello\")\n    false\n*/\nbool f_47(const char* str);", "fa": "#include <assert.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nتعیین کنید که آیا یک رشته داده شده یک پالیندروم است یا خیر. پالیندروم کلمه، عبارت، عدد یا دنباله دیگری از کاراکترها است که از جلو و عقب به همان صورت خوانده می‌شود (با نادیده گرفتن فاصله‌ها، علائم نگارشی و حروف بزرگ و کوچک).\n    >>> f_47(\"racecar\")\n    true\n    >>> f_47(\"hello\")\n    false\n*/\nbool f_47(const char* str);"}, "canonical_solution": "bool f_47(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}", "instruction": {"en": "Write a C function `bool f_47(const char* str)` to solve the following problem:\nDetermine if a given string is a palindrome. A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward (ignoring spaces, punctuation, and capitalization).\n    >>> f_47(\"racecar\")\n    true\n    >>> f_47(\"hello\")\n    false\n", "sq": "Shkruani një funksion në C `bool f_47(const char* str)` për të zgjidhur problemin e mëposhtëm:\nPërcaktoni nëse një varg i dhënë është palindrom. Një palindrom është një fjalë, frazë, numër, ose sekuencë tjetër karakteresh që lexohet njësoj përpara dhe prapa (duke injoruar hapësirat, shenjat e pikësimit dhe shkronjat e mëdha).  \n    >>> f_47(\"racecar\")  \n    true  \n    >>> f_47(\"hello\")  \n    false  ", "hy": "Գրեք C ֆունկցիա `bool f_47(const char* str)` հետևյալ խնդիրը լուծելու համար:\nՈրոշեք՝ արդյոք տրված տողը պալինդրոմ է: Պալինդրոմը բառ, արտահայտություն, թիվ կամ այլ նիշերի հաջորդականություն է, որը կարդացվում է նույն կերպ առաջ և հետ (անտեսելով բացատները, կետադրությունը և մեծատառերը):\n    >>> f_47(\"racecar\")\n    true\n    >>> f_47(\"hello\")\n    false", "bn": "একটি C ফাংশন `bool f_47(const char* str)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nনির্ধারণ করুন একটি প্রদত্ত স্ট্রিং প্যালিনড্রোম কিনা। একটি প্যালিনড্রোম হল একটি শব্দ, বাক্যাংশ, সংখ্যা, বা অন্যান্য অক্ষরের ক্রম যা সামনের দিকে এবং পিছনের দিকে একইভাবে পড়ে (স্পেস, বিরামচিহ্ন, এবং বড় হাতের অক্ষর উপেক্ষা করে)।", "bg": "Напишете C функция `bool f_47(const char* str)` за решаване на следния проблем:\nОпределете дали даден низ е палиндром. Палиндром е дума, фраза, число или друга последователност от символи, която се чете еднакво напред и назад (като се игнорират интервали, пунктуация и главни букви).  \n    >>> f_47(\"racecar\")  \n    true  \n    >>> f_47(\"hello\")  \n    false  ", "zh": "编写一个 C 函数 `bool f_47(const char* str)` 来解决以下问题：\n确定给定的字符串是否是回文。回文是指正着读和反着读都相同的单词、短语、数字或其他字符序列（忽略空格、标点和大小写）。  \n    >>> f_47(\"racecar\")  \n    true  \n    >>> f_47(\"hello\")  \n    false  ", "fr": "Écrire une fonction C `bool f_47(const char* str)` pour résoudre le problème suivant:\nDéterminer si une chaîne donnée est un palindrome. Un palindrome est un mot, une phrase, un nombre ou une autre séquence de caractères qui se lit de la même manière à l'endroit et à l'envers (en ignorant les espaces, la ponctuation et la capitalisation).  \n    >>> f_47(\"racecar\")  \n    true  \n    >>> f_47(\"hello\")  \n    false  ", "de": "Schreiben Sie eine C-Funktion `bool f_47(const char* str)`, um das folgende Problem zu lösen:\nBestimmen Sie, ob ein gegebener String ein Palindrom ist. Ein Palindrom ist ein Wort, ein Satz, eine Zahl oder eine andere Zeichenfolge, die vorwärts und rückwärts gleich gelesen wird (unter Ignorierung von Leerzeichen, Satzzeichen und Groß-/Kleinschreibung).", "ha": "Rubuta aikin C `bool f_47(const char* str)` don warware matsalar mai zuwa:\nTantance idan wani kirtani da aka bayar palindrome ne. Palindrome kalma ce, jimla, lamba, ko wata jerin haruffa da ke karantawa iri ɗaya gaba da baya (ba tare da la'akari da sarari, rubutu, da manyan haruffa ba).", "hi": "C फ़ंक्शन `bool f_47(const char* str)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nयह निर्धारित करें कि दिया गया स्ट्रिंग एक पालिंड्रोम है या नहीं। एक पालिंड्रोम एक शब्द, वाक्यांश, संख्या, या अन्य वर्णों का अनुक्रम है जो आगे और पीछे से समान रूप से पढ़ा जाता है (स्पेस, विराम चिह्न, और कैपिटलाइज़ेशन को अनदेखा करते हुए)।  \n    >>> f_47(\"racecar\")  \n    true  \n    >>> f_47(\"hello\")  \n    false  ", "hu": "Írj egy C függvényt `bool f_47(const char* str)` a következő probléma megoldására:\nHatározd meg, hogy egy adott string palindróm-e. Egy palindróm olyan szó, kifejezés, szám vagy más karakterlánc, amely előre és visszafelé olvasva is ugyanaz (figyelmen kívül hagyva a szóközöket, írásjeleket és a nagybetűket).  \n    >>> f_47(\"racecar\")  \n    true  \n    >>> f_47(\"hello\")  \n    false  ", "es": "Escribe una función en C `bool f_47(const char* str)` para resolver el siguiente problema:\nDeterminar si una cadena dada es un palíndromo. Un palíndromo es una palabra, frase, número u otra secuencia de caracteres que se lee igual de adelante hacia atrás (ignorando espacios, puntuación y mayúsculas).\n    >>> f_47(\"racecar\")\n    true\n    >>> f_47(\"hello\")\n    false", "arb": "اكتب دالة بلغة C `bool f_47(const char* str)` لحل المشكلة التالية:\nتحديد ما إذا كانت سلسلة معينة هي كلمة متطابقة. الكلمة المتطابقة هي كلمة، عبارة، رقم، أو تسلسل آخر من الأحرف الذي يقرأ بنفس الطريقة من الأمام إلى الخلف (مع تجاهل المسافات، وعلامات الترقيم، والحروف الكبيرة والصغيرة).\n    >>> f_47(\"racecar\")\n    true\n    >>> f_47(\"hello\")\n    false", "sw": "Andika kazi ya C `bool f_47(const char* str)` kutatua tatizo lifuatalo:\nTambua kama kamba iliyotolewa ni palindrome. Palindrome ni neno, kifungu, nambari, au mlolongo mwingine wa herufi ambao unasomwa sawa mbele na nyuma (kupuuza nafasi, alama za uakifishaji, na herufi kubwa na ndogo).  \n    >>> f_47(\"racecar\")  \n    true  \n    >>> f_47(\"hello\")  \n    false  ", "tr": "Bir C fonksiyonu `bool f_47(const char* str)` yazın ve aşağıdaki problemi çözün:\nVerilen bir dizgenin palindrom olup olmadığını belirleyin. Palindrom, ileri ve geri okunduğunda aynı olan (boşluklar, noktalama işaretleri ve büyük/küçük harf farkı göz ardı edilerek) bir kelime, ifade, sayı veya diğer karakter dizisidir.\n    >>> f_47(\"racecar\")\n    true\n    >>> f_47(\"hello\")\n    false", "vi": "Viết một hàm C `bool f_47(const char* str)` để giải quyết vấn đề sau:\nXác định xem một chuỗi cho trước có phải là palindrome hay không. Một palindrome là một từ, cụm từ, số, hoặc chuỗi ký tự khác mà đọc xuôi hay ngược đều giống nhau (bỏ qua khoảng trắng, dấu câu, và phân biệt chữ hoa chữ thường).  \n    >>> f_47(\"racecar\")  \n    true  \n    >>> f_47(\"hello\")  \n    false  ", "id": "Tulis sebuah fungsi C `bool f_47(const char* str)` untuk menyelesaikan masalah berikut:\nTentukan apakah string yang diberikan adalah palindrom. Palindrom adalah kata, frasa, angka, atau urutan karakter lain yang dibaca sama maju dan mundur (mengabaikan spasi, tanda baca, dan kapitalisasi).\n    >>> f_47(\"racecar\")\n    true\n    >>> f_47(\"hello\")\n    false", "ja": "Cの関数を書け `bool f_47(const char* str)` を作成して、次の問題を解決してください:\n与えられた文字列が回文かどうかを判定します。回文とは、前から読んでも後ろから読んでも同じになる単語、フレーズ、数字、またはその他の文字列のことです（スペース、句読点、大文字と小文字は無視します）。\n    >>> f_47(\"racecar\")\n    true\n    >>> f_47(\"hello\")\n    false", "ko": "C 함수 `bool f_47(const char* str)`를 작성하여 다음 문제를 해결하십시오:\n주어진 문자열이 회문인지 확인하십시오. 회문은 앞뒤로 읽어도 동일한 단어, 구, 숫자 또는 기타 문자 시퀀스입니다 (공백, 구두점 및 대소문자를 무시).  \n    >>> f_47(\"racecar\")  \n    true  \n    >>> f_47(\"hello\")  \n    false  ", "ml": "C ഫംഗ്ഷൻ `bool f_47(const char* str)` എഴുതുക താഴെ കൊടുത്തിരിക്കുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nഒരു നൽകിയിരിക്കുന്ന സ്ട്രിംഗ് പലിൻഡ്രോമാണോ എന്ന് നിർണയിക്കുക. ഒരു പലിൻഡ്രോം എന്നത് ഒരു വാക്ക്, വാചകം, സംഖ്യ, അല്ലെങ്കിൽ മറ്റ് പ്രതീകങ്ങളുടെ ക്രമമാണ്, അത് മുന്നോട്ടും പിന്നോട്ടും ഒരുപോലെ വായിക്കപ്പെടുന്നു (വ്യത്യാസങ്ങൾ, ചിഹ്നങ്ങൾ, തലക്കെട്ടുകൾ എന്നിവ അവഗണിക്കുന്നു).\n    >>> f_47(\"racecar\")\n    true\n    >>> f_47(\"hello\")\n    false", "fa": "یک تابع C به نام `bool f_47(const char* str)` بنویسید تا مسئله زیر را حل کند:\nتعیین کنید که آیا یک رشته داده شده یک پالیندروم است یا خیر. پالیندروم کلمه، عبارت، عدد یا دنباله دیگری از کاراکترها است که از جلو و عقب به همان صورت خوانده می‌شود (با نادیده گرفتن فاصله‌ها، علائم نگارشی و حروف بزرگ و کوچک).\n    >>> f_47(\"racecar\")\n    true\n    >>> f_47(\"hello\")\n    false"}, "level": "middle", "test": "int main()\n{\n    assert(f_47(\"A man a plan a canal Panama\") == true);\n    assert(f_47(\"No lemon, no melon\") == true);\n    assert(f_47(\"Was it a car or a cat I saw\") == true);\n    assert(f_47(\"Madam, in Eden, I'm Adam\") == true);\n    assert(f_47(\"Never odd or even\") == true);\n    assert(f_47(\"Eva, can I see bees in a cave\") == true);\n    assert(f_47(\"hello\") == false);\n    assert(f_47(\"GitHub\") == false);\n    assert(f_47(\"programming\") == false);\n    \n    return 0;\n}", "entry_point": "f_47", "signature": "bool f_47(const char* str)", "docstring": {"en": "Determine if a given string is a palindrome. A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward (ignoring spaces, punctuation, and capitalization).\n    >>> f_47(\"racecar\")\n    true\n    >>> f_47(\"hello\")\n    false\n", "sq": "Përcaktoni nëse një varg i dhënë është një palindrom. Një palindrom është një fjalë, frazë, numër, ose një sekuencë tjetër karakteresh që lexohet njësoj përpara dhe prapa (duke injoruar hapësirat, shenjat e pikësimit dhe shkronjat e mëdha).\n    >>> f_47(\"racecar\")\n    true\n    >>> f_47(\"hello\")\n    false", "hy": "Սահմանել՝ արդյոք տրված տողը պալինդրոմ է: Պալինդրոմը բառ է, արտահայտություն, թիվ կամ այլ նիշերի հաջորդականություն, որը կարդացվում է նույն կերպ առաջ և հետ (անտեսելով բացատները, կետադրությունը և մեծատառերը):\n    >>> f_47(\"racecar\")\n    true\n    >>> f_47(\"hello\")\n    false", "bn": "একটি প্রদত্ত স্ট্রিং প্যালিনড্রোম কিনা তা নির্ধারণ করুন। একটি প্যালিনড্রোম হল একটি শব্দ, বাক্যাংশ, সংখ্যা, বা অন্যান্য অক্ষরের ক্রম যা সামনে এবং পিছনে একইভাবে পড়ে (স্পেস, বিরামচিহ্ন এবং বড় হাতের অক্ষর উপেক্ষা করে)।\n    >>> f_47(\"racecar\")\n    true\n    >>> f_47(\"hello\")\n    false", "bg": "Определете дали даден низ е палиндром. Палиндром е дума, фраза, число или друга последователност от символи, която се чете еднакво напред и назад (като се игнорират интервали, пунктуация и главни букви).\n    >>> f_47(\"racecar\")\n    true\n    >>> f_47(\"hello\")\n    false", "zh": "确定给定的字符串是否是回文。回文是指无论正向还是反向读取都相同的单词、短语、数字或其他字符序列（忽略空格、标点和大小写）。\n    >>> f_47(\"racecar\")\n    true\n    >>> f_47(\"hello\")\n    false", "fr": "Déterminer si une chaîne donnée est un palindrome. Un palindrome est un mot, une phrase, un nombre ou une autre séquence de caractères qui se lit de la même manière de l'avant vers l'arrière et de l'arrière vers l'avant (en ignorant les espaces, la ponctuation et la capitalisation).\n    >>> f_47(\"racecar\")\n    true\n    >>> f_47(\"hello\")\n    false", "de": "Bestimmen Sie, ob ein gegebener String ein Palindrom ist. Ein Palindrom ist ein Wort, ein Satz, eine Zahl oder eine andere Zeichenfolge, die vorwärts und rückwärts gleich gelesen wird (unter Ignorierung von Leerzeichen, Interpunktion und Groß-/Kleinschreibung).\n    >>> f_47(\"racecar\")\n    true\n    >>> f_47(\"hello\")\n    false", "ha": "Kayyade idan wani kirtani da aka bayar palindrome ne. Palindrome kalma ce, jimla, lamba, ko wata jerin haruffa da ake karantawa iri ɗaya gaba da baya (ba tare da la'akari da sarari, rubutun alama, da babba ko ƙaramin ba).\n\n    >>> f_47(\"racecar\")\n    true\n    >>> f_47(\"hello\")\n    false", "hi": "दिया गया स्ट्रिंग एक पालिंड्रोम है या नहीं, यह निर्धारित करें। एक पालिंड्रोम एक शब्द, वाक्यांश, संख्या, या अन्य वर्णों का अनुक्रम है जो आगे और पीछे से एक जैसा पढ़ा जाता है (स्पेस, विराम चिह्न, और बड़े अक्षरों को नजरअंदाज करते हुए)।\n    >>> f_47(\"racecar\")\n    true\n    >>> f_47(\"hello\")\n    false", "hu": "Határozza meg, hogy egy adott sztring palindróm-e. A palindróm olyan szó, kifejezés, szám vagy más karakterlánc, amely előre és hátra olvasva is ugyanaz (figyelmen kívül hagyva a szóközöket, írásjeleket és a nagybetűket).\n    >>> f_47(\"racecar\")\n    true\n    >>> f_47(\"hello\")\n    false", "es": "Determinar si una cadena dada es un palíndromo. Un palíndromo es una palabra, frase, número u otra secuencia de caracteres que se lee igual de adelante hacia atrás (ignorando espacios, puntuación y mayúsculas).\n    >>> f_47(\"racecar\")\n    true\n    >>> f_47(\"hello\")\n    false", "arb": "تحديد ما إذا كانت سلسلة معينة هي كلمة متطابقة عند قراءتها من الأمام والخلف. الكلمة المتطابقة هي كلمة، عبارة، رقم، أو تسلسل آخر من الأحرف التي تُقرأ بنفس الطريقة من الأمام والخلف (مع تجاهل المسافات، وعلامات الترقيم، والحروف الكبيرة والصغيرة).\n    >>> f_47(\"racecar\")\n    true\n    >>> f_47(\"hello\")\n    false", "sw": "Amua kama string iliyotolewa ni palindrome. Palindrome ni neno, kifungu, nambari, au mlolongo mwingine wa herufi ambao unasomeka sawa mbele na nyuma (ukipuuza nafasi, alama za uakifishaji, na herufi kubwa na ndogo).\n    >>> f_47(\"racecar\")\n    true\n    >>> f_47(\"hello\")\n    false", "tr": "Verilen bir stringin palindrom olup olmadığını belirleyin. Palindrom, ileri ve geri okunduğunda aynı olan (boşluklar, noktalama işaretleri ve büyük/küçük harf farkı göz ardı edilerek) bir kelime, ifade, sayı veya diğer karakter dizisidir.\n    >>> f_47(\"racecar\")\n    true\n    >>> f_47(\"hello\")\n    false", "vi": "Xác định xem một chuỗi cho trước có phải là một chuỗi palindrome hay không. Một chuỗi palindrome là một từ, cụm từ, số, hoặc một chuỗi ký tự khác mà khi đọc từ trái sang phải và từ phải sang trái đều giống nhau (bỏ qua khoảng trắng, dấu câu và chữ hoa chữ thường).\n    >>> f_47(\"racecar\")\n    true\n    >>> f_47(\"hello\")\n    false", "id": "Menentukan apakah sebuah string adalah palindrom. Palindrom adalah kata, frasa, angka, atau urutan karakter lain yang dibaca sama dari depan ke belakang (mengabaikan spasi, tanda baca, dan kapitalisasi).\n    >>> f_47(\"racecar\")\n    true\n    >>> f_47(\"hello\")\n    false", "ja": "与えられた文字列が回文かどうかを判断します。回文とは、前から読んでも後ろから読んでも同じになる単語、フレーズ、数字、またはその他の文字列のことです（スペース、句読点、大文字小文字を無視します）。\n    >>> f_47(\"racecar\")\n    true\n    >>> f_47(\"hello\")\n    false", "ko": "주어진 문자열이 회문인지 확인합니다. 회문은 앞뒤로 읽어도 동일한 단어, 구, 숫자 또는 기타 문자 시퀀스를 말합니다 (공백, 구두점 및 대소문자는 무시합니다).\n    >>> f_47(\"racecar\")\n    true\n    >>> f_47(\"hello\")\n    false", "ml": "ഒരു നൽകിയ സ്റ്റ്രിംഗ് പലിൻഡ്രോം ആണോ എന്ന് നിർണയിക്കുക. പലിൻഡ്രോം എന്നത് ഒരു വാക്ക്, വാചകം, സംഖ്യ, അല്ലെങ്കിൽ മറ്റേതെങ്കിലും അക്ഷരങ്ങളുടെ നിരയാണ്, അത് മുന്നോട്ടും പിന്നോട്ടും ഒരേപോലെ വായിക്കപ്പെടുന്നു (സ്പേസുകൾ, ചിഹ്നങ്ങൾ, ക്യാപിറ്റലൈസേഷൻ എന്നിവ അവഗണിക്കുന്നു).\n    >>> f_47(\"racecar\")\n    true\n    >>> f_47(\"hello\")\n    false", "fa": " یک کلمه‌ی palindrome کلمه، عبارت، عدد یا دنباله‌ای از کاراکترها است که از جلو به عقب و از عقب به جلو به یک شکل خوانده می‌شود (با نادیده گرفتن فاصله‌ها، علائم نگارشی و حروف بزرگ و کوچک).\n    >>> f_47(\"racecar\")\n    true\n    >>> f_47(\"hello\")\n    false"}}
{"task_id": "C/48", "prompt": {"en": "#include <assert.h>\n#include <stdio.h>\n/*\nGiven a non-negative integer num, repeatedly add all its digits until the result has only one digit.\nFor example:\n    >>> f_48(38)\n    2\n    Because 3 + 8 = 11, and 1 + 1 = 2. Since 2 has only one digit, 2 is the result.\n*/\nint f_48(int num)", "sq": "#include <assert.h>\n#include <stdio.h>\n/*\nDuke pasur një numër të plotë jo-negativ num, shtoni përsëri të gjitha shifrat e tij derisa rezultati të ketë vetëm një shifër.\nPër shembull:\n    >>> f_48(38)\n    2\n    Sepse 3 + 8 = 11, dhe 1 + 1 = 2. Meqenëse 2 ka vetëm një shifër, 2 është rezultati.\n*/\nint f_48(int num)", "hy": "#include <assert.h>\n#include <stdio.h>\n/*\nՏրված է ոչ բացասական ամբողջ թիվ num, բազմիցս գումարեք նրա բոլոր թվանշանները, մինչև արդյունքը կունենա միայն մեկ թվանշան:\nՕրինակ:\n    >>> f_48(38)\n    2\n    Քանի որ 3 + 8 = 11, և 1 + 1 = 2: Քանի որ 2-ն ունի միայն մեկ թվանշան, 2-ը արդյունքն է:\n*/\nint f_48(int num)", "bn": "#include <assert.h>\n#include <stdio.h>\n/*\nএকটি অ-ঋণাত্মক পূর্ণসংখ্যা num দেওয়া আছে, এর সমস্ত অঙ্ক বারবার যোগ করুন যতক্ষণ না ফলাফলে শুধুমাত্র একটি অঙ্ক থাকে।\nউদাহরণস্বরূপ:\n    >>> f_48(38)\n    2\n    কারণ 3 + 8 = 11, এবং 1 + 1 = 2। যেহেতু 2-এ শুধুমাত্র একটি অঙ্ক আছে, 2 হল ফলাফল।\n*/\nint f_48(int num)", "bg": "#include <assert.h>\n#include <stdio.h>\n/*\nДадено е неотрицателно цяло число num, многократно събирайте всичките му цифри, докато резултатът има само една цифра.\nНапример:\n    >>> f_48(38)\n    2\n    Защото 3 + 8 = 11, и 1 + 1 = 2. Тъй като 2 има само една цифра, 2 е резултатът.\n*/\nint f_48(int num)", "zh": "#include <assert.h>\n#include <stdio.h>\n/*\n给定一个非负整数 num，反复将所有位上的数字相加，直到结果只有一位数字。\n例如：\n    >>> f_48(38)\n    2\n    因为 3 + 8 = 11，且 1 + 1 = 2。由于 2 只有一位数字，所以结果是 2。\n*/\nint f_48(int num)", "fr": "#include <assert.h>\n#include <stdio.h>\n/*\nÉtant donné un entier non négatif num, ajoutez de manière répétée tous ses chiffres jusqu'à ce que le résultat n'ait qu'un seul chiffre.\nPar exemple :\n    >>> f_48(38)\n    2\n    Parce que 3 + 8 = 11, et 1 + 1 = 2. Puisque 2 n'a qu'un seul chiffre, 2 est le résultat.\n*/\nint f_48(int num)", "de": "#include <assert.h>\n#include <stdio.h>\n/*\nGegeben eine nicht-negative ganze Zahl num, addiere wiederholt alle ihre Ziffern, bis das Ergebnis nur noch eine Ziffer hat.\nZum Beispiel:\n    >>> f_48(38)\n    2\n    Weil 3 + 8 = 11, und 1 + 1 = 2. Da 2 nur eine Ziffer hat, ist 2 das Ergebnis.\n*/\nint f_48(int num)", "ha": "#include <assert.h>\n#include <stdio.h>\n/*\nAn ba da lamba mai kyau num, a ci gaba da ƙara duk lambobinsa har sai sakamakon yana da lamba ɗaya kawai.\nMisali:\n    >>> f_48(38)\n    2\n    Domin 3 + 8 = 11, kuma 1 + 1 = 2. Tun da 2 yana da lamba ɗaya kawai, 2 shine sakamakon.\n*/\nint f_48(int num)", "hi": "#include <assert.h>\n#include <stdio.h>\n/*\nदिए गए एक गैर-ऋणात्मक पूर्णांक num के लिए, इसके सभी अंकों को तब तक जोड़ते रहें जब तक परिणाम में केवल एक अंक न रह जाए।\nउदाहरण के लिए:\n    >>> f_48(38)\n    2\n    क्योंकि 3 + 8 = 11, और 1 + 1 = 2। चूंकि 2 में केवल एक अंक है, 2 परिणाम है।\n*/\nint f_48(int num)", "hu": "#include <assert.h>\n#include <stdio.h>\n/*\nAdott egy nem negatív egész szám, ismételten add össze az összes számjegyét, amíg az eredmény csak egy számjegyből áll.\nPéldául:\n    >>> f_48(38)\n    2\n    Mert 3 + 8 = 11, és 1 + 1 = 2. Mivel a 2 csak egy számjegyből áll, 2 az eredmény.\n*/\nint f_48(int num)", "es": "#include <assert.h>\n#include <stdio.h>\n/*\nDado un número entero no negativo num, suma repetidamente todos sus dígitos hasta que el resultado tenga solo un dígito.\nPor ejemplo:\n    >>> f_48(38)\n    2\n    Porque 3 + 8 = 11, y 1 + 1 = 2. Dado que 2 tiene solo un dígito, 2 es el resultado.\n*/\nint f_48(int num)", "arb": "#include <assert.h>\n#include <stdio.h>\n/*\nمعطى عدد صحيح غير سالب num، اجمع جميع أرقامه بشكل متكرر حتى يكون الناتج رقمًا واحدًا فقط.\nعلى سبيل المثال:\n    >>> f_48(38)\n    2\n    لأن 3 + 8 = 11، و 1 + 1 = 2. ولأن 2 هو رقم واحد فقط، فإن 2 هو الناتج.\n*/\nint f_48(int num)", "sw": "#include <assert.h>\n#include <stdio.h>\n/*\nUkipiwa nambari isiyo hasi num, ongeza tarakimu zake zote mara kwa mara hadi matokeo yawe na tarakimu moja tu.\nKwa mfano:\n    >>> f_48(38)\n    2\n    Kwa sababu 3 + 8 = 11, na 1 + 1 = 2. Kwa kuwa 2 ina tarakimu moja tu, 2 ndiyo matokeo.\n*/\nint f_48(int num)", "tr": "#include <assert.h>\n#include <stdio.h>\n/*\nVerilen negatif olmayan bir tamsayı num için, sonucu tek bir basamak olana kadar tüm basamaklarını tekrar tekrar toplayın.\nÖrneğin:\n    >>> f_48(38)\n    2\n    Çünkü 3 + 8 = 11 ve 1 + 1 = 2. 2 yalnızca bir basamağa sahip olduğundan, sonuç 2'dir.\n*/\nint f_48(int num)", "vi": "#include <assert.h>\n#include <stdio.h>\n/*\nCho một số nguyên không âm num, liên tục cộng tất cả các chữ số của nó cho đến khi kết quả chỉ còn một chữ số.\nVí dụ:\n    >>> f_48(38)\n    2\n    Bởi vì 3 + 8 = 11, và 1 + 1 = 2. Vì 2 chỉ có một chữ số, 2 là kết quả.\n*/\nint f_48(int num)", "id": "#include <assert.h>\n#include <stdio.h>\n/*\nDiberikan bilangan bulat non-negatif num, tambahkan semua digitnya berulang kali hingga hasilnya hanya memiliki satu digit.\nSebagai contoh:\n    >>> f_48(38)\n    2\n    Karena 3 + 8 = 11, dan 1 + 1 = 2. Karena 2 hanya memiliki satu digit, 2 adalah hasilnya.\n*/\nint f_48(int num)", "ja": "#include <assert.h>\n#include <stdio.h>\n/*\n非負整数 num が与えられたとき、その桁をすべて繰り返し加算して、結果が一桁になるまで続けます。\n例えば:\n    >>> f_48(38)\n    2\n    なぜなら 3 + 8 = 11 で、1 + 1 = 2 だからです。2 は一桁なので、2 が結果です。\n*/\nint f_48(int num)", "ko": "#include <assert.h>\n#include <stdio.h>\n/*\n비음수가 아닌 정수 num이 주어졌을 때, 그 숫자의 모든 자릿수를 반복적으로 더하여 결과가 한 자리 숫자가 될 때까지 계속합니다.\n예를 들어:\n    >>> f_48(38)\n    2\n    3 + 8 = 11이고, 1 + 1 = 2입니다. 2는 한 자리 숫자이므로, 2가 결과입니다.\n*/\nint f_48(int num)", "ml": "#include <assert.h>\n#include <stdio.h>\n/*\nഒരു നെഗറ്റീവ് അല്ലാത്ത പൂർണ്ണസംഖ്യ നൽകിയാൽ, ഫലം ഒരു അക്കമായിരിക്കുമ്പോൾ വരെ അതിന്റെ എല്ലാ അക്കങ്ങളും ആവർത്തിച്ച് ചേർക്കുക.\nഉദാഹരണത്തിന്:\n    >>> f_48(38)\n    2\n    കാരണം 3 + 8 = 11, 1 + 1 = 2. 2 ഒരു അക്കമാത്രം ഉള്ളതിനാൽ, 2 ആണ് ഫലം.\n*/\nint f_48(int num)", "fa": "#include <assert.h>\n#include <stdio.h>\n/*\nعدد صحیح غیرمنفی داده شده را بگیرید و به طور مکرر تمام ارقام آن را جمع کنید تا زمانی که نتیجه فقط یک رقم داشته باشد.\nبرای مثال:\n    >>> f_48(38)\n    2\n    زیرا 3 + 8 = 11، و 1 + 1 = 2. از آنجا که 2 فقط یک رقم دارد، 2 نتیجه است.\n*/\nint f_48(int num)"}, "canonical_solution": "{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}", "instruction": {"en": "Write a C function `int f_48(int num)` to solve the following problem:\nGiven a non-negative integer num, repeatedly add all its digits until the result has only one digit.\nFor example:\n    >>> f_48(38)\n    2\n    Because 3 + 8 = 11, and 1 + 1 = 2. Since 2 has only one digit, 2 is the result.", "sq": "Shkruani një funksion në C `int f_48(int num)` për të zgjidhur problemin e mëposhtëm:\nDuke pasur një numër të plotë jo-negativ num, shtoni përsëri të gjitha shifrat e tij derisa rezultati të ketë vetëm një shifër.\nPër shembull:\n    >>> f_48(38)\n    2\n    Sepse 3 + 8 = 11, dhe 1 + 1 = 2. Meqenëse 2 ka vetëm një shifër, 2 është rezultati.", "hy": "Գրեք C ֆունկցիա `int f_48(int num)`՝ հետևյալ խնդիրը լուծելու համար:\nՏրված է ոչ բացասական ամբողջ թիվ num, կրկնվող կերպով գումարեք նրա բոլոր թվանշանները, մինչև արդյունքը կունենա միայն մեկ թվանշան:\nՕրինակ:\n    >>> f_48(38)\n    2\n    Քանի որ 3 + 8 = 11, և 1 + 1 = 2: Քանի որ 2-ը ունի միայն մեկ թվանշան, 2-ը արդյունքն է:", "bn": "একটি C ফাংশন `int f_48(int num)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি অ-ঋণাত্মক পূর্ণসংখ্যা num দেওয়া হলে, তার সমস্ত অঙ্ক বারবার যোগ করুন যতক্ষণ না ফলাফলে শুধুমাত্র একটি অঙ্ক থাকে।\nউদাহরণস্বরূপ:\n    >>> f_48(38)\n    2\n    কারণ 3 + 8 = 11, এবং 1 + 1 = 2। যেহেতু 2-এ শুধুমাত্র একটি অঙ্ক রয়েছে, তাই 2 হল ফলাফল।", "bg": "Напишете C функция `int f_48(int num)`, за да решите следния проблем:\nДадено е неотрицателно цяло число num, повтаряйте събирането на всичките му цифри, докато резултатът не стане едноцифрено число.  \nНапример:  \n    >>> f_48(38)  \n    2  \n    Защото 3 + 8 = 11, и 1 + 1 = 2. Тъй като 2 е едноцифрено число, 2 е резултатът.", "zh": "编写一个 C 函数 `int f_48(int num)` 来解决以下问题：\n给定一个非负整数 num，重复将所有位上的数字相加，直到结果只有一位数字。  \n例如：  \n    >>> f_48(38)  \n    2  \n    因为 3 + 8 = 11，并且 1 + 1 = 2。由于 2 只有一位数字，2 是结果。", "fr": "Écrire une fonction C `int f_48(int num)` pour résoudre le problème suivant :\nÉtant donné un entier non négatif num, ajoutez de manière répétée tous ses chiffres jusqu'à ce que le résultat n'ait qu'un seul chiffre.\nPar exemple :\n    >>> f_48(38)\n    2\n    Parce que 3 + 8 = 11, et 1 + 1 = 2. Comme 2 n'a qu'un seul chiffre, 2 est le résultat.", "de": "Schreiben Sie eine C-Funktion `int f_48(int num)`, um das folgende Problem zu lösen:\nGegeben ist eine nicht-negative ganze Zahl num, addieren Sie wiederholt alle ihre Ziffern, bis das Ergebnis nur noch eine Ziffer hat.  \nZum Beispiel:  \n    >>> f_48(38)  \n    2  \n    Weil 3 + 8 = 11 und 1 + 1 = 2. Da 2 nur eine Ziffer hat, ist 2 das Ergebnis.  ", "ha": "Rubuta aikin C `int f_48(int num)` don warware matsalar mai zuwa:\nAn ba da lamba mai kyau wadda ba ta da alamar ƙari num, a ci gaba da ƙara duk lambobinta har sai sakamakon yana da lamba guda ɗaya kawai.\nAlal misali:\n    >>> f_48(38)\n    2\n    Saboda 3 + 8 = 11, kuma 1 + 1 = 2. Tun da 2 yana da lamba guda ɗaya kawai, 2 shine sakamakon.", "hi": "एक C फ़ंक्शन `int f_48(int num)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए एक गैर-ऋणात्मक पूर्णांक num के लिए, इसकी सभी अंकों को बार-बार जोड़ें जब तक कि परिणाम केवल एक अंक का न हो जाए।\nउदाहरण के लिए:\n    >>> f_48(38)\n    2\n    क्योंकि 3 + 8 = 11, और 1 + 1 = 2। चूंकि 2 में केवल एक अंक है, 2 परिणाम है।", "hu": "Írj egy C függvényt `int f_48(int num)` a következő probléma megoldására:\nAdott egy nem negatív egész szám num, add össze ismételten az összes számjegyét, amíg az eredmény csak egy számjegyből áll.  \nPéldául:  \n    >>> f_48(38)  \n    2  \n    Mert 3 + 8 = 11, és 1 + 1 = 2. Mivel a 2 csak egy számjegyből áll, 2 az eredmény.", "es": "Escriba una función en C `int f_48(int num)` para resolver el siguiente problema:\nDado un número entero no negativo num, sume repetidamente todos sus dígitos hasta que el resultado tenga solo un dígito.\nPor ejemplo:\n    >>> f_48(38)\n    2\n    Porque 3 + 8 = 11, y 1 + 1 = 2. Dado que 2 tiene solo un dígito, 2 es el resultado.", "arb": "اكتب دالة بلغة C `int f_48(int num)` لحل المشكلة التالية:\nمعطى عدد صحيح غير سالب num، اجمع جميع أرقامه بشكل متكرر حتى يكون الناتج رقمًا واحدًا فقط.\nعلى سبيل المثال:\n    >>> f_48(38)\n    2\n    لأن 3 + 8 = 11، و 1 + 1 = 2. بما أن 2 يحتوي على رقم واحد فقط، فإن 2 هو الناتج.", "sw": "Andika kazi ya C `int f_48(int num)` kutatua tatizo lifuatalo:\nUkipiwa nambari isiyo hasi num, ongeza mara kwa mara tarakimu zake zote hadi matokeo yawe na tarakimu moja tu.  \nKwa mfano:  \n    >>> f_48(38)  \n    2  \n    Kwa sababu 3 + 8 = 11, na 1 + 1 = 2. Kwa kuwa 2 ina tarakimu moja tu, 2 ndiyo matokeo.", "tr": "Bir C fonksiyonu `int f_48(int num)` yazın ve aşağıdaki problemi çözün:\nVerilen bir negatif olmayan tam sayı num, sonucu tek basamaklı olana kadar tüm basamaklarını tekrar tekrar toplayın.\nÖrneğin:\n    >>> f_48(38)\n    2\n    Çünkü 3 + 8 = 11 ve 1 + 1 = 2. 2 tek basamaklı olduğundan, sonuç 2'dir.", "vi": "Viết một hàm C `int f_48(int num)` để giải quyết vấn đề sau:\nCho một số nguyên không âm num, liên tục cộng tất cả các chữ số của nó cho đến khi kết quả chỉ còn một chữ số.  \nVí dụ:  \n    >>> f_48(38)  \n    2  \n    Bởi vì 3 + 8 = 11, và 1 + 1 = 2. Vì 2 chỉ có một chữ số, 2 là kết quả.", "id": "Tulis sebuah fungsi C `int f_48(int num)` untuk menyelesaikan masalah berikut:\nDiberikan sebuah bilangan bulat non-negatif num, tambahkan semua digitnya berulang kali hingga hasilnya hanya memiliki satu digit.  \nSebagai contoh:  \n    >>> f_48(38)  \n    2  \n    Karena 3 + 8 = 11, dan 1 + 1 = 2. Karena 2 hanya memiliki satu digit, 2 adalah hasilnya.", "ja": "Cの関数を書け `int f_48(int num)` を作成して、次の問題を解決してください:\n非負整数 num が与えられたとき、その桁をすべて加算し、結果が一桁になるまで繰り返します。  \n例えば:  \n    >>> f_48(38)  \n    2  \n    なぜなら、3 + 8 = 11 で、1 + 1 = 2 だからです。2 は一桁なので、2 が結果です。", "ko": "C 함수 `int f_48(int num)`를 작성하여 다음 문제를 해결하십시오:\n음이 아닌 정수 num이 주어지면, 결과가 한 자리 숫자가 될 때까지 모든 자릿수를 반복적으로 더하십시오.  \n예를 들어:  \n    >>> f_48(38)  \n    2  \n    왜냐하면 3 + 8 = 11이고, 1 + 1 = 2이기 때문입니다. 2는 한 자리 숫자이므로, 2가 결과입니다.", "ml": "C ഫംഗ്ഷൻ `int f_48(int num)` എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nഒരു നെഗറ്റീവ് അല്ലാത്ത പൂർണ്ണസംഖ്യ num നൽകിയാൽ, ഫലത്തിൽ ഒരു അക്കമാത്രം ശേഷിക്കുന്നതുവരെ അതിന്റെ എല്ലാ അക്കങ്ങളും ആവർത്തിച്ച് കൂട്ടുക.\nഉദാഹരണത്തിന്:\n    >>> f_48(38)\n    2\n    കാരണം 3 + 8 = 11, 1 + 1 = 2. 2-ന് ഒരു അക്കമാത്രം ഉള്ളതിനാൽ, 2 ഫലമാണ്.", "fa": "یک تابع C به نام `int f_48(int num)` بنویسید تا مسئله زیر را حل کند:\nیک عدد صحیح غیرمنفی داده شده است، به طور مکرر تمام ارقام آن را جمع کنید تا نتیجه تنها یک رقم داشته باشد.\nبرای مثال:\n    >>> f_48(38)\n    2\n    زیرا 3 + 8 = 11، و 1 + 1 = 2. از آنجا که 2 تنها یک رقم دارد، 2 نتیجه است."}, "level": "easy", "test": "int main() {\n    assert(f_48(38) == 2);\n    assert(f_48(0) == 0);\n    assert(f_48(9) == 9);\n    assert(f_48(123) == 6);\n    assert(f_48(456) == 6);\n    assert(f_48(9999) == 9);\n    assert(f_48(100) == 1);\n    assert(f_48(1010) == 2);\n    assert(f_48(1234) == 1);\n    assert(f_48(9876) == 3);\n    assert(f_48(199) == 1);\n    return 0;\n}", "entry_point": "f_48", "signature": "int f_48(int num)", "docstring": {"en": "Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.\nFor example:\n    >>> f_48(38)\n    2\n    Because 3 + 8 = 11, and 1 + 1 = 2. Since 2 has only one digit, 2 is the result.", "sq": "Duke pasur një numër të plotë jo-negativ num, shtoni përsëri të gjitha shifrat e tij derisa rezultati të ketë vetëm një shifër.\nPër shembull:\n    >>> f_48(38)\n    2\n    Sepse 3 + 8 = 11, dhe 1 + 1 = 2. Meqenëse 2 ka vetëm një shifër, 2 është rezultati.", "hy": "Տրված է ոչ բացասական ամբողջ թիվ num, կրկնվող կերպով գումարեք նրա բոլոր թվանշանները, մինչև արդյունքը ունենա միայն մեկ թվանշան:\nՕրինակ:\n    >>> f_48(38)\n    2\n    Քանի որ 3 + 8 = 11, և 1 + 1 = 2։ Քանի որ 2-ն ունի միայն մեկ թվանշան, 2-ը արդյունքն է։", "bn": "একটি অ-ঋণাত্মক পূর্ণসংখ্যা num দেওয়া হলে, ফলাফলটি শুধুমাত্র এক অঙ্ক না হওয়া পর্যন্ত এর সমস্ত অঙ্ক বারবার যোগ করুন। \nউদাহরণস্বরূপ:\n    >>> f_48(38)\n    2\n    কারণ 3 + 8 = 11, এবং 1 + 1 = 2। যেহেতু 2 এর মাত্র একটি অঙ্ক আছে, তাই 2 হল ফলাফল।", "bg": "Като се даде неотрицателно цяло число num, повтаряйте събирането на всичките му цифри, докато резултатът не стане едноцифрено число.\nНапример:\n    >>> f_48(38)\n    2\n    Защото 3 + 8 = 11, и 1 + 1 = 2. Тъй като 2 е едноцифрено число, 2 е резултатът.", "zh": "给定一个非负整数 num，重复相加它的所有数字，直到结果只有一位数字。\n\n例如：\n    >>> f_48(38)\n    2\n    因为 3 + 8 = 11，且 1 + 1 = 2。由于 2 只有一位数字，2 是结果。", "fr": "Étant donné un entier non négatif num, ajoutez de manière répétée tous ses chiffres jusqu'à ce que le résultat n'ait plus qu'un seul chiffre.\nPar exemple :\n    >>> f_48(38)\n    2\n    Parce que 3 + 8 = 11, et 1 + 1 = 2. Puisque 2 n'a qu'un seul chiffre, 2 est le résultat.", "de": "Angenommen, eine nicht-negative ganze Zahl num, addiere wiederholt alle ihre Ziffern, bis das Ergebnis nur noch eine Ziffer hat.  \nZum Beispiel:  \n    >>> f_48(38)  \n    2  \n    Weil 3 + 8 = 11, und 1 + 1 = 2. Da 2 nur eine Ziffer hat, ist 2 das Ergebnis.", "ha": "An ba da wani lamba mara kyau num, a ci gaba da ƙara dukkan lambobinsa har sai sakamakon yana da lamba ɗaya kawai.\nMisali:\n    >>> f_48(38)\n    2\n    Saboda 3 + 8 = 11, kuma 1 + 1 = 2. Tun da 2 yana da lamba ɗaya kawai, 2 shine sakamakon.", "hi": "गैर-ऋणात्मक पूर्णांक num दिया गया है, इसके सभी अंकों को बार-बार जोड़ें जब तक परिणाम में केवल एक अंक न रह जाए।\n\nउदाहरण के लिए:\n    >>> f_48(38)\n    2\n    क्योंकि 3 + 8 = 11, और 1 + 1 = 2। चूंकि 2 में केवल एक अंक है, 2 परिणाम है।", "hu": "Adott egy nem negatív egész szám, num, ismételten add össze az összes számjegyét, amíg az eredmény csak egy számjegyből áll.\nPéldául:\n    >>> f_48(38)\n    2\n    Mert 3 + 8 = 11, és 1 + 1 = 2. Mivel a 2 csak egy számjegyből áll, a 2 az eredmény.", "es": "Dado un número entero no negativo num, suma repetidamente todos sus dígitos hasta que el resultado tenga solo un dígito.  \nPor ejemplo:  \n    >>> f_48(38)  \n    2  \n    Porque 3 + 8 = 11, y 1 + 1 = 2. Dado que 2 tiene solo un dígito, 2 es el resultado.", "arb": "بالنظر إلى عدد صحيح غير سالب num، قم بإضافة جميع أرقامه بشكل متكرر حتى يكون الناتج رقمًا واحدًا فقط.\nعلى سبيل المثال:\n    >>> f_48(38)\n    2\n    لأن 3 + 8 = 11، و 1 + 1 = 2. ولأن 2 يحتوي على رقم واحد فقط، فإن 2 هو النتيجة.", "sw": "Ukipokea nambari isiyo hasi num, ongeza tena tarakimu zake zote hadi matokeo yawe na tarakimu moja pekee.\nKwa mfano:\n    >>> f_48(38)\n    2\n    Kwa sababu 3 + 8 = 11, na 1 + 1 = 2. Kwa kuwa 2 ina tarakimu moja pekee, 2 ndiyo matokeo.", "tr": "Verilen bir negatif olmayan tamsayı num için, sonucu tek bir basamak kalana kadar tüm basamaklarını tekrar tekrar toplayın.\nÖrneğin:\n    >>> f_48(38)\n    2\n    Çünkü 3 + 8 = 11 ve 1 + 1 = 2. 2 yalnızca bir basamak içerdiğinden, sonuç 2'dir.", "vi": "Cho một số nguyên không âm num, liên tục cộng tất cả các chữ số của nó cho đến khi kết quả chỉ còn một chữ số.  \nVí dụ:  \n    >>> f_48(38)  \n    2  \n    Bởi vì 3 + 8 = 11, và 1 + 1 = 2. Vì 2 chỉ có một chữ số, 2 là kết quả.", "id": "Diberikan bilangan bulat non-negatif num, tambahkan semua digitnya berulang kali hingga hasilnya hanya memiliki satu digit.  \nSebagai contoh:  \n    >>> f_48(38)  \n    2  \n    Karena 3 + 8 = 11, dan 1 + 1 = 2. Karena 2 hanya memiliki satu digit, 2 adalah hasilnya.", "ja": "非負整数 num が与えられたとき、結果が一桁になるまでその数字を繰り返し加算します。  \n例えば:\n    >>> f_48(38)\n    2\n    なぜなら、3 + 8 = 11 で、1 + 1 = 2 だからです。2 は一桁なので、結果は 2 です。", "ko": "주어진 비음수 정수 num에 대해, 그 자리의 모든 숫자를 반복적으로 더하여 결과가 한 자리 숫자가 될 때까지 계속합니다.\n예를 들어:\n    >>> f_48(38)\n    2\n    왜냐하면 3 + 8 = 11이고, 1 + 1 = 2이기 때문입니다. 2는 한 자리 숫자이므로, 2가 결과입니다.", "ml": "ഒരു നെഗറ്റീവ് അല്ലാത്ത പൂർണ്ണസംഖ്യയായ num നൽകിയാൽ, ഫലത്തിന് ഒരു അക്കമാത്രം ഉള്ളതുവരെ അതിന്റെ എല്ലാ അക്കങ്ങളും ആവർത്തിച്ച് കൂട്ടുക.\n\nഉദാഹരണത്തിന്:\n    >>> f_48(38)\n    2\n    കാരണം 3 + 8 = 11, കൂടാതെ 1 + 1 = 2. 2-ന് ഒരു അക്കമാത്രം ഉള്ളതിനാൽ, 2 ആണ് ഫലം.", "fa": "با توجه به یک عدد صحیح غیرمنفی num، به طور مکرر تمام ارقام آن را جمع کنید تا زمانی که نتیجه تنها یک رقم داشته باشد.\nبرای مثال:\n    >>> f_48(38)\n    2\n    زیرا 3 + 8 = 11، و 1 + 1 = 2. از آنجا که 2 تنها یک رقم دارد، 2 نتیجه است."}}
{"task_id": "C/49", "prompt": {"en": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nYou are playing a game called Nim. In this game, you start with a pile of n stones, and you and your opponent take turns to remove 1 to 3 stones from the pile. The one who removes the last stone wins the game. Given the number of stones n, determine if you can win the game if both you and your opponent play optimally.\nNote: You always take the first turn.\n\nHere are some cases:\n    >>> f_49(1)\n    true\n*/\nbool f_49(int n);", "sq": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nJu po luani një lojë të quajtur Nim. Në këtë lojë, ju filloni me një grumbull prej n gurësh, dhe ju dhe kundërshtari juaj merrni me radhë për të hequr 1 deri në 3 gurë nga grumbulli. Ai që heq gurin e fundit fiton lojën. Duke pasur parasysh numrin e gurëve n, përcaktoni nëse mund ta fitoni lojën nëse ju dhe kundërshtari juaj luani në mënyrë optimale.\nShënim: Ju gjithmonë merrni radhën e parë.\n\nKëtu janë disa raste:\n    >>> f_49(1)\n    true\n*/\nbool f_49(int n);", "hy": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nԴուք խաղում եք Nim կոչվող խաղը։ Այս խաղում դուք սկսում եք n քարերի կույտով, և դուք և ձեր մրցակիցը հերթով հեռացնում եք 1-ից 3 քար կույտից։ Նա, ով հեռացնում է վերջին քարը, հաղթում է խաղը։ Տրված է քարերի քանակը n, որոշեք՝ արդյոք դուք կարող եք հաղթել խաղը, եթե դուք և ձեր մրցակիցը խաղում եք օպտիմալ կերպով։\nՆշում. Դուք միշտ առաջինն եք խաղում։\n\nԱհա որոշ դեպքեր.\n    >>> f_49(1)\n    true\n*/\nbool f_49(int n);", "bn": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nতুমি একটি গেম খেলছো যার নাম নিম। এই গেমে, তুমি n পাথর দিয়ে শুরু করো, এবং তুমি ও তোমার প্রতিদ্বন্দ্বী পালা করে ১ থেকে ৩টি পাথর সরিয়ে নাও। যে শেষ পাথরটি সরাবে সে গেমটি জিতে যাবে। পাথরের সংখ্যা n দেওয়া আছে, যদি তুমি ও তোমার প্রতিদ্বন্দ্বী উভয়ই সর্বোত্তমভাবে খেলে, তাহলে তুমি গেমটি জিততে পারবে কিনা তা নির্ধারণ করো।\nনোট: তুমি সবসময় প্রথম পালা নাও।\n\nকিছু উদাহরণ এখানে দেওয়া হল:\n    >>> f_49(1)\n    true\n*/\nbool f_49(int n);", "bg": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nВие играете игра, наречена Nim. В тази игра започвате с купчина от n камъка, и вие и вашият противник се редувате да премахвате от 1 до 3 камъка от купчината. Този, който премахне последния камък, печели играта. Даден е броят на камъните n, определете дали можете да спечелите играта, ако и вие, и вашият противник играете оптимално.\nЗабележка: Винаги вие правите първия ход.\n\nЕто някои случаи:\n    >>> f_49(1)\n    true\n*/\nbool f_49(int n);", "zh": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\n你正在玩一个叫做 Nim 的游戏。在这个游戏中，你从一堆 n 个石头开始，你和你的对手轮流从堆中移走 1 到 3 个石头。移走最后一个石头的人赢得游戏。给定石头的数量 n，判断如果你和你的对手都以最佳方式玩游戏，你是否能赢。\n注意：你总是先手。\n\n以下是一些情况：\n    >>> f_49(1)\n    true\n*/\nbool f_49(int n);", "fr": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nVous jouez à un jeu appelé Nim. Dans ce jeu, vous commencez avec un tas de n pierres, et vous et votre adversaire retirez à tour de rôle de 1 à 3 pierres du tas. Celui qui retire la dernière pierre gagne la partie. Étant donné le nombre de pierres n, déterminez si vous pouvez gagner la partie si vous et votre adversaire jouez de manière optimale.\nRemarque : Vous jouez toujours en premier.\n\nVoici quelques cas :\n    >>> f_49(1)\n    true\n*/\nbool f_49(int n);", "de": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nDu spielst ein Spiel namens Nim. In diesem Spiel beginnst du mit einem Haufen von n Steinen, und du und dein Gegner wechseln euch ab, um 1 bis 3 Steine aus dem Haufen zu entfernen. Derjenige, der den letzten Stein entfernt, gewinnt das Spiel. Gegeben ist die Anzahl der Steine n, bestimme, ob du das Spiel gewinnen kannst, wenn sowohl du als auch dein Gegner optimal spielen.\nHinweis: Du bist immer derjenige, der den ersten Zug macht.\n\nHier sind einige Fälle:\n    >>> f_49(1)\n    true\n*/\nbool f_49(int n);", "ha": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nKana wasa mai suna Nim. A cikin wannan wasa, ka fara da tarin duwatsu n, kai da abokin hamayyarka kuna juyawa don cire 1 zuwa 3 daga cikin tarin. Wanda ya cire dutse na ƙarshe shi ne ya ci wasan. An ba da adadin duwatsu n, tantance ko za ka iya cin nasara idan kai da abokin hamayyarka kuna wasa da hikima.\nLura: Kai ne ka fara wasa.\n\nGa wasu lokuta:\n    >>> f_49(1)\n    true\n*/\nbool f_49(int n);", "hi": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nआप एक खेल खेल रहे हैं जिसे निम कहा जाता है। इस खेल में, आप n पत्थरों के ढेर से शुरू करते हैं, और आप और आपका प्रतिद्वंद्वी बारी-बारी से ढेर से 1 से 3 पत्थर हटाते हैं। जो आखिरी पत्थर हटाता है वह खेल जीतता है। दिए गए पत्थरों की संख्या n के आधार पर, यह निर्धारित करें कि क्या आप खेल जीत सकते हैं यदि आप और आपका प्रतिद्वंद्वी दोनों सर्वोत्तम तरीके से खेलते हैं।\nध्यान दें: आप हमेशा पहली बारी लेते हैं।\n\nयहाँ कुछ मामले हैं:\n    >>> f_49(1)\n    true\n*/\nbool f_49(int n);", "hu": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nEgy Nim nevű játékot játszol. Ebben a játékban egy halom n kővel kezdesz, és te, valamint az ellenfeled felváltva távolítotok el 1-3 követ a halomból. Az nyer, aki az utolsó követ eltávolítja. Adott n kövek száma, határozd meg, hogy nyerhetsz-e, ha mind te, mind az ellenfeled optimálisan játszik.\nMegjegyzés: Mindig te kezded az első kört.\n\nÍme néhány eset:\n    >>> f_49(1)\n    true\n*/\nbool f_49(int n);", "es": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nEstás jugando un juego llamado Nim. En este juego, comienzas con una pila de n piedras, y tú y tu oponente se turnan para remover de 1 a 3 piedras de la pila. Quien quite la última piedra gana el juego. Dado el número de piedras n, determina si puedes ganar el juego si tanto tú como tu oponente juegan de manera óptima.\nNota: Siempre tomas el primer turno.\n\nAquí hay algunos casos:\n    >>> f_49(1)\n    true\n*/\nbool f_49(int n);", "arb": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nأنت تلعب لعبة تسمى نيم. في هذه اللعبة، تبدأ بكومة من n حجارة، وأنت وخصمك تتناوبان على إزالة 1 إلى 3 حجارة من الكومة. الشخص الذي يزيل الحجر الأخير يفوز باللعبة. بالنظر إلى عدد الحجارة n، حدد ما إذا كان بإمكانك الفوز باللعبة إذا لعبت أنت وخصمك بشكل مثالي.\nملاحظة: أنت دائمًا تأخذ الدور الأول.\n\nإليك بعض الحالات:\n    >>> f_49(1)\n    true\n*/\nbool f_49(int n);", "sw": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nUnacheza mchezo unaoitwa Nim. Katika mchezo huu, unaanza na rundo la mawe n, na wewe na mpinzani wako mnachukua zamu kuondoa mawe 1 hadi 3 kutoka kwenye rundo. Yule anayeondoa jiwe la mwisho ndiye anayeshinda mchezo. Ukipewa idadi ya mawe n, amua kama unaweza kushinda mchezo ikiwa wewe na mpinzani wako mnaocheza kwa ufanisi.\nKumbuka: Daima unachukua zamu ya kwanza.\n\nHapa kuna baadhi ya kesi:\n    >>> f_49(1)\n    true\n*/\nbool f_49(int n);", "tr": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nNim adında bir oyun oynuyorsunuz. Bu oyunda, n taşlık bir yığınla başlarsınız ve siz ve rakibiniz sırayla yığından 1 ila 3 taş çıkarırsınız. Son taşı çıkaran oyunu kazanır. Taş sayısı n verildiğinde, hem siz hem de rakibiniz en iyi şekilde oynarsa oyunu kazanıp kazanamayacağınızı belirleyin.\nNot: Her zaman ilk hamleyi siz yaparsınız.\n\nİşte bazı durumlar:\n    >>> f_49(1)\n    true\n*/\nbool f_49(int n);", "vi": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nBạn đang chơi một trò chơi gọi là Nim. Trong trò chơi này, bạn bắt đầu với một đống n viên đá, và bạn cùng đối thủ lần lượt lấy đi từ 1 đến 3 viên đá từ đống. Người nào lấy viên đá cuối cùng sẽ thắng trò chơi. Cho số lượng viên đá n, xác định liệu bạn có thể thắng trò chơi nếu cả bạn và đối thủ đều chơi tối ưu.\nLưu ý: Bạn luôn đi trước.\n\nDưới đây là một số trường hợp:\n    >>> f_49(1)\n    true\n*/\nbool f_49(int n);", "id": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nAnda sedang bermain permainan bernama Nim. Dalam permainan ini, Anda memulai dengan tumpukan n batu, dan Anda serta lawan Anda bergantian untuk menghapus 1 hingga 3 batu dari tumpukan. Orang yang menghapus batu terakhir memenangkan permainan. Diberikan jumlah batu n, tentukan apakah Anda dapat memenangkan permainan jika Anda dan lawan Anda bermain secara optimal.\nCatatan: Anda selalu mengambil giliran pertama.\n\nBerikut beberapa kasus:\n    >>> f_49(1)\n    true\n*/\nbool f_49(int n);", "ja": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nあなたはNimというゲームをプレイしています。このゲームでは、n個の石の山から始め、あなたと相手が交互に1から3個の石を山から取り除きます。最後の石を取り除いた人がゲームに勝ちます。石の数nが与えられたとき、あなたと相手が最適にプレイした場合に、あなたがゲームに勝てるかどうかを判断してください。\n注意: あなたは常に最初のターンを取ります。\n\nいくつかのケースを示します:\n    >>> f_49(1)\n    true\n*/\nbool f_49(int n);", "ko": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\n당신은 Nim이라는 게임을 하고 있습니다. 이 게임에서, 당신은 n개의 돌무더기로 시작하고, 당신과 상대방은 번갈아 가며 돌무더기에서 1개에서 3개의 돌을 제거합니다. 마지막 돌을 제거하는 사람이 게임에서 승리합니다. 돌의 수 n이 주어졌을 때, 당신과 상대방이 최적으로 플레이한다면 당신이 게임에서 승리할 수 있는지 결정하십시오.\n참고: 당신이 항상 첫 번째 턴을 가집니다.\n\n다음은 몇 가지 경우입니다:\n    >>> f_49(1)\n    true\n*/\nbool f_49(int n);", "ml": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nനിങ്ങൾ നിം എന്നൊരു ഗെയിം കളിക്കുകയാണ്. ഈ ഗെയിമിൽ, നിങ്ങൾ n കല്ലുകൾ അടങ്ങിയ ഒരു കൂമ്പാരം കൊണ്ട് ആരംഭിക്കുന്നു, നിങ്ങൾക്കും നിങ്ങളുടെ എതിരാളിക്കും കൂമ്പാരത്തിൽ നിന്ന് 1 മുതൽ 3 വരെ കല്ലുകൾ നീക്കം ചെയ്യാനുള്ള അവസരം ലഭിക്കുന്നു. അവസാന കല്ല് നീക്കം ചെയ്യുന്നയാൾ ഗെയിം ജയിക്കും. കല്ലുകളുടെ എണ്ണം n നൽകിയാൽ, നിങ്ങൾക്കും നിങ്ങളുടെ എതിരാളിക്കും മികച്ച രീതിയിൽ കളിക്കുമ്പോൾ നിങ്ങൾക്ക് ഗെയിം ജയിക്കാനാകുമോ എന്ന് നിർണയിക്കുക.\nകുറിപ്പ്: നിങ്ങൾ എപ്പോഴും ആദ്യ തവണ കളിക്കുന്നു.\n\nഇവിടെ ചില കേസുകൾ:\n    >>> f_49(1)\n    true\n*/\nbool f_49(int n);", "fa": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nشما در حال بازی به نام Nim هستید. در این بازی، شما با یک توده از n سنگ شروع می‌کنید و شما و حریف‌تان به نوبت 1 تا 3 سنگ از توده برمی‌دارید. کسی که آخرین سنگ را بردارد برنده بازی است. با توجه به تعداد سنگ‌ها n، تعیین کنید که آیا می‌توانید بازی را ببرید اگر هر دو شما و حریف‌تان بهینه بازی کنید.\nتوجه: شما همیشه اولین نوبت را دارید.\n\nدر اینجا چند مورد وجود دارد:\n    >>> f_49(1)\n    true\n*/\nbool f_49(int n);"}, "canonical_solution": "bool f_49(int n) {\n    return n % 4 != 0;\n}", "instruction": {"en": "Write a C function `bool f_49(int n)` to solve the following problem:\nYou are playing a game called Nim. In this game, you start with a pile of n stones, and you and your opponent take turns to remove 1 to 3 stones from the pile. The one who removes the last stone wins the game. Given the number of stones n, determine if you can win the game if both you and your opponent play optimally.\nNote: You always take the first turn.\n\nHere are some cases:\n    >>> f_49(1)\n    true\n", "sq": "Shkruani një funksion në C `bool f_49(int n)` për të zgjidhur problemin e mëposhtëm:\nJu po luani një lojë të quajtur Nim. Në këtë lojë, ju filloni me një grumbull prej n gurësh, dhe ju dhe kundërshtari juaj merrni radhë për të hequr 1 deri në 3 gurë nga grumbulli. Ai që heq gurin e fundit fiton lojën. Duke pasur parasysh numrin e gurëve n, përcaktoni nëse mund të fitoni lojën nëse si ju ashtu edhe kundërshtari juaj luani në mënyrë optimale.\nShënim: Ju gjithmonë merrni radhën e parë.\n\nJa disa raste:\n    >>> f_49(1)\n    true", "hy": "Գրեք C ֆունկցիա `bool f_49(int n)`՝ հետևյալ խնդիրը լուծելու համար:\nԴուք խաղում եք Nim անունով խաղ: Այս խաղում դուք սկսում եք n քարերի կույտով, և դուք և ձեր մրցակիցը հերթով հանում եք 1-ից 3 քարեր կույտից: Նա, ով կհանի վերջին քարը, հաղթում է խաղը: Տրված է քարերի քանակը n, որոշեք՝ արդյոք դուք կարող եք հաղթել խաղը, եթե դուք և ձեր մրցակիցը խաղում եք օպտիմալ կերպով:\nՆշում: Դուք միշտ առաջինն եք խաղում:\n\nԱհա որոշ դեպքեր:\n    >>> f_49(1)\n    true", "bn": "একটি C ফাংশন `bool f_49(int n)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nআপনি একটি গেম খেলছেন যার নাম নিম। এই গেমে, আপনি n পাথর দিয়ে শুরু করেন, এবং আপনি এবং আপনার প্রতিপক্ষ পালাক্রমে পাইল থেকে 1 থেকে 3 পাথর সরান। যে শেষ পাথরটি সরায় সে গেমটি জেতে। প্রদত্ত পাথরের সংখ্যা n, নির্ধারণ করুন আপনি গেমটি জিততে পারবেন কিনা যদি আপনি এবং আপনার প্রতিপক্ষ উভয়ই সর্বোত্তমভাবে খেলে।\nদ্রষ্টব্য: আপনি সর্বদা প্রথম পালা নেন।\n\nকিছু উদাহরণ এখানে দেওয়া হল:\n    >>> f_49(1)\n    true", "bg": "Напишете C функция `bool f_49(int n)`, за да решите следния проблем:\nИграете игра, наречена Nim. В тази игра започвате с купчина от n камъка и вие и вашият противник се редувате да премахвате от 1 до 3 камъка от купчината. Този, който премахне последния камък, печели играта. Като се има предвид броят на камъните n, определете дали можете да спечелите играта, ако и вие, и вашият противник играете оптимално.  \nЗабележка: Винаги вие правите първия ход.  \n\nЕто някои случаи:  \n    >>> f_49(1)  \n    true  ", "zh": "编写一个 C 函数 `bool f_49(int n)` 来解决以下问题：\n你正在玩一个叫做 Nim 的游戏。在这个游戏中，你从一堆 n 个石头开始，你和你的对手轮流从堆中移除 1 到 3 个石头。移除最后一个石头的人赢得游戏。给定石头的数量 n，如果你和你的对手都采取最优策略，确定你是否能赢得游戏。  \n注意：你总是先走。  \n\n以下是一些情况：  \n    >>> f_49(1)  \n    true  ", "fr": "Écrivez une fonction C `bool f_49(int n)` pour résoudre le problème suivant:\nVous jouez à un jeu appelé Nim. Dans ce jeu, vous commencez avec un tas de n pierres, et vous et votre adversaire prenez à tour de rôle entre 1 et 3 pierres du tas. Celui qui enlève la dernière pierre gagne la partie. Étant donné le nombre de pierres n, déterminez si vous pouvez gagner la partie si vous et votre adversaire jouez de manière optimale.  \nRemarque : Vous prenez toujours le premier tour.\n\nVoici quelques cas :  \n    >>> f_49(1)  \n    true  ", "de": "Schreiben Sie eine C-Funktion `bool f_49(int n)`, um das folgende Problem zu lösen:\nSie spielen ein Spiel namens Nim. In diesem Spiel beginnen Sie mit einem Haufen von n Steinen, und Sie und Ihr Gegner wechseln sich ab, um 1 bis 3 Steine aus dem Haufen zu entfernen. Derjenige, der den letzten Stein entfernt, gewinnt das Spiel. Gegeben die Anzahl der Steine n, bestimmen Sie, ob Sie das Spiel gewinnen können, wenn sowohl Sie als auch Ihr Gegner optimal spielen.\nHinweis: Sie sind immer derjenige, der den ersten Zug macht.\n\nHier sind einige Fälle:\n    >>> f_49(1)\n    true", "ha": "Rubuta aikin C `bool f_49(int n)` don warware matsalar mai zuwa:\nKana wasa mai suna Nim. A cikin wannan wasa, ka fara da tarin duwatsu n, kai da abokin hamayyarka kuna yin juyi don cire 1 zuwa 3 daga cikin duwatsun. Wanda ya cire dutse na ƙarshe shi ne ya ci wasan. An ba da yawan duwatsu n, tantance idan zaka iya cin nasara idan kai da abokin hamayyarka kuna wasa da hikima.\nLura: Kai ne kake fara juyi na farko.\n\nGa wasu lokuta:\n    >>> f_49(1)\n    true", "hi": "C फ़ंक्शन `bool f_49(int n)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nआप एक खेल खेल रहे हैं जिसे निम कहा जाता है। इस खेल में, आप n पत्थरों के ढेर से शुरू करते हैं, और आप और आपका प्रतिद्वंद्वी बारी-बारी से ढेर से 1 से 3 पत्थर हटाते हैं। जो अंतिम पत्थर हटाता है वह खेल जीतता है। दिए गए पत्थरों की संख्या n के आधार पर यह निर्धारित करें कि यदि आप और आपका प्रतिद्वंद्वी दोनों ही सर्वोत्तम रूप से खेलते हैं तो क्या आप खेल जीत सकते हैं।\nनोट: आप हमेशा पहली बारी लेते हैं।\n\nयहाँ कुछ मामले हैं:\n    >>> f_49(1)\n    true", "hu": "Írj egy C függvényt `bool f_49(int n)` a következő probléma megoldására:\nEgy Nim nevű játékot játszol. Ebben a játékban egy halom n kővel kezdesz, és te, valamint az ellenfeled felváltva távolítotok el 1-től 3-ig terjedő számú követ a halomból. Az nyer, aki az utolsó követ eltávolítja. Adott a kövek száma n, határozd meg, hogy meg tudod-e nyerni a játékot, ha te és az ellenfeled is optimálisan játszotok.\nMegjegyzés: Mindig te kezded az első lépést.\n\nÍme néhány eset:\n    >>> f_49(1)\n    true", "es": "Escribe una función en C `bool f_49(int n)` para resolver el siguiente problema:\nEstás jugando un juego llamado Nim. En este juego, comienzas con una pila de n piedras, y tú y tu oponente se turnan para quitar de 1 a 3 piedras de la pila. Quien quite la última piedra gana el juego. Dado el número de piedras n, determina si puedes ganar el juego si tanto tú como tu oponente juegan de manera óptima.\nNota: Siempre tomas el primer turno.\n\nAquí hay algunos casos:\n    >>> f_49(1)\n    true", "arb": "اكتب دالة بلغة C `bool f_49(int n)` لحل المشكلة التالية:\nأنت تلعب لعبة تسمى نيم. في هذه اللعبة، تبدأ بكومة من n حجارة، وتقوم أنت وخصمك بالتناوب لإزالة 1 إلى 3 حجارة من الكومة. الشخص الذي يزيل الحجر الأخير يفوز باللعبة. بالنظر إلى عدد الحجارة n، حدد ما إذا كان بإمكانك الفوز باللعبة إذا لعبت أنت وخصمك بشكل مثالي.\nملاحظة: أنت دائمًا تأخذ الدور الأول.\n\nإليك بعض الحالات:\n    >>> f_49(1)\n    true", "sw": "Andika kazi ya C `bool f_49(int n)` kutatua tatizo lifuatalo:\nUnacheza mchezo unaoitwa Nim. Katika mchezo huu, unaanza na rundo la mawe n, na wewe na mpinzani wako mnapokezana kuondoa mawe 1 hadi 3 kutoka kwenye rundo. Yule anayeondoa jiwe la mwisho anashinda mchezo. Ukipewa idadi ya mawe n, amua kama unaweza kushinda mchezo ikiwa wewe na mpinzani wako mna cheza kwa ufanisi.\nKumbuka: Daima unachukua zamu ya kwanza.\n\nHapa kuna baadhi ya kesi:\n    >>> f_49(1)\n    true", "tr": "Bir C fonksiyonu `bool f_49(int n)` yazın ve aşağıdaki problemi çözün:\nNim adlı bir oyun oynuyorsunuz. Bu oyunda, n taşla başlarsınız ve siz ve rakibiniz sırayla yığından 1 ila 3 taş çıkarırsınız. Son taşı çıkaran oyunu kazanır. Verilen taş sayısı n olduğunda, hem siz hem de rakibiniz optimal oynarsa oyunu kazanıp kazanamayacağınızı belirleyin.\nNot: Her zaman ilk hamleyi siz yaparsınız.\n\nİşte bazı durumlar:\n    >>> f_49(1)\n    true", "vi": "Viết một hàm C `bool f_49(int n)` để giải quyết vấn đề sau:\nBạn đang chơi một trò chơi gọi là Nim. Trong trò chơi này, bạn bắt đầu với một đống n viên đá, và bạn cùng đối thủ của bạn lần lượt loại bỏ từ 1 đến 3 viên đá khỏi đống. Người nào loại bỏ viên đá cuối cùng sẽ thắng trò chơi. Cho số lượng viên đá n, xác định xem bạn có thể thắng trò chơi hay không nếu cả bạn và đối thủ của bạn đều chơi tối ưu.  \nLưu ý: Bạn luôn đi trước.\n\nDưới đây là một số trường hợp:  \n    >>> f_49(1)  \n    true  ", "id": "Tulis sebuah fungsi C `bool f_49(int n)` untuk menyelesaikan masalah berikut:\nAnda sedang bermain permainan yang disebut Nim. Dalam permainan ini, Anda memulai dengan setumpuk n batu, dan Anda serta lawan Anda bergiliran untuk menghapus 1 hingga 3 batu dari tumpukan. Orang yang menghapus batu terakhir memenangkan permainan. Diberikan jumlah batu n, tentukan apakah Anda bisa memenangkan permainan jika Anda dan lawan Anda bermain secara optimal.\nCatatan: Anda selalu mengambil giliran pertama.\n\nBerikut adalah beberapa kasus:\n    >>> f_49(1)\n    true", "ja": "Cの関数を書け `bool f_49(int n)` を作成して、次の問題を解決してください:\nあなたはNimというゲームをプレイしています。このゲームでは、n個の石の山から始め、あなたと相手が交互に1から3個の石を山から取り除きます。最後の石を取った人がゲームに勝ちます。石の数nが与えられたとき、あなたと相手が最適にプレイした場合に、あなたがゲームに勝てるかどうかを判断してください。\n注意: あなたが常に最初のターンを取ります。\n\nいくつかのケース:\n    >>> f_49(1)\n    true", "ko": "C 함수 `bool f_49(int n)`을 작성하여 다음 문제를 해결하십시오:\n당신은 Nim이라는 게임을 하고 있습니다. 이 게임에서, 당신은 n개의 돌무더기로 시작하고, 당신과 상대방은 번갈아 가며 1개에서 3개의 돌을 무더기에서 제거합니다. 마지막 돌을 제거하는 사람이 게임에서 승리합니다. 돌의 수 n이 주어졌을 때, 당신과 상대방이 최적으로 플레이할 경우 당신이 게임에서 이길 수 있는지 결정하십시오.\n참고: 당신이 항상 첫 번째 차례를 가집니다.\n\n다음은 몇 가지 경우입니다:\n    >>> f_49(1)\n    true", "ml": "C ഭാഷയിൽ ഒരു ഫംഗ്ഷൻ `bool f_49(int n)` എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nനിം എന്നൊരു ഗെയിം നിങ്ങൾ കളിക്കുകയാണ്. ഈ ഗെയിമിൽ, നിങ്ങൾ n കല്ലുകൾ ഉള്ള ഒരു കൂമ്പാരം കൊണ്ട് ആരംഭിക്കുന്നു, നിങ്ങൾക്കും നിങ്ങളുടെ എതിരാളിക്കും കൂമ്പാരത്തിൽ നിന്ന് 1 മുതൽ 3 വരെ കല്ലുകൾ നീക്കാൻ തവണയായി കഴിയും. അവസാനത്തെ കല്ല് നീക്കുന്നവൻ ഗെയിം ജയിക്കും. കല്ലുകളുടെ എണ്ണം n നൽകിയാൽ, നിങ്ങൾക്കും നിങ്ങളുടെ എതിരാളിക്കും മികച്ച രീതിയിൽ കളിക്കുമ്പോൾ നിങ്ങൾക്ക് ഗെയിം ജയിക്കാനാകുമോ എന്ന് നിർണ്ണയിക്കുക.\nകുറിപ്പ്: നിങ്ങൾ എപ്പോഴും ആദ്യ തവണ എടുക്കുന്നു.\n\nഇവിടെ ചില കേസുകൾ:\n    >>> f_49(1)\n    true", "fa": "یک تابع C به نام `bool f_49(int n)` بنویسید تا مسئله زیر را حل کند:\nشما در حال بازی به نام Nim هستید. در این بازی، شما با یک توده از n سنگ شروع می‌کنید و شما و حریف‌تان به نوبت 1 تا 3 سنگ از توده برمی‌دارید. کسی که آخرین سنگ را بردارد، برنده بازی است. با توجه به تعداد سنگ‌های n، تعیین کنید که آیا می‌توانید بازی را ببرید اگر هم شما و هم حریف‌تان بهینه بازی کنید.\nتوجه: شما همیشه اولین نوبت را دارید.\n\nدر اینجا چند مورد آمده است:\n    >>> f_49(1)\n    true"}, "level": "easy", "test": "int main() {\n    assert(f_49(1) == true);\n    assert(f_49(2) == true);\n    assert(f_49(3) == true);\n    assert(f_49(4) == false);\n    assert(f_49(5) == true);\n    assert(f_49(6) == true);\n    assert(f_49(7) == true);\n    assert(f_49(8) == false);\n    assert(f_49(9) == true);\n    assert(f_49(10) == true);\n    assert(f_49(11) == true);\n    assert(f_49(12) == false);\n    assert(f_49(13) == true);\n    assert(f_49(14) == true);\n    assert(f_49(15) == true);\n    assert(f_49(16) == false);\n    assert(f_49(17) == true);\n    assert(f_49(18) == true);\n    assert(f_49(19) == true);\n    assert(f_49(20) == false);\n    return 0;\n}", "entry_point": "f_49", "signature": "bool f_49(int n)", "docstring": {"en": "You are playing a game called Nim. In this game, you start with a pile of n stones, and you and your opponent take turns to remove 1 to 3 stones from the pile. The one who removes the last stone wins the game. Given the number of stones n, determine if you can win the game if both you and your opponent play optimally.\nNote: You always take the first turn.\n\nHere are some cases:\n    >>> f_49(1)\n    true\n", "sq": "Ju po luani një lojë të quajtur Nim. Në këtë lojë, ju filloni me një grumbull prej n gurësh, dhe ju dhe kundërshtari juaj merrni me radhë për të hequr 1 deri në 3 gurë nga grumbulli. Ai që heq gurin e fundit fiton lojën. Duke pasur parasysh numrin e gurëve n, përcaktoni nëse mund të fitoni lojën nëse si ju ashtu edhe kundërshtari juaj luani në mënyrë optimale. \nShënim: Ju gjithmonë e merrni lëvizjen e parë.\n\nKëtu janë disa raste:\n    >>> f_49(1)\n    true", "hy": "Դուք խաղում եք Nim կոչվող խաղը։ Այս խաղում դուք սկսում եք n քարերի կույտով, և դուք և ձեր մրցակիցը հերթով հանում եք 1-ից 3 քար կույտից։ Նա, ով կհանի վերջին քարը, հաղթում է խաղը։ Տրված է քարերի քանակը n, որոշեք՝ արդյոք դուք կարող եք հաղթել խաղը, եթե դուք և ձեր մրցակիցը խաղում եք օպտիմալ կերպով։\nՆշում. Դուք միշտ առաջինն եք խաղում։\n\nԱհա որոշ դեպքեր.\n    >>> f_49(1)\n    true", "bn": "আপনি একটি গেম খেলছেন যার নাম নিম। এই গেমে, আপনি একটি স্তূপের n পাথর দিয়ে শুরু করেন, এবং আপনি এবং আপনার প্রতিপক্ষ পালাক্রমে স্তূপ থেকে 1 থেকে 3 পাথর সরান। যে শেষ পাথরটি সরায় সে গেমটি জিতে। পাথরের সংখ্যা n দেওয়া আছে, নির্ধারণ করুন আপনি গেমটি জিততে পারবেন কিনা যদি আপনি এবং আপনার প্রতিপক্ষ উভয়ই সর্বোত্তমভাবে খেলেন।\nদ্রষ্টব্য: আপনি সর্বদা প্রথম পালা নেন।\n\nকিছু উদাহরণ এখানে:\n    >>> f_49(1)\n    true", "bg": "Вие играете игра, наречена Nim. В тази игра започвате с купчина от n камъка, и вие и вашият противник се редувате да премахвате от 1 до 3 камъка от купчината. Този, който премахне последния камък, печели играта. Даден е броят на камъните n, определете дали можете да спечелите играта, ако и вие, и вашият противник играете оптимално. \nЗабележка: Винаги вие правите първия ход.\n\nЕто някои случаи:\n    >>> f_49(1)\n    true", "zh": "你正在玩一个叫做 Nim 的游戏。在这个游戏中，你从一堆 n 个石头开始，你和你的对手轮流从堆中移除 1 到 3 个石头。移除最后一个石头的人赢得游戏。给定石头的数量 n，判断如果你和你的对手都采取最优策略，你是否能赢得游戏。\n注意：你总是先手。\n\n以下是一些情况：\n    >>> f_49(1)\n    true", "fr": "Vous jouez à un jeu appelé Nim. Dans ce jeu, vous commencez avec un tas de n pierres, et vous et votre adversaire retirez à tour de rôle de 1 à 3 pierres du tas. Celui qui retire la dernière pierre gagne la partie. Étant donné le nombre de pierres n, déterminez si vous pouvez gagner la partie si vous et votre adversaire jouez de manière optimale.  \nRemarque : Vous jouez toujours en premier.\n\nVoici quelques cas :  \n    >>> f_49(1)  \n    true  ", "de": "Du spielst ein Spiel namens Nim. In diesem Spiel beginnst du mit einem Haufen von n Steinen, und du und dein Gegner wechseln euch ab, um 1 bis 3 Steine aus dem Haufen zu entfernen. Derjenige, der den letzten Stein entfernt, gewinnt das Spiel. Angesichts der Anzahl der Steine n, bestimme, ob du das Spiel gewinnen kannst, wenn sowohl du als auch dein Gegner optimal spielen.\nHinweis: Du bist immer derjenige, der den ersten Zug macht.\n\nHier sind einige Fälle:\n    >>> f_49(1)\n    true", "ha": "Kana wasa da ake kira Nim. A cikin wannan wasa, ka fara da tarin duwatsu n, kai da abokin hamayyarka kuna canza juna don cire 1 zuwa 3 daga cikin duwatsun. Wanda ya cire dutse na ƙarshe shi ne ya ci wasan. An ba da adadin duwatsu n, tantance idan za ka iya cin nasara idan kai da abokin hamayyarka kuna wasa da hikima.\nLura: Kai ne kake fara wasa.\n\nGa wasu lokuta:\n    >>> f_49(1)\n    true", "hi": "आप एक खेल खेल रहे हैं जिसे निम कहा जाता है। इस खेल में, आप n पत्थरों के ढेर से शुरू करते हैं, और आप और आपका प्रतिद्वंद्वी बारी-बारी से ढेर से 1 से 3 पत्थर हटाते हैं। जो आखिरी पत्थर हटाता है वह खेल जीतता है। दिए गए पत्थरों की संख्या n के आधार पर, यह निर्धारित करें कि क्या आप खेल जीत सकते हैं यदि आप और आपका प्रतिद्वंद्वी दोनों ही सर्वोत्तम रूप से खेलते हैं। \nनोट: आप हमेशा पहली बारी लेते हैं।\n\nयहाँ कुछ मामले हैं:\n    >>> f_49(1)\n    true", "hu": "A Nim nevű játékot játszol. Ebben a játékban egy halom n kővel kezded, és te, valamint az ellenfeled felváltva távolítotok el 1-3 követ a halomból. Az nyer, aki az utolsó követ eltávolítja. Adott n kő száma esetén határozd meg, hogy nyerhetsz-e, ha mind te, mind az ellenfeled optimálisan játszik.\nMegjegyzés: Mindig te kezded az első lépést.\n\nÍme néhány eset:\n    >>> f_49(1)\n    true", "es": "Estás jugando un juego llamado Nim. En este juego, comienzas con un montón de n piedras, y tú y tu oponente se turnan para quitar de 1 a 3 piedras del montón. El que quite la última piedra gana el juego. Dado el número de piedras n, determina si puedes ganar el juego si tanto tú como tu oponente juegan de manera óptima.\nNota: Siempre tomas el primer turno.\n\nAquí hay algunos casos:\n    >>> f_49(1)\n    true", "arb": "أنت تلعب لعبة تسمى نيم. في هذه اللعبة، تبدأ بكومة من n من الحجارة، وأنت وخصمك تتناوبان على إزالة من 1 إلى 3 حجارة من الكومة. الشخص الذي يزيل الحجر الأخير يفوز باللعبة. بالنظر إلى عدد الحجارة n، حدد ما إذا كان بإمكانك الفوز باللعبة إذا لعبت أنت وخصمك بشكل مثالي. \nملاحظة: أنت دائمًا تأخذ الدور الأول.\n\nإليك بعض الحالات:\n    >>> f_49(1)\n    true", "sw": "Unacheza mchezo unaoitwa Nim. Katika mchezo huu, unaanza na rundo la mawe n, na wewe pamoja na mpinzani wako mnachukua zamu kuondoa mawe 1 hadi 3 kutoka kwenye rundo. Yule anayeondoa jiwe la mwisho anashinda mchezo. Ukipewa idadi ya mawe n, amua kama unaweza kushinda mchezo ikiwa wewe na mpinzani wako mna cheza kwa ustadi.\n\nKumbuka: Daima unachukua zamu ya kwanza.\n\nHapa kuna baadhi ya kesi:\n    >>> f_49(1)\n    true", "tr": "Nim adlı bir oyun oynuyorsunuz. Bu oyunda, n taşlık bir yığınla başlarsınız ve siz ve rakibiniz sırayla yığından 1 ila 3 taş alırsınız. Son taşı alan oyunu kazanır. Taş sayısı n verildiğinde, hem siz hem de rakibiniz optimal oynarsa oyunu kazanıp kazanamayacağınızı belirleyin. Not: Her zaman ilk hamleyi siz yaparsınız.\n\nİşte bazı durumlar:\n    >>> f_49(1)\n    true", "vi": "Bạn đang chơi một trò chơi có tên là Nim. Trong trò chơi này, bạn bắt đầu với một đống n viên đá, và bạn cùng đối thủ lần lượt lấy đi từ 1 đến 3 viên đá từ đống. Người nào lấy viên đá cuối cùng sẽ thắng trò chơi. Cho số viên đá n, xác định xem bạn có thể thắng trò chơi hay không nếu cả bạn và đối thủ đều chơi tối ưu. \nLưu ý: Bạn luôn đi trước.\n\nDưới đây là một số trường hợp:\n    >>> f_49(1)\n    true", "id": "Anda sedang bermain permainan bernama Nim. Dalam permainan ini, Anda memulai dengan tumpukan n batu, dan Anda serta lawan Anda bergiliran untuk mengambil 1 hingga 3 batu dari tumpukan. Orang yang mengambil batu terakhir memenangkan permainan. Diberikan jumlah batu n, tentukan apakah Anda bisa memenangkan permainan jika Anda dan lawan Anda bermain secara optimal.\nCatatan: Anda selalu mengambil giliran pertama.\n\nBerikut adalah beberapa kasus:\n    >>> f_49(1)\n    true", "ja": "あなたはNimというゲームをプレイしています。このゲームでは、n個の石の山から始め、あなたと対戦相手が交互に1から3個の石を取り除きます。最後の石を取り除いた人がゲームに勝ちます。石の数nが与えられたとき、あなたと対戦相手が最適にプレイした場合に、あなたがゲームに勝てるかどうかを判断します。\n注意: あなたは常に最初のターンを取ります。\n\nいくつかのケース:\n    >>> f_49(1)\n    true", "ko": "당신은 Nim이라는 게임을 하고 있습니다. 이 게임에서, 당신은 n개의 돌무더기로 시작하며, 당신과 상대방은 번갈아가며 돌무더기에서 1개에서 3개의 돌을 제거합니다. 마지막 돌을 제거하는 사람이 게임에서 승리합니다. 돌의 수 n이 주어졌을 때, 당신과 상대방이 최적으로 플레이할 경우 당신이 게임에서 승리할 수 있는지 결정하십시오.  \n참고: 당신이 항상 첫 번째 차례를 가집니다.\n\n다음은 몇 가지 경우입니다:\n    >>> f_49(1)\n    true", "ml": "നിങ്ങൾ നിം എന്നൊരു ഗെയിം കളിക്കുകയാണ്. ഈ ഗെയിമിൽ, നിങ്ങൾ n കല്ലുകൾ അടങ്ങിയ ഒരു കൂമ്പാരം ഉപയോഗിച്ച് ആരംഭിക്കുന്നു, നിങ്ങൾക്കും നിങ്ങളുടെ എതിരാളിക്കും കൂമ്പാരത്തിൽ നിന്ന് 1 മുതൽ 3 വരെ കല്ലുകൾ നീക്കം ചെയ്യാൻ കഴിയുന്ന രീതിയിൽ മാറി മാറി കളിക്കാം. അവസാന കല്ല് നീക്കം ചെയ്യുന്നയാൾ ഗെയിം ജയിക്കും. കല്ലുകളുടെ എണ്ണം n നൽകിയാൽ, നിങ്ങൾക്കും നിങ്ങളുടെ എതിരാളിക്കും മികച്ച രീതിയിൽ കളിക്കുമ്പോൾ നിങ്ങൾക്ക് ഗെയിം ജയിക്കാനാകുമോ എന്ന് നിർണയിക്കുക. കുറിപ്പ്: നിങ്ങൾ എപ്പോഴും ആദ്യ തവണ കളിക്കും.\n\nഇവിടെ ചില കേസുകൾ:\n    >>> f_49(1)\n    true", "fa": "شما در حال بازی به نام نیم هستید. در این بازی، شما با یک توده از n سنگ شروع می‌کنید و شما و حریف‌تان به نوبت 1 تا 3 سنگ از توده برمی‌دارید. کسی که آخرین سنگ را بردارد برنده بازی است. با توجه به تعداد سنگ‌ها n، تعیین کنید که آیا می‌توانید بازی را ببرید اگر هم شما و هم حریف‌تان بهینه بازی کنید.\nتوجه: شما همیشه اولین نوبت را دارید.\n\nدر اینجا چند مورد وجود دارد:\n    >>> f_49(1)\n    true"}}
{"task_id": "C/50", "prompt": {"en": "#include <assert.h>\n#include <stdio.h>\n/*\nGiven two integers a and b, return the sum if the sum is even, or return the product of a and b if the sum is odd.\n    >>> f_50(2, 3)\n    6\n    >>> f_50(5, 5)\n    10\n*/\nint f_50(int a, int b);", "sq": "#include <assert.h>\n#include <stdio.h>\n/*\nDuke pasur dy numra të plotë a dhe b, kthejeni shumën nëse shuma është çift, ose kthejeni produktin e a dhe b nëse shuma është tek.\n    >>> f_50(2, 3)\n    6\n    >>> f_50(5, 5)\n    10\n*/\nint f_50(int a, int b);", "hy": "#include <assert.h>\n#include <stdio.h>\n/*\nՏրված է երկու ամբողջ թիվ a և b, վերադարձնել գումարը, եթե գումարը զույգ է, կամ վերադարձնել a և b արտադրյալը, եթե գումարը կենտ է։\n    >>> f_50(2, 3)\n    6\n    >>> f_50(5, 5)\n    10\n*/\nint f_50(int a, int b);", "bn": "#include <assert.h>\n#include <stdio.h>\n/*\nদুটি পূর্ণসংখ্যা a এবং b দেওয়া আছে, যদি যোগফলটি জোড় হয় তবে যোগফল ফেরত দিন, অথবা যদি যোগফলটি বিজোড় হয় তবে a এবং b এর গুণফল ফেরত দিন।\n    >>> f_50(2, 3)\n    6\n    >>> f_50(5, 5)\n    10\n*/\nint f_50(int a, int b);", "bg": "#include <assert.h>\n#include <stdio.h>\n/*\nДадени са две цели числа a и b, върнете сумата, ако сумата е четна, или върнете произведението на a и b, ако сумата е нечетна.\n    >>> f_50(2, 3)\n    6\n    >>> f_50(5, 5)\n    10\n*/\nint f_50(int a, int b);", "zh": "#include <assert.h>\n#include <stdio.h>\n/*\n给定两个整数 a 和 b，如果它们的和是偶数则返回和，如果和是奇数则返回 a 和 b 的乘积。\n    >>> f_50(2, 3)\n    6\n    >>> f_50(5, 5)\n    10\n*/\nint f_50(int a, int b);", "fr": "#include <assert.h>\n#include <stdio.h>\n/*\nÉtant donné deux entiers a et b, retourner la somme si la somme est paire, ou retourner le produit de a et b si la somme est impaire.\n    >>> f_50(2, 3)\n    6\n    >>> f_50(5, 5)\n    10\n*/\nint f_50(int a, int b);", "de": "#include <assert.h>\n#include <stdio.h>\n/*\nGegeben zwei ganze Zahlen a und b, gib die Summe zurück, wenn die Summe gerade ist, oder gib das Produkt von a und b zurück, wenn die Summe ungerade ist.\n    >>> f_50(2, 3)\n    6\n    >>> f_50(5, 5)\n    10\n*/\nint f_50(int a, int b);", "ha": "#include <assert.h>\n#include <stdio.h>\n/*\nAn ba da lambobi guda biyu a da b, dawo da jumlar idan jumlar tana da lamba mai ma'ana, ko kuma dawo da samfurin a da b idan jumlar tana da lamba mai wargi.\n    >>> f_50(2, 3)\n    6\n    >>> f_50(5, 5)\n    10\n*/\nint f_50(int a, int b);", "hi": "#include <assert.h>\n#include <stdio.h>\n/*\nदो पूर्णांक a और b दिए गए हैं, यदि योग सम है तो योग लौटाएं, या यदि योग विषम है तो a और b का गुणनफल लौटाएं।\n    >>> f_50(2, 3)\n    6\n    >>> f_50(5, 5)\n    10\n*/\nint f_50(int a, int b);", "hu": "#include <assert.h>\n#include <stdio.h>\n/*\nAdott két egész szám, a és b, add vissza az összegüket, ha az összeg páros, vagy add vissza a szorzatukat, ha az összeg páratlan.\n    >>> f_50(2, 3)\n    6\n    >>> f_50(5, 5)\n    10\n*/\nint f_50(int a, int b);", "es": "#include <assert.h>\n#include <stdio.h>\n/*\nDado dos enteros a y b, devuelve la suma si la suma es par, o devuelve el producto de a y b si la suma es impar.\n    >>> f_50(2, 3)\n    6\n    >>> f_50(5, 5)\n    10\n*/\nint f_50(int a, int b);", "arb": "#include <assert.h>\n#include <stdio.h>\n/*\nمعطى عددان صحيحان a و b، أعد المجموع إذا كان المجموع زوجيًا، أو أعد حاصل ضرب a و b إذا كان المجموع فرديًا.\n    >>> f_50(2, 3)\n    6\n    >>> f_50(5, 5)\n    10\n*/\nint f_50(int a, int b);", "sw": "#include <assert.h>\n#include <stdio.h>\n/*\nUkipata nambari mbili nzima a na b, rudisha jumla ikiwa jumla ni shufwa, au rudisha bidhaa ya a na b ikiwa jumla ni witiri.\n    >>> f_50(2, 3)\n    6\n    >>> f_50(5, 5)\n    10\n*/\nint f_50(int a, int b);", "tr": "#include <assert.h>\n#include <stdio.h>\n/*\nİki tamsayı a ve b verildiğinde, toplam çift ise toplamı döndürün, toplam tek ise a ve b'nin çarpımını döndürün.\n    >>> f_50(2, 3)\n    6\n    >>> f_50(5, 5)\n    10\n*/\nint f_50(int a, int b);", "vi": "#include <assert.h>\n#include <stdio.h>\n/*\nCho hai số nguyên a và b, trả về tổng nếu tổng là số chẵn, hoặc trả về tích của a và b nếu tổng là số lẻ.\n    >>> f_50(2, 3)\n    6\n    >>> f_50(5, 5)\n    10\n*/\nint f_50(int a, int b);", "id": "#include <assert.h>\n#include <stdio.h>\n/*\nDiberikan dua bilangan bulat a dan b, kembalikan jumlahnya jika jumlahnya genap, atau kembalikan hasil kali dari a dan b jika jumlahnya ganjil.\n    >>> f_50(2, 3)\n    6\n    >>> f_50(5, 5)\n    10\n*/\nint f_50(int a, int b);", "ja": "#include <assert.h>\n#include <stdio.h>\n/*\n2つの整数aとbが与えられたとき、合計が偶数であればその合計を返し、合計が奇数であればaとbの積を返します。\n    >>> f_50(2, 3)\n    6\n    >>> f_50(5, 5)\n    10\n*/\nint f_50(int a, int b);", "ko": "#include <assert.h>\n#include <stdio.h>\n/*\n두 정수 a와 b가 주어졌을 때, 합이 짝수이면 합을 반환하고, 합이 홀수이면 a와 b의 곱을 반환합니다.\n    >>> f_50(2, 3)\n    6\n    >>> f_50(5, 5)\n    10\n*/\nint f_50(int a, int b);", "ml": "#include <assert.h>\n#include <stdio.h>\n/*\nരണ്ട് പൂർണ്ണസംഖ്യകൾ a, b എന്നിവ നൽകിയാൽ, തുക സമം ആണെങ്കിൽ തുക മടക്കുക, അല്ലെങ്കിൽ തുക വിചിത്രമാണെങ്കിൽ a, b എന്നിവയുടെ ഗുണനം മടക്കുക.\n    >>> f_50(2, 3)\n    6\n    >>> f_50(5, 5)\n    10\n*/\nint f_50(int a, int b);", "fa": "#include <assert.h>\n#include <stdio.h>\n/*\nدو عدد صحیح a و b داده شده است، اگر مجموع زوج باشد، مجموع را برگردانید، یا اگر مجموع فرد باشد، حاصلضرب a و b را برگردانید.\n    >>> f_50(2, 3)\n    6\n    >>> f_50(5, 5)\n    10\n*/\nint f_50(int a, int b);"}, "canonical_solution": "int f_50(int a, int b) {\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}", "instruction": {"en": "Write a C function `int f_50(int a, int b)` to solve the following problem:\nGiven two integers a and b, return the sum if the sum is even, or return the product of a and b if the sum is odd.\n    >>> f_50(2, 3)\n    6\n    >>> f_50(5, 5)\n    10\n", "sq": "Shkruani një funksion në C `int f_50(int a, int b)` për të zgjidhur problemin në vijim:\nDuke pasur dy numra të plotë a dhe b, kthejeni shumën nëse shuma është çift, ose kthejeni prodhimin e a dhe b nëse shuma është tek.  \n    >>> f_50(2, 3)  \n    6  \n    >>> f_50(5, 5)  \n    10  ", "hy": "Գրեք C ֆունկցիա `int f_50(int a, int b)`՝ հետևյալ խնդիրը լուծելու համար:\nՏրված են երկու ամբողջ թիվ a և b, վերադարձնել գումարը, եթե գումարը զույգ է, կամ վերադարձնել a և b արտադրյալը, եթե գումարը կենտ է։", "bn": "একটি C ফাংশন `int f_50(int a, int b)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nদেওয়া দুটি পূর্ণসংখ্যা a এবং b, যদি যোগফল জোড় হয় তবে যোগফল ফেরত দিন, অথবা যদি যোগফল বিজোড় হয় তবে a এবং b এর গুণফল ফেরত দিন।", "bg": "Напишете C функция `int f_50(int a, int b)` за решаване на следния проблем:\nДадени са две цели числа a и b, върнете сумата, ако сумата е четна, или върнете произведението на a и b, ако сумата е нечетна.", "zh": "编写一个C函数 `int f_50(int a, int b)` 来解决以下问题：\n给定两个整数 a 和 b，如果它们的和是偶数，则返回和；如果和是奇数，则返回 a 和 b 的乘积。", "fr": "Écrire une fonction C `int f_50(int a, int b)` pour résoudre le problème suivant :\nÉtant donné deux entiers a et b, retourner la somme si la somme est paire, ou retourner le produit de a et b si la somme est impaire.  \n    >>> f_50(2, 3)  \n    6  \n    >>> f_50(5, 5)  \n    10  ", "de": "Schreiben Sie eine C-Funktion `int f_50(int a, int b)`, um das folgende Problem zu lösen:\nGegeben sind zwei ganze Zahlen a und b, geben Sie die Summe zurück, wenn die Summe gerade ist, oder geben Sie das Produkt von a und b zurück, wenn die Summe ungerade ist.  \n    >>> f_50(2, 3)  \n    6  \n    >>> f_50(5, 5)  \n    10  ", "ha": "Rubuta wani aikin C `int f_50(int a, int b)` don warware matsalar mai zuwa:\nAn ba da lambobi guda biyu a da b, dawo da jumlar idan jumlar tana da lamba mai lamba, ko dawo da samfurin a da b idan jumlar tana da lamba mara lamba.  \n    >>> f_50(2, 3)  \n    6  \n    >>> f_50(5, 5)  \n    10  ", "hi": "C फ़ंक्शन `int f_50(int a, int b)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए दो पूर्णांक a और b, यदि योग सम है तो योग लौटाएं, या यदि योग विषम है तो a और b का गुणनफल लौटाएं।\n    >>> f_50(2, 3)\n    6\n    >>> f_50(5, 5)\n    10", "hu": "Írj egy C függvényt `int f_50(int a, int b)` a következő probléma megoldására:\nKét egész szám, a és b adott, add vissza az összegüket, ha az összeg páros, vagy add vissza a és b szorzatát, ha az összeg páratlan.  \n    >>> f_50(2, 3)  \n    6  \n    >>> f_50(5, 5)  \n    10  ", "es": "Escribe una función en C `int f_50(int a, int b)` para resolver el siguiente problema:\nDado dos enteros a y b, devuelve la suma si la suma es par, o devuelve el producto de a y b si la suma es impar.\n    >>> f_50(2, 3)\n    6\n    >>> f_50(5, 5)\n    10", "arb": "اكتب دالة بلغة C `int f_50(int a, int b)` لحل المشكلة التالية:\nبالنظر إلى عددين صحيحين a و b، أعد المجموع إذا كان المجموع زوجياً، أو أعد حاصل ضرب a و b إذا كان المجموع فردياً.\n    >>> f_50(2, 3)\n    6\n    >>> f_50(5, 5)\n    10", "sw": "Andika kazi ya C `int f_50(int a, int b)` kutatua tatizo lifuatalo:\nUkipiwa nambari mbili za mzima a na b, rudisha jumla ikiwa jumla ni nambari shufwa, au rudisha bidhaa ya a na b ikiwa jumla ni nambari witiri.\n    >>> f_50(2, 3)\n    6\n    >>> f_50(5, 5)\n    10", "tr": "Bir C fonksiyonu `int f_50(int a, int b)` yazın ve aşağıdaki problemi çözün:\nVerilen iki tam sayı a ve b için, toplam çift ise toplamı döndürün, toplam tek ise a ve b'nin çarpımını döndürün.\n    >>> f_50(2, 3)\n    6\n    >>> f_50(5, 5)\n    10", "vi": "Viết một hàm C `int f_50(int a, int b)` để giải quyết vấn đề sau:\nCho hai số nguyên a và b, trả về tổng nếu tổng là số chẵn, hoặc trả về tích của a và b nếu tổng là số lẻ.\n    >>> f_50(2, 3)\n    6\n    >>> f_50(5, 5)\n    10", "id": "Tulis sebuah fungsi C `int f_50(int a, int b)` untuk menyelesaikan masalah berikut:\nDiberikan dua bilangan bulat a dan b, kembalikan jumlah jika jumlahnya genap, atau kembalikan hasil kali dari a dan b jika jumlahnya ganjil.\n    >>> f_50(2, 3)\n    6\n    >>> f_50(5, 5)\n    10", "ja": "Cの関数を書け `int f_50(int a, int b)` を作成して、次の問題を解決してください:\n2つの整数 a と b が与えられたとき、合計が偶数であれば合計を返し、合計が奇数であれば a と b の積を返します。\n    >>> f_50(2, 3)\n    6\n    >>> f_50(5, 5)\n    10", "ko": "C 함수 `int f_50(int a, int b)`를 작성하여 다음 문제를 해결하십시오:\n두 정수 a와 b가 주어지면, 합이 짝수인 경우 합을 반환하고, 합이 홀수인 경우 a와 b의 곱을 반환하십시오.\n    >>> f_50(2, 3)\n    6\n    >>> f_50(5, 5)\n    10", "ml": "C ഫംഗ്ഷൻ `int f_50(int a, int b)` എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nരണ്ട് പൂർണ്ണസംഖ്യകൾ a, b നൽകിയാൽ, ആകെ തുക സമവായമായാൽ തുക തിരിച്ചുകൊടുക്കുക, അല്ലെങ്കിൽ തുക വിചിത്രമായാൽ a, b ന്റെ ഗുണഫലം തിരിച്ചുകൊടുക്കുക.\n    >>> f_50(2, 3)\n    6\n    >>> f_50(5, 5)\n    10", "fa": "یک تابع C `int f_50(int a, int b)` بنویسید تا مسئله زیر را حل کند:\nبا توجه به دو عدد صحیح a و b، اگر مجموع زوج باشد، مجموع را برگردانید، یا اگر مجموع فرد باشد، حاصل‌ضرب a و b را برگردانید.\n    >>> f_50(2, 3)\n    6\n    >>> f_50(5, 5)\n    10"}, "level": "easy", "test": "int main() {\n    assert(f_50(2, 3) == 6);\n    assert(f_50(5, 5) == 10);\n    assert(f_50(1, 1) == 2);\n    assert(f_50(0, 0) == 0);\n    assert(f_50(-1, -1) == -2);\n    assert(f_50(100, 200) == 300);\n    assert(f_50(3, 4) == 12);\n    assert(f_50(-5, 5) == 0);\n    assert(f_50(7, 8) == 56);\n    assert(f_50(9, 10) == 90);\n    assert(f_50(11, 14) == 154);\n    return 0;\n}", "entry_point": "f_50", "signature": "int f_50(int a, int b)", "docstring": {"en": "Given two integers a and b, return the sum if the sum is even, or return the product of a and b if the sum is odd.\n    >>> f_50(2, 3)\n    6\n    >>> f_50(5, 5)\n    10\n", "sq": "Duke pasur dy numra të plotë a dhe b, kthejeni shumën nëse shuma është çift, ose ktheni produktin e a dhe b nëse shuma është tek.\n    >>> f_50(2, 3)\n    6\n    >>> f_50(5, 5)\n    10", "hy": "Տրված երկու ամբողջ թիվ a և b, վերադարձնել գումարը, եթե գումարը զույգ է, կամ վերադարձնել a և b արտադրյալը, եթե գումարը կենտ է:\n    >>> f_50(2, 3)\n    6\n    >>> f_50(5, 5)\n    10", "bn": "দুটি পূর্ণসংখ্যা a এবং b দেওয়া হলে, যদি যোগফলটি জোড় হয় তবে যোগফল ফেরত দিন, অথবা যদি যোগফলটি বিজোড় হয় তবে a এবং b এর গুণফল ফেরত দিন।", "bg": "Дадени са две цели числа a и b, върнете сумата, ако сумата е четна, или върнете произведението на a и b, ако сумата е нечетна.\n    >>> f_50(2, 3)\n    6\n    >>> f_50(5, 5)\n    10", "zh": "给定两个整数 a 和 b，如果它们的和是偶数，则返回和；如果和是奇数，则返回 a 和 b 的乘积。\n    >>> f_50(2, 3)\n    6\n    >>> f_50(5, 5)\n    10", "fr": "Étant donné deux entiers a et b, retourner la somme si la somme est paire, ou retourner le produit de a et b si la somme est impaire.\n    >>> f_50(2, 3)\n    6\n    >>> f_50(5, 5)\n    10", "de": "Gegeben zwei ganze Zahlen a und b, gib die Summe zurück, wenn die Summe gerade ist, oder gib das Produkt von a und b zurück, wenn die Summe ungerade ist.\n    >>> f_50(2, 3)\n    6\n    >>> f_50(5, 5)\n    10", "ha": "An ba da lambobi guda biyu a da b, dawo da jumlar idan jumlar tana da lamba mai ma'ana, ko kuma dawo da samfurin a da b idan jumlar tana da lamba mara ma'ana.\n    >>> f_50(2, 3)\n    6\n    >>> f_50(5, 5)\n    10", "hi": "दो पूर्णांक a और b दिए गए हैं, यदि योगफल सम है तो योगफल लौटाएं, या यदि योगफल विषम है तो a और b का गुणनफल लौटाएं।\n    >>> f_50(2, 3)\n    6\n    >>> f_50(5, 5)\n    10", "hu": "Két egész szám, a és b esetén térj vissza az összeggel, ha az összeg páros, vagy térj vissza a és b szorzatával, ha az összeg páratlan.\n    >>> f_50(2, 3)\n    6\n    >>> f_50(5, 5)\n    10", "es": "Dado dos enteros a y b, devuelve la suma si la suma es par, o devuelve el producto de a y b si la suma es impar.\n    >>> f_50(2, 3)\n    6\n    >>> f_50(5, 5)\n    10", "arb": "نظرًا لعددين صحيحين a و b، قم بإرجاع المجموع إذا كان المجموع زوجيًا، أو قم بإرجاع حاصل ضرب a و b إذا كان المجموع فرديًا.\n    >>> f_50(2, 3)\n    6\n    >>> f_50(5, 5)\n    10", "sw": "Kwa kupewa nambari mbili za mzima a na b, rudisha jumla ikiwa jumla ni namba shufwa, au rudisha bidhaa ya a na b ikiwa jumla ni namba witiri.\n    >>> f_50(2, 3)\n    6\n    >>> f_50(5, 5)\n    10", "tr": "Verilen iki tamsayı a ve b için, toplam çift ise toplamı döndürün, eğer toplam tek ise a ve b'nin çarpımını döndürün.\n    >>> f_50(2, 3)\n    6\n    >>> f_50(5, 5)\n    10", "vi": "Cho hai số nguyên a và b, trả về tổng nếu tổng là số chẵn, hoặc trả về tích của a và b nếu tổng là số lẻ.\n    >>> f_50(2, 3)\n    6\n    >>> f_50(5, 5)\n    10", "id": "Diberikan dua bilangan bulat a dan b, kembalikan jumlahnya jika jumlahnya genap, atau kembalikan hasil kali dari a dan b jika jumlahnya ganjil.\n    >>> f_50(2, 3)\n    6\n    >>> f_50(5, 5)\n    10", "ja": "2つの整数aとbが与えられたとき、合計が偶数であればその合計を返し、合計が奇数であればaとbの積を返します。\n    >>> f_50(2, 3)\n    6\n    >>> f_50(5, 5)\n    10", "ko": "두 정수 a와 b가 주어졌을 때, 합이 짝수이면 합을 반환하고, 합이 홀수이면 a와 b의 곱을 반환합니다.\n    >>> f_50(2, 3)\n    6\n    >>> f_50(5, 5)\n    10", "ml": "രണ്ട് പൂർണ്ണസംഖ്യകളായ a, b എന്നിവ നൽകിയാൽ, ആകെ തുക സമവായിരുന്നാൽ തുക തിരികെ നൽകുക, അല്ലെങ്കിൽ തുക ബിസമവായിരുന്നാൽ a, b എന്നിവയുടെ ഗുണഫലം തിരികെ നൽകുക.\n    >>> f_50(2, 3)\n    6\n    >>> f_50(5, 5)\n    10", "fa": "با توجه به دو عدد صحیح a و b، اگر مجموع آن‌ها زوج باشد، مجموع را برگردانید، یا اگر مجموع فرد باشد، حاصل‌ضرب a و b را برگردانید.\n    >>> f_50(2, 3)\n    6\n    >>> f_50(5, 5)\n    10"}}
