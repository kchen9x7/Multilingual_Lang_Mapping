{"task_id": "CPP/1", "prompt": {"en": "#include <bits/stdc++.h>\nusing namespace std;\n// Return \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"\nstring f_1()", "sq": "#include <bits/stdc++.h>\nusing namespace std;\n// Kthen \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"\nstring f_1()", "hy": "#include <bits/stdc++.h>\nusing namespace std;\n// Վերադարձնել \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"\nstring f_1()", "bn": "#include <bits/stdc++.h>\nusing namespace std;\n// \"Hello, Mass-McEval: massively scaled multilingual code evaluation\" ফেরত দিন\nstring f_1()", "bg": "#include <bits/stdc++.h>\nusing namespace std;\n// Връща \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"\nstring f_1()", "zh": "#include <bits/stdc++.h>\nusing namespace std;\n// 返回 \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"\nstring f_1()", "fr": "#include <bits/stdc++.h>\nusing namespace std;\n// Retourne \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"\nstring f_1()", "de": "#include <bits/stdc++.h>\nusing namespace std;\n// Gibt \"Hello, Mass-McEval: massively scaled multilingual code evaluation\" zurück\nstring f_1()", "ha": "#include <bits/stdc++.h>\nusing namespace std;\n// Mayar da \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"\nstring f_1()", "hi": "#include <bits/stdc++.h>\nusing namespace std;\n// \"Hello, Mass-McEval: massively scaled multilingual code evaluation\" लौटाएं\nstring f_1()", "hu": "#include <bits/stdc++.h>\nusing namespace std;\n// Adja vissza a \"Hello, Mass-McEval: massively scaled multilingual code evaluation\" szöveget\nstring f_1()", "es": "#include <bits/stdc++.h>\nusing namespace std;\n// Devuelve \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"\nstring f_1()", "arb": "#include <bits/stdc++.h>\nusing namespace std;\n// إرجاع \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"\nstring f_1()", "sw": "#include <bits/stdc++.h>\nusing namespace std;\n// Rudisha \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"\nstring f_1()", "tr": "#include <bits/stdc++.h>\nusing namespace std;\n// \"Hello, Mass-McEval: massively scaled multilingual code evaluation\" döndür\nstring f_1()", "vi": "#include <bits/stdc++.h>\nusing namespace std;\n// Trả về \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"\nstring f_1()", "id": "#include <bits/stdc++.h>\nusing namespace std;\n// Mengembalikan \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"\nstring f_1()", "ja": "#include <bits/stdc++.h>\nusing namespace std;\n// \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"を返す\nstring f_1()", "ko": "#include <bits/stdc++.h>\nusing namespace std;\n// \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"을 반환합니다.\nstring f_1()", "ml": "#include <bits/stdc++.h>\nusing namespace std;\n// \"Hello, Mass-McEval: massively scaled multilingual code evaluation\" എന്നത് തിരികെ നൽകുക\nstring f_1()", "fa": "#include <bits/stdc++.h>\nusing namespace std;\n// بازگرداندن \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"\nstring f_1()"}, "canonical_solution": "{\n    return \"Hello, Mass-McEval: massively scaled multilingual code evaluation\";\n}", "instruction": {"en": "Write a CPP function `string f_1()` to solve the following problem:\nReturn \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "sq": "Shkruani një funksion CPP `string f_1()` për të zgjidhur problemin e mëposhtëm: Kthe \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "hy": "Գրեք CPP ֆունկցիա `string f_1()` հետևյալ խնդիրը լուծելու համար: Վերադարձնել \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "bn": "একটি CPP ফাংশন `string f_1()` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\n\"Hello, Mass-McEval: massively scaled multilingual code evaluation\" রিটার্ন করুন", "bg": "Напишете CPP функция `string f_1()` за решаване на следния проблем:  \nВърнете \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "zh": "编写一个 CPP 函数 `string f_1()` 来解决以下问题：  \n返回 \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "fr": "Écrire une fonction CPP `string f_1()` pour résoudre le problème suivant :  \nRetourner \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "de": "Schreiben Sie eine CPP-Funktion `string f_1()`, um das folgende Problem zu lösen:  \nGeben Sie \"Hello, Mass-McEval: massively scaled multilingual code evaluation\" zurück.", "ha": "Rubuta aikin CPP `string f_1()` don warware matsalar mai zuwa: Mayar da \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "hi": "एक CPP फ़ंक्शन `string f_1()` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\"Hello, Mass-McEval: massively scaled multilingual code evaluation\" लौटाएं", "hu": "Írj egy CPP függvényt `string f_1()` a következő probléma megoldására:  \nAdja vissza a \"Hello, Mass-McEval: massively scaled multilingual code evaluation\" szöveget", "es": "Escribe una función CPP `string f_1()` para resolver el siguiente problema:\nDevuelve \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "arb": "اكتب دالة CPP `string f_1()` لحل المشكلة التالية:\nإرجاع \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "sw": "Andika kazi ya CPP `string f_1()` kutatua tatizo lifuatalo: Rudisha \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "tr": "Bir CPP fonksiyonu `string f_1()` yazın ve aşağıdaki problemi çözün:\n\"Hello, Mass-McEval: massively scaled multilingual code evaluation\" döndürün.", "vi": "Viết một hàm CPP `string f_1()` để giải quyết vấn đề sau:  \nTrả về \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "id": "Tulis fungsi CPP `string f_1()` untuk menyelesaikan masalah berikut:  \nKembalikan \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "ja": "C++関数 `string f_1()` を作成して、次の問題を解決してください:\n\"Hello, Mass-McEval: massively scaled multilingual code evaluation\" を返します。", "ko": "다음 문제를 해결하기 위해 CPP 함수를 작성하세요 `string f_1()`:  \n\"Hello, Mass-McEval: massively scaled multilingual code evaluation\"을 반환합니다.", "ml": "CPP ഫംഗ്ഷൻ `string f_1()` എഴുതുക താഴെക്കാണുന്ന പ്രശ്നം പരിഹരിക്കുന്നതിന്: \"Hello, Mass-McEval: massively scaled multilingual code evaluation\" മടക്കുക", "fa": "یک تابع CPP بنویسید `string f_1()` برای حل مشکل زیر:\nبرگرداندن \"Hello, Mass-McEval: massively scaled multilingual code evaluation\""}, "level": "easy", "test": "int main()\n{\n    assert(f_1() ==  \"Hello, Mass-McEval: massively scaled multilingual code evaluation\");\n    return 0;\n}", "entry_point": "f_1", "signature": "string f_1()", "docstring": {"en": "Return \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "sq": "Kthe \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "hy": "Վերադարձնել \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "bn": "\"Hello, Mass-McEval: massively scaled multilingual code evaluation\" ফেরত দিন", "bg": "Върни \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "zh": "返回 \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "fr": "Retourne \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "de": "Gibt \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "ha": "Mayar da \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "hi": "\"Hello, Mass-McEval: massively scaled multilingual code evaluation\" लौटाएं", "hu": "Adja vissza a \"Hello, Mass-McEval: massively scaled multilingual code evaluation\" szöveget.", "es": "Devuelve \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "arb": "إرجاع \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "sw": "Rudisha \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "tr": " \"Hello, Mass-McEval: massively scaled multilingual code evaluation\" döndür", "vi": "Trả về \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "id": "Mengembalikan \"Hello, Mass-McEval: massively scaled multilingual code evaluation\"", "ja": "\"Hello, Mass-McEval: massively scaled multilingual code evaluation\" を返します", "ko": "\"Hello, Mass-McEval: massively scaled multilingual code evaluation\"을 반환합니다.", "ml": "\"Hello, Mass-McEval: massively scaled multilingual code evaluation\" തിരികെ നൽകുക", "fa": "بازگرداندن \"Hello, Mass-McEval: massively scaled multilingual code evaluation\""}}
{"task_id": "CPP/2", "prompt": {"en": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Calculate the area of a triangle given its three sides.\n *\n * @param a (double): Length of side 'a'.\n * @param b (double): Length of side 'b'.\n * @param c (double): Length of side 'c'.\n *\n * @return (double): If the provided sides form a triangle, return the\n *                   calculated area rounded to 2 decimal places.\n *                   Otherwise, return -1 as an indicator.\n *\n * Example usage:\n *     double area = f_2(3, 5, 4);\n *     assert(fabs(area - 6.00) < 1e-6); // Area should be approximately 6\n */\nf_2(double a, double b, double c)", "sq": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Llogarit sipërfaqen e një trekëndëshi duke pasur parasysh tre anët e tij.\n *\n * @param a (double): Gjatësia e anës 'a'.\n * @param b (double): Gjatësia e anës 'b'.\n * @param c (double): Gjatësia e anës 'c'.\n *\n * @return (double): Nëse anët e dhëna formojnë një trekëndësh, kthen\n *                   sipërfaqen e llogaritur të rrumbullakosur në 2 vende dhjetore.\n *                   Përndryshe, kthen -1 si tregues.\n *\n * Shembull përdorimi:\n *     double area = f_2(3, 5, 4);\n *     assert(fabs(area - 6.00) < 1e-6); // Sipërfaqja duhet të jetë afërsisht 6\n */\nf_2(double a, double b, double c)", "hy": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Հաշվարկել եռանկյան մակերեսը՝ տրված նրա երեք կողմերը:\n *\n * @param a (double): Կողմ 'a'-ի երկարությունը:\n * @param b (double): Կողմ 'b'-ի երկարությունը:\n * @param c (double): Կողմ 'c'-ի երկարությունը:\n *\n * @return (double): Եթե տրված կողմերը կազմում են եռանկյուն, վերադարձնել\n *                   հաշվարկված մակերեսը՝ կլորացված մինչև 2 տասնորդական նշան:\n *                   Հակառակ դեպքում վերադարձնել -1 որպես ցուցիչ:\n *\n * Օրինակ օգտագործում:\n *     double area = f_2(3, 5, 4);\n *     assert(fabs(area - 6.00) < 1e-6); // Մակերեսը պետք է մոտ լինի 6\n */\nf_2(double a, double b, double c)", "bn": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * একটি ত্রিভুজের তিনটি বাহু দেওয়া থাকলে তার ক্ষেত্রফল গণনা করুন।\n *\n * @param a (double): বাহু 'a' এর দৈর্ঘ্য।\n * @param b (double): বাহু 'b' এর দৈর্ঘ্য।\n * @param c (double): বাহু 'c' এর দৈর্ঘ্য।\n *\n * @return (double): যদি প্রদত্ত বাহুগুলি একটি ত্রিভুজ গঠন করে, তাহলে\n *                   গণনা করা ক্ষেত্রফল 2 দশমিক স্থান পর্যন্ত রাউন্ড করে ফেরত দিন।\n *                   অন্যথায়, নির্দেশক হিসেবে -1 ফেরত দিন।\n *\n * উদাহরণ ব্যবহার:\n *     double area = f_2(3, 5, 4);\n *     assert(fabs(area - 6.00) < 1e-6); // ক্ষেত্রফল প্রায় 6 হওয়া উচিত\n */\nf_2(double a, double b, double c)", "bg": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Изчислява площта на триъгълник, дадени неговите три страни.\n *\n * @param a (double): Дължина на страна 'a'.\n * @param b (double): Дължина на страна 'b'.\n * @param c (double): Дължина на страна 'c'.\n *\n * @return (double): Ако предоставените страни образуват триъгълник, връща\n *                   изчислената площ, закръглена до 2 десетични знака.\n *                   В противен случай връща -1 като индикатор.\n *\n * Пример за използване:\n *     double area = f_2(3, 5, 4);\n *     assert(fabs(area - 6.00) < 1e-6); // Площта трябва да бъде приблизително 6\n */\nf_2(double a, double b, double c)", "zh": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * 计算给定三边的三角形面积。\n *\n * @param a (double): 边 'a' 的长度。\n * @param b (double): 边 'b' 的长度。\n * @param c (double): 边 'c' 的长度。\n *\n * @return (double): 如果提供的边能构成一个三角形，返回计算出的面积，保留两位小数。\n *                   否则，返回 -1 作为指示。\n *\n * 使用示例:\n *     double area = f_2(3, 5, 4);\n *     assert(fabs(area - 6.00) < 1e-6); // 面积应约为 6\n */\nf_2(double a, double b, double c)", "fr": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Calculer l'aire d'un triangle donné ses trois côtés.\n *\n * @param a (double): Longueur du côté 'a'.\n * @param b (double): Longueur du côté 'b'.\n * @param c (double): Longueur du côté 'c'.\n *\n * @return (double): Si les côtés fournis forment un triangle, retourne\n *                   l'aire calculée arrondie à 2 décimales.\n *                   Sinon, retourne -1 comme indicateur.\n *\n * Exemple d'utilisation :\n *     double area = f_2(3, 5, 4);\n *     assert(fabs(area - 6.00) < 1e-6); // L'aire devrait être approximativement 6\n */\nf_2(double a, double b, double c)", "de": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Berechne die Fläche eines Dreiecks, gegeben durch seine drei Seiten.\n *\n * @param a (double): Länge der Seite 'a'.\n * @param b (double): Länge der Seite 'b'.\n * @param c (double): Länge der Seite 'c'.\n *\n * @return (double): Wenn die angegebenen Seiten ein Dreieck bilden, gib die\n *                   berechnete Fläche gerundet auf 2 Dezimalstellen zurück.\n *                   Andernfalls gib -1 als Indikator zurück.\n *\n * Beispielverwendung:\n *     double area = f_2(3, 5, 4);\n *     assert(fabs(area - 6.00) < 1e-6); // Fläche sollte ungefähr 6 sein\n */\nf_2(double a, double b, double c)", "ha": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Lissafin yankin wani kusurwar kusurwa idan aka ba shi bangarorinsa guda uku.\n *\n * @param a (double): Tsawon gefen 'a'.\n * @param b (double): Tsawon gefen 'b'.\n * @param c (double): Tsawon gefen 'c'.\n *\n * @return (double): Idan bangarorin da aka bayar sun kafa kusurwa, dawo da\n *                   yankin da aka lissafa wanda aka zagaye zuwa wurare 2 na goma.\n *                   In ba haka ba, dawo da -1 a matsayin alama.\n *\n * Misalin amfani:\n *     double area = f_2(3, 5, 4);\n *     assert(fabs(area - 6.00) < 1e-6); // Yankin ya kamata ya kusan zama 6\n */\nf_2(double a, double b, double c)", "hi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * दिए गए तीन भुजाओं के आधार पर त्रिभुज का क्षेत्रफल गणना करें।\n *\n * @param a (double): भुजा 'a' की लंबाई।\n * @param b (double): भुजा 'b' की लंबाई।\n * @param c (double): भुजा 'c' की लंबाई।\n *\n * @return (double): यदि दी गई भुजाएँ एक त्रिभुज बनाती हैं, तो गणना किया गया\n *                   क्षेत्रफल 2 दशमलव स्थानों तक गोल करके लौटाएं।\n *                   अन्यथा, संकेतक के रूप में -1 लौटाएं।\n *\n * उदाहरण उपयोग:\n *     double area = f_2(3, 5, 4);\n *     assert(fabs(area - 6.00) < 1e-6); // क्षेत्रफल लगभग 6 होना चाहिए\n */\nf_2(double a, double b, double c)", "hu": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Számítsa ki egy háromszög területét a három oldalának ismeretében.\n *\n * @param a (double): Az 'a' oldal hossza.\n * @param b (double): A 'b' oldal hossza.\n * @param c (double): A 'c' oldal hossza.\n *\n * @return (double): Ha a megadott oldalak háromszöget alkotnak, adja vissza a\n *                   kiszámított területet 2 tizedesjegyre kerekítve.\n *                   Ellenkező esetben adja vissza a -1 értéket jelzésként.\n *\n * Példa használat:\n *     double area = f_2(3, 5, 4);\n *     assert(fabs(area - 6.00) < 1e-6); // A területnek körülbelül 6-nak kell lennie\n */\nf_2(double a, double b, double c)", "es": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Calcular el área de un triángulo dados sus tres lados.\n *\n * @param a (double): Longitud del lado 'a'.\n * @param b (double): Longitud del lado 'b'.\n * @param c (double): Longitud del lado 'c'.\n *\n * @return (double): Si los lados proporcionados forman un triángulo, devuelve el\n *                   área calculada redondeada a 2 decimales.\n *                   De lo contrario, devuelve -1 como indicador.\n *\n * Ejemplo de uso:\n *     double area = f_2(3, 5, 4);\n *     assert(fabs(area - 6.00) < 1e-6); // El área debería ser aproximadamente 6\n */\nf_2(double a, double b, double c)", "arb": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * حساب مساحة المثلث المعطى أضلاعه الثلاثة.\n *\n * @param a (double): طول الضلع 'a'.\n * @param b (double): طول الضلع 'b'.\n * @param c (double): طول الضلع 'c'.\n *\n * @return (double): إذا كانت الأضلاع المقدمة تشكل مثلثًا، يتم إرجاع\n *                   المساحة المحسوبة مقربة إلى منزلتين عشريتين.\n *                   خلاف ذلك، يتم إرجاع -1 كمؤشر.\n *\n * مثال على الاستخدام:\n *     double area = f_2(3, 5, 4);\n *     assert(fabs(area - 6.00) < 1e-6); // يجب أن تكون المساحة تقريبًا 6\n */\nf_2(double a, double b, double c)", "sw": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Kuhesabu eneo la pembetatu ukizingatia pande zake tatu.\n *\n * @param a (double): Urefu wa upande 'a'.\n * @param b (double): Urefu wa upande 'b'.\n * @param c (double): Urefu wa upande 'c'.\n *\n * @return (double): Ikiwa pande zilizotolewa zinaunda pembetatu, rudisha\n *                   eneo lililohesabiwa likiwa limezungushwa hadi sehemu 2 za desimali.\n *                   Vinginevyo, rudisha -1 kama kiashiria.\n *\n * Mfano wa matumizi:\n *     double area = f_2(3, 5, 4);\n *     assert(fabs(area - 6.00) < 1e-6); // Eneo linapaswa kuwa takriban 6\n */\nf_2(double a, double b, double c)", "tr": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Üç kenarı verilen bir üçgenin alanını hesaplayın.\n *\n * @param a (double): 'a' kenarının uzunluğu.\n * @param b (double): 'b' kenarının uzunluğu.\n * @param c (double): 'c' kenarının uzunluğu.\n *\n * @return (double): Verilen kenarlar bir üçgen oluşturuyorsa,\n *                   hesaplanan alanı 2 ondalık basamağa yuvarlanmış\n *                   olarak döndürün. Aksi takdirde, bir gösterge olarak\n *                   -1 döndürün.\n *\n * Örnek kullanım:\n *     double area = f_2(3, 5, 4);\n *     assert(fabs(area - 6.00) < 1e-6); // Alan yaklaşık olarak 6 olmalıdır\n */\nf_2(double a, double b, double c)", "vi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Tính diện tích của một tam giác khi biết ba cạnh của nó.\n *\n * @param a (double): Độ dài của cạnh 'a'.\n * @param b (double): Độ dài của cạnh 'b'.\n * @param c (double): Độ dài của cạnh 'c'.\n *\n * @return (double): Nếu các cạnh được cung cấp tạo thành một tam giác, trả về\n *                   diện tích đã tính toán làm tròn đến 2 chữ số thập phân.\n *                   Nếu không, trả về -1 như một chỉ báo.\n *\n * Ví dụ sử dụng:\n *     double area = f_2(3, 5, 4);\n *     assert(fabs(area - 6.00) < 1e-6); // Diện tích nên xấp xỉ 6\n */\nf_2(double a, double b, double c)", "id": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Hitung luas segitiga yang diberikan tiga sisinya.\n *\n * @param a (double): Panjang sisi 'a'.\n * @param b (double): Panjang sisi 'b'.\n * @param c (double): Panjang sisi 'c'.\n *\n * @return (double): Jika sisi yang diberikan membentuk segitiga, kembalikan\n *                   luas yang dihitung dibulatkan ke 2 tempat desimal.\n *                   Jika tidak, kembalikan -1 sebagai indikator.\n *\n * Contoh penggunaan:\n *     double area = f_2(3, 5, 4);\n *     assert(fabs(area - 6.00) < 1e-6); // Luas seharusnya kira-kira 6\n */\nf_2(double a, double b, double c)", "ja": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * 三辺が与えられた三角形の面積を計算します。\n *\n * @param a (double): 辺 'a' の長さ。\n * @param b (double): 辺 'b' の長さ。\n * @param c (double): 辺 'c' の長さ。\n *\n * @return (double): 提供された辺が三角形を形成する場合、計算された面積を小数点以下2桁に丸めて返します。\n *                   そうでない場合は、指標として -1 を返します。\n *\n * 使用例:\n *     double area = f_2(3, 5, 4);\n *     assert(fabs(area - 6.00) < 1e-6); // 面積はおおよそ6であるべき\n */\nf_2(double a, double b, double c)", "ko": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * 주어진 세 변의 길이를 통해 삼각형의 넓이를 계산합니다.\n *\n * @param a (double): 변 'a'의 길이.\n * @param b (double): 변 'b'의 길이.\n * @param c (double): 변 'c'의 길이.\n *\n * @return (double): 제공된 변들이 삼각형을 형성하면,\n *                   계산된 넓이를 소수점 두 자리로 반올림하여 반환합니다.\n *                   그렇지 않으면, -1을 표시로 반환합니다.\n *\n * 사용 예:\n *     double area = f_2(3, 5, 4);\n *     assert(fabs(area - 6.00) < 1e-6); // 넓이는 대략 6이어야 합니다\n */\nf_2(double a, double b, double c)", "ml": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * ഒരു ത്രികോണത്തിന്റെ മൂന്നു വശങ്ങൾ നൽകിയാൽ അതിന്റെ വിസ്തീർണ്ണം കണക്കാക്കുക.\n *\n * @param a (double): വശം 'a'യുടെ നീളം.\n * @param b (double): വശം 'b'യുടെ നീളം.\n * @param c (double): വശം 'c'യുടെ നീളം.\n *\n * @return (double): നൽകിയ വശങ്ങൾ ഒരു ത്രികോണം രൂപീകരിക്കുന്നുവെങ്കിൽ,\n *                   കണക്കാക്കിയ വിസ്തീർണ്ണം 2 ദശാംശസ്ഥാനം വരെ വൃത്തമാക്കി മടക്കിക്കൊടുക്കുക.\n *                   അല്ലെങ്കിൽ, സൂചകമായി -1 മടക്കിക്കൊടുക്കുക.\n *\n * ഉദാഹരണ ഉപയോഗം:\n *     double area = f_2(3, 5, 4);\n *     assert(fabs(area - 6.00) < 1e-6); // വിസ്തീർണ്ണം ഏകദേശം 6 ആയിരിക്കണം\n */\nf_2(double a, double b, double c)", "fa": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * مساحت یک مثلث را با توجه به سه ضلع آن محاسبه کنید.\n *\n * @param a (double): طول ضلع 'a'.\n * @param b (double): طول ضلع 'b'.\n * @param c (double): طول ضلع 'c'.\n *\n * @return (double): اگر اضلاع داده شده یک مثلث را تشکیل دهند، مساحت\n *                   محاسبه شده را با گرد کردن به 2 رقم اعشار برمی‌گرداند.\n *                   در غیر این صورت، به عنوان نشانگر -1 را برمی‌گرداند.\n *\n * مثال استفاده:\n *     double area = f_2(3, 5, 4);\n *     assert(fabs(area - 6.00) < 1e-6); // مساحت باید تقریباً 6 باشد\n */\nf_2(double a, double b, double c)"}, "canonical_solution": "{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        return -1; // Special value to indicate it's not a triangle\n    }\n}", "instruction": {"en": "Write a CPP function `f_2(double a, double b, double c)` to solve the following problem:\nCalculate the area of a triangle given its three sides.\n\n@param a (double): Length of side 'a'.\n@param b (double): Length of side 'b'.\n@param c (double): Length of side 'c'.\n\n@return (double): If the provided sides form a triangle, return the calculated area rounded to 2 decimal places. Otherwise, return -1 as an indicator.\n\nExample usage:\n    double area = f_2(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // Area should be approximately 6", "sq": "Shkruani një funksion CPP `f_2(double a, double b, double c)` për të zgjidhur problemin në vijim:\nLlogaritni sipërfaqen e një trekëndëshi duke pasur parasysh tre anët e tij.\n\n@param a (double): Gjatësia e anës 'a'.\n@param b (double): Gjatësia e anës 'b'.\n@param c (double): Gjatësia e anës 'c'.\n\n@return (double): Nëse anët e dhëna formojnë një trekëndësh, kthejeni sipërfaqen e llogaritur të rrumbullakosur në 2 vende dhjetore. Përndryshe, kthejeni -1 si një tregues.\n\nShembull përdorimi:\n    double area = f_2(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // Sipërfaqja duhet të jetë afërsisht 6", "hy": "Գրեք CPP ֆունկցիա `f_2(double a, double b, double c)` հետևյալ խնդիրը լուծելու համար:\nՀաշվեք եռանկյան մակերեսը՝ հաշվի առնելով նրա երեք կողմերը:\n\n@param a (double): Կողմ 'a'-ի երկարությունը։\n@param b (double): Կողմ 'b'-ի երկարությունը։\n@param c (double): Կողմ 'c'-ի երկարությունը։\n\n@return (double): Եթե տրված կողմերը կազմում են եռանկյուն, վերադարձնել հաշվարկված մակերեսը՝ կլորացված մինչև 2 տասնորդական նշան։ Հակառակ դեպքում, վերադարձնել -1 որպես ցուցիչ։\n\nՕրինակ օգտագործում:\n    double area = f_2(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // Մակերեսը պետք է մոտ լինի 6", "bn": "একটি CPP ফাংশন `f_2(double a, double b, double c)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি ত্রিভুজের তিনটি বাহু দেওয়া থাকলে তার ক্ষেত্রফল গণনা করুন।\n\n@param a (double): বাহু 'a' এর দৈর্ঘ্য।\n@param b (double): বাহু 'b' এর দৈর্ঘ্য।\n@param c (double): বাহু 'c' এর দৈর্ঘ্য।\n\n@return (double): যদি প্রদত্ত বাহুগুলি একটি ত্রিভুজ গঠন করে, তবে গণনা করা ক্ষেত্রফল 2 দশমিক স্থানে রাউন্ড করে ফেরত দিন। অন্যথায়, নির্দেশক হিসাবে -1 ফেরত দিন।\n\nউদাহরণ ব্যবহার:\n    double area = f_2(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // ক্ষেত্রফল আনুমানিক 6 হওয়া উচিত", "bg": "Напишете CPP функция `f_2(double a, double b, double c)`, за да решите следния проблем:  \nИзчислете площта на триъгълник, като са дадени трите му страни.\n\n@param a (double): Дължина на страна 'a'.  \n@param b (double): Дължина на страна 'b'.  \n@param c (double): Дължина на страна 'c'.  \n\n@return (double): Ако предоставените страни образуват триъгълник, върнете изчислената площ закръглена до 2 знака след десетичната запетая. В противен случай върнете -1 като индикатор.\n\nПример за използване:  \n    double area = f_2(3, 5, 4);  \n    assert(fabs(area - 6.00) < 1e-6); // Площта трябва да бъде приблизително 6", "zh": "编写一个 CPP 函数 `f_2(double a, double b, double c)` 来解决以下问题：\n计算给定三边的三角形面积。\n\n@param a (double): 边 'a' 的长度。\n@param b (double): 边 'b' 的长度。\n@param c (double): 边 'c' 的长度。\n\n@return (double): 如果提供的边能构成一个三角形，返回计算出的面积，保留两位小数。否则，返回 -1 作为指示。\n\n示例用法：\n    double area = f_2(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // 面积应约为 6", "fr": "Écrire une fonction CPP `f_2(double a, double b, double c)` pour résoudre le problème suivant :\nCalculer l'aire d'un triangle donné ses trois côtés.\n\n@param a (double): Longueur du côté 'a'.\n@param b (double): Longueur du côté 'b'.\n@param c (double): Longueur du côté 'c'.\n\n@return (double): Si les côtés fournis forment un triangle, retourner l'aire calculée arrondie à 2 décimales. Sinon, retourner -1 comme indicateur.\n\nExemple d'utilisation :\n    double area = f_2(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // L'aire devrait être approximativement 6", "de": "Schreiben Sie eine CPP-Funktion `f_2(double a, double b, double c)`, um das folgende Problem zu lösen:\nBerechnen Sie die Fläche eines Dreiecks, gegeben seine drei Seiten.\n\n@param a (double): Länge der Seite 'a'.\n@param b (double): Länge der Seite 'b'.\n@param c (double): Länge der Seite 'c'.\n\n@return (double): Wenn die angegebenen Seiten ein Dreieck bilden, geben Sie die berechnete Fläche gerundet auf 2 Dezimalstellen zurück. Andernfalls geben Sie -1 als Indikator zurück.\n\nBeispielverwendung:\n    double area = f_2(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // Die Fläche sollte ungefähr 6 sein", "ha": "Rubuta aikin CPP `f_2(double a, double b, double c)` don warware matsalar mai zuwa:\nƘididdige yanki na alwatika da aka ba shi ta gefen sa guda uku.\n\n@param a (double): Tsawon gefen 'a'.\n@param b (double): Tsawon gefen 'b'.\n@param c (double): Tsawon gefen 'c'.\n\n@return (double): Idan gefen da aka bayar sun samar da alwatika, dawo da yankin da aka ƙididdige wanda aka zagaye zuwa wurare 2 na goma. In ba haka ba, dawo da -1 a matsayin alamar.\n\nMisalin amfani:\n    double area = f_2(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // Yankin yakamata ya zama kusan 6", "hi": "एक CPP फ़ंक्शन `f_2(double a, double b, double c)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए तीन भुजाओं के आधार पर एक त्रिभुज का क्षेत्रफल ज्ञात करें।\n\n@param a (double): भुजा 'a' की लंबाई।\n@param b (double): भुजा 'b' की लंबाई।\n@param c (double): भुजा 'c' की लंबाई।\n\n@return (double): यदि दी गई भुजाएँ एक त्रिभुज बनाती हैं, तो गणना किया गया क्षेत्रफल 2 दशमलव स्थानों तक गोल कर लौटाएँ। अन्यथा, संकेतक के रूप में -1 लौटाएँ।\n\nउदाहरण उपयोग:\n    double area = f_2(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // क्षेत्रफल लगभग 6 होना चाहिए", "hu": "Írj egy CPP függvényt `f_2(double a, double b, double c)` a következő probléma megoldására:\nSzámítsd ki egy háromszög területét a három oldalának ismeretében.\n\n@param a (double): Az 'a' oldal hossza.\n@param b (double): A 'b' oldal hossza.\n@param c (double): A 'c' oldal hossza.\n\n@return (double): Ha a megadott oldalak háromszöget alkotnak, térj vissza a kiszámított területtel, 2 tizedesjegyre kerekítve. Ellenkező esetben térj vissza -1 értékkel, mint jelző.\n\nPélda használat:\n    double area = f_2(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // A területnek körülbelül 6-nak kell lennie", "es": "Escribe una función CPP `f_2(double a, double b, double c)` para resolver el siguiente problema:\nCalcular el área de un triángulo dados sus tres lados.\n\n@param a (double): Longitud del lado 'a'.\n@param b (double): Longitud del lado 'b'.\n@param c (double): Longitud del lado 'c'.\n\n@return (double): Si los lados proporcionados forman un triángulo, devuelve el área calculada redondeada a 2 decimales. De lo contrario, devuelve -1 como indicador.\n\nEjemplo de uso:\n    double area = f_2(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // El área debería ser aproximadamente 6", "arb": "اكتب دالة CPP `f_2(double a, double b, double c)` لحل المشكلة التالية:\nاحسب مساحة مثلث معطى أضلاعه الثلاثة.\n\n@param a (double): طول الضلع 'a'.\n@param b (double): طول الضلع 'b'.\n@param c (double): طول الضلع 'c'.\n\n@return (double): إذا كانت الأضلاع المعطاة تشكل مثلثًا، أعد المساحة المحسوبة مقربة إلى منزلتين عشريتين. خلاف ذلك، أعد -1 كمؤشر.\n\nمثال على الاستخدام:\n    double area = f_2(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // يجب أن تكون المساحة تقريبًا 6", "sw": "Andika kazi ya CPP `f_2(double a, double b, double c)` kutatua tatizo lifuatalo:\nHesabu eneo la pembetatu ukizingatia pande zake tatu.\n\n@param a (double): Urefu wa upande 'a'.\n@param b (double): Urefu wa upande 'b'.\n@param c (double): Urefu wa upande 'c'.\n\n@return (double): Ikiwa pande zilizotolewa zinaunda pembetatu, rudisha eneo lililohesabiwa lililokaribia hadi sehemu 2 za desimali. Vinginevyo, rudisha -1 kama kiashiria.\n\nMfano wa matumizi:\n    double area = f_2(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // Eneo linapaswa kuwa takriban 6", "tr": "Bir CPP fonksiyonu `f_2(double a, double b, double c)` yazın ve aşağıdaki problemi çözün:\nÜç kenarı verilen bir üçgenin alanını hesaplayın.\n\n@param a (double): 'a' kenarının uzunluğu.\n@param b (double): 'b' kenarının uzunluğu.\n@param c (double): 'c' kenarının uzunluğu.\n\n@return (double): Eğer verilen kenarlar bir üçgen oluşturuyorsa, hesaplanan alanı 2 ondalık basamağa yuvarlanmış olarak döndürün. Aksi takdirde, bir gösterge olarak -1 döndürün.\n\nÖrnek kullanım:\n    double area = f_2(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // Alan yaklaşık olarak 6 olmalıdır.", "vi": "Viết một hàm CPP `f_2(double a, double b, double c)` để giải quyết vấn đề sau:\nTính diện tích của một tam giác khi biết ba cạnh của nó.\n\n@param a (double): Độ dài của cạnh 'a'.\n@param b (double): Độ dài của cạnh 'b'.\n@param c (double): Độ dài của cạnh 'c'.\n\n@return (double): Nếu các cạnh được cung cấp tạo thành một tam giác, trả về diện tích đã tính được làm tròn đến 2 chữ số thập phân. Nếu không, trả về -1 để chỉ thị.\n\nVí dụ sử dụng:\n    double area = f_2(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // Diện tích nên xấp xỉ 6", "id": "Tulis fungsi CPP `f_2(double a, double b, double c)` untuk menyelesaikan masalah berikut:\nHitung luas segitiga yang diberikan tiga sisinya.\n\n@param a (double): Panjang sisi 'a'.\n@param b (double): Panjang sisi 'b'.\n@param c (double): Panjang sisi 'c'.\n\n@return (double): Jika sisi yang diberikan membentuk segitiga, kembalikan luas yang dihitung dibulatkan ke 2 tempat desimal. Jika tidak, kembalikan -1 sebagai indikator.\n\nContoh penggunaan:\n    double area = f_2(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // Luas seharusnya kira-kira 6", "ja": "CPP関数 `f_2(double a, double b, double c)` を作成して、次の問題を解決してください:\n与えられた3辺から三角形の面積を計算します。\n\n@param a (double): 辺 'a' の長さ。\n@param b (double): 辺 'b' の長さ。\n@param c (double): 辺 'c' の長さ。\n\n@return (double): 指定された辺が三角形を形成する場合、計算された面積を小数点以下2桁に丸めて返します。それ以外の場合は、指標として-1を返します。\n\n使用例:\n    double area = f_2(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // 面積は約6であるべきです。", "ko": "CPP 함수 `f_2(double a, double b, double c)`를 작성하여 다음 문제를 해결하십시오:\n주어진 세 변을 통해 삼각형의 면적을 계산하십시오.\n\n@param a (double): 변 'a'의 길이.\n@param b (double): 변 'b'의 길이.\n@param c (double): 변 'c'의 길이.\n\n@return (double): 제공된 변들이 삼각형을 형성하면, 계산된 면적을 소수점 두 자리로 반올림하여 반환합니다. 그렇지 않으면, -1을 표시기로 반환합니다.\n\n사용 예:\n    double area = f_2(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // 면적은 대략 6이어야 합니다.", "ml": "CPP ഫംഗ്ഷൻ `f_2(double a, double b, double c)` എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nതന്റെ മൂന്നു വശങ്ങൾ നൽകിയിരിക്കുന്ന ഒരു ത്രികോണത്തിന്റെ വിസ്തീർണം കണക്കാക്കുക.\n\n@param a (double): വശം 'a'യുടെ നീളം.\n@param b (double): വശം 'b'യുടെ നീളം.\n@param c (double): വശം 'c'യുടെ നീളം.\n\n@return (double): നൽകിയിരിക്കുന്ന വശങ്ങൾ ഒരു ത്രികോണം രൂപീകരിക്കുന്നുവെങ്കിൽ, കണക്കാക്കിയ വിസ്തീർണം 2 ദശാംശസ്ഥാനം വരെ വട്ടമിട്ട് മടക്കുക. അല്ലെങ്കിൽ, സൂചകമായി -1 മടക്കുക.\n\nഉദാഹരണ ഉപയോഗം:\n    double area = f_2(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // വിസ്തീർണം ഏകദേശം 6 ആയിരിക്കണം", "fa": "یک تابع CPP `f_2(double a, double b, double c)` بنویسید تا مسئله زیر را حل کند:\nمساحت یک مثلث را با توجه به سه ضلع آن محاسبه کنید.\n\n@param a (double): طول ضلع 'a'.\n@param b (double): طول ضلع 'b'.\n@param c (double): طول ضلع 'c'.\n\n@return (double): اگر اضلاع داده شده یک مثلث را تشکیل دهند، مساحت محاسبه شده را با گرد کردن به 2 رقم اعشار برگردانید. در غیر این صورت، -1 را به عنوان نشانگر برگردانید.\n\nمثال استفاده:\n    double area = f_2(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // مساحت باید تقریباً 6 باشد"}, "level": "easy", "test": "int main() {\n    // Test cases for the f_2 function\n    assert(fabs(f_2(3, 5, 4) - 6.00) < 1e-6); // Expected area is 6\n    assert(f_2(1, 1, 4) == -1);  // Not a triangle, should return -1\n    assert(fabs(f_2(7, 24, 25) - 84.00) < 1e-6); // Expected area is 84\n    assert(fabs(f_2(10.5, 6.2, 7.3) - 22.15) < 1e-2); // Expected area is approx 22.15\n\n    // All tests passed\n    \n    return 0;\n}", "entry_point": "f_2", "signature": "f_2(double a, double b, double c)", "docstring": {"en": "Calculate the area of a triangle given its three sides.\n\n@param a (double): Length of side 'a'.\n@param b (double): Length of side 'b'.\n@param c (double): Length of side 'c'.\n\n@return (double): If the provided sides form a triangle, return the calculated area rounded to 2 decimal places. Otherwise, return -1 as an indicator.\n\nExample usage:\n    double area = f_2(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // Area should be approximately 6", "sq": "Llogarit sipërfaqen e një trekëndëshi duke pasur parasysh tre anët e tij.\n\n@param a (double): Gjatësia e anës 'a'.\n@param b (double): Gjatësia e anës 'b'.\n@param c (double): Gjatësia e anës 'c'.\n\n@return (double): Nëse anët e dhëna formojnë një trekëndësh, kthen sipërfaqen e llogaritur të rrumbullakosur në 2 shifra dhjetore. Përndryshe, kthen -1 si një tregues.\n\nShembull përdorimi:\n    double area = f_2(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // Sipërfaqja duhet të jetë afërsisht 6", "hy": "Հաշվել եռանկյան մակերեսը՝ հաշվի առնելով նրա երեք կողմերը։\n\n@param a (double): Կողմ 'a'-ի երկարությունը։\n@param b (double): Կողմ 'b'-ի երկարությունը։\n@param c (double): Կողմ 'c'-ի երկարությունը։\n\n@return (double): Եթե տրված կողմերը կազմում են եռանկյուն, վերադարձնել հաշվարկված մակերեսը՝ կլորացված մինչև 2 տասնորդական։ Հակառակ դեպքում, վերադարձնել -1 որպես ցուցիչ։\n\nՕրինակ օգտագործում:\n    double area = f_2(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // Մակերեսը պետք է մոտավորապես լինի 6", "bn": "একটি ত্রিভুজের তিনটি বাহু দেওয়া থাকলে তার ক্ষেত্রফল গণনা করুন।\n\n@param a (double): বাহু 'a' এর দৈর্ঘ্য।\n@param b (double): বাহু 'b' এর দৈর্ঘ্য।\n@param c (double): বাহু 'c' এর দৈর্ঘ্য।\n\n@return (double): যদি প্রদত্ত বাহুগুলি একটি ত্রিভুজ গঠন করে, তবে 2 দশমিক স্থান পর্যন্ত গোলাকার গণনা করা ক্ষেত্রফল প্রদান করুন। অন্যথায়, সূচক হিসাবে -1 প্রদান করুন।\n\nব্যবহারের উদাহরণ:\n    double area = f_2(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // ক্ষেত্রফল আনুমানিক 6 হওয়া উচিত", "bg": "Изчислява площта на триъгълник, дадени неговите три страни.\n\n@param a (double): Дължина на страна 'a'.\n@param b (double): Дължина на страна 'b'.\n@param c (double): Дължина на страна 'c'.\n\n@return (double): Ако предоставените страни образуват триъгълник, връща изчислената площ, закръглена до 2 знака след десетичната запетая. В противен случай връща -1 като индикатор.\n\nПример за използване:\n    double area = f_2(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // Площта трябва да бъде приблизително 6", "zh": "计算给定三边的三角形面积。\n\n@param a (double): 边 'a' 的长度。\n@param b (double): 边 'b' 的长度。\n@param c (double): 边 'c' 的长度。\n\n@return (double): 如果提供的边长可以构成一个三角形，返回计算出的面积并四舍五入到小数点后两位。否则，返回 -1 作为指示。\n\n示例用法:\n    double area = f_2(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // 面积应大约为 6", "fr": "Calculer l'aire d'un triangle donné ses trois côtés.\n\n@param a (double): Longueur du côté 'a'.\n@param b (double): Longueur du côté 'b'.\n@param c (double): Longueur du côté 'c'.\n\n@return (double): Si les côtés fournis forment un triangle, retourner l'aire calculée arrondie à 2 décimales. Sinon, retourner -1 comme indicateur.\n\nExemple d'utilisation :\n    double area = f_2(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // L'aire devrait être approximativement 6", "de": "Berechnen Sie die Fläche eines Dreiecks, gegeben durch seine drei Seiten.\n\n@param a (double): Länge der Seite 'a'.\n@param b (double): Länge der Seite 'b'.\n@param c (double): Länge der Seite 'c'.\n\n@return (double): Wenn die angegebenen Seiten ein Dreieck bilden, geben Sie die berechnete Fläche auf 2 Dezimalstellen gerundet zurück. Andernfalls geben Sie -1 als Indikator zurück.\n\nBeispielverwendung:\n    double area = f_2(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // Die Fläche sollte ungefähr 6 betragen", "ha": "Lissafin yankin wani kusurwar kusurwa idan aka ba shi bangarorinsa guda uku.\n\n@param a (double): Tsawon gefen 'a'.\n@param b (double): Tsawon gefen 'b'.\n@param c (double): Tsawon gefen 'c'.\n\n@return (double): Idan gefen da aka bayar sun ƙirƙiri alwatika, dawo da yankin da aka lissafa wanda aka zagaye zuwa wurare 2 na adadi. In ba haka ba, dawo da -1 a matsayin alamar.\n\nExample usage:\n    double area = f_2(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // Ya kamata yankin ya kasance kusan 6", "hi": "त्रिभुज के तीन भुजाओं के आधार पर उसका क्षेत्रफल गणना करें।\n\n@param a (double): भुजा 'a' की लंबाई।\n@param b (double): भुजा 'b' की लंबाई।\n@param c (double): भुजा 'c' की लंबाई।\n\n@return (double): यदि दी गई भुजाएँ एक त्रिभुज बनाती हैं, तो गणना किया गया क्षेत्रफल 2 दशमलव स्थानों तक गोल कर लौटाएं। अन्यथा, संकेतक के रूप में -1 लौटाएं।\n\nउदाहरण उपयोग:\n    double area = f_2(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // क्षेत्रफल लगभग 6 होना चाहिए", "hu": "Számítsa ki egy háromszög területét a három oldalának ismeretében.\n\n@param a (double): Az 'a' oldal hossza.\n@param b (double): A 'b' oldal hossza.\n@param c (double): A 'c' oldal hossza.\n\n@return (double): Ha a megadott oldalak háromszöget alkotnak, adja vissza a kiszámított területet 2 tizedesjegyre kerekítve. Ellenkező esetben adja vissza a -1 értéket jelzésként.\n\nPélda használat:\n    double area = f_2(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // A területnek körülbelül 6-nak kell lennie", "es": "Calcular el área de un triángulo dados sus tres lados.\n\n@param a (double): Longitud del lado 'a'.\n@param b (double): Longitud del lado 'b'.\n@param c (double): Longitud del lado 'c'.\n\n@return (double): Si los lados proporcionados forman un triángulo, devuelve el área calculada redondeada a 2 decimales. De lo contrario, devuelve -1 como indicador.\n\nEjemplo de uso:\n    double area = f_2(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // El área debería ser aproximadamente 6", "arb": "حساب مساحة مثلث معطى أضلاعه الثلاثة.\n\n@param a (double): طول الضلع 'a'.\n@param b (double): طول الضلع 'b'.\n@param c (double): طول الضلع 'c'.\n\n@return (double): إذا كانت الأضلاع المعطاة تشكل مثلثًا، يتم إرجاع المساحة المحسوبة مقربة إلى منزلتين عشريتين. خلاف ذلك، يتم إرجاع -1 كمؤشر.\n\nمثال على الاستخدام:\n    double area = f_2(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // يجب أن تكون المساحة تقريبًا 6", "sw": "Hesabu eneo la pembetatu ukizingatia pande zake tatu.\n\n@param a (double): Urefu wa upande 'a'.\n@param b (double): Urefu wa upande 'b'.\n@param c (double): Urefu wa upande 'c'.\n\n@return (double): Ikiwa pande zilizotolewa zinaunda pembetatu, rudisha eneo lililohesabiwa likiwa limezungushwa hadi sehemu 2 za desimali. Vinginevyo, rudisha -1 kama kiashiria.\n\nMfano wa matumizi:\n    double area = f_2(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // Eneo linapaswa kuwa takriban 6", "tr": "Üç kenarı verilen bir üçgenin alanını hesaplayın.\n\n@param a (double): 'a' kenarının uzunluğu.\n@param b (double): 'b' kenarının uzunluğu.\n@param c (double): 'c' kenarının uzunluğu.\n\n@return (double): Verilen kenarlar bir üçgen oluşturuyorsa, hesaplanan alanı 2 ondalık basamağa yuvarlanmış olarak döndürün. Aksi takdirde, bir gösterge olarak -1 döndürün.\n\nÖrnek kullanım:\n    double area = f_2(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // Alan yaklaşık olarak 6 olmalıdır.", "vi": "Tính diện tích của một tam giác khi biết độ dài ba cạnh của nó.\n\n@param a (double): Độ dài của cạnh 'a'.\n@param b (double): Độ dài của cạnh 'b'.\n@param c (double): Độ dài của cạnh 'c'.\n\n@return (double): Nếu các cạnh được cung cấp tạo thành một tam giác, trả về diện tích đã tính toán được làm tròn đến 2 chữ số thập phân. Nếu không, trả về -1 để chỉ báo.\n\nVí dụ sử dụng:\n    double area = f_2(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // Diện tích nên xấp xỉ 6", "id": "Hitung luas segitiga berdasarkan tiga sisinya.\n\n@param a (double): Panjang sisi 'a'.\n@param b (double): Panjang sisi 'b'.\n@param c (double): Panjang sisi 'c'.\n\n@return (double): Jika sisi-sisi yang diberikan membentuk segitiga, kembalikan luas yang dihitung dibulatkan ke 2 tempat desimal. Jika tidak, kembalikan -1 sebagai indikator.\n\nContoh penggunaan:\n    double area = f_2(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // Luas seharusnya sekitar 6", "ja": "三辺が与えられた三角形の面積を計算します。\n\n@param a (double): 辺 'a' の長さ。\n@param b (double): 辺 'b' の長さ。\n@param c (double): 辺 'c' の長さ。\n\n@return (double): 提供された辺が三角形を形成する場合、計算された面積を小数点以下2桁に丸めて返します。それ以外の場合は、指標として -1 を返します。\n\n使用例:\n    double area = f_2(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // 面積は約6であるべきです。", "ko": "삼각형의 세 변이 주어졌을 때, 삼각형의 면적을 계산합니다.\n\n@param a (double): 변 'a'의 길이.\n@param b (double): 변 'b'의 길이.\n@param c (double): 변 'c'의 길이.\n\n@return (double): 주어진 변들이 삼각형을 형성하면, 계산된 면적을 소수점 두 자리로 반올림하여 반환합니다. 그렇지 않으면, -1을 지표로 반환합니다.\n\n사용 예:\n    double area = f_2(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // 면적은 대략 6이어야 합니다.", "ml": "ത്രികോണമിതിയുടെ മൂന്ന് വശങ്ങൾ നൽകിയാൽ, അതിന്റെ വിസ്തീർണ്ണം കണക്കാക്കുക.\n\n@param a (double): വശം 'a'യുടെ നീളം.\n@param b (double): വശം 'b'യുടെ നീളം.\n@param c (double): വശം 'c'യുടെ നീളം.\n\n@return (double): നൽകിയ വശങ്ങൾ ത്രികോണം രൂപീകരിക്കുന്നുവെങ്കിൽ, കണക്കാക്കിയ വിസ്തീർണ്ണം 2 ദശാംശസ്ഥാനം വരെ വൃത്താകൃതിയിലുള്ളതായിരിക്കും. അല്ലാത്തപക്ഷം, സൂചകമായി -1 മടക്കുക.\n\nഉദാഹരണ ഉപയോഗം:\n    double area = f_2(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // വിസ്തീർണ്ണം ഏകദേശം 6 ആയിരിക്കണം", "fa": "محاسبه مساحت یک مثلث با توجه به سه ضلع آن.\n\n@param a (double): طول ضلع 'a'.\n@param b (double): طول ضلع 'b'.\n@param c (double): طول ضلع 'c'.\n\n@return (double): اگر اضلاع داده شده یک مثلث را تشکیل دهند، مساحت محاسبه شده را با گرد کردن به 2 رقم اعشار برمی‌گرداند. در غیر این صورت، -1 را به عنوان نشانگر برمی‌گرداند.\n\nمثال استفاده:\n    double area = f_2(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // مساحت باید تقریباً 6 باشد"}}
{"task_id": "CPP/3", "prompt": {"en": "#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <string>\n/**\n * Calculate the value of the function for a given input.\n * Parameters:\n * - x (int): Input value for the function.\n * Returns:\n * - std::string: If x is not in the defined domain, returns \"Not define\".\n *   Otherwise, returns the calculated function value rounded to 5 decimal places.\n *\n * Function Definitions:\n * - For 0 <= x < 10: y = cos(x + 3.0)\n * - For 10 <= x < 20: y = (cos(x + 7.5))^2\n * - For 20 <= x < 30: y = (cos(x + 4.0))^4\n * Example:\n *   f_3(40) returns \"Not define\"\n */\nstd::string f_3(int x)", "sq": "#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <string>\n/**\n * Llogarit vlerën e funksionit për një hyrje të dhënë.\n * Parametra:\n * - x (int): Vlera e hyrjes për funksionin.\n * Kthen:\n * - std::string: Nëse x nuk është në domenin e përcaktuar, kthen \"Not define\".\n *   Përndryshe, kthen vlerën e llogaritur të funksionit të rrumbullakosur në 5 shifra dhjetore.\n *\n * Përkufizimet e Funksionit:\n * - Për 0 <= x < 10: y = cos(x + 3.0)\n * - Për 10 <= x < 20: y = (cos(x + 7.5))^2\n * - Për 20 <= x < 30: y = (cos(x + 4.0))^4\n * Shembull:\n *   f_3(40) kthen \"Not define\"\n */\nstd::string f_3(int x)", "hy": "#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <string>\n/**\n * Հաշվել ֆունկցիայի արժեքը տրված մուտքի համար։\n * Պարամետրեր:\n * - x (int): Մուտքային արժեք ֆունկցիայի համար։\n * Վերադարձնում է:\n * - std::string: Եթե x-ը սահմանված տիրույթում չէ, վերադարձնում է \"Not define\"։\n *   Հակառակ դեպքում, վերադարձնում է հաշվարկված ֆունկցիայի արժեքը կլորացված մինչև 5 տասնորդական նիշ։\n *\n * Ֆունկցիայի սահմանումներ:\n * - 0 <= x < 10: y = cos(x + 3.0)\n * - 10 <= x < 20: y = (cos(x + 7.5))^2\n * - 20 <= x < 30: y = (cos(x + 4.0))^4\n * Օրինակ:\n *   f_3(40) վերադարձնում է \"Not define\"\n */\nstd::string f_3(int x)", "bn": "#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <string>\n/**\n * প্রদত্ত ইনপুটের জন্য ফাংশনের মান গণনা করুন।\n * প্যারামিটার:\n * - x (int): ফাংশনের জন্য ইনপুট মান।\n * রিটার্নস:\n * - std::string: যদি x সংজ্ঞায়িত ডোমেইনে না থাকে, \"Not define\" রিটার্ন করে।\n *   অন্যথায়, গণনা করা ফাংশনের মান 5 দশমিক স্থানে রাউন্ড করে রিটার্ন করে।\n *\n * ফাংশন সংজ্ঞা:\n * - 0 <= x < 10 এর জন্য: y = cos(x + 3.0)\n * - 10 <= x < 20 এর জন্য: y = (cos(x + 7.5))^2\n * - 20 <= x < 30 এর জন্য: y = (cos(x + 4.0))^4\n * উদাহরণ:\n *   f_3(40) \"Not define\" রিটার্ন করে\n */\nstd::string f_3(int x)", "bg": "#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <string>\n/**\n * Изчислява стойността на функцията за даден вход.\n * Параметри:\n * - x (int): Входна стойност за функцията.\n * Връща:\n * - std::string: Ако x не е в определения домейн, връща \"Not define\".\n *   В противен случай, връща изчислената стойност на функцията, закръглена до 5 десетични знака.\n *\n * Дефиниции на функцията:\n * - За 0 <= x < 10: y = cos(x + 3.0)\n * - За 10 <= x < 20: y = (cos(x + 7.5))^2\n * - За 20 <= x < 30: y = (cos(x + 4.0))^4\n * Пример:\n *   f_3(40) връща \"Not define\"\n */\nstd::string f_3(int x)", "zh": "#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <string>\n/**\n * 计算给定输入的函数值。\n * 参数：\n * - x (int): 函数的输入值。\n * 返回：\n * - std::string: 如果 x 不在定义域内，返回 \"Not define\"。\n *   否则，返回计算后的函数值，四舍五入到小数点后5位。\n *\n * 函数定义：\n * - 对于 0 <= x < 10: y = cos(x + 3.0)\n * - 对于 10 <= x < 20: y = (cos(x + 7.5))^2\n * - 对于 20 <= x < 30: y = (cos(x + 4.0))^4\n * 示例：\n *   f_3(40) 返回 \"Not define\"\n */\nstd::string f_3(int x)", "fr": "#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <string>\n/**\n * Calculer la valeur de la fonction pour une entrée donnée.\n * Paramètres:\n * - x (int): Valeur d'entrée pour la fonction.\n * Renvoie:\n * - std::string: Si x n'est pas dans le domaine défini, renvoie \"Not define\".\n *   Sinon, renvoie la valeur calculée de la fonction arrondie à 5 décimales.\n *\n * Définitions de la fonction:\n * - Pour 0 <= x < 10: y = cos(x + 3.0)\n * - Pour 10 <= x < 20: y = (cos(x + 7.5))^2\n * - Pour 20 <= x < 30: y = (cos(x + 4.0))^4\n * Exemple:\n *   f_3(40) returns \"Not define\"\n */\nstd::string f_3(int x)", "de": "#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <string>\n/**\n * Berechnet den Wert der Funktion für eine gegebene Eingabe.\n * Parameter:\n * - x (int): Eingabewert für die Funktion.\n * Rückgabewert:\n * - std::string: Wenn x nicht im definierten Bereich liegt, wird \"Not define\" zurückgegeben.\n *   Andernfalls wird der berechnete Funktionswert auf 5 Dezimalstellen gerundet zurückgegeben.\n *\n * Funktionsdefinitionen:\n * - Für 0 <= x < 10: y = cos(x + 3.0)\n * - Für 10 <= x < 20: y = (cos(x + 7.5))^2\n * - Für 20 <= x < 30: y = (cos(x + 4.0))^4\n * Beispiel:\n *   f_3(40) gibt \"Not define\" zurück\n */\nstd::string f_3(int x)", "ha": "#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <string>\n/**\n * Lissafa ƙimar aikin don wani shigarwa da aka bayar.\n * Sigogi:\n * - x (int): Ƙimar shigarwa don aikin.\n * Komawa:\n * - std::string: Idan x ba ya cikin yankin da aka ayyana, yana mayar da \"Not define\".\n *   In ba haka ba, yana mayar da ƙimar aikin da aka lissafa an zagaye zuwa wurare 5 na ɗigo.\n *\n * Ma'anar Aiki:\n * - Don 0 <= x < 10: y = cos(x + 3.0)\n * - Don 10 <= x < 20: y = (cos(x + 7.5))^2\n * - Don 20 <= x < 30: y = (cos(x + 4.0))^4\n * Misali:\n *   f_3(40) yana mayar da \"Not define\"\n */\nstd::string f_3(int x)", "hi": "#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <string>\n/**\n * दिए गए इनपुट के लिए फ़ंक्शन का मान गणना करें।\n * पैरामीटर्स:\n * - x (int): फ़ंक्शन के लिए इनपुट मान।\n * रिटर्न करता है:\n * - std::string: यदि x परिभाषित डोमेन में नहीं है, तो \"Not define\" लौटाता है।\n *   अन्यथा, गणना किए गए फ़ंक्शन मान को 5 दशमलव स्थानों तक राउंड करके लौटाता है।\n *\n * फ़ंक्शन परिभाषाएँ:\n * - 0 <= x < 10 के लिए: y = cos(x + 3.0)\n * - 10 <= x < 20 के लिए: y = (cos(x + 7.5))^2\n * - 20 <= x < 30 के लिए: y = (cos(x + 4.0))^4\n * उदाहरण:\n *   f_3(40) \"Not define\" लौटाता है\n */\nstd::string f_3(int x)", "hu": "#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <string>\n/**\n * Számítsa ki a függvény értékét egy adott bemenetre.\n * Paraméterek:\n * - x (int): A függvény bemeneti értéke.\n * Visszatér:\n * - std::string: Ha x nincs a meghatározott tartományban, \"Not define\" értéket ad vissza.\n *   Egyébként visszaadja a kiszámított függvényértéket 5 tizedesjegyre kerekítve.\n *\n * Függvénydefiníciók:\n * - Ha 0 <= x < 10: y = cos(x + 3.0)\n * - Ha 10 <= x < 20: y = (cos(x + 7.5))^2\n * - Ha 20 <= x < 30: y = (cos(x + 4.0))^4\n * Példa:\n *   f_3(40) visszaadja \"Not define\"\n */\nstd::string f_3(int x)", "es": "#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <string>\n/**\n * Calcula el valor de la función para una entrada dada.\n * Parámetros:\n * - x (int): Valor de entrada para la función.\n * Retorna:\n * - std::string: Si x no está en el dominio definido, retorna \"Not define\".\n *   De lo contrario, retorna el valor calculado de la función redondeado a 5 decimales.\n *\n * Definiciones de la función:\n * - Para 0 <= x < 10: y = cos(x + 3.0)\n * - Para 10 <= x < 20: y = (cos(x + 7.5))^2\n * - Para 20 <= x < 30: y = (cos(x + 4.0))^4\n * Ejemplo:\n *   f_3(40) devuelve \"Not define\"\n */\nstd::string f_3(int x)", "arb": "#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <string>\n/**\n * حساب قيمة الدالة لمدخل معين.\n * المعاملات:\n * - x (int): قيمة المدخل للدالة.\n * يعيد:\n * - std::string: إذا لم يكن x في النطاق المحدد، يعيد \"Not define\".\n *   خلاف ذلك، يعيد قيمة الدالة المحسوبة مقربة إلى 5 منازل عشرية.\n *\n * تعريفات الدالة:\n * - لـ 0 <= x < 10: y = cos(x + 3.0)\n * - لـ 10 <= x < 20: y = (cos(x + 7.5))^2\n * - لـ 20 <= x < 30: y = (cos(x + 4.0))^4\n * مثال:\n *   f_3(40) يعيد \"Not define\"\n */\nstd::string f_3(int x)", "sw": "#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <string>\n/**\n * Hesabu thamani ya kazi kwa ingizo lililopewa.\n * Vigezo:\n * - x (int): Thamani ya ingizo kwa kazi.\n * Inarudisha:\n * - std::string: Ikiwa x haiko katika kikoa kilichobainishwa, inarudisha \"Not define\".\n *   Vinginevyo, inarudisha thamani ya kazi iliyohesabiwa iliyopinduliwa hadi sehemu 5 za desimali.\n *\n * Ufafanuzi wa Kazi:\n * - Kwa 0 <= x < 10: y = cos(x + 3.0)\n * - Kwa 10 <= x < 20: y = (cos(x + 7.5))^2\n * - Kwa 20 <= x < 30: y = (cos(x + 4.0))^4\n * Mfano:\n *   f_3(40) inarudisha \"Not define\"\n */\nstd::string f_3(int x)", "tr": "#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <string>\n/**\n * Belirli bir giriş için fonksiyonun değerini hesapla.\n * Parametreler:\n * - x (int): Fonksiyon için giriş değeri.\n * Döndürür:\n * - std::string: Eğer x tanımlı alanda değilse, \"Not define\" döndürür.\n *   Aksi takdirde, hesaplanan fonksiyon değerini 5 ondalık basamağa yuvarlanmış olarak döndürür.\n *\n * Fonksiyon Tanımları:\n * - 0 <= x < 10 için: y = cos(x + 3.0)\n * - 10 <= x < 20 için: y = (cos(x + 7.5))^2\n * - 20 <= x < 30 için: y = (cos(x + 4.0))^4\n * Örnek:\n *   f_3(40) \"Not define\" döndürür\n */\nstd::string f_3(int x)", "vi": "#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <string>\n/**\n * Tính giá trị của hàm cho một đầu vào cho trước.\n * Tham số:\n * - x (int): Giá trị đầu vào cho hàm.\n * Trả về:\n * - std::string: Nếu x không nằm trong miền xác định, trả về \"Not define\".\n *   Ngược lại, trả về giá trị hàm đã tính được làm tròn đến 5 chữ số thập phân.\n *\n * Định nghĩa hàm:\n * - Với 0 <= x < 10: y = cos(x + 3.0)\n * - Với 10 <= x < 20: y = (cos(x + 7.5))^2\n * - Với 20 <= x < 30: y = (cos(x + 4.0))^4\n * Ví dụ:\n *   f_3(40) trả về \"Not define\"\n */\nstd::string f_3(int x)", "id": "#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <string>\n/**\n * Hitung nilai fungsi untuk input yang diberikan.\n * Parameter:\n * - x (int): Nilai input untuk fungsi.\n * Mengembalikan:\n * - std::string: Jika x tidak dalam domain yang ditentukan, mengembalikan \"Not define\".\n *   Jika tidak, mengembalikan nilai fungsi yang dihitung dibulatkan ke 5 tempat desimal.\n *\n * Definisi Fungsi:\n * - Untuk 0 <= x < 10: y = cos(x + 3.0)\n * - Untuk 10 <= x < 20: y = (cos(x + 7.5))^2\n * - Untuk 20 <= x < 30: y = (cos(x + 4.0))^4\n * Contoh:\n *   f_3(40) mengembalikan \"Not define\"\n */\nstd::string f_3(int x)", "ja": "#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <string>\n/**\n * 与えられた入力に対して関数の値を計算します。\n * パラメータ:\n * - x (int): 関数の入力値。\n * 戻り値:\n * - std::string: x が定義された範囲にない場合は \"Not define\" を返します。\n *   それ以外の場合は、計算された関数の値を小数点以下5桁に丸めて返します。\n *\n * 関数定義:\n * - 0 <= x < 10 の場合: y = cos(x + 3.0)\n * - 10 <= x < 20 の場合: y = (cos(x + 7.5))^2\n * - 20 <= x < 30 の場合: y = (cos(x + 4.0))^4\n * 例:\n *   f_3(40) は \"Not define\" を返します\n */\nstd::string f_3(int x)", "ko": "#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <string>\n/**\n * 주어진 입력에 대한 함수의 값을 계산합니다.\n * 매개변수:\n * - x (int): 함수에 대한 입력 값.\n * 반환값:\n * - std::string: x가 정의된 도메인에 없으면 \"Not define\"을 반환합니다.\n *   그렇지 않으면 계산된 함수 값을 소수점 5자리로 반올림하여 반환합니다.\n *\n * 함수 정의:\n * - 0 <= x < 10: y = cos(x + 3.0)\n * - 10 <= x < 20: y = (cos(x + 7.5))^2\n * - 20 <= x < 30: y = (cos(x + 4.0))^4\n * 예시:\n *   f_3(40) returns \"Not define\"\n */\nstd::string f_3(int x)", "ml": "#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <string>\n/**\n * നൽകിയ ഇൻപുട്ടിനായി ഫംഗ്ഷന്റെ മൂല്യം കണക്കാക്കുക.\n * പാരാമീറ്ററുകൾ:\n * - x (int): ഫംഗ്ഷനുള്ള ഇൻപുട്ട് മൂല്യം.\n * റിട്ടേൺസ്:\n * - std::string: x നിർവചിച്ചിരിക്കുന്ന ഡൊമെയിനിൽ ഇല്ലെങ്കിൽ, \"Not define\" റിട്ടേൺ ചെയ്യും.\n *   അല്ലെങ്കിൽ, കണക്കാക്കിയ ഫംഗ്ഷൻ മൂല്യം 5 ദശാംശ സ്ഥാനങ്ങളിൽ റൗണ്ട് ചെയ്ത് റിട്ടേൺ ചെയ്യും.\n *\n * ഫംഗ്ഷൻ നിർവചനങ്ങൾ:\n * - 0 <= x < 10: y = cos(x + 3.0)\n * - 10 <= x < 20: y = (cos(x + 7.5))^2\n * - 20 <= x < 30: y = (cos(x + 4.0))^4\n * ഉദാഹരണം:\n *   f_3(40) \"Not define\" റിട്ടേൺ ചെയ്യും\n */\nstd::string f_3(int x)", "fa": "#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <string>\n/**\n * محاسبه مقدار تابع برای یک ورودی داده شده.\n * پارامترها:\n * - x (int): مقدار ورودی برای تابع.\n * بازگشت:\n * - std::string: اگر x در دامنه تعریف شده نباشد، \"Not define\" را برمی‌گرداند.\n *   در غیر این صورت، مقدار محاسبه شده تابع را به 5 رقم اعشار گرد می‌کند و برمی‌گرداند.\n *\n * تعریف‌های تابع:\n * - برای 0 <= x < 10: y = cos(x + 3.0)\n * - برای 10 <= x < 20: y = (cos(x + 7.5))^2\n * - برای 20 <= x < 30: y = (cos(x + 4.0))^4\n * مثال:\n *   f_3(40) returns \"Not define\"\n */\nstd::string f_3(int x)"}, "canonical_solution": "{\n    char output[50]; // Buffer to hold the output string.\n\n    if (0 <= x && x < 10) {\n        snprintf(output, sizeof(output), \"%.5f\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return std::string(output);\n}", "instruction": {"en": "Write a CPP function `std::string f_3(int x)` to solve the following problem:\nCalculate the value of the function for a given input. Parameters: - x (int): Input value for the function. Returns: - std::string: If x is not in the defined domain, returns \"Not define\". Otherwise, returns the calculated function value rounded to 5 decimal places. Function Definitions: - For 0 <= x < 10: y = cos(x + 3.0) - For 10 <= x < 20: y = (cos(x + 7.5))^2 - For 20 <= x < 30: y = (cos(x + 4.0))^4 Example: f_3(40) returns \"Not define\"", "sq": "Shkruani një funksion CPP `std::string f_3(int x)` për të zgjidhur problemin e mëposhtëm:  \nLlogaritni vlerën e funksionit për një hyrje të dhënë. Parametrat: - x (int): Vlera e hyrjes për funksionin. Kthen: - std::string: Nëse x nuk është në domenin e përcaktuar, kthen \"Not define\". Përndryshe, kthen vlerën e llogaritur të funksionit të rrumbullakosur në 5 vende dhjetore. Përkufizimet e funksionit: - Për 0 <= x < 10: y = cos(x + 3.0) - Për 10 <= x < 20: y = (cos(x + 7.5))^2 - Për 20 <= x < 30: y = (cos(x + 4.0))^4 Shembull: f_3(40) kthen \"Not define\"", "hy": "Գրեք CPP ֆունկցիա `std::string f_3(int x)` հետևյալ խնդիրը լուծելու համար: Հաշվարկել ֆունկցիայի արժեքը տրված մուտքի համար: Պարամետրեր: - x (int): Մուտքային արժեք ֆունկցիայի համար: Վերադարձնում է: - std::string: Եթե x-ը սահմանված դոմենում չէ, վերադարձնում է \"Not define\": Հակառակ դեպքում, վերադարձնում է հաշվարկված ֆունկցիայի արժեքը կլորացված մինչև 5 տասնորդական: Ֆունկցիայի սահմանումներ: - 0 <= x < 10: y = cos(x + 3.0) - 10 <= x < 20: y = (cos(x + 7.5))^2 - 20 <= x < 30: y = (cos(x + 4.0))^4 Օրինակ: f_3(40) վերադարձնում է \"Not define\"", "bn": "একটি CPP ফাংশন `std::string f_3(int x)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি প্রদত্ত ইনপুটের জন্য ফাংশনের মান গণনা করুন। প্যারামিটারসমূহ: - x (int): ফাংশনের জন্য ইনপুট মান। রিটার্নস: - std::string: যদি x সংজ্ঞায়িত ডোমেইনে না থাকে, তাহলে \"Not define\" রিটার্ন করে। অন্যথায়, গণনা করা ফাংশনের মান ৫ দশমিক স্থান পর্যন্ত রাউন্ড করে রিটার্ন করে। ফাংশনের সংজ্ঞা: - 0 <= x < 10 এর জন্য: y = cos(x + 3.0) - 10 <= x < 20 এর জন্য: y = (cos(x + 7.5))^2 - 20 <= x < 30 এর জন্য: y = (cos(x + 4.0))^4 উদাহরণ: f_3(40) \"Not define\" রিটার্ন করে", "bg": "Напишете CPP функция `std::string f_3(int x)`, за да решите следния проблем:  \nИзчислете стойността на функцията за даден вход.  \nПараметри:  \n- x (int): Входна стойност за функцията.  \nВръща:  \n- std::string: Ако x не е в определения домейн, връща \"Not define\". В противен случай, връща изчислената стойност на функцията, закръглена до 5 знака след десетичната запетая.  \nДефиниции на функцията:  \n- За 0 <= x < 10: y = cos(x + 3.0)  \n- За 10 <= x < 20: y = (cos(x + 7.5))^2  \n- За 20 <= x < 30: y = (cos(x + 4.0))^4  \nПример: f_3(40) връща \"Not define\"", "zh": "编写一个 CPP 函数 `std::string f_3(int x)` 来解决以下问题：\n计算给定输入的函数值。  \n参数：  \n- x (int): 函数的输入值。  \n返回：  \n- std::string: 如果 x 不在定义域内，返回 \"Not define\"。否则，返回计算的函数值，四舍五入到小数点后 5 位。  \n函数定义：  \n- 对于 0 <= x < 10: y = cos(x + 3.0)  \n- 对于 10 <= x < 20: y = (cos(x + 7.5))^2  \n- 对于 20 <= x < 30: y = (cos(x + 4.0))^4  \n示例：f_3(40) 返回 \"Not define\"  ", "fr": "Écrire une fonction CPP `std::string f_3(int x)` pour résoudre le problème suivant :  \nCalculer la valeur de la fonction pour une entrée donnée.  \nParamètres :  \n- x (int) : Valeur d'entrée pour la fonction.  \nRenvoie :  \n- std::string : Si x n'est pas dans le domaine défini, renvoie \"Not define\". Sinon, renvoie la valeur calculée de la fonction arrondie à 5 décimales.  \nDéfinitions de la fonction :  \n- Pour 0 <= x < 10 : y = cos(x + 3.0)  \n- Pour 10 <= x < 20 : y = (cos(x + 7.5))^2  \n- Pour 20 <= x < 30 : y = (cos(x + 4.0))^4  \nExemple : f_3(40) renvoie \"Not define\"", "de": "Schreiben Sie eine CPP-Funktion `std::string f_3(int x)`, um das folgende Problem zu lösen:\nBerechnen Sie den Wert der Funktion für eine gegebene Eingabe. Parameter: - x (int): Eingabewert für die Funktion. Rückgabewerte: - std::string: Wenn x nicht im definierten Bereich liegt, gibt \"Not define\" zurück. Andernfalls wird der berechnete Funktionswert auf 5 Dezimalstellen gerundet zurückgegeben. Funktionsdefinitionen: - Für 0 <= x < 10: y = cos(x + 3.0) - Für 10 <= x < 20: y = (cos(x + 7.5))^2 - Für 20 <= x < 30: y = (cos(x + 4.0))^4 Beispiel: f_3(40) gibt \"Not define\" zurück", "ha": "Rubuta aikin CPP `std::string f_3(int x)` don warware matsalar mai zuwa: \nƘididdige ƙimar aikin don wani shigarwa da aka bayar. Sigogi: - x (int): Ƙimar shigarwa don aikin. Yana dawowa: - std::string: Idan x ba ya cikin yankin da aka ayyana, yana dawowa \"Not define\". In ba haka ba, yana dawowa ƙimar aikin da aka ƙididdige tare da zagaye zuwa wurare 5 na ƙidaya. Ma'anar Aiki: - Don 0 <= x < 10: y = cos(x + 3.0) - Don 10 <= x < 20: y = (cos(x + 7.5))^2 - Don 20 <= x < 30: y = (cos(x + 4.0))^4 Misali: f_3(40) yana dawowa \"Not define\"", "hi": "एक CPP फ़ंक्शन `std::string f_3(int x)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए इनपुट के लिए फ़ंक्शन का मान गणना करें। पैरामीटर्स: - x (int): फ़ंक्शन के लिए इनपुट मान। रिटर्न्स: - std::string: यदि x परिभाषित डोमेन में नहीं है, तो \"Not define\" लौटाता है। अन्यथा, गणना किए गए फ़ंक्शन मान को 5 दशमलव स्थानों तक राउंड करके लौटाता है। फ़ंक्शन परिभाषाएँ: - 0 <= x < 10 के लिए: y = cos(x + 3.0) - 10 <= x < 20 के लिए: y = (cos(x + 7.5))^2 - 20 <= x < 30 के लिए: y = (cos(x + 4.0))^4 उदाहरण: f_3(40) \"Not define\" लौटाता है।", "hu": "Írj egy CPP függvényt `std::string f_3(int x)` a következő probléma megoldására:\nSzámítsd ki a függvény értékét egy adott bemenetre. Paraméterek: - x (int): A függvény bemeneti értéke. Visszatérési érték: - std::string: Ha x nincs a meghatározott tartományban, akkor \"Not define\" értéket ad vissza. Ellenkező esetben a kiszámított függvényértéket adja vissza 5 tizedesjegyre kerekítve. Függvénydefiníciók: - Ha 0 <= x < 10: y = cos(x + 3.0) - Ha 10 <= x < 20: y = (cos(x + 7.5))^2 - Ha 20 <= x < 30: y = (cos(x + 4.0))^4 Példa: f_3(40) visszaadja \"Not define\"", "es": "Escribe una función CPP `std::string f_3(int x)` para resolver el siguiente problema:\nCalcular el valor de la función para una entrada dada. Parámetros: - x (int): Valor de entrada para la función. Retorna: - std::string: Si x no está en el dominio definido, retorna \"Not define\". De lo contrario, retorna el valor calculado de la función redondeado a 5 decimales. Definiciones de la función: - Para 0 <= x < 10: y = cos(x + 3.0) - Para 10 <= x < 20: y = (cos(x + 7.5))^2 - Para 20 <= x < 30: y = (cos(x + 4.0))^4 Ejemplo: f_3(40) retorna \"Not define\"", "arb": "اكتب دالة CPP `std::string f_3(int x)` لحل المشكلة التالية:\nاحسب قيمة الدالة لمدخل معين. المعطيات: - x (int): قيمة المدخل للدالة. يعيد: - std::string: إذا لم يكن x في النطاق المحدد، يعيد \"Not define\". خلاف ذلك، يعيد قيمة الدالة المحسوبة مقربة إلى 5 منازل عشرية. تعريفات الدالة: - لـ 0 <= x < 10: y = cos(x + 3.0) - لـ 10 <= x < 20: y = (cos(x + 7.5))^2 - لـ 20 <= x < 30: y = (cos(x + 4.0))^4 مثال: f_3(40) يعيد \"Not define\"", "sw": "Andika kazi ya CPP `std::string f_3(int x)` kutatua tatizo lifuatalo:\nHesabu thamani ya kazi kwa ingizo lililopewa. Vigezo: - x (int): Thamani ya ingizo kwa kazi. Inarudisha: - std::string: Ikiwa x haipo kwenye uwanja uliofafanuliwa, inarudisha \"Not define\". Vinginevyo, inarudisha thamani ya kazi iliyohesabiwa ikizungushwa hadi sehemu tano za desimali. Ufafanuzi wa Kazi: - Kwa 0 <= x < 10: y = cos(x + 3.0) - Kwa 10 <= x < 20: y = (cos(x + 7.5))^2 - Kwa 20 <= x < 30: y = (cos(x + 4.0))^4 Mfano: f_3(40) inarudisha \"Not define\"", "tr": "Bir CPP fonksiyonu `std::string f_3(int x)` yazın. Aşağıdaki problemi çözmek için:\nVerilen bir girdi için fonksiyonun değerini hesaplayın. Parametreler: - x (int): Fonksiyon için giriş değeri. Döndürür: - std::string: Eğer x tanımlı alanda değilse, \"Not define\" döndürür. Aksi takdirde, hesaplanan fonksiyon değerini 5 ondalık basamağa yuvarlanmış olarak döndürür. Fonksiyon Tanımları: - 0 <= x < 10 için: y = cos(x + 3.0) - 10 <= x < 20 için: y = (cos(x + 7.5))^2 - 20 <= x < 30 için: y = (cos(x + 4.0))^4 Örnek: f_3(40) \"Not define\" döndürür.", "vi": "Viết một hàm CPP `std::string f_3(int x)` để giải quyết vấn đề sau:\nTính giá trị của hàm cho một đầu vào nhất định. Tham số: - x (int): Giá trị đầu vào cho hàm. Trả về: - std::string: Nếu x không nằm trong miền xác định, trả về \"Not define\". Ngược lại, trả về giá trị hàm đã tính được làm tròn đến 5 chữ số thập phân. Định nghĩa hàm: - Đối với 0 <= x < 10: y = cos(x + 3.0) - Đối với 10 <= x < 20: y = (cos(x + 7.5))^2 - Đối với 20 <= x < 30: y = (cos(x + 4.0))^4 Ví dụ: f_3(40) trả về \"Not define\"", "id": "Tulis fungsi CPP `std::string f_3(int x)` untuk menyelesaikan masalah berikut:\nHitung nilai fungsi untuk input yang diberikan. Parameter: - x (int): Nilai input untuk fungsi. Mengembalikan: - std::string: Jika x tidak dalam domain yang ditentukan, mengembalikan \"Not define\". Jika tidak, mengembalikan nilai fungsi yang dihitung dibulatkan ke 5 tempat desimal. Definisi Fungsi: - Untuk 0 <= x < 10: y = cos(x + 3.0) - Untuk 10 <= x < 20: y = (cos(x + 7.5))^2 - Untuk 20 <= x < 30: y = (cos(x + 4.0))^4 Contoh: f_3(40) mengembalikan \"Not define\"", "ja": "以下の問題を解決するために、CPP関数 `std::string f_3(int x)` を作成してください:\n与えられた入力に対して関数の値を計算します。 パラメータ: - x (int): 関数の入力値。 戻り値: - std::string: xが定義されたドメインにない場合は \"Not define\" を返します。それ以外の場合は、計算された関数の値を小数点以下5桁に丸めて返します。 関数定義: - 0 <= x < 10 の場合: y = cos(x + 3.0) - 10 <= x < 20 の場合: y = (cos(x + 7.5))^2 - 20 <= x < 30 の場合: y = (cos(x + 4.0))^4 例: f_3(40) は \"Not define\" を返します。", "ko": "CPP 함수를 작성하세요 `std::string f_3(int x)` 다음 문제를 해결하기 위해:\n주어진 입력에 대한 함수의 값을 계산합니다. 매개변수: - x (int): 함수의 입력 값. 반환값: - std::string: x가 정의된 도메인에 없으면, \"Not define\"을 반환합니다. 그렇지 않으면, 계산된 함수 값을 소수점 5자리로 반올림하여 반환합니다. 함수 정의: - 0 <= x < 10: y = cos(x + 3.0) - 10 <= x < 20: y = (cos(x + 7.5))^2 - 20 <= x < 30: y = (cos(x + 4.0))^4 예시: f_3(40) returns \"Not define\"", "ml": "CPP ഫങ്ഷൻ `std::string f_3(int x)` എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ: \n\nഒരു നൽകിയ ഇൻപുട്ടിനായി ഫങ്ഷന്റെ മൂല്യം കണക്കാക്കുക. \n\nപാരാമീറ്ററുകൾ: \n- x (int): ഫങ്ഷനുള്ള ഇൻപുട്ട് മൂല്യം. \n\nമടക്കുന്നു: \n- std::string: x നിർവ്വചിച്ചിരിക്കുന്ന ഡൊമെയിനിൽ ഇല്ലെങ്കിൽ, \"Not define\" മടക്കുന്നു. അല്ലെങ്കിൽ, കണക്കാക്കിയ ഫങ്ഷൻ മൂല്യം 5 ദശാംശ സ്ഥാനങ്ങളിൽ പൂർണ്ണീകരിച്ച് മടക്കുന്നു. \n\nഫങ്ഷൻ നിർവ്വചനങ്ങൾ: \n- 0 <= x < 10: y = cos(x + 3.0) \n- 10 <= x < 20: y = (cos(x + 7.5))^2 \n- 20 <= x < 30: y = (cos(x + 4.0))^4 \n\nഉദാഹരണം: f_3(40) \"Not define\" മടക്കുന്നു", "fa": "یک تابع CPP به نام `std::string f_3(int x)` بنویسید تا مسئله زیر را حل کند:\nمقدار تابع را برای یک ورودی مشخص محاسبه کنید. پارامترها: - x (int): مقدار ورودی برای تابع. بازگشت: - std::string: اگر x در دامنه تعریف شده نباشد، \"Not define\" را برمی‌گرداند. در غیر این صورت، مقدار محاسبه شده تابع را که به 5 رقم اعشار گرد شده است برمی‌گرداند. تعاریف تابع: - برای 0 <= x < 10: y = cos(x + 3.0) - برای 10 <= x < 20: y = (cos(x + 7.5))^2 - برای 20 <= x < 30: y = (cos(x + 4.0))^4 مثال: f_3(40) \"Not define\" را برمی‌گرداند."}, "level": "easy", "test": "int main() {\n    assert(f_3(40) == \"Not define\");\n\n    // Additional test cases based on provided function definitions\n    assert(f_3(5) == \"-0.14550\");\n    assert(f_3(15) == \"0.76266\");\n    assert(f_3(25) == \"0.31314\");\n    assert(f_3(-1) == \"Not define\");\n\n    // std::cout << \"All tests passed successfully.\" << std::endl;\n\n    return 0;\n}", "entry_point": "f_3", "signature": "std::string f_3(int x)", "docstring": {"en": "Calculate the value of the function for a given input. Parameters: - x (int): Input value for the function. Returns: - std::string: If x is not in the defined domain, returns \"Not define\". Otherwise, returns the calculated function value rounded to 5 decimal places. Function Definitions: - For 0 <= x < 10: y = cos(x + 3.0) - For 10 <= x < 20: y = (cos(x + 7.5))^2 - For 20 <= x < 30: y = (cos(x + 4.0))^4 Example: f_3(40) returns \"Not define\"", "sq": "Llogarit vlerën e funksionit për një hyrje të dhënë.\n\nParametrat: - x (int): Vlera e hyrjes për funksionin.\n\nKthen:\n- std::string: Nëse x nuk është në domenin e përcaktuar, kthen \"Not define\". Përndryshe, kthen vlerën e llogaritur të funksionit të rrumbullakosur në 5 vende dhjetore.\n\nPërcaktimet e Funksionit:\n- Për 0 <= x < 10: y = cos(x + 3.0)\n- Për 10 <= x < 20: y = (cos(x + 7.5))^2\n- Për 20 <= x < 30: y = (cos(x + 4.0))^4\n\nShembull:\nf_3(40) kthen \"Not define\"", "hy": "Հաշվարկել ֆունկցիայի արժեքը տրված մուտքագրվածի համար։ Պարամետրեր՝ - x (int): Մուտքագրված արժեք ֆունկցիայի համար։ Վերադարձնում է՝ - std::string: Եթե x-ը սահմանված տիրույթում չէ, վերադարձնում է \"Not define\"։ Հակառակ դեպքում, վերադարձնում է հաշվարկված ֆունկցիայի արժեքը կլորացված մինչև 5 տասնորդական։ Ֆունկցիայի սահմանումներ՝ - 0 <= x < 10: y = cos(x + 3.0) - 10 <= x < 20: y = (cos(x + 7.5))^2 - 20 <= x < 30: y = (cos(x + 4.0))^4 Օրինակ՝ f_3(40) վերադարձնում է \"Not define\"", "bn": "প্রদত্ত ইনপুটের জন্য ফাংশনের মান গণনা করুন।\n\nParameters: - x (int): ফাংশনের জন্য ইনপুট মান।\n\nReturns:\n- std::string: যদি x সংজ্ঞায়িত ডোমেইনে না থাকে, তাহলে \"Not define\" রিটার্ন করে। অন্যথায়, গণনা করা ফাংশনের মান 5 দশমিক স্থানে রাউন্ড করে রিটার্ন করে।\n\nFunction Definitions:\n- For 0 <= x < 10: y = cos(x + 3.0)\n- For 10 <= x < 20: y = (cos(x + 7.5))^2\n- For 20 <= x < 30: y = (cos(x + 4.0))^4\n\nExample:\nf_3(40) returns \"Not define\"", "bg": "Изчислява стойността на функцията за даден вход. \n\nПараметри: - x (int): Входна стойност за функцията.\n\nВръща:\n- std::string: Ако x не е в определения домейн, връща \"Not define\". В противен случай, връща изчислената стойност на функцията, закръглена до 5 знака след десетичната запетая.\n\nОпределения на функцията:\n- За 0 <= x < 10: y = cos(x + 3.0)\n- За 10 <= x < 20: y = (cos(x + 7.5))^2\n- За 20 <= x < 30: y = (cos(x + 4.0))^4\n\nПример:\nf_3(40) връща \"Not define\"", "zh": "计算给定输入的函数值。\n\n参数: - x (int): 函数的输入值。\n\n返回:\n- std::string: 如果 x 不在定义域内，返回 \"Not define\"。否则，返回计算后的函数值，保留小数点后 5 位。\n\n函数定义:\n- 对于 0 <= x < 10: y = cos(x + 3.0)\n- 对于 10 <= x < 20: y = (cos(x + 7.5))^2\n- 对于 20 <= x < 30: y = (cos(x + 4.0))^4\n\n示例:\nf_3(40) 返回 \"Not define\"", "fr": "Calculer la valeur de la fonction pour une entrée donnée. \n\nParamètres: - x (int): Valeur d'entrée pour la fonction. \n\nRenvoie: \n- std::string: Si x n'est pas dans le domaine défini, renvoie \"Not define\". Sinon, renvoie la valeur calculée de la fonction arrondie à 5 décimales. \n\nDéfinitions de fonction: \n- Pour 0 <= x < 10: y = cos(x + 3.0) \n- Pour 10 <= x < 20: y = (cos(x + 7.5))^2 \n- Pour 20 <= x < 30: y = (cos(x + 4.0))^4 \n\nExemple: f_3(40) renvoie \"Not define\"", "de": "Berechne den Wert der Funktion für eine gegebene Eingabe.\n\nParameter: - x (int): Eingabewert für die Funktion.\n\nRückgabewerte:\n- std::string: Wenn x nicht im definierten Bereich liegt, wird \"Not define\" zurückgegeben. Andernfalls wird der berechnete Funktionswert auf 5 Dezimalstellen gerundet zurückgegeben.\n\nFunktionsdefinitionen:\n- Für 0 <= x < 10: y = cos(x + 3.0)\n- Für 10 <= x < 20: y = (cos(x + 7.5))^2\n- Für 20 <= x < 30: y = (cos(x + 4.0))^4\n\nBeispiel:\nf_3(40) gibt \"Not define\" zurück.", "ha": "Lissafa ƙimar aikin don wani shigarwa da aka bayar.\n\nSigogi: - x (int): Ƙimar shigarwa don aikin.\n\nReturns:\n    - std::string: Idan x ba ya cikin yankin da aka ayyana, yana dawowa \"Not define\". In ba haka ba, yana dawowa da ƙimar aikin da aka lissafa tare da zagaye zuwa wurare 5 na ƙidaya.\n\nFunction Definitions:\n    - Don 0 <= x < 10: y = cos(x + 3.0)\n    - Don 10 <= x < 20: y = (cos(x + 7.5))^2\n    - Don 20 <= x < 30: y = (cos(x + 4.0))^4\n\nExample:\n    f_3(40) returns \"Not define\"", "hi": "दिए गए इनपुट के लिए फ़ंक्शन का मान गणना करें।\n\nपैरामीटर्स: - x (int): फ़ंक्शन के लिए इनपुट मान।\n\nReturns:\n- std::string: यदि x परिभाषित डोमेन में नहीं है, तो \"Not define\" लौटाता है। अन्यथा, गणना किए गए फ़ंक्शन मान को 5 दशमलव स्थानों तक राउंड करके लौटाता है।\n\nFunction Definitions:\n- For 0 <= x < 10: y = cos(x + 3.0)\n- For 10 <= x < 20: y = (cos(x + 7.5))^2\n- For 20 <= x < 30: y = (cos(x + 4.0))^4\n\nExample:\nf_3(40) returns \"Not define\"", "hu": "Számítsa ki a függvény értékét egy adott bemenethez. Paraméterek: - x (int): A függvény bemeneti értéke. Visszatér: - std::string: Ha x nincs a meghatározott tartományban, \"Not define\" értéket ad vissza. Ellenkező esetben a kiszámított függvényértéket adja vissza, 5 tizedesjegyre kerekítve. Függvénydefiníciók: - Ha 0 <= x < 10: y = cos(x + 3.0) - Ha 10 <= x < 20: y = (cos(x + 7.5))^2 - Ha 20 <= x < 30: y = (cos(x + 4.0))^4 Példa: f_3(40) visszatér \"Not define\"", "es": "Calcular el valor de la función para una entrada dada. Parámetros: - x (int): Valor de entrada para la función. Devuelve: - std::string: Si x no está en el dominio definido, devuelve \"Not define\". De lo contrario, devuelve el valor calculado de la función redondeado a 5 decimales. Definiciones de Función: - Para 0 <= x < 10: y = cos(x + 3.0) - Para 10 <= x < 20: y = (cos(x + 7.5))^2 - Para 20 <= x < 30: y = (cos(x + 4.0))^4 Ejemplo: f_3(40) devuelve \"Not define\"", "arb": "احسب قيمة الدالة لقيمة مدخلة معينة.  \nالمعلمات:  \n- x (int): قيمة المدخل للدالة.  \n\nالقيم المعادة:  \n- std::string: إذا لم يكن x في النطاق المحدد، يعيد \"غير معرف\". خلاف ذلك، يعيد قيمة الدالة المحسوبة مقربة إلى 5 منازل عشرية.  \n\nتعريفات الدالة:  \n- لـ 0 <= x < 10: y = cos(x + 3.0)  \n- لـ 10 <= x < 20: y = (cos(x + 7.5))^2  \n- لـ 20 <= x < 30: y = (cos(x + 4.0))^4  \n\nمثال:  \nf_3(40) يعيد \"غير معرف\"", "sw": "Hesabu thamani ya kazi kwa pembejeo iliyotolewa.\n\nVigezo:\n- x (int): Thamani ya pembejeo kwa kazi.\n\nInarejesha:\n- std::string: Ikiwa x haipo kwenye kikoa kilichofafanuliwa, inarejesha \"Not define\". Vinginevyo, inarejesha thamani ya kazi iliyohesabiwa ikizunguushwa hadi sehemu 5 za desimali.\n\nUfafanuzi wa Kazi:\n- Kwa 0 <= x < 10: y = cos(x + 3.0)\n- Kwa 10 <= x < 20: y = (cos(x + 7.5))^2\n- Kwa 20 <= x < 30: y = (cos(x + 4.0))^4\n\nMfano:\nf_3(40) inarejesha \"Not define\"", "tr": "Calculate the value of the function for a given input.\n\nParametreler:\n- x (int): Fonksiyon için giriş değeri.\n\nDöndürülenler:\n- std::string: Eğer x tanımlı alanda değilse, \"Not define\" döner. Aksi takdirde, hesaplanan fonksiyon değerini 5 ondalık basamağa yuvarlanmış olarak döner.\n\nFonksiyon Tanımları:\n- 0 <= x < 10 için: y = cos(x + 3.0)\n- 10 <= x < 20 için: y = (cos(x + 7.5))^2\n- 20 <= x < 30 için: y = (cos(x + 4.0))^4\n\nÖrnek:\nf_3(40) döndürür \"Not define\"", "vi": "Tính giá trị của hàm cho một đầu vào đã cho.\n\nTham số:\n- x (int): Giá trị đầu vào cho hàm.\n\nTrả về:\n- std::string: Nếu x không nằm trong miền xác định, trả về \"Not define\". Ngược lại, trả về giá trị hàm đã tính toán được làm tròn đến 5 chữ số thập phân.\n\nĐịnh nghĩa hàm:\n- Với 0 <= x < 10: y = cos(x + 3.0)\n- Với 10 <= x < 20: y = (cos(x + 7.5))^2\n- Với 20 <= x < 30: y = (cos(x + 4.0))^4\n\nVí dụ:\nf_3(40) trả về \"Not define\"", "id": "Hitung nilai fungsi untuk input yang diberikan. \n\nParameter:\n- x (int): Nilai input untuk fungsi.\n\nMengembalikan:\n- std::string: Jika x tidak dalam domain yang ditentukan, mengembalikan \"Not define\". Jika tidak, mengembalikan nilai fungsi yang dihitung dibulatkan ke 5 tempat desimal.\n\nDefinisi Fungsi:\n- Untuk 0 <= x < 10: y = cos(x + 3.0)\n- Untuk 10 <= x < 20: y = (cos(x + 7.5))^2\n- Untuk 20 <= x < 30: y = (cos(x + 4.0))^4\n\nContoh:\nf_3(40) mengembalikan \"Not define\"", "ja": "関数の値を指定された入力に対して計算します。\n\n引数:\n- x (int): 関数の入力値。\n\n戻り値:\n- std::string: x が定義された範囲にない場合は \"Not define\" を返します。それ以外の場合は、計算された関数の値を小数点以下5桁に丸めて返します。\n\n関数定義:\n- 0 <= x < 10 の場合: y = cos(x + 3.0)\n- 10 <= x < 20 の場合: y = (cos(x + 7.5))^2\n- 20 <= x < 30 の場合: y = (cos(x + 4.0))^4\n\n例:\nf_3(40) は \"Not define\" を返します。", "ko": "주어진 입력에 대한 함수의 값을 계산합니다. \n\n매개변수:\n- x (int): 함수의 입력 값.\n\n반환:\n- std::string: x가 정의된 도메인에 있지 않으면 \"Not define\"을 반환합니다. 그렇지 않으면 계산된 함수 값을 소수점 5자리로 반올림하여 반환합니다.\n\n함수 정의:\n- 0 <= x < 10: y = cos(x + 3.0)\n- 10 <= x < 20: y = (cos(x + 7.5))^2\n- 20 <= x < 30: y = (cos(x + 4.0))^4\n\n예제:\nf_3(40) returns \"Not define\"", "ml": "നൽകിയ ഇൻപുട്ടിനായി ഫംഗ്ഷന്റെ മൂല്യം കണക്കാക്കുക.\n\nപാരാമീറ്ററുകൾ:\n- x (int): ഫംഗ്ഷനു വേണ്ടി നൽകുന്ന ഇൻപുട്ട് മൂല്യം.\n\nReturn ചെയ്യുന്നത്:\n- std::string: x നിർവചിച്ചിരിക്കുന്ന ഡൊമെയ്‌നിൽ ഇല്ലെങ്കിൽ, \"Not define\" എന്നത് Return ചെയ്യും. അല്ലെങ്കിൽ, കൃത്യമായ 5 ദശാംശ സ്ഥാനങ്ങളിൽ വൃത്താകൃതിയിലുള്ള ഫംഗ്ഷൻ മൂല്യം Return ചെയ്യും.\n\nഫംഗ്ഷൻ നിർവചനങ്ങൾ:\n- 0 <= x < 10: y = cos(x + 3.0)\n- 10 <= x < 20: y = (cos(x + 7.5))^2\n- 20 <= x < 30: y = (cos(x + 4.0))^4\n\nഉദാഹരണം:\nf_3(40) \"Not define\" Return ചെയ്യും", "fa": "محاسبه مقدار تابع برای یک ورودی داده شده.\n\nپارامترها:\n- x (int): مقدار ورودی برای تابع.\n\nبازگشت‌ها:\n- std::string: اگر x در دامنه تعریف‌شده نباشد، \"Not define\" را برمی‌گرداند. در غیر این صورت، مقدار محاسبه‌شده تابع را با گرد کردن به 5 رقم اعشار برمی‌گرداند.\n\nتعاریف تابع:\n- برای 0 <= x < 10: y = cos(x + 3.0)\n- برای 10 <= x < 20: y = (cos(x + 7.5))^2\n- برای 20 <= x < 30: y = (cos(x + 4.0))^4\n\nمثال:\nf_3(40) returns \"Not define\""}}
{"task_id": "CPP/4", "prompt": {"en": "#include <cassert>\n#include <cstdio>\n/*\nFind the maximum and minimum of three distinct integers.\nParameters:\na (int): The first integer.\nb (int): The second integer.\nc (int): The third integer.\n\nReturns:\nTuple[int, int]: A tuple is not a concept in C; instead, we will return by reference.\n\n>>> Example call: \nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid f_4(int a, int b, int c, int *max, int *min)", "sq": "#include <cassert>\n#include <cstdio>\n/*\nGjeni maksimumin dhe minimumin e tre numrave të plotë të ndryshëm.\nParametrat:\na (int): Numri i parë i plotë.\nb (int): Numri i dytë i plotë.\nc (int): Numri i tretë i plotë.\n\nKthen:\nTuple[int, int]: Një tuple nuk është një koncept në C; në vend të kësaj, ne do të kthejmë me referencë.\n\n>>> Shembull thirrjeje: \nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid f_4(int a, int b, int c, int *max, int *min)", "hy": "#include <cassert>\n#include <cstdio>\n/*\nԳտնել երեք տարբեր ամբողջ թվերի առավելագույնն ու նվազագույնը։\nՊարամետրեր:\na (int): Առաջին ամբողջ թիվը։\nb (int): Երկրորդ ամբողջ թիվը։\nc (int): Երրորդ ամբողջ թիվը։\n\nՎերադարձնում է:\nTuple[int, int]: Tuple-ը հասկացություն չէ C-ում; փոխարենը, մենք կվերադարձնենք հղումով։\n\n>>> Օրինակ կանչ:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid f_4(int a, int b, int c, int *max, int *min)", "bn": "#include <cassert>\n#include <cstdio>\n/*\nতিনটি ভিন্ন পূর্ণসংখ্যার সর্বাধিক এবং সর্বনিম্ন মান খুঁজে বের করুন।\nপ্যারামিটারসমূহ:\na (int): প্রথম পূর্ণসংখ্যা।\nb (int): দ্বিতীয় পূর্ণসংখ্যা।\nc (int): তৃতীয় পূর্ণসংখ্যা।\n\nরিটার্নস:\nTuple[int, int]: একটি টিউপল C তে একটি ধারণা নয়; পরিবর্তে, আমরা রেফারেন্স দ্বারা রিটার্ন করব।\n\n>>> উদাহরণ কল:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid f_4(int a, int b, int c, int *max, int *min)", "bg": "#include <cassert>\n#include <cstdio>\n/*\nНамерете максимума и минимума на три различни цели числа.\nПараметри:\na (int): Първото цяло число.\nb (int): Второто цяло число.\nc (int): Третото цяло число.\n\nВръща:\nTuple[int, int]: Кортеж не е концепция в C; вместо това ще връщаме чрез референция.\n\n>>> Примерно извикване: \nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid f_4(int a, int b, int c, int *max, int *min)", "zh": "#include <cassert>\n#include <cstdio>\n/*\n找到三个不同整数的最大值和最小值。\n参数：\na (int): 第一个整数。\nb (int): 第二个整数。\nc (int): 第三个整数。\n\n返回：\nTuple[int, int]: 元组不是C语言中的概念，因此我们将通过引用返回。\n\n>>> 示例调用: \nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid f_4(int a, int b, int c, int *max, int *min)", "fr": "#include <cassert>\n#include <cstdio>\n/*\nTrouver le maximum et le minimum de trois entiers distincts.\nParamètres :\na (int) : Le premier entier.\nb (int) : Le deuxième entier.\nc (int) : Le troisième entier.\n\nRenvoie :\nTuple[int, int] : Un tuple n'est pas un concept en C ; à la place, nous allons retourner par référence.\n\n>>> Exemple d'appel : \nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid f_4(int a, int b, int c, int *max, int *min)", "de": "#include <cassert>\n#include <cstdio>\n/*\nFinde das Maximum und Minimum von drei verschiedenen ganzen Zahlen.\nParameter:\na (int): Die erste ganze Zahl.\nb (int): Die zweite ganze Zahl.\nc (int): Die dritte ganze Zahl.\n\nRückgabe:\nTuple[int, int]: Ein Tupel ist kein Konzept in C; stattdessen werden wir durch Referenz zurückgeben.\n\n>>> Beispielaufruf: \nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid f_4(int a, int b, int c, int *max, int *min)", "ha": "#include <cassert>\n#include <cstdio>\n/*\nNemo mafi girma da mafi ƙanƙanta daga cikin lambobi guda uku masu bambanta.\nSigogi:\na (int): Lamba ta farko.\nb (int): Lamba ta biyu.\nc (int): Lamba ta uku.\n\nDawowa:\nTuple[int, int]: Ba a samun ra'ayin tuple a cikin C; maimakon haka, za mu dawo ta hanyar tunani.\n\n>>> Misalin kira:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid f_4(int a, int b, int c, int *max, int *min)", "hi": "#include <cassert>\n#include <cstdio>\n/*\nतीन भिन्न पूर्णांकों का अधिकतम और न्यूनतम मान खोजें।\nपैरामीटर्स:\na (int): पहला पूर्णांक।\nb (int): दूसरा पूर्णांक।\nc (int): तीसरा पूर्णांक।\n\nवापसी:\nTuple[int, int]: C में एक ट्यूपल की अवधारणा नहीं है; इसके बजाय, हम संदर्भ द्वारा लौटाएंगे।\n\n>>> उदाहरण कॉल:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid f_4(int a, int b, int c, int *max, int *min)", "hu": "#include <cassert>\n#include <cstdio>\n/*\nKeresse meg három különböző egész szám maximumát és minimumát.\nParaméterek:\na (int): Az első egész szám.\nb (int): A második egész szám.\nc (int): A harmadik egész szám.\n\nVisszatérési érték:\nTuple[int, int]: A tuple nem egy fogalom a C-ben; ehelyett referencia alapján fogunk visszatérni.\n\n>>> Példa hívás:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid f_4(int a, int b, int c, int *max, int *min)", "es": "#include <cassert>\n#include <cstdio>\n/*\nEncuentra el máximo y el mínimo de tres enteros distintos.\nParámetros:\na (int): El primer entero.\nb (int): El segundo entero.\nc (int): El tercer entero.\n\nDevuelve:\nTuple[int, int]: Una tupla no es un concepto en C; en su lugar, devolveremos por referencia.\n\n>>> Ejemplo de llamada: \nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid f_4(int a, int b, int c, int *max, int *min)", "arb": "#include <cassert>\n#include <cstdio>\n/*\nالعثور على القيمة القصوى والدنيا لثلاثة أعداد صحيحة متميزة.\nالمعلمات:\na (int): العدد الصحيح الأول.\nb (int): العدد الصحيح الثاني.\nc (int): العدد الصحيح الثالث.\n\nالإرجاع:\nTuple[int, int]: الزوج ليس مفهومًا في C؛ بدلاً من ذلك، سنعيد بالقيمة المرجعية.\n\n>>> مثال على الاستدعاء: \nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid f_4(int a, int b, int c, int *max, int *min)", "sw": "#include <cassert>\n#include <cstdio>\n/*\nPata kubwa na ndogo kati ya nambari tatu tofauti za mzima.\nVigezo:\na (int): Nambari ya kwanza ya mzima.\nb (int): Nambari ya pili ya mzima.\nc (int): Nambari ya tatu ya mzima.\n\nRudisha:\nTuple[int, int]: Tuple si dhana katika C; badala yake, tutarudisha kwa marejeleo.\n\n>>> Mfano wa kupiga simu: \nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid f_4(int a, int b, int c, int *max, int *min)", "tr": "#include <cassert>\n#include <cstdio>\n/*\nÜç farklı tamsayının maksimum ve minimumunu bulun.\nParametreler:\na (int): Birinci tamsayı.\nb (int): İkinci tamsayı.\nc (int): Üçüncü tamsayı.\n\nDöndürür:\nTuple[int, int]: C'de bir tuple kavramı yoktur; bunun yerine referansla döndüreceğiz.\n\n>>> Örnek çağrı: \nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid f_4(int a, int b, int c, int *max, int *min)", "vi": "#include <cassert>\n#include <cstdio>\n/*\nTìm giá trị lớn nhất và nhỏ nhất của ba số nguyên khác nhau.\nTham số:\na (int): Số nguyên thứ nhất.\nb (int): Số nguyên thứ hai.\nc (int): Số nguyên thứ ba.\n\nTrả về:\nTuple[int, int]: Một tuple không phải là khái niệm trong C; thay vào đó, chúng ta sẽ trả về bằng tham chiếu.\n\n>>> Ví dụ gọi:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid f_4(int a, int b, int c, int *max, int *min)", "id": "#include <cassert>\n#include <cstdio>\n/*\nTemukan nilai maksimum dan minimum dari tiga bilangan bulat yang berbeda.\nParameter:\na (int): Bilangan bulat pertama.\nb (int): Bilangan bulat kedua.\nc (int): Bilangan bulat ketiga.\n\nMengembalikan:\nTuple[int, int]: Tuple bukanlah konsep dalam C; sebagai gantinya, kita akan mengembalikan melalui referensi.\n\n>>> Contoh pemanggilan: \nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid f_4(int a, int b, int c, int *max, int *min)", "ja": "#include <cassert>\n#include <cstdio>\n/*\n3つの異なる整数の最大値と最小値を見つけます。\nパラメータ:\na (int): 最初の整数。\nb (int): 2番目の整数。\nc (int): 3番目の整数。\n\n戻り値:\nTuple[int, int]: Cにはタプルの概念がないため、参照によって返します。\n\n>>> 例の呼び出し: \nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid f_4(int a, int b, int c, int *max, int *min)", "ko": "#include <cassert>\n#include <cstdio>\n/*\n세 개의 서로 다른 정수의 최대값과 최소값을 찾습니다.\n매개변수:\na (int): 첫 번째 정수.\nb (int): 두 번째 정수.\nc (int): 세 번째 정수.\n\n반환:\nTuple[int, int]: 튜플은 C에서 개념이 아니므로, 참조로 반환합니다.\n\n>>> 예시 호출: \nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid f_4(int a, int b, int c, int *max, int *min)", "ml": "#include <cassert>\n#include <cstdio>\n/*\nമൂന്ന് വ്യത്യസ്തമായ പൂർണ്ണസംഖ്യകളിൽ പരമാവധിയും കുറഞ്ഞതും കണ്ടെത്തുക.\nപാരാമീറ്ററുകൾ:\na (int): ആദ്യത്തെ പൂർണ്ണസംഖ്യ.\nb (int): രണ്ടാം പൂർണ്ണസംഖ്യ.\nc (int): മൂന്നാമത്തെ പൂർണ്ണസംഖ്യ.\n\nമടക്കുന്നു:\nTuple[int, int]: C-യിൽ ഒരു ട്യൂപ്പിൾ എന്ന ആശയം ഇല്ല; പകരം, ഞങ്ങൾ റഫറൻസിലൂടെ മടക്കും.\n\n>>> ഉദാഹരണ കോൾ: \nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid f_4(int a, int b, int c, int *max, int *min)", "fa": "#include <cassert>\n#include <cstdio>\n/*\nحداکثر و حداقل سه عدد صحیح متمایز را پیدا کنید.\nپارامترها:\na (int): عدد صحیح اول.\nb (int): عدد صحیح دوم.\nc (int): عدد صحیح سوم.\n\nبازگشت:\nTuple[int, int]: تاپل یک مفهوم در C نیست؛ در عوض، ما با ارجاع برمی‌گردانیم.\n\n>>> مثال فراخوانی: \nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid f_4(int a, int b, int c, int *max, int *min)"}, "canonical_solution": "{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else if (b > c) {\n        *max = b;\n        *min = (a < c) ? a : c;\n    } else {\n        *max = c;\n        *min = a;\n    }\n}", "instruction": {"en": "Write a CPP function `void f_4(int a, int b, int c, int *max, int *min)` to solve the following problem:\nFind the maximum and minimum of three distinct integers.\nParameters:\na (int): The first integer.\nb (int): The second integer.\nc (int): The third integer.\n\nReturns:\nTuple[int, int]: A tuple is not a concept in C; instead, we will return by reference.\n\n>>> Example call:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n", "sq": "Shkruani një funksion CPP `void f_4(int a, int b, int c, int *max, int *min)` për të zgjidhur problemin e mëposhtëm:  \nGjeni maksimumin dhe minimumin e tre numrave të plotë të ndryshëm.  \nParametrat:  \na (int): Numri i parë i plotë.  \nb (int): Numri i dytë i plotë.  \nc (int): Numri i tretë i plotë.  \n\nKthen:  \nTuple[int, int]: Një tuple nuk është një koncept në C; në vend të kësaj, ne do të kthejmë me referencë.  \n\n>>> Shembull thirrjeje:  \nint max, min;  \nf_4(1,2,3, &max, &min);  \nassert(max == 3 && min == 1);  ", "hy": "Գրեք CPP ֆունկցիա `void f_4(int a, int b, int c, int *max, int *min)` հետևյալ խնդիրը լուծելու համար:\nԳտնել երեք տարբեր ամբողջ թվերի առավելագույնը և նվազագույնը։\nՊարամետրեր:\na (int): Առաջին ամբողջ թիվը։\nb (int): Երկրորդ ամբողջ թիվը։\nc (int): Երրորդ ամբողջ թիվը։\n\nՎերադարձնում է:\nTuple[int, int]: Tuple-ը C-ում հասկացություն չէ; փոխարենը մենք կվերադարձնենք հղումով։\n\n>>> Օրինակ կանչ:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "bn": "একটি CPP ফাংশন `void f_4(int a, int b, int c, int *max, int *min)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nতিনটি পৃথক পূর্ণসংখ্যার মধ্যে সর্বাধিক এবং সর্বনিম্ন খুঁজে বের করুন।\nপ্যারামিটারসমূহ:\na (int): প্রথম পূর্ণসংখ্যা।\nb (int): দ্বিতীয় পূর্ণসংখ্যা।\nc (int): তৃতীয় পূর্ণসংখ্যা।\n\nফেরত:\nTuple[int, int]: একটি টিউপল C তে একটি ধারণা নয়; পরিবর্তে, আমরা রেফারেন্স দ্বারা ফেরত দেব।\n\n>>> উদাহরণ কল:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "bg": "Напишете CPP функция `void f_4(int a, int b, int c, int *max, int *min)`, за да решите следния проблем:\nНамерете максимума и минимума на три различни цели числа.\nПараметри:\na (int): Първото цяло число.\nb (int): Второто цяло число.\nc (int): Третото цяло число.\n\nВръща:\nTuple[int, int]: Кортеж не е концепция в C; вместо това ще върнем чрез препратка.\n\n>>> Примерно извикване:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "zh": "编写一个 CPP 函数 `void f_4(int a, int b, int c, int *max, int *min)` 来解决以下问题：\n找出三个不同整数的最大值和最小值。\n参数：\na (int): 第一个整数。\nb (int): 第二个整数。\nc (int): 第三个整数。\n\n返回：\nTuple[int, int]: 在 C 中没有元组的概念，我们将通过引用返回。\n\n>>> 示例调用:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "fr": "Écrire une fonction CPP `void f_4(int a, int b, int c, int *max, int *min)` pour résoudre le problème suivant :  \nTrouver le maximum et le minimum de trois entiers distincts.  \nParamètres :  \na (int) : Le premier entier.  \nb (int) : Le deuxième entier.  \nc (int) : Le troisième entier.  \n\nRenvoie :  \nTuple[int, int] : Un tuple n'est pas un concept en C ; à la place, nous allons retourner par référence.\n\n>>> Exemple d'appel :  \nint max, min;  \nf_4(1,2,3, &max, &min);  \nassert(max == 3 && min == 1);  ", "de": "Schreiben Sie eine CPP-Funktion `void f_4(int a, int b, int c, int *max, int *min)`, um das folgende Problem zu lösen:\nFinden Sie das Maximum und Minimum von drei verschiedenen ganzen Zahlen.\nParameter:\na (int): Die erste ganze Zahl.\nb (int): Die zweite ganze Zahl.\nc (int): Die dritte ganze Zahl.\n\nRückgabe:\nTuple[int, int]: Ein Tupel ist kein Konzept in C; stattdessen werden wir per Referenz zurückgeben.\n\n>>> Beispielaufruf:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "ha": "Rubuta aikin CPP `void f_4(int a, int b, int c, int *max, int *min)` don warware matsalar mai zuwa:\nNemo mafi girma da mafi ƙanƙanta daga cikin lambobi guda uku daban-daban.\nSigogi:\na (int): Lamba ta farko.\nb (int): Lamba ta biyu.\nc (int): Lamba ta uku.\n\nDawowa:\nTuple[int, int]: Ba a san ma'anar tuple a cikin C; maimakon haka, za mu dawo ta hanyar tunani.\n\n>>> Misalin kira:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "hi": "एक CPP फ़ंक्शन `void f_4(int a, int b, int c, int *max, int *min)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nतीन भिन्न पूर्णांकों में से अधिकतम और न्यूनतम खोजें।\nपैरामीटर्स:\na (int): पहला पूर्णांक।\nb (int): दूसरा पूर्णांक।\nc (int): तीसरा पूर्णांक।\n\nवापसी:\nTuple[int, int]: C में एक ट्यूपल एक अवधारणा नहीं है; इसके बजाय, हम संदर्भ द्वारा वापस करेंगे।\n\n>>> उदाहरण कॉल:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "hu": "Írjon egy CPP függvényt `void f_4(int a, int b, int c, int *max, int *min)` a következő probléma megoldására:\nKeresse meg három különböző egész szám maximumát és minimumát.\nParaméterek:\na (int): Az első egész szám.\nb (int): A második egész szám.\nc (int): A harmadik egész szám.\n\nVisszatérési érték:\nTuple[int, int]: A tuple nem egy fogalom a C-ben; ehelyett referencia alapján fogunk visszatérni.\n\n>>> Példa hívás:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "es": "Escribe una función CPP `void f_4(int a, int b, int c, int *max, int *min)` para resolver el siguiente problema:\nEncuentra el máximo y mínimo de tres enteros distintos.\nParámetros:\na (int): El primer entero.\nb (int): El segundo entero.\nc (int): El tercer entero.\n\nDevuelve:\nTuple[int, int]: Una tupla no es un concepto en C; en su lugar, devolveremos por referencia.\n\n>>> Llamada de ejemplo:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "arb": "اكتب دالة CPP `void f_4(int a, int b, int c, int *max, int *min)` لحل المشكلة التالية:\nإيجاد القيمة العظمى والصغرى لثلاثة أعداد صحيحة مميزة.\nالمعلمات:\na (int): العدد الصحيح الأول.\nb (int): العدد الصحيح الثاني.\nc (int): العدد الصحيح الثالث.\n\nالإرجاع:\nTuple[int, int]: الكائن Tuple ليس مفهومًا في C؛ بدلاً من ذلك، سنقوم بالإرجاع عن طريق المرجع.\n\n>>> مثال على الاستدعاء:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "sw": "Andika kazi ya CPP `void f_4(int a, int b, int c, int *max, int *min)` kutatua tatizo lifuatalo:\nPata kubwa na ndogo kati ya namba tatu tofauti za mzima.\nVigezo:\na (int): Namba ya kwanza ya mzima.\nb (int): Namba ya pili ya mzima.\nc (int): Namba ya tatu ya mzima.\n\nRudisha:\nTuple[int, int]: Tuple si dhana katika C; badala yake, tutarudisha kwa marejeleo.\n\n>>> Mfano wa kuita:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "tr": "Bir CPP fonksiyonu `void f_4(int a, int b, int c, int *max, int *min)` yazın ve aşağıdaki problemi çözün:\nÜç farklı tam sayının maksimum ve minimumunu bulun.\nParametreler:\na (int): Birinci tam sayı.\nb (int): İkinci tam sayı.\nc (int): Üçüncü tam sayı.\n\nDöndürülenler:\nTuple[int, int]: C'de bir tuple kavramı yoktur; bunun yerine referansla döneceğiz.\n\n>>> Örnek çağrı:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "vi": "Viết một hàm CPP `void f_4(int a, int b, int c, int *max, int *min)` để giải quyết vấn đề sau:\nTìm giá trị lớn nhất và nhỏ nhất của ba số nguyên khác nhau.\nTham số:\na (int): Số nguyên thứ nhất.\nb (int): Số nguyên thứ hai.\nc (int): Số nguyên thứ ba.\n\nTrả về:\nTuple[int, int]: Tuple không phải là một khái niệm trong C; thay vào đó, chúng ta sẽ trả về bằng tham chiếu.\n\n>>> Ví dụ gọi:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "id": "Tulis fungsi CPP `void f_4(int a, int b, int c, int *max, int *min)` untuk menyelesaikan masalah berikut:\nTemukan nilai maksimum dan minimum dari tiga bilangan bulat yang berbeda.\nParameter:\na (int): Bilangan bulat pertama.\nb (int): Bilangan bulat kedua.\nc (int): Bilangan bulat ketiga.\n\nMengembalikan:\nTuple[int, int]: Tuple bukanlah konsep dalam C; sebagai gantinya, kita akan mengembalikan melalui referensi.\n\n>>> Contoh pemanggilan:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "ja": "CPP関数 `void f_4(int a, int b, int c, int *max, int *min)` を作成して、次の問題を解決してください:\n3つの異なる整数の最大値と最小値を見つけます。\nパラメータ:\na (int): 最初の整数。\nb (int): 2番目の整数。\nc (int): 3番目の整数。\n\n戻り値:\nTuple[int, int]: タプルはCの概念ではないため、参照によって返します。\n\n>>> 呼び出し例:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "ko": "CPP 함수를 작성하세요 `void f_4(int a, int b, int c, int *max, int *min)` 다음 문제를 해결하기 위해:\n세 개의 서로 다른 정수의 최대값과 최소값을 찾습니다.\n매개변수:\na (int): 첫 번째 정수.\nb (int): 두 번째 정수.\nc (int): 세 번째 정수.\n\n반환값:\nTuple[int, int]: C에는 튜플이라는 개념이 없으므로, 참조에 의해 반환합니다.\n\n>>> 예시 호출:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "ml": "`void f_4(int a, int b, int c, int *max, int *min)` എന്ന CPP ഫംഗ്ഷൻ എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nമൂന്ന് വ്യത്യസ്തമായ പൂർണ്ണസംഖ്യകളിൽ പരമാവധിയും പരമാവധിയും കണ്ടെത്തുക.\nപാരാമീറ്ററുകൾ:\na (int): ആദ്യ പൂർണ്ണസംഖ്യ.\nb (int): രണ്ടാം പൂർണ്ണസംഖ്യ.\nc (int): മൂന്നാം പൂർണ്ണസംഖ്യ.\n\nമടക്കുക:\nTuple[int, int]: C-യിൽ ട്യൂപ്പിൾ എന്ന ആശയം ഇല്ല; പകരം, നാം റഫറൻസിലൂടെ മടക്കും.\n\n>>> ഉദാഹരണ കോൾ:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "fa": "یک تابع CPP `void f_4(int a, int b, int c, int *max, int *min)` بنویسید تا مسئله زیر را حل کند:\nحداکثر و حداقل سه عدد صحیح متمایز را پیدا کنید.\nپارامترها:\na (int): عدد صحیح اول.\nb (int): عدد صحیح دوم.\nc (int): عدد صحیح سوم.\n\nبازگشت:\nTuple[int, int]: تاپل یک مفهوم در C نیست؛ در عوض، ما با ارجاع برمی‌گردانیم.\n\n>>> مثال فراخوانی:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);"}, "level": "easy", "test": "int main() {\n    int max, min;\n\n    // Test with a set of values\n    f_4(1, 2, 3, &max, &min);\n    assert(max == 3 && min == 1);\n\n    // Additional tests\n    f_4(5, 3, 4, &max, &min);\n    assert(max == 5 && min == 3);\n\n    f_4(10, -2, 7, &max, &min);\n    assert(max == 10 && min == -2);\n\n    f_4(-1, -3, -2, &max, &min);\n    assert(max == -1 && min == -3);\n\n    return 0;\n}", "entry_point": "f_4", "signature": "void f_4(int a, int b, int c, int *max, int *min)", "docstring": {"en": "Find the maximum and minimum of three distinct integers.\nParameters:\na (int): The first integer.\nb (int): The second integer.\nc (int): The third integer.\n\nReturns:\nTuple[int, int]: A tuple is not a concept in C; instead, we will return by reference.\n\n>>> Example call:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n", "sq": "Gjeni maksimumin dhe minimumin e tre numrave të plotë të dallueshëm.\nParametrat:\na (int): Numri i parë i plotë.\nb (int): Numri i dytë i plotë.\nc (int): Numri i tretë i plotë.\n\nKthen:\nTuple[int, int]: Një tuple nuk është një koncept në C; në vend të kësaj, ne do të kthejmë me referencë.\n\n>>> Thirrje shembull:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "hy": "Երեք տարբեր ամբողջ թվերի առավելագույնը և նվազագույնը գտնել:\nՊարամետրեր:\na (int): Առաջին ամբողջ թիվը:\nb (int): Երկրորդ ամբողջ թիվը:\nc (int): Երրորդ ամբողջ թիվը:\n\nՎերադարձնում է:\nTuple[int, int]: Կապ չի հանդիսանում C-ում հասկացություն; փոխարենը մենք կվերադարձնենք հղումով:\n\n>>> Օրինակ կանչ:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "bn": "তিনটি ভিন্ন পূর্ণসংখ্যার সর্বাধিক এবং সর্বনিম্ন মান খুঁজে বের করুন।\nParameters:\na (int): প্রথম পূর্ণসংখ্যা।\nb (int): দ্বিতীয় পূর্ণসংখ্যা।\nc (int): তৃতীয় পূর্ণসংখ্যা।\n\nReturns:\nTuple[int, int]: একটি টিউপল C তে একটি ধারণা নয়; পরিবর্তে, আমরা রেফারেন্স দ্বারা ফেরত দেব।\n\n>>> উদাহরণ কল:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "bg": "Намерете максимума и минимума на три различни цели числа.\nПараметри:\na (int): Първото цяло число.\nb (int): Второто цяло число.\nc (int): Третото цяло число.\n\nВръща:\nTuple[int, int]: Кортежът не е концепция в C; вместо това ще върнем чрез референция.\n\n>>> Примерно извикване:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "zh": "找出三个不同整数的最大值和最小值。\n参数：\na (int): 第一个整数。\nb (int): 第二个整数。\nc (int): 第三个整数。\n\n返回：\nTuple[int, int]: 在C语言中没有元组的概念，因此我们将通过引用返回。\n\n>>> 示例调用：\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "fr": "Trouver le maximum et le minimum de trois entiers distincts.  \nParamètres :  \na (int) : Le premier entier.  \nb (int) : Le deuxième entier.  \nc (int) : Le troisième entier.  \n\nRenvoie :  \nTuple[int, int] : Un tuple n'est pas un concept en C ; à la place, nous renverrons par référence.  \n\n>>> Exemple d'appel :  \nint max, min;  \nf_4(1,2,3, &max, &min);  \nassert(max == 3 && min == 1);  ", "de": "Finde das Maximum und Minimum von drei verschiedenen ganzen Zahlen.\nParameter:\na (int): Die erste ganze Zahl.\nb (int): Die zweite ganze Zahl.\nc (int): Die dritte ganze Zahl.\n\nRückgabewerte:\nTuple[int, int]: Ein Tupel ist kein Konzept in C; stattdessen werden wir durch Referenz zurückgeben.\n\n>>> Beispielaufruf:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "ha": "Nemo mafi girma da mafi ƙanƙanta daga cikin lambobi guda uku masu bambanta.  \nSigogi:  \na (int): Lamba ta farko.  \nb (int): Lamba ta biyu.  \nc (int): Lamba ta uku.  \n\nDawowa:  \nTuple[int, int]: Tuple ba wani abu bane a cikin C; maimakon haka, za mu dawo ta hanyar tunani.  \n\n>>> Misalin kira:  \nint max, min;  \nf_4(1,2,3, &max, &min);  \nassert(max == 3 && min == 1);  ", "hi": "तीन भिन्न पूर्णांकों का अधिकतम और न्यूनतम मान खोजें।\nमापदंड:\na (int): पहला पूर्णांक।\nb (int): दूसरा पूर्णांक।\nc (int): तीसरा पूर्णांक।\n\nवापसी:\nTuple[int, int]: एक ट्यूपल C में एक अवधारणा नहीं है; इसके बजाय, हम संदर्भ द्वारा वापस करेंगे।\n\n>>> उदाहरण कॉल:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "hu": "Keresse meg három különböző egész szám maximumát és minimumát.  \nParaméterek:  \na (int): Az első egész szám.  \nb (int): A második egész szám.  \nc (int): A harmadik egész szám.  \n\nVisszatér:  \nTuple[int, int]: A tuple nem egy fogalom a C nyelvben; ehelyett referencia alapján térünk vissza.  \n\n>>> Példa hívás:  \nint max, min;  \nf_4(1,2,3, &max, &min);  \nassert(max == 3 && min == 1);  ", "es": "Encuentra el máximo y el mínimo de tres enteros distintos.  \nParámetros:  \na (int): El primer entero.  \nb (int): El segundo entero.  \nc (int): El tercer entero.  \n\nDevuelve:  \nTuple[int, int]: Una tupla no es un concepto en C; en su lugar, devolveremos por referencia.  \n\n>>> Llamada de ejemplo:  \nint max, min;  \nf_4(1,2,3, &max, &min);  \nassert(max == 3 && min == 1);  ", "arb": "إيجاد القيمة القصوى والدنيا لثلاثة أعداد صحيحة مميزة.\nالمعلمات:\na (int): العدد الصحيح الأول.\nb (int): العدد الصحيح الثاني.\nc (int): العدد الصحيح الثالث.\n\nالقيم المعادة:\nTuple[int, int]: الزوج ليس مفهومًا في C؛ بدلاً من ذلك، سنعيد بالقيمة المرجعية.\n\n>>> مثال على الاستدعاء:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "sw": "Pata kubwa na ndogo kati ya nambari tatu tofauti za mzima.\n\nVigezo:\na (int): Nambari ya kwanza ya mzima.\nb (int): Nambari ya pili ya mzima.\nc (int): Nambari ya tatu ya mzima.\n\nInarejesha:\nTuple[int, int]: Tuple sio dhana katika C; badala yake, tutarejesha kwa marejeleo.\n\n>>> Mfano wa kupiga:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "tr": "Üç farklı tam sayının maksimum ve minimumunu bulun.\nParametreler:\na (int): Birinci tam sayı.\nb (int): İkinci tam sayı.\nc (int): Üçüncü tam sayı.\n\nDöndürür:\nTuple[int, int]: C'de bir kavram olarak tuple yoktur; bunun yerine referansla döndüreceğiz.\n\n>>> Örnek çağrı:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "vi": "Tìm giá trị lớn nhất và nhỏ nhất của ba số nguyên khác nhau.\nTham số:\na (int): Số nguyên thứ nhất.\nb (int): Số nguyên thứ hai.\nc (int): Số nguyên thứ ba.\n\nTrả về:\nTuple[int, int]: Một tuple không phải là khái niệm trong C; thay vào đó, chúng ta sẽ trả về bằng tham chiếu.\n\n>>> Ví dụ gọi:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "id": "Temukan nilai maksimum dan minimum dari tiga bilangan bulat yang berbeda.\nParameter:\na (int): Bilangan bulat pertama.\nb (int): Bilangan bulat kedua.\nc (int): Bilangan bulat ketiga.\n\nMengembalikan:\nTuple[int, int]: Tuple bukanlah konsep dalam C; sebagai gantinya, kita akan mengembalikan melalui referensi.\n\n>>> Contoh pemanggilan:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "ja": "3つの異なる整数の最大値と最小値を見つけます。\nパラメータ:\na (int): 最初の整数。\nb (int): 2番目の整数。\nc (int): 3番目の整数。\n\n戻り値:\nTuple[int, int]: タプルはCの概念ではないため、参照によって返します。\n\n>>> 使用例:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "ko": "세 개의 서로 다른 정수 중 최대값과 최소값을 찾습니다.  \n매개변수:  \na (int): 첫 번째 정수.  \nb (int): 두 번째 정수.  \nc (int): 세 번째 정수.  \n\n반환:  \nTuple[int, int]: 튜플은 C에서 개념이 아니므로, 참조로 반환합니다.  \n\n>>> 예시 호출:  \nint max, min;  \nf_4(1,2,3, &max, &min);  \nassert(max == 3 && min == 1);  ", "ml": "മൂന്ന് വ്യത്യസ്തമായ പൂർണ്ണസംഖ്യകളിൽ പരമാവധിയും കുറഞ്ഞതും കണ്ടെത്തുക.\nപാരാമീറ്ററുകൾ:\na (int): ആദ്യത്തെ പൂർണ്ണസംഖ്യ.\nb (int): രണ്ടാം പൂർണ്ണസംഖ്യ.\nc (int): മൂന്നാം പൂർണ്ണസംഖ്യ.\n\nമടങ്ങിവരവ്:\nTuple[int, int]: ട്യൂപ്പിൾ എന്നത് C-യിൽ ഒരു ആശയം അല്ല; പകരം, നാം റഫറൻസിലൂടെ മടക്കം ചെയ്യും.\n\n>>> ഉദാഹരണ കോൾ:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "fa": "حداکثر و حداقل سه عدد صحیح متمایز را پیدا کنید.\nپارامترها:\na (int): عدد صحیح اول.\nb (int): عدد صحیح دوم.\nc (int): عدد صحیح سوم.\n\nبازگشت:\nTuple[int, int]: تاپل یک مفهوم در C نیست؛ در عوض، ما با ارجاع باز خواهیم گشت.\n\n>>> مثال فراخوانی:\nint max, min;\nf_4(1,2,3, &max, &min);\nassert(max == 3 && min == 1);"}}
{"task_id": "CPP/5", "prompt": {"en": "#include <cassert>\n#include <cmath>\n#include <cstring>\n/**\n * Calculate the distance between two points A (xa, ya) and B (xb, yb).\n * \n * Parameters:\n * - xa (double): x-coordinate of point A.\n * - ya (double): y-coordinate of point A.\n * - xb (double): x-coordinate of point B.\n * - yb (double): y-coordinate of point B.\n * \n * Returns:\n * double: The distance between points A and B.\n * \n * Examples:\n * f_5(0, 0, 3, 4) returns 5\n */\ndouble f_5(double xa, double ya, double xb, double yb)", "sq": "#include <cassert>\n#include <cmath>\n#include <cstring>\n/**\n * Llogarit distancën midis dy pikave A (xa, ya) dhe B (xb, yb).\n * \n * Parametrat:\n * - xa (double): koordinata x e pikës A.\n * - ya (double): koordinata y e pikës A.\n * - xb (double): koordinata x e pikës B.\n * - yb (double): koordinata y e pikës B.\n * \n * Kthen:\n * double: Distanca midis pikave A dhe B.\n * \n * Shembuj:\n * f_5(0, 0, 3, 4) kthen 5\n */\ndouble f_5(double xa, double ya, double xb, double yb)", "hy": "#include <cassert>\n#include <cmath>\n#include <cstring>\n/**\n * Հաշվել հեռավորությունը երկու կետերի A (xa, ya) և B (xb, yb) միջև։\n * \n * Պարամետրեր:\n * - xa (double): A կետի x-կոորդինատը։\n * - ya (double): A կետի y-կոորդինատը։\n * - xb (double): B կետի x-կոորդինատը։\n * - yb (double): B կետի y-կոորդինատը։\n * \n * Վերադարձնում է:\n * double: Հեռավորությունը A և B կետերի միջև։\n * \n * Օրինակներ:\n * f_5(0, 0, 3, 4) վերադարձնում է 5\n */\ndouble f_5(double xa, double ya, double xb, double yb)", "bn": "#include <cassert>\n#include <cmath>\n#include <cstring>\n/**\n * দুটি বিন্দু A (xa, ya) এবং B (xb, yb) এর মধ্যে দূরত্ব গণনা করুন।\n * \n * প্যারামিটার:\n * - xa (double): বিন্দু A এর x-অক্ষাংশ।\n * - ya (double): বিন্দু A এর y-অক্ষাংশ।\n * - xb (double): বিন্দু B এর x-অক্ষাংশ।\n * - yb (double): বিন্দু B এর y-অক্ষাংশ।\n * \n * রিটার্নস:\n * double: বিন্দু A এবং B এর মধ্যে দূরত্ব।\n * \n * উদাহরণ:\n * f_5(0, 0, 3, 4) returns 5\n */\ndouble f_5(double xa, double ya, double xb, double yb)", "bg": "#include <cassert>\n#include <cmath>\n#include <cstring>\n/**\n * Изчисляване на разстоянието между две точки A (xa, ya) и B (xb, yb).\n * \n * Параметри:\n * - xa (double): x-координата на точка A.\n * - ya (double): y-координата на точка A.\n * - xb (double): x-координата на точка B.\n * - yb (double): y-координата на точка B.\n * \n * Връща:\n * double: Разстоянието между точките A и B.\n * \n * Примери:\n * f_5(0, 0, 3, 4) връща 5\n */\ndouble f_5(double xa, double ya, double xb, double yb)", "zh": "#include <cassert>\n#include <cmath>\n#include <cstring>\n/**\n * 计算两个点 A (xa, ya) 和 B (xb, yb) 之间的距离。\n * \n * 参数:\n * - xa (double): 点 A 的 x 坐标。\n * - ya (double): 点 A 的 y 坐标。\n * - xb (double): 点 B 的 x 坐标。\n * - yb (double): 点 B 的 y 坐标。\n * \n * 返回:\n * double: 点 A 和 B 之间的距离。\n * \n * 示例:\n * f_5(0, 0, 3, 4) 返回 5\n */\ndouble f_5(double xa, double ya, double xb, double yb)", "fr": "#include <cassert>\n#include <cmath>\n#include <cstring>\n/**\n * Calculer la distance entre deux points A (xa, ya) et B (xb, yb).\n * \n * Paramètres :\n * - xa (double) : coordonnée x du point A.\n * - ya (double) : coordonnée y du point A.\n * - xb (double) : coordonnée x du point B.\n * - yb (double) : coordonnée y du point B.\n * \n * Renvoie :\n * double : La distance entre les points A et B.\n * \n * Exemples :\n * f_5(0, 0, 3, 4) returns 5\n */\ndouble f_5(double xa, double ya, double xb, double yb)", "de": "#include <cassert>\n#include <cmath>\n#include <cstring>\n/**\n * Berechne die Entfernung zwischen zwei Punkten A (xa, ya) und B (xb, yb).\n * \n * Parameter:\n * - xa (double): x-Koordinate des Punktes A.\n * - ya (double): y-Koordinate des Punktes A.\n * - xb (double): x-Koordinate des Punktes B.\n * - yb (double): y-Koordinate des Punktes B.\n * \n * Rückgabewert:\n * double: Die Entfernung zwischen den Punkten A und B.\n * \n * Beispiele:\n * f_5(0, 0, 3, 4) gibt 5 zurück\n */\ndouble f_5(double xa, double ya, double xb, double yb)", "ha": "#include <cassert>\n#include <cmath>\n#include <cstring>\n/**\n * Lissafi nisan tsakanin maki biyu A (xa, ya) da B (xb, yb).\n * \n * Sigogi:\n * - xa (double): x-daidaici na maki A.\n * - ya (double): y-daidaici na maki A.\n * - xb (double): x-daidaici na maki B.\n * - yb (double): y-daidaici na maki B.\n * \n * Komawa:\n * double: Nisan tsakanin maki A da B.\n * \n * Misalai:\n * f_5(0, 0, 3, 4) returns 5\n */\ndouble f_5(double xa, double ya, double xb, double yb)", "hi": "#include <cassert>\n#include <cmath>\n#include <cstring>\n/**\n * दो बिंदुओं A (xa, ya) और B (xb, yb) के बीच की दूरी की गणना करें।\n * \n * पैरामीटर्स:\n * - xa (double): बिंदु A का x-निर्देशांक।\n * - ya (double): बिंदु A का y-निर्देशांक।\n * - xb (double): बिंदु B का x-निर्देशांक।\n * - yb (double): बिंदु B का y-निर्देशांक।\n * \n * रिटर्न करता है:\n * double: बिंदुओं A और B के बीच की दूरी।\n * \n * उदाहरण:\n * f_5(0, 0, 3, 4) returns 5\n */\ndouble f_5(double xa, double ya, double xb, double yb)", "hu": "#include <cassert>\n#include <cmath>\n#include <cstring>\n/**\n * Számítsa ki a távolságot két pont, A (xa, ya) és B (xb, yb) között.\n * \n * Paraméterek:\n * - xa (double): A pont x-koordinátája.\n * - ya (double): A pont y-koordinátája.\n * - xb (double): B pont x-koordinátája.\n * - yb (double): B pont y-koordinátája.\n * \n * Visszatérési érték:\n * double: A távolság A és B pontok között.\n * \n * Példák:\n * f_5(0, 0, 3, 4) visszaadja 5\n */\ndouble f_5(double xa, double ya, double xb, double yb)", "es": "#include <cassert>\n#include <cmath>\n#include <cstring>\n/**\n * Calcular la distancia entre dos puntos A (xa, ya) y B (xb, yb).\n * \n * Parámetros:\n * - xa (double): coordenada x del punto A.\n * - ya (double): coordenada y del punto A.\n * - xb (double): coordenada x del punto B.\n * - yb (double): coordenada y del punto B.\n * \n * Devuelve:\n * double: La distancia entre los puntos A y B.\n * \n * Ejemplos:\n * f_5(0, 0, 3, 4) devuelve 5\n */\ndouble f_5(double xa, double ya, double xb, double yb)", "arb": "#include <cassert>\n#include <cmath>\n#include <cstring>\n/**\n * حساب المسافة بين نقطتين A (xa, ya) و B (xb, yb).\n * \n * المعاملات:\n * - xa (double): الإحداثي السيني للنقطة A.\n * - ya (double): الإحداثي الصادي للنقطة A.\n * - xb (double): الإحداثي السيني للنقطة B.\n * - yb (double): الإحداثي الصادي للنقطة B.\n * \n * يعيد:\n * double: المسافة بين النقطتين A و B.\n * \n * أمثلة:\n * f_5(0, 0, 3, 4) يعيد 5\n */\ndouble f_5(double xa, double ya, double xb, double yb)", "sw": "#include <cassert>\n#include <cmath>\n#include <cstring>\n/**\n * Hesabu umbali kati ya pointi mbili A (xa, ya) na B (xb, yb).\n * \n * Vigezo:\n * - xa (double): x-kiwango cha pointi A.\n * - ya (double): y-kiwango cha pointi A.\n * - xb (double): x-kiwango cha pointi B.\n * - yb (double): y-kiwango cha pointi B.\n * \n * Inarudisha:\n * double: Umbali kati ya pointi A na B.\n * \n * Mifano:\n * f_5(0, 0, 3, 4) inarudisha 5\n */\ndouble f_5(double xa, double ya, double xb, double yb)", "tr": "#include <cassert>\n#include <cmath>\n#include <cstring>\n/**\n * İki nokta A (xa, ya) ve B (xb, yb) arasındaki mesafeyi hesapla.\n * \n * Parametreler:\n * - xa (double): A noktasının x-koordinatı.\n * - ya (double): A noktasının y-koordinatı.\n * - xb (double): B noktasının x-koordinatı.\n * - yb (double): B noktasının y-koordinatı.\n * \n * Döndürülen:\n * double: A ve B noktaları arasındaki mesafe.\n * \n * Örnekler:\n * f_5(0, 0, 3, 4) 5 döndürür\n */\ndouble f_5(double xa, double ya, double xb, double yb)", "vi": "#include <cassert>\n#include <cmath>\n#include <cstring>\n/**\n * Tính khoảng cách giữa hai điểm A (xa, ya) và B (xb, yb).\n * \n * Tham số:\n * - xa (double): tọa độ x của điểm A.\n * - ya (double): tọa độ y của điểm A.\n * - xb (double): tọa độ x của điểm B.\n * - yb (double): tọa độ y của điểm B.\n * \n * Trả về:\n * double: Khoảng cách giữa điểm A và B.\n * \n * Ví dụ:\n * f_5(0, 0, 3, 4) trả về 5\n */\ndouble f_5(double xa, double ya, double xb, double yb)", "id": "#include <cassert>\n#include <cmath>\n#include <cstring>\n/**\n * Hitung jarak antara dua titik A (xa, ya) dan B (xb, yb).\n * \n * Parameter:\n * - xa (double): koordinat x dari titik A.\n * - ya (double): koordinat y dari titik A.\n * - xb (double): koordinat x dari titik B.\n * - yb (double): koordinat y dari titik B.\n * \n * Mengembalikan:\n * double: Jarak antara titik A dan B.\n * \n * Contoh:\n * f_5(0, 0, 3, 4) mengembalikan 5\n */\ndouble f_5(double xa, double ya, double xb, double yb)", "ja": "#include <cassert>\n#include <cmath>\n#include <cstring>\n/**\n * 2つの点A (xa, ya) とB (xb, yb) の間の距離を計算します。\n * \n * パラメータ:\n * - xa (double): 点Aのx座標。\n * - ya (double): 点Aのy座標。\n * - xb (double): 点Bのx座標。\n * - yb (double): 点Bのy座標。\n * \n * 戻り値:\n * double: 点AとBの間の距離。\n * \n * 例:\n * f_5(0, 0, 3, 4) は5を返します\n */\ndouble f_5(double xa, double ya, double xb, double yb)", "ko": "#include <cassert>\n#include <cmath>\n#include <cstring>\n/**\n * 두 점 A (xa, ya)와 B (xb, yb) 사이의 거리를 계산합니다.\n * \n * 매개변수:\n * - xa (double): 점 A의 x-좌표.\n * - ya (double): 점 A의 y-좌표.\n * - xb (double): 점 B의 x-좌표.\n * - yb (double): 점 B의 y-좌표.\n * \n * 반환값:\n * double: 점 A와 B 사이의 거리.\n * \n * 예시:\n * f_5(0, 0, 3, 4) returns 5\n */\ndouble f_5(double xa, double ya, double xb, double yb)", "ml": "#include <cassert>\n#include <cmath>\n#include <cstring>\n/**\n * A (xa, ya) എന്ന രണ്ടു ബിന്ദുക്കൾക്കും B (xb, yb) എന്ന ബിന്ദുക്കൾക്കുമിടയിലെ ദൂരം കണക്കാക്കുക.\n * \n * പാരാമീറ്ററുകൾ:\n * - xa (double): A ബിന്ദുവിന്റെ x-കോഓർഡിനേറ്റ്.\n * - ya (double): A ബിന്ദുവിന്റെ y-കോഓർഡിനേറ്റ്.\n * - xb (double): B ബിന്ദുവിന്റെ x-കോഓർഡിനേറ്റ്.\n * - yb (double): B ബിന്ദുവിന്റെ y-കോഓർഡിനേറ്റ്.\n * \n * തിരികെ നൽകുന്നു:\n * double: A, B ബിന്ദുക്കൾക്കുമിടയിലെ ദൂരം.\n * \n * ഉദാഹരണങ്ങൾ:\n * f_5(0, 0, 3, 4) 5 തിരികെ നൽകുന്നു\n */\ndouble f_5(double xa, double ya, double xb, double yb)", "fa": "#include <cassert>\n#include <cmath>\n#include <cstring>\n/**\n * محاسبه فاصله بین دو نقطه A (xa, ya) و B (xb, yb).\n * \n * پارامترها:\n * - xa (double): مختصات x نقطه A.\n * - ya (double): مختصات y نقطه A.\n * - xb (double): مختصات x نقطه B.\n * - yb (double): مختصات y نقطه B.\n * \n * بازگشت:\n * double: فاصله بین نقاط A و B.\n * \n * مثال‌ها:\n * f_5(0, 0, 3, 4) returns 5\n */\ndouble f_5(double xa, double ya, double xb, double yb)"}, "canonical_solution": "{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}", "instruction": {"en": "Write a CPP function `double f_5(double xa, double ya, double xb, double yb)` to solve the following problem:\nCalculate the distance between two points A (xa, ya) and B (xb, yb).\n\nParameters:\n- xa (double): x-coordinate of point A.\n- ya (double): y-coordinate of point A.\n- xb (double): x-coordinate of point B.\n- yb (double): y-coordinate of point B.\n\nReturns:\ndouble: The distance between points A and B.\n\nExamples:\nf_5(0, 0, 3, 4) returns 5", "sq": "Shkruani një funksion CPP `double f_5(double xa, double ya, double xb, double yb)` për të zgjidhur problemin në vijim:\nLlogarit distancën midis dy pikave A (xa, ya) dhe B (xb, yb).\n\nParametrat:\n- xa (double): koordinata x e pikës A.\n- ya (double): koordinata y e pikës A.\n- xb (double): koordinata x e pikës B.\n- yb (double): koordinata y e pikës B.\n\nKthen:\ndouble: Distanca midis pikave A dhe B.\n\nShembuj:\nf_5(0, 0, 3, 4) kthen 5", "hy": "Գրեք CPP ֆունկցիա `double f_5(double xa, double ya, double xb, double yb)` հետևյալ խնդիրը լուծելու համար:\nՀաշվել հեռավորությունը A (xa, ya) և B (xb, yb) կետերի միջև:\n\nՊարամետրեր:\n- xa (double): A կետի x-կոորդինատը:\n- ya (double): A կետի y-կոորդինատը:\n- xb (double): B կետի x-կոորդինատը:\n- yb (double): B կետի y-կոորդինատը:\n\nՎերադարձնում է:\ndouble: A և B կետերի միջև հեռավորությունը:\n\nՕրինակներ:\nf_5(0, 0, 3, 4) վերադարձնում է 5", "bn": "একটি CPP ফাংশন `double f_5(double xa, double ya, double xb, double yb)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nদুটি বিন্দু A (xa, ya) এবং B (xb, yb) এর মধ্যে দূরত্ব গণনা করুন।\n\nপ্যারামিটারসমূহ:\n- xa (double): বিন্দু A এর x-সমন্বয়।\n- ya (double): বিন্দু A এর y-সমন্বয়।\n- xb (double): বিন্দু B এর x-সমন্বয়।\n- yb (double): বিন্দু B এর y-সমন্বয়।\n\nরিটার্নস:\ndouble: বিন্দু A এবং B এর মধ্যে দূরত্ব।\n\nউদাহরণসমূহ:\nf_5(0, 0, 3, 4) 5 রিটার্ন করে।", "bg": "Напишете CPP функция `double f_5(double xa, double ya, double xb, double yb)` за решаване на следния проблем:  \nИзчислете разстоянието между две точки A (xa, ya) и B (xb, yb).\n\nПараметри:\n- xa (double): x-координата на точка A.\n- ya (double): y-координата на точка A.\n- xb (double): x-координата на точка B.\n- yb (double): y-координата на точка B.\n\nВръща:\ndouble: Разстоянието между точките A и B.\n\nПримери:\nf_5(0, 0, 3, 4) връща 5", "zh": "编写一个 CPP 函数 `double f_5(double xa, double ya, double xb, double yb)` 来解决以下问题：\n计算两点 A (xa, ya) 和 B (xb, yb) 之间的距离。\n\n参数：\n- xa (double): 点 A 的 x 坐标。\n- ya (double): 点 A 的 y 坐标。\n- xb (double): 点 B 的 x 坐标。\n- yb (double): 点 B 的 y 坐标。\n\n返回：\ndouble: 点 A 和 B 之间的距离。\n\n示例：\nf_5(0, 0, 3, 4) 返回 5", "fr": "Écrire une fonction CPP `double f_5(double xa, double ya, double xb, double yb)` pour résoudre le problème suivant :\nCalculer la distance entre deux points A (xa, ya) et B (xb, yb).\n\nParamètres :\n- xa (double) : coordonnée x du point A.\n- ya (double) : coordonnée y du point A.\n- xb (double) : coordonnée x du point B.\n- yb (double) : coordonnée y du point B.\n\nRenvoie :\ndouble : La distance entre les points A et B.\n\nExemples :\nf_5(0, 0, 3, 4) renvoie 5", "de": "Schreiben Sie eine CPP-Funktion `double f_5(double xa, double ya, double xb, double yb)`, um das folgende Problem zu lösen:\nBerechnen Sie die Entfernung zwischen zwei Punkten A (xa, ya) und B (xb, yb).\n\nParameter:\n- xa (double): x-Koordinate des Punktes A.\n- ya (double): y-Koordinate des Punktes A.\n- xb (double): x-Koordinate des Punktes B.\n- yb (double): y-Koordinate des Punktes B.\n\nRückgabewert:\ndouble: Die Entfernung zwischen den Punkten A und B.\n\nBeispiele:\nf_5(0, 0, 3, 4) gibt 5 zurück.", "ha": "Rubuta aikin CPP `double f_5(double xa, double ya, double xb, double yb)` don warware matsalar mai zuwa:\nƘididdige nisan tsakanin maki biyu A (xa, ya) da B (xb, yb).\n\nSigogi:\n- xa (double): x-ƙudurin maki A.\n- ya (double): y-ƙudurin maki A.\n- xb (double): x-ƙudurin maki B.\n- yb (double): y-ƙudurin maki B.\n\nDawowa:\ndouble: Nisan tsakanin maki A da B.\n\nMisalai:\nf_5(0, 0, 3, 4) yana dawowa 5", "hi": "एक CPP फ़ंक्शन `double f_5(double xa, double ya, double xb, double yb)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदो बिंदुओं A (xa, ya) और B (xb, yb) के बीच की दूरी की गणना करें।\n\nपैरामीटर्स:\n- xa (double): बिंदु A का x-निर्देशांक।\n- ya (double): बिंदु A का y-निर्देशांक।\n- xb (double): बिंदु B का x-निर्देशांक।\n- yb (double): बिंदु B का y-निर्देशांक।\n\nवापसी मान:\ndouble: बिंदु A और B के बीच की दूरी।\n\nउदाहरण:\nf_5(0, 0, 3, 4) 5 लौटाता है।", "hu": "Írj egy CPP függvényt `double f_5(double xa, double ya, double xb, double yb)` a következő probléma megoldására:\nSzámítsd ki a távolságot két pont, A (xa, ya) és B (xb, yb) között.\n\nParaméterek:\n- xa (double): A pont x-koordinátája.\n- ya (double): A pont y-koordinátája.\n- xb (double): B pont x-koordinátája.\n- yb (double): B pont y-koordinátája.\n\nVisszatérési érték:\ndouble: A távolság A és B pontok között.\n\nPéldák:\nf_5(0, 0, 3, 4) visszaadja 5", "es": "Escribe una función CPP `double f_5(double xa, double ya, double xb, double yb)` para resolver el siguiente problema:\nCalcular la distancia entre dos puntos A (xa, ya) y B (xb, yb).\n\nParámetros:\n- xa (double): coordenada x del punto A.\n- ya (double): coordenada y del punto A.\n- xb (double): coordenada x del punto B.\n- yb (double): coordenada y del punto B.\n\nDevuelve:\ndouble: La distancia entre los puntos A y B.\n\nEjemplos:\nf_5(0, 0, 3, 4) devuelve 5", "arb": "اكتب دالة CPP `double f_5(double xa, double ya, double xb, double yb)` لحل المشكلة التالية:\nحساب المسافة بين نقطتين A (xa, ya) و B (xb, yb).\n\nالمعطيات:\n- xa (double): الإحداثي السيني للنقطة A.\n- ya (double): الإحداثي الصادي للنقطة A.\n- xb (double): الإحداثي السيني للنقطة B.\n- yb (double): الإحداثي الصادي للنقطة B.\n\nالقيم المعادة:\ndouble: المسافة بين النقطتين A و B.\n\nأمثلة:\nf_5(0, 0, 3, 4) يعيد 5", "sw": "Andika kazi ya CPP `double f_5(double xa, double ya, double xb, double yb)` kutatua tatizo lifuatalo:\nHesabu umbali kati ya pointi mbili A (xa, ya) na B (xb, yb).\n\nVigezo:\n- xa (double): x-kiwianishi cha pointi A.\n- ya (double): y-kiwianishi cha pointi A.\n- xb (double): x-kiwianishi cha pointi B.\n- yb (double): y-kiwianishi cha pointi B.\n\nInarudisha:\ndouble: Umbali kati ya pointi A na B.\n\nMifano:\nf_5(0, 0, 3, 4) inarudisha 5", "tr": "Bir CPP fonksiyonu `double f_5(double xa, double ya, double xb, double yb)` yazın ve aşağıdaki problemi çözün:\nİki nokta A (xa, ya) ve B (xb, yb) arasındaki mesafeyi hesaplayın.\n\nParametreler:\n- xa (double): A noktasının x-koordinatı.\n- ya (double): A noktasının y-koordinatı.\n- xb (double): B noktasının x-koordinatı.\n- yb (double): B noktasının y-koordinatı.\n\nDöndürülen:\ndouble: A ve B noktaları arasındaki mesafe.\n\nÖrnekler:\nf_5(0, 0, 3, 4) 5 döndürür.", "vi": "Viết một hàm CPP `double f_5(double xa, double ya, double xb, double yb)` để giải quyết vấn đề sau:\nTính khoảng cách giữa hai điểm A (xa, ya) và B (xb, yb).\n\nTham số:\n- xa (double): tọa độ x của điểm A.\n- ya (double): tọa độ y của điểm A.\n- xb (double): tọa độ x của điểm B.\n- yb (double): tọa độ y của điểm B.\n\nTrả về:\ndouble: Khoảng cách giữa điểm A và B.\n\nVí dụ:\nf_5(0, 0, 3, 4) trả về 5", "id": "Tulis fungsi CPP `double f_5(double xa, double ya, double xb, double yb)` untuk menyelesaikan masalah berikut:\nHitung jarak antara dua titik A (xa, ya) dan B (xb, yb).\n\nParameter:\n- xa (double): koordinat x dari titik A.\n- ya (double): koordinat y dari titik A.\n- xb (double): koordinat x dari titik B.\n- yb (double): koordinat y dari titik B.\n\nMengembalikan:\ndouble: Jarak antara titik A dan B.\n\nContoh:\nf_5(0, 0, 3, 4) mengembalikan 5", "ja": "以下の問題を解くために、CPP関数 `double f_5(double xa, double ya, double xb, double yb)` を作成してください。\n2点 A (xa, ya) と B (xb, yb) の間の距離を計算します。\n\nパラメータ:\n- xa (double): 点Aのx座標。\n- ya (double): 点Aのy座標。\n- xb (double): 点Bのx座標。\n- yb (double): 点Bのy座標。\n\n戻り値:\ndouble: 点AとBの間の距離。\n\n例:\nf_5(0, 0, 3, 4) は 5 を返します。", "ko": "CPP 함수를 작성하세요 `double f_5(double xa, double ya, double xb, double yb)` 다음 문제를 해결하기 위해:\n두 점 A (xa, ya)와 B (xb, yb) 사이의 거리를 계산합니다.\n\n매개변수:\n- xa (double): 점 A의 x-좌표.\n- ya (double): 점 A의 y-좌표.\n- xb (double): 점 B의 x-좌표.\n- yb (double): 점 B의 y-좌표.\n\n반환값:\ndouble: 점 A와 B 사이의 거리.\n\n예시:\nf_5(0, 0, 3, 4) returns 5", "ml": "CPP ഫംഗ്ഷൻ `double f_5(double xa, double ya, double xb, double yb)` എഴുതുക താഴെക്കൊടുത്തിരിക്കുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nരണ്ട് ബിന്ദുക്കൾ A (xa, ya) and B (xb, yb) തമ്മിലുള്ള ദൂരം കണക്കാക്കുക.\n\nപാരാമീറ്ററുകൾ:\n- xa (double): A ബിന്ദുവിന്റെ x-കോഓർഡിനേറ്റ്.\n- ya (double): A ബിന്ദുവിന്റെ y-കോഓർഡിനേറ്റ്.\n- xb (double): B ബിന്ദുവിന്റെ x-കോഓർഡിനേറ്റ്.\n- yb (double): B ബിന്ദുവിന്റെ y-കോഓർഡിനേറ്റ്.\n\nമടക്കുന്നു:\ndouble: A and B ബിന്ദുക്കൾ തമ്മിലുള്ള ദൂരം.\n\nഉദാഹരണങ്ങൾ:\nf_5(0, 0, 3, 4) 5 മടക്കുന്നു", "fa": "یک تابع CPP بنویسید `double f_5(double xa, double ya, double xb, double yb)` برای حل مسئله زیر:\nفاصله بین دو نقطه A (xa, ya) و B (xb, yb) را محاسبه کنید.\n\nپارامترها:\n- xa (double): مختصات x نقطه A.\n- ya (double): مختصات y نقطه A.\n- xb (double): مختصات x نقطه B.\n- yb (double): مختصات y نقطه B.\n\nبازگشتی:\ndouble: فاصله بین نقاط A و B.\n\nمثال‌ها:\nf_5(0, 0, 3, 4) مقدار 5 را برمی‌گرداند."}, "level": "easy", "test": "int main() \n{\n    assert(fabs(f_5(0, 0, 3, 4) - 5) < 1e-6);\n    assert(fabs(f_5(0, 0, 0, 0) - 0) < 1e-6);\n    assert(fabs(f_5(-1, -1, 2, 2) - 4.242640687) < 1e-6);\n    assert(fabs(f_5(1.5, 3.9, 4.2, -1.1) - 5.68243) < 1e-6);\n    //std::cout << \"All test cases passed!\\n\"; // printf can be replaced with std::cout\n    return 0;\n}", "entry_point": "f_5", "signature": "double f_5(double xa, double ya, double xb, double yb)", "docstring": {"en": "Calculate the distance between two points A (xa, ya) and B (xb, yb).\n\nParameters:\n- xa (double): x-coordinate of point A.\n- ya (double): y-coordinate of point A.\n- xb (double): x-coordinate of point B.\n- yb (double): y-coordinate of point B.\n\nReturns:\ndouble: The distance between points A and B.\n\nExamples:\nf_5(0, 0, 3, 4) returns 5", "sq": "Llogarit distancën midis dy pikave A (xa, ya) dhe B (xb, yb).\n\nParametrat:\n- xa (double): koordinata x e pikës A.\n- ya (double): koordinata y e pikës A.\n- xb (double): koordinata x e pikës B.\n- yb (double): koordinata y e pikës B.\n\nKthen:\ndouble: Distanca midis pikave A dhe B.\n\nShembuj:\nf_5(0, 0, 3, 4) kthen 5", "hy": "Հաշվարկել հեռավորությունը երկու կետերի A (xa, ya) և B (xb, yb) միջև։\n\nՊարամետրեր՝\n- xa (double): A կետի x-կոորդինատը։\n- ya (double): A կետի y-կոորդինատը։\n- xb (double): B կետի x-կոորդինատը։\n- yb (double): B կետի y-կոորդինատը։\n\nՎերադարձնում է՝\ndouble: Հեռավորությունը A և B կետերի միջև։\n\nՕրինակներ՝\nf_5(0, 0, 3, 4) վերադարձնում է 5", "bn": "দুটি বিন্দু A (xa, ya) এবং B (xb, yb) এর মধ্যে দূরত্ব গণনা করুন।\n\nপ্যারামিটারসমূহ:\n- xa (double): বিন্দু A এর x-সমন্বয়।\n- ya (double): বিন্দু A এর y-সমন্বয়।\n- xb (double): বিন্দু B এর x-সমন্বয়।\n- yb (double): বিন্দু B এর y-সমন্বয়।\n\nরিটার্নস:\ndouble: বিন্দু A এবং B এর মধ্যে দূরত্ব।\n\nউদাহরণ:\nf_5(0, 0, 3, 4) returns 5", "bg": "Изчислява разстоянието между две точки A (xa, ya) и B (xb, yb).\n\nПараметри:\n- xa (double): x-координата на точка A.\n- ya (double): y-координата на точка A.\n- xb (double): x-координата на точка B.\n- yb (double): y-координата на точка B.\n\nВръща:\ndouble: Разстоянието между точките A и B.\n\nПримери:\nf_5(0, 0, 3, 4) връща 5", "zh": "计算两点 A (xa, ya) 和 B (xb, yb) 之间的距离。\n\n参数：\n- xa (double): 点 A 的 x 坐标。\n- ya (double): 点 A 的 y 坐标。\n- xb (double): 点 B 的 x 坐标。\n- yb (double): 点 B 的 y 坐标。\n\n返回：\ndouble: 点 A 和 B 之间的距离。\n\n示例：\nf_5(0, 0, 3, 4) 返回 5", "fr": "Calculer la distance entre deux points A (xa, ya) et B (xb, yb).\n\nParamètres :\n- xa (double) : coordonnée x du point A.\n- ya (double) : coordonnée y du point A.\n- xb (double) : coordonnée x du point B.\n- yb (double) : coordonnée y du point B.\n\nRenvoie :\ndouble : La distance entre les points A et B.\n\nExemples :\nf_5(0, 0, 3, 4) renvoie 5", "de": "Berechnen Sie die Entfernung zwischen zwei Punkten A (xa, ya) und B (xb, yb).\n\nParameter:\n- xa (double): x-Koordinate des Punktes A.\n- ya (double): y-Koordinate des Punktes A.\n- xb (double): x-Koordinate des Punktes B.\n- yb (double): y-Koordinate des Punktes B.\n\nRückgabewert:\ndouble: Die Entfernung zwischen den Punkten A und B.\n\nBeispiele:\nf_5(0, 0, 3, 4) gibt 5 zurück", "ha": "Lissafi nisan tsakanin maki biyu A (xa, ya) da B (xb, yb).\n\nSigogi:\n- xa (double): x-kwatance na aya A.\n- ya (double): y-kwatance na aya A.\n- xb (double): x-kwatance na aya B.\n- yb (double): y-kwatance na aya B.\n\nDawowa:\ndouble: Nisan tsakanin wurare A da B.\n\nMisalai:\nf_5(0, 0, 3, 4) returns 5", "hi": "दो बिंदुओं A (xa, ya) और B (xb, yb) के बीच की दूरी की गणना करें।\n\nपैरामीटर्स:\n- xa (double): बिंदु A का x-निर्देशांक।\n- ya (double): बिंदु A का y-निर्देशांक।\n- xb (double): बिंदु B का x-निर्देशांक।\n- yb (double): बिंदु B का y-निर्देशांक।\n\nवापसी:\ndouble: बिंदु A और B के बीच की दूरी।\n\nउदाहरण:\nf_5(0, 0, 3, 4) 5 लौटाता है।", "hu": "Számítsa ki a távolságot két pont, A (xa, ya) és B (xb, yb) között.\n\nParaméterek:\n- xa (double): A pont x-koordinátája.\n- ya (double): A pont y-koordinátája.\n- xb (double): B pont x-koordinátája.\n- yb (double): B pont y-koordinátája.\n\nVisszatérési érték:\ndouble: A távolság A és B pontok között.\n\nPéldák:\nf_5(0, 0, 3, 4) visszaadja 5", "es": "Calcular la distancia entre dos puntos A (xa, ya) y B (xb, yb).\n\nParámetros:\n- xa (double): coordenada x del punto A.\n- ya (double): coordenada y del punto A.\n- xb (double): coordenada x del punto B.\n- yb (double): coordenada y del punto B.\n\nDevuelve:\ndouble: La distancia entre los puntos A y B.\n\nEjemplos:\nf_5(0, 0, 3, 4) devuelve 5", "arb": "احسب المسافة بين نقطتين A (xa, ya) و B (xb, yb).\n\nالمعلمات:\n- xa (double): الإحداثي السيني للنقطة A.\n- ya (double): الإحداثي الصادي للنقطة A.\n- xb (double): الإحداثي السيني للنقطة B.\n- yb (double): الإحداثي الصادي للنقطة B.\n\nالقيم المعادة:\ndouble: المسافة بين النقطتين A و B.\n\nأمثلة:\nf_5(0, 0, 3, 4) يعيد 5", "sw": "Calculate the distance between two points A (xa, ya) and B (xb, yb).\n\nVigezo:\n- xa (double): x-kiwiko cha nukta A.\n- ya (double): y-kiwiko cha nukta A.\n- xb (double): x-kiwiko cha nukta B.\n- yb (double): y-kiwiko cha nukta B.\n\nRudisha:\ndouble: Umbali kati ya nukta A na B.\n\nMifano:\nf_5(0, 0, 3, 4) inarudisha 5", "tr": "İki nokta A (xa, ya) ve B (xb, yb) arasındaki mesafeyi hesaplayın.\n\nParametreler:\n- xa (double): A noktasının x-koordinatı.\n- ya (double): A noktasının y-koordinatı.\n- xb (double): B noktasının x-koordinatı.\n- yb (double): B noktasının y-koordinatı.\n\nDöndürülenler:\ndouble: A ve B noktaları arasındaki mesafe.\n\nÖrnekler:\nf_5(0, 0, 3, 4) 5 döndürür.", "vi": "Tính khoảng cách giữa hai điểm A (xa, ya) và B (xb, yb).\n\nTham số:\n- xa (double): tọa độ x của điểm A.\n- ya (double): tọa độ y của điểm A.\n- xb (double): tọa độ x của điểm B.\n- yb (double): tọa độ y của điểm B.\n\nTrả về:\ndouble: Khoảng cách giữa điểm A và B.\n\nVí dụ:\nf_5(0, 0, 3, 4) trả về 5", "id": "Hitung jarak antara dua titik A (xa, ya) dan B (xb, yb).\n\nParameter:\n- xa (double): koordinat-x dari titik A.\n- ya (double): koordinat-y dari titik A.\n- xb (double): koordinat-x dari titik B.\n- yb (double): koordinat-y dari titik B.\n\nMengembalikan:\ndouble: Jarak antara titik A dan B.\n\nContoh:\nf_5(0, 0, 3, 4) mengembalikan 5", "ja": "2点A (xa, ya) とB (xb, yb) の間の距離を計算します。\n\n引数:\n- xa (double): 点Aのx座標。\n- ya (double): 点Aのy座標。\n- xb (double): 点Bのx座標。\n- yb (double): 点Bのy座標。\n\n戻り値:\ndouble: 点AとBの間の距離。\n\n例:\nf_5(0, 0, 3, 4) は5を返します。", "ko": "두 점 A (xa, ya)와 B (xb, yb) 사이의 거리를 계산합니다.\n\n매개변수:\n- xa (double): 점 A의 x-좌표.\n- ya (double): 점 A의 y-좌표.\n- xb (double): 점 B의 x-좌표.\n- yb (double): 점 B의 y-좌표.\n\n반환값:\ndouble: 점 A와 B 사이의 거리.\n\n예제:\nf_5(0, 0, 3, 4) returns 5", "ml": "Calculate the distance between two points A (xa, ya) and B (xb, yb).\n\nപാരാമീറ്ററുകൾ:\n- xa (double): A ബിന്ദുവിന്റെ x-കോഓർഡിനേറ്റ്.\n- ya (double): A ബിന്ദുവിന്റെ y-കോഓർഡിനേറ്റ്.\n- xb (double): B ബിന്ദുവിന്റെ x-കോഓർഡിനേറ്റ്.\n- yb (double): B ബിന്ദുവിന്റെ y-കോഓർഡിനേറ്റ്.\n\nമടങ്ങിവരവ്:\ndouble: A, B ബിന്ദുക്കളുടെ ഇടയിലെ ദൂരം.\n\nഉദാഹരണങ്ങൾ:\nf_5(0, 0, 3, 4) 5 മടങ്ങിവരുന്നു", "fa": "محاسبه فاصله بین دو نقطه A (xa, ya) و B (xb, yb).\n\nپارامترها:\n- xa (double): مختصات x نقطه A.\n- ya (double): مختصات y نقطه A.\n- xb (double): مختصات x نقطه B.\n- yb (double): مختصات y نقطه B.\n\nبازگشت:\ndouble: فاصله بین نقاط A و B.\n\nمثال‌ها:\nf_5(0, 0, 3, 4) بازمی‌گرداند 5"}}
{"task_id": "CPP/6", "prompt": {"en": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Calculates the factorial of N modulo 10007.\n * \n * Parameters:\n * - N (int): An integer representing the input value (N <= 10000).\n * \n * Returns:\n * int: The result after calculating the factorial of N and\n * taking the modulo 10007.\n * \n * Examples:\n * >>> f_6(1)\n * 1\n * >>> f_6(10)\n * 6266\n */\nint f_6(int n)", "sq": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Llogarit faktorielin e N modulo 10007.\n * \n * Parametrat:\n * - N (int): Një numër i plotë që përfaqëson vlerën hyrëse (N <= 10000).\n * \n * Kthen:\n * int: Rezultati pas llogaritjes së faktorielit të N dhe\n * marrjes së modulo 10007.\n * \n * Shembuj:\n * >>> f_6(1)\n * 1\n * >>> f_6(10)\n * 6266\n */", "hy": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Հաշվարկում է N-ի ֆակտորիալը 10007 մոդուլով։\n * \n * Պարամետրեր:\n * - N (int): Ամբողջ թիվ, որը ներկայացնում է մուտքագրված արժեքը (N <= 10000)։\n * \n * Վերադարձնում է:\n * int: Արդյունքը՝ N-ի ֆակտորիալը հաշվելուց և\n * 10007 մոդուլով վերցնելուց հետո։\n * \n * Օրինակներ:\n * >>> f_6(1)\n * 1\n * >>> f_6(10)\n * 6266\n */\nint f_6(int n)", "bn": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * N এর ফ্যাক্টরিয়াল 10007 দ্বারা মডুলো হিসাব করে।\n * \n * প্যারামিটার:\n * - N (int): একটি পূর্ণসংখ্যা যা ইনপুট মানকে উপস্থাপন করে (N <= 10000)।\n * \n * রিটার্নস:\n * int: N এর ফ্যাক্টরিয়াল হিসাব করার পর এবং 10007 দ্বারা মডুলো নেওয়ার পর ফলাফল।\n * \n * উদাহরণ:\n * >>> f_6(1)\n * 1\n * >>> f_6(10)\n * 6266\n */\nint f_6(int n)", "bg": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Изчислява факториела на N по модул 10007.\n * \n * Параметри:\n * - N (int): Цяло число, представляващо входната стойност (N <= 10000).\n * \n * Връща:\n * int: Резултатът след изчисляване на факториела на N и\n * вземане на модул 10007.\n * \n * Примери:\n * >>> f_6(1)\n * 1\n * >>> f_6(10)\n * 6266\n */\nint f_6(int n)", "zh": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * 计算 N 的阶乘模 10007。\n * \n * 参数:\n * - N (int): 表示输入值的整数 (N <= 10000)。\n * \n * 返回:\n * int: 计算 N 的阶乘并取模 10007 后的结果。\n * \n * 示例:\n * >>> f_6(1)\n * 1\n * >>> f_6(10)\n * 6266\n */\nint f_6(int n)", "fr": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Calcule la factorielle de N modulo 10007.\n * \n * Paramètres :\n * - N (int) : Un entier représentant la valeur d'entrée (N <= 10000).\n * \n * Renvoie :\n * int : Le résultat après avoir calculé la factorielle de N et\n * pris le modulo 10007.\n * \n * Exemples :\n * >>> f_6(1)\n * 1\n * >>> f_6(10)\n * 6266\n */\nint f_6(int n)", "de": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Berechnet die Fakultät von N modulo 10007.\n * \n * Parameter:\n * - N (int): Eine ganze Zahl, die den Eingabewert darstellt (N <= 10000).\n * \n * Rückgabewert:\n * int: Das Ergebnis nach der Berechnung der Fakultät von N und\n * der Modulo-Operation mit 10007.\n * \n * Beispiele:\n * >>> f_6(1)\n * 1\n * >>> f_6(10)\n * 6266\n */\nint f_6(int n)", "ha": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Lissafi na factorial na N modulo 10007.\n * \n * Sigogi:\n * - N (int): Wani cikakken lamba da ke wakiltar ƙimar shigarwa (N <= 10000).\n * \n * Komawa:\n * int: Sakamakon bayan lissafin factorial na N da\n * ɗaukar modulo 10007.\n * \n * Misalai:\n * >>> f_6(1)\n * 1\n * >>> f_6(10)\n * 6266\n */\nint f_6(int n)", "hi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * N का फैक्टोरियल 10007 से मोड्यूलो के साथ गणना करता है।\n * \n * पैरामीटर्स:\n * - N (int): एक पूर्णांक जो इनपुट मान का प्रतिनिधित्व करता है (N <= 10000)।\n * \n * रिटर्न्स:\n * int: N का फैक्टोरियल गणना करने के बाद और\n * 10007 से मोड्यूलो लेने के बाद का परिणाम।\n * \n * उदाहरण:\n * >>> f_6(1)\n * 1\n * >>> f_6(10)\n * 6266\n */\nint f_6(int n)", "hu": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Kiszámítja N faktoriálisát modulo 10007.\n * \n * Paraméterek:\n * - N (int): Egy egész szám, amely az input értéket jelöli (N <= 10000).\n * \n * Visszatér:\n * int: Az eredmény, miután kiszámítottuk N faktoriálisát és\n * vettük a modulo 10007-et.\n * \n * Példák:\n * >>> f_6(1)\n * 1\n * >>> f_6(10)\n * 6266\n */\nint f_6(int n)", "es": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Calcula el factorial de N módulo 10007.\n * \n * Parámetros:\n * - N (int): Un entero que representa el valor de entrada (N <= 10000).\n * \n * Retorna:\n * int: El resultado después de calcular el factorial de N y\n * tomar el módulo 10007.\n * \n * Ejemplos:\n * >>> f_6(1)\n * 1\n * >>> f_6(10)\n * 6266\n */\nint f_6(int n)", "arb": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * يحسب مضروب N موديولو 10007.\n * \n * المعلمات:\n * - N (int): عدد صحيح يمثل قيمة الإدخال (N <= 10000).\n * \n * يعيد:\n * int: النتيجة بعد حساب مضروب N وأخذ الموديولو 10007.\n * \n * أمثلة:\n * >>> f_6(1)\n * 1\n * >>> f_6(10)\n * 6266\n */\nint f_6(int n)", "sw": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Inahesabu factorial ya N modulo 10007.\n * \n * Vigezo:\n * - N (int): Nambari nzima inayowakilisha thamani ya ingizo (N <= 10000).\n * \n * Inarudisha:\n * int: Matokeo baada ya kuhesabu factorial ya N na\n * kuchukua modulo 10007.\n * \n * Mifano:\n * >>> f_6(1)\n * 1\n * >>> f_6(10)\n * 6266\n */\nint f_6(int n)", "tr": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * N faktöriyelinin 10007 ile modülünü hesaplar.\n * \n * Parametreler:\n * - N (int): Girdi değeri olarak bir tam sayı (N <= 10000).\n * \n * Döndürür:\n * int: N faktöriyelini hesapladıktan sonra 10007 ile modülünü\n * aldıktan sonraki sonuç.\n * \n * Örnekler:\n * >>> f_6(1)\n * 1\n * >>> f_6(10)\n * 6266\n */\nint f_6(int n)", "vi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Tính giai thừa của N theo modulo 10007.\n * \n * Tham số:\n * - N (int): Một số nguyên đại diện cho giá trị đầu vào (N <= 10000).\n * \n * Trả về:\n * int: Kết quả sau khi tính giai thừa của N và\n * lấy modulo 10007.\n * \n * Ví dụ:\n * >>> f_6(1)\n * 1\n * >>> f_6(10)\n * 6266\n */\nint f_6(int n)", "id": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Menghitung faktorial dari N modulo 10007.\n * \n * Parameter:\n * - N (int): Sebuah bilangan bulat yang mewakili nilai masukan (N <= 10000).\n * \n * Mengembalikan:\n * int: Hasil setelah menghitung faktorial dari N dan\n * mengambil modulo 10007.\n * \n * Contoh:\n * >>> f_6(1)\n * 1\n * >>> f_6(10)\n * 6266\n */\nint f_6(int n)", "ja": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Nの階乗を10007で割った余りを計算します。\n * \n * パラメータ:\n * - N (int): 入力値を表す整数 (N <= 10000)。\n * \n * 戻り値:\n * int: Nの階乗を計算し、10007で割った余りの結果。\n * \n * 例:\n * >>> f_6(1)\n * 1\n * >>> f_6(10)\n * 6266\n */\nint f_6(int n)", "ko": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * N의 팩토리얼을 10007로 나눈 나머지를 계산합니다.\n * \n * 매개변수:\n * - N (int): 입력 값을 나타내는 정수 (N <= 10000).\n * \n * 반환값:\n * int: N의 팩토리얼을 계산한 후 10007로 나눈 나머지 결과.\n * \n * 예시:\n * >>> f_6(1)\n * 1\n * >>> f_6(10)\n * 6266\n */\nint f_6(int n)", "ml": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * N ന്റെ ഫാക്ടോറിയൽ 10007 ന്റെ മോഡുലോ ആയി കണക്കാക്കുന്നു.\n * \n * പാരാമീറ്ററുകൾ:\n * - N (int): ഇൻപുട്ട് മൂല്യം പ്രതിനിധീകരിക്കുന്ന ഒരു പൂർണ്ണസംഖ്യ (N <= 10000).\n * \n * മടക്കുന്നു:\n * int: N ന്റെ ഫാക്ടോറിയൽ കണക്കാക്കി 10007 ന്റെ മോഡുലോ എടുക്കുന്നതിന് ശേഷമുള്ള ഫലം.\n * \n * ഉദാഹരണങ്ങൾ:\n * >>> f_6(1)\n * 1\n * >>> f_6(10)\n * 6266\n */\nint f_6(int n)", "fa": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * محاسبه فاکتوریل N به پیمانه 10007.\n * \n * پارامترها:\n * - N (int): یک عدد صحیح که نشان‌دهنده مقدار ورودی است (N <= 10000).\n * \n * بازمی‌گرداند:\n * int: نتیجه پس از محاسبه فاکتوریل N و گرفتن پیمانه 10007.\n * \n * مثال‌ها:\n * >>> f_6(1)\n * 1\n * >>> f_6(10)\n * 6266\n */\nint f_6(int n)"}, "canonical_solution": "{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for (register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i - 1] * i) % 10007;\n    }\n    return a[n];\n}", "instruction": {"en": "Write a CPP function `int f_6(int n)` to solve the following problem:\nCalculates the factorial of N modulo 10007.\n\nParameters:\n- N (int): An integer representing the input value (N <= 10000).\n\nReturns:\nint: The result after calculating the factorial of N and\ntaking the modulo 10007.\n\nExamples:\n>>> f_6(1)\n1\n>>> f_6(10)\n6266", "sq": "Shkruani një funksion CPP `int f_6(int n)` për të zgjidhur problemin e mëposhtëm:  \nLlogarit faktorialin e N modulo 10007.\n\nParametrat:  \n- N (int): Një numër i plotë që përfaqëson vlerën hyrëse (N <= 10000).\n\nKthen:  \nint: Rezultati pas llogaritjes së faktorialit të N dhe marrjes së modulo 10007.\n\nShembuj:  \n>>> f_6(1)  \n1  \n>>> f_6(10)  \n6266", "hy": "Գրեք CPP ֆունկցիա `int f_6(int n)` հետևյալ խնդիրը լուծելու համար:\nՀաշվարկում է N-ի ֆակտորիալը մոդուլո 10007-ով։\n\nՊարամետրեր:\n- N (int): Ամբողջ թիվ, որը ներկայացնում է մուտքային արժեքը (N <= 10000)։\n\nՎերադարձնում է:\nint: Արդյունքը N-ի ֆակտորիալը հաշվելուց հետո և\nմոդուլո 10007 վերցնելուց հետո։", "bn": "একটি CPP ফাংশন `int f_6(int n)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nN এর ফ্যাক্টোরিয়াল গণনা করে 10007 দ্বারা মডুলো করে।\n\nপ্যারামিটারসমূহ:\n- N (int): একটি পূর্ণসংখ্যা যা ইনপুট মানকে উপস্থাপন করে (N <= 10000)।\n\nফেরত দেয়:\nint: N এর ফ্যাক্টোরিয়াল গণনা করে এবং 10007 দ্বারা মডুলো করার পর ফলাফল।\n\nউদাহরণ:\n>>> f_6(1)\n1\n>>> f_6(10)\n6266", "bg": "Напишете CPP функция `int f_6(int n)`, за да решите следния проблем:\nИзчислява факториела на N по модул 10007.\n\nПараметри:\n- N (int): Цяло число, представляващо входната стойност (N <= 10000).\n\nВръща:\nint: Резултатът след изчисляване на факториела на N и\nвземане на модул 10007.\n\nПримери:\n>>> f_6(1)\n1\n>>> f_6(10)\n6266", "zh": "编写一个 CPP 函数 `int f_6(int n)` 来解决以下问题：\n计算 N 的阶乘对 10007 取模。\n\n参数：\n- N (int): 表示输入值的整数 (N <= 10000)。\n\n返回：\nint: 计算 N 的阶乘并对 10007 取模后的结果。\n\n示例：\n>>> f_6(1)\n1\n>>> f_6(10)\n6266", "fr": "Écrire une fonction CPP `int f_6(int n)` pour résoudre le problème suivant :\nCalcule le factoriel de N modulo 10007.\n\nParamètres :\n- N (int) : Un entier représentant la valeur d'entrée (N <= 10000).\n\nRenvoie :\nint : Le résultat après avoir calculé le factoriel de N et\nappliqué le modulo 10007.\n\nExemples :\n>>> f_6(1)\n1\n>>> f_6(10)\n6266", "de": "Schreiben Sie eine CPP-Funktion `int f_6(int n)`, um das folgende Problem zu lösen:\nBerechnet das Fakultät von N modulo 10007.\n\nParameter:\n- N (int): Eine ganze Zahl, die den Eingabewert darstellt (N <= 10000).\n\nRückgabewert:\nint: Das Ergebnis nach der Berechnung des Fakultäts von N und\nder Modulo-Operation mit 10007.\n\nBeispiele:\n>>> f_6(1)\n1\n>>> f_6(10)\n6266", "ha": "Rubuta aikin CPP `int f_6(int n)` don warware matsalar mai zuwa:\nLissafa factorial na N modulo 10007.\n\nSigogi:\n- N (int): Wani cikakken lamba da ke wakiltar ƙimar shigarwa (N <= 10000).\n\nMayarwa:\nint: Sakamakon bayan lissafin factorial na N da\ndaukar modulo 10007.\n\nMisalai:\n>>> f_6(1)\n1\n>>> f_6(10)\n6266", "hi": "`int f_6(int n)` नामक एक CPP फ़ंक्शन लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nN का फैक्टोरियल 10007 से मोड्यूलो के रूप में गणना करता है।\n\nपैरामीटर्स:\n- N (int): इनपुट मान का प्रतिनिधित्व करने वाला एक पूर्णांक (N <= 10000)।\n\nवापसी:\nint: N का फैक्टोरियल गणना करने के बाद और\n10007 से मोड्यूलो लेने के बाद का परिणाम।\n\nउदाहरण:\n>>> f_6(1)\n1\n>>> f_6(10)\n6266", "hu": "Írj egy CPP függvényt `int f_6(int n)` a következő probléma megoldására:\nKiszámítja N faktoriálisát modulo 10007.\n\nParaméterek:\n- N (int): Egy egész szám, amely az input értéket képviseli (N <= 10000).\n\nVisszatérési érték:\nint: Az eredmény, miután kiszámítottuk N faktoriálisát és\nvettük a modulo 10007-et.\n\nPéldák:\n>>> f_6(1)\n1\n>>> f_6(10)\n6266", "es": "Escribe una función CPP `int f_6(int n)` para resolver el siguiente problema:\nCalcula el factorial de N módulo 10007.\n\nParámetros:\n- N (int): Un entero que representa el valor de entrada (N <= 10000).\n\nDevuelve:\nint: El resultado después de calcular el factorial de N y\ntomar el módulo 10007.\n\nEjemplos:\n>>> f_6(1)\n1\n>>> f_6(10)\n6266", "arb": "اكتب دالة CPP `int f_6(int n)` لحل المشكلة التالية:\nتحسب المضروب لـ N موديولو 10007.\n\nالمعطيات:\n- N (int): عدد صحيح يمثل قيمة الإدخال (N <= 10000).\n\nالقيم المعادة:\nint: النتيجة بعد حساب المضروب لـ N وأخذ الموديولو 10007.\n\nأمثلة:\n>>> f_6(1)\n1\n>>> f_6(10)\n6266", "sw": "Andika kazi ya CPP `int f_6(int n)` kutatua tatizo lifuatalo:\nInahesabu faktoria ya N modulo 10007.\n\nVigezo:\n- N (int): Nambari nzima inayowakilisha thamani ya pembejeo (N <= 10000).\n\nInarudisha:\nint: Matokeo baada ya kuhesabu faktoria ya N na\nkuchukua modulo 10007.\n\nMifano:\n>>> f_6(1)\n1\n>>> f_6(10)\n6266", "tr": "Bir CPP fonksiyonu `int f_6(int n)` yazın ve aşağıdaki problemi çözün:\nN faktöriyelini 10007 ile mod alarak hesaplar.\n\nParametreler:\n- N (int): Girdi değerini temsil eden bir tamsayı (N <= 10000).\n\nDöndürür:\nint: N faktöriyelini hesapladıktan sonra 10007 ile mod alındıktan sonraki sonuç.\n\nÖrnekler:\n>>> f_6(1)\n1\n>>> f_6(10)\n6266", "vi": "Viết một hàm CPP `int f_6(int n)` để giải quyết vấn đề sau:  \nTính giai thừa của N modulo 10007.\n\nTham số:  \n- N (int): Một số nguyên đại diện cho giá trị đầu vào (N <= 10000).\n\nTrả về:  \nint: Kết quả sau khi tính giai thừa của N và lấy modulo 10007.\n\nVí dụ:  \n>>> f_6(1)  \n1  \n>>> f_6(10)  \n6266  ", "id": "Tulis fungsi CPP `int f_6(int n)` untuk menyelesaikan masalah berikut:  \nMenghitung faktorial dari N modulo 10007.\n\nParameter:\n- N (int): Sebuah bilangan bulat yang mewakili nilai input (N <= 10000).\n\nMengembalikan:\nint: Hasil setelah menghitung faktorial dari N dan\nmengambil modulo 10007.\n\nContoh:\n>>> f_6(1)\n1\n>>> f_6(10)\n6266", "ja": "CPP関数 `int f_6(int n)` を作成して、次の問題を解決してください:\nNの階乗を10007で割った余りを計算します。\n\nパラメータ:\n- N (int): 入力値を表す整数 (N <= 10000)。\n\n戻り値:\nint: Nの階乗を計算し、10007で割った余りの結果。\n\n例:\n>>> f_6(1)\n1\n>>> f_6(10)\n6266", "ko": "다음 문제를 해결하기 위해 CPP 함수를 작성하십시오 `int f_6(int n)`:\nN의 팩토리얼을 10007로 나눈 나머지를 계산합니다.\n\n매개변수:\n- N (int): 입력 값을 나타내는 정수 (N <= 10000).\n\n반환값:\nint: N의 팩토리얼을 계산하고 10007로 나눈 나머지를 구한 결과입니다.\n\n예시:\n>>> f_6(1)\n1\n>>> f_6(10)\n6266", "ml": "ഒരു CPP ഫംഗ്ഷൻ `int f_6(int n)` എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nN ന്റെ ഫാക്ടോറിയൽ 10007 ന്റെ മോഡുലോ കണക്കാക്കുന്നു.\n\nപാരാമീറ്ററുകൾ:\n- N (int): ഇൻപുട്ട് മൂല്യം പ്രതിനിധീകരിക്കുന്ന ഒരു പൂർണ്ണസംഖ്യ (N <= 10000).\n\nമടക്കുന്നു:\nint: N ന്റെ ഫാക്ടോറിയൽ കണക്കാക്കി 10007 ന്റെ മോഡുലോ എടുത്ത ശേഷം ഫലം.\n\nഉദാഹരണങ്ങൾ:\n>>> f_6(1)\n1\n>>> f_6(10)\n6266", "fa": "یک تابع CPP `int f_6(int n)` بنویسید تا مسئله‌ی زیر را حل کند:\nمحاسبه فاکتوریل N به پیمانه 10007.\n\nپارامترها:\n- N (int): یک عدد صحیح که مقدار ورودی را نشان می‌دهد (N <= 10000).\n\nبازگشت:\nint: نتیجه پس از محاسبه فاکتوریل N و گرفتن پیمانه 10007.\n\nمثال‌ها:\n>>> f_6(1)\n1\n>>> f_6(10)\n6266"}, "level": "easy", "test": "int main()\n{\n    assert(f_6(0) == 1); // Added test for boundary condition\n    assert(f_6(1) == 1);\n    assert(f_6(2) == 2);\n    assert(f_6(3) == 6);\n    assert(f_6(4) == 24);\n    assert(f_6(10) == 6266); // 10! % 10007 = 3628800 % 10007 = 6266\n    assert(f_6(10000) == 6991); // Added a test for upper boundary condition\n    // printf(\"All tests passed.\\n\");\n    return 0;\n}", "entry_point": "f_6", "signature": "int f_6(int n)", "docstring": {"en": "Calculates the factorial of N modulo 10007.\n\nParameters:\n- N (int): An integer representing the input value (N <= 10000).\n\nReturns:\nint: The result after calculating the factorial of N and\ntaking the modulo 10007.\n\nExamples:\n>>> f_6(1)\n1\n>>> f_6(10)\n6266", "sq": "Llogarit faktorielin e N modulo 10007.\n\nParametrat:\n- N (int): Një numër i plotë që përfaqëson vlerën hyrëse (N <= 10000).\n\nKthen:\nint: Rezultati pas llogaritjes së faktorielit të N dhe\nmarrjes së modulo 10007.\n\nShembuj:\n>>> f_6(1)\n1\n>>> f_6(10)\n6266", "hy": "Հաշվում է N-ի ֆակտորիալը մոդուլո 10007-ով։\n\nՊարամետրեր՝\n- N (int): Ընդհանուր թիվ, որը ներկայացնում է մուտքային արժեքը (N <= 10000)։\n\nՎերադարձնում է՝\nint: Արդյունքը՝ N-ի ֆակտորիալը հաշվելուց հետո և\nմոդուլո 10007 վերցնելուց հետո։\n\nՕրինակներ՝\n>>> f_6(1)\n1\n>>> f_6(10)\n6266", "bn": "N এর ফ্যাক্টোরিয়াল 10007 দ্বারা মডুলো হিসাব করে।\n\nপ্যারামিটার:\n- N (int): একটি পূর্ণসংখ্যা যা ইনপুট মানকে উপস্থাপন করে (N <= 10000)।\n\nফেরত দেয়:\nint: N এর ফ্যাক্টোরিয়াল গণনা করার পর এবং 10007 দ্বারা মডুলো নেওয়ার পর ফলাফল।\n\nউদাহরণ:\n>>> f_6(1)\n1\n>>> f_6(10)\n6266", "bg": "Изчислява факториела на N по модул 10007.\n\nПараметри:\n- N (int): Цяло число, представляващо входната стойност (N <= 10000).\n\nВръща:\nint: Резултатът след изчисляване на факториела на N и\nвземане на модул 10007.\n\nПримери:\n>>> f_6(1)\n1\n>>> f_6(10)\n6266", "zh": "计算 N 的阶乘并取模 10007。\n\n参数：\n- N (int): 表示输入值的整数 (N <= 10000)。\n\n返回：\nint: 计算 N 的阶乘并取模 10007 后的结果。\n\n示例：\n>>> f_6(1)\n1\n>>> f_6(10)\n6266", "fr": "Calcule la factorielle de N modulo 10007.\n\nParamètres:\n- N (int): Un entier représentant la valeur d'entrée (N <= 10000).\n\nRenvoie:\nint: Le résultat après avoir calculé la factorielle de N et\nappliqué le modulo 10007.\n\nExemples:\n>>> f_6(1)\n1\n>>> f_6(10)\n6266", "de": "Berechnet die Fakultät von N modulo 10007.\n\nParameter:\n- N (int): Eine ganze Zahl, die den Eingabewert darstellt (N <= 10000).\n\nRückgabewerte:\nint: Das Ergebnis nach der Berechnung der Fakultät von N und\nder Modulo-Operation mit 10007.\n\nBeispiele:\n>>> f_6(1)\n1\n>>> f_6(10)\n6266", "ha": "Lissafi na factorial na N modulo 10007.\n\nSigogi:\n- N (int): Wani cikakken lamba wanda ke wakiltar darajar shigarwa (N <= 10000).\n\nDawowa:\nint: Sakamakon bayan lissafin factorial na N da\ndaukar modulo 10007.\n\nMisalai:\n>>> f_6(1)\n1\n>>> f_6(10)\n6266", "hi": "N का फैक्टोरियल 10007 से मॉड्यूलो निकालता है।\n\nपैरामीटर्स:\n- N (int): एक पूर्णांक जो इनपुट मान का प्रतिनिधित्व करता है (N <= 10000)।\n\nवापसी:\nint: N का फैक्टोरियल निकालने और 10007 से मॉड्यूलो लेने के बाद का परिणाम।\n\nउदाहरण:\n>>> f_6(1)\n1\n>>> f_6(10)\n6266", "hu": "Kiszámítja N faktoriálisát modulo 10007.\n\nParaméterek:\n- N (int): Egy egész szám, amely az input értéket jelöli (N <= 10000).\n\nVisszatérési érték:\nint: Az eredmény, miután kiszámítottuk N faktoriálisát és\nvettük a modulo 10007-et.\n\nPéldák:\n>>> f_6(1)\n1\n>>> f_6(10)\n6266", "es": "Calcula el factorial de N módulo 10007.\n\nParámetros:\n- N (int): Un entero que representa el valor de entrada (N <= 10000).\n\nDevuelve:\nint: El resultado después de calcular el factorial de N y\ntomar el módulo 10007.\n\nEjemplos:\n>>> f_6(1)\n1\n>>> f_6(10)\n6266", "arb": "يحسب مضروب N بتطبيق باقي القسمة 10007.\n\nالمعطيات:\n- N (int): عدد صحيح يمثل قيمة الإدخال (N <= 10000).\n\nالقيم المعادة:\nint: النتيجة بعد حساب مضروب N وأخذ باقي القسمة 10007.\n\nأمثلة:\n>>> f_6(1)\n1\n>>> f_6(10)\n6266", "sw": "Hesabu faktoria ya N modulo 10007.\n\nVigezo:\n- N (int): Nambari nzima inayowakilisha thamani ya ingizo (N <= 10000).\n\nInarejesha:\nint: Matokeo baada ya kuhesabu faktoria ya N na\nkuchukua modulo 10007.\n\nMifano:\n>>> f_6(1)\n1\n>>> f_6(10)\n6266", "tr": "N'in faktöriyelini 10007 ile mod alarak hesaplar.\n\nParametreler:\n- N (int): Girdi değerini temsil eden bir tamsayı (N <= 10000).\n\nDöndürür:\nint: N'in faktöriyelini hesapladıktan sonra 10007 ile mod alarak elde edilen sonuç.\n\nÖrnekler:\n>>> f_6(1)\n1\n>>> f_6(10)\n6266", "vi": "Tính giai thừa của N theo modulo 10007.\n\nTham số:\n- N (int): Một số nguyên đại diện cho giá trị đầu vào (N <= 10000).\n\nTrả về:\nint: Kết quả sau khi tính giai thừa của N và\nlấy modulo 10007.\n\nVí dụ:\n>>> f_6(1)\n1\n>>> f_6(10)\n6266", "id": "Menghitung faktorial dari N modulo 10007.\n\nParameter:\n- N (int): Sebuah bilangan bulat yang mewakili nilai input (N <= 10000).\n\nMengembalikan:\nint: Hasil setelah menghitung faktorial dari N dan\nmengambil modulo 10007.\n\nContoh:\n>>> f_6(1)\n1\n>>> f_6(10)\n6266", "ja": "Nの階乗を10007で割った余りを計算します。\n\n引数:\n- N (int): 入力値を表す整数 (N <= 10000)。\n\n戻り値:\nint: Nの階乗を計算し、10007で割った余りの結果。\n\n例:\n>>> f_6(1)\n1\n>>> f_6(10)\n6266", "ko": "N의 팩토리얼을 10007로 나눈 나머지를 계산합니다.\n\n매개변수:\n- N (int): 입력 값을 나타내는 정수 (N <= 10000).\n\n반환값:\nint: N의 팩토리얼을 계산한 후 10007로 나눈 나머지 결과.\n\n예제:\n>>> f_6(1)\n1\n>>> f_6(10)\n6266", "ml": "N-യുടെ ഫാക്ടോറിയൽ 10007-ൽ മോഡുലോ എടുത്ത് കണക്കാക്കുന്നു.\n\nപാരാമീറ്ററുകൾ:\n- N (int): ഇൻപുട്ട് മൂല്യം പ്രതിനിധീകരിക്കുന്ന ഒരു പൂർണ്ണസംഖ്യ (N <= 10000).\n\nമടക്കം:\nint: N-യുടെ ഫാക്ടോറിയൽ കണക്കാക്കി 10007-ൽ മോഡുലോ എടുത്തതിന് ശേഷമുള്ള ഫലം.\n\nഉദാഹരണങ്ങൾ:\n>>> f_6(1)\n1\n>>> f_6(10)\n6266", "fa": "محاسبه فاکتوریل N به پیمانه 10007.\n\nپارامترها:\n- N (int): یک عدد صحیح که مقدار ورودی را نشان می‌دهد (N <= 10000).\n\nبازگشت:\nint: نتیجه پس از محاسبه فاکتوریل N و گرفتن پیمانه 10007.\n\nمثال‌ها:\n>>> f_6(1)\n1\n>>> f_6(10)\n6266"}}
{"task_id": "CPP/7", "prompt": {"en": "#include <bits/stdc++.h>\n/*\nCalculate the area of a triangle given its base and height.\n​    Parameters:\n- base (int): The base length of the triangle.\n- height (int): The height of the triangle.\n​    Returns:\n​    float: The calculated area of the triangle, rounded to one decimal place.\n\t>>> f_7(1,2)\n\t1.0\n*/\nfloat f_7(int base, int height)", "sq": "#include <bits/stdc++.h>\n/*\nLlogarit sipërfaqen e një trekëndëshi duke pasur bazën dhe lartësinë e tij.\n​    Parametrat:\n- base (int): Gjatësia e bazës së trekëndëshit.\n- height (int): Lartësia e trekëndëshit.\n​    Kthen:\n​    float: Sipërfaqja e llogaritur e trekëndëshit, e rrumbullakosur në një vend dhjetor.\n\t>>> f_7(1,2)\n\t1.0\n*/\nfloat f_7(int base, int height)", "hy": "#include <bits/stdc++.h>\n/*\nՀաշվել եռանկյան մակերեսը, տրված են նրա հիմքը և բարձրությունը։\n​    Պարամետրեր:\n- base (int): Եռանկյան հիմքի երկարությունը։\n- height (int): Եռանկյան բարձրությունը։\n​    Վերադարձնում է:\n​    float: Եռանկյան հաշվարկված մակերեսը, կլորացված մինչև մեկ տասնորդական։\n\t>>> f_7(1,2)\n\t1.0\n*/\nfloat f_7(int base, int height)", "bn": "#include <bits/stdc++.h>\n/*\nত্রিভুজের ভিত্তি এবং উচ্চতা দেওয়া থাকলে এর ক্ষেত্রফল গণনা করুন।\n​    প্যারামিটারসমূহ:\n- base (int): ত্রিভুজের ভিত্তির দৈর্ঘ্য।\n- height (int): ত্রিভুজের উচ্চতা।\n​    রিটার্নস:\n​    float: ত্রিভুজের গণনা করা ক্ষেত্রফল, এক দশমিক স্থানে রাউন্ড করা।\n\t>>> f_7(1,2)\n\t1.0\n*/\nfloat f_7(int base, int height)", "bg": "#include <bits/stdc++.h>\n/*\nИзчисляване на лицето на триъгълник, дадени неговата основа и височина.\n​    Параметри:\n- base (int): Дължината на основата на триъгълника.\n- height (int): Височината на триъгълника.\n​    Връща:\n​    float: Изчисленото лице на триъгълника, закръглено до един десетичен знак.\n\t>>> f_7(1,2)\n\t1.0\n*/\nfloat f_7(int base, int height)", "zh": "#include <bits/stdc++.h>\n/*\n计算给定底边和高的三角形面积。\n    参数:\n- base (int): 三角形的底边长度。\n- height (int): 三角形的高度。\n    返回:\n    float: 计算的三角形面积，四舍五入到小数点后一位。\n\t>>> f_7(1,2)\n\t1.0\n*/\nfloat f_7(int base, int height)", "fr": "#include <bits/stdc++.h>\n/*\nCalculer l'aire d'un triangle donné sa base et sa hauteur.\n    Paramètres:\n- base (int): La longueur de la base du triangle.\n- height (int): La hauteur du triangle.\n    Renvoie:\n    float: L'aire calculée du triangle, arrondie à une décimale.\n\t>>> f_7(1,2)\n\t1.0\n*/\nfloat f_7(int base, int height)", "de": "#include <bits/stdc++.h>\n/*\nBerechne die Fläche eines Dreiecks, gegeben durch seine Basis und Höhe.\n    Parameter:\n- base (int): Die Basislänge des Dreiecks.\n- height (int): Die Höhe des Dreiecks.\n    Rückgabe:\n    float: Die berechnete Fläche des Dreiecks, auf eine Dezimalstelle gerundet.\n\t>>> f_7(1,2)\n\t1.0\n*/\nfloat f_7(int base, int height)", "ha": "#include <bits/stdc++.h>\n/*\nƘididdige yanki na alwatika da aka ba da ginshiƙi da tsawo.\n​    Sigogi:\n- base (int): Tsawon ginshiƙin alwatika.\n- height (int): Tsawon alwatika.\n​    Mayar da:\n​    float: Yankin da aka ƙididdige na alwatika, an zagaye zuwa wuri ɗaya na goma.\n\t>>> f_7(1,2)\n\t1.0\n*/\nfloat f_7(int base, int height)", "hi": "#include <bits/stdc++.h>\n/*\nत्रिभुज का क्षेत्रफल उसकी आधार और ऊँचाई के आधार पर गणना करें।\n    पैरामीटर्स:\n- base (int): त्रिभुज की आधार लंबाई।\n- height (int): त्रिभुज की ऊँचाई।\n    रिटर्न्स:\n    float: त्रिभुज का गणना किया गया क्षेत्रफल, एक दशमलव स्थान तक गोल किया गया।\n\t>>> f_7(1,2)\n\t1.0\n*/\nfloat f_7(int base, int height)", "hu": "#include <bits/stdc++.h>\n/*\nSzámítsa ki egy háromszög területét az alapja és magassága alapján.\n​    Paraméterek:\n- base (int): A háromszög alapjának hossza.\n- height (int): A háromszög magassága.\n​    Visszatér:\n​    float: A háromszög kiszámított területe, egy tizedesjegyre kerekítve.\n\t>>> f_7(1,2)\n\t1.0\n*/\nfloat f_7(int base, int height)", "es": "#include <bits/stdc++.h>\n/*\nCalcular el área de un triángulo dado su base y altura.\n    Parámetros:\n- base (int): La longitud de la base del triángulo.\n- height (int): La altura del triángulo.\n    Retorna:\n    float: El área calculada del triángulo, redondeada a un decimal.\n\t>>> f_7(1,2)\n\t1.0\n*/\nfloat f_7(int base, int height)", "arb": "#include <bits/stdc++.h>\n/*\nاحسب مساحة المثلث المعطى قاعدته وارتفاعه.\n    المعطيات:\n- base (int): طول قاعدة المثلث.\n- height (int): ارتفاع المثلث.\n    يعيد:\n    float: المساحة المحسوبة للمثلث، مقربة إلى مكان عشري واحد.\n\t>>> f_7(1,2)\n\t1.0\n*/\nfloat f_7(int base, int height)", "sw": "#include <bits/stdc++.h>\n/*\nHesabu eneo la pembetatu ukizingatia msingi wake na urefu.\n​    Vigezo:\n- base (int): Urefu wa msingi wa pembetatu.\n- height (int): Urefu wa pembetatu.\n​    Inarudisha:\n​    float: Eneo lililohesabiwa la pembetatu, limezungushwa hadi sehemu moja ya desimali.\n\t>>> f_7(1,2)\n\t1.0\n*/\nfloat f_7(int base, int height)", "tr": "#include <bits/stdc++.h>\n/*\nBir üçgenin alanını, tabanı ve yüksekliği verildiğinde hesaplayın.\n​    Parametreler:\n- base (int): Üçgenin taban uzunluğu.\n- height (int): Üçgenin yüksekliği.\n​    Döndürür:\n​    float: Üçgenin hesaplanan alanı, bir ondalık basamağa yuvarlanmış.\n\t>>> f_7(1,2)\n\t1.0\n*/\nfloat f_7(int base, int height)", "vi": "#include <bits/stdc++.h>\n/*\nTính diện tích của một tam giác khi biết đáy và chiều cao của nó.\n    Tham số:\n- base (int): Chiều dài đáy của tam giác.\n- height (int): Chiều cao của tam giác.\n    Trả về:\n    float: Diện tích đã tính của tam giác, làm tròn đến một chữ số thập phân.\n\t>>> f_7(1,2)\n\t1.0\n*/\nfloat f_7(int base, int height)", "id": "#include <bits/stdc++.h>\n/*\nMenghitung luas segitiga berdasarkan alas dan tingginya.\n​    Parameter:\n- base (int): Panjang alas segitiga.\n- height (int): Tinggi segitiga.\n​    Mengembalikan:\n​    float: Luas segitiga yang dihitung, dibulatkan ke satu tempat desimal.\n\t>>> f_7(1,2)\n\t1.0\n*/\nfloat f_7(int base, int height)", "ja": "#include <bits/stdc++.h>\n/*\n三角形の面積を、その底辺と高さを与えて計算します。\n​    パラメータ:\n- base (int): 三角形の底辺の長さ。\n- height (int): 三角形の高さ。\n​    戻り値:\n​    float: 計算された三角形の面積を、小数点以下1桁に丸めたもの。\n\t>>> f_7(1,2)\n\t1.0\n*/\nfloat f_7(int base, int height)", "ko": "#include <bits/stdc++.h>\n/*\n삼각형의 밑변과 높이가 주어졌을 때 면적을 계산합니다.\n​    매개변수:\n- base (int): 삼각형의 밑변 길이.\n- height (int): 삼각형의 높이.\n​    반환값:\n​    float: 소수점 첫째 자리까지 반올림된 삼각형의 계산된 면적.\n\t>>> f_7(1,2)\n\t1.0\n*/\nfloat f_7(int base, int height)", "ml": "#include <bits/stdc++.h>\n/*\nഒരു ത്രികോണത്തിന്റെ അടിസ്ഥാനവും ഉയരവും നൽകിയാൽ അതിന്റെ വിസ്തീർണം കണക്കാക്കുക.\n    പാരാമീറ്ററുകൾ:\n- base (int): ത്രികോണത്തിന്റെ അടിയുടെ നീളം.\n- height (int): ത്രികോണത്തിന്റെ ഉയരം.\n    റിട്ടേൺസ്:\n    float: ഒരു ദശാംശ സ്ഥാനത്തേക്ക് വട്ടമിട്ട ത്രികോണത്തിന്റെ കണക്കാക്കിയ വിസ്തീർണം.\n\t>>> f_7(1,2)\n\t1.0\n*/\nfloat f_7(int base, int height)", "fa": "#include <bits/stdc++.h>\n/*\nمساحت یک مثلث را با توجه به قاعده و ارتفاع آن محاسبه کنید.\n    پارامترها:\n- base (int): طول قاعده مثلث.\n- height (int): ارتفاع مثلث.\n    بازگشت:\n    float: مساحت محاسبه شده مثلث، گرد شده به یک رقم اعشار.\n\t>>> f_7(1,2)\n\t1.0\n*/\nfloat f_7(int base, int height)"}, "canonical_solution": "{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}", "instruction": {"en": "Write a CPP function `float f_7(int base, int height)` to solve the following problem:\nCalculate the area of a triangle given its base and height.\n    Parameters:\n- base (int): The base length of the triangle.\n- height (int): The height of the triangle.\n​    Returns:\n​    float: The calculated area of the triangle, rounded to one decimal place.\n    >>> f_7(1,2)\n    1.0\n", "sq": "Shkruani një funksion CPP `float f_7(int base, int height)` për të zgjidhur problemin e mëposhtëm:  \nLlogaritni sipërfaqen e një trekëndëshi duke pasur bazën dhe lartësinë e tij.  \n    Parametrat:  \n- base (int): Gjatësia e bazës së trekëndëshit.  \n- height (int): Lartësia e trekëndëshit.  \n​    Kthen:  \n​    float: Sipërfaqja e llogaritur e trekëndëshit, e rrumbullakosur në një vend dhjetor.  \n    >>> f_7(1,2)  \n    1.0  ", "hy": "Գրեք CPP ֆունկցիա `float f_7(int base, int height)` հետևյալ խնդիրը լուծելու համար:\nՀաշվեք եռանկյան մակերեսը՝ հաշվի առնելով նրա հիմքը և բարձրությունը:\n    Պարամետրեր:\n- base (int): Եռանկյան հիմքի երկարությունը:\n- height (int): Եռանկյան բարձրությունը:\n    Վերադարձնում է:\n    float: Եռանկյան հաշվարկված մակերեսը՝ կլորացված մինչև մեկ տասնորդական:\n    >>> f_7(1,2)\n    1.0", "bn": "একটি CPP ফাংশন `float f_7(int base, int height)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি ত্রিভুজের ভিত্তি এবং উচ্চতা দেওয়া হলে এর ক্ষেত্রফল গণনা করুন।\n    প্যারামিটারসমূহ:\n- base (int): ত্রিভুজের ভিত্তির দৈর্ঘ্য।\n- height (int): ত্রিভুজের উচ্চতা।\n    রিটার্নস:\n    float: ত্রিভুজের গণনা করা ক্ষেত্রফল, এক দশমিক স্থানে রাউন্ড করা।\n    >>> f_7(1,2)\n    1.0", "bg": "Напишете CPP функция `float f_7(int base, int height)` за решаване на следния проблем:\nИзчислете лицето на триъгълник, дадени неговата основа и височина.\n    Параметри:\n- base (int): Дължината на основата на триъгълника.\n- height (int): Височината на триъгълника.\n​    Връща:\n​    float: Изчисленото лице на триъгълника, закръглено до едно десетично място.\n    >>> f_7(1,2)\n    1.0", "zh": "编写一个 CPP 函数 `float f_7(int base, int height)` 来解决以下问题：\n计算给定底边和高的三角形面积。\n    参数：\n- base (int): 三角形的底边长度。\n- height (int): 三角形的高度。\n    返回：\n    float: 计算出的三角形面积，保留一位小数。\n    >>> f_7(1,2)\n    1.0", "fr": "Écrire une fonction CPP `float f_7(int base, int height)` pour résoudre le problème suivant :  \nCalculer l'aire d'un triangle donné sa base et sa hauteur.  \n    Paramètres :  \n- base (int) : La longueur de la base du triangle.  \n- height (int) : La hauteur du triangle.  \n    Renvoie :  \n    float : L'aire calculée du triangle, arrondie à une décimale.  \n    >>> f_7(1,2)  \n    1.0  ", "de": "Schreiben Sie eine CPP-Funktion `float f_7(int base, int height)`, um das folgende Problem zu lösen:\nBerechnen Sie die Fläche eines Dreiecks, gegeben seine Basis und Höhe.\n    Parameter:\n- base (int): Die Basislänge des Dreiecks.\n- height (int): Die Höhe des Dreiecks.\n​    Rückgabewert:\n​    float: Die berechnete Fläche des Dreiecks, gerundet auf eine Dezimalstelle.\n    >>> f_7(1,2)\n    1.0", "ha": "Rubuta aikin CPP `float f_7(int base, int height)` don warware matsalar mai zuwa: \nƘididdige yanki na alwatika da aka ba da tushen sa da tsawo.\n    Sigogi:\n- base (int): Tsawon tushe na alwatika.\n- height (int): Tsawon alwatika.\n​    Dawowa:\n​    float: Yankin da aka ƙididdige na alwatika, an zagaye zuwa wuri ɗaya na goma.\n    >>> f_7(1,2)\n    1.0", "hi": "एक CPP फ़ंक्शन `float f_7(int base, int height)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए आधार और ऊँचाई के साथ एक त्रिभुज का क्षेत्रफल गणना करें।\n    पैरामीटर्स:\n- base (int): त्रिभुज की आधार लंबाई।\n- height (int): त्रिभुज की ऊँचाई।\n​    रिटर्न्स:\n​    float: त्रिभुज का गणना किया गया क्षेत्रफल, एक दशमलव स्थान तक गोल किया गया।\n    >>> f_7(1,2)\n    1.0", "hu": "Írj egy CPP függvényt `float f_7(int base, int height)` a következő probléma megoldására:\nSzámítsd ki egy háromszög területét az alapja és magassága alapján.\n    Paraméterek:\n- base (int): A háromszög alapjának hossza.\n- height (int): A háromszög magassága.\n    Visszatérési érték:\n    float: A háromszög kiszámított területe, egy tizedesjegyre kerekítve.\n    >>> f_7(1,2)\n    1.0", "es": "Escribe una función CPP `float f_7(int base, int height)` para resolver el siguiente problema:\nCalcular el área de un triángulo dado su base y altura.\n    Parámetros:\n- base (int): La longitud de la base del triángulo.\n- height (int): La altura del triángulo.\n​    Devuelve:\n​    float: El área calculada del triángulo, redondeada a un decimal.\n    >>> f_7(1,2)\n    1.0", "arb": "اكتب دالة CPP `float f_7(int base, int height)` لحل المشكلة التالية:  \nاحسب مساحة المثلث المعطى قاعدته وارتفاعه.  \n    المعطيات:  \n- base (int): طول قاعدة المثلث.  \n- height (int): ارتفاع المثلث.  \n    المخرجات:  \n    float: المساحة المحسوبة للمثلث، مقربة إلى مكان عشري واحد.  \n    >>> f_7(1,2)  \n    1.0  ", "sw": "Andika kazi ya CPP `float f_7(int base, int height)` kutatua tatizo lifuatalo:\nHesabu eneo la pembetatu ukizingatia msingi wake na urefu.\n    Vigezo:\n- base (int): Urefu wa msingi wa pembetatu.\n- height (int): Urefu wa pembetatu.\n​    Inarudisha:\n​    float: Eneo lililohesabiwa la pembetatu, lililozungushwa hadi sehemu moja ya desimali.\n    >>> f_7(1,2)\n    1.0", "tr": "Bir CPP fonksiyonu `float f_7(int base, int height)` yazın ve aşağıdaki problemi çözün:\nÜçgenin tabanı ve yüksekliği verildiğinde alanını hesaplayın.\n    Parametreler:\n- base (int): Üçgenin taban uzunluğu.\n- height (int): Üçgenin yüksekliği.\n​    Döndürür:\n​    float: Hesaplanan üçgen alanı, bir ondalık basamağa yuvarlanmış.\n    >>> f_7(1,2)\n    1.0", "vi": "Viết một hàm CPP `float f_7(int base, int height)` để giải quyết vấn đề sau:\nTính diện tích của một tam giác cho trước độ dài đáy và chiều cao của nó.\n    Tham số:\n- base (int): Độ dài đáy của tam giác.\n- height (int): Chiều cao của tam giác.\n    Trả về:\n    float: Diện tích đã tính của tam giác, làm tròn đến một chữ số thập phân.\n    >>> f_7(1,2)\n    1.0", "id": "Tulis fungsi CPP `float f_7(int base, int height)` untuk menyelesaikan masalah berikut:\nHitung luas segitiga yang diberikan alas dan tingginya.\n    Parameter:\n- base (int): Panjang alas segitiga.\n- height (int): Tinggi segitiga.\n    Mengembalikan:\n    float: Luas segitiga yang dihitung, dibulatkan ke satu tempat desimal.\n    >>> f_7(1,2)\n    1.0", "ja": "CPP関数 `float f_7(int base, int height)` を作成して、次の問題を解決してください:\n三角形の底辺と高さが与えられたとき、その面積を計算します。\n    パラメータ:\n- base (int): 三角形の底辺の長さ。\n- height (int): 三角形の高さ。\n​    戻り値:\n​    float: 計算された三角形の面積、小数点以下1桁に丸められます。\n    >>> f_7(1,2)\n    1.0", "ko": "`float f_7(int base, int height)` 함수를 작성하여 다음 문제를 해결하십시오:\n주어진 밑변과 높이를 사용하여 삼각형의 면적을 계산하십시오.\n    매개변수:\n- base (int): 삼각형의 밑변 길이.\n- height (int): 삼각형의 높이.\n​    반환:\n​    float: 소수점 첫째 자리까지 반올림된 삼각형의 계산된 면적.\n    >>> f_7(1,2)\n    1.0", "ml": "ഒരു CPP ഫംഗ്ഷൻ `float f_7(int base, int height)` എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nതലക്കെട്ടും ഉയരവും നൽകിയിരിക്കുന്ന ഒരു ത്രികോണത്തിന്റെ വിസ്തീർണ്ണം കണക്കാക്കുക.\n    പാരാമീറ്ററുകൾ:\n- base (int): ത്രികോണത്തിന്റെ അടിയുടെ നീളം.\n- height (int): ത്രികോണത്തിന്റെ ഉയരം.\n​    തിരികെ നൽകുന്നു:\n​    float: കണക്കാക്കിയ ത്രികോണത്തിന്റെ വിസ്തീർണ്ണം, ഒരു ദശാംശ സ്ഥാനത്തേക്ക് വട്ടമിട്ടത്.\n    >>> f_7(1,2)\n    1.0", "fa": "یک تابع CPP بنویسید `float f_7(int base, int height)` برای حل مسئله زیر:\nمساحت یک مثلث را با توجه به قاعده و ارتفاع آن محاسبه کنید.\n    پارامترها:\n- base (int): طول قاعده مثلث.\n- height (int): ارتفاع مثلث.\n    بازگشت:\n    float: مساحت محاسبه شده مثلث، گرد شده به یک رقم اعشار.\n    >>> f_7(1,2)\n    1.0"}, "level": "easy", "test": "int main()\n{\n    // Adding more comprehensive test cases and correcting the expected values\n    assert(fabs(f_7(1, 2) - 1.0) < 1e-6); // Should assert true with close approximate comparison\n    assert(fabs(f_7(3, 4) - 6.0) < 1e-6); // Should assert true with close approximate comparison\n    assert(fabs(f_7(5, 8) - 20.0) < 1e-6); // Additional test case\n    assert(fabs(f_7(7, 3) - 10.5) < 1e-6); // Additional test case\n    assert(fabs(f_7(10, 10) - 50.0) < 1e-6); // Additional test case\n\n    // printf(\"All tests passed.\\n\");\n    return 0;\n}", "entry_point": "f_7", "signature": "float f_7(int base, int height)", "docstring": {"en": "Calculate the area of a triangle given its base and height.\n    Parameters:\n- base (int): The base length of the triangle.\n- height (int): The height of the triangle.\n​    Returns:\n​    float: The calculated area of the triangle, rounded to one decimal place.\n    >>> f_7(1,2)\n    1.0\n", "sq": "Llogarit sipërfaqen e një trekëndëshi duke pasur bazën dhe lartësinë e tij.\n    Parametrat:\n- base (int): Gjatësia e bazës së trekëndëshit.\n- height (int): Lartësia e trekëndëshit.\n    Kthen:\n    float: Sipërfaqja e llogaritur e trekëndëshit, e rrumbullakosur në një vend dhjetor.\n    >>> f_7(1,2)\n    1.0", "hy": "Հաշվել եռանկյան մակերեսը, տրված նրա հիմքը և բարձրությունը:\n    Պարամետրեր:\n- base (int): Եռանկյան հիմքի երկարությունը:\n- height (int): Եռանկյան բարձրությունը:\n    Վերադարձնում է:\n    float: Եռանկյան հաշվարկված մակերեսը, կլորացված մինչև մեկ տասնորդական:\n    >>> f_7(1,2)\n    1.0", "bn": "ত্রিভুজের ভিত্তি এবং উচ্চতা দেওয়া থাকলে তার ক্ষেত্রফল গণনা করুন।\n    Parameters:\n- base (int): ত্রিভুজের ভিত্তির দৈর্ঘ্য।\n- height (int): ত্রিভুজের উচ্চতা।\n    Returns:\n    float: ত্রিভুজের গণনা করা ক্ষেত্রফল, এক দশমিক স্থান পর্যন্ত গোলাকার।\n    >>> f_7(1,2)\n    1.0", "bg": "Изчисляване на лицето на триъгълник, като се дадат неговата основа и височина.\n    Параметри:\n- base (int): Дължината на основата на триъгълника.\n- height (int): Височината на триъгълника.\n​    Връща:\n​    float: Изчисленото лице на триъгълника, закръглено до един десетичен знак.\n    >>> f_7(1,2)\n    1.0", "zh": "计算给定底边和高的三角形面积。\n    参数:\n- base (int): 三角形的底边长度。\n- height (int): 三角形的高度。\n    返回:\n    float: 计算出的三角形面积，四舍五入到小数点后一位。\n    >>> f_7(1,2)\n    1.0", "fr": "Calculer l'aire d'un triangle donné sa base et sa hauteur.\n    Paramètres:\n- base (int): La longueur de la base du triangle.\n- height (int): La hauteur du triangle.\n​    Renvoie:\n​    float: L'aire calculée du triangle, arrondie à un chiffre après la virgule.\n    >>> f_7(1,2)\n    1.0", "de": "Berechnen Sie die Fläche eines Dreiecks, gegeben durch seine Basis und Höhe.\n    Parameter:\n- base (int): Die Basislänge des Dreiecks.\n- height (int): Die Höhe des Dreiecks.\n​    Rückgabewert:\n​    float: Die berechnete Fläche des Dreiecks, gerundet auf eine Dezimalstelle.\n    >>> f_7(1,2)\n    1.0", "ha": "Ƙididdige yanki na alwatika da aka ba da ginshiƙi da tsawo.\n    Sigogi:\n- base (int): Tsawon tushe na alwatika.\n- height (int): Tsawon tsawo na alwatika.\n​    Komawa:\n​    float: Yankin da aka lissafa na alwatika, an zagaye zuwa wuri daya na goma.\n    >>> f_7(1,2)\n    1.0", "hi": "त्रिभुज का क्षेत्रफल उसकी आधार और ऊँचाई के आधार पर गणना करें।\n    पैरामीटर्स:\n- base (int): त्रिभुज की आधार लंबाई।\n- height (int): त्रिभुज की ऊँचाई।\n    रिटर्न्स:\n    float: त्रिभुज का गणना किया गया क्षेत्रफल, एक दशमलव स्थान तक गोल किया गया।\n    >>> f_7(1,2)\n    1.0", "hu": "Számítsa ki egy háromszög területét az alapja és magassága alapján.\n    Paraméterek:\n- base (int): A háromszög alapjának hossza.\n- height (int): A háromszög magassága.\n    Visszatér:\n    float: A háromszög kiszámított területe, egy tizedesjegyre kerekítve.\n    >>> f_7(1,2)\n    1.0", "es": "Calcular el área de un triángulo dado su base y altura.\n    Parámetros:\n- base (int): La longitud de la base del triángulo.\n- height (int): La altura del triángulo.\n​    Devuelve:\n​    float: El área calculada del triángulo, redondeada a un decimal.\n    >>> f_7(1,2)\n    1.0", "arb": "احسب مساحة المثلث المعطى قاعدته وارتفاعه.\n    المعلمات:\n- base (int): طول قاعدة المثلث.\n- height (int): ارتفاع المثلث.\n    يعيد:\n    float: المساحة المحسوبة للمثلث، مقربة إلى منزلة عشرية واحدة.\n    >>> f_7(1,2)\n    1.0", "sw": "Hesabu eneo la pembetatu ukizingatia msingi wake na urefu.\n    Parameters:\n- base (int): Urefu wa msingi wa pembetatu.\n- height (int): Urefu wa pembetatu.\n​    Inarejesha:\n​    float: Eneo lililohesabiwa la pembetatu, lililokadiriwa hadi sehemu moja ya desimali.\n    >>> f_7(1,2)\n    1.0", "tr": "Üçgenin taban uzunluğu ve yüksekliği verildiğinde alanını hesaplayın.\n    Parametreler:\n- base (int): Üçgenin taban uzunluğu.\n- height (int): Üçgenin yüksekliği.\n    Dönüş:\n    float: Üçgenin hesaplanan alanı, bir ondalık basamağa yuvarlanmış olarak.\n    >>> f_7(1,2)\n    1.0", "vi": "Tính diện tích của một tam giác dựa trên đáy và chiều cao của nó.\n    Tham số:\n- base (int): Chiều dài đáy của tam giác.\n- height (int): Chiều cao của tam giác.\n    Trả về:\n    float: Diện tích được tính của tam giác, làm tròn đến một chữ số thập phân.\n    >>> f_7(1,2)\n    1.0", "id": "Hitung luas segitiga yang diberikan alas dan tingginya.\n    Parameters:\n- base (int): Panjang alas segitiga.\n- height (int): Tinggi segitiga.\n    Returns:\n    float: Luas segitiga yang dihitung, dibulatkan ke satu tempat desimal.\n    >>> f_7(1,2)\n    1.0", "ja": "三角形の底辺と高さが与えられたときの面積を計算します。\n    引数:\n    - base (int): 三角形の底辺の長さ。\n    - height (int): 三角形の高さ。\n    戻り値:\n    float: 計算された三角形の面積を小数点以下1桁に丸めたもの。\n    >>> f_7(1,2)\n    1.0", "ko": "삼각형의 밑변과 높이가 주어졌을 때 삼각형의 넓이를 계산합니다.\n    매개변수:\n    - base (int): 삼각형의 밑변 길이.\n    - height (int): 삼각형의 높이.\n    반환:\n    float: 소수점 첫째 자리까지 반올림된 삼각형의 계산된 넓이.\n    >>> f_7(1,2)\n    1.0", "ml": "ത്രികോണത്തിന്റെ അടിയും ഉയരവും നൽകിയാൽ അതിന്റെ വിസ്തീർണ്ണം കണക്കാക്കുക.\n    പാരാമീറ്ററുകൾ:\n- base (int): ത്രികോണത്തിന്റെ അടിയുടെ നീളം.\n- height (int): ത്രികോണത്തിന്റെ ഉയരം.\n    മടക്കുക:\n    float: ത്രികോണത്തിന്റെ വിസ്തീർണ്ണം കണക്കാക്കി, ഒരു ദശാംശ സ്ഥാനത്തേക്ക് വട്ടമിട്ട്.\n    >>> f_7(1,2)\n    1.0", "fa": "محاسبه مساحت یک مثلث با توجه به قاعده و ارتفاع آن.\n    پارامترها:\n- base (int): طول قاعده مثلث.\n- height (int): ارتفاع مثلث.\n    بازگشت:\n    float: مساحت محاسبه شده مثلث، گرد شده به یک رقم اعشار.\n    >>> f_7(1,2)\n    1.0"}}
{"task_id": "CPP/8", "prompt": {"en": "#include <bits/stdc++.h>\n/*\nCalculate the Hamming distance between two integers in binary representation.\n​    Parameters:\n- x (int): The first positive integer (x <= 1,000,000,000).\n- y (int): The second positive integer (y <= 1,000,000,000).\n​    Returns:\n​    int: The Hamming distance between x and y, i.e., the number of bits that need to be flipped\n​         to transform x into y in binary.\n\t>>> f_8(1,2)\n\t2\n*/\nint f_8(int x, int y)", "sq": "#include <bits/stdc++.h>\n/*\nLlogarit distancën Hamming midis dy numrave të plotë në përfaqësimin binar.\n​    Parametrat:\n- x (int): Numri i parë pozitiv (x <= 1,000,000,000).\n- y (int): Numri i dytë pozitiv (y <= 1,000,000,000).\n​    Kthen:\n​    int: Distanca Hamming midis x dhe y, dmth numri i biteve që duhet të ndryshohen\n​         për të transformuar x në y në binar.\n\t>>> f_8(1,2)\n\t2\n*/\nint f_8(int x, int y)", "hy": "#include <bits/stdc++.h>\n/*\nՀաշվել Հեմինգի հեռավորությունը երկու ամբողջ թվերի միջև երկբայական ներկայացման մեջ։\n​    Պարամետրեր:\n- x (int): Առաջին դրական ամբողջ թիվը (x <= 1,000,000,000)։\n- y (int): Երկրորդ դրական ամբողջ թիվը (y <= 1,000,000,000)։\n​    Վերադարձնում է:\n​    int: Հեմինգի հեռավորությունը x-ի և y-ի միջև, այսինքն՝ բիթերի քանակը, որոնք պետք է փոխվեն\n​         x-ը y-ի վերածելու համար երկբայականում։\n\t>>> f_8(1,2)\n\t2\n*/\nint f_8(int x, int y)", "bn": "#include <bits/stdc++.h>\n/*\nদুটি পূর্ণসংখ্যার বাইনারি উপস্থাপনার মধ্যে হ্যামিং দূরত্ব গণনা করুন।\n    পরামিতি:\n- x (int): প্রথম ধনাত্মক পূর্ণসংখ্যা (x <= 1,000,000,000)।\n- y (int): দ্বিতীয় ধনাত্মক পূর্ণসংখ্যা (y <= 1,000,000,000)।\n    রিটার্নস:\n    int: x এবং y এর মধ্যে হ্যামিং দূরত্ব, অর্থাৎ x কে বাইনারিতে y তে রূপান্তর করতে যে সংখ্যক বিট পরিবর্তন করতে হবে\n         তার সংখ্যা।\n\t>>> f_8(1,2)\n\t2\n*/\nint f_8(int x, int y)", "bg": "#include <bits/stdc++.h>\n/*\nИзчислете разстоянието на Хаминг между две цели числа в двоична форма.\n​    Параметри:\n- x (int): Първото положително цяло число (x <= 1,000,000,000).\n- y (int): Второто положително цяло число (y <= 1,000,000,000).\n​    Връща:\n​    int: Разстоянието на Хаминг между x и y, т.е. броят на битовете, които трябва да бъдат обърнати,\n​         за да се трансформира x в y в двоична форма.\n\t>>> f_8(1,2)\n\t2\n*/\nint f_8(int x, int y)", "zh": "#include <bits/stdc++.h>\n/*\n计算两个整数在二进制表示中的汉明距离。\n​    参数:\n- x (int): 第一个正整数 (x <= 1,000,000,000)。\n- y (int): 第二个正整数 (y <= 1,000,000,000)。\n​    返回:\n​    int: x 和 y 之间的汉明距离，即需要翻转的位数以将 x 转换为二进制中的 y。\n\t>>> f_8(1,2)\n\t2\n*/\nint f_8(int x, int y)", "fr": "#include <bits/stdc++.h>\n/*\nCalculer la distance de Hamming entre deux entiers en représentation binaire.\n​    Paramètres:\n- x (int): Le premier entier positif (x <= 1,000,000,000).\n- y (int): Le deuxième entier positif (y <= 1,000,000,000).\n​    Renvoie:\n​    int: La distance de Hamming entre x et y, c'est-à-dire le nombre de bits qui doivent être inversés\n​         pour transformer x en y en binaire.\n\t>>> f_8(1,2)\n\t2\n*/\nint f_8(int x, int y)", "de": "#include <bits/stdc++.h>\n/*\nBerechne die Hamming-Distanz zwischen zwei ganzen Zahlen in binärer Darstellung.\n​    Parameter:\n- x (int): Die erste positive ganze Zahl (x <= 1,000,000,000).\n- y (int): Die zweite positive ganze Zahl (y <= 1,000,000,000).\n​    Rückgabewert:\n​    int: Die Hamming-Distanz zwischen x und y, d.h., die Anzahl der Bits, die umgekehrt werden müssen,\n​         um x in y in binärer Form zu transformieren.\n\t>>> f_8(1,2)\n\t2\n*/\nint f_8(int x, int y)", "ha": "#include <bits/stdc++.h>\n/*\nƘididdige nisan Hamming tsakanin lambobi biyu a cikin wakilcin binary.\n​    Sigogi:\n- x (int): Lamba ta farko mai kyau (x <= 1,000,000,000).\n- y (int): Lamba ta biyu mai kyau (y <= 1,000,000,000).\n​    Mayar da:\n​    int: Nisan Hamming tsakanin x da y, wato, adadin bits da ake buƙatar a jujjuya\n​         don canza x zuwa y a cikin binary.\n\t>>> f_8(1,2)\n\t2\n*/\nint f_8(int x, int y)", "hi": "#include <bits/stdc++.h>\n/*\nदो पूर्णांकों के बीच बाइनरी प्रतिनिधित्व में हैमिंग दूरी की गणना करें।\n    पैरामीटर्स:\n- x (int): पहला धनात्मक पूर्णांक (x <= 1,000,000,000)।\n- y (int): दूसरा धनात्मक पूर्णांक (y <= 1,000,000,000)।\n    रिटर्न करता है:\n    int: x और y के बीच हैमिंग दूरी, अर्थात्, बाइनरी में x को y में बदलने के लिए कितने बिट्स को फ्लिप करने की आवश्यकता है।\n\t>>> f_8(1,2)\n\t2\n*/\nint f_8(int x, int y)", "hu": "#include <bits/stdc++.h>\n/*\nSzámítsa ki a Hamming-távolságot két egész szám között bináris ábrázolásban.\n​    Paraméterek:\n- x (int): Az első pozitív egész szám (x <= 1,000,000,000).\n- y (int): A második pozitív egész szám (y <= 1,000,000,000).\n​    Visszatér:\n​    int: A Hamming-távolság x és y között, azaz a bitek száma, amelyeket meg kell változtatni\n​         ahhoz, hogy x-et y-ra alakítsuk binárisan.\n\t>>> f_8(1,2)\n\t2\n*/\nint f_8(int x, int y)", "es": "#include <bits/stdc++.h>\n/*\nCalcular la distancia de Hamming entre dos enteros en representación binaria.\n    Parámetros:\n- x (int): El primer entero positivo (x <= 1,000,000,000).\n- y (int): El segundo entero positivo (y <= 1,000,000,000).\n    Retorna:\n    int: La distancia de Hamming entre x e y, es decir, el número de bits que necesitan ser cambiados\n         para transformar x en y en binario.\n    >>> f_8(1,2)\n    2\n*/\nint f_8(int x, int y)", "arb": "#include <bits/stdc++.h>\n/*\nاحسب مسافة هامنج بين عددين صحيحين في التمثيل الثنائي.\n    المعطيات:\n- x (int): العدد الصحيح الأول الموجب (x <= 1,000,000,000).\n- y (int): العدد الصحيح الثاني الموجب (y <= 1,000,000,000).\n    يعيد:\n    int: مسافة هامنج بين x و y، أي عدد البتات التي يجب قلبها\n         لتحويل x إلى y في النظام الثنائي.\n\t>>> f_8(1,2)\n\t2\n*/\nint f_8(int x, int y)", "sw": "#include <bits/stdc++.h>\n/*\nHesabu umbali wa Hamming kati ya nambari mbili katika uwakilishi wa binary.\n​    Vigezo:\n- x (int): Nambari ya kwanza chanya (x <= 1,000,000,000).\n- y (int): Nambari ya pili chanya (y <= 1,000,000,000).\n​    Inarudisha:\n​    int: Umbali wa Hamming kati ya x na y, yaani, idadi ya biti zinazohitaji kubadilishwa\n​         ili kubadilisha x kuwa y katika binary.\n\t>>> f_8(1,2)\n\t2\n*/\nint f_8(int x, int y)", "tr": "#include <bits/stdc++.h>\n/*\nİki tam sayının ikili gösteriminde Hamming mesafesini hesaplayın.\n​    Parametreler:\n- x (int): İlk pozitif tam sayı (x <= 1,000,000,000).\n- y (int): İkinci pozitif tam sayı (y <= 1,000,000,000).\n​    Döndürür:\n​    int: x ve y arasındaki Hamming mesafesi, yani x'i ikili olarak y'ye dönüştürmek için çevrilmesi gereken bit sayısı.\n\t>>> f_8(1,2)\n\t2\n*/\nint f_8(int x, int y)", "vi": "#include <bits/stdc++.h>\n/*\nTính khoảng cách Hamming giữa hai số nguyên trong biểu diễn nhị phân.\n​    Tham số:\n- x (int): Số nguyên dương thứ nhất (x <= 1,000,000,000).\n- y (int): Số nguyên dương thứ hai (y <= 1,000,000,000).\n​    Trả về:\n​    int: Khoảng cách Hamming giữa x và y, tức là số bit cần phải lật\n​         để biến đổi x thành y trong nhị phân.\n\t>>> f_8(1,2)\n\t2\n*/\nint f_8(int x, int y)", "id": "#include <bits/stdc++.h>\n/*\nHitung jarak Hamming antara dua bilangan bulat dalam representasi biner.\n​    Parameter:\n- x (int): Bilangan bulat positif pertama (x <= 1,000,000,000).\n- y (int): Bilangan bulat positif kedua (y <= 1,000,000,000).\n​    Mengembalikan:\n​    int: Jarak Hamming antara x dan y, yaitu jumlah bit yang perlu dibalik\n​         untuk mengubah x menjadi y dalam biner.\n\t>>> f_8(1,2)\n\t2\n*/\nint f_8(int x, int y)", "ja": "#include <bits/stdc++.h>\n/*\n2つの整数の2進数表現におけるハミング距離を計算します。\n​    パラメータ:\n- x (int): 最初の正の整数 (x <= 1,000,000,000)。\n- y (int): 2番目の正の整数 (y <= 1,000,000,000)。\n​    戻り値:\n​    int: xとyのハミング距離、つまりxを2進数でyに変換するために反転する必要があるビットの数。\n\t>>> f_8(1,2)\n\t2\n*/\nint f_8(int x, int y)", "ko": "#include <bits/stdc++.h>\n/*\n두 정수의 이진 표현에서 해밍 거리 계산.\n​    매개변수:\n- x (int): 첫 번째 양의 정수 (x <= 1,000,000,000).\n- y (int): 두 번째 양의 정수 (y <= 1,000,000,000).\n​    반환:\n​    int: x와 y 사이의 해밍 거리, 즉 x를 이진수로 y로 변환하기 위해 뒤집어야 하는 비트의 수.\n\t>>> f_8(1,2)\n\t2\n*/\nint f_8(int x, int y)", "ml": "#include <bits/stdc++.h>\n/*\nരണ്ട് പൂർണ്ണസംഖ്യകളുടെ ബൈനറി പ്രതിനിധാനത്തിൽ ഹാമ്മിംഗ് ദൂരം കണക്കാക്കുക.\n​    പാരാമീറ്ററുകൾ:\n- x (int): ആദ്യത്തെ പോസിറ്റീവ് പൂർണ്ണസംഖ്യ (x <= 1,000,000,000).\n- y (int): രണ്ടാം പോസിറ്റീവ് പൂർണ്ണസംഖ്യ (y <= 1,000,000,000).\n​    തിരികെ നൽകുന്നു:\n​    int: x നെ y ആയി ബൈനറിയിൽ മാറ്റാൻ എത്ര ബിറ്റുകൾ മാറ്റേണ്ടതുണ്ട് എന്നതിന്റെ ഹാമ്മിംഗ് ദൂരം.\n\t>>> f_8(1,2)\n\t2\n*/\nint f_8(int x, int y)", "fa": "#include <bits/stdc++.h>\n/*\nمحاسبه فاصله همینگ بین دو عدد صحیح در نمایش باینری.\n​    پارامترها:\n- x (int): اولین عدد صحیح مثبت (x <= 1,000,000,000).\n- y (int): دومین عدد صحیح مثبت (y <= 1,000,000,000).\n​    بازگشت:\n​    int: فاصله همینگ بین x و y، یعنی تعداد بیت‌هایی که باید تغییر کنند\n​         تا x به y در باینری تبدیل شود.\n\t>>> f_8(1,2)\n\t2\n*/\nint f_8(int x, int y)"}, "canonical_solution": "{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}", "instruction": {"en": "Write a CPP function `int f_8(int x, int y)` to solve the following problem:\nCalculate the Hamming distance between two integers in binary representation.\n    Parameters:\n- x (int): The first positive integer (x <= 1,000,000,000).\n- y (int): The second positive integer (y <= 1,000,000,000).\n    Returns:\n    int: The Hamming distance between x and y, i.e., the number of bits that need to be flipped to transform x into y in binary.\n    >>> f_8(1,2)\n    2\n", "sq": "Shkruani një funksion CPP `int f_8(int x, int y)` për të zgjidhur problemin e mëposhtëm:\nLlogaritni distancën Hamming midis dy numrave të plotë në përfaqësimin binar.\n    Parametrat:\n- x (int): Numri i parë pozitiv (x <= 1,000,000,000).\n- y (int): Numri i dytë pozitiv (y <= 1,000,000,000).\n    Kthen:\n    int: Distanca Hamming midis x dhe y, dmth., numri i bitëve që duhet të ndryshohen për të transformuar x në y në binar.\n    >>> f_8(1,2)\n    2", "hy": "Գրեք CPP ֆունկցիա `int f_8(int x, int y)` հետևյալ խնդիրը լուծելու համար:\nՀաշվեք Հեմինգի հեռավորությունը երկու ամբողջ թվերի միջև երկբայն ներկայացման մեջ։\n    Պարամետրեր:\n- x (int): Առաջին դրական ամբողջ թիվը (x <= 1,000,000,000)։\n- y (int): Երկրորդ դրական ամբողջ թիվը (y <= 1,000,000,000)։\n    Վերադարձնում է:\n    int: Հեմինգի հեռավորությունը x-ի և y-ի միջև, այսինքն՝ այն բիթերի քանակը, որոնք պետք է փոխվեն x-ը y-ի վերածելու համար երկբայն համակարգում։\n    >>> f_8(1,2)\n    2", "bn": "একটি CPP ফাংশন `int f_8(int x, int y)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nদুটি পূর্ণসংখ্যার বাইনারি উপস্থাপনার মধ্যে হ্যামিং দূরত্ব গণনা করুন।\n    প্যারামিটারসমূহ:\n- x (int): প্রথম ধনাত্মক পূর্ণসংখ্যা (x <= 1,000,000,000)।\n- y (int): দ্বিতীয় ধনাত্মক পূর্ণসংখ্যা (y <= 1,000,000,000)।\n    রিটার্নস:\n    int: x এবং y এর মধ্যে হ্যামিং দূরত্ব, অর্থাৎ x কে বাইনারিতে y তে রূপান্তর করতে যে সংখ্যক বিট পরিবর্তন করতে হবে।\n    >>> f_8(1,2)\n    2", "bg": "Напишете CPP функция `int f_8(int x, int y)`, за да решите следния проблем:\nИзчислете разстоянието на Хаминг между две цели числа в двоично представяне.\n    Параметри:\n- x (int): Първото положително цяло число (x <= 1,000,000,000).\n- y (int): Второто положително цяло число (y <= 1,000,000,000).\n    Връща:\n    int: Разстоянието на Хаминг между x и y, т.е. броят на битовете, които трябва да бъдат обърнати, за да се трансформира x в y в двоична форма.\n    >>> f_8(1,2)\n    2", "zh": "编写一个 CPP 函数 `int f_8(int x, int y)` 来解决以下问题：\n计算两个整数在二进制表示中的汉明距离。\n参数：\n- x (int): 第一个正整数 (x <= 1,000,000,000)。\n- y (int): 第二个正整数 (y <= 1,000,000,000)。\n返回：\nint: x 和 y 之间的汉明距离，即需要翻转的位数以将 x 转换为二进制中的 y。\n>>> f_8(1,2)\n2", "fr": "Écrire une fonction CPP `int f_8(int x, int y)` pour résoudre le problème suivant :\nCalculer la distance de Hamming entre deux entiers en représentation binaire.\n    Paramètres :\n- x (int) : Le premier entier positif (x <= 1,000,000,000).\n- y (int) : Le deuxième entier positif (y <= 1,000,000,000).\n    Renvoie :\n    int : La distance de Hamming entre x et y, c'est-à-dire le nombre de bits qui doivent être inversés pour transformer x en y en binaire.\n    >>> f_8(1,2)\n    2", "de": "Schreiben Sie eine CPP-Funktion `int f_8(int x, int y)`, um das folgende Problem zu lösen:\nBerechnen Sie die Hamming-Distanz zwischen zwei ganzen Zahlen in binärer Darstellung.\n    Parameter:\n- x (int): Die erste positive ganze Zahl (x <= 1,000,000,000).\n- y (int): Die zweite positive ganze Zahl (y <= 1,000,000,000).\n    Rückgabewert:\n    int: Die Hamming-Distanz zwischen x und y, d.h. die Anzahl der Bits, die umgekehrt werden müssen, um x in y in binärer Form zu transformieren.\n    >>> f_8(1,2)\n    2", "ha": "Rubuta aikin CPP `int f_8(int x, int y)` don warware matsalar mai zuwa:\nƘididdige nisan Hamming tsakanin lambobi biyu a cikin wakilcin binary.\n    Sigogi:\n- x (int): Lamba ta farko mai kyau (x <= 1,000,000,000).\n- y (int): Lamba ta biyu mai kyau (y <= 1,000,000,000).\n    Mayarwa:\n    int: Nisan Hamming tsakanin x da y, wato, adadin bits da ake buƙatar juyawa don sauya x zuwa y a cikin binary.\n    >>> f_8(1,2)\n    2", "hi": "एक CPP फ़ंक्शन `int f_8(int x, int y)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदो पूर्णांकों के बीच बाइनरी रूप में हैमिंग दूरी की गणना करें।\n    पैरामीटर्स:\n- x (int): पहला धनात्मक पूर्णांक (x <= 1,000,000,000)।\n- y (int): दूसरा धनात्मक पूर्णांक (y <= 1,000,000,000)।\n    रिटर्न करता है:\n    int: x और y के बीच की हैमिंग दूरी, अर्थात्, बाइनरी में x को y में बदलने के लिए जितने बिट्स को फ्लिप करने की आवश्यकता है।\n    >>> f_8(1,2)\n    2", "hu": "Írj egy CPP függvényt `int f_8(int x, int y)` a következő probléma megoldására:\nSzámítsd ki a Hamming-távolságot két egész szám bináris ábrázolása között.\n    Paraméterek:\n- x (int): Az első pozitív egész szám (x <= 1,000,000,000).\n- y (int): A második pozitív egész szám (y <= 1,000,000,000).\n    Visszatérési érték:\n    int: A Hamming-távolság x és y között, azaz a bitek száma, amelyeket meg kell változtatni, hogy x-ből y-t kapjunk binárisan.\n    >>> f_8(1,2)\n    2", "es": "Escribe una función CPP `int f_8(int x, int y)` para resolver el siguiente problema:\nCalcular la distancia de Hamming entre dos enteros en representación binaria.\n    Parámetros:\n- x (int): El primer entero positivo (x <= 1,000,000,000).\n- y (int): El segundo entero positivo (y <= 1,000,000,000).\n    Devuelve:\n    int: La distancia de Hamming entre x e y, es decir, el número de bits que deben ser cambiados para transformar x en y en binario.\n    >>> f_8(1,2)\n    2", "arb": "اكتب دالة CPP `int f_8(int x, int y)` لحل المشكلة التالية:\nاحسب مسافة هامنج بين عددين صحيحين في التمثيل الثنائي.\n    المعاملات:\n- x (int): العدد الصحيح الأول الموجب (x <= 1,000,000,000).\n- y (int): العدد الصحيح الثاني الموجب (y <= 1,000,000,000).\n    يعيد:\n    int: مسافة هامنج بين x و y، أي عدد البتات التي تحتاج إلى التغيير لتحويل x إلى y في النظام الثنائي.\n    >>> f_8(1,2)\n    2", "sw": "Andika kazi ya CPP `int f_8(int x, int y)` kutatua tatizo lifuatalo:\nHesabu umbali wa Hamming kati ya nambari mbili katika uwakilishi wa binary.\n    Vigezo:\n- x (int): Nambari ya kwanza chanya (x <= 1,000,000,000).\n- y (int): Nambari ya pili chanya (y <= 1,000,000,000).\n    Inarejesha:\n    int: Umbali wa Hamming kati ya x na y, yaani, idadi ya biti zinazohitajika kubadilishwa ili kubadilisha x kuwa y katika binary.\n    >>> f_8(1,2)\n    2", "tr": "Bir CPP fonksiyonu `int f_8(int x, int y)` yazın: Aşağıdaki problemi çözmek için:\nİki tam sayının ikili gösterimdeki Hamming mesafesini hesaplayın.\n    Parametreler:\n- x (int): İlk pozitif tam sayı (x <= 1,000,000,000).\n- y (int): İkinci pozitif tam sayı (y <= 1,000,000,000).\n    Döndürür:\n    int: x ve y arasındaki Hamming mesafesi, yani x'i ikili olarak y'ye dönüştürmek için çevrilmesi gereken bit sayısı.\n    >>> f_8(1,2)\n    2", "vi": "Viết một hàm CPP `int f_8(int x, int y)` để giải quyết vấn đề sau:\nTính khoảng cách Hamming giữa hai số nguyên trong biểu diễn nhị phân.\n    Tham số:\n- x (int): Số nguyên dương thứ nhất (x <= 1,000,000,000).\n- y (int): Số nguyên dương thứ hai (y <= 1,000,000,000).\n    Trả về:\n    int: Khoảng cách Hamming giữa x và y, tức là số bit cần phải lật để biến đổi x thành y trong nhị phân.\n    >>> f_8(1,2)\n    2", "id": "Tulis sebuah fungsi CPP `int f_8(int x, int y)` untuk menyelesaikan masalah berikut:\nHitung jarak Hamming antara dua bilangan bulat dalam representasi biner.\n    Parameter:\n- x (int): Bilangan bulat positif pertama (x <= 1,000,000,000).\n- y (int): Bilangan bulat positif kedua (y <= 1,000,000,000).\n    Mengembalikan:\n    int: Jarak Hamming antara x dan y, yaitu jumlah bit yang perlu dibalik untuk mengubah x menjadi y dalam biner.\n    >>> f_8(1,2)\n    2", "ja": "次の問題を解くために、CPP関数 `int f_8(int x, int y)` を作成してください:\n2つの整数の2進数表現におけるハミング距離を計算します。\n    パラメータ:\n- x (int): 最初の正の整数 (x <= 1,000,000,000)。\n- y (int): 2番目の正の整数 (y <= 1,000,000,000)。\n    戻り値:\n    int: xとyのハミング距離、すなわちxをyに2進数で変換するために反転する必要があるビット数。\n    >>> f_8(1,2)\n    2", "ko": "다음 문제를 해결하기 위해 CPP 함수를 작성하세요 `int f_8(int x, int y)`:\n두 정수를 이진 표현으로 나타내었을 때의 해밍 거리 계산.\n    매개변수:\n- x (int): 첫 번째 양의 정수 (x <= 1,000,000,000).\n- y (int): 두 번째 양의 정수 (y <= 1,000,000,000).\n    반환:\n    int: x와 y 사이의 해밍 거리, 즉 이진수로 x를 y로 변환하기 위해 뒤집어야 하는 비트의 수.\n    >>> f_8(1,2)\n    2", "ml": "CPP ഫംഗ്ഷൻ `int f_8(int x, int y)` എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nരണ്ട് പൂർണ്ണസംഖ്യകളുടെ ബൈനറി പ്രതിനിധാനത്തിലെ ഹാമിംഗ് ദൂരം കണക്കാക്കുക.\n    പാരാമീറ്ററുകൾ:\n- x (int): ആദ്യത്തെ പോസിറ്റീവ് പൂർണ്ണസംഖ്യ (x <= 1,000,000,000).\n- y (int): രണ്ടാം പോസിറ്റീവ് പൂർണ്ണസംഖ്യ (y <= 1,000,000,000).\n    തിരികെ നൽകുന്നത്:\n    int: x നും y നും ഇടയിലെ ഹാമിംഗ് ദൂരം, അഥവാ x നെ ബൈനറിയിൽ y ആക്കാൻ മാറ്റേണ്ട ബിറ്റുകളുടെ എണ്ണം.\n    >>> f_8(1,2)\n    2", "fa": "یک تابع CPP `int f_8(int x, int y)` بنویسید تا مسئله زیر را حل کند:\nفاصله همینگ بین دو عدد صحیح در نمایش دودویی را محاسبه کنید.\n    پارامترها:\n- x (int): اولین عدد صحیح مثبت (x <= 1,000,000,000).\n- y (int): دومین عدد صحیح مثبت (y <= 1,000,000,000).\n    بازگشت:\n    int: فاصله همینگ بین x و y، یعنی تعداد بیت‌هایی که برای تبدیل x به y در دودویی باید تغییر کنند.\n    >>> f_8(1,2)\n    2"}, "level": "middle", "test": "int main() {\n    assert(f_8(1, 2) == 2); // 01 and 10 have 2 different bits\n    assert(f_8(4, 7) == 2); // 100 and 111 have 2 different bits\n    assert(f_8(25, 30) == 3); // Additional test: 11001 and 11110 have 3 different bits\n    assert(f_8(0, 0) == 0); // Additional test: Same numbers have 0 different bits\n    assert(f_8(0xFFFFFFF, 0x0000000) == 28); // Additional test: Max unsigned int and 0 have 32 different bits\n    return 0;\n}", "entry_point": "f_8", "signature": "int f_8(int x, int y)", "docstring": {"en": "Calculate the Hamming distance between two integers in binary representation.\n    Parameters:\n- x (int): The first positive integer (x <= 1,000,000,000).\n- y (int): The second positive integer (y <= 1,000,000,000).\n    Returns:\n    int: The Hamming distance between x and y, i.e., the number of bits that need to be flipped to transform x into y in binary.\n    >>> f_8(1,2)\n    2\n", "sq": "Llogarit distancën Hamming midis dy numrave të plotë në përfaqësimin binar.\n    Parametrat:\n- x (int): Numri i parë pozitiv (x <= 1,000,000,000).\n- y (int): Numri i dytë pozitiv (y <= 1,000,000,000).\n    Kthen:\n    int: Distanca Hamming midis x dhe y, dmth numri i biteve që duhet të ndryshohen për të transformuar x në y në binar.\n    >>> f_8(1,2)\n    2", "hy": "Հաշվարկել Հեմինգի հեռավորությունը երկու ամբողջ թվերի միջև երկուական ներկայացմամբ։ \n    Պարամետրեր:\n- x (int): Առաջին դրական ամբողջ թիվը (x <= 1,000,000,000)։\n- y (int): Երկրորդ դրական ամբողջ թիվը (y <= 1,000,000,000)։\n    Վերադարձնում է:\n    int: Հեմինգի հեռավորությունը x-ի և y-ի միջև, այսինքն՝ բիթերի քանակը, որոնք անհրաժեշտ է փոխել, որպեսզի x-ը վերածվի y-ի երկուականում։\n    >>> f_8(1,2)\n    2", "bn": "দুটি পূর্ণসংখ্যার বাইনারি উপস্থাপনার মধ্যে হ্যামিং দূরত্ব গণনা করুন।\n    Parameters:\n- x (int): প্রথম ধনাত্মক পূর্ণসংখ্যা (x <= 1,000,000,000)।\n- y (int): দ্বিতীয় ধনাত্মক পূর্ণসংখ্যা (y <= 1,000,000,000)।\n    Returns:\n    int: x এবং y এর মধ্যে হ্যামিং দূরত্ব, অর্থাৎ x কে y তে রূপান্তর করতে যে সংখ্যক বিট পরিবর্তন করতে হবে।\n    >>> f_8(1,2)\n    2", "bg": "Изчисляване на разстоянието на Хаминг между две цели числа в двоична форма.\n    Параметри:\n- x (int): Първото положително цяло число (x <= 1,000,000,000).\n- y (int): Второто положително цяло число (y <= 1,000,000,000).\n    Връща:\n    int: Разстоянието на Хаминг между x и y, т.е. броят на битовете, които трябва да бъдат обърнати, за да се преобразува x в y в двоична форма.\n    >>> f_8(1,2)\n    2", "zh": "计算两个整数在二进制表示中的汉明距离。\n    参数:\n- x (int): 第一个正整数 (x <= 1,000,000,000)。\n- y (int): 第二个正整数 (y <= 1,000,000,000)。\n    返回:\n    int: x 和 y 之间的汉明距离，即需要翻转多少个位才能将 x 转换为 y。\n    >>> f_8(1,2)\n    2", "fr": "Calculer la distance de Hamming entre deux entiers en représentation binaire.\n    Paramètres:\n- x (int): Le premier entier positif (x <= 1,000,000,000).\n- y (int): Le deuxième entier positif (y <= 1,000,000,000).\n    Renvoie:\n    int: La distance de Hamming entre x et y, c'est-à-dire le nombre de bits qui doivent être inversés pour transformer x en y en binaire.\n    >>> f_8(1,2)\n    2", "de": "Berechne die Hamming-Distanz zwischen zwei ganzen Zahlen in binärer Darstellung.\n    Parameter:\n- x (int): Die erste positive ganze Zahl (x <= 1.000.000.000).\n- y (int): Die zweite positive ganze Zahl (y <= 1.000.000.000).\n    Rückgabewert:\n    int: Die Hamming-Distanz zwischen x und y, d.h., die Anzahl der Bits, die umgekehrt werden müssen, um x in y in binär zu transformieren.\n    >>> f_8(1,2)\n    2", "ha": "Ƙididdige nisan Hamming tsakanin lambobi biyu a cikin wakilcin binary.\n    Sigogi:\n- x (int): Lamba ta farko mai kyau (x <= 1,000,000,000).\n- y (int): Lamba ta biyu mai kyau (y <= 1,000,000,000).\n    Dawowa:\n    int: Nisan Hamming tsakanin x da y, wato, adadin bits da ake buƙatar juyawa don canza x zuwa y a cikin binary.\n    >>> f_8(1,2)\n    2", "hi": "दो पूर्णांकों के बीच बाइनरी प्रतिनिधित्व में हैमिंग दूरी की गणना करें।\n    पैरामीटर्स:\n- x (int): पहला धनात्मक पूर्णांक (x <= 1,000,000,000)।\n- y (int): दूसरा धनात्मक पूर्णांक (y <= 1,000,000,000)।\n    रिटर्न्स:\n    int: x और y के बीच हैमिंग दूरी, अर्थात्, x को बाइनरी में y में बदलने के लिए जितने बिट्स को उलटना आवश्यक है।\n    >>> f_8(1,2)\n    2", "hu": "Számítsa ki a Hamming-távolságot két egész szám bináris ábrázolása között.\n    Paraméterek:\n- x (int): Az első pozitív egész szám (x <= 1,000,000,000).\n- y (int): A második pozitív egész szám (y <= 1,000,000,000).\n    Visszatérési érték:\n    int: A Hamming-távolság x és y között, azaz a bitek száma, amelyeket meg kell változtatni ahhoz, hogy x-et y-ra alakítsuk binárisan.\n    >>> f_8(1,2)\n    2", "es": "Calcular la distancia de Hamming entre dos enteros en representación binaria.\n    Parámetros:\n- x (int): El primer entero positivo (x <= 1,000,000,000).\n- y (int): El segundo entero positivo (y <= 1,000,000,000).\n    Devuelve:\n    int: La distancia de Hamming entre x e y, es decir, el número de bits que necesitan ser cambiados para transformar x en y en binario.\n    >>> f_8(1,2)\n    2", "arb": "احسب مسافة هامنج بين عددين صحيحين في التمثيل الثنائي.\n    المعاملات:\n- x (int): العدد الصحيح الأول الموجب (x <= 1,000,000,000).\n- y (int): العدد الصحيح الثاني الموجب (y <= 1,000,000,000).\n    يعيد:\n    int: مسافة هامنج بين x و y، أي عدد البتات التي تحتاج إلى قلب لتحويل x إلى y في النظام الثنائي.\n    >>> f_8(1,2)\n    2", "sw": "Hesabu umbali wa Hamming kati ya nambari mbili katika uwakilishi wa binary.\n    Vigezo:\n- x (int): Nambari ya kwanza chanya (x <= 1,000,000,000).\n- y (int): Nambari ya pili chanya (y <= 1,000,000,000).\n    Inarejesha:\n    int: Umbali wa Hamming kati ya x na y, yaani, idadi ya biti zinazohitajika kubadilishwa ili kubadilisha x kuwa y katika binary.\n    >>> f_8(1,2)\n    2", "tr": "İkili gösterimde iki tamsayı arasındaki Hamming mesafesini hesaplayın.\n    Parametreler:\n- x (int): İlk pozitif tamsayı (x <= 1,000,000,000).\n- y (int): İkinci pozitif tamsayı (y <= 1,000,000,000).\n    Döndürür:\n    int: x ve y arasındaki Hamming mesafesi, yani x'i ikili olarak y'ye dönüştürmek için değiştirilmesi gereken bit sayısı.\n    >>> f_8(1,2)\n    2", "vi": "Tính khoảng cách Hamming giữa hai số nguyên trong biểu diễn nhị phân.\n    Tham số:\n- x (int): Số nguyên dương thứ nhất (x <= 1,000,000,000).\n- y (int): Số nguyên dương thứ hai (y <= 1,000,000,000).\n    Trả về:\n    int: Khoảng cách Hamming giữa x và y, tức là số bit cần phải lật để biến đổi x thành y trong nhị phân.\n    >>> f_8(1,2)\n    2", "id": "Hitung jarak Hamming antara dua bilangan bulat dalam representasi biner.\n    Parameter:\n- x (int): Bilangan bulat positif pertama (x <= 1,000,000,000).\n- y (int): Bilangan bulat positif kedua (y <= 1,000,000,000).\n    Mengembalikan:\n    int: Jarak Hamming antara x dan y, yaitu jumlah bit yang perlu dibalik untuk mengubah x menjadi y dalam biner.\n    >>> f_8(1,2)\n    2", "ja": "2つの整数の2進数表現間のハミング距離を計算します。\n    パラメータ:\n- x (int): 最初の正の整数 (x <= 1,000,000,000)。\n- y (int): 2番目の正の整数 (y <= 1,000,000,000)。\n    戻り値:\n    int: xとyのハミング距離。すなわち、xを2進数でyに変換するために反転する必要があるビットの数。\n    >>> f_8(1,2)\n    2", "ko": "두 정수를 이진 표현으로 변환하여 해밍 거리를 계산합니다.\n    매개변수:\n- x (int): 첫 번째 양의 정수 (x <= 1,000,000,000).\n- y (int): 두 번째 양의 정수 (y <= 1,000,000,000).\n    반환값:\n    int: x와 y 사이의 해밍 거리, 즉 x를 y로 변환하기 위해 뒤집어야 하는 비트 수입니다.\n    >>> f_8(1,2)\n    2", "ml": "Calculate the Hamming distance between two integers in binary representation.\n    പാരാമീറ്ററുകൾ:\n- x (int): ആദ്യത്തെ പോസിറ്റീവ് പൂർണ്ണസംഖ്യ (x <= 1,000,000,000).\n- y (int): രണ്ടാമത്തെ പോസിറ്റീവ് പൂർണ്ണസംഖ്യ (y <= 1,000,000,000).\n    തിരികെ നൽകുന്നു:\n    int: x നും y നും ഇടയിലെ ഹാമിംഗ് ദൂരം, അതായത്, ബൈനറിയിൽ x നെ y ആക്കാൻ മാറ്റേണ്ട ബിറ്റുകളുടെ എണ്ണം.\n    >>> f_8(1,2)\n    2", "fa": "محاسبه فاصله همینگ بین دو عدد صحیح در نمایش دودویی.\n    پارامترها:\n- x (int): اولین عدد صحیح مثبت (x <= 1,000,000,000).\n- y (int): دومین عدد صحیح مثبت (y <= 1,000,000,000).\n    بازگشت:\n    int: فاصله همینگ بین x و y، یعنی تعداد بیت‌هایی که باید تغییر کنند تا x به y در دودویی تبدیل شود.\n    >>> f_8(1,2)\n    2"}}
{"task_id": "CPP/9", "prompt": {"en": "#include <assert.h>\n#include <stdarg.h>\n\n/**\n * Count the number of odd integers in a given list of numbers.\n * Parameters:\n * - count (int): The number of integers to evaluate.\n * - ... (int): A sequence of integers.\n * Returns:\n *   int: The count of odd numbers in the input list.\n * Usage:\n *   f_9(5, 1, 4, 3, 2, 5) should return 3\n */\nint f_9(int count, ...)", "sq": "#include <assert.h>\n#include <stdarg.h>\n\n/**\n * Numëron numrin e numrave tek në një listë të dhënë numrash.\n * Parametrat:\n * - count (int): Numri i numrave për të vlerësuar.\n * - ... (int): Një sekuencë numrash.\n * Kthen:\n *   int: Numri i numrave tek në listën e hyrjes.\n * Përdorimi:\n *   f_9(5, 1, 4, 3, 2, 5) duhet të kthejë 3\n */\nint f_9(int count, ...)", "hy": "#include <assert.h>\n#include <stdarg.h>\n\n/**\n * Հաշվել տրված թվերի ցուցակում կենտ ամբողջ թվերի քանակը։\n * Պարամետրեր:\n * - count (int): Գնահատվող ամբողջ թվերի քանակը։\n * - ... (int): Ամբողջ թվերի հաջորդականություն։\n * Վերադարձնում է:\n *   int: Մուտքային ցուցակի կենտ թվերի քանակը։\n * Օգտագործում:\n *   f_9(5, 1, 4, 3, 2, 5) պետք է վերադարձնի 3\n */\nint f_9(int count, ...)", "bn": "#include <assert.h>\n#include <stdarg.h>\n\n/**\n * প্রদত্ত সংখ্যার তালিকায় বিজোড় পূর্ণসংখ্যার সংখ্যা গণনা করুন।\n * প্যারামিটারসমূহ:\n * - count (int): মূল্যায়ন করার জন্য পূর্ণসংখ্যার সংখ্যা।\n * - ... (int): পূর্ণসংখ্যার একটি ক্রম।\n * রিটার্ন করে:\n *   int: ইনপুট তালিকায় বিজোড় সংখ্যার সংখ্যা।\n * ব্যবহার:\n *   f_9(5, 1, 4, 3, 2, 5) 3 রিটার্ন করা উচিত\n */\nint f_9(int count, ...)", "bg": "#include <assert.h>\n#include <stdarg.h>\n\n/**\n * Преброява броя на нечетните цели числа в даден списък от числа.\n * Параметри:\n * - count (int): Броят на целите числа за оценка.\n * - ... (int): Последователност от цели числа.\n * Връща:\n *   int: Броят на нечетните числа в входния списък.\n * Употреба:\n *   f_9(5, 1, 4, 3, 2, 5) трябва да върне 3\n */\nint f_9(int count, ...)", "zh": "#include <assert.h>\n#include <stdarg.h>\n\n/**\n * 计算给定数字列表中奇数的数量。\n * 参数:\n * - count (int): 要评估的整数数量。\n * - ... (int): 一系列整数。\n * 返回:\n *   int: 输入列表中奇数的数量。\n * 用法:\n *   f_9(5, 1, 4, 3, 2, 5) 应返回 3\n */\nint f_9(int count, ...)", "fr": "#include <assert.h>\n#include <stdarg.h>\n\n/**\n * Compter le nombre d'entiers impairs dans une liste donnée de nombres.\n * Paramètres :\n * - count (int) : Le nombre d'entiers à évaluer.\n * - ... (int) : Une séquence d'entiers.\n * Retourne :\n *   int : Le nombre d'entiers impairs dans la liste d'entrée.\n * Utilisation :\n *   f_9(5, 1, 4, 3, 2, 5) devrait retourner 3\n */\nint f_9(int count, ...)", "de": "#include <assert.h>\n#include <stdarg.h>\n\n/**\n * Zählt die Anzahl der ungeraden Ganzzahlen in einer gegebenen Liste von Zahlen.\n * Parameter:\n * - count (int): Die Anzahl der zu bewertenden Ganzzahlen.\n * - ... (int): Eine Sequenz von Ganzzahlen.\n * Rückgabewert:\n *   int: Die Anzahl der ungeraden Zahlen in der Eingabeliste.\n * Verwendung:\n *   f_9(5, 1, 4, 3, 2, 5) sollte 3 zurückgeben\n */\nint f_9(int count, ...)", "ha": "#include <assert.h>\n#include <stdarg.h>\n\n/**\n * Ƙirga adadin lambobin da ba su da ma'aurata a cikin jerin lambobi da aka bayar.\n * Sigogi:\n * - count (int): Yawan lambobin da za a tantance.\n * - ... (int): Jerin lambobi.\n * Komawa:\n *   int: Adadin lambobin da ba su da ma'aurata a cikin jerin shigarwa.\n * Amfani:\n *   f_9(5, 1, 4, 3, 2, 5) ya kamata ya dawo da 3\n */\nint f_9(int count, ...)", "hi": "#include <assert.h>\n#include <stdarg.h>\n\n/**\n * दी गई संख्याओं की सूची में विषम पूर्णांकों की संख्या गिनें।\n * पैरामीटर्स:\n * - count (int): मूल्यांकन करने के लिए पूर्णांकों की संख्या।\n * - ... (int): पूर्णांकों की एक अनुक्रम।\n * रिटर्न करता है:\n *   int: इनपुट सूची में विषम संख्याओं की गिनती।\n * उपयोग:\n *   f_9(5, 1, 4, 3, 2, 5) को 3 लौटाना चाहिए\n */\nint f_9(int count, ...)", "hu": "#include <assert.h>\n#include <stdarg.h>\n\n/**\n * Számolja meg a páratlan egész számok számát egy adott számok listájában.\n * Paraméterek:\n * - count (int): Az értékelendő egész számok száma.\n * - ... (int): Egy egész számok sorozata.\n * Visszatér:\n *   int: A páratlan számok száma a bemeneti listában.\n * Használat:\n *   f_9(5, 1, 4, 3, 2, 5) vissza kell adja a 3-at\n */\nint f_9(int count, ...)", "es": "#include <assert.h>\n#include <stdarg.h>\n\n/**\n * Cuenta el número de enteros impares en una lista dada de números.\n * Parámetros:\n * - count (int): El número de enteros a evaluar.\n * - ... (int): Una secuencia de enteros.\n * Retorna:\n *   int: La cantidad de números impares en la lista de entrada.\n * Uso:\n *   f_9(5, 1, 4, 3, 2, 5) debería retornar 3\n */\nint f_9(int count, ...)", "arb": "#include <assert.h>\n#include <stdarg.h>\n\n/**\n * عد عدد الأعداد الفردية في قائمة معينة من الأرقام.\n * المعلمات:\n * - count (int): عدد الأعداد لتقييمها.\n * - ... (int): سلسلة من الأعداد الصحيحة.\n * يعيد:\n *   int: عدد الأعداد الفردية في قائمة الإدخال.\n * الاستخدام:\n *   f_9(5, 1, 4, 3, 2, 5) يجب أن تعيد 3\n */\nint f_9(int count, ...)", "sw": "#include <assert.h>\n#include <stdarg.h>\n\n/**\n * Hesabu idadi ya nambari zisizo za kawaida katika orodha iliyotolewa ya nambari.\n * Vigezo:\n * - count (int): Idadi ya nambari za kutathmini.\n * - ... (int): Mlolongo wa nambari.\n * Inarudi:\n *   int: Idadi ya nambari zisizo za kawaida katika orodha ya pembejeo.\n * Matumizi:\n *   f_9(5, 1, 4, 3, 2, 5) inapaswa kurudi 3\n */\nint f_9(int count, ...)", "tr": "#include <assert.h>\n#include <stdarg.h>\n\n/**\n * Verilen bir sayı listesindeki tek sayıların sayısını sayar.\n * Parametreler:\n * - count (int): Değerlendirilecek tamsayıların sayısı.\n * - ... (int): Bir dizi tamsayı.\n * Döndürür:\n *   int: Girdi listesindeki tek sayıların sayısı.\n * Kullanım:\n *   f_9(5, 1, 4, 3, 2, 5) 3 döndürmelidir\n */\nint f_9(int count, ...)", "vi": "#include <assert.h>\n#include <stdarg.h>\n\n/**\n * Đếm số lượng số nguyên lẻ trong một danh sách số đã cho.\n * Tham số:\n * - count (int): Số lượng số nguyên cần đánh giá.\n * - ... (int): Một dãy số nguyên.\n * Trả về:\n *   int: Số lượng số lẻ trong danh sách đầu vào.\n * Sử dụng:\n *   f_9(5, 1, 4, 3, 2, 5) sẽ trả về 3\n */\nint f_9(int count, ...)", "id": "#include <assert.h>\n#include <stdarg.h>\n\n/**\n * Hitung jumlah bilangan bulat ganjil dalam daftar angka yang diberikan.\n * Parameter:\n * - count (int): Jumlah bilangan bulat yang akan dievaluasi.\n * - ... (int): Sekumpulan bilangan bulat.\n * Mengembalikan:\n *   int: Jumlah bilangan ganjil dalam daftar input.\n * Penggunaan:\n *   f_9(5, 1, 4, 3, 2, 5) seharusnya mengembalikan 3\n */\nint f_9(int count, ...)", "ja": "#include <assert.h>\n#include <stdarg.h>\n\n/**\n * 指定された数値のリスト内の奇数の数をカウントします。\n * パラメータ:\n * - count (int): 評価する整数の数。\n * - ... (int): 整数のシーケンス。\n * 戻り値:\n *   int: 入力リスト内の奇数の数。\n * 使用例:\n *   f_9(5, 1, 4, 3, 2, 5) は 3 を返すべきです\n */\nint f_9(int count, ...)", "ko": "#include <assert.h>\n#include <stdarg.h>\n\n/**\n * 주어진 숫자 목록에서 홀수의 개수를 셉니다.\n * 매개변수:\n * - count (int): 평가할 정수의 수.\n * - ... (int): 정수의 시퀀스.\n * 반환값:\n *   int: 입력 목록에서 홀수의 개수.\n * 사용법:\n *   f_9(5, 1, 4, 3, 2, 5) 는 3을 반환해야 합니다\n */\nint f_9(int count, ...)", "ml": "#include <assert.h>\n#include <stdarg.h>\n\n/**\n * നൽകിയ നമ്പറുകളുടെ ലിസ്റ്റിൽ എത്ര ഒറ്റ സംഖ്യകളുണ്ടെന്ന് എണ്ണുക.\n * പാരാമീറ്ററുകൾ:\n * - count (int): വിലയിരുത്തേണ്ട സംഖ്യകളുടെ എണ്ണം.\n * - ... (int): സംഖ്യകളുടെ ഒരു നിര.\n * റിട്ടേൺസ്:\n *   int: ഇൻപുട്ട് ലിസ്റ്റിലെ ഒറ്റ സംഖ്യകളുടെ എണ്ണം.\n * ഉപയോഗം:\n *   f_9(5, 1, 4, 3, 2, 5) 3 റിട്ടേൺ ചെയ്യണം\n */\nint f_9(int count, ...)", "fa": "#include <assert.h>\n#include <stdarg.h>\n\n/**\n * تعداد اعداد فرد را در یک لیست داده شده از اعداد بشمارید.\n * پارامترها:\n * - count (int): تعداد اعدادی که باید ارزیابی شوند.\n * - ... (int): دنباله‌ای از اعداد صحیح.\n * بازگشت:\n *   int: تعداد اعداد فرد در لیست ورودی.\n * استفاده:\n *   f_9(5, 1, 4, 3, 2, 5) باید 3 را برگرداند\n */\nint f_9(int count, ...)"}, "canonical_solution": "{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1) {\n            ans++;\n        }\n    }\n    va_end(args);\n    return ans;\n}", "instruction": {"en": "Write a CPP function `int f_9(int count, ...)` to solve the following problem:\nCount the number of odd integers in a given list of numbers.\nParameters:\n- count (int): The number of integers to evaluate.\n- ... (int): A sequence of integers.\nReturns:\n  int: The count of odd numbers in the input list.\nUsage:\n  f_9(5, 1, 4, 3, 2, 5) should return 3", "sq": "Shkruani një funksion CPP `int f_9(int count, ...)` për të zgjidhur problemin e mëposhtëm:\nNumëroni numrin e numrave tek në një listë të dhënë numrash.\nParametrat:\n- count (int): Numri i numrave për të vlerësuar.\n- ... (int): Një sekuencë numrash të plotë.\nKthen:\n  int: Numri i numrave tek në listën e dhënë.\nPërdorimi:\n  f_9(5, 1, 4, 3, 2, 5) duhet të kthejë 3", "hy": "Գրեք CPP ֆունկցիա `int f_9(int count, ...)` հետևյալ խնդիրը լուծելու համար:\nՀաշվեք կենտ ամբողջ թվերի քանակը տրված թվերի ցուցակում:\nՊարամետրեր:\n- count (int): Ամբողջ թվերի քանակը, որոնք պետք է գնահատել:\n- ... (int): Ամբողջ թվերի հաջորդականություն:\nՎերադարձնում է:\n  int: Կենտ թվերի քանակը մուտքագրված ցուցակում:\nՕգտագործում:\n  f_9(5, 1, 4, 3, 2, 5) պետք է վերադարձնի 3", "bn": "একটি CPP ফাংশন `int f_9(int count, ...)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nদেওয়া সংখ্যার একটি তালিকায় বিজোড় পূর্ণসংখ্যার সংখ্যা গণনা করুন।\nপ্যারামিটারসমূহ:\n- count (int): মূল্যায়ন করার জন্য পূর্ণসংখ্যার সংখ্যা।\n- ... (int): পূর্ণসংখ্যার একটি ক্রম।\nরিটার্নস:\n  int: ইনপুট তালিকায় বিজোড় সংখ্যার সংখ্যা।\nব্যবহার:\n  f_9(5, 1, 4, 3, 2, 5) 3 রিটার্ন করা উচিত।", "bg": "Напишете CPP функция `int f_9(int count, ...)`, за да решите следния проблем:  \nПребройте броя на нечетните цели числа в даден списък от числа.  \nПараметри:  \n- count (int): Броят на целите числа за оценка.  \n- ... (int): Последователност от цели числа.  \nВръща:  \n  int: Броят на нечетните числа в списъка с входни данни.  \nУпотреба:  \n  f_9(5, 1, 4, 3, 2, 5) трябва да върне 3", "zh": "编写一个 CPP 函数 `int f_9(int count, ...)` 来解决以下问题：\n统计给定数字列表中奇数的数量。\n参数：\n- count (int): 要评估的整数数量。\n- ... (int): 一系列整数。\n返回：\n  int: 输入列表中奇数的数量。\n用法：\n  f_9(5, 1, 4, 3, 2, 5) 应返回 3。", "fr": "Écrire une fonction CPP `int f_9(int count, ...)` pour résoudre le problème suivant :  \nCompter le nombre d'entiers impairs dans une liste donnée de nombres.  \nParamètres :  \n- count (int) : Le nombre d'entiers à évaluer.  \n- ... (int) : Une séquence d'entiers.  \nRenvoie :  \n  int : Le nombre d'entiers impairs dans la liste d'entrée.  \nUtilisation :  \n  f_9(5, 1, 4, 3, 2, 5) devrait retourner 3", "de": "Schreiben Sie eine CPP-Funktion `int f_9(int count, ...)`, um das folgende Problem zu lösen:\nZählen Sie die Anzahl der ungeraden Ganzzahlen in einer gegebenen Liste von Zahlen.\nParameter:\n- count (int): Die Anzahl der zu bewertenden Ganzzahlen.\n- ... (int): Eine Sequenz von Ganzzahlen.\nGibt zurück:\n  int: Die Anzahl der ungeraden Zahlen in der Eingabeliste.\nVerwendung:\n  f_9(5, 1, 4, 3, 2, 5) sollte 3 zurückgeben.", "ha": "Rubuta aikin CPP `int f_9(int count, ...)` don warware matsalar mai zuwa:\nƘididdige adadin lambobin da ba su daidai ba a cikin jerin lambobi da aka bayar.\nSigogi:\n- count (int): Yawan lambobin da za a tantance.\n- ... (int): Jeri na lambobi.\nYa dawo:\n  int: Adadin lambobin da ba su daidai ba a cikin jerin shigarwa.\nAmfani:\n  f_9(5, 1, 4, 3, 2, 5) ya kamata ya dawo da 3", "hi": "एक CPP फ़ंक्शन `int f_9(int count, ...)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए संख्याओं की सूची में विषम पूर्णांकों की संख्या गिनें।\nपैरामीटर्स:\n- count (int): मूल्यांकन करने के लिए पूर्णांकों की संख्या।\n- ... (int): पूर्णांकों का अनुक्रम।\nरिटर्न करता है:\n  int: इनपुट सूची में विषम संख्याओं की गिनती।\nउपयोग:\n  f_9(5, 1, 4, 3, 2, 5) 3 लौटाना चाहिए।", "hu": "Írj egy CPP függvényt `int f_9(int count, ...)` a következő probléma megoldására:\nSzámold meg a páratlan egész számok számát egy adott számok listájában.\nParaméterek:\n- count (int): Az értékelendő egész számok száma.\n- ... (int): Egy egész számok sorozata.\nVisszatérési érték:\n  int: A bemeneti listában található páratlan számok száma.\nHasználat:\n  f_9(5, 1, 4, 3, 2, 5) vissza kell adja a 3-at.", "es": "Escribe una función CPP `int f_9(int count, ...)` para resolver el siguiente problema:\nCuenta la cantidad de enteros impares en una lista dada de números.\nParámetros:\n- count (int): El número de enteros a evaluar.\n- ... (int): Una secuencia de enteros.\nDevuelve:\n  int: La cantidad de números impares en la lista de entrada.\nUso:\n  f_9(5, 1, 4, 3, 2, 5) debería devolver 3", "arb": "اكتب دالة CPP `int f_9(int count, ...)` لحل المشكلة التالية:\nعد عدد الأعداد الفردية في قائمة معينة من الأرقام.\nالمعلمات:\n- count (int): عدد الأعداد للتقييم.\n- ... (int): تسلسل من الأعداد الصحيحة.\nالقيم المعادة:\n  int: عدد الأعداد الفردية في قائمة الإدخال.\nالاستخدام:\n  f_9(5, 1, 4, 3, 2, 5) يجب أن تعيد 3", "sw": "Andika kazi ya CPP `int f_9(int count, ...)` kutatua tatizo lifuatalo:\nHesabu idadi ya nambari zisizo za kawaida katika orodha iliyotolewa ya nambari.\nVigezo:\n- count (int): Idadi ya nambari za kutathmini.\n- ... (int): Mlolongo wa nambari.\nInarudisha:\n  int: Idadi ya nambari zisizo za kawaida katika orodha ya pembejeo.\nMatumizi:\n  f_9(5, 1, 4, 3, 2, 5) inapaswa kurudisha 3", "tr": "Bir CPP fonksiyonu `int f_9(int count, ...)` yazın ve aşağıdaki problemi çözün:\nVerilen bir sayı listesindeki tek sayıların sayısını hesaplayın.\nParametreler:\n- count (int): Değerlendirilecek tamsayıların sayısı.\n- ... (int): Bir dizi tamsayı.\nDöndürülen:\n  int: Girdi listesindeki tek sayıların sayısı.\nKullanım:\n  f_9(5, 1, 4, 3, 2, 5) 3 döndürmelidir.", "vi": "Viết một hàm CPP `int f_9(int count, ...)` để giải quyết vấn đề sau:\nĐếm số lượng số nguyên lẻ trong một danh sách các số cho trước.\nTham số:\n- count (int): Số lượng số nguyên cần đánh giá.\n- ... (int): Một dãy các số nguyên.\nTrả về:\n  int: Số lượng số lẻ trong danh sách đầu vào.\nSử dụng:\n  f_9(5, 1, 4, 3, 2, 5) nên trả về 3", "id": "Tulis fungsi CPP `int f_9(int count, ...)` untuk menyelesaikan masalah berikut:\nHitung jumlah bilangan bulat ganjil dalam daftar angka yang diberikan.\nParameter:\n- count (int): Jumlah bilangan bulat yang akan dievaluasi.\n- ... (int): Urutan bilangan bulat.\nMengembalikan:\n  int: Jumlah bilangan ganjil dalam daftar input.\nPenggunaan:\n  f_9(5, 1, 4, 3, 2, 5) seharusnya mengembalikan 3", "ja": "以下の問題を解決するために、CPP関数 `int f_9(int count, ...)` を作成してください:\n与えられた数のリストの中で奇数の整数の数を数えます。\nパラメータ:\n- count (int): 評価する整数の数。\n- ... (int): 整数のシーケンス。\n戻り値:\n  int: 入力リスト内の奇数の数。\n使用例:\n  f_9(5, 1, 4, 3, 2, 5) は 3 を返すべきです。", "ko": "다음 문제를 해결하기 위해 CPP 함수를 작성하세요 `int f_9(int count, ...)`:\n주어진 숫자 목록에서 홀수 정수의 개수를 세십시오.\n매개변수:\n- count (int): 평가할 정수의 수.\n- ... (int): 정수의 시퀀스.\n반환:\n  int: 입력 목록에서 홀수의 개수.\n사용법:\n  f_9(5, 1, 4, 3, 2, 5)는 3을 반환해야 합니다.", "ml": "`int f_9(int count, ...)` എന്ന CPP ഫംഗ്ഷൻ എഴുതുക താഴെ കാണിച്ചിരിക്കുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nനൽകിയിരിക്കുന്ന സംഖ്യകളുടെ പട്ടികയിൽ എത്ര ഒറ്റ സംഖ്യകളാണുള്ളതെന്ന് എണ്ണുക.\nപാരാമീറ്ററുകൾ:\n- count (int): വിലയിരുത്തേണ്ട സംഖ്യകളുടെ എണ്ണം.\n- ... (int): സംഖ്യകളുടെ ഒരു ക്രമം.\nമടക്കിവരുത്തുന്നത്:\n  int: ഇൻപുട്ട് പട്ടികയിലെ ഒറ്റ സംഖ്യകളുടെ എണ്ണം.\nഉപയോഗം:\n  f_9(5, 1, 4, 3, 2, 5) 3 മടക്കിവരുത്തണം.", "fa": "یک تابع CPP بنویسید `int f_9(int count, ...)` برای حل مسئله زیر:\nتعداد اعداد فرد را در یک لیست از اعداد داده شده بشمارید.\nپارامترها:\n- count (int): تعداد اعدادی که باید ارزیابی شوند.\n- ... (int): یک دنباله از اعداد صحیح.\nبرمی‌گرداند:\n  int: تعداد اعداد فرد در لیست ورودی.\nاستفاده:\n  f_9(5, 1, 4, 3, 2, 5) باید 3 را برگرداند."}, "level": "easy", "test": "int main() {\n    assert(f_9(5, 1, 4, 3, 2, 5) == 3);\n    assert(f_9(4, 2, 2, 0, 0) == 0);\n    assert(f_9(6, 7, 7, 8, 1, 9, 10) == 4); // Additional Test Sample\n    // Uncomment the following line to print a success message\n    // std::printf(\"All tests passed!\\n\");\n    return 0;\n}", "entry_point": "f_9", "signature": "int f_9(int count, ...)", "docstring": {"en": "Count the number of odd integers in a given list of numbers.\nParameters:\n- count (int): The number of integers to evaluate.\n- ... (int): A sequence of integers.\nReturns:\n  int: The count of odd numbers in the input list.\nUsage:\n  f_9(5, 1, 4, 3, 2, 5) should return 3", "sq": "Numëroni numrin e numrave tek në një listë të dhënë numrash.  \nParametrat:  \n- count (int): Numri i numrave për të vlerësuar.  \n- ... (int): Një sekuencë numrash të plotë.  \nKthen:  \n  int: Numri i numrave tek në listën e dhënë.  \nPërdorimi:  \n  f_9(5, 1, 4, 3, 2, 5) duhet të kthejë 3  ", "hy": "Հաշվել տրված թվերի ցուցակում կենտ ամբողջ թվերի քանակը։\nՊարամետրեր՝\n- count (int): Ամբողջ թվերի քանակը գնահատելու համար։\n- ... (int): Ամբողջ թվերի հաջորդականություն։\nՎերադարձնում է՝\n  int: Կենտ թվերի քանակը մուտքագրված ցուցակում։\nՕգտագործում՝\n  f_9(5, 1, 4, 3, 2, 5) պետք է վերադարձնի 3", "bn": "দেওয়া সংখ্যার তালিকায় বিজোড় পূর্ণসংখ্যার সংখ্যা গণনা করুন।\nপ্যারামিটারসমূহ:\n- count (int): মূল্যায়ন করার পূর্ণসংখ্যার সংখ্যা।\n- ... (int): পূর্ণসংখ্যার একটি ক্রম।\nফেরত দেয়:\n  int: ইনপুট তালিকায় বিজোড় সংখ্যার সংখ্যা।\nব্যবহার:\n  f_9(5, 1, 4, 3, 2, 5) 3 ফেরত দেবে।", "bg": "Бройте броя на нечетните цели числа в даден списък от числа.\nПараметри:\n- count (int): Броят на целите числа за оценка.\n- ... (int): Последователност от цели числа.\nВръща:\n  int: Броят на нечетните числа в входния списък.\nИзползване:\n  f_9(5, 1, 4, 3, 2, 5) трябва да върне 3", "zh": "计算给定数字列表中奇数的数量。\n参数：\n- count (int): 要评估的整数数量。\n- ... (int): 一系列整数。\n返回：\n  int: 输入列表中奇数的数量。\n用法：\n  f_9(5, 1, 4, 3, 2, 5) 应返回 3", "fr": "Compter le nombre d'entiers impairs dans une liste donnée de nombres.\nParamètres:\n- count (int): Le nombre d'entiers à évaluer.\n- ... (int): Une séquence d'entiers.\nRenvoie:\n  int: Le nombre d'entiers impairs dans la liste d'entrée.\nUtilisation:\n  f_9(5, 1, 4, 3, 2, 5) devrait renvoyer 3", "de": "Zähle die Anzahl der ungeraden Ganzzahlen in einer gegebenen Liste von Zahlen.\nParameter:\n- count (int): Die Anzahl der zu bewertenden Ganzzahlen.\n- ... (int): Eine Sequenz von Ganzzahlen.\nRückgabe:\n  int: Die Anzahl der ungeraden Zahlen in der Eingabeliste.\nVerwendung:\n  f_9(5, 1, 4, 3, 2, 5) sollte 3 zurückgeben.", "ha": "Ƙirga adadin lambobin da ba su da ma'aurata a cikin jerin lambobi da aka bayar.\nParameters:  \n- count (int): Yawan lambobin da za a tantance.  \n- ... (int): Jerin lambobi.  \nReturns:  \n  int: Yawan lambobin da ba su da ma'ana a cikin jerin shigarwa.  \nUsage:  \n  f_9(5, 1, 4, 3, 2, 5) ya kamata ya dawo da 3", "hi": "दिए गए संख्याओं की सूची में विषम पूर्णांकों की संख्या गिनें।  \nपैरामीटर्स:  \n- count (int): मूल्यांकन करने के लिए पूर्णांकों की संख्या।  \n- ... (int): पूर्णांकों का अनुक्रम।  \nरिटर्न्स:  \n  int: इनपुट सूची में विषम संख्याओं की गिनती।  \nउपयोग:  \n  f_9(5, 1, 4, 3, 2, 5) को 3 लौटाना चाहिए।", "hu": "Számolja meg a páratlan egész számok számát egy adott számok listájában.\nParaméterek:\n- count (int): Az értékelendő egész számok száma.\n- ... (int): Egy egész számok sorozata.\nVisszatér:\n  int: A páratlan számok száma a bemeneti listában.\nHasználat:\n  f_9(5, 1, 4, 3, 2, 5) esetén az eredmény 3 kell legyen.", "es": "Cuenta el número de enteros impares en una lista dada de números.\nParámetros:\n- count (int): El número de enteros a evaluar.\n- ... (int): Una secuencia de enteros.\nDevuelve:\n  int: La cuenta de números impares en la lista de entrada.\nUso:\n  f_9(5, 1, 4, 3, 2, 5) debería devolver 3", "arb": "احسب عدد الأعداد الفردية في قائمة معينة من الأرقام.\nالمعلمات:\n- count (int): عدد الأعداد لتقييمها.\n- ... (int): سلسلة من الأعداد الصحيحة.\nالقيم المعادة:\n  int: عدد الأعداد الفردية في قائمة الإدخال.\nالاستخدام:\n  f_9(5, 1, 4, 3, 2, 5) يجب أن تعيد 3", "sw": "Hesabu idadi ya nambari zisizo za jozi katika orodha iliyotolewa ya nambari.\n\nVigezo:\n- count (int): Idadi ya nambari za kutathmini.\n- ... (int): Mfululizo wa nambari.\n\nInarejesha:\n  int: Idadi ya nambari zisizo za jozi katika orodha ya pembejeo.\n\nMatumizi:\n  f_9(5, 1, 4, 3, 2, 5) inapaswa kurejesha 3", "tr": "Verilen bir sayı listesindeki tek sayıların sayısını hesaplayın.\nParametreler:\n- count (int): Değerlendirilecek tamsayıların sayısı.\n- ... (int): Bir dizi tamsayı.\nDöndürülen:\n  int: Girdi listesindeki tek sayıların sayısı.\nKullanım:\n  f_9(5, 1, 4, 3, 2, 5) 3 döndürmelidir.", "vi": "Đếm số lượng số nguyên lẻ trong một danh sách số đã cho.  \nTham số:  \n- count (int): Số lượng số nguyên cần đánh giá.  \n- ... (int): Một dãy số nguyên.  \nTrả về:  \n  int: Số lượng số lẻ trong danh sách đầu vào.  \nSử dụng:  \n  f_9(5, 1, 4, 3, 2, 5) sẽ trả về 3  ", "id": "Hitung jumlah bilangan bulat ganjil dalam daftar angka yang diberikan.\nParameter:\n- count (int): Jumlah bilangan bulat yang akan dievaluasi.\n- ... (int): Urutan bilangan bulat.\nMengembalikan:\n  int: Jumlah bilangan ganjil dalam daftar input.\nPenggunaan:\n  f_9(5, 1, 4, 3, 2, 5) seharusnya mengembalikan 3", "ja": "与えられた数値のリスト内の奇数の整数の数を数えます。\n引数:\n- count (int): 評価する整数の数。\n- ... (int): 整数のシーケンス。\n戻り値:\n  int: 入力リスト内の奇数の数。\n使用例:\n  f_9(5, 1, 4, 3, 2, 5) は 3 を返すべきです。", "ko": "주어진 숫자 목록에서 홀수 정수의 개수를 셉니다.\n매개변수:\n- count (int): 평가할 정수의 개수.\n- ... (int): 정수의 시퀀스.\n반환:\n  int: 입력 목록에서 홀수의 개수.\n사용 예:\n  f_9(5, 1, 4, 3, 2, 5)는 3을 반환해야 합니다.", "ml": "ഒരുപ്രദത്തായ ലിസ്റ്റിലെ বিজോദ സംഖ്യകളുടെ എണ്ണം എണ്ണുക.\nപാരാമീറ്ററുകൾ:\n- count (int): വിലയിരുത്തേണ്ട സംഖ്യകളുടെ എണ്ണം.\n- ... (int): ഒരു സംഖ്യകളുടെ ശ്രേണി.\nമടക്കം:\n  int: ഇൻപുട്ട് ലിസ്റ്റിലെ ബിസോദ സംഖ്യകളുടെ എണ്ണം.\nഉപയോഗം:\n  f_9(5, 1, 4, 3, 2, 5) 3 മടക്കണം", "fa": "تعداد اعداد فرد را در یک لیست داده شده از اعداد بشمارید.\nپارامترها:\n- count (int): تعداد اعدادی که باید ارزیابی شوند.\n- ... (int): یک دنباله از اعداد صحیح.\nبازگشت:\n  int: تعداد اعداد فرد در لیست ورودی.\nاستفاده:\n  f_9(5, 1, 4, 3, 2, 5) باید 3 را برگرداند."}}
{"task_id": "CPP/10", "prompt": {"en": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Calculate the sum of even numbers in a given array.\n * \n * Parameters:\n * - numbers (vector<int>): A vector of integers.\n * - size (int): The size of the array.\n * \n * Returns:\n * int: The sum of even numbers in the input array.\n * \n * Examples:\n * >>> f_10({1,4,3,2,5}, 5)\n * 6\n */\nint f_10(const std::vector<int>& numbers)", "sq": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Llogarit shumën e numrave çift në një varg të dhënë.\n * \n * Parametrat:\n * - numbers (vector<int>): Një vektor i numrave të plotë.\n * - size (int): Madhësia e vargut.\n * \n * Kthen:\n * int: Shuma e numrave çift në vargun hyrës.\n * \n * Shembuj:\n * >>> f_10({1,4,3,2,5}, 5)\n * 6\n */\nint f_10(const std::vector<int>& numbers)", "hy": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Հաշվել տրված զանգվածի զույգ թվերի գումարը։\n * \n * Պարամետրեր:\n * - numbers (vector<int>): Թվերի վեկտոր։\n * - size (int): Զանգվածի չափը։\n * \n * Վերադարձնում է:\n * int: Մուտքային զանգվածի զույգ թվերի գումարը։\n * \n * Օրինակներ:\n * >>> f_10({1,4,3,2,5}, 5)\n * 6\n */\nint f_10(const std::vector<int>& numbers)", "bn": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * প্রদত্ত অ্যারেতে জোড় সংখ্যাগুলির যোগফল গণনা করুন।\n * \n * প্যারামিটার:\n * - numbers (vector<int>): পূর্ণসংখ্যার একটি ভেক্টর।\n * - size (int): অ্যারের আকার।\n * \n * রিটার্নস:\n * int: ইনপুট অ্যারেতে জোড় সংখ্যাগুলির যোগফল।\n * \n * উদাহরণ:\n * >>> f_10({1,4,3,2,5}, 5)\n * 6\n */\nint f_10(const std::vector<int>& numbers)", "bg": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Изчислява сумата на четните числа в даден масив.\n * \n * Параметри:\n * - numbers (vector<int>): Вектор от цели числа.\n * - size (int): Размерът на масива.\n * \n * Връща:\n * int: Сумата на четните числа в входния масив.\n * \n * Примери:\n * >>> f_10({1,4,3,2,5}, 5)\n * 6\n */\nint f_10(const std::vector<int>& numbers)", "zh": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * 计算给定数组中偶数的和。\n * \n * 参数:\n * - numbers (vector<int>): 整数向量。\n * - size (int): 数组的大小。\n * \n * 返回:\n * int: 输入数组中偶数的和。\n * \n * 示例:\n * >>> f_10({1,4,3,2,5}, 5)\n * 6\n */\nint f_10(const std::vector<int>& numbers)", "fr": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Calculer la somme des nombres pairs dans un tableau donné.\n * \n * Paramètres :\n * - numbers (vector<int>): Un vecteur d'entiers.\n * - size (int): La taille du tableau.\n * \n * Renvoie :\n * int : La somme des nombres pairs dans le tableau d'entrée.\n * \n * Exemples :\n * >>> f_10({1,4,3,2,5}, 5)\n * 6\n */\nint f_10(const std::vector<int>& numbers)", "de": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Berechnet die Summe der geraden Zahlen in einem gegebenen Array.\n * \n * Parameter:\n * - numbers (vector<int>): Ein Vektor von ganzen Zahlen.\n * - size (int): Die Größe des Arrays.\n * \n * Rückgabewert:\n * int: Die Summe der geraden Zahlen im Eingabearray.\n * \n * Beispiele:\n * >>> f_10({1,4,3,2,5}, 5)\n * 6\n */\nint f_10(const std::vector<int>& numbers)", "ha": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Lissafa jimillar lambobin da suka zama lamba biyu a cikin jerin da aka bayar.\n * \n * Sigogi:\n * - numbers (vector<int>): Wani vector na lambobi.\n * - size (int): Girman jerin.\n * \n * Komawa:\n * int: Jimillar lambobin da suka zama lamba biyu a cikin jerin shigarwa.\n * \n * Misalai:\n * >>> f_10({1,4,3,2,5}, 5)\n * 6\n */\nint f_10(const std::vector<int>& numbers)", "hi": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * दिए गए array में सम संख्याओं का योग गणना करें।\n * \n * पैरामीटर्स:\n * - numbers (vector<int>): पूर्णांकों का एक वेक्टर।\n * - size (int): array का आकार।\n * \n * रिटर्न करता है:\n * int: इनपुट array में सम संख्याओं का योग।\n * \n * उदाहरण:\n * >>> f_10({1,4,3,2,5}, 5)\n * 6\n */\nint f_10(const std::vector<int>& numbers)", "hu": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Számolja ki a páros számok összegét egy adott tömbben.\n * \n * Paraméterek:\n * - numbers (vector<int>): Egész számokat tartalmazó vektor.\n * - size (int): A tömb mérete.\n * \n * Visszatérési érték:\n * int: A bemeneti tömbben lévő páros számok összege.\n * \n * Példák:\n * >>> f_10({1,4,3,2,5}, 5)\n * 6\n */\nint f_10(const std::vector<int>& numbers)", "es": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Calcular la suma de números pares en un arreglo dado.\n * \n * Parámetros:\n * - numbers (vector<int>): Un vector de enteros.\n * - size (int): El tamaño del arreglo.\n * \n * Devuelve:\n * int: La suma de los números pares en el arreglo de entrada.\n * \n * Ejemplos:\n * >>> f_10({1,4,3,2,5}, 5)\n * 6\n */\nint f_10(const std::vector<int>& numbers)", "arb": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * حساب مجموع الأعداد الزوجية في مصفوفة معينة.\n * \n * المعاملات:\n * - numbers (vector<int>): متجه من الأعداد الصحيحة.\n * - size (int): حجم المصفوفة.\n * \n * يعيد:\n * int: مجموع الأعداد الزوجية في المصفوفة المدخلة.\n * \n * أمثلة:\n * >>> f_10({1,4,3,2,5}, 5)\n * 6\n */\nint f_10(const std::vector<int>& numbers)", "sw": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Hesabu jumla ya namba shufwa katika safu iliyotolewa.\n * \n * Vigezo:\n * - numbers (vector<int>): Vekta ya namba nzima.\n * - size (int): Ukubwa wa safu.\n * \n * Inarudisha:\n * int: Jumla ya namba shufwa katika safu ya ingizo.\n * \n * Mifano:\n * >>> f_10({1,4,3,2,5}, 5)\n * 6\n */\nint f_10(const std::vector<int>& numbers)", "tr": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Verilen bir dizideki çift sayıların toplamını hesapla.\n * \n * Parametreler:\n * - numbers (vector<int>): Bir tamsayılar vektörü.\n * - size (int): Dizinin boyutu.\n * \n * Döndürür:\n * int: Girdi dizisindeki çift sayıların toplamı.\n * \n * Örnekler:\n * >>> f_10({1,4,3,2,5}, 5)\n * 6\n */\nint f_10(const std::vector<int>& numbers)", "vi": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Tính tổng các số chẵn trong một mảng cho trước.\n * \n * Tham số:\n * - numbers (vector<int>): Một vector các số nguyên.\n * - size (int): Kích thước của mảng.\n * \n * Trả về:\n * int: Tổng các số chẵn trong mảng đầu vào.\n * \n * Ví dụ:\n * >>> f_10({1,4,3,2,5}, 5)\n * 6\n */\nint f_10(const std::vector<int>& numbers)", "id": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Hitung jumlah bilangan genap dalam array yang diberikan.\n * \n * Parameter:\n * - numbers (vector<int>): Sebuah vektor bilangan bulat.\n * - size (int): Ukuran array.\n * \n * Mengembalikan:\n * int: Jumlah bilangan genap dalam array masukan.\n * \n * Contoh:\n * >>> f_10({1,4,3,2,5}, 5)\n * 6\n */\nint f_10(const std::vector<int>& numbers)", "ja": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * 与えられた配列の偶数の合計を計算します。\n * \n * パラメータ:\n * - numbers (vector<int>): 整数のベクター。\n * - size (int): 配列のサイズ。\n * \n * 戻り値:\n * int: 入力配列の偶数の合計。\n * \n * 例:\n * >>> f_10({1,4,3,2,5}, 5)\n * 6\n */\nint f_10(const std::vector<int>& numbers)", "ko": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * 주어진 배열에서 짝수의 합을 계산합니다.\n * \n * 매개변수:\n * - numbers (vector<int>): 정수의 벡터.\n * - size (int): 배열의 크기.\n * \n * 반환값:\n * int: 입력 배열에서 짝수의 합.\n * \n * 예시:\n * >>> f_10({1,4,3,2,5}, 5)\n * 6\n */\nint f_10(const std::vector<int>& numbers)", "ml": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * നൽകിയ ഒരു അറേയിലുള്ള സജാത സംഖ്യകളുടെ മൊത്തം കണക്കാക്കുക.\n * \n * പാരാമീറ്ററുകൾ:\n * - numbers (vector<int>): ഒരു പദങ്ങളുടെ വെക്റ്റർ.\n * - size (int): അറേയുടെ വലിപ്പം.\n * \n * മടക്കുന്നു:\n * int: ഇൻപുട്ട് അറേയിലുള്ള സജാത സംഖ്യകളുടെ മൊത്തം.\n * \n * ഉദാഹരണങ്ങൾ:\n * >>> f_10({1,4,3,2,5}, 5)\n * 6\n */\nint f_10(const std::vector<int>& numbers)", "fa": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * محاسبه مجموع اعداد زوج در یک آرایه داده شده.\n * \n * پارامترها:\n * - numbers (vector<int>): یک وکتور از اعداد صحیح.\n * - size (int): اندازه آرایه.\n * \n * بازگشت:\n * int: مجموع اعداد زوج در آرایه ورودی.\n * \n * مثال‌ها:\n * >>> f_10({1,4,3,2,5}, 5)\n * 6\n */\nint f_10(const std::vector<int>& numbers)"}, "canonical_solution": "{\n    int ans = 0;\n    for (auto num : numbers) {\n        if ((num & 1) == 0) { // Only sum the even numbers\n            ans += num;\n        }\n    }\n    return ans;\n}", "instruction": {"en": "Write a CPP function `int f_10(const std::vector<int>& numbers)` to solve the following problem:\nCalculate the sum of even numbers in a given array.\n\nParameters:\n- numbers (vector<int>): A vector of integers.\n\nReturns:\nint: The sum of even numbers in the input array.\n\nExamples:\n>>> f_10({1,4,3,2,5}, 5)\n6\n", "sq": "Shkruani një funksion CPP `int f_10(const std::vector<int>& numbers)` për të zgjidhur problemin e mëposhtëm:  \nLlogaritni shumën e numrave çift në një varg të dhënë.\n\nParametrat:  \n- numbers (vector<int>): Një vektor i numrave të plotë.\n\nKthen:  \nint: Shuma e numrave çift në vargun e dhënë.\n\nShembuj:  \n>>> f_10({1,4,3,2,5}, 5)  \n6  ", "hy": "Գրեք CPP ֆունկցիա `int f_10(const std::vector<int>& numbers)` հետևյալ խնդիրը լուծելու համար:\nՀաշվել տրված զանգվածում զույգ թվերի գումարը:\n\nՊարամետրեր:\n- numbers (vector<int>): Թվերի վեկտոր:\n\nՎերադարձնում է:\nint: Մուտքային զանգվածի զույգ թվերի գումարը:\n\nՕրինակներ:\n>>> f_10({1,4,3,2,5}, 5)\n6", "bn": "একটি CPP ফাংশন `int f_10(const std::vector<int>& numbers)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি প্রদত্ত অ্যারের জোড় সংখ্যাগুলির যোগফল গণনা করুন।\n\nপ্যারামিটারসমূহ:\n- numbers (vector<int>): পূর্ণসংখ্যার একটি ভেক্টর।\n\nরিটার্নস:\nint: ইনপুট অ্যারের জোড় সংখ্যাগুলির যোগফল।\n\nউদাহরণসমূহ:\n>>> f_10({1,4,3,2,5}, 5)\n6", "bg": "Напишете CPP функция `int f_10(const std::vector<int>& numbers)`, за да решите следния проблем:\nИзчислете сумата на четните числа в даден масив.\n\nПараметри:\n- numbers (vector<int>): Вектор от цели числа.\n\nВръща:\nint: Сумата на четните числа в входния масив.\n\nПримери:\n>>> f_10({1,4,3,2,5}, 5)\n6", "zh": "编写一个 CPP 函数 `int f_10(const std::vector<int>& numbers)` 来解决以下问题：\n计算给定数组中偶数的和。\n\n参数：\n- numbers (vector<int>): 整数向量。\n\n返回：\nint: 输入数组中偶数的和。\n\n示例：\n>>> f_10({1,4,3,2,5}, 5)\n6", "fr": "Écrire une fonction CPP `int f_10(const std::vector<int>& numbers)` pour résoudre le problème suivant :  \nCalculer la somme des nombres pairs dans un tableau donné.\n\nParamètres :  \n- numbers (vector<int>) : Un vecteur d'entiers.\n\nRenvoie :  \nint : La somme des nombres pairs dans le tableau d'entrée.\n\nExemples :  \n>>> f_10({1,4,3,2,5}, 5)  \n6  ", "de": "Schreiben Sie eine CPP-Funktion `int f_10(const std::vector<int>& numbers)`, um das folgende Problem zu lösen:\nBerechnen Sie die Summe der geraden Zahlen in einem gegebenen Array.\n\nParameter:\n- numbers (vector<int>): Ein Vektor von ganzen Zahlen.\n\nRückgabewert:\nint: Die Summe der geraden Zahlen im Eingabearray.\n\nBeispiele:\n>>> f_10({1,4,3,2,5}, 5)\n6", "ha": "Rubuta aikin CPP `int f_10(const std::vector<int>& numbers)` don warware matsalar mai zuwa:  \nƘididdige jumlar lambobin da suka yi maiko a cikin jerin lambobi da aka bayar.\n\nSigogi:\n- numbers (vector<int>): Wani vector na lambobi.\n\nDawowa:\nint: Jumlar lambobin da suka yi maiko a cikin jerin lambobi da aka shigar.\n\nMisalai:\n>>> f_10({1,4,3,2,5}, 5)\n6", "hi": "एक CPP फ़ंक्शन `int f_10(const std::vector<int>& numbers)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए array में सम संख्याओं का योग गणना करें।\n\nParameters:\n- numbers (vector<int>): पूर्णांकों का एक vector।\n\nReturns:\nint: इनपुट array में सम संख्याओं का योग।\n\nExamples:\n>>> f_10({1,4,3,2,5}, 5)\n6", "hu": "Írj egy CPP függvényt `int f_10(const std::vector<int>& numbers)` a következő probléma megoldására:\nSzámítsd ki a páros számok összegét egy adott tömbben.\n\nParaméterek:\n- numbers (vector<int>): Egész számokat tartalmazó vektor.\n\nVisszatérési érték:\nint: A bemeneti tömbben található páros számok összege.\n\nPéldák:\n>>> f_10({1,4,3,2,5}, 5)\n6", "es": "Escribe una función CPP `int f_10(const std::vector<int>& numbers)` para resolver el siguiente problema:\nCalcular la suma de los números pares en un arreglo dado.\n\nParámetros:\n- numbers (vector<int>): Un vector de enteros.\n\nDevuelve:\nint: La suma de los números pares en el arreglo de entrada.\n\nEjemplos:\n>>> f_10({1,4,3,2,5}, 5)\n6", "arb": "اكتب دالة CPP `int f_10(const std::vector<int>& numbers)` لحل المشكلة التالية:\nاحسب مجموع الأرقام الزوجية في مصفوفة معينة.\n\nالمعطيات:\n- numbers (vector<int>): متجه من الأعداد الصحيحة.\n\nالقيم المعادة:\nint: مجموع الأرقام الزوجية في المصفوفة المدخلة.\n\nأمثلة:\n>>> f_10({1,4,3,2,5}, 5)\n6", "sw": "Andika kazi ya CPP `int f_10(const std::vector<int>& numbers)` kutatua tatizo lifuatalo:\nHesabu jumla ya namba shufwa katika safu iliyotolewa.\n\nVigezo:\n- numbers (vector<int>): Vekta ya namba nzima.\n\nInarejesha:\nint: Jumla ya namba shufwa katika safu ya pembejeo.\n\nMifano:\n>>> f_10({1,4,3,2,5}, 5)\n6", "tr": "Bir CPP fonksiyonu `int f_10(const std::vector<int>& numbers)` yazın:\nVerilen bir dizideki çift sayıların toplamını hesaplayın.\n\nParametreler:\n- numbers (vector<int>): Bir tamsayı vektörü.\n\nDöndürür:\nint: Girdi dizisindeki çift sayıların toplamı.\n\nÖrnekler:\n>>> f_10({1,4,3,2,5}, 5)\n6", "vi": "Viết một hàm CPP `int f_10(const std::vector<int>& numbers)` để giải quyết vấn đề sau:  \nTính tổng các số chẵn trong một mảng cho trước.\n\nTham số:  \n- numbers (vector<int>): Một vector các số nguyên.\n\nTrả về:  \nint: Tổng các số chẵn trong mảng đầu vào.\n\nVí dụ:  \n>>> f_10({1,4,3,2,5}, 5)  \n6  ", "id": "Tulis sebuah fungsi CPP `int f_10(const std::vector<int>& numbers)` untuk menyelesaikan masalah berikut:\nHitung jumlah bilangan genap dalam sebuah array yang diberikan.\n\nParameter:\n- numbers (vector<int>): Sebuah vektor bilangan bulat.\n\nMengembalikan:\nint: Jumlah bilangan genap dalam array masukan.\n\nContoh:\n>>> f_10({1,4,3,2,5}, 5)\n6", "ja": "以下の問題を解決するために、CPP関数 `int f_10(const std::vector<int>& numbers)` を作成してください:\n与えられた配列内の偶数の合計を計算します。\n\nパラメータ:\n- numbers (vector<int>): 整数のベクター。\n\n戻り値:\nint: 入力配列内の偶数の合計。\n\n例:\n>>> f_10({1,4,3,2,5}, 5)\n6", "ko": "다음 문제를 해결하기 위해 CPP 함수를 작성하십시오: `int f_10(const std::vector<int>& numbers)`\n\n주어진 배열에서 짝수의 합을 계산합니다.\n\n매개변수:\n- numbers (vector<int>): 정수 벡터.\n\n반환값:\nint: 입력 배열에서 짝수의 합.\n\n예시:\n>>> f_10({1,4,3,2,5}, 5)\n6", "ml": "`int f_10(const std::vector<int>& numbers)` എന്ന CPP ഫംഗ്ഷൻ എഴുതുക താഴെക്കാണുന്ന പ്രശ്നം പരിഹരിക്കാൻ:  \nഒരു നൽകിയിരിക്കുന്ന അറേയിലുളള സമവായ സംഖ്യകളുടെ മൊത്തം കണക്കാക്കുക.\n\nപാരാമീറ്ററുകൾ:  \n- numbers (vector<int>): ഒരു പദങ്ങളുടെ വെക്ടർ.\n\nമടക്കിക്കൊടുക്കുന്നു:  \nint: ഇൻപുട്ട് അറേയിലുള്ള സമവായ സംഖ്യകളുടെ മൊത്തം.\n\nഉദാഹരണങ്ങൾ:  \n>>> f_10({1,4,3,2,5}, 5)  \n6  ", "fa": "یک تابع CPP بنویسید `int f_10(const std::vector<int>& numbers)` برای حل مسئله زیر:\nمجموع اعداد زوج در یک آرایه داده شده را محاسبه کنید.\n\nپارامترها:\n- numbers (vector<int>): یک وکتور از اعداد صحیح.\n\nبازگشت:\nint: مجموع اعداد زوج در آرایه ورودی.\n\nمثال‌ها:\n>>> f_10({1,4,3,2,5}, 5)\n6"}, "level": "easy", "test": "int main() {\n    std::vector<int> sample1 = {1, 4, 3, 2, 5};\n    std::vector<int> sample2 = {2, 2, 0, 0};\n    std::vector<int> sample3 = {7, 11, 19}; // Additional test with no even numbers\n    std::vector<int> sample4 = {12, 14, 16, 18, 20}; // Additional test with all even numbers\n\n    assert(f_10(sample1) == 6);\n    assert(f_10(sample2) == 4);\n    assert(f_10(sample3) == 0); // Should return 0 because there are no even numbers\n    assert(f_10(sample4) == 12 + 14 + 16 + 18 + 20);\n\n    // std::cout << \"All tests passed successfully.\\n\";\n\n    return 0;\n}", "entry_point": "f_10", "signature": "int f_10(const std::vector<int>& numbers)", "docstring": {"en": "Calculate the sum of even numbers in a given array.\n\nParameters:\n- numbers (vector<int>): A vector of integers.\n\nReturns:\nint: The sum of even numbers in the input array.\n\nExamples:\n>>> f_10({1,4,3,2,5}, 5)\n6\n", "sq": "Llogarit shumën e numrave çift në një varg të dhënë.\n\nParametrat:\n- numbers (vector<int>): Një vektor i numrave të plotë.\n\nKthen:\nint: Shuma e numrave çift në vargun hyrës.\n\nShembuj:\n>>> f_10({1,4,3,2,5}, 5)\n6", "hy": "Հաշվել տրված զանգվածում զույգ թվերի գումարը։\n\nՊարամետրեր:\n- numbers (vector<int>): Ամբողջ թվերի վեկտոր։\n\nՎերադարձնում է:\nint: Մուտքագրված զանգվածի զույգ թվերի գումարը։\n\nՕրինակներ:\n>>> f_10({1,4,3,2,5}, 5)\n6", "bn": "দেওয়া অ্যারেতে জোড় সংখ্যাগুলোর যোগফল গণনা করুন।\n\nপ্যারামিটারসমূহ:\n- numbers (vector<int>): পূর্ণসংখ্যার একটি ভেক্টর।\n\nফেরত দেয়:\nint: ইনপুট অ্যারেতে জোড় সংখ্যাগুলোর যোগফল।\n\nউদাহরণ:\n>>> f_10({1,4,3,2,5}, 5)\n6", "bg": "Изчисляване на сумата от четни числа в даден масив.\n\nПараметри:\n- numbers (vector<int>): Вектор от цели числа.\n\nВръща:\nint: Сумата от четните числа в входния масив.\n\nПримери:\n>>> f_10({1,4,3,2,5}, 5)\n6", "zh": "计算给定数组中偶数的和。\n\n参数：\n- numbers (vector<int>): 一个整数向量。\n\n返回：\nint: 输入数组中偶数的和。\n\n示例：\n>>> f_10({1,4,3,2,5}, 5)\n6", "fr": "Calculer la somme des nombres pairs dans un tableau donné.\n\nParamètres:\n- numbers (vector<int>): Un vecteur d'entiers.\n\nRenvoie:\nint: La somme des nombres pairs dans le tableau d'entrée.\n\nExemples:\n>>> f_10({1,4,3,2,5}, 5)\n6", "de": "Berechnen Sie die Summe der geraden Zahlen in einem gegebenen Array.\n\nParameter:\n- numbers (vector<int>): Ein Vektor von ganzen Zahlen.\n\nRückgabewert:\nint: Die Summe der geraden Zahlen im Eingabearray.\n\nBeispiele:\n>>> f_10({1,4,3,2,5}, 5)\n6", "ha": "Lissafa jimillar lambobin da suka zama lamba biyu a cikin jerin da aka bayar.\n\nMa'auni:\n- numbers (vector<int>): Wata vector na lambobi.\n\nDawowa:\nint: Jimillar lambobin da suka kasance ma'aurata a cikin jerin lambobin shigarwa.\n\nMisalai:\n>>> f_10({1,4,3,2,5}, 5)\n6", "hi": "दिए गए ऐरे में सम संख्या का योग गणना करें।\n\nपैरामीटर्स:\n- numbers (vector<int>): पूर्णांकों का एक वेक्टर।\n\nरिटर्न्स:\nint: इनपुट ऐरे में सम संख्याओं का योग।\n\nउदाहरण:\n>>> f_10({1,4,3,2,5}, 5)\n6", "hu": "Számítsa ki a páros számok összegét egy adott tömbben.\n\nParaméterek:\n- numbers (vector<int>): Egész számok vektora.\n\nVisszatérési érték:\nint: A bemeneti tömbben lévő páros számok összege.\n\nPéldák:\n>>> f_10({1,4,3,2,5}, 5)\n6", "es": "Calcular la suma de números pares en un arreglo dado.\n\nParámetros:\n- numbers (vector<int>): Un vector de enteros.\n\nDevuelve:\nint: La suma de los números pares en el arreglo de entrada.\n\nEjemplos:\n>>> f_10({1,4,3,2,5}, 5)\n6", "arb": "حساب مجموع الأعداد الزوجية في مصفوفة معينة.\n\nالمعلمات:\n- numbers (vector<int>): متجه من الأعداد الصحيحة.\n\nالقيم المعادة:\nint: مجموع الأعداد الزوجية في المصفوفة المدخلة.\n\nأمثلة:\n>>> f_10({1,4,3,2,5}, 5)\n6", "sw": "Hesabu jumla ya namba shufwa katika safu iliyotolewa.\n\nVigezo:\n- numbers (vector<int>): Kipeo cha namba nzima.\n\nInarejesha:\nint: Jumla ya namba shufwa katika safu iliyoingizwa.\n\nMifano:\n>>> f_10({1,4,3,2,5}, 5)\n6", "tr": "Verilen bir dizideki çift sayıların toplamını hesaplayın.\n\nParametreler:\n- numbers (vector<int>): Bir tamsayı vektörü.\n\nDöndürür:\nint: Girdi dizisindeki çift sayıların toplamı.\n\nÖrnekler:\n>>> f_10({1,4,3,2,5}, 5)\n6", "vi": "Tính tổng các số chẵn trong một mảng cho trước.\n\nTham số:\n- numbers (vector<int>): Một vector chứa các số nguyên.\n\nTrả về:\nint: Tổng các số chẵn trong mảng đầu vào.\n\nVí dụ:\n>>> f_10({1,4,3,2,5}, 5)\n6", "id": "Hitung jumlah bilangan genap dalam array yang diberikan.\n\nParameter:\n- numbers (vector<int>): Sebuah vektor dari bilangan bulat.\n\nMengembalikan:\nint: Jumlah bilangan genap dalam array masukan.\n\nContoh:\n>>> f_10({1,4,3,2,5}, 5)\n6", "ja": "偶数の合計を計算します。\n\n引数:\n- numbers (vector<int>): 整数のベクター。\n\n戻り値:\nint: 入力配列内の偶数の合計。\n\n例:\n>>> f_10({1,4,3,2,5}, 5)\n6", "ko": "주어진 배열에서 짝수의 합을 계산합니다.\n\n매개변수:\n- numbers (vector<int>): 정수 벡터.\n\n반환값:\nint: 입력 배열에서 짝수의 합.\n\n예제:\n>>> f_10({1,4,3,2,5}, 5)\n6", "ml": "ദിയ്ക്കപ്പെട്ട അറേയിൽ സമവായ സംഖ്യകളുടെ മൊത്തം കൂട്ടം കണക്കാക്കുക.\n\nപാരാമീറ്ററുകൾ:\n- numbers (vector<int>): പൂർണ്ണസംഖ്യകളുടെ ഒരു വെക്റ്റർ.\n\nമടക്കുന്നു:\nint: ഇൻപുട്ട് അറേയിലെ സമവായ സംഖ്യകളുടെ മൊത്തം കൂട്ടം.\n\nഉദാഹരണങ്ങൾ:\n>>> f_10({1,4,3,2,5}, 5)\n6", "fa": "محاسبه مجموع اعداد زوج در یک آرایه داده شده.\n\nپارامترها:\n- numbers (vector<int>): یک بردار از اعداد صحیح.\n\nبازگشت:\nint: مجموع اعداد زوج در آرایه ورودی.\n\nمثال‌ها:\n>>> f_10({1,4,3,2,5}, 5)\n6"}}
{"task_id": "CPP/11", "prompt": {"en": "#include <cassert>\n#include <cstdio>\n/**\n * Determines if two closed intervals intersect.\n *\n * @param a The lower bound of the first closed interval [a,b].\n * @param b The upper bound of the first closed interval [a,b].\n * @param c The lower bound of the second closed interval [c,d].\n * @param d The upper bound of the second closed interval [c,d].\n *\n * @return 1 if the intervals intersect, 0 otherwise.\n *\n * Examples:\n * f_11(1, 1, 1, 2) returns 1\n * f_11(3, 5, 2, 6) returns 1\n * f_11(3, 5, 4, 7) returns 1\n * f_11(3, 5, 6, 7) returns 0\n */\nint f_11(int a, int b, int c, int d)", "sq": "#include <cassert>\n#include <cstdio>\n/**\n * Përcakton nëse dy intervale të mbyllura ndërpriten.\n *\n * @param a Kufiri i poshtëm i intervalit të parë të mbyllur [a,b].\n * @param b Kufiri i sipërm i intervalit të parë të mbyllur [a,b].\n * @param c Kufiri i poshtëm i intervalit të dytë të mbyllur [c,d].\n * @param d Kufiri i sipërm i intervalit të dytë të mbyllur [c,d].\n *\n * @return 1 nëse intervalet ndërpriten, 0 përndryshe.\n *\n * Shembuj:\n * f_11(1, 1, 1, 2) kthen 1\n * f_11(3, 5, 2, 6) kthen 1\n * f_11(3, 5, 4, 7) kthen 1\n * f_11(3, 5, 6, 7) kthen 0\n */\nint f_11(int a, int b, int c, int d)", "hy": "#include <cassert>\n#include <cstdio>\n/**\n * Սահմանում է՝ արդյոք երկու փակ միջակայքերը հատվում են։\n *\n * @param a Առաջին փակ միջակայքի ստորին սահմանը [a,b]։\n * @param b Առաջին փակ միջակայքի վերին սահմանը [a,b]։\n * @param c Երկրորդ փակ միջակայքի ստորին սահմանը [c,d]։\n * @param d Երկրորդ փակ միջակայքի վերին սահմանը [c,d]։\n *\n * @return 1 եթե միջակայքերը հատվում են, 0՝ հակառակ դեպքում։\n *\n * Օրինակներ:\n * f_11(1, 1, 1, 2) վերադարձնում է 1\n * f_11(3, 5, 2, 6) վերադարձնում է 1\n * f_11(3, 5, 4, 7) վերադարձնում է 1\n * f_11(3, 5, 6, 7) վերադարձնում է 0\n */\nint f_11(int a, int b, int c, int d)", "bn": "#include <cassert>\n#include <cstdio>\n/**\n * দুটি বন্ধ ইন্টারভাল পরস্পরকে অতিক্রম করে কিনা তা নির্ধারণ করে।\n *\n * @param a প্রথম বন্ধ ইন্টারভাল [a,b] এর নিম্ন সীমা।\n * @param b প্রথম বন্ধ ইন্টারভাল [a,b] এর উপরের সীমা।\n * @param c দ্বিতীয় বন্ধ ইন্টারভাল [c,d] এর নিম্ন সীমা।\n * @param d দ্বিতীয় বন্ধ ইন্টারভাল [c,d] এর উপরের সীমা।\n *\n * @return ইন্টারভালগুলি অতিক্রম করলে 1, অন্যথায় 0।\n *\n * উদাহরণ:\n * f_11(1, 1, 1, 2) 1 প্রদান করে\n * f_11(3, 5, 2, 6) 1 প্রদান করে\n * f_11(3, 5, 4, 7) 1 প্রদান করে\n * f_11(3, 5, 6, 7) 0 প্রদান করে\n */\nint f_11(int a, int b, int c, int d)", "bg": "#include <cassert>\n#include <cstdio>\n/**\n * Определя дали два затворени интервала се пресичат.\n *\n * @param a Долна граница на първия затворен интервал [a,b].\n * @param b Горна граница на първия затворен интервал [a,b].\n * @param c Долна граница на втория затворен интервал [c,d].\n * @param d Горна граница на втория затворен интервал [c,d].\n *\n * @return 1 ако интервалите се пресичат, 0 в противен случай.\n *\n * Примери:\n * f_11(1, 1, 1, 2) връща 1\n * f_11(3, 5, 2, 6) връща 1\n * f_11(3, 5, 4, 7) връща 1\n * f_11(3, 5, 6, 7) връща 0\n */\nint f_11(int a, int b, int c, int d)", "zh": "#include <cassert>\n#include <cstdio>\n/**\n * 确定两个闭区间是否相交。\n *\n * @param a 第一个闭区间 [a,b] 的下界。\n * @param b 第一个闭区间 [a,b] 的上界。\n * @param c 第二个闭区间 [c,d] 的下界。\n * @param d 第二个闭区间 [c,d] 的上界。\n *\n * @return 如果区间相交返回 1，否则返回 0。\n *\n * 示例:\n * f_11(1, 1, 1, 2) 返回 1\n * f_11(3, 5, 2, 6) 返回 1\n * f_11(3, 5, 4, 7) 返回 1\n * f_11(3, 5, 6, 7) 返回 0\n */\nint f_11(int a, int b, int c, int d)", "fr": "#include <cassert>\n#include <cstdio>\n/**\n * Détermine si deux intervalles fermés s'intersectent.\n *\n * @param a La borne inférieure du premier intervalle fermé [a,b].\n * @param b La borne supérieure du premier intervalle fermé [a,b].\n * @param c La borne inférieure du second intervalle fermé [c,d].\n * @param d La borne supérieure du second intervalle fermé [c,d].\n *\n * @return 1 si les intervalles s'intersectent, 0 sinon.\n *\n * Exemples :\n * f_11(1, 1, 1, 2) retourne 1\n * f_11(3, 5, 2, 6) retourne 1\n * f_11(3, 5, 4, 7) retourne 1\n * f_11(3, 5, 6, 7) retourne 0\n */\nint f_11(int a, int b, int c, int d)", "de": "#include <cassert>\n#include <cstdio>\n/**\n * Bestimmt, ob zwei geschlossene Intervalle sich überschneiden.\n *\n * @param a Die Untergrenze des ersten geschlossenen Intervalls [a,b].\n * @param b Die Obergrenze des ersten geschlossenen Intervalls [a,b].\n * @param c Die Untergrenze des zweiten geschlossenen Intervalls [c,d].\n * @param d Die Obergrenze des zweiten geschlossenen Intervalls [c,d].\n *\n * @return 1, wenn die Intervalle sich überschneiden, 0 andernfalls.\n *\n * Beispiele:\n * f_11(1, 1, 1, 2) gibt 1 zurück\n * f_11(3, 5, 2, 6) gibt 1 zurück\n * f_11(3, 5, 4, 7) gibt 1 zurück\n * f_11(3, 5, 6, 7) gibt 0 zurück\n */\nint f_11(int a, int b, int c, int d)", "ha": "#include <cassert>\n#include <cstdio>\n/**\n * Yana tantance idan tazara biyu masu rufe suna hade.\n *\n * @param a Iyakacin kasa na tazara na farko mai rufe [a,b].\n * @param b Iyakacin sama na tazara na farko mai rufe [a,b].\n * @param c Iyakacin kasa na tazara na biyu mai rufe [c,d].\n * @param d Iyakacin sama na tazara na biyu mai rufe [c,d].\n *\n * @return 1 idan tazaran suna hade, 0 in ba haka ba.\n *\n * Misalai:\n * f_11(1, 1, 1, 2) returns 1\n * f_11(3, 5, 2, 6) returns 1\n * f_11(3, 5, 4, 7) returns 1\n * f_11(3, 5, 6, 7) returns 0\n */\nint f_11(int a, int b, int c, int d)", "hi": "#include <cassert>\n#include <cstdio>\n/**\n * यह निर्धारित करता है कि दो बंद अंतराल एक-दूसरे से मिलते हैं या नहीं।\n *\n * @param a पहले बंद अंतराल [a,b] की निचली सीमा।\n * @param b पहले बंद अंतराल [a,b] की ऊपरी सीमा।\n * @param c दूसरे बंद अंतराल [c,d] की निचली सीमा।\n * @param d दूसरे बंद अंतराल [c,d] की ऊपरी सीमा।\n *\n * @return 1 यदि अंतराल मिलते हैं, अन्यथा 0।\n *\n * उदाहरण:\n * f_11(1, 1, 1, 2) returns 1\n * f_11(3, 5, 2, 6) returns 1\n * f_11(3, 5, 4, 7) returns 1\n * f_11(3, 5, 6, 7) returns 0\n */\nint f_11(int a, int b, int c, int d)", "hu": "#include <cassert>\n#include <cstdio>\n/**\n * Meghatározza, hogy két zárt intervallum metszi-e egymást.\n *\n * @param a Az első zárt intervallum alsó határa [a,b].\n * @param b Az első zárt intervallum felső határa [a,b].\n * @param c A második zárt intervallum alsó határa [c,d].\n * @param d A második zárt intervallum felső határa [c,d].\n *\n * @return 1, ha az intervallumok metszik egymást, különben 0.\n *\n * Példák:\n * f_11(1, 1, 1, 2) visszaadja 1\n * f_11(3, 5, 2, 6) visszaadja 1\n * f_11(3, 5, 4, 7) visszaadja 1\n * f_11(3, 5, 6, 7) visszaadja 0\n */\nint f_11(int a, int b, int c, int d)", "es": "#include <cassert>\n#include <cstdio>\n/**\n * Determina si dos intervalos cerrados se intersectan.\n *\n * @param a El límite inferior del primer intervalo cerrado [a,b].\n * @param b El límite superior del primer intervalo cerrado [a,b].\n * @param c El límite inferior del segundo intervalo cerrado [c,d].\n * @param d El límite superior del segundo intervalo cerrado [c,d].\n *\n * @return 1 si los intervalos se intersectan, 0 en caso contrario.\n *\n * Ejemplos:\n * f_11(1, 1, 1, 2) devuelve 1\n * f_11(3, 5, 2, 6) devuelve 1\n * f_11(3, 5, 4, 7) devuelve 1\n * f_11(3, 5, 6, 7) devuelve 0\n */\nint f_11(int a, int b, int c, int d)", "arb": "#include <cassert>\n#include <cstdio>\n/**\n * يحدد ما إذا كان هناك تقاطع بين فترتين مغلقتين.\n *\n * @param a الحد الأدنى للفترة المغلقة الأولى [a,b].\n * @param b الحد الأقصى للفترة المغلقة الأولى [a,b].\n * @param c الحد الأدنى للفترة المغلقة الثانية [c,d].\n * @param d الحد الأقصى للفترة المغلقة الثانية [c,d].\n *\n * @return 1 إذا كانت الفترات تتقاطع، 0 خلاف ذلك.\n *\n * أمثلة:\n * f_11(1, 1, 1, 2) يعيد 1\n * f_11(3, 5, 2, 6) يعيد 1\n * f_11(3, 5, 4, 7) يعيد 1\n * f_11(3, 5, 6, 7) يعيد 0\n */\nint f_11(int a, int b, int c, int d)", "sw": "#include <cassert>\n#include <cstdio>\n/**\n * Huamua ikiwa vipindi viwili vilivyofungwa vinaingiliana.\n *\n * @param a Kikomo cha chini cha kipindi cha kwanza kilichofungwa [a,b].\n * @param b Kikomo cha juu cha kipindi cha kwanza kilichofungwa [a,b].\n * @param c Kikomo cha chini cha kipindi cha pili kilichofungwa [c,d].\n * @param d Kikomo cha juu cha kipindi cha pili kilichofungwa [c,d].\n *\n * @return 1 ikiwa vipindi vinaingiliana, 0 vinginevyo.\n *\n * Mifano:\n * f_11(1, 1, 1, 2) inarejesha 1\n * f_11(3, 5, 2, 6) inarejesha 1\n * f_11(3, 5, 4, 7) inarejesha 1\n * f_11(3, 5, 6, 7) inarejesha 0\n */\nint f_11(int a, int b, int c, int d)", "tr": "#include <cassert>\n#include <cstdio>\n/**\n * İki kapalı aralığın kesişip kesişmediğini belirler.\n *\n * @param a İlk kapalı aralığın alt sınırı [a,b].\n * @param b İlk kapalı aralığın üst sınırı [a,b].\n * @param c İkinci kapalı aralığın alt sınırı [c,d].\n * @param d İkinci kapalı aralığın üst sınırı [c,d].\n *\n * @return Aralıklar kesişiyorsa 1, aksi takdirde 0.\n *\n * Örnekler:\n * f_11(1, 1, 1, 2) 1 döndürür\n * f_11(3, 5, 2, 6) 1 döndürür\n * f_11(3, 5, 4, 7) 1 döndürür\n * f_11(3, 5, 6, 7) 0 döndürür\n */\nint f_11(int a, int b, int c, int d)", "vi": "#include <cassert>\n#include <cstdio>\n/**\n * Xác định xem hai khoảng đóng có giao nhau hay không.\n *\n * @param a Giới hạn dưới của khoảng đóng thứ nhất [a,b].\n * @param b Giới hạn trên của khoảng đóng thứ nhất [a,b].\n * @param c Giới hạn dưới của khoảng đóng thứ hai [c,d].\n * @param d Giới hạn trên của khoảng đóng thứ hai [c,d].\n *\n * @return 1 nếu các khoảng giao nhau, 0 nếu không.\n *\n * Ví dụ:\n * f_11(1, 1, 1, 2) trả về 1\n * f_11(3, 5, 2, 6) trả về 1\n * f_11(3, 5, 4, 7) trả về 1\n * f_11(3, 5, 6, 7) trả về 0\n */\nint f_11(int a, int b, int c, int d)", "id": "#include <cassert>\n#include <cstdio>\n/**\n * Menentukan apakah dua interval tertutup saling berpotongan.\n *\n * @param a Batas bawah dari interval tertutup pertama [a,b].\n * @param b Batas atas dari interval tertutup pertama [a,b].\n * @param c Batas bawah dari interval tertutup kedua [c,d].\n * @param d Batas atas dari interval tertutup kedua [c,d].\n *\n * @return 1 jika interval saling berpotongan, 0 jika tidak.\n *\n * Contoh:\n * f_11(1, 1, 1, 2) mengembalikan 1\n * f_11(3, 5, 2, 6) mengembalikan 1\n * f_11(3, 5, 4, 7) mengembalikan 1\n * f_11(3, 5, 6, 7) mengembalikan 0\n */\nint f_11(int a, int b, int c, int d)", "ja": "#include <cassert>\n#include <cstdio>\n/**\n * 2つの閉区間が交差するかどうかを判断します。\n *\n * @param a 最初の閉区間 [a,b] の下限。\n * @param b 最初の閉区間 [a,b] の上限。\n * @param c 2番目の閉区間 [c,d] の下限。\n * @param d 2番目の閉区間 [c,d] の上限。\n *\n * @return 区間が交差する場合は1、そうでない場合は0を返します。\n *\n * 例:\n * f_11(1, 1, 1, 2) は1を返します\n * f_11(3, 5, 2, 6) は1を返します\n * f_11(3, 5, 4, 7) は1を返します\n * f_11(3, 5, 6, 7) は0を返します\n */\nint f_11(int a, int b, int c, int d)", "ko": "#include <cassert>\n#include <cstdio>\n/**\n * 두 닫힌 구간이 교차하는지 여부를 결정합니다.\n *\n * @param a 첫 번째 닫힌 구간 [a,b]의 하한.\n * @param b 첫 번째 닫힌 구간 [a,b]의 상한.\n * @param c 두 번째 닫힌 구간 [c,d]의 하한.\n * @param d 두 번째 닫힌 구간 [c,d]의 상한.\n *\n * @return 구간이 교차하면 1을 반환하고, 그렇지 않으면 0을 반환합니다.\n *\n * 예시:\n * f_11(1, 1, 1, 2) returns 1\n * f_11(3, 5, 2, 6) returns 1\n * f_11(3, 5, 4, 7) returns 1\n * f_11(3, 5, 6, 7) returns 0\n */\nint f_11(int a, int b, int c, int d)", "ml": "#include <cassert>\n#include <cstdio>\n/**\n * രണ്ട് അടച്ച ഇടവേളകൾ തമ്മിൽ മുട്ടുന്നുണ്ടോ എന്ന് നിർണ്ണയിക്കുന്നു.\n *\n * @param a ആദ്യ അടച്ച ഇടവേളയുടെ താഴത്തെ പരിധി [a,b].\n * @param b ആദ്യ അടച്ച ഇടവേളയുടെ മേലത്തെ പരിധി [a,b].\n * @param c രണ്ടാം അടച്ച ഇടവേളയുടെ താഴത്തെ പരിധി [c,d].\n * @param d രണ്ടാം അടച്ച ഇടവേളയുടെ മേലത്തെ പരിധി [c,d].\n *\n * @return ഇടവേളകൾ മുട്ടുന്നുണ്ടെങ്കിൽ 1, അല്ലെങ്കിൽ 0.\n *\n * ഉദാഹരണങ്ങൾ:\n * f_11(1, 1, 1, 2) 1 മടക്കുന്നു\n * f_11(3, 5, 2, 6) 1 മടക്കുന്നു\n * f_11(3, 5, 4, 7) 1 മടക്കുന്നു\n * f_11(3, 5, 6, 7) 0 മടക്കുന്നു\n */\nint f_11(int a, int b, int c, int d)", "fa": "#include <cassert>\n#include <cstdio>\n/**\n * تعیین می‌کند که آیا دو بازه بسته با هم تلاقی دارند یا خیر.\n *\n * @param a حد پایین اولین بازه بسته [a,b].\n * @param b حد بالای اولین بازه بسته [a,b].\n * @param c حد پایین دومین بازه بسته [c,d].\n * @param d حد بالای دومین بازه بسته [c,d].\n *\n * @return 1 اگر بازه‌ها تلاقی دارند، در غیر این صورت 0.\n *\n * مثال‌ها:\n * f_11(1, 1, 1, 2) returns 1\n * f_11(3, 5, 2, 6) returns 1\n * f_11(3, 5, 4, 7) returns 1\n * f_11(3, 5, 6, 7) returns 0\n */\nint f_11(int a, int b, int c, int d)"}, "canonical_solution": "{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}", "instruction": {"en": "Write a CPP function `int f_11(int a, int b, int c, int d)` to solve the following problem:\nDetermines if two closed intervals intersect.\n\n@param a The lower bound of the first closed interval [a,b].\n@param b The upper bound of the first closed interval [a,b].\n@param c The lower bound of the second closed interval [c,d].\n@param d The upper bound of the second closed interval [c,d].\n\n@return 1 if the intervals intersect, 0 otherwise.\n\nExamples:\nf_11(1, 1, 1, 2) returns 1\nf_11(3, 5, 2, 6) returns 1\nf_11(3, 5, 4, 7) returns 1\nf_11(3, 5, 6, 7) returns 0\n", "sq": "Shkruani një funksion CPP `int f_11(int a, int b, int c, int d)` për të zgjidhur problemin e mëposhtëm:  \nPërcakton nëse dy intervale të mbyllura ndërpriten.\n\n@param a Kufiri i poshtëm i intervalit të parë të mbyllur [a,b].  \n@param b Kufiri i sipërm i intervalit të parë të mbyllur [a,b].  \n@param c Kufiri i poshtëm i intervalit të dytë të mbyllur [c,d].  \n@param d Kufiri i sipërm i intervalit të dytë të mbyllur [c,d].\n\n@return 1 nëse intervalet ndërpriten, 0 përndryshe.\n\nShembuj:  \nf_11(1, 1, 1, 2) kthen 1  \nf_11(3, 5, 2, 6) kthen 1  \nf_11(3, 5, 4, 7) kthen 1  \nf_11(3, 5, 6, 7) kthen 0  ", "hy": "Գրեք CPP ֆունկցիա `int f_11(int a, int b, int c, int d)` հետևյալ խնդիրը լուծելու համար:\nՈրոշում է՝ արդյոք երկու փակ միջակայքերը հատվում են:\n\n@param a Առաջին փակ միջակայքի [a,b] ստորին սահմանը:\n@param b Առաջին փակ միջակայքի [a,b] վերին սահմանը:\n@param c Երկրորդ փակ միջակայքի [c,d] ստորին սահմանը:\n@param d Երկրորդ փակ միջակայքի [c,d] վերին սահմանը:\n\n@return 1 եթե միջակայքերը հատվում են, 0՝ հակառակ դեպքում:\n\nՕրինակներ:\nf_11(1, 1, 1, 2) վերադարձնում է 1\nf_11(3, 5, 2, 6) վերադարձնում է 1\nf_11(3, 5, 4, 7) վերադարձնում է 1\nf_11(3, 5, 6, 7) վերադարձնում է 0", "bn": "একটি CPP ফাংশন `int f_11(int a, int b, int c, int d)` লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\nদুটি বন্ধ অন্তরাল পরস্পর ছেদ করে কিনা তা নির্ধারণ করে।\n\n@param a প্রথম বন্ধ অন্তরাল [a,b] এর নিম্ন সীমা।\n@param b প্রথম বন্ধ অন্তরাল [a,b] এর ঊর্ধ্ব সীমা।\n@param c দ্বিতীয় বন্ধ অন্তরাল [c,d] এর নিম্ন সীমা।\n@param d দ্বিতীয় বন্ধ অন্তরাল [c,d] এর ঊর্ধ্ব সীমা।\n\n@return 1 যদি অন্তরালগুলি ছেদ করে, অন্যথায় 0।\n\nExamples:\nf_11(1, 1, 1, 2) returns 1\nf_11(3, 5, 2, 6) returns 1\nf_11(3, 5, 4, 7) returns 1\nf_11(3, 5, 6, 7) returns 0", "bg": "Напишете CPP функция `int f_11(int a, int b, int c, int d)`, за да решите следния проблем:\nОпределя дали два затворени интервала се пресичат.\n\n@param a Долна граница на първия затворен интервал [a,b].\n@param b Горна граница на първия затворен интервал [a,b].\n@param c Долна граница на втория затворен интервал [c,d].\n@param d Горна граница на втория затворен интервал [c,d].\n\n@return 1 ако интервалите се пресичат, 0 в противен случай.\n\nПримери:\nf_11(1, 1, 1, 2) връща 1\nf_11(3, 5, 2, 6) връща 1\nf_11(3, 5, 4, 7) връща 1\nf_11(3, 5, 6, 7) връща 0", "zh": "编写一个 CPP 函数 `int f_11(int a, int b, int c, int d)` 来解决以下问题：\n确定两个闭区间是否相交。\n\n@param a 第一个闭区间 [a,b] 的下界。\n@param b 第一个闭区间 [a,b] 的上界。\n@param c 第二个闭区间 [c,d] 的下界。\n@param d 第二个闭区间 [c,d] 的上界。\n\n@return 如果区间相交则返回 1，否则返回 0。\n\n示例：\nf_11(1, 1, 1, 2) 返回 1\nf_11(3, 5, 2, 6) 返回 1\nf_11(3, 5, 4, 7) 返回 1\nf_11(3, 5, 6, 7) 返回 0", "fr": "Écrire une fonction CPP `int f_11(int a, int b, int c, int d)` pour résoudre le problème suivant :  \nDétermine si deux intervalles fermés s'intersectent.\n\n@param a La borne inférieure du premier intervalle fermé [a,b].  \n@param b La borne supérieure du premier intervalle fermé [a,b].  \n@param c La borne inférieure du second intervalle fermé [c,d].  \n@param d La borne supérieure du second intervalle fermé [c,d].\n\n@return 1 si les intervalles s'intersectent, 0 sinon.\n\nExemples :  \nf_11(1, 1, 1, 2) retourne 1  \nf_11(3, 5, 2, 6) retourne 1  \nf_11(3, 5, 4, 7) retourne 1  \nf_11(3, 5, 6, 7) retourne 0  ", "de": "Schreiben Sie eine CPP-Funktion `int f_11(int a, int b, int c, int d)`, um das folgende Problem zu lösen:\nBestimmt, ob zwei geschlossene Intervalle sich überschneiden.\n\n@param a Die untere Grenze des ersten geschlossenen Intervalls [a,b].\n@param b Die obere Grenze des ersten geschlossenen Intervalls [a,b].\n@param c Die untere Grenze des zweiten geschlossenen Intervalls [c,d].\n@param d Die obere Grenze des zweiten geschlossenen Intervalls [c,d].\n\n@return 1, wenn die Intervalle sich überschneiden, 0 andernfalls.\n\nBeispiele:\nf_11(1, 1, 1, 2) gibt 1 zurück\nf_11(3, 5, 2, 6) gibt 1 zurück\nf_11(3, 5, 4, 7) gibt 1 zurück\nf_11(3, 5, 6, 7) gibt 0 zurück", "ha": "Rubuta aikin CPP `int f_11(int a, int b, int c, int d)` don warware matsalar mai zuwa:\nYana tantance idan tazara biyu masu rufe suna haduwa.\n\n@param a Ƙananan iyaka na tazara na farko mai rufe [a,b].\n@param b Babban iyaka na tazara na farko mai rufe [a,b].\n@param c Ƙananan iyaka na tazara na biyu mai rufe [c,d].\n@param d Babban iyaka na tazara na biyu mai rufe [c,d].\n\n@return 1 idan tazarar suna haduwa, 0 in ba haka ba.\n\nMisalai:\nf_11(1, 1, 1, 2) yana dawowa 1\nf_11(3, 5, 2, 6) yana dawowa 1\nf_11(3, 5, 4, 7) yana dawowa 1\nf_11(3, 5, 6, 7) yana dawowa 0", "hi": "एक CPP फ़ंक्शन `int f_11(int a, int b, int c, int d)` लिखें ताकि निम्नलिखित समस्या का समाधान हो सके:\nनिर्धारित करता है कि क्या दो बंद अंतराल एक-दूसरे को काटते हैं।\n\n@param a पहले बंद अंतराल [a,b] की निचली सीमा।\n@param b पहले बंद अंतराल [a,b] की ऊपरी सीमा।\n@param c दूसरे बंद अंतराल [c,d] की निचली सीमा।\n@param d दूसरे बंद अंतराल [c,d] की ऊपरी सीमा।\n\n@return 1 यदि अंतराल एक-दूसरे को काटते हैं, अन्यथा 0।\n\nउदाहरण:\nf_11(1, 1, 1, 2) 1 लौटाता है\nf_11(3, 5, 2, 6) 1 लौटाता है\nf_11(3, 5, 4, 7) 1 लौटाता है\nf_11(3, 5, 6, 7) 0 लौटाता है", "hu": "Írj egy CPP függvényt `int f_11(int a, int b, int c, int d)` a következő probléma megoldására:\nMeghatározza, hogy két zárt intervallum metszi-e egymást.\n\n@param a Az első zárt intervallum [a,b] alsó határa.\n@param b Az első zárt intervallum [a,b] felső határa.\n@param c A második zárt intervallum [c,d] alsó határa.\n@param d A második zárt intervallum [c,d] felső határa.\n\n@return 1, ha az intervallumok metszik egymást, 0 különben.\n\nPéldák:\nf_11(1, 1, 1, 2) visszatér 1\nf_11(3, 5, 2, 6) visszatér 1\nf_11(3, 5, 4, 7) visszatér 1\nf_11(3, 5, 6, 7) visszatér 0", "es": "Escribe una función CPP `int f_11(int a, int b, int c, int d)` para resolver el siguiente problema:\nDetermina si dos intervalos cerrados se intersectan.\n\n@param a El límite inferior del primer intervalo cerrado [a,b].\n@param b El límite superior del primer intervalo cerrado [a,b].\n@param c El límite inferior del segundo intervalo cerrado [c,d].\n@param d El límite superior del segundo intervalo cerrado [c,d].\n\n@return 1 si los intervalos se intersectan, 0 en caso contrario.\n\nEjemplos:\nf_11(1, 1, 1, 2) devuelve 1\nf_11(3, 5, 2, 6) devuelve 1\nf_11(3, 5, 4, 7) devuelve 1\nf_11(3, 5, 6, 7) devuelve 0", "arb": "اكتب دالة CPP `int f_11(int a, int b, int c, int d)` لحل المشكلة التالية:\nتحديد ما إذا كانت فترتان مغلقتان تتقاطعان.\n\n@param a الحد الأدنى للفترة المغلقة الأولى [a,b].\n@param b الحد الأقصى للفترة المغلقة الأولى [a,b].\n@param c الحد الأدنى للفترة المغلقة الثانية [c,d].\n@param d الحد الأقصى للفترة المغلقة الثانية [c,d].\n\n@return 1 إذا كانت الفترات تتقاطع، 0 خلاف ذلك.\n\nأمثلة:\nf_11(1, 1, 1, 2) يعيد 1\nf_11(3, 5, 2, 6) يعيد 1\nf_11(3, 5, 4, 7) يعيد 1\nf_11(3, 5, 6, 7) يعيد 0", "sw": "Andika kazi ya CPP `int f_11(int a, int b, int c, int d)` kutatua tatizo lifuatalo:\nInabainisha kama vipindi viwili vilivyofungwa vinaingiliana.\n\n@param a Kikomo cha chini cha kipindi cha kwanza kilichofungwa [a,b].\n@param b Kikomo cha juu cha kipindi cha kwanza kilichofungwa [a,b].\n@param c Kikomo cha chini cha kipindi cha pili kilichofungwa [c,d].\n@param d Kikomo cha juu cha kipindi cha pili kilichofungwa [c,d].\n\n@return 1 ikiwa vipindi vinaingiliana, 0 vinginevyo.\n\nMifano:\nf_11(1, 1, 1, 2) inarejesha 1\nf_11(3, 5, 2, 6) inarejesha 1\nf_11(3, 5, 4, 7) inarejesha 1\nf_11(3, 5, 6, 7) inarejesha 0", "tr": "Bir CPP fonksiyonu `int f_11(int a, int b, int c, int d)` yazarak aşağıdaki problemi çözün:\nİki kapalı aralığın kesişip kesişmediğini belirler.\n\n@param a İlk kapalı aralığın [a,b] alt sınırı.\n@param b İlk kapalı aralığın [a,b] üst sınırı.\n@param c İkinci kapalı aralığın [c,d] alt sınırı.\n@param d İkinci kapalı aralığın [c,d] üst sınırı.\n\n@return Aralıklar kesişiyorsa 1, aksi takdirde 0.\n\nÖrnekler:\nf_11(1, 1, 1, 2) 1 döndürür\nf_11(3, 5, 2, 6) 1 döndürür\nf_11(3, 5, 4, 7) 1 döndürür\nf_11(3, 5, 6, 7) 0 döndürür", "vi": "Viết một hàm CPP `int f_11(int a, int b, int c, int d)` để giải quyết vấn đề sau:\nXác định xem hai đoạn đóng có giao nhau hay không.\n\n@param a Giới hạn dưới của đoạn đóng thứ nhất [a,b].\n@param b Giới hạn trên của đoạn đóng thứ nhất [a,b].\n@param c Giới hạn dưới của đoạn đóng thứ hai [c,d].\n@param d Giới hạn trên của đoạn đóng thứ hai [c,d].\n\n@return 1 nếu các đoạn giao nhau, 0 nếu không.\n\nVí dụ:\nf_11(1, 1, 1, 2) trả về 1\nf_11(3, 5, 2, 6) trả về 1\nf_11(3, 5, 4, 7) trả về 1\nf_11(3, 5, 6, 7) trả về 0", "id": "Tulis sebuah fungsi CPP `int f_11(int a, int b, int c, int d)` untuk menyelesaikan masalah berikut:\nMenentukan apakah dua interval tertutup berpotongan.\n\n@param a Batas bawah dari interval tertutup pertama [a,b].\n@param b Batas atas dari interval tertutup pertama [a,b].\n@param c Batas bawah dari interval tertutup kedua [c,d].\n@param d Batas atas dari interval tertutup kedua [c,d].\n\n@return 1 jika interval berpotongan, 0 jika tidak.\n\nContoh:\nf_11(1, 1, 1, 2) mengembalikan 1\nf_11(3, 5, 2, 6) mengembalikan 1\nf_11(3, 5, 4, 7) mengembalikan 1\nf_11(3, 5, 6, 7) mengembalikan 0", "ja": "CPP関数 `int f_11(int a, int b, int c, int d)` を作成して、次の問題を解決してください:\n2つの閉区間が交差するかどうかを判定します。\n\n@param a 最初の閉区間 [a,b] の下限。\n@param b 最初の閉区間 [a,b] の上限。\n@param c 2番目の閉区間 [c,d] の下限。\n@param d 2番目の閉区間 [c,d] の上限。\n\n@return 区間が交差する場合は1、そうでない場合は0を返します。\n\n例:\nf_11(1, 1, 1, 2) は1を返します\nf_11(3, 5, 2, 6) は1を返します\nf_11(3, 5, 4, 7) は1を返します\nf_11(3, 5, 6, 7) は0を返します", "ko": "CPP 함수를 작성하세요 `int f_11(int a, int b, int c, int d)` 다음 문제를 해결하기 위해:\n두 개의 닫힌 구간이 교차하는지 여부를 결정합니다.\n\n@param a 첫 번째 닫힌 구간 [a,b]의 하한.\n@param b 첫 번째 닫힌 구간 [a,b]의 상한.\n@param c 두 번째 닫힌 구간 [c,d]의 하한.\n@param d 두 번째 닫힌 구간 [c,d]의 상한.\n\n@return 구간이 교차하면 1을 반환하고, 그렇지 않으면 0을 반환합니다.\n\n예시:\nf_11(1, 1, 1, 2) returns 1\nf_11(3, 5, 2, 6) returns 1\nf_11(3, 5, 4, 7) returns 1\nf_11(3, 5, 6, 7) returns 0", "ml": "CPP ഫംഗ്ഷൻ `int f_11(int a, int b, int c, int d)` എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nരണ്ട് അടച്ച ഇടവേളകൾ തമ്മിൽ മുട്ടിച്ചേരുന്നുണ്ടോ എന്ന് നിർണ്ണയിക്കുന്നു.\n\n@param a ആദ്യ അടച്ച ഇടവേളയുടെ താഴത്തെ പരിധി [a,b].\n@param b ആദ്യ അടച്ച ഇടവേളയുടെ മുകളിലെ പരിധി [a,b].\n@param c രണ്ടാം അടച്ച ഇടവേളയുടെ താഴത്തെ പരിധി [c,d].\n@param d രണ്ടാം അടച്ച ഇടവേളയുടെ മുകളിലെ പരിധി [c,d].\n\n@return ഇടവേളകൾ മുട്ടിച്ചേരുന്നുണ്ടെങ്കിൽ 1, അല്ലെങ്കിൽ 0.\n\nഉദാഹരണങ്ങൾ:\nf_11(1, 1, 1, 2) 1 തിരിച്ചുനൽകുന്നു\nf_11(3, 5, 2, 6) 1 തിരിച്ചുനൽകുന്നു\nf_11(3, 5, 4, 7) 1 തിരിച്ചുനൽകുന്നു\nf_11(3, 5, 6, 7) 0 തിരിച്ചുനൽകുന്നു", "fa": "یک تابع CPP بنویسید `int f_11(int a, int b, int c, int d)` برای حل مسئله زیر:\nتعیین می‌کند که آیا دو بازه بسته با یکدیگر تداخل دارند یا خیر.\n\n@param a حد پایین بازه بسته اول [a,b].\n@param b حد بالا بازه بسته اول [a,b].\n@param c حد پایین بازه بسته دوم [c,d].\n@param d حد بالا بازه بسته دوم [c,d].\n\n@return 1 اگر بازه‌ها تداخل داشته باشند، در غیر این صورت 0.\n\nمثال‌ها:\nf_11(1, 1, 1, 2) returns 1\nf_11(3, 5, 2, 6) returns 1\nf_11(3, 5, 4, 7) returns 1\nf_11(3, 5, 6, 7) returns 0"}, "level": "easy", "test": "int main() {\n    assert(f_11(1, 1, 1, 2) == 1);\n    assert(f_11(3, 5, 2, 6) == 1);\n    assert(f_11(3, 5, 4, 7) == 1);\n    assert(f_11(3, 5, 6, 7) == 0);\n    // Additional test cases\n    assert(f_11(0, 0, 0, 0) == 1);\n    assert(f_11(1, 3, 2, 4) == 1);\n    assert(f_11(1, 3, 4, 6) == 0);\n    assert(f_11(10, 20, 20, 30) == 1);\n    assert(f_11(10, 20, 21, 30) == 0);\n    \n    // printf(\"All tests passed.\\n\");\n    return 0;\n}", "entry_point": "f_11", "signature": "int f_11(int a, int b, int c, int d)", "docstring": {"en": "Determines if two closed intervals intersect.\n\n@param a The lower bound of the first closed interval [a,b].\n@param b The upper bound of the first closed interval [a,b].\n@param c The lower bound of the second closed interval [c,d].\n@param d The upper bound of the second closed interval [c,d].\n\n@return 1 if the intervals intersect, 0 otherwise.\n\nExamples:\nf_11(1, 1, 1, 2) returns 1\nf_11(3, 5, 2, 6) returns 1\nf_11(3, 5, 4, 7) returns 1\nf_11(3, 5, 6, 7) returns 0\n", "sq": "Determinon nëse dy intervale të mbyllura ndërpriten.\n\n@param a Kufiri i poshtëm i intervalit të parë të mbyllur [a,b].\n@param b Kufiri i sipërm i intervalit të parë të mbyllur [a,b].\n@param c Kufiri i poshtëm i intervalit të dytë të mbyllur [c,d].\n@param d Kufiri i sipërm i intervalit të dytë të mbyllur [c,d].\n\n@return 1 nëse intervalet ndërpriten, 0 përndryshe.\n\nShembuj:\nf_11(1, 1, 1, 2) kthen 1\nf_11(3, 5, 2, 6) kthen 1\nf_11(3, 5, 4, 7) kthen 1\nf_11(3, 5, 6, 7) kthen 0", "hy": "Որոշում է՝ արդյոք երկու փակ միջակայքերը հատվում են։\n\n@param a Առաջին փակ միջակայքի ստորին սահմանը [a,b]։\n@param b Առաջին փակ միջակայքի վերին սահմանը [a,b]։\n@param c Երկրորդ փակ միջակայքի ստորին սահմանը [c,d]։\n@param d Երկրորդ փակ միջակայքի վերին սահմանը [c,d]։\n\n@return 1՝ եթե միջակայքերը հատվում են, 0՝ հակառակ դեպքում։\n\nՕրինակներ:\nf_11(1, 1, 1, 2) վերադարձնում է 1\nf_11(3, 5, 2, 6) վերադարձնում է 1\nf_11(3, 5, 4, 7) վերադարձնում է 1\nf_11(3, 5, 6, 7) վերադարձնում է 0", "bn": "দুটি বন্ধ ইন্টারভাল পরস্পরকে অতিক্রম করে কিনা তা নির্ধারণ করে।\n\n@param a প্রথম বন্ধ ইন্টারভালের [a,b] নিম্ন সীমা।\n@param b প্রথম বন্ধ ইন্টারভালের [a,b] উপরের সীমা।\n@param c দ্বিতীয় বন্ধ ইন্টারভালের [c,d] নিম্ন সীমা।\n@param d দ্বিতীয় বন্ধ ইন্টারভালের [c,d] উপরের সীমা।\n\n@return 1 যদি ইন্টারভালগুলি ছেদ করে, অন্যথায় 0।\n\nউদাহরণ:\nf_11(1, 1, 1, 2) returns 1\nf_11(3, 5, 2, 6) returns 1\nf_11(3, 5, 4, 7) returns 1\nf_11(3, 5, 6, 7) returns 0", "bg": "Определя дали два затворени интервала се пресичат.\n\n@param a Долна граница на първия затворен интервал [a,b].\n@param b Горна граница на първия затворен интервал [a,b].\n@param c Долна граница на втория затворен интервал [c,d].\n@param d Горна граница на втория затворен интервал [c,d].\n\n@return 1 ако интервалите се пресичат, 0 в противен случай.\n\nПримери:\nf_11(1, 1, 1, 2) връща 1\nf_11(3, 5, 2, 6) връща 1\nf_11(3, 5, 4, 7) връща 1\nf_11(3, 5, 6, 7) връща 0", "zh": "确定两个闭区间是否相交。\n\n@param a 第一个闭区间 [a,b] 的下界。\n@param b 第一个闭区间 [a,b] 的上界。\n@param c 第二个闭区间 [c,d] 的下界。\n@param d 第二个闭区间 [c,d] 的上界。\n\n@return 如果区间相交返回 1，否则返回 0。\n\n示例：\nf_11(1, 1, 1, 2) 返回 1\nf_11(3, 5, 2, 6) 返回 1\nf_11(3, 5, 4, 7) 返回 1\nf_11(3, 5, 6, 7) 返回 0", "fr": "Détermine si deux intervalles fermés s'intersectent.\n\n@param a La borne inférieure du premier intervalle fermé [a,b].\n@param b La borne supérieure du premier intervalle fermé [a,b].\n@param c La borne inférieure du second intervalle fermé [c,d].\n@param d La borne supérieure du second intervalle fermé [c,d].\n\n@return 1 si les intervalles s'intersectent, 0 sinon.\n\nExemples:\nf_11(1, 1, 1, 2) retourne 1\nf_11(3, 5, 2, 6) retourne 1\nf_11(3, 5, 4, 7) retourne 1\nf_11(3, 5, 6, 7) retourne 0", "de": "Bestimmt, ob zwei abgeschlossene Intervalle sich überschneiden.\n\n@param a Die untere Grenze des ersten abgeschlossenen Intervalls [a,b].\n@param b Die obere Grenze des ersten abgeschlossenen Intervalls [a,b].\n@param c Die untere Grenze des zweiten abgeschlossenen Intervalls [c,d].\n@param d Die obere Grenze des zweiten abgeschlossenen Intervalls [c,d].\n\n@return 1, wenn sich die Intervalle überschneiden, 0 andernfalls.\n\nBeispiele:\nf_11(1, 1, 1, 2) gibt 1 zurück\nf_11(3, 5, 2, 6) gibt 1 zurück\nf_11(3, 5, 4, 7) gibt 1 zurück\nf_11(3, 5, 6, 7) gibt 0 zurück", "ha": "Yana tantance idan tazara biyu masu rufe suna hade.\n\n@param a Ƙananan iyaka na farkon rufaffiyar tazara [a,b].\n@param b Babban iyaka na farkon rufaffiyar tazara [a,b].\n@param c Ƙananan iyaka na na biyun rufaffiyar tazara [c,d].\n@param d Babban iyaka na na biyun rufaffiyar tazara [c,d].\n\n@return 1 idan tazarorin sun haɗu, 0 in ba haka ba.\n\nMisalai:\nf_11(1, 1, 1, 2) returns 1\nf_11(3, 5, 2, 6) returns 1\nf_11(3, 5, 4, 7) returns 1\nf_11(3, 5, 6, 7) returns 0", "hi": "दो बंद अंतरालों के प्रतिच्छेदन की जाँच करता है।\n\n@param a पहले बंद अंतराल [a,b] की निचली सीमा।\n@param b पहले बंद अंतराल [a,b] की ऊपरी सीमा।\n@param c दूसरे बंद अंतराल [c,d] की निचली सीमा।\n@param d दूसरे बंद अंतराल [c,d] की ऊपरी सीमा।\n\n@return 1 यदि अंतराल प्रतिच्छेदित होते हैं, अन्यथा 0।\n\nउदाहरण:\nf_11(1, 1, 1, 2) returns 1\nf_11(3, 5, 2, 6) returns 1\nf_11(3, 5, 4, 7) returns 1\nf_11(3, 5, 6, 7) returns 0", "hu": "Meghatározza, hogy két zárt intervallum metszi-e egymást.\n\n@param a Az első zárt intervallum [a,b] alsó határa.\n@param b Az első zárt intervallum [a,b] felső határa.\n@param c A második zárt intervallum [c,d] alsó határa.\n@param d A második zárt intervallum [c,d] felső határa.\n\n@return 1, ha az intervallumok metszik egymást, különben 0.\n\nPéldák:\nf_11(1, 1, 1, 2) visszaadja 1\nf_11(3, 5, 2, 6) visszaadja 1\nf_11(3, 5, 4, 7) visszaadja 1\nf_11(3, 5, 6, 7) visszaadja 0", "es": "Determina si dos intervalos cerrados se intersectan.\n\n@param a El límite inferior del primer intervalo cerrado [a,b].\n@param b El límite superior del primer intervalo cerrado [a,b].\n@param c El límite inferior del segundo intervalo cerrado [c,d].\n@param d El límite superior del segundo intervalo cerrado [c,d].\n\n@return 1 si los intervalos se intersectan, 0 en caso contrario.\n\nEjemplos:\nf_11(1, 1, 1, 2) devuelve 1\nf_11(3, 5, 2, 6) devuelve 1\nf_11(3, 5, 4, 7) devuelve 1\nf_11(3, 5, 6, 7) devuelve 0", "arb": "تحديد ما إذا كانت فترتان مغلقتان تتقاطعان.\n\n@param a الحد الأدنى للفترة المغلقة الأولى [a,b].\n@param b الحد الأقصى للفترة المغلقة الأولى [a,b].\n@param c الحد الأدنى للفترة المغلقة الثانية [c,d].\n@param d الحد الأقصى للفترة المغلقة الثانية [c,d].\n\n@return 1 إذا كانت الفترات تتقاطع، 0 خلاف ذلك.\n\nأمثلة:\nf_11(1, 1, 1, 2) returns 1\nf_11(3, 5, 2, 6) returns 1\nf_11(3, 5, 4, 7) returns 1\nf_11(3, 5, 6, 7) returns 0", "sw": "Inabainisha kama vipindi viwili vilivyofungwa vinaingiliana.\n\n@param a Chini ya mpaka wa kipengele cha kwanza kilichofungwa [a,b].\n@param b Juu ya mpaka wa kipengele cha kwanza kilichofungwa [a,b].\n@param c Chini ya mpaka wa kipengele cha pili kilichofungwa [c,d].\n@param d Juu ya mpaka wa kipengele cha pili kilichofungwa [c,d].\n\n@return 1 ikiwa vipengele vinaingiliana, 0 vinginevyo.\n\nExamples:\nf_11(1, 1, 1, 2) returns 1\nf_11(3, 5, 2, 6) returns 1\nf_11(3, 5, 4, 7) returns 1\nf_11(3, 5, 6, 7) returns 0", "tr": "İki kapalı aralığın kesişip kesişmediğini belirler.\n\n@param a İlk kapalı aralığın [a,b] alt sınırı.\n@param b İlk kapalı aralığın [a,b] üst sınırı.\n@param c İkinci kapalı aralığın [c,d] alt sınırı.\n@param d İkinci kapalı aralığın [c,d] üst sınırı.\n\n@return Aralıklar kesişiyorsa 1, aksi takdirde 0.\n\nÖrnekler:\nf_11(1, 1, 1, 2) 1 döndürür\nf_11(3, 5, 2, 6) 1 döndürür\nf_11(3, 5, 4, 7) 1 döndürür\nf_11(3, 5, 6, 7) 0 döndürür", "vi": "Xác định xem hai khoảng đóng có giao nhau hay không.\n\n@param a Giới hạn dưới của khoảng đóng thứ nhất [a,b].\n@param b Giới hạn trên của khoảng đóng thứ nhất [a,b].\n@param c Giới hạn dưới của khoảng đóng thứ hai [c,d].\n@param d Giới hạn trên của khoảng đóng thứ hai [c,d].\n\n@return 1 nếu các khoảng giao nhau, 0 nếu không.\n\nVí dụ:\nf_11(1, 1, 1, 2) trả về 1\nf_11(3, 5, 2, 6) trả về 1\nf_11(3, 5, 4, 7) trả về 1\nf_11(3, 5, 6, 7) trả về 0", "id": "Menentukan apakah dua interval tertutup saling berpotongan.\n\n@param a Batas bawah dari interval tertutup pertama [a,b].\n@param b Batas atas dari interval tertutup pertama [a,b].\n@param c Batas bawah dari interval tertutup kedua [c,d].\n@param d Batas atas dari interval tertutup kedua [c,d].\n\n@return 1 jika interval berpotongan, 0 jika tidak.\n\nContoh:\nf_11(1, 1, 1, 2) mengembalikan 1\nf_11(3, 5, 2, 6) mengembalikan 1\nf_11(3, 5, 4, 7) mengembalikan 1\nf_11(3, 5, 6, 7) mengembalikan 0", "ja": "2つの閉区間が交差するかどうかを判断します。\n\n@param a 最初の閉区間 [a,b] の下限。\n@param b 最初の閉区間 [a,b] の上限。\n@param c 2番目の閉区間 [c,d] の下限。\n@param d 2番目の閉区間 [c,d] の上限。\n\n@return 区間が交差する場合は1、そうでない場合は0。\n\n例:\nf_11(1, 1, 1, 2) は1を返します\nf_11(3, 5, 2, 6) は1を返します\nf_11(3, 5, 4, 7) は1を返します\nf_11(3, 5, 6, 7) は0を返します", "ko": "두 닫힌 구간이 교차하는지 여부를 결정합니다.\n\n@param a 첫 번째 닫힌 구간 [a,b]의 하한.\n@param b 첫 번째 닫힌 구간 [a,b]의 상한.\n@param c 두 번째 닫힌 구간 [c,d]의 하한.\n@param d 두 번째 닫힌 구간 [c,d]의 상한.\n\n@return 구간이 교차하면 1을 반환하고, 그렇지 않으면 0을 반환합니다.\n\n예제:\nf_11(1, 1, 1, 2) returns 1\nf_11(3, 5, 2, 6) returns 1\nf_11(3, 5, 4, 7) returns 1\nf_11(3, 5, 6, 7) returns 0", "ml": "Determines if two closed intervals intersect.\n\n@param a ആദ്യത്തെ അടച്ച ഇടവേളയുടെ താഴത്തെ പരിധി [a,b].\n@param b ആദ്യത്തെ അടച്ച ഇടവേളയുടെ മുകളിലെ പരിധി [a,b].\n@param c രണ്ടാമത്തെ അടച്ച ഇടവേളയുടെ താഴത്തെ പരിധി [c,d].\n@param d രണ്ടാമത്തെ അടച്ച ഇടവേളയുടെ മുകളിലെ പരിധി [c,d].\n\n@return ഇടവേളകൾ തമ്മിൽ മുട്ടിച്ചേരുന്നുവെങ്കിൽ 1, അല്ലെങ്കിൽ 0.\n\nExamples:\nf_11(1, 1, 1, 2) returns 1\nf_11(3, 5, 2, 6) returns 1\nf_11(3, 5, 4, 7) returns 1\nf_11(3, 5, 6, 7) returns 0", "fa": "രണ്ട് വാക്കുകൾ ഒരു നിർദ്ദിഷ്ട മാതൃകയിൽ ചേർത്തുകൊണ്ട് ഒരു അതുല്യമായ ഐഡന്റിഫയർ സൃഷ്ടിക്കുന്നു..\n\n@param a کران پایین اولین بازه بسته [a,b].\n@param b کران بالای اولین بازه بسته [a,b].\n@param c کران پایین دومین بازه بسته [c,d].\n@param d کران بالای دومین بازه بسته [c,d].\n\n@return 1 اگر بازه‌ها همپوشانی داشته باشند، در غیر این صورت 0.\n\nExamples:\nf_11(1, 1, 1, 2) returns 1\nf_11(3, 5, 2, 6) returns 1\nf_11(3, 5, 4, 7) returns 1\nf_11(3, 5, 6, 7) returns 0"}}
{"task_id": "CPP/12", "prompt": {"en": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n/**\n * You are given three integers a, b, c, where two of them are equal, and the\n * third is different from the other two. Your task is to find the value that\n * occurs exactly once.\n *\n * Examples:\n *   f_12(0, 0, 1) returns 1\n *   f_12(4, 3, 4) returns 3\n */\nint f_12(int a, int b, int c)", "sq": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n/**\n * Ju jepen tre numra të plotë a, b, c, ku dy prej tyre janë të barabartë, dhe\n * i treti është i ndryshëm nga dy të tjerët. Detyra juaj është të gjeni vlerën që\n * ndodh saktësisht një herë.\n *\n * Shembuj:\n *   f_12(0, 0, 1) kthen 1\n *   f_12(4, 3, 4) kthen 3\n */\nint f_12(int a, int b, int c)", "hy": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n/**\n * Ձեզ տրված են երեք ամբողջ թվեր a, b, c, որտեղ երկուսը հավասար են, և\n * երրորդը տարբերվում է մյուս երկուսից։ Ձեր խնդիրը գտնել այն արժեքը,\n * որը հանդիպում է հենց մեկ անգամ։\n *\n * Օրինակներ:\n *   f_12(0, 0, 1) վերադարձնում է 1\n *   f_12(4, 3, 4) վերադարձնում է 3\n */\nint f_12(int a, int b, int c)", "bn": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n/**\n * আপনাকে তিনটি পূর্ণসংখ্যা দেওয়া হয়েছে a, b, c, যেখানে এদের মধ্যে দুটি সমান, এবং\n * তৃতীয়টি অন্য দুটি থেকে আলাদা। আপনার কাজ হল যে মানটি ঠিক একবার ঘটে তা খুঁজে বের করা।\n *\n * উদাহরণ:\n *   f_12(0, 0, 1) 1 প্রদান করে\n *   f_12(4, 3, 4) 3 প্রদান করে\n */\nint f_12(int a, int b, int c)", "bg": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n/**\n * Дадени са ви три цели числа a, b, c, където две от тях са равни, а\n * третото е различно от другите две. Вашата задача е да намерите стойността,\n * която се среща точно веднъж.\n *\n * Примери:\n *   f_12(0, 0, 1) връща 1\n *   f_12(4, 3, 4) връща 3\n */\nint f_12(int a, int b, int c)", "zh": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n/**\n * 给定三个整数 a, b, c，其中两个是相等的，第三个与其他两个不同。你的任务是找到那个只出现一次的值。\n *\n * 示例:\n *   f_12(0, 0, 1) 返回 1\n *   f_12(4, 3, 4) 返回 3\n */\nint f_12(int a, int b, int c)", "fr": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n/**\n * On vous donne trois entiers a, b, c, où deux d'entre eux sont égaux, et le\n * troisième est différent des deux autres. Votre tâche est de trouver la valeur qui\n * apparaît exactement une fois.\n *\n * Exemples :\n *   f_12(0, 0, 1) retourne 1\n *   f_12(4, 3, 4) retourne 3\n */\nint f_12(int a, int b, int c)", "de": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n/**\n * Sie haben drei ganze Zahlen a, b, c, wobei zwei von ihnen gleich sind und die\n * dritte sich von den anderen beiden unterscheidet. Ihre Aufgabe ist es, den Wert zu finden,\n * der genau einmal vorkommt.\n *\n * Beispiele:\n *   f_12(0, 0, 1) gibt 1 zurück\n *   f_12(4, 3, 4) gibt 3 zurück\n */\nint f_12(int a, int b, int c)", "ha": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n/**\n * An ba ku lambobi guda uku a, b, c, inda biyu daga cikinsu suna daidai, \n * kuma na ukun ya bambanta da sauran biyun. Ayyukanku shine ku nemo \n * ƙimar da ta bayyana sau ɗaya kawai.\n *\n * Misalai:\n *   f_12(0, 0, 1) returns 1\n *   f_12(4, 3, 4) returns 3\n */\nint f_12(int a, int b, int c)", "hi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n/**\n * आपको तीन पूर्णांक a, b, c दिए गए हैं, जहाँ इनमें से दो समान हैं, और\n * तीसरा अन्य दो से भिन्न है। आपका कार्य उस मान को खोजना है जो\n * केवल एक बार आता है।\n *\n * उदाहरण:\n *   f_12(0, 0, 1) 1 लौटाता है\n *   f_12(4, 3, 4) 3 लौटाता है\n */\nint f_12(int a, int b, int c)", "hu": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n/**\n * Három egész számot kap, a, b, c, ahol kettő közülük egyenlő, és a\n * harmadik különbözik a másik kettőtől. Az Ön feladata megtalálni azt az értéket,\n * amely pontosan egyszer fordul elő.\n *\n * Példák:\n *   f_12(0, 0, 1) visszaadja 1\n *   f_12(4, 3, 4) visszaadja 3\n */\nint f_12(int a, int b, int c)", "es": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n/**\n * Se te dan tres enteros a, b, c, donde dos de ellos son iguales, y el\n * tercero es diferente de los otros dos. Tu tarea es encontrar el valor que\n * ocurre exactamente una vez.\n *\n * Ejemplos:\n *   f_12(0, 0, 1) returns 1\n *   f_12(4, 3, 4) returns 3\n */\nint f_12(int a, int b, int c)", "arb": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n/**\n * لديك ثلاثة أعداد صحيحة a، b، c، حيث يكون اثنان منها متساويين،\n * والثالث مختلف عن الاثنين الآخرين. مهمتك هي العثور على القيمة التي\n * تظهر مرة واحدة فقط.\n *\n * أمثلة:\n *   f_12(0, 0, 1) returns 1\n *   f_12(4, 3, 4) returns 3\n */\nint f_12(int a, int b, int c)", "sw": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n/**\n * Umepewa nambari tatu a, b, c, ambapo mbili kati ya hizo ni sawa, na\n * ya tatu ni tofauti na hizo mbili nyingine. Kazi yako ni kupata thamani\n * inayotokea mara moja tu.\n *\n * Mifano:\n *   f_12(0, 0, 1) inarudisha 1\n *   f_12(4, 3, 4) inarudisha 3\n */\nint f_12(int a, int b, int c)", "tr": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n/**\n * Üç tamsayı a, b, c verilir, bunlardan ikisi eşittir ve\n * üçüncüsü diğer ikisinden farklıdır. Göreviniz tam olarak bir kez\n * geçen değeri bulmaktır.\n *\n * Örnekler:\n *   f_12(0, 0, 1) 1 döndürür\n *   f_12(4, 3, 4) 3 döndürür\n */\nint f_12(int a, int b, int c)", "vi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n/**\n * Bạn được cung cấp ba số nguyên a, b, c, trong đó hai số bằng nhau và\n * số thứ ba khác với hai số còn lại. Nhiệm vụ của bạn là tìm giá trị xuất hiện\n * chính xác một lần.\n *\n * Ví dụ:\n *   f_12(0, 0, 1) trả về 1\n *   f_12(4, 3, 4) trả về 3\n */\nint f_12(int a, int b, int c)", "id": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n/**\n * Anda diberikan tiga bilangan bulat a, b, c, di mana dua di antaranya sama, dan\n * yang ketiga berbeda dari dua lainnya. Tugas Anda adalah menemukan nilai yang\n * muncul tepat sekali.\n *\n * Contoh:\n *   f_12(0, 0, 1) mengembalikan 1\n *   f_12(4, 3, 4) mengembalikan 3\n */\nint f_12(int a, int b, int c)", "ja": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n/**\n * あなたは3つの整数 a, b, c を与えられます。そのうち2つは等しく、残りの1つは他の2つと異なります。\n * あなたのタスクは、ちょうど一度だけ出現する値を見つけることです。\n *\n * 例:\n *   f_12(0, 0, 1) は 1 を返します\n *   f_12(4, 3, 4) は 3 を返します\n */\nint f_12(int a, int b, int c)", "ko": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n/**\n * 세 개의 정수 a, b, c가 주어졌을 때, 그 중 두 개는 같고\n * 나머지 하나는 다른 두 개와 다릅니다. 당신의 작업은\n * 정확히 한 번만 나타나는 값을 찾는 것입니다.\n *\n * 예시:\n *   f_12(0, 0, 1) returns 1\n *   f_12(4, 3, 4) returns 3\n */\nint f_12(int a, int b, int c)", "ml": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n/**\n * നിങ്ങൾക്ക് മൂന്ന് പൂർണ്ണസംഖ്യകൾ a, b, c നൽകിയിരിക്കുന്നു, ഇവയിൽ രണ്ടെണ്ണം തുല്യമാണ്,\n * മൂന്നാമത്തേത് മറ്റുള്ള രണ്ടിനെക്കാൾ വ്യത്യസ്തമാണ്. ഒരിക്കൽ മാത്രം സംഭവിക്കുന്ന\n * മൂല്യം കണ്ടെത്തുക എന്നതാണ് നിങ്ങളുടെ പണി.\n *\n * ഉദാഹരണങ്ങൾ:\n *   f_12(0, 0, 1) 1 നു മടങ്ങുന്നു\n *   f_12(4, 3, 4) 3 നു മടങ്ങുന്നു\n */\nint f_12(int a, int b, int c)", "fa": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n/**\n * به شما سه عدد صحیح a، b، c داده شده است که دو تا از آنها برابر هستند و\n * سومی با دو تای دیگر متفاوت است. وظیفه شما این است که مقداری را پیدا کنید که\n * دقیقاً یک بار ظاهر می‌شود.\n *\n * مثال‌ها:\n *   f_12(0, 0, 1) مقدار 1 را برمی‌گرداند\n *   f_12(4, 3, 4) مقدار 3 را برمی‌گرداند\n */\nint f_12(int a, int b, int c)"}, "canonical_solution": "{\n    if (a == b) {\n        return c;\n    } else if (a == c) {\n        return b;\n    } else {\n        return a;\n    }\n}", "instruction": {"en": "Write a CPP function `int f_12(int a, int b, int c)` to solve the following problem:\nYou are given three integers a, b, c, where two of them are equal, and the third is different from the other two. Your task is to find the value that occurs exactly once.\n\nExamples:\n  f_12(0, 0, 1) returns 1\n  f_12(4, 3, 4) returns 3\n", "sq": "Shkruani një funksion CPP `int f_12(int a, int b, int c)` për të zgjidhur problemin e mëposhtëm:\nJu jepen tre numra të plotë a, b, c, ku dy prej tyre janë të barabartë, dhe i treti është i ndryshëm nga dy të tjerët. Detyra juaj është të gjeni vlerën që ndodh saktësisht një herë.\n\nShembuj:\n  f_12(0, 0, 1) kthen 1\n  f_12(4, 3, 4) kthen 3", "hy": "Գրեք CPP ֆունկցիա `int f_12(int a, int b, int c)` հետևյալ խնդիրը լուծելու համար:  \nՁեզ տրված են երեք ամբողջ թիվ a, b, c, որտեղ երկուսը հավասար են, իսկ երրորդը տարբերվում է մյուս երկուսից: Ձեր խնդիրն է գտնել այն արժեքը, որը հանդիպում է միայն մեկ անգամ:\n\nՕրինակներ:\n  f_12(0, 0, 1) վերադարձնում է 1\n  f_12(4, 3, 4) վերադարձնում է 3", "bn": "একটি CPP ফাংশন `int f_12(int a, int b, int c)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nআপনাকে তিনটি পূর্ণসংখ্যা a, b, c দেওয়া হয়েছে, যেখানে তাদের মধ্যে দুটি সমান এবং তৃতীয়টি অন্য দুটি থেকে ভিন্ন। আপনার কাজ হল সেই মানটি খুঁজে বের করা যা ঠিক একবার ঘটে।\n\nউদাহরণসমূহ:\n  f_12(0, 0, 1) 1 প্রদান করে\n  f_12(4, 3, 4) 3 প্রদান করে", "bg": "Напишете CPP функция `int f_12(int a, int b, int c)`, за да решите следния проблем:  \nДадени са ви три цели числа a, b, c, където две от тях са равни, а третото е различно от другите две. Вашата задача е да намерите стойността, която се среща точно веднъж.\n\nПримери:  \n  f_12(0, 0, 1) връща 1  \n  f_12(4, 3, 4) връща 3  ", "zh": "编写一个 CPP 函数 `int f_12(int a, int b, int c)` 来解决以下问题：  \n给定三个整数 a, b, c，其中两个相等，第三个与其他两个不同。你的任务是找到只出现一次的值。\n\n示例：  \nf_12(0, 0, 1) 返回 1  \nf_12(4, 3, 4) 返回 3  ", "fr": "Écrire une fonction CPP `int f_12(int a, int b, int c)` pour résoudre le problème suivant :  \nOn vous donne trois entiers a, b, c, dont deux sont égaux, et le troisième est différent des deux autres. Votre tâche est de trouver la valeur qui apparaît exactement une fois.\n\nExemples :\n  f_12(0, 0, 1) renvoie 1\n  f_12(4, 3, 4) renvoie 3", "de": "Schreiben Sie eine CPP-Funktion `int f_12(int a, int b, int c)`, um das folgende Problem zu lösen:\nSie haben drei ganze Zahlen a, b, c, von denen zwei gleich sind und die dritte sich von den anderen beiden unterscheidet. Ihre Aufgabe ist es, den Wert zu finden, der genau einmal vorkommt.\n\nBeispiele:\n  f_12(0, 0, 1) gibt 1 zurück\n  f_12(4, 3, 4) gibt 3 zurück", "ha": "Rubuta aikin CPP `int f_12(int a, int b, int c)` don warware matsalar mai zuwa:\nAn ba ka lambobi guda uku a, b, c, inda biyu daga cikinsu suna daidai, kuma na uku ya bambanta daga sauran biyun. Ayyukanka shine gano ƙimar da ta bayyana sau ɗaya kawai.\n\nMisalai:\n  f_12(0, 0, 1) yana dawowa 1\n  f_12(4, 3, 4) yana dawowa 3", "hi": "एक CPP फ़ंक्शन `int f_12(int a, int b, int c)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nआपको तीन पूर्णांक a, b, c दिए गए हैं, जिनमें से दो समान हैं, और तीसरा अन्य दो से भिन्न है। आपका कार्य उस मान को खोजना है जो केवल एक बार आता है।\n\nउदाहरण:\n  f_12(0, 0, 1) returns 1\n  f_12(4, 3, 4) returns 3", "hu": "Írj egy CPP függvényt `int f_12(int a, int b, int c)` a következő probléma megoldására:\nHárom egész számot kapsz, a, b, c, ahol kettő közülük egyenlő, és a harmadik eltér a másik kettőtől. A feladatod az, hogy megtaláld azt az értéket, amely pontosan egyszer fordul elő.\n\nPéldák:\n  f_12(0, 0, 1) visszaadja 1\n  f_12(4, 3, 4) visszaadja 3", "es": "Escribe una función CPP `int f_12(int a, int b, int c)` para resolver el siguiente problema:\nSe te dan tres enteros a, b, c, donde dos de ellos son iguales, y el tercero es diferente de los otros dos. Tu tarea es encontrar el valor que ocurre exactamente una vez.\n\nEjemplos:\n  f_12(0, 0, 1) devuelve 1\n  f_12(4, 3, 4) devuelve 3", "arb": "اكتب دالة CPP `int f_12(int a, int b, int c)` لحل المشكلة التالية:\nأنت لديك ثلاثة أعداد صحيحة a، b، c، حيث يكون اثنان منهما متساويين، والثالث مختلف عن الآخرين. مهمتك هي إيجاد القيمة التي تظهر مرة واحدة فقط.\n\nأمثلة:\n  f_12(0, 0, 1) returns 1\n  f_12(4, 3, 4) returns 3", "sw": "Andika kazi ya CPP `int f_12(int a, int b, int c)` kutatua tatizo lifuatalo:  \nUmepewa nambari tatu za mzima a, b, c, ambapo mbili kati ya hizo ni sawa, na ya tatu ni tofauti na zile mbili nyingine. Kazi yako ni kupata thamani inayotokea mara moja tu.\n\nMifano:  \n  f_12(0, 0, 1) inarudisha 1  \n  f_12(4, 3, 4) inarudisha 3  ", "tr": "Bir CPP fonksiyonu `int f_12(int a, int b, int c)` yazarak aşağıdaki problemi çözün:\nÜç tamsayı a, b, c verilir, bunlardan ikisi eşittir ve üçüncüsü diğer ikisinden farklıdır. Göreviniz, yalnızca bir kez meydana gelen değeri bulmaktır.\n\nÖrnekler:\n  f_12(0, 0, 1) 1 döndürür\n  f_12(4, 3, 4) 3 döndürür", "vi": "Viết một hàm CPP `int f_12(int a, int b, int c)` để giải quyết vấn đề sau:  \nBạn được cho ba số nguyên a, b, c, trong đó hai trong số chúng bằng nhau, và số thứ ba khác với hai số còn lại. Nhiệm vụ của bạn là tìm giá trị xuất hiện chính xác một lần.\n\nVí dụ:  \n  f_12(0, 0, 1) trả về 1  \n  f_12(4, 3, 4) trả về 3  ", "id": "Tulis fungsi CPP `int f_12(int a, int b, int c)` untuk menyelesaikan masalah berikut:  \nAnda diberikan tiga bilangan bulat a, b, c, di mana dua di antaranya sama, dan yang ketiga berbeda dari dua lainnya. Tugas Anda adalah menemukan nilai yang muncul tepat sekali.\n\nContoh:  \n  f_12(0, 0, 1) mengembalikan 1  \n  f_12(4, 3, 4) mengembalikan 3  ", "ja": "CPP関数 `int f_12(int a, int b, int c)` を作成して、次の問題を解決してください:\n3つの整数 a, b, c が与えられます。このうち2つは等しく、残りの1つは他の2つと異なります。あなたのタスクは、ちょうど1回だけ出現する値を見つけることです。\n\n例:\n  f_12(0, 0, 1) は 1 を返します\n  f_12(4, 3, 4) は 3 を返します", "ko": "다음 문제를 해결하기 위해 CPP 함수 `int f_12(int a, int b, int c)`를 작성하십시오:\n세 정수 a, b, c가 주어지며, 이 중 두 개는 서로 같고 나머지 하나는 다른 두 개와 다릅니다. 당신의 작업은 정확히 한 번 나타나는 값을 찾는 것입니다.\n\n예시:\n  f_12(0, 0, 1) returns 1\n  f_12(4, 3, 4) returns 3", "ml": "`int f_12(int a, int b, int c)` എന്ന CPP ഫംഗ്ഷൻ എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:  \nനിങ്ങൾക്ക് മൂന്ന് പൂർണ്ണസംഖ്യകൾ a, b, c ലഭ്യമാണ്, ഇവയിൽ രണ്ടെണ്ണം തുല്യമാണ്, ബാക്കി ഒന്നെണ്ണം മറ്റുള്ളവ രണ്ടിനും വ്യത്യസ്തമാണ്. നിങ്ങളുടെ ജോലി ഒരു തവണ മാത്രം സംഭവിക്കുന്ന മൂല്യം കണ്ടെത്തുക എന്നതാണ്.\n\nഉദാഹരണങ്ങൾ:  \n  f_12(0, 0, 1) 1 തിരികെ നൽകുന്നു  \n  f_12(4, 3, 4) 3 തിരികെ നൽകുന്നു  ", "fa": "یک تابع CPP به نام `int f_12(int a, int b, int c)` بنویسید تا مسئله زیر را حل کند:\nبه شما سه عدد صحیح a، b، c داده می‌شود که دو تا از آن‌ها برابر هستند و سومی با دو تای دیگر متفاوت است. وظیفه شما این است که مقداری را پیدا کنید که دقیقاً یک بار رخ می‌دهد.\n\nمثال‌ها:\n  f_12(0, 0, 1) مقدار 1 را برمی‌گرداند\n  f_12(4, 3, 4) مقدار 3 را برمی‌گرداند"}, "level": "easy", "test": "int main() {\n    assert(f_12(2, 7, 2) == 7);\n    assert(f_12(3, 2, 2) == 3);\n    assert(f_12(5, 5, 1) == 1);\n    assert(f_12(500000000, 3, 500000000) == 3);\n    assert(f_12(500000000, 500000000, 3) == 3);\n\n    \n    return 0;\n}", "entry_point": "f_12", "signature": "int f_12(int a, int b, int c)", "docstring": {"en": "You are given three integers a, b, c, where two of them are equal, and the third is different from the other two. Your task is to find the value that occurs exactly once.\n\nExamples:\n  f_12(0, 0, 1) returns 1\n  f_12(4, 3, 4) returns 3\n", "sq": "Ju jepen tre numra të plotë a, b, c, ku dy prej tyre janë të barabartë, dhe i treti është i ndryshëm nga dy të tjerët. Detyra juaj është të gjeni vlerën që ndodh saktësisht një herë.\n\nShembuj:\n  f_12(0, 0, 1) kthen 1\n  f_12(4, 3, 4) kthen 3", "hy": "Դուք տրված եք երեք ամբողջ թվերով `a`, `b`, `c`, որտեղ երկուսը հավասար են, իսկ երրորդը տարբերվում է մյուս երկուսից։ Ձեր խնդիրն է գտնել այն արժեքը, որը հանդիպում է հենց մեկ անգամ։\n\nՕրինակներ:\n  f_12(0, 0, 1) վերադարձնում է 1\n  f_12(4, 3, 4) վերադարձնում է 3", "bn": "তোমাকে তিনটি পূর্ণসংখ্যা দেওয়া হয়েছে a, b, c, যেখানে এদের মধ্যে দুটি সমান এবং তৃতীয়টি অন্য দুটি থেকে ভিন্ন। তোমার কাজ হল সেই মানটি খুঁজে বের করা যা ঠিক একবার ঘটে।\n\nউদাহরণসমূহ:\n  f_12(0, 0, 1) ১ ফেরত দেয়\n  f_12(4, 3, 4) ৩ ফেরত দেয়", "bg": "Дадени са ви три цели числа a, b, c, където две от тях са равни, а третото е различно от другите две. Вашата задача е да намерите стойността, която се среща точно веднъж.\n\nПримери:\n  f_12(0, 0, 1) връща 1\n  f_12(4, 3, 4) връща 3", "zh": "你有三个整数 a, b, c，其中两个是相等的，第三个与其他两个不同。你的任务是找出只出现一次的值。\n\n示例：\n  f_12(0, 0, 1) 返回 1\n  f_12(4, 3, 4) 返回 3", "fr": "Vous avez trois entiers a, b, c, où deux d'entre eux sont égaux, et le troisième est différent des deux autres. Votre tâche est de trouver la valeur qui apparaît exactement une fois.\n\nExemples :\n  f_12(0, 0, 1) returns 1\n  f_12(4, 3, 4) returns 3", "de": "Du hast drei ganze Zahlen a, b, c, wobei zwei von ihnen gleich sind und die dritte sich von den anderen beiden unterscheidet. Deine Aufgabe ist es, den Wert zu finden, der genau einmal vorkommt.\n\nBeispiele:\n  f_12(0, 0, 1) gibt 1 zurück\n  f_12(4, 3, 4) gibt 3 zurück", "ha": "An ba ku lambobi guda uku a, b, c, inda biyu daga cikinsu suna daidai, kuma na uku ya bambanta da sauran biyun. Aikin ku shine nemo darajar da ta bayyana sau daya kawai.\n\nMisalai:\n  f_12(0, 0, 1) yana dawowa 1\n  f_12(4, 3, 4) yana dawowa 3", "hi": "आपको तीन पूर्णांक a, b, c दिए गए हैं, जिनमें से दो समान हैं, और तीसरा अन्य दो से भिन्न है। आपका कार्य उस मान को खोजना है जो केवल एक बार आता है।\n\nउदाहरण:\n  f_12(0, 0, 1) 1 लौटाता है\n  f_12(4, 3, 4) 3 लौटाता है", "hu": "Három egész számot kap, a, b, c, ahol kettő közülük egyenlő, és a harmadik különbözik a másik kettőtől. Az Ön feladata megtalálni azt az értéket, amely pontosan egyszer fordul elő.\n\nPéldák:\n  f_12(0, 0, 1) visszaadja 1\n  f_12(4, 3, 4) visszaadja 3", "es": "Se te dan tres enteros a, b, c, donde dos de ellos son iguales, y el tercero es diferente de los otros dos. Tu tarea es encontrar el valor que ocurre exactamente una vez.\n\nEjemplos:\n  f_12(0, 0, 1) returns 1\n  f_12(4, 3, 4) returns 3", "arb": "أنت مُعطى ثلاثة أعداد صحيحة a، b، c، حيث أن اثنين منهما متساويان، والثالث مختلف عن الاثنين الآخرين. مهمتك هي إيجاد القيمة التي تظهر مرة واحدة فقط.\n\nأمثلة:\n  f_12(0, 0, 1) يعيد 1\n  f_12(4, 3, 4) يعيد 3", "sw": "Unapewa nambari tatu za mzima a, b, c, ambapo mbili kati yao ni sawa, na ya tatu ni tofauti na zile nyingine mbili. Kazi yako ni kupata thamani inayotokea mara moja tu.\n\nMifano:\n  f_12(0, 0, 1) inarudisha 1\n  f_12(4, 3, 4) inarudisha 3", "tr": "Üç tamsayı a, b, c verilir ve bunlardan ikisi eşittir, üçüncüsü ise diğer ikisinden farklıdır. Göreviniz, tam olarak bir kez geçen değeri bulmaktır.\n\nÖrnekler:\n  f_12(0, 0, 1) 1 döndürür\n  f_12(4, 3, 4) 3 döndürür", "vi": "Bạn được cung cấp ba số nguyên a, b, c, trong đó có hai số bằng nhau, và số thứ ba khác với hai số còn lại. Nhiệm vụ của bạn là tìm giá trị xuất hiện chính xác một lần.\n\nVí dụ:\n  f_12(0, 0, 1) trả về 1\n  f_12(4, 3, 4) trả về 3", "id": "Anda diberikan tiga bilangan bulat a, b, c, di mana dua di antaranya sama, dan yang ketiga berbeda dari dua lainnya. Tugas Anda adalah menemukan nilai yang muncul tepat sekali.\n\nContoh:\n  f_12(0, 0, 1) mengembalikan 1\n  f_12(4, 3, 4) mengembalikan 3", "ja": "3つの整数 a, b, c が与えられます。このうち2つは等しく、残りの1つは他の2つと異なります。あなたのタスクは、ちょうど1回だけ出現する値を見つけることです。\n\n例:\n  f_12(0, 0, 1) は 1 を返します\n  f_12(4, 3, 4) は 3 を返します", "ko": "세 개의 정수 a, b, c가 주어집니다. 이 중 두 개는 같고, 나머지 하나는 다른 두 개와 다릅니다. 당신의 작업은 정확히 한 번만 나타나는 값을 찾는 것입니다.\n\n예시:\n  f_12(0, 0, 1) returns 1\n  f_12(4, 3, 4) returns 3", "ml": "നിങ്ങൾക്ക് മൂന്ന് പൂർണ്ണസംഖ്യകൾ a, b, c ലഭിച്ചിരിക്കുന്നു, ഇവയിൽ രണ്ടെണ്ണം തുല്യമാണ്, മൂന്നാമത്തേത് മറ്റുള്ള രണ്ടെണ്ണത്തേക്കാൾ വ്യത്യസ്തമാണ്. കൃത്യമായി ഒരിക്കൽ മാത്രമേ സംഭവിക്കുന്ന മൂല്യം കണ്ടെത്തുക എന്നതാണ് നിങ്ങളുടെ ജോലി.\n\nഉദാഹരണങ്ങൾ:\n  f_12(0, 0, 1) 1 മടക്കുന്നു\n  f_12(4, 3, 4) 3 മടക്കുന്നു", "fa": "شما سه عدد صحیح a، b، c دارید که دو تای آن‌ها برابر هستند و سومی با دو تای دیگر متفاوت است. وظیفه شما این است که مقداری را که دقیقاً یک بار رخ می‌دهد پیدا کنید.\n\nمثال‌ها:\n  f_12(0, 0, 1) برمی‌گرداند 1\n  f_12(4, 3, 4) برمی‌گرداند 3"}}
{"task_id": "CPP/13", "prompt": {"en": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Calculate the total score for a student based on the scores in different subjects.\n *\n * Parameters:\n * - subject_scores (list): A list containing the scores for each subject.\n *\n * Returns:\n *   int: The total score obtained by summing up the scores in all subjects.\n *\n * Examples:\n *   >>> f_13(100,100,100,100,100)\n *   500\n */\nint f_13(int score1, int score2, int score3, int score4, int score5)", "sq": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Llogarit totalin e pikëve për një student bazuar në pikët në lëndë të ndryshme.\n *\n * Parametrat:\n * - subject_scores (listë): Një listë që përmban pikët për secilën lëndë.\n *\n * Kthen:\n *   int: Totali i pikëve të marra duke mbledhur pikët në të gjitha lëndët.\n *\n * Shembuj:\n *   >>> f_13(100,100,100,100,100)\n *   500\n */\nint f_13(int score1, int score2, int score3, int score4, int score5)", "hy": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Հաշվել ուսանողի ընդհանուր միավորը տարբեր առարկաներում ստացված միավորների հիման վրա:\n *\n * Պարամետրեր:\n * - subject_scores (list): Ցանկ, որը պարունակում է յուրաքանչյուր առարկայի միավորները:\n *\n * Վերադարձնում է:\n *   int: Ընդհանուր միավորը, որը ստացվում է բոլոր առարկաների միավորների գումարով:\n *\n * Օրինակներ:\n *   >>> f_13(100,100,100,100,100)\n *   500\n */\nint f_13(int score1, int score2, int score3, int score4, int score5)", "bn": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * বিভিন্ন বিষয়ে প্রাপ্ত নম্বরের উপর ভিত্তি করে একজন শিক্ষার্থীর মোট স্কোর গণনা করুন।\n *\n * প্যারামিটার:\n * - subject_scores (list): প্রতিটি বিষয়ের নম্বর ধারণকারী একটি তালিকা।\n *\n * রিটার্নস:\n *   int: সমস্ত বিষয়ের নম্বর যোগ করে প্রাপ্ত মোট স্কোর।\n *\n * উদাহরণ:\n *   >>> f_13(100,100,100,100,100)\n *   500\n */\nint f_13(int score1, int score2, int score3, int score4, int score5)", "bg": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Изчислява общия резултат за студент въз основа на оценките в различни предмети.\n *\n * Параметри:\n * - subject_scores (list): Списък, съдържащ оценките за всеки предмет.\n *\n * Връща:\n *   int: Общият резултат, получен чрез сумиране на оценките във всички предмети.\n *\n * Примери:\n *   >>> f_13(100,100,100,100,100)\n *   500\n */\nint f_13(int score1, int score2, int score3, int score4, int score5)", "zh": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * 根据不同科目的分数计算学生的总分。\n *\n * 参数:\n * - subject_scores (list): 包含每个科目分数的列表。\n *\n * 返回:\n *   int: 通过将所有科目的分数相加获得的总分。\n *\n * 示例:\n *   >>> f_13(100,100,100,100,100)\n *   500\n */\nint f_13(int score1, int score2, int score3, int score4, int score5)", "fr": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Calculer le score total pour un étudiant basé sur les scores dans différentes matières.\n *\n * Paramètres :\n * - subject_scores (list): Une liste contenant les scores pour chaque matière.\n *\n * Renvoie :\n *   int : Le score total obtenu en additionnant les scores de toutes les matières.\n *\n * Exemples :\n *   >>> f_13(100,100,100,100,100)\n *   500\n */\nint f_13(int score1, int score2, int score3, int score4, int score5)", "de": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Berechnet die Gesamtpunktzahl für einen Schüler basierend auf den Punkten in verschiedenen Fächern.\n *\n * Parameter:\n * - subject_scores (list): Eine Liste, die die Punkte für jedes Fach enthält.\n *\n * Rückgabe:\n *   int: Die Gesamtpunktzahl, die durch das Summieren der Punkte in allen Fächern erzielt wird.\n *\n * Beispiele:\n *   >>> f_13(100,100,100,100,100)\n *   500\n */\nint f_13(int score1, int score2, int score3, int score4, int score5)", "ha": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Lissafi jimillar maki ga ɗalibi bisa ga maki a fannoni daban-daban.\n *\n * Sigogi:\n * - subject_scores (list): Jerin da ke ɗauke da maki na kowane fanni.\n *\n * Komawa:\n *   int: Jimillar maki da aka samu ta hanyar tara maki a dukkan fannoni.\n *\n * Misalai:\n *   >>> f_13(100,100,100,100,100)\n *   500\n */\nint f_13(int score1, int score2, int score3, int score4, int score5)", "hi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * विभिन्न विषयों में अंकों के आधार पर एक छात्र के लिए कुल स्कोर की गणना करें।\n *\n * पैरामीटर्स:\n * - subject_scores (list): प्रत्येक विषय के लिए अंकों की सूची।\n *\n * रिटर्न करता है:\n *   int: सभी विषयों में अंकों को जोड़कर प्राप्त कुल स्कोर।\n *\n * उदाहरण:\n *   >>> f_13(100,100,100,100,100)\n *   500\n */\nint f_13(int score1, int score2, int score3, int score4, int score5)", "hu": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Számítsa ki a diák összpontszámát a különböző tantárgyakban elért pontszámok alapján.\n *\n * Paraméterek:\n * - subject_scores (list): Egy lista, amely tartalmazza az egyes tantárgyak pontszámait.\n *\n * Visszatér:\n *   int: Az összpontszám, amelyet az összes tantárgy pontszámainak összeadásával kapunk.\n *\n * Példák:\n *   >>> f_13(100,100,100,100,100)\n *   500\n */\nint f_13(int score1, int score2, int score3, int score4, int score5)", "es": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Calcular la puntuación total para un estudiante basada en las puntuaciones en diferentes materias.\n *\n * Parámetros:\n * - subject_scores (list): Una lista que contiene las puntuaciones para cada materia.\n *\n * Retorna:\n *   int: La puntuación total obtenida al sumar las puntuaciones en todas las materias.\n *\n * Ejemplos:\n *   >>> f_13(100,100,100,100,100)\n *   500\n */\nint f_13(int score1, int score2, int score3, int score4, int score5)", "arb": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * حساب المجموع الكلي للدرجات لطالب بناءً على الدرجات في مواد مختلفة.\n *\n * المعلمات:\n * - subject_scores (list): قائمة تحتوي على الدرجات لكل مادة.\n *\n * العوائد:\n *   int: المجموع الكلي للدرجات المحصل عليه بجمع الدرجات في جميع المواد.\n *\n * أمثلة:\n *   >>> f_13(100,100,100,100,100)\n *   500\n */\nint f_13(int score1, int score2, int score3, int score4, int score5)", "sw": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Hesabu jumla ya alama kwa mwanafunzi kulingana na alama katika masomo tofauti.\n *\n * Vigezo:\n * - subject_scores (list): Orodha inayojumuisha alama za kila somo.\n *\n * Inarejesha:\n *   int: Jumla ya alama iliyopatikana kwa kujumlisha alama katika masomo yote.\n *\n * Mifano:\n *   >>> f_13(100,100,100,100,100)\n *   500\n */\nint f_13(int score1, int score2, int score3, int score4, int score5)", "tr": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Farklı derslerdeki puanlara göre bir öğrencinin toplam puanını hesaplayın.\n *\n * Parametreler:\n * - subject_scores (list): Her ders için puanları içeren bir liste.\n *\n * Döndürür:\n *   int: Tüm derslerdeki puanların toplanmasıyla elde edilen toplam puan.\n *\n * Örnekler:\n *   >>> f_13(100,100,100,100,100)\n *   500\n */\nint f_13(int score1, int score2, int score3, int score4, int score5)", "vi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Tính tổng điểm cho một học sinh dựa trên điểm số trong các môn học khác nhau.\n *\n * Tham số:\n * - subject_scores (list): Một danh sách chứa điểm số cho mỗi môn học.\n *\n * Trả về:\n *   int: Tổng điểm đạt được bằng cách cộng điểm số trong tất cả các môn học.\n *\n * Ví dụ:\n *   >>> f_13(100,100,100,100,100)\n *   500\n */\nint f_13(int score1, int score2, int score3, int score4, int score5)", "id": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Menghitung total skor untuk seorang siswa berdasarkan skor dalam berbagai mata pelajaran.\n *\n * Parameter:\n * - subject_scores (list): Sebuah daftar yang berisi skor untuk setiap mata pelajaran.\n *\n * Mengembalikan:\n *   int: Total skor yang diperoleh dengan menjumlahkan skor di semua mata pelajaran.\n *\n * Contoh:\n *   >>> f_13(100,100,100,100,100)\n *   500\n */\nint f_13(int score1, int score2, int score3, int score4, int score5)", "ja": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * 異なる科目のスコアに基づいて学生の合計スコアを計算します。\n *\n * パラメータ:\n * - subject_scores (list): 各科目のスコアを含むリスト。\n *\n * 戻り値:\n *   int: すべての科目のスコアを合計した合計スコア。\n *\n * 例:\n *   >>> f_13(100,100,100,100,100)\n *   500\n */\nint f_13(int score1, int score2, int score3, int score4, int score5)", "ko": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * 학생의 다양한 과목 점수를 기반으로 총 점수를 계산합니다.\n *\n * 매개변수:\n * - subject_scores (list): 각 과목의 점수를 포함하는 리스트입니다.\n *\n * 반환값:\n *   int: 모든 과목의 점수를 합산하여 얻은 총 점수입니다.\n *\n * 예시:\n *   >>> f_13(100,100,100,100,100)\n *   500\n */\nint f_13(int score1, int score2, int score3, int score4, int score5)", "ml": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * വിവിധ വിഷയങ്ങളിലെ സ്കോറുകളുടെ അടിസ്ഥാനത്തിൽ ഒരു വിദ്യാർത്ഥിയുടെ മൊത്തം സ്കോർ കണക്കാക്കുക.\n *\n * പാരാമീറ്ററുകൾ:\n * - subject_scores (list): ഓരോ വിഷയത്തിന്റെയും സ്കോറുകൾ അടങ്ങിയ ഒരു പട്ടിക.\n *\n * റിട്ടേൺസ്:\n *   int: എല്ലാ വിഷയങ്ങളിലെയും സ്കോറുകൾ കൂട്ടിച്ചേർത്തു ലഭിക്കുന്ന മൊത്തം സ്കോർ.\n *\n * ഉദാഹരണങ്ങൾ:\n *   >>> f_13(100,100,100,100,100)\n *   500\n */\nint f_13(int score1, int score2, int score3, int score4, int score5)", "fa": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * محاسبه امتیاز کل برای یک دانش‌آموز بر اساس امتیازات در موضوعات مختلف.\n *\n * پارامترها:\n * - subject_scores (list): لیستی که شامل امتیازات هر موضوع است.\n *\n * بازگشت:\n *   int: امتیاز کل که با جمع کردن امتیازات در همه موضوعات به دست می‌آید.\n *\n * مثال‌ها:\n *   >>> f_13(100,100,100,100,100)\n *   500\n */\nint f_13(int score1, int score2, int score3, int score4, int score5)"}, "canonical_solution": "{\n    return score1 + score2 + score3 + score4 + score5;\n}", "instruction": {"en": "Write a CPP function `int f_13(int score1, int score2, int score3, int score4, int score5)` to solve the following problem:\nCalculate the total score for a student based on the scores in different subjects.\n\nParameters:\n- score1 (int): The score for the first subject.\n- score2 (int): The score for the second subject.\n- score3 (int): The score for the third subject.\n- score4 (int): The score for the fourth subject.\n- score5 (int): The score for the fifth subject.\n\nReturns:\n  int: The total score obtained by summing up the scores in all subjects.\n\nExamples:\n  >>> f_13(100,100,100,100,100)\n  500\n", "sq": "Shkruani një funksion CPP `int f_13(int score1, int score2, int score3, int score4, int score5)` për të zgjidhur problemin e mëposhtëm:\nLlogaritni totalin e pikëve për një student bazuar në pikët në lëndë të ndryshme.\n\nParametrat:\n- score1 (int): Pikët për lëndën e parë.\n- score2 (int): Pikët për lëndën e dytë.\n- score3 (int): Pikët për lëndën e tretë.\n- score4 (int): Pikët për lëndën e katërt.\n- score5 (int): Pikët për lëndën e pestë.\n\nKthen:\n  int: Totali i pikëve të marra duke mbledhur pikët në të gjitha lëndët.\n\nShembuj:\n  >>> f_13(100,100,100,100,100)\n  500", "hy": "Գրեք CPP ֆունկցիա `int f_13(int score1, int score2, int score3, int score4, int score5)` հետևյալ խնդիրը լուծելու համար:\nՀաշվարկել ուսանողի ընդհանուր միավորը տարբեր առարկաներում ստացված միավորների հիման վրա:\n\nՊարամետրեր:\n- score1 (int): Առաջին առարկայի միավորը:\n- score2 (int): Երկրորդ առարկայի միավորը:\n- score3 (int): Երրորդ առարկայի միավորը:\n- score4 (int): Չորրորդ առարկայի միավորը:\n- score5 (int): Հինգերորդ առարկայի միավորը:\n\nՎերադարձնում է:\n  int: Ընդհանուր միավորը, որը ստացվում է բոլոր առարկաների միավորների գումարով:\n\nՕրինակներ:\n  >>> f_13(100,100,100,100,100)\n  500", "bn": "একটি CPP ফাংশন `int f_13(int score1, int score2, int score3, int score4, int score5)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nবিভিন্ন বিষয়ের স্কোরের উপর ভিত্তি করে একজন শিক্ষার্থীর মোট স্কোর গণনা করুন।\n\nপ্যারামিটার:\n- score1 (int): প্রথম বিষয়ের জন্য স্কোর।\n- score2 (int): দ্বিতীয় বিষয়ের জন্য স্কোর।\n- score3 (int): তৃতীয় বিষয়ের জন্য স্কোর।\n- score4 (int): চতুর্থ বিষয়ের জন্য স্কোর।\n- score5 (int): পঞ্চম বিষয়ের জন্য স্কোর।\n\nরিটার্নস:\n  int: সমস্ত বিষয়ের স্কোর যোগ করে প্রাপ্ত মোট স্কোর।\n\nউদাহরণ:\n  >>> f_13(100,100,100,100,100)\n  500", "bg": "Напишете CPP функция `int f_13(int score1, int score2, int score3, int score4, int score5)` за решаване на следния проблем:\nИзчислете общия резултат за студент въз основа на резултатите в различни предмети.\n\nПараметри:\n- score1 (int): Резултатът за първия предмет.\n- score2 (int): Резултатът за втория предмет.\n- score3 (int): Резултатът за третия предмет.\n- score4 (int): Резултатът за четвъртия предмет.\n- score5 (int): Резултатът за петия предмет.\n\nВръща:\n  int: Общият резултат, получен чрез сумиране на резултатите във всички предмети.\n\nПримери:\n  >>> f_13(100,100,100,100,100)\n  500", "zh": "编写一个 CPP 函数 `int f_13(int score1, int score2, int score3, int score4, int score5)` 来解决以下问题：\n计算学生在不同科目中的总分。\n\n参数：\n- score1 (int): 第一科目的分数。\n- score2 (int): 第二科目的分数。\n- score3 (int): 第三科目的分数。\n- score4 (int): 第四科目的分数。\n- score5 (int): 第五科目的分数。\n\n返回：\n  int: 通过将所有科目的分数相加得到的总分。\n\n例子：\n  >>> f_13(100,100,100,100,100)\n  500", "fr": "Écrire une fonction CPP `int f_13(int score1, int score2, int score3, int score4, int score5)` pour résoudre le problème suivant :  \nCalculer le score total pour un étudiant basé sur les scores dans différentes matières.\n\nParamètres :\n- score1 (int) : Le score pour la première matière.\n- score2 (int) : Le score pour la deuxième matière.\n- score3 (int) : Le score pour la troisième matière.\n- score4 (int) : Le score pour la quatrième matière.\n- score5 (int) : Le score pour la cinquième matière.\n\nRenvoie :\n  int : Le score total obtenu en additionnant les scores dans toutes les matières.\n\nExemples :\n  >>> f_13(100,100,100,100,100)\n  500", "de": "Schreiben Sie eine CPP-Funktion `int f_13(int score1, int score2, int score3, int score4, int score5)`, um das folgende Problem zu lösen:\nBerechnen Sie die Gesamtpunktzahl für einen Schüler basierend auf den Punktzahlen in verschiedenen Fächern.\n\nParameter:\n- score1 (int): Die Punktzahl für das erste Fach.\n- score2 (int): Die Punktzahl für das zweite Fach.\n- score3 (int): Die Punktzahl für das dritte Fach.\n- score4 (int): Die Punktzahl für das vierte Fach.\n- score5 (int): Die Punktzahl für das fünfte Fach.\n\nRückgabewert:\n  int: Die Gesamtpunktzahl, die durch das Summieren der Punktzahlen in allen Fächern erhalten wird.\n\nBeispiele:\n  >>> f_13(100,100,100,100,100)\n  500", "ha": "Rubuta aikin CPP `int f_13(int score1, int score2, int score3, int score4, int score5)` don warware matsalar mai zuwa:\nƘididdige jimlar maki ga ɗalibi bisa ga maki a fannoni daban-daban.\n\nSigogi:\n- score1 (int): Makin fanni na farko.\n- score2 (int): Makin fanni na biyu.\n- score3 (int): Makin fanni na uku.\n- score4 (int): Makin fanni na huɗu.\n- score5 (int): Makin fanni na biyar.\n\nMayarwa:\n  int: Jimlar maki da aka samu ta hanyar tara maki a dukkan fannoni.\n\nMisalai:\n  >>> f_13(100,100,100,100,100)\n  500", "hi": "एक CPP फ़ंक्शन `int f_13(int score1, int score2, int score3, int score4, int score5)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nविभिन्न विषयों में अंकों के आधार पर एक छात्र के लिए कुल अंक की गणना करें।\n\nपैरामीटर्स:\n- score1 (int): पहले विषय के लिए अंक।\n- score2 (int): दूसरे विषय के लिए अंक।\n- score3 (int): तीसरे विषय के लिए अंक।\n- score4 (int): चौथे विषय के लिए अंक।\n- score5 (int): पांचवें विषय के लिए अंक।\n\nवापसी मान:\n  int: सभी विषयों के अंकों को जोड़कर प्राप्त कुल अंक।\n\nउदाहरण:\n  >>> f_13(100,100,100,100,100)\n  500", "hu": "Írj egy CPP függvényt `int f_13(int score1, int score2, int score3, int score4, int score5)` a következő probléma megoldására:\nSzámítsd ki a diák összpontszámát a különböző tantárgyakban elért pontszámok alapján.\n\nParaméterek:\n- score1 (int): Az első tantárgy pontszáma.\n- score2 (int): A második tantárgy pontszáma.\n- score3 (int): A harmadik tantárgy pontszáma.\n- score4 (int): A negyedik tantárgy pontszáma.\n- score5 (int): Az ötödik tantárgy pontszáma.\n\nVisszatérési érték:\n  int: Az összpontszám, amelyet az összes tantárgy pontszámainak összeadásával kapunk.\n\nPéldák:\n  >>> f_13(100,100,100,100,100)\n  500", "es": "Escribe una función CPP `int f_13(int score1, int score2, int score3, int score4, int score5)` para resolver el siguiente problema:\nCalcular la puntuación total de un estudiante basada en las puntuaciones en diferentes materias.\n\nParámetros:\n- score1 (int): La puntuación para la primera materia.\n- score2 (int): La puntuación para la segunda materia.\n- score3 (int): La puntuación para la tercera materia.\n- score4 (int): La puntuación para la cuarta materia.\n- score5 (int): La puntuación para la quinta materia.\n\nDevuelve:\n  int: La puntuación total obtenida al sumar las puntuaciones en todas las materias.\n\nEjemplos:\n  >>> f_13(100,100,100,100,100)\n  500", "arb": "اكتب دالة CPP `int f_13(int score1, int score2, int score3, int score4, int score5)` لحل المشكلة التالية:\nاحسب المجموع الكلي للدرجات لطالب بناءً على الدرجات في مواد مختلفة.\n\nالمعلمات:\n- score1 (int): الدرجة للموضوع الأول.\n- score2 (int): الدرجة للموضوع الثاني.\n- score3 (int): الدرجة للموضوع الثالث.\n- score4 (int): الدرجة للموضوع الرابع.\n- score5 (int): الدرجة للموضوع الخامس.\n\nالإرجاع:\n  int: المجموع الكلي للدرجات المحصل عليه بجمع الدرجات في جميع المواد.\n\nأمثلة:\n  >>> f_13(100,100,100,100,100)\n  500", "sw": "Andika kazi ya CPP `int f_13(int score1, int score2, int score3, int score4, int score5)` kutatua tatizo lifuatalo:\nHesabu jumla ya alama kwa mwanafunzi kulingana na alama katika masomo tofauti.\n\nVigezo:\n- score1 (int): Alama kwa somo la kwanza.\n- score2 (int): Alama kwa somo la pili.\n- score3 (int): Alama kwa somo la tatu.\n- score4 (int): Alama kwa somo la nne.\n- score5 (int): Alama kwa somo la tano.\n\nInarejesha:\n  int: Jumla ya alama inayopatikana kwa kujumlisha alama katika masomo yote.\n\nMifano:\n  >>> f_13(100,100,100,100,100)\n  500", "tr": "Bir CPP fonksiyonu `int f_13(int score1, int score2, int score3, int score4, int score5)` yazarak aşağıdaki problemi çözün:\nFarklı derslerdeki puanlara dayalı olarak bir öğrencinin toplam puanını hesaplayın.\n\nParametreler:\n- score1 (int): Birinci dersin puanı.\n- score2 (int): İkinci dersin puanı.\n- score3 (int): Üçüncü dersin puanı.\n- score4 (int): Dördüncü dersin puanı.\n- score5 (int): Beşinci dersin puanı.\n\nDöndürür:\n  int: Tüm derslerdeki puanların toplamını alarak elde edilen toplam puan.\n\nÖrnekler:\n  >>> f_13(100,100,100,100,100)\n  500", "vi": "Viết một hàm CPP `int f_13(int score1, int score2, int score3, int score4, int score5)` để giải quyết vấn đề sau:\nTính tổng điểm cho một học sinh dựa trên điểm số trong các môn học khác nhau.\n\nTham số:\n- score1 (int): Điểm số cho môn học thứ nhất.\n- score2 (int): Điểm số cho môn học thứ hai.\n- score3 (int): Điểm số cho môn học thứ ba.\n- score4 (int): Điểm số cho môn học thứ tư.\n- score5 (int): Điểm số cho môn học thứ năm.\n\nTrả về:\n  int: Tổng điểm đạt được bằng cách cộng các điểm số trong tất cả các môn học.\n\nVí dụ:\n  >>> f_13(100,100,100,100,100)\n  500", "id": "Tulis fungsi CPP `int f_13(int score1, int score2, int score3, int score4, int score5)` untuk menyelesaikan masalah berikut:\nHitung total skor untuk seorang siswa berdasarkan skor dalam berbagai mata pelajaran.\n\nParameter:\n- score1 (int): Skor untuk mata pelajaran pertama.\n- score2 (int): Skor untuk mata pelajaran kedua.\n- score3 (int): Skor untuk mata pelajaran ketiga.\n- score4 (int): Skor untuk mata pelajaran keempat.\n- score5 (int): Skor untuk mata pelajaran kelima.\n\nMengembalikan:\n  int: Total skor yang diperoleh dengan menjumlahkan skor di semua mata pelajaran.\n\nContoh:\n  >>> f_13(100,100,100,100,100)\n  500", "ja": "以下の問題を解決するためのCPP関数 `int f_13(int score1, int score2, int score3, int score4, int score5)` を作成してください:\n異なる科目のスコアに基づいて学生の合計スコアを計算します。\n\nパラメータ:\n- score1 (int): 最初の科目のスコア。\n- score2 (int): 2番目の科目のスコア。\n- score3 (int): 3番目の科目のスコア。\n- score4 (int): 4番目の科目のスコア。\n- score5 (int): 5番目の科目のスコア。\n\n戻り値:\n  int: すべての科目のスコアを合計して得られる合計スコア。\n\n例:\n  >>> f_13(100,100,100,100,100)\n  500", "ko": "CPP 함수를 작성하세요 `int f_13(int score1, int score2, int score3, int score4, int score5)` 다음 문제를 해결하기 위해:\n다양한 과목의 점수를 기반으로 학생의 총 점수를 계산합니다.\n\n매개변수:\n- score1 (int): 첫 번째 과목의 점수.\n- score2 (int): 두 번째 과목의 점수.\n- score3 (int): 세 번째 과목의 점수.\n- score4 (int): 네 번째 과목의 점수.\n- score5 (int): 다섯 번째 과목의 점수.\n\n반환값:\n  int: 모든 과목의 점수를 합산하여 얻은 총 점수.\n\n예시:\n  >>> f_13(100,100,100,100,100)\n  500", "ml": "ഒരു സിപിപി ഫംഗ്ഷൻ എഴുതുക `int f_13(int score1, int score2, int score3, int score4, int score5)` എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nവിഭിന്ന വിഷയങ്ങളിലെ സ്കോറുകൾ അടിസ്ഥാനമാക്കി ഒരു വിദ്യാർത്ഥിയുടെ മൊത്തം സ്കോർ കണക്കാക്കുക.\n\nപാരാമീറ്ററുകൾ:\n- score1 (int): ആദ്യ വിഷയത്തിനുള്ള സ്കോർ.\n- score2 (int): രണ്ടാം വിഷയത്തിനുള്ള സ്കോർ.\n- score3 (int): മൂന്നാം വിഷയത്തിനുള്ള സ്കോർ.\n- score4 (int): നാലാം വിഷയത്തിനുള്ള സ്കോർ.\n- score5 (int): അഞ്ചാം വിഷയത്തിനുള്ള സ്കോർ.\n\nമടക്കാൻ:\n  int: എല്ലാ വിഷയങ്ങളിലെ സ്കോറുകൾ കൂട്ടിച്ചേർത്തു ലഭിക്കുന്ന മൊത്തം സ്കോർ.\n\nഉദാഹരണങ്ങൾ:\n  >>> f_13(100,100,100,100,100)\n  500", "fa": "یک تابع CPP بنویسید `int f_13(int score1, int score2, int score3, int score4, int score5)` تا مسئله زیر را حل کند:\nمحاسبه نمره کل برای یک دانش‌آموز بر اساس نمرات در موضوعات مختلف.\n\nپارامترها:\n- score1 (int): نمره برای موضوع اول.\n- score2 (int): نمره برای موضوع دوم.\n- score3 (int): نمره برای موضوع سوم.\n- score4 (int): نمره برای موضوع چهارم.\n- score5 (int): نمره برای موضوع پنجم.\n\nبازگشت:\n  int: نمره کل به‌دست‌آمده با جمع کردن نمرات در تمام موضوعات.\n\nمثال‌ها:\n  >>> f_13(100,100,100,100,100)\n  500"}, "level": "easy", "test": "int main() {\n    assert(f_13(100,100,100,100,100) == 500);\n    assert(f_13(0,0,0,0,0) == 0);\n    assert(f_13(20, 30, 40, 10, 50) == 150);\n    assert(f_13(23, 45, 67, 89, 12) == 236);\n    assert(f_13(5, 5, 5, 5, 5) == 25);\n    return 0;\n}", "entry_point": "f_13", "signature": "int f_13(int score1, int score2, int score3, int score4, int score5)", "docstring": {"en": "Calculate the total score for a student based on the scores in different subjects.\n\nParameters:\n- score1 (int): The score for the first subject.\n- score2 (int): The score for the second subject.\n- score3 (int): The score for the third subject.\n- score4 (int): The score for the fourth subject.\n- score5 (int): The score for the fifth subject.\n\nReturns:\n  int: The total score obtained by summing up the scores in all subjects.\n\nExamples:\n  >>> f_13(100,100,100,100,100)\n  500\n", "sq": "Llogaritni rezultatin total për një student bazuar në rezultatet në lëndë të ndryshme.\n\nParametrat:\n- score1 (int): Rezultati për lëndën e parë.\n- score2 (int): Rezultati për lëndën e dytë.\n- score3 (int): Rezultati për lëndën e tretë.\n- score4 (int): Rezultati për lëndën e katërt.\n- score5 (int): Rezultati për lëndën e pestë.\n\nKthen:\n  int: Rezultati total i marrë duke mbledhur rezultatet në të gjitha lëndët.\n\nShembuj:\n  >>> f_13(100,100,100,100,100)\n  500", "hy": "Հաշվարկել ուսանողի ընդհանուր միավորը տարբեր առարկաներում ստացված միավորների հիման վրա:\n\nՊարամետրեր:\n- score1 (int): Առաջին առարկայի միավորը:\n- score2 (int): Երկրորդ առարկայի միավորը:\n- score3 (int): Երրորդ առարկայի միավորը:\n- score4 (int): Չորրորդ առարկայի միավորը:\n- score5 (int): Հինգերորդ առարկայի միավորը:\n\nՎերադարձնում է:\n  int: Ընդհանուր միավորը, որը ստացվում է բոլոր առարկաների միավորների գումարով:\n\nՕրինակներ:\n  >>> f_13(100,100,100,100,100)\n  500", "bn": "একজন শিক্ষার্থীর বিভিন্ন বিষয়ে প্রাপ্ত নম্বরের ভিত্তিতে মোট স্কোর গণনা করুন।\n\nপ্যারামিটারসমূহ:\n- score1 (int): প্রথম বিষয়ের নম্বর।\n- score2 (int): দ্বিতীয় বিষয়ের নম্বর।\n- score3 (int): তৃতীয় বিষয়ের নম্বর।\n- score4 (int): চতুর্থ বিষয়ের নম্বর।\n- score5 (int): পঞ্চম বিষয়ের নম্বর।\n\nফেরত দেয়:\n  int: সব বিষয়ের নম্বর যোগ করে প্রাপ্ত মোট স্কোর।\n\nউদাহরণ:\n  >>> f_13(100,100,100,100,100)\n  500", "bg": "Изчислява общия резултат за студент въз основа на резултатите по различни предмети.\n\nПараметри:\n- score1 (int): Резултатът за първия предмет.\n- score2 (int): Резултатът за втория предмет.\n- score3 (int): Резултатът за третия предмет.\n- score4 (int): Резултатът за четвъртия предмет.\n- score5 (int): Резултатът за петия предмет.\n\nВръща:\n  int: Общият резултат, получен чрез сумиране на резултатите по всички предмети.\n\nПримери:\n  >>> f_13(100,100,100,100,100)\n  500", "zh": "计算学生在不同科目中的总分。\n\n参数：\n- score1 (int): 第一科目的分数。\n- score2 (int): 第二科目的分数。\n- score3 (int): 第三科目的分数。\n- score4 (int): 第四科目的分数。\n- score5 (int): 第五科目的分数。\n\n返回：\n  int: 通过将所有科目的分数相加得到的总分。\n\n示例：\n  >>> f_13(100,100,100,100,100)\n  500", "fr": "Calculer le score total pour un étudiant basé sur les scores dans différentes matières.\n\nParamètres:\n- score1 (int): Le score pour la première matière.\n- score2 (int): Le score pour la deuxième matière.\n- score3 (int): Le score pour la troisième matière.\n- score4 (int): Le score pour la quatrième matière.\n- score5 (int): Le score pour la cinquième matière.\n\nRenvoie:\n  int: Le score total obtenu en additionnant les scores dans toutes les matières.\n\nExemples:\n  >>> f_13(100,100,100,100,100)\n  500", "de": "Berechnen Sie die Gesamtpunktzahl für einen Schüler basierend auf den Punkten in verschiedenen Fächern.\n\nParameter:\n- score1 (int): Die Punktzahl für das erste Fach.\n- score2 (int): Die Punktzahl für das zweite Fach.\n- score3 (int): Die Punktzahl für das dritte Fach.\n- score4 (int): Die Punktzahl für das vierte Fach.\n- score5 (int): Die Punktzahl für das fünfte Fach.\n\nRückgabewert:\n  int: Die Gesamtpunktzahl, die durch das Aufsummieren der Punkte in allen Fächern erzielt wird.\n\nBeispiele:\n  >>> f_13(100,100,100,100,100)\n  500", "ha": "Ƙididdige jimillar maki ga ɗalibi bisa ga maki a fannoni daban-daban.\n\nSigogi:\n- score1 (int): Makin fanni na farko.\n- score2 (int): Makin fanni na biyu.\n- score3 (int): Makin fanni na uku.\n- score4 (int): Makin fanni na huɗu.\n- score5 (int): Makin fanni na biyar.\n\nDawowa:\n  int: Jimillar maki da aka samu ta hanyar tara maki a duk fannoni.\n\nMisalai:\n  >>> f_13(100,100,100,100,100)\n  500", "hi": "विभिन्न विषयों में अंकों के आधार पर एक छात्र के लिए कुल स्कोर की गणना करें।\n\nमापदंड:\n- score1 (int): पहले विषय के लिए अंक।\n- score2 (int): दूसरे विषय के लिए अंक।\n- score3 (int): तीसरे विषय के लिए अंक।\n- score4 (int): चौथे विषय के लिए अंक।\n- score5 (int): पांचवें विषय के लिए अंक।\n\nवापसी:\n  int: सभी विषयों में अंकों को जोड़कर प्राप्त कुल अंक।\n\nउदाहरण:\n  >>> f_13(100,100,100,100,100)\n  500", "hu": "Számítsa ki a diák összpontszámát a különböző tantárgyakban elért pontszámok alapján.\n\nParaméterek:\n- score1 (int): Az első tantárgy pontszáma.\n- score2 (int): A második tantárgy pontszáma.\n- score3 (int): A harmadik tantárgy pontszáma.\n- score4 (int): A negyedik tantárgy pontszáma.\n- score5 (int): Az ötödik tantárgy pontszáma.\n\nVisszatér:\n  int: Az összpontszám, amelyet az összes tantárgy pontszámának összeadásával kapunk.\n\nPéldák:\n  >>> f_13(100,100,100,100,100)\n  500", "es": "Calcular la puntuación total para un estudiante basado en las puntuaciones en diferentes materias.\n\nParámetros:\n- score1 (int): La puntuación para la primera materia.\n- score2 (int): La puntuación para la segunda materia.\n- score3 (int): La puntuación para la tercera materia.\n- score4 (int): La puntuación para la cuarta materia.\n- score5 (int): La puntuación para la quinta materia.\n\nDevuelve:\n  int: La puntuación total obtenida al sumar las puntuaciones en todas las materias.\n\nEjemplos:\n  >>> f_13(100,100,100,100,100)\n  500", "arb": "احسب المجموع الكلي للدرجات لطالب بناءً على الدرجات في مواد مختلفة.\n\nالمعلمات:\n- score1 (int): الدرجة للموضوع الأول.\n- score2 (int): الدرجة للموضوع الثاني.\n- score3 (int): الدرجة للموضوع الثالث.\n- score4 (int): الدرجة للموضوع الرابع.\n- score5 (int): الدرجة للموضوع الخامس.\n\nالقيم المعادة:\n  int: المجموع الكلي للدرجات الناتج عن جمع الدرجات في جميع المواد.\n\nأمثلة:\n  >>> f_13(100,100,100,100,100)\n  500", "sw": "Hesabu jumla ya alama kwa mwanafunzi kulingana na alama katika masomo tofauti.\n\nVigezo:\n- score1 (int): Alama ya somo la kwanza.\n- score2 (int): Alama ya somo la pili.\n- score3 (int): Alama ya somo la tatu.\n- score4 (int): Alama ya somo la nne.\n- score5 (int): Alama ya somo la tano.\n\nInarejesha:\n  int: Jumla ya alama iliyopatikana kwa kujumlisha alama katika masomo yote.\n\nMifano:\n  >>> f_13(100,100,100,100,100)\n  500", "tr": "Bir öğrencinin farklı derslerdeki puanlarına göre toplam puanını hesaplayın.\n\nParametreler:\n- score1 (int): Birinci dersin puanı.\n- score2 (int): İkinci dersin puanı.\n- score3 (int): Üçüncü dersin puanı.\n- score4 (int): Dördüncü dersin puanı.\n- score5 (int): Beşinci dersin puanı.\n\nDöndürür:\n  int: Tüm derslerdeki puanların toplamıyla elde edilen toplam puan.\n\nÖrnekler:\n  >>> f_13(100,100,100,100,100)\n  500", "vi": "Tính tổng điểm cho một học sinh dựa trên điểm số trong các môn học khác nhau.\n\nTham số:\n- score1 (int): Điểm số cho môn học thứ nhất.\n- score2 (int): Điểm số cho môn học thứ hai.\n- score3 (int): Điểm số cho môn học thứ ba.\n- score4 (int): Điểm số cho môn học thứ tư.\n- score5 (int): Điểm số cho môn học thứ năm.\n\nTrả về:\n  int: Tổng điểm đạt được bằng cách cộng điểm số trong tất cả các môn học.\n\nVí dụ:\n  >>> f_13(100,100,100,100,100)\n  500", "id": "Hitung total skor untuk seorang siswa berdasarkan skor dalam berbagai mata pelajaran.\n\nParameter:\n- score1 (int): Skor untuk mata pelajaran pertama.\n- score2 (int): Skor untuk mata pelajaran kedua.\n- score3 (int): Skor untuk mata pelajaran ketiga.\n- score4 (int): Skor untuk mata pelajaran keempat.\n- score5 (int): Skor untuk mata pelajaran kelima.\n\nMengembalikan:\n  int: Total skor yang diperoleh dengan menjumlahkan skor di semua mata pelajaran.\n\nContoh:\n  >>> f_13(100,100,100,100,100)\n  500", "ja": "学生の異なる科目のスコアに基づいて総合スコアを計算します。\n\nパラメータ:\n- score1 (int): 最初の科目のスコア。\n- score2 (int): 2番目の科目のスコア。\n- score3 (int): 3番目の科目のスコア。\n- score4 (int): 4番目の科目のスコア。\n- score5 (int): 5番目の科目のスコア。\n\n戻り値:\n  int: すべての科目のスコアを合計して得られる総合スコア。\n\n例:\n  >>> f_13(100,100,100,100,100)\n  500", "ko": "학생의 다양한 과목 점수를 기반으로 총 점수를 계산합니다.\n\n매개변수:\n- score1 (int): 첫 번째 과목의 점수.\n- score2 (int): 두 번째 과목의 점수.\n- score3 (int): 세 번째 과목의 점수.\n- score4 (int): 네 번째 과목의 점수.\n- score5 (int): 다섯 번째 과목의 점수.\n\n반환값:\n  int: 모든 과목의 점수를 합산하여 얻은 총 점수.\n\n예제:\n  >>> f_13(100,100,100,100,100)\n  500", "ml": "വിദ്യാർത്ഥിയുടെ വിവിധ വിഷയങ്ങളിലെ മാർക്കുകൾ അടിസ്ഥാനമാക്കി ആകെ സ്കോർ കണക്കാക്കുക.\n\nപാരാമീറ്ററുകൾ:\n- score1 (int): ആദ്യ വിഷയത്തിന്റെ സ്കോർ.\n- score2 (int): രണ്ടാം വിഷയത്തിന്റെ സ്കോർ.\n- score3 (int): മൂന്നാം വിഷയത്തിന്റെ സ്കോർ.\n- score4 (int): നാലാം വിഷയത്തിന്റെ സ്കോർ.\n- score5 (int): അഞ്ചാം വിഷയത്തിന്റെ സ്കോർ.\n\nമടക്കം:\n  int: എല്ലാ വിഷയങ്ങളിലെ സ്കോറുകൾ കൂട്ടിച്ചേർത്തു ലഭിക്കുന്ന ആകെ സ്കോർ.\n\nഉദാഹരണങ്ങൾ:\n  >>> f_13(100,100,100,100,100)\n  500", "fa": "محاسبه نمره کل برای یک دانش‌آموز بر اساس نمرات در موضوعات مختلف.\n\nپارامترها:\n- score1 (int): نمره برای موضوع اول.\n- score2 (int): نمره برای موضوع دوم.\n- score3 (int): نمره برای موضوع سوم.\n- score4 (int): نمره برای موضوع چهارم.\n- score5 (int): نمره برای موضوع پنجم.\n\nبازگشت:\n  int: نمره کل به‌دست‌آمده با جمع کردن نمرات در همه موضوعات.\n\nمثال‌ها:\n  >>> f_13(100,100,100,100,100)\n  500"}}
{"task_id": "CPP/14", "prompt": {"en": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/*\nDecode a series of numbers to reveal the pattern and understand the actual values \neach digit represents.\n\nEquations provided for reference:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParameters:\n- data_str: A constant character array (C-style string) representing a series of numbers. Length does not exceed 100.\n\nReturns:\nint: The result of each data string corresponding to the right-hand side of the equation.\n\nExample usage:\nassert(f_14(\"0000\") == 4);\n*/\nint f_14(const char* data_str)", "sq": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/*\nDekodo një seri numrash për të zbuluar modelin dhe për të kuptuar vlerat aktuale \nqë përfaqëson secila shifër.\n\nEkuacionet e dhëna për referencë:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParametrat:\n- data_str: Një varg karakteresh konstant (string në stilin C) që përfaqëson një seri numrash. Gjatësia nuk e tejkalon 100.\n\nKthen:\nint: Rezultati i secilit varg të dhënash që korrespondon me anën e djathtë të ekuacionit.\n\nShembull përdorimi:\nassert(f_14(\"0000\") == 4);\n*/\nint f_14(const char* data_str)", "hy": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/*\nՎերծանել թվերի շարք՝ բացահայտելու օրինաչափությունը և հասկանալու, թե իրականում ինչ արժեքներ են ներկայացնում\nյուրաքանչյուր թվանշան:\n\nՀաշվարկները տրամադրված են հղման համար:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nՊարամետրեր:\n- data_str: Կոնստանտ սիմվոլային զանգված (C-ոճի տող), որը ներկայացնում է թվերի շարք: Երկարությունը չի գերազանցում 100-ը:\n\nՎերադարձնում է:\nint: Յուրաքանչյուր տվյալների տողի արդյունքը, որը համապատասխանում է հավասարման աջ կողմին:\n\nՕրինակ օգտագործում:\nassert(f_14(\"0000\") == 4);\n*/\nint f_14(const char* data_str)", "bn": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/*\nসংখ্যার একটি সিরিজ ডিকোড করে প্যাটার্ন উন্মোচন করুন এবং প্রতিটি অঙ্ক আসলে কোন মানগুলি উপস্থাপন করে তা বুঝুন।\n\nতুলনামূলক সমীকরণগুলি রেফারেন্সের জন্য প্রদান করা হয়েছে:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nপ্যারামিটারসমূহ:\n- data_str: একটি ধ্রুবক ক্যারেক্টার অ্যারে (সি-স্টাইল স্ট্রিং) যা সংখ্যার একটি সিরিজ উপস্থাপন করে। দৈর্ঘ্য 100 অতিক্রম করে না।\n\nরিটার্নস:\nint: প্রতিটি ডেটা স্ট্রিংয়ের ফলাফল যা সমীকরণের ডান দিকের সাথে মিলে যায়।\n\nউদাহরণ ব্যবহার:\nassert(f_14(\"0000\") == 4);\n*/\nint f_14(const char* data_str)", "bg": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/*\nДекодирайте серия от числа, за да разкриете модела и да разберете действителните стойности,\nкоито всяка цифра представлява.\n\nПредоставени уравнения за справка:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nПараметри:\n- data_str: Константен масив от символи (низ в стил C), представляващ серия от числа. Дължината не надвишава 100.\n\nВръща:\nint: Резултатът от всеки низ от данни, съответстващ на дясната страна на уравнението.\n\nПример за използване:\nassert(f_14(\"0000\") == 4);\n*/\nint f_14(const char* data_str)", "zh": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/*\n解码一系列数字以揭示模式并理解每个数字代表的实际值。\n\n提供的方程用于参考：\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\n参数：\n- data_str: 一个常量字符数组（C风格字符串），表示一系列数字。长度不超过100。\n\n返回：\nint: 每个数据字符串对应方程右侧的结果。\n\n示例用法：\nassert(f_14(\"0000\") == 4);\n*/\nint f_14(const char* data_str)", "fr": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/*\nDécoder une série de chiffres pour révéler le motif et comprendre les valeurs réelles \nque chaque chiffre représente.\n\nÉquations fournies à titre de référence :\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParamètres :\n- data_str : Un tableau de caractères constant (chaîne de style C) représentant une série de chiffres. La longueur ne dépasse pas 100.\n\nRenvoie :\nint : Le résultat de chaque chaîne de données correspondant au côté droit de l'équation.\n\nExemple d'utilisation :\nassert(f_14(\"0000\") == 4);\n*/\nint f_14(const char* data_str)", "de": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/*\nDekodiere eine Reihe von Zahlen, um das Muster zu erkennen und die tatsächlichen Werte zu verstehen, \ndie jede Ziffer darstellt.\n\nGleichungen zur Referenz:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParameter:\n- data_str: Ein konstantes Zeichenarray (C-Style-String), das eine Reihe von Zahlen darstellt. Die Länge überschreitet nicht 100.\n\nRückgabewert:\nint: Das Ergebnis jeder Datenzeichenfolge, das der rechten Seite der Gleichung entspricht.\n\nBeispielverwendung:\nassert(f_14(\"0000\") == 4);\n*/\nint f_14(const char* data_str)", "ha": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/*\nFassara jerin lambobi don bayyana tsarin kuma fahimtar ainihin ƙimar da kowace lamba ke wakilta.\n\nAn bayar da daidaito don tunani:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nSigogi:\n- data_str: Tsayayyen jerin haruffa (salo na C) wanda ke wakiltar jerin lambobi. Tsawon bai wuce 100 ba.\n\nDawo:\nint: Sakamakon kowanne jerin bayanai da ya dace da gefen dama na daidaito.\n\nMisalin amfani:\nassert(f_14(\"0000\") == 4);\n*/\nint f_14(const char* data_str)", "hi": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/*\nसंख्याओं की एक श्रृंखला को डिकोड करें ताकि पैटर्न का पता चल सके और समझ सकें कि प्रत्येक अंक का वास्तविक मूल्य क्या है।\n\nसंदर्भ के लिए दिए गए समीकरण:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nपैरामीटर्स:\n- data_str: एक स्थिर वर्ण सरणी (C-शैली की स्ट्रिंग) जो संख्याओं की एक श्रृंखला का प्रतिनिधित्व करती है। लंबाई 100 से अधिक नहीं होती।\n\nवापसी:\nint: प्रत्येक डेटा स्ट्रिंग का परिणाम जो समीकरण के दाहिने हाथ की ओर संबंधित होता है।\n\nउदाहरण उपयोग:\nassert(f_14(\"0000\") == 4);\n*/\nint f_14(const char* data_str)", "hu": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/*\nDekódolj egy számsorozatot, hogy felfedd a mintát és megértsd, hogy az egyes számjegyek milyen valós értékeket képviselnek.\n\nAz egyenletek referenciaként szolgálnak:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParaméterek:\n- data_str: Egy konstans karaktertömb (C-stílusú string), amely egy számsorozatot képvisel. Hossza nem haladja meg a 100-at.\n\nVisszatérési érték:\nint: Az egyes adatstringek eredménye, amely megfelel az egyenlet jobb oldalának.\n\nPélda használat:\nassert(f_14(\"0000\") == 4);\n*/\nint f_14(const char* data_str)", "es": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/*\nDecodificar una serie de números para revelar el patrón y entender los valores reales \nque representa cada dígito.\n\nEcuaciones proporcionadas como referencia:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParámetros:\n- data_str: Una matriz de caracteres constante (cadena de estilo C) que representa una serie de números. La longitud no excede 100.\n\nDevuelve:\nint: El resultado de cada cadena de datos correspondiente al lado derecho de la ecuación.\n\nEjemplo de uso:\nassert(f_14(\"0000\") == 4);\n*/\nint f_14(const char* data_str)", "arb": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/*\nفك سلسلة من الأرقام للكشف عن النمط وفهم القيم الفعلية التي يمثلها كل رقم.\n\nالمعادلات المقدمة للمرجعية:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nالمعلمات:\n- data_str: مصفوفة حروف ثابتة (سلسلة نمط C) تمثل سلسلة من الأرقام. الطول لا يتجاوز 100.\n\nالإرجاع:\nint: نتيجة كل سلسلة بيانات تقابل الجانب الأيمن من المعادلة.\n\nمثال على الاستخدام:\nassert(f_14(\"0000\") == 4);\n*/\nint f_14(const char* data_str)", "sw": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/*\nFasiri mfululizo wa nambari ili kufichua muundo na kuelewa thamani halisi \nambayo kila tarakimu inawakilisha.\n\nMlinganyo uliotolewa kwa kumbukumbu:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nVigezo:\n- data_str: Safu ya tabia ya mara kwa mara (kamba ya mtindo wa C) inayowakilisha mfululizo wa nambari. Urefu hauzidi 100.\n\nInarejesha:\nint: Matokeo ya kila kamba ya data inayolingana na upande wa kulia wa mlinganyo.\n\nMfano wa matumizi:\nassert(f_14(\"0000\") == 4);\n*/\nint f_14(const char* data_str)", "tr": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/*\nBir dizi sayıyı çözerek deseni ortaya çıkarın ve her bir rakamın temsil ettiği gerçek değerleri anlayın.\n\nReferans için sağlanan denklemler:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParametreler:\n- data_str: Bir dizi sayıyı temsil eden sabit karakter dizisi (C tarzı string). Uzunluk 100'ü geçmez.\n\nDöndürülen:\nint: Her bir veri dizisinin denklemin sağ tarafına karşılık gelen sonucu.\n\nÖrnek kullanım:\nassert(f_14(\"0000\") == 4);\n*/\nint f_14(const char* data_str)", "vi": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/*\nGiải mã một chuỗi số để tiết lộ mẫu và hiểu các giá trị thực tế mà mỗi chữ số đại diện.\n\nCác phương trình được cung cấp để tham khảo:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nTham số:\n- data_str: Một mảng ký tự hằng số (chuỗi kiểu C) đại diện cho một chuỗi số. Độ dài không vượt quá 100.\n\nTrả về:\nint: Kết quả của mỗi chuỗi dữ liệu tương ứng với vế phải của phương trình.\n\nVí dụ sử dụng:\nassert(f_14(\"0000\") == 4);\n*/\nint f_14(const char* data_str)", "id": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/*\nDekode serangkaian angka untuk mengungkap pola dan memahami nilai sebenarnya \nyang diwakili setiap digit.\n\nPersamaan yang diberikan untuk referensi:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParameter:\n- data_str: Sebuah array karakter konstan (string gaya C) yang mewakili serangkaian angka. Panjangnya tidak melebihi 100.\n\nMengembalikan:\nint: Hasil dari setiap string data yang sesuai dengan sisi kanan persamaan.\n\nContoh penggunaan:\nassert(f_14(\"0000\") == 4);\n*/\nint f_14(const char* data_str)", "ja": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/*\n一連の数字をデコードしてパターンを明らかにし、各桁が表す実際の値を理解します。\n\n参照用の方程式:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nパラメータ:\n- data_str: 一連の数字を表す定数文字配列（Cスタイルの文字列）。長さは100を超えません。\n\n戻り値:\nint: 方程式の右辺に対応する各データ文字列の結果。\n\n使用例:\nassert(f_14(\"0000\") == 4);\n*/\nint f_14(const char* data_str)", "ko": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/*\n숫자 시리즈를 해독하여 패턴을 드러내고 각 자릿수가 나타내는 실제 값을 이해합니다.\n\n참조용으로 제공된 방정식:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\n매개변수:\n- data_str: 숫자 시리즈를 나타내는 상수 문자 배열(C 스타일 문자열). 길이는 100을 초과하지 않습니다.\n\n반환값:\nint: 방정식의 오른쪽에 해당하는 각 데이터 문자열의 결과.\n\n사용 예:\nassert(f_14(\"0000\") == 4);\n*/\nint f_14(const char* data_str)", "ml": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/*\nഒരു സംഖ്യാ പരമ്പര ഡികോഡ് ചെയ്ത് ഓരോ അക്കവും പ്രതിനിധാനം ചെയ്യുന്ന യഥാർത്ഥ മൂല്യങ്ങൾ മനസ്സിലാക്കുക.\n\nഉദ്ധരണികൾ സൂചനയ്ക്കായി നൽകിയിരിക്കുന്നു:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nപാരാമീറ്ററുകൾ:\n- data_str: ഒരു സ്ഥിരമായ പ്രതീക ചാര നിര (സി-ശൈലി സ്ട്രിംഗ്) സംഖ്യകളുടെ പരമ്പരയെ പ്രതിനിധീകരിക്കുന്നു. നീളം 100-നെ കവിയുന്നില്ല.\n\nമടക്കം:\nint: സമവാക്യത്തിന്റെ വലത് വശവുമായി ബന്ധപ്പെട്ട ഓരോ ഡാറ്റാ സ്ട്രിംഗിന്റെയും ഫലമാണ്.\n\nഉദാഹരണ ഉപയോഗം:\nassert(f_14(\"0000\") == 4);\n*/\nint f_14(const char* data_str)", "fa": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/*\nرمزگشایی یک سری از اعداد برای آشکارسازی الگو و درک مقادیر واقعی که هر رقم نشان می‌دهد.\n\nمعادلات برای مرجع ارائه شده‌اند:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nپارامترها:\n- data_str: یک آرایه کاراکتری ثابت (رشته به سبک C) که نشان‌دهنده یک سری از اعداد است. طول آن از 100 تجاوز نمی‌کند.\n\nبازگشت:\nint: نتیجه هر رشته داده که با سمت راست معادله مطابقت دارد.\n\nمثال استفاده:\nassert(f_14(\"0000\") == 4);\n*/\nint f_14(const char* data_str)"}, "canonical_solution": "{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < std::strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}", "instruction": {"en": "Write a CPP function `int f_14(const char* data_str)` to solve the following problem:\nDecode a series of numbers to reveal the pattern and understand the actual values each digit represents.\n\nEquations provided for reference:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParameters:\n- data_str: A constant character array (C-style string) representing a series of numbers. Length does not exceed 100.\n\nReturns:\nint: The result of each data string corresponding to the right-hand side of the equation.\n\nExample usage:\nassert(f_14(\"0000\") == 4);", "sq": "Shkruani një funksion CPP `int f_14(const char* data_str)` për të zgjidhur problemin e mëposhtëm:\nDekodoni një seri numrash për të zbuluar modelin dhe për të kuptuar vlerat aktuale që përfaqëson secila shifër.\n\nEkuacionet e dhëna për referencë:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParametrat:\n- data_str: Një varg karakteresh konstant (string në stilin C) që përfaqëson një seri numrash. Gjatësia nuk e kalon 100.\n\nKthen:\nint: Rezultati i secilit varg të dhënash që korrespondon me anën e djathtë të ekuacionit.\n\nShembull përdorimi:\nassert(f_14(\"0000\") == 4);", "hy": "Գրեք CPP ֆունկցիա `int f_14(const char* data_str)` հետևյալ խնդիրը լուծելու համար:\nՎերծանել թվերի շարք՝ բացահայտելու օրինաչափությունը և հասկանալու, թե իրականում ինչ արժեքներ է ներկայացնում յուրաքանչյուր թիվ:\n\nՀավասարումներ՝ հղման համար:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nՊարամետրեր:\n- data_str: Հաստատուն սիմվոլների զանգված (C-ոճի տող), որը ներկայացնում է թվերի շարք։ Երկարությունը չի գերազանցում 100-ը։\n\nՎերադարձնում է:\nint: Յուրաքանչյուր տվյալ տողի արդյունքը, որը համապատասխանում է հավասարման աջ կողմին։\n\nՕրինակ օգտագործում:\nassert(f_14(\"0000\") == 4);", "bn": "একটি CPP ফাংশন `int f_14(const char* data_str)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nসংখ্যার একটি সিরিজ ডিকোড করুন যাতে প্যাটার্নটি প্রকাশ পায় এবং প্রতিটি অঙ্কের প্রকৃত মান বোঝা যায়।\n\nতুলনামূলক সূত্রগুলি রেফারেন্সের জন্য প্রদান করা হয়েছে:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nপ্যারামিটারসমূহ:\n- data_str: একটি ধ্রুবক চরিত্রের অ্যারে (সি-স্টাইল স্ট্রিং) যা সংখ্যার একটি সিরিজ উপস্থাপন করে। দৈর্ঘ্য 100 অতিক্রম করে না।\n\nফেরত দেয়:\nint: প্রতিটি ডেটা স্ট্রিং এর সমতুল্য সমীকরণের ডানপাশের ফলাফল।\n\nউদাহরণ ব্যবহার:\nassert(f_14(\"0000\") == 4);", "bg": "Напишете CPP функция `int f_14(const char* data_str)`, за да решите следния проблем:\nДекодирайте серия от числа, за да разкриете модела и да разберете действителните стойности, които всяка цифра представлява.\n\nПредоставени уравнения за справка:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nПараметри:\n- data_str: Константен масив от символи (низ в стил C), представляващ серия от числа. Дължината не надвишава 100.\n\nВръща:\nint: Резултатът от всеки низ от данни, съответстващ на дясната страна на уравнението.\n\nПример за използване:\nassert(f_14(\"0000\") == 4);", "zh": "编写一个 CPP 函数 `int f_14(const char* data_str)` 来解决以下问题：  \n解码一系列数字以揭示模式并理解每个数字代表的实际值。\n\n提供的方程用于参考：  \n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\n参数：  \n- data_str: 一个常量字符数组（C风格字符串），表示一系列数字。长度不超过100。\n\n返回：  \nint: 每个数据字符串对应方程右侧的结果。\n\n示例用法：  \nassert(f_14(\"0000\") == 4);", "fr": "Écrire une fonction CPP `int f_14(const char* data_str)` pour résoudre le problème suivant :\nDécoder une série de chiffres pour révéler le motif et comprendre les valeurs réelles que chaque chiffre représente.\n\nÉquations fournies à titre de référence :\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParamètres :\n- data_str : Un tableau de caractères constant (chaîne de style C) représentant une série de chiffres. La longueur ne dépasse pas 100.\n\nRenvoie :\nint : Le résultat de chaque chaîne de données correspondant au côté droit de l'équation.\n\nExemple d'utilisation :\nassert(f_14(\"0000\") == 4);", "de": "Schreiben Sie eine CPP-Funktion `int f_14(const char* data_str)`, um das folgende Problem zu lösen:\nDekodieren Sie eine Reihe von Zahlen, um das Muster zu erkennen und die tatsächlichen Werte zu verstehen, die jede Ziffer darstellt.\n\nGleichungen zur Referenz:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParameter:\n- data_str: Ein konstantes Zeichenarray (C-Style-String), das eine Reihe von Zahlen darstellt. Die Länge überschreitet nicht 100.\n\nRückgabewert:\nint: Das Ergebnis jedes Datenstrings, das der rechten Seite der Gleichung entspricht.\n\nBeispielverwendung:\nassert(f_14(\"0000\") == 4);", "ha": "Rubuta aikin CPP `int f_14(const char* data_str)` don warware matsalar mai zuwa:\nFassara jerin lambobi don bayyana tsarin kuma fahimtar ainihin ƙimar da kowace lamba ke wakilta.\n\nLissafai da aka bayar don tunani:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nSigogi:\n- data_str: Tsayayyen jerin haruffa (C-style string) wanda ke wakiltar jerin lambobi. Tsawon ba zai wuce 100 ba.\n\nDawowa:\nint: Sakamakon kowanne jerin bayanai da ya dace da gefen dama na lissafin.\n\nMisalin amfani:\nassert(f_14(\"0000\") == 4);", "hi": "एक CPP फ़ंक्शन `int f_14(const char* data_str)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nसंख्याओं की एक श्रृंखला को डिकोड करें ताकि पैटर्न का पता चल सके और समझ सकें कि प्रत्येक अंक का वास्तविक मूल्य क्या है।\n\nसंदर्भ के लिए समीकरण दिए गए हैं:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nपैरामीटर्स:\n- data_str: एक स्थिर वर्ण सरणी (C-शैली की स्ट्रिंग) जो संख्याओं की एक श्रृंखला का प्रतिनिधित्व करती है। लंबाई 100 से अधिक नहीं है।\n\nरिटर्न करता है:\nint: प्रत्येक डेटा स्ट्रिंग का परिणाम जो समीकरण के दाहिने हाथ की ओर मेल खाता है।\n\nउदाहरण उपयोग:\nassert(f_14(\"0000\") == 4);", "hu": "Írj egy CPP függvényt `int f_14(const char* data_str)` a következő probléma megoldására:\nDekódolj egy számsorozatot, hogy felfedd a mintát és megértsd, milyen valós értékeket képviselnek az egyes számjegyek.\n\nEgyenletek hivatkozásként:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParaméterek:\n- data_str: Egy konstans karaktertömb (C-stílusú string), amely egy számsorozatot képvisel. Hossza nem haladja meg a 100-at.\n\nVisszatérési érték:\nint: Az egyes adat stringek eredménye, amely megfelel az egyenlet jobb oldalának.\n\nPélda használat:\nassert(f_14(\"0000\") == 4);", "es": "Escriba una función CPP `int f_14(const char* data_str)` para resolver el siguiente problema:\nDecodificar una serie de números para revelar el patrón y entender los valores reales que representa cada dígito.\n\nEcuaciones proporcionadas como referencia:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParámetros:\n- data_str: Un arreglo de caracteres constante (cadena estilo C) que representa una serie de números. La longitud no excede 100.\n\nDevuelve:\nint: El resultado de cada cadena de datos correspondiente al lado derecho de la ecuación.\n\nEjemplo de uso:\nassert(f_14(\"0000\") == 4);", "arb": "اكتب دالة CPP `int f_14(const char* data_str)` لحل المشكلة التالية:\nفك شفرة سلسلة من الأرقام للكشف عن النمط وفهم القيم الفعلية التي يمثلها كل رقم.\n\nالمعادلات المقدمة للمرجعية:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nالمعطيات:\n- data_str: مصفوفة حروف ثابتة (سلسلة نمط C) تمثل سلسلة من الأرقام. الطول لا يتجاوز 100.\n\nالقيم المعادة:\nint: نتيجة كل سلسلة بيانات تقابل الجانب الأيمن من المعادلة.\n\nمثال على الاستخدام:\nassert(f_14(\"0000\") == 4);", "sw": "Andika kazi ya CPP `int f_14(const char* data_str)` kutatua tatizo lifuatalo:\nFasiri mfululizo wa nambari ili kufichua muundo na kuelewa thamani halisi ambayo kila tarakimu inawakilisha.\n\nMlinganyo uliotolewa kwa marejeleo:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nVigezo:\n- data_str: Mfululizo wa herufi za tabia (C-style string) unaowakilisha mfululizo wa nambari. Urefu hauzidi 100.\n\nInarejesha:\nint: Matokeo ya kila mfululizo wa data yanayolingana na upande wa kulia wa mlinganyo.\n\nMfano wa matumizi:\nassert(f_14(\"0000\") == 4);", "tr": "Bir CPP fonksiyonu `int f_14(const char* data_str)` yazın ve aşağıdaki problemi çözün:\nBir dizi sayıyı çözerek deseni ortaya çıkarın ve her bir rakamın temsil ettiği gerçek değerleri anlayın.\n\nReferans için verilen denklemler:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParametreler:\n- data_str: Bir dizi sayıyı temsil eden sabit karakter dizisi (C tarzı string). Uzunluğu 100'ü geçmez.\n\nDöndürülen:\nint: Denklemin sağ tarafına karşılık gelen her bir veri dizisinin sonucu.\n\nÖrnek kullanım:\nassert(f_14(\"0000\") == 4);", "vi": "Viết một hàm CPP `int f_14(const char* data_str)` để giải quyết vấn đề sau:\nGiải mã một chuỗi các số để khám phá mẫu và hiểu giá trị thực mà mỗi chữ số đại diện.\n\nCác phương trình được cung cấp để tham khảo:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nTham số:\n- data_str: Một mảng ký tự hằng (chuỗi kiểu C) đại diện cho một chuỗi các số. Độ dài không vượt quá 100.\n\nTrả về:\nint: Kết quả của mỗi chuỗi dữ liệu tương ứng với vế phải của phương trình.\n\nVí dụ sử dụng:\nassert(f_14(\"0000\") == 4);", "id": "Tulis sebuah fungsi CPP `int f_14(const char* data_str)` untuk menyelesaikan masalah berikut:\nDekode serangkaian angka untuk mengungkap pola dan memahami nilai sebenarnya yang diwakili oleh setiap digit.\n\nPersamaan yang diberikan untuk referensi:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParameter:\n- data_str: Sebuah array karakter konstan (string gaya C) yang mewakili serangkaian angka. Panjangnya tidak melebihi 100.\n\nMengembalikan:\nint: Hasil dari setiap string data yang sesuai dengan sisi kanan persamaan.\n\nContoh penggunaan:\nassert(f_14(\"0000\") == 4);", "ja": "`int f_14(const char* data_str)` というCPP関数を書いて、次の問題を解決してください:\n一連の数字をデコードしてパターンを明らかにし、各桁が表す実際の値を理解します。\n\n参考のために提供された方程式:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nパラメータ:\n- data_str: 数字の並びを表す定数文字配列（Cスタイルの文字列）。長さは100を超えません。\n\n戻り値:\nint: 方程式の右辺に対応する各データ文字列の結果。\n\n使用例:\nassert(f_14(\"0000\") == 4);", "ko": "CPP 함수 `int f_14(const char* data_str)`를 작성하여 다음 문제를 해결하십시오:\n숫자 시리즈를 디코딩하여 패턴을 밝히고 각 숫자가 나타내는 실제 값을 이해합니다.\n\n참고용으로 제공된 방정식:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\n매개변수:\n- data_str: 숫자 시리즈를 나타내는 상수 문자 배열(C 스타일 문자열). 길이는 100을 초과하지 않습니다.\n\n반환:\nint: 방정식의 오른쪽에 해당하는 각 데이터 문자열의 결과.\n\n사용 예:\nassert(f_14(\"0000\") == 4);", "ml": "ഒരു സിപിപി ഫംഗ്ഷൻ എഴുതുക`int f_14(const char* data_str)` ഈ പ്രശ്നം പരിഹരിക്കാൻ:\nസംഖ്യകളുടെ ഒരു പരമ്പര ഡികോഡ് ചെയ്ത് പാറ്റേൺ വെളിപ്പെടുത്തുകയും ഓരോ അക്കവും പ്രതിനിധാനം ചെയ്യുന്ന യഥാർത്ഥ മൂല്യങ്ങൾ മനസ്സിലാക്കുകയും ചെയ്യുക.\n\nസൂചകമായി നൽകിയിരിക്കുന്ന സമവാക്യങ്ങൾ:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nപാരാമീറ്ററുകൾ:\n- data_str: ഒരു സ്ഥിരമായ കറക്റ്റർ അറേ (സി-സ്റ്റൈൽ സ്ട്രിംഗ്) സംഖ്യകളുടെ ഒരു പരമ്പര പ്രതിനിധാനം ചെയ്യുന്നു. നീളം 100 കവിഞ്ഞുപോകില്ല.\n\nമടക്കം:\nint: സമവാക്യത്തിന്റെ വലതുഭാഗത്തോട് അനുബന്ധിച്ചുള്ള ഓരോ ഡാറ്റ സ്ട്രിംഗിന്റെയും ഫലമാണ്.\n\nഉദാഹരണ ഉപയോഗം:\nassert(f_14(\"0000\") == 4);", "fa": "یک تابع CPP `int f_14(const char* data_str)` بنویسید تا مسئله زیر را حل کند:\nیک سری از اعداد را رمزگشایی کنید تا الگو را آشکار کرده و مقادیر واقعی که هر رقم نشان می‌دهد را درک کنید.\n\nمعادلات ارائه شده برای مرجع:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nپارامترها:\n- data_str: یک آرایه کاراکتر ثابت (رشته به سبک C) که یک سری از اعداد را نشان می‌دهد. طول آن از 100 تجاوز نمی‌کند.\n\nبرمی‌گرداند:\nint: نتیجه هر رشته داده که به طرف راست معادله مربوط می‌شود.\n\nمثال استفاده:\nassert(f_14(\"0000\") == 4);"}, "level": "easy", "test": "int main() {\n    // Assert basic provided test cases\n    assert(f_14(\"0000\") == 4);\n    assert(f_14(\"8888\") == 8);\n    assert(f_14(\"1234\") == 1);\n    assert(f_14(\"5678\") == 3);\n    assert(f_14(\"9012\") == 2);\n    assert(f_14(\"1357\") == 0);\n    assert(f_14(\"2468\") == 4);\n\n    // Assert additional test cases\n    assert(f_14(\"9999\") == 4);\n    assert(f_14(\"1111\") == 0);\n    assert(f_14(\"2222\") == 0);\n    assert(f_14(\"3333\") == 0);\n    assert(f_14(\"4444\") == 4);\n    assert(f_14(\"5555\") == 0);\n    assert(f_14(\"6666\") == 4);\n    assert(f_14(\"7777\") == 0);\n    assert(f_14(\"0001\") == 3);\n    assert(f_14(\"2301\") == 1);\n\n    // Indicate that all tests passed\n    // std::cout << \"All tests passed successfully!\" << std::endl;\n\n    return 0;\n}", "entry_point": "f_14", "signature": "int f_14(const char* data_str)", "docstring": {"en": "Decode a series of numbers to reveal the pattern and understand the actual values each digit represents.\n\nEquations provided for reference:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParameters:\n- data_str: A constant character array (C-style string) representing a series of numbers. Length does not exceed 100.\n\nReturns:\nint: The result of each data string corresponding to the right-hand side of the equation.\n\nExample usage:\nassert(f_14(\"0000\") == 4);", "sq": "Dekodoni një seri numrash për të zbuluar modelin dhe për të kuptuar vlerat aktuale që përfaqëson secila shifër.\n\nEkuacionet e dhëna për referencë:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParametrat:\n- data_str: Një varg karakteresh konstant (string në stilin C) që përfaqëson një seri numrash. Gjatësia nuk tejkalon 100.\n\nKthen:\nint: Rezultati i secilit varg të dhënash që korrespondon me anën e djathtë të ekuacionit.\n\nShembull përdorimi:\nassert(f_14(\"0000\") == 4);", "hy": "Թվերի շարք ապակոդավորել՝ բացահայտելու օրինաչափությունը և հասկանալու, թե իրականում ինչ արժեքներ են ներկայացնում յուրաքանչյուր թվանշան։\n\nՀաշվարկները տրված են հղման համար.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nՊարամետրեր:\n- data_str: Հաստատուն սիմվոլների զանգված (C ոճի տող), որը ներկայացնում է թվերի շարք։ Երկարությունը չի գերազանցում 100-ը։\n\nՎերադարձնում է:\nint: Յուրաքանչյուր տվյալների տողի արդյունքը, որը համապատասխանում է հավասարման աջ կողմին։\n\nՕրինակ օգտագործում:\nassert(f_14(\"0000\") == 4);", "bn": "সংখ্যার একটি সিরিজ ডিকোড করুন প্যাটার্নটি প্রকাশ করতে এবং প্রতিটি অঙ্কের প্রকৃত মানগুলি বোঝার জন্য।\n\nতুলনার জন্য প্রদত্ত সমীকরণ:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nপ্যারামিটারসমূহ:\n- data_str: একটি ধ্রুব চরিত্রের অ্যারে (সি-স্টাইল স্ট্রিং) যা সংখ্যার একটি সিরিজ উপস্থাপন করে। দৈর্ঘ্য 100 অতিক্রম করে না।\n\nফেরত দেয়:\nint: প্রতিটি ডেটা স্ট্রিংয়ের ফলাফল যা সমীকরণের ডানপাশের সাথে মিলে যায়।\n\nব্যবহারের উদাহরণ:\nassert(f_14(\"0000\") == 4);", "bg": "Декодирайте серия от числа, за да разкриете модела и да разберете действителните стойности, които всяка цифра представлява.\n\nУравнения, предоставени за справка:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nПараметри:\n- data_str: Константен масив от символи (стринг в стил C), представляващ серия от числа. Дължината не надвишава 100.\n\nВръща:\nint: Резултатът от всеки низ от данни, съответстващ на дясната страна на уравнението.\n\nПример за използване:\nassert(f_14(\"0000\") == 4);", "zh": "解码一系列数字以揭示模式并理解每个数字代表的实际值。\n\n提供的方程用于参考：\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\n参数：\n- data_str: 一个常量字符数组（C风格字符串），表示一系列数字。长度不超过100。\n\n返回：\nint: 每个数据字符串对应方程右侧的结果。\n\n示例用法：\nassert(f_14(\"0000\") == 4);", "fr": "Décoder une série de chiffres pour révéler le motif et comprendre les valeurs réelles que chaque chiffre représente.\n\nÉquations fournies à titre de référence :\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParamètres :\n- data_str : Un tableau de caractères constant (chaîne de style C) représentant une série de chiffres. La longueur ne dépasse pas 100.\n\nRenvoie :\nint : Le résultat de chaque chaîne de données correspondant au côté droit de l'équation.\n\nExemple d'utilisation :\nassert(f_14(\"0000\") == 4);", "de": "Dekodiere eine Serie von Zahlen, um das Muster zu erkennen und die tatsächlichen Werte zu verstehen, die jede Ziffer darstellt.\n\nGleichungen zur Referenz:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParameter:\n- data_str: Ein konstantes Zeichenarray (C-Style-String), das eine Serie von Zahlen darstellt. Die Länge überschreitet nicht 100.\n\nRückgabewert:\nint: Das Ergebnis jeder Datenzeichenkette, das der rechten Seite der Gleichung entspricht.\n\nBeispielverwendung:\nassert(f_14(\"0000\") == 4);", "ha": "Fassara jerin lambobi don bayyana tsarin kuma fahimtar ainihin ƙimar da kowace lamba ke wakilta.\n\nLissafin da aka bayar don tunani:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nSigogi:\n- data_str: Wata madaidaiciyar jerin haruffa (C-style string) da ke wakiltar jerin lambobi. Tsawon ba ya wuce 100.\n\nAbubuwan da ake dawowa da su:\nint: Sakamakon kowanne jerin bayanai da ya dace da gefen dama na lissafin.\n\nMisalin amfani:\nassert(f_14(\"0000\") == 4);", "hi": "संख्याओं की एक श्रृंखला को डिकोड करें ताकि पैटर्न का पता चल सके और समझ सकें कि प्रत्येक अंक का वास्तविक मूल्य क्या है।\n\nसंदर्भ के लिए समीकरण दिए गए हैं:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nपैरामीटर्स:\n- data_str: एक स्थिर वर्ण सरणी (C-शैली स्ट्रिंग) जो संख्याओं की एक श्रृंखला का प्रतिनिधित्व करती है। लंबाई 100 से अधिक नहीं है।\n\nवापसी:\nint: प्रत्येक डेटा स्ट्रिंग का परिणाम जो समीकरण के दाहिने हिस्से से मेल खाता है।\n\nउदाहरण उपयोग:\nassert(f_14(\"0000\") == 4);", "hu": "Dekódoljon egy számok sorozatát, hogy felfedje a mintát, és megértse, hogy az egyes számjegyek valójában milyen értékeket képviselnek.\n\nAz egyenletek referenciaként szolgálnak:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParaméterek:\n- data_str: Egy állandó karaktertömb (C-stílusú string), amely számok sorozatát képviseli. Hossza nem haladja meg a 100-at.\n\nVisszatérési érték:\nint: Az egyes adat stringek eredménye, amely megfelel az egyenlet jobb oldalának.\n\nPélda használat:\nassert(f_14(\"0000\") == 4);", "es": "Decodificar una serie de números para revelar el patrón y entender los valores reales que representa cada dígito.\n\nEcuaciones proporcionadas como referencia:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParámetros:\n- data_str: Un arreglo de caracteres constante (cadena estilo C) que representa una serie de números. La longitud no excede 100.\n\nDevuelve:\nint: El resultado de cada cadena de datos correspondiente al lado derecho de la ecuación.\n\nEjemplo de uso:\nassert(f_14(\"0000\") == 4);", "arb": "فك سلسلة من الأرقام للكشف عن النمط وفهم القيم الفعلية التي يمثلها كل رقم.\n\nالمعادلات المقدمة للمرجعية:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nالمعلمات:\n- data_str: مصفوفة حرفية ثابتة (سلسلة نمط C) تمثل سلسلة من الأرقام. الطول لا يتجاوز 100.\n\nالقيم المعادة:\nint: نتيجة كل سلسلة بيانات تقابل الجانب الأيمن من المعادلة.\n\nمثال على الاستخدام:\nassert(f_14(\"0000\") == 4);", "sw": "Fasiri mfululizo wa nambari ili kufichua muundo na kuelewa thamani halisi ambayo kila tarakimu inawakilisha.\n\nMlinganyo uliotolewa kwa kumbukumbu:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nVigezo:\n- data_str: Safu ya tabia isiyobadilika (mfuatano wa herufi wa mtindo wa C) inayowakilisha mfululizo wa nambari. Urefu hauzidi 100.\n\nInarejesha:\nint: Matokeo ya kila mfuatano wa data yanayolingana na upande wa kulia wa mlinganyo.\n\nMfano wa matumizi:\nassert(f_14(\"0000\") == 4);", "tr": "Bir dizi sayıyı çözerek deseni ortaya çıkarın ve her bir rakamın temsil ettiği gerçek değerleri anlayın.\n\nReferans için sağlanan denklemler:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParametreler:\n- data_str: Bir dizi sayıyı temsil eden sabit karakter dizisi (C tarzı string). Uzunluk 100'ü geçmez.\n\nDöndürülenler:\nint: Her veri dizisinin denklemin sağ tarafına karşılık gelen sonucu.\n\nÖrnek kullanım:\nassert(f_14(\"0000\") == 4);", "vi": "Giải mã một chuỗi số để lộ ra mô hình và hiểu các giá trị thực mà mỗi chữ số đại diện.\n\nCác phương trình được cung cấp để tham khảo:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nTham số:\n- data_str: Một mảng ký tự hằng số (chuỗi kiểu C) đại diện cho một chuỗi số. Độ dài không vượt quá 100.\n\nTrả về:\nint: Kết quả của mỗi chuỗi dữ liệu tương ứng với vế phải của phương trình.\n\nVí dụ sử dụng:\nassert(f_14(\"0000\") == 4);", "id": "Menguraikan serangkaian angka untuk mengungkap pola dan memahami nilai sebenarnya yang diwakili oleh setiap digit.\n\nPersamaan yang diberikan untuk referensi:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParameter:\n- data_str: Sebuah array karakter konstan (string gaya C) yang mewakili serangkaian angka. Panjangnya tidak melebihi 100.\n\nMengembalikan:\nint: Hasil dari setiap string data yang sesuai dengan sisi kanan persamaan.\n\nContoh penggunaan:\nassert(f_14(\"0000\") == 4);", "ja": "数列をデコードしてパターンを明らかにし、各数字が表す実際の値を理解します。\n\n参照用の方程式:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nパラメータ:\n- data_str: 一連の数字を表す定数文字配列（Cスタイルの文字列）。長さは100を超えません。\n\n戻り値:\nint: 方程式の右辺に対応する各データ文字列の結果。\n\n使用例:\nassert(f_14(\"0000\") == 4);", "ko": "숫자 시리즈를 해독하여 패턴을 밝히고 각 숫자가 나타내는 실제 값을 이해합니다.\n\n참조용으로 제공된 방정식:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\n매개변수:\n- data_str: 숫자 시리즈를 나타내는 상수 문자 배열(C 스타일 문자열). 길이는 100을 초과하지 않습니다.\n\n반환:\nint: 방정식의 오른쪽에 해당하는 각 데이터 문자열의 결과.\n\n사용 예:\nassert(f_14(\"0000\") == 4);", "ml": "സംഖ്യകളുടെ ഒരു ശ്രേണി ഡികോഡ് ചെയ്ത് മാതൃക വെളിപ്പെടുത്തുകയും ഓരോ അക്കവും പ്രതിനിധാനം ചെയ്യുന്ന യഥാർത്ഥ മൂല്യങ്ങൾ മനസിലാക്കുകയും ചെയ്യുക.\n\nഉദാഹരണത്തിന് സമവാക്യങ്ങൾ:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nപാരാമീറ്ററുകൾ:\n- data_str: സംഖ്യകളുടെ ഒരു ശ്രേണി പ്രതിനിധീകരിക്കുന്ന ഒരു സ്ഥിരമായ പ്രതീക നിര (സി-ശൈലി സ്ട്രിംഗ്). നീളം 100-നെ കവിയുന്നില്ല.\n\nമടക്കം:\nint: സമവാക്യത്തിന്റെ വലതുഭാഗത്തോട് അനുബന്ധിച്ചുള്ള ഓരോ ഡാറ്റ സ്ട്രിംഗിന്റെയും ഫലമാണ്.\n\nഉദാഹരണ ഉപയോഗം:\nassert(f_14(\"0000\") == 4);", "fa": "رمزگشایی یک سری از اعداد برای آشکارسازی الگو و درک مقادیر واقعی که هر رقم نشان می‌دهد.\n\nمعادلات ارائه شده برای مرجع:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nپارامترها:\n- data_str: یک آرایه کاراکتری ثابت (رشته به سبک C) که یک سری اعداد را نشان می‌دهد. طول آن از 100 تجاوز نمی‌کند.\n\nبازگشت:\nint: نتیجه هر رشته داده که با سمت راست معادله مطابقت دارد.\n\nمثال استفاده:\nassert(f_14(\"0000\") == 4);"}}
{"task_id": "CPP/15", "prompt": {"en": "#include <cassert>\n#include <iostream>\n/**\n * Counts the number of different coloring methods for n squares with m colors,\n * considering the requirement that adjacent squares and the first/last squares\n * must have different colors.\n * \n * @param n The number of squares.\n * @param m The number of colors.\n * @return The count of different coloring methods satisfying the specified conditions.\n *         The result is modulo 1000003.\n *\n * Examples:\n * f_15(1,1) returns 1\n * f_15(2,2) returns 2\n */\nint f_15(int n, int m)", "sq": "#include <cassert>\n#include <iostream>\n/**\n * Numëron numrin e metodave të ndryshme të ngjyrosjes për n katrorë me m ngjyra,\n * duke marrë parasysh kërkesën që katrorët ngjitur dhe katrorët e parë/fundit\n * duhet të kenë ngjyra të ndryshme.\n * \n * @param n Numri i katrorëve.\n * @param m Numri i ngjyrave.\n * @return Numri i metodave të ndryshme të ngjyrosjes që plotësojnë kushtet e specifikuara.\n *         Rezultati është modulo 1000003.\n *\n * Shembuj:\n * f_15(1,1) kthen 1\n * f_15(2,2) kthen 2\n */\nint f_15(int n, int m)", "hy": "#include <cassert>\n#include <iostream>\n/**\n * Հաշվում է քառակուսիների n քանակի տարբեր գունավորման մեթոդների թիվը m գույներով,\n * հաշվի առնելով այն պահանջը, որ հարակից քառակուսիները և առաջին/վերջին քառակուսիները\n * պետք է ունենան տարբեր գույներ:\n * \n * @param n Քառակուսիների քանակը:\n * @param m Գույների քանակը:\n * @return Տարբեր գունավորման մեթոդների թիվը, որը բավարարում է նշված պայմաններին:\n *         Արդյունքը վերադարձվում է 1000003 մոդուլով:\n *\n * Օրինակներ:\n * f_15(1,1) վերադարձնում է 1\n * f_15(2,2) վերադարձնում է 2\n */\nint f_15(int n, int m)", "bn": "#include <cassert>\n#include <iostream>\n/**\n * n টি বর্গক্ষেত্রের জন্য m টি রঙের বিভিন্ন রঙ করার পদ্ধতির সংখ্যা গণনা করে,\n * যেখানে শর্ত হল যে সংলগ্ন বর্গক্ষেত্র এবং প্রথম/শেষ বর্গক্ষেত্রের রঙ ভিন্ন হতে হবে।\n * \n * @param n বর্গক্ষেত্রের সংখ্যা।\n * @param m রঙের সংখ্যা।\n * @return নির্দিষ্ট শর্তগুলি পূরণ করে এমন বিভিন্ন রঙ করার পদ্ধতির সংখ্যা প্রদান করে।\n *         ফলাফলটি 1000003 দ্বারা মডুলো করা হয়।\n *\n * উদাহরণ:\n * f_15(1,1) 1 প্রদান করে\n * f_15(2,2) 2 প্রদান করে\n */\nint f_15(int n, int m)", "bg": "#include <cassert>\n#include <iostream>\n/**\n * Брои броя на различните методи за оцветяване на n квадрата с m цвята,\n * като се взема предвид изискването съседните квадрати и първият/последният квадрат\n * да имат различни цветове.\n * \n * @param n Броят на квадратите.\n * @param m Броят на цветовете.\n * @return Броят на различните методи за оцветяване, които удовлетворяват посочените условия.\n *         Резултатът е по модул 1000003.\n *\n * Примери:\n * f_15(1,1) връща 1\n * f_15(2,2) връща 2\n */\nint f_15(int n, int m)", "zh": "#include <cassert>\n#include <iostream>\n/**\n * 计算使用 m 种颜色对 n 个方块进行不同着色的方法数，\n * 考虑到相邻方块以及第一个/最后一个方块必须具有不同颜色的要求。\n * \n * @param n 方块的数量。\n * @param m 颜色的数量。\n * @return 满足指定条件的不同着色方法的计数。\n *         结果取模 1000003。\n *\n * 示例:\n * f_15(1,1) 返回 1\n * f_15(2,2) 返回 2\n */\nint f_15(int n, int m)", "fr": "#include <cassert>\n#include <iostream>\n/**\n * Compte le nombre de méthodes de coloration différentes pour n carrés avec m couleurs,\n * en considérant l'exigence que les carrés adjacents et les premiers/derniers carrés\n * doivent avoir des couleurs différentes.\n * \n * @param n Le nombre de carrés.\n * @param m Le nombre de couleurs.\n * @return Le compte des différentes méthodes de coloration satisfaisant les conditions spécifiées.\n *         Le résultat est modulo 1000003.\n *\n * Exemples:\n * f_15(1,1) returns 1\n * f_15(2,2) returns 2\n */\nint f_15(int n, int m)", "de": "#include <cassert>\n#include <iostream>\n/**\n * Zählt die Anzahl der verschiedenen Färbemethoden für n Quadrate mit m Farben,\n * unter Berücksichtigung der Anforderung, dass benachbarte Quadrate und die ersten/letzten Quadrate\n * unterschiedliche Farben haben müssen.\n * \n * @param n Die Anzahl der Quadrate.\n * @param m Die Anzahl der Farben.\n * @return Die Anzahl der verschiedenen Färbemethoden, die die angegebenen Bedingungen erfüllen.\n *         Das Ergebnis ist modulo 1000003.\n *\n * Beispiele:\n * f_15(1,1) gibt 1 zurück\n * f_15(2,2) gibt 2 zurück\n */\nint f_15(int n, int m)", "ha": "#include <cassert>\n#include <iostream>\n/**\n * Yana ƙidaya adadin hanyoyin launin daban-daban don murabba'i n tare da launuka m,\n * la'akari da buƙatar cewa murabba'ai masu makwabtaka da murabba'ai na farko/na ƙarshe\n * dole ne su sami launuka daban-daban.\n * \n * @param n Yawan murabba'ai.\n * @param m Yawan launuka.\n * @return Adadin hanyoyin launin daban-daban da suka cika sharuɗɗan da aka fayyace.\n *         Sakamakon yana cikin modulo 1000003.\n *\n * Misalai:\n * f_15(1,1) yana dawowa 1\n * f_15(2,2) yana dawowa 2\n */\nint f_15(int n, int m)", "hi": "#include <cassert>\n#include <iostream>\n/**\n * n वर्गों के लिए m रंगों के विभिन्न रंगाई विधियों की संख्या गिनता है,\n * इस आवश्यकता को ध्यान में रखते हुए कि आसन्न वर्गों और पहले/अंतिम वर्गों के\n * रंग अलग-अलग होने चाहिए।\n * \n * @param n वर्गों की संख्या।\n * @param m रंगों की संख्या।\n * @return विभिन्न रंगाई विधियों की संख्या जो निर्दिष्ट शर्तों को पूरा करती हैं।\n *         परिणाम 1000003 से मॉड्यूलो है।\n *\n * उदाहरण:\n * f_15(1,1) 1 लौटाता है\n * f_15(2,2) 2 लौटाता है\n */\nint f_15(int n, int m)", "hu": "#include <cassert>\n#include <iostream>\n/**\n * Megszámolja az n négyzet m színnel való különböző színezési módszereit,\n * figyelembe véve azt a követelményt, hogy a szomszédos négyzetek és az első/utolsó négyzetek\n * különböző színűek legyenek.\n * \n * @param n A négyzetek száma.\n * @param m A színek száma.\n * @return A különböző színezési módszerek száma, amelyek megfelelnek a megadott feltételeknek.\n *         Az eredmény modulo 1000003.\n *\n * Példák:\n * f_15(1,1) visszaadja 1\n * f_15(2,2) visszaadja 2\n */\nint f_15(int n, int m)", "es": "#include <cassert>\n#include <iostream>\n/**\n * Cuenta el número de diferentes métodos de coloreado para n cuadrados con m colores,\n * considerando el requisito de que los cuadrados adyacentes y los primeros/últimos cuadrados\n * deben tener colores diferentes.\n * \n * @param n El número de cuadrados.\n * @param m El número de colores.\n * @return La cuenta de diferentes métodos de coloreado que satisfacen las condiciones especificadas.\n *         El resultado es módulo 1000003.\n *\n * Ejemplos:\n * f_15(1,1) returns 1\n * f_15(2,2) returns 2\n */\nint f_15(int n, int m)", "arb": "#include <cassert>\n#include <iostream>\n/**\n * يحسب عدد طرق التلوين المختلفة لـ n من المربعات باستخدام m من الألوان،\n * مع مراعاة الشرط الذي ينص على أن المربعات المتجاورة والمربعات الأولى/الأخيرة\n * يجب أن تكون بألوان مختلفة.\n * \n * @param n عدد المربعات.\n * @param m عدد الألوان.\n * @return عدد طرق التلوين المختلفة التي تلبي الشروط المحددة.\n *         النتيجة تكون موديولو 1000003.\n *\n * أمثلة:\n * f_15(1,1) returns 1\n * f_15(2,2) returns 2\n */\nint f_15(int n, int m)", "sw": "#include <cassert>\n#include <iostream>\n/**\n * Inahesabu idadi ya mbinu tofauti za kupaka rangi miraba n kwa rangi m,\n * kwa kuzingatia hitaji kwamba miraba iliyo karibu na miraba ya kwanza/mwisho\n * lazima iwe na rangi tofauti.\n * \n * @param n Idadi ya miraba.\n * @param m Idadi ya rangi.\n * @return Idadi ya mbinu tofauti za kupaka rangi zinazokidhi masharti yaliyotajwa.\n *         Matokeo ni modulo 1000003.\n *\n * Mifano:\n * f_15(1,1) inarudisha 1\n * f_15(2,2) inarudisha 2\n */\nint f_15(int n, int m)", "tr": "#include <cassert>\n#include <iostream>\n/**\n * n kare için m renk ile farklı boyama yöntemlerinin sayısını,\n * bitişik karelerin ve ilk/son karelerin farklı renklere sahip olması\n * gerekliliğini göz önünde bulundurarak sayar.\n * \n * @param n Kare sayısı.\n * @param m Renk sayısı.\n * @return Belirtilen koşulları karşılayan farklı boyama yöntemlerinin sayısı.\n *         Sonuç 1000003 ile mod alınmıştır.\n *\n * Örnekler:\n * f_15(1,1) 1 döndürür\n * f_15(2,2) 2 döndürür\n */\nint f_15(int n, int m)", "vi": "#include <cassert>\n#include <iostream>\n/**\n * Đếm số lượng phương pháp tô màu khác nhau cho n ô vuông với m màu,\n * xem xét yêu cầu rằng các ô vuông liền kề và ô đầu/cuối\n * phải có màu khác nhau.\n * \n * @param n Số lượng ô vuông.\n * @param m Số lượng màu.\n * @return Số lượng phương pháp tô màu khác nhau thỏa mãn các điều kiện đã chỉ định.\n *         Kết quả được lấy modulo 1000003.\n *\n * Ví dụ:\n * f_15(1,1) trả về 1\n * f_15(2,2) trả về 2\n */\nint f_15(int n, int m)", "id": "#include <cassert>\n#include <iostream>\n/**\n * Menghitung jumlah metode pewarnaan yang berbeda untuk n kotak dengan m warna,\n * dengan mempertimbangkan persyaratan bahwa kotak yang bersebelahan dan kotak pertama/terakhir\n * harus memiliki warna yang berbeda.\n * \n * @param n Jumlah kotak.\n * @param m Jumlah warna.\n * @return Jumlah metode pewarnaan yang berbeda yang memenuhi kondisi yang ditentukan.\n *         Hasilnya adalah modulo 1000003.\n *\n * Contoh:\n * f_15(1,1) mengembalikan 1\n * f_15(2,2) mengembalikan 2\n */\nint f_15(int n, int m)", "ja": "#include <cassert>\n#include <iostream>\n/**\n * n個の正方形をm色で塗る異なる方法の数を数えます。\n * 隣接する正方形と最初/最後の正方形が異なる色である必要があることを考慮します。\n * \n * @param n 正方形の数。\n * @param m 色の数。\n * @return 指定された条件を満たす異なる塗り方の数。\n *         結果は1000003での剰余です。\n *\n * 例:\n * f_15(1,1) は1を返します\n * f_15(2,2) は2を返します\n */\nint f_15(int n, int m)", "ko": "#include <cassert>\n#include <iostream>\n/**\n * n개의 정사각형을 m개의 색상으로 칠하는 서로 다른 방법의 수를 계산합니다.\n * 인접한 정사각형과 첫 번째/마지막 정사각형이 다른 색상이어야 한다는 요구 사항을 고려합니다.\n * \n * @param n 정사각형의 수.\n * @param m 색상의 수.\n * @return 지정된 조건을 만족하는 서로 다른 색칠 방법의 수를 반환합니다.\n *         결과는 1000003으로 나눈 나머지입니다.\n *\n * 예시:\n * f_15(1,1) returns 1\n * f_15(2,2) returns 2\n */\nint f_15(int n, int m)", "ml": "#include <cassert>\n#include <iostream>\n/**\n * n ചതുരങ്ങൾ m നിറങ്ങളുമായി വ്യത്യസ്തമായ നിറപ്പെടുത്തൽ രീതികളുടെ എണ്ണം എണ്ണുന്നു,\n * ചേർന്നിരിക്കുന്ന ചതുരങ്ങൾക്കും ആദ്യ/അവസാന ചതുരങ്ങൾക്കും വ്യത്യസ്തമായ നിറങ്ങൾ വേണമെന്ന\n * ആവശ്യം പരിഗണിക്കുന്നു.\n * \n * @param n ചതുരങ്ങളുടെ എണ്ണം.\n * @param m നിറങ്ങളുടെ എണ്ണം.\n * @return നിർദ്ദിഷ്ട വ്യവസ്ഥകൾ പാലിക്കുന്ന വ്യത്യസ്ത നിറപ്പെടുത്തൽ രീതികളുടെ എണ്ണം.\n *         ഫലം 1000003 ന്റെ മോഡുലോ ആണ്.\n *\n * ഉദാഹരണങ്ങൾ:\n * f_15(1,1) 1 തിരികെ നൽകുന്നു\n * f_15(2,2) 2 തിരികെ നൽകുന്നു\n */\nint f_15(int n, int m)", "fa": "#include <cassert>\n#include <iostream>\n/**\n * تعداد روش‌های مختلف رنگ‌آمیزی برای n مربع با m رنگ را شمارش می‌کند،\n * با در نظر گرفتن این که مربع‌های مجاور و مربع‌های اول/آخر باید رنگ‌های متفاوتی داشته باشند.\n * \n * @param n تعداد مربع‌ها.\n * @param m تعداد رنگ‌ها.\n * @return تعداد روش‌های مختلف رنگ‌آمیزی که شرایط مشخص شده را برآورده می‌کنند.\n *         نتیجه به صورت مدولوی 1000003 است.\n *\n * مثال‌ها:\n * f_15(1,1) مقدار 1 را برمی‌گرداند\n * f_15(2,2) مقدار 2 را برمی‌گرداند\n */\nint f_15(int n, int m)"}, "canonical_solution": "{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return static_cast<long long>(m) * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = static_cast<long long>(m) * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = static_cast<long long>(f[2]) * (m - 2) % 1000003;\n    for(int i = 4; i <= n; ++i) {\n        f[i] = (static_cast<long long>(f[i - 1]) * (m - 2) % 1000003 +\n                static_cast<long long>(f[i - 2]) * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}", "instruction": {"en": "Write a CPP function `int f_15(int n, int m)` to solve the following problem:\nCounts the number of different coloring methods for n squares with m colors, considering the requirement that adjacent squares and the first/last squares must have different colors.\n\n@param n The number of squares.\n@param m The number of colors.\n@return The count of different coloring methods satisfying the specified conditions. The result is modulo 1000003.\n\nExamples:\nf_15(1,1) returns 1\nf_15(2,2) returns 2\n", "sq": "Shkruani një funksion CPP `int f_15(int n, int m)` për të zgjidhur problemin e mëposhtëm: Numëron numrin e metodave të ndryshme të ngjyrosjes për n katrorë me m ngjyra, duke marrë parasysh kërkesën që katrorët ngjitur dhe katrorët e parë/të fundit duhet të kenë ngjyra të ndryshme.\n\n@param n Numri i katrorëve.\n@param m Numri i ngjyrave.\n@return Numri i metodave të ndryshme të ngjyrosjes që plotësojnë kushtet e specifikuara. Rezultati është modulo 1000003.\n\nShembuj:\nf_15(1,1) kthen 1\nf_15(2,2) kthen 2", "hy": "Գրեք CPP ֆունկցիա `int f_15(int n, int m)` հետևյալ խնդիրը լուծելու համար:\nՀաշվում է քառակուսիների n քանակի տարբեր գունավորման մեթոդների քանակը m գույներով՝ հաշվի առնելով պահանջը, որ հարակից քառակուսիները և առաջին/վերջին քառակուսիները պետք է ունենան տարբեր գույներ։\n\n@param n Քառակուսիների քանակը։\n@param m Գույների քանակը։\n@return Տարբեր գունավորման մեթոդների քանակը, որոնք բավարարում են նշված պայմանները։ Արդյունքը մոդուլո 1000003 է։\n\nՕրինակներ:\nf_15(1,1) վերադարձնում է 1\nf_15(2,2) վերադարձնում է 2", "bn": "একটি CPP ফাংশন `int f_15(int n, int m)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nn বর্গক্ষেত্রের জন্য m রঙের বিভিন্ন রঙ করার পদ্ধতির সংখ্যা গণনা করে, এই শর্তটি বিবেচনা করে যে সংলগ্ন বর্গক্ষেত্র এবং প্রথম/শেষ বর্গক্ষেত্রের রঙ ভিন্ন হতে হবে।\n\n@param n বর্গক্ষেত্রের সংখ্যা।\n@param m রঙের সংখ্যা।\n@return নির্দিষ্ট শর্তগুলি পূরণকারী বিভিন্ন রঙ করার পদ্ধতির সংখ্যা। ফলাফলটি 1000003 দ্বারা মডুলো।\n\nউদাহরণসমূহ:\nf_15(1,1) 1 প্রদান করে\nf_15(2,2) 2 প্রদান করে", "bg": "Напишете CPP функция `int f_15(int n, int m)`, за да решите следния проблем:\nБрои броя на различните методи за оцветяване на n квадрата с m цвята, като се има предвид изискването съседните квадрати и първият/последният квадрат да са с различни цветове.\n\n@param n Броят на квадратите.\n@param m Броят на цветовете.\n@return Броят на различните методи за оцветяване, които удовлетворяват посочените условия. Резултатът е по модул 1000003.\n\nПримери:\nf_15(1,1) връща 1\nf_15(2,2) връща 2", "zh": "编写一个 CPP 函数 `int f_15(int n, int m)` 来解决以下问题：\n计算使用 m 种颜色为 n 个方块着色的不同方法数，考虑到相邻方块以及第一个和最后一个方块必须具有不同颜色的要求。\n\n@param n 方块的数量。\n@param m 颜色的数量。\n@return 满足指定条件的不同着色方法的数量。结果取模 1000003。\n\n示例：\nf_15(1,1) 返回 1\nf_15(2,2) 返回 2", "fr": "Écrire une fonction CPP `int f_15(int n, int m)` pour résoudre le problème suivant :  \nCompte le nombre de méthodes de coloration différentes pour n carrés avec m couleurs, en considérant l'exigence que les carrés adjacents et les premiers/derniers carrés doivent avoir des couleurs différentes.\n\n@param n Le nombre de carrés.\n@param m Le nombre de couleurs.\n@return Le nombre de méthodes de coloration différentes satisfaisant les conditions spécifiées. Le résultat est modulo 1000003.\n\nExemples :  \nf_15(1,1) retourne 1  \nf_15(2,2) retourne 2  ", "de": "Schreiben Sie eine CPP-Funktion `int f_15(int n, int m)`, um das folgende Problem zu lösen:\nZählt die Anzahl der verschiedenen Färbemethoden für n Quadrate mit m Farben, wobei die Anforderung besteht, dass benachbarte Quadrate und die ersten/letzten Quadrate unterschiedliche Farben haben müssen.\n\n@param n Die Anzahl der Quadrate.\n@param m Die Anzahl der Farben.\n@return Die Anzahl der verschiedenen Färbemethoden, die die angegebenen Bedingungen erfüllen. Das Ergebnis ist modulo 1000003.\n\nBeispiele:\nf_15(1,1) gibt 1 zurück\nf_15(2,2) gibt 2 zurück", "ha": "Rubuta aikin CPP `int f_15(int n, int m)` don warware matsalar mai zuwa:  \nYana ƙididdige adadin hanyoyin launi daban-daban don murabba'i n tare da launuka m, la'akari da buƙatar cewa murabba'i masu makwabtaka da murabba'i na farko/na ƙarshe dole ne su sami launuka daban-daban.\n\n@param n Adadin murabba'ai.  \n@param m Adadin launuka.  \n@return Adadin hanyoyin launi daban-daban da suka cika sharuɗɗan da aka fayyace. Sakamakon yana cikin modulo 1000003.\n\nMisalai:  \nf_15(1,1) yana dawowa 1  \nf_15(2,2) yana dawowa 2  ", "hi": "एक CPP फ़ंक्शन `int f_15(int n, int m)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nn वर्गों के लिए m रंगों के विभिन्न रंगाई विधियों की संख्या गिनें, इस आवश्यकता को ध्यान में रखते हुए कि आसन्न वर्गों और पहले/अंतिम वर्गों के रंग अलग-अलग होने चाहिए।\n\n@param n वर्गों की संख्या।\n@param m रंगों की संख्या।\n@return निर्दिष्ट शर्तों को संतुष्ट करने वाली विभिन्न रंगाई विधियों की गिनती। परिणाम 1000003 के मोड्यूलो में है।\n\nउदाहरण:\nf_15(1,1) 1 लौटाता है\nf_15(2,2) 2 लौटाता है", "hu": "Írj egy CPP függvényt `int f_15(int n, int m)` a következő probléma megoldására:\nSzámolja meg az n négyzet m színnel való különböző színezési módszereit, figyelembe véve azt a követelményt, hogy a szomszédos négyzetek és az első/utolsó négyzetek különböző színűek legyenek.\n\n@param n A négyzetek száma.\n@param m A színek száma.\n@return A megadott feltételeknek megfelelő különböző színezési módszerek száma. Az eredmény 1000003-mal modulozva van.\n\nPéldák:\nf_15(1,1) visszaadja 1\nf_15(2,2) visszaadja 2", "es": "Escribe una función CPP `int f_15(int n, int m)` para resolver el siguiente problema:\nCuenta el número de diferentes métodos de coloreo para n cuadrados con m colores, considerando el requisito de que los cuadrados adyacentes y los primeros/últimos cuadrados deben tener colores diferentes.\n\n@param n El número de cuadrados.\n@param m El número de colores.\n@return La cuenta de diferentes métodos de coloreo que satisfacen las condiciones especificadas. El resultado es módulo 1000003.\n\nEjemplos:\nf_15(1,1) devuelve 1\nf_15(2,2) devuelve 2", "arb": "اكتب دالة CPP `int f_15(int n, int m)` لحل المشكلة التالية:\nتحسب عدد طرق التلوين المختلفة لـ n من المربعات باستخدام m من الألوان، مع مراعاة الشرط بأن المربعات المتجاورة والمربعين الأول والأخير يجب أن تكون بألوان مختلفة.\n\n@param n عدد المربعات.\n@param m عدد الألوان.\n@return عدد طرق التلوين المختلفة التي تلبي الشروط المحددة. النتيجة هي باقي القسمة على 1000003.\n\nأمثلة:\nf_15(1,1) يعيد 1\nf_15(2,2) يعيد 2", "sw": "Andika kazi ya CPP `int f_15(int n, int m)` kutatua tatizo lifuatalo:\nInahesabu idadi ya mbinu tofauti za kupaka rangi kwa miraba n na rangi m, kwa kuzingatia hitaji kwamba miraba iliyo karibu na miraba ya kwanza/ya mwisho lazima iwe na rangi tofauti.\n\n@param n Idadi ya miraba.\n@param m Idadi ya rangi.\n@return Idadi ya mbinu tofauti za kupaka rangi zinazokidhi masharti yaliyotajwa. Matokeo ni modulo 1000003.\n\nMifano:\nf_15(1,1) inarudisha 1\nf_15(2,2) inarudisha 2", "tr": "Bir CPP fonksiyonu `int f_15(int n, int m)` yazın ve aşağıdaki problemi çözün:\nn kareyi m renkle boyamak için farklı boyama yöntemlerinin sayısını hesaplar, bitişik karelerin ve ilk/son karelerin farklı renklere sahip olması gerektiği şartını göz önünde bulundurarak.\n\n@param n Karelerin sayısı.\n@param m Renklerin sayısı.\n@return Belirtilen koşulları sağlayan farklı boyama yöntemlerinin sayısı. Sonuç 1000003 ile mod alınır.\n\nÖrnekler:\nf_15(1,1) 1 döndürür\nf_15(2,2) 2 döndürür", "vi": "Viết một hàm CPP `int f_15(int n, int m)` để giải quyết vấn đề sau:\nĐếm số lượng phương pháp tô màu khác nhau cho n ô vuông với m màu, với yêu cầu rằng các ô vuông liền kề và các ô đầu/cuối phải có màu khác nhau.\n\n@param n Số lượng ô vuông.\n@param m Số lượng màu sắc.\n@return Số lượng phương pháp tô màu khác nhau thỏa mãn các điều kiện đã chỉ định. Kết quả được lấy modulo 1000003.\n\nVí dụ:\nf_15(1,1) trả về 1\nf_15(2,2) trả về 2", "id": "Tulis fungsi CPP `int f_15(int n, int m)` untuk menyelesaikan masalah berikut:\nMenghitung jumlah metode pewarnaan yang berbeda untuk n kotak dengan m warna, dengan mempertimbangkan persyaratan bahwa kotak yang berdekatan dan kotak pertama/terakhir harus memiliki warna yang berbeda.\n\n@param n Jumlah kotak.\n@param m Jumlah warna.\n@return Jumlah metode pewarnaan yang berbeda yang memenuhi kondisi yang ditentukan. Hasilnya adalah modulo 1000003.\n\nContoh:\nf_15(1,1) mengembalikan 1\nf_15(2,2) mengembalikan 2", "ja": "CPP関数 `int f_15(int n, int m)` を作成して、次の問題を解決してください:\nn個の正方形をm色で塗る異なる方法の数を数えます。隣接する正方形と最初/最後の正方形が異なる色でなければならないという要件を考慮します。\n\n@param n 正方形の数。\n@param m 色の数。\n@return 指定された条件を満たす異なる塗り方の数。結果は1000003でのモジュロです。\n\n例:\nf_15(1,1) は 1 を返します\nf_15(2,2) は 2 を返します", "ko": "다음 문제를 해결하기 위해 CPP 함수를 작성하세요 `int f_15(int n, int m)`:\n인접한 사각형과 첫 번째/마지막 사각형이 다른 색을 가져야 한다는 요구 사항을 고려하여 n개의 사각형을 m개의 색으로 색칠하는 서로 다른 방법의 수를 계산합니다.\n\n@param n 사각형의 수.\n@param m 색의 수.\n@return 지정된 조건을 만족하는 서로 다른 색칠 방법의 수. 결과는 1000003으로 나눈 나머지입니다.\n\n예시:\nf_15(1,1) returns 1\nf_15(2,2) returns 2", "ml": "ഒരു സിപിപി ഫംഗ്ഷൻ എഴുതുക `int f_15(int n, int m)` താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nn ചതുരങ്ങൾ m നിറങ്ങളുമായി വ്യത്യസ്തമായ നിറപ്പെടുത്തൽ രീതികളുടെ എണ്ണം എണ്ണുക, ചേർന്നിരിക്കുന്ന ചതുരങ്ങൾക്കും ആദ്യ/അവസാന ചതുരങ്ങൾക്കും വ്യത്യസ്ത നിറങ്ങൾ വേണം എന്ന ആവശ്യം പരിഗണിച്ച്.\n\n@param n ചതുരങ്ങളുടെ എണ്ണം.\n@param m നിറങ്ങളുടെ എണ്ണം.\n@return നിർദ്ദിഷ്ട നിബന്ധനകൾ പാലിക്കുന്ന വ്യത്യസ്ത നിറപ്പെടുത്തൽ രീതികളുടെ എണ്ണം. ഫലം 1000003 ന്റെ മോഡുലോ ആണ്.\n\nഉദാഹരണങ്ങൾ:\nf_15(1,1) 1 മടക്കുന്നു\nf_15(2,2) 2 മടക്കുന്നു", "fa": "یک تابع CPP به نام `int f_15(int n, int m)` بنویسید تا مسئله زیر را حل کند:\nتعداد روش‌های مختلف رنگ‌آمیزی برای n مربع با m رنگ را شمارش می‌کند، با در نظر گرفتن این شرط که مربع‌های مجاور و مربع‌های اول/آخر باید رنگ‌های متفاوتی داشته باشند.\n\n@param n تعداد مربع‌ها.\n@param m تعداد رنگ‌ها.\n@return تعداد روش‌های مختلف رنگ‌آمیزی که شرایط مشخص شده را برآورده می‌کنند. نتیجه به صورت مدولوی 1000003 است.\n\nمثال‌ها:\nf_15(1,1) مقدار 1 را برمی‌گرداند\nf_15(2,2) مقدار 2 را برمی‌گرداند"}, "level": "hard", "test": "int main() {\n    assert(f_15(1, 1) == 1);\n    assert(f_15(2, 2) == 2);\n    assert(f_15(3, 3) == 6);\n    assert(f_15(4, 2) == 2);\n    assert(f_15(1000, 10) == 566585); // We don't have the expected result for this case\n\n    // Additional test cases\n    assert(f_15(2, 3) == 6);\n    assert(f_15(1000, 1000) == 67911);\n    assert(f_15(999, 66) == 501817);\n    assert(f_15(5, 3) == 30); // Example of an expected output\n\n    // std::cout << \"All tests passed!\\n\";\n    return 0;\n}", "entry_point": "f_15", "signature": "int f_15(int n, int m)", "docstring": {"en": "Counts the number of different coloring methods for n squares with m colors, considering the requirement that adjacent squares and the first/last squares must have different colors.\n\n@param n The number of squares.\n@param m The number of colors.\n@return The count of different coloring methods satisfying the specified conditions. The result is modulo 1000003.\n\nExamples:\nf_15(1,1) returns 1\nf_15(2,2) returns 2\n", "sq": "Numëron numrin e metodave të ndryshme të ngjyrosjes për n katrorë me m ngjyra, duke marrë parasysh kërkesën që katrorët ngjitur dhe katrorët e parë/fundit duhet të kenë ngjyra të ndryshme.\n\n@param n Numri i katrorëve.\n@param m Numri i ngjyrave.\n@return Numri i metodave të ndryshme të ngjyrosjes që plotësojnë kushtet e specifikuara. Rezultati është modulo 1000003.\n\nShembuj:\nf_15(1,1) kthen 1\nf_15(2,2) kthen 2", "hy": "Հաշվում է n քառակուսիների տարբեր գունավորման մեթոդների քանակը m գույներով՝ հաշվի առնելով, որ հարակից քառակուսիները և առաջին/վերջին քառակուսիները պետք է ունենան տարբեր գույներ:\n\n@param n Քառակուսիների քանակը։\n@param m Գույների քանակը։\n@return Տարբեր գունավորման մեթոդների քանակը, որոնք բավարարում են նշված պայմանները։ Արդյունքը մոդուլո 1000003 է։\n\nՕրինակներ:\nf_15(1,1) վերադարձնում է 1\nf_15(2,2) վերադարձնում է 2", "bn": "nটি বর্গক্ষেত্রের জন্য mটি রঙের বিভিন্ন রঙ করার পদ্ধতির সংখ্যা গণনা করে, যেখানে শর্ত হল যে সংলগ্ন বর্গক্ষেত্র এবং প্রথম/শেষ বর্গক্ষেত্রের রঙ ভিন্ন হতে হবে।\n\n@param n বর্গক্ষেত্রের সংখ্যা।\n@param m রঙের সংখ্যা।\n@return নির্দিষ্ট শর্তগুলি পূরণকারী বিভিন্ন রঙ করার পদ্ধতির সংখ্যা। ফলাফলটি 1000003 দ্বারা মডুলো।\n\nউদাহরণসমূহ:\nf_15(1,1) 1 ফেরত দেয়\nf_15(2,2) 2 ফেরত দেয়", "bg": "Брои броя на различните методи за оцветяване за n квадрата с m цвята, като се има предвид изискването съседните квадрати и първият/последният квадрат да са с различни цветове.\n\n@param n Броят на квадратите.\n@param m Броят на цветовете.\n@return Броят на различните методи за оцветяване, които удовлетворяват посочените условия. Резултатът е модуло 1000003.\n\nПримери:\nf_15(1,1) връща 1\nf_15(2,2) връща 2", "zh": "计算使用 m 种颜色对 n 个方块进行不同着色的方法数，考虑到相邻方块以及首尾方块必须具有不同颜色的要求。\n\n@param n 方块的数量。\n@param m 颜色的数量。\n@return 满足指定条件的不同着色方法的计数。结果取模 1000003。\n\n示例:\nf_15(1,1) 返回 1\nf_15(2,2) 返回 2", "fr": "Compte le nombre de méthodes de coloration différentes pour n carrés avec m couleurs, en tenant compte de l'exigence selon laquelle les carrés adjacents et les premiers/derniers carrés doivent avoir des couleurs différentes.\n\n@param n Le nombre de carrés.\n@param m Le nombre de couleurs.\n@return Le compte des différentes méthodes de coloration satisfaisant les conditions spécifiées. Le résultat est modulo 1000003.\n\nExemples :\nf_15(1,1) renvoie 1\nf_15(2,2) renvoie 2", "de": "Zählt die Anzahl der verschiedenen Färbemethoden für n Quadrate mit m Farben, unter Berücksichtigung der Anforderung, dass benachbarte Quadrate und die ersten/letzten Quadrate unterschiedliche Farben haben müssen.\n\n@param n Die Anzahl der Quadrate.\n@param m Die Anzahl der Farben.\n@return Die Anzahl der verschiedenen Färbemethoden, die die angegebenen Bedingungen erfüllen. Das Ergebnis ist modulo 1000003.\n\nBeispiele:\nf_15(1,1) gibt 1 zurück\nf_15(2,2) gibt 2 zurück", "ha": "Yana ƙididdige adadin hanyoyin canza launi daban-daban don murabba'i n tare da launuka m, la'akari da buƙatar cewa murabba'i masu makwabtaka da murabba'i na farko/na ƙarshe dole ne su sami launuka daban.\n\n@param n Yawan murabba'ai.\n@param m Yawan launuka.\n@return Adadin hanyoyin canza launi daban-daban da suka cika yanayin da aka fayyace. Sakamakon yana cikin modulo 1000003.\n\nMisalai:\nf_15(1,1) returns 1\nf_15(2,2) returns 2", "hi": "n वर्गों के लिए m रंगों के साथ विभिन्न रंगाई विधियों की संख्या की गणना करता है, इस आवश्यकता को ध्यान में रखते हुए कि आसन्न वर्गों और पहले/अंतिम वर्गों के रंग अलग-अलग होने चाहिए।\n\n@param n वर्गों की संख्या।\n@param m रंगों की संख्या।\n@return निर्दिष्ट शर्तों को संतुष्ट करने वाली विभिन्न रंगाई विधियों की गणना। परिणाम 1000003 के माड्यूलो में है।\n\nउदाहरण:\nf_15(1,1) 1 लौटाता है\nf_15(2,2) 2 लौटाता है", "hu": "Számolja meg az n négyzet különböző színezési módszereinek számát m színnel, figyelembe véve azt a követelményt, hogy a szomszédos négyzetek és az első/utolsó négyzetek különböző színűek legyenek.\n\n@param n A négyzetek száma.\n@param m A színek száma.\n@return A különböző színezési módszerek száma, amelyek megfelelnek a megadott feltételeknek. Az eredmény modulo 1000003.\n\nPéldák:\nf_15(1,1) visszaadja 1\nf_15(2,2) visszaadja 2", "es": "Cuenta el número de diferentes métodos de coloreado para n cuadrados con m colores, considerando el requisito de que los cuadrados adyacentes y los primeros/últimos cuadrados deben tener colores diferentes.\n\n@param n El número de cuadrados.\n@param m El número de colores.\n@return El conteo de diferentes métodos de coloreado que satisfacen las condiciones especificadas. El resultado es módulo 1000003.\n\nEjemplos:\nf_15(1,1) returns 1\nf_15(2,2) returns 2", "arb": "يحسب عدد طرق التلوين المختلفة لـ n من المربعات باستخدام m من الألوان، مع مراعاة الشرط الذي ينص على أن المربعات المتجاورة والمربعات الأولى/الأخيرة يجب أن تكون بألوان مختلفة.\n\n@param n عدد المربعات.\n@param m عدد الألوان.\n@return عدد طرق التلوين المختلفة التي تفي بالشروط المحددة. النتيجة هي باقي القسمة على 1000003.\n\nأمثلة:\nf_15(1,1) returns 1\nf_15(2,2) returns 2", "sw": "Hesabu idadi ya mbinu tofauti za kupaka rangi mraba n kwa rangi m, kwa kuzingatia hitaji kwamba miraba iliyo karibu na miraba ya kwanza/mwisho lazima iwe na rangi tofauti.\n\n@param n Idadi ya miraba.\n@param m Idadi ya rangi.\n@return Hesabu ya mbinu tofauti za kupaka rangi zinazokidhi masharti yaliyowekwa. Matokeo ni modulo 1000003.\n\nMifano:\nf_15(1,1) inarudisha 1\nf_15(2,2) inarudisha 2", "tr": "Farklı renklendirme yöntemlerinin sayısını, bitişik karelerin ve ilk/son karelerin farklı renklere sahip olması gerekliliğini dikkate alarak, n kare için m renk ile sayar.\n\n@param n Karelerin sayısı.\n@param m Renklerin sayısı.\n@return Belirtilen koşulları karşılayan farklı renklendirme yöntemlerinin sayısı. Sonuç 1000003 ile mod alınır.\n\nÖrnekler:\nf_15(1,1) returns 1\nf_15(2,2) returns 2", "vi": "Đếm số lượng phương pháp tô màu khác nhau cho n ô vuông với m màu, xem xét yêu cầu rằng các ô vuông liền kề và ô vuông đầu tiên/cuối cùng phải có màu khác nhau.\n\n@param n Số lượng ô vuông.\n@param m Số lượng màu sắc.\n@return Số lượng phương pháp tô màu khác nhau thỏa mãn các điều kiện đã chỉ định. Kết quả được lấy modulo 1000003.\n\nVí dụ:\nf_15(1,1) trả về 1\nf_15(2,2) trả về 2", "id": "Menghitung jumlah metode pewarnaan berbeda untuk n kotak dengan m warna, dengan mempertimbangkan persyaratan bahwa kotak yang berdekatan dan kotak pertama/terakhir harus memiliki warna yang berbeda.\n\n@param n Jumlah kotak.\n@param m Jumlah warna.\n@return Jumlah metode pewarnaan berbeda yang memenuhi kondisi yang ditentukan. Hasilnya adalah modulo 1000003.\n\nContoh:\nf_15(1,1) mengembalikan 1\nf_15(2,2) mengembalikan 2", "ja": "n 個の正方形を m 色で塗り分ける異なる方法の数を数えます。隣接する正方形および最初と最後の正方形は異なる色でなければならないという条件を考慮します。\n\n@param n 正方形の数。\n@param m 色の数。\n@return 指定された条件を満たす異なる塗り分け方法の数。結果は 1000003 での剰余です。\n\n例:\nf_15(1,1) は 1 を返します\nf_15(2,2) は 2 を返します", "ko": "n개의 정사각형을 m개의 색상으로 칠하는 서로 다른 방법의 수를 계산합니다. 인접한 정사각형과 첫 번째/마지막 정사각형은 다른 색이어야 한다는 요구 사항을 고려합니다.\n\n@param n 정사각형의 수.\n@param m 색상의 수.\n@return 지정된 조건을 만족하는 서로 다른 색칠 방법의 수. 결과는 1000003으로 나눈 나머지입니다.\n\n예시:\nf_15(1,1) returns 1\nf_15(2,2) returns 2", "ml": "n ചതുരങ്ങൾ m നിറങ്ങളുമായി വ്യത്യസ്തമായ നിറപ്പെടുത്തൽ രീതികളുടെ എണ്ണം എണ്ണുന്നു, സമീപ ചതുരങ്ങൾക്കും ആദ്യ/അവസാന ചതുരങ്ങൾക്കും വ്യത്യസ്ത നിറങ്ങൾ വേണമെന്ന ആവശ്യകത പരിഗണിച്ച്.\n\n@param n ചതുരങ്ങളുടെ എണ്ണം.\n@param m നിറങ്ങളുടെ എണ്ണം.\n@return നിർദ്ദിഷ്ട വ്യവസ്ഥകൾ പാലിക്കുന്ന വ്യത്യസ്ത നിറപ്പെടുത്തൽ രീതികളുടെ എണ്ണം. ഫലം 1000003 ന്റെ മോഡുലോ ആണ്.\n\nഉദാഹരണങ്ങൾ:\nf_15(1,1) 1 മടക്കുന്നു\nf_15(2,2) 2 മടക്കുന്നു", "fa": "تعداد روش‌های مختلف رنگ‌آمیزی برای n مربع با m رنگ را محاسبه می‌کند، با در نظر گرفتن این شرط که مربع‌های مجاور و مربع‌های اول/آخر باید رنگ‌های متفاوتی داشته باشند.\n\n@param n تعداد مربع‌ها.\n@param m تعداد رنگ‌ها.\n@return تعداد روش‌های مختلف رنگ‌آمیزی که شرایط مشخص‌شده را برآورده می‌کنند. نتیجه به‌صورت مدولوی 1000003 است.\n\nمثال‌ها:\nf_15(1,1) مقدار 1 را برمی‌گرداند\nf_15(2,2) مقدار 2 را برمی‌گرداند"}}
{"task_id": "CPP/16", "prompt": {"en": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Count the number of valid coin toss sequences with no consecutive heads in n tosses.\n *\n * Parameters:\n * - n (int): The number of coin tosses.\n *\n * Returns:\n * - unsigned long long: The count of valid sequences.\n *\n * Examples:\n *   f_16(1) returns 2\n *   f_16(2) returns 3\n */\nunsigned long long f_16(int n)", "sq": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Numëron numrin e sekuencave të vlefshme të hedhjeve të monedhës pa koka të njëpasnjëshme në n hedhje.\n *\n * Parametrat:\n * - n (int): Numri i hedhjeve të monedhës.\n *\n * Kthen:\n * - unsigned long long: Numri i sekuencave të vlefshme.\n *\n * Shembuj:\n *   f_16(1) kthen 2\n *   f_16(2) kthen 3\n */\nunsigned long long f_16(int n)", "hy": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Հաշվել վավեր մետաղադրամի նետման հաջորդականությունների քանակը՝ առանց հաջորդական գլուխների n նետման դեպքում:\n *\n * Պարամետրեր:\n * - n (int): Մետաղադրամի նետումների քանակը:\n *\n * Վերադարձնում է:\n * - unsigned long long: Վավեր հաջորդականությունների քանակը:\n *\n * Օրինակներ:\n *   f_16(1) վերադարձնում է 2\n *   f_16(2) վերադարձնում է 3\n */\nunsigned long long f_16(int n)", "bn": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * n টসের মধ্যে কোন পরপর হেড না থাকা বৈধ কয়েন টস সিকোয়েন্সের সংখ্যা গণনা করুন।\n *\n * প্যারামিটার:\n * - n (int): কয়েন টসের সংখ্যা।\n *\n * রিটার্নস:\n * - unsigned long long: বৈধ সিকোয়েন্সের সংখ্যা।\n *\n * উদাহরণ:\n *   f_16(1) returns 2\n *   f_16(2) returns 3\n */\nunsigned long long f_16(int n)", "bg": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Пребройте броя на валидните последователности от хвърляния на монета без последователни ези в n хвърляния.\n *\n * Параметри:\n * - n (int): Броят на хвърлянията на монетата.\n *\n * Връща:\n * - unsigned long long: Броят на валидните последователности.\n *\n * Примери:\n *   f_16(1) връща 2\n *   f_16(2) връща 3\n */\nunsigned long long f_16(int n)", "zh": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * 计算在 n 次投掷中没有连续正面的有效投掷序列的数量。\n *\n * 参数:\n * - n (int): 投掷硬币的次数。\n *\n * 返回:\n * - unsigned long long: 有效序列的数量。\n *\n * 示例:\n *   f_16(1) 返回 2\n *   f_16(2) 返回 3\n */\nunsigned long long f_16(int n)", "fr": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Compter le nombre de séquences de lancers de pièces valides sans têtes consécutives en n lancers.\n *\n * Paramètres:\n * - n (int): Le nombre de lancers de pièces.\n *\n * Renvoie:\n * - unsigned long long: Le nombre de séquences valides.\n *\n * Exemples:\n *   f_16(1) returns 2\n *   f_16(2) returns 3\n */\nunsigned long long f_16(int n)", "de": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Zählt die Anzahl der gültigen Münzwurfsequenzen ohne aufeinanderfolgende Köpfe bei n Würfen.\n *\n * Parameter:\n * - n (int): Die Anzahl der Münzwürfe.\n *\n * Rückgabewert:\n * - unsigned long long: Die Anzahl der gültigen Sequenzen.\n *\n * Beispiele:\n *   f_16(1) gibt 2 zurück\n *   f_16(2) gibt 3 zurück\n */\nunsigned long long f_16(int n)", "ha": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Ƙirga adadin jerin jefa tsabar kudi masu inganci tare da babu kawunan da ke jere a cikin jefa tsabar kudi n.\n *\n * Sigogi:\n * - n (int): Yawan jefa tsabar kudi.\n *\n * Komawa:\n * - unsigned long long: Adadin jerin masu inganci.\n *\n * Misalai:\n *   f_16(1) returns 2\n *   f_16(2) returns 3\n */\nunsigned long long f_16(int n)", "hi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * n उछालों में बिना लगातार हेड्स के वैध सिक्का उछाल अनुक्रमों की संख्या गिनें।\n *\n * पैरामीटर्स:\n * - n (int): सिक्का उछालों की संख्या।\n *\n * रिटर्न्स:\n * - unsigned long long: वैध अनुक्रमों की गिनती।\n *\n * उदाहरण:\n *   f_16(1) returns 2\n *   f_16(2) returns 3\n */\nunsigned long long f_16(int n)", "hu": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Számolja meg az érvényes pénzfeldobási sorozatok számát, ahol nincsenek egymást követő fej dobások n dobás esetén.\n *\n * Paraméterek:\n * - n (int): A pénzfeldobások száma.\n *\n * Visszatérési érték:\n * - unsigned long long: Az érvényes sorozatok száma.\n *\n * Példák:\n *   f_16(1) visszaadja 2\n *   f_16(2) visszaadja 3\n */\nunsigned long long f_16(int n)", "es": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Cuenta el número de secuencias válidas de lanzamientos de moneda sin caras consecutivas en n lanzamientos.\n *\n * Parámetros:\n * - n (int): El número de lanzamientos de moneda.\n *\n * Devuelve:\n * - unsigned long long: El conteo de secuencias válidas.\n *\n * Ejemplos:\n *   f_16(1) returns 2\n *   f_16(2) returns 3\n */\nunsigned long long f_16(int n)", "arb": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * احسب عدد تسلسلات رمي العملة الصحيحة بدون رؤوس متتالية في n رميات.\n *\n * المعلمات:\n * - n (int): عدد رميات العملة.\n *\n * يعيد:\n * - unsigned long long: عدد التسلسلات الصحيحة.\n *\n * أمثلة:\n *   f_16(1) returns 2\n *   f_16(2) returns 3\n */\nunsigned long long f_16(int n)", "sw": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Hesabu idadi ya mfuatano halali wa kurusha sarafu bila vichwa mfululizo katika kurusha n.\n *\n * Vigezo:\n * - n (int): Idadi ya kurusha sarafu.\n *\n * Inarudisha:\n * - unsigned long long: Hesabu ya mfuatano halali.\n *\n * Mifano:\n *   f_16(1) inarudisha 2\n *   f_16(2) inarudisha 3\n */\nunsigned long long f_16(int n)", "tr": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Ardışık yazı gelmeyen geçerli para atışı dizilerinin sayısını n atışta sayar.\n *\n * Parametreler:\n * - n (int): Para atışlarının sayısı.\n *\n * Döndürür:\n * - unsigned long long: Geçerli dizilerin sayısı.\n *\n * Örnekler:\n *   f_16(1) returns 2\n *   f_16(2) returns 3\n */\nunsigned long long f_16(int n)", "vi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Đếm số lượng dãy tung đồng xu hợp lệ không có hai mặt ngửa liên tiếp trong n lần tung.\n *\n * Tham số:\n * - n (int): Số lần tung đồng xu.\n *\n * Trả về:\n * - unsigned long long: Số lượng dãy hợp lệ.\n *\n * Ví dụ:\n *   f_16(1) trả về 2\n *   f_16(2) trả về 3\n */\nunsigned long long f_16(int n)", "id": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Hitung jumlah urutan lemparan koin yang valid tanpa kepala berturut-turut dalam n lemparan.\n *\n * Parameter:\n * - n (int): Jumlah lemparan koin.\n *\n * Mengembalikan:\n * - unsigned long long: Jumlah urutan yang valid.\n *\n * Contoh:\n *   f_16(1) mengembalikan 2\n *   f_16(2) mengembalikan 3\n */\nunsigned long long f_16(int n)", "ja": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * n回のコイントスで連続する表がない有効なコイントスシーケンスの数を数えます。\n *\n * パラメータ:\n * - n (int): コイントスの回数。\n *\n * 戻り値:\n * - unsigned long long: 有効なシーケンスの数。\n *\n * 例:\n *   f_16(1) は 2 を返します\n *   f_16(2) は 3 を返します\n */\nunsigned long long f_16(int n)", "ko": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * 연속된 앞면이 없는 유효한 동전 던지기 시퀀스의 수를 n번 던졌을 때 계산합니다.\n *\n * 매개변수:\n * - n (int): 동전 던지기의 횟수.\n *\n * 반환값:\n * - unsigned long long: 유효한 시퀀스의 수.\n *\n * 예시:\n *   f_16(1) returns 2\n *   f_16(2) returns 3\n */\nunsigned long long f_16(int n)", "ml": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * n തവണ എറിയുമ്പോൾ തുടർച്ചയായ തലകളില്ലാത്ത സാധുവായ നാണയ എറിയൽ ക്രമങ്ങളുടെ എണ്ണം എണ്ണുക.\n *\n * പാരാമീറ്ററുകൾ:\n * - n (int): നാണയം എറിയുന്ന തവണകളുടെ എണ്ണം.\n *\n * മടക്കുന്നു:\n * - unsigned long long: സാധുവായ ക്രമങ്ങളുടെ എണ്ണം.\n *\n * ഉദാഹരണങ്ങൾ:\n *   f_16(1) 2 മടക്കുന്നു\n *   f_16(2) 3 മടക്കുന്നു\n */\nunsigned long long f_16(int n)", "fa": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * تعداد دنباله‌های معتبر پرتاب سکه را که در آن‌ها هیچ دو شیر متوالی وجود ندارد، در n پرتاب محاسبه کنید.\n *\n * پارامترها:\n * - n (int): تعداد پرتاب‌های سکه.\n *\n * بازگشت:\n * - unsigned long long: تعداد دنباله‌های معتبر.\n *\n * مثال‌ها:\n *   f_16(1) بازمی‌گرداند 2\n *   f_16(2) بازمی‌گرداند 3\n */\nunsigned long long f_16(int n)"}, "canonical_solution": "{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n\n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n\n    return a[n][0] + a[n][1];\n}", "instruction": {"en": "Write a CPP function `unsigned long long f_16(int n)` to solve the following problem:\nCount the number of valid coin toss sequences with no consecutive heads in n tosses.\n\nParameters:\n- n (int): The number of coin tosses.\n\nReturns:\n- unsigned long long: The count of valid sequences.\n\nExamples:\n  f_16(1) returns 2\n  f_16(2) returns 3\n", "sq": "Shkruani një funksion CPP `unsigned long long f_16(int n)` për të zgjidhur problemin e mëposhtëm: Numëroni numrin e sekuencave të vlefshme të hedhjeve të monedhave pa koka të njëpasnjëshme në n hedhje.\n\nParametrat:\n- n (int): Numri i hedhjeve të monedhave.\n\nKthen:\n- unsigned long long: Numri i sekuencave të vlefshme.\n\nShembuj:\n  f_16(1) kthen 2\n  f_16(2) kthen 3", "hy": "Գրեք CPP ֆունկցիա `unsigned long long f_16(int n)` հետևյալ խնդիրը լուծելու համար:\nՀաշվեք վավեր մետաղադրամի նետումների հաջորդականությունների քանակը, որտեղ n նետումների ժամանակ չկան հաջորդական գլուխներ:\n\nՊարամետրեր:\n- n (int): Մետաղադրամի նետումների քանակը։\n\nՎերադարձնում է:\n- unsigned long long: Վավեր հաջորդականությունների քանակը։\n\nՕրինակներ:\n  f_16(1) վերադարձնում է 2\n  f_16(2) վերադարձնում է 3", "bn": "একটি CPP ফাংশন `unsigned long long f_16(int n)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nn বার টসের মধ্যে কোন ধারাবাহিক হেড ছাড়া বৈধ কয়েন টস সিকোয়েন্সের সংখ্যা গণনা করুন।\n\nপ্যারামিটারসমূহ:\n- n (int): কয়েন টসের সংখ্যা।\n\nরিটার্নস:\n- unsigned long long: বৈধ সিকোয়েন্সের সংখ্যা।\n\nউদাহরণসমূহ:\n  f_16(1) রিটার্ন করে 2\n  f_16(2) রিটার্ন করে 3", "bg": "Напишете CPP функция `unsigned long long f_16(int n)`, за да решите следния проблем:  \nПребройте броя на валидните последователности от хвърляния на монета без последователни ези в n хвърляния.\n\nПараметри:\n- n (int): Броят на хвърлянията на монетата.\n\nВръща:\n- unsigned long long: Броят на валидните последователности.\n\nПримери:\n  f_16(1) връща 2\n  f_16(2) връща 3", "zh": "编写一个 CPP 函数 `unsigned long long f_16(int n)` 来解决以下问题：\n计算在 n 次投掷中没有连续正面的有效投掷序列的数量。\n\n参数：\n- n (int): 投掷硬币的次数。\n\n返回：\n- unsigned long long: 有效序列的数量。\n\n示例：\n  f_16(1) 返回 2\n  f_16(2) 返回 3", "fr": "Écrire une fonction CPP `unsigned long long f_16(int n)` pour résoudre le problème suivant :  \nCompter le nombre de séquences valides de lancers de pièce sans têtes consécutives dans n lancers.\n\nParamètres :  \n- n (int) : Le nombre de lancers de pièce.\n\nRenvoie :  \n- unsigned long long : Le compte des séquences valides.\n\nExemples :  \n  f_16(1) renvoie 2  \n  f_16(2) renvoie 3  ", "de": "Schreiben Sie eine CPP-Funktion `unsigned long long f_16(int n)`, um das folgende Problem zu lösen:\nZählen Sie die Anzahl der gültigen Münzwurfsequenzen ohne aufeinanderfolgende Köpfe in n Würfen.\n\nParameter:\n- n (int): Die Anzahl der Münzwürfe.\n\nRückgabewert:\n- unsigned long long: Die Anzahl der gültigen Sequenzen.\n\nBeispiele:\n  f_16(1) gibt 2 zurück\n  f_16(2) gibt 3 zurück", "ha": "Rubuta aikin CPP `unsigned long long f_16(int n)` don warware matsalar mai zuwa:\nƘididdige adadin sahihan jerin jefa tsabar kudi ba tare da kai biyu a jere ba a cikin n jefa.\n\nSigogi:\n- n (int): Yawan jefa tsabar kudi.\n\nDawowa:\n- unsigned long long: Adadin sahihan jerin.\n\nMisalai:\n  f_16(1) returns 2\n  f_16(2) returns 3", "hi": "एक CPP फ़ंक्शन `unsigned long long f_16(int n)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nn उछालों में बिना लगातार हेड्स के मान्य सिक्का उछाल अनुक्रमों की संख्या गिनें।\n\nपैरामीटर्स:\n- n (int): सिक्का उछालों की संख्या।\n\nवापसी:\n- unsigned long long: मान्य अनुक्रमों की गिनती।\n\nउदाहरण:\n  f_16(1) returns 2\n  f_16(2) returns 3", "hu": "Írj egy CPP függvényt `unsigned long long f_16(int n)` a következő probléma megoldására:\nSzámold meg az érvényes pénzfeldobás sorozatok számát, ahol nincs egymást követő fej n dobás esetén.\n\nParaméterek:\n- n (int): A pénzfeldobások száma.\n\nVisszatérési érték:\n- unsigned long long: Az érvényes sorozatok száma.\n\nPéldák:\n  f_16(1) visszaadja 2\n  f_16(2) visszaadja 3", "es": "Escribe una función CPP `unsigned long long f_16(int n)` para resolver el siguiente problema:\nCuenta el número de secuencias válidas de lanzamientos de moneda sin caras consecutivas en n lanzamientos.\n\nParámetros:\n- n (int): El número de lanzamientos de moneda.\n\nDevuelve:\n- unsigned long long: La cuenta de secuencias válidas.\n\nEjemplos:\n  f_16(1) returns 2\n  f_16(2) returns 3", "arb": "اكتب دالة CPP `unsigned long long f_16(int n)` لحل المشكلة التالية:\nاحسب عدد تسلسلات رمي العملة الصحيحة بدون رؤوس متتالية في n رميات.\n\nالمعطيات:\n- n (int): عدد رميات العملة.\n\nالقيم المعادة:\n- unsigned long long: عدد التسلسلات الصحيحة.\n\nأمثلة:\n  f_16(1) returns 2\n  f_16(2) returns 3", "sw": "Andika kazi ya CPP `unsigned long long f_16(int n)` kutatua tatizo lifuatalo:\nHesabu idadi ya mfuatano sahihi wa kurusha sarafu bila vichwa mfululizo katika kurusha n.\n\nVigezo:\n- n (int): Idadi ya kurusha sarafu.\n\nInarudisha:\n- unsigned long long: Idadi ya mfuatano sahihi.\n\nMifano:\n  f_16(1) inarudisha 2\n  f_16(2) inarudisha 3", "tr": "Bir CPP fonksiyonu `unsigned long long f_16(int n)` yazın ve aşağıdaki problemi çözün:\nn atışında ardışık yazı gelmeyen geçerli para atışı dizilerinin sayısını sayın.\n\nParametreler:\n- n (int): Para atışlarının sayısı.\n\nDöndürür:\n- unsigned long long: Geçerli dizilerin sayısı.\n\nÖrnekler:\n  f_16(1) returns 2\n  f_16(2) returns 3", "vi": "Viết một hàm CPP `unsigned long long f_16(int n)` để giải quyết vấn đề sau:\nĐếm số lượng dãy tung đồng xu hợp lệ mà không có hai mặt ngửa liên tiếp trong n lần tung.\n\nTham số:\n- n (int): Số lần tung đồng xu.\n\nTrả về:\n- unsigned long long: Số lượng dãy hợp lệ.\n\nVí dụ:\n  f_16(1) trả về 2\n  f_16(2) trả về 3", "id": "Tulis sebuah fungsi CPP `unsigned long long f_16(int n)` untuk menyelesaikan masalah berikut:\nHitung jumlah urutan lemparan koin yang valid tanpa kepala berturut-turut dalam n lemparan.\n\nParameter:\n- n (int): Jumlah lemparan koin.\n\nMengembalikan:\n- unsigned long long: Jumlah urutan yang valid.\n\nContoh:\n  f_16(1) mengembalikan 2\n  f_16(2) mengembalikan 3", "ja": "以下の問題を解くために、CPP関数 `unsigned long long f_16(int n)` を作成してください:\nn回のコイントスで連続する表がない有効なコイントスシーケンスの数を数えます。\n\nパラメータ:\n- n (int): コイントスの回数。\n\n戻り値:\n- unsigned long long: 有効なシーケンスの数。\n\n例:\n  f_16(1) は 2 を返します\n  f_16(2) は 3 を返します", "ko": "다음 문제를 해결하기 위해 CPP 함수를 `unsigned long long f_16(int n)` 작성하십시오:\nn번 던질 때 연속된 앞면이 없는 유효한 동전 던지기 시퀀스의 수를 계산합니다.\n\n매개변수:\n- n (int): 동전 던지기의 수.\n\n반환값:\n- unsigned long long: 유효한 시퀀스의 수.\n\n예시:\n  f_16(1) returns 2\n  f_16(2) returns 3", "ml": "`unsigned long long f_16(int n)` എന്ന CPP ഫംഗ്ഷൻ എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:  \n\nതുടർച്ചയായ തലകൾ ഇല്ലാത്ത n തവണ തലയിടൽ ശ്രേണികളുടെ എണ്ണം എണ്ണുക.\n\nParameters:\n- n (int): തലയിടലുകളുടെ എണ്ണം.\n\nReturns:\n- unsigned long long: സാധുവായ ശ്രേണികളുടെ എണ്ണം.\n\nExamples:\n  f_16(1) returns 2\n  f_16(2) returns 3", "fa": "یک تابع CPP به نام `unsigned long long f_16(int n)` بنویسید تا مسئله زیر را حل کند:\nتعداد دنباله‌های معتبر پرتاب سکه را که در آن‌ها هیچ دو شیر متوالی وجود ندارد در n پرتاب بشمارید.\n\nپارامترها:\n- n (int): تعداد پرتاب‌های سکه.\n\nبرمی‌گرداند:\n- unsigned long long: تعداد دنباله‌های معتبر.\n\nمثال‌ها:\n  f_16(1) برمی‌گرداند 2\n  f_16(2) برمی‌گرداند 3"}, "level": "easy", "test": "int main() {\n    assert(f_16(1) == 2);\n    assert(f_16(2) == 3);\n    assert(f_16(3) == 5);\n    assert(f_16(4) == 8); // Additional test\n    assert(f_16(5) == 13); // Additional test\n    // Feel free to add more tests here\n    assert(f_16(40) == 267914296ULL); // Additional test\n    assert(f_16(39) == 165580141ULL);\n    assert(f_16(38) == 102334155ULL);\n    // printf(\"All tests passed!\\n\");\n    return 0;\n}", "entry_point": "f_16", "signature": "unsigned long long f_16(int n)", "docstring": {"en": "Count the number of valid coin toss sequences with no consecutive heads in n tosses.\n\nParameters:\n- n (int): The number of coin tosses.\n\nReturns:\n- unsigned long long: The count of valid sequences.\n\nExamples:\n  f_16(1) returns 2\n  f_16(2) returns 3\n", "sq": "Numëroni numrin e sekuencave të vlefshme të hedhjeve të monedhës pa koka të njëpasnjëshme në n hedhje.\n\nParametrat:\n- n (int): Numri i hedhjeve të monedhës.\n\nKthen:\n- unsigned long long: Numri i sekuencave të vlefshme.\n\nShembuj:\n  f_16(1) kthen 2\n  f_16(2) kthen 3", "hy": "Հաշվել վավեր մետաղադրամի նետման հաջորդականությունների քանակը՝ առանց հաջորդական գլուխների n նետման դեպքում:\n\nՊարամետրեր:\n- n (int): Նետումների քանակը:\n\nՎերադարձնում է:\n- unsigned long long: Վավեր հաջորդականությունների քանակը:\n\nՕրինակներ:\n  f_16(1) վերադարձնում է 2\n  f_16(2) վերադարձնում է 3", "bn": "n টসের মধ্যে কোন পরপর হেড না থাকা বৈধ কয়েন টস সিকোয়েন্সের সংখ্যা গণনা করুন।\n\nপ্যারামিটারসমূহ:\n- n (int): কয়েন টসের সংখ্যা।\n\nফেরত দেয়:\n- unsigned long long: বৈধ সিকোয়েন্সের সংখ্যা।\n\nউদাহরণসমূহ:\n  f_16(1) ফেরত দেয় 2\n  f_16(2) ফেরত দেয় 3", "bg": "Бройте броя на валидните последователности от хвърляния на монета без последователни ези в n хвърляния.\n\nПараметри:\n- n (int): Броят на хвърлянията на монетата.\n\nВръща:\n- unsigned long long: Броят на валидните последователности.\n\nПримери:\n  f_16(1) връща 2\n  f_16(2) връща 3", "zh": "计算在 n 次投掷中没有连续正面的有效硬币投掷序列的数量。\n\n参数：\n- n (int): 硬币投掷的次数。\n\n返回：\n- unsigned long long: 有效序列的数量。\n\n示例：\n  f_16(1) returns 2\n  f_16(2) returns 3", "fr": "Compter le nombre de séquences de lancers de pièce valides sans faces consécutives dans n lancers.\n\nParamètres :\n- n (int) : Le nombre de lancers de pièce.\n\nRenvoie :\n- unsigned long long : Le compte des séquences valides.\n\nExemples :\n  f_16(1) renvoie 2\n  f_16(2) renvoie 3", "de": "Zähle die Anzahl der gültigen Münzwurfsequenzen ohne aufeinanderfolgende Köpfe bei n Würfen.\n\nParameter:\n- n (int): Die Anzahl der Münzwürfe.\n\nGibt zurück:\n- unsigned long long: Die Anzahl der gültigen Sequenzen.\n\nBeispiele:\n  f_16(1) gibt 2 zurück\n  f_16(2) gibt 3 zurück", "ha": "Ƙirga adadin jerin jefa tsabar kudi masu inganci tare da babu kawunan da ke jere a cikin jefa tsabar kudi n.\n\nSigogi:\n- n (int): Yawan jefa tsabar kudi.\n\nDawowa:\n- unsigned long long: Adadin sahihan jerin.\n\nMisalai:\n  f_16(1) returns 2\n  f_16(2) returns 3", "hi": "n उछालों में बिना लगातार हेड्स के वैध सिक्का उछाल अनुक्रमों की संख्या गिनें।\n\nपैरामीटर्स:\n- n (int): सिक्का उछालों की संख्या।\n\nवापसी:\n- unsigned long long: वैध अनुक्रमों की गिनती।\n\nउदाहरण:\n  f_16(1) returns 2\n  f_16(2) returns 3", "hu": "Számolja meg az érvényes pénzfeldobási sorozatok számát, ahol nincs egymást követő fej n dobás esetén.\n\nParaméterek:\n- n (int): A pénzfeldobások száma.\n\nVisszatér:\n- unsigned long long: Az érvényes sorozatok száma.\n\nPéldák:\n  f_16(1) visszaadja 2\n  f_16(2) visszaadja 3", "es": "Cuenta el número de secuencias válidas de lanzamientos de moneda sin caras consecutivas en n lanzamientos.\n\nParámetros:\n- n (int): El número de lanzamientos de moneda.\n\nDevuelve:\n- unsigned long long: El conteo de secuencias válidas.\n\nEjemplos:\n  f_16(1) devuelve 2\n  f_16(2) devuelve 3", "arb": "احسب عدد تسلسلات رمي العملة الصحيحة بدون رؤوس متتالية في n رميات.\n\nالمعطيات:\n- n (int): عدد رميات العملة.\n\nالقيم المعادة:\n- unsigned long long: عدد التسلسلات الصحيحة.\n\nأمثلة:\n  f_16(1) returns 2\n  f_16(2) returns 3", "sw": "Hesabu idadi ya mfuatano halali wa kurusha sarafu bila vichwa mfululizo katika kurusha sarafu n.\n\nVigezo:\n- n (int): Idadi ya kurusha sarafu.\n\nInarejesha:\n- unsigned long long: Hesabu ya mfuatano halali.\n\nMifano:\n  f_16(1) inarejesha 2\n  f_16(2) inarejesha 3", "tr": "n atışında ardışık yazı gelmeyen geçerli madeni para atış dizilerinin sayısını sayın.\n\nParametreler:\n- n (int): Madeni para atışlarının sayısı.\n\nDöndürür:\n- unsigned long long: Geçerli dizilerin sayısı.\n\nÖrnekler:\n  f_16(1) returns 2\n  f_16(2) returns 3", "vi": "Đếm số lượng dãy tung đồng xu hợp lệ mà không có mặt sấp liên tiếp trong n lần tung.\n\nTham số:\n- n (int): Số lần tung đồng xu.\n\nTrả về:\n- unsigned long long: Số lượng dãy hợp lệ.\n\nVí dụ:\n  f_16(1) trả về 2\n  f_16(2) trả về 3", "id": "Hitung jumlah urutan lempar koin yang valid tanpa kepala berturut-turut dalam n lemparan.\n\nParameter:\n- n (int): Jumlah lemparan koin.\n\nMengembalikan:\n- unsigned long long: Jumlah urutan yang valid.\n\nContoh:\n  f_16(1) mengembalikan 2\n  f_16(2) mengembalikan 3", "ja": "n回のコイントスで連続する表がない有効なコイントスのシーケンスの数を数えます。\n\n引数:\n- n (int): コイントスの回数。\n\n戻り値:\n- unsigned long long: 有効なシーケンスの数。\n\n例:\n  f_16(1) は 2 を返します\n  f_16(2) は 3 を返します", "ko": "n번 던질 때 연속된 앞면이 없는 유효한 동전 던지기 시퀀스의 수를 계산합니다.\n\n매개변수:\n- n (int): 동전 던지기의 횟수.\n\n반환값:\n- unsigned long long: 유효한 시퀀스의 수.\n\n예시:\n  f_16(1) returns 2\n  f_16(2) returns 3", "ml": "n തവണ ചില്ലറ നാണയങ്ങൾ എറിയുമ്പോൾ തുടർച്ചയായ തലകൾ ഇല്ലാത്ത സാധുവായ നാണയ എറിയൽ ക്രമങ്ങളുടെ എണ്ണം എണ്ണുക.\n\nപാരാമീറ്ററുകൾ:\n- n (int): ചില്ലറ നാണയങ്ങൾ എറിയുന്ന എണ്ണം.\n\nമടക്കങ്ങൾ:\n- unsigned long long: സാധുവായ ക്രമങ്ങളുടെ എണ്ണം.\n\nഉദാഹരണങ്ങൾ:\n  f_16(1) 2 മടക്കുന്നു\n  f_16(2) 3 മടക്കുന്നു", "fa": "تعداد دنباله‌های معتبر پرتاب سکه را که در آن‌ها هیچ دو شیر متوالی وجود ندارد در n پرتاب محاسبه کنید.\n\nپارامترها:\n- n (int): تعداد پرتاب‌های سکه.\n\nبازگشت:\n- unsigned long long: تعداد دنباله‌های معتبر.\n\nمثال‌ها:\n  f_16(1) بازمی‌گرداند 2\n  f_16(2) بازمی‌گرداند 3"}}
{"task_id": "CPP/17", "prompt": {"en": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Find the length of the longest consecutive sequence of 1s in the binary \n * representation of a non-negative integer.\n *\n * Parameters:\n * - n (unsigned long long): A non-negative integer (0 ≤ n ≤ 2^64 - 1).\n *\n * Returns:\n * - int: The length of the longest consecutive sequence of 1s in the binary \n *        representation of the given integer.\n *\n * Examples:\n *   >>> f_17(7)\n *   3\n */\nint f_17(unsigned long long n)", "sq": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Gjeni gjatësinë e sekuencës më të gjatë të njëshave radhazi në paraqitjen \n * binare të një numri të plotë jo-negativ.\n *\n * Parametrat:\n * - n (unsigned long long): Një numër i plotë jo-negativ (0 ≤ n ≤ 2^64 - 1).\n *\n * Kthen:\n * - int: Gjatësia e sekuencës më të gjatë të njëshave radhazi në paraqitjen \n *        binare të numrit të dhënë.\n *\n * Shembuj:\n *   >>> f_17(7)\n *   3\n */\nint f_17(unsigned long long n)", "hy": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Գտնել 1-երի ամենաերկար հաջորդական հաջորդականության երկարությունը ոչ բացասական ամբողջ թվի \n * երկբայնական ներկայացման մեջ:\n *\n * Պարամետրեր:\n * - n (unsigned long long): Ոչ բացասական ամբողջ թիվ (0 ≤ n ≤ 2^64 - 1):\n *\n * Վերադարձնում է:\n * - int: 1-երի ամենաերկար հաջորդական հաջորդականության երկարությունը տրված թվի \n *        երկբայնական ներկայացման մեջ:\n *\n * Օրինակներ:\n *   >>> f_17(7)\n *   3\n */\nint f_17(unsigned long long n)", "bn": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * একটি অ-ঋণাত্মক পূর্ণসংখ্যার বাইনারি উপস্থাপনায় 1 এর দীর্ঘতম ক্রমাগত ক্রমের দৈর্ঘ্য খুঁজে বের করুন।\n *\n * প্যারামিটার:\n * - n (unsigned long long): একটি অ-ঋণাত্মক পূর্ণসংখ্যা (0 ≤ n ≤ 2^64 - 1)।\n *\n * রিটার্নস:\n * - int: প্রদত্ত পূর্ণসংখ্যার বাইনারি উপস্থাপনায় 1 এর দীর্ঘতম ক্রমাগত ক্রমের দৈর্ঘ্য।\n *\n * উদাহরণ:\n *   >>> f_17(7)\n *   3\n */\nint f_17(unsigned long long n)", "bg": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Намерете дължината на най-дългата последователна поредица от 1-ци в двоичното \n * представяне на неотрицателно цяло число.\n *\n * Параметри:\n * - n (unsigned long long): Неотрицателно цяло число (0 ≤ n ≤ 2^64 - 1).\n *\n * Връща:\n * - int: Дължината на най-дългата последователна поредица от 1-ци в двоичното \n *        представяне на даденото число.\n *\n * Примери:\n *   >>> f_17(7)\n *   3\n */\nint f_17(unsigned long long n)", "zh": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * 找到非负整数的二进制表示中最长连续1序列的长度。\n *\n * 参数:\n * - n (unsigned long long): 一个非负整数 (0 ≤ n ≤ 2^64 - 1)。\n *\n * 返回:\n * - int: 给定整数的二进制表示中最长连续1序列的长度。\n *\n * 示例:\n *   >>> f_17(7)\n *   3\n */\nint f_17(unsigned long long n)", "fr": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Trouver la longueur de la plus longue séquence consécutive de 1 dans la \n * représentation binaire d'un entier non négatif.\n *\n * Paramètres :\n * - n (unsigned long long) : Un entier non négatif (0 ≤ n ≤ 2^64 - 1).\n *\n * Renvoie :\n * - int : La longueur de la plus longue séquence consécutive de 1 dans la \n *        représentation binaire de l'entier donné.\n *\n * Exemples :\n *   >>> f_17(7)\n *   3\n */\nint f_17(unsigned long long n)", "de": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Finde die Länge der längsten aufeinanderfolgenden Sequenz von 1en in der \n * Binärdarstellung einer nicht-negativen ganzen Zahl.\n *\n * Parameter:\n * - n (unsigned long long): Eine nicht-negative ganze Zahl (0 ≤ n ≤ 2^64 - 1).\n *\n * Rückgabe:\n * - int: Die Länge der längsten aufeinanderfolgenden Sequenz von 1en in der \n *        Binärdarstellung der gegebenen Zahl.\n *\n * Beispiele:\n *   >>> f_17(7)\n *   3\n */\nint f_17(unsigned long long n)", "ha": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Nemo tsawon jere mafi tsawo na 1s a cikin wakilcin binary \n * na lamba mara kyau.\n *\n * Sigogi:\n * - n (unsigned long long): Lamba mara kyau (0 ≤ n ≤ 2^64 - 1).\n *\n * Komawa:\n * - int: Tsawon jere mafi tsawo na 1s a cikin wakilcin binary \n *        na lambar da aka bayar.\n *\n * Misalai:\n *   >>> f_17(7)\n *   3\n */\nint f_17(unsigned long long n)", "hi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * एक गैर-ऋणात्मक पूर्णांक के द्विआधारी रूप में 1s के सबसे लंबे लगातार अनुक्रम की लंबाई खोजें।\n *\n * पैरामीटर:\n * - n (unsigned long long): एक गैर-ऋणात्मक पूर्णांक (0 ≤ n ≤ 2^64 - 1)।\n *\n * रिटर्न करता है:\n * - int: दिए गए पूर्णांक के द्विआधारी रूप में 1s के सबसे लंबे लगातार अनुक्रम की लंबाई।\n *\n * उदाहरण:\n *   >>> f_17(7)\n *   3\n */\nint f_17(unsigned long long n)", "hu": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Keresse meg a leghosszabb egymást követő 1-esek sorozatának hosszát egy nem negatív egész szám bináris \n * ábrázolásában.\n *\n * Paraméterek:\n * - n (unsigned long long): Egy nem negatív egész szám (0 ≤ n ≤ 2^64 - 1).\n *\n * Visszatérési érték:\n * - int: A leghosszabb egymást követő 1-esek sorozatának hossza a megadott egész szám bináris \n *        ábrázolásában.\n *\n * Példák:\n *   >>> f_17(7)\n *   3\n */\nint f_17(unsigned long long n)", "es": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Encuentra la longitud de la secuencia consecutiva más larga de 1s en la \n * representación binaria de un entero no negativo.\n *\n * Parámetros:\n * - n (unsigned long long): Un entero no negativo (0 ≤ n ≤ 2^64 - 1).\n *\n * Devuelve:\n * - int: La longitud de la secuencia consecutiva más larga de 1s en la \n *        representación binaria del entero dado.\n *\n * Ejemplos:\n *   >>> f_17(7)\n *   3\n */\nint f_17(unsigned long long n)", "arb": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * إيجاد طول أطول تسلسل متتالي من الأرقام 1 في التمثيل الثنائي لعدد صحيح غير سالب.\n *\n * المعاملات:\n * - n (unsigned long long): عدد صحيح غير سالب (0 ≤ n ≤ 2^64 - 1).\n *\n * يعيد:\n * - int: طول أطول تسلسل متتالي من الأرقام 1 في التمثيل الثنائي للعدد المعطى.\n *\n * أمثلة:\n *   >>> f_17(7)\n *   3\n */\nint f_17(unsigned long long n)", "sw": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Tafuta urefu wa mlolongo mrefu zaidi wa 1 mfululizo katika uwakilishi wa \n * binary wa nambari isiyo hasi.\n *\n * Vigezo:\n * - n (unsigned long long): Nambari isiyo hasi (0 ≤ n ≤ 2^64 - 1).\n *\n * Inarejesha:\n * - int: Urefu wa mlolongo mrefu zaidi wa 1 mfululizo katika uwakilishi wa \n *        binary wa nambari iliyotolewa.\n *\n * Mifano:\n *   >>> f_17(7)\n *   3\n */\nint f_17(unsigned long long n)", "tr": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Bir pozitif olmayan tam sayının ikili gösterimindeki en uzun ardışık 1 dizisinin \n * uzunluğunu bulun.\n *\n * Parametreler:\n * - n (unsigned long long): Pozitif olmayan bir tam sayı (0 ≤ n ≤ 2^64 - 1).\n *\n * Döndürür:\n * - int: Verilen tam sayının ikili gösterimindeki en uzun ardışık 1 dizisinin \n *        uzunluğu.\n *\n * Örnekler:\n *   >>> f_17(7)\n *   3\n */\nint f_17(unsigned long long n)", "vi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Tìm độ dài của dãy số 1 liên tiếp dài nhất trong biểu diễn nhị phân \n * của một số nguyên không âm.\n *\n * Tham số:\n * - n (unsigned long long): Một số nguyên không âm (0 ≤ n ≤ 2^64 - 1).\n *\n * Trả về:\n * - int: Độ dài của dãy số 1 liên tiếp dài nhất trong biểu diễn nhị phân \n *        của số nguyên đã cho.\n *\n * Ví dụ:\n *   >>> f_17(7)\n *   3\n */\nint f_17(unsigned long long n)", "id": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Temukan panjang urutan terpanjang dari 1s berturut-turut dalam representasi \n * biner dari bilangan bulat non-negatif.\n *\n * Parameter:\n * - n (unsigned long long): Sebuah bilangan bulat non-negatif (0 ≤ n ≤ 2^64 - 1).\n *\n * Mengembalikan:\n * - int: Panjang urutan terpanjang dari 1s berturut-turut dalam representasi \n *        biner dari bilangan bulat yang diberikan.\n *\n * Contoh:\n *   >>> f_17(7)\n *   3\n */\nint f_17(unsigned long long n)", "ja": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * 非負整数の2進数表現における1の最長連続シーケンスの長さを見つけます。\n *\n * パラメータ:\n * - n (unsigned long long): 非負整数 (0 ≤ n ≤ 2^64 - 1)。\n *\n * 戻り値:\n * - int: 与えられた整数の2進数表現における1の最長連続シーケンスの長さ。\n *\n * 例:\n *   >>> f_17(7)\n *   3\n */\nint f_17(unsigned long long n)", "ko": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * 이진수 표현에서 1의 가장 긴 연속 시퀀스의 길이를 찾습니다.\n *\n * 매개변수:\n * - n (unsigned long long): 음이 아닌 정수 (0 ≤ n ≤ 2^64 - 1).\n *\n * 반환값:\n * - int: 주어진 정수의 이진수 표현에서 1의 가장 긴 연속 시퀀스의 길이.\n *\n * 예시:\n *   >>> f_17(7)\n *   3\n */\nint f_17(unsigned long long n)", "ml": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * ഒരു അസാധാരണമായ പാസിറ്റീവ് പൂർണ്ണസംഖ്യയുടെ ബൈനറി പ്രതിനിധാനത്തിലെ \n * ഏറ്റവും നീളമുള്ള അനന്തരമായ 1കളുടെ ശ്രേണിയുടെ നീളം കണ്ടെത്തുക.\n *\n * പാരാമീറ്ററുകൾ:\n * - n (unsigned long long): ഒരു അസാധാരണമായ പാസിറ്റീവ് പൂർണ്ണസംഖ്യ (0 ≤ n ≤ 2^64 - 1).\n *\n * തിരിച്ചുവരവ് മൂല്യം:\n * - int: നൽകിയിരിക്കുന്ന പൂർണ്ണസംഖ്യയുടെ ബൈനറി പ്രതിനിധാനത്തിലെ \n *        ഏറ്റവും നീളമുള്ള അനന്തരമായ 1കളുടെ ശ്രേണിയുടെ നീളം.\n *\n * ഉദാഹരണങ്ങൾ:\n *   >>> f_17(7)\n *   3\n */\nint f_17(unsigned long long n)", "fa": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * طول بلندترین دنباله متوالی از 1ها را در نمایش دودویی یک عدد صحیح غیرمنفی پیدا کنید.\n *\n * پارامترها:\n * - n (unsigned long long): یک عدد صحیح غیرمنفی (0 ≤ n ≤ 2^64 - 1).\n *\n * بازگشت:\n * - int: طول بلندترین دنباله متوالی از 1ها در نمایش دودویی عدد داده شده.\n *\n * مثال‌ها:\n *   >>> f_17(7)\n *   3\n */\nint f_17(unsigned long long n)"}, "canonical_solution": "{\n    int max_length = 0;\n    int current_length = 0;\n    while (n) {\n        if (n & 1) {\n            current_length++;\n        } else {\n            if (current_length > max_length) {\n                max_length = current_length;\n            }\n            current_length = 0;\n        }\n        n >>= 1;\n    }\n    if (current_length > max_length) {\n        max_length = current_length;\n    }\n    return max_length;\n}", "instruction": {"en": "Write a CPP function `int f_17(unsigned long long n)` to solve the following problem:\nFind the length of the longest consecutive sequence of 1s in the binary representation of a non-negative integer.\n\nParameters:\n- n (unsigned long long): A non-negative integer (0 ≤ n ≤ 2^64 - 1).\n\nReturns:\n- int: The length of the longest consecutive sequence of 1s in the binary representation of the given integer.\n\nExamples:\n  >>> f_17(7)\n  3\n", "sq": "Shkruani një funksion CPP `int f_17(unsigned long long n)` për të zgjidhur problemin e mëposhtëm:\nGjeni gjatësinë e sekuencës më të gjatë të njëshave radhazi në paraqitjen binare të një numri të plotë jo-negativ.\n\nParametrat:\n- n (unsigned long long): Një numër i plotë jo-negativ (0 ≤ n ≤ 2^64 - 1).\n\nKthen:\n- int: Gjatësia e sekuencës më të gjatë të njëshave radhazi në paraqitjen binare të numrit të dhënë.\n\nShembuj:\n  >>> f_17(7)\n  3", "hy": "Գրեք CPP ֆունկցիա `int f_17(unsigned long long n)` հետևյալ խնդիրը լուծելու համար:\nԳտնել ամենաերկար հաջորդական 1-երի հաջորդականության երկարությունը ոչ բացասական ամբողջ թվի բինար ներկայացման մեջ:\n\nՊարամետրեր:\n- n (unsigned long long): Ոչ բացասական ամբողջ թիվ (0 ≤ n ≤ 2^64 - 1):\n\nՎերադարձնում է:\n- int: Տրված ամբողջ թվի բինար ներկայացման մեջ ամենաերկար հաջորդական 1-երի հաջորդականության երկարությունը:\n\nՕրինակներ:\n  >>> f_17(7)\n  3", "bn": "একটি CPP ফাংশন `int f_17(unsigned long long n)` লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\nএকটি অ-ঋণাত্মক পূর্ণসংখ্যার বাইনারি উপস্থাপনার মধ্যে 1s এর দীর্ঘতম ক্রমাগত অনুক্রমের দৈর্ঘ্য খুঁজে বের করুন।\n\nপ্যারামিটারসমূহ:\n- n (unsigned long long): একটি অ-ঋণাত্মক পূর্ণসংখ্যা (0 ≤ n ≤ 2^64 - 1)।\n\nরিটার্নস:\n- int: প্রদত্ত পূর্ণসংখ্যার বাইনারি উপস্থাপনার মধ্যে 1s এর দীর্ঘতম ক্রমাগত অনুক্রমের দৈর্ঘ্য।\n\nউদাহরণসমূহ:\n  >>> f_17(7)\n  3", "bg": "Напишете CPP функция `int f_17(unsigned long long n)`, за да решите следния проблем:  \nНамерете дължината на най-дългата последователна поредица от 1-ци в двоичното представяне на неотрицателно цяло число.\n\nПараметри:\n- n (unsigned long long): Неотрицателно цяло число (0 ≤ n ≤ 2^64 - 1).\n\nВръща:\n- int: Дължината на най-дългата последователна поредица от 1-ци в двоичното представяне на даденото число.\n\nПримери:\n  >>> f_17(7)\n  3", "zh": "编写一个 CPP 函数 `int f_17(unsigned long long n)` 来解决以下问题：\n找到一个非负整数的二进制表示中最长连续 1 的序列长度。\n\n参数：\n- n (unsigned long long): 一个非负整数 (0 ≤ n ≤ 2^64 - 1)。\n\n返回：\n- int: 给定整数的二进制表示中最长连续 1 的序列长度。\n\n示例：\n  >>> f_17(7)\n  3", "fr": "Écrire une fonction CPP `int f_17(unsigned long long n)` pour résoudre le problème suivant :  \nTrouver la longueur de la plus longue séquence consécutive de 1 dans la représentation binaire d'un entier non négatif.\n\nParamètres :  \n- n (unsigned long long) : Un entier non négatif (0 ≤ n ≤ 2^64 - 1).\n\nRenvoie :  \n- int : La longueur de la plus longue séquence consécutive de 1 dans la représentation binaire de l'entier donné.\n\nExemples :  \n  >>> f_17(7)  \n  3  ", "de": "Schreiben Sie eine CPP-Funktion `int f_17(unsigned long long n)`, um das folgende Problem zu lösen:\nFinden Sie die Länge der längsten aufeinanderfolgenden Sequenz von 1en in der Binärdarstellung einer nicht-negativen ganzen Zahl.\n\nParameter:\n- n (unsigned long long): Eine nicht-negative ganze Zahl (0 ≤ n ≤ 2^64 - 1).\n\nRückgabewert:\n- int: Die Länge der längsten aufeinanderfolgenden Sequenz von 1en in der Binärdarstellung der gegebenen Zahl.\n\nBeispiele:\n  >>> f_17(7)\n  3", "ha": "Rubuta aikin CPP `int f_17(unsigned long long n)` don warware matsalar mai zuwa:\nNemo tsawon jerin jere mafi tsawo na 1s a cikin wakilcin binary na lamba mara kyau.\n\nSigogi:\n- n (unsigned long long): Lamba mara kyau (0 ≤ n ≤ 2^64 - 1).\n\nDawowa:\n- int: Tsawon jerin jere mafi tsawo na 1s a cikin wakilcin binary na lambar da aka bayar.\n\nMisalai:\n  >>> f_17(7)\n  3", "hi": "एक CPP फ़ंक्शन `int f_17(unsigned long long n)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nएक गैर-ऋणात्मक पूर्णांक के द्विआधारी प्रतिनिधित्व में 1s के सबसे लंबे अनुक्रम की लंबाई खोजें।\n\nParameters:\n- n (unsigned long long): एक गैर-ऋणात्मक पूर्णांक (0 ≤ n ≤ 2^64 - 1)।\n\nReturns:\n- int: दिए गए पूर्णांक के द्विआधारी प्रतिनिधित्व में 1s के सबसे लंबे अनुक्रम की लंबाई।\n\nExamples:\n  >>> f_17(7)\n  3", "hu": "Írj egy CPP függvényt `int f_17(unsigned long long n)` a következő probléma megoldására:\nTaláld meg a leghosszabb egymást követő 1-esek sorozatának hosszát egy nem-negatív egész szám bináris ábrázolásában.\n\nParaméterek:\n- n (unsigned long long): Egy nem-negatív egész szám (0 ≤ n ≤ 2^64 - 1).\n\nVisszatérési érték:\n- int: A leghosszabb egymást követő 1-esek sorozatának hossza a megadott egész szám bináris ábrázolásában.\n\nPéldák:\n  >>> f_17(7)\n  3", "es": "Escribe una función CPP `int f_17(unsigned long long n)` para resolver el siguiente problema:\nEncuentra la longitud de la secuencia consecutiva más larga de 1s en la representación binaria de un entero no negativo.\n\nParámetros:\n- n (unsigned long long): Un entero no negativo (0 ≤ n ≤ 2^64 - 1).\n\nDevuelve:\n- int: La longitud de la secuencia consecutiva más larga de 1s en la representación binaria del entero dado.\n\nEjemplos:\n  >>> f_17(7)\n  3", "arb": "اكتب دالة CPP `int f_17(unsigned long long n)` لحل المشكلة التالية:\nابحث عن طول أطول تسلسل متتالي من الأرقام 1 في التمثيل الثنائي لعدد صحيح غير سالب.\n\nالمعاملات:\n- n (unsigned long long): عدد صحيح غير سالب (0 ≤ n ≤ 2^64 - 1).\n\nالقيم المعادة:\n- int: طول أطول تسلسل متتالي من الأرقام 1 في التمثيل الثنائي للعدد الصحيح المعطى.\n\nأمثلة:\n  >>> f_17(7)\n  3", "sw": "Andika kazi ya CPP `int f_17(unsigned long long n)` kutatua tatizo lifuatalo:\nPata urefu wa mlolongo mrefu zaidi wa mfululizo wa 1 katika uwakilishi wa binary wa nambari isiyo hasi.\n\nVigezo:\n- n (unsigned long long): Nambari isiyo hasi (0 ≤ n ≤ 2^64 - 1).\n\nInarejesha:\n- int: Urefu wa mlolongo mrefu zaidi wa mfululizo wa 1 katika uwakilishi wa binary wa nambari iliyotolewa.\n\nMifano:\n  >>> f_17(7)\n  3", "tr": "Bir CPP fonksiyonu `int f_17(unsigned long long n)` yazın ve aşağıdaki problemi çözün:\nBir negatif olmayan bir tam sayının ikili gösteriminde en uzun ardışık 1'ler dizisinin uzunluğunu bulun.\n\nParametreler:\n- n (unsigned long long): Negatif olmayan bir tam sayı (0 ≤ n ≤ 2^64 - 1).\n\nDöndürür:\n- int: Verilen tam sayının ikili gösteriminde en uzun ardışık 1'ler dizisinin uzunluğu.\n\nÖrnekler:\n  >>> f_17(7)\n  3", "vi": "Viết một hàm CPP `int f_17(unsigned long long n)` để giải quyết vấn đề sau:\nTìm độ dài của dãy liên tiếp dài nhất của các số 1 trong biểu diễn nhị phân của một số nguyên không âm.\n\nTham số:\n- n (unsigned long long): Một số nguyên không âm (0 ≤ n ≤ 2^64 - 1).\n\nTrả về:\n- int: Độ dài của dãy liên tiếp dài nhất của các số 1 trong biểu diễn nhị phân của số nguyên đã cho.\n\nVí dụ:\n  >>> f_17(7)\n  3", "id": "Tulis fungsi CPP `int f_17(unsigned long long n)` untuk menyelesaikan masalah berikut:\nTemukan panjang urutan 1 berturut-turut terpanjang dalam representasi biner dari bilangan bulat non-negatif.\n\nParameter:\n- n (unsigned long long): Sebuah bilangan bulat non-negatif (0 ≤ n ≤ 2^64 - 1).\n\nMengembalikan:\n- int: Panjang urutan 1 berturut-turut terpanjang dalam representasi biner dari bilangan bulat yang diberikan.\n\nContoh:\n  >>> f_17(7)\n  3", "ja": "以下の問題を解決するために、CPP関数 `int f_17(unsigned long long n)` を作成しなさい:\n非負整数の2進数表現における1の最長連続シーケンスの長さを見つけなさい。\n\nパラメータ:\n- n (unsigned long long): 非負整数 (0 ≤ n ≤ 2^64 - 1)。\n\n戻り値:\n- int: 与えられた整数の2進数表現における1の最長連続シーケンスの長さ。\n\n例:\n  >>> f_17(7)\n  3", "ko": "다음 문제를 해결하기 위해 CPP 함수를 작성하세요 `int f_17(unsigned long long n)`:\n비음수 정수의 이진 표현에서 1이 연속되는 가장 긴 시퀀스의 길이를 찾으세요.\n\n매개변수:\n- n (unsigned long long): 비음수 정수 (0 ≤ n ≤ 2^64 - 1).\n\n반환값:\n- int: 주어진 정수의 이진 표현에서 1이 연속되는 가장 긴 시퀀스의 길이.\n\n예시:\n  >>> f_17(7)\n  3", "ml": "ഒരു സിപിപി ഫംഗ്ഷൻ എഴുതുക `int f_17(unsigned long long n)` ഈ പ്രശ്നം പരിഹരിക്കാൻ:\nഒരു അസാധാരണമായ പൂർണ്ണസംഖ്യയുടെ ബൈനറി പ്രതിനിധാനത്തിൽ ഏറ്റവും നീളമുള്ള തുടർച്ചയായ 1കളുടെ അനുക്രമത്തിന്റെ നീളം കണ്ടെത്തുക.\n\nParameters:\n- n (unsigned long long): ഒരു അസാധാരണമായ പൂർണ്ണസംഖ്യ (0 ≤ n ≤ 2^64 - 1).\n\nReturns:\n- int: നൽകിയിരിക്കുന്ന പൂർണ്ണസംഖ്യയുടെ ബൈനറി പ്രതിനിധാനത്തിൽ ഏറ്റവും നീളമുള്ള തുടർച്ചയായ 1കളുടെ അനുക്രമത്തിന്റെ നീളം.\n\nExamples:\n  >>> f_17(7)\n  3", "fa": "یک تابع CPP به نام `int f_17(unsigned long long n)` بنویسید تا مسئله زیر را حل کند:\nطول بلندترین دنباله متوالی از ۱ها را در نمایش باینری یک عدد صحیح غیرمنفی پیدا کنید.\n\nپارامترها:\n- n (unsigned long long): یک عدد صحیح غیرمنفی (0 ≤ n ≤ 2^64 - 1).\n\nبازگشت:\n- int: طول بلندترین دنباله متوالی از ۱ها در نمایش باینری عدد داده شده.\n\nمثال‌ها:\n  >>> f_17(7)\n  3"}, "level": "hard", "test": "int main()\n{\n    assert(f_17(7) == 3);\n    assert(f_17(13) == 2);\n    assert(f_17(12345) == 3); // New test sample\n    assert(f_17(0b11011101111) == 4); // New test sample using binary literal for clarity\n    assert(f_17(0xFFFFFFFF) == 32); // New test sample: all ones for a 32-bit number\n    assert(f_17(0) == 0); // New test sample: no ones in a zero\n\n    // printf(\"All tests passed!\\n\"); // In C++, you might use std::cout, but it is commented out as per the original code.\n    return 0;\n}", "entry_point": "f_17", "signature": "int f_17(unsigned long long n)", "docstring": {"en": "Find the length of the longest consecutive sequence of 1s in the binary representation of a non-negative integer.\n\nParameters:\n- n (unsigned long long): A non-negative integer (0 ≤ n ≤ 2^64 - 1).\n\nReturns:\n- int: The length of the longest consecutive sequence of 1s in the binary representation of the given integer.\n\nExamples:\n  >>> f_17(7)\n  3\n", "sq": "Gjeni gjatësinë e sekuencës më të gjatë të njëshave radhazi në përfaqësimin binar të një numri të plotë jo-negativ.\n\nParametrat:\n- n (unsigned long long): Një numër i plotë jo-negativ (0 ≤ n ≤ 2^64 - 1).\n\nKthen:\n- int: Gjatësia e sekuencës më të gjatë të njëshave radhazi në përfaqësimin binar të numrit të dhënë.\n\nShembuj:\n  >>> f_17(7)\n  3", "hy": "Բացահայտեք 1-երի ամենաերկար հաջորդական հաջորդականության երկարությունը ոչ բացասական ամբողջ թվի երկբայնի ներկայացման մեջ:\n\nՊարամետրեր:\n- n (unsigned long long): Ոչ բացասական ամբողջ թիվ (0 ≤ n ≤ 2^64 - 1):\n\nՎերադարձնում է:\n- int: Տրված ամբողջ թվի երկբայնի ներկայացման մեջ 1-երի ամենաերկար հաջորդական հաջորդականության երկարությունը:\n\nՕրինակներ:\n  >>> f_17(7)\n  3", "bn": "একটি অ-ঋণাত্মক পূর্ণসংখ্যার বাইনারি উপস্থাপনার মধ্যে 1s এর দীর্ঘতম ক্রমাগত অনুক্রমের দৈর্ঘ্য খুঁজে বের করুন।\n\nপ্যারামিটারসমূহ:\n- n (unsigned long long): একটি অ-ঋণাত্মক পূর্ণসংখ্যা (0 ≤ n ≤ 2^64 - 1)।\n\nফেরত দেয়:\n- int: প্রদত্ত পূর্ণসংখ্যার বাইনারি উপস্থাপনায় 1-এর দীর্ঘতম ধারাবাহিক ক্রমের দৈর্ঘ্য।\n\nউদাহরণসমূহ:\n  >>> f_17(7)\n  3", "bg": "Намерете дължината на най-дългата последователна поредица от 1 в двоичното представяне на неотрицателно цяло число.\n\nПараметри:\n- n (unsigned long long): Неотрицателно цяло число (0 ≤ n ≤ 2^64 - 1).\n\nВръща:\n- int: Дължината на най-дългата последователна поредица от 1 в двоичното представяне на даденото число.\n\nПримери:\n  >>> f_17(7)\n  3", "zh": "找到非负整数的二进制表示中最长连续1序列的长度。\n\n参数:\n- n (unsigned long long): 一个非负整数 (0 ≤ n ≤ 2^64 - 1)。\n\n返回:\n- int: 给定整数的二进制表示中最长连续1序列的长度。\n\n示例:\n  >>> f_17(7)\n  3", "fr": "Trouver la longueur de la plus longue séquence consécutive de 1 dans la représentation binaire d'un entier non négatif.\n\nParamètres :\n- n (unsigned long long) : Un entier non négatif (0 ≤ n ≤ 2^64 - 1).\n\nRenvoie :\n- int : La longueur de la plus longue séquence consécutive de 1 dans la représentation binaire de l'entier donné.\n\nExemples :\n  >>> f_17(7)\n  3\n", "de": "Finden Sie die Länge der längsten aufeinanderfolgenden Sequenz von 1en in der Binärdarstellung einer nicht-negativen ganzen Zahl.\n\nParameter:\n- n (unsigned long long): Eine nicht-negative ganze Zahl (0 ≤ n ≤ 2^64 - 1).\n\nRückgabewert:\n- int: Die Länge der längsten aufeinanderfolgenden Sequenz von 1en in der Binärdarstellung der gegebenen ganzen Zahl.\n\nBeispiele:\n  >>> f_17(7)\n  3\n", "ha": "Nemo tsawon jerin jere mafi tsawo na 1s a cikin wakilcin binary na lamba mara kyau.\n\nSigogi:\n- n (unsigned long long): Wani lamba mara kyau (0 ≤ n ≤ 2^64 - 1).\n\nDawowa:\n- int: Tsawon mafi tsawo jere na 1s a cikin wakilcin binary na lambar da aka bayar.\n\nMisalai:\n  >>> f_17(7)\n  3", "hi": "एक गैर-ऋणात्मक पूर्णांक के द्विआधारी प्रतिनिधित्व में 1s के सबसे लंबे अनुक्रम की लंबाई खोजें।\n\nपैरामीटर्स:\n- n (unsigned long long): एक गैर-ऋणात्मक पूर्णांक (0 ≤ n ≤ 2^64 - 1)।\n\nवापसी:\n- int: दिए गए पूर्णांक के द्विआधारी प्रतिनिधित्व में 1s के सबसे लंबे अनुक्रम की लंबाई।\n\nउदाहरण:\n  >>> f_17(7)\n  3", "hu": "Keresse meg a leghosszabb egymást követő 1-esek sorozatának hosszát egy nem negatív egész szám bináris ábrázolásában.\n\nParaméterek:\n- n (unsigned long long): Egy nem negatív egész szám (0 ≤ n ≤ 2^64 - 1).\n\nVisszatérési érték:\n- int: A leghosszabb egymást követő 1-esek sorozatának hossza a megadott egész szám bináris ábrázolásában.\n\nPéldák:\n  >>> f_17(7)\n  3", "es": "Encontrar la longitud de la secuencia consecutiva más larga de 1s en la representación binaria de un número entero no negativo.\n\nParámetros:\n- n (unsigned long long): Un número entero no negativo (0 ≤ n ≤ 2^64 - 1).\n\nDevuelve:\n- int: La longitud de la secuencia consecutiva más larga de 1s en la representación binaria del número entero dado.\n\nEjemplos:\n  >>> f_17(7)\n  3", "arb": "إيجاد طول أطول تسلسل متتابع من الأرقام 1 في التمثيل الثنائي لعدد صحيح غير سالب.\n\nالمعلمات:\n- n (unsigned long long): عدد صحيح غير سالب (0 ≤ n ≤ 2^64 - 1).\n\nالقيم المعادة:\n- int: طول أطول تسلسل متتابع من الأرقام 1 في التمثيل الثنائي للعدد الصحيح المعطى.\n\nأمثلة:\n  >>> f_17(7)\n  3", "sw": "Pata urefu wa mlolongo mrefu zaidi wa 1 mfululizo katika uwakilishi wa binary wa nambari isiyo hasi.\n\nVigezo:\n- n (unsigned long long): Nambari isiyo hasi (0 ≤ n ≤ 2^64 - 1).\n\nRudisha:\n- int: Urefu wa mlolongo mrefu zaidi wa 1 mfululizo katika uwakilishi wa binary wa nambari iliyotolewa.\n\nMifano:\n  >>> f_17(7)\n  3", "tr": "İkili gösterimdeki bir pozitif olmayan tam sayının ardışık en uzun 1 dizisinin uzunluğunu bulun.\n\nParametreler:\n- n (unsigned long long): Pozitif olmayan bir tam sayı (0 ≤ n ≤ 2^64 - 1).\n\nDöndürür:\n- int: Verilen tam sayının ikili gösterimindeki ardışık en uzun 1 dizisinin uzunluğu.\n\nÖrnekler:\n  >>> f_17(7)\n  3", "vi": "Tìm độ dài của dãy liên tiếp dài nhất của các số 1 trong biểu diễn nhị phân của một số nguyên không âm.\n\nTham số:\n- n (unsigned long long): Một số nguyên không âm (0 ≤ n ≤ 2^64 - 1).\n\nTrả về:\n- int: Độ dài của dãy liên tiếp dài nhất của các số 1 trong biểu diễn nhị phân của số nguyên đã cho.\n\nVí dụ:\n  >>> f_17(7)\n  3", "id": "Temukan panjang urutan 1s terpanjang yang berurutan dalam representasi biner dari bilangan bulat non-negatif.\n\nParameter:\n- n (unsigned long long): Sebuah bilangan bulat non-negatif (0 ≤ n ≤ 2^64 - 1).\n\nMengembalikan:\n- int: Panjang urutan 1s terpanjang yang berurutan dalam representasi biner dari bilangan bulat yang diberikan.\n\nContoh:\n  >>> f_17(7)\n  3", "ja": "非負整数の2進数表現における1の最長連続シーケンスの長さを見つけます。\n\nパラメータ:\n- n (unsigned long long): 非負の整数 (0 ≤ n ≤ 2^64 - 1)。\n\n戻り値:\n- int: 与えられた整数の2進数表現における1の最長連続シーケンスの長さ。\n\n例:\n  >>> f_17(7)\n  3", "ko": "이진수 표현에서 1의 가장 긴 연속 시퀀스의 길이를 찾습니다.\n\n매개변수:\n- n (unsigned long long): 비음수 정수 (0 ≤ n ≤ 2^64 - 1).\n\n반환:\n- int: 주어진 정수의 이진 표현에서 가장 긴 연속된 1의 길이.\n\n예시:\n  >>> f_17(7)\n  3", "ml": "ഒരു അസാധാരണമായ പാസിറ്റീവ് പൂർണ്ണസംഖ്യയുടെ ബൈനറി പ്രതിനിധാനത്തിലെ.\n\nപാരാമീറ്ററുകൾ:\n- n (unsigned long long): ഒരു നെഗറ്റീവ് അല്ലാത്ത പൂർണ്ണസംഖ്യ (0 ≤ n ≤ 2^64 - 1).\n\nമടക്കം:\n- int: നൽകിയിരിക്കുന്ന പൂർണ്ണസംഖ്യയുടെ ബൈനറി പ്രതിനിധാനത്തിലെ ഏറ്റവും നീളമേറിയ തുടർച്ചയായ 1കളുടെ നിരയുടെ നീളം.\n\nഉദാഹരണങ്ങൾ:\n  >>> f_17(7)\n  3", "fa": "طول بلندترین دنباله متوالی از 1ها در نمایش باینری یک عدد صحیح غیرمنفی را پیدا کنید.\n\nپارامترها:\n- n (unsigned long long): یک عدد صحیح غیرمنفی (0 ≤ n ≤ 2^64 - 1).\n\nبازگشت:\n- int: طول بلندترین دنباله متوالی از 1ها در نمایش باینری عدد داده شده.\n\nمثال‌ها:\n  >>> f_17(7)\n  3"}}
{"task_id": "CPP/18", "prompt": {"en": "#include <iostream>\n#include <string>\n#include <cassert>\n/**\n * Generates a unique identifier by interweaving two words in a specified pattern.\n * @param word1 The first word to be used in the ID creation process.\n * @param word2 The second word to be used in the ID creation process.\n * @return A unique identifier formed by alternating characters from the second word,\n *         reversed, with characters from the first word.\n * Example Usage:\n * \n * f_18(\"fish\", \"cat\") returns \"ftiasch\"\n * f_18(\"icpc\", \"acm\") returns \"imccpac\"\n * \n */\nstd::string f_18(const std::string& word1, const std::string& word2)", "sq": "#include <iostream>\n#include <string>\n#include <cassert>\n/**\n * Gjeneron një identifikues unik duke ndërthurur dy fjalë në një model të specifikuar.\n * @param word1 Fjala e parë që do të përdoret në procesin e krijimit të ID-së.\n * @param word2 Fjala e dytë që do të përdoret në procesin e krijimit të ID-së.\n * @return Një identifikues unik i formuar duke alternuar karakteret nga fjala e dytë,\n *         e kthyer mbrapsht, me karaktere nga fjala e parë.\n * Shembull Përdorimi:\n * \n * f_18(\"fish\", \"cat\") returns \"ftiasch\"\n * f_18(\"icpc\", \"acm\") returns \"imccpac\"\n * \n */\nstd::string f_18(const std::string& word1, const std::string& word2)", "hy": "#include <iostream>\n#include <string>\n#include <cassert>\n/**\n * Ստեղծում է եզակի նույնացուցիչ՝ երկու բառերը որոշակի ձևով միահյուսելով:\n * @param word1 Առաջին բառը, որը կօգտագործվի ID ստեղծման գործընթացում:\n * @param word2 Երկրորդ բառը, որը կօգտագործվի ID ստեղծման գործընթացում:\n * @return Եզակի նույնացուցիչ, որը ձևավորվում է երկրորդ բառի հակադարձված\n *         տառերը հերթագայելով առաջին բառի տառերի հետ:\n * Օրինակային օգտագործում:\n * \n * f_18(\"fish\", \"cat\") վերադարձնում է \"ftiasch\"\n * f_18(\"icpc\", \"acm\") վերադարձնում է \"imccpac\"\n * \n */\nstd::string f_18(const std::string& word1, const std::string& word2)", "bn": "#include <iostream>\n#include <string>\n#include <cassert>\n/**\n * একটি অনন্য শনাক্তকারী তৈরি করে দুটি শব্দকে একটি নির্দিষ্ট প্যাটার্নে আন্তঃপ্রবাহিত করে।\n * @param word1 আইডি তৈরির প্রক্রিয়ায় ব্যবহৃত প্রথম শব্দ।\n * @param word2 আইডি তৈরির প্রক্রিয়ায় ব্যবহৃত দ্বিতীয় শব্দ।\n * @return একটি অনন্য শনাক্তকারী যা দ্বিতীয় শব্দের অক্ষরগুলি, বিপরীতক্রমে, প্রথম শব্দের অক্ষরগুলির সাথে পর্যায়ক্রমে গঠিত।\n * উদাহরণ ব্যবহার:\n * \n * f_18(\"fish\", \"cat\") returns \"ftiasch\"\n * f_18(\"icpc\", \"acm\") returns \"imccpac\"\n * \n */\nstd::string f_18(const std::string& word1, const std::string& word2)", "bg": "#include <iostream>\n#include <string>\n#include <cassert>\n/**\n * Генерира уникален идентификатор чрез преплитане на две думи в определен модел.\n * @param word1 Първата дума, която ще се използва в процеса на създаване на идентификатора.\n * @param word2 Втората дума, която ще се използва в процеса на създаване на идентификатора.\n * @return Уникален идентификатор, образуван чрез редуване на символи от втората дума,\n *         обърната, със символи от първата дума.\n * Пример за използване:\n * \n * f_18(\"fish\", \"cat\") връща \"ftiasch\"\n * f_18(\"icpc\", \"acm\") връща \"imccpac\"\n * \n */\nstd::string f_18(const std::string& word1, const std::string& word2)", "zh": "#include <iostream>\n#include <string>\n#include <cassert>\n/**\n * 通过以指定模式交织两个单词生成唯一标识符。\n * @param word1 在ID创建过程中使用的第一个单词。\n * @param word2 在ID创建过程中使用的第二个单词。\n * @return 一个唯一标识符，由第二个单词的字符反转后与第一个单词的字符交替形成。\n * 示例用法：\n * \n * f_18(\"fish\", \"cat\") 返回 \"ftiasch\"\n * f_18(\"icpc\", \"acm\") 返回 \"imccpac\"\n * \n */\nstd::string f_18(const std::string& word1, const std::string& word2)", "fr": "#include <iostream>\n#include <string>\n#include <cassert>\n/**\n * Génère un identifiant unique en entrelaçant deux mots selon un schéma spécifié.\n * @param word1 Le premier mot à utiliser dans le processus de création de l'identifiant.\n * @param word2 Le deuxième mot à utiliser dans le processus de création de l'identifiant.\n * @return Un identifiant unique formé en alternant les caractères du deuxième mot,\n *         inversé, avec les caractères du premier mot.\n * Exemple d'utilisation :\n * \n * f_18(\"fish\", \"cat\") returns \"ftiasch\"\n * f_18(\"icpc\", \"acm\") returns \"imccpac\"\n * \n */\nstd::string f_18(const std::string& word1, const std::string& word2)", "de": "#include <iostream>\n#include <string>\n#include <cassert>\n/**\n * Generiert eine eindeutige Kennung, indem zwei Wörter in einem bestimmten Muster verflochten werden.\n * @param word1 Das erste Wort, das im ID-Erstellungsprozess verwendet wird.\n * @param word2 Das zweite Wort, das im ID-Erstellungsprozess verwendet wird.\n * @return Eine eindeutige Kennung, die durch abwechselnde Zeichen aus dem zweiten Wort,\n *         rückwärts, mit Zeichen aus dem ersten Wort gebildet wird.\n * Beispielverwendung:\n * \n * f_18(\"fish\", \"cat\") gibt \"ftiasch\" zurück\n * f_18(\"icpc\", \"acm\") gibt \"imccpac\" zurück\n * \n */\nstd::string f_18(const std::string& word1, const std::string& word2)", "ha": "#include <iostream>\n#include <string>\n#include <cassert>\n/**\n * Yana samar da mai ganowa na musamman ta hanyar haɗa kalmomi biyu a cikin tsari da aka fayyace.\n * @param word1 Kalma ta farko da za a yi amfani da ita a cikin tsarin ƙirƙirar ID.\n * @param word2 Kalma ta biyu da za a yi amfani da ita a cikin tsarin ƙirƙirar ID.\n * @return Mai ganowa na musamman da aka samar ta hanyar musanya haruffa daga kalma ta biyu,\n *         a juye, tare da haruffa daga kalma ta farko.\n * Misalin Amfani:\n * \n * f_18(\"fish\", \"cat\") returns \"ftiasch\"\n * f_18(\"icpc\", \"acm\") returns \"imccpac\"\n * \n */\nstd::string f_18(const std::string& word1, const std::string& word2)", "hi": "#include <iostream>\n#include <string>\n#include <cassert>\n/**\n * दो शब्दों को एक निर्दिष्ट पैटर्न में मिलाकर एक अद्वितीय पहचानकर्ता उत्पन्न करता है।\n * @param word1 पहचानकर्ता निर्माण प्रक्रिया में उपयोग के लिए पहला शब्द।\n * @param word2 पहचानकर्ता निर्माण प्रक्रिया में उपयोग के लिए दूसरा शब्द।\n * @return एक अद्वितीय पहचानकर्ता जो दूसरे शब्द के अक्षरों को उल्टा करके,\n *         पहले शब्द के अक्षरों के साथ बारी-बारी से बनता है।\n * उदाहरण उपयोग:\n * \n * f_18(\"fish\", \"cat\") returns \"ftiasch\"\n * f_18(\"icpc\", \"acm\") returns \"imccpac\"\n * \n */\nstd::string f_18(const std::string& word1, const std::string& word2)", "hu": "#include <iostream>\n#include <string>\n#include <cassert>\n/**\n * Egyedi azonosítót generál két szó megadott mintázat szerinti összefűzésével.\n * @param word1 Az első szó, amelyet az azonosító létrehozásához használunk.\n * @param word2 A második szó, amelyet az azonosító létrehozásához használunk.\n * @return Egy egyedi azonosító, amely a második szó karaktereiből, fordítva,\n *         és az első szó karaktereiből váltakozva áll.\n * Példa használat:\n * \n * f_18(\"fish\", \"cat\") visszaadja \"ftiasch\"\n * f_18(\"icpc\", \"acm\") visszaadja \"imccpac\"\n * \n */\nstd::string f_18(const std::string& word1, const std::string& word2)", "es": "#include <iostream>\n#include <string>\n#include <cassert>\n/**\n * Genera un identificador único entrelazando dos palabras en un patrón especificado.\n * @param word1 La primera palabra que se utilizará en el proceso de creación del ID.\n * @param word2 La segunda palabra que se utilizará en el proceso de creación del ID.\n * @return Un identificador único formado alternando caracteres de la segunda palabra,\n *         invertida, con caracteres de la primera palabra.\n * Ejemplo de uso:\n * \n * f_18(\"fish\", \"cat\") returns \"ftiasch\"\n * f_18(\"icpc\", \"acm\") returns \"imccpac\"\n * \n */\nstd::string f_18(const std::string& word1, const std::string& word2)", "arb": "#include <iostream>\n#include <string>\n#include <cassert>\n/**\n * يولد معرفًا فريدًا عن طريق دمج كلمتين في نمط محدد.\n * @param word1 الكلمة الأولى التي ستستخدم في عملية إنشاء المعرف.\n * @param word2 الكلمة الثانية التي ستستخدم في عملية إنشاء المعرف.\n * @return معرف فريد يتكون من تبديل الأحرف من الكلمة الثانية،\n *         معكوسة، مع الأحرف من الكلمة الأولى.\n * مثال على الاستخدام:\n * \n * f_18(\"fish\", \"cat\") returns \"ftiasch\"\n * f_18(\"icpc\", \"acm\") returns \"imccpac\"\n * \n */\nstd::string f_18(const std::string& word1, const std::string& word2)", "sw": "#include <iostream>\n#include <string>\n#include <cassert>\n/**\n * Hutoa kitambulisho cha kipekee kwa kuchanganya maneno mawili kwa mtindo maalum.\n * @param word1 Neno la kwanza litakalotumika katika mchakato wa kuunda kitambulisho.\n * @param word2 Neno la pili litakalotumika katika mchakato wa kuunda kitambulisho.\n * @return Kitambulisho cha kipekee kinachoundwa kwa kubadilisha herufi kutoka neno la pili,\n *         lililogeuzwa, na herufi kutoka neno la kwanza.\n * Mfano wa Matumizi:\n * \n * f_18(\"fish\", \"cat\") returns \"ftiasch\"\n * f_18(\"icpc\", \"acm\") returns \"imccpac\"\n * \n */\nstd::string f_18(const std::string& word1, const std::string& word2)", "tr": "#include <iostream>\n#include <string>\n#include <cassert>\n/**\n * İki kelimeyi belirli bir desende iç içe geçirerek benzersiz bir kimlik oluşturur.\n * @param word1 Kimlik oluşturma sürecinde kullanılacak birinci kelime.\n * @param word2 Kimlik oluşturma sürecinde kullanılacak ikinci kelime.\n * @return İkinci kelimenin ters çevrilmiş karakterleri ile birinci kelimenin karakterlerinin\n *         dönüşümlü olarak kullanılmasıyla oluşturulan benzersiz bir kimlik.\n * Örnek Kullanım:\n * \n * f_18(\"fish\", \"cat\") \"ftiasch\" döndürür\n * f_18(\"icpc\", \"acm\") \"imccpac\" döndürür\n * \n */\nstd::string f_18(const std::string& word1, const std::string& word2)", "vi": "#include <iostream>\n#include <string>\n#include <cassert>\n/**\n * Tạo một định danh duy nhất bằng cách xen kẽ hai từ theo một mẫu được chỉ định.\n * @param word1 Từ đầu tiên được sử dụng trong quá trình tạo ID.\n * @param word2 Từ thứ hai được sử dụng trong quá trình tạo ID.\n * @return Một định danh duy nhất được tạo ra bằng cách xen kẽ các ký tự từ từ thứ hai,\n *         đảo ngược, với các ký tự từ từ đầu tiên.\n * Ví dụ sử dụng:\n * \n * f_18(\"fish\", \"cat\") trả về \"ftiasch\"\n * f_18(\"icpc\", \"acm\") trả về \"imccpac\"\n * \n */\nstd::string f_18(const std::string& word1, const std::string& word2)", "id": "#include <iostream>\n#include <string>\n#include <cassert>\n/**\n * Menghasilkan pengenal unik dengan menggabungkan dua kata dalam pola tertentu.\n * @param word1 Kata pertama yang akan digunakan dalam proses pembuatan ID.\n * @param word2 Kata kedua yang akan digunakan dalam proses pembuatan ID.\n * @return Pengenal unik yang dibentuk dengan menggabungkan karakter dari kata kedua,\n *         dibalik, dengan karakter dari kata pertama.\n * Contoh Penggunaan:\n * \n * f_18(\"fish\", \"cat\") returns \"ftiasch\"\n * f_18(\"icpc\", \"acm\") returns \"imccpac\"\n * \n */\nstd::string f_18(const std::string& word1, const std::string& word2)", "ja": "#include <iostream>\n#include <string>\n#include <cassert>\n/**\n * 2つの単語を指定されたパターンで交互に組み合わせて一意の識別子を生成します。\n * @param word1 ID作成プロセスで使用する最初の単語。\n * @param word2 ID作成プロセスで使用する2番目の単語。\n * @return 2番目の単語の文字を逆順にし、最初の単語の文字と交互に組み合わせて形成された一意の識別子。\n * 使用例:\n * \n * f_18(\"fish\", \"cat\") は \"ftiasch\" を返します\n * f_18(\"icpc\", \"acm\") は \"imccpac\" を返します\n * \n */\nstd::string f_18(const std::string& word1, const std::string& word2)", "ko": "#include <iostream>\n#include <string>\n#include <cassert>\n/**\n * 두 단어를 지정된 패턴으로 엮어 고유 식별자를 생성합니다.\n * @param word1 ID 생성 과정에서 사용될 첫 번째 단어입니다.\n * @param word2 ID 생성 과정에서 사용될 두 번째 단어입니다.\n * @return 두 번째 단어의 문자를 첫 번째 단어의 문자와 교대로 사용하여,\n *         뒤집어 형성된 고유 식별자를 반환합니다.\n * 사용 예시:\n * \n * f_18(\"fish\", \"cat\") returns \"ftiasch\"\n * f_18(\"icpc\", \"acm\") returns \"imccpac\"\n * \n */\nstd::string f_18(const std::string& word1, const std::string& word2)", "ml": "#include <iostream>\n#include <string>\n#include <cassert>\n/**\n * രണ്ട് വാക്കുകൾ ഒരു നിർദ്ദിഷ്ട മാതൃകയിൽ ചേർത്തുകൊണ്ട് ഒരു അതുല്യമായ ഐഡന്റിഫയർ സൃഷ്ടിക്കുന്നു.\n * @param word1 ഐഡി സൃഷ്ടി പ്രക്രിയയിൽ ഉപയോഗിക്കേണ്ട ആദ്യത്തെ വാക്ക്.\n * @param word2 ഐഡി സൃഷ്ടി പ്രക്രിയയിൽ ഉപയോഗിക്കേണ്ട രണ്ടാം വാക്ക്.\n * @return രണ്ടാം വാക്കിൽ നിന്നുള്ള പ്രത്യയങ്ങൾ, മറിച്ചുള്ള, ആദ്യ വാക്കിൽ നിന്നുള്ള പ്രത്യയങ്ങളുമായി മാറി രൂപീകരിച്ച\n *         ഒരു അതുല്യമായ ഐഡന്റിഫയർ.\n * ഉദാഹരണ ഉപയോഗം:\n * \n * f_18(\"fish\", \"cat\") returns \"ftiasch\"\n * f_18(\"icpc\", \"acm\") returns \"imccpac\"\n * \n */\nstd::string f_18(const std::string& word1, const std::string& word2)", "fa": "#include <iostream>\n#include <string>\n#include <cassert>\n/**\n * یک شناسه منحصر به فرد با در هم آمیختن دو کلمه در یک الگوی مشخص تولید می‌کند.\n * @param word1 اولین کلمه‌ای که در فرآیند ایجاد شناسه استفاده می‌شود.\n * @param word2 دومین کلمه‌ای که در فرآیند ایجاد شناسه استفاده می‌شود.\n * @return یک شناسه منحصر به فرد که با جایگزینی کاراکترهای کلمه دوم،\n *         به صورت معکوس، با کاراکترهای کلمه اول تشکیل شده است.\n * مثال استفاده:\n * \n * f_18(\"fish\", \"cat\") returns \"ftiasch\"\n * f_18(\"icpc\", \"acm\") returns \"imccpac\"\n * \n */\nstd::string f_18(const std::string& word1, const std::string& word2)"}, "canonical_solution": "{\n    std::string id;\n    int j = 0, k = word2.length() - 1;\n    for (int i = 0; i < word1.length() + word2.length(); ++i) {\n        if (i % 2 == 0) {\n            id += word1[j++]; // Take character from word1\n        } else {\n            id += word2[k--]; // Take character from word2 in reverse\n        }\n    }\n    return id;\n}", "instruction": {"en": "Write a CPP function `std::string f_18(const std::string& word1, const std::string& word2)` to solve the following problem:\nGenerates a unique identifier by interweaving two words in a specified pattern.\n@param word1 The first word to be used in the ID creation process.\n@param word2 The second word to be used in the ID creation process.\n@return A unique identifier formed by alternating characters from the second word, reversed, with characters from the first word.\nExample Usage:\n\nf_18(\"fish\", \"cat\") returns \"ftiasch\"\nf_18(\"icpc\", \"acm\") returns \"imccpac\"\n\n", "sq": "Shkruani një funksion CPP `std::string f_18(const std::string& word1, const std::string& word2)` për të zgjidhur problemin e mëposhtëm:\nGjeneron një identifikues unik duke ndërthurur dy fjalë në një model të specifikuar.\n@param word1 Fjalë e parë që do të përdoret në procesin e krijimit të ID-së.\n@param word2 Fjalë e dytë që do të përdoret në procesin e krijimit të ID-së.\n@return Një identifikues unik i formuar duke alternuar karakteret nga fjala e dytë, e përmbysur, me karakteret nga fjala e parë.\nShembull Përdorimi:\n\nf_18(\"fish\", \"cat\") returns \"ftiasch\"\nf_18(\"icpc\", \"acm\") returns \"imccpac\"", "hy": "Գրեք CPP ֆունկցիա `std::string f_18(const std::string& word1, const std::string& word2)` հետևյալ խնդիրը լուծելու համար:\nՍտեղծում է եզակի նույնացուցիչ՝ երկու բառերը որոշակի նախշով փոխկապակցելով:\n@param word1 Առաջին բառը, որը կօգտագործվի ID ստեղծման գործընթացում:\n@param word2 Երկրորդ բառը, որը կօգտագործվի ID ստեղծման գործընթացում:\n@return Եզակի նույնացուցիչ, որը ձևավորվում է երկրորդ բառի, շրջված, և առաջին բառի տառերը հերթափոխելով:\nՕրինակ օգտագործում:\n\nf_18(\"fish\", \"cat\") վերադարձնում է \"ftiasch\"\nf_18(\"icpc\", \"acm\") վերադարձնում է \"imccpac\"", "bn": "একটি CPP ফাংশন `std::string f_18(const std::string& word1, const std::string& word2)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nদুটি শব্দকে একটি নির্দিষ্ট প্যাটার্নে একত্রিত করে একটি অনন্য শনাক্তকারী তৈরি করে।\n@param word1 আইডি তৈরির প্রক্রিয়ায় ব্যবহৃত প্রথম শব্দ।\n@param word2 আইডি তৈরির প্রক্রিয়ায় ব্যবহৃত দ্বিতীয় শব্দ।\n@return দ্বিতীয় শব্দের বিপরীত অক্ষরগুলি প্রথম শব্দের অক্ষরগুলির সাথে পর্যায়ক্রমে ব্যবহার করে গঠিত একটি অনন্য শনাক্তকারী।\nউদাহরণ ব্যবহার:\n\nf_18(\"fish\", \"cat\") returns \"ftiasch\"\nf_18(\"icpc\", \"acm\") returns \"imccpac\"", "bg": "Напишете CPP функция `std::string f_18(const std::string& word1, const std::string& word2)`, за да решите следния проблем:\nГенерира уникален идентификатор, като преплита две думи по определен модел.\n@param word1 Първата дума, която ще се използва в процеса на създаване на идентификатор.\n@param word2 Втората дума, която ще се използва в процеса на създаване на идентификатор.\n@return Уникален идентификатор, образуван чрез редуване на символи от втората дума, обърната, със символи от първата дума.\nПример за използване:\n\nf_18(\"fish\", \"cat\") връща \"ftiasch\"\nf_18(\"icpc\", \"acm\") връща \"imccpac\"", "zh": "编写一个 CPP 函数 `std::string f_18(const std::string& word1, const std::string& word2)` 来解决以下问题：\n生成一个通过以指定模式交织两个单词的唯一标识符。\n@param word1 在 ID 创建过程中使用的第一个单词。\n@param word2 在 ID 创建过程中使用的第二个单词。\n@return 一个通过从第二个单词反向交替字符与第一个单词字符形成的唯一标识符。\n示例用法：\n\nf_18(\"fish\", \"cat\") returns \"ftiasch\"\nf_18(\"icpc\", \"acm\") returns \"imccpac\"", "fr": "Écrire une fonction CPP `std::string f_18(const std::string& word1, const std::string& word2)` pour résoudre le problème suivant :\nGénère un identifiant unique en entrelaçant deux mots selon un modèle spécifié.\n@param word1 Le premier mot à utiliser dans le processus de création de l'identifiant.\n@param word2 Le deuxième mot à utiliser dans le processus de création de l'identifiant.\n@return Un identifiant unique formé en alternant les caractères du deuxième mot, inversé, avec les caractères du premier mot.\nExemple d'utilisation :\n\nf_18(\"fish\", \"cat\") returns \"ftiasch\"\nf_18(\"icpc\", \"acm\") returns \"imccpac\"", "de": "Schreiben Sie eine CPP-Funktion `std::string f_18(const std::string& word1, const std::string& word2)`, um das folgende Problem zu lösen:\nErzeugt einen eindeutigen Bezeichner, indem zwei Wörter in einem bestimmten Muster verflochten werden.\n@param word1 Das erste Wort, das im ID-Erstellungsprozess verwendet wird.\n@param word2 Das zweite Wort, das im ID-Erstellungsprozess verwendet wird.\n@return Ein eindeutiger Bezeichner, der durch abwechselnde Zeichen aus dem zweiten Wort, umgekehrt, mit Zeichen aus dem ersten Wort gebildet wird.\nBeispielverwendung:\n\nf_18(\"fish\", \"cat\") gibt \"ftiasch\" zurück\nf_18(\"icpc\", \"acm\") gibt \"imccpac\" zurück", "ha": "Rubuta aikin CPP `std::string f_18(const std::string& word1, const std::string& word2)` don warware matsalar mai zuwa:\nƘirƙirar mai ganowa na musamman ta hanyar haɗa kalmomi biyu a cikin wata tsari da aka fayyace.\n@param word1 Kalma ta farko da za a yi amfani da ita a cikin tsarin ƙirƙirar ID.\n@param word2 Kalma ta biyu da za a yi amfani da ita a cikin tsarin ƙirƙirar ID.\n@return Mai ganowa na musamman da aka samar ta hanyar madadin haruffa daga kalma ta biyu, a juye, tare da haruffa daga kalma ta farko.\nMisalin Amfani:\n\nf_18(\"fish\", \"cat\") returns \"ftiasch\"\nf_18(\"icpc\", \"acm\") returns \"imccpac\"", "hi": "एक CPP फ़ंक्शन `std::string f_18(const std::string& word1, const std::string& word2)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदो शब्दों को एक निर्दिष्ट पैटर्न में मिलाकर एक अद्वितीय पहचानकर्ता उत्पन्न करता है।\n@param word1 आईडी निर्माण प्रक्रिया में उपयोग किए जाने वाला पहला शब्द।\n@param word2 आईडी निर्माण प्रक्रिया में उपयोग किए जाने वाला दूसरा शब्द।\n@return एक अद्वितीय पहचानकर्ता जो दूसरे शब्द के उल्टे वर्णों को पहले शब्द के वर्णों के साथ वैकल्पिक करके बनता है।\nउदाहरण उपयोग:\n\nf_18(\"fish\", \"cat\") returns \"ftiasch\"\nf_18(\"icpc\", \"acm\") returns \"imccpac\"", "hu": "Írj egy CPP függvényt `std::string f_18(const std::string& word1, const std::string& word2)` a következő probléma megoldására:\nEgyedi azonosító generálása két szó összefonásával egy meghatározott mintában.\n@param word1 Az első szó, amelyet az azonosító létrehozási folyamatában használnak.\n@param word2 A második szó, amelyet az azonosító létrehozási folyamatában használnak.\n@return Egy egyedi azonosító, amelyet a második szó visszafelé váltakozó karakterei és az első szó karakterei alkotnak.\nPélda használat:\n\nf_18(\"fish\", \"cat\") visszaadja \"ftiasch\"\nf_18(\"icpc\", \"acm\") visszaadja \"imccpac\"", "es": "Escribe una función CPP `std::string f_18(const std::string& word1, const std::string& word2)` para resolver el siguiente problema:\nGenera un identificador único entrelazando dos palabras en un patrón especificado.\n@param word1 La primera palabra a utilizar en el proceso de creación del ID.\n@param word2 La segunda palabra a utilizar en el proceso de creación del ID.\n@return Un identificador único formado alternando caracteres de la segunda palabra, invertida, con caracteres de la primera palabra.\nEjemplo de uso:\n\nf_18(\"fish\", \"cat\") returns \"ftiasch\"\nf_18(\"icpc\", \"acm\") returns \"imccpac\"", "arb": "اكتب دالة CPP `std::string f_18(const std::string& word1, const std::string& word2)` لحل المشكلة التالية:\nتوليد معرف فريد عن طريق تشابك كلمتين بنمط محدد.\n@param word1 الكلمة الأولى التي ستستخدم في عملية إنشاء المعرف.\n@param word2 الكلمة الثانية التي ستستخدم في عملية إنشاء المعرف.\n@return معرف فريد يتكون من تناوب الأحرف من الكلمة الثانية، معكوسة، مع الأحرف من الكلمة الأولى.\nمثال على الاستخدام:\n\nf_18(\"fish\", \"cat\") returns \"ftiasch\"\nf_18(\"icpc\", \"acm\") returns \"imccpac\"", "sw": "Andika kazi ya CPP `std::string f_18(const std::string& word1, const std::string& word2)` kutatua tatizo lifuatalo:\nHutengeneza kitambulisho cha kipekee kwa kuchanganya maneno mawili katika mpangilio maalum.\n@param word1 Neno la kwanza litakalotumika katika mchakato wa utengenezaji wa kitambulisho.\n@param word2 Neno la pili litakalotumika katika mchakato wa utengenezaji wa kitambulisho.\n@return Kitambulisho cha kipekee kinachoundwa kwa kubadilisha herufi kutoka neno la pili, lililogeuzwa, na herufi kutoka neno la kwanza.\nMfano wa Matumizi:\n\nf_18(\"fish\", \"cat\") inarudisha \"ftiasch\"\nf_18(\"icpc\", \"acm\") inarudisha \"imccpac\"", "tr": "Bir CPP fonksiyonu `std::string f_18(const std::string& word1, const std::string& word2)` yazın ve aşağıdaki problemi çözün:\nBelirli bir desende iki kelimeyi iç içe geçirerek benzersiz bir tanımlayıcı oluşturur.\n@param word1 ID oluşturma sürecinde kullanılacak ilk kelime.\n@param word2 ID oluşturma sürecinde kullanılacak ikinci kelime.\n@return İkinci kelimenin ters çevrilmiş karakterleriyle birinci kelimenin karakterlerinin dönüşümlü olarak birleştirilmesiyle oluşturulan benzersiz bir tanımlayıcı.\nÖrnek Kullanım:\n\nf_18(\"fish\", \"cat\") \"ftiasch\" döndürür\nf_18(\"icpc\", \"acm\") \"imccpac\" döndürür", "vi": "Viết một hàm CPP `std::string f_18(const std::string& word1, const std::string& word2)` để giải quyết vấn đề sau:\nTạo một định danh duy nhất bằng cách xen kẽ hai từ theo một mẫu được chỉ định.\n@param word1 Từ đầu tiên được sử dụng trong quá trình tạo ID.\n@param word2 Từ thứ hai được sử dụng trong quá trình tạo ID.\n@return Một định danh duy nhất được tạo thành bằng cách xen kẽ các ký tự từ từ thứ hai, đảo ngược, với các ký tự từ từ đầu tiên.\nVí dụ Sử Dụng:\n\nf_18(\"fish\", \"cat\") trả về \"ftiasch\"\nf_18(\"icpc\", \"acm\") trả về \"imccpac\"", "id": "Tulis fungsi CPP `std::string f_18(const std::string& word1, const std::string& word2)` untuk menyelesaikan masalah berikut:\nMenghasilkan pengenal unik dengan menganyam dua kata dalam pola tertentu.\n@param word1 Kata pertama yang akan digunakan dalam proses pembuatan ID.\n@param word2 Kata kedua yang akan digunakan dalam proses pembuatan ID.\n@return Sebuah pengenal unik yang dibentuk dengan menggantikan karakter dari kata kedua, dibalik, dengan karakter dari kata pertama.\nContoh Penggunaan:\n\nf_18(\"fish\", \"cat\") mengembalikan \"ftiasch\"\nf_18(\"icpc\", \"acm\") mengembalikan \"imccpac\"", "ja": "CPP関数 `std::string f_18(const std::string& word1, const std::string& word2)` を作成して、次の問題を解決してください:\n指定されたパターンで2つの単語を織り交ぜて一意の識別子を生成します。\n@param word1 ID作成プロセスに使用する最初の単語。\n@param word2 ID作成プロセスに使用する2番目の単語。\n@return 2番目の単語を逆にした文字と最初の単語の文字を交互に組み合わせて形成された一意の識別子。\n使用例:\n\nf_18(\"fish\", \"cat\") は \"ftiasch\" を返します\nf_18(\"icpc\", \"acm\") は \"imccpac\" を返します", "ko": "`std::string f_18(const std::string& word1, const std::string& word2)` 함수를 작성하여 다음 문제를 해결하십시오:\n지정된 패턴으로 두 단어를 엮어 고유 식별자를 생성합니다.\n@param word1 ID 생성 과정에서 사용될 첫 번째 단어입니다.\n@param word2 ID 생성 과정에서 사용될 두 번째 단어입니다.\n@return 두 번째 단어의 문자를 역순으로 첫 번째 단어의 문자와 번갈아 가며 형성된 고유 식별자입니다.\n사용 예:\n\nf_18(\"fish\", \"cat\")는 \"ftiasch\"를 반환합니다.\nf_18(\"icpc\", \"acm\")는 \"imccpac\"를 반환합니다.", "ml": "ഒരു സിപിപി ഫംഗ്ഷൻ എഴുതുക `std::string f_18(const std::string& word1, const std::string& word2)` ഈ പ്രശ്നം പരിഹരിക്കാൻ:\nനിർദ്ദിഷ്ട പാറ്റേണിൽ രണ്ട് വാക്കുകളെ ഇന്റർവീവ് ചെയ്ത് ഒരു യുണീക് ഐഡന്റിഫയർ സൃഷ്ടിക്കുന്നു.\n@param word1 ഐഡി സൃഷ്ടിക്കൽ പ്രക്രിയയിൽ ഉപയോഗിക്കുന്ന ആദ്യ വാക്ക്.\n@param word2 ഐഡി സൃഷ്ടിക്കൽ പ്രക്രിയയിൽ ഉപയോഗിക്കുന്ന രണ്ടാമത്തെ വാക്ക്.\n@return ആദ്യ വാക്കിലെ പ്രത്യയങ്ങൾക്കൊപ്പം രണ്ടാമത്തെ വാക്ക്, മറിച്ചുള്ള പ്രത്യയങ്ങൾ മാറ്റി വെച്ച് രൂപീകരിച്ച ഒരു യുണീക് ഐഡന്റിഫയർ.\nഉദാഹരണ ഉപയോഗം:\n\nf_18(\"fish\", \"cat\") returns \"ftiasch\"\nf_18(\"icpc\", \"acm\") returns \"imccpac\"", "fa": "یک تابع CPP بنویسید `std::string f_18(const std::string& word1, const std::string& word2)` برای حل مشکل زیر:\nتولید یک شناسه منحصر به فرد با در هم آمیختن دو کلمه در یک الگوی مشخص.\n@param word1 اولین کلمه‌ای که در فرآیند ایجاد شناسه استفاده می‌شود.\n@param word2 دومین کلمه‌ای که در فرآیند ایجاد شناسه استفاده می‌شود.\n@return یک شناسه منحصر به فرد که با جایگزینی کاراکترهای کلمه دوم، به صورت معکوس، با کاراکترهای کلمه اول تشکیل شده است.\nمثال استفاده:\n\nf_18(\"fish\", \"cat\") returns \"ftiasch\"\nf_18(\"icpc\", \"acm\") returns \"imccpac\""}, "level": "hard", "test": "int main() {\n    std::string id; // To hold the results from f_18\n\n    id = f_18(\"fish\", \"cat\");\n    assert(id.compare(\"ftiasch\") == 0);\n\n    id = f_18(\"icpc\", \"acm\");\n    assert(id.compare(\"imccpac\") == 0);\n\n    id = f_18(\"oo\", \"w\");\n    assert(id.compare(\"owo\") == 0);\n\n    // Add more test samples\n    id = f_18(\"hello\", \"world\");\n    assert(id.compare(\"hdellrloow\") == 0);\n\n    id = f_18(\"abc\", \"def\");\n    assert(id.compare(\"afbecd\") == 0);\n\n    id = f_18(\"buaanb\", \"nbbuaa\");\n    assert(id.compare(\"bauaauabnbbn\") == 0);\n\n    id = f_18(\"xtuisgood\", \"ilovextu\");\n    assert(id.compare(\"xuttuxiesvgooloid\") == 0);\n\n    // std::cout << \"All tests passed!\" << std::endl;\n\n    return 0;\n}", "entry_point": "f_18", "signature": "std::string f_18(const std::string& word1, const std::string& word2)", "docstring": {"en": "Generates a unique identifier by interweaving two words in a specified pattern.\n@param word1 The first word to be used in the ID creation process.\n@param word2 The second word to be used in the ID creation process.\n@return A unique identifier formed by alternating characters from the second word, reversed, with characters from the first word.\nExample Usage:\n\nf_18(\"fish\", \"cat\") returns \"ftiasch\"\nf_18(\"icpc\", \"acm\") returns \"imccpac\"\n\n", "sq": "Gjeneron një identifikues unik duke ndërthurur dy fjalë sipas një modeli të specifikuar.\n@param word1 Fjala e parë që do të përdoret në procesin e krijimit të ID-së.\n@param word2 Fjala e dytë që do të përdoret në procesin e krijimit të ID-së.\n@return Një identifikues unik i formuar duke alternuar karakteret nga fjala e dytë, e kthyer mbrapsht, me karakteret nga fjala e parë.\nShembull i Përdorimit:\n\nf_18(\"fish\", \"cat\") kthen \"ftiasch\"\nf_18(\"icpc\", \"acm\") kthen \"imccpac\"", "hy": "Ստեղծում է եզակի նույնացուցիչ՝ երկու բառերը որոշակի նախշով միահյուսելով:\n@param word1 Առաջին բառը, որը կօգտագործվի ID ստեղծման գործընթացում:\n@param word2 Երկրորդ բառը, որը կօգտագործվի ID ստեղծման գործընթացում:\n@return Եզակի նույնացուցիչ, որը ձևավորվում է երկրորդ բառի, հակադարձված, և առաջին բառի տառերը հերթագայելով:\nՕրինակ օգտագործում:\n\nf_18(\"fish\", \"cat\") վերադարձնում է \"ftiasch\"\nf_18(\"icpc\", \"acm\") վերադարձնում է \"imccpac\"", "bn": "একটি নির্দিষ্ট প্যাটার্নে দুটি শব্দ একত্রিত করে একটি অনন্য শনাক্তকারী তৈরি করে।\n@param word1 আইডি তৈরির প্রক্রিয়ায় ব্যবহৃত প্রথম শব্দ।\n@param word2 আইডি তৈরির প্রক্রিয়ায় ব্যবহৃত দ্বিতীয় শব্দ।\n@return দ্বিতীয় শব্দের অক্ষরগুলি, উল্টো করে, প্রথম শব্দের অক্ষরগুলির সাথে পর্যায়ক্রমে মিলিয়ে গঠিত একটি অনন্য শনাক্তকারী।\nব্যবহারের উদাহরণ:\n\nf_18(\"fish\", \"cat\") returns \"ftiasch\"\nf_18(\"icpc\", \"acm\") returns \"imccpac\"", "bg": "Генерира уникален идентификатор чрез преплитане на две думи в определен модел.\n@param word1 Първата дума, която ще се използва в процеса на създаване на идентификатора.\n@param word2 Втората дума, която ще се използва в процеса на създаване на идентификатора.\n@return Уникален идентификатор, образуван чрез редуване на символи от втората дума, обърната, със символи от първата дума.\nПример за използване:\n\nf_18(\"fish\", \"cat\") връща \"ftiasch\"\nf_18(\"icpc\", \"acm\") връща \"imccpac\"", "zh": "生成一个唯一标识符，通过以指定模式交织两个单词来实现。\n@param word1 用于创建ID的第一个单词。\n@param word2 用于创建ID的第二个单词。\n@return 一个唯一标识符，通过从第二个单词反向交替字符与第一个单词的字符形成。\n示例用法：\n\nf_18(\"fish\", \"cat\") 返回 \"ftiasch\"\nf_18(\"icpc\", \"acm\") 返回 \"imccpac\"", "fr": "Génère un identifiant unique en entrelaçant deux mots selon un modèle spécifié.\n@param word1 Le premier mot à utiliser dans le processus de création de l'ID.\n@param word2 Le deuxième mot à utiliser dans le processus de création de l'ID.\n@return Un identifiant unique formé en alternant des caractères du deuxième mot, inversé, avec des caractères du premier mot.\nExemple d'utilisation :\n\nf_18(\"fish\", \"cat\") retourne \"ftiasch\"\nf_18(\"icpc\", \"acm\") retourne \"imccpac\"", "de": "Erzeugt einen eindeutigen Bezeichner, indem zwei Wörter in einem bestimmten Muster miteinander verflochten werden.\n@param word1 Das erste Wort, das im ID-Erstellungsprozess verwendet wird.\n@param word2 Das zweite Wort, das im ID-Erstellungsprozess verwendet wird.\n@return Ein eindeutiger Bezeichner, der durch abwechselnde Zeichen aus dem zweiten Wort, umgekehrt, mit Zeichen aus dem ersten Wort gebildet wird.\nBeispielverwendung:\n\nf_18(\"fish\", \"cat\") gibt \"ftiasch\" zurück\nf_18(\"icpc\", \"acm\") gibt \"imccpac\" zurück", "ha": "Yana haifar da mai gano na musamman ta hanyar haɗa kalmomi biyu a cikin tsari da aka fayyace.\n@param word1 Kalma ta farko da za a yi amfani da ita a cikin tsarin ƙirƙirar ID.\n@param word2 Kalma ta biyu da za a yi amfani da ita a cikin tsarin ƙirƙirar ID.\n@return Mai gano na musamman da aka samar ta hanyar madadin haruffa daga kalma ta biyu, da aka juya, tare da haruffa daga kalma ta farko.\nMisalin Amfani:\n\nf_18(\"fish\", \"cat\") returns \"ftiasch\"\nf_18(\"icpc\", \"acm\") returns \"imccpac\"", "hi": "दो शब्दों को एक निर्दिष्ट पैटर्न में मिलाकर एक अद्वितीय पहचानकर्ता उत्पन्न करता है।\n@param word1 आईडी निर्माण प्रक्रिया में उपयोग किए जाने वाला पहला शब्द।\n@param word2 आईडी निर्माण प्रक्रिया में उपयोग किए जाने वाला दूसरा शब्द।\n@return एक अद्वितीय पहचानकर्ता जो दूसरे शब्द के अक्षरों को उलट कर, पहले शब्द के अक्षरों के साथ बारी-बारी से बनता है।\nउदाहरण उपयोग:\n\nf_18(\"fish\", \"cat\") returns \"ftiasch\"\nf_18(\"icpc\", \"acm\") returns \"imccpac\"", "hu": "Egyedi azonosítót generál két szó meghatározott mintázat szerinti összefonásával.\n@param word1 Az első szó, amelyet az azonosító létrehozási folyamatában használunk.\n@param word2 A második szó, amelyet az azonosító létrehozási folyamatában használunk.\n@return Egyedi azonosító, amelyet a második szó visszafelé vett karaktereinek és az első szó karaktereinek váltakozásával hozunk létre.\nPélda használat:\n\nf_18(\"fish\", \"cat\") visszaadja \"ftiasch\"\nf_18(\"icpc\", \"acm\") visszaadja \"imccpac\"", "es": "Genera un identificador único entrelazando dos palabras en un patrón especificado.\n@param word1 La primera palabra que se utilizará en el proceso de creación del ID.\n@param word2 La segunda palabra que se utilizará en el proceso de creación del ID.\n@return Un identificador único formado alternando caracteres de la segunda palabra, invertida, con caracteres de la primera palabra.\nEjemplo de uso:\n\nf_18(\"fish\", \"cat\") devuelve \"ftiasch\"\nf_18(\"icpc\", \"acm\") devuelve \"imccpac\"", "arb": "ينشئ معرفًا فريدًا عن طريق تشابك كلمتين بنمط محدد.\n@param word1 الكلمة الأولى التي سيتم استخدامها في عملية إنشاء المعرف.\n@param word2 الكلمة الثانية التي سيتم استخدامها في عملية إنشاء المعرف.\n@return معرف فريد يتكون من تبديل الأحرف من الكلمة الثانية، معكوسة، مع الأحرف من الكلمة الأولى.\nمثال على الاستخدام:\n\nf_18(\"fish\", \"cat\") returns \"ftiasch\"\nf_18(\"icpc\", \"acm\") returns \"imccpac\"", "sw": "Hutengeneza kitambulisho cha kipekee kwa kuchanganya maneno mawili kwa mpangilio maalum.\n@param word1 Neno la kwanza litakalotumika katika mchakato wa kuunda kitambulisho.\n@param word2 Neno la pili litakalotumika katika mchakato wa kuunda kitambulisho.\n@return Kitambulisho cha kipekee kinachoundwa kwa kubadilishana herufi kutoka neno la pili, lililogeuzwa, na herufi kutoka neno la kwanza.\nMfano wa Matumizi:\n\nf_18(\"fish\", \"cat\") inarudisha \"ftiasch\"\nf_18(\"icpc\", \"acm\") inarudisha \"imccpac\"", "tr": "İki kelimeyi belirtilen bir desende iç içe geçirerek benzersiz bir tanımlayıcı oluşturur.\n@param word1 Kimlik oluşturma sürecinde kullanılacak ilk kelime.\n@param word2 Kimlik oluşturma sürecinde kullanılacak ikinci kelime.\n@return İkinci kelimenin karakterlerinin ters çevrilmiş hali ile birinci kelimenin karakterlerinin dönüşümlü olarak kullanılmasıyla oluşturulan benzersiz bir tanımlayıcı.\nÖrnek Kullanım:\n\nf_18(\"fish\", \"cat\") returns \"ftiasch\"\nf_18(\"icpc\", \"acm\") returns \"imccpac\"", "vi": "Tạo một định danh duy nhất bằng cách xen kẽ hai từ theo một mẫu được chỉ định.\n@param word1 Từ đầu tiên được sử dụng trong quá trình tạo ID.\n@param word2 Từ thứ hai được sử dụng trong quá trình tạo ID.\n@return Một định danh duy nhất được tạo bằng cách xen kẽ các ký tự từ từ thứ hai, đảo ngược, với các ký tự từ từ đầu tiên.\nVí dụ Sử dụng:\n\nf_18(\"fish\", \"cat\") trả về \"ftiasch\"\nf_18(\"icpc\", \"acm\") trả về \"imccpac\"", "id": "Menghasilkan pengenal unik dengan menyisipkan dua kata dalam pola yang ditentukan.\n@param word1 Kata pertama yang akan digunakan dalam proses pembuatan ID.\n@param word2 Kata kedua yang akan digunakan dalam proses pembuatan ID.\n@return Sebuah pengenal unik yang dibentuk dengan menggabungkan karakter dari kata kedua, dibalik, dengan karakter dari kata pertama.\nContoh Penggunaan:\n\nf_18(\"fish\", \"cat\") mengembalikan \"ftiasch\"\nf_18(\"icpc\", \"acm\") mengembalikan \"imccpac\"", "ja": "指定されたパターンで2つの単語を交互に組み合わせてユニークな識別子を生成します。\n@param word1 ID作成プロセスで使用される最初の単語。\n@param word2 ID作成プロセスで使用される2番目の単語。\n@return 2番目の単語を逆にして、最初の単語の文字と交互に組み合わせて形成されたユニークな識別子。\n使用例:\n\nf_18(\"fish\", \"cat\") は \"ftiasch\" を返します\nf_18(\"icpc\", \"acm\") は \"imccpac\" を返します", "ko": "두 단어를 지정된 패턴으로 엮어 고유 식별자를 생성합니다.\n@param word1 ID 생성 과정에서 사용될 첫 번째 단어입니다.\n@param word2 ID 생성 과정에서 사용될 두 번째 단어입니다.\n@return 두 번째 단어의 문자를 역순으로 첫 번째 단어의 문자와 번갈아가며 형성된 고유 식별자입니다.\n사용 예:\n\nf_18(\"fish\", \"cat\") returns \"ftiasch\"\nf_18(\"icpc\", \"acm\") returns \"imccpac\"", "ml": "രണ്ട് വാക്കുകൾ ഒരു നിർദ്ദിഷ്ട മാതൃകയിൽ ചേർത്തുകൊണ്ട് ഒരു അതുല്യമായ ഐഡന്റിഫയർ സൃഷ്ടിക്കുന്നു.\n@param word1 ID സൃഷ്ടിക്കുന്ന പ്രക്രിയയിൽ ഉപയോഗിക്കേണ്ട ആദ്യത്തെ വാക്ക്.\n@param word2 ID സൃഷ്ടിക്കുന്ന പ്രക്രിയയിൽ ഉപയോഗിക്കേണ്ട രണ്ടാമത്തെ വാക്ക്.\n@return രണ്ടാമത്തെ വാക്കിൽ നിന്നുള്ള പ്രത്യയങ്ങൾ, മറിച്ചുള്ളവ, ആദ്യത്തെ വാക്കിൽ നിന്നുള്ള പ്രത്യയങ്ങളുമായി മാറി മാറി ചേർത്തു രൂപീകരിച്ച ഒരു പ്രത്യേക ഐഡന്റിഫയർ.\nExample Usage:\n\nf_18(\"fish\", \"cat\") returns \"ftiasch\"\nf_18(\"icpc\", \"acm\") returns \"imccpac\"", "fa": "یک شناسه منحصر به فرد با درهم‌آمیزی دو کلمه در یک الگوی مشخص تولید می‌کند.\n@param word1 اولین کلمه‌ای که در فرآیند ایجاد شناسه استفاده می‌شود.\n@param word2 دومین کلمه‌ای که در فرآیند ایجاد شناسه استفاده می‌شود.\n@return یک شناسه منحصر به فرد که با جایگزینی متناوب کاراکترها از کلمه دوم، به صورت معکوس، با کاراکترهای کلمه اول تشکیل می‌شود.\nمثال استفاده:\n\nf_18(\"fish\", \"cat\") بازمی‌گرداند \"ftiasch\"\nf_18(\"icpc\", \"acm\") بازمی‌گرداند \"imccpac\""}}
{"task_id": "CPP/19", "prompt": {"en": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Count the number of different permutation schemes for a binary string of length n,\n * where the number of '1's is m and the number of '0's is n - m.\n * \n * Parameters:\n * - n (int): Length of the binary string.\n * - m (int): Number of '1's in the binary string.\n * \n * Returns:\n * - int: The total number of different permutation schemes.\n */\nint f_19(int n, int m)", "sq": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Numëron numrin e skemave të ndryshme të permutimit për një varg binar me gjatësi n,\n * ku numri i '1'-ve është m dhe numri i '0'-ve është n - m.\n * \n * Parametrat:\n * - n (int): Gjatësia e vargut binar.\n * - m (int): Numri i '1'-ve në vargun binar.\n * \n * Kthen:\n * - int: Numri total i skemave të ndryshme të permutimit.\n */\nint f_19(int n, int m)", "hy": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Հաշվել տարբեր տեղափոխման սխեմաների քանակը երկբայնային տողի համար, որի երկարությունը n է,\n * որտեղ '1'-երի քանակը m է և '0'-երի քանակը n - m է:\n * \n * Պարամետրեր:\n * - n (int): Երկբայնային տողի երկարությունը:\n * - m (int): '1'-երի քանակը երկբայնային տողում:\n * \n * Վերադարձնում է:\n * - int: Տարբեր տեղափոխման սխեմաների ընդհանուր քանակը:\n */\nint f_19(int n, int m)", "bn": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * একটি বাইনারি স্ট্রিংয়ের জন্য বিভিন্ন বিন্যাস পরিকল্পনার সংখ্যা গণনা করুন যার দৈর্ঘ্য n,\n * যেখানে '1' এর সংখ্যা m এবং '0' এর সংখ্যা n - m।\n * \n * প্যারামিটার:\n * - n (int): বাইনারি স্ট্রিংয়ের দৈর্ঘ্য।\n * - m (int): বাইনারি স্ট্রিংয়ে '1' এর সংখ্যা।\n * \n * রিটার্নস:\n * - int: বিভিন্ন বিন্যাস পরিকল্পনার মোট সংখ্যা।\n */\nint f_19(int n, int m)", "bg": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Пребройте броя на различните схеми на пермутации за двоична редица с дължина n,\n * където броят на '1'-ците е m, а броят на '0'-ците е n - m.\n * \n * Параметри:\n * - n (int): Дължина на двоичната редица.\n * - m (int): Брой на '1'-ците в двоичната редица.\n * \n * Връща:\n * - int: Общият брой на различните схеми на пермутации.\n */\nint f_19(int n, int m)", "zh": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * 计算长度为 n 的二进制字符串的不同排列方案的数量，\n * 其中 '1' 的数量为 m，'0' 的数量为 n - m。\n * \n * 参数：\n * - n (int): 二进制字符串的长度。\n * - m (int): 二进制字符串中 '1' 的数量。\n * \n * 返回：\n * - int: 不同排列方案的总数量。\n */\nint f_19(int n, int m)", "fr": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Compter le nombre de différents schémas de permutation pour une chaîne binaire de longueur n,\n * où le nombre de '1' est m et le nombre de '0' est n - m.\n * \n * Paramètres :\n * - n (int) : Longueur de la chaîne binaire.\n * - m (int) : Nombre de '1' dans la chaîne binaire.\n * \n * Renvoie :\n * - int : Le nombre total de différents schémas de permutation.\n */\nint f_19(int n, int m)", "de": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Zähle die Anzahl der verschiedenen Permutationsschemata für einen Binärstring der Länge n,\n * wobei die Anzahl der '1's m ist und die Anzahl der '0's n - m ist.\n * \n * Parameter:\n * - n (int): Länge des Binärstrings.\n * - m (int): Anzahl der '1's im Binärstring.\n * \n * Rückgabewert:\n * - int: Die Gesamtanzahl der verschiedenen Permutationsschemata.\n */\nint f_19(int n, int m)", "ha": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Ƙididdige adadin tsarin permutation daban-daban don igiyar binary mai tsawon n,\n * inda adadin '1's shine m kuma adadin '0's shine n - m.\n * \n * Sigogi:\n * - n (int): Tsawon igiyar binary.\n * - m (int): Adadin '1's a cikin igiyar binary.\n * \n * Komawa:\n * - int: Jimlar adadin tsarin permutation daban-daban.\n */\nint f_19(int n, int m)", "hi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * एक बाइनरी स्ट्रिंग की विभिन्न क्रमचय योजनाओं की संख्या गिनें जिसकी लंबाई n है,\n * जहाँ '1's की संख्या m है और '0's की संख्या n - m है।\n * \n * पैरामीटर:\n * - n (int): बाइनरी स्ट्रिंग की लंबाई।\n * - m (int): बाइनरी स्ट्रिंग में '1's की संख्या।\n * \n * लौटाता है:\n * - int: विभिन्न क्रमचय योजनाओं की कुल संख्या।\n */\nint f_19(int n, int m)", "hu": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Számolja meg a különböző permutációs sémák számát egy n hosszúságú bináris karakterláncra,\n * ahol az '1'-ek száma m és a '0'-k száma n - m.\n * \n * Paraméterek:\n * - n (int): A bináris karakterlánc hossza.\n * - m (int): Az '1'-ek száma a bináris karakterláncban.\n * \n * Visszatérési érték:\n * - int: A különböző permutációs sémák összes száma.\n */\nint f_19(int n, int m)", "es": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Cuenta el número de diferentes esquemas de permutación para una cadena binaria de longitud n,\n * donde el número de '1's es m y el número de '0's es n - m.\n * \n * Parámetros:\n * - n (int): Longitud de la cadena binaria.\n * - m (int): Número de '1's en la cadena binaria.\n * \n * Devuelve:\n * - int: El número total de diferentes esquemas de permutación.\n */\nint f_19(int n, int m)", "arb": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * احسب عدد مخططات التبديل المختلفة لسلسلة ثنائية بطول n،\n * حيث يكون عدد '1's هو m وعدد '0's هو n - m.\n * \n * المعلمات:\n * - n (int): طول السلسلة الثنائية.\n * - m (int): عدد '1's في السلسلة الثنائية.\n * \n * يعيد:\n * - int: العدد الإجمالي لمخططات التبديل المختلفة.\n */\nint f_19(int n, int m)", "sw": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Hesabu idadi ya mipango tofauti ya upangaji kwa kamba ya binary ya urefu n,\n * ambapo idadi ya '1's ni m na idadi ya '0's ni n - m.\n * \n * Vigezo:\n * - n (int): Urefu wa kamba ya binary.\n * - m (int): Idadi ya '1's katika kamba ya binary.\n * \n * Inarudisha:\n * - int: Jumla ya idadi ya mipango tofauti ya upangaji.\n */\nint f_19(int n, int m)", "tr": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Uzunluğu n olan bir ikili dizgi için, '1'lerin sayısının m ve '0'ların sayısının n - m olduğu\n * farklı permütasyon düzenlerinin sayısını sayar.\n * \n * Parametreler:\n * - n (int): İkili dizginin uzunluğu.\n * - m (int): İkili dizgideki '1'lerin sayısı.\n * \n * Döndürür:\n * - int: Farklı permütasyon düzenlerinin toplam sayısı.\n */\nint f_19(int n, int m)", "vi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Đếm số lượng các sơ đồ hoán vị khác nhau cho một chuỗi nhị phân có độ dài n,\n * trong đó số lượng '1' là m và số lượng '0' là n - m.\n * \n * Tham số:\n * - n (int): Độ dài của chuỗi nhị phân.\n * - m (int): Số lượng '1' trong chuỗi nhị phân.\n * \n * Trả về:\n * - int: Tổng số lượng các sơ đồ hoán vị khác nhau.\n */\nint f_19(int n, int m)", "id": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Hitung jumlah skema permutasi yang berbeda untuk string biner dengan panjang n,\n * di mana jumlah '1' adalah m dan jumlah '0' adalah n - m.\n * \n * Parameter:\n * - n (int): Panjang dari string biner.\n * - m (int): Jumlah '1' dalam string biner.\n * \n * Mengembalikan:\n * - int: Total jumlah skema permutasi yang berbeda.\n */\nint f_19(int n, int m)", "ja": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * 長さnの2進文字列に対する異なる順列スキームの数を数える,\n * ここで '1' の数は m であり、 '0' の数は n - m である。\n * \n * パラメータ:\n * - n (int): 2進文字列の長さ。\n * - m (int): 2進文字列内の '1' の数。\n * \n * 戻り値:\n * - int: 異なる順列スキームの総数。\n */\nint f_19(int n, int m)", "ko": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * 길이가 n인 이진 문자열에 대해, '1'의 개수가 m이고 '0'의 개수가 n - m인 서로 다른 순열 방식의 수를 계산합니다.\n * \n * 매개변수:\n * - n (int): 이진 문자열의 길이.\n * - m (int): 이진 문자열에서 '1'의 개수.\n * \n * 반환값:\n * - int: 서로 다른 순열 방식의 총 수.\n */\nint f_19(int n, int m)", "ml": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * n നീളമുള്ള ബൈനറി സ്ട്രിംഗിനായുള്ള വ്യത്യസ്തമായ പെർമ്യൂട്ടേഷൻ സ്കീമുകളുടെ എണ്ണം എണ്ണുക,\n * ഇവിടെ '1' കളുടെ എണ്ണം m ആണ്, '0' കളുടെ എണ്ണം n - m ആണ്.\n * \n * പാരാമീറ്ററുകൾ:\n * - n (int): ബൈനറി സ്ട്രിംഗിന്റെ നീളം.\n * - m (int): ബൈനറി സ്ട്രിംഗിലെ '1' കളുടെ എണ്ണം.\n * \n * തിരികെ നൽകുന്നത്:\n * - int: വ്യത്യസ്തമായ പെർമ്യൂട്ടേഷൻ സ്കീമുകളുടെ മൊത്തം എണ്ണം.\n */\nint f_19(int n, int m)", "fa": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * تعداد طرح‌های مختلف جایگشت برای یک رشته باینری به طول n را بشمارید،\n * که تعداد '1' ها برابر با m و تعداد '0' ها برابر با n - m است.\n * \n * پارامترها:\n * - n (int): طول رشته باینری.\n * - m (int): تعداد '1' ها در رشته باینری.\n * \n * بازگشت:\n * - int: تعداد کل طرح‌های مختلف جایگشت.\n */\nint f_19(int n, int m)"}, "canonical_solution": "{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // Calculating the number of permutations using the factorial values\n        return static_cast<int>(numerator / denominator1 / denominator2 + 0.5);\n    }\n}", "instruction": {"en": "Write a CPP function `int f_19(int n, int m)` to solve the following problem:\nCount the number of different permutation schemes for a binary string of length n, where the number of '1's is m and the number of '0's is n - m.\n\nParameters:\n- n (int): Length of the binary string.\n- m (int): Number of '1's in the binary string.\n\nReturns:\n- int: The total number of different permutation schemes.", "sq": "Shkruani një funksion CPP `int f_19(int n, int m)` për të zgjidhur problemin e mëposhtëm:\nNumëroni numrin e skemave të ndryshme të permutimit për një varg binar me gjatësi n, ku numri i '1'-ve është m dhe numri i '0'-ve është n - m.\n\nParametrat:\n- n (int): Gjatësia e vargut binar.\n- m (int): Numri i '1'-ve në vargun binar.\n\nKthen:\n- int: Numri total i skemave të ndryshme të permutimit.", "hy": "Գրեք CPP ֆունկցիա `int f_19(int n, int m)` հետևյալ խնդիրը լուծելու համար:\nՀաշվեք տարբեր փոխատեղման սխեմաների քանակը երկբանական տողի համար, որի երկարությունը n է, որտեղ '1'-երի քանակը m է, իսկ '0'-երի քանակը n - m է։\n\nՊարամետրեր:\n- n (int): Երկբանական տողի երկարությունը։\n- m (int): '1'-երի քանակը երկբանական տողում։\n\nՎերադարձնում է:\n- int: Տարբեր փոխատեղման սխեմաների ընդհանուր քանակը։", "bn": "একটি CPP ফাংশন `int f_19(int n, int m)` লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\nএকটি বাইনারি স্ট্রিংয়ের জন্য বিভিন্ন বিন্যাস প্রকল্পের সংখ্যা গণনা করুন যার দৈর্ঘ্য n, যেখানে '1' এর সংখ্যা m এবং '0' এর সংখ্যা n - m।\n\nপ্যারামিটারসমূহ:\n- n (int): বাইনারি স্ট্রিংয়ের দৈর্ঘ্য।\n- m (int): বাইনারি স্ট্রিংয়ে '1' এর সংখ্যা।\n\nরিটার্নস:\n- int: বিভিন্ন বিন্যাস প্রকল্পের মোট সংখ্যা।", "bg": "Напишете CPP функция `int f_19(int n, int m)`, за да решите следния проблем:\nПребройте броя на различните схеми на пермутации за двоична низ с дължина n, където броят на '1'-ците е m и броят на '0'-ите е n - m.\n\nПараметри:\n- n (int): Дължина на двоичния низ.\n- m (int): Брой на '1'-ците в двоичния низ.\n\nВръща:\n- int: Общият брой на различните схеми на пермутации.", "zh": "编写一个 CPP 函数 `int f_19(int n, int m)` 来解决以下问题：\n计算长度为 n 的二进制字符串的不同排列方案的数量，其中 '1' 的数量为 m，'0' 的数量为 n - m。\n\n参数：\n- n (int): 二进制字符串的长度。\n- m (int): 二进制字符串中 '1' 的数量。\n\n返回：\n- int: 不同排列方案的总数。", "fr": "Écrire une fonction CPP `int f_19(int n, int m)` pour résoudre le problème suivant :\nCompter le nombre de différents schémas de permutation pour une chaîne binaire de longueur n, où le nombre de '1' est m et le nombre de '0' est n - m.\n\nParamètres :\n- n (int) : Longueur de la chaîne binaire.\n- m (int) : Nombre de '1' dans la chaîne binaire.\n\nRenvoie :\n- int : Le nombre total de différents schémas de permutation.", "de": "Schreiben Sie eine CPP-Funktion `int f_19(int n, int m)`, um das folgende Problem zu lösen:\nZählen Sie die Anzahl der verschiedenen Permutationsschemata für einen Binärstring der Länge n, wobei die Anzahl der '1's m ist und die Anzahl der '0's n - m ist.\n\nParameter:\n- n (int): Länge des Binärstrings.\n- m (int): Anzahl der '1's im Binärstring.\n\nRückgabewert:\n- int: Die Gesamtanzahl der verschiedenen Permutationsschemata.", "ha": "Rubuta aikin CPP `int f_19(int n, int m)` don warware matsalar mai zuwa:\nƘididdige adadin tsarin permutation daban-daban don wani binary string mai tsawon n, inda adadin '1's yake m kuma adadin '0's yake n - m.\n\nSigogi:\n- n (int): Tsawon binary string.\n- m (int): Adadin '1's a cikin binary string.\n\nDawowa:\n- int: Jimillar adadin tsarin permutation daban-daban.", "hi": "`int f_19(int n, int m)` नामक एक CPP फ़ंक्शन लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nलंबाई n के एक बाइनरी स्ट्रिंग के लिए विभिन्न क्रमपरिवर्तन योजनाओं की संख्या गिनें, जहाँ '1's की संख्या m है और '0's की संख्या n - m है।\n\nपैरामीटर्स:\n- n (int): बाइनरी स्ट्रिंग की लंबाई।\n- m (int): बाइनरी स्ट्रिंग में '1's की संख्या।\n\nवापसी:\n- int: विभिन्न क्रमपरिवर्तन योजनाओं की कुल संख्या।", "hu": "Írj egy CPP függvényt `int f_19(int n, int m)` a következő probléma megoldására:\nSzámold meg, hány különböző permutációs séma létezik egy n hosszúságú bináris karakterláncra, ahol az '1'-ek száma m és a '0'-k száma n - m.\n\nParaméterek:\n- n (int): A bináris karakterlánc hossza.\n- m (int): Az '1'-ek száma a bináris karakterláncban.\n\nVisszatérési érték:\n- int: A különböző permutációs sémák teljes száma.", "es": "Escribe una función CPP `int f_19(int n, int m)` para resolver el siguiente problema:\nCuenta el número de diferentes esquemas de permutación para una cadena binaria de longitud n, donde el número de '1's es m y el número de '0's es n - m.\n\nParámetros:\n- n (int): Longitud de la cadena binaria.\n- m (int): Número de '1's en la cadena binaria.\n\nDevuelve:\n- int: El número total de diferentes esquemas de permutación.", "arb": "اكتب دالة CPP `int f_19(int n, int m)` لحل المشكلة التالية:\nاحسب عدد مخططات التبديل المختلفة لسلسلة ثنائية بطول n، حيث يكون عدد '1's هو m وعدد '0's هو n - m.\n\nالمعلمات:\n- n (int): طول السلسلة الثنائية.\n- m (int): عدد '1's في السلسلة الثنائية.\n\nيعيد:\n- int: العدد الإجمالي لمخططات التبديل المختلفة.", "sw": "Andika kazi ya CPP `int f_19(int n, int m)` kutatua tatizo lifuatalo:\nHesabu idadi ya mipango tofauti ya mpangilio kwa kamba ya binary yenye urefu n, ambapo idadi ya '1's ni m na idadi ya '0's ni n - m.\n\nVigezo:\n- n (int): Urefu wa kamba ya binary.\n- m (int): Idadi ya '1's katika kamba ya binary.\n\nRudisha:\n- int: Jumla ya idadi ya mipango tofauti ya mpangilio.", "tr": "Bir CPP fonksiyonu `int f_19(int n, int m)` yazın ve aşağıdaki problemi çözün:\nUzunluğu n olan bir ikili dizgi için, '1'lerin sayısının m ve '0'ların sayısının n - m olduğu farklı permütasyon şemalarının sayısını sayın.\n\nParametreler:\n- n (int): İkili dizginin uzunluğu.\n- m (int): İkili dizgideki '1'lerin sayısı.\n\nDöndürür:\n- int: Farklı permütasyon şemalarının toplam sayısı.", "vi": "Viết một hàm CPP `int f_19(int n, int m)` để giải quyết vấn đề sau:\nĐếm số lượng các sơ đồ hoán vị khác nhau cho một chuỗi nhị phân có độ dài n, trong đó số lượng '1' là m và số lượng '0' là n - m.\n\nTham số:\n- n (int): Độ dài của chuỗi nhị phân.\n- m (int): Số lượng '1' trong chuỗi nhị phân.\n\nTrả về:\n- int: Tổng số các sơ đồ hoán vị khác nhau.", "id": "Tulis fungsi CPP `int f_19(int n, int m)` untuk menyelesaikan masalah berikut:\nHitung jumlah skema permutasi berbeda untuk string biner dengan panjang n, di mana jumlah '1' adalah m dan jumlah '0' adalah n - m.\n\nParameter:\n- n (int): Panjang string biner.\n- m (int): Jumlah '1' dalam string biner.\n\nMengembalikan:\n- int: Jumlah total skema permutasi berbeda.", "ja": "`int f_19(int n, int m)` というCPP関数を書いて、次の問題を解決してください:\n長さnの2進文字列に対して、'1'の数がmであり、'0'の数がn - mである場合の異なる順列スキームの数を数えます。\n\nパラメータ:\n- n (int): 2進文字列の長さ。\n- m (int): 2進文字列内の'1'の数。\n\n戻り値:\n- int: 異なる順列スキームの総数。", "ko": "다음 문제를 해결하기 위해 CPP 함수를 작성하세요 `int f_19(int n, int m)`:\n길이가 n인 이진 문자열에서 '1'의 개수가 m이고 '0'의 개수가 n - m인 서로 다른 순열 방식의 수를 계산합니다.\n\n매개변수:\n- n (int): 이진 문자열의 길이.\n- m (int): 이진 문자열에서 '1'의 개수.\n\n반환값:\n- int: 서로 다른 순열 방식의 총 수.", "ml": "`int f_19(int n, int m)` എന്ന CPP ഫംഗ്ഷൻ എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ: \nനീളം n ആയ ഒരു ബൈനറി സ്ട്രിംഗിന്റെ വ്യത്യസ്ത പെർമ്യൂട്ടേഷൻ സ്കീമുകളുടെ എണ്ണം എണ്ണുക, ഇവിടെ '1' കളുടെ എണ്ണം m ആണ്, '0' കളുടെ എണ്ണം n - m ആണ്.\n\nപാരാമീറ്ററുകൾ:\n- n (int): ബൈനറി സ്ട്രിംഗിന്റെ നീളം.\n- m (int): ബൈനറി സ്ട്രിംഗിലെ '1' കളുടെ എണ്ണം.\n\nമടക്കിക്കൊടുക്കുന്നു:\n- int: വ്യത്യസ്ത പെർമ്യൂട്ടേഷൻ സ്കീമുകളുടെ മൊത്തം എണ്ണം.", "fa": "یک تابع CPP به نام `int f_19(int n, int m)` بنویسید تا مسئله زیر را حل کند:\nتعداد طرح‌های جایگشت مختلف برای یک رشته باینری به طول n را بشمارید، جایی که تعداد '1'ها برابر با m و تعداد '0'ها برابر با n - m است.\n\nپارامترها:\n- n (int): طول رشته باینری.\n- m (int): تعداد '1'ها در رشته باینری.\n\nبازگشت:\n- int: تعداد کل طرح‌های جایگشت مختلف."}, "level": "hard", "test": "int main() {\n    assert(f_19(2, 0) == 2);\n    assert(f_19(2, 1) == 0);\n    assert(f_19(3, 0) == 0);\n    assert(f_19(3, 1) == 3);\n    assert(f_19(3, 2) == 0);\n    assert(f_19(30, 2) == 145422675);\n    assert(f_19(4, 2) == 4);\n    assert(f_19(5, 5) == 1);\n    assert(f_19(33, 17) == 13884156);\n    assert(f_19(1000, 1000) == 1);\n    // Add more test cases if necessary\n    return 0;\n}", "entry_point": "f_19", "signature": "int f_19(int n, int m)", "docstring": {"en": "Count the number of different permutation schemes for a binary string of length n, where the number of '1's is m and the number of '0's is n - m.\n\nParameters:\n- n (int): Length of the binary string.\n- m (int): Number of '1's in the binary string.\n\nReturns:\n- int: The total number of different permutation schemes.", "sq": "Numëroni numrin e skemave të ndryshme të permutimit për një varg binar me gjatësi n, ku numri i '1'-ve është m dhe numri i '0'-ve është n - m.\n\nParametrat:\n- n (int): Gjatësia e vargut binar.\n- m (int): Numri i '1'-ve në vargun binar.\n\nKthen:\n- int: Numri total i skemave të ndryshme të permutimit.", "hy": "Հաշվել տարբեր փոխարկման սխեմաների քանակը երկբայական տողի համար, որի երկարությունը n է, որտեղ '1'-երի քանակը m է, իսկ '0'-երի քանակը n - m է։\n\nՊարամետրեր:\n- n (int): Երկբայական տողի երկարությունը։\n- m (int): '1'-երի քանակը երկբայական տողի մեջ։\n\nՎերադարձնում է:\n- int: Տարբեր փոխարկման սխեմաների ընդհանուր քանակը։", "bn": "বাইনারি স্ট্রিংয়ের দৈর্ঘ্য n এর জন্য বিভিন্ন বিন্যাস প্রকল্পের সংখ্যা গণনা করুন, যেখানে '1' এর সংখ্যা m এবং '0' এর সংখ্যা n - m।\n\nপ্যারামিটারসমূহ:\n- n (int): বাইনারি স্ট্রিংয়ের দৈর্ঘ্য।\n- m (int): বাইনারি স্ট্রিংয়ে '1' এর সংখ্যা।\n\nরিটার্নস:\n- int: বিভিন্ন বিন্যাস প্রকল্পের মোট সংখ্যা।", "bg": "Бройте броя на различните схеми на пермутации за двоична низ с дължина n, където броят на '1'-ците е m и броят на '0'-ците е n - m.\n\nПараметри:\n- n (int): Дължина на двоичната низ.\n- m (int): Брой '1'-ци в двоичната низ.\n\nВръща:\n- int: Общият брой на различните схеми на пермутации.", "zh": "计算长度为 n 的二进制字符串的不同排列方案数量，其中 '1' 的数量为 m，'0' 的数量为 n - m。\n\n参数:\n- n (int): 二进制字符串的长度。\n- m (int): 二进制字符串中 '1' 的数量。\n\n返回:\n- int: 不同排列方案的总数量。", "fr": "Comptez le nombre de différents schémas de permutation pour une chaîne binaire de longueur n, où le nombre de '1' est m et le nombre de '0' est n - m.\n\nParamètres :\n- n (int) : Longueur de la chaîne binaire.\n- m (int) : Nombre de '1' dans la chaîne binaire.\n\nRetourne :\n- int : Le nombre total de différents schémas de permutation.", "de": "Zähle die Anzahl der verschiedenen Permutationsschemata für einen Binärstring der Länge n, wobei die Anzahl der '1's m ist und die Anzahl der '0's n - m ist.\n\nParameter:\n- n (int): Länge des Binärstrings.\n- m (int): Anzahl der '1's im Binärstring.\n\nRückgabewert:\n- int: Die Gesamtanzahl der verschiedenen Permutationsschemata.", "ha": "Ƙididdige adadin tsarin juyawa daban-daban don igiyar binary mai tsawon n, inda adadin '1's yake m kuma adadin '0's yake n - m.\n\nSigogi:\n- n (int): Tsawon igiyar binary.\n- m (int): Adadin '1's a cikin igiyar binary.\n\nDawowa:\n- int: Jimlar adadin tsarin juyawa daban-daban.", "hi": "बाइनरी स्ट्रिंग की लंबाई n के लिए विभिन्न क्रमपरिवर्तन योजनाओं की संख्या गिनें, जहाँ '1' की संख्या m है और '0' की संख्या n - m है।\n\nपैरामीटर्स:\n- n (int): बाइनरी स्ट्रिंग की लंबाई।\n- m (int): बाइनरी स्ट्रिंग में '1' की संख्या।\n\nवापसी:\n- int: विभिन्न क्रमपरिवर्तन योजनाओं की कुल संख्या।", "hu": "Számolja meg a különböző permutációs sémák számát egy n hosszúságú bináris karakterlánc esetén, ahol az '1'-ek száma m, és a '0'-k száma n - m.\n\nParaméterek:\n- n (int): A bináris karakterlánc hossza.\n- m (int): Az '1'-ek száma a bináris karakterláncban.\n\nVisszatér:\n- int: A különböző permutációs sémák teljes száma.", "es": "Cuenta el número de diferentes esquemas de permutación para una cadena binaria de longitud n, donde el número de '1's es m y el número de '0's es n - m.\n\nParámetros:\n- n (int): Longitud de la cadena binaria.\n- m (int): Número de '1's en la cadena binaria.\n\nDevuelve:\n- int: El número total de diferentes esquemas de permutación.", "arb": "احسب عدد مخططات التبديل المختلفة لسلسلة ثنائية بطول n، حيث يكون عدد '1's هو m وعدد '0's هو n - m.\n\nالمعلمات:\n- n (int): طول السلسلة الثنائية.\n- m (int): عدد '1's في السلسلة الثنائية.\n\nالقيم المعادة:\n- int: العدد الإجمالي لمخططات التبديل المختلفة.", "sw": "Hesabu idadi ya mipango tofauti ya mpangilio kwa kamba ya binary yenye urefu n, ambapo idadi ya '1's ni m na idadi ya '0's ni n - m.\n\nVigezo:\n- n (int): Urefu wa kamba ya binary.\n- m (int): Idadi ya '1's katika kamba ya binary.\n\nRudisha:\n- int: Jumla ya idadi ya mipango tofauti ya mpangilio.", "tr": "İkili bir dizgenin uzunluğu n, '1'lerin sayısı m ve '0'ların sayısı n - m olduğunda, farklı permütasyon şemalarının sayısını hesaplayın.\n\nParametreler:\n- n (int): İkili dizgenin uzunluğu.\n- m (int): İkili dizgedeki '1'lerin sayısı.\n\nDöndürür:\n- int: Farklı permütasyon şemalarının toplam sayısı.", "vi": "Đếm số lượng các sơ đồ hoán vị khác nhau cho một chuỗi nhị phân có độ dài n, trong đó số lượng '1' là m và số lượng '0' là n - m.\n\nTham số:\n- n (int): Độ dài của chuỗi nhị phân.\n- m (int): Số lượng '1' trong chuỗi nhị phân.\n\nTrả về:\n- int: Tổng số lượng các sơ đồ hoán vị khác nhau.", "id": "Hitung jumlah skema permutasi berbeda untuk string biner dengan panjang n, di mana jumlah '1' adalah m dan jumlah '0' adalah n - m.\n\nParameter:\n- n (int): Panjang string biner.\n- m (int): Jumlah '1' dalam string biner.\n\nMengembalikan:\n- int: Jumlah total skema permutasi berbeda.", "ja": "バイナリ文字列の長さnに対する異なる順列スキームの数を数えます。ここで、'1'の数はmで、'0'の数はn - mです。\n\n引数:\n- n (int): バイナリ文字列の長さ。\n- m (int): バイナリ文字列中の'1'の数。\n\n戻り値:\n- int: 異なる順列スキームの総数。", "ko": "이진 문자열의 길이가 n이고, '1'의 개수가 m이며 '0'의 개수가 n - m일 때, 서로 다른 순열 방식의 수를 계산합니다.\n\n매개변수:\n- n (int): 이진 문자열의 길이.\n- m (int): 이진 문자열에서 '1'의 개수.\n\n반환값:\n- int: 서로 다른 순열 방식의 총 개수.", "ml": "ബൈനറി സ്ട്രിംഗിന്റെ നീളം n ആയിരിക്കുമ്പോൾ, '1' കളുടെ എണ്ണം m ആയും '0' കളുടെ എണ്ണം n - m ആയും ഉള്ള വ്യത്യസ്ത പെർമ്യൂട്ടേഷൻ സ്കീമുകളുടെ എണ്ണം എണ്ണുക.\n\nപാരാമീറ്ററുകൾ:\n- n (int): ബൈനറി സ്ട്രിംഗിന്റെ നീളം.\n- m (int): ബൈനറി സ്ട്രിംഗിലെ '1' കളുടെ എണ്ണം.\n\nമടക്കുന്നു:\n- int: വ്യത്യസ്ത പെർമ്യൂട്ടേഷൻ സ്കീമുകളുടെ മൊത്തം എണ്ണം.", "fa": "تعداد طرح‌های جایگشت مختلف برای یک رشته باینری با طول n را بشمارید، جایی که تعداد '1's برابر با m و تعداد '0's برابر با n - m است.\n\nپارامترها:\n- n (int): طول رشته باینری.\n- m (int): تعداد '1's در رشته باینری.\n\nبازگشت:\n- int: تعداد کل طرح‌های جایگشت مختلف."}}
{"task_id": "CPP/20", "prompt": {"en": "#include <cassert>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n/**\n *  Answer a series of questions by providing choices A, B, C, or D for each question.\n *  \n *  Question 1:\n *  Constants like 1e6 belong to which data type?\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n *  \n *  Question 2:\n *  Given 21! = 51,090,942,171,709,440,000, which data type can be used to store this value?\n *      A. int\n *      B. long long\n *      C. double\n *      D. None of the above\n *  \n *  Question 3:\n *  Which statement about left values in expressions is incorrect?\n *      A. Variable name expressions are left values.\n *      B. Increment operation requires the operand to be a left value.\n *      C. Pointer dereference expressions are left values.\n *      D. Prefix increment operation expressions are left values.\n *  \n *  Question 4:\n *  Which statement about functions is incorrect?\n *      A. Formal parameters of a function are local variables.\n *      B. Local variables are allocated space in the stack.\n *      C. The function type is the same as the return value type.\n *      D. A function can call itself from within its body.\n *  \n *  Question 5:\n *  Which statement about pointers is incorrect?\n *      A. Subtracting two pointers equals the difference in their address values.\n *      B. Pointer dereference involves resolving based on the pointer's type.\n *      C. int *p[4], p is an array of int pointers.\n *      D. Function names can be assigned to function pointers.\n *  \n *  You're supposed to only return strings similar to \"AAAAA\", which stand for the choices of the question.\n */\nconst char* f_20()", "sq": "#include <cassert>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n/**\n *  Përgjigju një serie pyetjesh duke ofruar zgjedhjet A, B, C, ose D për secilën pyetje.\n *  \n *  Pyetja 1:\n *  Konstantet si 1e6 i përkasin cilit tip të dhënash?\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n *  \n *  Pyetja 2:\n *  Duke pasur parasysh 21! = 51,090,942,171,709,440,000, cili tip i dhënash mund të përdoret për të ruajtur këtë vlerë?\n *      A. int\n *      B. long long\n *      C. double\n *      D. Asnjë nga më sipër\n *  \n *  Pyetja 3:\n *  Cila deklaratë për vlerat e majta në shprehje është e pasaktë?\n *      A. Shprehjet me emra variablash janë vlera të majta.\n *      B. Operacioni i inkrementimit kërkon që operandi të jetë vlerë e majtë.\n *      C. Shprehjet e dereferencimit të treguesve janë vlera të majta.\n *      D. Shprehjet e operacionit të inkrementimit prefiks janë vlera të majta.\n *  \n *  Pyetja 4:\n *  Cila deklaratë për funksionet është e pasaktë?\n *      A. Parametrat formalë të një funksioni janë variabla lokale.\n *      B. Variablat lokale kanë hapësirë të caktuar në stack.\n *      C. Tipi i funksionit është i njëjtë me tipin e vlerës së kthimit.\n *      D. Një funksion mund të thërrasë vetveten nga brenda trupit të tij.\n *  \n *  Pyetja 5:\n *  Cila deklaratë për treguesit është e pasaktë?\n *      A. Zbritja e dy treguesve është e barabartë me diferencën në vlerat e adresave të tyre.\n *      B. Dereferencimi i treguesit përfshin zgjidhjen bazuar në tipin e treguesit.\n *      C. int *p[4], p është një varg treguesish int.\n *      D. Emrat e funksioneve mund të caktohen në tregues të funksioneve.\n *  \n *  Duhet të ktheni vetëm vargje të ngjashme me \"AAAAA\", të cilat përfaqësojnë zgjedhjet e pyetjes.\n */", "hy": "#include <cassert>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n/**\n *  Պատասխանել մի շարք հարցերի՝ տրամադրելով ընտրանքներ A, B, C կամ D յուրաքանչյուր հարցի համար:\n *  \n *  Հարց 1:\n *  1e6 նման հաստատունները որ տվյալների տիպին են պատկանում?\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n *  \n *  Հարց 2:\n *  Տրված է 21! = 51,090,942,171,709,440,000, որ տվյալների տիպը կարող է պահել այս արժեքը?\n *      A. int\n *      B. long long\n *      C. double\n *      D. Վերը նշվածներից ոչ մեկը\n *  \n *  Հարց 3:\n *  Որ հայտարարությունը ձախ արժեքների մասին արտահայտություններում սխալ է?\n *      A. Փոփոխականի անվան արտահայտությունները ձախ արժեքներ են:\n *      B. Ինկրեմենտ գործողությունը պահանջում է, որ օպերանդը լինի ձախ արժեք:\n *      C. Ցուցիչի ապահղման արտահայտությունները ձախ արժեքներ են:\n *      D. Նախածանց ինկրեմենտ գործողության արտահայտությունները ձախ արժեքներ են:\n *  \n *  Հարց 4:\n *  Որ հայտարարությունը ֆունկցիաների մասին սխալ է?\n *      A. Ֆունկցիայի ֆորմալ պարամետրերը տեղական փոփոխականներ են:\n *      B. Տեղական փոփոխականները հատկացվում են ստեկում:\n *      C. Ֆունկցիայի տիպը նույնն է, ինչ վերադարձվող արժեքի տիպը:\n *      D. Ֆունկցիան կարող է ինքն իրեն կանչել իր մարմնից:\n *  \n *  Հարց 5:\n *  Որ հայտարարությունը ցուցիչների մասին սխալ է?\n *      A. Երկու ցուցիչների հանումը հավասար է նրանց հասցեների արժեքների տարբերությանը:\n *      B. Ցուցիչի ապահղումը ներառում է լուծում ցուցիչի տիպի հիման վրա:\n *      C. int *p[4], p-ն int ցուցիչների զանգված է:\n *      D. Ֆունկցիայի անունները կարող են վերագրվել ֆունկցիայի ցուցիչներին:\n *  \n *  Դուք պետք է վերադարձնեք միայն նմանատիպ տողեր \"AAAAA\", որոնք ներկայացնում են հարցի ընտրանքները:\n */\nconst char* f_20()", "bn": "#include <cassert>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n/**\n *  প্রতিটি প্রশ্নের জন্য A, B, C, বা D বিকল্প প্রদান করে প্রশ্নগুলোর উত্তর দিন।\n *  \n *  প্রশ্ন ১:\n *  1e6 এর মতো ধ্রুবক কোন ডেটা টাইপের অন্তর্গত?\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n *  \n *  প্রশ্ন ২:\n *  প্রদত্ত 21! = 51,090,942,171,709,440,000, কোন ডেটা টাইপ এই মান সংরক্ষণ করতে ব্যবহার করা যেতে পারে?\n *      A. int\n *      B. long long\n *      C. double\n *      D. উপরোক্ত কোনোটিই নয়\n *  \n *  প্রশ্ন ৩:\n *  এক্সপ্রেশনে বাম মান সম্পর্কে কোন বিবৃতি ভুল?\n *      A. ভেরিয়েবল নাম এক্সপ্রেশনগুলি বাম মান।\n *      B. ইনক্রিমেন্ট অপারেশনটির জন্য অপারেন্ডটি একটি বাম মান হতে হবে।\n *      C. পয়েন্টার ডেরেফারেন্স এক্সপ্রেশনগুলি বাম মান।\n *      D. প্রিফিক্স ইনক্রিমেন্ট অপারেশন এক্সপ্রেশনগুলি বাম মান।\n *  \n *  প্রশ্ন ৪:\n *  ফাংশন সম্পর্কে কোন বিবৃতি ভুল?\n *      A. একটি ফাংশনের আনুষ্ঠানিক প্যারামিটারগুলি স্থানীয় ভেরিয়েবল।\n *      B. স্থানীয় ভেরিয়েবলগুলি স্ট্যাকে স্থান বরাদ্দ করা হয়।\n *      C. ফাংশনের টাইপ এবং রিটার্ন ভ্যালুর টাইপ একই।\n *      D. একটি ফাংশন তার দেহের ভিতর থেকে নিজেকে কল করতে পারে।\n *  \n *  প্রশ্ন ৫:\n *  পয়েন্টার সম্পর্কে কোন বিবৃতি ভুল?\n *      A. দুটি পয়েন্টার বিয়োগ করলে তাদের ঠিকানা মানের পার্থক্য হয়।\n *      B. পয়েন্টার ডেরেফারেন্সের জন্য পয়েন্টারের টাইপের উপর ভিত্তি করে সমাধান করা হয়।\n *      C. int *p[4], p একটি int পয়েন্টারের অ্যারে।\n *      D. ফাংশনের নাম ফাংশন পয়েন্টারগুলিতে বরাদ্দ করা যেতে পারে।\n *  \n *  আপনি শুধুমাত্র \"AAAAA\" এর মতো স্ট্রিং ফেরত দেওয়ার কথা, যা প্রশ্নের বিকল্পগুলোর জন্য দাঁড়ায়।\n */\nconst char* f_20()", "bg": "#include <cassert>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n/**\n *  Отговорете на серия от въпроси, като предоставите избори A, B, C или D за всеки въпрос.\n *  \n *  Въпрос 1:\n *  Константи като 1e6 принадлежат към кой тип данни?\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n *  \n *  Въпрос 2:\n *  Дадено 21! = 51,090,942,171,709,440,000, кой тип данни може да се използва за съхранение на тази стойност?\n *      A. int\n *      B. long long\n *      C. double\n *      D. Нито едно от горните\n *  \n *  Въпрос 3:\n *  Кое твърдение за левите стойности в изразите е неправилно?\n *      A. Изразите с имена на променливи са леви стойности.\n *      B. Операцията за инкремент изисква операндът да е лява стойност.\n *      C. Изразите за дереференция на указатели са леви стойности.\n *      D. Изразите за префиксен инкремент са леви стойности.\n *  \n *  Въпрос 4:\n *  Кое твърдение за функциите е неправилно?\n *      A. Формалните параметри на функцията са локални променливи.\n *      B. Локалните променливи се разпределят в стека.\n *      C. Типът на функцията е същият като типа на връщаната стойност.\n *      D. Функцията може да извика себе си от своето тяло.\n *  \n *  Въпрос 5:\n *  Кое твърдение за указателите е неправилно?\n *      A. Изваждането на два указателя е равно на разликата в техните адресни стойности.\n *      B. Дереференцията на указател включва разрешаване на базата на типа на указателя.\n *      C. int *p[4], p е масив от указатели към int.\n *      D. Имената на функциите могат да бъдат присвоени на указатели към функции.\n *  \n *  Предполага се, че трябва да върнете само низове, подобни на \"AAAAA\", които означават изборите на въпросите.\n */\nconst char* f_20()", "zh": "#include <cassert>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n/**\n *  通过为每个问题提供选择 A、B、C 或 D 来回答一系列问题。\n *  \n *  问题 1:\n *  常量如 1e6 属于哪种数据类型？\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n *  \n *  问题 2:\n *  给定 21! = 51,090,942,171,709,440,000，哪种数据类型可以用来存储这个值？\n *      A. int\n *      B. long long\n *      C. double\n *      D. 以上都不是\n *  \n *  问题 3:\n *  关于表达式中的左值，哪个说法是不正确的？\n *      A. 变量名表达式是左值。\n *      B. 增量操作要求操作数是左值。\n *      C. 指针解引用表达式是左值。\n *      D. 前缀增量操作表达式是左值。\n *  \n *  问题 4:\n *  关于函数，哪个说法是不正确的？\n *      A. 函数的形式参数是局部变量。\n *      B. 局部变量在栈中分配空间。\n *      C. 函数类型与返回值类型相同。\n *      D. 函数可以在其主体内调用自身。\n *  \n *  问题 5:\n *  关于指针，哪个说法是不正确的？\n *      A. 两个指针相减等于它们地址值的差。\n *      B. 指针解引用涉及基于指针的类型进行解析。\n *      C. int *p[4], p 是一个 int 指针的数组。\n *      D. 函数名可以赋值给函数指针。\n *  \n *  你应该只返回类似于 \"AAAAA\" 的字符串，代表问题的选择。\n */\nconst char* f_20()", "fr": "#include <cassert>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n/**\n *  Répondre à une série de questions en fournissant les choix A, B, C ou D pour chaque question.\n *  \n *  Question 1 :\n *  Les constantes comme 1e6 appartiennent à quel type de données ?\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n *  \n *  Question 2 :\n *  Étant donné 21! = 51,090,942,171,709,440,000, quel type de données peut être utilisé pour stocker cette valeur ?\n *      A. int\n *      B. long long\n *      C. double\n *      D. Aucun des précédents\n *  \n *  Question 3 :\n *  Quelle affirmation sur les valeurs à gauche dans les expressions est incorrecte ?\n *      A. Les expressions de nom de variable sont des valeurs à gauche.\n *      B. L'opération d'incrémentation nécessite que l'opérande soit une valeur à gauche.\n *      C. Les expressions de déréférencement de pointeur sont des valeurs à gauche.\n *      D. Les expressions d'opération d'incrémentation préfixée sont des valeurs à gauche.\n *  \n *  Question 4 :\n *  Quelle affirmation sur les fonctions est incorrecte ?\n *      A. Les paramètres formels d'une fonction sont des variables locales.\n *      B. Les variables locales sont allouées dans la pile.\n *      C. Le type de la fonction est le même que le type de la valeur de retour.\n *      D. Une fonction peut s'appeler elle-même depuis son corps.\n *  \n *  Question 5 :\n *  Quelle affirmation sur les pointeurs est incorrecte ?\n *      A. Soustraire deux pointeurs équivaut à la différence de leurs valeurs d'adresse.\n *      B. Le déréférencement de pointeur implique une résolution basée sur le type du pointeur.\n *      C. int *p[4], p est un tableau de pointeurs int.\n *      D. Les noms de fonctions peuvent être assignés à des pointeurs de fonction.\n *  \n *  Vous êtes censé ne retourner que des chaînes similaires à \"AAAAA\", qui représentent les choix de la question.\n */\nconst char* f_20()", "de": "#include <cassert>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n/**\n *  Beantworten Sie eine Reihe von Fragen, indem Sie für jede Frage die Auswahlmöglichkeiten A, B, C oder D angeben.\n *  \n *  Frage 1:\n *  Konstanten wie 1e6 gehören zu welchem Datentyp?\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n *  \n *  Frage 2:\n *  Angenommen, 21! = 51,090,942,171,709,440,000, welcher Datentyp kann verwendet werden, um diesen Wert zu speichern?\n *      A. int\n *      B. long long\n *      C. double\n *      D. Keine der oben genannten\n *  \n *  Frage 3:\n *  Welche Aussage über linke Werte in Ausdrücken ist falsch?\n *      A. Variablennamenausdrücke sind linke Werte.\n *      B. Der Inkrementierungsoperator erfordert, dass der Operand ein linker Wert ist.\n *      C. Zeiger-Dereferenzierungsausdrücke sind linke Werte.\n *      D. Präfix-Inkrementierungsoperationen sind linke Werte.\n *  \n *  Frage 4:\n *  Welche Aussage über Funktionen ist falsch?\n *      A. Formale Parameter einer Funktion sind lokale Variablen.\n *      B. Lokale Variablen werden im Stapel Speicherplatz zugewiesen.\n *      C. Der Funktionstyp ist derselbe wie der Rückgabewerttyp.\n *      D. Eine Funktion kann sich selbst innerhalb ihres Körpers aufrufen.\n *  \n *  Frage 5:\n *  Welche Aussage über Zeiger ist falsch?\n *      A. Das Subtrahieren von zwei Zeigern entspricht der Differenz ihrer Adresswerte.\n *      B. Die Zeiger-Dereferenzierung erfolgt basierend auf dem Typ des Zeigers.\n *      C. int *p[4], p ist ein Array von int-Zeigern.\n *      D. Funktionsnamen können Funktionszeigern zugewiesen werden.\n *  \n *  Sie sollen nur Zeichenfolgen wie \"AAAAA\" zurückgeben, die für die Auswahlmöglichkeiten der Frage stehen.\n */\nconst char* f_20()", "ha": "#include <cassert>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n/**\n *  Amsa jerin tambayoyi ta hanyar bayar da zaɓuɓɓuka A, B, C, ko D ga kowace tambaya.\n *  \n *  Tambaya ta 1:\n *  Kwatankwacin kamar 1e6 suna cikin wane nau'in bayanai?\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n *  \n *  Tambaya ta 2:\n *  An ba da 21! = 51,090,942,171,709,440,000, wane nau'in bayanai za a iya amfani da shi don adana wannan ƙima?\n *      A. int\n *      B. long long\n *      C. double\n *      D. Babu ɗaya daga cikin waɗanda ke sama\n *  \n *  Tambaya ta 3:\n *  Wane bayani game da ƙimar hagu a cikin bayyana ba daidai ba ne?\n *      A. Bayanan sunan canji suna ƙimar hagu.\n *      B. Aiki na ƙaruwa yana buƙatar mai aiki ya zama ƙimar hagu.\n *      C. Bayanan cire alamar mai nuna suna ƙimar hagu.\n *      D. Bayanan aikin ƙaruwa na farko suna ƙimar hagu.\n *  \n *  Tambaya ta 4:\n *  Wane bayani game da ayyuka ba daidai ba ne?\n *      A. Sigogin tsari na aiki su ne canje-canje na gida.\n *      B. Ana ware sarari ga canje-canje na gida a cikin tsari.\n *      C. Nau'in aiki yana daidai da nau'in ƙimar dawowa.\n *      D. Aiki na iya kiran kansa daga cikin jikinsa.\n *  \n *  Tambaya ta 5:\n *  Wane bayani game da masu nuna ba daidai ba ne?\n *      A. Rarrabe masu nuna biyu yana daidai da bambanci a cikin ƙimar adireshinsu.\n *      B. Cire alamar mai nuna yana da alaƙa da warwarewa bisa nau'in mai nuna.\n *      C. int *p[4], p tsari ne na masu nuna int.\n *      D. Ana iya sanya sunayen ayyuka ga masu nuna ayyuka.\n *  \n *  Ana tsammanin ku dawo da kirtani kamar \"AAAAA\" kawai, wanda ke wakiltar zaɓuɓɓukan tambayar.\n */", "hi": "#include <cassert>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n/**\n *  प्रत्येक प्रश्न के लिए विकल्प A, B, C, या D प्रदान करके प्रश्नों की एक श्रृंखला का उत्तर दें।\n *  \n *  प्रश्न 1:\n *  1e6 जैसे स्थिरांक किस डेटा प्रकार से संबंधित हैं?\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n *  \n *  प्रश्न 2:\n *  दिए गए 21! = 51,090,942,171,709,440,000, इस मान को संग्रहीत करने के लिए कौन सा डेटा प्रकार उपयोग किया जा सकता है?\n *      A. int\n *      B. long long\n *      C. double\n *      D. उपरोक्त में से कोई नहीं\n *  \n *  प्रश्न 3:\n *  अभिव्यक्तियों में बाएँ मानों के बारे में कौन सा कथन गलत है?\n *      A. वेरिएबल नाम अभिव्यक्तियाँ बाएँ मान हैं।\n *      B. वृद्धि ऑपरेशन के लिए ऑपरेन्ड का बाएँ मान होना आवश्यक है।\n *      C. पॉइंटर डिरेफरेंस अभिव्यक्तियाँ बाएँ मान हैं।\n *      D. उपसर्ग वृद्धि ऑपरेशन अभिव्यक्तियाँ बाएँ मान हैं।\n *  \n *  प्रश्न 4:\n *  कार्यों के बारे में कौन सा कथन गलत है?\n *      A. एक फ़ंक्शन के औपचारिक पैरामीटर स्थानीय वेरिएबल हैं।\n *      B. स्थानीय वेरिएबल स्टैक में स्थान आवंटित करते हैं।\n *      C. फ़ंक्शन प्रकार और रिटर्न मान प्रकार समान होते हैं।\n *      D. एक फ़ंक्शन अपने शरीर के भीतर से स्वयं को कॉल कर सकता है।\n *  \n *  प्रश्न 5:\n *  पॉइंटर्स के बारे में कौन सा कथन गलत है?\n *      A. दो पॉइंटर्स को घटाने से उनके पते के मानों का अंतर प्राप्त होता है।\n *      B. पॉइंटर डिरेफरेंस में पॉइंटर के प्रकार के आधार पर समाधान शामिल होता है।\n *      C. int *p[4], p एक int पॉइंटर्स की एक सरणी है।\n *      D. फ़ंक्शन नामों को फ़ंक्शन पॉइंटर्स को सौंपा जा सकता है।\n *  \n *  आपको केवल \"AAAAA\" जैसे स्ट्रिंग्स लौटाने हैं, जो प्रश्न के विकल्पों के लिए खड़े हैं।\n */\nconst char* f_20()", "hu": "#include <cassert>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n/**\n *  Válaszolj egy sor kérdésre az A, B, C vagy D választási lehetőségek megadásával minden kérdéshez.\n *  \n *  1. kérdés:\n *  Az olyan konstansok, mint az 1e6, melyik adattípushoz tartoznak?\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n *  \n *  2. kérdés:\n *  Adott, hogy 21! = 51,090,942,171,709,440,000, melyik adattípus használható ennek az értéknek a tárolására?\n *      A. int\n *      B. long long\n *      C. double\n *      D. Egyik sem a fentiek közül\n *  \n *  3. kérdés:\n *  Melyik állítás helytelen a balértékekkel kapcsolatban a kifejezésekben?\n *      A. A változónév kifejezések balértékek.\n *      B. Az inkrementáló művelet megköveteli, hogy az operandus balérték legyen.\n *      C. A mutatódereferálás kifejezések balértékek.\n *      D. A prefix inkrementáló művelet kifejezések balértékek.\n *  \n *  4. kérdés:\n *  Melyik állítás helytelen a függvényekkel kapcsolatban?\n *      A. A függvény formális paraméterei lokális változók.\n *      B. A lokális változók a veremben kapnak helyet.\n *      C. A függvény típusa megegyezik a visszatérési érték típusával.\n *      D. Egy függvény meghívhatja önmagát a saját törzsén belül.\n *  \n *  5. kérdés:\n *  Melyik állítás helytelen a mutatókkal kapcsolatban?\n *      A. Két mutató kivonása az címértékeik különbségével egyenlő.\n *      B. A mutatódereferálás a mutató típusának megfelelő feloldást igényel.\n *      C. int *p[4], p egy int mutatók tömbje.\n *      D. A függvénynevek hozzárendelhetők függvénymutatókhoz.\n *  \n *  Csak olyan karakterláncokat kell visszaadnod, mint például \"AAAAA\", amelyek a kérdések választásait jelölik.\n */\nconst char* f_20()", "es": "#include <cassert>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n/**\n *  Responder a una serie de preguntas proporcionando opciones A, B, C o D para cada pregunta.\n *  \n *  Pregunta 1:\n *  ¿Constantes como 1e6 pertenecen a qué tipo de dato?\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n *  \n *  Pregunta 2:\n *  Dado 21! = 51,090,942,171,709,440,000, ¿qué tipo de dato se puede usar para almacenar este valor?\n *      A. int\n *      B. long long\n *      C. double\n *      D. Ninguna de las anteriores\n *  \n *  Pregunta 3:\n *  ¿Cuál afirmación sobre los valores a la izquierda en expresiones es incorrecta?\n *      A. Las expresiones de nombres de variables son valores a la izquierda.\n *      B. La operación de incremento requiere que el operando sea un valor a la izquierda.\n *      C. Las expresiones de desreferencia de punteros son valores a la izquierda.\n *      D. Las expresiones de operación de incremento prefijo son valores a la izquierda.\n *  \n *  Pregunta 4:\n *  ¿Cuál afirmación sobre las funciones es incorrecta?\n *      A. Los parámetros formales de una función son variables locales.\n *      B. Las variables locales se asignan espacio en la pila.\n *      C. El tipo de la función es el mismo que el tipo del valor de retorno.\n *      D. Una función puede llamarse a sí misma desde dentro de su cuerpo.\n *  \n *  Pregunta 5:\n *  ¿Cuál afirmación sobre los punteros es incorrecta?\n *      A. Restar dos punteros equivale a la diferencia en sus valores de dirección.\n *      B. La desreferencia de punteros implica resolver según el tipo del puntero.\n *      C. int *p[4], p es un arreglo de punteros a int.\n *      D. Los nombres de funciones pueden asignarse a punteros de funciones.\n *  \n *  Se supone que debes devolver solo cadenas similares a \"AAAAA\", que representan las opciones de la pregunta.\n */\nconst char* f_20()", "arb": "#include <cassert>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n/**\n *  أجب عن سلسلة من الأسئلة بتقديم الخيارات A، B، C، أو D لكل سؤال.\n *  \n *  السؤال 1:\n *  الثوابت مثل 1e6 تنتمي إلى أي نوع من البيانات؟\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n *  \n *  السؤال 2:\n *  بالنظر إلى 21! = 51,090,942,171,709,440,000، أي نوع من البيانات يمكن استخدامه لتخزين هذه القيمة؟\n *      A. int\n *      B. long long\n *      C. double\n *      D. لا شيء مما سبق\n *  \n *  السؤال 3:\n *  أي عبارة عن القيم اليسارية في التعبيرات غير صحيحة؟\n *      A. تعبيرات أسماء المتغيرات هي قيم يسارية.\n *      B. عملية الزيادة تتطلب أن يكون المعامل قيمة يسارية.\n *      C. تعبيرات إلغاء المؤشر هي قيم يسارية.\n *      D. تعبيرات عملية الزيادة المسبقة هي قيم يسارية.\n *  \n *  السؤال 4:\n *  أي عبارة عن الدوال غير صحيحة؟\n *      A. المعاملات الشكلية للدالة هي متغيرات محلية.\n *      B. يتم تخصيص مساحة للمتغيرات المحلية في المكدس.\n *      C. نوع الدالة هو نفسه نوع قيمة الإرجاع.\n *      D. يمكن للدالة أن تستدعي نفسها من داخل جسمها.\n *  \n *  السؤال 5:\n *  أي عبارة عن المؤشرات غير صحيحة؟\n *      A. طرح مؤشرين يساوي الفرق في قيم عناوينهما.\n *      B. إلغاء المؤشر يتضمن الحل بناءً على نوع المؤشر.\n *      C. int *p[4], p هو مصفوفة من مؤشرات int.\n *      D. يمكن تعيين أسماء الدوال إلى مؤشرات الدوال.\n *  \n *  من المفترض أن تعيد فقط سلاسل مشابهة لـ \"AAAAA\"، والتي تمثل خيارات السؤال.\n */\nconst char* f_20()", "sw": "#include <cassert>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n/**\n *  Jibu mfululizo wa maswali kwa kutoa chaguo A, B, C, au D kwa kila swali.\n *  \n *  Swali la 1:\n *  Vigezo kama 1e6 vinahusiana na aina gani ya data?\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n *  \n *  Swali la 2:\n *  Ukipewa 21! = 51,090,942,171,709,440,000, ni aina gani ya data inaweza kutumika kuhifadhi thamani hii?\n *      A. int\n *      B. long long\n *      C. double\n *      D. Hakuna kati ya hizi\n *  \n *  Swali la 3:\n *  Ni kauli gani kuhusu thamani za kushoto katika maelezo sio sahihi?\n *      A. Maelezo ya majina ya vigezo ni thamani za kushoto.\n *      B. Operesheni ya kuongeza inahitaji operand kuwa thamani ya kushoto.\n *      C. Maelezo ya kufuta pointer ni thamani za kushoto.\n *      D. Maelezo ya operesheni ya kuongeza awali ni thamani za kushoto.\n *  \n *  Swali la 4:\n *  Ni kauli gani kuhusu kazi sio sahihi?\n *      A. Vigezo rasmi vya kazi ni vigezo vya ndani.\n *      B. Vigezo vya ndani vinapewa nafasi kwenye stack.\n *      C. Aina ya kazi ni sawa na aina ya thamani ya kurudi.\n *      D. Kazi inaweza kujita kutoka ndani ya mwili wake.\n *  \n *  Swali la 5:\n *  Ni kauli gani kuhusu pointers sio sahihi?\n *      A. Kutoa mbili pointers ni sawa na tofauti katika thamani za anwani zao.\n *      B. Kufuta pointer kunahusisha kutatua kulingana na aina ya pointer.\n *      C. int *p[4], p ni safu ya pointers za int.\n *      D. Majina ya kazi yanaweza kupewa pointers za kazi.\n *  \n *  Unatakiwa kurudisha tu mistari inayofanana na \"AAAAA\", ambayo inawakilisha chaguo za swali.\n */\nconst char* f_20()", "tr": "#include <cassert>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n/**\n *  Her bir soru için A, B, C veya D seçeneklerini sağlayarak bir dizi soruyu yanıtlayın.\n *  \n *  Soru 1:\n *  1e6 gibi sabitler hangi veri türüne aittir?\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n *  \n *  Soru 2:\n *  21! = 51,090,942,171,709,440,000 verildiğinde, bu değeri saklamak için hangi veri türü kullanılabilir?\n *      A. int\n *      B. long long\n *      C. double\n *      D. Yukarıdakilerin hiçbiri\n *  \n *  Soru 3:\n *  İfadelerdeki sol değerler hakkında hangi ifade yanlıştır?\n *      A. Değişken adı ifadeleri sol değerlerdir.\n *      B. Artırma işlemi, operandın bir sol değer olmasını gerektirir.\n *      C. Pointer çözme ifadeleri sol değerlerdir.\n *      D. Ön ek artırma işlemi ifadeleri sol değerlerdir.\n *  \n *  Soru 4:\n *  Fonksiyonlar hakkında hangi ifade yanlıştır?\n *      A. Bir fonksiyonun resmi parametreleri yerel değişkenlerdir.\n *      B. Yerel değişkenler yığında yer kaplar.\n *      C. Fonksiyon türü, dönüş değeri türü ile aynıdır.\n *      D. Bir fonksiyon, gövdesi içinden kendisini çağırabilir.\n *  \n *  Soru 5:\n *  Pointerlar hakkında hangi ifade yanlıştır?\n *      A. İki pointerın çıkarılması, adres değerlerindeki farkı eşittir.\n *      B. Pointer çözme, pointer türüne göre çözümlemeyi içerir.\n *      C. int *p[4], p bir int pointerları dizisidir.\n *      D. Fonksiyon isimleri, fonksiyon pointerlarına atanabilir.\n *  \n *  Soruların seçeneklerini temsil eden \"AAAAA\" gibi dizeler döndürmeniz bekleniyor.\n */\nconst char* f_20()", "vi": "#include <cassert>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n/**\n *  Trả lời một loạt câu hỏi bằng cách cung cấp lựa chọn A, B, C, hoặc D cho mỗi câu hỏi.\n *  \n *  Câu hỏi 1:\n *  Hằng số như 1e6 thuộc kiểu dữ liệu nào?\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n *  \n *  Câu hỏi 2:\n *  Cho 21! = 51,090,942,171,709,440,000, kiểu dữ liệu nào có thể được sử dụng để lưu trữ giá trị này?\n *      A. int\n *      B. long long\n *      C. double\n *      D. Không có lựa chọn nào ở trên\n *  \n *  Câu hỏi 3:\n *  Câu nào về giá trị bên trái trong biểu thức là không đúng?\n *      A. Biểu thức tên biến là giá trị bên trái.\n *      B. Phép toán tăng yêu cầu toán hạng phải là giá trị bên trái.\n *      C. Biểu thức giải tham chiếu con trỏ là giá trị bên trái.\n *      D. Biểu thức phép toán tăng trước là giá trị bên trái.\n *  \n *  Câu hỏi 4:\n *  Câu nào về hàm là không đúng?\n *      A. Tham số hình thức của hàm là biến cục bộ.\n *      B. Biến cục bộ được cấp phát không gian trong ngăn xếp.\n *      C. Kiểu của hàm giống với kiểu giá trị trả về.\n *      D. Một hàm có thể gọi chính nó từ trong thân hàm.\n *  \n *  Câu hỏi 5:\n *  Câu nào về con trỏ là không đúng?\n *      A. Trừ hai con trỏ bằng với sự khác biệt trong giá trị địa chỉ của chúng.\n *      B. Giải tham chiếu con trỏ liên quan đến việc giải quyết dựa trên kiểu của con trỏ.\n *      C. int *p[4], p là một mảng các con trỏ int.\n *      D. Tên hàm có thể được gán cho con trỏ hàm.\n *  \n *  Bạn được yêu cầu chỉ trả về các chuỗi tương tự như \"AAAAA\", đại diện cho các lựa chọn của câu hỏi.\n */\nconst char* f_20()", "id": "#include <cassert>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n/**\n *  Jawab serangkaian pertanyaan dengan memberikan pilihan A, B, C, atau D untuk setiap pertanyaan.\n *  \n *  Pertanyaan 1:\n *  Konstanta seperti 1e6 termasuk dalam tipe data apa?\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n *  \n *  Pertanyaan 2:\n *  Diberikan 21! = 51,090,942,171,709,440,000, tipe data mana yang dapat digunakan untuk menyimpan nilai ini?\n *      A. int\n *      B. long long\n *      C. double\n *      D. Tidak ada di atas\n *  \n *  Pertanyaan 3:\n *  Pernyataan mana tentang nilai kiri dalam ekspresi yang salah?\n *      A. Ekspresi nama variabel adalah nilai kiri.\n *      B. Operasi peningkatan memerlukan operan menjadi nilai kiri.\n *      C. Ekspresi dereferensi pointer adalah nilai kiri.\n *      D. Ekspresi operasi peningkatan prefiks adalah nilai kiri.\n *  \n *  Pertanyaan 4:\n *  Pernyataan mana tentang fungsi yang salah?\n *      A. Parameter formal dari sebuah fungsi adalah variabel lokal.\n *      B. Variabel lokal dialokasikan ruang di stack.\n *      C. Tipe fungsi sama dengan tipe nilai kembalian.\n *      D. Sebuah fungsi dapat memanggil dirinya sendiri dari dalam tubuhnya.\n *  \n *  Pertanyaan 5:\n *  Pernyataan mana tentang pointer yang salah?\n *      A. Mengurangkan dua pointer sama dengan selisih nilai alamat mereka.\n *      B. Dereferensi pointer melibatkan penyelesaian berdasarkan tipe pointer.\n *      C. int *p[4], p adalah array dari pointer int.\n *      D. Nama fungsi dapat ditugaskan ke pointer fungsi.\n *  \n *  Anda seharusnya hanya mengembalikan string seperti \"AAAAA\", yang mewakili pilihan dari pertanyaan.\n */\nconst char* f_20()", "ja": "#include <cassert>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n/**\n *  各質問に対して選択肢A、B、C、またはDを提供して一連の質問に答えてください。\n *  \n *  質問 1:\n *  1e6のような定数はどのデータ型に属しますか？\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n *  \n *  質問 2:\n *  21! = 51,090,942,171,709,440,000の場合、この値を格納するために使用できるデータ型はどれですか？\n *      A. int\n *      B. long long\n *      C. double\n *      D. 上記のいずれでもない\n *  \n *  質問 3:\n *  式における左辺値について誤っている記述はどれですか？\n *      A. 変数名の式は左辺値です。\n *      B. インクリメント操作にはオペランドが左辺値である必要があります。\n *      C. ポインタのデリファレンス式は左辺値です。\n *      D. プレフィックスインクリメント操作の式は左辺値です。\n *  \n *  質問 4:\n *  関数について誤っている記述はどれですか？\n *      A. 関数の形式パラメータはローカル変数です。\n *      B. ローカル変数はスタックにスペースが割り当てられます。\n *      C. 関数の型は戻り値の型と同じです。\n *      D. 関数はその本体内から自身を呼び出すことができます。\n *  \n *  質問 5:\n *  ポインタについて誤っている記述はどれですか？\n *      A. 2つのポインタを引くと、そのアドレス値の差になります。\n *      B. ポインタのデリファレンスはポインタの型に基づいて解決されます。\n *      C. int *p[4], pはintポインタの配列です。\n *      D. 関数名は関数ポインタに代入できます。\n *  \n *  質問の選択肢を表す「AAAAA」のような文字列のみを返すことになっています。\n */\nconst char* f_20()", "ko": "#include <cassert>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n/**\n *  각 질문에 대해 선택지 A, B, C, 또는 D를 제공하여 일련의 질문에 답하십시오.\n *  \n *  질문 1:\n *  1e6과 같은 상수는 어떤 데이터 유형에 속합니까?\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n *  \n *  질문 2:\n *  21! = 51,090,942,171,709,440,000일 때, 이 값을 저장할 수 있는 데이터 유형은 무엇입니까?\n *      A. int\n *      B. long long\n *      C. double\n *      D. 위의 것들 중 아무것도 아님\n *  \n *  질문 3:\n *  표현식에서 왼쪽 값에 대한 설명 중 틀린 것은 무엇입니까?\n *      A. 변수 이름 표현식은 왼쪽 값입니다.\n *      B. 증분 연산은 피연산자가 왼쪽 값이어야 합니다.\n *      C. 포인터 역참조 표현식은 왼쪽 값입니다.\n *      D. 접두사 증분 연산 표현식은 왼쪽 값입니다.\n *  \n *  질문 4:\n *  함수에 대한 설명 중 틀린 것은 무엇입니까?\n *      A. 함수의 형식 매개변수는 지역 변수입니다.\n *      B. 지역 변수는 스택에 공간이 할당됩니다.\n *      C. 함수 유형은 반환 값 유형과 동일합니다.\n *      D. 함수는 본문 내에서 자신을 호출할 수 있습니다.\n *  \n *  질문 5:\n *  포인터에 대한 설명 중 틀린 것은 무엇입니까?\n *      A. 두 포인터를 빼면 주소 값의 차이가 됩니다.\n *      B. 포인터 역참조는 포인터의 유형에 따라 해석됩니다.\n *      C. int *p[4], p는 int 포인터 배열입니다.\n *      D. 함수 이름은 함수 포인터에 할당할 수 있습니다.\n *  \n *  당신은 질문의 선택지를 나타내는 \"AAAAA\"와 같은 문자열만 반환해야 합니다.\n */\nconst char* f_20()", "ml": "#include <cassert>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n/**\n *  ഓരോ ചോദ്യത്തിനും A, B, C, അല്ലെങ്കിൽ D എന്ന തിരഞ്ഞെടുപ്പുകൾ നൽകിക്കൊണ്ട് ചോദ്യങ്ങൾക്ക് ഉത്തരം നൽകുക.\n *  \n *  ചോദ്യം 1:\n *  1e6 പോലുള്ള സ്ഥിരാങ്കങ്ങൾ ഏത് ഡാറ്റാ ടൈപ്പിലാണ് ഉൾപ്പെടുന്നത്?\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n *  \n *  ചോദ്യം 2:\n *  21! = 51,090,942,171,709,440,000 എന്നത് നൽകിയാൽ, ഈ മൂല്യം സംഭരിക്കാൻ ഏത് ഡാറ്റാ ടൈപ്പ് ഉപയോഗിക്കാം?\n *      A. int\n *      B. long long\n *      C. double\n *      D. മുകളിൽ പറയുന്നവയൊന്നുമല്ല\n *  \n *  ചോദ്യം 3:\n *  പ്രകടനങ്ങളിലെ ഇടത് മൂല്യങ്ങളെക്കുറിച്ചുള്ള ഏത് പ്രസ്താവന തെറ്റാണ്?\n *      A. വേരിയബിൾ നെയിം പ്രകടനങ്ങൾ ഇടത് മൂല്യങ്ങളാണ്.\n *      B. വർദ്ധന പ്രവർത്തനം ഇടത് മൂല്യമായ ഓപ്പറാൻഡ് ആവശ്യമാണ്.\n *      C. പോയിന്റർ ഡീറഫറൻസ് പ്രകടനങ്ങൾ ഇടത് മൂല്യങ്ങളാണ്.\n *      D. പ്രിഫിക്സ് വർദ്ധന പ്രവർത്തന പ്രകടനങ്ങൾ ഇടത് മൂല്യങ്ങളാണ്.\n *  \n *  ചോദ്യം 4:\n *  ഫംഗ്ഷനുകളെക്കുറിച്ചുള്ള ഏത് പ്രസ്താവന തെറ്റാണ്?\n *      A. ഒരു ഫംഗ്ഷന്റെ ഔപചാരിക പാരാമീറ്ററുകൾ പ്രാദേശിക വേരിയബിൾസ് ആണ്.\n *      B. പ്രാദേശിക വേരിയബിൾസിന് സ്റ്റാക്കിൽ സ്ഥലം അനുവദിച്ചിരിക്കുന്നു.\n *      C. ഫംഗ്ഷൻ തരം തിരിച്ചുവരവ് മൂല്യ തരം പോലെയാണ്.\n *      D. ഒരു ഫംഗ്ഷൻ അതിന്റെ ബോഡിയിൽ നിന്ന് തന്നെ വിളിക്കാം.\n *  \n *  ചോദ്യം 5:\n *  പോയിന്ററുകളെക്കുറിച്ചുള്ള ഏത് പ്രസ്താവന തെറ്റാണ്?\n *      A. രണ്ട് പോയിന്ററുകൾ കുറയ്ക്കുന്നത് അവരുടെ വിലാസ മൂല്യങ്ങളിലെ വ്യത്യാസമാണ്.\n *      B. പോയിന്റർ ഡീറഫറൻസ്, പോയിന്ററിന്റെ തരം അടിസ്ഥാനമാക്കി പരിഹരിക്കുന്നു.\n *      C. int *p[4], p ഒരു int പോയിന്ററുകളുടെ നിരയാണ്.\n *      D. ഫംഗ്ഷൻ നാമങ്ങൾ ഫംഗ്ഷൻ പോയിന്ററുകൾക്ക് നിയോഗിക്കാം.\n *  \n *  നിങ്ങൾ \"AAAAA\" പോലുള്ള സ്ട്രിംഗുകൾ മാത്രമേ തിരികെ നൽകേണ്ടതുള്ളൂ, ഇത് ചോദ്യത്തിന്റെ തിരഞ്ഞെടുപ്പുകൾക്കായി നിൽക്കുന്നു.\n */\nconst char* f_20()", "fa": "#include <cassert>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n/**\n *  به یک سری سوال با ارائه گزینه‌های A، B، C یا D برای هر سوال پاسخ دهید.\n *  \n *  سوال 1:\n *  ثابت‌هایی مانند 1e6 به کدام نوع داده تعلق دارند؟\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n *  \n *  سوال 2:\n *  با توجه به 21! = 51,090,942,171,709,440,000، از کدام نوع داده می‌توان برای ذخیره این مقدار استفاده کرد؟\n *      A. int\n *      B. long long\n *      C. double\n *      D. هیچ‌کدام از موارد بالا\n *  \n *  سوال 3:\n *  کدام عبارت درباره مقادیر چپ در عبارات نادرست است؟\n *      A. عبارات نام متغیر مقادیر چپ هستند.\n *      B. عملیات افزایش نیاز دارد که عملوند یک مقدار چپ باشد.\n *      C. عبارات اشاره‌گر به مقدار مقادیر چپ هستند.\n *      D. عبارات عملیات افزایش پیشوندی مقادیر چپ هستند.\n *  \n *  سوال 4:\n *  کدام عبارت درباره توابع نادرست است؟\n *      A. پارامترهای رسمی یک تابع متغیرهای محلی هستند.\n *      B. متغیرهای محلی در پشته فضا تخصیص داده می‌شوند.\n *      C. نوع تابع همان نوع مقدار بازگشتی است.\n *      D. یک تابع می‌تواند از درون بدنه خود را فراخوانی کند.\n *  \n *  سوال 5:\n *  کدام عبارت درباره اشاره‌گرها نادرست است؟\n *      A. تفریق دو اشاره‌گر برابر با تفاوت در مقادیر آدرس آن‌ها است.\n *      B. اشاره‌گر به مقدار شامل حل بر اساس نوع اشاره‌گر است.\n *      C. int *p[4]، p یک آرایه از اشاره‌گرهای int است.\n *      D. نام توابع می‌تواند به اشاره‌گرهای تابع اختصاص یابد.\n *  \n *  شما باید فقط رشته‌هایی مشابه \"AAAAA\" را که نشان‌دهنده گزینه‌های سوال هستند، برگردانید.\n */\nconst char* f_20()"}, "canonical_solution": "{\n    return \"DDDBA\";\n}", "instruction": {"en": "Write a CPP function `const char* f_20()` to solve the following problem:\nAnswer a series of questions by providing choices A, B, C, or D for each question.\n\nQuestion 1:\nConstants like 1e6 belong to which data type?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nQuestion 2:\nGiven 21! = 51,090,942,171,709,440,000, which data type can be used to store this value?\n    A. int\n    B. long long\n    C. double\n    D. None of the above\n\nQuestion 3:\nWhich statement about left values in expressions is incorrect?\n    A. Variable name expressions are left values.\n    B. Increment operation requires the operand to be a left value.\n    C. Pointer dereference expressions are left values.\n    D. Prefix increment operation expressions are left values.\n\nQuestion 4:\nWhich statement about functions is incorrect?\n    A. Formal parameters of a function are local variables.\n    B. Local variables are allocated space in the stack.\n    C. The function type is the same as the return value type.\n    D. A function can call itself from within its body.\n\nQuestion 5:\nWhich statement about pointers is incorrect?\n    A. Subtracting two pointers equals the difference in their address values.\n    B. Pointer dereference involves resolving based on the pointer's type.\n    C. int *p[4], p is an array of int pointers.\n    D. Function names can be assigned to function pointers.\n\nYou're supposed to only return strings similar to \"AAAAA\", which stand for the choices of the question.", "sq": "Shkruani një funksion CPP `const char* f_20()` për të zgjidhur problemin e mëposhtëm:\nPërgjigjuni një serie pyetjesh duke dhënë zgjedhjet A, B, C, ose D për secilën pyetje.\n\nPyetja 1:\nKonstantet si 1e6 i përkasin cilit lloj të dhënash?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nPyetja 2:\nDuke pasur 21! = 51,090,942,171,709,440,000, cili lloj i të dhënave mund të përdoret për të ruajtur këtë vlerë?\n    A. int\n    B. long long\n    C. double\n    D. Asnjë nga të mësipërmet\n\nPyetja 3:\nCila deklaratë për vlerat e majta në shprehje është e pasaktë?\n    A. Shprehjet me emra variablash janë vlera të majta.\n    B. Operacioni i inkrementimit kërkon që operandi të jetë një vlerë e majtë.\n    C. Shprehjet e dereferencimit të treguesve janë vlera të majta.\n    D. Shprehjet e operacionit të inkrementimit prefiks janë vlera të majta.\n\nPyetja 4:\nCila deklaratë për funksionet është e pasaktë?\n    A. Parametrat formalë të një funksioni janë variabla lokale.\n    B. Variablat lokale alokohen hapësirë në stack.\n    C. Lloji i funksionit është i njëjtë me llojin e vlerës së kthimit.\n    D. Një funksion mund të thërrasë vetveten nga brenda trupit të tij.\n\nPyetja 5:\nCila deklaratë për treguesit është e pasaktë?\n    A. Zbritja e dy treguesve është e barabartë me diferencën në vlerat e adresave të tyre.\n    B. Dereferencimi i treguesit përfshin zgjidhjen bazuar në llojin e treguesit.\n    C. int *p[4], p është një varg treguesish int.\n    D. Emrat e funksioneve mund t'u caktohen treguesve të funksioneve.\n\nJu supozohet të ktheni vetëm vargje të ngjashme me \"AAAAA\", të cilat përfaqësojnë zgjedhjet e pyetjes.", "hy": "Գրեք C++ ֆունկցիա `const char* f_20()`՝ հետևյալ խնդիրը լուծելու համար:\nՊատասխանեք մի շարք հարցերի՝ յուրաքանչյուր հարցի համար տրամադրելով A, B, C կամ D ընտրություններից մեկը:\n\nՀարց 1:\nՆման 1e6 հաստատունները որ տվյալների տիպին են պատկանում?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nՀարց 2:\nԵնթադրելով 21! = 51,090,942,171,709,440,000, որ տվյալների տիպը կարող է պահել այս արժեքը?\n    A. int\n    B. long long\n    C. double\n    D. Վերոնշյալներից ոչ մեկը\n\nՀարց 3:\nՈ՞ր հայտարարությունը ձախ արժեքների մասին արտահայտություններում սխալ է:\n    A. Փոփոխականի անվան արտահայտությունները ձախ արժեքներ են:\n    B. Ինկրեմենտ գործողությունը պահանջում է, որ օպերանդը լինի ձախ արժեք:\n    C. Ցուցիչի ապասահմանման արտահայտությունները ձախ արժեքներ են:\n    D. Նախածանց ինկրեմենտ գործողության արտահայտությունները ձախ արժեքներ են:\n\nՀարց 4:\nՈ՞ր հայտարարությունը ֆունկցիաների մասին սխալ է:\n    A. Ֆունկցիայի ֆորմալ պարամետրերը տեղական փոփոխականներ են:\n    B. Տեղական փոփոխականները տեղադրվում են ստեկում:\n    C. Ֆունկցիայի տիպը նույնն է, ինչ վերադարձվող արժեքի տիպը:\n    D. Ֆունկցիան կարող է ինքն իրեն կանչել իր մարմնից:\n\nՀարց 5:\nՈ՞ր հայտարարությունը ցուցիչների մասին սխալ է:\n    A. Երկու ցուցիչների հանումը հավասար է նրանց հասցեների արժեքների տարբերությանը:\n    B. Ցուցիչի ապասահմանումը ներառում է լուծում ըստ ցուցիչի տիպի:\n    C. int *p[4], p-ն int ցուցիչների զանգված է:\n    D. Ֆունկցիայի անունները կարող են վերագրվել ֆունկցիայի ցուցիչներին:\n\nԴուք պետք է վերադարձնեք միայն նմանատիպ տողեր \"AAAAA\", որոնք ներկայացնում են հարցերի ընտրությունները:", "bn": "একটি CPP ফাংশন `const char* f_20()` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nপ্রতিটি প্রশ্নের জন্য পছন্দ A, B, C, বা D প্রদান করে প্রশ্নগুলির একটি সিরিজের উত্তর দিন।\n\nপ্রশ্ন ১:\n১e৬ এর মত ধ্রুবক কোন ডেটা টাইপের অন্তর্গত?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nপ্রশ্ন ২:\n২১! = ৫১,০৯০,৯৪২,১৭১,৭০৯,৪৪০,০০০ দেওয়া হলে, কোন ডেটা টাইপ এই মান সংরক্ষণ করতে ব্যবহার করা যেতে পারে?\n    A. int\n    B. long long\n    C. double\n    D. উপরোক্ত কোনোটিই নয়\n\nপ্রশ্ন ৩:\nএক্সপ্রেশনে বাম মান সম্পর্কে কোন বিবৃতি ভুল?\n    A. ভেরিয়েবল নাম এক্সপ্রেশনগুলি বাম মান।\n    B. ইনক্রিমেন্ট অপারেশনটির জন্য অপারেন্ডকে বাম মান হতে হবে।\n    C. পয়েন্টার ডেরেফারেন্স এক্সপ্রেশনগুলি বাম মান।\n    D. প্রিফিক্স ইনক্রিমেন্ট অপারেশন এক্সপ্রেশনগুলি বাম মান।\n\nপ্রশ্ন ৪:\nফাংশন সম্পর্কে কোন বিবৃতি ভুল?\n    A. একটি ফাংশনের আনুষ্ঠানিক প্যারামিটারগুলি স্থানীয় ভেরিয়েবল।\n    B. স্থানীয় ভেরিয়েবলগুলি স্ট্যাকে স্থান বরাদ্দ করা হয়।\n    C. ফাংশনের টাইপ এবং রিটার্ন ভ্যালুর টাইপ একই।\n    D. একটি ফাংশন তার দেহের ভিতর থেকে নিজেকে কল করতে পারে।\n\nপ্রশ্ন ৫:\nপয়েন্টার সম্পর্কে কোন বিবৃতি ভুল?\n    A. দুটি পয়েন্টার বিয়োগ করা তাদের ঠিকানা মানের পার্থক্যের সমান।\n    B. পয়েন্টার ডেরেফারেন্স পয়েন্টারের টাইপের উপর ভিত্তি করে সমাধান করা হয়।\n    C. int *p[4], p একটি int পয়েন্টারের অ্যারে।\n    D. ফাংশন নামগুলি ফাংশন পয়েন্টারগুলিতে বরাদ্দ করা যেতে পারে।\n\nআপনাকে শুধুমাত্র \"AAAAA\" এর মত স্ট্রিং ফেরত দিতে হবে, যা প্রশ্নের পছন্দগুলির জন্য দাঁড়ায়।", "bg": "Напишете CPP функция `const char* f_20()` за решаване на следния проблем:\nОтговорете на серия от въпроси, като предоставите избори A, B, C или D за всеки въпрос.\n\nВъпрос 1:\nКонстанти като 1e6 принадлежат към кой тип данни?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nВъпрос 2:\nДадено е 21! = 51,090,942,171,709,440,000, кой тип данни може да се използва за съхранение на тази стойност?\n    A. int\n    B. long long\n    C. double\n    D. Нито едно от горепосочените\n\nВъпрос 3:\nКое твърдение за левите стойности в изразите е неправилно?\n    A. Изразите с имена на променливи са леви стойности.\n    B. Операцията за инкрементиране изисква операндът да бъде лява стойност.\n    C. Изразите за разименуване на указатели са леви стойности.\n    D. Изразите за префиксно инкрементиране са леви стойности.\n\nВъпрос 4:\nКое твърдение за функциите е неправилно?\n    A. Формалните параметри на функцията са локални променливи.\n    B. Локалните променливи са разпределени в стека.\n    C. Типът на функцията е същият като типа на връщаната стойност.\n    D. Функцията може да извика сама себе си в тялото си.\n\nВъпрос 5:\nКое твърдение за указателите е неправилно?\n    A. Изваждането на два указателя е равно на разликата в техните адресни стойности.\n    B. Разименуването на указател включва разрешаване на базата на типа на указателя.\n    C. int *p[4], p е масив от указатели към int.\n    D. Имената на функциите могат да бъдат присвоени на указатели към функции.\n\nТрябва да върнете само низове, подобни на \"AAAAA\", които представляват изборите за въпроса.", "zh": "编写一个 CPP 函数 `const char* f_20()` 来解决以下问题：  \n通过为每个问题提供选择 A、B、C 或 D 来回答一系列问题。\n\n问题 1：  \n像 1e6 这样的常量属于哪种数据类型？  \n    A. unsigned int  \n    B. int  \n    C. float  \n    D. double  \n\n问题 2：  \n给定 21! = 51,090,942,171,709,440,000，哪种数据类型可以用来存储这个值？  \n    A. int  \n    B. long long  \n    C. double  \n    D. 以上都不是  \n\n问题 3：  \n关于表达式中的左值，哪项说法不正确？  \n    A. 变量名表达式是左值。  \n    B. 自增操作要求操作数是左值。  \n    C. 指针解引用表达式是左值。  \n    D. 前缀自增操作表达式是左值。  \n\n问题 4：  \n关于函数，哪项说法不正确？  \n    A. 函数的形式参数是局部变量。  \n    B. 局部变量在栈中分配空间。  \n    C. 函数类型与返回值类型相同。  \n    D. 函数可以在其主体内调用自身。  \n\n问题 5：  \n关于指针，哪项说法不正确？  \n    A. 两个指针相减等于它们地址值的差。  \n    B. 指针解引用涉及根据指针类型进行解析。  \n    C. int *p[4]，p 是一个 int 指针的数组。  \n    D. 函数名可以赋值给函数指针。  \n\n你应该只返回类似于 \"AAAAA\" 的字符串，代表问题的选择。", "fr": "Écrire une fonction CPP `const char* f_20()` pour résoudre le problème suivant :\nRépondre à une série de questions en fournissant des choix A, B, C ou D pour chaque question.\n\nQuestion 1 :\nLes constantes comme 1e6 appartiennent à quel type de données ?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nQuestion 2 :\nÉtant donné 21! = 51,090,942,171,709,440,000, quel type de données peut être utilisé pour stocker cette valeur ?\n    A. int\n    B. long long\n    C. double\n    D. Aucun des précédents\n\nQuestion 3 :\nQuelle affirmation concernant les valeurs à gauche dans les expressions est incorrecte ?\n    A. Les expressions de noms de variables sont des valeurs à gauche.\n    B. L'opération d'incrémentation nécessite que l'opérande soit une valeur à gauche.\n    C. Les expressions de déréférencement de pointeur sont des valeurs à gauche.\n    D. Les expressions d'opération d'incrémentation préfixée sont des valeurs à gauche.\n\nQuestion 4 :\nQuelle affirmation concernant les fonctions est incorrecte ?\n    A. Les paramètres formels d'une fonction sont des variables locales.\n    B. Les variables locales sont allouées dans la pile.\n    C. Le type de la fonction est le même que le type de la valeur de retour.\n    D. Une fonction peut s'appeler elle-même depuis son corps.\n\nQuestion 5 :\nQuelle affirmation concernant les pointeurs est incorrecte ?\n    A. Soustraire deux pointeurs équivaut à la différence de leurs valeurs d'adresse.\n    B. Le déréférencement de pointeur implique une résolution basée sur le type du pointeur.\n    C. int *p[4], p est un tableau de pointeurs int.\n    D. Les noms de fonctions peuvent être assignés à des pointeurs de fonction.\n\nVous êtes censé ne retourner que des chaînes similaires à \"AAAAA\", qui représentent les choix de la question.", "de": "Schreiben Sie eine CPP-Funktion `const char* f_20()`, um das folgende Problem zu lösen:\nBeantworten Sie eine Reihe von Fragen, indem Sie für jede Frage die Optionen A, B, C oder D angeben.\n\nFrage 1:\nKonstanten wie 1e6 gehören zu welchem Datentyp?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nFrage 2:\nAngenommen, 21! = 51,090,942,171,709,440,000, welcher Datentyp kann verwendet werden, um diesen Wert zu speichern?\n    A. int\n    B. long long\n    C. double\n    D. Keine der oben genannten\n\nFrage 3:\nWelche Aussage über linke Werte in Ausdrücken ist falsch?\n    A. Variablennamen-Ausdrücke sind linke Werte.\n    B. Bei der Inkrementoperation muss der Operand ein linker Wert sein.\n    C. Zeiger-Dereferenz-Ausdrücke sind linke Werte.\n    D. Präfix-Inkrement-Ausdrucksoperationen sind linke Werte.\n\nFrage 4:\nWelche Aussage über Funktionen ist falsch?\n    A. Formale Parameter einer Funktion sind lokale Variablen.\n    B. Lokale Variablen werden im Stack Speicherplatz zugewiesen.\n    C. Der Funktionstyp ist derselbe wie der Rückgabewerttyp.\n    D. Eine Funktion kann sich selbst innerhalb ihres Körpers aufrufen.\n\nFrage 5:\nWelche Aussage über Zeiger ist falsch?\n    A. Das Subtrahieren zweier Zeiger ergibt die Differenz ihrer Adresswerte.\n    B. Zeiger-Dereferenzierung erfolgt basierend auf dem Typ des Zeigers.\n    C. int *p[4], p ist ein Array von int-Zeigern.\n    D. Funktionsnamen können Funktionszeigern zugewiesen werden.\n\nSie sollen nur Zeichenfolgen wie \"AAAAA\" zurückgeben, die für die Auswahl der Frage stehen.", "ha": "Rubuta aikin CPP `const char* f_20()` don warware matsalar mai zuwa: \n\nAmsa jerin tambayoyi ta hanyar bayar da zaɓuɓɓuka A, B, C, ko D don kowace tambaya.\n\nTambaya ta 1:\nConstant kamar 1e6 yana cikin wane nau'in bayanai?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nTambaya ta 2:\nAn ba da 21! = 51,090,942,171,709,440,000, wane nau'in bayanai za a iya amfani da shi don adana wannan ƙima?\n    A. int\n    B. long long\n    C. double\n    D. Babu ɗaya daga cikin waɗanda ke sama\n\nTambaya ta 3:\nWane bayani game da ƙimar hagu a cikin maganganu ba daidai ba ne?\n    A. Maganganun sunayen canji ƙimar hagu ne.\n    B. Aikin ƙaruwa yana buƙatar mai aiki ya zama ƙimar hagu.\n    C. Maganganun cirewa na alamar suna ƙimar hagu ne.\n    D. Maganganun aikin ƙaruwa na farkon suna ƙimar hagu ne.\n\nTambaya ta 4:\nWane bayani game da ayyuka ba daidai ba ne?\n    A. Sigogin hukuma na aiki canje-canje na gida ne.\n    B. Canje-canje na gida suna samun sarari a cikin faifai.\n    C. Nau'in aiki yana daidai da nau'in ƙimar dawowa.\n    D. Aiki na iya kiran kansa daga cikin jikinsa.\n\nTambaya ta 5:\nWane bayani game da alamar ba daidai ba ne?\n    A. Cirewa alamar biyu yana daidai da bambanci a cikin ƙimar adireshin su.\n    B. Cire alamar yana buƙatar warwarewa bisa nau'in alamar.\n    C. int *p[4], p tsari ne na alamomin int.\n    D. Ana iya sanya sunayen ayyuka ga alamomin ayyuka.\n\nDole ne ka dawo da kirtani kamar \"AAAAA\", wanda ke wakiltar zaɓuɓɓukan tambayar.", "hi": "एक CPP फ़ंक्शन `const char* f_20()` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nप्रत्येक प्रश्न के लिए विकल्प A, B, C, या D प्रदान करके प्रश्नों की एक श्रृंखला का उत्तर दें।\n\nप्रश्न 1:\n1e6 जैसी स्थिरांक किस डेटा प्रकार से संबंधित हैं?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nप्रश्न 2:\nदिया गया 21! = 51,090,942,171,709,440,000, इस मान को संग्रहीत करने के लिए किस डेटा प्रकार का उपयोग किया जा सकता है?\n    A. int\n    B. long long\n    C. double\n    D. उपरोक्त में से कोई नहीं\n\nप्रश्न 3:\nअभिव्यक्तियों में बाएँ मानों के बारे में कौन सा कथन गलत है?\n    A. वेरिएबल नाम अभिव्यक्तियाँ बाएँ मान हैं।\n    B. वृद्धि ऑपरेशन के लिए ऑपरेन्ड का बाएँ मान होना आवश्यक है।\n    C. पॉइंटर डिरेफरेंस अभिव्यक्तियाँ बाएँ मान हैं।\n    D. उपसर्ग वृद्धि ऑपरेशन अभिव्यक्तियाँ बाएँ मान हैं।\n\nप्रश्न 4:\nफंक्शनों के बारे में कौन सा कथन गलत है?\n    A. एक फ़ंक्शन के औपचारिक पैरामीटर स्थानीय वेरिएबल होते हैं।\n    B. स्थानीय वेरिएबल स्टैक में स्थान आवंटित करते हैं।\n    C. फ़ंक्शन प्रकार वही है जो रिटर्न मान प्रकार है।\n    D. एक फ़ंक्शन अपने शरीर के भीतर से स्वयं को कॉल कर सकता है।\n\nप्रश्न 5:\nपॉइंटर्स के बारे में कौन सा कथन गलत है?\n    A. दो पॉइंटर्स को घटाने से उनके पते के मानों में अंतर होता है।\n    B. पॉइंटर डिरेफरेंस में पॉइंटर के प्रकार के आधार पर समाधान शामिल होता है।\n    C. int *p[4], p एक int पॉइंटर्स की सरणी है।\n    D. फ़ंक्शन नाम को फ़ंक्शन पॉइंटर्स को सौंपा जा सकता है।\n\nआपको केवल \"AAAAA\" जैसे स्ट्रिंग्स लौटाने हैं, जो प्रश्न के विकल्पों के लिए खड़े होते हैं।", "hu": "Írj egy CPP függvényt `const char* f_20()` a következő probléma megoldására:\nVálaszolj egy sor kérdésre az A, B, C vagy D választási lehetőségek megadásával minden kérdésre.\n\n1. kérdés:\nAz olyan konstansok, mint az 1e6, melyik adattípushoz tartoznak?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\n2. kérdés:\nTekintettel arra, hogy 21! = 51,090,942,171,709,440,000, melyik adattípus használható ennek az értéknek a tárolására?\n    A. int\n    B. long long\n    C. double\n    D. Egyik sem a fentiek közül\n\n3. kérdés:\nMelyik állítás helytelen a bal értékekkel kapcsolatban a kifejezésekben?\n    A. A változónév kifejezések bal értékek.\n    B. Az inkrementáló művelet megköveteli, hogy az operandus bal érték legyen.\n    C. A pointer dereferálási kifejezések bal értékek.\n    D. A prefix inkrementáló műveleti kifejezések bal értékek.\n\n4. kérdés:\nMelyik állítás helytelen a függvényekkel kapcsolatban?\n    A. A függvény formális paraméterei lokális változók.\n    B. A lokális változók számára a veremben van hely lefoglalva.\n    C. A függvény típusa megegyezik a visszatérési érték típusával.\n    D. Egy függvény meghívhatja önmagát a törzsén belül.\n\n5. kérdés:\nMelyik állítás helytelen a pointerekkel kapcsolatban?\n    A. Két pointer kivonása egyenlő a címértékeik különbségével.\n    B. A pointer dereferálása a pointer típusának alapján történő feloldást jelenti.\n    C. int *p[4], p egy int pointerek tömbje.\n    D. A függvénynevek hozzárendelhetők függvény pointerekhez.\n\nCsak olyan karakterláncokat kell visszaadnod, mint például \"AAAAA\", amelyek a kérdések választásait jelölik.", "es": "Escribe una función CPP `const char* f_20()` para resolver el siguiente problema:\nResponde una serie de preguntas proporcionando opciones A, B, C o D para cada pregunta.\n\nPregunta 1:\n¿A qué tipo de dato pertenecen constantes como 1e6?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nPregunta 2:\nDado 21! = 51,090,942,171,709,440,000, ¿qué tipo de dato se puede usar para almacenar este valor?\n    A. int\n    B. long long\n    C. double\n    D. Ninguno de los anteriores\n\nPregunta 3:\n¿Cuál afirmación sobre los valores a la izquierda en expresiones es incorrecta?\n    A. Las expresiones de nombres de variables son valores a la izquierda.\n    B. La operación de incremento requiere que el operando sea un valor a la izquierda.\n    C. Las expresiones de desreferencia de punteros son valores a la izquierda.\n    D. Las expresiones de operación de incremento prefijo son valores a la izquierda.\n\nPregunta 4:\n¿Cuál afirmación sobre las funciones es incorrecta?\n    A. Los parámetros formales de una función son variables locales.\n    B. Las variables locales se asignan espacio en la pila.\n    C. El tipo de la función es el mismo que el tipo de valor de retorno.\n    D. Una función puede llamarse a sí misma desde dentro de su cuerpo.\n\nPregunta 5:\n¿Cuál afirmación sobre los punteros es incorrecta?\n    A. Restar dos punteros equivale a la diferencia en sus valores de dirección.\n    B. La desreferencia de punteros implica resolver basado en el tipo del puntero.\n    C. int *p[4], p es un arreglo de punteros a int.\n    D. Los nombres de funciones pueden asignarse a punteros de función.\n\nSe supone que solo debes devolver cadenas similares a \"AAAAA\", que representan las opciones de la pregunta.", "arb": "اكتب دالة CPP `const char* f_20()` لحل المشكلة التالية:\nالإجابة على سلسلة من الأسئلة عن طريق تقديم الخيارات A، B، C، أو D لكل سؤال.\n\nالسؤال 1:\nالثوابت مثل 1e6 تنتمي إلى أي نوع من البيانات؟\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nالسؤال 2:\nبالنظر إلى 21! = 51,090,942,171,709,440,000، أي نوع من البيانات يمكن استخدامه لتخزين هذه القيمة؟\n    A. int\n    B. long long\n    C. double\n    D. لا شيء مما سبق\n\nالسؤال 3:\nأي عبارة عن القيم اليسارية في التعبيرات غير صحيحة؟\n    A. تعبيرات أسماء المتغيرات هي قيم يسارية.\n    B. عملية الزيادة تتطلب أن يكون المعامل قيمة يسارية.\n    C. تعبيرات إلغاء المؤشر هي قيم يسارية.\n    D. تعبيرات عملية الزيادة المسبقة هي قيم يسارية.\n\nالسؤال 4:\nأي عبارة عن الدوال غير صحيحة؟\n    A. المعاملات الشكلية للدالة هي متغيرات محلية.\n    B. المتغيرات المحلية يتم تخصيص مساحة لها في المكدس.\n    C. نوع الدالة هو نفسه نوع قيمة الإرجاع.\n    D. يمكن للدالة أن تستدعي نفسها من داخل جسمها.\n\nالسؤال 5:\nأي عبارة عن المؤشرات غير صحيحة؟\n    A. طرح مؤشرين يساوي الفرق في قيم عناوينهما.\n    B. إلغاء المؤشر يتضمن الحل بناءً على نوع المؤشر.\n    C. int *p[4]، p هو مصفوفة من مؤشرات int.\n    D. يمكن تعيين أسماء الدوال إلى مؤشرات الدوال.\n\nمن المفترض أن تعيد فقط سلاسل مشابهة لـ \"AAAAA\"، والتي تمثل اختيارات السؤال.", "sw": "Andika kazi ya CPP `const char* f_20()` kutatua tatizo lifuatalo:\nJibu mfululizo wa maswali kwa kutoa chaguo A, B, C, au D kwa kila swali.\n\nSwali la 1:\nKonstanti kama 1e6 ni ya aina gani ya data?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nSwali la 2:\nKwa kuzingatia 21! = 51,090,942,171,709,440,000, aina gani ya data inaweza kutumika kuhifadhi thamani hii?\n    A. int\n    B. long long\n    C. double\n    D. Hakuna kati ya haya\n\nSwali la 3:\nNi kauli gani kuhusu thamani za kushoto katika maonyesho si sahihi?\n    A. Maonyesho ya majina ya vigezo ni thamani za kushoto.\n    B. Operesheni ya kuongeza inahitaji operand kuwa thamani ya kushoto.\n    C. Maonyesho ya kufuta pointer ni thamani za kushoto.\n    D. Maonyesho ya operesheni ya kuongeza awali ni thamani za kushoto.\n\nSwali la 4:\nNi kauli gani kuhusu kazi si sahihi?\n    A. Vigezo rasmi vya kazi ni vigezo vya ndani.\n    B. Vigezo vya ndani vinapewa nafasi katika stack.\n    C. Aina ya kazi ni sawa na aina ya thamani ya kurudi.\n    D. Kazi inaweza kujita kutoka ndani ya mwili wake.\n\nSwali la 5:\nNi kauli gani kuhusu pointers si sahihi?\n    A. Kutoa pointers mbili ni sawa na tofauti katika thamani za anwani zao.\n    B. Kufuta pointer kunahusisha kutatua kulingana na aina ya pointer.\n    C. int *p[4], p ni safu ya pointers za int.\n    D. Majina ya kazi yanaweza kupewa pointers za kazi.\n\nUnatakiwa kurudisha tu misururu inayofanana na \"AAAAA\", ambayo inawakilisha chaguo za swali.", "tr": "Bir CPP fonksiyonu `const char* f_20()` yazın ve aşağıdaki problemi çözün:\nHer soru için A, B, C veya D seçeneklerini sağlayarak bir dizi soruyu yanıtlayın.\n\nSoru 1:\n1e6 gibi sabitler hangi veri tipine aittir?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nSoru 2:\n21! = 51,090,942,171,709,440,000 verildiğinde, bu değeri saklamak için hangi veri tipi kullanılabilir?\n    A. int\n    B. long long\n    C. double\n    D. Yukarıdakilerin hiçbiri\n\nSoru 3:\nİfadelerdeki sol değerler hakkında hangi ifade yanlıştır?\n    A. Değişken adı ifadeleri sol değerlerdir.\n    B. Artırma işlemi, operandın sol değer olmasını gerektirir.\n    C. Gösterici çözme ifadeleri sol değerlerdir.\n    D. Ön ek artırma işlemi ifadeleri sol değerlerdir.\n\nSoru 4:\nFonksiyonlar hakkında hangi ifade yanlıştır?\n    A. Bir fonksiyonun resmi parametreleri yerel değişkenlerdir.\n    B. Yerel değişkenler yığında alan tahsis edilir.\n    C. Fonksiyon tipi, dönüş değeri tipi ile aynıdır.\n    D. Bir fonksiyon, kendi gövdesinden kendisini çağırabilir.\n\nSoru 5:\nGöstericiler hakkında hangi ifade yanlıştır?\n    A. İki göstericinin çıkarılması, adres değerlerindeki farkı eşittir.\n    B. Gösterici çözme, göstericinin türüne göre çözülmeyi içerir.\n    C. int *p[4], p bir int gösterici dizisidir.\n    D. Fonksiyon isimleri, fonksiyon göstericilerine atanabilir.\n\nSoruların seçenekleri gibi \"AAAAA\" şeklinde dizeler döndürmeniz bekleniyor.", "vi": "Viết một hàm CPP `const char* f_20()` để giải quyết vấn đề sau:  \nTrả lời một loạt câu hỏi bằng cách cung cấp lựa chọn A, B, C, hoặc D cho mỗi câu hỏi.\n\nCâu hỏi 1:  \nHằng số như 1e6 thuộc kiểu dữ liệu nào?  \n    A. unsigned int  \n    B. int  \n    C. float  \n    D. double  \n\nCâu hỏi 2:  \nCho 21! = 51,090,942,171,709,440,000, kiểu dữ liệu nào có thể được sử dụng để lưu trữ giá trị này?  \n    A. int  \n    B. long long  \n    C. double  \n    D. Không có cái nào ở trên  \n\nCâu hỏi 3:  \nPhát biểu nào về giá trị trái trong biểu thức là không đúng?  \n    A. Biểu thức tên biến là giá trị trái.  \n    B. Toán tử tăng yêu cầu toán hạng phải là giá trị trái.  \n    C. Biểu thức giải tham chiếu con trỏ là giá trị trái.  \n    D. Biểu thức toán tử tăng tiền tố là giá trị trái.  \n\nCâu hỏi 4:  \nPhát biểu nào về hàm là không đúng?  \n    A. Tham số hình thức của một hàm là biến cục bộ.  \n    B. Biến cục bộ được cấp phát không gian trong ngăn xếp.  \n    C. Kiểu hàm giống như kiểu giá trị trả về.  \n    D. Một hàm có thể tự gọi chính nó từ trong thân của nó.  \n\nCâu hỏi 5:  \nPhát biểu nào về con trỏ là không đúng?  \n    A. Trừ hai con trỏ bằng với sự khác biệt trong giá trị địa chỉ của chúng.  \n    B. Giải tham chiếu con trỏ liên quan đến việc giải quyết dựa trên kiểu của con trỏ.  \n    C. int *p[4], p là một mảng con trỏ int.  \n    D. Tên hàm có thể được gán cho con trỏ hàm.  \n\nBạn cần chỉ trả về chuỗi tương tự như \"AAAAA\", đại diện cho các lựa chọn của câu hỏi.", "id": "Tulis fungsi CPP `const char* f_20()` untuk menyelesaikan masalah berikut:\nMenjawab serangkaian pertanyaan dengan memberikan pilihan A, B, C, atau D untuk setiap pertanyaan.\n\nPertanyaan 1:\nKonstanta seperti 1e6 termasuk dalam tipe data apa?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nPertanyaan 2:\nDiberikan 21! = 51,090,942,171,709,440,000, tipe data mana yang dapat digunakan untuk menyimpan nilai ini?\n    A. int\n    B. long long\n    C. double\n    D. Tidak ada dari yang di atas\n\nPertanyaan 3:\nPernyataan mana tentang nilai kiri dalam ekspresi yang salah?\n    A. Ekspresi nama variabel adalah nilai kiri.\n    B. Operasi peningkatan memerlukan operan menjadi nilai kiri.\n    C. Ekspresi dereferensi pointer adalah nilai kiri.\n    D. Ekspresi operasi peningkatan prefiks adalah nilai kiri.\n\nPertanyaan 4:\nPernyataan mana tentang fungsi yang salah?\n    A. Parameter formal dari suatu fungsi adalah variabel lokal.\n    B. Variabel lokal dialokasikan ruang di stack.\n    C. Tipe fungsi sama dengan tipe nilai kembalian.\n    D. Sebuah fungsi dapat memanggil dirinya sendiri dari dalam tubuhnya.\n\nPertanyaan 5:\nPernyataan mana tentang pointer yang salah?\n    A. Mengurangi dua pointer sama dengan perbedaan dalam nilai alamat mereka.\n    B. Dereferensi pointer melibatkan penyelesaian berdasarkan tipe pointer.\n    C. int *p[4], p adalah array dari pointer int.\n    D. Nama fungsi dapat ditugaskan ke pointer fungsi.\n\nAnda seharusnya hanya mengembalikan string seperti \"AAAAA\", yang mewakili pilihan dari pertanyaan.", "ja": "CPP関数 `const char* f_20()` を作成して、次の問題を解決してください:\n各質問に対して選択肢A、B、C、またはDを提供して、一連の質問に答えてください。\n\n質問1:\n1e6のような定数はどのデータ型に属しますか？\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\n質問2:\n21! = 51,090,942,171,709,440,000の場合、この値を格納するために使用できるデータ型はどれですか？\n    A. int\n    B. long long\n    C. double\n    D. 上記のどれでもない\n\n質問3:\n式における左辺値について誤っているのはどれですか？\n    A. 変数名の式は左辺値である。\n    B. インクリメント操作にはオペランドが左辺値であることが必要である。\n    C. ポインタの逆参照式は左辺値である。\n    D. 前置インクリメント操作の式は左辺値である。\n\n質問4:\n関数について誤っているのはどれですか？\n    A. 関数の仮引数はローカル変数である。\n    B. ローカル変数はスタックにスペースが割り当てられる。\n    C. 関数の型は戻り値の型と同じである。\n    D. 関数はその本体内から自分自身を呼び出すことができる。\n\n質問5:\nポインタについて誤っているのはどれですか？\n    A. 2つのポインタを引くと、それらのアドレス値の差になる。\n    B. ポインタの逆参照はポインタの型に基づいて解決される。\n    C. int *p[4], pはintポインタの配列である。\n    D. 関数名は関数ポインタに代入できる。\n\nあなたは質問の選択肢を表す「AAAAA」のような文字列を返すことになっています。", "ko": "CPP 함수 `const char* f_20()`를 작성하여 다음 문제를 해결하십시오: 각 질문에 대해 선택지 A, B, C 또는 D를 제공하여 일련의 질문에 답하십시오.\n\n질문 1:\n1e6과 같은 상수는 어떤 데이터 유형에 속합니까?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\n질문 2:\n21! = 51,090,942,171,709,440,000이 주어졌을 때, 이 값을 저장하는 데 사용할 수 있는 데이터 유형은 무엇입니까?\n    A. int\n    B. long long\n    C. double\n    D. 위의 것들 중 아무것도 아님\n\n질문 3:\n표현식의 왼쪽 값에 대한 설명 중 틀린 것은 무엇입니까?\n    A. 변수 이름 표현식은 왼쪽 값입니다.\n    B. 증가 연산은 피연산자가 왼쪽 값이어야 합니다.\n    C. 포인터 역참조 표현식은 왼쪽 값입니다.\n    D. 접두사 증가 연산 표현식은 왼쪽 값입니다.\n\n질문 4:\n함수에 대한 설명 중 틀린 것은 무엇입니까?\n    A. 함수의 형식 매개변수는 지역 변수입니다.\n    B. 지역 변수는 스택에 공간이 할당됩니다.\n    C. 함수 유형은 반환 값 유형과 동일합니다.\n    D. 함수는 본문 내에서 자신을 호출할 수 있습니다.\n\n질문 5:\n포인터에 대한 설명 중 틀린 것은 무엇입니까?\n    A. 두 포인터를 빼면 주소 값의 차이가 됩니다.\n    B. 포인터 역참조는 포인터의 유형에 따라 해석됩니다.\n    C. int *p[4], p는 int 포인터의 배열입니다.\n    D. 함수 이름은 함수 포인터에 할당할 수 있습니다.\n\n당신은 질문의 선택지를 나타내는 \"AAAAA\"와 같은 문자열만 반환해야 합니다.", "ml": "ഒരു സിപിപി ഫംഗ്ഷൻ എഴുതുക`const char* f_20()` എന്നത് താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ: ഓരോ ചോദ്യംക്കും A, B, C, അല്ലെങ്കിൽ D എന്നിങ്ങനെ തിരഞ്ഞെടുക്കലുകൾ നൽകി ചോദ്യങ്ങൾക്ക് ഉത്തരം നൽകുക.\n\nചോദ്യം 1:\n1e6 പോലുള്ള സ്ഥിരാങ്കങ്ങൾ ഏത് ഡാറ്റാ തരം ആകുന്നു?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nചോദ്യം 2:\n21! = 51,090,942,171,709,440,000 എന്നത് നൽകിയാൽ, ഈ മൂല്യം സംഭരിക്കാൻ ഏത് ഡാറ്റാ തരം ഉപയോഗിക്കാം?\n    A. int\n    B. long long\n    C. double\n    D. മുകളിലെവയും അല്ല\n\nചോദ്യം 3:\nവ്യക്തീകരണങ്ങളിലെ ഇടത് മൂല്യങ്ങളെക്കുറിച്ചുള്ള ഏത് പ്രസ്താവന തെറ്റാണ്?\n    A. വേരിയബിൾ നാമ വ്യക്തീകരണങ്ങൾ ഇടത് മൂല്യങ്ങളാണ്.\n    B. വർദ്ധന ഓപ്പറേഷൻക്ക് ഓപ്പറാൻഡ് ഇടത് മൂല്യം ആയിരിക്കണം.\n    C. പോയിന്റർ ഡീറഫറൻസ് വ്യക്തീകരണങ്ങൾ ഇടത് മൂല്യങ്ങളാണ്.\n    D. പ്രിഫിക്സ് വർദ്ധന ഓപ്പറേഷൻ വ്യക്തീകരണങ്ങൾ ഇടത് മൂല്യങ്ങളാണ്.\n\nചോദ്യം 4:\nഫംഗ്ഷനുകളെക്കുറിച്ചുള്ള ഏത് പ്രസ്താവന തെറ്റാണ്?\n    A. ഒരു ഫംഗ്ഷന്റെ ഔപചാരിക പാരാമീറ്ററുകൾ ലോക്കൽ വേരിയബിൾസ് ആണ്.\n    B. ലോക്കൽ വേരിയബിൾസ് സ്റ്റാക്കിൽ സ്ഥലം അനുവദിക്കുന്നു.\n    C. ഫംഗ്ഷൻ തരം മടക്ക മൂല്യ തരം പോലെ തന്നെയാണ്.\n    D. ഒരു ഫംഗ്ഷൻ അതിന്റെ ശരീരത്തിൽ നിന്ന് തന്നെ വിളിക്കാം.\n\nചോദ്യം 5:\nപോയിന്ററുകളെക്കുറിച്ചുള്ള ഏത് പ്രസ്താവന തെറ്റാണ്?\n    A. രണ്ട് പോയിന്ററുകൾ കുറയ്ക്കുന്നത് അവരുടെ വിലാസ മൂല്യങ്ങളിലെ വ്യത്യാസം ആണ്.\n    B. പോയിന്റർ ഡീറഫറൻസ്, പോയിന്ററിന്റെ തരം അടിസ്ഥാനമാക്കി പരിഹരിക്കുന്നു.\n    C. int *p[4], p ഒരു int പോയിന്ററുകളുടെ നിരയാണ്.\n    D. ഫംഗ്ഷൻ പേരുകൾ ഫംഗ്ഷൻ പോയിന്ററുകൾക്ക് നിയോഗിക്കാം.\n\nനിങ്ങൾ ചോദ്യത്തിന്റെ തിരഞ്ഞെടുക്കലുകൾ സൂചിപ്പിക്കുന്ന \"AAAAA\" പോലുള്ള സ്ട്രിംഗുകൾ മാത്രം മടക്കേണ്ടതാണ്.", "fa": "یک تابع CPP به نام `const char* f_20()` بنویسید تا مسئله زیر را حل کنید:\nبه یک سری سوال با ارائه گزینه‌های A، B، C یا D برای هر سوال پاسخ دهید.\n\nسوال 1:\nثابت‌هایی مانند 1e6 به کدام نوع داده‌ای تعلق دارند؟\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nسوال 2:\nبا توجه به 21! = 51,090,942,171,709,440,000، از کدام نوع داده‌ای می‌توان برای ذخیره این مقدار استفاده کرد؟\n    A. int\n    B. long long\n    C. double\n    D. هیچ‌کدام از موارد فوق\n\nسوال 3:\nکدام عبارت درباره مقادیر چپ در عبارات نادرست است؟\n    A. عبارات نام متغیر مقادیر چپ هستند.\n    B. عملیات افزایش نیاز دارد که عملوند یک مقدار چپ باشد.\n    C. عبارات اشاره‌گر به مقادیر چپ هستند.\n    D. عبارات عملیات افزایش پیشوندی مقادیر چپ هستند.\n\nسوال 4:\nکدام عبارت درباره توابع نادرست است؟\n    A. پارامترهای رسمی یک تابع متغیرهای محلی هستند.\n    B. متغیرهای محلی در پشته فضا اختصاص داده می‌شوند.\n    C. نوع تابع با نوع مقدار بازگشتی یکسان است.\n    D. یک تابع می‌تواند خود را از درون بدنه‌اش فراخوانی کند.\n\nسوال 5:\nکدام عبارت درباره اشاره‌گرها نادرست است؟\n    A. تفریق دو اشاره‌گر برابر با تفاوت در مقادیر آدرس آن‌ها است.\n    B. اشاره‌گر به نوع اشاره‌گر برای رفع ارجاع نیاز دارد.\n    C. int *p[4]، p یک آرایه از اشاره‌گرهای int است.\n    D. نام‌های توابع می‌توانند به اشاره‌گرهای تابع اختصاص داده شوند.\n\nشما باید فقط رشته‌هایی مشابه \"AAAAA\" که نشان‌دهنده انتخاب‌های سوال هستند را برگردانید."}, "level": "easy", "test": "int main() {\n    // The assert should compare strings, not literals or enums, using strcmp\n    const char* expected_answers = \"DDDBA\";\n    assert(strcmp(f_20(), expected_answers) == 0);\n    \n    return 0;\n}", "entry_point": "f_20", "signature": "const char* f_20()", "docstring": {"en": "Answer a series of questions by providing choices A, B, C, or D for each question.\n\nQuestion 1:\nConstants like 1e6 belong to which data type?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nQuestion 2:\nGiven 21! = 51,090,942,171,709,440,000, which data type can be used to store this value?\n    A. int\n    B. long long\n    C. double\n    D. None of the above\n\nQuestion 3:\nWhich statement about left values in expressions is incorrect?\n    A. Variable name expressions are left values.\n    B. Increment operation requires the operand to be a left value.\n    C. Pointer dereference expressions are left values.\n    D. Prefix increment operation expressions are left values.\n\nQuestion 4:\nWhich statement about functions is incorrect?\n    A. Formal parameters of a function are local variables.\n    B. Local variables are allocated space in the stack.\n    C. The function type is the same as the return value type.\n    D. A function can call itself from within its body.\n\nQuestion 5:\nWhich statement about pointers is incorrect?\n    A. Subtracting two pointers equals the difference in their address values.\n    B. Pointer dereference involves resolving based on the pointer's type.\n    C. int *p[4], p is an array of int pointers.\n    D. Function names can be assigned to function pointers.\n\nYou're supposed to only return strings similar to \"AAAAA\", which stand for the choices of the question.", "sq": "Përgjigjuni një serie pyetjesh duke dhënë zgjedhjet A, B, C, ose D për secilën pyetje.\n\nPyetja 1:\nKonstantet si 1e6 i përkasin cilit lloj të dhënash?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nPyetja 2:\nDuke pasur parasysh 21! = 51,090,942,171,709,440,000, cili lloj të dhënash mund të përdoret për të ruajtur këtë vlerë?\n    A. int\n    B. long long\n    C. double\n    D. Asnjë nga më sipër\n\nPyetja 3:\nCila deklaratë për vlerat e majta në shprehje është e pasaktë?\n    A. Shprehjet e emrave të variablave janë vlera të majta.\n    B. Operacioni i inkrementimit kërkon që operand të jetë një vlerë e majtë.\n    C. Shprehjet e dereferencimit të treguesve janë vlera të majta.\n    D. Shprehjet e operacionit të inkrementimit prefiks janë vlera të majta.\n\nPyetja 4:\nCila deklaratë për funksionet është e pasaktë?\n    A. Parametrat formalë të një funksioni janë variabla lokale.\n    B. Variablat lokale alokohen hapësirë në stack.\n    C. Lloji i funksionit është i njëjtë me llojin e vlerës së kthimit.\n    D. Një funksion mund të thërrasë veten brenda trupit të tij.\n\nPyetja 5:\nCila deklaratë për treguesit është e pasaktë?\n    A. Zbritja e dy treguesve është e barabartë me diferencën në vlerat e adresave të tyre.\n    B. Dereferencimi i treguesit përfshin zgjidhjen bazuar në llojin e treguesit.\n    C. int *p[4], p është një varg treguesish int.\n    D. Emrat e funksioneve mund të caktohen te treguesit e funksioneve.\n\nJu supozohet të ktheni vetëm vargje të ngjashme me \"AAAAA\", të cilat përfaqësojnë zgjedhjet e pyetjes.", "hy": "Պատասխանեք մի շարք հարցերի՝ յուրաքանչյուր հարցի համար տրամադրելով ընտրանքներ A, B, C կամ D:\n\nՀարց 1:\nՆման 1e6 հաստատունները որ տվյալների տիպին են պատկանում?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nՀարց 2:\nՀաշվի առնելով 21! = 51,090,942,171,709,440,000, որ տվյալների տիպը կարող է օգտագործվել այս արժեքը պահելու համար?\n    A. int\n    B. long long\n    C. double\n    D. Վերը նշվածներից ոչ մեկը\n\nՀարց 3:\nՈր հայտարարությունն է սխալ ձախ արժեքների վերաբերյալ արտահայտություններում?\n    A. Փոփոխականի անվան արտահայտությունները ձախ արժեքներ են:\n    B. Ինկրեմենտի գործողությունը պահանջում է, որ օպերանդը լինի ձախ արժեք:\n    C. Ցուցիչի ապահանում արտահայտությունները ձախ արժեքներ են:\n    D. Նախածանց ինկրեմենտի գործողության արտահայտությունները ձախ արժեքներ են:\n\nՀարց 4:\nՈր հայտարարությունն է սխալ ֆունկցիաների վերաբերյալ?\n    A. Ֆունկցիայի ֆորմալ պարամետրերը տեղական փոփոխականներ են:\n    B. Տեղական փոփոխականները հատկացվում են տարածքում:\n    C. Ֆունկցիայի տիպը նույնն է, ինչ վերադարձվող արժեքի տիպը:\n    D. Ֆունկցիան կարող է ինքն իրեն կանչել իր մարմնից:\n\nՀարց 5:\nՈր հայտարարությունն է սխալ ցուցիչների վերաբերյալ?\n    A. Երկու ցուցիչների հանումը հավասար է նրանց հասցեների արժեքների տարբերությանը:\n    B. Ցուցիչի ապահանումը ներառում է լուծում ցուցիչի տիպի հիման վրա:\n    C. int *p[4], p-ն int ցուցիչների զանգված է:\n    D. Ֆունկցիայի անունները կարող են վերագրվել ֆունկցիայի ցուցիչներին:\n\nԴուք պետք է վերադարձնեք միայն նմանատիպ տողեր \"AAAAA\", որոնք ներկայացնում են հարցի ընտրանքները:", "bn": "প্রশ্নগুলির প্রতিটি প্রশ্নের জন্য পছন্দগুলি A, B, C, বা D প্রদান করে একটি সিরিজ প্রশ্নের উত্তর দিন।\n\nপ্রশ্ন ১:\n1e6 এর মত ধ্রুবক কোন ডেটা টাইপের অন্তর্গত?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nপ্রশ্ন ২:\n21! = 51,090,942,171,709,440,000 দেওয়া হলে, কোন ডেটা টাইপ এই মান সংরক্ষণ করতে ব্যবহার করা যেতে পারে?\n    A. int\n    B. long long\n    C. double\n    D. উপরোক্ত কোনোটিই নয়\n\nপ্রশ্ন ৩:\nএক্সপ্রেশনগুলিতে বাম মান সম্পর্কে কোন বিবৃতিটি ভুল?\n    A. ভেরিয়েবল নাম এক্সপ্রেশনগুলি বাম মান।\n    B. ইনক্রিমেন্ট অপারেশনটির জন্য অপারেন্ডটি একটি বাম মান হতে হবে।\n    C. পয়েন্টার ডেরেফারেন্স এক্সপ্রেশনগুলি বাম মান।\n    D. প্রিফিক্স ইনক্রিমেন্ট অপারেশন এক্সপ্রেশনগুলি বাম মান।\n\nপ্রশ্ন ৪:\nফাংশন সম্পর্কে কোন বিবৃতিটি ভুল?\n    A. একটি ফাংশনের আনুষ্ঠানিক প্যারামিটারগুলি স্থানীয় ভেরিয়েবল।\n    B. স্থানীয় ভেরিয়েবলগুলি স্ট্যাকে স্থান বরাদ্দ করা হয়।\n    C. ফাংশন টাইপটি রিটার্ন মানের টাইপের সমান।\n    D. একটি ফাংশন তার দেহের ভিতর থেকে নিজেকে কল করতে পারে।\n\nপ্রশ্ন ৫:\nপয়েন্টার সম্পর্কে কোন বিবৃতিটি ভুল?\n    A. দুটি পয়েন্টার বিয়োগ করলে তাদের ঠিকানা মানের পার্থক্য সমান হয়।\n    B. পয়েন্টার ডেরেফারেন্স পয়েন্টারের টাইপের উপর ভিত্তি করে সমাধান করা হয়।\n    C. int *p[4], p একটি int পয়েন্টারের অ্যারে।\n    D. ফাংশন নামগুলি ফাংশন পয়েন্টারগুলিতে বরাদ্দ করা যেতে পারে।\n\nআপনাকে শুধুমাত্র \"AAAAA\" এর মত স্ট্রিংগুলি ফেরত দিতে হবে, যা প্রশ্নের পছন্দগুলির জন্য দাঁড়ায়।", "bg": "Отговорете на серия от въпроси, като предоставите избори A, B, C или D за всеки въпрос.\n\nВъпрос 1:\nКонстанти като 1e6 принадлежат към кой тип данни?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nВъпрос 2:\nДадено е 21! = 51,090,942,171,709,440,000, кой тип данни може да се използва за съхранение на тази стойност?\n    A. int\n    B. long long\n    C. double\n    D. Нито едно от горните\n\nВъпрос 3:\nКое твърдение за левите стойности в изразите е неправилно?\n    A. Изразите с имена на променливи са леви стойности.\n    B. Операцията за инкрементиране изисква операндът да бъде лява стойност.\n    C. Изразите за разименуване на указатели са леви стойности.\n    D. Изразите за префиксно инкрементиране са леви стойности.\n\nВъпрос 4:\nКое твърдение за функциите е неправилно?\n    A. Формалните параметри на функцията са локални променливи.\n    B. Локалните променливи са разпределени в стека.\n    C. Типът на функцията е същият като типа на връщаната стойност.\n    D. Функцията може да извика сама себе си в тялото си.\n\nВъпрос 5:\nКое твърдение за указателите е неправилно?\n    A. Изваждането на два указателя е равно на разликата в техните адресни стойности.\n    B. Разименуването на указател включва разрешаване на базата на типа на указателя.\n    C. int *p[4], p е масив от указатели към int.\n    D. Имената на функциите могат да бъдат присвоени на указатели към функции.\n\nТрябва да върнете само низове, подобни на \"AAAAA\", които представляват изборите на въпроса.", "zh": "回答一系列问题，为每个问题提供选择A、B、C或D。\n\n问题1：\n像1e6这样的常量属于哪种数据类型？\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\n问题2：\n给定21! = 51,090,942,171,709,440,000，哪种数据类型可以用来存储这个值？\n    A. int\n    B. long long\n    C. double\n    D. 以上都不是\n\n问题3：\n关于表达式中的左值，哪个说法是不正确的？\n    A. 变量名表达式是左值。\n    B. 增量操作要求操作数是左值。\n    C. 指针解引用表达式是左值。\n    D. 前缀增量操作表达式是左值。\n\n问题4：\n关于函数，哪个说法是不正确的？\n    A. 函数的形式参数是局部变量。\n    B. 局部变量在栈中分配空间。\n    C. 函数类型与返回值类型相同。\n    D. 函数可以在其主体内调用自身。\n\n问题5：\n关于指针，哪个说法是不正确的？\n    A. 两个指针相减等于它们地址值的差。\n    B. 指针解引用涉及根据指针的类型进行解析。\n    C. int *p[4]，p是一个int指针的数组。\n    D. 函数名可以赋值给函数指针。\n\n你应该只返回类似于\"AAAAA\"的字符串，代表问题的选择。", "fr": "Répondez à une série de questions en fournissant les choix A, B, C ou D pour chaque question.\n\nQuestion 1 :\nLes constantes comme 1e6 appartiennent à quel type de données ?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nQuestion 2 :\nÉtant donné 21! = 51,090,942,171,709,440,000, quel type de données peut être utilisé pour stocker cette valeur ?\n    A. int\n    B. long long\n    C. double\n    D. Aucun des précédents\n\nQuestion 3 :\nQuelle affirmation concernant les valeurs à gauche dans les expressions est incorrecte ?\n    A. Les expressions de noms de variables sont des valeurs à gauche.\n    B. L'opération d'incrément nécessite que l'opérande soit une valeur à gauche.\n    C. Les expressions de déréférencement de pointeur sont des valeurs à gauche.\n    D. Les expressions d'opération d'incrémentation préfixée sont des valeurs à gauche.\n\nQuestion 4 :\nQuelle affirmation concernant les fonctions est incorrecte ?\n    A. Les paramètres formels d'une fonction sont des variables locales.\n    B. Les variables locales sont allouées dans la pile.\n    C. Le type de la fonction est le même que le type de la valeur de retour.\n    D. Une fonction peut s'appeler elle-même depuis son corps.\n\nQuestion 5 :\nQuelle affirmation concernant les pointeurs est incorrecte ?\n    A. Soustraire deux pointeurs équivaut à la différence de leurs valeurs d'adresse.\n    B. Le déréférencement de pointeur implique une résolution basée sur le type du pointeur.\n    C. int *p[4], p est un tableau de pointeurs int.\n    D. Les noms de fonctions peuvent être assignés à des pointeurs de fonction.\n\nVous êtes censé ne retourner que des chaînes similaires à \"AAAAA\", qui représentent les choix de la question.", "de": "Beantworte eine Reihe von Fragen, indem du für jede Frage die Auswahlmöglichkeiten A, B, C oder D angibst.\n\nFrage 1:\nKonstanten wie 1e6 gehören zu welchem Datentyp?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nFrage 2:\nAngenommen, 21! = 51,090,942,171,709,440,000, welcher Datentyp kann verwendet werden, um diesen Wert zu speichern?\n    A. int\n    B. long long\n    C. double\n    D. Keine der oben genannten\n\nFrage 3:\nWelche Aussage über linke Werte in Ausdrücken ist falsch?\n    A. Variablennamen-Ausdrücke sind linke Werte.\n    B. Die Inkrementoperation erfordert, dass der Operand ein linker Wert ist.\n    C. Zeiger-Dereferenzierungs-Ausdrücke sind linke Werte.\n    D. Präfix-Inkrement-Operationen-Ausdrücke sind linke Werte.\n\nFrage 4:\nWelche Aussage über Funktionen ist falsch?\n    A. Formale Parameter einer Funktion sind lokale Variablen.\n    B. Lokale Variablen werden im Stapel Speicherplatz zugewiesen.\n    C. Der Funktionstyp ist derselbe wie der Rückgabewerttyp.\n    D. Eine Funktion kann sich selbst aus ihrem Körper heraus aufrufen.\n\nFrage 5:\nWelche Aussage über Zeiger ist falsch?\n    A. Das Subtrahieren von zwei Zeigern entspricht der Differenz ihrer Adresswerte.\n    B. Zeiger-Dereferenzierung beinhaltet die Auflösung basierend auf dem Typ des Zeigers.\n    C. int *p[4], p ist ein Array von int-Zeigern.\n    D. Funktionsnamen können Funktionszeigern zugewiesen werden.\n\nDu sollst nur Zeichenfolgen ähnlich wie \"AAAAA\" zurückgeben, die für die Auswahlmöglichkeiten der Frage stehen.", "ha": "Amsa jerin tambayoyi ta hanyar bayar da zaɓuɓɓuka A, B, C, ko D don kowace tambaya.\n\nTambaya ta 1:\nConstant kamar 1e6 na cikin wane nau'in bayanai?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nTambaya ta 2:\nAn ba da 21! = 51,090,942,171,709,440,000, wane nau'in bayanai za a iya amfani da shi don adana wannan ƙima?\n    A. int\n    B. long long\n    C. double\n    D. Babu ɗaya daga cikin waɗanda ke sama\n\nTambaya ta 3:\nWace magana game da ƙimar hagu a cikin magana ba daidai ba ce?\n    A. Maganganun sunayen canji ƙimar hagu ne.\n    B. Aiki na ƙaruwa yana buƙatar operand ya zama ƙimar hagu.\n    C. Maganganun cirewa na pointer ƙimar hagu ne.\n    D. Maganganun aiki na ƙaruwa na prefix ƙimar hagu ne.\n\nTambaya ta 4:\nWace magana game da ayyuka ba daidai ba ce?\n    A. Sigogi na zahiri na aiki canje-canje na gida ne.\n    B. Canje-canje na gida suna samun sarari a cikin stack.\n    C. Nau'in aiki yana daidai da nau'in ƙimar dawowa.\n    D. Aiki na iya kiran kansa daga cikin jikinsa.\n\nTambaya ta 5:\nWace magana game da pointers ba daidai ba ce?\n    A. Rage pointers biyu yana daidai da bambancin a cikin ƙimar adireshinsu.\n    B. Cirewa pointer yana buƙatar warwarewa bisa nau'in pointer.\n    C. int *p[4], p tsari ne na pointers int.\n    D. Ana iya sanya sunayen ayyuka ga pointers ayyuka.\n\nDole ne ka dawo da kirtani kamar \"AAAAA\", wanda ke wakiltar zaɓuɓɓukan tambayar.", "hi": "प्रश्नों की एक श्रृंखला का उत्तर देकर प्रत्येक प्रश्न के लिए विकल्प A, B, C, या D प्रदान करें।\n\nप्रश्न 1:\n1e6 जैसी स्थिरांक किस डेटा प्रकार से संबंधित हैं?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nप्रश्न 2:\nयदि 21! = 51,090,942,171,709,440,000 है, तो इस मान को संग्रहीत करने के लिए किस डेटा प्रकार का उपयोग किया जा सकता है?\n    A. int\n    B. long long\n    C. double\n    D. उपरोक्त में से कोई नहीं\n\nप्रश्न 3:\nअभिव्यक्तियों में बाएँ मानों के बारे में कौन सा कथन गलत है?\n    A. चर नाम अभिव्यक्तियाँ बाएँ मान हैं।\n    B. वृद्धि ऑपरेशन के लिए ऑपरेन्ड का बाएँ मान होना आवश्यक है।\n    C. पॉइंटर डीरिफरेंस अभिव्यक्तियाँ बाएँ मान हैं।\n    D. उपसर्ग वृद्धि ऑपरेशन अभिव्यक्तियाँ बाएँ मान हैं।\n\nप्रश्न 4:\nफंक्शनों के बारे में कौन सा कथन गलत है?\n    A. एक फ़ंक्शन के औपचारिक पैरामीटर स्थानीय चर होते हैं।\n    B. स्थानीय चर स्टैक में स्थान आवंटित करते हैं।\n    C. फ़ंक्शन प्रकार वही है जो रिटर्न मान प्रकार है।\n    D. एक फ़ंक्शन अपने शरीर के भीतर से स्वयं को कॉल कर सकता है।\n\nप्रश्न 5:\nपॉइंटर्स के बारे में कौन सा कथन गलत है?\n    A. दो पॉइंटर्स को घटाने से उनके पते के मूल्यों में अंतर होता है।\n    B. पॉइंटर डीरिफरेंस में पॉइंटर के प्रकार के आधार पर समाधान शामिल होता है।\n    C. int *p[4], p एक int पॉइंटर्स की सरणी है।\n    D. फ़ंक्शन नामों को फ़ंक्शन पॉइंटर्स को सौंपा जा सकता है।\n\nआपको केवल \"AAAAA\" जैसे स्ट्रिंग्स लौटाने हैं, जो प्रश्न के विकल्पों के लिए खड़े होते हैं।", "hu": "Válaszoljon egy sor kérdésre az A, B, C vagy D választási lehetőségek megadásával minden kérdéshez.\n\n1. kérdés:\nAz olyan konstansok, mint az 1e6, melyik adattípushoz tartoznak?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\n2. kérdés:\nAdott a 21! = 51,090,942,171,709,440,000, melyik adattípus használható ennek az értéknek a tárolására?\n    A. int\n    B. long long\n    C. double\n    D. Egyik sem a fentiek közül\n\n3. kérdés:\nMelyik állítás helytelen a balértékekről kifejezésekben?\n    A. A változónév kifejezések balértékek.\n    B. Az inkrementálás művelet megköveteli, hogy az operandus balérték legyen.\n    C. A pointer dereferálás kifejezések balértékek.\n    D. A prefix inkrementálás művelet kifejezések balértékek.\n\n4. kérdés:\nMelyik állítás helytelen a függvényekről?\n    A. Egy függvény formális paraméterei lokális változók.\n    B. A lokális változók helyet kapnak a veremben.\n    C. A függvény típusa megegyezik a visszatérési érték típusával.\n    D. Egy függvény meghívhatja önmagát a saját törzsén belül.\n\n5. kérdés:\nMelyik állítás helytelen a pointerekről?\n    A. Két pointer kivonása egyenlő a címértékeik különbségével.\n    B. A pointer dereferálás a pointer típusának megfelelően történik.\n    C. int *p[4], p egy int pointerek tömbje.\n    D. A függvénynevek hozzárendelhetők függvénypointerekhez.\n\nCsak olyan karakterláncokat kell visszaadnia, mint például \"AAAAA\", amelyek a kérdés választási lehetőségeit jelölik.", "es": "Responde una serie de preguntas proporcionando opciones A, B, C o D para cada pregunta.\n\nPregunta 1:\n¿A qué tipo de dato pertenecen constantes como 1e6?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nPregunta 2:\nDado 21! = 51,090,942,171,709,440,000, ¿qué tipo de dato se puede usar para almacenar este valor?\n    A. int\n    B. long long\n    C. double\n    D. Ninguna de las anteriores\n\nPregunta 3:\n¿Cuál afirmación sobre los valores a la izquierda en las expresiones es incorrecta?\n    A. Las expresiones de nombres de variables son valores a la izquierda.\n    B. La operación de incremento requiere que el operando sea un valor a la izquierda.\n    C. Las expresiones de desreferencia de punteros son valores a la izquierda.\n    D. Las expresiones de operación de incremento prefijo son valores a la izquierda.\n\nPregunta 4:\n¿Cuál afirmación sobre las funciones es incorrecta?\n    A. Los parámetros formales de una función son variables locales.\n    B. Las variables locales se asignan espacio en la pila.\n    C. El tipo de la función es el mismo que el tipo del valor de retorno.\n    D. Una función puede llamarse a sí misma desde dentro de su cuerpo.\n\nPregunta 5:\n¿Cuál afirmación sobre los punteros es incorrecta?\n    A. Restar dos punteros equivale a la diferencia en sus valores de dirección.\n    B. La desreferencia de punteros implica resolver según el tipo del puntero.\n    C. int *p[4], p es un arreglo de punteros a int.\n    D. Los nombres de funciones pueden asignarse a punteros de funciones.\n\nSe supone que solo debes devolver cadenas similares a \"AAAAA\", que representan las opciones de la pregunta.", "arb": "ترجمة سلسلة من الأسئلة عن طريق تقديم الخيارات A، B، C، أو D لكل سؤال.\n\nالسؤال 1:\nالثوابت مثل 1e6 تنتمي إلى أي نوع من البيانات؟\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nالسؤال 2:\nبالنظر إلى 21! = 51,090,942,171,709,440,000، أي نوع من البيانات يمكن استخدامه لتخزين هذه القيمة؟\n    A. int\n    B. long long\n    C. double\n    D. لا شيء مما سبق\n\nالسؤال 3:\nأي عبارة عن القيم اليسارية في التعبيرات غير صحيحة؟\n    A. تعبيرات أسماء المتغيرات هي قيم يسارية.\n    B. عملية الزيادة تتطلب أن يكون المعامل قيمة يسارية.\n    C. تعبيرات إلغاء المؤشر هي قيم يسارية.\n    D. تعبيرات عملية الزيادة السابقة هي قيم يسارية.\n\nالسؤال 4:\nأي عبارة عن الدوال غير صحيحة؟\n    A. المعاملات الشكلية للدالة هي متغيرات محلية.\n    B. يتم تخصيص مساحة للمتغيرات المحلية في المكدس.\n    C. نوع الدالة هو نفسه نوع قيمة الإرجاع.\n    D. يمكن للدالة استدعاء نفسها من داخل جسمها.\n\nالسؤال 5:\nأي عبارة عن المؤشرات غير صحيحة؟\n    A. طرح مؤشرين يساوي الفرق في قيم عناوينهما.\n    B. إلغاء المؤشر يتضمن الحل بناءً على نوع المؤشر.\n    C. int *p[4]، p هو مصفوفة من مؤشرات int.\n    D. يمكن تعيين أسماء الدوال إلى مؤشرات الدوال.\n\nمن المفترض أن تعيد فقط سلاسل مشابهة لـ \"AAAAA\"، والتي تمثل خيارات السؤال.", "sw": "Jibu maswali kadhaa kwa kutoa chaguo A, B, C, au D kwa kila swali.\n\nSwali la 1:\nKonstant kama 1e6 ni ya aina gani ya data?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nSwali la 2:\nKwa kuzingatia 21! = 51,090,942,171,709,440,000, ni aina gani ya data inaweza kutumika kuhifadhi thamani hii?\n    A. int\n    B. long long\n    C. double\n    D. Hakuna kati ya haya\n\nSwali la 3:\nNi kauli gani kuhusu thamani za kushoto katika maelezo ni isiyo sahihi?\n    A. Maelezo ya jina la kigezo ni thamani za kushoto.\n    B. Operesheni ya kuongeza inahitaji operand kuwa thamani ya kushoto.\n    C. Maelezo ya kufuta pointer ni thamani za kushoto.\n    D. Maelezo ya operesheni ya kuongeza awali ni thamani za kushoto.\n\nSwali la 4:\nNi kauli gani kuhusu kazi ni isiyo sahihi?\n    A. Vigezo rasmi vya kazi ni vigezo vya ndani.\n    B. Vigezo vya ndani vinatengewa nafasi kwenye stack.\n    C. Aina ya kazi ni sawa na aina ya thamani ya kurudi.\n    D. Kazi inaweza kujipigia yenyewe kutoka ndani ya mwili wake.\n\nSwali la 5:\nNi kauli gani kuhusu pointers ni isiyo sahihi?\n    A. Kutoa pointers mbili ni sawa na tofauti katika thamani za anwani zao.\n    B. Kufuta pointer kunahusisha kutatua kulingana na aina ya pointer.\n    C. int *p[4], p ni safu ya pointers za int.\n    D. Majina ya kazi yanaweza kupewa pointers za kazi.\n\nUnapaswa kurudisha tu mistari inayofanana na \"AAAAA\", ambayo inasimama kwa chaguo za swali.", "tr": "Bir dizi soruya, her soru için A, B, C veya D seçeneklerini sağlayarak cevap verin.\n\nSoru 1:\n1e6 gibi sabitler hangi veri türüne aittir?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nSoru 2:\n21! = 51,090,942,171,709,440,000 verildiğinde, bu değeri saklamak için hangi veri türü kullanılabilir?\n    A. int\n    B. long long\n    C. double\n    D. Yukarıdakilerin hiçbiri\n\nSoru 3:\nİfadelerdeki sol değerler hakkında hangi ifade yanlıştır?\n    A. Değişken adı ifadeleri sol değerlerdir.\n    B. Artırma işlemi, operandın sol değer olmasını gerektirir.\n    C. Gösterici dereference ifadeleri sol değerlerdir.\n    D. Ön ek artırma işlemi ifadeleri sol değerlerdir.\n\nSoru 4:\nFonksiyonlar hakkında hangi ifade yanlıştır?\n    A. Bir fonksiyonun resmi parametreleri yerel değişkenlerdir.\n    B. Yerel değişkenler yığında yer kaplar.\n    C. Fonksiyon türü, dönüş değeri türü ile aynıdır.\n    D. Bir fonksiyon, gövdesi içinden kendini çağırabilir.\n\nSoru 5:\nGöstericiler hakkında hangi ifade yanlıştır?\n    A. İki göstericinin çıkarılması, adres değerlerindeki farkı eşittir.\n    B. Gösterici dereference, göstericinin türüne göre çözümlemeyi içerir.\n    C. int *p[4], p bir int gösterici dizisidir.\n    D. Fonksiyon isimleri, fonksiyon göstericilerine atanabilir.\n\nSadece soruların seçenekleri olan \"AAAAA\" gibi dizeleri döndürmeniz gerekiyor.", "vi": "Trả lời một loạt câu hỏi bằng cách cung cấp lựa chọn A, B, C hoặc D cho mỗi câu hỏi.\n\nCâu hỏi 1:\nHằng số như 1e6 thuộc kiểu dữ liệu nào?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nCâu hỏi 2:\nCho 21! = 51,090,942,171,709,440,000, kiểu dữ liệu nào có thể được sử dụng để lưu trữ giá trị này?\n    A. int\n    B. long long\n    C. double\n    D. Không có cái nào ở trên\n\nCâu hỏi 3:\nCâu nào về giá trị trái trong biểu thức là không đúng?\n    A. Biểu thức tên biến là giá trị trái.\n    B. Phép toán tăng yêu cầu toán hạng là giá trị trái.\n    C. Biểu thức giải tham chiếu con trỏ là giá trị trái.\n    D. Biểu thức phép toán tăng trước là giá trị trái.\n\nCâu hỏi 4:\nCâu nào về hàm là không đúng?\n    A. Tham số hình thức của hàm là biến cục bộ.\n    B. Biến cục bộ được cấp phát không gian trong ngăn xếp.\n    C. Kiểu của hàm giống với kiểu giá trị trả về.\n    D. Một hàm có thể gọi chính nó từ bên trong thân hàm.\n\nCâu hỏi 5:\nCâu nào về con trỏ là không đúng?\n    A. Trừ hai con trỏ bằng với sự khác biệt trong giá trị địa chỉ của chúng.\n    B. Giải tham chiếu con trỏ liên quan đến việc giải quyết dựa trên kiểu của con trỏ.\n    C. int *p[4], p là một mảng các con trỏ int.\n    D. Tên hàm có thể được gán cho con trỏ hàm.\n\nBạn được yêu cầu chỉ trả về chuỗi tương tự như \"AAAAA\", đại diện cho các lựa chọn của câu hỏi.", "id": "Jawablah serangkaian pertanyaan dengan memberikan pilihan A, B, C, atau D untuk setiap pertanyaan.\n\nPertanyaan 1:\nKonstanta seperti 1e6 termasuk dalam tipe data apa?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nPertanyaan 2:\nDiberikan 21! = 51,090,942,171,709,440,000, tipe data mana yang dapat digunakan untuk menyimpan nilai ini?\n    A. int\n    B. long long\n    C. double\n    D. Tidak ada di atas\n\nPertanyaan 3:\nPernyataan mana tentang nilai kiri dalam ekspresi yang salah?\n    A. Ekspresi nama variabel adalah nilai kiri.\n    B. Operasi peningkatan memerlukan operan menjadi nilai kiri.\n    C. Ekspresi dereferensi pointer adalah nilai kiri.\n    D. Ekspresi operasi peningkatan prefiks adalah nilai kiri.\n\nPertanyaan 4:\nPernyataan mana tentang fungsi yang salah?\n    A. Parameter formal dari sebuah fungsi adalah variabel lokal.\n    B. Variabel lokal dialokasikan ruang di stack.\n    C. Tipe fungsi sama dengan tipe nilai kembalian.\n    D. Sebuah fungsi dapat memanggil dirinya sendiri dari dalam tubuhnya.\n\nPertanyaan 5:\nPernyataan mana tentang pointer yang salah?\n    A. Mengurangi dua pointer sama dengan perbedaan dalam nilai alamat mereka.\n    B. Dereferensi pointer melibatkan penyelesaian berdasarkan tipe pointer.\n    C. int *p[4], p adalah array dari pointer int.\n    D. Nama fungsi dapat ditugaskan ke pointer fungsi.\n\nAnda seharusnya hanya mengembalikan string seperti \"AAAAA\", yang mewakili pilihan dari pertanyaan.", "ja": "一連の質問に対して、各質問に対して選択肢A、B、C、またはDを提供して答えてください。\n\n質問1:\n1e6のような定数はどのデータ型に属しますか？\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\n質問2:\n21! = 51,090,942,171,709,440,000の場合、この値を格納するために使用できるデータ型はどれですか？\n    A. int\n    B. long long\n    C. double\n    D. 上記のいずれでもない\n\n質問3:\n式における左辺値について誤っている記述はどれですか？\n    A. 変数名の式は左辺値である。\n    B. インクリメント操作はオペランドが左辺値であることを要求する。\n    C. ポインタの逆参照式は左辺値である。\n    D. プレフィックスインクリメント操作の式は左辺値である。\n\n質問4:\n関数について誤っている記述はどれですか？\n    A. 関数の形式パラメータはローカル変数である。\n    B. ローカル変数はスタックにスペースが割り当てられる。\n    C. 関数の型は戻り値の型と同じである。\n    D. 関数はその本体内から自分自身を呼び出すことができる。\n\n質問5:\nポインタについて誤っている記述はどれですか？\n    A. 2つのポインタを引くと、そのアドレス値の差になる。\n    B. ポインタの逆参照はポインタの型に基づいて解決される。\n    C. int *p[4]、pはintポインタの配列である。\n    D. 関数名は関数ポインタに代入できる。\n\nあなたは質問の選択肢を表す「AAAAA」のような文字列を返すことになっています。", "ko": "질문에 대한 답변을 각각 A, B, C 또는 D로 제공하십시오.\n\n질문 1:\n1e6과 같은 상수는 어떤 데이터 유형에 속합니까?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\n질문 2:\n21! = 51,090,942,171,709,440,000이 주어졌을 때, 이 값을 저장하는 데 사용할 수 있는 데이터 유형은 무엇입니까?\n    A. int\n    B. long long\n    C. double\n    D. 위의 것들 중 아무것도 아님\n\n질문 3:\n표현식의 왼쪽 값에 대한 설명 중 틀린 것은 무엇입니까?\n    A. 변수 이름 표현식은 왼쪽 값입니다.\n    B. 증감 연산은 피연산자가 왼쪽 값이어야 합니다.\n    C. 포인터 역참조 표현식은 왼쪽 값입니다.\n    D. 전위 증감 연산 표현식은 왼쪽 값입니다.\n\n질문 4:\n함수에 대한 설명 중 틀린 것은 무엇입니까?\n    A. 함수의 형식 매개변수는 지역 변수입니다.\n    B. 지역 변수는 스택에 공간이 할당됩니다.\n    C. 함수 유형은 반환 값 유형과 동일합니다.\n    D. 함수는 본문 내에서 자신을 호출할 수 있습니다.\n\n질문 5:\n포인터에 대한 설명 중 틀린 것은 무엇입니까?\n    A. 두 포인터를 빼면 주소 값의 차이가 됩니다.\n    B. 포인터 역참조는 포인터의 유형에 따라 해석됩니다.\n    C. int *p[4], p는 int 포인터의 배열입니다.\n    D. 함수 이름은 함수 포인터에 할당할 수 있습니다.\n\n당신은 질문의 선택지를 나타내는 \"AAAAA\"와 같은 문자열만 반환해야 합니다.", "ml": "ചോദ്യങ്ങൾക്ക് A, B, C, അല്ലെങ്കിൽ D എന്നിങ്ങനെ ഓരോ ചോദ്യത്തിനും തിരഞ്ഞെടുപ്പുകൾ നൽകിയുകൊണ്ട് ഉത്തരം നൽകുക.\n\nചോദ്യ 1:\n1e6 പോലുള്ള സ്ഥിരാങ്കങ്ങൾ ഏത് ഡാറ്റാ തരം ആണെന്ന് കാണിക്കുന്നു?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nചോദ്യ 2:\n21! = 51,090,942,171,709,440,000 എന്നത് നൽകിയാൽ, ഈ മൂല്യം സൂക്ഷിക്കാൻ ഏത് ഡാറ്റാ തരം ഉപയോഗിക്കാം?\n    A. int\n    B. long long\n    C. double\n    D. മുകളിൽ പറയുന്നവയൊന്നുമല്ല\n\nചോദ്യ 3:\nവ്യക്തീകരണങ്ങളിലെ ഇടത് മൂല്യങ്ങളെക്കുറിച്ചുള്ള ഏത് പ്രസ്താവന തെറ്റാണ്?\n    A. വ്യത്യാസ നാമ വ്യാകരണങ്ങൾ ഇടത് മൂല്യങ്ങളാണ്.\n    B. വർദ്ധന പ്രവർത്തനത്തിന് ഓപ്പറാൻഡ് ഇടത് മൂല്യമായിരിക്കണം.\n    C. സൂചിക ഡീറഫറൻസ് വ്യാകരണങ്ങൾ ഇടത് മൂല്യങ്ങളാണ്.\n    D. മുൻകൂർ വർദ്ധന പ്രവർത്തന വ്യാകരണങ്ങൾ ഇടത് മൂല്യങ്ങളാണ്.\n\nചോദ്യ 4:\nഫംഗ്ഷനുകളെക്കുറിച്ചുള്ള ഏത് പ്രസ്താവന തെറ്റാണ്?\n    A. ഒരു ഫംഗ്ഷന്റെ ഔപചാരിക പാരാമീറ്ററുകൾ പ്രാദേശിക ചോദ്യങ്ങളാണ്.\n    B. പ്രാദേശിക ചോദ്യങ്ങൾക്ക് സ്റ്റാക്കിൽ സ്ഥലം അനുവദിച്ചിരിക്കുന്നു.\n    C. ഫംഗ്ഷൻ തരം മടക്ക മൂല്യ തരം പോലെയാണ്.\n    D. ഒരു ഫംഗ്ഷൻ അതിന്റെ ശരീരത്തിൽ നിന്ന് തന്നെ വിളിക്കാം.\n\nചോദ്യ 5:\nസൂചികകളെക്കുറിച്ചുള്ള ഏത് പ്രസ്താവന തെറ്റാണ്?\n    A. രണ്ട് സൂചികകൾ കുറയ്ക്കുന്നത് അവരുടെ വിലാസ മൂല്യങ്ങളിൽ വ്യത്യാസം ആണ്.\n    B. സൂചിക ഡീറഫറൻസ് സൂചികയുടെ തരം അടിസ്ഥാനമാക്കി പരിഹരിക്കുന്നു.\n    C. int *p[4], p ഒരു int സൂചികകളുടെ നിരയാണ്.\n    D. ഫംഗ്ഷൻ നാമങ്ങൾ ഫംഗ്ഷൻ സൂചികകൾക്ക് നിയോഗിക്കാം.\n\nനിങ്ങൾ \"AAAAA\" എന്നപോലെ ചോദ്യത്തിന്റെ തിരഞ്ഞെടുപ്പുകൾക്കായി നിൽക്കുന്ന സ്ട്രിംഗുകൾ മാത്രം മടക്കേണ്ടതാണ്.", "fa": "پاسخ به یک سری سوال با ارائه گزینه‌های A، B، C یا D برای هر سوال.\n\nسوال 1:\nثابت‌هایی مانند 1e6 به کدام نوع داده تعلق دارند؟\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nسوال 2:\nبا توجه به 21! = 51,090,942,171,709,440,000، کدام نوع داده می‌تواند این مقدار را ذخیره کند؟\n    A. int\n    B. long long\n    C. double\n    D. هیچ‌کدام از موارد بالا\n\nسوال 3:\nکدام عبارت درباره مقادیر چپ در عبارات نادرست است؟\n    A. عبارات نام متغیر مقادیر چپ هستند.\n    B. عملیات افزایش نیازمند این است که عملوند یک مقدار چپ باشد.\n    C. عبارات اشاره‌گر به مقادیر چپ هستند.\n    D. عبارات عملیات افزایش پیشوندی مقادیر چپ هستند.\n\nسوال 4:\nکدام عبارت درباره توابع نادرست است؟\n    A. پارامترهای رسمی یک تابع متغیرهای محلی هستند.\n    B. متغیرهای محلی در پشته فضا تخصیص می‌دهند.\n    C. نوع تابع همان نوع مقدار بازگشتی است.\n    D. یک تابع می‌تواند خود را از درون بدنه‌اش فراخوانی کند.\n\nسوال 5:\nکدام عبارت درباره اشاره‌گرها نادرست است؟\n    A. تفریق دو اشاره‌گر برابر با تفاوت در مقادیر آدرس آنها است.\n    B. اشاره‌گر به نوع اشاره‌گر برای حل نیاز دارد.\n    C. int *p[4]، p یک آرایه از اشاره‌گرهای int است.\n    D. نام توابع می‌تواند به اشاره‌گرهای تابع اختصاص یابد.\n\nشما باید فقط رشته‌هایی مشابه \"AAAAA\" را که نشان‌دهنده انتخاب‌های سوال هستند، برگردانید."}}
{"task_id": "CPP/21", "prompt": {"en": "#include <cassert>\n#include <cmath>\n#include <vector>\n/**\n * Determines if it is possible to assemble the wooden squares from n buckets\n * into a single larger square, where each bucket contains squares with a side length of 1.\n * \n * Input: vector of numbers\n * Example:\n *    >>> f_21({9})\n *    true\n * \n * @param squares Vector containing the count of squares in each bucket.\n * @return True if it is possible to form a larger square, False otherwise.\n */\nbool f_21(std::vector<int> squares)", "sq": "#include <cassert>\n#include <cmath>\n#include <vector>\n/**\n * Përcakton nëse është e mundur të montohet sheshi prej druri nga n kovë\n * në një shesh më të madh, ku secila kovë përmban katrorë me një gjatësi anësore prej 1.\n * \n * Hyrja: vektor numrash\n * Shembull:\n *    >>> f_21({9})\n *    true\n * \n * @param squares Vektor që përmban numrin e katrorëve në secilën kovë.\n * @return True nëse është e mundur të formohet një shesh më i madh, False përndryshe.\n */\nbool f_21(std::vector<int> squares)", "hy": "#include <cassert>\n#include <cmath>\n#include <vector>\n/**\n * Որոշում է՝ արդյոք հնարավոր է n դույլերից փայտե քառակուսիներ հավաքել մեկ մեծ քառակուսի մեջ,\n * որտեղ յուրաքանչյուր դույլ պարունակում է կողքի երկարությամբ 1 քառակուսիներ:\n * \n * Մուտք: թվերի վեկտոր\n * Օրինակ:\n *    >>> f_21({9})\n *    true\n * \n * @param squares Վեկտոր, որը պարունակում է յուրաքանչյուր դույլում քառակուսիների քանակը:\n * @return true եթե հնարավոր է ձևավորել մեծ քառակուսի, false հակառակ դեպքում:\n */\nbool f_21(std::vector<int> squares)", "bn": "#include <cassert>\n#include <cmath>\n#include <vector>\n/**\n * নির্ধারণ করে যে n বালতি থেকে কাঠের বর্গক্ষেত্রগুলি একটি বড় বর্গক্ষেত্রে সংযুক্ত করা সম্ভব কিনা,\n * যেখানে প্রতিটি বালতিতে 1 পার্শ্ব দৈর্ঘ্যের বর্গক্ষেত্র থাকে।\n * \n * ইনপুট: সংখ্যার ভেক্টর\n * উদাহরণ:\n *    >>> f_21({9})\n *    true\n * \n * @param squares প্রতিটি বালতিতে থাকা বর্গক্ষেত্রের সংখ্যা ধারণকারী ভেক্টর।\n * @return যদি একটি বড় বর্গক্ষেত্র তৈরি করা সম্ভব হয় তবে True, অন্যথায় False।\n */\nbool f_21(std::vector<int> squares)", "bg": "#include <cassert>\n#include <cmath>\n#include <vector>\n/**\n * Определя дали е възможно да се сглобят дървените квадрати от n кофи\n * в един по-голям квадрат, където всяка кофа съдържа квадрати със страна с дължина 1.\n * \n * Вход: вектор от числа\n * Пример:\n *    >>> f_21({9})\n *    true\n * \n * @param squares Вектор, съдържащ броя на квадратите във всяка кофа.\n * @return Връща True, ако е възможно да се образува по-голям квадрат, False в противен случай.\n */\nbool f_21(std::vector<int> squares)", "zh": "#include <cassert>\n#include <cmath>\n#include <vector>\n/**\n * 确定是否可以将 n 个桶中的木方块组装成一个更大的正方形，其中每个桶包含边长为 1 的正方形。\n * \n * 输入: 数字向量\n * 例子:\n *    >>> f_21({9})\n *    true\n * \n * @param squares 包含每个桶中正方形数量的向量。\n * @return 如果可以形成更大的正方形则返回 True，否则返回 False。\n */\nbool f_21(std::vector<int> squares)", "fr": "#include <cassert>\n#include <cmath>\n#include <vector>\n/**\n * Détermine s'il est possible d'assembler les carrés en bois provenant de n seaux\n * en un seul carré plus grand, où chaque seau contient des carrés avec une longueur de côté de 1.\n * \n * Entrée : vecteur de nombres\n * Exemple :\n *    >>> f_21({9})\n *    true\n * \n * @param squares Vecteur contenant le nombre de carrés dans chaque seau.\n * @return True s'il est possible de former un carré plus grand, False sinon.\n */\nbool f_21(std::vector<int> squares)", "de": "#include <cassert>\n#include <cmath>\n#include <vector>\n/**\n * Bestimmt, ob es möglich ist, die Holzquadrate aus n Eimern\n * zu einem einzigen größeren Quadrat zusammenzusetzen, wobei jeder Eimer Quadrate mit einer Seitenlänge von 1 enthält.\n * \n * Eingabe: Vektor von Zahlen\n * Beispiel:\n *    >>> f_21({9})\n *    true\n * \n * @param squares Vektor, der die Anzahl der Quadrate in jedem Eimer enthält.\n * @return True, wenn es möglich ist, ein größeres Quadrat zu bilden, False andernfalls.\n */\nbool f_21(std::vector<int> squares)", "ha": "#include <cassert>\n#include <cmath>\n#include <vector>\n/**\n * Yana tantancewa idan yana yiwuwa a tara murabba'ai na katako daga guga n\n * cikin murabba'i guda mafi girma, inda kowanne guga yana dauke da murabba'ai tare da tsawon gefe na 1.\n * \n * Shigarwa: vector na lambobi\n * Misali:\n *    >>> f_21({9})\n *    true\n * \n * @param squares Vector wanda ke dauke da adadin murabba'ai a kowanne guga.\n * @return True idan yana yiwuwa a samar da murabba'i mafi girma, False idan ba haka ba.\n */\nbool f_21(std::vector<int> squares)", "hi": "#include <cassert>\n#include <cmath>\n#include <vector>\n/**\n * यह निर्धारित करता है कि क्या n बाल्टियों से लकड़ी के वर्गों को एक बड़े वर्ग में इकट्ठा करना संभव है,\n * जहाँ प्रत्येक बाल्टी में 1 की भुजा लंबाई वाले वर्ग होते हैं।\n * \n * इनपुट: संख्याओं का वेक्टर\n * उदाहरण:\n *    >>> f_21({9})\n *    true\n * \n * @param squares प्रत्येक बाल्टी में वर्गों की संख्या वाला वेक्टर।\n * @return यदि एक बड़ा वर्ग बनाना संभव है तो True, अन्यथा False।\n */\nbool f_21(std::vector<int> squares)", "hu": "#include <cassert>\n#include <cmath>\n#include <vector>\n/**\n * Meghatározza, hogy lehetséges-e a fa négyzeteket n vödörből egyetlen nagyobb négyzetté összeállítani,\n * ahol minden vödör 1 oldalhosszúságú négyzeteket tartalmaz.\n * \n * Bemenet: számok vektora\n * Példa:\n *    >>> f_21({9})\n *    true\n * \n * @param squares Vektor, amely tartalmazza az egyes vödrökben lévő négyzetek számát.\n * @return Igaz, ha lehetséges egy nagyobb négyzetet kialakítani, hamis különben.\n */\nbool f_21(std::vector<int> squares)", "es": "#include <cassert>\n#include <cmath>\n#include <vector>\n/**\n * Determina si es posible ensamblar los cuadrados de madera de n cubos\n * en un solo cuadrado más grande, donde cada cubo contiene cuadrados con un lado de longitud 1.\n * \n * Entrada: vector de números\n * Ejemplo:\n *    >>> f_21({9})\n *    true\n * \n * @param squares Vector que contiene la cantidad de cuadrados en cada cubo.\n * @return True si es posible formar un cuadrado más grande, False en caso contrario.\n */\nbool f_21(std::vector<int> squares)", "arb": "#include <cassert>\n#include <cmath>\n#include <vector>\n/**\n * يحدد ما إذا كان من الممكن تجميع المربعات الخشبية من n دلاء\n * في مربع أكبر واحد، حيث يحتوي كل دلو على مربعات بطول جانب 1.\n * \n * المدخل: متجه من الأرقام\n * مثال:\n *    >>> f_21({9})\n *    true\n * \n * @param squares متجه يحتوي على عدد المربعات في كل دلو.\n * @return صحيح إذا كان من الممكن تشكيل مربع أكبر، خطأ خلاف ذلك.\n */\nbool f_21(std::vector<int> squares)", "sw": "#include <cassert>\n#include <cmath>\n#include <vector>\n/**\n * Huamua ikiwa inawezekana kuunganisha miraba ya mbao kutoka kwenye n ndoo\n * kuwa mraba mmoja mkubwa zaidi, ambapo kila ndoo ina miraba yenye urefu wa upande wa 1.\n * \n * Ingizo: vector ya namba\n * Mfano:\n *    >>> f_21({9})\n *    true\n * \n * @param squares Vector inayoshikilia idadi ya miraba katika kila ndoo.\n * @return True ikiwa inawezekana kuunda mraba mkubwa zaidi, False vinginevyo.\n */\nbool f_21(std::vector<int> squares)", "tr": "#include <cassert>\n#include <cmath>\n#include <vector>\n/**\n * Her bir kovada kenar uzunluğu 1 olan kareler bulunan n kovadan\n * tek bir büyük kare oluşturmanın mümkün olup olmadığını belirler.\n * \n * Girdi: sayıların vektörü\n * Örnek:\n *    >>> f_21({9})\n *    true\n * \n * @param squares Her kovadaki karelerin sayısını içeren vektör.\n * @return Daha büyük bir kare oluşturmak mümkünse True, aksi takdirde False döner.\n */\nbool f_21(std::vector<int> squares)", "vi": "#include <cassert>\n#include <cmath>\n#include <vector>\n/**\n * Xác định xem có thể lắp ráp các hình vuông gỗ từ n thùng\n * thành một hình vuông lớn hơn duy nhất hay không, trong đó mỗi thùng chứa các hình vuông có cạnh dài 1.\n * \n * Đầu vào: vector các số\n * Ví dụ:\n *    >>> f_21({9})\n *    true\n * \n * @param squares Vector chứa số lượng hình vuông trong mỗi thùng.\n * @return True nếu có thể tạo thành một hình vuông lớn hơn, False nếu không.\n */\nbool f_21(std::vector<int> squares)", "id": "#include <cassert>\n#include <cmath>\n#include <vector>\n/**\n * Menentukan apakah mungkin untuk merakit kotak kayu dari n ember\n * menjadi satu kotak yang lebih besar, di mana setiap ember berisi kotak dengan panjang sisi 1.\n * \n * Input: vektor angka\n * Contoh:\n *    >>> f_21({9})\n *    true\n * \n * @param squares Vektor yang berisi jumlah kotak di setiap ember.\n * @return True jika mungkin untuk membentuk kotak yang lebih besar, False jika tidak.\n */\nbool f_21(std::vector<int> squares)", "ja": "#include <cassert>\n#include <cmath>\n#include <vector>\n/**\n * 各バケツに1の辺の長さを持つ正方形が含まれている場合、n個のバケツから木製の正方形を\n * 1つの大きな正方形に組み立てることが可能かどうかを判断します。\n * \n * 入力: 数字のベクトル\n * 例:\n *    >>> f_21({9})\n *    true\n * \n * @param squares 各バケツに含まれる正方形の数を含むベクトル。\n * @return より大きな正方形を形成することが可能な場合はTrue、そうでない場合はFalseを返します。\n */\nbool f_21(std::vector<int> squares)", "ko": "#include <cassert>\n#include <cmath>\n#include <vector>\n/**\n * n개의 양동이에서 나무 정사각형을 하나의 더 큰 정사각형으로 조립할 수 있는지 여부를 결정합니다.\n * 각 양동이에는 한 변의 길이가 1인 정사각형이 들어 있습니다.\n * \n * 입력: 숫자의 벡터\n * 예시:\n *    >>> f_21({9})\n *    true\n * \n * @param squares 각 양동이에 있는 정사각형의 개수를 포함하는 벡터입니다.\n * @return 더 큰 정사각형을 만들 수 있으면 True, 그렇지 않으면 False를 반환합니다.\n */\nbool f_21(std::vector<int> squares)", "ml": "#include <cassert>\n#include <cmath>\n#include <vector>\n/**\n * n ബക്കറ്റുകളിൽ നിന്ന് മരം ചതുരങ്ങൾ ഒരു വലിയ ചതുരമായി അസംബിൾ ചെയ്യാൻ കഴിയുമോ എന്ന് നിർണ്ണയിക്കുന്നു,\n * ഓരോ ബക്കറ്റിലും 1 നീളമുള്ള ചതുരങ്ങൾ അടങ്ങിയിരിക്കുന്നു.\n * \n * ഇൻപുട്ട്: നംബറുകളുടെ വെക്റ്റർ\n * ഉദാഹരണം:\n *    >>> f_21({9})\n *    true\n * \n * @param squares ഓരോ ബക്കറ്റിലും ഉള്ള ചതുരങ്ങളുടെ എണ്ണം അടങ്ങിയ വെക്റ്റർ.\n * @return വലിയൊരു ചതുരം രൂപീകരിക്കാൻ കഴിയുമെങ്കിൽ True, അല്ലാത്തപക്ഷം False.\n */\nbool f_21(std::vector<int> squares)", "fa": "#include <cassert>\n#include <cmath>\n#include <vector>\n/**\n * تعیین می‌کند که آیا امکان ساخت مربع‌های چوبی از n سطل\n * به یک مربع بزرگتر وجود دارد یا خیر، جایی که هر سطل شامل مربع‌هایی با طول ضلع 1 است.\n * \n * ورودی: بردار اعداد\n * مثال:\n *    >>> f_21({9})\n *    true\n * \n * @param squares برداری که تعداد مربع‌ها در هر سطل را شامل می‌شود.\n * @return True اگر امکان تشکیل یک مربع بزرگتر وجود دارد، False در غیر این صورت.\n */\nbool f_21(std::vector<int> squares)"}, "canonical_solution": "{\n    long long sum = 0;\n    for (int square : squares) {\n        sum += square; // Sum the squares\n    }\n    int root = static_cast<int>(std::sqrt(sum));\n    return root * root == sum; // Check if the sum is a perfect square\n}", "instruction": {"en": "Write a CPP function `bool f_21(std::vector<int> squares)` to solve the following problem:\nDetermines if it is possible to assemble the wooden squares from n buckets\ninto a single larger square, where each bucket contains squares with a side length of 1.\n\nInput: vector of numbers\nExample:\n   >>> f_21({9})\n   true\n\n@param squares Vector containing the count of squares in each bucket.\n@return True if it is possible to form a larger square, False otherwise.\n", "sq": "Shkruani një funksion CPP `bool f_21(std::vector<int> squares)` për të zgjidhur problemin e mëposhtëm:\nPërcakton nëse është e mundur të montohen katrorët prej druri nga n kovë\nnë një katror më të madh, ku secila kovë përmban katrorë me një gjatësi anësore prej 1.\n\nHyrja: vektor numrash\nShembull:\n   >>> f_21({9})\n   true\n\n@param squares Vektor që përmban numrin e katrorëve në secilën kovë.\n@return True nëse është e mundur të formohet një katror më i madh, False përndryshe.", "hy": "Գրեք CPP ֆունկցիա `bool f_21(std::vector<int> squares)` հետևյալ խնդիրը լուծելու համար:\nՈրոշում է, արդյոք հնարավոր է հավաքել փայտե քառակուսիները n դույլերից\nմի մեծ քառակուսի մեջ, որտեղ յուրաքանչյուր դույլ պարունակում է 1 կողմի երկարությամբ քառակուսիներ:\n\nՄուտք: թվերի վեկտոր\nՕրինակ:\n   >>> f_21({9})\n   true\n\n@param squares Վեկտոր, որը պարունակում է յուրաքանչյուր դույլում քառակուսիների քանակը:\n@return True, եթե հնարավոր է ձևավորել ավելի մեծ քառակուսի, False՝ հակառակ դեպքում.", "bn": "একটি CPP ফাংশন `bool f_21(std::vector<int> squares)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nনির্ধারণ করে যে এটি সম্ভব কিনা কাঠের বর্গক্ষেত্রগুলি n বালতি থেকে একটি বড় বর্গক্ষেত্রে একত্রিত করা,\nযেখানে প্রতিটি বালতিতে 1 পার্শ্ব দৈর্ঘ্যের বর্গক্ষেত্র রয়েছে।\n\nইনপুট: সংখ্যার ভেক্টর\nউদাহরণ:\n   >>> f_21({9})\n   true\n\n@param squares প্রতিটি বালতিতে বর্গক্ষেত্রের সংখ্যা ধারণকারী ভেক্টর।\n@return True যদি একটি বড় বর্গক্ষেত্র তৈরি করা সম্ভব হয়, False অন্যথায়।", "bg": "Напишете CPP функция `bool f_21(std::vector<int> squares)`, за да решите следния проблем:\nОпределя дали е възможно да се сглобят дървените квадрати от n кофи в един по-голям квадрат, където всяка кофа съдържа квадрати със страна с дължина 1.\n\nВход: вектор от числа\nПример:\n   >>> f_21({9})\n   true\n\n@param squares Вектор, съдържащ броя на квадратите във всяка кофа.\n@return True, ако е възможно да се образува по-голям квадрат, False в противен случай.", "zh": "编写一个 CPP 函数 `bool f_21(std::vector<int> squares)` 来解决以下问题：\n确定是否可以将 n 个桶中的木块正方形组装成一个更大的正方形，其中每个桶包含边长为 1 的正方形。\n\n输入：数字向量\n示例：\n   >>> f_21({9})\n   true\n\n@param squares 向量，包含每个桶中的正方形数量。\n@return 如果可以形成一个更大的正方形，则返回 True，否则返回 False。", "fr": "Écrire une fonction CPP `bool f_21(std::vector<int> squares)` pour résoudre le problème suivant :\nDétermine s'il est possible d'assembler les carrés en bois de n seaux en un seul carré plus grand, où chaque seau contient des carrés avec une longueur de côté de 1.\n\nEntrée : vecteur de nombres\nExemple :\n   >>> f_21({9})\n   true\n\n@param squares Vecteur contenant le nombre de carrés dans chaque seau.\n@return True s'il est possible de former un carré plus grand, False sinon.", "de": "Schreiben Sie eine CPP-Funktion `bool f_21(std::vector<int> squares)`, um das folgende Problem zu lösen:\nBestimmt, ob es möglich ist, die Holzquadrate aus n Eimern zu einem einzigen größeren Quadrat zusammenzusetzen, wobei jeder Eimer Quadrate mit einer Seitenlänge von 1 enthält.\n\nEingabe: Vektor von Zahlen\nBeispiel:\n   >>> f_21({9})\n   true\n\n@param squares Vektor, der die Anzahl der Quadrate in jedem Eimer enthält.\n@return True, wenn es möglich ist, ein größeres Quadrat zu bilden, False andernfalls.", "ha": "Rubuta aikin CPP `bool f_21(std::vector<int> squares)` don warware matsalar mai zuwa: \n\nYana tantancewa idan zai yiwu a tara katako murabba'i daga kwandunan n cikin murabba'i mafi girma guda ɗaya, inda kowanne kwando ke ɗauke da murabba'i masu tsawon gefe 1.\n\nShigarwa: vector na lambobi\nMisali:\n   >>> f_21({9})\n   true\n\n@param squares Vector mai ɗauke da adadin murabba'i a kowanne kwando.\n@return True idan zai yiwu a samar da murabba'i mafi girma, False in ba haka ba.", "hi": "एक CPP फ़ंक्शन `bool f_21(std::vector<int> squares)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nनिर्धारित करें कि क्या n बाल्टियों से लकड़ी के वर्गों को एक बड़े वर्ग में इकट्ठा करना संभव है, जहाँ प्रत्येक बाल्टी में 1 की साइड लंबाई वाले वर्ग होते हैं।\n\nइनपुट: संख्याओं का वेक्टर\nउदाहरण:\n   >>> f_21({9})\n   true\n\n@param squares प्रत्येक बाल्टी में वर्गों की गिनती वाला वेक्टर।\n@return यदि एक बड़ा वर्ग बनाना संभव है तो True, अन्यथा False।", "hu": "Írj egy CPP függvényt `bool f_21(std::vector<int> squares)` a következő probléma megoldására:\nMegállapítja, hogy lehetséges-e a fa négyzeteket n vödörből egyetlen nagyobb négyzetté összeállítani, ahol minden vödör 1 oldalhosszúságú négyzeteket tartalmaz.\n\nBemenet: számokat tartalmazó vektor\nPélda:\n   >>> f_21({9})\n   true\n\n@param squares Vektor, amely minden vödörben található négyzetek számát tartalmazza.\n@return Igaz, ha lehetséges egy nagyobb négyzetet kialakítani, különben hamis.", "es": "Escribe una función CPP `bool f_21(std::vector<int> squares)` para resolver el siguiente problema:\nDetermina si es posible ensamblar los cuadrados de madera de n cubetas\nen un solo cuadrado más grande, donde cada cubeta contiene cuadrados con un lado de longitud 1.\n\nEntrada: vector de números\nEjemplo:\n   >>> f_21({9})\n   true\n\n@param squares Vector que contiene la cantidad de cuadrados en cada cubeta.\n@return True si es posible formar un cuadrado más grande, False en caso contrario.", "arb": "اكتب دالة CPP `bool f_21(std::vector<int> squares)` لحل المشكلة التالية:\nتحديد ما إذا كان من الممكن تجميع المربعات الخشبية من n دلاء\nفي مربع أكبر واحد، حيث يحتوي كل دلو على مربعات بطول ضلع 1.\n\nمدخل: متجه من الأرقام\nمثال:\n   >>> f_21({9})\n   true\n\n@param squares متجه يحتوي على عدد المربعات في كل دلو.\n@return True إذا كان من الممكن تشكيل مربع أكبر، False خلاف ذلك.", "sw": "Andika kazi ya CPP `bool f_21(std::vector<int> squares)` kutatua tatizo lifuatalo:\nInabainisha kama inawezekana kuunganisha miraba ya mbao kutoka kwenye ndoo n\nkuwa mraba mmoja mkubwa zaidi, ambapo kila ndoo ina miraba yenye urefu wa upande wa 1.\n\nIngizo: vector ya namba\nMfano:\n   >>> f_21({9})\n   true\n\n@param squares Vector inayojumuisha idadi ya miraba katika kila ndoo.\n@return True ikiwa inawezekana kuunda mraba mkubwa zaidi, False vinginevyo.", "tr": "Bir CPP fonksiyonu `bool f_21(std::vector<int> squares)` yazın ve aşağıdaki problemi çözün:\nAhşap kareleri n kovasından tek bir büyük kareye monte etmenin mümkün olup olmadığını belirler,\nburada her kova 1 birim kenar uzunluğuna sahip kareler içerir.\n\nGirdi: sayıların vektörü\nÖrnek:\n   >>> f_21({9})\n   true\n\n@param squares Her kovadaki karelerin sayısını içeren vektör.\n@return Daha büyük bir kare oluşturmak mümkünse True, aksi takdirde False.", "vi": "Viết một hàm CPP `bool f_21(std::vector<int> squares)` để giải quyết vấn đề sau:  \nXác định xem có thể lắp ráp các hình vuông gỗ từ n xô thành một hình vuông lớn hơn, trong đó mỗi xô chứa các hình vuông có độ dài cạnh là 1.\n\nĐầu vào: vector của các số  \nVí dụ:  \n   >>> f_21({9})  \n   true\n\n@param squares Vector chứa số lượng hình vuông trong mỗi xô.  \n@return True nếu có thể tạo thành một hình vuông lớn hơn, False nếu không.", "id": "Tulis fungsi CPP `bool f_21(std::vector<int> squares)` untuk menyelesaikan masalah berikut:\nMenentukan apakah mungkin untuk merakit kotak kayu dari n ember\nmenjadi satu kotak yang lebih besar, di mana setiap ember berisi kotak dengan panjang sisi 1.\n\nInput: vektor angka\nContoh:\n   >>> f_21({9})\n   true\n\n@param squares Vektor yang berisi jumlah kotak di setiap ember.\n@return True jika mungkin untuk membentuk kotak yang lebih besar, False jika tidak.", "ja": "以下の問題を解決するために、CPP関数 `bool f_21(std::vector<int> squares)` を作成してください:\nn個のバケツから木製の正方形を1つの大きな正方形に組み立てることが可能かどうかを判断します。各バケツには、1の辺の長さを持つ正方形が含まれています。\n\n入力: 数字のベクター\n例:\n   >>> f_21({9})\n   true\n\n@param squares 各バケツに含まれる正方形の数を含むベクター。\n@return 大きな正方形を形成することが可能な場合はTrue、そうでない場合はFalseを返します。", "ko": "다음 문제를 해결하기 위해 CPP 함수를 작성하십시오 `bool f_21(std::vector<int> squares)`:\nn개의 양동이에서 나무 정사각형을 단일 더 큰 정사각형으로 조립할 수 있는지 여부를 결정합니다. 여기서 각 양동이는 한 변의 길이가 1인 정사각형을 포함합니다.\n\n입력: 숫자의 벡터\n예:\n   >>> f_21({9})\n   true\n\n@param squares 각 양동이에 있는 정사각형의 개수를 포함하는 벡터.\n@return 더 큰 정사각형을 형성할 수 있으면 True, 그렇지 않으면 False.", "ml": "`bool f_21(std::vector<int> squares)` എന്ന CPP ഫംഗ്ഷൻ എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nn ബക്കറ്റുകളിൽ നിന്ന് മരം കൊണ്ട് നിർമ്മിച്ച ചതുരങ്ങൾ ഒരു വലിയ ചതുരമായി കൂട്ടിച്ചേർക്കാൻ സാധ്യമാണോ എന്ന് നിർണ്ണയിക്കുന്നു, ഓരോ ബക്കറ്റിലും 1 നീളമുള്ള വശങ്ങളുള്ള ചതുരങ്ങൾ അടങ്ങിയിരിക്കുന്നു.\n\nഇൻപുട്ട്: സംഖ്യകളുടെ വെക്ടർ\nഉദാഹരണം:\n   >>> f_21({9})\n   true\n\n@param squares ഓരോ ബക്കറ്റിലും ചതുരങ്ങളുടെ എണ്ണം അടങ്ങിയ വെക്ടർ.\n@return ഒരു വലിയ ചതുരം രൂപീകരിക്കാൻ സാധ്യമെങ്കിൽ True, അല്ലെങ്കിൽ False.", "fa": "یک تابع CPP به نام `bool f_21(std::vector<int> squares)` بنویسید تا مسئله زیر را حل کند:\nتعیین می‌کند که آیا ممکن است مربع‌های چوبی را از n سطل به یک مربع بزرگ‌تر مونتاژ کرد، جایی که هر سطل شامل مربع‌هایی با طول ضلع 1 است.\n\nورودی: وکتور اعداد\nمثال:\n   >>> f_21({9})\n   true\n\n@param squares وکتوری که تعداد مربع‌ها در هر سطل را شامل می‌شود.\n@return True اگر امکان تشکیل یک مربع بزرگ‌تر وجود داشته باشد، False در غیر این صورت."}, "level": "easy", "test": "int main() {\n    assert(f_21({9}) == true);\n    assert(f_21({14, 2}) == true);\n    assert(f_21({7, 7}) == false);\n    assert(f_21({1, 2, 3, 4, 5, 6, 7}) == false);\n    assert(f_21({1, 3, 5, 7, 9, 11}) == true);\n    assert(f_21({2, 2, 2, 2}) == false);\n\n    // Additional test cases\n    assert(f_21({4, 5, 6}) == false);\n    assert(f_21({16, 9, 4, 1}) == false);\n    assert(f_21({1, 1, 1, 1, 1}) == false);\n    assert(f_21({25, 25}) == false);\n    assert(f_21({10, 10, 5}) == true);\n\n    // All tests passed\n    return 0;\n}", "entry_point": "f_21", "signature": "bool f_21(std::vector<int> squares)", "docstring": {"en": "Determines if it is possible to assemble the wooden squares from n buckets\ninto a single larger square, where each bucket contains squares with a side length of 1.\n\nInput: vector of numbers\nExample:\n   >>> f_21({9})\n   true\n\n@param squares Vector containing the count of squares in each bucket.\n@return True if it is possible to form a larger square, False otherwise.\n", "sq": "Përcakton nëse është e mundur të montohen katrorët prej druri nga n kovë\nnë një katror më të madh, ku secila kovë përmban katrorë me një gjatësi anësore prej 1.\n\nHyrja: vektor numrash\nShembull:\n   >>> f_21({9})\n   true\n\n@param squares Vektor që përmban numrin e katrorëve në secilën kovë.\n@return True nëse është e mundur të formohet një katror më i madh, False përndryshe.", "hy": "Որոշում է, արդյոք հնարավոր է հավաքել փայտե քառակուսիները n դույլերից մեկ մեծ քառակուսիի մեջ, որտեղ յուրաքանչյուր դույլ պարունակում է կողմի երկարությամբ 1 քառակուսիներ:\n\nՄուտք: թվերի վեկտոր\nՕրինակ:\n   >>> f_21({9})\n   true\n\n@param squares Վեկտոր, որը պարունակում է յուրաքանչյուր դույլի քառակուսիների քանակը:\n@return Ճիշտ է, եթե հնարավոր է ձևավորել մեծ քառակուսի, Հակառակ դեպքում՝ սխալ:", "bn": "বর্ণনা করে এটি সম্ভব কিনা n বালতি থেকে কাঠের বর্গক্ষেত্রগুলি একত্রিত করে একটি বড় বর্গক্ষেত্র তৈরি করা, যেখানে প্রতিটি বালতিতে 1 পার্শ্ব দৈর্ঘ্যের বর্গক্ষেত্র রয়েছে।\n\nইনপুট: সংখ্যার ভেক্টর\nউদাহরণ:\n   >>> f_21({9})\n   true\n\n@param squares প্রতিটি বালতিতে বর্গক্ষেত্রের সংখ্যা ধারণকারী ভেক্টর।\n@return যদি একটি বড় বর্গক্ষেত্র তৈরি করা সম্ভব হয় তবে True, অন্যথায় False।", "bg": "Определя дали е възможно да се сглобят дървените квадрати от n кофи в един по-голям квадрат, където всяка кофа съдържа квадрати със страна с дължина 1.\n\nВход: вектор от числа\nПример:\n   >>> f_21({9})\n   true\n\n@param squares Вектор, съдържащ броя на квадратите във всяка кофа.\n@return True ако е възможно да се формира по-голям квадрат, False в противен случай.", "zh": "确定是否可以将 n 个桶中的木方块组装成一个更大的正方形，其中每个桶包含边长为 1 的正方形。\n\n输入：数字向量\n示例：\n   >>> f_21({9})\n   true\n\n@param squares 向量，包含每个桶中正方形的数量。\n@return 如果可以形成一个更大的正方形，则返回 True，否则返回 False。", "fr": "Détermine s'il est possible d'assembler les carrés en bois à partir de n seaux en un seul carré plus grand, où chaque seau contient des carrés avec une longueur de côté de 1.\n\nEntrée : vecteur de nombres\nExemple :\n   >>> f_21({9})\n   true\n\n@param squares Vecteur contenant le nombre de carrés dans chaque seau.\n@return True s'il est possible de former un carré plus grand, False sinon.", "de": "Bestimmt, ob es möglich ist, die Holzquadrate aus n Eimern zu einem einzigen größeren Quadrat zusammenzusetzen, wobei jeder Eimer Quadrate mit einer Seitenlänge von 1 enthält.\n\nEingabe: Vektor von Zahlen\nBeispiel:\n   >>> f_21({9})\n   true\n\n@param squares Vektor, der die Anzahl der Quadrate in jedem Eimer enthält.\n@return True, wenn es möglich ist, ein größeres Quadrat zu bilden, False andernfalls.", "ha": "Yana tantance ko zai yiwu a tara murabba'ai na katako daga guga n zuwa murabba'i mafi girma guda ɗaya, inda kowanne guga yana dauke da murabba'ai masu tsawon gefe 1.\n\nShigarwa: vector na lambobi\nMisali:\n   >>> f_21({9})\n   true\n\n@param squares Vector mai dauke da adadin murabba'ai a kowanne guga.\n@return True idan zai yiwu a samar da murabba'i mafi girma, False in ba haka ba.", "hi": "यह निर्धारित करता है कि क्या n बाल्टियों से लकड़ी के वर्गों को एक बड़े वर्ग में इकट्ठा करना संभव है, जहाँ प्रत्येक बाल्टी में 1 की भुजा लंबाई वाले वर्ग होते हैं।\n\nइनपुट: संख्याओं का वेक्टर\nउदाहरण:\n   >>> f_21({9})\n   true\n\n@param squares प्रत्येक बाल्टी में वर्गों की गिनती वाला वेक्टर।\n@return यदि एक बड़ा वर्ग बनाना संभव है तो True, अन्यथा False।", "hu": "Meghatározza, hogy lehetséges-e az n vödörből származó fa négyzeteket egyetlen nagyobb négyzetté összeszerelni, ahol minden vödör 1 oldalhosszúságú négyzeteket tartalmaz.\n\nBemenet: számok vektora\nPélda:\n   >>> f_21({9})\n   true\n\n@param squares Vektor, amely tartalmazza az egyes vödrökben lévő négyzetek számát.\n@return True, ha lehetséges egy nagyobb négyzetet kialakítani, különben False.", "es": "Determina si es posible ensamblar los cuadrados de madera de n cubetas en un solo cuadrado más grande, donde cada cubeta contiene cuadrados con un lado de longitud 1.\n\nEntrada: vector de números\nEjemplo:\n   >>> f_21({9})\n   true\n\n@param squares Vector que contiene la cantidad de cuadrados en cada cubeta.\n@return True si es posible formar un cuadrado más grande, False en caso contrario.", "arb": "يحدد ما إذا كان من الممكن تجميع المربعات الخشبية من n دلاء في مربع أكبر واحد، حيث يحتوي كل دلو على مربعات بطول جانب 1.\n\nالمدخلات: متجه من الأرقام\nمثال:\n   >>> f_21({9})\n   true\n\n@param squares متجه يحتوي على عدد المربعات في كل دلو.\n@return صحيح إذا كان من الممكن تشكيل مربع أكبر، خطأ خلاف ذلك.", "sw": "Inabainisha ikiwa inawezekana kuunganisha mraba wa mbao kutoka kwa n ndoo kuwa mraba mmoja mkubwa zaidi, ambapo kila ndoo ina miraba yenye urefu wa upande wa 1.\n\nIngizo: vekta ya namba\nMfano:\n   >>> f_21({9})\n   true\n\n@param squares Vekta inayojumuisha idadi ya miraba katika kila ndoo.\n@return Kweli ikiwa inawezekana kuunda mraba mkubwa zaidi, Si kweli vinginevyo.", "tr": "Bir büyük kare oluşturmak için n kovasından ahşap karelerin bir araya getirilip getirilemeyeceğini belirler, burada her kova kenar uzunluğu 1 olan kareler içerir.\n\nGirdi: sayıların vektörü\nÖrnek:\n   >>> f_21({9})\n   true\n\n@param squares Her kovadaki karelerin sayısını içeren vektör.\n@return Daha büyük bir kare oluşturmak mümkünse True, aksi takdirde False.", "vi": "Xác định xem có thể lắp ráp các hình vuông gỗ từ n thùng thành một hình vuông lớn hơn hay không, trong đó mỗi thùng chứa các hình vuông có độ dài cạnh là 1.\n\nĐầu vào: vector các số\nVí dụ:\n   >>> f_21({9})\n   true\n\n@param squares Vector chứa số lượng hình vuông trong mỗi thùng.\n@return True nếu có thể tạo thành một hình vuông lớn hơn, False nếu không.", "id": "Menentukan apakah mungkin untuk merakit kotak kayu dari n ember menjadi satu kotak yang lebih besar, di mana setiap ember berisi kotak dengan panjang sisi 1.\n\nInput: vektor angka\nContoh:\n   >>> f_21({9})\n   true\n\n@param squares Vektor yang berisi jumlah kotak di setiap ember.\n@return True jika mungkin untuk membentuk kotak yang lebih besar, False jika tidak.", "ja": "木製の正方形を n 個のバケツから単一の大きな正方形に組み立てることが可能かどうかを判断します。各バケツには辺の長さが 1 の正方形が含まれています。\n\n入力: 数字のベクトル\n例:\n   >>> f_21({9})\n   true\n\n@param squares 各バケツに含まれる正方形の数を含むベクトル。\n@return 大きな正方形を形成することが可能であれば True、そうでなければ False。", "ko": "n개의 버킷에서 나무 정사각형을 하나의 더 큰 정사각형으로 조립할 수 있는지 여부를 결정합니다. 각 버킷에는 한 변의 길이가 1인 정사각형이 들어 있습니다.\n\n입력: 숫자 벡터\n예시:\n   >>> f_21({9})\n   true\n\n@param squares 각 버킷에 있는 정사각형의 개수를 포함하는 벡터입니다.\n@return 더 큰 정사각형을 형성할 수 있으면 True, 그렇지 않으면 False를 반환합니다.", "ml": "ബക്കറ്റുകളിൽ നിന്ന് മരം ചതുരങ്ങൾ ഒരു വലിയ ചതുരമായി അസംബിൾ ചെയ്യാൻ കഴിയുമോ എന്ന് നിർണ്ണയിക്കുന്നു,\n\nഉൾക്കൊള്ളൽ: സംഖ്യകളുടെ വെക്റ്റർ\nഉദാഹരണം:\n   >>> f_21({9})\n   true\n\n@param squares ഓരോ ബക്കറ്റിലും ചതുരങ്ങളുടെ എണ്ണം അടങ്ങിയ വെക്റ്റർ.\n@return വലിയൊരു ചതുരം രൂപീകരിക്കാൻ കഴിയുമെങ്കിൽ True, അല്ലെങ്കിൽ False.", "fa": "تعیین می‌کند که آیا امکان مونتاژ مربع‌های چوبی از n سطل به یک مربع بزرگ‌تر وجود دارد یا خیر، به طوری که هر سطل شامل مربع‌هایی با طول ضلع 1 باشد.\n\nورودی: بردار اعداد\nمثال:\n   >>> f_21({9})\n   true\n\n@param squares برداری که تعداد مربع‌ها در هر سطل را شامل می‌شود.\n@return True اگر امکان تشکیل یک مربع بزرگ‌تر وجود داشته باشد، False در غیر این صورت."}}
{"task_id": "CPP/22", "prompt": {"en": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Given integers c and d, where a + b = c and a * b = d, this function\n * finds the possible value of a with the condition a <= b. When multiple \n * pairs (a, b) are possible, it returns the pair with the smallest a.\n * If no valid pair exists, it returns -1.\n *\n * Parameters:\n *  - c (int): The sum of a and b.\n *  - d (int): The product of a and b.\n *\n * Returns:\n *  - int: A possible value of a or -1 if no valid values exist.\n *\n * Examples:\n *  f_22(7, 11) returns -1\n *  f_22(5, 6) returns 2\n */\nint f_22(int c, int d)", "sq": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Duke pasur parasysh numrat e plotë c dhe d, ku a + b = c dhe a * b = d, kjo funksion\n * gjen vlerën e mundshme të a me kushtin a <= b. Kur janë të mundshme disa \n * çifte (a, b), kthen çiftin me a më të vogël.\n * Nëse nuk ekziston asnjë çift i vlefshëm, kthen -1.\n *\n * Parametrat:\n *  - c (int): Shuma e a dhe b.\n *  - d (int): Produkti i a dhe b.\n *\n * Kthen:\n *  - int: Një vlerë e mundshme e a ose -1 nëse nuk ekzistojnë vlera të vlefshme.\n *\n * Shembuj:\n *  f_22(7, 11) kthen -1\n *  f_22(5, 6) kthen 2\n */\nint f_22(int c, int d)", "hy": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Տրված են ամբողջ թվեր c և d, որտեղ a + b = c և a * b = d, այս ֆունկցիան\n * գտնում է a-ի հնարավոր արժեքը պայմանով a <= b: Երբ հնարավոր են բազմաթիվ \n * զույգեր (a, b), այն վերադարձնում է ամենափոքր a ունեցող զույգը:\n * Եթե վավեր զույգ չի գոյություն ունենում, այն վերադարձնում է -1:\n *\n * Պարամետրեր:\n *  - c (int): a և b-ի գումարը:\n *  - d (int): a և b-ի արտադրյալը:\n *\n * Վերադարձնում է:\n *  - int: a-ի հնարավոր արժեք կամ -1, եթե վավեր արժեքներ չեն գոյություն ունենում:\n *\n * Օրինակներ:\n *  f_22(7, 11) վերադարձնում է -1\n *  f_22(5, 6) վերադարձնում է 2\n */\nint f_22(int c, int d)", "bn": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * প্রদত্ত পূর্ণসংখ্যা c এবং d, যেখানে a + b = c এবং a * b = d, এই ফাংশনটি\n * a এর সম্ভাব্য মান খুঁজে বের করে শর্ত a <= b এর সাথে। যখন একাধিক \n * জোড়া (a, b) সম্ভব, এটি সবচেয়ে ছোট a সহ জোড়াটি ফেরত দেয়।\n * যদি কোনো বৈধ জোড়া না থাকে, এটি -1 ফেরত দেয়।\n *\n * প্যারামিটার:\n *  - c (int): a এবং b এর যোগফল।\n *  - d (int): a এবং b এর গুণফল।\n *\n * ফেরত দেয়:\n *  - int: a এর একটি সম্ভাব্য মান অথবা যদি কোনো বৈধ মান না থাকে তবে -1।\n *\n * উদাহরণ:\n *  f_22(7, 11) -1 ফেরত দেয়\n *  f_22(5, 6) 2 ফেরত দেয়\n */\nint f_22(int c, int d)", "bg": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Дадени са цели числа c и d, където a + b = c и a * b = d, тази функция\n * намира възможната стойност на a при условие, че a <= b. Когато са възможни \n * множество двойки (a, b), тя връща двойката с най-малко a.\n * Ако не съществува валидна двойка, връща -1.\n *\n * Параметри:\n *  - c (int): Сумата на a и b.\n *  - d (int): Произведението на a и b.\n *\n * Връща:\n *  - int: Възможна стойност на a или -1, ако не съществуват валидни стойности.\n *\n * Примери:\n *  f_22(7, 11) връща -1\n *  f_22(5, 6) връща 2\n */\nint f_22(int c, int d)", "zh": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * 给定整数 c 和 d，其中 a + b = c 且 a * b = d，此函数\n * 找出满足条件 a <= b 的 a 的可能值。当存在多个\n * (a, b) 对时，返回具有最小 a 的对。\n * 如果不存在有效对，则返回 -1。\n *\n * 参数:\n *  - c (int): a 和 b 的和。\n *  - d (int): a 和 b 的积。\n *\n * 返回:\n *  - int: a 的可能值或如果不存在有效值则返回 -1。\n *\n * 示例:\n *  f_22(7, 11) 返回 -1\n *  f_22(5, 6) 返回 2\n */\nint f_22(int c, int d)", "fr": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Étant donnés les entiers c et d, où a + b = c et a * b = d, cette fonction\n * trouve la valeur possible de a avec la condition a <= b. Lorsqu'il existe \n * plusieurs paires (a, b) possibles, elle retourne la paire avec le plus petit a.\n * Si aucune paire valide n'existe, elle retourne -1.\n *\n * Paramètres:\n *  - c (int): La somme de a et b.\n *  - d (int): Le produit de a et b.\n *\n * Renvoie:\n *  - int: Une valeur possible de a ou -1 si aucune valeur valide n'existe.\n *\n * Exemples:\n *  f_22(7, 11) retourne -1\n *  f_22(5, 6) retourne 2\n */\nint f_22(int c, int d)", "de": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Gegeben sind die ganzen Zahlen c und d, wobei a + b = c und a * b = d, \n * diese Funktion findet den möglichen Wert von a mit der Bedingung a <= b. \n * Wenn mehrere Paare (a, b) möglich sind, gibt sie das Paar mit dem kleinsten a zurück.\n * Wenn kein gültiges Paar existiert, gibt sie -1 zurück.\n *\n * Parameter:\n *  - c (int): Die Summe von a und b.\n *  - d (int): Das Produkt von a und b.\n *\n * Rückgabewerte:\n *  - int: Ein möglicher Wert von a oder -1, wenn keine gültigen Werte existieren.\n *\n * Beispiele:\n *  f_22(7, 11) gibt -1 zurück\n *  f_22(5, 6) gibt 2 zurück\n */\nint f_22(int c, int d)", "ha": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * An ba da lambobin c da d, inda a + b = c kuma a * b = d, wannan aikin\n * yana nemo yiwuwar darajar a tare da yanayin a <= b. Idan akwai ma'aurata \n * (a, b) da dama, yana dawo da ma'auratan da ke da ƙaramar a.\n * Idan babu ma'aurata masu inganci, yana dawo da -1.\n *\n * Sigogi:\n *  - c (int): Jimillar a da b.\n *  - d (int): Samfurin a da b.\n *\n * Yana dawowa:\n *  - int: Yiwuwar darajar a ko -1 idan babu ƙimar da ta dace.\n *\n * Misalai:\n *  f_22(7, 11) returns -1\n *  f_22(5, 6) returns 2\n */\nint f_22(int c, int d)", "hi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * दिए गए पूर्णांक c और d के लिए, जहाँ a + b = c और a * b = d, यह फ़ंक्शन\n * a के संभावित मान को ढूंढता है इस शर्त के साथ कि a <= b। जब कई \n * जोड़े (a, b) संभव होते हैं, तो यह सबसे छोटे a वाले जोड़े को लौटाता है।\n * यदि कोई मान्य जोड़ा मौजूद नहीं है, तो यह -1 लौटाता है।\n *\n * पैरामीटर्स:\n *  - c (int): a और b का योग।\n *  - d (int): a और b का गुणनफल।\n *\n * रिटर्न्स:\n *  - int: a का एक संभावित मान या -1 यदि कोई मान्य मान मौजूद नहीं है।\n *\n * उदाहरण:\n *  f_22(7, 11) returns -1\n *  f_22(5, 6) returns 2\n */\nint f_22(int c, int d)", "hu": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Adott két egész szám, c és d, ahol a + b = c és a * b = d, ez a függvény\n * megtalálja a lehetséges a értéket azzal a feltétellel, hogy a <= b. Ha több\n * (a, b) pár lehetséges, akkor a legkisebb a értékkel rendelkező párt adja vissza.\n * Ha nem létezik érvényes pár, akkor -1-et ad vissza.\n *\n * Paraméterek:\n *  - c (int): Az a és b összege.\n *  - d (int): Az a és b szorzata.\n *\n * Visszatérési érték:\n *  - int: Egy lehetséges a érték vagy -1, ha nem léteznek érvényes értékek.\n *\n * Példák:\n *  f_22(7, 11) visszaadja -1\n *  f_22(5, 6) visszaadja 2\n */\nint f_22(int c, int d)", "es": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Dados los enteros c y d, donde a + b = c y a * b = d, esta función\n * encuentra el valor posible de a con la condición a <= b. Cuando múltiples \n * pares (a, b) son posibles, devuelve el par con el menor a.\n * Si no existe un par válido, devuelve -1.\n *\n * Parámetros:\n *  - c (int): La suma de a y b.\n *  - d (int): El producto de a y b.\n *\n * Devuelve:\n *  - int: Un valor posible de a o -1 si no existen valores válidos.\n *\n * Ejemplos:\n *  f_22(7, 11) returns -1\n *  f_22(5, 6) returns 2\n */\nint f_22(int c, int d)", "arb": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * بالنظر إلى الأعداد الصحيحة c و d، حيث a + b = c و a * b = d، هذه الدالة\n * تجد القيمة الممكنة لـ a بشرط أن a <= b. عندما تكون هناك عدة أزواج (a, b) ممكنة،\n * تُرجع الزوج الذي يحتوي على أصغر قيمة لـ a.\n * إذا لم يوجد زوج صالح، تُرجع -1.\n *\n * المعاملات:\n *  - c (int): مجموع a و b.\n *  - d (int): حاصل ضرب a و b.\n *\n * تُرجع:\n *  - int: قيمة ممكنة لـ a أو -1 إذا لم توجد قيم صالحة.\n *\n * أمثلة:\n *  f_22(7, 11) returns -1\n *  f_22(5, 6) returns 2\n */\nint f_22(int c, int d)", "sw": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Ukipewa nambari kamili c na d, ambapo a + b = c na a * b = d, kazi hii\n * inapata thamani inayowezekana ya a kwa sharti a <= b. Wakati jozi nyingi \n * (a, b) zinawezekana, inarudisha jozi yenye a ndogo zaidi.\n * Ikiwa hakuna jozi halali ipo, inarudisha -1.\n *\n * Vigezo:\n *  - c (int): Jumla ya a na b.\n *  - d (int): Bidhaa ya a na b.\n *\n * Inarudisha:\n *  - int: Thamani inayowezekana ya a au -1 ikiwa hakuna thamani halali ipo.\n *\n * Mifano:\n *  f_22(7, 11) inarudisha -1\n *  f_22(5, 6) inarudisha 2\n */\nint f_22(int c, int d)", "tr": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * a + b = c ve a * b = d olan tamsayılar c ve d verildiğinde, bu fonksiyon\n * a <= b koşuluyla a'nın olası değerini bulur. Birden fazla (a, b) çifti mümkün olduğunda,\n * en küçük a'ya sahip çifti döndürür. Geçerli bir çift yoksa, -1 döndürür.\n *\n * Parametreler:\n *  - c (int): a ve b'nin toplamı.\n *  - d (int): a ve b'nin çarpımı.\n *\n * Döndürür:\n *  - int: a'nın olası bir değeri veya geçerli değer yoksa -1.\n *\n * Örnekler:\n *  f_22(7, 11) -1 döndürür\n *  f_22(5, 6) 2 döndürür\n */\nint f_22(int c, int d)", "vi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Cho các số nguyên c và d, trong đó a + b = c và a * b = d, hàm này\n * tìm giá trị có thể của a với điều kiện a <= b. Khi có nhiều cặp \n * (a, b) có thể, nó trả về cặp với a nhỏ nhất.\n * Nếu không tồn tại cặp hợp lệ, nó trả về -1.\n *\n * Tham số:\n *  - c (int): Tổng của a và b.\n *  - d (int): Tích của a và b.\n *\n * Trả về:\n *  - int: Một giá trị có thể của a hoặc -1 nếu không tồn tại giá trị hợp lệ.\n *\n * Ví dụ:\n *  f_22(7, 11) trả về -1\n *  f_22(5, 6) trả về 2\n */\nint f_22(int c, int d)", "id": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Diberikan bilangan bulat c dan d, di mana a + b = c dan a * b = d, fungsi ini\n * menemukan nilai a yang mungkin dengan kondisi a <= b. Ketika beberapa \n * pasangan (a, b) mungkin, ia mengembalikan pasangan dengan a terkecil.\n * Jika tidak ada pasangan yang valid, ia mengembalikan -1.\n *\n * Parameter:\n *  - c (int): Jumlah dari a dan b.\n *  - d (int): Hasil kali dari a dan b.\n *\n * Mengembalikan:\n *  - int: Nilai a yang mungkin atau -1 jika tidak ada nilai yang valid.\n *\n * Contoh:\n *  f_22(7, 11) mengembalikan -1\n *  f_22(5, 6) mengembalikan 2\n */\nint f_22(int c, int d)", "ja": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * 整数 c と d が与えられたとき、ここで a + b = c および a * b = d である場合、\n * a <= b の条件で可能な a の値を見つける関数です。複数のペア (a, b) が可能な場合、\n * 最小の a を持つペアを返します。有効なペアが存在しない場合は、-1 を返します。\n *\n * パラメータ:\n *  - c (int): a と b の合計。\n *  - d (int): a と b の積。\n *\n * 戻り値:\n *  - int: a の可能な値、または有効な値が存在しない場合は -1。\n *\n * 例:\n *  f_22(7, 11) は -1 を返します\n *  f_22(5, 6) は 2 を返します\n */\nint f_22(int c, int d)", "ko": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * 정수 c와 d가 주어졌을 때, 여기서 a + b = c이고 a * b = d인 경우\n * a <= b 조건을 만족하는 a의 가능한 값을 찾습니다. 여러 쌍 (a, b)이 가능한 경우\n * 가장 작은 a를 가진 쌍을 반환합니다. 유효한 쌍이 없으면 -1을 반환합니다.\n *\n * 매개변수:\n *  - c (int): a와 b의 합.\n *  - d (int): a와 b의 곱.\n *\n * 반환값:\n *  - int: a의 가능한 값 또는 유효한 값이 없을 경우 -1.\n *\n * 예시:\n *  f_22(7, 11) returns -1\n *  f_22(5, 6) returns 2\n */\nint f_22(int c, int d)", "ml": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * നൽകിയിരിക്കുന്ന പൂർണ്ണസംഖ്യകൾ c, d എന്നിവയിൽ, a + b = c കൂടാതെ a * b = d ആയിരിക്കുമ്പോൾ, \n * a <= b എന്ന വ്യവസ്ഥയോടെ a യുടെ സാധ്യമായ മൂല്യം കണ്ടെത്തുന്നു. \n * പല ജോഡികൾ (a, b) സാധ്യമാകുമ്പോൾ, ഏറ്റവും ചെറിയ a ഉള്ള ജോഡി തിരികെ നൽകുന്നു. \n * സാധുവായ ജോഡി ഒന്നും ഇല്ലെങ്കിൽ, -1 തിരികെ നൽകുന്നു.\n *\n * പാരാമീറ്ററുകൾ:\n *  - c (int): a, b എന്നിവയുടെ ആകെ ഫലം.\n *  - d (int): a, b എന്നിവയുടെ ഗുണഫലം.\n *\n * തിരികെ നൽകുന്നത്:\n *  - int: a യുടെ സാധ്യമായ മൂല്യം അല്ലെങ്കിൽ സാധുവായ മൂല്യങ്ങൾ ഇല്ലെങ്കിൽ -1.\n *\n * ഉദാഹരണങ്ങൾ:\n *  f_22(7, 11) -1 തിരികെ നൽകുന്നു\n *  f_22(5, 6) 2 തിരികെ നൽകുന്നു\n */\nint f_22(int c, int d)", "fa": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * اعداد صحیح c و d داده شده‌اند، جایی که a + b = c و a * b = d، این تابع\n * مقدار ممکن a را با شرط a <= b پیدا می‌کند. وقتی چندین جفت (a, b) ممکن است،\n * جفتی را با کوچکترین a برمی‌گرداند.\n * اگر هیچ جفت معتبری وجود نداشته باشد، -1 را برمی‌گرداند.\n *\n * پارامترها:\n *  - c (int): مجموع a و b.\n *  - d (int): حاصل‌ضرب a و b.\n *\n * بازگشت:\n *  - int: یک مقدار ممکن از a یا -1 اگر هیچ مقدار معتبری وجود نداشته باشد.\n *\n * مثال‌ها:\n *  f_22(7, 11) returns -1\n *  f_22(5, 6) returns 2\n */\nint f_22(int c, int d)"}, "canonical_solution": "{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i; // Return the value of a where a <= b and both conditions are satisfied\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}", "instruction": {"en": "Write a CPP function `int f_22(int c, int d)` to solve the following problem:\nGiven integers c and d, where a + b = c and a * b = d, this function\nfinds the possible value of a with the condition a <= b. When multiple\npairs (a, b) are possible, it returns the pair with the smallest a.\nIf no valid pair exists, it returns -1.\n\nParameters:\n- c (int): The sum of a and b.\n- d (int): The product of a and b.\n\nReturns:\n- int: A possible value of a or -1 if no valid values exist.\n\nExamples:\nf_22(7, 11) returns -1\nf_22(5, 6) returns 2\n", "sq": "Shkruani një funksion CPP `int f_22(int c, int d)` për të zgjidhur problemin e mëposhtëm:\nDuke pasur parasysh numrat e plotë c dhe d, ku a + b = c dhe a * b = d, ky funksion\ngjen vlerën e mundshme të a me kushtin a <= b. Kur janë të mundshme disa\nçifte (a, b), ai kthen çiftin me vlerën më të vogël të a.\nNëse nuk ekziston asnjë çift i vlefshëm, ai kthen -1.\n\nParametrat:\n- c (int): Shuma e a dhe b.\n- d (int): Produkti i a dhe b.\n\nKthen:\n- int: Një vlerë e mundshme e a ose -1 nëse nuk ekzistojnë vlera të vlefshme.\n\nShembuj:\nf_22(7, 11) kthen -1\nf_22(5, 6) kthen 2", "hy": "Գրեք CPP ֆունկցիա `int f_22(int c, int d)` հետևյալ խնդիրը լուծելու համար:\nՏրված են ամբողջ թվեր c և d, որտեղ a + b = c և a * b = d, այս ֆունկցիան\nգտնում է a-ի հնարավոր արժեքը պայմանով a <= b: Երբ հնարավոր են բազմաթիվ\nզույգեր (a, b), այն վերադարձնում է զույգը ամենափոքր a-ով:\nԵթե ոչ մի վավեր զույգ չկա, այն վերադարձնում է -1:\n\nՊարամետրեր:\n- c (int): a և b-ի գումարը:\n- d (int): a և b-ի արտադրյալը:\n\nՎերադարձնում է:\n- int: a-ի հնարավոր արժեքը կամ -1, եթե վավեր արժեքներ չկան:\n\nՕրինակներ:\nf_22(7, 11) վերադարձնում է -1\nf_22(5, 6) վերադարձնում է 2", "bn": "একটি CPP ফাংশন `int f_22(int c, int d)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nপ্রদত্ত পূর্ণসংখ্যা c এবং d, যেখানে a + b = c এবং a * b = d, এই ফাংশনটি a এর সম্ভাব্য মান খুঁজে বের করে শর্ত সহ a <= b। যখন একাধিক জোড়া (a, b) সম্ভব, এটি সবচেয়ে ছোট a সহ জোড়াটি ফেরত দেয়। যদি কোনো বৈধ জোড়া না থাকে, এটি -1 ফেরত দেয়।\n\nপ্যারামিটারসমূহ:\n- c (int): a এবং b এর যোগফল।\n- d (int): a এবং b এর গুণফল।\n\nফেরত দেয়:\n- int: a এর একটি সম্ভাব্য মান অথবা যদি কোনো বৈধ মান না থাকে তবে -1।\n\nউদাহরণসমূহ:\nf_22(7, 11) -1 ফেরত দেয়\nf_22(5, 6) 2 ফেরত দেয়", "bg": "Напишете CPP функция `int f_22(int c, int d)` за решаване на следния проблем:  \nДадени са цели числа c и d, където a + b = c и a * b = d, тази функция намира възможната стойност на a с условието a <= b. Когато са възможни няколко двойки (a, b), тя връща двойката с най-малката a. Ако не съществува валидна двойка, тя връща -1.\n\nПараметри:\n- c (int): Сумата на a и b.\n- d (int): Произведението на a и b.\n\nВръща:\n- int: Възможна стойност на a или -1, ако не съществуват валидни стойности.\n\nПримери:\nf_22(7, 11) връща -1  \nf_22(5, 6) връща 2", "zh": "编写一个 CPP 函数 `int f_22(int c, int d)` 来解决以下问题：  \n给定整数 c 和 d，其中 a + b = c 且 a * b = d，此函数找到满足条件 a <= b 的 a 的可能值。当存在多个 (a, b) 对时，返回具有最小 a 的对。如果不存在有效对，则返回 -1。\n\n参数：\n- c (int): a 和 b 的和。\n- d (int): a 和 b 的积。\n\n返回：\n- int: a 的可能值，如果不存在有效值则返回 -1。\n\n示例：\nf_22(7, 11) 返回 -1  \nf_22(5, 6) 返回 2  ", "fr": "Écrire une fonction CPP `int f_22(int c, int d)` pour résoudre le problème suivant :  \nÉtant donnés les entiers c et d, où a + b = c et a * b = d, cette fonction trouve la valeur possible de a avec la condition a <= b. Lorsqu'il existe plusieurs paires (a, b) possibles, elle retourne la paire avec le plus petit a. Si aucune paire valide n'existe, elle retourne -1.\n\nParamètres :\n- c (int) : La somme de a et b.\n- d (int) : Le produit de a et b.\n\nRenvoie :\n- int : Une valeur possible de a ou -1 si aucune valeur valide n'existe.\n\nExemples :\nf_22(7, 11) retourne -1  \nf_22(5, 6) retourne 2  ", "de": "Schreiben Sie eine CPP-Funktion `int f_22(int c, int d)`, um das folgende Problem zu lösen:\nGegeben sind die Ganzzahlen c und d, wobei a + b = c und a * b = d, diese Funktion\nfindet den möglichen Wert von a mit der Bedingung a <= b. Wenn mehrere\nPaare (a, b) möglich sind, gibt sie das Paar mit dem kleinsten a zurück.\nWenn kein gültiges Paar existiert, gibt sie -1 zurück.\n\nParameter:\n- c (int): Die Summe von a und b.\n- d (int): Das Produkt von a und b.\n\nRückgabewert:\n- int: Ein möglicher Wert von a oder -1, wenn keine gültigen Werte existieren.\n\nBeispiele:\nf_22(7, 11) gibt -1 zurück\nf_22(5, 6) gibt 2 zurück", "ha": "Rubuta aikin CPP `int f_22(int c, int d)` don warware matsalar mai zuwa:\nAn ba da lambobi c da d, inda a + b = c da a * b = d, wannan aikin\nyana nemo yiwuwar darajar a tare da yanayin a <= b. Idan akwai\nma'aurata da dama (a, b) masu yiwuwa, yana dawo da ma'aurata tare da ƙaramar a.\nIdan babu wata ma'aurata mai inganci, yana dawo da -1.\n\nSigogi:\n- c (int): Jimillar a da b.\n- d (int): Samfurin a da b.\n\nDawowa:\n- int: Yiwuwar darajar a ko -1 idan babu wasu ƙimar da suka dace.\n\nMisalai:\nf_22(7, 11) yana dawowa -1\nf_22(5, 6) yana dawowa 2", "hi": "`int f_22(int c, int d)` नामक एक CPP फ़ंक्शन लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए पूर्णांक c और d, जहाँ a + b = c और a * b = d, यह फ़ंक्शन a के संभावित मान को उस शर्त के साथ खोजता है कि a <= b। जब कई जोड़े (a, b) संभव होते हैं, तो यह सबसे छोटे a वाले जोड़े को लौटाता है। यदि कोई मान्य जोड़ा मौजूद नहीं है, तो यह -1 लौटाता है।\n\nपैरामीटर्स:\n- c (int): a और b का योग।\n- d (int): a और b का गुणनफल।\n\nवापसी:\n- int: a का एक संभावित मान या -1 यदि कोई मान्य मान मौजूद नहीं है।\n\nउदाहरण:\nf_22(7, 11) -1 लौटाता है\nf_22(5, 6) 2 लौटाता है", "hu": "Írj egy CPP függvényt `int f_22(int c, int d)` a következő probléma megoldására:\nAdottak az egész számok c és d, ahol a + b = c és a * b = d, ez a függvény\nmegtalálja a lehetséges a értéket azzal a feltétellel, hogy a <= b. Ha több\n(a, b) pár lehetséges, akkor a legkisebb a értékű párt adja vissza.\nHa nem létezik érvényes pár, akkor -1-et ad vissza.\n\nParaméterek:\n- c (int): a és b összege.\n- d (int): a és b szorzata.\n\nVisszatérési érték:\n- int: a lehetséges a érték vagy -1, ha nem léteznek érvényes értékek.\n\nPéldák:\nf_22(7, 11) visszaadja -1\nf_22(5, 6) visszaadja 2", "es": "Escribe una función CPP `int f_22(int c, int d)` para resolver el siguiente problema:\nDado los enteros c y d, donde a + b = c y a * b = d, esta función\nencuentra el valor posible de a con la condición a <= b. Cuando múltiples\npares (a, b) son posibles, devuelve el par con el menor a.\nSi no existe un par válido, devuelve -1.\n\nParámetros:\n- c (int): La suma de a y b.\n- d (int): El producto de a y b.\n\nDevuelve:\n- int: Un valor posible de a o -1 si no existen valores válidos.\n\nEjemplos:\nf_22(7, 11) devuelve -1\nf_22(5, 6) devuelve 2", "arb": "اكتب دالة CPP `int f_22(int c, int d)` لحل المشكلة التالية:\nبالنظر إلى الأعداد الصحيحة c و d، حيث a + b = c و a * b = d، تقوم هذه الدالة\nبإيجاد القيمة الممكنة لـ a مع الشرط a <= b. عندما تكون هناك أزواج متعددة (a, b) ممكنة، فإنها تعيد الزوج مع أصغر قيمة لـ a.\nإذا لم يكن هناك زوج صالح، فإنها تعيد -1.\n\nالمعلمات:\n- c (int): مجموع a و b.\n- d (int): حاصل ضرب a و b.\n\nالقيم المعادة:\n- int: قيمة ممكنة لـ a أو -1 إذا لم تكن هناك قيم صالحة.\n\nأمثلة:\nf_22(7, 11) يعيد -1\nf_22(5, 6) يعيد 2", "sw": "Andika kazi ya CPP `int f_22(int c, int d)` kutatua tatizo lifuatalo:\nUkipatiwa namba nzima c na d, ambapo a + b = c na a * b = d, kazi hii\ninapata thamani inayowezekana ya a kwa sharti a <= b. Wakati jozi nyingi (a, b) zinawezekana, inarudisha jozi yenye a ndogo zaidi.\nIkiwa hakuna jozi halali ipo, inarudisha -1.\n\nVigezo:\n- c (int): Jumla ya a na b.\n- d (int): Bidhaa ya a na b.\n\nInarudisha:\n- int: Thamani inayowezekana ya a au -1 ikiwa hakuna thamani halali ipo.\n\nMifano:\nf_22(7, 11) inarudisha -1\nf_22(5, 6) inarudisha 2", "tr": "Bir CPP fonksiyonu `int f_22(int c, int d)` yazın ve aşağıdaki problemi çözün:\nVerilen c ve d tamsayıları için, burada a + b = c ve a * b = d, bu fonksiyon\na'nın olası değerini a <= b koşuluyla bulur. Birden fazla\n(a, b) çifti mümkün olduğunda, en küçük a'ya sahip çifti döndürür.\nEğer geçerli bir çift yoksa, -1 döndürür.\n\nParametreler:\n- c (int): a ve b'nin toplamı.\n- d (int): a ve b'nin çarpımı.\n\nDöndürür:\n- int: a'nın olası bir değeri veya geçerli bir değer yoksa -1.\n\nÖrnekler:\nf_22(7, 11) -1 döndürür\nf_22(5, 6) 2 döndürür", "vi": "Viết một hàm CPP `int f_22(int c, int d)` để giải quyết vấn đề sau:\nCho các số nguyên c và d, nơi a + b = c và a * b = d, hàm này\ntìm giá trị có thể của a với điều kiện a <= b. Khi có nhiều\ncặp (a, b) có thể, nó trả về cặp với a nhỏ nhất.\nNếu không tồn tại cặp hợp lệ, nó trả về -1.\n\nTham số:\n- c (int): Tổng của a và b.\n- d (int): Tích của a và b.\n\nTrả về:\n- int: Một giá trị có thể của a hoặc -1 nếu không tồn tại giá trị hợp lệ.\n\nVí dụ:\nf_22(7, 11) trả về -1\nf_22(5, 6) trả về 2", "id": "Tulis fungsi CPP `int f_22(int c, int d)` untuk menyelesaikan masalah berikut:\nDiberikan bilangan bulat c dan d, di mana a + b = c dan a * b = d, fungsi ini\nmenemukan nilai a yang mungkin dengan kondisi a <= b. Ketika beberapa\npasangan (a, b) memungkinkan, fungsi ini mengembalikan pasangan dengan a terkecil.\nJika tidak ada pasangan yang valid, fungsi ini mengembalikan -1.\n\nParameter:\n- c (int): Jumlah dari a dan b.\n- d (int): Hasil kali dari a dan b.\n\nMengembalikan:\n- int: Nilai a yang mungkin atau -1 jika tidak ada nilai yang valid.\n\nContoh:\nf_22(7, 11) mengembalikan -1\nf_22(5, 6) mengembalikan 2", "ja": "次の問題を解くためのCPP関数 `int f_22(int c, int d)` を作成してください:\n整数 c と d が与えられたとき、a + b = c および a * b = d であるとします。この関数は、条件 a <= b を満たす a の可能な値を見つけます。複数のペア (a, b) が可能な場合、最小の a を持つペアを返します。有効なペアが存在しない場合は、-1 を返します。\n\nパラメータ:\n- c (int): a と b の合計。\n- d (int): a と b の積。\n\n戻り値:\n- int: a の可能な値、または有効な値が存在しない場合は -1。\n\n例:\nf_22(7, 11) は -1 を返します\nf_22(5, 6) は 2 を返します", "ko": "`int f_22(int c, int d)` 함수를 작성하여 다음 문제를 해결하십시오:\n정수 c와 d가 주어졌을 때, 여기서 a + b = c이고 a * b = d입니다. 이 함수는 a <= b 조건을 만족하는 a의 가능한 값을 찾습니다. 여러 쌍 (a, b)이 가능한 경우, 가장 작은 a를 가진 쌍을 반환합니다. 유효한 쌍이 존재하지 않으면 -1을 반환합니다.\n\n매개변수:\n- c (int): a와 b의 합.\n- d (int): a와 b의 곱.\n\n반환값:\n- int: 가능한 a의 값 또는 유효한 값이 존재하지 않으면 -1.\n\n예시:\nf_22(7, 11) returns -1\nf_22(5, 6) returns 2", "ml": "`int f_22(int c, int d)` എന്ന ഒരു CPP ഫംഗ്ഷൻ എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nഇൻറ്ജറുകൾ c, d നൽകിയിരിക്കുമ്പോൾ, എവിടെ a + b = c കൂടാതെ a * b = d, ഈ ഫംഗ്ഷൻ\na <= b എന്ന വ്യവസ്ഥയോടെ aയുടെ സാധ്യമായ മൂല്യം കണ്ടെത്തുന്നു. നിരവധി\nജോടികൾ (a, b) സാധ്യമാണെങ്കിൽ, ഏറ്റവും ചെറിയ a ഉള്ള ജോടി തിരികെ നൽകുന്നു.\nസാധുവായ ജോടി ഒന്നും ഇല്ലെങ്കിൽ, ഇത് -1 തിരികെ നൽകുന്നു.\n\nപാരാമീറ്ററുകൾ:\n- c (int): aയും bയും ചേർന്നത്.\n- d (int): aയും bയും ഗുണിച്ചുള്ളത്.\n\nതിരികെ നൽകുന്നത്:\n- int: aയുടെ സാധ്യമായ മൂല്യം അല്ലെങ്കിൽ സാധുവായ മൂല്യങ്ങൾ ഇല്ലെങ്കിൽ -1.\n\nഉദാഹരണങ്ങൾ:\nf_22(7, 11) -1 തിരികെ നൽകുന്നു\nf_22(5, 6) 2 തിരികെ നൽകുന്നു", "fa": "یک تابع CPP `int f_22(int c, int d)` بنویسید تا مسئله زیر را حل کند:\nبا توجه به اعداد صحیح c و d، که در آن a + b = c و a * b = d، این تابع\nمقدار ممکن a را با شرط a <= b پیدا می‌کند. هنگامی که جفت‌های متعددی (a, b) ممکن است، جفتی را با کوچکترین a برمی‌گرداند.\nاگر هیچ جفت معتبری وجود نداشته باشد، -1 را برمی‌گرداند.\n\nپارامترها:\n- c (int): مجموع a و b.\n- d (int): حاصل‌ضرب a و b.\n\nبازگشتی:\n- int: یک مقدار ممکن از a یا -1 اگر هیچ مقدار معتبری وجود نداشته باشد.\n\nمثال‌ها:\nf_22(7, 11) -1 را برمی‌گرداند\nf_22(5, 6) 2 را برمی‌گرداند"}, "level": "easy", "test": "int main() {\n    assert(f_22(5, 6) == 2);\n    assert(f_22(6, 9) == 3);\n    assert(f_22(7, 12) == 3);\n    assert(f_22(7, 11) == -1);\n    assert(f_22(9, 8) == 1);\n    assert(f_22(10, 25) == 5);\n    assert(f_22(10000, 8765) == -1);\n\n    return 0;\n}", "entry_point": "f_22", "signature": "int f_22(int c, int d)", "docstring": {"en": "Given integers c and d, where a + b = c and a * b = d, this function\nfinds the possible value of a with the condition a <= b. When multiple\npairs (a, b) are possible, it returns the pair with the smallest a.\nIf no valid pair exists, it returns -1.\n\nParameters:\n- c (int): The sum of a and b.\n- d (int): The product of a and b.\n\nReturns:\n- int: A possible value of a or -1 if no valid values exist.\n\nExamples:\nf_22(7, 11) returns -1\nf_22(5, 6) returns 2\n", "sq": "Duke pasur parasysh numrat e plotë c dhe d, ku a + b = c dhe a * b = d, kjo funksion\ngjen vlerën e mundshme të a me kushtin a <= b. Kur janë të mundshme shumë\nçifte (a, b), ajo kthen çiftin me a më të vogël.\nNëse nuk ekziston asnjë çift i vlefshëm, ajo kthen -1.\n\nParametrat:\n- c (int): Shuma e a dhe b.\n- d (int): Produkti i a dhe b.\n\nKthen:\n- int: Një vlerë e mundshme e a ose -1 nëse nuk ekzistojnë vlera të vlefshme.\n\nShembuj:\nf_22(7, 11) kthen -1\nf_22(5, 6) kthen 2", "hy": "Տրված են ամբողջ թվեր c և d, որտեղ a + b = c և a * b = d, այս ֆունկցիան\nգտնում է a-ի հնարավոր արժեքը պայմանով a <= b։ Երբ հնարավոր են մի քանի\nզույգեր (a, b), այն վերադարձնում է զույգը ամենափոքր a-ով։\nԵթե վավեր զույգ գոյություն չունի, այն վերադարձնում է -1։\n\nՊարամետրեր:\n- c (int): a և b-ի գումարը։\n- d (int): a և b-ի արտադրյալը։\n\nՎերադարձնում է:\n- int: a-ի հնարավոր արժեքը կամ -1, եթե վավեր արժեքներ չկան։\n\nՕրինակներ:\nf_22(7, 11) վերադարձնում է -1\nf_22(5, 6) վերադարձնում է 2", "bn": "দেওয়া পূর্ণসংখ্যা c এবং d এর জন্য, যেখানে a + b = c এবং a * b = d, এই ফাংশনটি a এর সম্ভাব্য মান খুঁজে বের করে শর্ত সহ a <= b। যখন একাধিক জোড়া (a, b) সম্ভব হয়, এটি সবচেয়ে ছোট a সহ জোড়াটি ফেরত দেয়। যদি কোনো বৈধ জোড়া না থাকে, এটি -1 ফেরত দেয়।\n\nপ্যারামিটারসমূহ:\n- c (int): a এবং b এর যোগফল।\n- d (int): a এবং b এর গুণফল।\n\nফেরত:\n- int: a এর একটি সম্ভাব্য মান অথবা যদি কোনো বৈধ মান না থাকে তবে -1।\n\nউদাহরণ:\nf_22(7, 11) returns -1\nf_22(5, 6) returns 2", "bg": "Дадени са цели числа c и d, където a + b = c и a * b = d, тази функция\nнамира възможната стойност на a с условието a <= b. Когато са възможни множество\nдвойки (a, b), тя връща двойката с най-малко a.\nАко не съществува валидна двойка, тя връща -1.\n\nПараметри:\n- c (int): Сумата на a и b.\n- d (int): Произведението на a и b.\n\nВръща:\n- int: Възможна стойност на a или -1, ако не съществуват валидни стойности.\n\nПримери:\nf_22(7, 11) връща -1\nf_22(5, 6) връща 2", "zh": "给定整数 c 和 d，其中 a + b = c 且 a * b = d，此函数在 a <= b 的条件下找到 a 的可能值。当存在多个 (a, b) 对时，返回具有最小 a 的对。如果不存在有效对，则返回 -1。\n\n参数:\n- c (int): a 和 b 的和。\n- d (int): a 和 b 的积。\n\n返回:\n- int: a 的可能值，如果不存在有效值则返回 -1。\n\n示例:\nf_22(7, 11) 返回 -1\nf_22(5, 6) 返回 2", "fr": "Étant donné des entiers c et d, où a + b = c et a * b = d, cette fonction\ntrouve la valeur possible de a avec la condition a <= b. Lorsqu'il existe plusieurs\npaires (a, b) possibles, elle renvoie la paire avec le plus petit a.\nSi aucune paire valide n'existe, elle renvoie -1.\n\nParamètres:\n- c (int): La somme de a et b.\n- d (int): Le produit de a et b.\n\nRenvoie:\n- int: Une valeur possible de a ou -1 si aucune valeur valide n'existe.\n\nExemples:\nf_22(7, 11) renvoie -1\nf_22(5, 6) renvoie 2", "de": "Gegeben ganze Zahlen c und d, wobei a + b = c und a * b = d, findet diese Funktion den möglichen Wert von a mit der Bedingung a <= b. Wenn mehrere Paare (a, b) möglich sind, gibt sie das Paar mit dem kleinsten a zurück. Wenn kein gültiges Paar existiert, gibt sie -1 zurück.\n\nParameter:\n- c (int): Die Summe von a und b.\n- d (int): Das Produkt von a und b.\n\nRückgabewert:\n- int: Ein möglicher Wert von a oder -1, wenn keine gültigen Werte existieren.\n\nBeispiele:\nf_22(7, 11) gibt -1 zurück\nf_22(5, 6) gibt 2 zurück", "ha": "An ba da lambobin c da d, inda a + b = c kuma a * b = d, wannan aikin yana nemo yiwuwar ƙimar a tare da yanayin a <= b. Lokacin da dama-dama (a, b) suna yiwuwa, yana dawo da ma'aurata tare da ƙaramin a. Idan babu ma'aurata masu inganci, yana dawo da -1.\n\nParameters:\n- c (int): Jimillar a da b.\n- d (int): Samfurin a da b.\n\nReturns:\n- int: Yiwuwar ƙimar a ko -1 idan babu ƙimar da ta dace.\n\nExamples:\nf_22(7, 11) returns -1\nf_22(5, 6) returns 2", "hi": "दिए गए पूर्णांक c और d के लिए, जहाँ a + b = c और a * b = d, यह फ़ंक्शन a के संभावित मान को ढूंढता है जिसमें शर्त a <= b होती है। जब कई जोड़े (a, b) संभव होते हैं, तो यह सबसे छोटे a वाले जोड़े को लौटाता है। यदि कोई वैध जोड़ा मौजूद नहीं है, तो यह -1 लौटाता है।\n\nपैरामीटर्स:\n- c (int): a और b का योग।\n- d (int): a और b का गुणनफल।\n\nवापसी:\n- int: a का एक संभावित मान या -1 यदि कोई वैध मान मौजूद नहीं है।\n\nउदाहरण:\nf_22(7, 11) -1 लौटाता है\nf_22(5, 6) 2 लौटाता है", "hu": "Adott c és d egész számok, ahol a + b = c és a * b = d, ez a függvény\nmegtalálja a lehetséges a értékét azzal a feltétellel, hogy a <= b. Ha több\n(a, b) pár lehetséges, akkor a legkisebb a értékű párt adja vissza.\nHa nem létezik érvényes pár, akkor -1-et ad vissza.\n\nParaméterek:\n- c (int): Az a és b összege.\n- d (int): Az a és b szorzata.\n\nVisszatérési érték:\n- int: Egy lehetséges a érték vagy -1, ha nem léteznek érvényes értékek.\n\nPéldák:\nf_22(7, 11) visszaadja -1\nf_22(5, 6) visszaadja 2", "es": "Dado los enteros c y d, donde a + b = c y a * b = d, esta función\nencuentra el valor posible de a con la condición a <= b. Cuando múltiples\npares (a, b) son posibles, devuelve el par con el menor a.\nSi no existe un par válido, devuelve -1.\n\nParámetros:\n- c (int): La suma de a y b.\n- d (int): El producto de a y b.\n\nDevuelve:\n- int: Un valor posible de a o -1 si no existen valores válidos.\n\nEjemplos:\nf_22(7, 11) devuelve -1\nf_22(5, 6) devuelve 2", "arb": "المعطاة الأعداد الصحيحة c و d، حيث a + b = c و a * b = d، هذه الدالة\nتجد القيمة الممكنة لـ a بشرط أن a <= b. عندما تكون هناك أزواج متعددة (a, b) ممكنة، فإنها تعيد الزوج الذي يحتوي على أصغر قيمة لـ a.\nإذا لم يكن هناك زوج صالح، فإنها تعيد -1.\n\nالمعطيات:\n- c (int): مجموع a و b.\n- d (int): حاصل ضرب a و b.\n\nالقيم المعادة:\n- int: قيمة ممكنة لـ a أو -1 إذا لم تكن هناك قيم صالحة.\n\nأمثلة:\nf_22(7, 11) يعيد -1\nf_22(5, 6) يعيد 2", "sw": "Kwa kupewa namba kamili c na d, ambapo a + b = c na a * b = d, kazi hii\ninapata thamani inayowezekana ya a kwa sharti a <= b. Wakati jozi nyingi (a, b) zinawezekana, inarudisha jozi yenye a ndogo zaidi.\nIkiwa hakuna jozi halali inayopatikana, inarudisha -1.\n\nVigezo:\n- c (int): Jumla ya a na b.\n- d (int): Bidhaa ya a na b.\n\nInarudisha:\n- int: Thamani inayowezekana ya a au -1 ikiwa hakuna thamani halali inayopatikana.\n\nMifano:\nf_22(7, 11) inarudisha -1\nf_22(5, 6) inarudisha 2", "tr": "Verilen c ve d tamsayıları için, burada a + b = c ve a * b = d, bu fonksiyon\na <= b koşuluyla a'nın olası değerini bulur. Birden fazla (a, b) çifti mümkün olduğunda, en küçük a'ya sahip çifti döndürür.\nEğer geçerli bir çift yoksa, -1 döner.\n\nParametreler:\n- c (int): a ve b'nin toplamı.\n- d (int): a ve b'nin çarpımı.\n\nDöndürür:\n- int: a'nın olası bir değeri veya geçerli bir değer yoksa -1.\n\nÖrnekler:\nf_22(7, 11) -1 döndürür\nf_22(5, 6) 2 döndürür", "vi": "Cho các số nguyên c và d, trong đó a + b = c và a * b = d, hàm này tìm giá trị có thể của a với điều kiện a <= b. Khi có nhiều cặp (a, b) có thể, nó trả về cặp với a nhỏ nhất. Nếu không tồn tại cặp hợp lệ nào, nó trả về -1.\n\nTham số:\n- c (int): Tổng của a và b.\n- d (int): Tích của a và b.\n\nTrả về:\n- int: Một giá trị có thể của a hoặc -1 nếu không tồn tại giá trị hợp lệ nào.\n\nVí dụ:\nf_22(7, 11) trả về -1\nf_22(5, 6) trả về 2", "id": "Diberikan bilangan bulat c dan d, di mana a + b = c dan a * b = d, fungsi ini\nmenemukan nilai a yang mungkin dengan kondisi a <= b. Ketika beberapa\npasangan (a, b) mungkin, fungsi ini mengembalikan pasangan dengan a terkecil.\nJika tidak ada pasangan yang valid, fungsi ini mengembalikan -1.\n\nParameter:\n- c (int): Jumlah dari a dan b.\n- d (int): Hasil kali dari a dan b.\n\nMengembalikan:\n- int: Nilai a yang mungkin atau -1 jika tidak ada nilai yang valid.\n\nContoh:\nf_22(7, 11) mengembalikan -1\nf_22(5, 6) mengembalikan 2", "ja": "与えられた整数 c と d に対して、a + b = c かつ a * b = d であるとき、この関数は条件 a <= b を満たす a の可能な値を見つけます。複数のペア (a, b) が可能な場合、最小の a を持つペアを返します。有効なペアが存在しない場合は、-1 を返します。\n\n引数:\n- c (int): a と b の合計。\n- d (int): a と b の積。\n\n戻り値:\n- int: a の可能な値、または有効な値が存在しない場合は -1。\n\n例:\nf_22(7, 11) は -1 を返します\nf_22(5, 6) は 2 を返します", "ko": "주어진 정수 c와 d에 대해, 여기서 a + b = c이고 a * b = d일 때, 이 함수는 a <= b 조건을 만족하는 a의 가능한 값을 찾습니다. 여러 쌍 (a, b)이 가능한 경우, a가 가장 작은 쌍을 반환합니다. 유효한 쌍이 존재하지 않으면 -1을 반환합니다.\n\n매개변수:\n- c (int): a와 b의 합.\n- d (int): a와 b의 곱.\n\n반환값:\n- int: 가능한 a의 값 또는 유효한 값이 존재하지 않으면 -1.\n\n예제:\nf_22(7, 11) returns -1\nf_22(5, 6) returns 2", "ml": "ഇൻറിജറുകൾ c, d എന്നിവ നൽകിയിരിക്കുന്നപ്പോൾ, a + b = c കൂടാതെ a * b = d എന്നിടത്ത്,\na <= b എന്ന നിബന്ധനയോടെ a യുടെ സാധ്യതയുള്ള മൂല്യം ഈ ഫങ്ഷൻ കണ്ടെത്തുന്നു.\nഒന്നിലധികം ജോഡികൾ (a, b) സാധ്യമായാൽ, ഏറ്റവും ചെറിയ a ഉള്ള ജോഡി ഇത് തിരികെ നൽകുന്നു.\nസാധുവായ ജോഡി ഒന്നും ഇല്ലെങ്കിൽ, ഇത് -1 തിരികെ നൽകുന്നു.\n\nപാരാമീറ്ററുകൾ:\n- c (int): a, b എന്നിവയുടെ തുക.\n- d (int): a, b എന്നിവയുടെ ഗുണഫലം.\n\nമടക്കുക:\n- int: a യുടെ സാധ്യതയുള്ള മൂല്യം അല്ലെങ്കിൽ സാധുവായ മൂല്യങ്ങൾ ഒന്നും ഇല്ലെങ്കിൽ -1.\n\nഉദാഹരണങ്ങൾ:\nf_22(7, 11) -1 തിരികെ നൽകുന്നു\nf_22(5, 6) 2 തിരികെ നൽകുന്നു", "fa": "اعداد صحیح c و d داده شده‌اند، جایی که a + b = c و a * b = d، این تابع\n * مقدار ممکن a را با شرط a <= b پیدا می‌کند. وقتی چندین جفت (a, b) ممکن است،\n * جفتی را با کوچکترین a برمی‌گرداند.\n * اگر هیچ جفت معتبری وجود نداشته باشد، -1 را برمی‌گرداند.\n *\n * پارامترها:\n *  - c (int): مجموع a و b.\n *  - d (int): حاصل‌ضرب a و b.\n *\n * بازگشت:\n *  - int: یک مقدار ممکن از a یا -1 اگر هیچ مقدار معتبری وجود نداشته باشد.\n *\n * مثال‌ها:\nf_22(7, 11) returns -1  \nf_22(5, 6) returns 2  "}}
{"task_id": "CPP/23", "prompt": {"en": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\n/**\nCount the number of acute-angled triangles that can be formed by selecting any 3 edges out of\na given set of edges.\n  \nArgs:\n- edges_count: The number of edges passed.\n- An arbitrary number of integer arguments representing the lengths of the edges.\n  \nReturns:\nint: The count of distinct acute-angled triangles that can be formed.\n  \nExamples:\n>>> f_23(4, 1, 1, 1, 1)\n4\n**/\nint f_23(int edges_count, ...)", "sq": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\n/**\nNumëron numrin e trekëndëshave kënddrejtë që mund të formohen duke zgjedhur çdo 3 brinjë nga\nnjë grup i dhënë brinjësh.\n  \nArgumentet:\n- edges_count: Numri i brinjëve të dhëna.\n- Një numër arbitrar argumentesh të tipit integer që përfaqësojnë gjatësitë e brinjëve.\n  \nKthen:\nint: Numri i trekëndëshave të veçantë kënddrejtë që mund të formohen.\n  \nShembuj:\n>>> f_23(4, 1, 1, 1, 1)\n4\n**/\nint f_23(int edges_count, ...)", "hy": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\n/**\nՀաշվել սուրանկյուն եռանկյունների քանակը, որոնք կարող են կազմվել ընտրելով ցանկացած 3 կողերից\nտրված կողերի բազմությունից:\n  \nԱրգումենտներ:\n- edges_count: Անցկացվող կողերի քանակը:\n- Կողերի երկարությունները ներկայացնող ամբողջ թվերի կամայական քանակի արգումենտներ:\n  \nՎերադարձնում է:\nint: Տարբեր սուրանկյուն եռանկյունների քանակը, որոնք կարող են կազմվել:\n  \nՕրինակներ:\n>>> f_23(4, 1, 1, 1, 1)\n4\n**/\nint f_23(int edges_count, ...)", "bn": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\n/**\nপ্রদত্ত প্রান্তগুলির একটি সেট থেকে যেকোন 3 প্রান্ত নির্বাচন করে গঠিত তীক্ষ্ণ-কোণী ত্রিভুজের সংখ্যা গণনা করুন।\n  \nআর্গুমেন্টসমূহ:\n- edges_count: প্রেরিত প্রান্তের সংখ্যা।\n- প্রান্তগুলির দৈর্ঘ্য উপস্থাপনকারী একটি স্বেচ্ছামূলক সংখ্যক পূর্ণসংখ্যা আর্গুমেন্ট।\n  \nফেরত দেয়:\nint: গঠিত হতে পারে এমন স্বতন্ত্র তীক্ষ্ণ-কোণী ত্রিভুজের সংখ্যা।\n  \nউদাহরণ:\n>>> f_23(4, 1, 1, 1, 1)\n4\n**/\nint f_23(int edges_count, ...)", "bg": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\n/**\nБройте броя на остроъгълните триъгълници, които могат да бъдат образувани чрез избиране на\nвсякакви 3 ръба от даден набор от ръбове.\n  \nАргументи:\n- edges_count: Броят на подадените ръбове.\n- Произволен брой цели аргументи, представляващи дължините на ръбовете.\n  \nВръща:\nint: Броят на различните остроъгълни триъгълници, които могат да бъдат образувани.\n  \nПримери:\n>>> f_23(4, 1, 1, 1, 1)\n4\n**/\nint f_23(int edges_count, ...)", "zh": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\n/**\n计算可以通过从给定的一组边中选择任意3条边形成的锐角三角形的数量。\n  \n参数:\n- edges_count: 传递的边的数量。\n- 任意数量的整数参数，表示边的长度。\n  \n返回:\nint: 可以形成的不同锐角三角形的数量。\n  \n示例:\n>>> f_23(4, 1, 1, 1, 1)\n4\n**/\nint f_23(int edges_count, ...)", "fr": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\n/**\nCompte le nombre de triangles aigus qui peuvent être formés en sélectionnant 3 arêtes parmi\nun ensemble donné d'arêtes.\n  \nArgs:\n- edges_count: Le nombre d'arêtes passées.\n- Un nombre arbitraire d'arguments entiers représentant les longueurs des arêtes.\n  \nReturns:\nint: Le nombre de triangles aigus distincts qui peuvent être formés.\n  \nExamples:\n>>> f_23(4, 1, 1, 1, 1)\n4\n**/\nint f_23(int edges_count, ...)", "de": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\n/**\nZählt die Anzahl der spitzwinkligen Dreiecke, die gebildet werden können, indem beliebige 3 Kanten aus einem gegebenen Satz von Kanten ausgewählt werden.\n  \nArgumente:\n- edges_count: Die Anzahl der übergebenen Kanten.\n- Eine beliebige Anzahl von ganzzahligen Argumenten, die die Längen der Kanten darstellen.\n  \nRückgabewert:\nint: Die Anzahl der verschiedenen spitzwinkligen Dreiecke, die gebildet werden können.\n  \nBeispiele:\n>>> f_23(4, 1, 1, 1, 1)\n4\n**/\nint f_23(int edges_count, ...)", "ha": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\n/**\nƘirga adadin kusurwoyi masu kaifi waɗanda za a iya samarwa ta hanyar zaɓar kowane gefuna 3 daga\nwani saiti na gefuna da aka bayar.\n  \nArgs:\n- edges_count: Adadin gefuna da aka wuce.\n- Yawan hujjojin lamba masu zaman kansu suna wakiltar tsayin gefuna.\n  \nReturns:\nint: Adadin kusurwoyi masu kaifi daban-daban waɗanda za a iya samarwa.\n  \nMisalai:\n>>> f_23(4, 1, 1, 1, 1)\n4\n**/\nint f_23(int edges_count, ...)", "hi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\n/**\nकिसी दिए गए किनारों के सेट में से किसी भी 3 किनारों का चयन करके बनने वाले तीव्र कोण त्रिभुजों की संख्या गिनें।\n\nआर्ग्स:\n- edges_count: पास किए गए किनारों की संख्या।\n- किनारों की लंबाई का प्रतिनिधित्व करने वाले कई पूर्णांक तर्क।\n\nवापसी:\nint: बनने वाले विशिष्ट तीव्र कोण त्रिभुजों की संख्या।\n\nउदाहरण:\n>>> f_23(4, 1, 1, 1, 1)\n4\n**/\nint f_23(int edges_count, ...)", "hu": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\n/**\nSzámolja meg a hegyesszögű háromszögek számát, amelyek kialakíthatók a megadott élek közül bármely 3 él kiválasztásával.\n\nArgs:\n- edges_count: A megadott élek száma.\n- Tetszőleges számú egész számú argumentum, amelyek az élek hosszát képviselik.\n\nReturns:\nint: Az egyedi hegyesszögű háromszögek száma, amelyek kialakíthatók.\n\nPéldák:\n>>> f_23(4, 1, 1, 1, 1)\n4\n**/\nint f_23(int edges_count, ...)", "es": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\n/**\nCuenta el número de triángulos acutángulos que se pueden formar seleccionando cualquier 3 lados de un conjunto dado de lados.\n  \nArgs:\n- edges_count: El número de lados pasados.\n- Un número arbitrario de argumentos enteros que representan las longitudes de los lados.\n  \nReturns:\nint: La cantidad de triángulos acutángulos distintos que se pueden formar.\n  \nExamples:\n>>> f_23(4, 1, 1, 1, 1)\n4\n**/\nint f_23(int edges_count, ...)", "arb": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\n/**\nاحسب عدد المثلثات الحادة الزاوية التي يمكن تشكيلها عن طريق اختيار أي 3 حواف من مجموعة معينة من الحواف.\n\nالمعطيات:\n- edges_count: عدد الحواف الممررة.\n- عدد تعسفي من المعطيات الصحيحة التي تمثل أطوال الحواف.\n\nالقيم المعادة:\nint: عدد المثلثات الحادة الزاوية المميزة التي يمكن تشكيلها.\n\nأمثلة:\n>>> f_23(4, 1, 1, 1, 1)\n4\n**/\nint f_23(int edges_count, ...)", "sw": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\n/**\nHesabu idadi ya pembetatu zenye pembe kali ambazo zinaweza kuundwa kwa kuchagua pande 3 zozote kutoka\nkatika seti iliyotolewa ya pande.\n  \nArgs:\n- edges_count: Idadi ya pande zilizopitishwa.\n- Idadi isiyo ya kawaida ya hoja za nambari za mzima zinazowakilisha urefu wa pande.\n  \nReturns:\nint: Idadi ya pembetatu tofauti zenye pembe kali ambazo zinaweza kuundwa.\n  \nExamples:\n>>> f_23(4, 1, 1, 1, 1)\n4\n**/\nint f_23(int edges_count, ...)", "tr": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\n/**\nVerilen bir kenar kümesinden herhangi 3 kenar seçilerek oluşturulabilecek dik açılı üçgenlerin sayısını sayar.\n  \nArgs:\n- edges_count: Geçilen kenarların sayısı.\n- Kenarların uzunluklarını temsil eden keyfi sayıda tamsayı argümanı.\n  \nReturns:\nint: Oluşturulabilecek farklı dik açılı üçgenlerin sayısı.\n  \nÖrnekler:\n>>> f_23(4, 1, 1, 1, 1)\n4\n**/\nint f_23(int edges_count, ...)", "vi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\n/**\nĐếm số lượng tam giác nhọn có thể được tạo thành bằng cách chọn bất kỳ 3 cạnh nào từ\nmột tập hợp các cạnh cho trước.\n  \nTham số:\n- edges_count: Số lượng cạnh được truyền vào.\n- Một số lượng tùy ý các tham số nguyên đại diện cho độ dài của các cạnh.\n  \nTrả về:\nint: Số lượng tam giác nhọn khác nhau có thể được tạo thành.\n  \nVí dụ:\n>>> f_23(4, 1, 1, 1, 1)\n4\n**/\nint f_23(int edges_count, ...)", "id": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\n/**\nMenghitung jumlah segitiga lancip yang dapat dibentuk dengan memilih 3 sisi dari\nsekumpulan sisi yang diberikan.\n  \nArgumen:\n- edges_count: Jumlah sisi yang diberikan.\n- Sejumlah argumen bilangan bulat yang mewakili panjang sisi-sisi.\n  \nMengembalikan:\nint: Jumlah segitiga lancip yang berbeda yang dapat dibentuk.\n  \nContoh:\n>>> f_23(4, 1, 1, 1, 1)\n4\n**/\nint f_23(int edges_count, ...)", "ja": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\n/**\n与えられた辺の集合から任意の3辺を選択することによって形成できる鋭角三角形の数を数えます。\n  \n引数:\n- edges_count: 渡された辺の数。\n- 辺の長さを表す任意の数の整数引数。\n  \n戻り値:\nint: 形成できる異なる鋭角三角形の数。\n  \n例:\n>>> f_23(4, 1, 1, 1, 1)\n4\n**/\nint f_23(int edges_count, ...)", "ko": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\n/**\n주어진 모서리 집합에서 임의의 3개의 모서리를 선택하여 만들 수 있는 예각 삼각형의 수를 계산합니다.\n  \n매개변수:\n- edges_count: 전달된 모서리의 수.\n- 모서리의 길이를 나타내는 임의의 정수 인자들.\n  \n반환값:\nint: 만들 수 있는 서로 다른 예각 삼각형의 수.\n  \n예시:\n>>> f_23(4, 1, 1, 1, 1)\n4\n**/\nint f_23(int edges_count, ...)", "ml": "#include <casserth >\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\n/**\nഒരു നൽകിയ എഡ്ജുകളുടെ സെറ്റിൽ നിന്ന് ഏതെങ്കിലും 3 എഡ്ജുകൾ തിരഞ്ഞെടുക്കുന്നതിലൂടെ രൂപീകരിക്കാവുന്ന acute-angled ത്രികോണങ്ങളുടെ എണ്ണം കണക്കാക്കുക.\n  \nആർഗ്സ്:\n- edges_count: പാസ്സായ എഡ്ജുകളുടെ എണ്ണം.\n- എഡ്ജുകളുടെ നീളങ്ങളെ പ്രതിനിധീകരിക്കുന്ന ഒരു യാദൃച്ഛികമായ സംഖ്യയുടെ പാരാമീറ്ററുകൾ.\n  \nമടക്കുന്നു:\nint: രൂപീകരിക്കാവുന്ന വ്യത്യസ്തമായ acute-angled ത്രികോണങ്ങളുടെ എണ്ണം.\n  \nഉദാഹരണങ്ങൾ:\n>>> f_23(4, 1, 1, 1, 1)\n4\n**/\nint f_23(int edges_count, ...)", "fa": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\n/**\nتعداد مثلث‌های تیزگوشه‌ای را که می‌توان با انتخاب هر ۳ ضلع از یک مجموعه از اضلاع تشکیل داد، بشمارید.\n\nآرگومان‌ها:\n- edges_count: تعداد اضلاع داده شده.\n- تعداد دلخواهی از آرگومان‌های صحیح که طول اضلاع را نشان می‌دهند.\n\nبرمی‌گرداند:\nint: تعداد مثلث‌های تیزگوشه‌ی متمایزی که می‌توان تشکیل داد.\n\nمثال‌ها:\n>>> f_23(4, 1, 1, 1, 1)\n4\n**/\nint f_23(int edges_count, ...)"}, "canonical_solution": "{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = (int*) malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    // qsort(edges, edges_count, sizeof(int), [](const void * a, const void * b) -> int {\n    //     return *(int*)a - *(int*)b;\n    // });\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}", "instruction": {"en": "Write a CPP function `int f_23(int edges_count, ...)` to solve the following problem:\nCount the number of acute-angled triangles that can be formed by selecting any 3 edges out of a given set of edges.\n\nArgs:\n- edges_count: The number of edges passed.\n- An arbitrary number of integer arguments representing the lengths of the edges.\n\nReturns:\nint: The count of distinct acute-angled triangles that can be formed.\n\nExamples:\n>>> f_23(4, 1, 1, 1, 1)\n4\n", "sq": "Shkruani një funksion CPP `int f_23(int edges_count, ...)` për të zgjidhur problemin e mëposhtëm:\nNumëroni numrin e trekëndëshave me kënde të mprehta që mund të formohen duke zgjedhur çdo 3 brinjë nga një grup i dhënë brinjësh.\n\nArgumentet:\n- edges_count: Numri i brinjëve të dhëna.\n- Një numër arbitrar i argumenteve të plotë që përfaqësojnë gjatësitë e brinjëve.\n\nKthen:\nint: Numri i trekëndëshave të dallueshëm me kënde të mprehta që mund të formohen.\n\nShembuj:\n>>> f_23(4, 1, 1, 1, 1)\n4", "hy": "Գրեք CPP ֆունկցիա `int f_23(int edges_count, ...)` հետևյալ խնդիրը լուծելու համար:\nՀաշվեք սուրանկյուն եռանկյունիների քանակը, որոնք կարող են կազմվել տրված կողերի հավաքածուից ցանկացած 3 կող ընտրելով:\n\nԱրգումենտներ:\n- edges_count: Փոխանցված կողերի քանակը:\n- Կողերի երկարությունները ներկայացնող ամբողջ թվերի կամայական քանակի արգումենտներ:\n\nՎերադարձնում է:\nint: Տարբեր սուրանկյուն եռանկյունիների քանակը, որոնք կարող են կազմվել:\n\nՕրինակներ:\n>>> f_23(4, 1, 1, 1, 1)\n4", "bn": "একটি CPP ফাংশন `int f_23(int edges_count, ...)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nপ্রদত্ত প্রান্তগুলির একটি সেট থেকে যেকোনো ৩টি প্রান্ত নির্বাচন করে কতগুলি তীক্ষ্ণ-কোণী ত্রিভুজ গঠন করা যেতে পারে তা গণনা করুন।\n\nআর্গুমেন্টসমূহ:\n- edges_count: পাস করা প্রান্তগুলির সংখ্যা।\n- প্রান্তগুলির দৈর্ঘ্য উপস্থাপনকারী অসীম সংখ্যক পূর্ণসংখ্যা আর্গুমেন্ট।\n\nফেরত দেয়:\nint: গঠিত হতে পারে এমন স্বতন্ত্র তীক্ষ্ণ-কোণী ত্রিভুজের সংখ্যা।\n\nউদাহরণ:\n>>> f_23(4, 1, 1, 1, 1)\n4", "bg": "Напишете CPP функция `int f_23(int edges_count, ...)`, за да решите следния проблем:  \nБройте броя на остроъгълните триъгълници, които могат да бъдат образувани чрез избиране на произволни 3 ръба от даден набор от ръбове.\n\nАргументи:\n- edges_count: Броят на подадените ръбове.\n- Произволен брой цели аргументи, представляващи дължините на ръбовете.\n\nВръща:\nint: Броят на различните остроъгълни триъгълници, които могат да бъдат образувани.\n\nПримери:\n>>> f_23(4, 1, 1, 1, 1)\n4", "zh": "编写一个 CPP 函数 `int f_23(int edges_count, ...)` 来解决以下问题：  \n计算可以通过从给定的一组边中选择任意 3 条边形成的锐角三角形的数量。\n\n参数：\n- edges_count: 传递的边的数量。\n- 任意数量的整数参数，表示边的长度。\n\n返回：\nint: 可以形成的不同锐角三角形的数量。 \n\n示例：\n>>> f_23(4, 1, 1, 1, 1)\n4", "fr": "Écrire une fonction CPP `int f_23(int edges_count, ...)` pour résoudre le problème suivant :  \nCompter le nombre de triangles acutangles qui peuvent être formés en sélectionnant n'importe quels 3 côtés parmi un ensemble donné de côtés.\n\nArgs:\n- edges_count: Le nombre de côtés passés.\n- Un nombre arbitraire d'arguments entiers représentant les longueurs des côtés.\n\nReturns:\nint: Le nombre de triangles acutangles distincts qui peuvent être formés.\n\nExemples:\n>>> f_23(4, 1, 1, 1, 1)\n4", "de": "Schreiben Sie eine CPP-Funktion `int f_23(int edges_count, ...)`, um das folgende Problem zu lösen:\nZählen Sie die Anzahl der spitzwinkligen Dreiecke, die gebildet werden können, indem Sie beliebige 3 Kanten aus einer gegebenen Menge von Kanten auswählen.\n\nArgumente:\n- edges_count: Die Anzahl der übergebenen Kanten.\n- Eine beliebige Anzahl von ganzzahligen Argumenten, die die Längen der Kanten darstellen.\n\nRückgabewert:\nint: Die Anzahl der verschiedenen spitzwinkligen Dreiecke, die gebildet werden können.\n\nBeispiele:\n>>> f_23(4, 1, 1, 1, 1)\n4", "ha": "Rubuta aikin CPP `int f_23(int edges_count, ...)` don warware matsalar mai zuwa:\nƘididdige adadin kusurwoyin triangles masu kaifi da za a iya samarwa ta zaɓar kowane 3 gefuna daga cikin saiti na gefuna da aka bayar.\n\nArgs:\n- edges_count: Yawan gefuna da aka bayar.\n- Yawan hujjojin lamba masu zaman kansu da ke wakiltar tsawon gefuna.\n\nReturns:\nint: Adadin triangles masu kaifi da za a iya samarwa.\n\nMisalai:\n>>> f_23(4, 1, 1, 1, 1)\n4", "hi": "एक CPP फ़ंक्शन `int f_23(int edges_count, ...)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए किनारों के सेट में से किसी भी 3 किनारों को चुनकर बनने वाले तीव्र कोणीय त्रिभुजों की संख्या गिनें।\n\nआर्ग्स:\n- edges_count: पास किए गए किनारों की संख्या।\n- किनारों की लंबाई का प्रतिनिधित्व करने वाले पूर्णांक तर्कों की एक मनमानी संख्या।\n\nरिटर्न:\nint: बनने वाले भिन्न तीव्र कोणीय त्रिभुजों की संख्या।\n\nउदाहरण:\n>>> f_23(4, 1, 1, 1, 1)\n4", "hu": "Írj egy CPP függvényt `int f_23(int edges_count, ...)` a következő probléma megoldására:\nSzámold meg, hogy hány hegyesszögű háromszög alakítható ki a megadott élek halmazából tetszőleges 3 él kiválasztásával.\n\nArgok:\n- edges_count: Az átadott élek száma.\n- Tetszőleges számú egész szám argumentum, amelyek az élek hosszát képviselik.\n\nVisszatér:\nint: Az alakítható különböző hegyesszögű háromszögek száma.\n\nPéldák:\n>>> f_23(4, 1, 1, 1, 1)\n4", "es": "Escribe una función CPP `int f_23(int edges_count, ...)` para resolver el siguiente problema:\nCuenta el número de triángulos acutángulos que se pueden formar seleccionando cualquier 3 aristas de un conjunto dado de aristas.\n\nArgs:\n- edges_count: El número de aristas pasadas.\n- Un número arbitrario de argumentos enteros que representan las longitudes de las aristas.\n\nReturns:\nint: La cuenta de triángulos acutángulos distintos que se pueden formar.\n\nExamples:\n>>> f_23(4, 1, 1, 1, 1)\n4", "arb": "اكتب دالة CPP `int f_23(int edges_count, ...)` لحل المشكلة التالية:\nاحسب عدد المثلثات الحادة الزاوية التي يمكن تشكيلها عن طريق اختيار أي 3 حواف من مجموعة الحواف المعطاة.\n\nArgs:\n- edges_count: عدد الحواف الممررة.\n- عدد تعسفي من الوسيطات الصحيحة التي تمثل أطوال الحواف.\n\nReturns:\nint: عدد المثلثات الحادة الزاوية المختلفة التي يمكن تشكيلها.\n\nExamples:\n>>> f_23(4, 1, 1, 1, 1)\n4", "sw": "Andika kazi ya CPP `int f_23(int edges_count, ...)` kutatua tatizo lifuatalo:\nHesabu idadi ya pembetatu zenye pembe kali ambazo zinaweza kuundwa kwa kuchagua pande 3 kutoka kwenye seti ya pande zilizotolewa.\n\nArgs:\n- edges_count: Idadi ya pande zilizopitishwa.\n- Idadi isiyo na kikomo ya hoja za nambari za mzima zinazoashiria urefu wa pande.\n\nInarudisha:\nint: Idadi ya pembetatu tofauti zenye pembe kali ambazo zinaweza kuundwa.\n\nMifano:\n>>> f_23(4, 1, 1, 1, 1)\n4", "tr": "Bir CPP fonksiyonu `int f_23(int edges_count, ...)` yazın ve aşağıdaki problemi çözün:\nVerilen bir kenar kümesinden herhangi 3 kenar seçilerek oluşturulabilecek dar açılı üçgenlerin sayısını sayın.\n\nArgümanlar:\n- edges_count: Geçilen kenarların sayısı.\n- Kenarların uzunluklarını temsil eden rastgele sayıda tamsayı argümanı.\n\nDöndürür:\nint: Oluşturulabilecek farklı dar açılı üçgenlerin sayısı.\n\nÖrnekler:\n>>> f_23(4, 1, 1, 1, 1)\n4", "vi": "Viết một hàm CPP `int f_23(int edges_count, ...)` để giải quyết vấn đề sau:\nĐếm số lượng tam giác nhọn có thể được tạo thành bằng cách chọn bất kỳ 3 cạnh nào từ một tập hợp các cạnh đã cho.\n\nTham số:\n- edges_count: Số lượng cạnh được truyền vào.\n- Một số lượng tùy ý các tham số nguyên đại diện cho độ dài của các cạnh.\n\nTrả về:\nint: Số lượng tam giác nhọn khác nhau có thể được tạo thành.\n\nVí dụ:\n>>> f_23(4, 1, 1, 1, 1)\n4", "id": "Tulis fungsi CPP `int f_23(int edges_count, ...)` untuk menyelesaikan masalah berikut:\nHitung jumlah segitiga lancip yang dapat dibentuk dengan memilih 3 sisi dari sekumpulan sisi yang diberikan.\n\nArgumen:\n- edges_count: Jumlah sisi yang diberikan.\n- Sejumlah argumen integer yang mewakili panjang sisi-sisi.\n\nMengembalikan:\nint: Jumlah segitiga lancip yang berbeda yang dapat dibentuk.\n\nContoh:\n>>> f_23(4, 1, 1, 1, 1)\n4", "ja": "以下の問題を解くために、CPP関数 `int f_23(int edges_count, ...)` を作成してください:\n与えられたエッジのセットから任意の3つのエッジを選択して形成できる鋭角三角形の数を数えます。\n\n引数:\n- edges_count: 渡されたエッジの数。\n- エッジの長さを表す任意の数の整数引数。\n\n戻り値:\nint: 形成できる異なる鋭角三角形の数。\n\n例:\n>>> f_23(4, 1, 1, 1, 1)\n4", "ko": "다음 문제를 해결하기 위해 CPP 함수를 작성하세요 `int f_23(int edges_count, ...)`:\n주어진 모서리 집합에서 임의의 3개의 모서리를 선택하여 형성할 수 있는 예각 삼각형의 수를 계산합니다.\n\n인수:\n- edges_count: 전달된 모서리의 수.\n- 모서리의 길이를 나타내는 임의의 수의 정수 인수.\n\n반환:\nint: 형성할 수 있는 서로 다른 예각 삼각형의 수.\n\n예시:\n>>> f_23(4, 1, 1, 1, 1)\n4", "ml": "`int f_23(int edges_count, ...)` എന്ന CPP ഫംഗ്ഷൻ എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nഒരു നൽകിയ എഡ്ജുകളുടെ സെറ്റിൽ നിന്ന് ഏതെങ്കിലും 3 എഡ്ജുകൾ തിരഞ്ഞെടുക്കുന്നതിലൂടെ രൂപീകരിക്കാവുന്ന മൂർച്ചയുള്ള ത്രികോണങ്ങളുടെ എണ്ണം എണ്ണുക.\n\nആർഗ്യുമെന്റുകൾ:\n- edges_count: പാസ്സായ എഡ്ജുകളുടെ എണ്ണം.\n- എഡ്ജുകളുടെ നീളങ്ങൾ പ്രതിനിധീകരിക്കുന്ന അനിയന്ത്രിതമായ സംഖ്യയിലെ പൂർണ്ണസംഖ്യാ ആർഗ്യുമെന്റുകൾ.\n\nമടക്കിക്കൊടുക്കുന്നു:\nint: രൂപീകരിക്കാവുന്ന വ്യത്യസ്തമായ മൂർച്ചയുള്ള ത്രികോണങ്ങളുടെ എണ്ണം.\n\nഉദാഹരണങ്ങൾ:\n>>> f_23(4, 1, 1, 1, 1)\n4", "fa": "یک تابع CPP به نام `int f_23(int edges_count, ...)` بنویسید تا مسئله زیر را حل کند:\nتعداد مثلث‌های تیزگوشه‌ای را که می‌توان با انتخاب هر ۳ ضلع از مجموعه‌ای از اضلاع تشکیل داد، بشمارید.\n\nآرگومان‌ها:\n- edges_count: تعداد اضلاع داده شده.\n- تعداد دلخواهی از آرگومان‌های عدد صحیح که طول اضلاع را نشان می‌دهند.\n\nبرمی‌گرداند:\nint: تعداد مثلث‌های تیزگوشه متمایزی که می‌توان تشکیل داد.\n\nمثال‌ها:\n>>> f_23(4, 1, 1, 1, 1)\n4"}, "level": "middle", "test": "int main() {\n    assert(f_23(4, 1, 1, 1, 1) == 4);\n    assert(f_23(3, 1, 2, 3) == 0);\n    // Additional tests to ensure correctness\n    assert(f_23(5, 3, 4, 5, 7, 10) == 0);\n    assert(f_23(6, 6, 8, 10, 5, 5, 5) == 4);\n    return 0;\n}", "entry_point": "f_23", "signature": "int f_23(int edges_count, ...)", "docstring": {"en": "Count the number of acute-angled triangles that can be formed by selecting any 3 edges out of a given set of edges.\n\nArgs:\n- edges_count: The number of edges passed.\n- An arbitrary number of integer arguments representing the lengths of the edges.\n\nReturns:\nint: The count of distinct acute-angled triangles that can be formed.\n\nExamples:\n>>> f_23(4, 1, 1, 1, 1)\n4\n", "sq": "Numëroni numrin e trekëndëshave me kënd të mprehtë që mund të formohen duke zgjedhur çdo 3 brinjë nga një grup i dhënë brinjësh.\n\nArgumentet:\n- edges_count: Numri i brinjëve të dhëna.\n- Një numër i pacaktuar argumentesh të tipit integer që përfaqësojnë gjatësitë e brinjëve.\n\nKthen:\nint: Numri i trekëndëshave të dallueshëm me kënd të mprehtë që mund të formohen.\n\nShembuj:\n>>> f_23(4, 1, 1, 1, 1)\n4", "hy": "Հաշվեք սուր անկյուն ունեցող եռանկյունիների քանակը, որոնք կարող են կազմվել՝ ընտրելով ցանկացած 3 կողերից տրված կողերի հավաքածուից։\n\nԱրգումենտներ:\n- edges_count: Անցկացված կողերի քանակը։\n- Կողերի երկարությունները ներկայացնող ամբողջ թվերի կամայական քանակի արգումենտներ։\n\nՎերադարձնում է:\nint: Տարբեր սուր անկյուն ունեցող եռանկյունիների քանակը, որոնք կարող են կազմվել։\n\nՕրինակներ:\n>>> f_23(4, 1, 1, 1, 1)\n4", "bn": "তীক্ষ্ণ-কোণবিশিষ্ট ত্রিভুজের সংখ্যা গণনা করুন যা একটি প্রদত্ত প্রান্তের সেট থেকে যেকোনো 3টি প্রান্ত নির্বাচন করে গঠন করা যেতে পারে।\n\nআর্গস:\n- edges_count: পাস করা প্রান্তের সংখ্যা।\n- প্রান্তের দৈর্ঘ্য উপস্থাপনকারী একটি নির্বিচারে সংখ্যক পূর্ণসংখ্যা আর্গুমেন্ট।\n\nরিটার্নস:\nint: গঠিত হতে পারে এমন স্বতন্ত্র তীক্ষ্ণ-কোণবিশিষ্ট ত্রিভুজের সংখ্যা।\n\nউদাহরণ:\n>>> f_23(4, 1, 1, 1, 1)\n4", "bg": "Бройте броя на остроъгълните триъгълници, които могат да бъдат образувани чрез избиране на произволни 3 ръба от даден набор от ръбове.\n\nАргументи:\n- edges_count: Броят на предадените ръбове.\n- Произволен брой цели аргументи, представляващи дължините на ръбовете.\n\nВръща:\nint: Броят на различните остроъгълни триъгълници, които могат да бъдат образувани.\n\nПримери:\n>>> f_23(4, 1, 1, 1, 1)\n4", "zh": "计算可以通过从给定的边集中选择任意3条边形成的锐角三角形的数量。\n\n参数:\n- edges_count: 传递的边的数量。\n- 任意数量的整数参数，表示边的长度。\n\n返回:\nint: 可以形成的不同锐角三角形的数量。\n\n示例:\n>>> f_23(4, 1, 1, 1, 1)\n4", "fr": "Compter le nombre de triangles aigus qui peuvent être formés en sélectionnant 3 arêtes parmi un ensemble donné d'arêtes.\n\nArgs:\n- edges_count: Le nombre d'arêtes passées.\n- Un nombre arbitraire d'arguments entiers représentant les longueurs des arêtes.\n\nReturns:\nint: Le nombre de triangles aigus distincts qui peuvent être formés.\n\nExamples:\n>>> f_23(4, 1, 1, 1, 1)\n4", "de": "Zähle die Anzahl der spitzwinkligen Dreiecke, die gebildet werden können, indem beliebige 3 Kanten aus einer gegebenen Menge von Kanten ausgewählt werden.\n\nArgs:\n- edges_count: Die Anzahl der übergebenen Kanten.\n- Eine beliebige Anzahl von ganzzahligen Argumenten, die die Längen der Kanten darstellen.\n\nReturns:\nint: Die Anzahl der verschiedenen spitzwinkligen Dreiecke, die gebildet werden können.\n\nExamples:\n>>> f_23(4, 1, 1, 1, 1)\n4", "ha": "Ƙididdige adadin kusurwoyin triangles masu kaifi da za a iya samarwa ta zaɓar kowane 3 gefuna daga cikin saiti na gefuna da aka bayar.\n\nArgs:\n- edges_count: Yawan gefuna da aka bayar.\n- Wani adadi na hujjojin lamba masu wakiltar tsawon gefuna.\n\nReturns:\nint: Yawan kusurwoyi masu kaifi daban-daban da za a iya samarwa.\n\nExamples:\n>>> f_23(4, 1, 1, 1, 1)\n4", "hi": "तीक्ष्ण कोण वाले त्रिभुजों की संख्या गिनें जो दिए गए किनारों के सेट में से किसी भी 3 किनारों का चयन करके बनाए जा सकते हैं।\n\nआर्ग्स:\n- edges_count: पास किए गए किनारों की संख्या।\n- किनारों की लंबाई का प्रतिनिधित्व करने वाले पूर्णांक तर्कों की एक मनमानी संख्या।\n\nवापसी:\nint: विशिष्ट तीक्ष्ण कोण वाले त्रिभुजों की संख्या जो बनाई जा सकती है।\n\nउदाहरण:\n>>> f_23(4, 1, 1, 1, 1)\n4", "hu": "Számolja meg azokat a hegyesszögű háromszögeket, amelyeket a megadott élek halmazából bármely 3 él kiválasztásával lehet kialakítani.\n\nArgs:\n- edges_count: A megadott élek száma.\n- Tetszőleges számú egész szám argumentum, amelyek az élek hosszát képviselik.\n\nReturns:\nint: Az alakítható különböző hegyesszögű háromszögek száma.\n\nExamples:\n>>> f_23(4, 1, 1, 1, 1)\n4", "es": "Contar el número de triángulos acutángulos que se pueden formar seleccionando cualquier 3 lados de un conjunto dado de lados.\n\nArgs:\n- edges_count: El número de lados pasados.\n- Un número arbitrario de argumentos enteros que representan las longitudes de los lados.\n\nReturns:\nint: La cantidad de triángulos acutángulos distintos que se pueden formar.\n\nExamples:\n>>> f_23(4, 1, 1, 1, 1)\n4", "arb": "احسب عدد المثلثات الحادة الزاوية التي يمكن تشكيلها عن طريق اختيار أي 3 حواف من مجموعة الحواف المعطاة.\n\nArgs:\n- edges_count: عدد الحواف الممررة.\n- عدد تعسفي من الوسائط الصحيحة التي تمثل أطوال الحواف.\n\nReturns:\nint: عدد المثلثات الحادة الزاوية المميزة التي يمكن تشكيلها.\n\nExamples:\n>>> f_23(4, 1, 1, 1, 1)\n4", "sw": "Hesabu idadi ya pembetatu zenye pembe kali ambazo zinaweza kuundwa kwa kuchagua pande 3 zozote kutoka kwenye seti iliyotolewa ya pande.\n\nArgs:\n- edges_count: Idadi ya pande zilizopitishwa.\n- Idadi isiyo ya lazima ya hoja za nambari nzima zinazowakilisha urefu wa pande.\n\nReturns:\nint: Idadi ya pembetatu tofauti zenye pembe kali ambazo zinaweza kuundwa.\n\nExamples:\n>>> f_23(4, 1, 1, 1, 1)\n4", "tr": "Verilen bir kenar kümesinden herhangi 3 kenar seçilerek oluşturulabilecek dar açılı üçgenlerin sayısını sayın.\n\nArgs:\n- edges_count: Geçilen kenarların sayısı.\n- Kenarların uzunluklarını temsil eden rastgele sayıda tam sayı argümanı.\n\nReturns:\nint: Oluşturulabilecek farklı dar açılı üçgenlerin sayısı.\n\nExamples:\n>>> f_23(4, 1, 1, 1, 1)\n4\n", "vi": "Đếm số lượng tam giác nhọn có thể được tạo thành bằng cách chọn bất kỳ 3 cạnh nào từ một tập hợp các cạnh cho trước.\n\nTham số:\n- edges_count: Số lượng cạnh được truyền vào.\n- Một số lượng tùy ý các đối số kiểu số nguyên đại diện cho độ dài của các cạnh.\n\nTrả về:\nint: Số lượng tam giác nhọn khác biệt có thể được tạo thành.\n\nVí dụ:\n>>> f_23(4, 1, 1, 1, 1)\n4", "id": "Hitung jumlah segitiga lancip yang dapat dibentuk dengan memilih 3 sisi dari kumpulan sisi yang diberikan.\n\nArgs:\n- edges_count: Jumlah sisi yang diberikan.\n- Sejumlah argumen bilangan bulat yang mewakili panjang sisi-sisi.\n\nReturns:\nint: Jumlah segitiga lancip yang berbeda yang dapat dibentuk.\n\nExamples:\n>>> f_23(4, 1, 1, 1, 1)\n4", "ja": "与えられたエッジのセットから任意の3つのエッジを選択することによって形成できる鋭角三角形の数を数えます。\n\n引数:\n- edges_count: 渡されたエッジの数。\n- エッジの長さを表す任意の数の整数引数。\n\n戻り値:\nint: 形成できる異なる鋭角三角形の数。\n\n例:\n>>> f_23(4, 1, 1, 1, 1)\n4", "ko": "주어진 변의 집합에서 임의의 3개의 변을 선택하여 만들 수 있는 예각 삼각형의 개수를 계산합니다.\n\n인수:\n- edges_count: 전달된 변의 수입니다.\n- 변의 길이를 나타내는 임의의 개수의 정수 인수입니다.\n\n반환:\nint: 만들 수 있는 고유한 예각 삼각형의 개수입니다.\n\n예제:\n>>> f_23(4, 1, 1, 1, 1)\n4", "ml": "മൂന്ന് വശങ്ങൾ തിരഞ്ഞെടുക്കുന്നതിലൂടെ രൂപപ്പെടുത്താവുന്ന മൂർച്ചയുള്ള മൂന്നു കോണുകളുള്ള ത്രികോണങ്ങളുടെ എണ്ണം എണ്ണുക.\n\nആർഗ്സ്:\n- edges_count: നൽകിയ വശങ്ങളുടെ എണ്ണം.\n- വശങ്ങളുടെ നീളങ്ങൾ പ്രതിനിധീകരിക്കുന്ന ഒരു 任ച്ഛായ整数引数.\n\nമടക്കങ്ങൾ:\nint: രൂപപ്പെടുത്താവുന്ന വ്യത്യസ്തമായ മൂർച്ചയുള്ള ത്രികോണങ്ങളുടെ എണ്ണം.\n\nഉദാഹരണങ്ങൾ:\n>>> f_23(4, 1, 1, 1, 1)\n4", "fa": "تعداد مثلث‌های تیزگوشه‌ای را که می‌توان با انتخاب هر ۳ ضلع از مجموعه‌ای از اضلاع تشکیل داد، بشمارید.\n\nآرگومان‌ها:\n- edges_count: تعداد اضلاع داده شده.\n- تعداد دلخواهی از آرگومان‌های صحیح که طول اضلاع را نشان می‌دهند.\n\nبازگشت:\nint: تعداد مثلث‌های تیزگوشه‌ی متمایزی که می‌توان تشکیل داد.\n\nمثال‌ها:\n>>> f_23(4, 1, 1, 1, 1)\n4"}}
{"task_id": "CPP/24", "prompt": {"en": "#include <bits/stdc++.h>\n/**\n * Reads an integer and a character, then returns them as a formatted string separated by a comma.\n * \n * Parameters:\n * - integer_value (int): The input integer.\n * - char_value (char): The input character.\n * \n * Returns:\n * - char*: A string containing the integer and character separated by a comma.\n * \n * Example:\n * f_24(234, 'H') returns \"234,H\"\n */\nchar* f_24(int integer_value, char char_value)", "sq": "#include <bits/stdc++.h>\n/**\n * Lexon një numër të plotë dhe një karakter, pastaj i kthen ato si një varg i formatuar i ndarë me presje.\n * \n * Parametrat:\n * - integer_value (int): Numri i plotë i dhënë si hyrje.\n * - char_value (char): Karakteri i dhënë si hyrje.\n * \n * Kthen:\n * - char*: Një varg që përmban numrin e plotë dhe karakterin e ndarë me presje.\n * \n * Shembull:\n * f_24(234, 'H') kthen \"234,H\"\n */\nchar* f_24(int integer_value, char char_value)", "hy": "#include <bits/stdc++.h>\n/**\n * Կարդում է ամբողջ թիվ և սիմվոլ, ապա վերադարձնում է դրանք ձևաչափված տողում, բաժանված ստորակետով։\n * \n * Պարամետրեր:\n * - integer_value (int): Մուտքային ամբողջ թիվը։\n * - char_value (char): Մուտքային սիմվոլը։\n * \n * Վերադարձնում է:\n * - char*: Տող, որը պարունակում է ամբողջ թիվը և սիմվոլը, բաժանված ստորակետով։\n * \n * Օրինակ:\n * f_24(234, 'H') վերադարձնում է \"234,H\"\n */\nchar* f_24(int integer_value, char char_value)", "bn": "#include <bits/stdc++.h>\n/**\n * একটি পূর্ণসংখ্যা এবং একটি অক্ষর পড়ে, তারপর সেগুলিকে কমা দ্বারা পৃথক একটি ফরম্যাটেড স্ট্রিং হিসাবে ফেরত দেয়।\n * \n * প্যারামিটার:\n * - integer_value (int): ইনপুট পূর্ণসংখ্যা।\n * - char_value (char): ইনপুট অক্ষর।\n * \n * ফেরত দেয়:\n * - char*: একটি স্ট্রিং যা পূর্ণসংখ্যা এবং অক্ষরকে কমা দ্বারা পৃথক করে।\n * \n * উদাহরণ:\n * f_24(234, 'H') \"234,H\" ফেরত দেয়\n */\nchar* f_24(int integer_value, char char_value)", "bg": "#include <bits/stdc++.h>\n/**\n * Чете цяло число и символ, след което ги връща като форматиран низ, разделен със запетая.\n * \n * Параметри:\n * - integer_value (int): Входното цяло число.\n * - char_value (char): Входният символ.\n * \n * Връща:\n * - char*: Низ, съдържащ цялото число и символа, разделени със запетая.\n * \n * Пример:\n * f_24(234, 'H') връща \"234,H\"\n */\nchar* f_24(int integer_value, char char_value)", "zh": "#include <bits/stdc++.h>\n/**\n * 读取一个整数和一个字符，然后将它们作为用逗号分隔的格式化字符串返回。\n * \n * 参数:\n * - integer_value (int): 输入的整数。\n * - char_value (char): 输入的字符。\n * \n * 返回:\n * - char*: 包含整数和字符并用逗号分隔的字符串。\n * \n * 示例:\n * f_24(234, 'H') returns \"234,H\"\n */\nchar* f_24(int integer_value, char char_value)", "fr": "#include <bits/stdc++.h>\n/**\n * Lit un entier et un caractère, puis les renvoie sous forme de chaîne formatée séparée par une virgule.\n * \n * Paramètres :\n * - integer_value (int) : L'entier d'entrée.\n * - char_value (char) : Le caractère d'entrée.\n * \n * Renvoie :\n * - char* : Une chaîne contenant l'entier et le caractère séparés par une virgule.\n * \n * Exemple :\n * f_24(234, 'H') returns \"234,H\"\n */\nchar* f_24(int integer_value, char char_value)", "de": "#include <bits/stdc++.h>\n/**\n * Liest eine Ganzzahl und ein Zeichen ein und gibt sie dann als formatierte Zeichenkette, getrennt durch ein Komma, zurück.\n * \n * Parameter:\n * - integer_value (int): Die Eingabeganzzahl.\n * - char_value (char): Das Eingabezeichen.\n * \n * Rückgabe:\n * - char*: Eine Zeichenkette, die die Ganzzahl und das Zeichen, getrennt durch ein Komma, enthält.\n * \n * Beispiel:\n * f_24(234, 'H') gibt \"234,H\" zurück\n */\nchar* f_24(int integer_value, char char_value)", "ha": "#include <bits/stdc++.h>\n/**\n * Karanta lamba da harafi, sannan ya mayar da su a matsayin jeren rubutu da aka raba da alamar kwafi.\n * \n * Sigogi:\n * - integer_value (int): Lambar da aka shigar.\n * - char_value (char): Harafin da aka shigar.\n * \n * Komawa:\n * - char*: Jeren rubutu da ke dauke da lambar da harafin da aka raba da alamar kwafi.\n * \n * Misali:\n * f_24(234, 'H') returns \"234,H\"\n */\nchar* f_24(int integer_value, char char_value)", "hi": "#include <bits/stdc++.h>\n/**\n * एक पूर्णांक और एक वर्ण पढ़ता है, फिर उन्हें अल्पविराम से अलग किए गए स्वरूपित स्ट्रिंग के रूप में लौटाता है।\n * \n * पैरामीटर्स:\n * - integer_value (int): इनपुट पूर्णांक।\n * - char_value (char): इनपुट वर्ण।\n * \n * रिटर्न्स:\n * - char*: एक स्ट्रिंग जिसमें पूर्णांक और वर्ण अल्पविराम से अलग किए गए होते हैं।\n * \n * उदाहरण:\n * f_24(234, 'H') \"234,H\" लौटाता है\n */\nchar* f_24(int integer_value, char char_value)", "hu": "#include <bits/stdc++.h>\n/**\n * Beolvas egy egész számot és egy karaktert, majd visszaadja őket egy formázott, vesszővel elválasztott karakterláncként.\n * \n * Paraméterek:\n * - integer_value (int): A bemeneti egész szám.\n * - char_value (char): A bemeneti karakter.\n * \n * Visszatérési érték:\n * - char*: Egy karakterlánc, amely az egész számot és a karaktert vesszővel elválasztva tartalmazza.\n * \n * Példa:\n * f_24(234, 'H') visszaadja \"234,H\"\n */\nchar* f_24(int integer_value, char char_value)", "es": "#include <bits/stdc++.h>\n/**\n * Lee un entero y un carácter, luego los devuelve como una cadena formateada separada por una coma.\n * \n * Parámetros:\n * - integer_value (int): El entero de entrada.\n * - char_value (char): El carácter de entrada.\n * \n * Devuelve:\n * - char*: Una cadena que contiene el entero y el carácter separados por una coma.\n * \n * Ejemplo:\n * f_24(234, 'H') returns \"234,H\"\n */\nchar* f_24(int integer_value, char char_value)", "arb": "#include <bits/stdc++.h>\n/**\n * يقرأ عددًا صحيحًا وحرفًا، ثم يعيدهما كسلسلة نصية منسقة مفصولة بفاصلة.\n * \n * المعاملات:\n * - integer_value (int): العدد الصحيح المدخل.\n * - char_value (char): الحرف المدخل.\n * \n * يعيد:\n * - char*: سلسلة نصية تحتوي على العدد الصحيح والحرف مفصولين بفاصلة.\n * \n * مثال:\n * f_24(234, 'H') returns \"234,H\"\n */\nchar* f_24(int integer_value, char char_value)", "sw": "#include <bits/stdc++.h>\n/**\n * Husoma nambari kamili na herufi, kisha kuzirudisha kama mfuatano wa maandishi uliopangwa kwa koma.\n * \n * Vigezo:\n * - integer_value (int): Nambari kamili ya ingizo.\n * - char_value (char): Herufi ya ingizo.\n * \n * Inarudisha:\n * - char*: Mfuatano wa maandishi unaojumuisha nambari kamili na herufi zilizotenganishwa na koma.\n * \n * Mfano:\n * f_24(234, 'H') inarudisha \"234,H\"\n */\nchar* f_24(int integer_value, char char_value)", "tr": "#include <bits/stdc++.h>\n/**\n * Bir tam sayı ve bir karakter okur, ardından bunları virgülle ayrılmış biçimlendirilmiş bir dize olarak döndürür.\n * \n * Parametreler:\n * - integer_value (int): Girdi tam sayısı.\n * - char_value (char): Girdi karakteri.\n * \n * Döndürür:\n * - char*: Tam sayı ve karakteri virgülle ayrılmış bir dize olarak içeren bir dize.\n * \n * Örnek:\n * f_24(234, 'H') \"234,H\" döndürür\n */\nchar* f_24(int integer_value, char char_value)", "vi": "#include <bits/stdc++.h>\n/**\n * Đọc một số nguyên và một ký tự, sau đó trả về chúng dưới dạng một chuỗi định dạng được ngăn cách bằng dấu phẩy.\n * \n * Tham số:\n * - integer_value (int): Số nguyên đầu vào.\n * - char_value (char): Ký tự đầu vào.\n * \n * Trả về:\n * - char*: Một chuỗi chứa số nguyên và ký tự được ngăn cách bằng dấu phẩy.\n * \n * Ví dụ:\n * f_24(234, 'H') trả về \"234,H\"\n */\nchar* f_24(int integer_value, char char_value)", "id": "#include <bits/stdc++.h>\n/**\n * Membaca sebuah bilangan bulat dan sebuah karakter, kemudian mengembalikannya sebagai string yang diformat dipisahkan oleh koma.\n * \n * Parameter:\n * - integer_value (int): Bilangan bulat masukan.\n * - char_value (char): Karakter masukan.\n * \n * Mengembalikan:\n * - char*: Sebuah string yang berisi bilangan bulat dan karakter dipisahkan oleh koma.\n * \n * Contoh:\n * f_24(234, 'H') mengembalikan \"234,H\"\n */\nchar* f_24(int integer_value, char char_value)", "ja": "#include <bits/stdc++.h>\n/**\n * 整数と文字を読み取り、カンマで区切られたフォーマットされた文字列として返します。\n * \n * パラメータ:\n * - integer_value (int): 入力整数。\n * - char_value (char): 入力文字。\n * \n * 戻り値:\n * - char*: 整数と文字をカンマで区切った文字列。\n * \n * 例:\n * f_24(234, 'H') returns \"234,H\"\n */\nchar* f_24(int integer_value, char char_value)", "ko": "#include <bits/stdc++.h>\n/**\n * 정수와 문자를 읽고, 쉼표로 구분된 형식의 문자열로 반환합니다.\n * \n * 매개변수:\n * - integer_value (int): 입력 정수.\n * - char_value (char): 입력 문자.\n * \n * 반환값:\n * - char*: 정수와 문자가 쉼표로 구분된 문자열.\n * \n * 예시:\n * f_24(234, 'H') returns \"234,H\"\n */\nchar* f_24(int integer_value, char char_value)", "ml": "#include <bits/stdc++.h>\n/**\n * ഒരു പൂർണ്ണസംഖ്യയും ഒരു അക്ഷരവും വായിച്ച് അവയെ കോമയാൽ വേർതിരിച്ച ഫോർമാറ്റ് ചെയ്ത സ്ട്രിംഗായി തിരികെ നൽകുന്നു.\n * \n * പാരാമീറ്ററുകൾ:\n * - integer_value (int): ഇൻപുട്ട് പൂർണ്ണസംഖ്യ.\n * - char_value (char): ഇൻപുട്ട് അക്ഷരം.\n * \n * തിരികെ നൽകുന്നു:\n * - char*: പൂർണ്ണസംഖ്യയും അക്ഷരവും കോമയാൽ വേർതിരിച്ച സ്ട്രിംഗ്.\n * \n * ഉദാഹരണം:\n * f_24(234, 'H') \"234,H\" തിരികെ നൽകുന്നു\n */\nchar* f_24(int integer_value, char char_value)", "fa": "#include <bits/stdc++.h>\n/**\n * یک عدد صحیح و یک کاراکتر را می‌خواند، سپس آن‌ها را به صورت یک رشته قالب‌بندی شده که با ویرگول جدا شده‌اند، برمی‌گرداند.\n * \n * پارامترها:\n * - integer_value (int): عدد صحیح ورودی.\n * - char_value (char): کاراکتر ورودی.\n * \n * برمی‌گرداند:\n * - char*: یک رشته که شامل عدد صحیح و کاراکتر است که با ویرگول جدا شده‌اند.\n * \n * مثال:\n * f_24(234, 'H') returns \"234,H\"\n */\nchar* f_24(int integer_value, char char_value)"}, "canonical_solution": "{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}", "instruction": {"en": "Write a CPP function `char* f_24(int integer_value, char char_value)` to solve the following problem:\nReads an integer and a character, then returns them as a formatted string separated by a comma.\n\nParameters:\n- integer_value (int): The input integer.\n- char_value (char): The input character.\n\nReturns:\n- char*: A string containing the integer and character separated by a comma.\n\nExample:\nf_24(234, 'H') returns \"234,H\"", "sq": "Shkruani një funksion CPP `char* f_24(int integer_value, char char_value)` për të zgjidhur problemin e mëposhtëm:\nLexon një numër të plotë dhe një karakter, pastaj i kthen ato si një varg i formatuar i ndarë nga një presje.\n\nParametrat:\n- integer_value (int): Numri i plotë i dhënë si hyrje.\n- char_value (char): Karakteri i dhënë si hyrje.\n\nKthen:\n- char*: Një varg që përmban numrin e plotë dhe karakterin e ndarë nga një presje.\n\nShembull:\nf_24(234, 'H') kthen \"234,H\"", "hy": "Գրեք CPP ֆունկցիա `char* f_24(int integer_value, char char_value)` հետևյալ խնդիրը լուծելու համար:\nԿարդում է ամբողջ թիվ և սիմվոլ, ապա վերադարձնում է դրանք ձևաչափված տողում, որը բաժանված է ստորակետով։\n\nՊարամետրեր:\n- integer_value (int): Մուտքային ամբողջ թիվը։\n- char_value (char): Մուտքային սիմվոլը։\n\nՎերադարձնում է:\n- char*: Տող, որը պարունակում է ամբողջ թիվը և սիմվոլը, բաժանված ստորակետով։\n\nՕրինակ:\nf_24(234, 'H') վերադարձնում է \"234,H\"", "bn": "একটি CPP ফাংশন `char* f_24(int integer_value, char char_value)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি পূর্ণসংখ্যা এবং একটি অক্ষর পড়ে, তারপর সেগুলি একটি ফরম্যাট করা স্ট্রিং হিসাবে কমা দ্বারা পৃথক করে ফেরত দেয়।\n\nপ্যারামিটারসমূহ:\n- integer_value (int): ইনপুট পূর্ণসংখ্যা।\n- char_value (char): ইনপুট অক্ষর।\n\nফেরত দেয়:\n- char*: একটি স্ট্রিং যা পূর্ণসংখ্যা এবং অক্ষরকে কমা দ্বারা পৃথক করে ধারণ করে।\n\nউদাহরণ:\nf_24(234, 'H') \"234,H\" ফেরত দেয়।", "bg": "Напишете CPP функция `char* f_24(int integer_value, char char_value)`, за да решите следния проблем:\nЧете цяло число и символ, след което ги връща като форматиран низ, разделен със запетая.\n\nПараметри:\n- integer_value (int): Входното цяло число.\n- char_value (char): Входният символ.\n\nВръща:\n- char*: Низ, съдържащ цялото число и символа, разделени със запетая.\n\nПример:\nf_24(234, 'H') връща \"234,H\"", "zh": "编写一个 CPP 函数 `char* f_24(int integer_value, char char_value)` 来解决以下问题：\n读取一个整数和一个字符，然后将它们作为一个格式化的字符串返回，字符串以逗号分隔。\n\n参数：\n- integer_value (int): 输入的整数。\n- char_value (char): 输入的字符。\n\n返回：\n- char*: 一个包含整数和字符并以逗号分隔的字符串。\n\n示例：\nf_24(234, 'H') 返回 \"234,H\"", "fr": "Écrire une fonction CPP `char* f_24(int integer_value, char char_value)` pour résoudre le problème suivant :\nLit un entier et un caractère, puis les renvoie sous forme de chaîne formatée séparée par une virgule.\n\nParamètres :\n- integer_value (int) : L'entier d'entrée.\n- char_value (char) : Le caractère d'entrée.\n\nRenvoie :\n- char* : Une chaîne contenant l'entier et le caractère séparés par une virgule.\n\nExemple :\nf_24(234, 'H') renvoie \"234,H\"", "de": "Schreiben Sie eine CPP-Funktion `char* f_24(int integer_value, char char_value)`, um das folgende Problem zu lösen:\nLiest eine ganze Zahl und ein Zeichen und gibt sie dann als formatierten String, getrennt durch ein Komma, zurück.\n\nParameter:\n- integer_value (int): Die Eingabe-Ganzzahl.\n- char_value (char): Das Eingabe-Zeichen.\n\nRückgabewert:\n- char*: Ein String, der die Ganzzahl und das Zeichen, getrennt durch ein Komma, enthält.\n\nBeispiel:\nf_24(234, 'H') gibt \"234,H\" zurück.", "ha": "Rubuta aikin CPP `char* f_24(int integer_value, char char_value)` don warware matsalar mai zuwa: \n\nKaranta lamba da harafi, sannan ya mayar da su azaman jeren rubutu da aka tsara wanda aka raba su da alamar rubutu.\n\nSigogi:\n- integer_value (int): Lambar shigarwa.\n- char_value (char): Harafin shigarwa.\n\nMayarwa:\n- char*: Jeren rubutu da ke dauke da lamba da harafi da aka raba su da alamar rubutu.\n\nMisali:\nf_24(234, 'H') yana mayar da \"234,H\"", "hi": "`char* f_24(int integer_value, char char_value)` फ़ंक्शन लिखें ताकि निम्नलिखित समस्या का समाधान हो सके:\nएक पूर्णांक और एक अक्षर पढ़ता है, फिर उन्हें एक स्वरूपित स्ट्रिंग के रूप में अल्पविराम द्वारा अलग करके लौटाता है।\n\nपैरामीटर्स:\n- integer_value (int): इनपुट पूर्णांक।\n- char_value (char): इनपुट अक्षर।\n\nरिटर्न्स:\n- char*: एक स्ट्रिंग जिसमें पूर्णांक और अक्षर अल्पविराम द्वारा अलग किए गए होते हैं।\n\nउदाहरण:\nf_24(234, 'H') \"234,H\" लौटाता है।", "hu": "Írj egy CPP függvényt `char* f_24(int integer_value, char char_value)` a következő probléma megoldására:\nBeolvas egy egész számot és egy karaktert, majd visszaadja őket egy formázott karakterláncként, vesszővel elválasztva.\n\nParaméterek:\n- integer_value (int): A bemeneti egész szám.\n- char_value (char): A bemeneti karakter.\n\nVisszatérési érték:\n- char*: Egy karakterlánc, amely tartalmazza az egész számot és a karaktert vesszővel elválasztva.\n\nPélda:\nf_24(234, 'H') visszaadja \"234,H\"", "es": "Escribe una función en CPP `char* f_24(int integer_value, char char_value)` para resolver el siguiente problema:\nLee un entero y un carácter, luego los devuelve como una cadena formateada separada por una coma.\n\nParámetros:\n- integer_value (int): El entero de entrada.\n- char_value (char): El carácter de entrada.\n\nDevuelve:\n- char*: Una cadena que contiene el entero y el carácter separados por una coma.\n\nEjemplo:\nf_24(234, 'H') returns \"234,H\"", "arb": "اكتب دالة CPP `char* f_24(int integer_value, char char_value)` لحل المشكلة التالية:\nيقرأ عددًا صحيحًا وحرفًا، ثم يعيدهما كسلسلة منسقة مفصولة بفاصلة.\n\nالمعلمات:\n- integer_value (int): العدد الصحيح المدخل.\n- char_value (char): الحرف المدخل.\n\nيعيد:\n- char*: سلسلة تحتوي على العدد الصحيح والحرف مفصولين بفاصلة.\n\nمثال:\nf_24(234, 'H') returns \"234,H\"", "sw": "Andika kazi ya CPP `char* f_24(int integer_value, char char_value)` kutatua tatizo lifuatalo:\nHusoma nambari nzima na herufi, kisha huzirudisha kama kamba iliyopangwa ikitenganishwa na koma.\n\nVigezo:\n- integer_value (int): Nambari nzima ya ingizo.\n- char_value (char): Herufi ya ingizo.\n\nInarejesha:\n- char*: Kamba inayojumuisha nambari nzima na herufi ikitenganishwa na koma.\n\nMfano:\nf_24(234, 'H') inarejesha \"234,H\"", "tr": "Bir CPP fonksiyonu `char* f_24(int integer_value, char char_value)` yazın ve aşağıdaki problemi çözün:\nBir tam sayı ve bir karakter okur, ardından bunları virgülle ayrılmış biçimlendirilmiş bir dize olarak döndürür.\n\nParametreler:\n- integer_value (int): Girdi tam sayısı.\n- char_value (char): Girdi karakteri.\n\nDöndürülenler:\n- char*: Virgülle ayrılmış tam sayı ve karakter içeren bir dize.\n\nÖrnek:\nf_24(234, 'H') \"234,H\" döndürür.", "vi": "Viết một hàm CPP `char* f_24(int integer_value, char char_value)` để giải quyết vấn đề sau:\nĐọc một số nguyên và một ký tự, sau đó trả về chúng dưới dạng một chuỗi định dạng được phân tách bằng dấu phẩy.\n\nTham số:\n- integer_value (int): Số nguyên đầu vào.\n- char_value (char): Ký tự đầu vào.\n\nTrả về:\n- char*: Một chuỗi chứa số nguyên và ký tự được phân tách bằng dấu phẩy.\n\nVí dụ:\nf_24(234, 'H') trả về \"234,H\"", "id": "Tulis fungsi CPP `char* f_24(int integer_value, char char_value)` untuk menyelesaikan masalah berikut:\nMembaca sebuah bilangan bulat dan sebuah karakter, kemudian mengembalikannya sebagai string terformat yang dipisahkan oleh koma.\n\nParameter:\n- integer_value (int): Bilangan bulat masukan.\n- char_value (char): Karakter masukan.\n\nMengembalikan:\n- char*: Sebuah string yang berisi bilangan bulat dan karakter yang dipisahkan oleh koma.\n\nContoh:\nf_24(234, 'H') mengembalikan \"234,H\"", "ja": "CPP関数 `char* f_24(int integer_value, char char_value)` を作成して、次の問題を解決してください:\n整数と文字を読み取り、それらをカンマで区切ったフォーマットされた文字列として返します。\n\nパラメータ:\n- integer_value (int): 入力される整数。\n- char_value (char): 入力される文字。\n\n戻り値:\n- char*: カンマで区切られた整数と文字を含む文字列。\n\n例:\nf_24(234, 'H') は \"234,H\" を返します。", "ko": "CPP 함수를 작성하십시오 `char* f_24(int integer_value, char char_value)` 다음 문제를 해결하기 위해:\n정수와 문자를 읽은 다음, 쉼표로 구분된 형식의 문자열로 반환합니다.\n\n매개변수:\n- integer_value (int): 입력 정수.\n- char_value (char): 입력 문자.\n\n반환:\n- char*: 쉼표로 구분된 정수와 문자를 포함하는 문자열.\n\n예시:\nf_24(234, 'H') returns \"234,H\"", "ml": "CPP ഫങ്ഷൻ `char* f_24(int integer_value, char char_value)` എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nഒരു പൂർണ്ണസംഖ്യയും ഒരു അക്ഷരവും വായിച്ച് അവയെ കോമയാൽ വേർതിരിച്ച ഫോർമാറ്റ് ചെയ്ത സ്ട്രിംഗായി തിരികെ നൽകുന്നു.\n\nപാരാമീറ്ററുകൾ:\n- integer_value (int): ഇൻപുട്ട് പൂർണ്ണസംഖ്യ.\n- char_value (char): ഇൻപുട്ട് അക്ഷരം.\n\nമടക്കം:\n- char*: കോമയാൽ വേർതിരിച്ച പൂർണ്ണസംഖ്യയും അക്ഷരവും അടങ്ങിയ ഒരു സ്ട്രിംഗ്.\n\nഉദാഹരണം:\nf_24(234, 'H') \"234,H\" മടക്കം നൽകുന്നു.", "fa": "یک تابع CPP به نام `char* f_24(int integer_value, char char_value)` بنویسید تا مسئله زیر را حل کند:\nیک عدد صحیح و یک کاراکتر را می‌خواند، سپس آن‌ها را به صورت یک رشته قالب‌بندی شده که با کاما جدا شده‌اند برمی‌گرداند.\n\nپارامترها:\n- integer_value (int): عدد صحیح ورودی.\n- char_value (char): کاراکتر ورودی.\n\nبازگشتی:\n- char*: یک رشته که حاوی عدد صحیح و کاراکتر است که با کاما جدا شده‌اند.\n\nمثال:\nf_24(234, 'H') مقدار \"234,H\" را برمی‌گرداند."}, "level": "middle", "test": "int main() {\n    // Test 1\n    char* output1 = f_24(234, 'H');\n    assert(strcmp(output1, \"234,H\") == 0);\n    free(output1); // Don't forget to free the allocated memory\n\n    // Additional tests can be added here with different input values\n    // Test 2\n    char* output2 = f_24(123, 'A');\n    assert(strcmp(output2, \"123,A\") == 0);\n    free(output2);\n\n    // Test 3\n    char* output3 = f_24(0, 'Z');\n    assert(strcmp(output3, \"0,Z\") == 0);\n    free(output3);\n\n    return 0;\n}", "entry_point": "f_24", "signature": "char* f_24(int integer_value, char char_value)", "docstring": {"en": "Reads an integer and a character, then returns them as a formatted string separated by a comma.\n\nParameters:\n- integer_value (int): The input integer.\n- char_value (char): The input character.\n\nReturns:\n- char*: A string containing the integer and character separated by a comma.\n\nExample:\nf_24(234, 'H') returns \"234,H\"", "sq": "Lexon një numër të plotë dhe një karakter, pastaj i kthen ato si një varg i formatuar i ndarë me presje.\n\nParametrat:\n- integer_value (int): Numri i plotë i dhënë si hyrje.\n- char_value (char): Karakteri i dhënë si hyrje.\n\nKthen:\n- char*: Një varg që përmban numrin e plotë dhe karakterin e ndarë me presje.\n\nShembull:\nf_24(234, 'H') kthen \"234,H\"", "hy": "Կարդում է ամբողջ թիվ և սիմվոլ, ապա վերադարձնում է դրանք որպես ձևաչափված տող, որոնք բաժանված են ստորակետով։\n\nՊարամետրեր:\n- integer_value (int): Մուտքային ամբողջ թիվը։\n- char_value (char): Մուտքային սիմվոլը։\n\nՎերադարձնում է:\n- char*: Տող, որը պարունակում է ամբողջ թիվը և սիմվոլը, բաժանված ստորակետով։\n\nՕրինակ:\nf_24(234, 'H') վերադարձնում է \"234,H\"", "bn": "একটি পূর্ণসংখ্যা এবং একটি চরিত্র পড়ে, তারপর সেগুলিকে একটি কমা দ্বারা পৃথক করা ফরম্যাট করা স্ট্রিং হিসাবে ফেরত দেয়।\n\nপ্যারামিটার:\n- integer_value (int): ইনপুট পূর্ণসংখ্যা।\n- char_value (char): ইনপুট চরিত্র।\n\nফেরত:\n- char*: একটি স্ট্রিং যা পূর্ণসংখ্যা এবং চরিত্রকে একটি কমা দ্বারা পৃথক করে ধারণ করে।\n\nউদাহরণ:\nf_24(234, 'H') \"234,H\" ফেরত দেয়।", "bg": "Чете цяло число и символ, след което ги връща като форматиран низ, разделен със запетая.\n\nПараметри:\n- integer_value (int): Входното цяло число.\n- char_value (char): Входният символ.\n\nВръща:\n- char*: Низ, съдържащ цялото число и символа, разделени със запетая.\n\nПример:\nf_24(234, 'H') връща \"234,H\"", "zh": "读取一个整数和一个字符，然后将它们作为用逗号分隔的格式化字符串返回。\n\n参数：\n- integer_value (int): 输入的整数。\n- char_value (char): 输入的字符。\n\n返回：\n- char*: 一个包含整数和字符并用逗号分隔的字符串。\n\n示例：\nf_24(234, 'H') 返回 \"234,H\"", "fr": "Lit un entier et un caractère, puis les renvoie sous forme de chaîne formatée séparée par une virgule.\n\nParamètres :\n- integer_value (int) : L'entier d'entrée.\n- char_value (char) : Le caractère d'entrée.\n\nRenvoie :\n- char* : Une chaîne contenant l'entier et le caractère séparés par une virgule.\n\nExemple :\nf_24(234, 'H') renvoie \"234,H\"", "de": "Liest eine ganze Zahl und ein Zeichen ein und gibt sie als formatierten String getrennt durch ein Komma zurück.\n\nParameter:\n- integer_value (int): Die Eingabe-Ganzzahl.\n- char_value (char): Das Eingabe-Zeichen.\n\nRückgabe:\n- char*: Ein String, der die Ganzzahl und das Zeichen durch ein Komma getrennt enthält.\n\nBeispiel:\nf_24(234, 'H') gibt \"234,H\" zurück.", "ha": "Karanta wata lamba da wata alama, sannan ya mayar da su a matsayin wani tsari na rubutu da aka raba su da alamar kwafa.\n\nSigogi:\n- integer_value (int): Lambar shigarwa.\n- char_value (char): Alamar shigarwa.\n\nDawowa:\n- char*: Wani rubutu da ke dauke da lambar da alamar da aka raba su da alamar kwafa.\n\nMisali:\nf_24(234, 'H') yana dawowa \"234,H\"", "hi": "एक पूर्णांक और एक वर्ण पढ़ता है, फिर उन्हें अल्पविराम से अलग किए गए स्वरूपित स्ट्रिंग के रूप में लौटाता है।\n\nमापदंड:\n- integer_value (int): इनपुट पूर्णांक।\n- char_value (char): इनपुट वर्ण।\n\nवापसी:\n- char*: एक स्ट्रिंग जिसमें पूर्णांक और वर्ण अल्पविराम से अलग किए गए हैं।\n\nउदाहरण:\nf_24(234, 'H') returns \"234,H\"", "hu": "Beolvas egy egész számot és egy karaktert, majd visszaadja őket egy formázott karakterláncként, vesszővel elválasztva.\n\nParaméterek:\n- integer_value (int): A bemeneti egész szám.\n- char_value (char): A bemeneti karakter.\n\nVisszatérési érték:\n- char*: Egy karakterlánc, amely az egész számot és a karaktert tartalmazza, vesszővel elválasztva.\n\nPélda:\nf_24(234, 'H') visszaadja \"234,H\"", "es": "Lee un entero y un carácter, luego los devuelve como una cadena formateada separada por una coma.\n\nParámetros:\n- integer_value (int): El entero de entrada.\n- char_value (char): El carácter de entrada.\n\nDevuelve:\n- char*: Una cadena que contiene el entero y el carácter separados por una coma.\n\nEjemplo:\nf_24(234, 'H') devuelve \"234,H\"", "arb": "يقرأ عددًا صحيحًا وحرفًا، ثم يعيدهما كسلسلة منسقة مفصولة بفاصلة.\n\nالمعلمات:\n- integer_value (int): العدد الصحيح المدخل.\n- char_value (char): الحرف المدخل.\n\nالقيم المعادة:\n- char*: سلسلة تحتوي على العدد الصحيح والحرف مفصولين بفاصلة.\n\nمثال:\nf_24(234, 'H') يعيد \"234,H\"", "sw": "Husoma nambari kamili na herufi, kisha inazirudisha kama kamba iliyopangwa kwa mtindo wa kutenganishwa na koma.\n\nVigezo:\n- integer_value (int): Nambari kamili ya ingizo.\n- char_value (char): Herufi ya ingizo.\n\nInarudisha:\n- char*: Kamba inayojumuisha nambari kamili na herufi iliyotenganishwa na koma.\n\nMfano:\nf_24(234, 'H') inarudisha \"234,H\"", "tr": "Reads an integer and a character, then returns them as a formatted string separated by a comma.\n\nParametreler:\n- integer_value (int): Girdi tam sayısı.\n- char_value (char): Girdi karakteri.\n\nDöndürür:\n- char*: Tam sayı ve karakteri virgülle ayrılmış bir dize olarak içeren bir dize.\n\nÖrnek:\nf_24(234, 'H') \"234,H\" döndürür.", "vi": "Đọc một số nguyên và một ký tự, sau đó trả về chúng dưới dạng một chuỗi định dạng được ngăn cách bởi dấu phẩy.\n\nTham số:\n- integer_value (int): Số nguyên đầu vào.\n- char_value (char): Ký tự đầu vào.\n\nTrả về:\n- char*: Một chuỗi chứa số nguyên và ký tự được ngăn cách bởi dấu phẩy.\n\nVí dụ:\nf_24(234, 'H') trả về \"234,H\"", "id": "Membaca sebuah bilangan bulat dan sebuah karakter, kemudian mengembalikannya sebagai string yang diformat dipisahkan dengan koma.\n\nParameter:\n- integer_value (int): Bilangan bulat yang dimasukkan.\n- char_value (char): Karakter yang dimasukkan.\n\nMengembalikan:\n- char*: Sebuah string yang berisi bilangan bulat dan karakter yang dipisahkan dengan koma.\n\nContoh:\nf_24(234, 'H') mengembalikan \"234,H\"", "ja": "整数と文字を読み取り、それらをカンマで区切ったフォーマットされた文字列として返します。\n\n引数:\n- integer_value (int): 入力される整数。\n- char_value (char): 入力される文字。\n\n戻り値:\n- char*: 整数と文字をカンマで区切った文字列。\n\n例:\nf_24(234, 'H') は \"234,H\" を返します。", "ko": "정수와 문자를 읽고, 쉼표로 구분된 형식의 문자열로 반환합니다.\n\n매개변수:\n- integer_value (int): 입력 정수.\n- char_value (char): 입력 문자.\n\n반환:\n- char*: 쉼표로 구분된 정수와 문자를 포함하는 문자열.\n\n예제:\nf_24(234, 'H') returns \"234,H\"", "ml": "ഒരു പൂർണ്ണസംഖ്യയും ഒരു അക്ഷരവും വായിച്ച് അവയെ കോമയാൽ വേർതിരിച്ച ഫോർമാറ്റ് ചെയ്ത സ്ട്രിംഗായി തിരികെ നൽകുന്നു.\n\nപാരാമീറ്ററുകൾ:\n- integer_value (int): ഇൻപുട്ട് പൂർണ്ണസംഖ്യ.\n- char_value (char): ഇൻപുട്ട് അക്ഷരം.\n\nമടക്കുന്നു:\n- char*: പൂർണ്ണസംഖ്യയും അക്ഷരവും കോമയാൽ വേർതിരിച്ചുള്ള ഒരു സ്ട്രിംഗ്.\n\nഉദാഹരണം:\nf_24(234, 'H') മടക്കുന്നു \"234,H\"", "fa": "یک عدد صحیح و یک کاراکتر را می‌خواند، سپس آن‌ها را به‌صورت یک رشته قالب‌بندی‌شده که با کاما جدا شده‌اند برمی‌گرداند.\n\nپارامترها:\n- integer_value (int): عدد صحیح ورودی.\n- char_value (char): کاراکتر ورودی.\n\nبازگشتی:\n- char*: یک رشته که شامل عدد صحیح و کاراکتر است و با کاما جدا شده‌اند.\n\nمثال:\nf_24(234, 'H') بازمی‌گرداند \"234,H\""}}
{"task_id": "CPP/25", "prompt": {"en": "#include <bits/stdc++.h>\n/*\nShifts all characters by 5 positions in alphabetical order. Only letters are replaced,\nand all letters are in uppercase.\n\nParameters:\ntext (std::string&): The input text to be processed, modified in place.\n\nReturns:\nstd::string&: The transformed text with characters shifted by 5 positions.\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nstd::string& f_25(std::string& text)", "sq": "#include <bits/stdc++.h>\n/*\nZhvendos të gjitha karakteret me 5 pozicione në rend alfabetik. Vetëm shkronjat zëvendësohen,\ndhe të gjitha shkronjat janë me shkronja të mëdha.\n\nParametrat:\ntext (std::string&): Teksti hyrës që do të përpunohet, modifikohet në vend.\n\nKthen:\nstd::string&: Teksti i transformuar me karaktere të zhvendosura me 5 pozicione.\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nstd::string& f_25(std::string& text)", "hy": "#include <bits/stdc++.h>\n/*\nՏեղաշարժում է բոլոր սիմվոլները 5 դիրքով այբբենական կարգով: Միայն տառերն են փոխարինվում,\nև բոլոր տառերը մեծատառ են:\n\nՊարամետրեր:\ntext (std::string&): Մուտքային տեքստը, որը պետք է մշակվի, փոփոխվում է տեղում:\n\nՎերադարձնում է:\nstd::string&: Փոխակերպված տեքստը, որի սիմվոլները տեղաշարժված են 5 դիրքով:\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nstd::string& f_25(std::string& text)", "bn": "#include <bits/stdc++.h>\n/*\nসমস্ত অক্ষর বর্ণানুক্রমিক ক্রমে ৫ পজিশন সরানো হয়। শুধুমাত্র অক্ষরগুলি প্রতিস্থাপিত হয়,\nএবং সমস্ত অক্ষর বড় হাতের অক্ষরে থাকে।\n\nপ্যারামিটার:\ntext (std::string&): প্রক্রিয়াকরণের জন্য ইনপুট টেক্সট, যা স্থানেই পরিবর্তিত হয়।\n\nফেরত দেয়:\nstd::string&: রূপান্তরিত টেক্সট যার অক্ষরগুলি ৫ পজিশন সরানো হয়েছে।\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nstd::string& f_25(std::string& text)", "bg": "#include <bits/stdc++.h>\n/*\nИзмества всички символи с 5 позиции в азбучен ред. Само букви се заменят,\nи всички букви са с главни букви.\n\nПараметри:\ntext (std::string&): Входният текст, който ще бъде обработен, модифициран на място.\n\nВръща:\nstd::string&: Трансформираният текст с изместени символи с 5 позиции.\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nstd::string& f_25(std::string& text)", "zh": "#include <bits/stdc++.h>\n/*\n将所有字符在字母表中移动5个位置。只有字母被替换，并且所有字母都是大写。\n\n参数：\ntext (std::string&): 要处理的输入文本，原地修改。\n\n返回：\nstd::string&: 字符移动5个位置后的转换文本。\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nstd::string& f_25(std::string& text)", "fr": "#include <bits/stdc++.h>\n/*\nDécale tous les caractères de 5 positions dans l'ordre alphabétique. Seules les lettres sont remplacées,\net toutes les lettres sont en majuscules.\n\nParamètres :\ntext (std::string&): Le texte d'entrée à traiter, modifié sur place.\n\nRenvoie :\nstd::string&: Le texte transformé avec les caractères décalés de 5 positions.\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nstd::string& f_25(std::string& text)", "de": "#include <bits/stdc++.h>\n/*\nVerschiebt alle Zeichen um 5 Positionen in alphabetischer Reihenfolge. Nur Buchstaben werden ersetzt,\nund alle Buchstaben sind in Großbuchstaben.\n\nParameter:\ntext (std::string&): Der Eingabetext, der verarbeitet und an Ort und Stelle modifiziert wird.\n\nRückgabe:\nstd::string&: Der transformierte Text mit um 5 Positionen verschobenen Zeichen.\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nstd::string& f_25(std::string& text)", "ha": "#include <bits/stdc++.h>\n/*\nCanza duk haruffa ta wurin matsar da su wurare 5 a cikin tsarin haruffa. Haruffa kawai ake maye gurbinsu,\nkuma duk haruffa suna cikin manyan baƙaƙe.\n\nSigogi:\ntext (std::string&): Rubutun shigarwa da za a sarrafa, ana gyara shi a wurin.\n\nDawowa:\nstd::string&: Rubutun da aka canza tare da haruffa da aka matsar da wurare 5.\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nstd::string& f_25(std::string& text)", "hi": "#include <bits/stdc++.h>\n/*\nसभी वर्णों को वर्णमाला क्रम में 5 स्थानों से स्थानांतरित करता है। केवल अक्षरों को बदला जाता है,\nऔर सभी अक्षर बड़े अक्षरों में होते हैं।\n\nपैरामीटर्स:\ntext (std::string&): वह इनपुट टेक्स्ट जिसे संसाधित किया जाना है, स्थान पर ही संशोधित किया गया।\n\nवापसी:\nstd::string&: परिवर्तित टेक्स्ट जिसमें वर्ण 5 स्थानों से स्थानांतरित होते हैं।\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nstd::string& f_25(std::string& text)", "hu": "#include <bits/stdc++.h>\n/*\nEltolja az összes karaktert 5 pozícióval az ábécében. Csak a betűk kerülnek cserére,\nés minden betű nagybetűs.\n\nParaméterek:\ntext (std::string&): A feldolgozandó bemeneti szöveg, amely helyben módosul.\n\nVisszatér:\nstd::string&: Az átalakított szöveg, amelynek karakterei 5 pozícióval eltolódtak.\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nstd::string& f_25(std::string& text)", "es": "#include <bits/stdc++.h>\n/*\nDesplaza todos los caracteres 5 posiciones en orden alfabético. Solo se reemplazan las letras,\ny todas las letras están en mayúsculas.\n\nParámetros:\ntext (std::string&): El texto de entrada a procesar, modificado en su lugar.\n\nDevuelve:\nstd::string&: El texto transformado con caracteres desplazados 5 posiciones.\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nstd::string& f_25(std::string& text)", "arb": "#include <bits/stdc++.h>\n/*\nينقل جميع الأحرف بمقدار 5 مواقع في الترتيب الأبجدي. يتم استبدال الأحرف فقط،\nوجميع الأحرف تكون بحروف كبيرة.\n\nالمعلمات:\ntext (std::string&): النص المدخل ليتم معالجته، يتم تعديله في مكانه.\n\nيُرجع:\nstd::string&: النص المحول مع الأحرف التي تم نقلها بمقدار 5 مواقع.\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nstd::string& f_25(std::string& text)", "sw": "#include <bits/stdc++.h>\n/*\nInasogeza herufi zote kwa nafasi 5 katika mpangilio wa alfabeti. Ni herufi pekee zinazobadilishwa,\nna herufi zote ziko katika herufi kubwa.\n\nVigezo:\ntext (std::string&): Maandishi ya ingizo yanayopaswa kushughulikiwa, yanabadilishwa papo hapo.\n\nInarejesha:\nstd::string&: Maandishi yaliyobadilishwa na herufi zilizohamishwa kwa nafasi 5.\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nstd::string& f_25(std::string& text)", "tr": "#include <bits/stdc++.h>\n/*\nTüm karakterleri alfabetik sırada 5 pozisyon kaydırır. Sadece harfler değiştirilir\nve tüm harfler büyük harfle yazılır.\n\nParametreler:\ntext (std::string&): İşlenecek giriş metni, yerinde değiştirilir.\n\nDöndürür:\nstd::string&: Karakterlerin 5 pozisyon kaydırıldığı dönüştürülmüş metin.\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nstd::string& f_25(std::string& text)", "vi": "#include <bits/stdc++.h>\n/*\nDịch chuyển tất cả các ký tự 5 vị trí trong thứ tự bảng chữ cái. Chỉ các chữ cái được thay thế,\nvà tất cả các chữ cái đều ở dạng chữ hoa.\n\nTham số:\ntext (std::string&): Văn bản đầu vào cần được xử lý, được sửa đổi tại chỗ.\n\nTrả về:\nstd::string&: Văn bản đã được biến đổi với các ký tự được dịch chuyển 5 vị trí.\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nstd::string& f_25(std::string& text)", "id": "#include <bits/stdc++.h>\n/*\nMenggeser semua karakter sebanyak 5 posisi dalam urutan alfabet. Hanya huruf yang diganti,\ndan semua huruf dalam huruf besar.\n\nParameter:\ntext (std::string&): Teks masukan yang akan diproses, dimodifikasi di tempat.\n\nMengembalikan:\nstd::string&: Teks yang telah diubah dengan karakter digeser sebanyak 5 posisi.\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nstd::string& f_25(std::string& text)", "ja": "#include <bits/stdc++.h>\n/*\nアルファベット順で全ての文字を5文字分シフトします。置き換えられるのは文字のみで、\n全ての文字は大文字です。\n\nパラメータ:\ntext (std::string&): 処理される入力テキストで、インプレースで変更されます。\n\n戻り値:\nstd::string&: 文字が5文字分シフトされた変換後のテキスト。\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nstd::string& f_25(std::string& text)", "ko": "#include <bits/stdc++.h>\n/*\n알파벳 순서에서 모든 문자를 5자리 이동시킵니다. 문자만 대체되며,\n모든 문자는 대문자입니다.\n\n매개변수:\ntext (std::string&): 처리할 입력 텍스트로, 제자리에서 수정됩니다.\n\n반환값:\nstd::string&: 문자가 5자리 이동된 변형된 텍스트입니다.\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nstd::string& f_25(std::string& text)", "ml": "#include <bits/stdc++.h>\n/*\nഅക്ഷരമാല ക്രമത്തിൽ എല്ലാ അക്ഷരങ്ങളും 5 സ്ഥാനങ്ങൾ മാറ്റുന്നു. അക്ഷരങ്ങൾ മാത്രമാണ് മാറ്റപ്പെടുന്നത്,\nഎല്ലാ അക്ഷരങ്ങളും വലിയക്ഷരങ്ങളായിരിക്കും.\n\nപാരാമീറ്ററുകൾ:\ntext (std::string&): പ്രോസസ്സ് ചെയ്യേണ്ട ഇൻപുട്ട് ടെക്സ്റ്റ്, ഇത് സ്ഥലം മാറ്റി മാറ്റുന്നു.\n\nമടങ്ങിവരവ്:\nstd::string&: 5 സ്ഥാനങ്ങൾ മാറ്റിയ അക്ഷരങ്ങളുള്ള പരിവർത്തിത ടെക്സ്റ്റ്.\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nstd::string& f_25(std::string& text)", "fa": "#include <bits/stdc++.h>\n/*\nتمام حروف را به اندازه ۵ موقعیت در ترتیب حروف الفبا جابجا می‌کند. فقط حروف جایگزین می‌شوند\nو همه حروف به صورت بزرگ هستند.\n\nپارامترها:\ntext (std::string&): متنی که باید پردازش شود، به صورت درجا تغییر می‌کند.\n\nبرمی‌گرداند:\nstd::string&: متن تغییر یافته با حروفی که به اندازه ۵ موقعیت جابجا شده‌اند.\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nstd::string& f_25(std::string& text)"}, "canonical_solution": "{\n    size_t len = text.length();\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}", "instruction": {"en": "Write a CPP function `std::string& f_25(std::string& text)` to solve the following problem:\nShifts all characters by 5 positions in alphabetical order. Only letters are replaced, and all letters are in uppercase.\n\nParameters:\ntext (std::string&): The input text to be processed, modified in place.\n\nReturns:\nstd::string&: The transformed text with characters shifted by 5 positions.\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n", "sq": "Shkruani një funksion CPP `std::string& f_25(std::string& text)` për të zgjidhur problemin e mëposhtëm:\nZhvendos të gjitha karakteret me 5 pozicione në rend alfabetik. Vetëm shkronjat zëvendësohen, dhe të gjitha shkronjat janë me shkronja të mëdha.\n\nParametrat:\ntext (std::string&): Teksti hyrës që do të përpunohet, modifikohet në vend.\n\nKthen:\nstd::string&: Teksti i transformuar me karakteret e zhvendosura me 5 pozicione.\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n", "hy": "Գրեք CPP ֆունկցիա `std::string& f_25(std::string& text)` հետևյալ խնդիրը լուծելու համար:\nՏառերը 5 դիրքով տեղափոխում է այբբենական կարգով: Միայն տառերը են փոխարինվում, և բոլոր տառերը մեծատառ են:\n\nՊարամետրեր:\ntext (std::string&): Մուտքային տեքստը, որը պետք է մշակվի, փոփոխվում է տեղում:\n\nՎերադարձնում է:\nstd::string&: Փոխակերպված տեքստը, որտեղ տառերը տեղափոխված են 5 դիրքով:\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n", "bn": "`std::string& f_25(std::string& text)` ফাংশনটি লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nসমস্ত অক্ষর বর্ণানুক্রমিক ক্রমে ৫ অবস্থানে সরানো হয়। শুধুমাত্র অক্ষরগুলি প্রতিস্থাপিত হয়, এবং সমস্ত অক্ষর বড় হাতের।\n\nপ্যারামিটার:\ntext (std::string&): প্রক্রিয়াকৃত হওয়ার জন্য ইনপুট টেক্সট, স্থানেই পরিবর্তিত হয়।\n\nফেরত দেয়:\nstd::string&: রূপান্তরিত টেক্সট যেখানে অক্ষরগুলি ৫ অবস্থানে সরানো হয়েছে।\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n", "bg": "Напишете CPP функция `std::string& f_25(std::string& text)`, за да решите следния проблем:\nПремества всички символи с 5 позиции в азбучен ред. Само буквите се заменят, и всички букви са с главни букви.\n\nПараметри:\ntext (std::string&): Входният текст, който ще бъде обработен, модифициран на място.\n\nВръща:\nstd::string&: Преобразуваният текст с преместени с 5 позиции символи.\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n", "zh": "编写一个 CPP 函数 `std::string& f_25(std::string& text)` 来解决以下问题：\n将所有字符按字母顺序移动5个位置。只有字母被替换，且所有字母均为大写。\n\n参数：\ntext (std::string&): 要处理的输入文本，原地修改。\n\n返回：\nstd::string&: 字符被移动5个位置后的转换文本。\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n", "fr": "Écrire une fonction CPP `std::string& f_25(std::string& text)` pour résoudre le problème suivant :  \nDécale tous les caractères de 5 positions dans l'ordre alphabétique. Seules les lettres sont remplacées, et toutes les lettres sont en majuscules.\n\nParamètres :  \ntext (std::string&) : Le texte d'entrée à traiter, modifié sur place.\n\nRenvoie :  \nstd::string& : Le texte transformé avec les caractères décalés de 5 positions.\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n", "de": "Schreiben Sie eine CPP-Funktion `std::string& f_25(std::string& text)`, um das folgende Problem zu lösen:\nVerschiebt alle Zeichen um 5 Positionen in alphabetischer Reihenfolge. Nur Buchstaben werden ersetzt, und alle Buchstaben sind in Großbuchstaben.\n\nParameter:\ntext (std::string&): Der zu verarbeitende Eingabetext, der vor Ort modifiziert wird.\n\nRückgabe:\nstd::string&: Der transformierte Text mit um 5 Positionen verschobenen Zeichen.\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n", "ha": "Rubuta aikin CPP `std::string& f_25(std::string& text)` don warware matsalar mai zuwa:\nCanza duk haruffa ta wurin matsar da su wurare 5 a cikin tsarin haruffa. Haruffa kawai ake maye gurbinsu, kuma duk haruffa suna cikin manyan baki.\n\nSigogi:\ntext (std::string&): Rubutun shigar da za a sarrafa, a gyara a wurin.\n\nDawowa:\nstd::string&: Rubutun da aka canza tare da haruffa da aka matsar da su wurare 5.\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n", "hi": "`std::string& f_25(std::string& text)` नामक एक CPP फ़ंक्शन लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nसभी वर्णों को वर्णमाला क्रम में 5 स्थानों से स्थानांतरित करता है। केवल अक्षरों को बदला जाता है, और सभी अक्षर बड़े अक्षरों में होते हैं।\n\nपैरामीटर्स:\ntext (std::string&): इनपुट टेक्स्ट जिसे संसाधित किया जाना है, स्थान पर संशोधित किया गया।\n\nवापसी:\nstd::string&: परिवर्तित टेक्स्ट जिसमें वर्ण 5 स्थानों से स्थानांतरित होते हैं।\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n", "hu": "Írj egy CPP függvényt `std::string& f_25(std::string& text)` a következő probléma megoldására:\nEltol minden karaktert 5 pozícióval az ábécé sorrendjében. Csak a betűk kerülnek cserére, és minden betű nagybetűs.\n\nParaméterek:\ntext (std::string&): A feldolgozandó bemeneti szöveg, amelyet helyben módosítanak.\n\nVisszatér:\nstd::string&: Az átalakított szöveg, amelyben a karakterek 5 pozícióval eltolódtak.\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n", "es": "Escriba una función CPP `std::string& f_25(std::string& text)` para resolver el siguiente problema:\nDesplaza todos los caracteres 5 posiciones en orden alfabético. Solo se reemplazan letras, y todas las letras están en mayúsculas.\n\nParámetros:\ntext (std::string&): El texto de entrada a ser procesado, modificado en su lugar.\n\nDevuelve:\nstd::string&: El texto transformado con caracteres desplazados 5 posiciones.\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "arb": "اكتب دالة CPP `std::string& f_25(std::string& text)` لحل المشكلة التالية:\nتحريك جميع الأحرف بمقدار 5 مواقع في الترتيب الأبجدي. يتم استبدال الحروف فقط، وجميع الحروف تكون بأحرف كبيرة.\n\nالمعلمات:\ntext (std::string&): النص المدخل ليتم معالجته، يتم تعديله في مكانه.\n\nالقيم المعادة:\nstd::string&: النص المحول مع الأحرف المحركة بمقدار 5 مواقع.\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "sw": "Andika kazi ya CPP `std::string& f_25(std::string& text)` kutatua tatizo lifuatalo:\nInasogeza herufi zote kwa nafasi 5 katika mpangilio wa alfabeti. Ni herufi pekee ndizo zinazobadilishwa, na herufi zote ni kubwa.\n\nVigezo:\ntext (std::string&): Maandishi ya kuingiza yatakayoshughulikiwa, kubadilishwa mahali pale pale.\n\nInarejesha:\nstd::string&: Maandishi yaliyobadilishwa na herufi kusogezwa kwa nafasi 5.\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "tr": "Bir CPP fonksiyonu `std::string& f_25(std::string& text)` yazın ve aşağıdaki problemi çözün:\nTüm karakterleri alfabetik sırada 5 pozisyon kaydırır. Sadece harfler değiştirilir ve tüm harfler büyük harfle yazılır.\n\nParametreler:\ntext (std::string&): İşlenecek olan giriş metni, yerinde değiştirilir.\n\nDöndürülenler:\nstd::string&: Karakterleri 5 pozisyon kaydırılmış olan dönüştürülmüş metin.\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "vi": "Viết một hàm CPP `std::string& f_25(std::string& text)` để giải quyết vấn đề sau:\nDịch chuyển tất cả các ký tự theo thứ tự bảng chữ cái thêm 5 vị trí. Chỉ các chữ cái được thay thế, và tất cả các chữ cái đều ở dạng chữ hoa.\n\nTham số:\ntext (std::string&): Văn bản đầu vào cần được xử lý, được sửa đổi tại chỗ.\n\nTrả về:\nstd::string&: Văn bản đã được biến đổi với các ký tự dịch chuyển thêm 5 vị trí.\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "id": "Tulis fungsi CPP `std::string& f_25(std::string& text)` untuk menyelesaikan masalah berikut:\nMenggeser semua karakter sebanyak 5 posisi dalam urutan alfabet. Hanya huruf yang diganti, dan semua huruf dalam huruf besar.\n\nParameter:\ntext (std::string&): Teks input yang akan diproses, dimodifikasi di tempat.\n\nMengembalikan:\nstd::string&: Teks yang telah diubah dengan karakter digeser sebanyak 5 posisi.\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "ja": "`std::string& f_25(std::string& text)`というCPP関数を作成して、次の問題を解決してください:\nアルファベット順で全ての文字を5つの位置だけシフトします。文字は置き換えられ、全ての文字は大文字になります。\n\nパラメータ:\ntext (std::string&): 処理される入力テキストで、インプレースで変更されます。\n\n戻り値:\nstd::string&: 文字が5つの位置でシフトされた変換済みテキスト。\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "ko": "`std::string& f_25(std::string& text)`라는 CPP 함수를 작성하여 다음 문제를 해결하십시오:\n모든 문자를 알파벳 순서로 5자리 이동시킵니다. 문자만 대체되며, 모든 문자는 대문자입니다.\n\n매개변수:\ntext (std::string&): 처리할 입력 텍스트로, 제자리에서 수정됩니다.\n\n반환값:\nstd::string&: 문자가 5자리 이동된 변환된 텍스트.\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "ml": "`std::string& f_25(std::string& text)` എന്ന CPP ഫംഗ്ഷൻ എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nഎല്ലാ അക്ഷരങ്ങളും അക്ഷരമാല ക്രമത്തിൽ 5 സ്ഥാനങ്ങൾ മാറ്റുന്നു. അക്ഷരങ്ങൾ മാത്രമേ മാറ്റപ്പെടുകയുള്ളൂ, എല്ലാ അക്ഷരങ്ങളും അപ്പർകേസിലാണ്.\n\nപാരാമീറ്ററുകൾ:\ntext (std::string&): പ്രോസസ്സ് ചെയ്യേണ്ട ഇൻപുട്ട് ടെക്സ്റ്റ്, സ്ഥലം മാറ്റി മാറ്റം വരുത്തുന്നു.\n\nമടക്കിക്കൊടുക്കുന്നു:\nstd::string&: 5 സ്ഥാനങ്ങൾ മാറ്റിയ അക്ഷരങ്ങളുള്ള പരിവർത്തിത ടെക്സ്റ്റ്.\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "fa": "یک تابع CPP `std::string& f_25(std::string& text)` بنویسید تا مسئله زیر را حل کند:\nتمام کاراکترها را به اندازه ۵ موقعیت در ترتیب حروف الفبا جابجا می‌کند. فقط حروف جایگزین می‌شوند و همه حروف به صورت بزرگ هستند.\n\nپارامترها:\ntext (std::string&): متن ورودی که باید پردازش شود و به صورت درجا تغییر می‌کند.\n\nبازگشت:\nstd::string&: متن تغییر یافته با کاراکترهایی که به اندازه ۵ موقعیت جابجا شده‌اند.\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\""}, "level": "easy", "test": "int main()\n{\n    std::string test1 = \"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\";\n    std::string test2 = \"N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ\";\n    std::string test3 = \"IFSLJW PSTBX KZQQ BJQQ YMFY HFJXFW NX RTWJ IFSLJWTZX YMFS MJ\";\n\n    assert(f_25(test1) == \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\");\n    assert(f_25(test2) == \"I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME\");\n    assert(f_25(test3) == \"DANGER KNOWS FULL WELL THAT CAESAR IS MORE DANGEROUS THAN HE\");\n    return 0;\n}", "entry_point": "f_25", "signature": "std::string& f_25(std::string& text)", "docstring": {"en": "Shifts all characters by 5 positions in alphabetical order. Only letters are replaced, and all letters are in uppercase.\n\nParameters:\ntext (std::string&): The input text to be processed, modified in place.\n\nReturns:\nstd::string&: The transformed text with characters shifted by 5 positions.\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n", "sq": "Zhvendos të gjitha karakteret me 5 pozicione në rend alfabetik. Vetëm shkronjat zëvendësohen, dhe të gjitha shkronjat janë me shkronja të mëdha.\n\nParametrat:\ntext (std::string&): Teksti hyrës që do të përpunohet, modifikohet në vend.\n\nKthen:\nstd::string&: Teksti i transformuar me karaktere të zhvendosura me 5 pozicione.\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "hy": "Տեղաշարժում է բոլոր տառերը 5 դիրքով այբենական կարգով: Միայն տառերն են փոխարինվում, և բոլոր տառերը մեծատառ են:\n\nՊարամետրեր:\ntext (std::string&): Մուտքային տեքստը, որը պետք է մշակվի, փոփոխվում է տեղում:\n\nՎերադարձնում է:\nstd::string&: Փոխակերպված տեքստը, որտեղ տառերը տեղաշարժված են 5 դիրքով:\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "bn": "বর্ণানুক্রমিক ক্রমে সমস্ত অক্ষরকে ৫ অবস্থানে স্থানান্তর করে। শুধুমাত্র অক্ষরগুলি প্রতিস্থাপিত হয়, এবং সমস্ত অক্ষর বড় হাতের হয়।\n\nপ্যারামিটার:\ntext (std::string&): প্রক্রিয়াকরণের জন্য ইনপুট টেক্সট, যা স্থানে পরিবর্তিত হয়।\n\nরিটার্নস:\nstd::string&: পরিবর্তিত টেক্সট যেখানে অক্ষরগুলি ৫ অবস্থানে স্থানান্তরিত হয়েছে।\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "bg": "Измества всички знаци с 5 позиции в азбучен ред. Само буквите се заменят и всички букви са с главни букви.\n\nПараметри:\ntext (std::string&): Входният текст, който ще бъде обработен, модифициран на място.\n\nВръща:\nstd::string&: Преобразуваният текст със знаци, изместени с 5 позиции.\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "zh": "将所有字符在字母表中移动5个位置。仅替换字母，且所有字母均为大写。\n\n参数：\ntext (std::string&): 要处理的输入文本，原地修改。\n\n返回：\nstd::string&: 字符移动5个位置后的转换文本。\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "fr": "Décale tous les caractères de 5 positions dans l'ordre alphabétique. Seules les lettres sont remplacées, et toutes les lettres sont en majuscules.\n\nParamètres :\ntext (std::string&) : Le texte d'entrée à traiter, modifié sur place.\n\nRenvoie :\nstd::string& : Le texte transformé avec les caractères décalés de 5 positions.\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "de": "Verschiebt alle Zeichen um 5 Positionen in alphabetischer Reihenfolge. Nur Buchstaben werden ersetzt, und alle Buchstaben sind in Großbuchstaben.\n\nParameter:\ntext (std::string&): Der zu verarbeitende Eingabetext, der vor Ort modifiziert wird.\n\nRückgabewert:\nstd::string&: Der transformierte Text mit um 5 Positionen verschobenen Zeichen.\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "ha": "Canza duk haruffa ta wurin matsar da su wurare 5 a cikin tsarin haruffa. Haruffa kawai ake maye gurbinsu, kuma duk haruffa suna cikin manyan baki.\n\nSigogi:\ntext (std::string&): Rubutun shigar da za a sarrafa, a gyara a wurin.\n\nDawowa:\nstd::string&: Rubutun da aka canza tare da haruffa da aka matsar da matsayi 5.\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "hi": "अक्षरों को वर्णमाला क्रम में 5 स्थानों से स्थानांतरित करता है। केवल अक्षरों को बदला जाता है, और सभी अक्षर बड़े अक्षरों में होते हैं।\n\nपैरामीटर्स:\ntext (std::string&): इनपुट टेक्स्ट जिसे संसाधित किया जाना है, स्थान पर ही संशोधित किया जाता है।\n\nवापसी:\nstd::string&: परिवर्तित टेक्स्ट जिसमें अक्षर 5 स्थानों से स्थानांतरित होते हैं।\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "hu": "Az összes karaktert 5 pozícióval eltolja az ábécében. Csak a betűk kerülnek cserére, és minden betű nagybetűs.\n\nParaméterek:\ntext (std::string&): A feldolgozandó bemeneti szöveg, amely helyben módosul.\n\nVisszatérési érték:\nstd::string&: Az átalakított szöveg, amelyben a karakterek 5 pozícióval eltolódtak.\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "es": "Desplaza todos los caracteres 5 posiciones en orden alfabético. Solo se reemplazan las letras, y todas las letras están en mayúsculas.\n\nParámetros:\ntext (std::string&): El texto de entrada a procesar, modificado en el lugar.\n\nDevuelve:\nstd::string&: El texto transformado con caracteres desplazados 5 posiciones.\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "arb": "ينقل جميع الأحرف بمقدار 5 مواقع في الترتيب الأبجدي. يتم استبدال الحروف فقط، وجميع الحروف تكون بأحرف كبيرة.\n\nالمعلمات:\ntext (std::string&): النص المدخل ليتم معالجته، يتم تعديله في المكان.\n\nالإرجاع:\nstd::string&: النص المحول مع الأحرف المنقولة بمقدار 5 مواقع.\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "sw": "Hubadilisha herufi zote kwa nafasi 5 katika mpangilio wa alfabeti. Ni herufi pekee ndizo hubadilishwa, na herufi zote ni za herufi kubwa.\n\nVigezo:\ntext (std::string&): Maandishi ya pembejeo yatakayoshughulikiwa, yamebadilishwa papo hapo.\n\nInarejesha:\nstd::string&: Maandishi yaliyobadilishwa na herufi zilizohamishwa kwa nafasi 5.\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "tr": "Alfabetik sırada tüm karakterleri 5 pozisyon kaydırır. Sadece harfler değiştirilir ve tüm harfler büyük harfle yazılır.\n\nParametreler:\ntext (std::string&): İşlenecek giriş metni, yerinde değiştirilir.\n\nDöndürür:\nstd::string&: Karakterleri 5 pozisyon kaydırılmış dönüştürülmüş metin.\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "vi": "Dịch chuyển tất cả các ký tự theo 5 vị trí trong thứ tự bảng chữ cái. Chỉ các chữ cái được thay thế, và tất cả các chữ cái đều ở dạng chữ hoa.\n\nTham số:\ntext (std::string&): Văn bản đầu vào cần được xử lý, được sửa đổi tại chỗ.\n\nTrả về:\nstd::string&: Văn bản đã được biến đổi với các ký tự được dịch chuyển 5 vị trí.\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "id": "Menggeser semua karakter sebanyak 5 posisi dalam urutan alfabet. Hanya huruf yang diganti, dan semua huruf dalam huruf kapital.\n\nParameter:\ntext (std::string&): Teks input yang akan diproses, dimodifikasi di tempat.\n\nMengembalikan:\nstd::string&: Teks yang telah diubah dengan karakter digeser sebanyak 5 posisi.\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "ja": "アルファベット順で全ての文字を5つの位置だけシフトします。文字のみが置き換えられ、全ての文字は大文字です。\n\nパラメータ:\ntext (std::string&): 処理される入力テキストで、インプレースで変更されます。\n\n戻り値:\nstd::string&: 文字が5つの位置だけシフトされた変換後のテキスト。\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "ko": "알파벳 순서에서 모든 문자를 5자리 이동시킵니다. 문자만 대체되며, 모든 문자는 대문자입니다.\n\n매개변수:\ntext (std::string&): 처리할 입력 텍스트로, 제자리에서 수정됩니다.\n\n반환값:\nstd::string&: 문자가 5자리 이동된 변환된 텍스트입니다.\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "ml": "അക്ഷരമാല ക്രമത്തിൽ എല്ലാ അക്ഷരങ്ങളും 5 സ്ഥാനങ്ങൾ മാറ്റുന്നു. അക്ഷരങ്ങൾ മാത്രമേ മാറ്റപ്പെടുകയുള്ളൂ, എല്ലാ അക്ഷരങ്ങളും വലിയവയാണ്.\n\nപാരാമീറ്ററുകൾ:\ntext (std::string&): പ്രോസസ്സ് ചെയ്യേണ്ട, സ്ഥലം മാറ്റം വരുത്തേണ്ട ഇൻപുട്ട് ടെക്സ്റ്റ്.\n\nമടക്കം:\nstd::string&: 5 സ്ഥാനങ്ങൾ മാറ്റിയ അക്ഷരങ്ങളുള്ള പരിവർത്തിത ടെക്സ്റ്റ്.\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "fa": "حروف را به اندازه ۵ موقعیت در ترتیب الفبایی جابجا می‌کند. تنها حروف جایگزین می‌شوند و همه حروف به صورت بزرگ هستند.\n\nپارامترها:\ntext (std::string&): متن ورودی که باید پردازش شود و به صورت درجا تغییر می‌کند.\n\nبازگشتی:\nstd::string&: متن تغییر یافته با حروفی که به اندازه ۵ موقعیت جابجا شده‌اند.\n\n>>> f_25(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\""}}
{"task_id": "CPP/26", "prompt": {"en": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Classify the integer x based on the following method:\n * If x is a single-digit number, x belongs to its own class.\n * Otherwise, sum the digits of x, get a new x, and iterate until \n * the class is determined.\n *\n * Parameters:\n * - x (const char*): The integer to be classified in string form.\n *\n * Returns:\n * int: The class to which the integer x belongs.\n *\n * Usage:\n * >>> f_26(\"24\")\n * 6\n */\nint f_26(const char *x)", "sq": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Klasifikoni numrin e plotë x bazuar në metodën e mëposhtme:\n * Nëse x është një numër njëshifror, x i përket klasës së vet.\n * Përndryshe, mblidhni shifrat e x, merrni një x të ri, dhe përsëritni derisa \n * klasa të përcaktohet.\n *\n * Parametrat:\n * - x (const char*): Numri i plotë që do të klasifikohet në formë stringu.\n *\n * Kthen:\n * int: Klasa së cilës i përket numri i plotë x.\n *\n * Përdorimi:\n * >>> f_26(\"24\")\n * 6\n */\nint f_26(const char *x)", "hy": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Դասակարգել ամբողջ թիվը x-ը հետևյալ մեթոդով.\n * Եթե x-ը միանիշ թիվ է, ապա x-ը պատկանում է իր սեփական դասին:\n * Հակառակ դեպքում, գումարեք x-ի թվանշանները, ստացեք նոր x և կրկնեք, մինչև \n * դասը որոշվի:\n *\n * Պարամետրեր:\n * - x (const char*): Դասակարգման ենթակա ամբողջ թիվը տողային ձևով:\n *\n * Վերադարձնում է:\n * int: Դասը, որին պատկանում է ամբողջ թիվը x-ը:\n *\n * Օգտագործում:\n * >>> f_26(\"24\")\n * 6\n */\nint f_26(const char *x)", "bn": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * নিম্নলিখিত পদ্ধতির ভিত্তিতে পূর্ণসংখ্যা x শ্রেণীবদ্ধ করুন:\n * যদি x এক অঙ্কের সংখ্যা হয়, তাহলে x তার নিজস্ব শ্রেণীর অন্তর্ভুক্ত।\n * অন্যথায়, x এর অঙ্কগুলির যোগফল নিন, একটি নতুন x পান, এবং পুনরাবৃত্তি করুন যতক্ষণ না \n * শ্রেণী নির্ধারণ করা হয়।\n *\n * প্যারামিটার:\n * - x (const char*): স্ট্রিং আকারে শ্রেণীবদ্ধ করার জন্য পূর্ণসংখ্যা।\n *\n * রিটার্নস:\n * int: শ্রেণী যা পূর্ণসংখ্যা x এর অন্তর্ভুক্ত।\n *\n * ব্যবহার:\n * >>> f_26(\"24\")\n * 6\n */\nint f_26(const char *x)", "bg": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Класифицирайте цялото число x въз основа на следния метод:\n * Ако x е едноцифрено число, x принадлежи към своя собствен клас.\n * В противен случай, съберете цифрите на x, получете ново x и \n * итерайте, докато класът бъде определен.\n *\n * Параметри:\n * - x (const char*): Цялото число, което трябва да бъде класифицирано, в стрингова форма.\n *\n * Връща:\n * int: Класът, към който принадлежи цялото число x.\n *\n * Употреба:\n * >>> f_26(\"24\")\n * 6\n */\nint f_26(const char *x)", "zh": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * 根据以下方法对整数 x 进行分类：\n * 如果 x 是一位数，x 属于它自己的类。\n * 否则，将 x 的各位数字相加，得到一个新的 x，并迭代直到确定类。\n *\n * 参数：\n * - x (const char*): 要分类的整数，以字符串形式表示。\n *\n * 返回：\n * int: 整数 x 所属的类。\n *\n * 用法：\n * >>> f_26(\"24\")\n * 6\n */\nint f_26(const char *x)", "fr": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Classifier l'entier x basé sur la méthode suivante :\n * Si x est un nombre à un chiffre, x appartient à sa propre classe.\n * Sinon, additionnez les chiffres de x, obtenez un nouveau x, et itérez jusqu'à \n * ce que la classe soit déterminée.\n *\n * Paramètres :\n * - x (const char*): L'entier à classifier sous forme de chaîne.\n *\n * Renvoie :\n * int : La classe à laquelle appartient l'entier x.\n *\n * Utilisation :\n * >>> f_26(\"24\")\n * 6\n */\nint f_26(const char *x)", "de": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Klassifiziere die ganze Zahl x basierend auf der folgenden Methode:\n * Wenn x eine einstellige Zahl ist, gehört x zu seiner eigenen Klasse.\n * Andernfalls summiere die Ziffern von x, erhalte ein neues x und iteriere, \n * bis die Klasse bestimmt ist.\n *\n * Parameter:\n * - x (const char*): Die zu klassifizierende ganze Zahl in Stringform.\n *\n * Rückgabewert:\n * int: Die Klasse, zu der die ganze Zahl x gehört.\n *\n * Verwendung:\n * >>> f_26(\"24\")\n * 6\n */\nint f_26(const char *x)", "ha": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Rarraba lambar x bisa ga hanyar da ke biye:\n * Idan x lamba ce mai lamba guda, x na cikin ajin kansa.\n * In ba haka ba, tara lambobin x, sami sabon x, kuma maimaita har \n * aji ya ƙaddara.\n *\n * Sigogi:\n * - x (const char*): Lambar da za a rarraba a cikin tsarin kirtani.\n *\n * Komawa:\n * int: Aji da lambar x take ciki.\n *\n * Amfani:\n * >>> f_26(\"24\")\n * 6\n */\nint f_26(const char *x)", "hi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * निम्नलिखित विधि के आधार पर पूर्णांक x को वर्गीकृत करें:\n * यदि x एकल-अंकीय संख्या है, तो x अपने स्वयं के वर्ग से संबंधित है।\n * अन्यथा, x के अंकों का योग करें, एक नया x प्राप्त करें, और तब तक पुनरावृत्ति करें \n * जब तक वर्ग निर्धारित न हो जाए।\n *\n * पैरामीटर:\n * - x (const char*): पूर्णांक को स्ट्रिंग रूप में वर्गीकृत किया जाना है।\n *\n * लौटाता है:\n * int: वह वर्ग जिसमें पूर्णांक x संबंधित है।\n *\n * उपयोग:\n * >>> f_26(\"24\")\n * 6\n */\nint f_26(const char *x)", "hu": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Osztályozza az x egész számot az alábbi módszer alapján:\n * Ha x egyjegyű szám, akkor x a saját osztályába tartozik.\n * Ellenkező esetben összeadja x számjegyeit, kap egy új x-et, és iterál, amíg \n * az osztály meg nem határozódik.\n *\n * Paraméterek:\n * - x (const char*): Az osztályozandó egész szám sztring formában.\n *\n * Visszatér:\n * int: Az osztály, amelyhez az x egész szám tartozik.\n *\n * Használat:\n * >>> f_26(\"24\")\n * 6\n */\nint f_26(const char *x)", "es": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Clasificar el entero x basado en el siguiente método:\n * Si x es un número de un solo dígito, x pertenece a su propia clase.\n * De lo contrario, suma los dígitos de x, obtén un nuevo x, e itera hasta \n * que se determine la clase.\n *\n * Parámetros:\n * - x (const char*): El entero a clasificar en forma de cadena.\n *\n * Retorna:\n * int: La clase a la que pertenece el entero x.\n *\n * Uso:\n * >>> f_26(\"24\")\n * 6\n */\nint f_26(const char *x)", "arb": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * صنف العدد الصحيح x بناءً على الطريقة التالية:\n * إذا كان x رقمًا مكونًا من رقم واحد، فإن x ينتمي إلى فئته الخاصة.\n * خلاف ذلك، اجمع أرقام x، واحصل على x جديد، وكرر حتى يتم تحديد الفئة.\n *\n * المعلمات:\n * - x (const char*): العدد الصحيح الذي سيتم تصنيفه في شكل سلسلة.\n *\n * يعيد:\n * int: الفئة التي ينتمي إليها العدد الصحيح x.\n *\n * الاستخدام:\n * >>> f_26(\"24\")\n * 6\n */\nint f_26(const char *x)", "sw": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Tambua nambari x kulingana na njia ifuatayo:\n * Ikiwa x ni nambari ya tarakimu moja, x ni ya darasa lake lenyewe.\n * Vinginevyo, jumlisha tarakimu za x, pata x mpya, na rudia hadi \n * darasa litakapobainishwa.\n *\n * Vigezo:\n * - x (const char*): Nambari ya kutambuliwa katika umbo la kamba.\n *\n * Inarudisha:\n * int: Darasa ambalo nambari x inamiliki.\n *\n * Matumizi:\n * >>> f_26(\"24\")\n * 6\n */\nint f_26(const char *x)", "tr": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * x tamsayısını aşağıdaki yönteme göre sınıflandırın:\n * Eğer x tek basamaklı bir sayı ise, x kendi sınıfına aittir.\n * Aksi takdirde, x'in basamaklarını toplayın, yeni bir x elde edin ve\n * sınıf belirlenene kadar yineleyin.\n *\n * Parametreler:\n * - x (const char*): Sınıflandırılacak tamsayı, string formunda.\n *\n * Döndürür:\n * int: x tamsayısının ait olduğu sınıf.\n *\n * Kullanım:\n * >>> f_26(\"24\")\n * 6\n */\nint f_26(const char *x)", "vi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Phân loại số nguyên x dựa trên phương pháp sau:\n * Nếu x là số có một chữ số, x thuộc về lớp của chính nó.\n * Ngược lại, tính tổng các chữ số của x, lấy một x mới, và lặp lại cho đến khi \n * lớp được xác định.\n *\n * Tham số:\n * - x (const char*): Số nguyên cần phân loại dưới dạng chuỗi.\n *\n * Trả về:\n * int: Lớp mà số nguyên x thuộc về.\n *\n * Sử dụng:\n * >>> f_26(\"24\")\n * 6\n */\nint f_26(const char *x)", "id": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Klasifikasikan bilangan bulat x berdasarkan metode berikut:\n * Jika x adalah angka satu digit, x termasuk dalam kelasnya sendiri.\n * Jika tidak, jumlahkan digit-digit dari x, dapatkan x baru, dan ulangi sampai \n * kelas ditentukan.\n *\n * Parameter:\n * - x (const char*): Bilangan bulat yang akan diklasifikasikan dalam bentuk string.\n *\n * Mengembalikan:\n * int: Kelas di mana bilangan bulat x termasuk.\n *\n * Penggunaan:\n * >>> f_26(\"24\")\n * 6\n */\nint f_26(const char *x)", "ja": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * 次の方法に基づいて整数 x を分類します:\n * もし x が一桁の数字であれば、x はそれ自身のクラスに属します。\n * それ以外の場合、x の桁を合計し、新しい x を取得し、クラスが決定されるまで繰り返します。\n *\n * パラメータ:\n * - x (const char*): 文字列形式で分類される整数。\n *\n * 戻り値:\n * int: 整数 x が属するクラス。\n *\n * 使用例:\n * >>> f_26(\"24\")\n * 6\n */\nint f_26(const char *x)", "ko": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * 정수 x를 다음 방법에 따라 분류합니다:\n * x가 한 자리 숫자이면, x는 자신의 클래스에 속합니다.\n * 그렇지 않으면, x의 자리수를 합산하여 새로운 x를 얻고, \n * 클래스가 결정될 때까지 반복합니다.\n *\n * 매개변수:\n * - x (const char*): 문자열 형태로 분류할 정수.\n *\n * 반환값:\n * int: 정수 x가 속하는 클래스.\n *\n * 사용 예:\n * >>> f_26(\"24\")\n * 6\n */\nint f_26(const char *x)", "ml": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * താഴെ പറയുന്ന രീതിയിൽ പൂർണ്ണസംഖ്യ x നെ വർഗ്ഗീകരിക്കുക:\n * x ഒറ്റ അക്ക സംഖ്യയായാൽ, x തന്റെ സ്വന്തം വർഗ്ഗത്തിൽ പെടുന്നു.\n * അല്ലെങ്കിൽ, x ന്റെ അക്കങ്ങൾ കൂട്ടിച്ചേർക്കുക, ഒരു പുതിയ x ലഭിക്കുക, \n * വർഗ്ഗം നിർണയിക്കുന്നതുവരെ ആവർത്തിക്കുക.\n *\n * പാരാമീറ്ററുകൾ:\n * - x (const char*): സ്റ്റ്രിംഗ് രൂപത്തിലുള്ള വർഗ്ഗീകരിക്കപ്പെടേണ്ട പൂർണ്ണസംഖ്യ.\n *\n * മടക്കുന്നു:\n * int: പൂർണ്ണസംഖ്യ x പെടുന്ന വർഗ്ഗം.\n *\n * ഉപയോഗം:\n * >>> f_26(\"24\")\n * 6\n */\nint f_26(const char *x)", "fa": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * عدد صحیح x را بر اساس روش زیر طبقه‌بندی کنید:\n * اگر x یک عدد یک‌رقمی باشد، x به کلاس خودش تعلق دارد.\n * در غیر این صورت، ارقام x را جمع کنید، یک x جدید بگیرید و تا زمانی که \n * کلاس تعیین شود، تکرار کنید.\n *\n * پارامترها:\n * - x (const char*): عدد صحیحی که باید به صورت رشته طبقه‌بندی شود.\n *\n * بازگشت:\n * int: کلاسی که عدد صحیح x به آن تعلق دارد.\n *\n * استفاده:\n * >>> f_26(\"24\")\n * 6\n */\nint f_26(const char *x)"}, "canonical_solution": "{\n    int n = 0, i, a, t;\n    for (i = 0; i < std::strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}", "instruction": {"en": "Write a CPP function `int f_26(const char *x)` to solve the following problem:\nClassify the integer x based on the following method:\nIf x is a single-digit number, x belongs to its own class.\nOtherwise, sum the digits of x, get a new x, and iterate until the class is determined.\n\nParameters:\n- x (const char*): The integer to be classified in string form.\n\nReturns:\nint: The class to which the integer x belongs.\n\nUsage:\n>>> f_26(\"24\")\n6", "sq": "Shkruani një funksion CPP `int f_26(const char *x)` për të zgjidhur problemin e mëposhtëm:\nKlasifikoni numrin e plotë x bazuar në metodën e mëposhtme:\nNëse x është një numër njëshifror, x i përket klasës së vet.\nPërndryshe, mblidhni shifrat e x, merrni një x të ri dhe iteroni derisa klasa të përcaktohet.\n\nParametrat:\n- x (const char*): Numri i plotë që do të klasifikohet në formë stringu.\n\nKthen:\nint: Klasa së cilës i përket numri i plotë x.\n\nPërdorimi:\n>>> f_26(\"24\")\n6", "hy": "Գրեք CPP ֆունկցիա `int f_26(const char *x)` հետևյալ խնդիրը լուծելու համար:\nԴասակարգեք ամբողջ թիվը x հետևյալ մեթոդով:\nԵթե x-ը միանիշ թիվ է, ապա x-ը պատկանում է իր սեփական դասին:\nՀակառակ դեպքում, գումարեք x-ի թվանշանները, ստացեք նոր x և կրկնեք, մինչև դասը որոշվի:\n\nՊարամետրեր:\n- x (const char*): Դասակարգվող ամբողջ թիվը տողային ձևով:\n\nՎերադարձնում է:\nint: Դասը, որին պատկանում է ամբողջ թիվը x:\n\nՕգտագործում:\n>>> f_26(\"24\")\n6", "bn": "একটি CPP ফাংশন `int f_26(const char *x)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nনিম্নলিখিত পদ্ধতির ভিত্তিতে পূর্ণসংখ্যা x শ্রেণীবদ্ধ করুন:\nযদি x একটি এক অঙ্কের সংখ্যা হয়, তাহলে x তার নিজস্ব শ্রেণীতে অন্তর্ভুক্ত।\nঅন্যথায়, x এর অঙ্কগুলির যোগফল নিন, একটি নতুন x পান এবং পুনরাবৃত্তি করুন যতক্ষণ না শ্রেণী নির্ধারণ করা হয়।\n\nপ্যারামিটার:\n- x (const char*): পূর্ণসংখ্যাটি স্ট্রিং আকারে শ্রেণীবদ্ধ করার জন্য।\n\nরিটার্নস:\nint: যে শ্রেণীতে পূর্ণসংখ্যা x অন্তর্ভুক্ত।\n\nব্যবহার:\n>>> f_26(\"24\")\n6", "bg": "Напишете CPP функция `int f_26(const char *x)`, за да решите следния проблем:\nКласифицирайте цялото число x въз основа на следния метод:\nАко x е едноцифрено число, x принадлежи към своя собствен клас.\nВ противен случай, съберете цифрите на x, получете ново x и итерайте, докато класът бъде определен.\n\nПараметри:\n- x (const char*): Цялото число, което трябва да бъде класифицирано в стринг форма.\n\nВръща:\nint: Класът, към който принадлежи цялото число x.\n\nУпотреба:\n>>> f_26(\"24\")\n6", "zh": "编写一个 CPP 函数 `int f_26(const char *x)` 来解决以下问题：\n根据以下方法对整数 x 进行分类：\n如果 x 是个位数，则 x 属于其自身的类别。\n否则，将 x 的各位数字相加，得到一个新的 x，并迭代直到确定类别。\n\n参数：\n- x (const char*): 要分类的整数，字符串形式。\n\n返回：\nint: 整数 x 所属的类别。\n\n用法：\n>>> f_26(\"24\")\n6", "fr": "Écrire une fonction CPP `int f_26(const char *x)` pour résoudre le problème suivant :\nClasser l'entier x selon la méthode suivante :\nSi x est un nombre à un seul chiffre, x appartient à sa propre classe.\nSinon, additionner les chiffres de x, obtenir un nouveau x, et itérer jusqu'à ce que la classe soit déterminée.\n\nParamètres :\n- x (const char*): L'entier à classer sous forme de chaîne.\n\nRenvoie :\nint : La classe à laquelle appartient l'entier x.\n\nUtilisation :\n>>> f_26(\"24\")\n6", "de": "Schreiben Sie eine CPP-Funktion `int f_26(const char *x)`, um das folgende Problem zu lösen:\nKlassifizieren Sie die ganze Zahl x basierend auf der folgenden Methode:\nWenn x eine einstellige Zahl ist, gehört x zu seiner eigenen Klasse.\nAndernfalls summieren Sie die Ziffern von x, erhalten ein neues x und wiederholen den Vorgang, bis die Klasse bestimmt ist.\n\nParameter:\n- x (const char*): Die zu klassifizierende ganze Zahl in String-Form.\n\nRückgabewert:\nint: Die Klasse, zu der die ganze Zahl x gehört.\n\nVerwendung:\n>>> f_26(\"24\")\n6", "ha": "Rubuta aikin CPP `int f_26(const char *x)` don warware matsalar mai zuwa:\nRarraba lambar x bisa ga hanyar mai zuwa:\nIdan x lamba ce mai lamba daya, x tana cikin ajinta.\nIn ba haka ba, tara lambobin x, sami sabon x, kuma maimaita har sai an tantance ajin.\n\nSigogi:\n- x (const char*): Lambar da za a rarraba a cikin tsarin kirtani.\n\nDawowa:\nint: Aji wanda lambar x ta ke ciki.\n\nAmfani:\n>>> f_26(\"24\")\n6", "hi": "`int f_26(const char *x)` फ़ंक्शन लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nनिम्नलिखित विधि के आधार पर पूर्णांक x को वर्गीकृत करें:\nयदि x एकल-अंकीय संख्या है, तो x अपने स्वयं के वर्ग से संबंधित है।\nअन्यथा, x के अंकों का योग करें, एक नया x प्राप्त करें, और तब तक दोहराएं जब तक वर्ग निर्धारित न हो जाए।\n\nपैरामीटर्स:\n- x (const char*): पूर्णांक जो स्ट्रिंग रूप में वर्गीकृत किया जाना है।\n\nवापसी:\nint: वह वर्ग जिसमें पूर्णांक x संबंधित है।", "hu": "Írj egy CPP függvényt `int f_26(const char *x)` a következő probléma megoldására:\nOsztályozd az x egész számot a következő módszer alapján:\nHa x egyjegyű szám, akkor x a saját osztályába tartozik.\nEgyébként add össze x számjegyeit, kapj egy új x-et, és iterálj, amíg az osztály meg nem határozódik.\n\nParaméterek:\n- x (const char*): Az osztályozandó egész szám szöveges formában.\n\nVisszatérési érték:\nint: Az osztály, amelyhez az x egész szám tartozik.\n\nHasználat:\n>>> f_26(\"24\")\n6", "es": "Escribe una función CPP `int f_26(const char *x)` para resolver el siguiente problema:\nClasifica el entero x basado en el siguiente método:\nSi x es un número de un solo dígito, x pertenece a su propia clase.\nDe lo contrario, suma los dígitos de x, obtén un nuevo x, e itera hasta que se determine la clase.\n\nParámetros:\n- x (const char*): El entero a ser clasificado en forma de cadena.\n\nDevuelve:\nint: La clase a la que pertenece el entero x.\n\nUso:\n>>> f_26(\"24\")\n6", "arb": "اكتب دالة CPP `int f_26(const char *x)` لحل المشكلة التالية:\nتصنيف العدد الصحيح x بناءً على الطريقة التالية:\nإذا كان x رقمًا مكونًا من رقم واحد، فإن x ينتمي إلى فئته الخاصة.\nخلاف ذلك، اجمع أرقام x، واحصل على x جديد، وكرر حتى يتم تحديد الفئة.\n\nالمعلمات:\n- x (const char*): العدد الصحيح الذي سيتم تصنيفه في شكل سلسلة.\n\nالإرجاع:\nint: الفئة التي ينتمي إليها العدد الصحيح x.\n\nالاستخدام:\n>>> f_26(\"24\")\n6", "sw": "Andika kazi ya CPP `int f_26(const char *x)` kutatua tatizo lifuatalo:\nTambua nambari x kulingana na njia ifuatayo:\nIkiwa x ni nambari ya tarakimu moja, x ni ya darasa lake yenyewe.\nVinginevyo, jumlisha tarakimu za x, pata x mpya, na rudia hadi darasa litakapobainishwa.\n\nVigezo:\n- x (const char*): Nambari inayotakiwa kutambuliwa katika mfumo wa kamba.\n\nInarudisha:\nint: Darasa ambalo nambari x ni ya.\n\nMatumizi:\n>>> f_26(\"24\")\n6", "tr": "Bir CPP fonksiyonu `int f_26(const char *x)` yazın ve aşağıdaki problemi çözün:\nAşağıdaki yönteme göre tamsayı x'i sınıflandırın:\nEğer x tek basamaklı bir sayı ise, x kendi sınıfına aittir.\nAksi takdirde, x'in basamaklarını toplayın, yeni bir x elde edin ve sınıf belirlenene kadar yineleyin.\n\nParametreler:\n- x (const char*): Sınıflandırılacak tamsayı, string formunda.\n\nDöndürülen:\nint: Tamsayı x'in ait olduğu sınıf.\n\nKullanım:\n>>> f_26(\"24\")\n6", "vi": "Viết một hàm CPP `int f_26(const char *x)` để giải quyết vấn đề sau:\nPhân loại số nguyên x dựa trên phương pháp sau:\nNếu x là một số có một chữ số, x thuộc về lớp của chính nó.\nNgược lại, cộng các chữ số của x, lấy một x mới, và lặp lại cho đến khi xác định được lớp.\n\nTham số:\n- x (const char*): Số nguyên cần phân loại dưới dạng chuỗi.\n\nTrả về:\nint: Lớp mà số nguyên x thuộc về.\n\nSử dụng:\n>>> f_26(\"24\")\n6", "id": "Tulis fungsi CPP `int f_26(const char *x)` untuk menyelesaikan masalah berikut:\nKlasifikasikan bilangan bulat x berdasarkan metode berikut:\nJika x adalah angka satu digit, x termasuk dalam kelasnya sendiri.\nJika tidak, jumlahkan digit-digit dari x, dapatkan x baru, dan iterasi sampai kelas ditentukan.\n\nParameter:\n- x (const char*): Bilangan bulat yang akan diklasifikasikan dalam bentuk string.\n\nMengembalikan:\nint: Kelas di mana bilangan bulat x termasuk.\n\nPenggunaan:\n>>> f_26(\"24\")\n6", "ja": "`int f_26(const char *x)` というCPP関数を書いて、次の問題を解決してください:\n次の方法に基づいて整数xを分類します:\nもしxが一桁の数字であれば、xはそれ自身のクラスに属します。\nそれ以外の場合、xの桁を合計し、新しいxを取得し、クラスが決定されるまで繰り返します。\n\nパラメータ:\n- x (const char*): 文字列形式で分類される整数。\n\n戻り値:\nint: 整数xが属するクラス。\n\n使用例:\n>>> f_26(\"24\")\n6", "ko": "`int f_26(const char *x)` 함수를 작성하여 다음 문제를 해결하십시오:\n다음 방법에 따라 정수 x를 분류하십시오:\nx가 한 자리 숫자이면, x는 자신의 클래스에 속합니다.\n그렇지 않으면, x의 자릿수를 합산하여 새로운 x를 얻고, 클래스가 결정될 때까지 반복합니다.\n\n매개변수:\n- x (const char*): 문자열 형태로 분류할 정수.\n\n반환값:\nint: 정수 x가 속하는 클래스.\n\n사용 예:\n>>> f_26(\"24\")\n6", "ml": "`int f_26(const char *x)` എന്ന CPP ഫംഗ്ഷൻ എഴുതുക താഴെക്കാണുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nഇനിപ്പറയുന്ന രീതിയനുസരിച്ച് പൂർണ്ണസംഖ്യ x നെ വർഗ്ഗീകരിക്കുക:\nx ഒറ്റ അക്ക സംഖ്യയായാൽ, x അതിന്റെ സ്വന്തം വർഗ്ഗത്തിൽപ്പെടുന്നു.\nഇല്ലെങ്കിൽ, x ന്റെ അക്കങ്ങൾ കൂട്ടിച്ചേർക്കുക, ഒരു പുതിയ x നേടുക, വർഗ്ഗം നിർണയിക്കുന്നതുവരെ ആവർത്തിക്കുക.\n\nപാരാമീറ്ററുകൾ:\n- x (const char*): വർഗ്ഗീകരിക്കേണ്ട പൂർണ്ണസംഖ്യയുടെ സ്ട്രിംഗ് രൂപം.\n\nമടക്കം:\nint: പൂർണ്ണസംഖ്യ x ഏത് വർഗ്ഗത്തിൽപ്പെടുന്നു.\n\nഉപയോഗം:\n>>> f_26(\"24\")\n6", "fa": "تابعی به زبان CPP به نام `int f_26(const char *x)` بنویسید تا مسئله زیر را حل کند:\nعدد صحیح x را بر اساس روش زیر طبقه‌بندی کنید:\nاگر x یک عدد تک‌رقمی است، x به کلاس خودش تعلق دارد.\nدر غیر این صورت، ارقام x را جمع کنید، یک x جدید بگیرید و تا زمانی که کلاس تعیین شود، تکرار کنید.\n\nپارامترها:\n- x (const char*): عدد صحیحی که به صورت رشته برای طبقه‌بندی است.\n\nبازگشت:\nint: کلاسی که عدد صحیح x به آن تعلق دارد.\n\nاستفاده:\n>>> f_26(\"24\")\n6"}, "level": "easy", "test": "int main() {\n    assert(f_26(\"24\") == 6);\n    assert(f_26(\"39\") == 3);\n    assert(f_26(\"123456789\") == 9);\n    assert(f_26(\"123456789012345678901234567890\") == 9);\n    assert(f_26(\"12345\") == 6);\n    assert(f_26(\"999999999\") == 9);\n    // std::printf(\"All tests passed successfully!\\n\");\n    return 0;\n}", "entry_point": "f_26", "signature": "int f_26(const char *x)", "docstring": {"en": "Classify the integer x based on the following method:\nIf x is a single-digit number, x belongs to its own class.\nOtherwise, sum the digits of x, get a new x, and iterate until the class is determined.\n\nParameters:\n- x (const char*): The integer to be classified in string form.\n\nReturns:\nint: The class to which the integer x belongs.\n\nUsage:\n>>> f_26(\"24\")\n6", "sq": "Klasifikoni numrin e plotë x bazuar në metodën e mëposhtme:\nNëse x është një numër njëshifror, x i përket klasës së vet.\nPërndryshe, mblidhni shifrat e x, merrni një x të ri dhe përsëritni derisa klasa të përcaktohet.\n\nParametrat:\n- x (const char*): Numri i plotë që do të klasifikohet në formë stringu.\n\nKthen:\nint: Klasa së cilës i përket numri i plotë x.\n\nPërdorimi:\n>>> f_26(\"24\")\n6", "hy": "Դասակարգեք ամբողջ թիվը x հետևյալ մեթոդով:\nԵթե x-ը միանիշ թիվ է, ապա x-ը պատկանում է իր սեփական դասին։\nՀակառակ դեպքում, գումարեք x-ի թվանշանները, ստացեք նոր x, և կրկնեք մինչև դասը որոշվի։\n\nՊարամետրեր:  \n- x (const char*): Թիվը, որը պետք է դասակարգվի տողի ձևով։\n\nՎերադարձնում է:  \nint: Դասը, որին պատկանում է թիվ x-ը։\n\nՕգտագործում:  \n>>> f_26(\"24\")  \n6", "bn": "ইন্টিজার x নিম্নলিখিত পদ্ধতির ভিত্তিতে শ্রেণীবদ্ধ করুন:\nযদি x একটি একক-অঙ্কের সংখ্যা হয়, তাহলে x তার নিজস্ব শ্রেণীতে অন্তর্ভুক্ত।\nঅন্যথায়, x এর অঙ্কগুলির যোগফল নিন, একটি নতুন x পান, এবং শ্রেণী নির্ধারিত না হওয়া পর্যন্ত পুনরাবৃত্তি করুন।\n\nপ্যারামিটার:\n- x (const char*): স্ট্রিং আকারে শ্রেণীবদ্ধ করার জন্য ইন্টিজার।\n\nরিটার্নস:\nint: যে শ্রেণীতে ইন্টিজার x অন্তর্ভুক্ত।\n\nব্যবহার:\n>>> f_26(\"24\")\n6", "bg": "Класифицирайте цялото число x въз основа на следния метод:\nАко x е едноцифрено число, x принадлежи към своя собствен клас.\nВ противен случай, съберете цифрите на x, получете ново x и итерайте, докато класът не бъде определен.\n\nПараметри:\n- x (const char*): Цялото число, което трябва да бъде класифицирано, във вид на низ.\n\nВръща:\nint: Класът, към който принадлежи цялото число x.\n\nУпотреба:\n>>> f_26(\"24\")\n6", "zh": "根据以下方法对整数 x 进行分类：\n如果 x 是一个个位数，则 x 属于它自己的类。\n否则，将 x 的各位数字相加，得到一个新的 x，并迭代直到确定类。\n\n参数：\n- x (const char*): 以字符串形式表示的要分类的整数。\n\n返回：\nint: 整数 x 所属的类。\n\n用法：\n>>> f_26(\"24\")\n6", "fr": "Classifiez l'entier x selon la méthode suivante :\nSi x est un nombre à un chiffre, x appartient à sa propre classe.\nSinon, additionnez les chiffres de x, obtenez un nouveau x, et itérez jusqu'à ce que la classe soit déterminée.\n\nParamètres :\n- x (const char*): L'entier à classer sous forme de chaîne de caractères.\n\nRenvoie :\nint : La classe à laquelle appartient l'entier x.\n\nUtilisation :\n>>> f_26(\"24\")\n6", "de": "Klassifizieren Sie die ganze Zahl x basierend auf der folgenden Methode:\nWenn x eine einstellige Zahl ist, gehört x zu seiner eigenen Klasse.\nAndernfalls summieren Sie die Ziffern von x, erhalten ein neues x und iterieren, bis die Klasse bestimmt ist.\n\nParameter:\n\n- x (const char*): The integer to be classified in string form.  \n  - x (const char*): Die ganze Zahl, die in String-Form klassifiziert werden soll.\n\nGibt zurück:\n\nint: Die Klasse, zu der die ganze Zahl x gehört.\n\nVerwendung:\n\n>>> f_26(\"24\")\n6", "ha": "Rarraba lambar x bisa ga hanyar mai zuwa:\nIdan x lamba ce mai ɗigo ɗaya, x na cikin aji nasa.\nIn ba haka ba, tara lambobin x, sami sabon x, kuma maimaita har sai an tantance ajin.\n\nParameters:\n- x (const char*): Lambar da za a tantance a cikin tsarin kirtani.\n\nReturns:\nint: Ajin da lambar x ta ke ciki.\n\nUsage:\n>>> f_26(\"24\")\n6", "hi": "निम्नलिखित विधि के आधार पर पूर्णांक x को वर्गीकृत करें:\nयदि x एक एकल अंक संख्या है, तो x अपनी स्वयं की श्रेणी में आता है।\nअन्यथा, x के अंकों का योग करें, एक नया x प्राप्त करें, और तब तक पुनरावृत्ति करें जब तक कि श्रेणी निर्धारित न हो जाए।\n\nParameters:\n- x (const char*): स्ट्रिंग रूप में वर्गीकृत की जाने वाली पूर्णांक।\n\nReturns:\nint: वह श्रेणी जिसमें पूर्णांक x आता है।\n\nUsage:\n>>> f_26(\"24\")\n6", "hu": "Osztályozza az x egész számot az alábbi módszer alapján:\nHa x egyjegyű szám, akkor x a saját osztályába tartozik.\nEgyébként összegezze x számjegyeit, kapjon egy új x-et, és ismételje meg, amíg az osztály meg nem határozódik.\n\nParaméterek:\n- x (const char*): Az osztályozandó egész szám sztring formában.\n\nVisszatér:\nint: Az osztály, amelyhez az x egész szám tartozik.\n\nHasználat:\n>>> f_26(\"24\")\n6", "es": "Clasificar el entero x basado en el siguiente método:\nSi x es un número de un solo dígito, x pertenece a su propia clase.\nDe lo contrario, suma los dígitos de x, obtén un nuevo x, e itera hasta que se determine la clase.\n\nParámetros:\n- x (const char*): El entero a ser clasificado en forma de cadena.\n\nDevuelve:\nint: La clase a la que pertenece el entero x.\n\nUso:\n>>> f_26(\"24\")\n6", "arb": "صنف العدد الصحيح x بناءً على الطريقة التالية:\nإذا كان x رقمًا مكونًا من رقم واحد، فإن x ينتمي إلى فئته الخاصة.\nخلاف ذلك، اجمع أرقام x، واحصل على x جديد، وكرر حتى يتم تحديد الفئة.\n\nالمعلمات:\n- x (const char*): العدد الصحيح الذي سيتم تصنيفه في شكل سلسلة.\n\nالقيم المعادة:\nint: الفئة التي ينتمي إليها العدد الصحيح x.\n\nالاستخدام:\n>>> f_26(\"24\")\n6", "sw": "Tambua nambari x kulingana na njia ifuatayo:\nIkiwa x ni nambari ya tarakimu moja, x inahusiana na darasa lake lenyewe.\nVinginevyo, jumlisha tarakimu za x, pata x mpya, na rudia hadi darasa litakapobainishwa.\n\nVigezo:\n- x (const char*): Nambari ya kuhesabu inayopaswa kuainishwa katika umbo la kamba.\n\nInarejesha:\nint: Darasa ambalo nambari x inahusiana.\n\nMatumizi:\n>>> f_26(\"24\")\n6", "tr": "Tam sayı x'i aşağıdaki yönteme göre sınıflandırın:\nEğer x tek basamaklı bir sayıysa, x kendi sınıfına aittir.\nAksi takdirde, x'in basamaklarını toplayın, yeni bir x elde edin ve sınıf belirlenene kadar yineleyin.\n\nParametreler:\n- x (const char*): Sınıflandırılacak tam sayının string formu.\n\nDöndürür:\nint: Tam sayı x'in ait olduğu sınıf.\n\nKullanım:\n>>> f_26(\"24\")\n6", "vi": "Phân loại số nguyên x dựa trên phương pháp sau:\nNếu x là một số có một chữ số, x thuộc về lớp của chính nó.\nNgược lại, cộng các chữ số của x lại, nhận được một x mới, và lặp lại cho đến khi xác định được lớp.\n\nTham số:\n- x (const char*): Số nguyên cần được phân loại dưới dạng chuỗi.\n\nTrả về:\nint: Lớp mà số nguyên x thuộc về.\n\nSử dụng:\n>>> f_26(\"24\")\n6", "id": "Classify the integer x berdasarkan metode berikut:\nJika x adalah angka satu digit, x termasuk dalam kelasnya sendiri.\nJika tidak, jumlahkan digit-digit x, dapatkan x baru, dan iterasi hingga kelas ditentukan.\n\nParameter:\n- x (const char*): Bilangan bulat yang akan diklasifikasikan dalam bentuk string.\n\nMengembalikan:\nint: Kelas di mana bilangan bulat x termasuk.\n\nPenggunaan:\n>>> f_26(\"24\")\n6", "ja": "整数 x を次の方法で分類します:\nx が一桁の数字の場合、x はそれ自身のクラスに属します。\nそれ以外の場合、x の桁を合計し、新しい x を取得し、クラスが決定されるまで繰り返します。\n\nパラメータ:\n- x (const char*): 文字列形式で分類される整数。\n\n戻り値:\nint: 整数 x が属するクラス。\n\n使用例:\n>>> f_26(\"24\")\n6", "ko": "정수 x를 다음 방법에 따라 분류합니다:\nx가 한 자리 숫자이면, x는 자신의 클래스에 속합니다.\n그렇지 않으면, x의 각 자릿수를 더하여 새로운 x를 얻고, 클래스가 결정될 때까지 반복합니다.\n\n매개변수:\n- x (const char*): 문자열 형식으로 분류할 정수.\n\n반환:\nint: 정수 x가 속하는 클래스.\n\n사용 예:\n>>> f_26(\"24\")\n6", "ml": "താഴെ പറയുന്ന രീതിയിൽ പൂർണ്ണസംഖ്യ x നെ വർഗ്ഗീകരിക്കുക:\nIf x is a single-digit number, x belongs to its own class.\nOtherwise, sum the digits of x, get a new x, and iterate until the class is determined.\n\nParameters:\n- x (const char*): ക്ലാസിഫൈ ചെയ്യേണ്ട സംഖ്യയുടെ സ്ട്രിംഗ് രൂപം.\n\nReturns:\nint: സംഖ്യ x ഏത് ക്ലാസിൽ പെടുന്നു എന്ന്.\n\nUsage:\n>>> f_26(\"24\")\n6", "fa": "عدد صحیح x را بر اساس روش زیر طبقه‌بندی کنید: \nاگر x یک عدد یک‌رقمی باشد، x به کلاس خودش تعلق دارد.  \nدر غیر این صورت، ارقام x را جمع کنید، یک x جدید بگیرید و تا زمانی که کلاس تعیین شود تکرار کنید.\n\nParameters:  \n- x (const char*): عدد صحیحی که باید به صورت رشته طبقه‌بندی شود.\n\nReturns:  \nint: کلاسی که عدد صحیح x به آن تعلق دارد.\n\nUsage:  \n>>> f_26(\"24\")  \n6"}}
{"task_id": "CPP/27", "prompt": {"en": "#include <cassert>\n#include <cstdio>\n/**\n * Transforms the case of a given letter.\n * \n * If the input is a lowercase letter, it returns the uppercase version,\n * and if the input is an uppercase letter, it returns the lowercase version.\n * Non-alphabetic characters are returned unchanged.\n *\n * Usage:\n *   char result = f_27('b'); // result will be 'B'\n *   char result = f_27('B'); // result will be 'b'\n *\n * @param letter The input letter to be transformed.\n * @return The letter with its case reversed if it's alphabetic, otherwise the original letter.\n */\nchar f_27(char letter)", "sq": "#include <cassert>\n#include <cstdio>\n/**\n * Transformon shkronjën e dhënë në rast tjetër.\n * \n * Nëse hyrja është një shkronjë e vogël, kthen versionin e madh,\n * dhe nëse hyrja është një shkronjë e madhe, kthen versionin e vogël.\n * Karakteret jo-alfabetike kthehen të pandryshuara.\n *\n * Përdorimi:\n *   char result = f_27('b'); // rezultati do të jetë 'B'\n *   char result = f_27('B'); // rezultati do të jetë 'b'\n *\n * @param letter Shkronja e hyrjes që do të transformohet.\n * @return Shkronja me rastin e saj të kthyer nëse është alfabetike, përndryshe shkronja origjinale.\n */\nchar f_27(char letter)", "hy": "#include <cassert>\n#include <cstdio>\n/**\n * Փոխակերպում է տրված տառի ռեգիստրը։\n * \n * Եթե մուտքագրումը փոքրատառ է, վերադարձնում է մեծատառ տարբերակը,\n * իսկ եթե մուտքագրումը մեծատառ է, վերադարձնում է փոքրատառ տարբերակը։\n * Այլ ոչ այբբենական նիշերը վերադարձվում են անփոփոխ։\n *\n * Օգտագործում:\n *   char result = f_27('b'); // result-ը կլինի 'B'\n *   char result = f_27('B'); // result-ը կլինի 'b'\n *\n * @param letter Մուտքագրված տառը, որը պետք է փոխակերպվի։\n * @return Տառը իր ռեգիստրը փոխված, եթե այն այբբենական է, հակառակ դեպքում՝ սկզբնական տառը։\n */\nchar f_27(char letter)", "bn": "#include <cassert>\n#include <cstdio>\n/**\n * একটি প্রদত্ত অক্ষরের ক্ষেত্রে পরিবর্তন করে।\n * \n * যদি ইনপুট একটি ছোট হাতের অক্ষর হয়, এটি বড় হাতের সংস্করণটি ফেরত দেয়,\n * এবং যদি ইনপুট একটি বড় হাতের অক্ষর হয়, এটি ছোট হাতের সংস্করণটি ফেরত দেয়।\n * অক্ষর ব্যতীত অন্যান্য অক্ষর অপরিবর্তিত অবস্থায় ফেরত দেয়।\n *\n * ব্যবহার:\n *   char result = f_27('b'); // result হবে 'B'\n *   char result = f_27('B'); // result হবে 'b'\n *\n * @param letter পরিবর্তন করার জন্য ইনপুট অক্ষর।\n * @return অক্ষরটি যদি বর্ণমালা হয় তবে তার ক্ষেত্রে বিপরীত অবস্থায় ফেরত দেয়, অন্যথায় মূল অক্ষরটি ফেরত দেয়।\n */\nchar f_27(char letter)", "bg": "#include <cassert>\n#include <cstdio>\n/**\n * Преобразува регистъра на дадена буква.\n * \n * Ако входът е малка буква, връща главната версия,\n * и ако входът е главна буква, връща малката версия.\n * Неалфабетните символи се връщат непроменени.\n *\n * Употреба:\n *   char result = f_27('b'); // result ще бъде 'B'\n *   char result = f_27('B'); // result ще бъде 'b'\n *\n * @param letter Входната буква, която ще бъде преобразувана.\n * @return Буквата с обърнат регистър, ако е алфабетна, в противен случай оригиналната буква.\n */\nchar f_27(char letter)", "zh": "#include <cassert>\n#include <cstdio>\n/**\n * 转换给定字母的大小写。\n * \n * 如果输入是小写字母，则返回大写版本，\n * 如果输入是大写字母，则返回小写版本。\n * 非字母字符将保持不变。\n *\n * 用法:\n *   char result = f_27('b'); // result 将是 'B'\n *   char result = f_27('B'); // result 将是 'b'\n *\n * @param letter 要转换的输入字母。\n * @return 如果是字母则返回大小写反转的字母，否则返回原始字母。\n */\nchar f_27(char letter)", "fr": "#include <cassert>\n#include <cstdio>\n/**\n * Transforme la casse d'une lettre donnée.\n * \n * Si l'entrée est une lettre minuscule, elle renvoie la version majuscule,\n * et si l'entrée est une lettre majuscule, elle renvoie la version minuscule.\n * Les caractères non alphabétiques sont renvoyés inchangés.\n *\n * Utilisation :\n *   char result = f_27('b'); // result sera 'B'\n *   char result = f_27('B'); // result sera 'b'\n *\n * @param letter La lettre d'entrée à transformer.\n * @return La lettre avec sa casse inversée si elle est alphabétique, sinon la lettre originale.\n */\nchar f_27(char letter)", "de": "#include <cassert>\n#include <cstdio>\n/**\n * Transformiert den Fall eines gegebenen Buchstabens.\n * \n * Wenn die Eingabe ein Kleinbuchstabe ist, wird die Großbuchstabenversion zurückgegeben,\n * und wenn die Eingabe ein Großbuchstabe ist, wird die Kleinbuchstabenversion zurückgegeben.\n * Nicht-alphabetische Zeichen werden unverändert zurückgegeben.\n *\n * Verwendung:\n *   char result = f_27('b'); // result wird 'B' sein\n *   char result = f_27('B'); // result wird 'b' sein\n *\n * @param letter Der Eingabebuchstabe, der transformiert werden soll.\n * @return Der Buchstabe mit umgekehrter Groß-/Kleinschreibung, wenn er alphabetisch ist, ansonsten der ursprüngliche Buchstabe.\n */\nchar f_27(char letter)", "ha": "#include <cassert>\n#include <cstdio>\n/**\n * Canza yanayin harafin da aka bayar.\n * \n * Idan shigarwar harafi ne ƙarami, zai dawo da babbar sigar,\n * kuma idan shigarwar harafi ne babba, zai dawo da ƙaramin sigar.\n * Haruffan da ba na haruffa ba za a dawo da su ba tare da canji ba.\n *\n * Amfani:\n *   char result = f_27('b'); // sakamakon zai zama 'B'\n *   char result = f_27('B'); // sakamakon zai zama 'b'\n *\n * @param letter Harafin shigarwa da za a canza.\n * @return Harafin da aka juya yanayinsa idan harafi ne, in ba haka ba harafin asali.\n */\nchar f_27(char letter)", "hi": "#include <cassert>\n#include <cstdio>\n/**\n * दिए गए अक्षर का केस बदलता है।\n * \n * यदि इनपुट एक लोअरकेस अक्षर है, तो यह अपरकेस संस्करण लौटाता है,\n * और यदि इनपुट एक अपरकेस अक्षर है, तो यह लोअरकेस संस्करण लौटाता है।\n * गैर-अक्षरीय वर्ण अपरिवर्तित लौटाए जाते हैं।\n *\n * उपयोग:\n *   char result = f_27('b'); // result होगा 'B'\n *   char result = f_27('B'); // result होगा 'b'\n *\n * @param letter इनपुट अक्षर जिसे परिवर्तित किया जाना है।\n * @return अक्षर जिसका केस उलट दिया गया है यदि यह अक्षरीय है, अन्यथा मूल अक्षर।\n */\nchar f_27(char letter)", "hu": "#include <cassert>\n#include <cstdio>\n/**\n * Egy adott betű esetét alakítja át.\n * \n * Ha a bemenet kisbetű, akkor a nagybetűs változatot adja vissza,\n * és ha a bemenet nagybetű, akkor a kisbetűs változatot adja vissza.\n * Nem alfabetikus karakterek változatlanul kerülnek visszaadásra.\n *\n * Használat:\n *   char result = f_27('b'); // result 'B' lesz\n *   char result = f_27('B'); // result 'b' lesz\n *\n * @param letter Az átalakítandó bemeneti betű.\n * @return A betű ellentétes esetben, ha alfabetikus, különben az eredeti betű.\n */\nchar f_27(char letter)", "es": "#include <cassert>\n#include <cstdio>\n/**\n * Transforma el caso de una letra dada.\n * \n * Si la entrada es una letra minúscula, devuelve la versión en mayúscula,\n * y si la entrada es una letra mayúscula, devuelve la versión en minúscula.\n * Los caracteres no alfabéticos se devuelven sin cambios.\n *\n * Uso:\n *   char result = f_27('b'); // result será 'B'\n *   char result = f_27('B'); // result será 'b'\n *\n * @param letter La letra de entrada a transformar.\n * @return La letra con su caso invertido si es alfabética, de lo contrario la letra original.\n */\nchar f_27(char letter)", "arb": "#include <cassert>\n#include <cstdio>\n/**\n * يحول حالة حرف معين.\n * \n * إذا كان الإدخال حرفًا صغيرًا، فإنه يعيد النسخة الكبيرة،\n * وإذا كان الإدخال حرفًا كبيرًا، فإنه يعيد النسخة الصغيرة.\n * الأحرف غير الأبجدية تُعاد دون تغيير.\n *\n * الاستخدام:\n *   char result = f_27('b'); // النتيجة ستكون 'B'\n *   char result = f_27('B'); // النتيجة ستكون 'b'\n *\n * @param letter الحرف المدخل ليتم تحويله.\n * @return الحرف مع عكس حالته إذا كان أبجديًا، وإلا الحرف الأصلي.\n */\nchar f_27(char letter)", "sw": "#include <cassert>\n#include <cstdio>\n/**\n * Hubadilisha herufi kubwa au ndogo ya herufi iliyotolewa.\n * \n * Ikiwa ingizo ni herufi ndogo, inarudisha toleo la herufi kubwa,\n * na ikiwa ingizo ni herufi kubwa, inarudisha toleo la herufi ndogo.\n * Herufi zisizo za alfabeti zinarudishwa bila kubadilishwa.\n *\n * Matumizi:\n *   char result = f_27('b'); // result itakuwa 'B'\n *   char result = f_27('B'); // result itakuwa 'b'\n *\n * @param letter Herufi ya ingizo inayopaswa kubadilishwa.\n * @return Herufi ikiwa imebadilishwa herufi kubwa au ndogo ikiwa ni ya alfabeti, vinginevyo herufi asili.\n */\nchar f_27(char letter)", "tr": "#include <cassert>\n#include <cstdio>\n/**\n * Belirtilen bir harfin büyük/küçük harf durumunu değiştirir.\n * \n * Eğer giriş küçük harf ise, büyük harf versiyonunu döndürür,\n * ve eğer giriş büyük harf ise, küçük harf versiyonunu döndürür.\n * Alfabetik olmayan karakterler değişmeden döndürülür.\n *\n * Kullanım:\n *   char result = f_27('b'); // result 'B' olacaktır\n *   char result = f_27('B'); // result 'b' olacaktır\n *\n * @param letter Dönüştürülecek giriş harfi.\n * @return Eğer alfabetikse harfin büyük/küçük harfi değiştirilmiş hali, aksi takdirde orijinal harf.\n */\nchar f_27(char letter)", "vi": "#include <cassert>\n#include <cstdio>\n/**\n * Chuyển đổi kiểu chữ của một chữ cái cho trước.\n * \n * Nếu đầu vào là một chữ cái viết thường, nó sẽ trả về phiên bản viết hoa,\n * và nếu đầu vào là một chữ cái viết hoa, nó sẽ trả về phiên bản viết thường.\n * Các ký tự không phải chữ cái được trả về không thay đổi.\n *\n * Sử dụng:\n *   char result = f_27('b'); // result sẽ là 'B'\n *   char result = f_27('B'); // result sẽ là 'b'\n *\n * @param letter Chữ cái đầu vào cần được chuyển đổi.\n * @return Chữ cái với kiểu chữ được đảo ngược nếu nó là chữ cái, nếu không thì trả về chữ cái gốc.\n */\nchar f_27(char letter)", "id": "#include <cassert>\n#include <cstdio>\n/**\n * Mengubah huruf besar/kecil dari huruf yang diberikan.\n * \n * Jika input adalah huruf kecil, fungsi ini mengembalikan versi huruf besar,\n * dan jika input adalah huruf besar, fungsi ini mengembalikan versi huruf kecil.\n * Karakter non-alfabetik dikembalikan tanpa perubahan.\n *\n * Penggunaan:\n *   char result = f_27('b'); // result akan menjadi 'B'\n *   char result = f_27('B'); // result akan menjadi 'b'\n *\n * @param letter Huruf input yang akan diubah.\n * @return Huruf dengan perubahan besar/kecil jika itu alfabetik, jika tidak, huruf asli.\n */\nchar f_27(char letter)", "ja": "#include <cassert>\n#include <cstdio>\n/**\n * 与えられた文字の大文字小文字を変換します。\n * \n * 入力が小文字の文字の場合、大文字のバージョンを返し、\n * 入力が大文字の文字の場合、小文字のバージョンを返します。\n * アルファベット以外の文字は変更されずに返されます。\n *\n * 使用例:\n *   char result = f_27('b'); // result は 'B' になります\n *   char result = f_27('B'); // result は 'b' になります\n *\n * @param letter 変換する入力文字。\n * @return アルファベットの場合は大文字小文字が反転した文字、それ以外の場合は元の文字。\n */\nchar f_27(char letter)", "ko": "#include <cassert>\n#include <cstdio>\n/**\n * 주어진 문자의 대소문자를 변환합니다.\n * \n * 입력이 소문자일 경우, 대문자 버전을 반환하고,\n * 입력이 대문자일 경우, 소문자 버전을 반환합니다.\n * 알파벳이 아닌 문자는 변경되지 않고 그대로 반환됩니다.\n *\n * 사용 예:\n *   char result = f_27('b'); // result는 'B'가 됩니다\n *   char result = f_27('B'); // result는 'b'가 됩니다\n *\n * @param letter 변환할 입력 문자입니다.\n * @return 알파벳일 경우 대소문자가 반전된 문자를 반환하고, 그렇지 않으면 원래 문자를 반환합니다.\n */\nchar f_27(char letter)", "ml": "#include <cassert>\n#include <cstdio>\n/**\n * നൽകിയ അക്ഷരത്തിന്റെ കേസിനെ മാറ്റുന്നു.\n * \n * ഇൻപുട്ട് ചെറിയക്ഷരം ആണെങ്കിൽ, അത് വലിയക്ഷരമായി മടക്കുന്നു,\n * ഇൻപുട്ട് വലിയക്ഷരം ആണെങ്കിൽ, അത് ചെറിയക്ഷരമായി മടക്കുന്നു.\n * അക്ഷരമല്ലാത്ത കഥാപാത്രങ്ങൾ മാറ്റമില്ലാതെ മടക്കുന്നു.\n *\n * ഉപയോഗം:\n *   char result = f_27('b'); // ഫലം 'B' ആയിരിക്കും\n *   char result = f_27('B'); // ഫലം 'b' ആയിരിക്കും\n *\n * @param letter മാറ്റേണ്ട ഇൻപുട്ട് അക്ഷരം.\n * @return അക്ഷരമെങ്കിൽ, അതിന്റെ കേസ് മറിച്ചുള്ള അക്ഷരം, അല്ലെങ്കിൽ യഥാർത്ഥ അക്ഷരം.\n */\nchar f_27(char letter)", "fa": "#include <cassert>\n#include <cstdio>\n/**\n * حالت یک حرف داده شده را تغییر می‌دهد.\n * \n * اگر ورودی یک حرف کوچک باشد، نسخه بزرگ آن را برمی‌گرداند،\n * و اگر ورودی یک حرف بزرگ باشد، نسخه کوچک آن را برمی‌گرداند.\n * کاراکترهای غیر الفبایی بدون تغییر برگردانده می‌شوند.\n *\n * استفاده:\n *   char result = f_27('b'); // result خواهد بود 'B'\n *   char result = f_27('B'); // result خواهد بود 'b'\n *\n * @param letter حرف ورودی که باید تغییر یابد.\n * @return حرف با حالت معکوس شده اگر الفبایی باشد، در غیر این صورت حرف اصلی.\n */\nchar f_27(char letter)"}, "canonical_solution": "{\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    }\n    else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}", "instruction": {"en": "Write a CPP function `char f_27(char letter)` to solve the following problem:\nTransforms the case of a given letter.\n\nIf the input is a lowercase letter, it returns the uppercase version,\nand if the input is an uppercase letter, it returns the lowercase version.\nNon-alphabetic characters are returned unchanged.\n\nUsage:\n  char result = f_27('b'); // result will be 'B'\n  char result = f_27('B'); // result will be 'b'\n\n@param letter The input letter to be transformed.\n@return The letter with its case reversed if it's alphabetic, otherwise the original letter.\n", "sq": "Shkruani një funksion CPP `char f_27(char letter)` për të zgjidhur problemin e mëposhtëm:\nTransformon rastin e një shkronje të dhënë.\n\nNëse hyrja është një shkronjë e vogël, ajo kthen versionin e madh,\ndhe nëse hyrja është një shkronjë e madhe, ajo kthen versionin e vogël.\nKarakteret jo-alfabetike kthehen të pandryshuara.\n\nPërdorimi:\n  char result = f_27('b'); // rezultati do të jetë 'B'\n  char result = f_27('B'); // rezultati do të jetë 'b'\n\n@param letter Shkronja hyrëse që do të transformohet.\n@return Shkronja me rastin e saj të kthyer nëse është alfabetike, përndryshe shkronja origjinale.", "hy": "Գրեք CPP ֆունկցիա `char f_27(char letter)` հետևյալ խնդիրը լուծելու համար:\nՓոխակերպում է տրված տառի ռեգիստրը։\n\nԵթե մուտքագրումը փոքրատառ տառ է, վերադարձնում է մեծատառ տարբերակը,\nիսկ եթե մուտքագրումը մեծատառ տառ է, վերադարձնում է փոքրատառ տարբերակը։\nԱյլ ոչ այբբենական նիշերը վերադարձվում են անփոփոխ։\n\nՕգտագործում:\n  char result = f_27('b'); // result-ը կլինի 'B'\n  char result = f_27('B'); // result-ը կլինի 'b'\n\n@param letter Մուտքային տառը, որը պետք է փոխակերպվի։\n@return Տառը, որի ռեգիստրը փոխված է, եթե այն այբբենական է, հակառակ դեպքում՝ սկզբնական տառը։", "bn": "একটি CPP ফাংশন `char f_27(char letter)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি প্রদত্ত অক্ষরের কেস পরিবর্তন করে।\n\nযদি ইনপুট একটি ছোট হাতের অক্ষর হয়, এটি বড় হাতের সংস্করণ ফেরত দেয়,\nএবং যদি ইনপুট একটি বড় হাতের অক্ষর হয়, এটি ছোট হাতের সংস্করণ ফেরত দেয়।\nঅ-আক্ষরিক অক্ষর অপরিবর্তিত অবস্থায় ফেরত দেওয়া হয়।\n\nব্যবহার:\n  char result = f_27('b'); // result হবে 'B'\n  char result = f_27('B'); // result হবে 'b'\n\n@param letter পরিবর্তন করার জন্য ইনপুট অক্ষর।\n@return অক্ষরটি যদি আক্ষরিক হয় তবে তার কেস বিপরীত অবস্থায় ফেরত দেয়, অন্যথায় মূল অক্ষরটি।", "bg": "Напишете CPP функция `char f_27(char letter)`, за да решите следния проблем:\nПреобразува регистъра на дадена буква.\n\nАко входът е малка буква, връща голямата версия,\nи ако входът е голяма буква, връща малката версия.\nНеалфабетните символи се връщат непроменени.\n\nУпотреба:\n  char result = f_27('b'); // result ще бъде 'B'\n  char result = f_27('B'); // result ще бъде 'b'\n\n@param letter Входната буква, която ще бъде преобразувана.\n@return Буквата с обърнат регистър, ако е алфабетна, в противен случай оригиналната буква.", "zh": "编写一个 CPP 函数 `char f_27(char letter)` 来解决以下问题：\n转换给定字母的大小写。\n\n如果输入是小写字母，则返回大写版本，\n如果输入是大写字母，则返回小写版本。\n非字母字符将保持不变。\n\n用法:\n  char result = f_27('b'); // result 将是 'B'\n  char result = f_27('B'); // result 将是 'b'\n\n@param letter 要转换的输入字母。\n@return 如果是字母，则返回大小写转换后的字母，否则返回原始字母。", "fr": "Écrire une fonction CPP `char f_27(char letter)` pour résoudre le problème suivant :\nTransforme la casse d'une lettre donnée.\n\nSi l'entrée est une lettre minuscule, elle renvoie la version majuscule,\net si l'entrée est une lettre majuscule, elle renvoie la version minuscule.\nLes caractères non alphabétiques sont renvoyés inchangés.\n\nUtilisation :\n  char result = f_27('b'); // result sera 'B'\n  char result = f_27('B'); // result sera 'b'\n\n@param letter La lettre d'entrée à transformer.\n@return La lettre avec sa casse inversée si elle est alphabétique, sinon la lettre originale.", "de": "Schreiben Sie eine CPP-Funktion `char f_27(char letter)`, um das folgende Problem zu lösen:\nTransformiert die Groß-/Kleinschreibung eines gegebenen Buchstabens.\n\nWenn die Eingabe ein Kleinbuchstabe ist, wird die Großbuchstabenversion zurückgegeben,\nund wenn die Eingabe ein Großbuchstabe ist, wird die Kleinbuchstabenversion zurückgegeben.\nNicht-alphabetische Zeichen werden unverändert zurückgegeben.\n\nVerwendung:\n  char result = f_27('b'); // result wird 'B' sein\n  char result = f_27('B'); // result wird 'b' sein\n\n@param letter Der Eingabebuchstabe, der transformiert werden soll.\n@return Der Buchstabe mit umgekehrter Groß-/Kleinschreibung, wenn er alphabetisch ist, andernfalls der ursprüngliche Buchstabe.", "ha": "Rubuta aikin CPP `char f_27(char letter)` don warware matsalar mai zuwa:\nCanza harafin da aka bayar daga babba zuwa ƙanana ko daga ƙanana zuwa babba.\n\nIdan shigarwar harafi ne ƙanana, zai dawo da sigar babba,\nkuma idan shigarwar harafi ne babba, zai dawo da sigar ƙanana.\nHaruffan da ba na alfabiti ba za a dawo da su ba tare da canji ba.\n\nAmfani:\n  char result = f_27('b'); // sakamakon zai zama 'B'\n  char result = f_27('B'); // sakamakon zai zama 'b'\n\n@param letter Harafin shigarwa da za a canza.\n@return Harafin da aka juya idan harafi ne na alfabiti, in ba haka ba harafin asali.", "hi": "एक CPP फ़ंक्शन `char f_27(char letter)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए अक्षर के मामले को बदलता है।\n\nयदि इनपुट एक छोटे अक्षर का है, तो यह बड़े अक्षर का संस्करण लौटाता है,\nऔर यदि इनपुट एक बड़े अक्षर का है, तो यह छोटे अक्षर का संस्करण लौटाता है।\nगैर-वर्णमाला वर्ण अपरिवर्तित लौटाए जाते हैं।\n\nउपयोग:\n  char result = f_27('b'); // result will be 'B'\n  char result = f_27('B'); // result will be 'b'\n\n@param letter इनपुट अक्षर जिसे परिवर्तित किया जाना है।\n@return अक्षर जिसका मामला उलटा हो जाता है यदि यह वर्णमाला है, अन्यथा मूल अक्षर।", "hu": "Írj egy CPP függvényt `char f_27(char letter)` a következő probléma megoldására:\nÁtalakítja egy adott betű kis- és nagybetűs formáját.\n\nHa a bemenet kisbetűs, akkor a nagybetűs változatát adja vissza,\nés ha a bemenet nagybetűs, akkor a kisbetűs változatát adja vissza.\nNem alfabetikus karakterek változatlanul kerülnek visszaadásra.\n\nHasználat:\n  char result = f_27('b'); // result 'B' lesz\n  char result = f_27('B'); // result 'b' lesz\n\n@param letter Az átalakítandó bemeneti betű.\n@return A betű megfordított kis- és nagybetűs formája, ha alfabetikus, egyébként az eredeti betű.", "es": "Escribe una función CPP `char f_27(char letter)` para resolver el siguiente problema:\nTransforma el caso de una letra dada.\n\nSi la entrada es una letra minúscula, devuelve la versión en mayúscula,\ny si la entrada es una letra mayúscula, devuelve la versión en minúscula.\nLos caracteres no alfabéticos se devuelven sin cambios.\n\nUso:\n  char result = f_27('b'); // result será 'B'\n  char result = f_27('B'); // result será 'b'\n\n@param letter La letra de entrada a transformar.\n@return La letra con su caso invertido si es alfabética, de lo contrario, la letra original.", "arb": "اكتب دالة CPP `char f_27(char letter)` لحل المشكلة التالية:\nتحول حالة الحرف المعطى.\n\nإذا كان الإدخال حرفًا صغيرًا، فإنه يعيد النسخة الكبيرة،\nوإذا كان الإدخال حرفًا كبيرًا، فإنه يعيد النسخة الصغيرة.\nالحروف غير الأبجدية تعاد دون تغيير.\n\nالاستخدام:\n  char result = f_27('b'); // النتيجة ستكون 'B'\n  char result = f_27('B'); // النتيجة ستكون 'b'\n\n@param letter الحرف المدخل الذي سيتم تحويله.\n@return الحرف مع عكس حالته إذا كان أبجديًا، وإلا يعاد الحرف الأصلي.", "sw": "Andika kazi ya CPP `char f_27(char letter)` kutatua tatizo lifuatalo:\nHubadilisha herufi kuwa katika hali tofauti.\n\nIkiwa ingizo ni herufi ndogo, inarudisha toleo la herufi kubwa,\nna ikiwa ingizo ni herufi kubwa, inarudisha toleo la herufi ndogo.\nHerufi zisizo za alfabeti zinarudishwa bila kubadilishwa.\n\nMatumizi:\n  char result = f_27('b'); // result itakuwa 'B'\n  char result = f_27('B'); // result itakuwa 'b'\n\n@param letter Herufi ya ingizo inayopaswa kubadilishwa.\n@return Herufi ikiwa na hali yake imebadilishwa ikiwa ni ya alfabeti, vinginevyo herufi asilia.", "tr": "Bir CPP fonksiyonu `char f_27(char letter)` yazın: Aşağıdaki problemi çözmek için:\n\nVerilen bir harfin büyük/küçük harf durumunu dönüştürür.\n\nEğer giriş küçük harf ise, büyük harf versiyonunu döndürür,\nve eğer giriş büyük harf ise, küçük harf versiyonunu döndürür.\nAlfabetik olmayan karakterler değişmeden geri döndürülür.\n\nKullanım:\n  char result = f_27('b'); // result 'B' olacaktır\n  char result = f_27('B'); // result 'b' olacaktır\n\n@param letter Dönüştürülecek giriş harfi.\n@return Eğer alfabetikse harfin büyük/küçük harf durumu tersine çevrilmiş hali, aksi takdirde orijinal harf.", "vi": "Viết một hàm CPP `char f_27(char letter)` để giải quyết vấn đề sau:\nChuyển đổi chữ hoa thành chữ thường của một chữ cái đã cho.\n\nNếu đầu vào là một chữ cái thường, nó sẽ trả về phiên bản chữ hoa,\nvà nếu đầu vào là một chữ cái hoa, nó sẽ trả về phiên bản chữ thường.\nCác ký tự không phải chữ cái được trả về không thay đổi.\n\nSử dụng:\n  char result = f_27('b'); // result sẽ là 'B'\n  char result = f_27('B'); // result sẽ là 'b'\n\n@param letter Chữ cái đầu vào cần được chuyển đổi.\n@return Chữ cái với trường hợp của nó bị đảo ngược nếu nó là chữ cái, nếu không thì trả về chữ cái gốc.", "id": "Tulis fungsi CPP `char f_27(char letter)` untuk menyelesaikan masalah berikut:\nMengubah huruf menjadi huruf besar atau kecil.\n\nJika input adalah huruf kecil, fungsi ini mengembalikan versi huruf besar,\ndan jika input adalah huruf besar, fungsi ini mengembalikan versi huruf kecil.\nKarakter non-alfabetik dikembalikan tanpa perubahan.\n\nPenggunaan:\n  char result = f_27('b'); // result akan menjadi 'B'\n  char result = f_27('B'); // result akan menjadi 'b'\n\n@param letter Huruf input yang akan diubah.\n@return Huruf dengan perubahan huruf besar/kecil jika itu alfabet, jika tidak, huruf asli.", "ja": "CPP関数`char f_27(char letter)`を作成して、次の問題を解決してください:\n指定された文字の大文字小文字を変換します。\n\n入力が小文字の場合、大文字バージョンを返し、\n入力が大文字の場合、小文字バージョンを返します。\nアルファベット以外の文字は変更せずに返されます。\n\n使用例:\n  char result = f_27('b'); // resultは 'B' になります\n  char result = f_27('B'); // resultは 'b' になります\n\n@param letter 変換する入力文字。\n@return アルファベットの場合はその文字の大文字小文字を逆にしたもの、それ以外の場合は元の文字。", "ko": "CPP 함수 `char f_27(char letter)`를 작성하여 다음 문제를 해결하십시오:\n주어진 문자의 대소문자를 변환합니다.\n\n입력이 소문자이면 대문자로 변환하여 반환하고,\n입력이 대문자이면 소문자로 변환하여 반환합니다.\n알파벳이 아닌 문자는 변경되지 않고 그대로 반환됩니다.\n\n사용 예:\n  char result = f_27('b'); // result는 'B'가 됩니다.\n  char result = f_27('B'); // result는 'b'가 됩니다.\n\n@param letter 변환할 입력 문자입니다.\n@return 알파벳 문자일 경우 대소문자가 반전된 문자를 반환하고, 그렇지 않으면 원래 문자를 반환합니다.", "ml": "ഒരു CPP ഫംഗ്ഷൻ `char f_27(char letter)` എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nഒരു നൽകിയ അക്ഷരത്തിന്റെ കേസിനെ മാറ്റുന്നു.\n\nഇൻപുട്ട് ഒരു ലൊവർകേസ് അക്ഷരമാണെങ്കിൽ, അത് അപ്പർകേസ് പതിപ്പ് തിരികെ നൽകുന്നു,\nമറ്റുവശത്ത്, ഇൻപുട്ട് ഒരു അപ്പർകേസ് അക്ഷരമാണെങ്കിൽ, അത് ലൊവർകേസ് പതിപ്പ് തിരികെ നൽകുന്നു.\nഅക്ഷരമല്ലാത്ത പ്രതീകങ്ങൾ മാറ്റമില്ലാതെ തിരികെ നൽകുന്നു.\n\nഉപയോഗം:\n  char result = f_27('b'); // ഫലമായി 'B' ലഭിക്കും\n  char result = f_27('B'); // ഫലമായി 'b' ലഭിക്കും\n\n@param letter മാറ്റാൻ ആവശ്യമായ ഇൻപുട്ട് അക്ഷരം.\n@return അത് അക്ഷരമാണെങ്കിൽ, അതിന്റെ കേസ് മറിച്ചുള്ള അക്ഷരം, അല്ലെങ്കിൽ യഥാർത്ഥ അക്ഷരം.", "fa": "یک تابع CPP `char f_27(char letter)` بنویسید تا مسئله زیر را حل کند:\nحالت حروف داده شده را تغییر می‌دهد.\n\nاگر ورودی یک حرف کوچک باشد، نسخه بزرگ آن را برمی‌گرداند،\nو اگر ورودی یک حرف بزرگ باشد، نسخه کوچک آن را برمی‌گرداند.\nکاراکترهای غیر الفبایی بدون تغییر برگردانده می‌شوند.\n\nاستفاده:\n  char result = f_27('b'); // نتیجه 'B' خواهد بود\n  char result = f_27('B'); // نتیجه 'b' خواهد بود\n\n@param letter حرف ورودی که باید تغییر یابد.\n@return حرف با تغییر حالت اگر الفبایی باشد، در غیر این صورت حرف اصلی."}, "level": "easy", "test": "int main() {\n    assert(f_27('b') == 'B');\n    assert(f_27('B') == 'b');\n    // Additional test cases\n    assert(f_27('z') == 'Z');\n    assert(f_27('Z') == 'z');\n    assert(f_27('m') == 'M');\n    assert(f_27('M') == 'm');\n    assert(f_27('1') == '1'); // Non-alphabetic, should be unchanged\n    assert(f_27('!') == '!'); // Non-alphabetic, should be unchanged\n\n    // Uncomment the following line to print a success message (optional)\n    \n    return 0;\n}", "entry_point": "f_27", "signature": "char f_27(char letter)", "docstring": {"en": "Transforms the case of a given letter.\n\nIf the input is a lowercase letter, it returns the uppercase version,\nand if the input is an uppercase letter, it returns the lowercase version.\nNon-alphabetic characters are returned unchanged.\n\nUsage:\n  char result = f_27('b'); // result will be 'B'\n  char result = f_27('B'); // result will be 'b'\n\n@param letter The input letter to be transformed.\n@return The letter with its case reversed if it's alphabetic, otherwise the original letter.\n", "sq": "Transformon shkronjën e dhënë në rast tjetër.\n\nNëse hyrja është një shkronjë e vogël, kthen versionin e saj me shkronja të mëdha,\ndhe nëse hyrja është një shkronjë e madhe, kthen versionin e saj me shkronja të vogla.\nKarakteret jo-alfabetike kthehen të pandryshuara.\n\nPërdorimi:\n  char result = f_27('b'); // rezultati do të jetë 'B'\n  char result = f_27('B'); // rezultati do të jetë 'b'\n\n@param letter Shkronja hyrëse që do të transformohet.\n@return Shkronja me rastin e saj të kthyer nëse është alfabetike, përndryshe shkronja origjinale.", "hy": "Փոխակերպում է տրված տառի ռեգիստրը։\n\nԵթե մուտքագրվածը փոքրատառ է, վերադարձնում է մեծատառ տարբերակը,\nիսկ եթե մուտքագրվածը մեծատառ է, վերադարձնում է փոքրատառ տարբերակը։\nԱյլ ոչ այբբենական նշանները վերադարձվում են առանց փոփոխության։\n\nՕգտագործում:\n  char result = f_27('b'); // result-ը կլինի 'B'\n  char result = f_27('B'); // result-ը կլինի 'b'\n\n@param letter Մուտքագրված տառը, որը պետք է փոխակերպվի։\n@return Տառը՝ իր ռեգիստրով փոխված, եթե այն այբբենական է, հակառակ դեպքում՝ բնօրինակ տառը։", "bn": "একটি প্রদত্ত অক্ষরের কেস পরিবর্তন করে।\n\nযদি ইনপুটটি একটি ছোট হাতের অক্ষর হয়, এটি বড় হাতের সংস্করণটি ফেরত দেয়,\nএবং যদি ইনপুটটি একটি বড় হাতের অক্ষর হয়, এটি ছোট হাতের সংস্করণটি ফেরত দেয়।\nঅ্যালফাবেটিক নয় এমন অক্ষর অপরিবর্তিত অবস্থায় ফেরত দেওয়া হয়।\n\nব্যবহার:\n  char result = f_27('b'); // result হবে 'B'\n  char result = f_27('B'); // result হবে 'b'\n\n@param letter রূপান্তর করার জন্য ইনপুট অক্ষর।\n@return অক্ষরটি যদি অ্যালফাবেটিক হয় তবে তার কেস উল্টানো অবস্থায় ফেরত দেয়, অন্যথায় মূল অক্ষরটি।", "bg": "Преобразува регистъра на дадена буква.\n\nАко входът е малка буква, връща главната версия,\nа ако входът е главна буква, връща малката версия.\nНеалфабетните символи се връщат непроменени.\n\nУпотреба:\n  char result = f_27('b'); // result ще бъде 'B'\n  char result = f_27('B'); // result ще бъде 'b'\n\n@param letter Входната буква, която ще бъде преобразувана.\n@return Буквата с обърнат регистър, ако е алфабетна, в противен случай оригиналната буква.", "zh": "将给定字母的大小写转换。\n\n如果输入是小写字母，则返回大写版本，\n如果输入是大写字母，则返回小写版本。\n非字母字符将保持不变。\n\n用法:\n  char result = f_27('b'); // result 将是 'B'\n  char result = f_27('B'); // result 将是 'b'\n\n@param letter 要转换的输入字母。\n@return 如果是字母，则返回大小写反转的字母，否则返回原始字母。", "fr": "Transforme la casse d'une lettre donnée.\n\nSi l'entrée est une lettre minuscule, elle retourne la version majuscule,\net si l'entrée est une lettre majuscule, elle retourne la version minuscule.\nLes caractères non alphabétiques sont retournés inchangés.\n\nUtilisation :\n  char result = f_27('b'); // result sera 'B'\n  char result = f_27('B'); // result sera 'b'\n\n@param letter La lettre d'entrée à transformer.\n@return La lettre avec sa casse inversée si elle est alphabétique, sinon la lettre originale.", "de": "Verändert die Groß-/Kleinschreibung eines gegebenen Buchstabens.\n\nWenn die Eingabe ein Kleinbuchstabe ist, wird die Großbuchstabenversion zurückgegeben,\nund wenn die Eingabe ein Großbuchstabe ist, wird die Kleinbuchstabenversion zurückgegeben.\nNicht-alphabetische Zeichen werden unverändert zurückgegeben.\n\nVerwendung:\n  char result = f_27('b'); // result wird 'B' sein\n  char result = f_27('B'); // result wird 'b' sein\n\n@param letter Der Eingabebuchstabe, der umgewandelt werden soll.\n@return Der Buchstabe mit umgekehrter Groß-/Kleinschreibung, wenn er alphabetisch ist, andernfalls der ursprüngliche Buchstabe.", "ha": "Canza harafin da aka bayar daga babba zuwa ƙanana ko daga ƙanana zuwa babba.\n\nIdan harafin da aka shigar harafi ne ƙarami, zai mayar da shi babba,\nkuma idan harafin da aka shigar babba ne, zai mayar da shi ƙarami.\nHaruffan da ba na haruffa ba za a mayar da su ba tare da canji ba.\n\nAmfani:\n  char result = f_27('b'); // sakamakon zai zama 'B'\n  char result = f_27('B'); // sakamakon zai zama 'b'\n\n@param letter Harafin da aka shigar da za a canza.\n@return Harafin da aka juya yanayin idan harafi ne, in ba haka ba asalin harafin.", "hi": "दिए गए अक्षर के मामले को बदलता है।\n\nयदि इनपुट एक लोअरकेस अक्षर है, तो यह अपरकेस संस्करण लौटाता है,\nऔर यदि इनपुट एक अपरकेस अक्षर है, तो यह लोअरकेस संस्करण लौटाता है।\nगैर-अक्षरीय वर्ण अपरिवर्तित लौटाए जाते हैं।\n\nउपयोग:\n  char result = f_27('b'); // result होगा 'B'\n  char result = f_27('B'); // result होगा 'b'\n\n@param letter वह इनपुट अक्षर जिसे बदला जाना है।\n@return अक्षर जिसका मामला उलटा गया है यदि यह अक्षरीय है, अन्यथा मूल अक्षर।", "hu": "Átalakítja egy adott betű kis- és nagybetűs formáját.\n\nHa a bemenet kisbetű, akkor a nagybetűs változatát adja vissza,\nés ha a bemenet nagybetű, akkor a kisbetűs változatát adja vissza.\nA nem alfabetikus karakterek változatlanul kerülnek visszaadásra.\n\nHasználat:\n  char result = f_27('b'); // result 'B' lesz\n  char result = f_27('B'); // result 'b' lesz\n\n@param letter Az átalakítandó bemeneti betű.\n@return A betű megfordított kis- és nagybetűs változata, ha alfabetikus, különben az eredeti betű.", "es": "Transforma el caso de una letra dada.\n\nSi la entrada es una letra minúscula, devuelve la versión en mayúscula,\ny si la entrada es una letra mayúscula, devuelve la versión en minúscula.\nLos caracteres no alfabéticos se devuelven sin cambios.\n\nUso:\n  char result = f_27('b'); // result será 'B'\n  char result = f_27('B'); // result será 'b'\n\n@param letter La letra de entrada a transformar.\n@return La letra con su caso invertido si es alfabética, de lo contrario, la letra original.", "arb": "يحوّل حالة حرف معين.\n\nإذا كان الإدخال حرفًا صغيرًا، فإنه يعيد النسخة الكبيرة،\nوإذا كان الإدخال حرفًا كبيرًا، فإنه يعيد النسخة الصغيرة.\nيتم إرجاع الأحرف غير الأبجدية دون تغيير.\n\nالاستخدام:\n  char result = f_27('b'); // النتيجة ستكون 'B'\n  char result = f_27('B'); // النتيجة ستكون 'b'\n\n@param letter الحرف المدخل المراد تحويله.\n@return الحرف مع عكس حالته إذا كان أبجديًا، وإلا الحرف الأصلي.", "sw": "Hubadilisha herufi kubwa au ndogo ya herufi iliyotolewa.\n\nIkiwa ingizo ni herufi ndogo, itarudisha toleo la herufi kubwa,\nna ikiwa ingizo ni herufi kubwa, itarudisha toleo la herufi ndogo.\nHerufi zisizo za alfabeti zitarudishwa bila kubadilishwa.\n\nMatumizi:\n  char result = f_27('b'); // result itakuwa 'B'\n  char result = f_27('B'); // result itakuwa 'b'\n\n@param letter Herufi ya ingizo inayopaswa kubadilishwa.\n@return Herufi ikiwa imebadilishwa herufi kubwa au ndogo ikiwa ni ya alfabeti, vinginevyo herufi asili.", "tr": "Verilen bir harfin büyük/küçük harf durumunu değiştirir.\n\nEğer giriş küçük harfse, büyük harf versiyonunu döndürür,\nve eğer giriş büyük harfse, küçük harf versiyonunu döndürür.\nAlfabetik olmayan karakterler değişmeden döndürülür.\n\nKullanım:\n  char result = f_27('b'); // result 'B' olacaktır\n  char result = f_27('B'); // result 'b' olacaktır\n\n@param letter Dönüştürülecek giriş harfi.\n@return Eğer alfabetikse harfin büyük/küçük harf durumu değiştirilmiş hali, aksi takdirde orijinal harf.", "vi": "Biến đổi chữ hoa/thường của một chữ cái cho trước.\n\nNếu đầu vào là một chữ cái viết thường, nó trả về phiên bản viết hoa,\nvà nếu đầu vào là một chữ cái viết hoa, nó trả về phiên bản viết thường.\nCác ký tự không phải chữ cái được trả về không thay đổi.\n\nSử dụng:\n  char result = f_27('b'); // result sẽ là 'B'\n  char result = f_27('B'); // result sẽ là 'b'\n\n@param letter Chữ cái đầu vào cần được biến đổi.\n@return Chữ cái với chữ hoa/thường đảo ngược nếu nó là chữ cái, ngược lại trả về chữ cái gốc.", "id": "Mengubah huruf menjadi huruf besar atau kecil.\n\nJika input adalah huruf kecil, fungsi ini mengembalikan versi huruf besar,\ndan jika input adalah huruf besar, fungsi ini mengembalikan versi huruf kecil.\nKarakter non-alfabetik dikembalikan tanpa perubahan.\n\nPenggunaan:\n  char result = f_27('b'); // hasilnya akan 'B'\n  char result = f_27('B'); // hasilnya akan 'b'\n\n@param letter Huruf input yang akan diubah.\n@return Huruf dengan perubahan besar-kecil jika itu alfabetik, jika tidak, huruf asli.", "ja": "与えられた文字の大文字小文字を変換します。\n\n入力が小文字の場合、大文字バージョンを返し、\n入力が大文字の場合、小文字バージョンを返します。\nアルファベット以外の文字は変更されずに返されます。\n\n使用例:\n  char result = f_27('b'); // result は 'B' になります\n  char result = f_27('B'); // result は 'b' になります\n\n@param letter 変換する入力文字。\n@return アルファベットの場合は大文字小文字を反転した文字、それ以外の場合は元の文字。", "ko": "주어진 문자의 대소문자를 변환합니다.\n\n입력이 소문자일 경우 대문자로 변환하여 반환하고,\n입력이 대문자일 경우 소문자로 변환하여 반환합니다.\n알파벳이 아닌 문자는 변경되지 않고 그대로 반환됩니다.\n\n사용 예:\n  char result = f_27('b'); // result는 'B'가 됩니다.\n  char result = f_27('B'); // result는 'b'가 됩니다.\n\n@param letter 변환할 입력 문자입니다.\n@return 알파벳일 경우 대소문자가 반전된 문자, 그렇지 않으면 원래 문자를 반환합니다.", "ml": "നൽകിയ അക്ഷരത്തിന്റെ കേസിനെ മാറ്റുന്നു.\n\nഇൻപുട്ട് ചെറിയ അക്ഷരമെങ്കിൽ, അതിന്റെ വലിയ അക്ഷര രൂപം തിരികെ നൽകുന്നു, \nമറ്റുവശത്ത്, ഇൻപുട്ട് വലിയ അക്ഷരമെങ്കിൽ, അതിന്റെ ചെറിയ അക്ഷര രൂപം തിരികെ നൽകുന്നു. \nഅക്ഷരമല്ലാത്ത പ്രതീകങ്ങൾ മാറ്റമില്ലാതെ തിരികെ നൽകുന്നു.\n\nഉപയോഗം:\n  char result = f_27('b'); // ഫലമായി 'B' ലഭിക്കും\n  char result = f_27('B'); // ഫലമായി 'b' ലഭിക്കും\n\n@param letter മാറ്റേണ്ട ഇൻപുട്ട് അക്ഷരം.\n@return അത് അക്ഷരമെങ്കിൽ, അതിന്റെ കേസ് മറിച്ചുകാണിക്കുന്ന അക്ഷരം, അല്ലെങ്കിൽ ഒറിജിനൽ അക്ഷരം.", "fa": "حالت یک حرف داده شده را تغییر می‌دهد.\n\nاگر ورودی یک حرف کوچک باشد، نسخه بزرگ آن را برمی‌گرداند، و اگر ورودی یک حرف بزرگ باشد، نسخه کوچک آن را برمی‌گرداند. کاراکترهای غیرالفبایی بدون تغییر برگردانده می‌شوند.\n\nاستفاده:\n  char result = f_27('b'); // نتیجه 'B' خواهد بود\n  char result = f_27('B'); // نتیجه 'b' خواهد بود\n\n@param letter حرف ورودی که باید تغییر یابد.\n@return حرف با حالت معکوس اگر الفبایی باشد، در غیر این صورت حرف اصلی."}}
{"task_id": "CPP/28", "prompt": {"en": "#include <cassert>\n#include <cstdio>\n/**\n * Displays the ASCII information for a given character.\n * \n * @param character The input character for which ASCII information is to be displayed.\n * @return The corresponding ASCII code.\n * \n * Example:\n * ```cpp\n * int asciiCode = f_28('A');\n * std::cout << asciiCode; // Output: 65\n * ```\n */\nint f_28(char character)", "sq": "#include <cassert>\n#include <cstdio>\n/**\n * Shfaq informacionin ASCII për një karakter të dhënë.\n * \n * @param character Karakteri hyrës për të cilin do të shfaqet informacioni ASCII.\n * @return Kodi përkatës ASCII.\n * \n * Shembull:\n * ```cpp\n * int asciiCode = f_28('A');\n * std::cout << asciiCode; // Output: 65\n * ```\n */\nint f_28(char character)", "hy": "#include <cassert>\n#include <cstdio>\n/**\n * Ցուցադրում է տրված սիմվոլի ASCII տեղեկատվությունը։\n * \n * @param character Մուտքային սիմվոլը, որի համար պետք է ցուցադրվի ASCII տեղեկատվությունը։\n * @return Համապատասխանող ASCII կոդը։\n * \n * Օրինակ:\n * ```cpp\n * int asciiCode = f_28('A');\n * std::cout << asciiCode; // Output: 65\n * ```\n */\nint f_28(char character)", "bn": "#include <cassert>\n#include <cstdio>\n/**\n * প্রদত্ত অক্ষরের জন্য ASCII তথ্য প্রদর্শন করে।\n * \n * @param character ইনপুট অক্ষর যার জন্য ASCII তথ্য প্রদর্শন করা হবে।\n * @return সংশ্লিষ্ট ASCII কোড।\n * \n * উদাহরণ:\n * ```cpp\n * int asciiCode = f_28('A');\n * std::cout << asciiCode; // Output: 65\n * ```\n */\nint f_28(char character)", "bg": "#include <cassert>\n#include <cstdio>\n/**\n * Показва ASCII информацията за даден символ.\n * \n * @param character Входният символ, за който ще се покаже ASCII информацията.\n * @return Съответният ASCII код.\n * \n * Пример:\n * ```cpp\n * int asciiCode = f_28('A');\n * std::cout << asciiCode; // Output: 65\n * ```\n */\nint f_28(char character)", "zh": "#include <cassert>\n#include <cstdio>\n/**\n * 显示给定字符的ASCII信息。\n * \n * @param character 要显示ASCII信息的输入字符。\n * @return 对应的ASCII码。\n * \n * 示例:\n * ```cpp\n * int asciiCode = f_28('A');\n * std::cout << asciiCode; // 输出: 65\n * ```\n */\nint f_28(char character)", "fr": "#include <cassert>\n#include <cstdio>\n/**\n * Affiche les informations ASCII pour un caractère donné.\n * \n * @param character Le caractère d'entrée pour lequel les informations ASCII doivent être affichées.\n * @return Le code ASCII correspondant.\n * \n * Exemple:\n * ```cpp\n * int asciiCode = f_28('A');\n * std::cout << asciiCode; // Output: 65\n * ```\n */\nint f_28(char character)", "de": "#include <cassert>\n#include <cstdio>\n/**\n * Zeigt die ASCII-Informationen für ein gegebenes Zeichen an.\n * \n * @param character Das Eingabezeichen, für das die ASCII-Informationen angezeigt werden sollen.\n * @return Der entsprechende ASCII-Code.\n * \n * Beispiel:\n * ```cpp\n * int asciiCode = f_28('A');\n * std::cout << asciiCode; // Ausgabe: 65\n * ```\n */\nint f_28(char character)", "ha": "#include <cassert>\n#include <cstdio>\n/**\n * Nuna bayanin ASCII don wata alama da aka bayar.\n * \n * @param character Alamar shigarwa wanda za a nuna bayanin ASCII.\n * @return Lambar ASCII da ta dace.\n * \n * Misali:\n * ```cpp\n * int asciiCode = f_28('A');\n * std::cout << asciiCode; // Output: 65\n * ```\n */\nint f_28(char character)", "hi": "#include <cassert>\n#include <cstdio>\n/**\n * दिए गए अक्षर के लिए ASCII जानकारी प्रदर्शित करता है।\n * \n * @param character वह इनपुट अक्षर जिसके लिए ASCII जानकारी प्रदर्शित की जानी है।\n * @return संबंधित ASCII कोड।\n * \n * Example:\n * ```cpp\n * int asciiCode = f_28('A');\n * std::cout << asciiCode; // Output: 65\n * ```\n */\nint f_28(char character)", "hu": "#include <cassert>\n#include <cstdio>\n/**\n * Megjeleníti az ASCII információt egy adott karakterhez.\n * \n * @param character Az input karakter, amelyhez az ASCII információt meg kell jeleníteni.\n * @return A megfelelő ASCII kód.\n * \n * Példa:\n * ```cpp\n * int asciiCode = f_28('A');\n * std::cout << asciiCode; // Output: 65\n * ```\n */\nint f_28(char character)", "es": "#include <cassert>\n#include <cstdio>\n/**\n * Muestra la información ASCII para un carácter dado.\n * \n * @param character El carácter de entrada para el cual se mostrará la información ASCII.\n * @return El código ASCII correspondiente.\n * \n * Ejemplo:\n * ```cpp\n * int asciiCode = f_28('A');\n * std::cout << asciiCode; // Output: 65\n * ```\n */\nint f_28(char character)", "arb": "#include <cassert>\n#include <cstdio>\n/**\n * يعرض معلومات ASCII لحرف معين.\n * \n * @param character الحرف المدخل الذي سيتم عرض معلومات ASCII له.\n * @return رمز ASCII المقابل.\n * \n * مثال:\n * ```cpp\n * int asciiCode = f_28('A');\n * std::cout << asciiCode; // Output: 65\n * ```\n */\nint f_28(char character)", "sw": "#include <cassert>\n#include <cstdio>\n/**\n * Inaonyesha taarifa za ASCII kwa herufi iliyotolewa.\n * \n * @param character Herufi ya ingizo ambayo taarifa za ASCII zinapaswa kuonyeshwa.\n * @return Nambari ya ASCII inayolingana.\n * \n * Mfano:\n * ```cpp\n * int asciiCode = f_28('A');\n * std::cout << asciiCode; // Output: 65\n * ```\n */\nint f_28(char character)", "tr": "#include <cassert>\n#include <cstdio>\n/**\n * Belirtilen bir karakter için ASCII bilgisini görüntüler.\n * \n * @param character ASCII bilgisinin görüntüleneceği giriş karakteri.\n * @return Karşılık gelen ASCII kodu.\n * \n * Örnek:\n * ```cpp\n * int asciiCode = f_28('A');\n * std::cout << asciiCode; // Çıktı: 65\n * ```\n */\nint f_28(char character)", "vi": "#include <cassert>\n#include <cstdio>\n/**\n * Hiển thị thông tin ASCII cho một ký tự nhất định.\n * \n * @param character Ký tự đầu vào mà thông tin ASCII cần được hiển thị.\n * @return Mã ASCII tương ứng.\n * \n * Ví dụ:\n * ```cpp\n * int asciiCode = f_28('A');\n * std::cout << asciiCode; // Output: 65\n * ```\n */\nint f_28(char character)", "id": "#include <cassert>\n#include <cstdio>\n/**\n * Menampilkan informasi ASCII untuk karakter yang diberikan.\n * \n * @param character Karakter input yang informasinya akan ditampilkan.\n * @return Kode ASCII yang sesuai.\n * \n * Contoh:\n * cpp\n * int asciiCode = f_28('A');\n * std::cout << asciiCode; // Output: 65\n * \n */\nint f_28(char character)", "ja": "#include <cassert>\n#include <cstdio>\n/**\n * 指定された文字のASCII情報を表示します。\n * \n * @param character ASCII情報を表示するための入力文字。\n * @return 対応するASCIIコード。\n * \n * 例:\n * cpp\n * int asciiCode = f_28('A');\n * std::cout << asciiCode; // Output: 65\n * \n */\nint f_28(char character)", "ko": "#include <cassert>\n#include <cstdio>\n/**\n * 주어진 문자에 대한 ASCII 정보를 표시합니다.\n * \n * @param character ASCII 정보를 표시할 입력 문자입니다.\n * @return 해당하는 ASCII 코드입니다.\n * \n * 예시:\n * cpp\n * int asciiCode = f_28('A');\n * std::cout << asciiCode; // 출력: 65\n * \n */\nint f_28(char character)", "ml": "#include <cassert>\n#include <cstdio>\n/**\n * നൽകിയ അക്ഷരത്തിനായുള്ള ASCII വിവരങ്ങൾ പ്രദർശിപ്പിക്കുന്നു.\n * \n * @param character ASCII വിവരങ്ങൾ പ്രദർശിപ്പിക്കേണ്ട ഇൻപുട്ട് അക്ഷരം.\n * @return അനുബന്ധ ASCII കോഡ്.\n * \n * ഉദാഹരണം:\n * cpp\n * int asciiCode = f_28('A');\n * std::cout << asciiCode; // Output: 65\n * \n */\nint f_28(char character)", "fa": "#include <cassert>\n#include <cstdio>\n/**\n * اطلاعات ASCII را برای یک کاراکتر داده شده نمایش می‌دهد.\n * \n * @param character کاراکتر ورودی که اطلاعات ASCII آن باید نمایش داده شود.\n * @return کد ASCII مربوطه.\n * \n * مثال:\n * cpp\n * int asciiCode = f_28('A');\n * std::cout << asciiCode; // Output: 65\n * \n */\nint f_28(char character)"}, "canonical_solution": "{\n    return character;\n}", "instruction": {"en": "Write a CPP function `int f_28(char character)` to solve the following problem:\nDisplays the ASCII information for a given character.\n\n@param character The input character for which ASCII information is to be displayed.\n@return The corresponding ASCII code.\n\nExample:\n```cpp\nint asciiCode = f_28('A');\nstd::cout << asciiCode; // Output: 65\n```", "sq": "Shkruani një funksion CPP `int f_28(char character)` për të zgjidhur problemin në vijim:\nShfaq informacionin ASCII për një karakter të dhënë.\n\n@param character Karakteri i hyrjes për të cilin informacioni ASCII do të shfaqet.\n@return Kodi përkatës ASCII.\n\nShembull:\n```cpp\nint asciiCode = f_28('A');\nstd::cout << asciiCode; // Output: 65\n```", "hy": "Գրեք CPP ֆունկցիա `int f_28(char character)` հետևյալ խնդիրը լուծելու համար:\nՑուցադրում է տրված սիմվոլի ASCII տեղեկատվությունը։\n\n@param character Մուտքային սիմվոլը, որի համար պետք է ցուցադրվի ASCII տեղեկատվությունը։\n@return Համապատասխան ASCII կոդը։\n\nՕրինակ:\n```cpp\nint asciiCode = f_28('A');\nstd::cout << asciiCode; // Output: 65\n```", "bn": "একটি CPP ফাংশন `int f_28(char character)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি প্রদত্ত অক্ষরের জন্য ASCII তথ্য প্রদর্শন করে।\n\n@param character ইনপুট অক্ষর যার জন্য ASCII তথ্য প্রদর্শন করা হবে।\n@return সংশ্লিষ্ট ASCII কোড।\n\nউদাহরণ:\n```cpp\nint asciiCode = f_28('A');\nstd::cout << asciiCode; // আউটপুট: 65\n```", "bg": "Напишете CPP функция `int f_28(char character)` за решаване на следния проблем:  \nПоказва ASCII информацията за даден символ.\n\n@param character Входният символ, за който ще се покаже ASCII информацията.  \n@return Съответният ASCII код.\n\nПример:  \n```cpp\nint asciiCode = f_28('A');\nstd::cout << asciiCode; // Output: 65\n```", "zh": "编写一个 CPP 函数 `int f_28(char character)` 来解决以下问题：\n显示给定字符的 ASCII 信息。\n\n@param character 要显示其 ASCII 信息的输入字符。\n@return 对应的 ASCII 代码。\n\n示例:\n```cpp\nint asciiCode = f_28('A');\nstd::cout << asciiCode; // 输出: 65\n```", "fr": "Écrire une fonction CPP `int f_28(char character)` pour résoudre le problème suivant :  \nAffiche les informations ASCII pour un caractère donné.\n\n@param character Le caractère d'entrée pour lequel les informations ASCII doivent être affichées.  \n@return Le code ASCII correspondant.\n\nExemple:\n```cpp\nint asciiCode = f_28('A');\nstd::cout << asciiCode; // Output: 65\n```", "de": "Schreiben Sie eine CPP-Funktion `int f_28(char character)`, um das folgende Problem zu lösen:\nZeigt die ASCII-Informationen für ein gegebenes Zeichen an.\n\n@param character Das Eingabezeichen, für das die ASCII-Informationen angezeigt werden sollen.\n@return Der entsprechende ASCII-Code.\n\nBeispiel:\n```cpp\nint asciiCode = f_28('A');\nstd::cout << asciiCode; // Ausgabe: 65\n```", "ha": "Rubuta aikin CPP `int f_28(char character)` don warware matsalar mai zuwa:  \nNuna bayanin ASCII don wata alama da aka bayar.\n\n@param character Alamar shigarwa wadda za a nuna bayanin ASCII dinta.  \n@return Lambar ASCII da ta dace.\n\nMisali:\n```cpp\nint asciiCode = f_28('A');\nstd::cout << asciiCode; // Output: 65\n```", "hi": "एक CPP फ़ंक्शन `int f_28(char character)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए अक्षर के लिए ASCII जानकारी प्रदर्शित करता है।\n\n@param character वह इनपुट अक्षर जिसके लिए ASCII जानकारी प्रदर्शित की जानी है।\n@return संबंधित ASCII कोड।\n\nउदाहरण:\n```cpp\nint asciiCode = f_28('A');\nstd::cout << asciiCode; // Output: 65\n```", "hu": "Írj egy CPP függvényt `int f_28(char character)` a következő probléma megoldására:\nMegjeleníti a megadott karakter ASCII információit.\n\n@param character Az a bemeneti karakter, amelynek ASCII információit meg kell jeleníteni.\n@return A megfelelő ASCII kód.\n\nPélda:\n```cpp\nint asciiCode = f_28('A');\nstd::cout << asciiCode; // Kimenet: 65\n```", "es": "Escribe una función CPP `int f_28(char character)` para resolver el siguiente problema:\nMuestra la información ASCII para un carácter dado.\n\n@param character El carácter de entrada para el cual se mostrará la información ASCII.\n@return El código ASCII correspondiente.\n\nExample:\n```cpp\nint asciiCode = f_28('A');\nstd::cout << asciiCode; // Output: 65", "arb": "اكتب دالة CPP `int f_28(char character)` لحل المشكلة التالية:\nيعرض معلومات ASCII للحرف المعطى.\n\n@param character الحرف المدخل الذي سيتم عرض معلومات ASCII له.\n@return رمز ASCII المقابل.\n\nمثال:\n```cpp\nint asciiCode = f_28('A');\nstd::cout << asciiCode; // Output: 65", "sw": "Andika kazi ya CPP `int f_28(char character)` kutatua tatizo lifuatalo: \nOnyesha taarifa za ASCII kwa herufi iliyotolewa.\n\n@param character Herufi ya ingizo ambayo taarifa za ASCII zinapaswa kuonyeshwa.\n@return Msimbo wa ASCII unaolingana.\n\nMfano:\n```cpp\nint asciiCode = f_28('A');\nstd::cout << asciiCode; // Output: 65", "tr": "Bir CPP fonksiyonu `int f_28(char character)` yazın: \nVerilen bir karakter için ASCII bilgisini görüntüler.\n\n@param character ASCII bilgisinin görüntüleneceği giriş karakteri.\n@return Karşılık gelen ASCII kodu.\n\nÖrnek:\n```cpp\nint asciiCode = f_28('A');\nstd::cout << asciiCode; // Çıktı: 65", "vi": "Viết một hàm CPP `int f_28(char character)` để giải quyết vấn đề sau:  \nHiển thị thông tin ASCII cho một ký tự đã cho.\n\n@param character Ký tự đầu vào mà thông tin ASCII cần được hiển thị.  \n@return Mã ASCII tương ứng.\n\nVí dụ:\n```cpp\nint asciiCode = f_28('A');\nstd::cout << asciiCode; // Output: 65", "id": "Tulis fungsi CPP `int f_28(char character)` untuk menyelesaikan masalah berikut:\nMenampilkan informasi ASCII untuk karakter yang diberikan.\n\n@param character Karakter input untuk mana informasi ASCII akan ditampilkan.\n@return Kode ASCII yang sesuai.\n\nContoh:\ncpp\nint asciiCode = f_28('A');\nstd::cout << asciiCode; // Output: 65", "ja": "CPP関数 `int f_28(char character)` を作成して、次の問題を解決してください:\n指定された文字のASCII情報を表示します。\n\n@param character ASCII情報を表示するための入力文字。\n@return 対応するASCIIコード。\n\n例:\ncpp\nint asciiCode = f_28('A');\nstd::cout << asciiCode; // 出力: 65", "ko": "다음 문제를 해결하기 위해 CPP 함수를 작성하세요: `int f_28(char character)`\n\n주어진 문자에 대한 ASCII 정보를 표시합니다.\n\n@param character ASCII 정보를 표시할 입력 문자입니다.\n@return 해당 ASCII 코드입니다.\n\n예시:\ncpp\nint asciiCode = f_28('A');\nstd::cout << asciiCode; // 출력: 65", "ml": "CPP ഫംഗ്ഷൻ `int f_28(char character)` എഴുതുക താഴെ കൊടുത്തിരിക്കുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nനൽകിയിരിക്കുന്ന അക്ഷരത്തിനായുള്ള ASCII വിവരങ്ങൾ പ്രദർശിപ്പിക്കുന്നു.\n\n@param character ASCII വിവരങ്ങൾ പ്രദർശിപ്പിക്കേണ്ട ഇൻപുട്ട് അക്ഷരം.\n@return അനുബന്ധ ASCII കോഡ്.\n\nഉദാഹരണം:\ncpp\nint asciiCode = f_28('A');\nstd::cout << asciiCode; // Output: 65", "fa": "یک تابع CPP بنویسید `int f_28(char character)` برای حل مسئله زیر:\nنمایش اطلاعات ASCII برای یک کاراکتر داده شده.\n\n@param character کاراکتر ورودی که اطلاعات ASCII آن باید نمایش داده شود.\n@return کد ASCII مربوطه.\n\nمثال:\ncpp\nint asciiCode = f_28('A');\nstd::cout << asciiCode; // Output: 65"}, "level": "easy", "test": "int main() {\n    assert(f_28('A') == 65);\n    assert(f_28('B') == 66); // Additional test case\n    assert(f_28('0') == 48); // Additional test case\n    assert(f_28(' ') == 32); // Additional test case\n    \n    // Uncomment the line below to print a success message if compiled outside a test framework\n    // std::printf(\"All tests passed.\\n\");\n\n    return 0;\n}", "entry_point": "f_28", "signature": "int f_28(char character)", "docstring": {"en": "Displays the ASCII information for a given character.\n\n@param character The input character for which ASCII information is to be displayed.\n@return The corresponding ASCII code.\n\nExample:\n```cpp\nint asciiCode = f_28('A');\nstd::cout << asciiCode; // Output: 65\n```", "sq": "Shfaq informacionin ASCII për një karakter të dhënë.\n\n@param character Karakteri hyrës për të cilin do të shfaqet informacioni ASCII.\n@return Kodi përkatës ASCII.\n\nShembull:\n```cpp\nint asciiCode = f_28('A');\nstd::cout << asciiCode; // Output: 65\n```", "hy": "Տպում է ASCII տեղեկատվությունը տրված սիմվոլի համար։\n\n@param character Մուտքային սիմվոլը, որի համար պետք է տպել ASCII տեղեկատվությունը։\n@return Համապատասխանող ASCII կոդը։\n\nՕրինակ:\n```cpp\nint asciiCode = f_28('A');\nstd::cout << asciiCode; // Output: 65\n```", "bn": "একটি প্রদত্ত অক্ষরের জন্য ASCII তথ্য প্রদর্শন করে।\n\n@param character ইনপুট অক্ষর যার জন্য ASCII তথ্য প্রদর্শন করা হবে।\n@return সংশ্লিষ্ট ASCII কোড।\n\nউদাহরণ:\n```cpp\nint asciiCode = f_28('A');\nstd::cout << asciiCode; // Output: 65\n```", "bg": "Показва ASCII информацията за даден символ.\n\n@param character Входният символ, за който трябва да се покаже ASCII информацията.\n@return Съответният ASCII код.\n\nПример:\n```cpp\nint asciiCode = f_28('A');\nstd::cout << asciiCode; // Изход: 65\n```", "zh": "显示给定字符的ASCII信息。\n\n@param character 要显示ASCII信息的输入字符。\n@return 对应的ASCII代码。\n\n示例：\n```cpp\nint asciiCode = f_28('A');\nstd::cout << asciiCode; // 输出: 65\n```", "fr": "Affiche les informations ASCII pour un caractère donné.\n\n@param character Le caractère d'entrée pour lequel les informations ASCII doivent être affichées.\n@return Le code ASCII correspondant.\n\nExemple :\n```cpp\nint asciiCode = f_28('A');\nstd::cout << asciiCode; // Sortie : 65\n```", "de": "Zeigt die ASCII-Informationen für ein gegebenes Zeichen an.\n\n@param character Das Eingabezeichen, für das die ASCII-Informationen angezeigt werden sollen.\n@return Der entsprechende ASCII-Code.\n\nBeispiel:\n```cpp\nint asciiCode = f_28('A');\nstd::cout << asciiCode; // Ausgabe: 65\n```", "ha": "Nuna bayanin ASCII don wata alama da aka bayar.\n\n@param character Harafin shigarwa wanda za a nuna bayanin ASCII.\n@return Lambar ASCII da ta dace.\n\nMisali:\n```cpp\nint asciiCode = f_28('A');\nstd::cout << asciiCode; // Output: 65\n```", "hi": "दिए गए वर्ण के लिए ASCII जानकारी प्रदर्शित करता है।\n\n@param character वह इनपुट वर्ण जिसके लिए ASCII जानकारी प्रदर्शित की जानी है।\n@return संबंधित ASCII कोड।\n\nउदाहरण:\n```cpp\nint asciiCode = f_28('A');\nstd::cout << asciiCode; // आउटपुट: 65\n```", "hu": "Megjeleníti a megadott karakter ASCII információját.\n\n@param character A bemeneti karakter, amelynek az ASCII információját meg kell jeleníteni.\n@return A megfelelő ASCII kód.\n\nPélda:\n```cpp\nint asciiCode = f_28('A');\nstd::cout << asciiCode; // Kimenet: 65\n```", "es": "Muestra la información ASCII para un carácter dado.\n\n@param character El carácter de entrada para el cual se mostrará la información ASCII.\n@return El código ASCII correspondiente.\n\nEjemplo:\n```cpp\nint asciiCode = f_28('A');\nstd::cout << asciiCode; // Output: 65", "arb": "يعرض معلومات ASCII للحرف المعطى.\n\n@param character الحرف المدخل الذي سيتم عرض معلومات ASCII له.\n@return كود ASCII المقابل.\n\nمثال:\n```cpp\nint asciiCode = f_28('A');\nstd::cout << asciiCode; // Output: 65", "sw": "Inaonyesha habari za ASCII kwa herufi iliyotolewa.\n\n@param character Herufi ya ingizo ambayo habari za ASCII zinaonyeshwa.\n@return Nambari ya ASCII inayolingana.\n\nMfano:\n```cpp\nint asciiCode = f_28('A');\nstd::cout << asciiCode; // Output: 65", "tr": "Belirtilen karakter için ASCII bilgisini görüntüler.\n\n@param character ASCII bilgisinin görüntüleneceği giriş karakteri.\n@return Karşılık gelen ASCII kodu.\n\nÖrnek:\n```cpp\nint asciiCode = f_28('A');\nstd::cout << asciiCode; // Çıktı: 65", "vi": "Hiển thị thông tin ASCII cho một ký tự được cung cấp.\n\n@param character Ký tự đầu vào mà thông tin ASCII cần được hiển thị.\n@return Mã ASCII tương ứng.\n\nVí dụ:\n```cpp\nint asciiCode = f_28('A');\nstd::cout << asciiCode; // Output: 65", "id": "Menampilkan informasi ASCII untuk karakter yang diberikan.\n\n@param character Karakter input yang akan ditampilkan informasi ASCII-nya.\n@return Kode ASCII yang sesuai.\n\nContoh:\ncpp\nint asciiCode = f_28('A');\nstd::cout << asciiCode; // Output: 65", "ja": "与えられた文字のASCII情報を表示します。\n\n@param character ASCII情報を表示するための入力文字。\n@return 対応するASCIIコード。\n\n例:\ncpp\nint asciiCode = f_28('A');\nstd::cout << asciiCode; // 出力: 65", "ko": "주어진 문자에 대한 ASCII 정보를 표시합니다.\n\n@param character ASCII 정보를 표시할 입력 문자입니다.\n@return 해당하는 ASCII 코드입니다.\n\n예시:\ncpp\nint asciiCode = f_28('A');\nstd::cout << asciiCode; // 출력: 65", "ml": "ASCII വിവരങ്ങൾ നൽകിയ അക്ഷരത്തിനായി പ്രദർശിപ്പിക്കുന്നു.\n\n@param character ASCII വിവരങ്ങൾ പ്രദർശിപ്പിക്കേണ്ട ഇൻപുട്ട് അക്ഷരം.\n@return അനുബന്ധ ASCII കോഡ്.\n\nഉദാഹരണം:\ncpp\nint asciiCode = f_28('A');\nstd::cout << asciiCode; // Output: 65", "fa": "اطلاعات ASCII را برای یک کاراکتر داده شده نمایش می‌دهد.\n\n@param character کاراکتر ورودی که اطلاعات ASCII برای آن نمایش داده می‌شود.\n@return کد ASCII متناظر.\n\nمثال:\ncpp\nint asciiCode = f_28('A');\nstd::cout << asciiCode; // Output: 65"}}
{"task_id": "CPP/29", "prompt": {"en": "#include <cassert> // Used for making assertions in test cases\n/**\n * @brief Evaluate the grade for an input integer.\n * \n * @param score The integer score to be evaluated.\n * @return char The grade corresponding to the input score.\n *              If the score is between 90 and 100 (inclusive), returns 'A'.\n *              Otherwise, returns 'B'.\n * \n * Examples:\n *     f_29(90) -> 'A'\n *     f_29(89) -> 'B'\n */\nchar f_29(int score)", "sq": "#include <cassert> // Përdoret për të bërë pohime në rastet e testimit\n/**\n * @brief Vlerëson notën për një numër të plotë hyrës.\n * \n * @param score Nota e plotë që do të vlerësohet.\n * @return char Nota që korrespondon me notën hyrëse.\n *              Nëse nota është midis 90 dhe 100 (përfshirë), kthen 'A'.\n *              Përndryshe, kthen 'B'.\n * \n * Shembuj:\n *     f_29(90) -> 'A'\n *     f_29(89) -> 'B'\n */\nchar f_29(int score)", "hy": "#include <cassert> // Օգտագործվում է թեստային դեպքերում հաստատումներ կատարելու համար\n/**\n * @brief Գնահատել մուտքային ամբողջ թվի գնահատականը։\n * \n * @param score Գնահատման ենթակա ամբողջ թիվը։\n * @return char Մուտքային գնահատականին համապատասխանող գնահատականը։\n *              Եթե գնահատականը 90-ից 100-ի (ներառյալ) միջև է, վերադարձնում է 'A'։\n *              Հակառակ դեպքում, վերադարձնում է 'B'։\n * \n * Օրինակներ:\n *     f_29(90) -> 'A'\n *     f_29(89) -> 'B'\n */\nchar f_29(int score)", "bn": "#include <cassert> // টেস্ট কেসে অ্যাসারশন করার জন্য ব্যবহৃত হয়\n/**\n * @brief একটি পূর্ণসংখ্যার জন্য গ্রেড মূল্যায়ন করুন।\n * \n * @param score মূল্যায়ন করার জন্য পূর্ণসংখ্যার স্কোর।\n * @return char ইনপুট স্কোরের সাথে সম্পর্কিত গ্রেড।\n *              যদি স্কোর 90 এবং 100 (অন্তর্ভুক্ত) এর মধ্যে হয়, তাহলে 'A' রিটার্ন করে।\n *              অন্যথায়, 'B' রিটার্ন করে।\n * \n * উদাহরণ:\n *     f_29(90) -> 'A'\n *     f_29(89) -> 'B'\n */\nchar f_29(int score)", "bg": "#include <cassert> // Използва се за извършване на твърдения в тестови случаи\n/**\n * @brief Оценява оценката за входно цяло число.\n * \n * @param score Цялочислената оценка, която трябва да бъде оценена.\n * @return char Оценката, съответстваща на входната оценка.\n *              Ако оценката е между 90 и 100 (включително), връща 'A'.\n *              В противен случай връща 'B'.\n * \n * Примери:\n *     f_29(90) -> 'A'\n *     f_29(89) -> 'B'\n */\nchar f_29(int score)", "zh": "#include <cassert> // 用于在测试用例中进行断言\n/**\n * @brief 评估输入整数的等级。\n * \n * @param score 要评估的整数分数。\n * @return char 与输入分数对应的等级。\n *              如果分数在90到100之间（包括90和100），返回'A'。\n *              否则，返回'B'。\n * \n * 示例:\n *     f_29(90) -> 'A'\n *     f_29(89) -> 'B'\n */\nchar f_29(int score)", "fr": "#include <cassert> // Utilisé pour faire des assertions dans les cas de test\n/**\n * @brief Évaluer la note pour un entier en entrée.\n * \n * @param score Le score entier à évaluer.\n * @return char La note correspondant au score en entrée.\n *              Si le score est entre 90 et 100 (inclus), retourne 'A'.\n *              Sinon, retourne 'B'.\n * \n * Exemples :\n *     f_29(90) -> 'A'\n *     f_29(89) -> 'B'\n */\nchar f_29(int score)", "de": "#include <cassert> // Wird für Assertions in Testfällen verwendet\n/**\n * @brief Bewertet die Note für eine Eingabezahl.\n * \n * @param score Die zu bewertende ganze Zahl.\n * @return char Die Note, die der Eingabezahl entspricht.\n *              Wenn die Punktzahl zwischen 90 und 100 (einschließlich) liegt, wird 'A' zurückgegeben.\n *              Andernfalls wird 'B' zurückgegeben.\n * \n * Beispiele:\n *     f_29(90) -> 'A'\n *     f_29(89) -> 'B'\n */\nchar f_29(int score)", "ha": "#include <cassert> // Ana amfani da wannan don yin tabbaci a gwaje-gwaje\n\n/**\n * @brief Kimanta darajar maki don wani lamba.\n * \n * @param score Makin lamba da za a kimanta.\n * @return char Darajar da ta dace da makin da aka shigar.\n *              Idan makin yana tsakanin 90 da 100 (ciki har da), zai dawo da 'A'.\n *              In ba haka ba, zai dawo da 'B'.\n * \n * Misalai:\n *     f_29(90) -> 'A'\n *     f_29(89) -> 'B'\n */\nchar f_29(int score)", "hi": "#include <cassert> // परीक्षण मामलों में अभिकथन करने के लिए उपयोग किया जाता है\n/**\n * @brief किसी इनपुट पूर्णांक के लिए ग्रेड का मूल्यांकन करें।\n * \n * @param score मूल्यांकन के लिए पूर्णांक स्कोर।\n * @return char इनपुट स्कोर के अनुरूप ग्रेड।\n *              यदि स्कोर 90 और 100 (समावेशी) के बीच है, तो 'A' लौटाता है।\n *              अन्यथा, 'B' लौटाता है।\n * \n * उदाहरण:\n *     f_29(90) -> 'A'\n *     f_29(89) -> 'B'\n */\nchar f_29(int score)", "hu": "#include <cassert> // Használva az állítások megfogalmazására a tesztesetekben\n/**\n * @brief Értékeli a jegyet egy bemeneti egész számhoz.\n * \n * @param score Az értékelendő egész szám pontszám.\n * @return char A bemeneti pontszámhoz tartozó jegy.\n *              Ha a pontszám 90 és 100 között van (beleértve), 'A'-t ad vissza.\n *              Ellenkező esetben 'B'-t ad vissza.\n * \n * Példák:\n *     f_29(90) -> 'A'\n *     f_29(89) -> 'B'\n */\nchar f_29(int score)", "es": "#include <cassert> // Usado para hacer afirmaciones en casos de prueba\n/**\n * @brief Evalúa la calificación para un número entero de entrada.\n * \n * @param score La puntuación entera que se va a evaluar.\n * @return char La calificación correspondiente a la puntuación de entrada.\n *              Si la puntuación está entre 90 y 100 (inclusive), devuelve 'A'.\n *              De lo contrario, devuelve 'B'.\n * \n * Ejemplos:\n *     f_29(90) -> 'A'\n *     f_29(89) -> 'B'\n */\nchar f_29(int score)", "arb": "#include <cassert> // مستخدم لإجراء التأكيدات في حالات الاختبار\n/**\n * @brief تقييم الدرجة لعدد صحيح مدخل.\n * \n * @param score الدرجة الصحيحة التي سيتم تقييمها.\n * @return char الدرجة المقابلة للدرجة المدخلة.\n *              إذا كانت الدرجة بين 90 و 100 (شاملة)، تعيد 'A'.\n *              خلاف ذلك، تعيد 'B'.\n * \n * أمثلة:\n *     f_29(90) -> 'A'\n *     f_29(89) -> 'B'\n */\nchar f_29(int score)", "sw": "#include <cassert> // Inatumika kwa kufanya uthibitisho katika kesi za majaribio\n/**\n * @brief Tambua daraja kwa namba kamili iliyoingizwa.\n * \n * @param score Alama ya namba kamili inayotakiwa kutathminiwa.\n * @return char Daraja linalolingana na alama iliyoingizwa.\n *              Ikiwa alama iko kati ya 90 na 100 (pamoja), inarudisha 'A'.\n *              Vinginevyo, inarudisha 'B'.\n * \n * Mifano:\n *     f_29(90) -> 'A'\n *     f_29(89) -> 'B'\n */\nchar f_29(int score)", "tr": "#include <cassert> // Test durumlarında doğrulama yapmak için kullanılır\n/**\n * @brief Bir tam sayı için notu değerlendirir.\n * \n * @param score Değerlendirilecek tam sayı puanı.\n * @return char Girdi puanına karşılık gelen not.\n *              Eğer puan 90 ile 100 arasında (dahil) ise, 'A' döner.\n *              Aksi takdirde, 'B' döner.\n * \n * Örnekler:\n *     f_29(90) -> 'A'\n *     f_29(89) -> 'B'\n */\nchar f_29(int score)", "vi": "#include <cassert> // Được sử dụng để thực hiện các khẳng định trong các trường hợp kiểm tra\n/**\n * @brief Đánh giá điểm cho một số nguyên đầu vào.\n * \n * @param score Điểm số nguyên cần được đánh giá.\n * @return char Điểm tương ứng với điểm số đầu vào.\n *              Nếu điểm số nằm trong khoảng từ 90 đến 100 (bao gồm cả 90 và 100), trả về 'A'.\n *              Ngược lại, trả về 'B'.\n * \n * Ví dụ:\n *     f_29(90) -> 'A'\n *     f_29(89) -> 'B'\n */\nchar f_29(int score)", "id": "#include <cassert> // Digunakan untuk membuat pernyataan dalam kasus uji\n/**\n * @brief Mengevaluasi nilai untuk sebuah bilangan bulat masukan.\n * \n * @param score Skor bilangan bulat yang akan dievaluasi.\n * @return char Nilai yang sesuai dengan skor masukan.\n *              Jika skor antara 90 dan 100 (inklusif), mengembalikan 'A'.\n *              Jika tidak, mengembalikan 'B'.\n * \n * Contoh:\n *     f_29(90) -> 'A'\n *     f_29(89) -> 'B'\n */\nchar f_29(int score)", "ja": "#include <cassert> // テストケースでアサーションを行うために使用されます\n/**\n * @brief 入力整数の評価を行います。\n * \n * @param score 評価される整数スコア。\n * @return char 入力スコアに対応するグレード。\n *              スコアが90から100の間（含む）の場合、'A'を返します。\n *              それ以外の場合は、'B'を返します。\n * \n * 例:\n *     f_29(90) -> 'A'\n *     f_29(89) -> 'B'\n */\nchar f_29(int score)", "ko": "#include <cassert> // 테스트 케이스에서 주장을 하기 위해 사용됨\n/**\n * @brief 입력 정수에 대한 등급을 평가합니다.\n * \n * @param score 평가할 정수 점수입니다.\n * @return char 입력 점수에 해당하는 등급을 반환합니다.\n *              점수가 90과 100 사이(포함)인 경우 'A'를 반환합니다.\n *              그렇지 않으면 'B'를 반환합니다.\n * \n * 예시:\n *     f_29(90) -> 'A'\n *     f_29(89) -> 'B'\n */\nchar f_29(int score)", "ml": "#include <cassert> // ടെസ്റ്റ് കേസുകളിൽ ഉറപ്പുകൾ നടത്താൻ ഉപയോഗിക്കുന്നു\n/**\n * @brief ഒരു ഇൻപുട്ട് പൂർണ്ണസംഖ്യയ്ക്ക് ഗ്രേഡ് വിലയിരുത്തുക.\n * \n * @param score വിലയിരുത്തേണ്ട പൂർണ്ണസംഖ്യ സ്കോർ.\n * @return char ഇൻപുട്ട് സ്കോറിനൊത്തുള്ള ഗ്രേഡ്.\n *              സ്കോർ 90നും 100നും (ഉൾപ്പെടെ) ഇടയിൽ ആണെങ്കിൽ, 'A' മടക്കിനൽകുന്നു.\n *              അല്ലെങ്കിൽ, 'B' മടക്കിനൽകുന്നു.\n * \n * ഉദാഹരണങ്ങൾ:\n *     f_29(90) -> 'A'\n *     f_29(89) -> 'B'\n */\nchar f_29(int score)", "fa": "#include <cassert> // برای ایجاد اطمینان در موارد تست استفاده می‌شود\n/**\n * @brief ارزیابی نمره برای یک عدد صحیح ورودی.\n * \n * @param score نمره صحیحی که باید ارزیابی شود.\n * @return char نمره‌ای که با نمره ورودی مطابقت دارد.\n *              اگر نمره بین 90 و 100 (شامل) باشد، 'A' را برمی‌گرداند.\n *              در غیر این صورت، 'B' را برمی‌گرداند.\n * \n * مثال‌ها:\n *     f_29(90) -> 'A'\n *     f_29(89) -> 'B'\n */\nchar f_29(int score)"}, "canonical_solution": "{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}", "instruction": {"en": "Write a CPP function `char f_29(int score)` to solve the following problem:\nEvaluate the grade for an input integer.\n\n@param score The integer score to be evaluated.\n@return char The grade corresponding to the input score.\n             If the score is between 90 and 100 (inclusive), returns 'A'.\n             Otherwise, returns 'B'.\n\nExamples:\n    f_29(90) -> 'A'\n    f_29(89) -> 'B'\n", "sq": "Shkruani një funksion CPP `char f_29(int score)` për të zgjidhur problemin e mëposhtëm:\nVlerësoni notën për një numër të plotë të dhënë.\n\n@param score Numri i plotë i pikëve që do të vlerësohet.\n@return char Nota që korrespondon me pikët e dhëna.\n             Nëse pikët janë midis 90 dhe 100 (përfshirë), kthen 'A'.\n             Përndryshe, kthen 'B'.\n\nShembuj:\n    f_29(90) -> 'A'\n    f_29(89) -> 'B'", "hy": "Գրեք CPP ֆունկցիա `char f_29(int score)` հետևյալ խնդիրը լուծելու համար:\nԳնահատել մուտքային ամբողջ թվային գնահատականը:\n\n@param score Գնահատման ենթակա ամբողջ թվային միավորը:\n@return char Մուտքային գնահատականին համապատասխանող գնահատականը:\n             Եթե գնահատականը 90-ից 100-ի (ներառյալ) միջակայքում է, վերադարձնում է 'A':\n             Հակառակ դեպքում, վերադարձնում է 'B':\n\nՕրինակներ:\n    f_29(90) -> 'A'\n    f_29(89) -> 'B'", "bn": "একটি CPP ফাংশন `char f_29(int score)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি ইনপুট পূর্ণসংখ্যার জন্য গ্রেড মূল্যায়ন করুন।\n\n@param score মূল্যায়ন করার জন্য পূর্ণসংখ্যা স্কোর।\n@return char ইনপুট স্কোরের সাথে সম্পর্কিত গ্রেড।\n             যদি স্কোর 90 এবং 100 (অন্তর্ভুক্ত) এর মধ্যে হয়, তাহলে 'A' প্রদান করে।\n             অন্যথায়, 'B' প্রদান করে।\n\nউদাহরণ:\n    f_29(90) -> 'A'\n    f_29(89) -> 'B'", "bg": "Напишете CPP функция `char f_29(int score)`, за да решите следния проблем:\nОценете оценката за входно цяло число.\n\n@param score Цялото число, което трябва да бъде оценено.\n@return char Оценката, съответстваща на входното число.\n             Ако числото е между 90 и 100 (включително), връща 'A'.\n             В противен случай връща 'B'.\n\nПримери:\n    f_29(90) -> 'A'\n    f_29(89) -> 'B'", "zh": "编写一个 CPP 函数 `char f_29(int score)` 来解决以下问题：\n评估输入整数的等级。\n\n@param score 要评估的整数分数。\n@return char 与输入分数对应的等级。\n             如果分数在 90 到 100 之间（包括 90 和 100），返回 'A'。\n             否则，返回 'B'。\n\n示例：\n    f_29(90) -> 'A'\n    f_29(89) -> 'B'", "fr": "Écrire une fonction CPP `char f_29(int score)` pour résoudre le problème suivant :\nÉvaluer la note pour un entier en entrée.\n\n@param score L'entier à évaluer.\n@return char La note correspondant au score en entrée.\n             Si le score est entre 90 et 100 (inclus), retourne 'A'.\n             Sinon, retourne 'B'.\n\nExemples :\n    f_29(90) -> 'A'\n    f_29(89) -> 'B'", "de": "Schreiben Sie eine CPP-Funktion `char f_29(int score)`, um das folgende Problem zu lösen:\nBewerten Sie die Note für eine Eingabezahl.\n\n@param score Die zu bewertende ganze Zahl.\n@return char Die Note, die der Eingabezahl entspricht.\n             Wenn die Punktzahl zwischen 90 und 100 (einschließlich) liegt, wird 'A' zurückgegeben.\n             Andernfalls wird 'B' zurückgegeben.\n\nBeispiele:\n    f_29(90) -> 'A'\n    f_29(89) -> 'B'", "ha": "Rubuta aikin CPP `char f_29(int score)` don warware matsalar mai zuwa:\nKimanta darajar don shigar da cikakken lamba.\n\n@param score Cikakken lambar da za a kimanta.\n@return char Darajar da ta dace da lambar da aka shigar.\n             Idan lambar tana tsakanin 90 da 100 (ciki har da), zai dawo da 'A'.\n             In ba haka ba, zai dawo da 'B'.\n\nMisalai:\n    f_29(90) -> 'A'\n    f_29(89) -> 'B'", "hi": "`char f_29(int score)` फ़ंक्शन लिखें ताकि निम्नलिखित समस्या का समाधान हो सके:\nइनपुट पूर्णांक का ग्रेड मूल्यांकन करें।\n\n@param score मूल्यांकन के लिए पूर्णांक स्कोर।\n@return char इनपुट स्कोर के अनुरूप ग्रेड।\n             यदि स्कोर 90 और 100 (समावेशी) के बीच है, तो 'A' लौटाता है।\n             अन्यथा, 'B' लौटाता है।\n\nउदाहरण:\n    f_29(90) -> 'A'\n    f_29(89) -> 'B'", "hu": "Írj egy CPP függvényt `char f_29(int score)` a következő probléma megoldására:\nÉrtékeld ki a jegyet egy egész számú bemenet alapján.\n\n@param score Az egész számú pontszám, amelyet ki kell értékelni.\n@return char A bemeneti pontszámnak megfelelő jegy.\n             Ha a pontszám 90 és 100 között van (beleértve), 'A'-t ad vissza.\n             Egyébként 'B'-t ad vissza.\n\nPéldák:\n    f_29(90) -> 'A'\n    f_29(89) -> 'B'", "es": "Escribe una función CPP `char f_29(int score)` para resolver el siguiente problema:\nEvalúa la calificación para un entero de entrada.\n\n@param score El puntaje entero a ser evaluado.\n@return char La calificación correspondiente al puntaje de entrada.\n             Si el puntaje está entre 90 y 100 (inclusive), devuelve 'A'.\n             De lo contrario, devuelve 'B'.\n\nEjemplos:\n    f_29(90) -> 'A'\n    f_29(89) -> 'B'", "arb": "اكتب دالة CPP `char f_29(int score)` لحل المشكلة التالية:\nتقييم الدرجة لعدد صحيح مدخل.\n\n@param score العدد الصحيح الذي سيتم تقييمه.\n@return char الدرجة المقابلة للعدد المدخل.\n             إذا كانت الدرجة بين 90 و 100 (شاملة)، تعيد 'A'.\n             خلاف ذلك، تعيد 'B'.\n\nأمثلة:\n    f_29(90) -> 'A'\n    f_29(89) -> 'B'", "sw": "Andika kazi ya CPP `char f_29(int score)` kutatua tatizo lifuatalo:\nTambua alama kwa namba kamili iliyoingizwa.\n\n@param score Namba kamili ya alama itakayopimwa.\n@return char Alama inayolingana na alama iliyoingizwa.\n             Ikiwa alama iko kati ya 90 na 100 (pamoja), inarudisha 'A'.\n             Vinginevyo, inarudisha 'B'.\n\nMifano:\n    f_29(90) -> 'A'\n    f_29(89) -> 'B'", "tr": "Bir CPP fonksiyonu `char f_29(int score)` yazın: Aşağıdaki problemi çözmek için:\nBir tamsayı notunu değerlendirin.\n\n@param score Değerlendirilecek tamsayı notu.\n@return char Girdi notuna karşılık gelen harf notu.\n             Eğer not 90 ile 100 arasında (dahil) ise, 'A' döner.\n             Aksi takdirde, 'B' döner.\n\nÖrnekler:\n    f_29(90) -> 'A'\n    f_29(89) -> 'B'", "vi": "Viết một hàm CPP `char f_29(int score)` để giải quyết vấn đề sau:  \nĐánh giá điểm cho một số nguyên đầu vào.\n\n@param score Số nguyên điểm cần được đánh giá.  \n@return char Điểm tương ứng với điểm đầu vào.  \n             Nếu điểm nằm trong khoảng từ 90 đến 100 (bao gồm cả 90 và 100), trả về 'A'.  \n             Ngược lại, trả về 'B'.\n\nVí dụ:  \n    f_29(90) -> 'A'  \n    f_29(89) -> 'B'  ", "id": "Tulis fungsi CPP `char f_29(int score)` untuk menyelesaikan masalah berikut:\nEvaluasi nilai untuk sebuah bilangan bulat masukan.\n\n@param score Skor bilangan bulat yang akan dievaluasi.\n@return char Nilai yang sesuai dengan skor masukan.\n             Jika skor antara 90 dan 100 (inklusif), mengembalikan 'A'.\n             Jika tidak, mengembalikan 'B'.\n\nContoh:\n    f_29(90) -> 'A'\n    f_29(89) -> 'B'", "ja": "以下の問題を解決するために、CPP関数 `char f_29(int score)` を作成してください:\n入力された整数の評価を行います。\n\n@param score 評価する整数スコア。\n@return char 入力スコアに対応する成績。\n             スコアが90から100の間（含む）の場合は 'A' を返します。\n             それ以外の場合は 'B' を返します。\n\n例:\n    f_29(90) -> 'A'\n    f_29(89) -> 'B'", "ko": "다음 문제를 해결하기 위해 CPP 함수를 작성하세요: `char f_29(int score)`:\n입력 정수에 대한 등급을 평가합니다.\n\n@param score 평가할 정수 점수입니다.\n@return char 입력 점수에 해당하는 등급입니다.\n             점수가 90에서 100 사이(포함)인 경우 'A'를 반환합니다.\n             그렇지 않으면 'B'를 반환합니다.\n\n예시:\n    f_29(90) -> 'A'\n    f_29(89) -> 'B'", "ml": "CPP ഫംഗ്ഷൻ `char f_29(int score)` എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:  \nഇൻപുട്ട് ഇന്റിജർ ഗ്രേഡ് വിലയിരുത്തുക.\n\n@param score വിലയിരുത്തേണ്ട ഇന്റിജർ സ്കോർ.  \n@return char ഇൻപുട്ട് സ്കോറിന് അനുയോജ്യമായ ഗ്രേഡ്.  \n             സ്കോർ 90നും 100നും ഇടയിൽ (ഉൾപ്പെടെ) ആണെങ്കിൽ, 'A' തിരിച്ചുനൽകുന്നു.  \n             അല്ലാത്തപക്ഷം, 'B' തിരിച്ചുനൽകുന്നു.\n\nഉദാഹരണങ്ങൾ:  \n    f_29(90) -> 'A'  \n    f_29(89) -> 'B'  ", "fa": "یک تابع CPP بنویسید `char f_29(int score)` برای حل مسئله زیر:\nارزیابی نمره برای یک عدد صحیح ورودی.\n\n@param score نمره صحیحی که باید ارزیابی شود.\n@return char نمره‌ای که با نمره ورودی مطابقت دارد.\n             اگر نمره بین 90 و 100 (شامل) باشد، 'A' را برمی‌گرداند.\n             در غیر این صورت، 'B' را برمی‌گرداند.\n\nمثال‌ها:\n    f_29(90) -> 'A'\n    f_29(89) -> 'B'"}, "level": "easy", "test": "int main() {\n    assert(f_29(90) == 'A'); // Test for lower bound of 'A' grade\n    assert(f_29(89) == 'B'); // Test for score just below 'A' grade\n    assert(f_29(95) == 'A'); // Test for a score well within the 'A' range\n    assert(f_29(100) == 'A'); // Test for upper boundary of 'A' grade\n    assert(f_29(101) == 'B'); // Test for score above 'A' grade range\n\n    // Print \"All tests passed\" if all assertions hold true (optional)\n    // std::cout << \"All tests passed\\n\";\n\n    return 0;\n}", "entry_point": "f_29", "signature": "char f_29(int score)", "docstring": {"en": "Evaluate the grade for an input integer.\n\n@param score The integer score to be evaluated.\n@return char The grade corresponding to the input score.\n             If the score is between 90 and 100 (inclusive), returns 'A'.\n             Otherwise, returns 'B'.\n\nExamples:\n    f_29(90) -> 'A'\n    f_29(89) -> 'B'\n", "sq": "Vlerësoni notën për një numër të plotë hyrës.\n\n@param score Numri i plotë i pikëve që do të vlerësohet.\n@return char Nota që korrespondon me pikët hyrëse.\n             Nëse pikët janë midis 90 dhe 100 (përfshirë), kthen 'A'.\n             Përndryshe, kthen 'B'.\n\nShembuj:\n    f_29(90) -> 'A'\n    f_29(89) -> 'B'", "hy": "Հաշվարկել գնահատականը մուտքային ամբողջ թվի համար։\n\n@param score Գնահատվող ամբողջ թվային միավորը։\n@return char Մուտքային միավորին համապատասխան գնահատականը։\n             Եթե միավորը 90-ից 100-ի (ներառյալ) միջև է, վերադարձնում է 'A'։\n             Հակառակ դեպքում, վերադարձնում է 'B'։\n\nՕրինակներ:\n    f_29(90) -> 'A'\n    f_29(89) -> 'B'", "bn": "একটি ইনপুট পূর্ণসংখ্যার জন্য গ্রেড মূল্যায়ন করুন।\n\n@param score মূল্যায়ন করার জন্য পূর্ণসংখ্যার স্কোর।\n@return char ইনপুট স্কোরের সাথে সম্পর্কিত গ্রেড।\n             যদি স্কোর 90 এবং 100 এর মধ্যে হয় (অন্তর্ভুক্ত), তবে 'A' ফেরত দেয়।\n             অন্যথায়, 'B' ফেরত দেয়।\n\nউদাহরণ:\n    f_29(90) -> 'A'\n    f_29(89) -> 'B'", "bg": "Оценете оценката за входящо цяло число.\n\n@param score Цялото число, което трябва да бъде оценено.\n@return char Оценката, съответстваща на входящия резултат.\n             Ако резултатът е между 90 и 100 (включително), връща 'A'.\n             В противен случай връща 'B'.\n\nПримери:\n    f_29(90) -> 'A'\n    f_29(89) -> 'B'", "zh": "评估输入整数的等级。\n\n@param score 要评估的整数分数。\n@return char 与输入分数对应的等级。\n如果分数在90到100之间（包括90和100），返回'A'。\n             否则，返回'B'。\n\n示例：\n    f_29(90) -> 'A'\n    f_29(89) -> 'B'", "fr": "Évaluer la note pour un entier en entrée.\n\n@param score L'entier score à évaluer.\n@return char La note correspondant au score d'entrée.\n             Si le score est entre 90 et 100 (inclus), retourne 'A'.\n             Sinon, retourne 'B'.\n\nExemples :\n    f_29(90) -> 'A'\n    f_29(89) -> 'B'", "de": "Bewerten Sie die Note für eine eingegebene ganze Zahl.\n\n@param score Die ganzzahlige Punktzahl, die bewertet werden soll.\n@return char Die Note, die der eingegebenen Punktzahl entspricht.\n             Wenn die Punktzahl zwischen 90 und 100 (einschließlich) liegt, wird 'A' zurückgegeben.\n             Andernfalls wird 'B' zurückgegeben.\n\nBeispiele:\n    f_29(90) -> 'A'\n    f_29(89) -> 'B'", "ha": "Kimanta darajar don shigar da cikakken lamba.\n\n@param score Lambar da za a tantance.\n@return char Darajar da ta dace da lambar shigarwa.\n             Idan lambar tana tsakanin 90 da 100 (ciki har da), yana dawowa 'A'.\n             In ba haka ba, yana dawowa 'B'.\n\nMisalai:\n    f_29(90) -> 'A'\n    f_29(89) -> 'B'", "hi": "इनपुट पूर्णांक के लिए ग्रेड का मूल्यांकन करें।\n\n@param score मूल्यांकन के लिए पूर्णांक स्कोर।\n@return char इनपुट स्कोर के अनुरूप ग्रेड।\n             यदि स्कोर 90 और 100 (समावेशी) के बीच है, तो 'A' लौटाता है।\n             अन्यथा, 'B' लौटाता है।\n\nउदाहरण:\n    f_29(90) -> 'A'\n    f_29(89) -> 'B'", "hu": "Értékelje egy bemeneti egész szám osztályzatát.\n\n@param score Az értékelendő egész szám pontszám.\n@return char Az osztályzat, amely megfelel a bemeneti pontszámnak.\n             Ha a pontszám 90 és 100 között van (beleértve), 'A'-t ad vissza.\n             Egyébként 'B'-t ad vissza.\n\nPéldák:\n    f_29(90) -> 'A'\n    f_29(89) -> 'B'", "es": "Evaluar la calificación para un entero de entrada.\n\n@param score El puntaje entero a evaluar.\n@return char La calificación correspondiente al puntaje de entrada.\n             Si el puntaje está entre 90 y 100 (inclusive), devuelve 'A'.\n             De lo contrario, devuelve 'B'.\n\nEjemplos:\n    f_29(90) -> 'A'\n    f_29(89) -> 'B'", "arb": "تقييم الدرجة لعدد صحيح مدخل.\n\n@param score الدرجة الصحيحة التي سيتم تقييمها.\n@return char الدرجة المقابلة للدرجة المدخلة.\n             إذا كانت الدرجة بين 90 و100 (شاملة)، تُرجع 'A'.\n             خلاف ذلك، تُرجع 'B'.\n\nأمثلة:\n    f_29(90) -> 'A'\n    f_29(89) -> 'B'", "sw": "Tambua alama kwa namba kamili iliyoingizwa.\n\n@param score Namba kamili ya alama itakayopimwa.\n@return char Daraja linalolingana na alama iliyoingizwa.\n             Ikiwa alama iko kati ya 90 na 100 (pamoja), inarudisha 'A'.\n             Vinginevyo, inarudisha 'B'.\n\nMifano:\n    f_29(90) -> 'A'\n    f_29(89) -> 'B'", "tr": "Girdi tamsayısı için notu değerlendirir.\n\n@param score Değerlendirilecek tamsayı puanı.\n@return char Girdi puanına karşılık gelen not.\n             Eğer puan 90 ile 100 arasında (dahil) ise, 'A' döndürür.\n             Aksi takdirde, 'B' döndürür.\n\nÖrnekler:\n    f_29(90) -> 'A'\n    f_29(89) -> 'B'", "vi": "Đánh giá điểm cho một số nguyên đầu vào.\n\n@param score Số nguyên điểm cần được đánh giá.\n@return char Điểm tương ứng với điểm đầu vào.\n             Nếu điểm nằm trong khoảng từ 90 đến 100 (bao gồm cả 90 và 100), trả về 'A'.\n             Ngược lại, trả về 'B'.\n\nVí dụ:\n    f_29(90) -> 'A'\n    f_29(89) -> 'B'", "id": "Evaluasi nilai untuk sebuah bilangan bulat masukan.\n\n@param score Nilai bilangan bulat yang akan dievaluasi.\n@return char Nilai yang sesuai dengan skor masukan.\n             Jika skor antara 90 dan 100 (inklusif), mengembalikan 'A'.\n             Jika tidak, mengembalikan 'B'.\n\nContoh:\n    f_29(90) -> 'A'\n    f_29(89) -> 'B'", "ja": "入力された整数の評価を行います。\n\n@param score 評価される整数のスコア。\n@return char 入力スコアに対応するグレード。\n             スコアが90から100の間（含む）の場合は 'A' を返します。\n             それ以外の場合は 'B' を返します。\n\n例:\n    f_29(90) -> 'A'\n    f_29(89) -> 'B'", "ko": "입력 정수에 대한 등급을 평가합니다.\n\n@param score 평가할 정수 점수입니다.\n@return char 입력 점수에 해당하는 등급입니다.\n             점수가 90에서 100 사이(포함)인 경우 'A'를 반환합니다.\n             그렇지 않으면 'B'를 반환합니다.\n\n예시:\n    f_29(90) -> 'A'\n    f_29(89) -> 'B'", "ml": "ഒരു ഇൻപുട്ട് പൂർണ്ണസംഖ്യയ്ക്ക് ഗ്രേഡ് വിലയിരുത്തുക.\n\n@param score മൂല്യനിർണയം ചെയ്യേണ്ട പൂർണ്ണസംഖ്യ സ്കോർ.\n@return char ഇൻപുട്ട് സ്കോറിനൊത്ത ഗ്രേഡ്.\n             സ്കോർ 90നും 100നും ഇടയിൽ (ഉൾപ്പെടെ) ആണെങ്കിൽ, 'A' തിരികെ നൽകും.\n             അല്ലാത്തപക്ഷം, 'B' തിരികെ നൽകും.\n\nഉദാഹരണങ്ങൾ:\n    f_29(90) -> 'A'\n    f_29(89) -> 'B'", "fa": "ارزیابی نمره برای یک عدد صحیح ورودی.\n\n@param score نمره صحیحی که باید ارزیابی شود.\n@return char نمره‌ای که با نمره ورودی مطابقت دارد.\n             اگر نمره بین 90 و 100 (شامل) باشد، 'A' را برمی‌گرداند.\n             در غیر این صورت، 'B' را برمی‌گرداند.\n\nمثال‌ها:\n    f_29(90) -> 'A'\n    f_29(89) -> 'B'"}}
{"task_id": "CPP/30", "prompt": {"en": "#include <cassert>\n#include <cstring>\n#include <cstdio>\n/**\n * Checks if a three-character string has exactly two characters that are the same.\n * \n * @param s A three-character string to be checked.\n * \n * @return Returns \"Yes\" if the input has exactly two equal characters, otherwise \"No\".\n * Examples:\n *   >>> f_30(\"112\")\n *   \"Yes\"\n *   >>> f_30(\"123\")\n *   \"No\"\n */\nconst char* f_30(const char s[4])", "sq": "#include <cassert>\n#include <cstring>\n#include <cstdio>\n/**\n * Kontrollon nëse një varg me tre karaktere ka saktësisht dy karaktere që janë të njëjta.\n * \n * @param s Një varg me tre karaktere që do të kontrollohet.\n * \n * @return Kthen \"Yes\" nëse inputi ka saktësisht dy karaktere të barabarta, përndryshe \"No\".\n * Shembuj:\n *   >>> f_30(\"112\")\n *   \"Yes\"\n *   >>> f_30(\"123\")\n *   \"No\"\n */\nconst char* f_30(const char s[4])", "hy": "#include <cassert>\n#include <cstring>\n#include <cstdio>\n/**\n * Ստուգում է, արդյոք երեք նիշից բաղկացած տողը ունի՞ ճիշտ երկու նույն նիշ։\n * \n * @param s Երեք նիշից բաղկացած տող, որը պետք է ստուգվի։\n * \n * @return Վերադարձնում է \"Yes\", եթե մուտքում կա ճիշտ երկու հավասար նիշ, հակառակ դեպքում՝ \"No\"։\n * Օրինակներ:\n *   >>> f_30(\"112\")\n *   \"Yes\"\n *   >>> f_30(\"123\")\n *   \"No\"\n */\nconst char* f_30(const char s[4])", "bn": "#include <cassert>\n#include <cstring>\n#include <cstdio>\n/**\n * পরীক্ষা করে যে একটি তিন-অক্ষরের স্ট্রিংয়ে ঠিক দুটি অক্ষর একই আছে কিনা।\n * \n * @param s একটি তিন-অক্ষরের স্ট্রিং যা পরীক্ষা করা হবে।\n * \n * @return \"Yes\" প্রদান করে যদি ইনপুটে ঠিক দুটি সমান অক্ষর থাকে, অন্যথায় \"No\"।\n * উদাহরণ:\n *   >>> f_30(\"112\")\n *   \"Yes\"\n *   >>> f_30(\"123\")\n *   \"No\"\n */\nconst char* f_30(const char s[4])", "bg": "#include <cassert>\n#include <cstring>\n#include <cstdio>\n/**\n * Проверява дали низ от три знака има точно два еднакви знака.\n * \n * @param s Низ от три знака, който трябва да бъде проверен.\n * \n * @return Връща \"Yes\", ако входът има точно два еднакви знака, в противен случай \"No\".\n * Примери:\n *   >>> f_30(\"112\")\n *   \"Yes\"\n *   >>> f_30(\"123\")\n *   \"No\"\n */\nconst char* f_30(const char s[4])", "zh": "#include <cassert>\n#include <cstring>\n#include <cstdio>\n/**\n * 检查一个三字符的字符串是否有且仅有两个字符相同。\n * \n * @param s 要检查的三字符字符串。\n * \n * @return 如果输入有且仅有两个相同的字符，则返回 \"Yes\"，否则返回 \"No\"。\n * 例子:\n *   >>> f_30(\"112\")\n *   \"Yes\"\n *   >>> f_30(\"123\")\n *   \"No\"\n */\nconst char* f_30(const char s[4])", "fr": "#include <cassert>\n#include <cstring>\n#include <cstdio>\n/**\n * Vérifie si une chaîne de trois caractères a exactement deux caractères identiques.\n * \n * @param s Une chaîne de trois caractères à vérifier.\n * \n * @return Retourne \"Yes\" si l'entrée a exactement deux caractères égaux, sinon \"No\".\n * Exemples :\n *   >>> f_30(\"112\")\n *   \"Yes\"\n *   >>> f_30(\"123\")\n *   \"No\"\n */\nconst char* f_30(const char s[4])", "de": "#include <cassert>\n#include <cstring>\n#include <cstdio>\n/**\n * Überprüft, ob ein dreistelliger String genau zwei gleiche Zeichen hat.\n * \n * @param s Ein dreistelliger String, der überprüft werden soll.\n * \n * @return Gibt \"Yes\" zurück, wenn der Eingabewert genau zwei gleiche Zeichen hat, andernfalls \"No\".\n * Beispiele:\n *   >>> f_30(\"112\")\n *   \"Yes\"\n *   >>> f_30(\"123\")\n *   \"No\"\n */\nconst char* f_30(const char s[4])", "ha": "#include <cassert>\n#include <cstring>\n#include <cstdio>\n/**\n * Duba idan kirtani mai haruffa uku yana da daidai haruffa biyu da suke daidai.\n * \n * @param s Kirtani mai haruffa uku da za a duba.\n * \n * @return Yana dawowa \"Yes\" idan shigarwar tana da daidai haruffa biyu da suke daidai, in ba haka ba \"No\".\n * Misalai:\n *   >>> f_30(\"112\")\n *   \"Yes\"\n *   >>> f_30(\"123\")\n *   \"No\"\n */\nconst char* f_30(const char s[4])", "hi": "#include <cassert>\n#include <cstring>\n#include <cstdio>\n/**\n * जांचता है कि क्या एक तीन-अक्षर वाली स्ट्रिंग में ठीक दो अक्षर समान हैं।\n * \n * @param s एक तीन-अक्षर वाली स्ट्रिंग जिसे जांचा जाना है।\n * \n * @return \"Yes\" लौटाता है यदि इनपुट में ठीक दो समान अक्षर हैं, अन्यथा \"No\"।\n * उदाहरण:\n *   >>> f_30(\"112\")\n *   \"Yes\"\n *   >>> f_30(\"123\")\n *   \"No\"\n */\nconst char* f_30(const char s[4])", "hu": "#include <cassert>\n#include <cstring>\n#include <cstdio>\n/**\n * Ellenőrzi, hogy egy három karakterből álló string pontosan két azonos karaktert tartalmaz-e.\n * \n * @param s Egy három karakterből álló string, amelyet ellenőrizni kell.\n * \n * @return \"Yes\"-t ad vissza, ha a bemenet pontosan két egyenlő karaktert tartalmaz, különben \"No\"-t.\n * Példák:\n *   >>> f_30(\"112\")\n *   \"Yes\"\n *   >>> f_30(\"123\")\n *   \"No\"\n */\nconst char* f_30(const char s[4])", "es": "#include <cassert>\n#include <cstring>\n#include <cstdio>\n/**\n * Verifica si una cadena de tres caracteres tiene exactamente dos caracteres iguales.\n * \n * @param s Una cadena de tres caracteres a verificar.\n * \n * @return Devuelve \"Yes\" si la entrada tiene exactamente dos caracteres iguales, de lo contrario \"No\".\n * Ejemplos:\n *   >>> f_30(\"112\")\n *   \"Yes\"\n *   >>> f_30(\"123\")\n *   \"No\"\n */\nconst char* f_30(const char s[4])", "arb": "#include <cassert>\n#include <cstring>\n#include <cstdio>\n/**\n * يتحقق مما إذا كانت سلسلة مكونة من ثلاثة أحرف تحتوي على حرفين متطابقين بالضبط.\n * \n * @param s سلسلة مكونة من ثلاثة أحرف للتحقق منها.\n * \n * @return يعيد \"Yes\" إذا كانت المدخلات تحتوي على حرفين متساويين بالضبط، وإلا يعيد \"No\".\n * أمثلة:\n *   >>> f_30(\"112\")\n *   \"Yes\"\n *   >>> f_30(\"123\")\n *   \"No\"\n */\nconst char* f_30(const char s[4])", "sw": "#include <cassert>\n#include <cstring>\n#include <cstdio>\n/**\n * Hukagua kama mfuatano wa herufi tatu una herufi mbili sawa.\n * \n * @param s Mfuatano wa herufi tatu unaopaswa kukaguliwa.\n * \n * @return Inarudisha \"Yes\" ikiwa ingizo lina herufi mbili sawa, vinginevyo \"No\".\n * Mifano:\n *   >>> f_30(\"112\")\n *   \"Yes\"\n *   >>> f_30(\"123\")\n *   \"No\"\n */\nconst char* f_30(const char s[4])", "tr": "#include <cassert>\n#include <cstring>\n#include <cstdio>\n/**\n * Üç karakterli bir dizgede tam olarak iki karakterin aynı olup olmadığını kontrol eder.\n * \n * @param s Kontrol edilecek üç karakterli bir dizge.\n * \n * @return Girdi tam olarak iki eşit karaktere sahipse \"Yes\" döndürür, aksi takdirde \"No\".\n * Örnekler:\n *   >>> f_30(\"112\")\n *   \"Yes\"\n *   >>> f_30(\"123\")\n *   \"No\"\n */\nconst char* f_30(const char s[4])", "vi": "#include <cassert>\n#include <cstring>\n#include <cstdio>\n/**\n * Kiểm tra xem một chuỗi ba ký tự có chính xác hai ký tự giống nhau hay không.\n * \n * @param s Một chuỗi ba ký tự cần được kiểm tra.\n * \n * @return Trả về \"Yes\" nếu đầu vào có chính xác hai ký tự bằng nhau, ngược lại \"No\".\n * Ví dụ:\n *   >>> f_30(\"112\")\n *   \"Yes\"\n *   >>> f_30(\"123\")\n *   \"No\"\n */\nconst char* f_30(const char s[4])", "id": "#include <cassert>\n#include <cstring>\n#include <cstdio>\n/**\n * Memeriksa apakah string tiga karakter memiliki tepat dua karakter yang sama.\n * \n * @param s Sebuah string tiga karakter yang akan diperiksa.\n * \n * @return Mengembalikan \"Yes\" jika input memiliki tepat dua karakter yang sama, jika tidak \"No\".\n * Contoh:\n *   >>> f_30(\"112\")\n *   \"Yes\"\n *   >>> f_30(\"123\")\n *   \"No\"\n */\nconst char* f_30(const char s[4])", "ja": "#include <cassert>\n#include <cstring>\n#include <cstdio>\n/**\n * 3文字の文字列に、正確に2つの同じ文字があるかどうかを確認します。\n * \n * @param s チェックする3文字の文字列。\n * \n * @return 入力に正確に2つの等しい文字がある場合は \"Yes\" を返し、それ以外の場合は \"No\" を返します。\n * 例:\n *   >>> f_30(\"112\")\n *   \"Yes\"\n *   >>> f_30(\"123\")\n *   \"No\"\n */\nconst char* f_30(const char s[4])", "ko": "#include <cassert>\n#include <cstring>\n#include <cstdio>\n/**\n * 세 문자로 구성된 문자열에 정확히 두 개의 동일한 문자가 있는지 확인합니다.\n * \n * @param s 확인할 세 문자로 구성된 문자열입니다.\n * \n * @return 입력에 정확히 두 개의 동일한 문자가 있는 경우 \"Yes\"를 반환하고, 그렇지 않으면 \"No\"를 반환합니다.\n * 예시:\n *   >>> f_30(\"112\")\n *   \"Yes\"\n *   >>> f_30(\"123\")\n *   \"No\"\n */\nconst char* f_30(const char s[4])", "ml": "#include <cassert>\n#include <cstring>\n#include <cstdio>\n/**\n * ഒരു മൂന്ന്-അക്ഷര സ്ട്രിംഗ് കൃത്യമായി രണ്ട് അക്ഷരങ്ങൾ ഒരേപോലെയാണോ എന്ന് പരിശോധിക്കുന്നു.\n * \n * @param s പരിശോധിക്കേണ്ട മൂന്ന്-അക്ഷര സ്ട്രിംഗ്.\n * \n * @return ഇൻപുട്ടിൽ കൃത്യമായി രണ്ട് സമാനമായ അക്ഷരങ്ങൾ ഉണ്ടെങ്കിൽ \"Yes\" മടങ്ങും, അല്ലെങ്കിൽ \"No\" മടങ്ങും.\n * ഉദാഹരണങ്ങൾ:\n *   >>> f_30(\"112\")\n *   \"Yes\"\n *   >>> f_30(\"123\")\n *   \"No\"\n */\nconst char* f_30(const char s[4])", "fa": "#include <cassert>\n#include <cstring>\n#include <cstdio>\n/**\n * بررسی می‌کند که آیا یک رشته سه‌کاراکتری دقیقاً دو کاراکتر یکسان دارد یا خیر.\n * \n * @param s یک رشته سه‌کاراکتری که باید بررسی شود.\n * \n * @return \"Yes\" را برمی‌گرداند اگر ورودی دقیقاً دو کاراکتر برابر داشته باشد، در غیر این صورت \"No\".\n * مثال‌ها:\n *   >>> f_30(\"112\")\n *   \"Yes\"\n *   >>> f_30(\"123\")\n *   \"No\"\n */\nconst char* f_30(const char s[4])"}, "canonical_solution": "{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}", "instruction": {"en": "Write a CPP function `const char* f_30(const char s[4])` to solve the following problem:\nChecks if a three-character string has exactly two characters that are the same.\n \nParameters:\n@param s A three-character string to be checked.\n \nReturns:\nReturns \"Yes\" if the input has exactly two equal characters, otherwise \"No\".\nExamples:\n  >>> f_30(\"112\")\n  \"Yes\"\n  >>> f_30(\"123\")\n  \"No\"\n", "sq": "Shkruani një funksion CPP `const char* f_30(const char s[4])` për të zgjidhur problemin në vijim:  \nKontrollon nëse një varg me tre karaktere ka saktësisht dy karaktere që janë të njëjta.\n\nParametrat:  \n@param s Një varg me tre karaktere që do të kontrollohet.\n\nKthen:  \nKthen \"Yes\" nëse inputi ka saktësisht dy karaktere të barabarta, përndryshe \"No\".  \nShembuj:  \n  >>> f_30(\"112\")  \n  \"Yes\"  \n  >>> f_30(\"123\")  \n  \"No\"  ", "hy": "Գրեք CPP ֆունկցիա `const char* f_30(const char s[4])` հետևյալ խնդիրը լուծելու համար:\nՍտուգում է՝ արդյոք երեք նիշից բաղկացած տողում կա՞ն ճիշտ երկու նույն նիշեր։\n\nՊարամետրեր:\n@param s Երեք նիշից բաղկացած տող, որը պետք է ստուգվի։\n\nՎերադարձնում է:\nՎերադարձնում է \"Yes\", եթե մուտքում կա ճիշտ երկու նույն նիշ, հակառակ դեպքում՝ \"No\":\nՕրինակներ:\n  >>> f_30(\"112\")\n  \"Yes\"\n  >>> f_30(\"123\")\n  \"No\"", "bn": "একটি CPP ফাংশন `const char* f_30(const char s[4])` লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\nপরীক্ষা করে যে একটি তিন-অক্ষরের স্ট্রিং-এ ঠিক দুটি অক্ষর একই কিনা।\n\nParameters:\n@param s একটি তিন-অক্ষরের স্ট্রিং যা পরীক্ষা করা হবে।\n\nReturns:\nযদি ইনপুটে ঠিক দুটি সমান অক্ষর থাকে তবে \"Yes\" রিটার্ন করে, অন্যথায় \"No\"।\nExamples:\n  >>> f_30(\"112\")\n  \"Yes\"\n  >>> f_30(\"123\")\n  \"No\"", "bg": "Напишете CPP функция `const char* f_30(const char s[4])`, за да решите следния проблем:\nПроверява дали низ с три символа има точно два еднакви символа.\n\nПараметри:\n@param s Низ с три символа, който трябва да бъде проверен.\n\nВръща:\nВръща \"Yes\", ако входът има точно два еднакви символа, в противен случай \"No\".\nПримери:\n  >>> f_30(\"112\")\n  \"Yes\"\n  >>> f_30(\"123\")\n  \"No\"", "zh": "编写一个 CPP 函数 `const char* f_30(const char s[4])` 来解决以下问题：\n检查一个三字符字符串是否恰好有两个字符相同。\n\n参数：\n@param s 要检查的三字符字符串。\n\n返回：\n如果输入恰好有两个相同的字符，则返回 \"Yes\"，否则返回 \"No\"。\n示例：\n  >>> f_30(\"112\")\n  \"Yes\"\n  >>> f_30(\"123\")\n  \"No\"", "fr": "Écrire une fonction CPP `const char* f_30(const char s[4])` pour résoudre le problème suivant :  \nVérifie si une chaîne de trois caractères a exactement deux caractères identiques.\n\nParamètres :  \n@param s Une chaîne de trois caractères à vérifier.\n\nRenvoie :  \nRenvoie \"Yes\" si l'entrée a exactement deux caractères égaux, sinon \"No\".  \nExemples :  \n  >>> f_30(\"112\")  \n  \"Yes\"  \n  >>> f_30(\"123\")  \n  \"No\"  ", "de": "Schreiben Sie eine CPP-Funktion `const char* f_30(const char s[4])`, um das folgende Problem zu lösen:\nPrüft, ob ein dreistelliger Zeichenfolgen genau zwei gleiche Zeichen hat.\n\nParameter:\n@param s Eine dreistellige Zeichenfolge, die überprüft werden soll.\n\nRückgabewerte:\nGibt \"Yes\" zurück, wenn die Eingabe genau zwei gleiche Zeichen hat, andernfalls \"No\".\nBeispiele:\n  >>> f_30(\"112\")\n  \"Yes\"\n  >>> f_30(\"123\")\n  \"No\"", "ha": "Rubuta aikin CPP `const char* f_30(const char s[4])` don warware matsalar mai zuwa:  \nDuba idan kirtani mai haruffa uku yana da daidai haruffa biyu da suke iri ɗaya.\n\nSigogi:  \n@param s Kirtani mai haruffa uku da za a duba.\n\nDawowa:  \nDawo da \"Yes\" idan shigarwar tana da daidai haruffa biyu da suke iri ɗaya, in ba haka ba \"No\".  \nMisalai:  \n  >>> f_30(\"112\")  \n  \"Yes\"  \n  >>> f_30(\"123\")  \n  \"No\"", "hi": "एक CPP फ़ंक्शन `const char* f_30(const char s[4])` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nजाँच करता है कि क्या तीन-अक्षरों की स्ट्रिंग में ठीक दो अक्षर समान हैं।\n\nParameters:\n@param s एक तीन-अक्षरों की स्ट्रिंग जिसे जाँचना है।\n\nReturns:\n\"Yes\" लौटाता है यदि इनपुट में ठीक दो समान अक्षर हैं, अन्यथा \"No\"।\nExamples:\n  >>> f_30(\"112\")\n  \"Yes\"\n  >>> f_30(\"123\")\n  \"No\"", "hu": "Írj egy CPP függvényt `const char* f_30(const char s[4])` a következő probléma megoldására:\nEllenőrzi, hogy egy három karakterből álló stringben pontosan két karakter azonos-e.\n\nParaméterek:\n@param s Egy három karakterből álló string, amelyet ellenőrizni kell.\n\nVisszatérési érték:\n\"Yes\"-t ad vissza, ha a bemenetben pontosan két azonos karakter van, különben \"No\"-t.\nPéldák:\n  >>> f_30(\"112\")\n  \"Yes\"\n  >>> f_30(\"123\")\n  \"No\"", "es": "Escribe una función CPP `const char* f_30(const char s[4])` para resolver el siguiente problema:\nVerifica si una cadena de tres caracteres tiene exactamente dos caracteres que son iguales.\n \nParámetros:\n@param s Una cadena de tres caracteres a ser verificada.\n \nRetorna:\nRetorna \"Yes\" si la entrada tiene exactamente dos caracteres iguales, de lo contrario \"No\".\nEjemplos:\n  >>> f_30(\"112\")\n  \"Yes\"\n  >>> f_30(\"123\")\n  \"No\"", "arb": "اكتب دالة CPP `const char* f_30(const char s[4])` لحل المشكلة التالية:\nالتحقق مما إذا كانت سلسلة مكونة من ثلاثة أحرف تحتوي على حرفين متشابهين بالضبط.\n\nالمعلمات:\n@param s سلسلة مكونة من ثلاثة أحرف ليتم التحقق منها.\n\nالقيم المعادة:\nتعيد \"Yes\" إذا كانت المدخلات تحتوي على حرفين متساويين بالضبط، وإلا تعيد \"No\".\nأمثلة:\n  >>> f_30(\"112\")\n  \"Yes\"\n  >>> f_30(\"123\")\n  \"No\"", "sw": "Andika kazi ya CPP `const char* f_30(const char s[4])` kutatua tatizo lifuatalo:\nHukagua kama kamba ya herufi tatu ina herufi mbili tu ambazo ni sawa.\n\nVigezo:\n@param s Kamba ya herufi tatu inayopaswa kukaguliwa.\n\nInarejesha:\nInarejesha \"Yes\" ikiwa ingizo lina herufi mbili sawa, vinginevyo \"No\".\nMifano:\n  >>> f_30(\"112\")\n  \"Yes\"\n  >>> f_30(\"123\")\n  \"No\"", "tr": "Bir CPP fonksiyonu `const char* f_30(const char s[4])` yazın ve aşağıdaki problemi çözün:\nÜç karakterli bir dizgede tam olarak iki karakterin aynı olup olmadığını kontrol eder.\n\nParametreler:\n@param s Kontrol edilecek üç karakterli bir dizge.\n\nDöndürülen Değer:\nGirdi tam olarak iki eşit karaktere sahipse \"Yes\", aksi takdirde \"No\" döndürür.\nÖrnekler:\n  >>> f_30(\"112\")\n  \"Yes\"\n  >>> f_30(\"123\")\n  \"No\"", "vi": "Viết một hàm CPP `const char* f_30(const char s[4])` để giải quyết vấn đề sau:  \nKiểm tra xem một chuỗi ba ký tự có chính xác hai ký tự giống nhau hay không.\n\nTham số:  \n@param s Một chuỗi ba ký tự cần được kiểm tra.\n\nTrả về:  \nTrả về \"Yes\" nếu đầu vào có chính xác hai ký tự giống nhau, ngược lại trả về \"No\".  \nVí dụ:  \n  >>> f_30(\"112\")  \n  \"Yes\"  \n  >>> f_30(\"123\")  \n  \"No\"  ", "id": "Tulis fungsi CPP `const char* f_30(const char s[4])` untuk menyelesaikan masalah berikut:\nMemeriksa apakah string tiga karakter memiliki tepat dua karakter yang sama.\n\nParameter:\n@param s String tiga karakter yang akan diperiksa.\n\nMengembalikan:\nMengembalikan \"Yes\" jika input memiliki tepat dua karakter yang sama, jika tidak \"No\".\nContoh:\n  >>> f_30(\"112\")\n  \"Yes\"\n  >>> f_30(\"123\")\n  \"No\"", "ja": "CPP関数 `const char* f_30(const char s[4])` を作成して、次の問題を解決します:\n3文字の文字列に、正確に2つの同じ文字があるかどうかを確認します。\n\nパラメータ:\n@param s チェックする3文字の文字列。\n\n戻り値:\n入力に正確に2つの等しい文字がある場合は \"Yes\" を返し、それ以外の場合は \"No\" を返します。\n例:\n  >>> f_30(\"112\")\n  \"Yes\"\n  >>> f_30(\"123\")\n  \"No\"", "ko": "CPP 함수 `const char* f_30(const char s[4])`를 작성하여 다음 문제를 해결하십시오:\n세 문자로 구성된 문자열에 정확히 두 문자가 동일한지 확인합니다.\n\n매개변수:\n@param s 확인할 세 문자로 구성된 문자열입니다.\n\n반환값:\n입력에 정확히 두 개의 동일한 문자가 있으면 \"Yes\"를 반환하고, 그렇지 않으면 \"No\"를 반환합니다.\n예시:\n  >>> f_30(\"112\")\n  \"Yes\"\n  >>> f_30(\"123\")\n  \"No\"", "ml": "CPP ഫംഗ്ഷൻ `const char* f_30(const char s[4])` എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nമൂന്ന് അക്ഷരങ്ങളുള്ള ഒരു സ്ട്രിംഗിൽ കൃത്യമായി രണ്ട് അക്ഷരങ്ങൾ ഒരേപോലെയാണോ എന്ന് പരിശോധിക്കുന്നു.\n\nപാരാമീറ്ററുകൾ:\n@param s പരിശോധിക്കേണ്ട മൂന്ന് അക്ഷരങ്ങളുള്ള ഒരു സ്ട്രിംഗ്.\n\nറിട്ടേൺസ്:\nഇൻപുട്ടിൽ കൃത്യമായി രണ്ട് സമാനമായ അക്ഷരങ്ങൾ ഉണ്ടെങ്കിൽ \"Yes\" റിട്ടേൺ ചെയ്യും, അല്ലെങ്കിൽ \"No\" റിട്ടേൺ ചെയ്യും.\nഉദാഹരണങ്ങൾ:\n  >>> f_30(\"112\")\n  \"Yes\"\n  >>> f_30(\"123\")\n  \"No\"", "fa": "یک تابع CPP بنویسید `const char* f_30(const char s[4])` برای حل مسئله زیر:\nبررسی می‌کند که آیا یک رشته سه‌کاراکتری دقیقاً دو کاراکتر مشابه دارد یا خیر.\n\nپارامترها:\n@param s یک رشته سه‌کاراکتری که باید بررسی شود.\n\nبازگشت:\n\"Yes\" را برمی‌گرداند اگر ورودی دقیقاً دو کاراکتر برابر داشته باشد، در غیر این صورت \"No\".\n\nمثال‌ها:\n  >>> f_30(\"112\")\n  \"Yes\"\n  >>> f_30(\"123\")\n  \"No\""}, "level": "easy", "test": "int main() {\n    // Testing the logic with various cases and using string comparison for assert.\n    assert(strcmp(f_30(\"112\"), \"Yes\") == 0);\n    assert(strcmp(f_30(\"123\"), \"No\") == 0);\n    assert(strcmp(f_30(\"232\"), \"Yes\") == 0);\n    assert(strcmp(f_30(\"444\"), \"No\") == 0); // All three characters are equal, not two.\n    assert(strcmp(f_30(\"121\"), \"Yes\") == 0);\n\n    // Additional test cases to cover more scenarios\n    assert(strcmp(f_30(\"787\"), \"Yes\") == 0);\n    assert(strcmp(f_30(\"999\"), \"No\") == 0); // All three characters are equal\n    assert(strcmp(f_30(\"890\"), \"No\") == 0);\n    assert(strcmp(f_30(\"556\"), \"Yes\") == 0);\n    assert(strcmp(f_30(\"353\"), \"Yes\") == 0); // No two characters are equal\n\n    \n    return 0;\n}", "entry_point": "f_30", "signature": "const char* f_30(const char s[4])", "docstring": {"en": "Checks if a three-character string has exactly two characters that are the same.\n\nParameters:\n@param s A three-character string to be checked.\n \nReturns:\nReturns \"Yes\" if the input has exactly two equal characters, otherwise \"No\".\nExamples:\n  >>> f_30(\"112\")\n  \"Yes\"\n  >>> f_30(\"123\")\n  \"No\"\n", "sq": "Kontrollon nëse një varg me tre karaktere ka saktësisht dy karaktere që janë të njëjta.\n\nParametrat:\n@param s Një varg me tre karaktere që do të kontrollohet.\n\nKthen:\nKthen \"Po\" nëse hyrja ka saktësisht dy karaktere të barabarta, përndryshe \"Jo\".\nShembuj:\n  >>> f_30(\"112\")\n  \"Po\"\n  >>> f_30(\"123\")\n  \"Jo\"", "hy": "Ստուգում է, արդյոք երեք նիշից բաղկացած տողը ունի՞ հենց երկու նույն նիշ:\n\nՊարամետրեր:\n@param s Երեք նիշից բաղկացած տող, որը պետք է ստուգվի:\n\nՎերադարձնում է:\nՎերադարձնում է \"Yes\", եթե մուտքագրվածը ունի հենց երկու հավասար նիշ, հակառակ դեպքում՝ \"No\":\nՕրինակներ:\n  >>> f_30(\"112\")\n  \"Yes\"\n  >>> f_30(\"123\")\n  \"No\"", "bn": "পরীক্ষা করে যে একটি তিন-অক্ষরের স্ট্রিংয়ে ঠিক দুটি অক্ষর একই আছে কিনা।\n\nপ্যারামিটারসমূহ:\n@param s একটি তিন-অক্ষরের স্ট্রিং যা পরীক্ষা করা হবে।\n\nফেরত দেয়:\nযদি ইনপুটে ঠিক দুটি সমান অক্ষর থাকে তবে \"Yes\" ফেরত দেয়, অন্যথায় \"No\"।\n\nউদাহরণসমূহ:\n  >>> f_30(\"112\")\n  \"Yes\"\n  >>> f_30(\"123\")\n  \"No\"", "bg": "Проверява дали низ с три знака има точно два еднакви знака.\n\nПараметри:\n@param s Низ с три знака, който да бъде проверен.\n\nВръща:\nВръща \"Yes\", ако входът има точно два еднакви знака, в противен случай \"No\".\nПримери:\n  >>> f_30(\"112\")\n  \"Yes\"\n  >>> f_30(\"123\")\n  \"No\"", "zh": "检查一个三字符字符串是否恰好有两个字符相同。\n\n参数：\n@param s 要检查的三字符字符串。\n\n返回：\n如果输入恰好有两个相同的字符，则返回 \"Yes\"，否则返回 \"No\"。\n\n示例：\n  >>> f_30(\"112\")\n  \"Yes\"\n  >>> f_30(\"123\")\n  \"No\"", "fr": "Vérifie si une chaîne de trois caractères a exactement deux caractères identiques.\n\nParamètres:\n@param s Une chaîne de trois caractères à vérifier.\n\nRetourne:\nRetourne \"Yes\" si l'entrée a exactement deux caractères égaux, sinon \"No\".\nExemples:\n  >>> f_30(\"112\")\n  \"Yes\"\n  >>> f_30(\"123\")\n  \"No\"", "de": "Prüft, ob ein dreistelliger String genau zwei gleiche Zeichen hat.\n\nParameter:\n@param s Ein dreistelliger String, der überprüft werden soll.\n\nRückgabe:\nGibt \"Ja\" zurück, wenn der Eingabewert genau zwei gleiche Zeichen hat, andernfalls \"Nein\".\nBeispiele:\n  >>> f_30(\"112\")\n  \"Ja\"\n  >>> f_30(\"123\")\n  \"Nein\"", "ha": "Duba idan kirtani mai haruffa uku yana da daidai haruffa biyu da suke daidai.\n\nSigogi:\n@param s Wani kirtani mai haruffa uku da za a duba.\n\nDawowa:\nYana dawowa \"Yes\" idan shigarwar tana da daidai haruffa biyu masu daidaituwa, in ba haka ba \"No\".\n\nMisalai:\n  >>> f_30(\"112\")\n  \"Yes\"\n  >>> f_30(\"123\")\n  \"No\"", "hi": "तीन-अक्षरों की स्ट्रिंग में जांच करता है कि क्या इसमें ठीक दो अक्षर समान हैं।\n\nपैरामीटर्स:\n@param s एक तीन-अक्षरों की स्ट्रिंग जिसे जांचा जाना है।\n\nवापसी:\nयदि इनपुट में ठीक दो समान अक्षर हैं तो \"Yes\" लौटाता है, अन्यथा \"No\"।\n\nउदाहरण:\n  >>> f_30(\"112\")\n  \"Yes\"\n  >>> f_30(\"123\")\n  \"No\"", "hu": "Ellenőrzi, hogy egy három karakter hosszú stringben pontosan két azonos karakter van-e.\n\nParaméterek:\n@param s Egy három karakter hosszú string, amelyet ellenőrizni kell.\n\nVisszatérési érték:\n\"Yes\"-t ad vissza, ha a bemenetben pontosan két egyenlő karakter van, különben \"No\"-t.\n\nPéldák:\n  >>> f_30(\"112\")\n  \"Yes\"\n  >>> f_30(\"123\")\n  \"No\"", "es": "Verifica si una cadena de tres caracteres tiene exactamente dos caracteres que son iguales.\n\nParámetros:\n@param s Una cadena de tres caracteres a verificar.\n\nDevuelve:\nDevuelve \"Yes\" si la entrada tiene exactamente dos caracteres iguales, de lo contrario \"No\".\nEjemplos:\n  >>> f_30(\"112\")\n  \"Yes\"\n  >>> f_30(\"123\")\n  \"No\"", "arb": "يتحقق مما إذا كانت سلسلة مكونة من ثلاثة أحرف تحتوي على حرفين متطابقين بالضبط.\n\nالمعلمات:\n@param s سلسلة مكونة من ثلاثة أحرف ليتم التحقق منها.\n\nالإرجاع:\nيعيد \"Yes\" إذا كانت المدخلات تحتوي على حرفين متساويين بالضبط، وإلا يعيد \"No\".\n\nأمثلة:\n  >>> f_30(\"112\")\n  \"Yes\"\n  >>> f_30(\"123\")\n  \"No\"", "sw": "Hukagua kama mfuatano wa herufi tatu una herufi mbili sawa.\n\nVigezo:\n@param s Mfuatano wa herufi tatu unaopaswa kukaguliwa.\n\nInarejesha:\nInarejesha \"Yes\" ikiwa ingizo lina herufi mbili sawa, vinginevyo \"No\".\nMifano:\n  >>> f_30(\"112\")\n  \"Yes\"\n  >>> f_30(\"123\")\n  \"No\"", "tr": "Üç karakterli bir dizgede tam olarak iki karakterin aynı olup olmadığını kontrol eder.\n\nParametreler:\n@param s Kontrol edilecek üç karakterli bir dizge.\n\nDöndürülenler:\nGirdi tam olarak iki eşit karakter içeriyorsa \"Evet\", aksi takdirde \"Hayır\" döndürür.\nÖrnekler:\n  >>> f_30(\"112\")\n  \"Evet\"\n  >>> f_30(\"123\")\n  \"Hayır\"", "vi": "Kiểm tra xem một chuỗi ba ký tự có chính xác hai ký tự giống nhau hay không.\n\nTham số:\n@param s Một chuỗi ba ký tự cần được kiểm tra.\n\nTrả về:\nTrả về \"Yes\" nếu đầu vào có chính xác hai ký tự bằng nhau, nếu không thì \"No\".\nVí dụ:\n  >>> f_30(\"112\")\n  \"Yes\"\n  >>> f_30(\"123\")\n  \"No\"", "id": "Memeriksa apakah string tiga karakter memiliki tepat dua karakter yang sama.\n\nParameter:\n@param s String tiga karakter yang akan diperiksa.\n\nMengembalikan:\nMengembalikan \"Yes\" jika input memiliki tepat dua karakter yang sama, jika tidak \"No\".\n\nContoh:\n  >>> f_30(\"112\")\n  \"Yes\"\n  >>> f_30(\"123\")\n  \"No\"", "ja": "3文字の文字列に、正確に2つの同じ文字が含まれているかどうかを確認します。\n\nパラメータ:\n@param s チェックする3文字の文字列。\n\n戻り値:\n入力に正確に2つの等しい文字が含まれている場合は \"Yes\" を返し、それ以外の場合は \"No\" を返します。\n\n例:\n  >>> f_30(\"112\")\n  \"Yes\"\n  >>> f_30(\"123\")\n  \"No\"", "ko": "세 글자 문자열에 정확히 두 개의 동일한 문자가 있는지 확인합니다.\n\n매개변수:\n@param s 확인할 세 글자 문자열입니다.\n\n반환:\n입력에 정확히 두 개의 동일한 문자가 있는 경우 \"Yes\"를 반환하고, 그렇지 않으면 \"No\"를 반환합니다.\n예제:\n  >>> f_30(\"112\")\n  \"Yes\"\n  >>> f_30(\"123\")\n  \"No\"", "ml": "ഒരു മൂന്ന്-അക്ഷര സ്ട്രിംഗ് കൃത്യമായി രണ്ട് അക്ഷരങ്ങൾ ഒരേപോലെയാണോ എന്ന് പരിശോധിക്കുന്നു.\n\nപാരാമീറ്ററുകൾ:\n@param s പരിശോധിക്കേണ്ട മൂന്ന് അക്ഷരങ്ങളുള്ള ഒരു സ്ട്രിംഗ്.\n\nതിരികെ നൽകുന്നു:\nഇൻപുട്ടിൽ കൃത്യമായി രണ്ട് സമാന അക്ഷരങ്ങൾ ഉണ്ടെങ്കിൽ \"Yes\" തിരികെ നൽകുന്നു, അല്ലെങ്കിൽ \"No\".\n\nഉദാഹരണങ്ങൾ:\n  >>> f_30(\"112\")\n  \"Yes\"\n  >>> f_30(\"123\")\n  \"No\"", "fa": "بررسی می‌کند که آیا یک رشته سه‌کاراکتری دقیقاً دو کاراکتر مشابه دارد یا خیر.\n\nپارامترها:\n@param s یک رشته سه‌کاراکتری که باید بررسی شود.\n\nبازگشت:\n\"Yes\" را برمی‌گرداند اگر ورودی دقیقاً دو کاراکتر برابر داشته باشد، در غیر این صورت \"No\".\n\nمثال‌ها:\n  >>> f_30(\"112\")\n  \"Yes\"\n  >>> f_30(\"123\")\n  \"No\""}}
{"task_id": "CPP/31", "prompt": {"en": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/**\n * Given a string consisting of lowercase English letters, in each round you can change\n * one of the characters to another character. The question is: what is the minimum\n * number of rounds needed to make the string composed of the same character?\n * \n * Examples:\n * >>> f_31(\"aab\")\n * 1\n * >>> f_31(\"abc\")\n * 2\n * >>> f_31(\"aaa\")\n * 0\n */\nint f_31(const char* s)", "sq": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/**\n * Duke pasur një varg që përbëhet nga shkronja të vogla të anglishtes, në çdo raund mund të ndryshoni\n * një nga karakteret në një karakter tjetër. Pyetja është: cili është numri minimal\n * i raundeve të nevojshme për ta bërë vargun të përbërë nga i njëjti karakter?\n * \n * Shembuj:\n * >>> f_31(\"aab\")\n * 1\n * >>> f_31(\"abc\")\n * 2\n * >>> f_31(\"aaa\")\n * 0\n */\nint f_31(const char* s)", "hy": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/**\n * Տրված է փոքրատառ անգլերեն տառերից կազմված լար, յուրաքանչյուր փուլում դուք կարող եք փոխել\n * տառերից մեկը մեկ այլ տառի: Հարցն այն է՝ որն է նվազագույն\n * փուլերի քանակը, որը անհրաժեշտ է լարը նույն տառից կազմված դարձնելու համար?\n * \n * Օրինակներ:\n * >>> f_31(\"aab\")\n * 1\n * >>> f_31(\"abc\")\n * 2\n * >>> f_31(\"aaa\")\n * 0\n */\nint f_31(const char* s)", "bn": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/**\n * একটি স্ট্রিং দেওয়া হয়েছে যা ছোট হাতের ইংরেজি অক্ষর নিয়ে গঠিত, প্রতিটি রাউন্ডে আপনি\n * একটি অক্ষরকে অন্য একটি অক্ষরে পরিবর্তন করতে পারেন। প্রশ্ন হল: স্ট্রিংটিকে একই অক্ষর\n * দিয়ে গঠিত করতে ন্যূনতম কতগুলি রাউন্ড প্রয়োজন?\n * \n * উদাহরণ:\n * >>> f_31(\"aab\")\n * 1\n * >>> f_31(\"abc\")\n * 2\n * >>> f_31(\"aaa\")\n * 0\n */\nint f_31(const char* s)", "bg": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/**\n * Даден е низ, състоящ се от малки английски букви, като във всеки рунд можете да промените\n * един от символите на друг символ. Въпросът е: какъв е минималният\n * брой рундове, необходими, за да се направи низът съставен от един и същ символ?\n * \n * Примери:\n * >>> f_31(\"aab\")\n * 1\n * >>> f_31(\"abc\")\n * 2\n * >>> f_31(\"aaa\")\n * 0\n */\nint f_31(const char* s)", "zh": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/**\n * 给定一个由小写英文字母组成的字符串，每一轮你可以将其中一个字符更改为另一个字符。\n * 问题是：需要多少轮才能使字符串由相同的字符组成？\n * \n * 示例：\n * >>> f_31(\"aab\")\n * 1\n * >>> f_31(\"abc\")\n * 2\n * >>> f_31(\"aaa\")\n * 0\n */\nint f_31(const char* s)", "fr": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/**\n * Étant donné une chaîne composée de lettres minuscules anglaises, à chaque tour, vous pouvez changer\n * l'un des caractères en un autre caractère. La question est : quel est le nombre minimum\n * de tours nécessaires pour que la chaîne soit composée du même caractère ?\n * \n * Exemples :\n * >>> f_31(\"aab\")\n * 1\n * >>> f_31(\"abc\")\n * 2\n * >>> f_31(\"aaa\")\n * 0\n */\nint f_31(const char* s)", "de": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/**\n * Gegeben ist ein String, der aus Kleinbuchstaben des englischen Alphabets besteht. In jeder Runde kann man\n * eines der Zeichen in ein anderes Zeichen ändern. Die Frage ist: Was ist die minimale\n * Anzahl von Runden, die benötigt werden, um den String aus demselben Zeichen bestehen zu lassen?\n * \n * Beispiele:\n * >>> f_31(\"aab\")\n * 1\n * >>> f_31(\"abc\")\n * 2\n * >>> f_31(\"aaa\")\n * 0\n */\nint f_31(const char* s)", "ha": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/**\n * An ba da wani kirtani da ya ƙunshi ƙananan haruffan Turanci, a kowace zagaye za ka iya canza\n * ɗaya daga cikin haruffan zuwa wani harafi. Tambayar ita ce: menene mafi ƙarancin\n * adadin zagaye da ake buƙata don sanya kirtanin ya ƙunshi harafi ɗaya?\n * \n * Misalai:\n * >>> f_31(\"aab\")\n * 1\n * >>> f_31(\"abc\")\n * 2\n * >>> f_31(\"aaa\")\n * 0\n */\nint f_31(const char* s)", "hi": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/**\n * दिए गए एक स्ट्रिंग जिसमें छोटे अंग्रेजी अक्षर होते हैं, प्रत्येक राउंड में आप \n * एक अक्षर को दूसरे अक्षर में बदल सकते हैं। प्रश्न यह है: स्ट्रिंग को एक ही \n * अक्षर से मिलकर बनाने के लिए न्यूनतम कितने राउंड की आवश्यकता है?\n * \n * उदाहरण:\n * >>> f_31(\"aab\")\n * 1\n * >>> f_31(\"abc\")\n * 2\n * >>> f_31(\"aaa\")\n * 0\n */\nint f_31(const char* s)", "hu": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/**\n * Adott egy, kisbetűs angol betűkből álló karakterlánc, minden körben megváltoztathatod\n * az egyik karaktert egy másik karakterre. A kérdés az: mi a minimális\n * körök száma, amely szükséges ahhoz, hogy a karakterlánc ugyanabból a karakterből álljon?\n * \n * Példák:\n * >>> f_31(\"aab\")\n * 1\n * >>> f_31(\"abc\")\n * 2\n * >>> f_31(\"aaa\")\n * 0\n */\nint f_31(const char* s)", "es": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/**\n * Dada una cadena compuesta de letras minúsculas del alfabeto inglés, en cada ronda puedes cambiar\n * uno de los caracteres por otro carácter. La pregunta es: ¿cuál es el número mínimo\n * de rondas necesarias para hacer que la cadena esté compuesta por el mismo carácter?\n * \n * Ejemplos:\n * >>> f_31(\"aab\")\n * 1\n * >>> f_31(\"abc\")\n * 2\n * >>> f_31(\"aaa\")\n * 0\n */\nint f_31(const char* s)", "arb": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/**\n * بالنظر إلى سلسلة تتكون من أحرف إنجليزية صغيرة، في كل جولة يمكنك تغيير\n * أحد الأحرف إلى حرف آخر. السؤال هو: ما هو الحد الأدنى\n * لعدد الجولات اللازمة لجعل السلسلة تتكون من نفس الحرف؟\n * \n * أمثلة:\n * >>> f_31(\"aab\")\n * 1\n * >>> f_31(\"abc\")\n * 2\n * >>> f_31(\"aaa\")\n * 0\n */\nint f_31(const char* s)", "sw": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/**\n * Ukipewa kamba inayojumuisha herufi ndogo za Kiingereza, katika kila raundi unaweza kubadilisha\n * moja ya herufi kuwa herufi nyingine. Swali ni: ni idadi gani ya chini ya raundi zinazohitajika\n * kufanya kamba iwe na herufi sawa?\n * \n * Mifano:\n * >>> f_31(\"aab\")\n * 1\n * >>> f_31(\"abc\")\n * 2\n * >>> f_31(\"aaa\")\n * 0\n */\nint f_31(const char* s)", "tr": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/**\n * Küçük İngiliz harflerinden oluşan bir dize verildiğinde, her turda karakterlerden birini\n * başka bir karaktere değiştirebilirsiniz. Soru şu: diziyi aynı karakterden oluşacak şekilde\n * yapmak için gereken minimum tur sayısı nedir?\n * \n * Örnekler:\n * >>> f_31(\"aab\")\n * 1\n * >>> f_31(\"abc\")\n * 2\n * >>> f_31(\"aaa\")\n * 0\n */\nint f_31(const char* s)", "vi": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/**\n * Cho một chuỗi gồm các chữ cái tiếng Anh viết thường, trong mỗi vòng bạn có thể thay đổi\n * một trong các ký tự thành ký tự khác. Câu hỏi là: cần tối thiểu bao nhiêu\n * vòng để làm cho chuỗi được tạo thành từ cùng một ký tự?\n * \n * Ví dụ:\n * >>> f_31(\"aab\")\n * 1\n * >>> f_31(\"abc\")\n * 2\n * >>> f_31(\"aaa\")\n * 0\n */\nint f_31(const char* s)", "id": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/**\n * Diberikan sebuah string yang terdiri dari huruf kecil bahasa Inggris, pada setiap putaran Anda dapat mengubah\n * salah satu karakter menjadi karakter lain. Pertanyaannya adalah: berapa jumlah putaran minimum\n * yang dibutuhkan untuk membuat string tersebut terdiri dari karakter yang sama?\n * \n * Contoh:\n * >>> f_31(\"aab\")\n * 1\n * >>> f_31(\"abc\")\n * 2\n * >>> f_31(\"aaa\")\n * 0\n */\nint f_31(const char* s)", "ja": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/**\n * 小文字の英字からなる文字列が与えられたとき、各ラウンドで文字を別の文字に変更することができます。\n * 質問は、文字列を同じ文字で構成するために必要な最小ラウンド数は何ですか？\n * \n * 例:\n * >>> f_31(\"aab\")\n * 1\n * >>> f_31(\"abc\")\n * 2\n * >>> f_31(\"aaa\")\n * 0\n */\nint f_31(const char* s)", "ko": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/**\n * 소문자 영어 문자로 구성된 문자열이 주어졌을 때, 각 라운드에서 하나의 문자를 다른 문자로 변경할 수 있습니다.\n * 질문은: 문자열을 같은 문자로 구성하기 위해 필요한 최소 라운드 수는 얼마입니까?\n * \n * 예시:\n * >>> f_31(\"aab\")\n * 1\n * >>> f_31(\"abc\")\n * 2\n * >>> f_31(\"aaa\")\n * 0\n */\nint f_31(const char* s)", "ml": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/**\n * ചെറിയ അക്ഷരങ്ങളായ ഇംഗ്ലീഷ് അക്ഷരങ്ങൾ അടങ്ങിയ ഒരു സ്ട്രിംഗ് നൽകിയാൽ, ഓരോ റൗണ്ടിലും \n * നിങ്ങൾക്ക് ഒരു അക്ഷരം മറ്റൊരു അക്ഷരമായി മാറ്റാൻ കഴിയും. ചോദ്യമിങ്ങനെ: \n * സ്ട്രിംഗ് ഒരേ അക്ഷരത്തിൽ നിന്ന് നിർമ്മിക്കപ്പെടാൻ വേണ്ട ഏറ്റവും കുറഞ്ഞ \n * റൗണ്ടുകളുടെ എണ്ണം എത്രയാണ്?\n * \n * ഉദാഹരണങ്ങൾ:\n * >>> f_31(\"aab\")\n * 1\n * >>> f_31(\"abc\")\n * 2\n * >>> f_31(\"aaa\")\n * 0\n */\nint f_31(const char* s)", "fa": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/**\n * با داشتن یک رشته متشکل از حروف کوچک انگلیسی، در هر دور می‌توانید یکی از کاراکترها را به کاراکتر دیگری تغییر دهید.\n * سوال این است: حداقل تعداد دورهایی که لازم است تا رشته از یک کاراکتر مشابه تشکیل شود، چقدر است؟\n * \n * مثال‌ها:\n * >>> f_31(\"aab\")\n * 1\n * >>> f_31(\"abc\")\n * 2\n * >>> f_31(\"aaa\")\n * 0\n */\nint f_31(const char* s)"}, "canonical_solution": "{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}\n\n", "instruction": {"en": "Write a CPP function `int f_31(const char* s)` to solve the following problem:\nGiven a string consisting of lowercase English letters, in each round you can change\none of the characters to another character. The question is: what is the minimum\nnumber of rounds needed to make the string composed of the same character?\n\nExamples:\n>>> f_31(\"aab\")\n1\n>>> f_31(\"abc\")\n2\n>>> f_31(\"aaa\")\n0", "sq": "Shkruani një funksion CPP `int f_31(const char* s)` për të zgjidhur problemin e mëposhtëm:\nDuke pasur një varg që përbëhet nga shkronja të vogla të anglishtes, në çdo raund mund të ndryshoni\nnjë nga karakteret në një karakter tjetër. Pyetja është: cili është numri minimal\ni raundeve të nevojshme për ta bërë vargun të përbërë nga i njëjti karakter?\n\nShembuj:\n>>> f_31(\"aab\")\n1\n>>> f_31(\"abc\")\n2\n>>> f_31(\"aaa\")\n0", "hy": "Գրեք CPP ֆունկցիա `int f_31(const char* s)` լուծելու համար հետևյալ խնդիրը:  \nՏրված է փոքրատառ անգլերեն տառերից կազմված տող, յուրաքանչյուր փուլում դուք կարող եք փոխել  \nտողերից մեկը մեկ այլ տառով: Հարցն այն է՝ ինչքա՞ն է նվազագույն  \nփուլերի քանակը, որը անհրաժեշտ է տողը նույն տառից կազմված դարձնելու համար:  \n\nՕրինակներ:  \n>>> f_31(\"aab\")  \n1  \n>>> f_31(\"abc\")  \n2  \n>>> f_31(\"aaa\")  \n0", "bn": "একটি CPP ফাংশন `int f_31(const char* s)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য: \nএকটি স্ট্রিং দেওয়া হয়েছে যা ছোট হাতের ইংরেজি অক্ষর নিয়ে গঠিত, প্রতিটি রাউন্ডে আপনি একটি অক্ষরকে অন্য একটি অক্ষরে পরিবর্তন করতে পারেন। প্রশ্ন হল: স্ট্রিংটিকে একই অক্ষর দিয়ে গঠিত করতে ন্যূনতম কত রাউন্ড প্রয়োজন?\n\nউদাহরণসমূহ:\n>>> f_31(\"aab\")\n1\n>>> f_31(\"abc\")\n2\n>>> f_31(\"aaa\")\n0", "bg": "Напишете CPP функция `int f_31(const char* s)` за решаване на следния проблем:  \nДаден е низ, състоящ се от малки английски букви, като във всеки рунд можете да промените един от символите на друг символ. Въпросът е: какъв е минималният брой рундове, необходими, за да се направи низът съставен от един и същ символ?\n\nПримери:\n>>> f_31(\"aab\")\n1\n>>> f_31(\"abc\")\n2\n>>> f_31(\"aaa\")\n0", "zh": "编写一个 CPP 函数 `int f_31(const char* s)` 来解决以下问题：  \n给定一个由小写英文字母组成的字符串，在每一轮中，你可以将其中一个字符更改为另一个字符。问题是：使字符串由相同字符组成所需的最小轮数是多少？  \n\n示例：  \n>>> f_31(\"aab\")  \n1  \n>>> f_31(\"abc\")  \n2  \n>>> f_31(\"aaa\")  \n0  ", "fr": "Écrire une fonction CPP `int f_31(const char* s)` pour résoudre le problème suivant :  \nÉtant donné une chaîne composée de lettres minuscules anglaises, à chaque tour, vous pouvez changer l'un des caractères en un autre caractère. La question est : quel est le nombre minimum de tours nécessaires pour que la chaîne soit composée du même caractère ?\n\nExemples :  \n>>> f_31(\"aab\")  \n1  \n>>> f_31(\"abc\")  \n2  \n>>> f_31(\"aaa\")  \n0  ", "de": "Schreiben Sie eine CPP-Funktion `int f_31(const char* s)`, um das folgende Problem zu lösen:\nGegeben ist ein String, der aus Kleinbuchstaben des englischen Alphabets besteht. In jeder Runde können Sie eines der Zeichen in ein anderes Zeichen ändern. Die Frage ist: Was ist die minimale Anzahl an Runden, die benötigt wird, um den String aus demselben Zeichen zusammengesetzt zu machen?\n\nBeispiele:\n>>> f_31(\"aab\")\n1\n>>> f_31(\"abc\")\n2\n>>> f_31(\"aaa\")\n0", "ha": "Rubuta aikin CPP `int f_31(const char* s)` don warware matsalar mai zuwa:  \n\nAn ba da wata igiya da ke kunshe da ƙananan haruffan Ingilishi, a kowace zagaye za ka iya canza ɗaya daga cikin haruffan zuwa wani harafi. Tambayar ita ce: menene mafi ƙarancin adadin zagaye da ake buƙata don sanya igiyar ta ƙunshi harafi ɗaya?  \n\nMisalai:  \n>>> f_31(\"aab\")  \n1  \n>>> f_31(\"abc\")  \n2  \n>>> f_31(\"aaa\")  \n0  ", "hi": "`int f_31(const char* s)` फ़ंक्शन लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए स्ट्रिंग में छोटे अंग्रेजी अक्षरों का समावेश है, प्रत्येक राउंड में आप एक अक्षर को दूसरे अक्षर में बदल सकते हैं। प्रश्न यह है: स्ट्रिंग को एक ही अक्षर से मिलकर बनाने के लिए न्यूनतम कितने राउंड की आवश्यकता है?", "hu": "Írj egy CPP függvényt `int f_31(const char* s)` a következő probléma megoldására:  \nAdott egy kisbetűs angol betűkből álló karakterlánc, minden körben megváltoztathatsz egy karaktert egy másik karakterre. A kérdés az: mi a minimális körök száma, amely szükséges ahhoz, hogy a karakterlánc ugyanabból a karakterből álljon?\n\nPéldák:\n>>> f_31(\"aab\")\n1\n>>> f_31(\"abc\")\n2\n>>> f_31(\"aaa\")\n0", "es": "Escribe una función CPP `int f_31(const char* s)` para resolver el siguiente problema:\nDada una cadena que consiste en letras minúsculas del alfabeto inglés, en cada ronda puedes cambiar uno de los caracteres por otro carácter. La pregunta es: ¿cuál es el número mínimo de rondas necesarias para hacer que la cadena esté compuesta por el mismo carácter?\n\nEjemplos:\n>>> f_31(\"aab\")\n1\n>>> f_31(\"abc\")\n2\n>>> f_31(\"aaa\")\n0", "arb": "اكتب دالة CPP `int f_31(const char* s)` لحل المشكلة التالية:\nبالنظر إلى سلسلة تتكون من حروف إنجليزية صغيرة، في كل جولة يمكنك تغيير\nأحد الأحرف إلى حرف آخر. السؤال هو: ما هو الحد الأدنى\nلعدد الجولات اللازمة لجعل السلسلة تتكون من نفس الحرف؟\n\nأمثلة:\n>>> f_31(\"aab\")\n1\n>>> f_31(\"abc\")\n2\n>>> f_31(\"aaa\")\n0", "sw": "Andika kazi ya CPP `int f_31(const char* s)` kutatua tatizo lifuatalo:  \nUkipiwa kamba inayojumuisha herufi ndogo za Kiingereza, katika kila raundi unaweza kubadilisha moja ya herufi kuwa herufi nyingine. Swali ni: ni idadi gani ndogo ya raundi inayohitajika ili kufanya kamba iwe na herufi sawa?\n\nMifano:  \n>>> f_31(\"aab\")  \n1  \n>>> f_31(\"abc\")  \n2  \n>>> f_31(\"aaa\")  \n0", "tr": "Bir CPP fonksiyonu `int f_31(const char* s)` yazın ve aşağıdaki problemi çözün:\nKüçük İngiliz harflerinden oluşan bir dizi verildiğinde, her turda karakterlerden birini başka bir karaktere değiştirebilirsiniz. Soru şu: Diziyi aynı karakterden oluşacak şekilde yapmak için gereken minimum tur sayısı nedir?\n\nÖrnekler:\n>>> f_31(\"aab\")\n1\n>>> f_31(\"abc\")\n2\n>>> f_31(\"aaa\")\n0", "vi": "Viết một hàm CPP `int f_31(const char* s)` để giải quyết vấn đề sau:  \nCho một chuỗi gồm các chữ cái tiếng Anh viết thường, trong mỗi vòng bạn có thể thay đổi một trong các ký tự thành ký tự khác. Câu hỏi là: cần tối thiểu bao nhiêu vòng để làm cho chuỗi được tạo thành từ cùng một ký tự?\n\nVí dụ:\n>>> f_31(\"aab\")\n1\n>>> f_31(\"abc\")\n2\n>>> f_31(\"aaa\")\n0", "id": "Tulis fungsi CPP `int f_31(const char* s)` untuk menyelesaikan masalah berikut:\nDiberikan sebuah string yang terdiri dari huruf kecil bahasa Inggris, dalam setiap putaran Anda dapat mengubah salah satu karakter menjadi karakter lain. Pertanyaannya adalah: berapa jumlah putaran minimum yang diperlukan untuk membuat string terdiri dari karakter yang sama?\n\nContoh:\n>>> f_31(\"aab\")\n1\n>>> f_31(\"abc\")\n2\n>>> f_31(\"aaa\")\n0", "ja": "CPP関数 `int f_31(const char* s)` を作成して、次の問題を解決してください:\n小文字の英字からなる文字列が与えられたとき、各ラウンドで1つの文字を別の文字に変更することができます。質問は、文字列を同じ文字で構成するために必要な最小ラウンド数は何ですか？\n\n例:\n>>> f_31(\"aab\")\n1\n>>> f_31(\"abc\")\n2\n>>> f_31(\"aaa\")\n0", "ko": "CPP 함수 `int f_31(const char* s)`를 작성하여 다음 문제를 해결하십시오:\n소문자 영어 문자로 구성된 문자열이 주어졌을 때, 각 라운드에서 하나의 문자를 다른 문자로 변경할 수 있습니다. 질문은: 문자열을 동일한 문자로 구성하기 위해 필요한 최소 라운드 수는 얼마입니까?\n\n예시:\n>>> f_31(\"aab\")\n1\n>>> f_31(\"abc\")\n2\n>>> f_31(\"aaa\")\n0", "ml": "`int f_31(const char* s)` എന്ന CPP ഫംഗ്ഷൻ എഴുതുക താഴെ കൊടുത്തിരിക്കുന്ന പ്രശ്നം പരിഹരിക്കാൻ:  \nചെറിയ ഇംഗ്ലീഷ് അക്ഷരങ്ങൾ അടങ്ങിയ ഒരു സ്ട്രിംഗ് നൽകിയിരിക്കുന്നു, ഓരോ റൗണ്ടിലും നിങ്ങൾക്ക് ഒരു അക്ഷരം മറ്റൊരു അക്ഷരമായി മാറ്റാൻ കഴിയും. ഈ സ്ട്രിംഗ് ഒരേ അക്ഷരംകൊണ്ട് നിർമ്മിക്കാൻ ആവശ്യമായ കുറഞ്ഞ റൗണ്ടുകളുടെ എണ്ണം എത്രയാണ്?\n\nഉദാഹരണങ്ങൾ:\n>>> f_31(\"aab\")\n1\n>>> f_31(\"abc\")\n2\n>>> f_31(\"aaa\")\n0", "fa": "یک تابع CPP بنویسید `int f_31(const char* s)` برای حل مسئله زیر:\nبا توجه به یک رشته که از حروف کوچک انگلیسی تشکیل شده است، در هر دور می‌توانید یکی از کاراکترها را به کاراکتر دیگری تغییر دهید. سوال این است: حداقل تعداد دورهایی که لازم است تا رشته از یک کاراکتر یکسان تشکیل شود، چقدر است؟\n\nمثال‌ها:\n>>> f_31(\"aab\")\n1\n>>> f_31(\"abc\")\n2\n>>> f_31(\"aaa\")\n0"}, "level": "middle", "test": "int main() {\n    assert(f_31(\"aab\") == 1);\n    assert(f_31(\"abc\") == 2);\n    assert(f_31(\"aaa\") == 0);\n    assert(f_31(\"abab\") == 1);\n    assert(f_31(\"zzzzz\") == 0);\n\n    return 0;\n}", "entry_point": "f_31", "signature": "int f_31(const char* s)", "docstring": {"en": "Given a string consisting of lowercase English letters, in each round you can change\none of the characters to another character. The question is: what is the minimum\nnumber of rounds needed to make the string composed of the same character?\n\nExamples:\n>>> f_31(\"aab\")\n1\n>>> f_31(\"abc\")\n2\n>>> f_31(\"aaa\")\n0", "sq": "Duke pasur një varg që përbëhet nga shkronja të vogla të anglishtes, në çdo raund ju mund të ndryshoni një nga karakteret në një karakter tjetër. Pyetja është: cila është numri minimal i raundeve të nevojshme për ta bërë vargun të përbërë nga i njëjti karakter?\n\nShembuj:\n>>> f_31(\"aab\")\n1\n>>> f_31(\"abc\")\n2\n>>> f_31(\"aaa\")\n0", "hy": "Տրված է փոքրատառ անգլերեն տառերից կազմված տող, յուրաքանչյուր փուլում կարող եք փոխել\nմեկ նիշը մեկ այլ նիշով: Հարցն այն է՝ ինչքա՞ն է նվազագույն\nփուլերի քանակը, որը անհրաժեշտ է, որպեսզի տողը կազմված լինի նույն նիշից:\n\nՕրինակներ:\n>>> f_31(\"aab\")\n1\n>>> f_31(\"abc\")\n2\n>>> f_31(\"aaa\")\n0", "bn": "প্রদত্ত একটি স্ট্রিং যা ছোট হাতের ইংরেজি অক্ষর নিয়ে গঠিত, প্রতিটি রাউন্ডে আপনি একটি অক্ষরকে অন্য একটি অক্ষরে পরিবর্তন করতে পারেন। প্রশ্ন হল: স্ট্রিংটিকে একই অক্ষর দিয়ে গঠিত করতে ন্যূনতম কত রাউন্ড প্রয়োজন?\n\nউদাহরণসমূহ:\n>>> f_31(\"aab\")\n1\n>>> f_31(\"abc\")\n2\n>>> f_31(\"aaa\")\n0", "bg": "Даден е низ, състоящ се от малки английски букви, като във всеки рунд можете да промените един от символите на друг символ. Въпросът е: какъв е минималният брой рундове, необходими, за да се направи низът съставен от един и същ символ?\n\nПримери:\n>>> f_31(\"aab\")\n1\n>>> f_31(\"abc\")\n2\n>>> f_31(\"aaa\")\n0", "zh": "给定一个由小写英文字母组成的字符串，在每一轮中，你可以将其中一个字符更改为另一个字符。问题是：使字符串由相同字符组成所需的最少轮数是多少？\n\n示例：\n>>> f_31(\"aab\")\n1\n>>> f_31(\"abc\")\n2\n>>> f_31(\"aaa\")\n0", "fr": "Étant donné une chaîne composée de lettres minuscules anglaises, à chaque tour, vous pouvez changer l'un des caractères en un autre caractère. La question est : quel est le nombre minimum de tours nécessaires pour que la chaîne soit composée du même caractère ?\n\nExemples :\n>>> f_31(\"aab\")\n1\n>>> f_31(\"abc\")\n2\n>>> f_31(\"aaa\")\n0", "de": "Angenommen, ein String besteht aus Kleinbuchstaben des englischen Alphabets. In jeder Runde kann man eines der Zeichen in ein anderes Zeichen ändern. Die Frage ist: Wie viele Runden sind mindestens erforderlich, um den String aus demselben Zeichen zusammengesetzt zu machen?\n\nBeispiele:\n>>> f_31(\"aab\")\n1\n>>> f_31(\"abc\")\n2\n>>> f_31(\"aaa\")\n0", "ha": "An ba da wata igiyar rubutu da ke kunshe da ƙananan haruffan Ingilishi, a kowace zagaye za ka iya canza ɗaya daga cikin haruffan zuwa wani harafi daban. Tambayar ita ce: menene mafi ƙarancin adadin zagaye da ake buƙata don sanya igiyar rubutu ta ƙunshi harafi ɗaya?\n\nMisalai:\n>>> f_31(\"aab\")\n1\n>>> f_31(\"abc\")\n2\n>>> f_31(\"aaa\")\n0", "hi": "दिए गए स्ट्रिंग में छोटे अंग्रेजी अक्षरों का समावेश है, प्रत्येक राउंड में आप एक अक्षर को दूसरे अक्षर में बदल सकते हैं। प्रश्न यह है: स्ट्रिंग को एक ही अक्षर से मिलकर बनाने के लिए न्यूनतम कितने राउंड की आवश्यकता है?\n\nउदाहरण:\n>>> f_31(\"aab\")\n1\n>>> f_31(\"abc\")\n2\n>>> f_31(\"aaa\")\n0", "hu": "Adott egy kisbetűs angol betűkből álló karakterlánc, minden körben megváltoztathatod az egyik karaktert egy másik karakterre. A kérdés az: mi a minimális körök száma, amely szükséges ahhoz, hogy a karakterlánc ugyanabból a karakterből álljon?\n\nPéldák:\n>>> f_31(\"aab\")\n1\n>>> f_31(\"abc\")\n2\n>>> f_31(\"aaa\")\n0", "es": "Dada una cadena que consiste en letras minúsculas del alfabeto inglés, en cada ronda puedes cambiar uno de los caracteres por otro carácter. La pregunta es: ¿cuál es el número mínimo de rondas necesarias para que la cadena esté compuesta por el mismo carácter?\n\nEjemplos:\n>>> f_31(\"aab\")\n1\n>>> f_31(\"abc\")\n2\n>>> f_31(\"aaa\")\n0", "arb": "بالنظر إلى سلسلة تتكون من حروف إنجليزية صغيرة، في كل جولة يمكنك تغيير أحد الأحرف إلى حرف آخر. السؤال هو: ما هو الحد الأدنى لعدد الجولات اللازمة لجعل السلسلة تتكون من نفس الحرف؟\n\nأمثلة:\n>>> f_31(\"aab\")\n1\n>>> f_31(\"abc\")\n2\n>>> f_31(\"aaa\")\n0", "sw": "Kwa kuzingatia kamba inayojumuisha herufi ndogo za Kiingereza, katika kila raundi unaweza kubadilisha moja ya herufi kuwa herufi nyingine. Swali ni: ni idadi gani ndogo zaidi ya raundi zinazohitajika ili kufanya kamba iwe na herufi sawa?\n\nMifano:\n>>> f_31(\"aab\")\n1\n>>> f_31(\"abc\")\n2\n>>> f_31(\"aaa\")\n0", "tr": "Verilen küçük İngilizce harflerden oluşan bir dize için, her turda karakterlerden birini başka bir karaktere değiştirebilirsiniz. Soru şu: Diziyi aynı karakterden oluşacak şekilde yapmak için gereken minimum tur sayısı nedir?\n\nÖrnekler:\n>>> f_31(\"aab\")\n1\n>>> f_31(\"abc\")\n2\n>>> f_31(\"aaa\")\n0", "vi": "Cho một chuỗi bao gồm các chữ cái tiếng Anh viết thường, trong mỗi vòng bạn có thể thay đổi một trong các ký tự thành ký tự khác. Câu hỏi là: số vòng tối thiểu cần thiết để làm cho chuỗi được tạo thành từ cùng một ký tự là bao nhiêu?\n\nVí dụ:\n>>> f_31(\"aab\")\n1\n>>> f_31(\"abc\")\n2\n>>> f_31(\"aaa\")\n0", "id": "Diberikan sebuah string yang terdiri dari huruf kecil bahasa Inggris, pada setiap putaran Anda dapat mengubah salah satu karakter menjadi karakter lain. Pertanyaannya adalah: berapa jumlah putaran minimum yang diperlukan untuk membuat string terdiri dari karakter yang sama?\n\nContoh:\n>>> f_31(\"aab\")\n1\n>>> f_31(\"abc\")\n2\n>>> f_31(\"aaa\")\n0", "ja": "文字列が小文字の英字で構成されているとき、各ラウンドで文字の1つを別の文字に変更できます。質問は、文字列を同じ文字で構成するために必要な最小ラウンド数は何ですか？\n\n例:\n>>> f_31(\"aab\")\n1\n>>> f_31(\"abc\")\n2\n>>> f_31(\"aaa\")\n0", "ko": "주어진 문자열이 소문자 영어 문자로 구성되어 있을 때, 각 라운드마다 문자를 다른 문자로 변경할 수 있습니다. 질문은: 문자열을 동일한 문자로 구성하기 위해 필요한 최소 라운드 수는 얼마입니까?\n\n예시:\n>>> f_31(\"aab\")\n1\n>>> f_31(\"abc\")\n2\n>>> f_31(\"aaa\")\n0", "ml": "ഒരു ചെറിയ ഇംഗ്ലീഷ് അക്ഷരങ്ങളടങ്ങിയ സ്ട്രിംഗ് നൽകിയാൽ, ഓരോ റൗണ്ടിലും നിങ്ങൾക്ക് ഒരു അക്ഷരം മറ്റൊരു അക്ഷരത്തിലേക്ക് മാറ്റാൻ കഴിയും. ചോദ്യമെന്നാൽ: സ്ട്രിംഗ് ഒരേ അക്ഷരത്തിൽ നിന്നുള്ളതാക്കാൻ ആവശ്യമായ കുറഞ്ഞ റൗണ്ടുകളുടെ എണ്ണം എത്ര?\n\nഉദാഹരണങ്ങൾ:\n>>> f_31(\"aab\")\n1\n>>> f_31(\"abc\")\n2\n>>> f_31(\"aaa\")\n0", "fa": "با توجه به یک رشته که از حروف کوچک انگلیسی تشکیل شده است، در هر دور می‌توانید یکی از کاراکترها را به کاراکتر دیگری تغییر دهید. سوال این است: حداقل تعداد دورهای مورد نیاز برای تبدیل رشته به رشته‌ای که از یک کاراکتر مشابه تشکیل شده باشد، چقدر است؟\n\nمثال‌ها:\n>>> f_31(\"aab\")\n1\n>>> f_31(\"abc\")\n2\n>>> f_31(\"aaa\")\n0"}}
{"task_id": "CPP/32", "prompt": {"en": "#include <cassert>\n#include <cstdio>\n/**\n * Given a sequence of n events, each occurring with a periodicity of a_i years, the task is to find\n * the year Y_n when the n-th event occurs. The countdown for event i+1 only starts in the year\n * immediately following the occurrence of event i.\n * Example usage:\n *     f_32(6, {3,2,4,5,9,18}) returns 36\n */\nint f_32(int n, int signs[])", "sq": "#include <cassert>\n#include <cstdio>\n/**\n * Duke pasur një sekuencë prej n ngjarjesh, secila që ndodh me një periodikë prej a_i vitesh, detyra është të gjejmë\n * vitin Y_n kur ndodh ngjarja e n-të. Numërimi mbrapsht për ngjarjen i+1 fillon vetëm në vitin\n * menjëherë pas ndodhjes së ngjarjes i.\n * Shembull përdorimi:\n *     f_32(6, {3,2,4,5,9,18}) kthen 36\n */\nint f_32(int n, int signs[])", "hy": "#include <cassert>\n#include <cstdio>\n/**\n * Տրված է n իրադարձությունների հաջորդականություն, որոնցից յուրաքանչյուրը տեղի է ունենում a_i տարիների պարբերականությամբ, խնդիրը գտնելն է\n * Y_n տարին, երբ տեղի է ունենում n-րդ իրադարձությունը։ Իրադարձություն i+1-ի համար հաշվարկը սկսվում է միայն այն տարում,\n * որը անմիջապես հաջորդում է իրադարձություն i-ի տեղի ունենալուն։\n * Օրինակ օգտագործում:\n *     f_32(6, {3,2,4,5,9,18}) վերադարձնում է 36\n */\nint f_32(int n, int signs[])", "bn": "#include <cassert>\n#include <cstdio>\n/**\n * nটি ঘটনার একটি ক্রম দেওয়া হয়েছে, প্রতিটি a_i বছর পরপর ঘটে, কাজটি হল n-তম ঘটনা যখন ঘটে সেই বছর Y_n খুঁজে বের করা।\n * ঘটনা i+1 এর জন্য কাউন্টডাউন শুধুমাত্র ঘটনা i ঘটার পরের বছর থেকে শুরু হয়।\n * উদাহরণ ব্যবহার:\n *     f_32(6, {3,2,4,5,9,18}) 36 প্রদান করে\n */\nint f_32(int n, int signs[])", "bg": "#include <cassert>\n#include <cstdio>\n/**\n * Дадена е последователност от n събития, всяко от които се случва с периодичност от a_i години, задачата е да се намери\n * годината Y_n, когато се случва n-тото събитие. Обратното броене за събитие i+1 започва само в годината\n * непосредствено след настъпването на събитие i.\n * Пример за използване:\n *     f_32(6, {3,2,4,5,9,18}) returns 36\n */\nint f_32(int n, int signs[])", "zh": "#include <cassert>\n#include <cstdio>\n/**\n * 给定一个由 n 个事件组成的序列，每个事件以 a_i 年为周期发生，任务是找到第 n 个事件发生的年份 Y_n。\n * 事件 i+1 的倒计时仅在事件 i 发生后的年份开始。\n * 示例用法：\n *     f_32(6, {3,2,4,5,9,18}) 返回 36\n */\nint f_32(int n, int signs[])", "fr": "#include <cassert>\n#include <cstdio>\n/**\n * Étant donné une séquence de n événements, chacun se produisant avec une périodicité de a_i années, la tâche consiste à trouver\n * l'année Y_n lorsque le n-ième événement se produit. Le compte à rebours pour l'événement i+1 ne commence que l'année\n * suivant immédiatement l'occurrence de l'événement i.\n * Exemple d'utilisation :\n *     f_32(6, {3,2,4,5,9,18}) renvoie 36\n */\nint f_32(int n, int signs[])", "de": "#include <cassert>\n#include <cstdio>\n/**\n * Gegeben eine Sequenz von n Ereignissen, die jeweils mit einer Periodizität von a_i Jahren auftreten, besteht die Aufgabe darin,\n * das Jahr Y_n zu finden, in dem das n-te Ereignis eintritt. Der Countdown für das Ereignis i+1 beginnt erst im Jahr\n * unmittelbar nach dem Eintreten des Ereignisses i.\n * Beispielverwendung:\n *     f_32(6, {3,2,4,5,9,18}) gibt 36 zurück\n */\nint f_32(int n, int signs[])", "ha": "#include <cassert>\n#include <cstdio>\n/**\n * An ba da jerin abubuwan n, kowanne yana faruwa da tsawon lokaci na a_i shekaru, aikin shine a gano\n * shekarar Y_n lokacin da abin n-th ya faru. Kirga don abin i+1 kawai yana farawa a shekarar\n * nan take bayan faruwar abin i.\n * Misalin amfani:\n *     f_32(6, {3,2,4,5,9,18}) returns 36\n */\nint f_32(int n, int signs[])", "hi": "#include <cassert>\n#include <cstdio>\n/**\n * n घटनाओं के अनुक्रम को दिया गया है, प्रत्येक घटना a_i वर्षों की आवधिकता के साथ होती है, कार्य यह है कि\n * वर्ष Y_n का पता लगाएं जब n-वीं घटना होती है। घटना i+1 के लिए उलटी गिनती केवल उसी वर्ष में शुरू होती है\n * जब घटना i होती है।\n * उदाहरण उपयोग:\n *     f_32(6, {3,2,4,5,9,18}) returns 36\n */\nint f_32(int n, int signs[])", "hu": "#include <cassert>\n#include <cstdio>\n/**\n * Adott egy n eseményből álló sorozat, amelyek mindegyike a_i évenként fordul elő, a feladat az,\n * hogy megtaláljuk az Y_n évet, amikor az n-edik esemény bekövetkezik. Az i+1-edik esemény\n * visszaszámlálása csak az i-edik esemény bekövetkezését követő évben kezdődik.\n * Példa használat:\n *     f_32(6, {3,2,4,5,9,18}) visszaadja 36\n */\nint f_32(int n, int signs[])", "es": "#include <cassert>\n#include <cstdio>\n/**\n * Dada una secuencia de n eventos, cada uno ocurriendo con una periodicidad de a_i años, la tarea es encontrar\n * el año Y_n cuando ocurre el n-ésimo evento. La cuenta regresiva para el evento i+1 solo comienza en el año\n * inmediatamente después de la ocurrencia del evento i.\n * Ejemplo de uso:\n *     f_32(6, {3,2,4,5,9,18}) devuelve 36\n */\nint f_32(int n, int signs[])", "arb": "#include <cassert>\n#include <cstdio>\n/**\n * بالنظر إلى تسلسل من n أحداث، كل منها يحدث بدورية a_i سنوات، المهمة هي إيجاد\n * السنة Y_n عندما يحدث الحدث n. يبدأ العد التنازلي للحدث i+1 فقط في السنة\n * التي تلي مباشرة حدوث الحدث i.\n * مثال على الاستخدام:\n *     f_32(6, {3,2,4,5,9,18}) returns 36\n */\nint f_32(int n, int signs[])", "sw": "#include <cassert>\n#include <cstdio>\n/**\n * Ukipewa mlolongo wa matukio n, kila moja likitokea kwa kipindi cha miaka a_i, kazi ni kupata\n * mwaka Y_n ambapo tukio la n linatokea. Hesabu ya tukio i+1 inaanza tu katika mwaka\n * unaofuata mara baada ya tukio i kutokea.\n * Mfano wa matumizi:\n *     f_32(6, {3,2,4,5,9,18}) inarudisha 36\n */\nint f_32(int n, int signs[])", "tr": "#include <cassert>\n#include <cstdio>\n/**\n * n olayından oluşan bir dizi verildiğinde, her biri a_i yıl periyoduyla gerçekleşen, \n * n'inci olayın gerçekleştiği Y_n yılını bulma görevi. i+1'inci olayın geri sayımı, \n * yalnızca i'inci olayın gerçekleştiği yılın hemen ardından başlar.\n * Örnek kullanım:\n *     f_32(6, {3,2,4,5,9,18}) 36 döndürür\n */\nint f_32(int n, int signs[])", "vi": "#include <cassert>\n#include <cstdio>\n/**\n * Cho một chuỗi n sự kiện, mỗi sự kiện xảy ra với chu kỳ a_i năm, nhiệm vụ là tìm\n * năm Y_n khi sự kiện thứ n xảy ra. Đếm ngược cho sự kiện i+1 chỉ bắt đầu vào năm\n * ngay sau khi sự kiện i xảy ra.\n * Ví dụ sử dụng:\n *     f_32(6, {3,2,4,5,9,18}) trả về 36\n */\nint f_32(int n, int signs[])", "id": "#include <cassert>\n#include <cstdio>\n/**\n * Diberikan sebuah urutan dari n kejadian, masing-masing terjadi dengan periodisitas a_i tahun, tugasnya adalah untuk menemukan\n * tahun Y_n ketika kejadian ke-n terjadi. Hitungan mundur untuk kejadian i+1 hanya dimulai pada tahun\n * segera setelah terjadinya kejadian i.\n * Contoh penggunaan:\n *     f_32(6, {3,2,4,5,9,18}) mengembalikan 36\n */\nint f_32(int n, int signs[])", "ja": "#include <cassert>\n#include <cstdio>\n/**\n * n個のイベントのシーケンスが与えられ、それぞれがa_i年の周期で発生します。タスクは、n番目のイベントが発生する年Y_nを見つけることです。\n * イベントi+1のカウントダウンは、イベントiが発生した直後の年からのみ開始されます。\n * 使用例:\n *     f_32(6, {3,2,4,5,9,18}) は36を返します\n */\nint f_32(int n, int signs[])", "ko": "#include <cassert>\n#include <cstdio>\n/**\n * 주어진 n개의 사건 시퀀스에서 각각 a_i년 주기로 발생하는 경우, n번째 사건이 발생하는 해 Y_n을 찾는 것이 과제입니다. \n * 사건 i+1의 카운트다운은 사건 i가 발생한 바로 다음 해에만 시작됩니다.\n * 사용 예:\n *     f_32(6, {3,2,4,5,9,18})는 36을 반환합니다.\n */\nint f_32(int n, int signs[])", "ml": "#include <cassert>\n#include <cstdio>\n/**\n * n സംഭവങ്ങളുടെ ഒരു അനുക്രമം നൽകിയാൽ, ഓരോത് a_i വർഷങ്ങളുടെ കാലയളവിൽ സംഭവിക്കുന്നു, \n * n-ആമത്തെ സംഭവം സംഭവിക്കുന്ന വർഷം Y_n കണ്ടെത്തുക എന്നതാണ് ഈ പ്രവൃത്തിയുടെ ലക്ഷ്യം. \n * സംഭവം i+1-ന്റെ കൗണ്ട്ഡൗൺ, സംഭവം i സംഭവിക്കുന്ന വർഷത്തിന് തൊട്ടുപിന്നാലെ മാത്രമേ ആരംഭിക്കൂ.\n * ഉദാഹരണ ഉപയോഗം:\n *     f_32(6, {3,2,4,5,9,18}) 36 തിരിച്ചുനൽകുന്നു\n */\nint f_32(int n, int signs[])", "fa": "#include <cassert>\n#include <cstdio>\n/**\n * با توجه به دنباله‌ای از n رویداد، هر کدام با دوره تناوب a_i سال رخ می‌دهند، وظیفه این است که\n * سال Y_n را پیدا کنیم که در آن n-امین رویداد رخ می‌دهد. شمارش معکوس برای رویداد i+1 فقط در سال\n * بلافاصله پس از وقوع رویداد i شروع می‌شود.\n * مثال استفاده:\n *     f_32(6, {3,2,4,5,9,18}) returns 36\n */\nint f_32(int n, int signs[])"}, "canonical_solution": "{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        year = ((year / period) + 1) * period;\n    }\n    return year;\n}", "instruction": {"en": "Write a CPP function `int f_32(int n, int signs[])` to solve the following problem:\nGiven a sequence of n events, each occurring with a periodicity of a_i years, the task is to find\nthe year Y_n when the n-th event occurs. The countdown for event i+1 only starts in the year\nimmediately following the occurrence of event i.\nExample usage:\nf_32(6, {3,2,4,5,9,18}) returns 36", "sq": "Shkruani një funksion CPP `int f_32(int n, int signs[])` për të zgjidhur problemin e mëposhtëm:\nDuke pasur një sekuencë prej n ngjarjesh, secila që ndodh me një periodikë prej a_i vitesh, detyra është të gjendet\nviti Y_n kur ndodh ngjarja e n-të. Numërimi mbrapsht për ngjarjen i+1 fillon vetëm në vitin\nmenjëherë pas ndodhjes së ngjarjes i.\nShembull përdorimi:\nf_32(6, {3,2,4,5,9,18}) kthen 36", "hy": "Գրեք CPP ֆունկցիա `int f_32(int n, int signs[])` հետևյալ խնդիրը լուծելու համար:\nՏրված է n իրադարձությունների հաջորդականություն, որոնցից յուրաքանչյուրն ունի a_i տարիների պարբերականություն, խնդիրը գտնելն է Y_n տարին, երբ տեղի է ունենում n-րդ իրադարձությունը: Իրադարձություն i+1-ի հետհաշվարկը սկսվում է միայն i իրադարձության տեղի ունենալուց անմիջապես հետո:\nՕրինակ օգտագործում:\nf_32(6, {3,2,4,5,9,18}) վերադարձնում է 36", "bn": "একটি CPP ফাংশন `int f_32(int n, int signs[])` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nnটি ঘটনার একটি ক্রম দেওয়া হয়েছে, প্রতিটি a_i বছর পরপর ঘটে, কাজটি হল Y_n বছরটি খুঁজে বের করা যখন n-তম ঘটনা ঘটে। ঘটনা i+1 এর জন্য কাউন্টডাউন শুধুমাত্র ঘটনা i ঘটার পরের বছর থেকে শুরু হয়।\nউদাহরণ ব্যবহার:\nf_32(6, {3,2,4,5,9,18}) returns 36", "bg": "Напишете CPP функция `int f_32(int n, int signs[])`, за да решите следния проблем: Дадена е последователност от n събития, всяко от които се случва с периодичност от a_i години, задачата е да се намери годината Y_n, когато се случва n-тото събитие. Обратното броене за събитие i+1 започва само в годината непосредствено след настъпването на събитие i. Пример за използване: f_32(6, {3,2,4,5,9,18}) връща 36", "zh": "编写一个 CPP 函数 `int f_32(int n, int signs[])` 来解决以下问题：  \n给定一个包含 n 个事件的序列，每个事件以 a_i 年为周期发生，任务是找到第 n 个事件发生的年份 Y_n。事件 i+1 的倒计时仅在事件 i 发生后的年份开始。  \n示例用法：  \nf_32(6, {3,2,4,5,9,18}) 返回 36", "fr": "Écrire une fonction CPP `int f_32(int n, int signs[])` pour résoudre le problème suivant :  \nÉtant donné une séquence de n événements, chacun se produisant avec une périodicité de a_i années, la tâche consiste à trouver l'année Y_n lorsque le n-ième événement se produit. Le compte à rebours pour l'événement i+1 ne commence que l'année suivant immédiatement la survenue de l'événement i.  \nExemple d'utilisation :  \nf_32(6, {3,2,4,5,9,18}) retourne 36", "de": "Schreiben Sie eine CPP-Funktion `int f_32(int n, int signs[])`, um das folgende Problem zu lösen:\nGegeben ist eine Sequenz von n Ereignissen, die jeweils mit einer Periodizität von a_i Jahren auftreten. Die Aufgabe besteht darin, das Jahr Y_n zu finden, in dem das n-te Ereignis eintritt. Der Countdown für das Ereignis i+1 beginnt erst im Jahr unmittelbar nach dem Auftreten des Ereignisses i.\nBeispielverwendung:\nf_32(6, {3,2,4,5,9,18}) gibt 36 zurück.", "ha": "Rubuta aikin CPP `int f_32(int n, int signs[])` don magance matsalar mai zuwa:\nAn ba da jerin abubuwan n, kowannensu yana faruwa tare da maimaita shekaru a_i, aikin shine gano shekarar Y_n lokacin da abin n-th ya faru. Kirga don abin i+1 kawai yana farawa a shekarar da ke biye da faruwar abin i.\nMisalin amfani:\nf_32(6, {3,2,4,5,9,18}) yana dawowa 36", "hi": "`int f_32(int n, int signs[])` फ़ंक्शन लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए n घटनाओं के अनुक्रम में, प्रत्येक घटना a_i वर्षों की आवृत्ति के साथ होती है, कार्य यह है कि वर्ष Y_n का पता लगाएं जब n-वां घटना होती है। घटना i+1 की उलटी गिनती केवल घटना i के होने के तुरंत बाद वाले वर्ष में शुरू होती है।\nउदाहरण उपयोग:\nf_32(6, {3,2,4,5,9,18}) 36 लौटाता है", "hu": "Írj egy CPP függvényt `int f_32(int n, int signs[])` a következő probléma megoldására:\nAdott egy n eseményből álló sorozat, ahol mindegyik esemény a_i évek periodicitással fordul elő, a feladat az Y_n év megtalálása, amikor az n-edik esemény bekövetkezik. Az i+1 esemény visszaszámlálása csak az i esemény bekövetkezését követő évben kezdődik.\nPélda használat:\nf_32(6, {3,2,4,5,9,18}) visszaadja a 36-ot", "es": "Escribe una función en CPP `int f_32(int n, int signs[])` para resolver el siguiente problema:\nDada una secuencia de n eventos, cada uno ocurriendo con una periodicidad de a_i años, la tarea es encontrar el año Y_n cuando ocurre el n-ésimo evento. La cuenta regresiva para el evento i+1 solo comienza en el año inmediatamente posterior a la ocurrencia del evento i.\nEjemplo de uso:\nf_32(6, {3,2,4,5,9,18}) devuelve 36", "arb": "اكتب دالة CPP `int f_32(int n, int signs[])` لحل المشكلة التالية:\nبالنظر إلى تسلسل من n أحداث، كل منها يحدث بشكل دوري كل a_i سنوات، المهمة هي إيجاد\nالسنة Y_n عندما يحدث الحدث n. يبدأ العد التنازلي للحدث i+1 فقط في السنة\nالتي تلي مباشرة حدوث الحدث i.\nمثال على الاستخدام:\nf_32(6, {3,2,4,5,9,18}) يعيد 36", "sw": "Andika kazi ya CPP `int f_32(int n, int signs[])` kutatua tatizo lifuatalo:\nUkipewa mlolongo wa matukio n, kila moja likitokea kwa kipindi cha miaka a_i, kazi ni kupata\nmwaka Y_n ambapo tukio la n linatokea. Muda wa kuhesabu kwa tukio i+1 unaanza tu katika mwaka\nunaofuata mara tu baada ya tukio i kutokea.\nMfano wa matumizi:\nf_32(6, {3,2,4,5,9,18}) inarudisha 36", "tr": "Bir CPP fonksiyonu `int f_32(int n, int signs[])` yazın ve aşağıdaki problemi çözün:\nn olayından oluşan bir dizisi verildiğinde, her biri a_i yıllık bir periyodiklikle meydana gelen, görev\nn'inci olayın gerçekleştiği Y_n yılını bulmaktır. i+1 olayının geri sayımı yalnızca i olayının meydana geldiği yılın hemen ardından başlar.\nÖrnek kullanım:\nf_32(6, {3,2,4,5,9,18}) 36 döndürür", "vi": "Viết một hàm CPP `int f_32(int n, int signs[])` để giải quyết vấn đề sau:\nCho một dãy gồm n sự kiện, mỗi sự kiện xảy ra với chu kỳ a_i năm, nhiệm vụ là tìm\nnăm Y_n khi sự kiện thứ n xảy ra. Đếm ngược cho sự kiện i+1 chỉ bắt đầu vào năm\nngay sau khi sự kiện i xảy ra.\nVí dụ sử dụng:\nf_32(6, {3,2,4,5,9,18}) trả về 36", "id": "Tulis fungsi CPP `int f_32(int n, int signs[])` untuk menyelesaikan masalah berikut:\nDiberikan sebuah urutan dari n kejadian, masing-masing terjadi dengan periodisitas a_i tahun, tugasnya adalah menemukan tahun Y_n ketika kejadian ke-n terjadi. Hitungan mundur untuk kejadian i+1 hanya dimulai pada tahun yang segera mengikuti terjadinya kejadian i.\nContoh penggunaan:\nf_32(6, {3,2,4,5,9,18}) mengembalikan 36", "ja": "CPP関数 `int f_32(int n, int signs[])` を作成して、次の問題を解決してください:\nn個のイベントのシーケンスが与えられ、それぞれがa_i年の周期で発生します。タスクは、n番目のイベントが発生する年Y_nを見つけることです。イベントi+1のカウントダウンは、イベントiが発生した直後の年からのみ始まります。\n使用例:\nf_32(6, {3,2,4,5,9,18}) は36を返します", "ko": "CPP 함수 `int f_32(int n, int signs[])`를 작성하여 다음 문제를 해결하십시오:\n주어진 n개의 사건 시퀀스에서 각 사건은 a_i년 주기로 발생합니다. n번째 사건이 발생하는 연도 Y_n을 찾는 것이 과제입니다. 사건 i+1의 카운트다운은 사건 i가 발생한 직후의 연도부터 시작됩니다.\n사용 예:\nf_32(6, {3,2,4,5,9,18})는 36을 반환합니다.", "ml": "`int f_32(int n, int signs[])` എന്ന CPP ഫംഗ്ഷൻ എഴുതുക താഴെ കൊടുത്തിരിക്കുന്ന പ്രശ്നം പരിഹരിക്കാൻ: n സംഭവങ്ങളുടെ ഒരു ക്രമം നൽകിയിരിക്കുന്നു, ഓരോത് a_i വർഷങ്ങളുടെ കാലയളവിൽ സംഭവിക്കുന്നു, n-ആമത്തെ സംഭവം നടക്കുമ്പോഴുള്ള Y_n വർഷം കണ്ടെത്തുക എന്നതാണ് ഈ പ്രവർത്തി. സംഭവം i+1 ന്റെ കൗണ്ട്ഡൗൺ, സംഭവം i നടന്നതിനു തൊട്ടുപിന്നാലെയുള്ള വർഷം മാത്രമേ ആരംഭിക്കൂ. ഉദാഹരണ ഉപയോഗം: f_32(6, {3,2,4,5,9,18}) 36 മടക്കുന്നു", "fa": "یک تابع CPP `int f_32(int n, int signs[])` بنویسید تا مسئله زیر را حل کند:\nبا توجه به دنباله‌ای از n رویداد، که هر کدام با دوره تناوب a_i سال اتفاق می‌افتند، وظیفه این است که سال Y_n را پیدا کنید که در آن رویداد n-ام رخ می‌دهد. شمارش معکوس برای رویداد i+1 فقط در سال بلافاصله پس از وقوع رویداد i شروع می‌شود.\nمثال استفاده:\nf_32(6, {3,2,4,5,9,18}) مقدار 36 را برمی‌گرداند."}, "level": "easy", "test": "int main() {\n    int arr1[] = {3,2,4,5,9,18};\n    assert(f_32(6, arr1) == 36);\n    int arr2[] = {1, 2,3,4,5};\n    assert(f_32(5, arr2) == 5);\n    int arr3[] = {1,1,1,1,1};\n    assert(f_32(5, arr3) == 5);\n    int arr4[] = {50,30,711,200,503,1006};\n    assert(f_32(6, arr4) == 2012);\n    int arr5[] = {1, 2};\n    assert(f_32(2, arr5) == 2);\n    int arr6[] = {3, 1, 2};\n    assert(f_32(3, arr6) == 6);\n    int arr7[] = {2, 3, 4};\n    assert(f_32(3, arr7) == 4);\n    int arr8[] = {1, 2, 3, 4};\n    assert(f_32(4, arr8) == 4);\n    int arr9[] = {5, 7, 11, 13};\n    assert(f_32(4, arr9) == 13);\n    int arr10[] = {2, 2, 2, 2, 2};\n    assert(f_32(5, arr10) == 10);\n    int arr11[] = {6, 10, 15};\n    assert(f_32(3, arr11) == 15);\n    int arr12[] = {4, 6, 14};\n    assert(f_32(3, arr12) == 14);\n    int arr13[] = {50, 30, 711, 200};\n    assert(f_32(4, arr13) == 800);\n    int arr14[] = {1, 1, 1, 1, 1, 1};\n    assert(f_32(6, arr14) == 6);\n    int arr15[] = {1000000, 999999};\n    assert(f_32(2, arr15) == 1999998);\n    return 0;\n}", "entry_point": "f_32", "signature": "int f_32(int n, int signs[])", "docstring": {"en": "Given a sequence of n events, each occurring with a periodicity of a_i years, the task is to find\nthe year Y_n when the n-th event occurs. The countdown for event i+1 only starts in the year\nimmediately following the occurrence of event i.\nExample usage:\nf_32(6, {3,2,4,5,9,18}) returns 36", "sq": "Duke pasur një sekuencë prej n ngjarjesh, secila që ndodh me një periudhë prej a_i vitesh, detyra është të gjendet viti Y_n kur ndodh ngjarja e n-të. Numërimi mbrapsht për ngjarjen i+1 fillon vetëm në vitin menjëherë pas ndodhjes së ngjarjes i.\nShembull përdorimi:\nf_32(6, {3,2,4,5,9,18}) kthen 36", "hy": "Տրված է n իրադարձությունների հաջորդականություն, որոնցից յուրաքանչյուրը տեղի է ունենում a_i տարիների պարբերականությամբ, խնդիրն է գտնել Y_n տարին, երբ տեղի է ունենում n-րդ իրադարձությունը: i+1 իրադարձության հաշվարկը սկսվում է միայն այն տարում, որը անմիջապես հաջորդում է i իրադարձության տեղի ունենալուն:\nՕրինակ օգտագործում:\nf_32(6, {3,2,4,5,9,18}) վերադարձնում է 36", "bn": "প্রদত্ত nটি ঘটনার একটি ক্রমে, প্রতিটি ঘটনা a_i বছর পরপর ঘটে, কাজটি হল n-তম ঘটনা যখন ঘটে সেই বছর Y_n খুঁজে বের করা। ঘটনা i+1 এর জন্য কাউন্টডাউন শুধুমাত্র ঘটনা i ঘটার পরের বছর থেকে শুরু হয়।\n\nউদাহরণ ব্যবহার:\nf_32(6, {3,2,4,5,9,18}) 36 প্রদান করে", "bg": "Дадена е последователност от n събития, всяко от които се случва с периодичност от a_i години, задачата е да се намери годината Y_n, когато се случва n-тото събитие. Обратното броене за събитие i+1 започва едва в годината, непосредствено следваща събитието i.\nПример за използване:\nf_32(6, {3,2,4,5,9,18}) връща 36", "zh": "给定一个由 n 个事件组成的序列，每个事件以 a_i 年为周期发生，任务是找到第 n 个事件发生的年份 Y_n。事件 i+1 的倒计时仅在事件 i 发生后的年份开始。\n\n示例用法：\nf_32(6, {3,2,4,5,9,18}) 返回 36", "fr": "Étant donné une séquence de n événements, chacun se produisant avec une périodicité de a_i années, la tâche consiste à trouver l'année Y_n lorsque le n-ième événement se produit. Le compte à rebours pour l'événement i+1 ne commence que l'année suivant immédiatement l'occurrence de l'événement i.\nExemple d'utilisation :\nf_32(6, {3,2,4,5,9,18}) retourne 36", "de": "Gegeben eine Sequenz von n Ereignissen, die jeweils mit einer Periodizität von a_i Jahren auftreten, besteht die Aufgabe darin, das Jahr Y_n zu finden, in dem das n-te Ereignis eintritt. Der Countdown für Ereignis i+1 beginnt erst im Jahr unmittelbar nach dem Auftreten von Ereignis i.\n\nBeispielverwendung:\nf_32(6, {3,2,4,5,9,18}) gibt 36 zurück", "ha": "An ba da jerin abubuwan n, kowanne yana faruwa tare da maimaitawar a_i shekaru, aikin shine nemo shekarar Y_n lokacin da abin n-th ya faru. Kirga don abin i+1 kawai yana farawa a shekarar da ke biye da faruwar abin i.\n\nMisalin amfani:\nf_32(6, {3,2,4,5,9,18}) returns 36", "hi": "n घटनाओं के अनुक्रम को देखते हुए, जिनमें से प्रत्येक a_i वर्षों की आवधिकता के साथ होता है, कार्य यह है कि n-वीं घटना के घटित होने वाले वर्ष Y_n को खोजा जाए। घटना i+1 की उलटी गिनती केवल घटना i के घटित होने के तुरंत बाद वाले वर्ष में शुरू होती है। \n\nउदाहरण उपयोग:\nf_32(6, {3,2,4,5,9,18}) 36 लौटाता है", "hu": "Egy n eseményből álló sorozat esetén, ahol mindegyik esemény a_i évek periodicitással következik be, a feladat megtalálni az Y_n évet, amikor az n-edik esemény bekövetkezik. Az i+1 esemény visszaszámlálása csak az i esemény bekövetkezését követő évben kezdődik.\nPélda használat:\nf_32(6, {3,2,4,5,9,18}) visszaadja 36", "es": "Dada una secuencia de n eventos, cada uno ocurriendo con una periodicidad de a_i años, la tarea es encontrar el año Y_n cuando ocurre el n-ésimo evento. La cuenta regresiva para el evento i+1 solo comienza en el año inmediatamente posterior a la ocurrencia del evento i.\n\nEjemplo de uso:\nf_32(6, {3,2,4,5,9,18}) devuelve 36", "arb": "بالنظر إلى تسلسل من n من الأحداث، كل منها يحدث بتكرار دوري قدره a_i سنوات، فإن المهمة هي إيجاد السنة Y_n عندما يحدث الحدث n. يبدأ العد التنازلي للحدث i+1 فقط في السنة التي تلي مباشرة حدوث الحدث i.\n\nاستخدام المثال:\nf_32(6, {3,2,4,5,9,18}) يعيد 36", "sw": "Kwa kuzingatia mlolongo wa matukio n, kila moja likitokea kwa kipindi cha miaka a_i, kazi ni kupata mwaka Y_n ambapo tukio la n linatokea. Hesabu ya tukio i+1 inaanza tu katika mwaka unaofuata mara baada ya tukio i kutokea.\n\nMfano wa matumizi:\nf_32(6, {3,2,4,5,9,18}) inarudisha 36", "tr": "Verilen n adet olaydan oluşan bir dizide, her biri a_i yıllık bir periyodiklikle meydana gelen olaylar için, n'inci olayın gerçekleştiği yıl Y_n bulunmalıdır. i+1'inci olayın geri sayımı, yalnızca i'inci olayın gerçekleştiği yılın hemen ardından başlar.\nÖrnek kullanım:\nf_32(6, {3,2,4,5,9,18}) 36 döndürür", "vi": "Cho một dãy gồm n sự kiện, mỗi sự kiện xảy ra với chu kỳ a_i năm, nhiệm vụ là tìm năm Y_n khi sự kiện thứ n xảy ra. Đếm ngược cho sự kiện i+1 chỉ bắt đầu vào năm ngay sau khi sự kiện i xảy ra.\nVí dụ sử dụng:\n\nf_32(6, {3,2,4,5,9,18}) trả về 36", "id": "Diberikan sebuah urutan dari n kejadian, masing-masing terjadi dengan periodisitas a_i tahun, tugasnya adalah menemukan tahun Y_n ketika kejadian ke-n terjadi. Hitungan mundur untuk kejadian i+1 hanya dimulai pada tahun segera setelah terjadinya kejadian i.\n\nPenggunaan contoh:\nf_32(6, {3,2,4,5,9,18}) mengembalikan 36", "ja": "n 個のイベントのシーケンスがあり、それぞれが a_i 年の周期で発生する場合、n 番目のイベントが発生する年 Y_n を見つけるタスクです。イベント i+1 のカウントダウンは、イベント i が発生した直後の年からのみ開始されます。\n\n使用例:\nf_32(6, {3,2,4,5,9,18}) は 36 を返します。", "ko": "주어진 n개의 이벤트 시퀀스에서 각 이벤트는 a_i년의 주기로 발생하며, n번째 이벤트가 발생하는 연도 Y_n을 찾는 것이 과제입니다. 이벤트 i+1의 카운트다운은 이벤트 i가 발생한 직후의 연도부터 시작됩니다. \n\n예제 사용법:\nf_32(6, {3,2,4,5,9,18})는 36을 반환합니다.", "ml": "ഒരു നിരയിലെ n സംഭവങ്ങൾ, ഓരോന്നും a_i വർഷങ്ങളുടെ കാലക്രമത്തിൽ സംഭവിക്കുമ്പോൾ, n-ആമത്തെ സംഭവം സംഭവിക്കുന്ന വർഷം Y_n കണ്ടെത്തുക എന്നതാണ് ഈ പ്രവർത്തനം. സംഭവം i+1 ന്റെ കൗണ്ട്ഡൗൺ, സംഭവം i സംഭവിച്ച വർഷത്തിന് തൊട്ടുപിന്നാലെ മാത്രമേ തുടങ്ങുകയുള്ളു.\n\nExample usage:\nഉദാഹരണ ഉപയോഗം:\nf_32(6, {3,2,4,5,9,18}) returns 36", "fa": "با توجه به دنباله‌ای از n رویداد، که هر کدام با دوره تناوب a_i سال رخ می‌دهند، وظیفه این است که سال Y_n را پیدا کنیم که در آن n-امین رویداد رخ می‌دهد. شمارش معکوس برای رویداد i+1 تنها در سال بلافاصله پس از وقوع رویداد i شروع می‌شود.\n\nمثال استفاده:\nf_32(6, {3,2,4,5,9,18}) بازمی‌گرداند 36"}}
{"task_id": "CPP/33", "prompt": {"en": "#include <cassert>\n#include <cstdio>\n/**\n * This problem introduces a custom modulo operation, denoted by \"⊕\".\n * When calculating x ⊕ y, if x is not a multiple of y, the result is x % y.\n * If x is a multiple of y, divide x by y repeatedly until x is no longer a\n * multiple of y, denoting this final value as x'. Then the result is x' % y.\n * For example:\n * - 4⊕5=4,\n * - 20⊕5=4,\n * - 100⊕5=4.\n * Given a prime number p, you need to handle several queries where you're given\n * an integer n and you must compute n! ⊕ p. Here, n! is the factorial of n.\n * Example:\n *    f_33(3, 7) returns 6\n */\nunsigned long long f_33(unsigned long long n, unsigned long long p)", "sq": "#include <cassert>\n#include <cstdio>\n/**\n * Ky problem prezanton një operacion të personalizuar modulo, i shënuar me \"⊕\".\n * Kur llogarit x ⊕ y, nëse x nuk është shumëfish i y, rezultati është x % y.\n * Nëse x është shumëfish i y, ndaj x me y vazhdimisht derisa x të mos jetë më\n * shumëfish i y, duke e shënuar këtë vlerë përfundimtare si x'. Atëherë rezultati është x' % y.\n * Për shembull:\n * - 4⊕5=4,\n * - 20⊕5=4,\n * - 100⊕5=4.\n * Duke pasur një numër të thjeshtë p, ju duhet të trajtoni disa pyetje ku ju jepet\n * një numër i plotë n dhe duhet të llogaritni n! ⊕ p. Këtu, n! është faktoriali i n.\n * Shembull:\n *    f_33(3, 7) kthen 6\n */\nunsigned long long f_33(unsigned long long n, unsigned long long p)", "hy": "#include <cassert>\n#include <cstdio>\n/**\n * Այս խնդիրը ներկայացնում է հատուկ մնացորդային գործողություն, որը նշված է \"⊕\" նշանով:\n * Երբ հաշվարկում ենք x ⊕ y, եթե x-ը y-ի բազմապատիկ չէ, արդյունքը x % y է:\n * Եթե x-ը y-ի բազմապատիկ է, բաժանեք x-ը y-ի վրա կրկնակիորեն, մինչև x-ը այլևս\n * y-ի բազմապատիկ չլինի, և այս վերջնական արժեքը նշեք որպես x': Ապա արդյունքը x' % y է:\n * Օրինակ:\n * - 4⊕5=4,\n * - 20⊕5=4,\n * - 100⊕5=4:\n * Տրված է p պարզ թիվը, դուք պետք է մշակեք մի քանի հարցումներ, որտեղ ձեզ տրված է\n * n ամբողջ թիվը, և դուք պետք է հաշվարկեք n! ⊕ p: Այստեղ, n! նշանակում է n-ի ֆակտորիալը:\n * Օրինակ:\n *    f_33(3, 7) վերադարձնում է 6\n */\nunsigned long long f_33(unsigned long long n, unsigned long long p)", "bn": "#include <cassert>\n#include <cstdio>\n/**\n * এই সমস্যাটি একটি কাস্টম মডুলো অপারেশন পরিচয় করায়, যা \"⊕\" দ্বারা চিহ্নিত।\n * যখন x ⊕ y গণনা করা হয়, যদি x, y এর গুণিতক না হয়, তাহলে ফলাফল হয় x % y।\n * যদি x, y এর গুণিতক হয়, তাহলে x কে y দ্বারা বারবার ভাগ করুন যতক্ষণ না x আর y এর গুণিতক থাকে,\n * এই চূড়ান্ত মানটিকে x' হিসাবে চিহ্নিত করুন। তারপর ফলাফল হয় x' % y।\n * উদাহরণস্বরূপ:\n * - 4⊕5=4,\n * - 20⊕5=4,\n * - 100⊕5=4।\n * একটি মৌলিক সংখ্যা p দেওয়া হলে, আপনাকে বেশ কয়েকটি প্রশ্ন পরিচালনা করতে হবে যেখানে আপনাকে একটি পূর্ণসংখ্যা n দেওয়া হবে\n * এবং আপনাকে n! ⊕ p গণনা করতে হবে। এখানে, n! হল n এর ফ্যাক্টোরিয়াল।\n * উদাহরণ:\n *    f_33(3, 7) 6 প্রদান করে\n */\nunsigned long long f_33(unsigned long long n, unsigned long long p)", "bg": "#include <cassert>\n#include <cstdio>\n/**\n * Този проблем въвежда персонализирана операция за модуло, обозначена с \"⊕\".\n * При изчисляване на x ⊕ y, ако x не е кратно на y, резултатът е x % y.\n * Ако x е кратно на y, разделете x на y многократно, докато x вече не е\n * кратно на y, като обозначите тази крайна стойност като x'. Тогава резултатът е x' % y.\n * Например:\n * - 4⊕5=4,\n * - 20⊕5=4,\n * - 100⊕5=4.\n * Дадено е просто число p, трябва да обработите няколко заявки, където ви е дадено\n * цяло число n и трябва да изчислите n! ⊕ p. Тук n! е факториелът на n.\n * Пример:\n *    f_33(3, 7) връща 6\n */\nunsigned long long f_33(unsigned long long n, unsigned long long p)", "zh": "#include <cassert>\n#include <cstdio>\n/**\n * 这个问题引入了一个自定义的取模运算，记作“⊕”。\n * 当计算 x ⊕ y 时，如果 x 不是 y 的倍数，结果是 x % y。\n * 如果 x 是 y 的倍数，反复将 x 除以 y，直到 x 不再是 y 的倍数，将此最终值记为 x'。然后结果是 x' % y。\n * 例如：\n * - 4⊕5=4,\n * - 20⊕5=4,\n * - 100⊕5=4。\n * 给定一个质数 p，你需要处理若干查询，每个查询给定一个整数 n，你必须计算 n! ⊕ p。这里，n! 是 n 的阶乘。\n * 示例：\n *    f_33(3, 7) 返回 6\n */\nunsigned long long f_33(unsigned long long n, unsigned long long p)", "fr": "#include <cassert>\n#include <cstdio>\n/**\n * Ce problème introduit une opération modulo personnalisée, notée par \"⊕\".\n * Lors du calcul de x ⊕ y, si x n'est pas un multiple de y, le résultat est x % y.\n * Si x est un multiple de y, divisez x par y de manière répétée jusqu'à ce que x ne soit plus un\n * multiple de y, en notant cette valeur finale comme x'. Ensuite, le résultat est x' % y.\n * Par exemple :\n * - 4⊕5=4,\n * - 20⊕5=4,\n * - 100⊕5=4.\n * Étant donné un nombre premier p, vous devez traiter plusieurs requêtes où un\n * entier n est donné et vous devez calculer n! ⊕ p. Ici, n! est la factorielle de n.\n * Exemple :\n *    f_33(3, 7) retourne 6\n */\nunsigned long long f_33(unsigned long long n, unsigned long long p)", "de": "#include <cassert>\n#include <cstdio>\n/**\n * Dieses Problem führt eine benutzerdefinierte Modulo-Operation ein, die durch \"⊕\" bezeichnet wird.\n * Beim Berechnen von x ⊕ y, wenn x kein Vielfaches von y ist, ist das Ergebnis x % y.\n * Wenn x ein Vielfaches von y ist, teile x wiederholt durch y, bis x kein\n * Vielfaches von y mehr ist, und bezeichne diesen Endwert als x'. Dann ist das Ergebnis x' % y.\n * Zum Beispiel:\n * - 4⊕5=4,\n * - 20⊕5=4,\n * - 100⊕5=4.\n * Gegeben ist eine Primzahl p, Sie müssen mehrere Abfragen bearbeiten, bei denen Ihnen\n * eine ganze Zahl n gegeben ist und Sie n! ⊕ p berechnen müssen. Hierbei ist n! die Fakultät von n.\n * Beispiel:\n *    f_33(3, 7) gibt 6 zurück\n */\nunsigned long long f_33(unsigned long long n, unsigned long long p)", "ha": "#include <cassert>\n#include <cstdio>\n/**\n * Wannan matsalar tana gabatar da wani aiki na modulo na musamman, wanda aka nuna da \"⊕\".\n * Lokacin da ake lissafin x ⊕ y, idan x ba shi ne sau na y ba, sakamakon shi ne x % y.\n * Idan x sau na y ne, raba x da y akai-akai har sai x ba shi ne sau na y ba,\n * ana nuna wannan ƙimar ƙarshe a matsayin x'. Sannan sakamakon shi ne x' % y.\n * Alal misali:\n * - 4⊕5=4,\n * - 20⊕5=4,\n * - 100⊕5=4.\n * An ba da lamba mai lamba p, kuna buƙatar sarrafa tambayoyi da yawa inda aka ba ku\n * wani cikakken lamba n kuma dole ne ku lissafa n! ⊕ p. Anan, n! shine factorial na n.\n * Misali:\n *    f_33(3, 7) yana dawowa 6\n */\nunsigned long long f_33(unsigned long long n, unsigned long long p)", "hi": "#include <cassert>\n#include <cstdio>\n/**\n * यह समस्या एक कस्टम माड्यूलो ऑपरेशन को प्रस्तुत करती है, जिसे \"⊕\" द्वारा दर्शाया गया है।\n * जब x ⊕ y की गणना की जाती है, यदि x, y का गुणज नहीं है, तो परिणाम x % y होता है।\n * यदि x, y का गुणज है, तो x को y से बार-बार विभाजित करें जब तक कि x अब y का गुणज न रहे,\n * इस अंतिम मान को x' के रूप में दर्शाया जाता है। फिर परिणाम x' % y होता है।\n * उदाहरण के लिए:\n * - 4⊕5=4,\n * - 20⊕5=4,\n * - 100⊕5=4।\n * एक अभाज्य संख्या p दी गई है, आपको कई प्रश्नों को संभालना होगा जहाँ आपको एक पूर्णांक n दिया जाता है\n * और आपको n! ⊕ p की गणना करनी होगी। यहाँ, n! n का फैक्टरियल है।\n * उदाहरण:\n *    f_33(3, 7) 6 लौटाता है\n */\nunsigned long long f_33(unsigned long long n, unsigned long long p)", "hu": "#include <cassert>\n#include <cstdio>\n/**\n * Ez a probléma egy egyedi modulo műveletet vezet be, amelyet \"⊕\" jelöl.\n * Amikor x ⊕ y-t számítunk, ha x nem osztható maradék nélkül y-nal, az eredmény x % y.\n * Ha x osztható maradék nélkül y-nal, akkor osszuk el x-et y-nal ismételten, amíg x már nem\n * osztható maradék nélkül y-nal, és jelöljük ezt a végső értéket x'-vel. Ekkor az eredmény x' % y.\n * Például:\n * - 4⊕5=4,\n * - 20⊕5=4,\n * - 100⊕5=4.\n * Adott egy prímszám p, több lekérdezést kell kezelnie, ahol egy egész számot n kap, és ki kell számítania n! ⊕ p-t. Itt n! az n faktoriálisa.\n * Példa:\n *    f_33(3, 7) visszaadja 6\n */\nunsigned long long f_33(unsigned long long n, unsigned long long p)", "es": "#include <cassert>\n#include <cstdio>\n/**\n * Este problema introduce una operación de módulo personalizada, denotada por \"⊕\".\n * Al calcular x ⊕ y, si x no es un múltiplo de y, el resultado es x % y.\n * Si x es un múltiplo de y, divide x por y repetidamente hasta que x ya no sea un\n * múltiplo de y, denotando este valor final como x'. Entonces el resultado es x' % y.\n * Por ejemplo:\n * - 4⊕5=4,\n * - 20⊕5=4,\n * - 100⊕5=4.\n * Dado un número primo p, necesitas manejar varias consultas donde se te da\n * un entero n y debes calcular n! ⊕ p. Aquí, n! es el factorial de n.\n * Ejemplo:\n *    f_33(3, 7) devuelve 6\n */\nunsigned long long f_33(unsigned long long n, unsigned long long p)", "arb": "#include <cassert>\n#include <cstdio>\n/**\n * هذه المسألة تقدم عملية باقي مخصصة، يرمز لها بـ \"⊕\".\n * عند حساب x ⊕ y، إذا لم يكن x مضاعفًا لـ y، فإن النتيجة هي x % y.\n * إذا كان x مضاعفًا لـ y، قم بتقسيم x على y بشكل متكرر حتى لا يكون x\n * مضاعفًا لـ y، مشيرًا إلى هذه القيمة النهائية بـ x'. ثم تكون النتيجة x' % y.\n * على سبيل المثال:\n * - 4⊕5=4،\n * - 20⊕5=4،\n * - 100⊕5=4.\n * بالنظر إلى عدد أولي p، تحتاج إلى معالجة عدة استفسارات حيث يُعطى لك\n * عدد صحيح n ويجب عليك حساب n! ⊕ p. هنا، n! هو العامل المضاعف لـ n.\n * مثال:\n *    f_33(3, 7) يعيد 6\n */\nunsigned long long f_33(unsigned long long n, unsigned long long p)", "sw": "#include <cassert>\n#include <cstdio>\n/**\n * Shida hii inatambulisha operesheni maalum ya modulo, inayojulikana kama \"⊕\".\n * Wakati wa kuhesabu x ⊕ y, ikiwa x si kigezo cha y, matokeo ni x % y.\n * Ikiwa x ni kigezo cha y, gawanya x kwa y mara kwa mara hadi x isiwe tena\n * kigezo cha y, ukitaja thamani hii ya mwisho kama x'. Kisha matokeo ni x' % y.\n * Kwa mfano:\n * - 4⊕5=4,\n * - 20⊕5=4,\n * - 100⊕5=4.\n * Ukipewa nambari ya kwanza p, unahitaji kushughulikia maswali kadhaa ambapo unapewa\n * nambari nzima n na lazima uhisabu n! ⊕ p. Hapa, n! ni factorial ya n.\n * Mfano:\n *    f_33(3, 7) inarudisha 6\n */\nunsigned long long f_33(unsigned long long n, unsigned long long p)", "tr": "#include <cassert>\n#include <cstdio>\n/**\n * Bu problem, \"⊕\" ile gösterilen özel bir modül işlemi tanıtır.\n * x ⊕ y hesaplanırken, x y'nin katı değilse, sonuç x % y olur.\n * Eğer x y'nin katıysa, x y'nin katı olmayana kadar x'i y'ye bölün,\n * bu son değeri x' olarak belirtin. Sonuç x' % y olur.\n * Örneğin:\n * - 4⊕5=4,\n * - 20⊕5=4,\n * - 100⊕5=4.\n * Verilen bir asal sayı p ile, birkaç sorguyu ele almanız gerekiyor\n * burada size bir tamsayı n verilir ve n! ⊕ p hesaplamanız gerekir.\n * Burada n!, n'nin faktöriyelidir.\n * Örnek:\n *    f_33(3, 7) 6 döndürür\n */\nunsigned long long f_33(unsigned long long n, unsigned long long p)", "vi": "#include <cassert>\n#include <cstdio>\n/**\n * Vấn đề này giới thiệu một phép toán modulo tùy chỉnh, ký hiệu là \"⊕\".\n * Khi tính toán x ⊕ y, nếu x không phải là bội số của y, kết quả là x % y.\n * Nếu x là bội số của y, chia x cho y lặp đi lặp lại cho đến khi x không còn\n * là bội số của y, ký hiệu giá trị cuối cùng này là x'. Sau đó kết quả là x' % y.\n * Ví dụ:\n * - 4⊕5=4,\n * - 20⊕5=4,\n * - 100⊕5=4.\n * Cho một số nguyên tố p, bạn cần xử lý một số truy vấn trong đó bạn được cho\n * một số nguyên n và bạn phải tính n! ⊕ p. Ở đây, n! là giai thừa của n.\n * Ví dụ:\n *    f_33(3, 7) trả về 6\n */\nunsigned long long f_33(unsigned long long n, unsigned long long p)", "id": "#include <cassert>\n#include <cstdio>\n/**\n * Masalah ini memperkenalkan operasi modulo kustom, yang dilambangkan dengan \"⊕\".\n * Ketika menghitung x ⊕ y, jika x bukan kelipatan dari y, hasilnya adalah x % y.\n * Jika x adalah kelipatan dari y, bagi x dengan y berulang kali hingga x tidak lagi\n * menjadi kelipatan dari y, menandai nilai akhir ini sebagai x'. Kemudian hasilnya adalah x' % y.\n * Sebagai contoh:\n * - 4⊕5=4,\n * - 20⊕5=4,\n * - 100⊕5=4.\n * Diberikan bilangan prima p, Anda perlu menangani beberapa kueri di mana Anda diberikan\n * sebuah bilangan bulat n dan Anda harus menghitung n! ⊕ p. Di sini, n! adalah faktorial dari n.\n * Contoh:\n *    f_33(3, 7) mengembalikan 6\n */\nunsigned long long f_33(unsigned long long n, unsigned long long p)", "ja": "#include <cassert>\n#include <cstdio>\n/**\n * この問題では、\"⊕\"で表されるカスタムの剰余演算を紹介します。\n * x ⊕ y を計算する際、x が y の倍数でない場合、結果は x % y です。\n * x が y の倍数である場合、x を y で割り続け、x がもはや y の倍数でなくなるまで繰り返し、\n * この最終的な値を x' とします。その後、結果は x' % y です。\n * 例えば:\n * - 4⊕5=4,\n * - 20⊕5=4,\n * - 100⊕5=4.\n * 素数 p が与えられたとき、いくつかのクエリを処理する必要があります。\n * ここで、整数 n が与えられ、n! ⊕ p を計算しなければなりません。ここで、n! は n の階乗です。\n * 例:\n *    f_33(3, 7) は 6 を返します\n */\nunsigned long long f_33(unsigned long long n, unsigned long long p)", "ko": "#include <cassert>\n#include <cstdio>\n/**\n * 이 문제는 \"⊕\"로 표시되는 사용자 정의 모듈로 연산을 소개합니다.\n * x ⊕ y를 계산할 때, x가 y의 배수가 아니면 결과는 x % y입니다.\n * x가 y의 배수인 경우, x를 y로 반복적으로 나누어 x가 더 이상 y의 배수가 아닐 때까지\n * 나누며, 이 최종 값을 x'로 표시합니다. 그런 다음 결과는 x' % y입니다.\n * 예를 들어:\n * - 4⊕5=4,\n * - 20⊕5=4,\n * - 100⊕5=4.\n * 소수 p가 주어졌을 때, 여러 쿼리를 처리해야 하며, 여기서 정수 n이 주어지고\n * n! ⊕ p를 계산해야 합니다. 여기서 n!은 n의 팩토리얼입니다.\n * 예시:\n *    f_33(3, 7)은 6을 반환합니다.\n */\nunsigned long long f_33(unsigned long long n, unsigned long long p)", "ml": "#include <cassert>\n#include <cstdio>\n/**\n * ഈ പ്രശ്നം \"⊕\" എന്ന ചിഹ്നം ഉപയോഗിക്കുന്ന ഒരു കസ്റ്റം മോഡുലോ ഓപ്പറേഷൻ പരിചയപ്പെടുത്തുന്നു.\n * x ⊕ y കണക്കാക്കുമ്പോൾ, x y-യുടെ ഗുണിതമല്ലെങ്കിൽ, ഫലം x % y ആണ്.\n * x y-യുടെ ഗുണിതമാണെങ്കിൽ, x y-ൽ നിന്ന് വീണ്ടും വീണ്ടും വിഭജിക്കുക, x y-യുടെ\n * ഗുണിതമല്ലാത്തതുവരെ, ഈ അന്തിമ മൂല്യം x' എന്നുവിളിക്കുന്നു. പിന്നീട് ഫലം x' % y ആണ്.\n * ഉദാഹരണത്തിന്:\n * - 4⊕5=4,\n * - 20⊕5=4,\n * - 100⊕5=4.\n * ഒരു പ്രധാന സംഖ്യ p നൽകിയാൽ, നിങ്ങൾക്ക് പല ക്വറിയുകളും കൈകാര്യം ചെയ്യേണ്ടതുണ്ട്\n * നിങ്ങൾക്ക് ഒരു പൂർണ്ണസംഖ്യ n ലഭിക്കുമ്പോൾ, നിങ്ങൾ n! ⊕ p കണക്കാക്കണം. ഇവിടെ, n! n-ന്റെ ഫാക്ടോറിയൽ ആണ്.\n * ഉദാഹരണം:\n *    f_33(3, 7) 6 മടക്കുന്നു\n */\nunsigned long long f_33(unsigned long long n, unsigned long long p)", "fa": "#include <cassert>\n#include <cstdio>\n/**\n * این مسئله یک عملگر باقی‌مانده سفارشی را معرفی می‌کند که با \"⊕\" نشان داده می‌شود.\n * هنگام محاسبه x ⊕ y، اگر x مضربی از y نباشد، نتیجه x % y است.\n * اگر x مضربی از y باشد، x را به طور مکرر بر y تقسیم کنید تا زمانی که x دیگر\n * مضربی از y نباشد، که این مقدار نهایی را به عنوان x' نشان می‌دهیم. سپس نتیجه x' % y است.\n * برای مثال:\n * - 4⊕5=4،\n * - 20⊕5=4،\n * - 100⊕5=4.\n * با توجه به یک عدد اول p، شما باید چندین پرسش را مدیریت کنید که در آن‌ها\n * یک عدد صحیح n داده می‌شود و شما باید n! ⊕ p را محاسبه کنید. در اینجا، n! فاکتوریل n است.\n * مثال:\n *    f_33(3, 7) مقدار 6 را برمی‌گرداند\n */\nunsigned long long f_33(unsigned long long n, unsigned long long p)"}, "canonical_solution": "{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n\n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}", "instruction": {"en": "Write a CPP function `unsigned long long f_33(unsigned long long n, unsigned long long p)` to solve the following problem:\nThis problem introduces a custom modulo operation, denoted by \"⊕\".\nWhen calculating x ⊕ y, if x is not a multiple of y, the result is x % y.\nIf x is a multiple of y, divide x by y repeatedly until x is no longer a\nmultiple of y, denoting this final value as x'. Then the result is x' % y.\nFor example:\n- 4⊕5=4,\n- 20⊕5=4,\n- 100⊕5=4.\nGiven a prime number p, you need to handle several queries where you're given\nan integer n and you must compute n! ⊕ p. Here, n! is the factorial of n.\nExample:\n   f_33(3, 7) returns 6\n", "sq": "Shkruani një funksion CPP `unsigned long long f_33(unsigned long long n, unsigned long long p)` për të zgjidhur problemin në vijim:\nKy problem prezanton një operacion të personalizuar modulo, i shënuar me \"⊕\".\nKur llogaritni x ⊕ y, nëse x nuk është shumëfish i y, rezultati është x % y.\nNëse x është shumëfish i y, ndani x me y vazhdimisht derisa x të mos jetë më\nshumëfish i y, duke e shënuar këtë vlerë përfundimtare si x'. Pastaj rezultati është x' % y.\nPër shembull:\n- 4⊕5=4,\n- 20⊕5=4,\n- 100⊕5=4.\nDuke pasur një numër të plotë p, ju duhet të trajtoni disa kërkesa ku ju jepet\nnjë numër i plotë n dhe duhet të llogaritni n! ⊕ p. Këtu, n! është faktoriali i n.\nShembull:\n   f_33(3, 7) kthen 6", "hy": "Գրեք CPP ֆունկցիա `unsigned long long f_33(unsigned long long n, unsigned long long p)`՝ հետևյալ խնդիրը լուծելու համար:\nԱյս խնդիրը ներկայացնում է հատուկ մոդուլո գործողություն, որը նշվում է \"⊕\" նշանով:\nԵրբ հաշվարկվում է x ⊕ y, եթե x-ը y-ի բազմապատիկ չէ, արդյունքը x % y է:\nԵթե x-ը y-ի բազմապատիկ է, բաժանեք x-ը y-ի վրա բազմիցս, մինչև x-ը այլևս\nչլինի y-ի բազմապատիկ, և այս վերջնական արժեքը նշեք որպես x': Ապա արդյունքը x' % y է:\nՕրինակ՝\n- 4⊕5=4,\n- 20⊕5=4,\n- 100⊕5=4:\nՏրված է պարզ թիվ p, և դուք պետք է մշակեք մի քանի հարցումներ, որտեղ տրված է\nամբողջ թիվ n, և դուք պետք է հաշվարկեք n! ⊕ p: Այստեղ n! նշում է n-ի ֆակտորիալը:\nՕրինակ՝\n   f_33(3, 7) վերադարձնում է 6:", "bn": "একটি CPP ফাংশন `unsigned long long f_33(unsigned long long n, unsigned long long p)` লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\nএই সমস্যাটি একটি কাস্টম মডুলো অপারেশন পরিচয় করায়, যা \"⊕\" দ্বারা চিহ্নিত।\nযখন x ⊕ y গণনা করা হয়, যদি x y এর গুণিতক না হয়, তাহলে ফলাফল হয় x % y।\nযদি x y এর গুণিতক হয়, x কে y দ্বারা বারবার ভাগ করুন যতক্ষণ না x আর y এর গুণিতক থাকে না, এই চূড়ান্ত মানটিকে x' হিসাবে চিহ্নিত করুন। তারপর ফলাফল হয় x' % y।\nউদাহরণস্বরূপ:\n- 4⊕5=4,\n- 20⊕5=4,\n- 100⊕5=4।\nএকটি মৌলিক সংখ্যা p দেওয়া হলে, আপনাকে বেশ কয়েকটি প্রশ্ন পরিচালনা করতে হবে যেখানে আপনাকে একটি পূর্ণসংখ্যা n দেওয়া হয় এবং আপনাকে n! ⊕ p গণনা করতে হবে। এখানে, n! হল n এর ফ্যাক্টোরিয়াল।\nউদাহরণ:\n   f_33(3, 7) ফলাফল দেয় 6", "bg": "Напишете функция на C++ `unsigned long long f_33(unsigned long long n, unsigned long long p)`, за да решите следния проблем:\nТози проблем въвежда персонализирана операция за модуло, обозначена с \"⊕\".\nКогато изчислявате x ⊕ y, ако x не е кратно на y, резултатът е x % y.\nАко x е кратно на y, разделете x на y многократно, докато x вече не е\nкратно на y, като обозначите тази крайна стойност като x'. Тогава резултатът е x' % y.\nНапример:\n- 4⊕5=4,\n- 20⊕5=4,\n- 100⊕5=4.\nДадено е просто число p, трябва да обработите няколко заявки, където ви е дадено\nцяло число n и трябва да изчислите n! ⊕ p. Тук n! е факториелът на n.\nПример:\n   f_33(3, 7) връща 6", "zh": "编写一个 CPP 函数 `unsigned long long f_33(unsigned long long n, unsigned long long p)` 来解决以下问题：\n此问题引入了一个自定义模运算，记为 \"⊕\"。\n当计算 x ⊕ y 时，如果 x 不是 y 的倍数，结果是 x % y。\n如果 x 是 y 的倍数，则反复将 x 除以 y，直到 x 不再是 y 的倍数，将此最终值记为 x'。然后结果是 x' % y。\n例如：\n- 4⊕5=4,\n- 20⊕5=4,\n- 100⊕5=4。\n给定一个素数 p，你需要处理若干查询，其中给定一个整数 n，你必须计算 n! ⊕ p。这里，n! 是 n 的阶乘。\n示例：\n   f_33(3, 7) 返回 6", "fr": "Écrire une fonction CPP `unsigned long long f_33(unsigned long long n, unsigned long long p)` pour résoudre le problème suivant :\nCe problème introduit une opération modulo personnalisée, notée par \"⊕\".\nLors du calcul de x ⊕ y, si x n'est pas un multiple de y, le résultat est x % y.\nSi x est un multiple de y, divisez x par y de manière répétée jusqu'à ce que x ne soit plus un multiple de y, en notant cette valeur finale comme x'. Ensuite, le résultat est x' % y.\nPar exemple :\n- 4⊕5=4,\n- 20⊕5=4,\n- 100⊕5=4.\nÉtant donné un nombre premier p, vous devez traiter plusieurs requêtes où un entier n vous est donné et vous devez calculer n! ⊕ p. Ici, n! est la factorielle de n.\nExemple :\n   f_33(3, 7) retourne 6", "de": "Schreiben Sie eine CPP-Funktion `unsigned long long f_33(unsigned long long n, unsigned long long p)`, um das folgende Problem zu lösen:\nDieses Problem führt eine benutzerdefinierte Modulo-Operation ein, bezeichnet durch \"⊕\".\nBeim Berechnen von x ⊕ y, wenn x kein Vielfaches von y ist, ist das Ergebnis x % y.\nWenn x ein Vielfaches von y ist, teilen Sie x wiederholt durch y, bis x kein Vielfaches von y mehr ist, und bezeichnen Sie diesen Endwert als x'. Dann ist das Ergebnis x' % y.\nZum Beispiel:\n- 4⊕5=4,\n- 20⊕5=4,\n- 100⊕5=4.\nGegeben eine Primzahl p, müssen Sie mehrere Anfragen bearbeiten, bei denen Ihnen eine ganze Zahl n gegeben wird und Sie n! ⊕ p berechnen müssen. Hierbei ist n! die Fakultät von n.\nBeispiel:\n   f_33(3, 7) gibt 6 zurück", "ha": "Rubuta aikin CPP `unsigned long long f_33(unsigned long long n, unsigned long long p)` don warware matsalar mai zuwa:\nWannan matsalar tana gabatar da wani aiki na modulo na musamman, wanda aka nuna da \"⊕\".\nLokacin da ake lissafin x ⊕ y, idan x ba ya rabo da y, sakamakon shi ne x % y.\nIdan x ya rabo da y, raba x da y akai-akai har sai x ba ya rabo da y,\nsannan a nuna wannan ƙimar ƙarshe a matsayin x'. Sannan sakamakon shi ne x' % y.\nMisali:\n- 4⊕5=4,\n- 20⊕5=4,\n- 100⊕5=4.\nAn ba da lambar farko p, kuna buƙatar magance tambayoyi da yawa inda aka ba ku\nwani adadi n kuma dole ne ku lissafa n! ⊕ p. Anan, n! shine factorial na n.\nMisali:\n   f_33(3, 7) yana dawowa 6", "hi": "एक CPP फ़ंक्शन `unsigned long long f_33(unsigned long long n, unsigned long long p)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nयह समस्या एक कस्टम मॉड्यूलो ऑपरेशन को प्रस्तुत करती है, जिसे \"⊕\" द्वारा दर्शाया गया है।\nजब x ⊕ y की गणना की जाती है, अगर x y का गुणज नहीं है, तो परिणाम x % y होता है।\nयदि x y का गुणज है, तो x को y द्वारा बार-बार विभाजित करें जब तक कि x अब y का गुणज न रहे, इस अंतिम मान को x' के रूप में दर्शाया जाता है। फिर परिणाम x' % y होता है।\nउदाहरण के लिए:\n- 4⊕5=4,\n- 20⊕5=4,\n- 100⊕5=4।\nएक अभाज्य संख्या p दी गई है, आपको कई क्वेरीज़ को संभालना है जहाँ आपको एक पूर्णांक n दिया जाता है और आपको n! ⊕ p की गणना करनी होती है। यहाँ, n! n का फैक्टोरियल है।\nउदाहरण:\n   f_33(3, 7) 6 लौटाता है", "hu": "Írj egy CPP függvényt `unsigned long long f_33(unsigned long long n, unsigned long long p)` a következő probléma megoldására:\nEz a probléma egy egyedi modulo műveletet vezet be, amelyet \"⊕\" jelöl.\nAmikor x ⊕ y-t számítunk, ha x nem osztható y-nal, az eredmény x % y.\nHa x osztható y-nal, oszd el x-et y-nal ismételten, amíg x már nem osztható\ny-nal, ezt a végső értéket jelölve x'-ként. Ekkor az eredmény x' % y.\nPéldául:\n- 4⊕5=4,\n- 20⊕5=4,\n- 100⊕5=4.\nAdott egy prímszám p, több lekérdezést kell kezelni, ahol egy\negész számot n kapsz, és ki kell számítanod n! ⊕ p-t. Itt n! az n faktoriálisa.\nPélda:\n   f_33(3, 7) visszaadja 6", "es": "Escribe una función CPP `unsigned long long f_33(unsigned long long n, unsigned long long p)` para resolver el siguiente problema:\nEste problema introduce una operación de módulo personalizada, denotada por \"⊕\".\nAl calcular x ⊕ y, si x no es un múltiplo de y, el resultado es x % y.\nSi x es un múltiplo de y, divide x por y repetidamente hasta que x ya no sea un múltiplo de y, denotando este valor final como x'. Entonces el resultado es x' % y.\nPor ejemplo:\n- 4⊕5=4,\n- 20⊕5=4,\n- 100⊕5=4.\nDado un número primo p, necesitas manejar varias consultas donde se te da un entero n y debes calcular n! ⊕ p. Aquí, n! es el factorial de n.\nEjemplo:\n   f_33(3, 7) devuelve 6", "arb": "اكتب دالة CPP `unsigned long long f_33(unsigned long long n, unsigned long long p)` لحل المشكلة التالية:\nتقدم هذه المشكلة عملية باقي مخصصة، يرمز لها بـ \"⊕\".\nعند حساب x ⊕ y، إذا لم يكن x مضاعفًا لـ y، فإن النتيجة هي x % y.\nإذا كان x مضاعفًا لـ y، قم بقسمة x على y بشكل متكرر حتى لا يكون x مضاعفًا لـ y، مشيرًا إلى هذه القيمة النهائية بـ x'. ثم تكون النتيجة x' % y.\nعلى سبيل المثال:\n- 4⊕5=4،\n- 20⊕5=4،\n- 100⊕5=4.\nبالنظر إلى عدد أولي p، تحتاج إلى معالجة عدة استفسارات حيث يُعطى لك عدد صحيح n ويجب عليك حساب n! ⊕ p. هنا، n! هو مضروب n.\nمثال:\n   f_33(3, 7) returns 6", "sw": "Andika kazi ya CPP `unsigned long long f_33(unsigned long long n, unsigned long long p)` kutatua tatizo lifuatalo:\nTatizo hili linaanzisha operesheni ya modulo maalum, inayojulikana kama \"⊕\".\nWakati wa kuhesabu x ⊕ y, ikiwa x si kigezo cha y, matokeo ni x % y.\nIkiwa x ni kigezo cha y, gawanya x kwa y mara kwa mara hadi x isiwe tena\nkigezo cha y, ukionyesha thamani hii ya mwisho kama x'. Kisha matokeo ni x' % y.\nKwa mfano:\n- 4⊕5=4,\n- 20⊕5=4,\n- 100⊕5=4.\nUkipiwa nambari ya msingi p, unahitaji kushughulikia maswali kadhaa ambapo unapewa\nnambari nzima n na lazima uhakiki n! ⊕ p. Hapa, n! ni factorial ya n.\nMfano:\n   f_33(3, 7) inarudisha 6", "tr": "Bir CPP fonksiyonu `unsigned long long f_33(unsigned long long n, unsigned long long p)` yazın ve aşağıdaki problemi çözün:\nBu problem, \"⊕\" ile gösterilen özel bir modül işlemi tanıtır.\nx ⊕ y hesaplanırken, eğer x, y'nin katı değilse, sonuç x % y'dir.\nEğer x, y'nin katı ise, x artık y'nin katı olmayana kadar x'i tekrar tekrar y'ye bölün, bu son değeri x' olarak belirtin. Sonuç x' % y'dir.\nÖrneğin:\n- 4⊕5=4,\n- 20⊕5=4,\n- 100⊕5=4.\nVerilen bir asal sayı p ile, size bir tamsayı n verildiğinde n! ⊕ p hesaplamanız gereken birkaç sorguyu ele almanız gerekir. Burada, n! n'nin faktöriyelidir.\nÖrnek:\n   f_33(3, 7) 6 döndürür.", "vi": "Viết một hàm CPP `unsigned long long f_33(unsigned long long n, unsigned long long p)` để giải quyết vấn đề sau:\nVấn đề này giới thiệu một phép toán modulo tùy chỉnh, được ký hiệu là \"⊕\".\nKhi tính toán x ⊕ y, nếu x không phải là bội số của y, kết quả là x % y.\nNếu x là bội số của y, chia x cho y liên tục cho đến khi x không còn là\nbội số của y, ký hiệu giá trị cuối cùng này là x'. Sau đó kết quả là x' % y.\nVí dụ:\n- 4⊕5=4,\n- 20⊕5=4,\n- 100⊕5=4.\nCho trước một số nguyên tố p, bạn cần xử lý nhiều truy vấn trong đó bạn được cho\nmột số nguyên n và bạn phải tính n! ⊕ p. Ở đây, n! là giai thừa của n.\nVí dụ:\n   f_33(3, 7) trả về 6", "id": "Tulis fungsi CPP `unsigned long long f_33(unsigned long long n, unsigned long long p)` untuk menyelesaikan masalah berikut:\nMasalah ini memperkenalkan operasi modulo khusus, yang dilambangkan dengan \"⊕\".\nSaat menghitung x ⊕ y, jika x bukan kelipatan dari y, hasilnya adalah x % y.\nJika x adalah kelipatan dari y, bagi x dengan y berulang kali sampai x tidak lagi menjadi kelipatan dari y, menandai nilai akhir ini sebagai x'. Kemudian hasilnya adalah x' % y.\nSebagai contoh:\n- 4⊕5=4,\n- 20⊕5=4,\n- 100⊕5=4.\nDiberikan sebuah bilangan prima p, Anda perlu menangani beberapa kueri di mana Anda diberikan sebuah bilangan bulat n dan Anda harus menghitung n! ⊕ p. Di sini, n! adalah faktorial dari n.\nContoh:\n   f_33(3, 7) mengembalikan 6", "ja": "CPP関数 `unsigned long long f_33(unsigned long long n, unsigned long long p)` を作成して、次の問題を解決してください:\nこの問題では、「⊕」で表されるカスタムの剰余演算を導入します。\nx ⊕ y を計算するとき、x が y の倍数でない場合、結果は x % y です。\nx が y の倍数である場合、x を y で割り続け、x がもはや y の倍数でなくなるまで繰り返し、この最終的な値を x' とします。次に、結果は x' % y です。\n例えば:\n- 4⊕5=4,\n- 20⊕5=4,\n- 100⊕5=4.\n素数 p が与えられたとき、いくつかのクエリを処理する必要があります。ここで、整数 n が与えられ、n! ⊕ p を計算しなければなりません。ここで、n! は n の階乗です。\n例:\n   f_33(3, 7) は 6 を返します。", "ko": "CPP 함수 `unsigned long long f_33(unsigned long long n, unsigned long long p)`를 작성하여 다음 문제를 해결하십시오:  \n이 문제는 \"⊕\"로 표시되는 사용자 정의 모듈로 연산을 도입합니다.  \nx ⊕ y를 계산할 때, x가 y의 배수가 아니면 결과는 x % y입니다.  \nx가 y의 배수인 경우, x가 더 이상 y의 배수가 아닐 때까지 x를 y로 반복해서 나누고, 이 최종 값을 x'로 표시합니다. 그런 다음 결과는 x' % y입니다.  \n예를 들어:  \n- 4⊕5=4,  \n- 20⊕5=4,  \n- 100⊕5=4.  \n소수 p가 주어지면, 여러 쿼리를 처리해야 하며, 여기서 정수 n이 주어지고 n! ⊕ p를 계산해야 합니다. 여기서 n!은 n의 팩토리얼입니다.  \n예시:  \n   f_33(3, 7)은 6을 반환합니다.  ", "ml": "ഒരു സിപിപി ഫംഗ്ഷൻ എഴുതുക `unsigned long long f_33(unsigned long long n, unsigned long long p)` ഈ പ്രശ്നം പരിഹരിക്കാൻ:\nഈ പ്രശ്നം ഒരു കസ്റ്റം മോഡുലോ ഓപ്പറേഷൻ അവതരിപ്പിക്കുന്നു, \"⊕\" എന്നതാൽ സൂചിപ്പിക്കുന്നു.\nx ⊕ y കണക്കാക്കുമ്പോൾ, x y-യുടെ ഗുണിതമല്ലെങ്കിൽ, ഫലമായി x % y ആണ്.\nx y-യുടെ ഗുണിതമാണെങ്കിൽ, x y-ൽ നിന്ന് വീണ്ടും വീണ്ടും വിഭജിക്കുക x y-യുടെ ഗുണിതമല്ലാത്തതുവരെ, ഈ അന്തിമ മൂല്യം x' എന്നതാൽ സൂചിപ്പിക്കുന്നു. പിന്നീടുള്ള ഫലം x' % y ആണ്.\nഉദാഹരണത്തിന്:\n- 4⊕5=4,\n- 20⊕5=4,\n- 100⊕5=4.\nഒരു പ്രധാന സംഖ്യ p നൽകിയാൽ, നിങ്ങൾക്ക് നിരവധി ക്വറിയുകൾ കൈകാര്യം ചെയ്യേണ്ടതുണ്ട്, ഇവിടെ നിങ്ങൾക്ക് ഒരു പൂർണ്ണസംഖ്യ n ലഭിക്കും, നിങ്ങൾ n! ⊕ p കണക്കാക്കണം. ഇവിടെ, n! n-ന്റെ ഫാക്ടോറിയൽ ആണ്.\nഉദാഹരണം:\n   f_33(3, 7) 6 മടക്കുന്നു", "fa": "یک تابع CPP به نام `unsigned long long f_33(unsigned long long n, unsigned long long p)` بنویسید تا مسئله زیر را حل کند:\nاین مسئله یک عملگر باقیمانده سفارشی معرفی می‌کند که با \"⊕\" نشان داده می‌شود.\nهنگام محاسبه x ⊕ y، اگر x مضربی از y نباشد، نتیجه x % y است.\nاگر x مضربی از y باشد، x را به طور مکرر بر y تقسیم کنید تا زمانی که x دیگر مضربی از y نباشد، این مقدار نهایی را به عنوان x' نشان می‌دهیم. سپس نتیجه x' % y است.\nبرای مثال:\n- 4⊕5=4،\n- 20⊕5=4،\n- 100⊕5=4.\nبا توجه به یک عدد اول p، شما باید چندین پرس و جو را مدیریت کنید که در آن یک عدد صحیح n داده می‌شود و شما باید n! ⊕ p را محاسبه کنید. در اینجا، n! فاکتوریل n است.\nمثال:\n   f_33(3, 7) مقدار 6 را برمی‌گرداند."}, "level": "easy", "test": "int main() {\n    // Test cases\n    assert(f_33(3, 7) == 6);\n    assert(f_33(10, 3) == 1);\n    assert(f_33(11, 7) == 4);\n    assert(f_33(45, 7) == 1);\n    assert(f_33(14, 7) == 2);\n    assert(f_33(1919, 10007) == 3152);\n    assert(f_33(810, 10007) == 3679);\n    assert(f_33(3, 7) == 6);\n    assert(f_33(10, 3) == 1);\n    assert(f_33(1, 2) == 1);\n    assert(f_33(5, 11) == 10);\n    assert(f_33(6, 13) == 5);\n    assert(f_33(8, 17) == 13);\n    assert(f_33(15, 19) == 16);\n    assert(f_33(21, 23) == 1);\n    assert(f_33(30, 29) == 28);\n    assert(f_33(100, 101) == 100);\n    return 0;\n}", "entry_point": "f_33", "signature": "unsigned long long f_33(unsigned long long n, unsigned long long p)", "docstring": {"en": "This problem introduces a custom modulo operation, denoted by \"⊕\".\nWhen calculating x ⊕ y, if x is not a multiple of y, the result is x % y.\nIf x is a multiple of y, divide x by y repeatedly until x is no longer a\nmultiple of y, denoting this final value as x'. Then the result is x' % y.\nFor example:\n- 4⊕5=4,\n- 20⊕5=4,\n- 100⊕5=4.\nGiven a prime number p, you need to handle several queries where you're given\nan integer n and you must compute n! ⊕ p. Here, n! is the factorial of n.\nExample:\n   f_33(3, 7) returns 6\n", "sq": "Ky problem prezanton një operacion të personalizuar modulo, i shënuar me \"⊕\".  \nKur llogaritni x ⊕ y, nëse x nuk është shumëfish i y, rezultati është x % y.  \nNëse x është një shumëfish i y, ndani x me y në mënyrë të përsëritur derisa x të mos jetë më një shumëfish i y, duke e shënuar këtë vlerë përfundimtare si x'. Pastaj rezultati është x' % y.  \nPër shembull:  \n- 4⊕5=4,  \n- 20⊕5=4,  \n- 100⊕5=4.  \nDuke pasur një numër të thjeshtë p, ju duhet të trajtoni disa pyetje ku ju jepet një numër i plotë n dhe ju duhet të llogaritni n! ⊕ p. Këtu, n! është faktoriali i n.  \nShembull:  \n   f_33(3, 7) kthen 6  ", "hy": "Այս խնդիրն առաջարկում է հատուկ մնացորդային գործողություն, որը նշվում է \"⊕\" նշանով։  \nԵրբ հաշվարկում ենք x ⊕ y, եթե x-ը y-ի բազմապատիկ չէ, արդյունքը x % y է։  \nԵթե x-ը y-ի բազմապատիկ է, բաժանեք x-ը y-ի վրա կրկնակիորեն, մինչև x-ը այլևս y-ի բազմապատիկ չլինի, և այս վերջնական արժեքը նշեք որպես x'։ Այնուհետև արդյունքը x' % y է։  \nՕրինակ՝  \n- 4⊕5=4,  \n- 20⊕5=4,  \n- 100⊕5=4։  \nՏրված է p պարզ թիվը, դուք պետք է մշակեք մի քանի հարցումներ, որտեղ ձեզ տրված է n ամբողջ թիվը, և դուք պետք է հաշվարկեք n! ⊕ p։ Այստեղ, n! նշանակում է n-ի ֆակտորիալը։  \nՕրինակ՝  \n   f_33(3, 7) վերադարձնում է 6  ", "bn": "এই সমস্যাটি একটি কাস্টম মডুলো অপারেশন পরিচয় করিয়ে দেয়, যা \"⊕\" দ্বারা চিহ্নিত। \nযখন x ⊕ y গণনা করা হয়, যদি x y এর গুণিতক না হয়, তাহলে ফলাফল হয় x % y। \nযদি x y এর গুণিতক হয়, তাহলে x কে y দ্বারা বারবার ভাগ করুন যতক্ষণ না x আর y এর গুণিতক থাকে না, এই চূড়ান্ত মানটিকে x' দ্বারা চিহ্নিত করুন। তারপর ফলাফল হয় x' % y। \nউদাহরণস্বরূপ:\n- 4⊕5=4,\n- 20⊕5=4,\n- 100⊕5=4।\nএকটি মৌলিক সংখ্যা p দেওয়া হলে, আপনাকে বেশ কয়েকটি প্রশ্ন পরিচালনা করতে হবে যেখানে আপনাকে একটি পূর্ণসংখ্যা n দেওয়া হয় এবং আপনাকে n! ⊕ p গণনা করতে হবে। এখানে, n! হল n এর ফ্যাক্টোরিয়াল।\nউদাহরণ:\n   f_33(3, 7) 6 প্রদান করে।", "bg": "Този проблем въвежда персонализирана операция модуло, обозначена с \"⊕\".  \nКогато се изчислява x ⊕ y, ако x не е кратно на y, резултатът е x % y.  \nАко x е кратно на y, разделете x на y многократно, докато x вече не е  \nкратно на y, като обозначите тази крайна стойност като x'. Тогава резултатът е x' % y.  \nНапример:  \n- 4⊕5=4,  \n- 20⊕5=4,  \n- 100⊕5=4.  \nДадено е просто число p, трябва да обработите няколко заявки, при които ви е дадено  \nцяло число n и трябва да изчислите n! ⊕ p. Тук n! е факториелът на n.  \nПример:  \n   f_33(3, 7) връща 6  ", "zh": "这个问题介绍了一种自定义的模运算，用“⊕”表示。  \n在计算 x ⊕ y 时，如果 x 不是 y 的倍数，结果是 x % y。  \n如果 x 是 y 的倍数，则反复将 x 除以 y，直到 x 不再是 y 的倍数，将此最终值记为 x'。然后结果是 x' % y。  \n例如：  \n- 4⊕5=4，  \n- 20⊕5=4，  \n- 100⊕5=4。  \n给定一个质数 p，你需要处理几个查询，每个查询给定一个整数 n，你必须计算 n! ⊕ p。这里，n! 是 n 的阶乘。  \n例子：  \n   f_33(3, 7) 返回 6  ", "fr": "Ce problème introduit une opération modulo personnalisée, notée par \"⊕\".\nLors du calcul de x ⊕ y, si x n'est pas un multiple de y, le résultat est x % y.\nSi x est un multiple de y, divisez x par y de manière répétée jusqu'à ce que x ne soit plus un multiple de y, en notant cette valeur finale comme x'. Ensuite, le résultat est x' % y.\nPar exemple :\n- 4⊕5=4,\n- 20⊕5=4,\n- 100⊕5=4.\nÉtant donné un nombre premier p, vous devez traiter plusieurs requêtes où un entier n vous est donné et vous devez calculer n! ⊕ p. Ici, n! est la factorielle de n.\nExemple :\n   f_33(3, 7) retourne 6", "de": "Dieses Problem führt eine benutzerdefinierte Modulo-Operation ein, bezeichnet durch \"⊕\".  \nBei der Berechnung von x ⊕ y, wenn x kein Vielfaches von y ist, ist das Ergebnis x % y.  \nWenn x ein Vielfaches von y ist, teilen Sie x wiederholt durch y, bis x kein Vielfaches von y mehr ist, und bezeichnen Sie diesen Endwert als x'. Dann ist das Ergebnis x' % y.  \nZum Beispiel:  \n- 4⊕5=4,  \n- 20⊕5=4,  \n- 100⊕5=4.  \nGegeben eine Primzahl p, müssen Sie mehrere Anfragen bearbeiten, bei denen Ihnen eine ganze Zahl n gegeben wird und Sie n! ⊕ p berechnen müssen. Hierbei ist n! die Fakultät von n.  \nBeispiel:  \n   f_33(3, 7) gibt 6 zurück  ", "ha": "Wannan matsala tana gabatar da wani aiki na modulo na musamman, wanda aka nuna da \"⊕\".  \nLokacin da ake lissafin x ⊕ y, idan x ba ya rabo da y, sakamakon shi ne x % y.  \nIdan x yana rabo da y, raba x da y akai-akai har sai x ya daina zama rabo da y, ana nuna wannan ƙimar ƙarshe a matsayin x'. Sannan sakamakon shi ne x' % y.  \nMisali:  \n- 4⊕5=4,  \n- 20⊕5=4,  \n- 100⊕5=4.  \nAn ba da lambar farko p, kuna buƙatar sarrafa tambayoyi da yawa inda aka ba ku  \nwani cikakken lamba n kuma dole ne ku lissafa n! ⊕ p. Anan, n! shine factorial na n.  \nMisali:  \n   f_33(3, 7) yana dawowa 6  ", "hi": "यह समस्या एक कस्टम मोड्यूलो ऑपरेशन का परिचय देती है, जिसे \"⊕\" द्वारा निरूपित किया गया है।  \nजब x ⊕ y की गणना की जाती है, यदि x, y का गुणज नहीं है, तो परिणाम x % y होता है।  \nयदि x, y का गुणज है, तो x को y द्वारा बार-बार विभाजित करें जब तक कि x अब y का गुणज न रहे, इस अंतिम मान को x' के रूप में निरूपित करें। फिर परिणाम x' % y होता है।  \nउदाहरण के लिए:  \n- 4⊕5=4,  \n- 20⊕5=4,  \n- 100⊕5=4।  \nदिए गए एक अभाज्य संख्या p के लिए, आपको कई क्वेरीज़ को संभालना है जहाँ आपको एक पूर्णांक n दिया जाता है और आपको n! ⊕ p की गणना करनी होती है। यहाँ, n! n का फैक्टोरियल है।  \nउदाहरण:  \n   f_33(3, 7) 6 लौटाता है।  ", "hu": "Ez a probléma egy egyedi modulo műveletet vezet be, amelyet \"⊕\" jelöl.  \nAmikor az x ⊕ y értéket számítjuk, ha x nem osztható y-nal, az eredmény x % y.  \nHa x osztható y-nal, osszuk el x-et y-nal ismételten, amíg x már nem osztható y-nal, ezt a végső értéket jelöljük x'-ként. Ezután az eredmény x' % y.  \nPéldául:  \n- 4⊕5=4,  \n- 20⊕5=4,  \n- 100⊕5=4.  \nAdott egy prímszám p, több lekérdezést kell kezelnie, ahol egy n egész számot kap, és ki kell számítania n! ⊕ p értékét. Itt n! az n faktoriálisa.  \nPélda:  \n   f_33(3, 7) visszaadja 6", "es": "Este problema introduce una operación de módulo personalizada, denotada por \"⊕\".\nAl calcular x ⊕ y, si x no es un múltiplo de y, el resultado es x % y.\nSi x es un múltiplo de y, divide x por y repetidamente hasta que x ya no sea un\nmúltiplo de y, denotando este valor final como x'. Entonces el resultado es x' % y.\nPor ejemplo:\n- 4⊕5=4,\n- 20⊕5=4,\n- 100⊕5=4.\nDado un número primo p, necesitas manejar varias consultas donde se te da\nun número entero n y debes calcular n! ⊕ p. Aquí, n! es el factorial de n.\nEjemplo:\n   f_33(3, 7) devuelve 6", "arb": "هذه المشكلة تقدم عملية باقي مخصصة، يرمز لها بـ \"⊕\".  \nعند حساب x ⊕ y، إذا لم يكن x مضاعفًا لـ y، فإن النتيجة هي x % y.  \nإذا كان x مضاعفًا لـ y، قسم x على y بشكل متكرر حتى لا يكون x مضاعفًا لـ y، مشيرًا إلى هذه القيمة النهائية بـ x'. ثم تكون النتيجة هي x' % y.  \nعلى سبيل المثال:  \n- 4⊕5=4،  \n- 20⊕5=4،  \n- 100⊕5=4.  \nمعطى عدد أولي p، تحتاج إلى معالجة عدة استفسارات حيث يُعطى لك عدد صحيح n ويجب عليك حساب n! ⊕ p. هنا، n! هو مضروب n.  \nمثال:  \n   f_33(3, 7) returns 6  ", "sw": "Tatizo hili linaanzisha operesheni maalum ya modulo, inayojulikana kama \"⊕\". Wakati wa kuhesabu x ⊕ y, ikiwa x si kigezo cha y, matokeo ni x % y. Ikiwa x ni kigezo cha y, gawanya x kwa y mara kwa mara hadi x isiwe tena kigezo cha y, ukionyesha thamani hii ya mwisho kama x'. Kisha matokeo ni x' % y. Kwa mfano:\n- 4⊕5=4,\n- 20⊕5=4,\n- 100⊕5=4.\nUkipiwa nambari ya kwanza p, unahitaji kushughulikia maswali kadhaa ambapo unapewa nambari n na lazima uhakiki n! ⊕ p. Hapa, n! ni factorial ya n.\nMfano:\n   f_33(3, 7) inarudisha 6", "tr": "Bu problem, \"⊕\" ile gösterilen özel bir modül işlemi tanıtmaktadır. \nx ⊕ y hesaplanırken, eğer x, y'nin katı değilse, sonuç x % y'dir. \nEğer x, y'nin katı ise, x artık y'nin katı olmayana kadar x'i y ile tekrar tekrar bölün, bu son değeri x' olarak belirtin. Sonuç, x' % y'dir. \nÖrneğin:\n- 4⊕5=4,\n- 20⊕5=4,\n- 100⊕5=4.\nVerilen bir asal sayı p için, size bir tamsayı n verilen birkaç sorguyu ele almanız gerekmektedir ve n! ⊕ p hesaplamalısınız. Burada, n! n faktöriyelidir.\nÖrnek:\n   f_33(3, 7) 6 döndürür.", "vi": "Vấn đề này giới thiệu một phép toán modulo tùy chỉnh, được ký hiệu bằng \"⊕\".  \nKhi tính toán x ⊕ y, nếu x không phải là bội số của y, kết quả là x % y.  \nNếu x là bội số của y, chia x cho y liên tục cho đến khi x không còn là bội số của y, ký hiệu giá trị cuối cùng này là x'. Sau đó kết quả là x' % y.  \nVí dụ:  \n- 4⊕5=4,  \n- 20⊕5=4,  \n- 100⊕5=4.  \nCho một số nguyên tố p, bạn cần xử lý một số truy vấn mà bạn được cho một số nguyên n và bạn phải tính n! ⊕ p. Ở đây, n! là giai thừa của n.  \nVí dụ:  \n   f_33(3, 7) trả về 6  ", "id": "Masalah ini memperkenalkan operasi modulo khusus, yang dilambangkan dengan \"⊕\".  \nSaat menghitung x ⊕ y, jika x bukan kelipatan dari y, hasilnya adalah x % y.  \nJika x adalah kelipatan dari y, bagi x dengan y berulang kali hingga x tidak lagi menjadi kelipatan dari y, menandai nilai akhir ini sebagai x'. Kemudian hasilnya adalah x' % y.  \nSebagai contoh:  \n- 4⊕5=4,  \n- 20⊕5=4,  \n- 100⊕5=4.  \nDiberikan bilangan prima p, Anda perlu menangani beberapa kueri di mana Anda diberikan bilangan bulat n dan Anda harus menghitung n! ⊕ p. Di sini, n! adalah faktorial dari n.  \nContoh:  \n   f_33(3, 7) mengembalikan 6  ", "ja": "この問題では、「⊕」で表されるカスタムの剰余演算を紹介します。  \nx ⊕ y を計算する際、x が y の倍数でない場合、結果は x % y です。  \nx が y の倍数である場合、x を y で割り続け、x がもはや y の倍数でない状態になるまで続け、この最終的な値を x' とします。その後、結果は x' % y です。  \n例えば：  \n- 4⊕5=4、  \n- 20⊕5=4、  \n- 100⊕5=4。  \n素数 p が与えられたとき、いくつかのクエリを処理する必要があります。ここで整数 n が与えられ、n! ⊕ p を計算しなければなりません。ここで、n! は n の階乗です。  \n例：  \n   f_33(3, 7) は 6 を返します。", "ko": "이 문제는 \"⊕\"로 표시되는 사용자 정의 모듈로 연산을 소개합니다.\nx ⊕ y를 계산할 때, x가 y의 배수가 아니면 결과는 x % y입니다.\nx가 y의 배수이면, x가 더 이상 y의 배수가 아닐 때까지 x를 y로 반복해서 나누고, 이 최종 값을 x'로 표시합니다. 그런 다음 결과는 x' % y입니다.\n예를 들어:\n- 4⊕5=4,\n- 20⊕5=4,\n- 100⊕5=4.\n소수 p가 주어지면, 여러 쿼리를 처리해야 하며, 여기서 정수 n이 주어지고 n! ⊕ p를 계산해야 합니다. 여기서 n!은 n의 팩토리얼입니다.\n예:\n   f_33(3, 7) returns 6", "ml": "ഈ പ്രശ്നം \"⊕\" എന്ന ചിഹ്നം ഉപയോഗിച്ച് ഒരു കസ്റ്റം മോഡുലോ ഓപ്പറേഷൻ പരിചയപ്പെടുത്തുന്നു. \nx ⊕ y കണക്കാക്കുമ്പോൾ, x y-യുടെ ഗുണിതമല്ലെങ്കിൽ, ഫലം x % y ആണ്. \nx y-യുടെ ഗുണിതമാണെങ്കിൽ, x y-ൽ നിന്ന് വീണ്ടും വീണ്ടും വിഭജിച്ച് x y-യുടെ ഗുണിതമല്ലാത്തവരെ വരെ x-നെ വിഭജിക്കുക, ഈ അന്തിമ മൂല്യം x' ആയി രേഖപ്പെടുത്തുക. ശേഷം ഫലം x' % y ആണ്. \nഉദാഹരണത്തിന്: \n- 4⊕5=4, \n- 20⊕5=4, \n- 100⊕5=4. \nഒരു പ്രധാന സംഖ്യ p നൽകിയാൽ, നിങ്ങൾക്ക് n എന്ന ഒരു പൂർണ്ണസംഖ്യ നൽകുന്ന നിരവധി ചോദ്യങ്ങൾ കൈകാര്യം ചെയ്യേണ്ടതുണ്ട്, നിങ്ങൾ n! ⊕ p കണക്കാക്കണം. ഇവിടെ, n! n-ന്റെ ഫാക്ടോറിയൽ ആണ്. \nഉദാഹരണം: \n   f_33(3, 7) 6 തിരിച്ചുനൽകുന്നു", "fa": "این مسئله یک عملیات باقی‌مانده سفارشی معرفی می‌کند که با \"⊕\" نشان داده می‌شود.  \nهنگام محاسبه x ⊕ y، اگر x مضربی از y نباشد، نتیجه x % y است.  \nاگر x مضربی از y باشد، x را به طور مکرر بر y تقسیم کنید تا زمانی که x دیگر مضربی از y نباشد، این مقدار نهایی را به عنوان x' نشان می‌دهیم. سپس نتیجه x' % y است.  \nبرای مثال:  \n- 4⊕5=4،  \n- 20⊕5=4،  \n- 100⊕5=4.  \nبا توجه به یک عدد اول p، شما باید چندین پرسش را مدیریت کنید که در آن یک عدد صحیح n داده می‌شود و شما باید n! ⊕ p را محاسبه کنید. در اینجا، n! فاکتوریل n است.  \nمثال:  \n   f_33(3, 7) returns 6  "}}
{"task_id": "CPP/34", "prompt": {"en": "#include <cstdio>\n#include <cassert>\n/**\n * You are given an array a of n integers. You can perform at most one operation where you\n * select three integers i, j, x (1 <= i <= j <= n) and replace all elements from a[i] to a[j] with x,\n * at a cost of (j - i + 1). Find the minimum cost to make all elements in the array equal.\n *\n * Examples:\n *    >>> f_34(3, (int[]){1, 2, 1})\n *    1\n *    >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n *    1\n */\nint f_34(int n, int a[])", "sq": "#include <cstdio>\n#include <cassert>\n/**\n * Ju jepet një varg a me n numra të plotë. Ju mund të kryeni maksimumi një operacion ku\n * zgjidhni tre numra të plotë i, j, x (1 <= i <= j <= n) dhe zëvendësoni të gjitha elementet nga a[i] deri te a[j] me x,\n * me një kosto prej (j - i + 1). Gjeni koston minimale për të bërë të gjitha elementet në varg të barabarta.\n *\n * Shembuj:\n *    >>> f_34(3, (int[]){1, 2, 1})\n *    1\n *    >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n *    1\n */\nint f_34(int n, int a[])", "hy": "#include <cstdio>\n#include <cassert>\n/**\n * Ձեզ տրված է n ամբողջ թվերի զանգված a։ Դուք կարող եք կատարել առավելագույնը մեկ գործողություն, որտեղ\n * ընտրում եք երեք ամբողջ թվեր i, j, x (1 <= i <= j <= n) և փոխարինում եք a[i]-ից a[j] բոլոր տարրերը x-ով,\n * արժեքով (j - i + 1)։ Գտեք նվազագույն արժեքը, որպեսզի զանգվածի բոլոր տարրերը հավասար լինեն։\n *\n * Օրինակներ:\n *    >>> f_34(3, (int[]){1, 2, 1})\n *    1\n *    >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n *    1\n */\nint f_34(int n, int a[])", "bn": "#include <cstdio>\n#include <cassert>\n/**\n * আপনাকে n পূর্ণসংখ্যার একটি অ্যারে দেওয়া হয়েছে। আপনি সর্বাধিক একটি অপারেশন করতে পারেন যেখানে আপনি\n * তিনটি পূর্ণসংখ্যা i, j, x (1 <= i <= j <= n) নির্বাচন করেন এবং a[i] থেকে a[j] পর্যন্ত সমস্ত উপাদান x দিয়ে প্রতিস্থাপন করেন,\n * (j - i + 1) খরচে। অ্যারের সমস্ত উপাদান সমান করতে ন্যূনতম খরচ খুঁজুন।\n *\n * উদাহরণ:\n *    >>> f_34(3, (int[]){1, 2, 1})\n *    1\n *    >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n *    1\n */\nint f_34(int n, int a[])", "bg": "#include <cstdio>\n#include <cassert>\n/**\n * Даден ви е масив a от n цели числа. Можете да извършите най-много една операция, при която\n * избирате три цели числа i, j, x (1 <= i <= j <= n) и заменяте всички елементи от a[i] до a[j] с x,\n * на цена (j - i + 1). Намерете минималната цена, за да направите всички елементи в масива равни.\n *\n * Примери:\n *    >>> f_34(3, (int[]){1, 2, 1})\n *    1\n *    >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n *    1\n */\nint f_34(int n, int a[])", "zh": "#include <cstdio>\n#include <cassert>\n/**\n * 给定一个由 n 个整数组成的数组 a。你可以执行最多一次操作，选择三个整数 i, j, x (1 <= i <= j <= n)，\n * 并将所有从 a[i] 到 a[j] 的元素替换为 x，代价为 (j - i + 1)。找到使数组中所有元素相等的最小代价。\n *\n * 例子:\n *    >>> f_34(3, (int[]){1, 2, 1})\n *    1\n *    >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n *    1\n */\nint f_34(int n, int a[])", "fr": "#include <cstdio>\n#include <cassert>\n/**\n * Vous avez un tableau a de n entiers. Vous pouvez effectuer au plus une opération où vous\n * sélectionnez trois entiers i, j, x (1 <= i <= j <= n) et remplacez tous les éléments de a[i] à a[j] par x,\n * à un coût de (j - i + 1). Trouvez le coût minimum pour rendre tous les éléments du tableau égaux.\n *\n * Exemples :\n *    >>> f_34(3, (int[]){1, 2, 1})\n *    1\n *    >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n *    1\n */\nint f_34(int n, int a[])", "de": "#include <cstdio>\n#include <cassert>\n/**\n * Sie haben ein Array a mit n ganzen Zahlen. Sie können höchstens eine Operation durchführen, bei der Sie\n * drei ganze Zahlen i, j, x (1 <= i <= j <= n) auswählen und alle Elemente von a[i] bis a[j] durch x ersetzen,\n * zu Kosten von (j - i + 1). Finden Sie die minimalen Kosten, um alle Elemente im Array gleich zu machen.\n *\n * Beispiele:\n *    >>> f_34(3, (int[]){1, 2, 1})\n *    1\n *    >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n *    1\n */\nint f_34(int n, int a[])", "ha": "#include <cstdio>\n#include <cassert>\n/**\n * An ba ku wani jerin a na lambobin n. Kuna iya aiwatar da akalla aiki guda ɗaya inda za ku\n * zaɓi lambobi uku i, j, x (1 <= i <= j <= n) kuma ku maye gurbin dukkan abubuwa daga a[i] zuwa a[j] da x,\n * a farashin (j - i + 1). Nemo mafi ƙarancin kuɗi don sanya duk abubuwan cikin jerin su zama daidai.\n *\n * Misalai:\n *    >>> f_34(3, (int[]){1, 2, 1})\n *    1\n *    >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n *    1\n */\nint f_34(int n, int a[])", "hi": "#include <cstdio>\n#include <cassert>\n/**\n * आपको n पूर्णांकों की एक array a दी गई है। आप अधिकतम एक ऑपरेशन कर सकते हैं जहाँ आप\n * तीन पूर्णांक i, j, x (1 <= i <= j <= n) चुनते हैं और a[i] से a[j] तक के सभी तत्वों को x से बदल देते हैं,\n * जिसकी लागत (j - i + 1) होती है। सभी तत्वों को array में समान बनाने की न्यूनतम लागत खोजें।\n *\n * उदाहरण:\n *    >>> f_34(3, (int[]){1, 2, 1})\n *    1\n *    >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n *    1\n */\nint f_34(int n, int a[])", "hu": "#include <cstdio>\n#include <cassert>\n/**\n * Adott egy n egész számot tartalmazó tömb, a. Legfeljebb egy műveletet hajthatsz végre, ahol kiválasztasz három egész számot i, j, x (1 <= i <= j <= n), és az a[i] és a[j] közötti összes elemet x-szel helyettesíted, (j - i + 1) költséggel. Találd meg a minimális költséget, hogy a tömb összes eleme egyenlő legyen.\n *\n * Példák:\n *    >>> f_34(3, (int[]){1, 2, 1})\n *    1\n *    >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n *    1\n */\nint f_34(int n, int a[])", "es": "#include <cstdio>\n#include <cassert>\n/**\n * Se te da un array a de n enteros. Puedes realizar como máximo una operación donde\n * seleccionas tres enteros i, j, x (1 <= i <= j <= n) y reemplazas todos los elementos desde a[i] hasta a[j] con x,\n * a un costo de (j - i + 1). Encuentra el costo mínimo para hacer que todos los elementos en el array sean iguales.\n *\n * Ejemplos:\n *    >>> f_34(3, (int[]){1, 2, 1})\n *    1\n *    >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n *    1\n */\nint f_34(int n, int a[])", "arb": "#include <cstdio>\n#include <cassert>\n/**\n * لديك مصفوفة a تحتوي على n من الأعداد الصحيحة. يمكنك تنفيذ عملية واحدة على الأكثر حيث تختار ثلاثة أعداد صحيحة i، j، x (1 <= i <= j <= n) وتستبدل جميع العناصر من a[i] إلى a[j] بـ x، بتكلفة (j - i + 1). ابحث عن الحد الأدنى للتكلفة لجعل جميع العناصر في المصفوفة متساوية.\n *\n * أمثلة:\n *    >>> f_34(3, (int[]){1, 2, 1})\n *    1\n *    >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n *    1\n */\nint f_34(int n, int a[])", "sw": "#include <cstdio>\n#include <cassert>\n/**\n * Umepewa safu a ya n nambari za mzima. Unaweza kufanya operesheni moja tu ambapo\n * unachagua nambari tatu i, j, x (1 <= i <= j <= n) na kubadilisha vipengele vyote kutoka a[i] hadi a[j] na x,\n * kwa gharama ya (j - i + 1). Tafuta gharama ndogo zaidi ya kufanya vipengele vyote katika safu kuwa sawa.\n *\n * Mifano:\n *    >>> f_34(3, (int[]){1, 2, 1})\n *    1\n *    >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n *    1\n */\nint f_34(int n, int a[])", "tr": "#include <cstdio>\n#include <cassert>\n/**\n * Size n olan bir tamsayı dizisi verilmektedir. En fazla bir işlem gerçekleştirebilirsiniz, bu işlemde\n * i, j, x (1 <= i <= j <= n) üç tamsayısını seçer ve a[i] ile a[j] arasındaki tüm elemanları x ile değiştirirsiniz,\n * maliyet (j - i + 1) olur. Dizideki tüm elemanları eşit yapmak için minimum maliyeti bulun.\n *\n * Örnekler:\n *    >>> f_34(3, (int[]){1, 2, 1})\n *    1\n *    >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n *    1\n */\nint f_34(int n, int a[])", "vi": "#include <cstdio>\n#include <cassert>\n/**\n * Bạn được cho một mảng a gồm n số nguyên. Bạn có thể thực hiện tối đa một thao tác trong đó bạn\n * chọn ba số nguyên i, j, x (1 <= i <= j <= n) và thay thế tất cả các phần tử từ a[i] đến a[j] bằng x,\n * với chi phí là (j - i + 1). Tìm chi phí tối thiểu để làm cho tất cả các phần tử trong mảng bằng nhau.\n *\n * Ví dụ:\n *    >>> f_34(3, (int[]){1, 2, 1})\n *    1\n *    >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n *    1\n */\nint f_34(int n, int a[])", "id": "#include <cstdio>\n#include <cassert>\n/**\n * Anda diberikan sebuah array a yang terdiri dari n bilangan bulat. Anda dapat melakukan paling banyak satu operasi di mana Anda\n * memilih tiga bilangan bulat i, j, x (1 <= i <= j <= n) dan mengganti semua elemen dari a[i] hingga a[j] dengan x,\n * dengan biaya sebesar (j - i + 1). Temukan biaya minimum untuk membuat semua elemen dalam array menjadi sama.\n *\n * Contoh:\n *    >>> f_34(3, (int[]){1, 2, 1})\n *    1\n *    >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n *    1\n */\nint f_34(int n, int a[])", "ja": "#include <cstdio>\n#include <cassert>\n/**\n * 配列 a が n 個の整数で与えられます。最大で1回の操作を行うことができ、\n * その操作では 3 つの整数 i, j, x (1 <= i <= j <= n) を選択し、a[i] から a[j] までのすべての要素を x に置き換えます。\n * その際のコストは (j - i + 1) です。配列内のすべての要素を等しくするための最小コストを求めてください。\n *\n * 例:\n *    >>> f_34(3, (int[]){1, 2, 1})\n *    1\n *    >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n *    1\n */\nint f_34(int n, int a[])", "ko": "#include <cstdio>\n#include <cassert>\n/**\n * 정수 n개의 배열 a가 주어집니다. 최대 한 번의 연산을 수행할 수 있으며, 여기서 세 개의 정수 i, j, x (1 <= i <= j <= n)를 선택하고\n * a[i]부터 a[j]까지의 모든 요소를 x로 교체합니다. 이때 비용은 (j - i + 1)입니다. 배열의 모든 요소를 같게 만드는 최소 비용을 찾으세요.\n *\n * 예시:\n *    >>> f_34(3, (int[]){1, 2, 1})\n *    1\n *    >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n *    1\n */\nint f_34(int n, int a[])", "ml": "#include <cstdio>\n#include <cassert>\n/**\n * നിങ്ങൾക്ക് n പൂർണ്ണസംഖ്യകളുടെ ഒരു നിര a ലഭിക്കുന്നു. നിങ്ങൾക്ക് i, j, x (1 <= i <= j <= n) എന്ന മൂന്ന് പൂർണ്ണസംഖ്യകൾ തിരഞ്ഞെടുക്കുകയും\n * a[i] മുതൽ a[j] വരെയുള്ള എല്ലാ മൂല്യങ്ങളും x കൊണ്ട് മാറ്റിസ്ഥാപിക്കുകയും ചെയ്യുന്ന പരമാവധി ഒരു പ്രവർത്തനം നടത്താം,\n * (j - i + 1) എന്ന ചെലവിൽ. നിരയിലെ എല്ലാ മൂല്യങ്ങളും തുല്യമായി മാറ്റുന്നതിനുള്ള കുറഞ്ഞ ചെലവ് കണ്ടെത്തുക.\n *\n * ഉദാഹരണങ്ങൾ:\n *    >>> f_34(3, (int[]){1, 2, 1})\n *    1\n *    >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n *    1\n */\nint f_34(int n, int a[])", "fa": "#include <cstdio>\n#include <cassert>\n/**\n * شما یک آرایه a از n عدد صحیح دارید. شما می‌توانید حداکثر یک عملیات انجام دهید که در آن\n * سه عدد صحیح i، j، x (1 <= i <= j <= n) را انتخاب کنید و همه عناصر از a[i] تا a[j] را با x جایگزین کنید،\n * با هزینه (j - i + 1). حداقل هزینه برای برابر کردن همه عناصر در آرایه را پیدا کنید.\n *\n * مثال‌ها:\n *    >>> f_34(3, (int[]){1, 2, 1})\n *    1\n *    >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n *    1\n */\nint f_34(int n, int a[])"}, "canonical_solution": "{\n    int j = 0, p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}", "instruction": {"en": "Write a CPP function `int f_34(int n, int a[])` to solve the following problem:\nYou are given an array a of n integers. You can perform at most one operation where you select three integers i, j, x (1 <= i <= j <= n) and replace all elements from a[i] to a[j] with x, at a cost of (j - i + 1). Find the minimum cost to make all elements in the array equal.\n\nExamples:\n   >>> f_34(3, (int[]){1, 2, 1})\n   1\n   >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n   1\n", "sq": "Shkruani një funksion CPP `int f_34(int n, int a[])` për të zgjidhur problemin në vijim:\nJu jepet një varg a me n numra të plotë. Ju mund të kryeni maksimumi një operacion ku zgjidhni tre numra të plotë i, j, x (1 <= i <= j <= n) dhe zëvendësoni të gjitha elementet nga a[i] në a[j] me x, me një kosto prej (j - i + 1). Gjeni koston minimale për t'i bërë të gjitha elementet në varg të barabarta.\n\nShembuj:\n   >>> f_34(3, (int[]){1, 2, 1})\n   1\n   >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n   1", "hy": "Գրեք CPP ֆունկցիա `int f_34(int n, int a[])` հետևյալ խնդիրը լուծելու համար:\nՁեզ տրված է n ամբողջ թվերի զանգված a։ Դուք կարող եք կատարել առավելագույնը մեկ գործողություն, որտեղ ընտրում եք երեք ամբողջ թվեր i, j, x (1 <= i <= j <= n) և փոխարինում եք a[i]-ից a[j]-ը բոլոր տարրերը x-ով, արժեքով (j - i + 1): Գտեք նվազագույն արժեքը, որպեսզի զանգվածի բոլոր տարրերը հավասար լինեն:\n\nՕրինակներ:\n   >>> f_34(3, (int[]){1, 2, 1})\n   1\n   >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n   1", "bn": "একটি CPP ফাংশন `int f_34(int n, int a[])` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:  \nআপনাকে n পূর্ণসংখ্যার একটি অ্যারে a দেওয়া হয়েছে। আপনি সর্বাধিক একটি অপারেশন করতে পারেন যেখানে আপনি তিনটি পূর্ণসংখ্যা i, j, x (1 <= i <= j <= n) নির্বাচন করেন এবং a[i] থেকে a[j] পর্যন্ত সমস্ত উপাদান x দিয়ে প্রতিস্থাপন করেন, যার খরচ (j - i + 1)। অ্যারের সমস্ত উপাদান সমান করতে সর্বনিম্ন খরচ খুঁজে বের করুন।\n\nউদাহরণসমূহ:\n   >>> f_34(3, (int[]){1, 2, 1})\n   1\n   >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n   1", "bg": "Напишете CPP функция `int f_34(int n, int a[])`, за да решите следния проблем:\nДаден ви е масив a от n цели числа. Можете да извършите най-много една операция, при която избирате три цели числа i, j, x (1 <= i <= j <= n) и заменяте всички елементи от a[i] до a[j] с x, на цена (j - i + 1). Намерете минималната цена, за да направите всички елементи в масива равни.\n\nПримери:\n   >>> f_34(3, (int[]){1, 2, 1})\n   1\n   >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n   1", "zh": "编写一个 CPP 函数 `int f_34(int n, int a[])` 来解决以下问题：\n给定一个包含 n 个整数的数组 a。你可以最多执行一次操作，其中你选择三个整数 i, j, x (1 <= i <= j <= n)，并将所有从 a[i] 到 a[j] 的元素替换为 x，代价为 (j - i + 1)。找出使数组中所有元素相等的最小代价。\n\n示例:\n   >>> f_34(3, (int[]){1, 2, 1})\n   1\n   >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n   1", "fr": "Écrire une fonction CPP `int f_34(int n, int a[])` pour résoudre le problème suivant :  \nOn vous donne un tableau a de n entiers. Vous pouvez effectuer au plus une opération où vous sélectionnez trois entiers i, j, x (1 <= i <= j <= n) et remplacez tous les éléments de a[i] à a[j] par x, à un coût de (j - i + 1). Trouvez le coût minimum pour rendre tous les éléments du tableau égaux.\n\nExemples :\n   >>> f_34(3, (int[]){1, 2, 1})\n   1\n   >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n   1", "de": "Schreiben Sie eine CPP-Funktion `int f_34(int n, int a[])`, um das folgende Problem zu lösen:\nSie haben ein Array a mit n ganzen Zahlen. Sie können höchstens eine Operation durchführen, bei der Sie drei ganze Zahlen i, j, x (1 <= i <= j <= n) auswählen und alle Elemente von a[i] bis a[j] durch x ersetzen, zu einem Kostenaufwand von (j - i + 1). Finden Sie die minimalen Kosten, um alle Elemente im Array gleich zu machen.\n\nBeispiele:\n   >>> f_34(3, (int[]){1, 2, 1})\n   1\n   >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n   1", "ha": "Rubuta aikin CPP `int f_34(int n, int a[])` don warware matsalar mai zuwa:\nAn ba ku wani tsari a na lambobi n. Kuna iya aiwatar da aƙalla aiki ɗaya inda kuka zaɓi lambobi uku i, j, x (1 <= i <= j <= n) kuma ku maye gurbin duk abubuwan daga a[i] zuwa a[j] da x, a farashin (j - i + 1). Nemo mafi ƙarancin farashi don sanya duk abubuwan cikin jerin su zama daidai.\n\nMisalai:\n   >>> f_34(3, (int[]){1, 2, 1})\n   1\n   >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n   1", "hi": "एक CPP फ़ंक्शन `int f_34(int n, int a[])` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nआपको n पूर्णांकों की एक array a दी गई है। आप अधिकतम एक ऑपरेशन कर सकते हैं जहाँ आप तीन पूर्णांक i, j, x (1 <= i <= j <= n) का चयन करते हैं और a[i] से a[j] तक के सभी तत्वों को x से बदल देते हैं, जिसकी लागत (j - i + 1) होती है। सभी तत्वों को array में समान बनाने के लिए न्यूनतम लागत खोजें।\n\nउदाहरण:\n   >>> f_34(3, (int[]){1, 2, 1})\n   1\n   >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n   1", "hu": "Írj egy CPP függvényt `int f_34(int n, int a[])` a következő probléma megoldására:\nAdott egy a tömb n egész számmal. Legfeljebb egy műveletet hajthatsz végre, ahol kiválasztasz három egész számot i, j, x (1 <= i <= j <= n), és az a[i] és a[j] közötti összes elemet x-re cseréled, (j - i + 1) költséggel. Találd meg a minimális költséget, hogy az összes elem a tömbben egyenlő legyen.\n\nPéldák:\n   >>> f_34(3, (int[]){1, 2, 1})\n   1\n   >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n   1", "es": "Escribe una función CPP `int f_34(int n, int a[])` para resolver el siguiente problema:\nSe te da un arreglo a de n enteros. Puedes realizar como máximo una operación donde seleccionas tres enteros i, j, x (1 <= i <= j <= n) y reemplazas todos los elementos desde a[i] hasta a[j] con x, a un costo de (j - i + 1). Encuentra el costo mínimo para hacer que todos los elementos en el arreglo sean iguales.\n\nEjemplos:\n   >>> f_34(3, (int[]){1, 2, 1})\n   1\n   >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n   1", "arb": "اكتب دالة CPP `int f_34(int n, int a[])` لحل المشكلة التالية:\nأنت مُعطى مصفوفة a تحتوي على n عدد صحيح. يمكنك تنفيذ عملية واحدة على الأكثر حيث تختار ثلاثة أعداد صحيحة i, j, x (1 <= i <= j <= n) وتستبدل جميع العناصر من a[i] إلى a[j] بـ x، بتكلفة (j - i + 1). جد التكلفة الدنيا لجعل جميع العناصر في المصفوفة متساوية.\n\nأمثلة:\n   >>> f_34(3, (int[]){1, 2, 1})\n   1\n   >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n   1", "sw": "Andika kazi ya CPP `int f_34(int n, int a[])` kutatua tatizo lifuatalo:\nUmepewa safu a ya n nambari za mzima. Unaweza kufanya operesheni moja tu ambapo unachagua nambari tatu i, j, x (1 <= i <= j <= n) na kubadilisha vipengele vyote kutoka a[i] hadi a[j] na x, kwa gharama ya (j - i + 1). Tafuta gharama ya chini ya kufanya vipengele vyote katika safu kuwa sawa.\n\nMifano:\n   >>> f_34(3, (int[]){1, 2, 1})\n   1\n   >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n   1", "tr": "Bir CPP fonksiyonu `int f_34(int n, int a[])` yazın ve aşağıdaki problemi çözün:\nn tamsayısından oluşan bir dizi a verilmektedir. En fazla bir işlem gerçekleştirebilirsiniz; burada i, j, x (1 <= i <= j <= n) üç tamsayısını seçer ve a[i] ile a[j] arasındaki tüm elemanları x ile değiştirirsiniz, bu işlemin maliyeti (j - i + 1) olur. Dizideki tüm elemanları eşit yapmak için minimum maliyeti bulun.\n\nÖrnekler:\n   >>> f_34(3, (int[]){1, 2, 1})\n   1\n   >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n   1", "vi": "Viết một hàm CPP `int f_34(int n, int a[])` để giải quyết vấn đề sau:  \nBạn được cho một mảng a gồm n số nguyên. Bạn có thể thực hiện tối đa một thao tác, trong đó bạn chọn ba số nguyên i, j, x (1 <= i <= j <= n) và thay thế tất cả các phần tử từ a[i] đến a[j] bằng x, với chi phí là (j - i + 1). Tìm chi phí tối thiểu để làm cho tất cả các phần tử trong mảng bằng nhau.\n\nVí dụ:\n   >>> f_34(3, (int[]){1, 2, 1})\n   1\n   >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n   1", "id": "Tulis fungsi CPP `int f_34(int n, int a[])` untuk menyelesaikan masalah berikut:  \nDiberikan sebuah array a yang terdiri dari n bilangan bulat. Anda dapat melakukan paling banyak satu operasi di mana Anda memilih tiga bilangan bulat i, j, x (1 <= i <= j <= n) dan mengganti semua elemen dari a[i] hingga a[j] dengan x, dengan biaya (j - i + 1). Temukan biaya minimum untuk membuat semua elemen dalam array menjadi sama.\n\nContoh:\n   >>> f_34(3, (int[]){1, 2, 1})\n   1\n   >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n   1", "ja": "以下の問題を解決するために、CPP関数 `int f_34(int n, int a[])` を作成しなさい。\n整数 n の配列 a が与えられます。最大で1回の操作を行うことができ、3つの整数 i, j, x (1 <= i <= j <= n) を選択し、a[i] から a[j] までのすべての要素を x に置き換えます。この操作のコストは (j - i + 1) です。配列内のすべての要素を等しくするための最小コストを求めなさい。\n\n例:\n   >>> f_34(3, (int[]){1, 2, 1})\n   1\n   >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n   1", "ko": "다음 문제를 해결하기 위해 CPP 함수를 `int f_34(int n, int a[])` 작성하세요:\n정수 n개의 배열 a가 주어집니다. 최대 한 번의 연산을 수행할 수 있으며, 여기서 세 개의 정수 i, j, x (1 <= i <= j <= n)를 선택하고 a[i]에서 a[j]까지의 모든 요소를 x로 바꿉니다. 이때 비용은 (j - i + 1)입니다. 배열의 모든 요소를 같게 만드는 최소 비용을 찾으세요.\n\n예시:\n   >>> f_34(3, (int[]){1, 2, 1})\n   1\n   >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n   1", "ml": "`int f_34(int n, int a[])` എന്ന CPP ഫംഗ്ഷൻ എഴുതുക താഴെക്കൊടുത്തിരിക്കുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nനിങ്ങൾക്ക് n പൂർണ്ണസംഖ്യകളുടെ ഒരു നിര a ലഭിച്ചിട്ടുണ്ട്. നിങ്ങൾക്ക് ഏറ്റവും കൂടുതൽ ഒരു പ്രവർത്തനം നടത്താം, അവിടെ നിങ്ങൾ മൂന്നു പൂർണ്ണസംഖ്യകൾ i, j, x (1 <= i <= j <= n) തിരഞ്ഞെടുക്കുകയും a[i] മുതൽ a[j] വരെയുള്ള എല്ലാ മൂല്യങ്ങളും x-നായി മാറ്റുകയും ചെയ്യാം, (j - i + 1) എന്ന ചെലവിൽ. നിരയിലെ എല്ലാ മൂല്യങ്ങളും തുല്യമായിത്തീരാൻ കുറഞ്ഞ ചെലവ് കണ്ടെത്തുക.\n\nഉദാഹരണങ്ങൾ:\n   >>> f_34(3, (int[]){1, 2, 1})\n   1\n   >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n   1", "fa": "یک تابع CPP `int f_34(int n, int a[])` بنویسید تا مسئله زیر را حل کند:\nیک آرایه a از n عدد صحیح به شما داده شده است. شما می‌توانید حداکثر یک عملیات انجام دهید که در آن سه عدد صحیح i، j، x (1 <= i <= j <= n) را انتخاب کرده و همه عناصر از a[i] تا a[j] را با x جایگزین کنید، با هزینه (j - i + 1). حداقل هزینه برای برابر کردن همه عناصر در آرایه را پیدا کنید.\n\nمثال‌ها:\n   >>> f_34(3, (int[]){1, 2, 1})\n   1\n   >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n   1"}, "level": "middle", "test": "int main() {\n    int a1[] = {1,2,3,4,5,1};\n    int a2[] = {1,1,1,1,1,1,1};\n    int a3[] = {8,8,8,1,2,8,8,8};\n    int a4[] = {1,2,3};\n    int a5[] = {4,3,2,7,1,1,3};\n    int a6[] = {9,9,2,9,2,5,5,5,3};\n    \n    assert(f_34(6, a1) == 4);\n    assert(f_34(7, a2) == 0);\n    assert(f_34(8, a3) == 2);\n    assert(f_34(3, a4) == 2);\n    assert(f_34(7, a5) == 6);\n    assert(f_34(9, a6) == 7);\n\n    int a7[] = {1, 2, 1};\n    int a8[] = {5, 5, 1, 5, 5};\n    int a9[] = {1, 1, 1, 1};\n    int a10[] = {2, 2, 2, 3, 2, 2};\n    int a11[] = {1};\n    int a12[] = {1, 2};\n    int a13[] = {1, 2, 2, 1};\n    int a14[] = {4, 4, 4, 3, 3, 4, 4};\n    int a15[] = {5, 4, 4, 4, 5, 5};\n    int a16[] = {1, 2, 1, 2, 1, 2, 1};\n    // Additional provided tests\n    assert(f_34(3, a7) == 1);\n    assert(f_34(5, a8) == 1);\n    assert(f_34(4, a9) == 0);\n    assert(f_34(6, a10) == 1);\n    assert(f_34(1, a11) == 0);\n    assert(f_34(2, a12) == 1);\n    assert(f_34(4, a13) == 2);\n    assert(f_34(7, a14) == 2);\n    assert(f_34(6, a15) == 3);\n    assert(f_34(7, a16) == 5);\n    \n    return 0;\n}", "entry_point": "f_34", "signature": "int f_34(int n, int a[])", "docstring": {"en": "You are given an array a of n integers. You can perform at most one operation where you select three integers i, j, x (1 <= i <= j <= n) and replace all elements from a[i] to a[j] with x, at a cost of (j - i + 1). Find the minimum cost to make all elements in the array equal.\n\nExamples:\n   >>> f_34(3, (int[]){1, 2, 1})\n   1\n   >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n   1\n", "sq": "Ju jepet një varg a me n numra të plotë. Ju mund të kryeni maksimumi një operacion ku zgjidhni tre numra të plotë i, j, x (1 <= i <= j <= n) dhe zëvendësoni të gjitha elementet nga a[i] deri te a[j] me x, me një kosto prej (j - i + 1). Gjeni koston minimale për të bërë të gjithë elementet në varg të barabartë.\n\nShembuj:\n   >>> f_34(3, (int[]){1, 2, 1})\n   1\n   >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n   1", "hy": "Դուք տրված եք n ամբողջ թվերի զանգված a։ Դուք կարող եք կատարել առավելագույնը մեկ գործողություն, որտեղ ընտրում եք երեք ամբողջ թվեր i, j, x (1 <= i <= j <= n) և փոխարինում եք բոլոր տարրերը a[i]-ից մինչև a[j] x-ով, արժեքով (j - i + 1)։ Գտեք նվազագույն արժեքը, որպեսզի զանգվածի բոլոր տարրերը հավասար լինեն։\n\nՕրինակներ:\n   >>> f_34(3, (int[]){1, 2, 1})\n   1\n   >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n   1", "bn": "আপনাকে n পূর্ণসংখ্যার একটি অ্যারে a দেওয়া হয়েছে। আপনি সর্বাধিক একটি অপারেশন করতে পারেন যেখানে আপনি তিনটি পূর্ণসংখ্যা i, j, x (1 <= i <= j <= n) নির্বাচন করেন এবং a[i] থেকে a[j] পর্যন্ত সমস্ত উপাদানকে x দিয়ে প্রতিস্থাপন করেন, যার খরচ (j - i + 1)। অ্যারের সমস্ত উপাদান সমান করতে ন্যূনতম খরচ খুঁজে বের করুন।\n\nউদাহরণ:\n   >>> f_34(3, (int[]){1, 2, 1})\n   1\n   >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n   1", "bg": "Даден е масив a от n цели числа. Можете да извършите най-много една операция, при която избирате три цели числа i, j, x (1 <= i <= j <= n) и заменяте всички елементи от a[i] до a[j] с x, на цена от (j - i + 1). Намерете минималната цена, за да направите всички елементи в масива равни.\n\nПримери:\n   >>> f_34(3, (int[]){1, 2, 1})\n   1\n   >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n   1", "zh": "您有一个由 n 个整数组成的数组 a。您最多可以执行一次操作，在该操作中选择三个整数 i, j, x (1 <= i <= j <= n)，并将从 a[i] 到 a[j] 的所有元素替换为 x，代价为 (j - i + 1)。找出使数组中所有元素相等的最小代价。\n\n示例：\n   >>> f_34(3, (int[]){1, 2, 1})\n   1\n   >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n   1", "fr": "Vous disposez d'un tableau a de n entiers. Vous pouvez effectuer au plus une opération où vous sélectionnez trois entiers i, j, x (1 <= i <= j <= n) et remplacez tous les éléments de a[i] à a[j] par x, à un coût de (j - i + 1). Trouvez le coût minimum pour rendre tous les éléments du tableau égaux.\n\nExemples :\n   >>> f_34(3, (int[]){1, 2, 1})\n   1\n   >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n   1", "de": "Du hast ein Array a mit n ganzen Zahlen. Du kannst höchstens eine Operation durchführen, bei der du drei ganze Zahlen i, j, x (1 <= i <= j <= n) auswählst und alle Elemente von a[i] bis a[j] durch x ersetzt, zu einem Kostenaufwand von (j - i + 1). Finde die minimalen Kosten, um alle Elemente im Array gleich zu machen.\n\nBeispiele:\n   >>> f_34(3, (int[]){1, 2, 1})\n   1\n   >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n   1", "ha": "An ba ku wani tsari a na lambobi n. Kuna iya aiwatar da akalla aiki ɗaya inda kuka zaɓi lambobi uku i, j, x (1 <= i <= j <= n) kuma ku maye gurbin dukkan abubuwa daga a[i] zuwa a[j] da x, a farashin (j - i + 1). Nemo mafi ƙarancin farashi don sanya duk abubuwan cikin tsari su zama daidai.\n\nMisalai:\n   >>> f_34(3, (int[]){1, 2, 1})\n   1\n   >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n   1", "hi": "आपको n पूर्णांकों की एक array a दी गई है। आप अधिकतम एक ऑपरेशन कर सकते हैं जहाँ आप तीन पूर्णांक i, j, x (1 <= i <= j <= n) का चयन करते हैं और a[i] से a[j] तक के सभी तत्वों को x से बदलते हैं, जिसकी लागत (j - i + 1) होती है। सभी तत्वों को array में समान बनाने की न्यूनतम लागत खोजें।\n\nउदाहरण:\n   >>> f_34(3, (int[]){1, 2, 1})\n   1\n   >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n   1", "hu": "Meg van adva egy `a` tömb `n` egész számmal. Legfeljebb egy műveletet hajthatsz végre, ahol kiválasztasz három egész számot `i`, `j`, `x` (1 <= i <= j <= n), és az `a[i]`-től `a[j]`-ig terjedő összes elemet `x`-re cseréled, (j - i + 1) költséggel. Találd meg a minimális költséget, hogy az összes elem a tömbben egyenlő legyen.\n\nPéldák:\n   >>> f_34(3, (int[]){1, 2, 1})\n   1\n   >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n   1", "es": "Se te da un array a de n enteros. Puedes realizar como máximo una operación donde seleccionas tres enteros i, j, x (1 <= i <= j <= n) y reemplazas todos los elementos desde a[i] hasta a[j] con x, a un costo de (j - i + 1). Encuentra el costo mínimo para hacer que todos los elementos en el array sean iguales.\n\nEjemplos:\n   >>> f_34(3, (int[]){1, 2, 1})\n   1\n   >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n   1", "arb": "أنت مُعطى مصفوفة a تحتوي على n عدد صحيح. يمكنك تنفيذ عملية واحدة على الأكثر حيث تختار ثلاثة أعداد صحيحة i، j، x (1 <= i <= j <= n) وتستبدل جميع العناصر من a[i] إلى a[j] بـ x، بتكلفة (j - i + 1). ابحث عن الحد الأدنى للتكلفة لجعل جميع العناصر في المصفوفة متساوية.\n\nأمثلة:\n   >>> f_34(3, (int[]){1, 2, 1})\n   1\n   >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n   1", "sw": "Unapewa safu a ya n ya nambari za mzima. Unaweza kufanya operesheni moja tu ambapo unachagua nambari tatu i, j, x (1 <= i <= j <= n) na kubadilisha vipengele vyote kutoka a[i] hadi a[j] na x, kwa gharama ya (j - i + 1). Tafuta gharama ndogo zaidi ya kufanya vipengele vyote katika safu kuwa sawa.\n\nMifano:\n   >>> f_34(3, (int[]){1, 2, 1})\n   1\n   >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n   1", "tr": "Bir n tam sayısından oluşan bir dizi verilir. En fazla bir işlem gerçekleştirebilirsiniz; burada i, j, x (1 <= i <= j <= n) üç tam sayısını seçer ve a[i] ile a[j] arasındaki tüm elemanları x ile değiştirirsiniz, bu işlem (j - i + 1) maliyetine sahiptir. Dizideki tüm elemanları eşit yapmak için minimum maliyeti bulun.\n\nÖrnekler:\n   >>> f_34(3, (int[]){1, 2, 1})\n   1\n   >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n   1", "vi": "Bạn được cung cấp một mảng a gồm n số nguyên. Bạn có thể thực hiện tối đa một thao tác, trong đó bạn chọn ba số nguyên i, j, x (1 <= i <= j <= n) và thay thế tất cả các phần tử từ a[i] đến a[j] bằng x, với chi phí là (j - i + 1). Tìm chi phí tối thiểu để làm cho tất cả các phần tử trong mảng bằng nhau.\n\nVí dụ:\n   >>> f_34(3, (int[]){1, 2, 1})\n   1\n   >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n   1", "id": "Anda diberikan sebuah array a yang terdiri dari n bilangan bulat. Anda dapat melakukan paling banyak satu operasi di mana Anda memilih tiga bilangan bulat i, j, x (1 <= i <= j <= n) dan mengganti semua elemen dari a[i] hingga a[j] dengan x, dengan biaya (j - i + 1). Temukan biaya minimum untuk membuat semua elemen dalam array menjadi sama.\n\nContoh:\n   >>> f_34(3, (int[]){1, 2, 1})\n   1\n   >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n   1", "ja": "配列 a が n 個の整数で与えられます。最大で 1 回の操作を行うことができ、3 つの整数 i, j, x (1 <= i <= j <= n) を選択し、a[i] から a[j] までのすべての要素を x に置き換えます。この操作のコストは (j - i + 1) です。配列内のすべての要素を等しくするための最小コストを見つけてください。\n\n例:\n   >>> f_34(3, (int[]){1, 2, 1})\n   1\n   >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n   1", "ko": "당신에게 n개의 정수로 이루어진 배열 a가 주어집니다. 최대 한 번의 연산을 수행할 수 있으며, 여기서 세 정수 i, j, x (1 <= i <= j <= n)를 선택하고 a[i]에서 a[j]까지의 모든 요소를 x로 교체하며, 비용은 (j - i + 1)입니다. 배열의 모든 요소를 동일하게 만드는 최소 비용을 찾으십시오.\n\n예시:\n   >>> f_34(3, (int[]){1, 2, 1})\n   1\n   >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n   1", "ml": "നിങ്ങൾക്ക് n പൂർണ്ണസംഖ്യകളുടെ ഒരു നിര ലഭിച്ചിട്ടുണ്ട്. നിങ്ങൾക്ക് ഏറ്റവും കൂടുതൽ ഒരു പ്രവർത്തനം നടത്താൻ കഴിയും, അവിടെ നിങ്ങൾ മൂന്നു പൂർണ്ണസംഖ്യകൾ i, j, x (1 <= i <= j <= n) തിരഞ്ഞെടുക്കുകയും a[i] മുതൽ a[j] വരെയുള്ള എല്ലാ മൂല്യങ്ങളും x-ൽ മാറ്റിസ്ഥാപിക്കുകയും (j - i + 1) എന്ന ചെലവിൽ. നിരയിലെ എല്ലാ മൂല്യങ്ങളും തുല്യമായിത്തീരാൻ കുറഞ്ഞ ചെലവ് കണ്ടെത്തുക.\n\nഉദാഹരണങ്ങൾ:\n   >>> f_34(3, (int[]){1, 2, 1})\n   1\n   >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n   1", "fa": "شما یک آرایه a از n عدد صحیح دارید. شما می‌توانید حداکثر یک عملیات انجام دهید که در آن سه عدد صحیح i، j، x (1 <= i <= j <= n) را انتخاب کرده و تمام عناصر از a[i] تا a[j] را با x جایگزین کنید، با هزینه‌ای برابر با (j - i + 1). حداقل هزینه برای برابر کردن تمام عناصر در آرایه را پیدا کنید.\n\nمثال‌ها:\n   >>> f_34(3, (int[]){1, 2, 1})\n   1\n   >>> f_34(5, (int[]){5, 5, 1, 5, 5})\n   1"}}
{"task_id": "CPP/35", "prompt": {"en": "#include <cassert>\n#include <iostream>\n/**\n * Given a sequence of N piles of stones numbered from 1 to N, each containing a positive number of stones, determine the winner\n * of a game played by Charlie and Dan. Charlie starts, taking turns with Dan moving stones from the leftmost non-empty pile\n * to the adjacent right pile. The one who can only move stones in the last pile loses. Assuming perfect play, find the winner.\n *\n * >>> f_35(3, {1, 2, 2})\n * \"Dan\"\n */\nconst char* f_35(int n, const int piles[])", "sq": "#include <cassert>\n#include <iostream>\n/**\n * Duke pasur një sekuencë prej N grumbujsh gurësh të numëruar nga 1 deri në N, secili që përmban një numër pozitiv gurësh, përcaktoni fituesin\n * të një loje të luajtur nga Charlie dhe Dan. Charlie fillon, duke marrë radhën me Dan për të lëvizur gurët nga grumbulli më i majtë jo bosh\n * te grumbulli ngjitur në të djathtë. Ai që mund të lëvizë gurët vetëm në grumbullin e fundit humbet. Duke supozuar lojë të përkryer, gjeni fituesin.\n *\n * >>> f_35(3, {1, 2, 2})\n * \"Dan\"\n */\nconst char* f_35(int n, const int piles[])", "hy": "#include <cassert>\n#include <iostream>\n/**\n * Տրված է N քանակությամբ քարերի կույտերի հաջորդականություն, որոնք համարակալված են 1-ից N, և յուրաքանչյուրում կա քարերի դրական քանակություն, որոշել խաղի հաղթողին,\n * որը խաղում են Չարլին և Դենը: Չարլին սկսում է, հերթափոխով Դենի հետ տեղափոխելով քարերը ձախից աջ հարակից կույտ: Այն, ով կարող է տեղափոխել քարերը միայն վերջին կույտում, պարտվում է:\n * Ենթադրելով կատարյալ խաղ, գտնել հաղթողին:\n *\n * >>> f_35(3, {1, 2, 2})\n * \"Dan\"\n */\nconst char* f_35(int n, const int piles[])", "bn": "#include <cassert>\n#include <iostream>\n/**\n * ১ থেকে N পর্যন্ত নম্বরযুক্ত N পাথরের স্তূপের একটি ক্রম দেওয়া হয়েছে, প্রতিটি স্তূপে একটি ধনাত্মক সংখ্যক পাথর রয়েছে, একটি গেমের বিজয়ী নির্ধারণ করুন\n * যা চার্লি এবং ড্যান দ্বারা খেলা হয়। চার্লি শুরু করে, ড্যানের সাথে পালাক্রমে বাম দিকের প্রথম খালি না হওয়া স্তূপ থেকে\n * ডানদিকে সংলগ্ন স্তূপে পাথর সরিয়ে নিয়ে যায়। যে ব্যক্তি শুধুমাত্র শেষ স্তূপে পাথর সরাতে পারে সে হেরে যায়। নিখুঁত খেলার অনুমান করে, বিজয়ী খুঁজে বের করুন।\n *\n * >>> f_35(3, {1, 2, 2})\n * \"Dan\"\n */\nconst char* f_35(int n, const int piles[])", "bg": "#include <cassert>\n#include <iostream>\n/**\n * Дадена е последователност от N купчини с камъни, номерирани от 1 до N, всяка съдържаща положителен брой камъни, определете победителя\n * в игра, играна от Чарли и Дан. Чарли започва, като се редува с Дан да преместват камъни от най-лявата непразна купчина\n * към съседната дясна купчина. Този, който може да премести камъни само в последната купчина, губи. Приемайки перфектна игра, намерете победителя.\n *\n * >>> f_35(3, {1, 2, 2})\n * \"Dan\"\n */\nconst char* f_35(int n, const int piles[])", "zh": "#include <cassert>\n#include <iostream>\n/**\n * 给定一个编号从1到N的石堆序列，每堆包含正数个石头，确定Charlie和Dan玩的游戏的赢家。\n * Charlie开始，与Dan轮流从最左边的非空堆移动石头到相邻的右边堆。只能在最后一堆移动石头的人输。\n * 假设完美游戏，找出赢家。\n *\n * >>> f_35(3, {1, 2, 2})\n * \"Dan\"\n */\nconst char* f_35(int n, const int piles[])", "fr": "#include <cassert>\n#include <iostream>\n/**\n * Étant donné une séquence de N piles de pierres numérotées de 1 à N, chacune contenant un nombre positif de pierres, déterminer le gagnant\n * d'un jeu joué par Charlie et Dan. Charlie commence, prenant des tours avec Dan pour déplacer des pierres de la pile la plus à gauche non vide\n * vers la pile adjacente à droite. Celui qui ne peut déplacer des pierres que dans la dernière pile perd. En supposant un jeu parfait, trouver le gagnant.\n *\n * >>> f_35(3, {1, 2, 2})\n * \"Dan\"\n */\nconst char* f_35(int n, const int piles[])", "de": "#include <cassert>\n#include <iostream>\n/**\n * Gegeben eine Sequenz von N Steinhaufen, nummeriert von 1 bis N, wobei jeder Haufen eine positive Anzahl von Steinen enthält,\n * bestimmen Sie den Gewinner eines Spiels, das von Charlie und Dan gespielt wird. Charlie beginnt und wechselt sich mit Dan ab,\n * indem sie Steine vom linken, nicht leeren Haufen zum benachbarten rechten Haufen bewegen. Derjenige, der nur noch Steine im\n * letzten Haufen bewegen kann, verliert. Angenommen, beide spielen perfekt, finden Sie den Gewinner.\n *\n * >>> f_35(3, {1, 2, 2})\n * \"Dan\"\n */\nconst char* f_35(int n, const int piles[])", "ha": "#include <cassert>\n#include <iostream>\n/**\n * An ba da jerin N na tarin duwatsu da aka lamba daga 1 zuwa N, kowanne yana dauke da adadi mai kyau na duwatsu, tantance wanda ya ci\n * wasa da Charlie da Dan suka buga. Charlie yana farawa, suna juyawa da Dan suna motsa duwatsu daga mafi hagu da ba komai ba\n * zuwa tarin da ke kusa da dama. Wanda zai iya motsa duwatsu a cikin tarin karshe kawai ya yi rashin nasara. Ana tsammanin wasa mai kyau, gano wanda ya ci.\n *\n * >>> f_35(3, {1, 2, 2})\n * \"Dan\"\n */\nconst char* f_35(int n, const int piles[])", "hi": "#include <cassert>\n#include <iostream>\n/**\n * दिए गए पत्थरों के N ढेरों की एक अनुक्रमणिका, जिन्हें 1 से N तक क्रमांकित किया गया है, प्रत्येक में पत्थरों की एक सकारात्मक संख्या है, \n * चार्ली और डैन द्वारा खेले गए एक खेल के विजेता का निर्धारण करें। चार्ली शुरू करता है, डैन के साथ बारी-बारी से बाएं से दाएं \n * सबसे पहले गैर-खाली ढेर से पत्थरों को दाएं सटे ढेर में ले जाता है। जो केवल अंतिम ढेर में पत्थरों को ले जा सकता है, वह हार जाता है। \n * पूर्ण खेल मानते हुए, विजेता का पता लगाएं।\n *\n * >>> f_35(3, {1, 2, 2})\n * \"Dan\"\n */\nconst char* f_35(int n, const int piles[])", "hu": "#include <cassert>\n#include <iostream>\n/**\n * Adott egy N halomból álló kőhalmaz, amelyeket 1-től N-ig számoztak, mindegyik halom pozitív számú követ tartalmaz. Határozza meg a győztest\n * egy játékban, amelyet Charlie és Dan játszik. Charlie kezd, felváltva Dan-nel, köveket mozgatva a bal szélső nem üres halomból\n * a szomszédos jobb halomba. Az veszít, aki csak az utolsó halomban tud köveket mozgatni. Tökéletes játékot feltételezve, találja meg a győztest.\n *\n * >>> f_35(3, {1, 2, 2})\n * \"Dan\"\n */\nconst char* f_35(int n, const int piles[])", "es": "#include <cassert>\n#include <iostream>\n/**\n * Dada una secuencia de N pilas de piedras numeradas del 1 al N, cada una conteniendo un número positivo de piedras, determina el ganador\n * de un juego jugado por Charlie y Dan. Charlie comienza, turnándose con Dan moviendo piedras de la pila más a la izquierda no vacía\n * a la pila adyacente a la derecha. El que solo pueda mover piedras en la última pila pierde. Asumiendo un juego perfecto, encuentra al ganador.\n *\n * >>> f_35(3, {1, 2, 2})\n * \"Dan\"\n */\nconst char* f_35(int n, const int piles[])", "arb": "#include <cassert>\n#include <iostream>\n/**\n * بالنظر إلى تسلسل من N كومة من الحجارة مرقمة من 1 إلى N، كل منها يحتوي على عدد موجب من الحجارة، حدد الفائز\n * في لعبة يلعبها تشارلي ودان. يبدأ تشارلي، ويتناوب مع دان في نقل الحجارة من الكومة غير الفارغة الأكثر يسارًا\n * إلى الكومة المجاورة على اليمين. الشخص الذي لا يمكنه سوى نقل الحجارة في الكومة الأخيرة يخسر. بافتراض اللعب المثالي، حدد الفائز.\n *\n * >>> f_35(3, {1, 2, 2})\n * \"Dan\"\n */\nconst char* f_35(int n, const int piles[])", "sw": "#include <cassert>\n#include <iostream>\n/**\n * Ukipewa mlolongo wa mirundo N ya mawe iliyohesabiwa kutoka 1 hadi N, kila moja ikiwa na idadi chanya ya mawe, tambua mshindi\n * wa mchezo unaochezwa na Charlie na Dan. Charlie anaanza, wakibadilishana zamu na Dan kuhamisha mawe kutoka kwenye rundo la kwanza lisilo tupu\n * kwenda kwenye rundo la kulia lililo karibu. Yule ambaye anaweza tu kuhamisha mawe kwenye rundo la mwisho anapoteza. Ukizingatia uchezaji mkamilifu, pata mshindi.\n *\n * >>> f_35(3, {1, 2, 2})\n * \"Dan\"\n */\nconst char* f_35(int n, const int piles[])", "tr": "#include <cassert>\n#include <iostream>\n/**\n * 1'den N'e kadar numaralandırılmış N taş yığını dizisi verildiğinde, her biri pozitif sayıda taş içeren, Charlie ve Dan tarafından oynanan bir oyunun kazananını belirleyin.\n * Charlie başlar, Dan ile sırayla taşları en soldaki boş olmayan yığından bitişik sağ yığına taşır.\n * Sadece son yığındaki taşları hareket ettirebilen kişi kaybeder. Mükemmel oyun varsayılarak, kazananı bulun.\n *\n * >>> f_35(3, {1, 2, 2})\n * \"Dan\"\n */\nconst char* f_35(int n, const int piles[])", "vi": "#include <cassert>\n#include <iostream>\n/**\n * Cho một dãy N đống đá được đánh số từ 1 đến N, mỗi đống chứa một số lượng đá dương, xác định người chiến thắng\n * của một trò chơi được chơi bởi Charlie và Dan. Charlie bắt đầu, lần lượt với Dan di chuyển đá từ đống không trống bên trái nhất\n * sang đống bên phải liền kề. Người chỉ có thể di chuyển đá trong đống cuối cùng sẽ thua. Giả sử chơi hoàn hảo, tìm người chiến thắng.\n *\n * >>> f_35(3, {1, 2, 2})\n * \"Dan\"\n */\nconst char* f_35(int n, const int piles[])", "id": "#include <cassert>\n#include <iostream>\n/**\n * Diberikan urutan N tumpukan batu bernomor dari 1 hingga N, masing-masing berisi sejumlah batu positif, tentukan pemenang\n * dari permainan yang dimainkan oleh Charlie dan Dan. Charlie memulai, bergantian dengan Dan memindahkan batu dari tumpukan paling kiri yang tidak kosong\n * ke tumpukan kanan yang berdekatan. Orang yang hanya dapat memindahkan batu di tumpukan terakhir kalah. Dengan asumsi permainan sempurna, temukan pemenangnya.\n *\n * >>> f_35(3, {1, 2, 2})\n * \"Dan\"\n */\nconst char* f_35(int n, const int piles[])", "ja": "#include <cassert>\n#include <iostream>\n/**\n * 1からNまで番号が振られたN個の石の山の列が与えられ、それぞれが正の数の石を含んでいます。チャーリーとダンがプレイするゲームの勝者を決定します。\n * チャーリーがスタートし、ダンと交互に左端の空でない山から隣の右の山へ石を移動します。\n * 最後の山でしか石を動かせない人が負けます。完璧なプレイを仮定して、勝者を見つけてください。\n *\n * >>> f_35(3, {1, 2, 2})\n * \"Dan\"\n */\nconst char* f_35(int n, const int piles[])", "ko": "#include <cassert>\n#include <iostream>\n/**\n * 1부터 N까지 번호가 매겨진 N개의 돌무더기 시퀀스가 주어졌을 때, 각 무더기에는 양의 개수의 돌이 들어 있습니다. Charlie와 Dan이 하는 게임의 승자를 결정합니다.\n * Charlie가 시작하며, Dan과 번갈아 가며 가장 왼쪽의 빈 무더기에서 인접한 오른쪽 무더기로 돌을 옮깁니다. 마지막 무더기에서만 돌을 옮길 수 있는 사람이 패배합니다. 완벽한 플레이를 가정하고 승자를 찾습니다.\n *\n * >>> f_35(3, {1, 2, 2})\n * \"Dan\"\n */\nconst char* f_35(int n, const int piles[])", "ml": "#include <cassert>\n#include <iostream>\n/**\n * 1 മുതൽ N വരെ നമ്പർ ചെയ്ത N കൂമ്പാര കല്ലുകളുടെ ഒരു നിര നൽകിയാൽ, ഓരോ കൂമ്പാരവും കല്ലുകളുടെ ഒരു പോസിറ്റീവ് സംഖ്യ അടങ്ങിയിരിക്കുന്നു, ചാർളിയും ഡാനും കളിക്കുന്ന ഒരു ഗെയിമിന്റെ വിജയിയെ നിർണ്ണയിക്കുക.\n * ചാർളി ആരംഭിക്കുന്നു, ഡാനുമായി മാറി മാറി ഇടതുവശത്തെ ഒഴിഞ്ഞുകിടക്കുന്ന കൂമ്പാരത്തിൽ നിന്ന് കല്ലുകൾ അടുത്ത വലതുവശത്തെ കൂമ്പാരത്തിലേക്ക് നീക്കുന്നു. അവസാന കൂമ്പാരത്തിൽ മാത്രം കല്ലുകൾ നീക്കാൻ കഴിയുന്നയാൾ തോൽക്കും. പൂർണ്ണമായ കളി കണക്കിലെടുത്ത്, വിജയിയെ കണ്ടെത്തുക.\n *\n * >>> f_35(3, {1, 2, 2})\n * \"Dan\"\n */\nconst char* f_35(int n, const int piles[])", "fa": "#include <cassert>\n#include <iostream>\n/**\n * با توجه به دنباله‌ای از N توده سنگ شماره‌گذاری شده از 1 تا N، که هر کدام شامل تعداد مثبتی از سنگ‌ها هستند، برنده\n * بازی که توسط چارلی و دن انجام می‌شود را تعیین کنید. چارلی شروع می‌کند و نوبت به دن می‌رسد که سنگ‌ها را از توده\n * غیرخالی سمت چپ به توده مجاور سمت راست حرکت دهند. کسی که فقط می‌تواند سنگ‌ها را در توده آخر حرکت دهد، می‌بازد.\n * با فرض بازی کامل، برنده را پیدا کنید.\n *\n * >>> f_35(3, {1, 2, 2})\n * \"Dan\"\n */\nconst char* f_35(int n, const int piles[])"}, "canonical_solution": "{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}", "instruction": {"en": "Write a CPP function `const char* f_35(int n, const int piles[])` to solve the following problem:\nGiven a sequence of N piles of stones numbered from 1 to N, each containing a positive number of stones, determine the winner of a game played by Charlie and Dan. Charlie starts, taking turns with Dan moving stones from the leftmost non-empty pile to the adjacent right pile. The one who can only move stones in the last pile loses. Assuming perfect play, find the winner.\n\n>>> f_35(3, {1, 2, 2})\n\"Dan\"\n", "sq": "Shkruani një funksion CPP `const char* f_35(int n, const int piles[])` për të zgjidhur problemin e mëposhtëm:\nDuke pasur një sekuencë prej N grumbujsh gurësh të numëruar nga 1 deri në N, secili që përmban një numër pozitiv gurësh, përcaktoni fituesin e një loje të luajtur nga Charlie dhe Dan. Charlie fillon, duke marrë radhën me Dan duke lëvizur gurë nga grumbulli më i majtë jo bosh në grumbullin fqinj në të djathtë. Ai që mund të lëvizë gurë vetëm në grumbullin e fundit humbet. Duke supozuar lojë të përsosur, gjeni fituesin.\n\n>>> f_35(3, {1, 2, 2})\n\"Dan\"", "hy": "Գրեք CPP ֆունկցիա `const char* f_35(int n, const int piles[])` հետևյալ խնդիրը լուծելու համար:\nՈւնենալով N քարերի կույտերի հաջորդականություն, որոնք համարակալված են 1-ից N, և որոնցից յուրաքանչյուրում կա քարերի դրական քանակ, որոշեք խաղի հաղթողին, որը խաղում են Չարլին և Դենը: Չարլին սկսում է, հերթափոխով Դենի հետ տեղափոխելով քարերը ձախից ամենաառաջին ոչ դատարկ կույտից դեպի հարևան աջ կույտ: Նա, ով կարող է միայն տեղափոխել քարերը վերջին կույտում, պարտվում է: Ենթադրելով կատարյալ խաղ, գտեք հաղթողին:\n\n>>> f_35(3, {1, 2, 2})\n\"Dan\"", "bn": "একটি CPP ফাংশন `const char* f_35(int n, const int piles[])` লিখুন নিম্নলিখিত সমস্যার সমাধান করতে: \nএকটি N পাথরের স্তূপের ক্রম দেওয়া হয়েছে, যা 1 থেকে N পর্যন্ত নম্বরযুক্ত, প্রতিটি স্তূপে একটি ধনাত্মক সংখ্যক পাথর রয়েছে, চার্লি এবং ড্যান দ্বারা খেলা একটি গেমের বিজয়ী নির্ধারণ করুন। চার্লি শুরু করে, ড্যানের সাথে পালাক্রমে বামদিকের প্রথম খালি নয় এমন স্তূপ থেকে ডানদিকে সংলগ্ন স্তূপে পাথর সরিয়ে নেয়। যে ব্যক্তি কেবলমাত্র শেষ স্তূপে পাথর সরাতে পারে সে হেরে যায়। নিখুঁত খেলার ধরণ ধরে, বিজয়ী নির্ধারণ করুন।\n\n>>> f_35(3, {1, 2, 2})\n\"Dan\"", "bg": "Напишете функция на CPP `const char* f_35(int n, const int piles[])`, за да решите следния проблем:  \nДадена е последователност от N купчини камъни, номерирани от 1 до N, всяка съдържаща положителен брой камъни. Определете победителя в игра, играна от Чарли и Дан. Чарли започва, като се редува с Дан, премествайки камъни от най-лявата непразна купчина към съседната дясна купчина. Този, който може да премести камъни само в последната купчина, губи. Приемайки перфектна игра, намерете победителя.\n\n>>> f_35(3, {1, 2, 2})  \n\"Dan\"", "zh": "编写一个 CPP 函数 `const char* f_35(int n, const int piles[])` 来解决以下问题：  \n给定一个由 N 堆石头组成的序列，从 1 到 N 编号，每堆包含一个正数的石头，确定由 Charlie 和 Dan 玩的游戏的获胜者。Charlie 先开始，与 Dan 轮流从最左边的非空堆中移动石头到相邻的右边堆。只能在最后一堆中移动石头的人输掉比赛。在假设完美游戏的情况下，找出获胜者。", "fr": "Écrire une fonction CPP `const char* f_35(int n, const int piles[])` pour résoudre le problème suivant :  \nÉtant donné une séquence de N piles de pierres numérotées de 1 à N, chacune contenant un nombre positif de pierres, déterminer le gagnant d'un jeu joué par Charlie et Dan. Charlie commence, prenant des tours avec Dan en déplaçant des pierres de la pile la plus à gauche non vide vers la pile adjacente à droite. Celui qui ne peut déplacer des pierres que dans la dernière pile perd. En supposant un jeu parfait, trouver le gagnant.", "de": "Schreiben Sie eine CPP-Funktion `const char* f_35(int n, const int piles[])`, um das folgende Problem zu lösen:\nGegeben ist eine Sequenz von N Steinhaufen, nummeriert von 1 bis N, wobei jeder Haufen eine positive Anzahl von Steinen enthält. Bestimmen Sie den Gewinner eines Spiels, das von Charlie und Dan gespielt wird. Charlie beginnt und wechselt sich mit Dan ab, indem er Steine vom linken, nicht leeren Haufen zum angrenzenden rechten Haufen bewegt. Derjenige, der nur noch Steine im letzten Haufen bewegen kann, verliert. Bei perfektem Spiel finden Sie den Gewinner.", "ha": "Rubuta aikin CPP `const char* f_35(int n, const int piles[])` don warware matsalar mai zuwa:  \nAn ba da jerin N na tarin duwatsu da aka lissafa daga 1 zuwa N, kowanne yana dauke da adadin duwatsu masu kyau, gano wanda ya lashe wasan da Charlie da Dan suka buga. Charlie yana farawa, yana daukar matakai tare da Dan suna motsa duwatsu daga mafi hagu wanda ba komai ba zuwa tarin dama kusa. Wanda zai iya motsa duwatsu kawai a cikin tarin karshe ya rasa. Ana tsammanin wasa mai kyau, gano wanda ya lashe.", "hi": "एक CPP फ़ंक्शन `const char* f_35(int n, const int piles[])` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए पत्थरों के N ढेरों की एक अनुक्रमिक श्रृंखला, जो 1 से N तक क्रमांकित हैं, प्रत्येक में सकारात्मक संख्या में पत्थर हैं, यह निर्धारित करें कि चार्ली और डैन द्वारा खेले गए खेल का विजेता कौन है। चार्ली शुरू करता है, डैन के साथ बारी-बारी से बाएं से दाएं सबसे पहले गैर-खाली ढेर से पत्थरों को पास के दाएं ढेर में ले जाता है। जो केवल अंतिम ढेर में पत्थरों को ले जा सकता है, वह हार जाता है। पूर्ण खेल मानते हुए, विजेता का पता लगाएं।\n\n>>> f_35(3, {1, 2, 2})\n\"Dan\"", "hu": "Írj egy CPP függvényt `const char* f_35(int n, const int piles[])` a következő probléma megoldására:\nAdott egy N kövekből álló halom sorozat, amelyeket 1-től N-ig számoztak, mindegyik pozitív számú követ tartalmaz. Határozd meg a nyertesét egy játéknak, amelyet Charlie és Dan játszanak. Charlie kezd, felváltva Dan-nel köveket mozgatva a bal szélső nem üres halomból a szomszédos jobb halomba. Az veszít, aki csak az utolsó halomban tud köveket mozgatni. Tökéletes játékot feltételezve, találd meg a nyertest.\n\n>>> f_35(3, {1, 2, 2})\n\"Dan\"", "es": "Escribe una función CPP `const char* f_35(int n, const int piles[])` para resolver el siguiente problema:\nDada una secuencia de N pilas de piedras numeradas del 1 al N, cada una conteniendo un número positivo de piedras, determina el ganador de un juego jugado por Charlie y Dan. Charlie empieza, turnándose con Dan moviendo piedras de la pila más a la izquierda no vacía a la pila adyacente a la derecha. El que solo pueda mover piedras en la última pila pierde. Asumiendo un juego perfecto, encuentra al ganador.\n\n>>> f_35(3, {1, 2, 2})\n\"Dan\"", "arb": "اكتب دالة CPP `const char* f_35(int n, const int piles[])` لحل المشكلة التالية:\nبالنظر إلى تسلسل من N أكوام من الحجارة مرقمة من 1 إلى N، كل منها يحتوي على عدد موجب من الحجارة، حدد الفائز في لعبة يلعبها تشارلي ودان. يبدأ تشارلي، بالتناوب مع دان في نقل الحجارة من الكومة غير الفارغة الأكثر يسارًا إلى الكومة المجاورة على اليمين. الشخص الذي يمكنه فقط نقل الحجارة في الكومة الأخيرة يخسر. بافتراض اللعب المثالي، حدد الفائز.\n\n>>> f_35(3, {1, 2, 2})\n\"Dan\"", "sw": "Andika kazi ya CPP `const char* f_35(int n, const int piles[])` kutatua tatizo lifuatalo:\nUkipatiwa mlolongo wa mirundo N ya mawe iliyo na namba kutoka 1 hadi N, kila moja ikiwa na idadi chanya ya mawe, bainisha mshindi wa mchezo unaochezwa na Charlie na Dan. Charlie anaanza, wakibadilishana zamu na Dan kuhamisha mawe kutoka kwenye rundo la kwanza lisilo tupu kwenda kwenye rundo la kulia lililo karibu. Yule ambaye anaweza tu kuhamisha mawe kwenye rundo la mwisho anapoteza. Kwa kudhani uchezaji mkamilifu, tafuta mshindi.\n\n>>> f_35(3, {1, 2, 2})\n\"Dan\"", "tr": "Bir CPP fonksiyonu `const char* f_35(int n, const int piles[])` yazın ve aşağıdaki problemi çözün:\n1'den N'ye kadar numaralandırılmış, her biri pozitif sayıda taş içeren N taş yığını dizisi verildiğinde, Charlie ve Dan tarafından oynanan bir oyunun kazananını belirleyin. Charlie başlar ve Dan ile sırayla taşları en soldaki boş olmayan yığından bitişik sağdaki yığına taşır. Sadece son yığındaki taşları hareket ettirebilen kişi kaybeder. Mükemmel oyun varsayıldığında, kazananı bulun.\n\n>>> f_35(3, {1, 2, 2})\n\"Dan\"", "vi": "Viết một hàm CPP `const char* f_35(int n, const int piles[])` để giải quyết vấn đề sau:  \nCho một dãy N đống đá được đánh số từ 1 đến N, mỗi đống chứa một số lượng đá dương, xác định người chiến thắng của trò chơi được chơi bởi Charlie và Dan. Charlie bắt đầu, lần lượt với Dan di chuyển đá từ đống không trống bên trái nhất sang đống liền kề bên phải. Người chỉ có thể di chuyển đá trong đống cuối cùng sẽ thua. Giả sử chơi hoàn hảo, tìm người chiến thắng.\n\n>>> f_35(3, {1, 2, 2})\n\"Dan\"", "id": "Tulis fungsi CPP `const char* f_35(int n, const int piles[])` untuk menyelesaikan masalah berikut:\nDiberikan urutan N tumpukan batu yang diberi nomor dari 1 hingga N, masing-masing berisi sejumlah batu positif, tentukan pemenang dari permainan yang dimainkan oleh Charlie dan Dan. Charlie memulai, bergantian dengan Dan memindahkan batu dari tumpukan paling kiri yang tidak kosong ke tumpukan kanan yang berdekatan. Orang yang hanya dapat memindahkan batu di tumpukan terakhir kalah. Dengan asumsi permainan sempurna, temukan pemenangnya.\n\n>>> f_35(3, {1, 2, 2})\n\"Dan\"", "ja": "以下の問題を解くために、CPP関数 `const char* f_35(int n, const int piles[])` を作成しなさい:\n1からNまで番号が付けられたN個の石の山があり、それぞれが正の数の石を含んでいます。チャーリーとダンがプレイするゲームの勝者を決定します。チャーリーが開始し、ダンと交互に左端の空でない山から隣接する右の山に石を移動します。最後の山でしか石を動かせない人が負けます。完全なプレイを仮定して、勝者を見つけなさい。\n\n>>> f_35(3, {1, 2, 2})\n\"Dan\"", "ko": "CPP 함수 `const char* f_35(int n, const int piles[])`를 작성하여 다음 문제를 해결하십시오:\n1부터 N까지 번호가 매겨진 N개의 돌 더미가 주어졌을 때, 각 더미에는 양의 개수의 돌이 포함되어 있습니다. Charlie와 Dan이 플레이하는 게임의 승자를 결정하십시오. Charlie가 시작하며, Dan과 번갈아 가며 가장 왼쪽의 비어 있지 않은 더미에서 인접한 오른쪽 더미로 돌을 옮깁니다. 마지막 더미에서만 돌을 옮길 수 있는 사람이 패배합니다. 완벽한 플레이를 가정하여 승자를 찾으십시오.\n\n>>> f_35(3, {1, 2, 2})\n\"Dan\"", "ml": "ഒരു സിപിപി ഫംഗ്ഷൻ എഴുതുക `const char* f_35(int n, const int piles[])` ഈ പ്രശ്നം പരിഹരിക്കാൻ:\n1 മുതൽ N വരെ നമ്പർ ചെയ്ത N കൂമ്പാരങ്ങളുള്ള ഒരു നിര നൽകിയിരിക്കുന്നു, ഓരോന്നും ഒരു പോസിറ്റീവ് എണ്ണം കല്ലുകൾ അടങ്ങിയിരിക്കുന്നു, ചാർളിയും ഡാനും കളിക്കുന്ന ഒരു ഗെയിമിന്റെ വിജയിയെ നിർണയിക്കുക. ചാർളി ആരംഭിക്കുന്നു, ഡാനുമായി മാറി മാറി ഇടതുവശത്തെ ശൂന്യമല്ലാത്ത കൂമ്പാരത്തിൽ നിന്ന് സമീപമുള്ള വലതുവശത്തെ കൂമ്പാരത്തിലേക്ക് കല്ലുകൾ നീക്കുന്നു. അവസാന കൂമ്പാരത്തിൽ മാത്രം കല്ലുകൾ നീക്കാൻ കഴിയുന്നയാൾ തോൽക്കും. പൂർണ്ണമായ കളി പരിഗണിച്ച്, വിജയിയെ കണ്ടെത്തുക.\n\n>>> f_35(3, {1, 2, 2})\n\"Dan\"", "fa": "یک تابع CPP به نام `const char* f_35(int n, const int piles[])` بنویسید تا مسئله زیر را حل کند:\nبا توجه به دنباله‌ای از N توده سنگ شماره‌گذاری شده از 1 تا N، که هر کدام شامل تعداد مثبتی از سنگ‌ها هستند، برنده بازی که توسط چارلی و دن انجام می‌شود را تعیین کنید. چارلی شروع می‌کند و به نوبت با دن، سنگ‌ها را از توده غیرخالی سمت چپ به توده مجاور راست منتقل می‌کنند. کسی که فقط می‌تواند سنگ‌ها را در توده آخر حرکت دهد، بازنده است. با فرض بازی کامل، برنده را پیدا کنید.\n\n>>> f_35(3, {1, 2, 2})\n\"Dan\""}, "level": "middle", "test": "int main() {\n    int test1[] = {1, 2, 2};\n    int test2[] = {5, 5, 5, 5, 5};\n    int test3[] = {2, 1, 2};\n    int test4[] = {3, 3, 3, 3};\n    int test5[] = {1, 1};\n    int test6[] = {2, 1};\n    int test7[] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};\n    int test8[] = {2, 2, 2, 2, 2, 2, 2, 2, 2, 1};\n    int test9[] = {10, 10, 10, 10, 10, 10, 10, 10, 10, 10};\n    int test10[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n\n    assert(std::string(f_35(3, test1)) == \"Dan\");\n    assert(std::string(f_35(5, test2)) == \"Charlie\");\n    assert(std::string(f_35(3, test3)) == \"Charlie\");\n    assert(std::string(f_35(4, test4)) == \"Charlie\");\n    assert(std::string(f_35(2, test5)) == \"Charlie\");\n    assert(std::string(f_35(2, test6)) == \"Charlie\");\n    assert(std::string(f_35(11, test7)) == \"Dan\");\n    assert(std::string(f_35(10, test8)) == \"Charlie\");\n    assert(std::string(f_35(10, test9)) == \"Charlie\");\n    assert(std::string(f_35(10, test10)) == \"Dan\");\n\n    return 0;\n}", "entry_point": "f_35", "signature": "const char* f_35(int n, const int piles[])", "docstring": {"en": "Given a sequence of N piles of stones numbered from 1 to N, each containing a positive number of stones, determine the winner of a game played by Charlie and Dan. Charlie starts, taking turns with Dan moving stones from the leftmost non-empty pile to the adjacent right pile. The one who can only move stones in the last pile loses. Assuming perfect play, find the winner.\n\n>>> f_35(3, {1, 2, 2})\n\"Dan\"\n", "sq": "Duke pasur një sekuencë prej N grumbujsh gurësh të numëruar nga 1 deri në N, secili që përmban një numër pozitiv gurësh, përcaktoni fituesin e një loje të luajtur nga Charlie dhe Dan. Charlie fillon, duke marrë radhë me Dan për të lëvizur gurët nga grumbulli më i majtë jo bosh në grumbullin fqinj në të djathtë. Ai që mund të lëvizë gurë vetëm në grumbullin e fundit humbet. Duke supozuar lojë të përsosur, gjeni fituesin.\n\n>>> f_35(3, {1, 2, 2})\n\"Dan\"", "hy": "Տրված է N քանակությամբ քարերի կույտերի հաջորդականություն, որոնք համարակալված են 1-ից N, և յուրաքանչյուրում կա քարերի դրական քանակ: Պարզեք խաղի հաղթողին, որը խաղում են Չարլին և Դենը: Չարլին սկսում է, հերթով Դենի հետ տեղափոխելով քարերը ձախից ամենահեռու չդատարկ կույտից դեպի հարևան աջ կույտը: Նա, ով կարող է միայն տեղափոխել քարերը վերջին կույտում, պարտվում է: Ենթադրելով կատարյալ խաղ, գտեք հաղթողին:\n\n>>> f_35(3, {1, 2, 2})\n\"Dan\"", "bn": "N সংখ্যক পাথরের স্তূপের একটি ক্রম দেওয়া হয়েছে, যা 1 থেকে N পর্যন্ত নম্বরযুক্ত, প্রতিটি স্তূপে একটি ধনাত্মক সংখ্যক পাথর রয়েছে। চার্লি এবং ড্যানের মধ্যে একটি খেলা খেলে বিজয়ী নির্ধারণ করুন। চার্লি শুরু করে, ড্যানের সাথে পালাক্রমে বামদিকের প্রথম খালি নয় এমন স্তূপ থেকে ডানদিকে সংলগ্ন স্তূপে পাথর সরিয়ে নেয়। যে ব্যক্তি কেবলমাত্র শেষ স্তূপে পাথর সরাতে পারে সে হেরে যায়। নিখুঁত খেলার অনুমান করে, বিজয়ী নির্ধারণ করুন।\n\n>>> f_35(3, {1, 2, 2})\n\"Dan\"", "bg": "Дадена е последователност от N купчини камъни, номерирани от 1 до N, всяка съдържаща положителен брой камъни, определете победителя в игра, играна от Чарли и Дан. Чарли започва, като се редува с Дан да мести камъни от най-лявата непразна купчина към съседната дясна купчина. Този, който може да мести камъни само в последната купчина, губи. Предполага се перфектна игра, намерете победителя.\n\n>>> f_35(3, {1, 2, 2})\n\"Dan\"", "zh": "给定一个编号从1到N的石堆序列，每堆包含一个正数的石头，确定由Charlie和Dan进行的游戏的获胜者。Charlie开始，与Dan轮流从最左边的非空堆移动石头到相邻的右边堆。只能在最后一堆移动石头的人输。假设完美游戏，找出获胜者。\n\n>>> f_35(3, {1, 2, 2})\n\"Dan\"", "fr": "Étant donné une séquence de N tas de pierres numérotés de 1 à N, chacun contenant un nombre positif de pierres, déterminez le gagnant d'un jeu joué par Charlie et Dan. Charlie commence, prenant des tours avec Dan pour déplacer des pierres du tas le plus à gauche non vide vers le tas adjacent à droite. Celui qui ne peut déplacer des pierres que dans le dernier tas perd. En supposant un jeu parfait, trouvez le gagnant.\n\n>>> f_35(3, {1, 2, 2})\n\"Dan\"", "de": "Gegeben eine Sequenz von N Steinhaufen, nummeriert von 1 bis N, wobei jeder Haufen eine positive Anzahl von Steinen enthält, bestimmen Sie den Gewinner eines Spiels, das von Charlie und Dan gespielt wird. Charlie beginnt und zieht abwechselnd mit Dan Steine vom linken, nicht leeren Haufen zum benachbarten rechten Haufen. Derjenige, der nur noch Steine im letzten Haufen bewegen kann, verliert. Angenommen, es wird perfekt gespielt, finden Sie den Gewinner.\n\n>>> f_35(3, {1, 2, 2})\n\"Dan\"", "ha": "An ba da jerin N na tarin duwatsu da aka lissafa daga 1 zuwa N, kowanne yana dauke da adadin duwatsu masu kyau, a tantance wanda zai ci wasa da Charlie da Dan suka buga. Charlie yana farawa, yana juyawa tare da Dan suna motsa duwatsu daga tarin da ba komai a hagu zuwa tarin da ke makwabta a dama. Wanda zai iya motsa duwatsu a cikin tarin karshe kadai zai sha kaye. Ana tsammanin wasa mai kyau, gano wanda zai ci.\n\n>>> f_35(3, {1, 2, 2})\n\"Dan\"", "hi": "N पत्थरों के ढेरों की एक अनुक्रमणिका दी गई है, जिन्हें 1 से N तक क्रमांकित किया गया है, प्रत्येक में पत्थरों की एक सकारात्मक संख्या है। चार्ली और डैन द्वारा खेले गए एक खेल के विजेता का निर्धारण करें। चार्ली शुरू करता है, डैन के साथ बारी-बारी से बाएं से दाएं सबसे निकटतम गैर-खाली ढेर से पत्थरों को दाएं सटे हुए ढेर में ले जाता है। जो केवल अंतिम ढेर में पत्थरों को ले जा सकता है, वह हार जाता है। पूर्ण खेल मानते हुए, विजेता का पता लगाएं।\n\n>>> f_35(3, {1, 2, 2})\n\"Dan\"", "hu": "Adott egy N kövekből álló halom sorozat, amelyeket 1-től N-ig számoztak, mindegyik pozitív számú követ tartalmaz. Határozza meg a Charlie és Dan által játszott játék győztesét. Charlie kezd, felváltva Dan-nel, köveket mozgatva a bal szélső nem üres halomból a szomszédos jobb halomba. Az veszít, aki csak az utolsó halomban tud köveket mozgatni. Tökéletes játékot feltételezve, találja meg a győztest.\n\n>>> f_35(3, {1, 2, 2})\n\"Dan\"", "es": "Dada una secuencia de N pilas de piedras numeradas del 1 al N, cada una conteniendo un número positivo de piedras, determina el ganador de un juego jugado por Charlie y Dan. Charlie comienza, turnándose con Dan moviendo piedras de la pila más a la izquierda no vacía a la pila adyacente a la derecha. El que solo pueda mover piedras en la última pila pierde. Suponiendo un juego perfecto, encuentra al ganador.\n\n>>> f_35(3, {1, 2, 2})\n\"Dan\"", "arb": "بالنظر إلى تسلسل من N أكوام من الحجارة مرقمة من 1 إلى N، كل منها يحتوي على عدد موجب من الحجارة، حدد الفائز في لعبة يلعبها تشارلي ودان. يبدأ تشارلي، بالتناوب مع دان في نقل الحجارة من الكومة غير الفارغة الأكثر يسارًا إلى الكومة المجاورة على اليمين. الشخص الذي لا يمكنه سوى نقل الحجارة في الكومة الأخيرة يخسر. بافتراض اللعب المثالي، حدد الفائز.\n\n>>> f_35(3, {1, 2, 2})\n\"Dan\"", "sw": "Kwa kupewa mlolongo wa marundo N ya mawe yaliyoorodheshwa kutoka 1 hadi N, kila moja ikiwa na idadi chanya ya mawe, amua mshindi wa mchezo unaochezwa na Charlie na Dan. Charlie anaanza, wakibadilishana zamu na Dan kuhamisha mawe kutoka kwenye rundo la kwanza lenye mawe kwenda kwenye rundo la kulia lililo karibu. Yule ambaye anaweza tu kuhamisha mawe kwenye rundo la mwisho anapoteza. Tukichukulia uchezaji mkamilifu, tafuta mshindi.\n\n>>> f_35(3, {1, 2, 2})\n\"Dan\"", "tr": "Taşlardan oluşan N yığınından oluşan bir diziliş verildiğinde, her biri pozitif sayıda taş içeren ve 1'den N'e kadar numaralandırılmış olan, Charlie ve Dan tarafından oynanan bir oyunun kazananını belirleyin. Charlie başlar, Dan ile sırayla taşları en soldaki boş olmayan yığından bitişik sağ yığına taşır. Sadece son yığındaki taşları hareket ettirebilen kişi kaybeder. Mükemmel oyun varsayıldığında, kazananı bulun.\n\n>>> f_35(3, {1, 2, 2})\n\"Dan\"", "vi": "Cho một dãy N đống đá được đánh số từ 1 đến N, mỗi đống chứa một số lượng đá dương, xác định người chiến thắng của trò chơi được chơi bởi Charlie và Dan. Charlie bắt đầu, lần lượt với Dan di chuyển đá từ đống không rỗng bên trái nhất sang đống liền kề bên phải. Người chỉ có thể di chuyển đá trong đống cuối cùng sẽ thua. Giả sử chơi hoàn hảo, tìm người chiến thắng.\n\n>>> f_35(3, {1, 2, 2})\n\"Dan\"", "id": "Diberikan urutan N tumpukan batu yang diberi nomor dari 1 hingga N, masing-masing berisi sejumlah batu positif, tentukan pemenang dari permainan yang dimainkan oleh Charlie dan Dan. Charlie mulai, bergantian dengan Dan memindahkan batu dari tumpukan paling kiri yang tidak kosong ke tumpukan sebelah kanan yang berdekatan. Orang yang hanya dapat memindahkan batu di tumpukan terakhir kalah. Dengan asumsi permainan sempurna, temukan pemenangnya.\n\n>>> f_35(3, {1, 2, 2})\n\"Dan\"", "ja": "与えられたN個の石の山の列が1からNまで番号付けされており、それぞれが正の数の石を含んでいるとします。チャーリーとダンによって行われるゲームの勝者を決定します。チャーリーが開始し、ダンと交互に左端の空でない山から隣接する右の山に石を移動します。最後の山でしか石を動かせない者が負けます。完璧なプレイを仮定して、勝者を見つけてください。\n\n>>> f_35(3, {1, 2, 2})\n\"Dan\"", "ko": "돌무더기 게임 설명:\n\nN개의 돌무더기가 1부터 N까지 번호가 매겨져 있으며, 각 무더기에는 양의 개수의 돌이 들어 있습니다. Charlie와 Dan이 번갈아 가며 게임을 진행하는데, Charlie가 먼저 시작합니다. 각 턴마다 왼쪽에서 가장 가까운 비어 있지 않은 돌무더기에서 인접한 오른쪽 돌무더기로 돌을 옮깁니다. 마지막 돌무더기에서만 돌을 옮길 수 있는 상황이 되면 그 플레이어가 패배합니다. 두 플레이어 모두 최적의 플레이를 한다고 가정했을 때, 승자를 결정하세요.\n\n>>> f_35(3, {1, 2, 2})\n\"Dan\"", "ml": "N കല്ലുകളുടെ കൂമ്പാരങ്ങളുടെ ഒരു നിര നൽകിയിരിക്കുന്നു, ഓരോന്നും 1 മുതൽ N വരെ നമ്പർ ചെയ്തിരിക്കുന്നു, ഓരോന്നും ഒരു പോസിറ്റീവ് കല്ലുകളുടെ എണ്ണം ഉൾക്കൊള്ളുന്നു, ചാർളിയും ഡാനും കളിക്കുന്ന ഒരു ഗെയിമിന്റെ വിജയിയെ നിർണ്ണയിക്കുക. ചാർളി ആരംഭിക്കുന്നു, ഡാനുമായി മാറി മാറി ഇടതുവശത്തുള്ള ശൂന്യമല്ലാത്ത കൂമ്പാരത്തിൽ നിന്ന് അടുത്ത വലതുവശത്തുള്ള കൂമ്പാരത്തിലേക്ക് കല്ലുകൾ നീക്കുന്നു. അവസാന കൂമ്പാരത്തിൽ മാത്രം കല്ലുകൾ നീക്കാൻ കഴിയുന്നയാൾ തോൽക്കും. പൂർണ്ണമായ കളി കണക്കിലെടുത്ത്, വിജയിയെ കണ്ടെത്തുക.\n\n>>> f_35(3, {1, 2, 2})\n\"Dan\"", "fa": "با توجه به دنباله‌ای از N توده سنگ شماره‌گذاری شده از 1 تا N، که هر کدام شامل تعداد مثبتی از سنگ‌ها هستند، برنده بازی که توسط چارلی و دن بازی می‌شود را تعیین کنید. چارلی شروع می‌کند و به نوبت با دن، سنگ‌ها را از توده غیرخالی سمت چپ به توده مجاور سمت راست حرکت می‌دهد. کسی که فقط می‌تواند سنگ‌ها را در توده آخر حرکت دهد، بازنده است. با فرض بازی کامل، برنده را پیدا کنید.\n\n>>> f_35(3, {1, 2, 2})\n\"Dan\""}}
{"task_id": "CPP/36", "prompt": {"en": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * @doc\n * Given n doors arranged in a circle, the player starts in front of door 1.\n * Each turn, the player can choose a number i and pay a cost C_i to move i steps to the right\n * and then open the door at that position. It is guaranteed that C_i >= C_{i+1} for 1 <= i < n.\n * The task is to determine the minimum total cost required to open all doors.\n *\n * Example:\n *     >>> f_36(3, (1, 1, 1))\n *     3\n */\nlong long f_36(int n, const std::vector<int>& C)", "sq": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * @doc\n * Duke pasur parasysh n dyer të rregulluara në një rreth, lojtari fillon përpara derës 1.\n * Çdo radhë, lojtari mund të zgjedhë një numër i dhe të paguajë një kosto C_i për të lëvizur i hapa në të djathtë\n * dhe pastaj të hapë derën në atë pozicion. Është e garantuar që C_i >= C_{i+1} për 1 <= i < n.\n * Detyra është të përcaktohet kostoja totale minimale e nevojshme për të hapur të gjitha dyert.\n *\n * Shembull:\n *     >>> f_36(3, (1, 1, 1))\n *     3\n */\nlong long f_36(int n, const std::vector<int>& C)", "hy": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * @doc\n * Տրված է n դռներ, որոնք դասավորված են շրջանաձև, խաղացողը սկսում է դուռ 1-ի դիմացից։\n * Յուրաքանչյուր քայլի, խաղացողը կարող է ընտրել թիվ i և վճարել արժեք C_i՝ i քայլ աջ շարժվելու համար\n * և ապա բացել այդ դիրքում գտնվող դուռը։ Երաշխավորված է, որ C_i >= C_{i+1} 1 <= i < n համար։\n * Խնդիրը կայանում է որոշել բոլոր դռները բացելու համար անհրաժեշտ նվազագույն ընդհանուր արժեքը։\n *\n * Օրինակ:\n *     >>> f_36(3, (1, 1, 1))\n *     3\n */\nlong long f_36(int n, const std::vector<int>& C)", "bn": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * @doc\n * একটি বৃত্তে সাজানো n টি দরজা দেওয়া আছে, খেলোয়াড় দরজা 1 এর সামনে থেকে শুরু করে।\n * প্রতিটি পালায়, খেলোয়াড় একটি সংখ্যা i বেছে নিতে পারে এবং i ধাপ ডানদিকে যেতে C_i খরচ দিতে পারে\n * এবং তারপর সেই অবস্থানের দরজা খুলতে পারে। এটি নিশ্চিত যে C_i >= C_{i+1} 1 <= i < n এর জন্য।\n * কাজটি হল সমস্ত দরজা খোলার জন্য প্রয়োজনীয় সর্বনিম্ন মোট খরচ নির্ধারণ করা।\n *\n * উদাহরণ:\n *     >>> f_36(3, (1, 1, 1))\n *     3\n */\nlong long f_36(int n, const std::vector<int>& C)", "bg": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * @doc\n * Дадени са n врати, подредени в кръг, играчът започва пред врата 1.\n * Всеки ход, играчът може да избере число i и да плати цена C_i, за да се премести i стъпки надясно\n * и след това да отвори вратата на тази позиция. Гарантирано е, че C_i >= C_{i+1} за 1 <= i < n.\n * Задачата е да се определи минималната обща цена, необходима за отваряне на всички врати.\n *\n * Пример:\n *     >>> f_36(3, (1, 1, 1))\n *     3\n */\nlong long f_36(int n, const std::vector<int>& C)", "zh": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * @doc\n * 给定 n 个门按圆形排列，玩家从门 1 前面开始。\n * 每回合，玩家可以选择一个数字 i 并支付代价 C_i 向右移动 i 步，\n * 然后打开当前位置的门。保证 C_i >= C_{i+1} 对于 1 <= i < n。\n * 任务是确定打开所有门所需的最小总成本。\n *\n * 示例:\n *     >>> f_36(3, (1, 1, 1))\n *     3\n */\nlong long f_36(int n, const std::vector<int>& C)", "fr": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * @doc\n * Étant donné n portes disposées en cercle, le joueur commence devant la porte 1.\n * À chaque tour, le joueur peut choisir un nombre i et payer un coût C_i pour avancer de i pas vers la droite\n * puis ouvrir la porte à cette position. Il est garanti que C_i >= C_{i+1} pour 1 <= i < n.\n * La tâche consiste à déterminer le coût total minimum nécessaire pour ouvrir toutes les portes.\n *\n * Exemple:\n *     >>> f_36(3, (1, 1, 1))\n *     3\n */\nlong long f_36(int n, const std::vector<int>& C)", "de": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * @doc\n * Gegeben sind n Türen, die in einem Kreis angeordnet sind, und der Spieler beginnt vor Tür 1.\n * In jedem Zug kann der Spieler eine Zahl i wählen und einen Kosten C_i zahlen, um i Schritte nach rechts zu gehen\n * und dann die Tür an dieser Position zu öffnen. Es ist garantiert, dass C_i >= C_{i+1} für 1 <= i < n.\n * Die Aufgabe besteht darin, die minimalen Gesamtkosten zu bestimmen, die erforderlich sind, um alle Türen zu öffnen.\n *\n * Beispiel:\n *     >>> f_36(3, (1, 1, 1))\n *     3\n */\nlong long f_36(int n, const std::vector<int>& C)", "ha": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * @doc\n * An ba wa ƙofofi n da aka shirya a cikin da'ira, ɗan wasa yana farawa a gaban ƙofa ta 1.\n * Kowanne juyawa, ɗan wasan na iya zaɓar lamba i kuma ya biya kuɗi C_i don matsawa matakai i zuwa dama\n * sannan ya buɗe ƙofar a wannan matsayi. An tabbatar da cewa C_i >= C_{i+1} don 1 <= i < n.\n * Aikin shi ne tantance mafi ƙarancin jimillar kuɗi da ake buƙata don buɗe duk ƙofofin.\n *\n * Misali:\n *     >>> f_36(3, (1, 1, 1))\n *     3\n */\nlong long f_36(int n, const std::vector<int>& C)", "hi": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * @doc\n * दिए गए n दरवाजे जो एक वृत्त में व्यवस्थित हैं, खिलाड़ी दरवाजा 1 के सामने से शुरू करता है।\n * प्रत्येक चाल में, खिलाड़ी एक संख्या i चुन सकता है और i कदम दाईं ओर जाने के लिए लागत C_i का भुगतान कर सकता है\n * और फिर उस स्थिति पर दरवाजा खोल सकता है। यह गारंटी है कि C_i >= C_{i+1} जहाँ 1 <= i < n।\n * कार्य यह निर्धारित करना है कि सभी दरवाजे खोलने के लिए न्यूनतम कुल लागत क्या होगी।\n *\n * उदाहरण:\n *     >>> f_36(3, (1, 1, 1))\n *     3\n */\nlong long f_36(int n, const std::vector<int>& C)", "hu": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * @doc\n * Adott n ajtó, amelyek körben vannak elrendezve, a játékos az 1-es ajtó előtt kezd.\n * Minden körben a játékos választhat egy i számot, és fizet egy C_i költséget, hogy i lépést tegyen jobbra,\n * majd kinyissa az ajtót az adott pozíción. Garantált, hogy C_i >= C_{i+1} minden 1 <= i < n esetén.\n * A feladat meghatározni a minimális összköltséget, amely szükséges az összes ajtó kinyitásához.\n *\n * Példa:\n *     >>> f_36(3, (1, 1, 1))\n *     3\n */\nlong long f_36(int n, const std::vector<int>& C)", "es": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * @doc\n * Dado n puertas dispuestas en un círculo, el jugador comienza frente a la puerta 1.\n * En cada turno, el jugador puede elegir un número i y pagar un costo C_i para moverse i pasos a la derecha\n * y luego abrir la puerta en esa posición. Se garantiza que C_i >= C_{i+1} para 1 <= i < n.\n * La tarea es determinar el costo total mínimo requerido para abrir todas las puertas.\n *\n * Ejemplo:\n *     >>> f_36(3, (1, 1, 1))\n *     3\n */\nlong long f_36(int n, const std::vector<int>& C)", "arb": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * @doc\n * بالنظر إلى n من الأبواب مرتبة في دائرة، يبدأ اللاعب أمام الباب 1.\n * في كل دور، يمكن للاعب اختيار رقم i ودفع تكلفة C_i للتحرك i خطوات إلى اليمين\n * ثم فتح الباب في ذلك الموقع. من المضمون أن C_i >= C_{i+1} لـ 1 <= i < n.\n * المهمة هي تحديد الحد الأدنى للتكلفة الإجمالية المطلوبة لفتح جميع الأبواب.\n *\n * مثال:\n *     >>> f_36(3, (1, 1, 1))\n *     3\n */\nlong long f_36(int n, const std::vector<int>& C)", "sw": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * @doc\n * Ukipewa milango n iliyopangwa katika mduara, mchezaji anaanza mbele ya mlango wa 1.\n * Kila zamu, mchezaji anaweza kuchagua namba i na kulipa gharama C_i ili kusonga hatua i kwenda kulia\n * na kisha kufungua mlango katika nafasi hiyo. Inahakikishwa kuwa C_i >= C_{i+1} kwa 1 <= i < n.\n * Kazi ni kubaini gharama ndogo kabisa inayohitajika kufungua milango yote.\n *\n * Mfano:\n *     >>> f_36(3, (1, 1, 1))\n *     3\n */\nlong long f_36(int n, const std::vector<int>& C)", "tr": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * @doc\n * Bir çember şeklinde düzenlenmiş n kapı verildiğinde, oyuncu kapı 1'in önünde başlar.\n * Her turda, oyuncu bir sayı i seçebilir ve i adım sağa gitmek için bir maliyet C_i ödeyebilir\n * ve ardından o konumdaki kapıyı açabilir. C_i >= C_{i+1} olduğu garanti edilir, 1 <= i < n için.\n * Görev, tüm kapıları açmak için gereken minimum toplam maliyeti belirlemektir.\n *\n * Örnek:\n *     >>> f_36(3, (1, 1, 1))\n *     3\n */\nlong long f_36(int n, const std::vector<int>& C)", "vi": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * @doc\n * Cho n cánh cửa được sắp xếp thành một vòng tròn, người chơi bắt đầu trước cửa số 1.\n * Mỗi lượt, người chơi có thể chọn một số i và trả một chi phí C_i để di chuyển i bước sang phải\n * và sau đó mở cánh cửa ở vị trí đó. Đảm bảo rằng C_i >= C_{i+1} với 1 <= i < n.\n * Nhiệm vụ là xác định tổng chi phí tối thiểu cần thiết để mở tất cả các cửa.\n *\n * Ví dụ:\n *     >>> f_36(3, (1, 1, 1))\n *     3\n */\nlong long f_36(int n, const std::vector<int>& C)", "id": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * @doc\n * Diberikan n pintu yang diatur dalam lingkaran, pemain mulai di depan pintu 1.\n * Setiap giliran, pemain dapat memilih angka i dan membayar biaya C_i untuk bergerak i langkah ke kanan\n * dan kemudian membuka pintu pada posisi tersebut. Dijamin bahwa C_i >= C_{i+1} untuk 1 <= i < n.\n * Tugasnya adalah menentukan total biaya minimum yang diperlukan untuk membuka semua pintu.\n *\n * Contoh:\n *     >>> f_36(3, (1, 1, 1))\n *     3\n */\nlong long f_36(int n, const std::vector<int>& C)", "ja": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * @doc\n * 円形に配置された n 個のドアが与えられ、プレイヤーはドア 1 の前から開始します。\n * 各ターンで、プレイヤーは数 i を選び、コスト C_i を支払って右に i ステップ移動し、\n * その位置のドアを開けることができます。1 <= i < n に対して C_i >= C_{i+1} が保証されています。\n * すべてのドアを開けるために必要な最小の総コストを求めることが課題です。\n *\n * 例:\n *     >>> f_36(3, (1, 1, 1))\n *     3\n */\nlong long f_36(int n, const std::vector<int>& C)", "ko": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * @doc\n * 원형으로 배열된 n개의 문이 주어졌을 때, 플레이어는 문 1 앞에서 시작합니다.\n * 각 턴마다, 플레이어는 숫자 i를 선택하고 비용 C_i를 지불하여 오른쪽으로 i칸 이동한 후\n * 그 위치에 있는 문을 엽니다. C_i >= C_{i+1}가 1 <= i < n에 대해 보장됩니다.\n * 모든 문을 여는 데 필요한 최소 총 비용을 결정하는 것이 과제입니다.\n *\n * 예시:\n *     >>> f_36(3, (1, 1, 1))\n *     3\n */\nlong long f_36(int n, const std::vector<int>& C)", "ml": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * @doc\n * വൃത്താകൃതിയിൽ ക്രമീകരിച്ച n വാതിലുകൾ നൽകിയിരിക്കുന്നു, കളിക്കാരൻ വാതിൽ 1-ന്റെ മുന്നിൽ നിന്ന് ആരംഭിക്കുന്നു.\n * ഓരോ തവണയും, കളിക്കാരൻ ഒരു സംഖ്യ i തിരഞ്ഞെടുക്കുകയും i ഘട്ടങ്ങൾ വലത്തേക്ക് നീങ്ങാൻ ഒരു ചെലവ് C_i നൽകുകയും\n * തുടർന്ന് ആ സ്ഥാനത്തെ വാതിൽ തുറക്കുകയും ചെയ്യാം. 1 <= i < n എന്നതിനായി C_i >= C_{i+1} എന്ന് ഉറപ്പുനൽകുന്നു.\n * എല്ലാ വാതിലുകളും തുറക്കുന്നതിനാവശ്യമായ കുറഞ്ഞ മൊത്തം ചെലവ് നിർണ്ണയിക്കേണ്ടതാണ്.\n *\n * ഉദാഹരണം:\n *     >>> f_36(3, (1, 1, 1))\n *     3\n */\nlong long f_36(int n, const std::vector<int>& C)", "fa": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * @doc\n * با توجه به n درب که به صورت دایره‌ای چیده شده‌اند، بازیکن در مقابل درب 1 شروع می‌کند.\n * در هر نوبت، بازیکن می‌تواند عدد i را انتخاب کند و هزینه C_i را بپردازد تا i قدم به سمت راست حرکت کند\n * و سپس درب در آن موقعیت را باز کند. تضمین شده است که C_i >= C_{i+1} برای 1 <= i < n.\n * وظیفه این است که حداقل هزینه کل مورد نیاز برای باز کردن همه درب‌ها را تعیین کنید.\n *\n * مثال:\n *     >>> f_36(3, (1, 1, 1))\n *     3\n */\nlong long f_36(int n, const std::vector<int>& C)"}, "canonical_solution": "{\n    return static_cast<long long>(C[n - 2]) * (n - 1) + C[n - 1];\n}", "instruction": {"en": "Write a CPP function `long long f_36(int n, const std::vector<int>& C)` to solve the following problem:\nGiven n doors arranged in a circle, the player starts in front of door 1.\nEach turn, the player can choose a number i and pay a cost C_i to move i steps to the right\nand then open the door at that position. It is guaranteed that C_i >= C_{i+1} for 1 <= i < n.\nThe task is to determine the minimum total cost required to open all doors.\n\nExample:\n    >>> f_36(3, (1, 1, 1))\n    3\n", "sq": "Shkruani një funksion CPP `long long f_36(int n, const std::vector<int>& C)` për të zgjidhur problemin në vijim:\nDuke pasur parasysh n dyer të renditura në një rreth, lojtari fillon përpara derës 1.\nÇdo radhë, lojtari mund të zgjedhë një numër i dhe të paguajë një kosto C_i për të lëvizur i hapa djathtas\ndhe pastaj të hapë derën në atë pozicion. Është e garantuar që C_i >= C_{i+1} për 1 <= i < n.\nDetyra është të përcaktohet kostoja totale minimale e kërkuar për të hapur të gjitha dyert.\n\nShembull:\n    >>> f_36(3, (1, 1, 1))\n    3", "hy": "Գրեք CPP ֆունկցիա `long long f_36(int n, const std::vector<int>& C)` հետևյալ խնդիրը լուծելու համար:\nՏրված է n դռներ, որոնք դասավորված են շրջանաձև, խաղացողը սկսում է դուռ 1-ի դիմաց:\nՅուրաքանչյուր քայլի ժամանակ, խաղացողը կարող է ընտրել թիվ i և վճարել C_i արժեքը՝ i քայլ աջ շարժվելու համար\nև ապա բացել այդ դիրքի դուռը: Երաշխավորված է, որ C_i >= C_{i+1} 1 <= i < n-ի համար:\nԽնդիրն է որոշել նվազագույն ընդհանուր արժեքը, որը պահանջվում է բոլոր դռները բացելու համար:\n\nՕրինակ:\n    >>> f_36(3, (1, 1, 1))\n    3", "bn": "একটি CPP ফাংশন `long long f_36(int n, const std::vector<int>& C)` লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\nn টি দরজা একটি বৃত্তে সাজানো আছে, খেলোয়াড় দরজা 1 এর সামনে শুরু করে।\nপ্রতি টার্নে, খেলোয়াড় একটি সংখ্যা i বেছে নিতে পারে এবং i ধাপ ডানদিকে যেতে C_i খরচ দিতে পারে\nএবং তারপর সেই অবস্থানে দরজা খুলতে পারে। এটি নিশ্চিত যে C_i >= C_{i+1} 1 <= i < n এর জন্য।\nকাজটি হল সমস্ত দরজা খোলার জন্য প্রয়োজনীয় সর্বনিম্ন মোট খরচ নির্ধারণ করা।\n\nউদাহরণ:\n    >>> f_36(3, (1, 1, 1))\n    3", "bg": "Напишете CPP функция `long long f_36(int n, const std::vector<int>& C)`, за да решите следния проблем:  \nДадени са n врати, подредени в кръг, играчът започва пред врата 1.  \nВсеки ход играчът може да избере число i и да плати цена C_i, за да се премести i стъпки надясно и след това да отвори вратата на тази позиция. Гарантирано е, че C_i >= C_{i+1} за 1 <= i < n.  \nЗадачата е да се определи минималната обща цена, необходима за отваряне на всички врати.  \n\nПример:  \n    >>> f_36(3, (1, 1, 1))  \n    3  ", "zh": "编写一个 CPP 函数 `long long f_36(int n, const std::vector<int>& C)` 来解决以下问题：\n给定 n 扇门按圆形排列，玩家从门 1 前面开始。\n每一轮，玩家可以选择一个数字 i 并支付费用 C_i 向右移动 i 步\n然后打开该位置的门。保证 C_i >= C_{i+1} 对于 1 <= i < n。\n任务是确定打开所有门所需的最小总费用。\n\n示例:\n    >>> f_36(3, (1, 1, 1))\n    3", "fr": "Écrire une fonction CPP `long long f_36(int n, const std::vector<int>& C)` pour résoudre le problème suivant :  \nÉtant donné n portes disposées en cercle, le joueur commence devant la porte 1.  \nÀ chaque tour, le joueur peut choisir un nombre i et payer un coût C_i pour avancer de i pas vers la droite  \net ensuite ouvrir la porte à cette position. Il est garanti que C_i >= C_{i+1} pour 1 <= i < n.  \nLa tâche consiste à déterminer le coût total minimum nécessaire pour ouvrir toutes les portes.  \n\nExemple :  \n    >>> f_36(3, (1, 1, 1))  \n    3  ", "de": "Schreiben Sie eine CPP-Funktion `long long f_36(int n, const std::vector<int>& C)`, um das folgende Problem zu lösen:\nGegeben sind n Türen, die in einem Kreis angeordnet sind, und der Spieler beginnt vor Tür 1.\nIn jedem Zug kann der Spieler eine Zahl i wählen und einen Kosten C_i zahlen, um i Schritte nach rechts zu gehen\nund dann die Tür an dieser Position zu öffnen. Es ist garantiert, dass C_i >= C_{i+1} für 1 <= i < n.\nDie Aufgabe besteht darin, die minimalen Gesamtkosten zu bestimmen, die erforderlich sind, um alle Türen zu öffnen.\n\nBeispiel:\n    >>> f_36(3, (1, 1, 1))\n    3", "ha": "Rubuta aikin CPP `long long f_36(int n, const std::vector<int>& C)` don warware matsalar mai zuwa:\nAn ba da ƙofofi n da aka shirya a cikin madauwari, ɗan wasan yana farawa a gaban ƙofa ta 1.\nKowane juyi, ɗan wasan na iya zaɓar lamba i kuma ya biya kuɗin C_i don matsawa matakai i zuwa dama\nsannan ya buɗe ƙofar a wannan matsayi. An tabbatar da cewa C_i >= C_{i+1} don 1 <= i < n.\nAikin shi ne ƙayyade mafi ƙarancin jimillar kuɗin da ake buƙata don buɗe duk ƙofofi.\n\nMisali:\n    >>> f_36(3, (1, 1, 1))\n    3", "hi": "एक CPP फ़ंक्शन `long long f_36(int n, const std::vector<int>& C)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए n दरवाजे जो एक वृत्त में व्यवस्थित हैं, खिलाड़ी दरवाजा 1 के सामने से शुरू करता है।\nप्रत्येक चाल में, खिलाड़ी एक संख्या i चुन सकता है और i कदम दाईं ओर जाने के लिए C_i लागत का भुगतान कर सकता है\nऔर फिर उस स्थिति पर दरवाजा खोल सकता है। यह गारंटी है कि C_i >= C_{i+1} जहाँ 1 <= i < n।\nकार्य यह है कि सभी दरवाजे खोलने के लिए आवश्यक न्यूनतम कुल लागत का निर्धारण करें।\n\nउदाहरण:\n    >>> f_36(3, (1, 1, 1))\n    3", "hu": "Írj egy CPP függvényt `long long f_36(int n, const std::vector<int>& C)` a következő probléma megoldására:\nAdott n ajtó, amelyek körben vannak elrendezve, a játékos az 1-es ajtó előtt kezd.\nMinden körben a játékos választhat egy számot i, és fizethet egy C_i költséget, hogy i lépést tegyen jobbra, majd kinyissa az adott pozíción lévő ajtót. Garantált, hogy C_i >= C_{i+1} minden 1 <= i < n esetén.\nA feladat az, hogy meghatározzuk a minimális összköltséget, amely szükséges az összes ajtó kinyitásához.\n\nPélda:\n    >>> f_36(3, (1, 1, 1))\n    3", "es": "Escribe una función CPP `long long f_36(int n, const std::vector<int>& C)` para resolver el siguiente problema:\nDadas n puertas dispuestas en un círculo, el jugador comienza frente a la puerta 1.\nCada turno, el jugador puede elegir un número i y pagar un costo C_i para moverse i pasos a la derecha\ny luego abrir la puerta en esa posición. Se garantiza que C_i >= C_{i+1} para 1 <= i < n.\nLa tarea es determinar el costo total mínimo requerido para abrir todas las puertas.\n\nEjemplo:\n    >>> f_36(3, (1, 1, 1))\n    3", "arb": "اكتب دالة CPP `long long f_36(int n, const std::vector<int>& C)` لحل المشكلة التالية:\nمعطى n أبواب مرتبة في دائرة، يبدأ اللاعب أمام الباب 1.\nفي كل دور، يمكن للاعب اختيار رقم i ودفع تكلفة C_i للتحرك i خطوات إلى اليمين\nثم فتح الباب في ذلك الموضع. من المضمون أن C_i >= C_{i+1} لـ 1 <= i < n.\nالمهمة هي تحديد الحد الأدنى من التكلفة الإجمالية المطلوبة لفتح جميع الأبواب.\n\nمثال:\n    >>> f_36(3, (1, 1, 1))\n    3", "sw": "Andika kazi ya CPP `long long f_36(int n, const std::vector<int>& C)` kutatua tatizo lifuatalo:\nUkipewa milango n iliyopangwa katika mduara, mchezaji anaanza mbele ya mlango wa 1.\nKila zamu, mchezaji anaweza kuchagua namba i na kulipa gharama C_i ili kusonga hatua i kwenda kulia\nna kisha kufungua mlango katika nafasi hiyo. Imethibitishwa kuwa C_i >= C_{i+1} kwa 1 <= i < n.\nKazi ni kuamua gharama ndogo kabisa inayohitajika kufungua milango yote.\n\nMfano:\n    >>> f_36(3, (1, 1, 1))\n    3", "tr": "Bir CPP fonksiyonu `long long f_36(int n, const std::vector<int>& C)` yazın ve aşağıdaki problemi çözün:\nBir çember şeklinde düzenlenmiş n kapı verildiğinde, oyuncu 1 numaralı kapının önünde başlar.\nHer turda, oyuncu bir sayı i seçebilir ve i adım sağa hareket etmek için bir maliyet C_i ödeyebilir\nve ardından o konumdaki kapıyı açabilir. C_i >= C_{i+1} olduğu garanti edilir, burada 1 <= i < n.\nGörev, tüm kapıları açmak için gereken minimum toplam maliyeti belirlemektir.\n\nÖrnek:\n    >>> f_36(3, (1, 1, 1))\n    3", "vi": "Viết một hàm CPP `long long f_36(int n, const std::vector<int>& C)` để giải quyết vấn đề sau:\nCho n cánh cửa được sắp xếp thành một vòng tròn, người chơi bắt đầu trước cửa số 1.\nMỗi lượt, người chơi có thể chọn một số i và trả một chi phí C_i để di chuyển i bước sang phải\nvà sau đó mở cánh cửa ở vị trí đó. Đảm bảo rằng C_i >= C_{i+1} cho 1 <= i < n.\nNhiệm vụ là xác định tổng chi phí tối thiểu cần thiết để mở tất cả các cửa.\n\nVí dụ:\n    >>> f_36(3, (1, 1, 1))\n    3", "id": "Tulis fungsi CPP `long long f_36(int n, const std::vector<int>& C)` untuk menyelesaikan masalah berikut:\nDiberikan n pintu yang diatur dalam lingkaran, pemain mulai di depan pintu 1.\nSetiap giliran, pemain dapat memilih angka i dan membayar biaya C_i untuk bergerak i langkah ke kanan\ndan kemudian membuka pintu pada posisi tersebut. Dijamin bahwa C_i >= C_{i+1} untuk 1 <= i < n.\nTugasnya adalah menentukan biaya total minimum yang diperlukan untuk membuka semua pintu.\n\nContoh:\n    >>> f_36(3, (1, 1, 1))\n    3", "ja": "以下の問題を解くために、CPP関数 `long long f_36(int n, const std::vector<int>& C)` を作成してください:\nn個のドアが円形に配置されており、プレイヤーはドア1の前からスタートします。\n各ターンで、プレイヤーは番号iを選び、コストC_iを支払って右にiステップ移動し、その位置のドアを開けることができます。1 <= i < nに対して、C_i >= C_{i+1}が保証されています。\nすべてのドアを開けるために必要な最小の総コストを求めることが課題です。\n\n例:\n    >>> f_36(3, (1, 1, 1))\n    3", "ko": "CPP 함수를 작성하세요 `long long f_36(int n, const std::vector<int>& C)` 이 문제를 해결하기 위해:\nn개의 문이 원형으로 배열되어 있을 때, 플레이어는 문 1 앞에서 시작합니다.\n각 턴마다, 플레이어는 숫자 i를 선택하고 비용 C_i를 지불하여 오른쪽으로 i 걸음 이동한 후 그 위치의 문을 엽니다. C_i >= C_{i+1}이 1 <= i < n에 대해 보장됩니다.\n모든 문을 여는 데 필요한 최소 총 비용을 결정하는 것이 과제입니다.\n\n예시:\n    >>> f_36(3, (1, 1, 1))\n    3", "ml": "CPP ഫങ്ഷൻ `long long f_36(int n, const std::vector<int>& C)` എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:  \nn വാതിലുകൾ ഒരു വൃത്തത്തിൽ ക്രമീകരിച്ചിരിക്കുന്നു, കളിക്കാരൻ വാതിൽ 1-ന്റെ മുന്നിലാണ് ആരംഭിക്കുന്നത്.  \nഓരോ തവണയും, കളിക്കാരൻ ഒരു സംഖ്യ i തിരഞ്ഞെടുക്കുകയും i ഘട്ടങ്ങൾ വലത്തോട്ട് നീങ്ങാൻ C_i ചെലവ് നൽകുകയും  \nആ സ്ഥിതിയിലെ വാതിൽ തുറക്കുകയും ചെയ്യാം. 1 <= i < n എന്നതിനായി C_i >= C_{i+1} എന്ന് ഉറപ്പാണ്.  \nഎല്ലാ വാതിലുകളും തുറക്കാൻ ആവശ്യമായ കുറഞ്ഞ മൊത്തം ചെലവ് നിർണ്ണയിക്കുകയാണ് ഈ പ്രവർത്തി.  \n\nഉദാഹരണം:  \n    >>> f_36(3, (1, 1, 1))  \n    3  ", "fa": "یک تابع CPP `long long f_36(int n, const std::vector<int>& C)` بنویسید تا مسئله زیر را حل کند:\nبا توجه به n درب که به صورت دایره‌ای چیده شده‌اند، بازیکن در مقابل درب 1 شروع می‌کند.\nدر هر نوبت، بازیکن می‌تواند یک عدد i انتخاب کند و هزینه C_i را بپردازد تا i قدم به سمت راست حرکت کند\nو سپس درب در آن موقعیت را باز کند. تضمین شده است که C_i >= C_{i+1} برای 1 <= i < n.\nوظیفه این است که حداقل هزینه کل مورد نیاز برای باز کردن همه درب‌ها را تعیین کنید.\n\nمثال:\n    >>> f_36(3, (1, 1, 1))\n    3"}, "level": "easy", "test": "int main() {\n    std::vector<int> costs1 = {4, 3, 3, 3, 3}; // 1-indexed array\n    assert(f_36(5, costs1) == 15);\n\n    std::vector<int> costs2 = {1, 1, 1};\n    assert(f_36(3, costs2) == 3);\n\n    std::vector<int> costs3 = {5, 4, 3, 2};\n    assert(f_36(4, costs3) == 11);\n\n    std::vector<int> costs4 = {100, 99, 98, 97};\n    assert(f_36(4, costs4) == 391);\n\n    std::vector<int> costs5 = {10, 9, 8, 7, 6, 5};\n    assert(f_36(6, costs5) == 35);\n\n    std::vector<int> costs6 = {2, 2, 2, 2, 2, 2, 2};\n    assert(f_36(7, costs6) == 14);\n\n    std::vector<int> costs7 = {9, 7, 7, 7, 7, 7, 7, 7};\n    assert(f_36(8, costs7) == 56);\n\n    std::vector<int> costs8 = {3, 2, 2, 2, 2, 2, 2, 2, 2};\n    assert(f_36(9, costs8) == 18);\n\n    std::vector<int> costs9 = {6, 5, 5, 5, 5, 5, 5, 5, 5, 5};\n    assert(f_36(10, costs9) == 50);\n\n    std::vector<int> costs10 = {8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};\n    assert(f_36(11, costs10) == 11);\n\n\n    return 0;\n}", "entry_point": "f_36", "signature": "long long f_36(int n, const std::vector<int>& C)", "docstring": {"en": "Given n doors arranged in a circle, the player starts in front of door 1.\nEach turn, the player can choose a number i and pay a cost C_i to move i steps to the right\nand then open the door at that position. It is guaranteed that C_i >= C_{i+1} for 1 <= i < n.\nThe task is to determine the minimum total cost required to open all doors.\n\nExample:\n    >>> f_36(3, (1, 1, 1))\n    3\n", "sq": "Duke pasur n dyer të rregulluara në një rreth, lojtari fillon përpara derës 1.\nÇdo radhë, lojtari mund të zgjedhë një numër i dhe të paguajë një kosto C_i për të lëvizur i hapa në të djathtë\ndhe pastaj të hapë derën në atë pozicion. Është e garantuar që C_i >= C_{i+1} për 1 <= i < n.\nDetyra është të përcaktohet kostoja minimale totale e nevojshme për të hapur të gjitha dyert.\n\nShembull:\n    >>> f_36(3, (1, 1, 1))\n    3", "hy": "Տրված է n դռներ, որոնք դասավորված են շրջանաձև, խաղացողը սկսում է դուռ 1-ի դիմաց:  \nՅուրաքանչյուր քայլի ժամանակ խաղացողը կարող է ընտրել թիվ i և վճարել արժեք C_i՝ i քայլ աջ շարժվելու  \nև այնուհետև այդ դիրքում գտնվող դուռը բացելու համար: Երաշխավորված է, որ C_i >= C_{i+1} 1 <= i < n-ի համար:  \nԽնդիրն է որոշել նվազագույն ընդհանուր արժեքը, որը պահանջվում է բոլոր դռները բացելու համար:\n\nՕրինակ:\n    >>> f_36(3, (1, 1, 1))\n    3", "bn": "nটি দরজা একটি বৃত্তে সাজানো আছে, খেলোয়াড় দরজা 1 এর সামনে থেকে শুরু করে।  \nপ্রতি টার্নে, খেলোয়াড় একটি সংখ্যা i বেছে নিতে পারে এবং i ধাপ ডানদিকে যাওয়ার জন্য একটি খরচ C_i প্রদান করে  \nএবং তারপর সেই অবস্থানের দরজা খুলতে পারে। এটি নিশ্চিত যে C_i >= C_{i+1} যেখানে 1 <= i < n।  \nসমস্ত দরজা খোলার জন্য প্রয়োজনীয় সর্বনিম্ন মোট খরচ নির্ধারণ করার কাজ।\n\nউদাহরণ:\n    >>> f_36(3, (1, 1, 1))\n    3", "bg": "Дадени са n врати, подредени в кръг, играчът започва пред врата 1.  \nВсеки ход, играчът може да избере число i и да плати цена C_i, за да се премести i стъпки надясно и след това да отвори вратата на тази позиция. Гарантирано е, че C_i >= C_{i+1} за 1 <= i < n.  \nЗадачата е да се определи минималната обща цена, необходима за отваряне на всички врати.\n\nПример:\n    >>> f_36(3, (1, 1, 1))\n    3", "zh": "给定 n 个门排列成一个圆圈，玩家从门 1 前面开始。  \n每回合，玩家可以选择一个数字 i 并支付代价 C_i 向右移动 i 步，然后打开该位置的门。  \n保证 C_i >= C_{i+1} 对于 1 <= i < n。  \n任务是确定打开所有门所需的最小总成本。\n\n示例：\n    >>> f_36(3, (1, 1, 1))\n    3", "fr": "Étant donné n portes disposées en cercle, le joueur commence devant la porte 1.  \nÀ chaque tour, le joueur peut choisir un nombre i et payer un coût C_i pour avancer de i pas vers la droite  \net ensuite ouvrir la porte à cette position. Il est garanti que C_i >= C_{i+1} pour 1 <= i < n.  \nLa tâche consiste à déterminer le coût total minimum nécessaire pour ouvrir toutes les portes.\n\nExemple :\n    >>> f_36(3, (1, 1, 1))\n    3", "de": "Gegeben n Türen, die in einem Kreis angeordnet sind, beginnt der Spieler vor Tür 1. \nJede Runde kann der Spieler eine Zahl i wählen und einen Kosten C_i zahlen, um i Schritte nach rechts zu gehen \nund dann die Tür an dieser Position zu öffnen. Es ist garantiert, dass C_i >= C_{i+1} für 1 <= i < n. \nDie Aufgabe besteht darin, die minimalen Gesamtkosten zu bestimmen, die erforderlich sind, um alle Türen zu öffnen.\n\nBeispiel:\n    >>> f_36(3, (1, 1, 1))\n    3", "ha": "An ba wa ƙofa n da aka shirya a cikin da'ira, ɗan wasan yana farawa a gaban ƙofa ta 1. A kowane juyi, ɗan wasan na iya zaɓar lamba i kuma ya biya kuɗi C_i don matsawa matakai i zuwa dama sannan ya buɗe ƙofar a wannan matsayi. An tabbatar da cewa C_i >= C_{i+1} don 1 <= i < n. Aikin shi ne tantance mafi ƙarancin jimillar kuɗi da ake buƙata don buɗe duk ƙofofi.\n\nMisali:\n    >>> f_36(3, (1, 1, 1))\n    3", "hi": "n दरवाजों को एक वृत्त में व्यवस्थित किया गया है, खिलाड़ी दरवाजा 1 के सामने से शुरू करता है।  \nप्रत्येक चाल में, खिलाड़ी एक संख्या i चुन सकता है और i कदम दाईं ओर जाने के लिए एक लागत C_i का भुगतान कर सकता है  \nऔर फिर उस स्थिति पर दरवाजा खोल सकता है। यह गारंटी है कि C_i >= C_{i+1} जहाँ 1 <= i < n।  \nकार्य यह निर्धारित करना है कि सभी दरवाजे खोलने के लिए न्यूनतम कुल लागत क्या होगी।\n\nउदाहरण:\n    >>> f_36(3, (1, 1, 1))\n    3", "hu": "Adott n ajtó, amelyek körben vannak elrendezve, a játékos az 1-es ajtó előtt kezd.\nMinden körben a játékos választhat egy számot i, és fizet egy C_i költséget, hogy i lépést jobbra lépjen,\nmajd kinyissa az ajtót az adott pozíción. Garantált, hogy C_i >= C_{i+1} minden 1 <= i < n esetén.\nA feladat az, hogy meghatározzuk a minimális összköltséget, amely szükséges az összes ajtó kinyitásához.\n\nPélda:\n    >>> f_36(3, (1, 1, 1))\n    3", "es": "Dado n puertas dispuestas en un círculo, el jugador comienza frente a la puerta 1.  \nEn cada turno, el jugador puede elegir un número i y pagar un costo C_i para moverse i pasos a la derecha y luego abrir la puerta en esa posición. Se garantiza que C_i >= C_{i+1} para 1 <= i < n.  \nLa tarea es determinar el costo total mínimo requerido para abrir todas las puertas.\n\nEjemplo:\n    >>> f_36(3, (1, 1, 1))\n    3", "arb": "معطى n أبواب مرتبة في دائرة، يبدأ اللاعب أمام الباب 1.  \nفي كل دور، يمكن للاعب اختيار رقم i ودفع تكلفة C_i للتحرك i خطوات إلى اليمين  \nثم فتح الباب في ذلك الموضع. من المضمون أن C_i >= C_{i+1} لـ 1 <= i < n.  \nالمهمة هي تحديد الحد الأدنى للتكلفة الإجمالية المطلوبة لفتح جميع الأبواب.  \n\nمثال:  \n    >>> f_36(3, (1, 1, 1))  \n    3  ", "sw": "Kwa kuzingatia milango n iliyopangwa kwa mduara, mchezaji huanza mbele ya mlango wa 1. Kila zamu, mchezaji anaweza kuchagua namba i na kulipa gharama C_i ili kusonga hatua i kwenda kulia na kisha kufungua mlango katika nafasi hiyo. Inahakikishwa kuwa C_i >= C_{i+1} kwa 1 <= i < n. Kazi ni kubaini gharama ndogo kabisa inayohitajika kufungua milango yote.\n\nMfano:\n    >>> f_36(3, (1, 1, 1))\n    3", "tr": "Verilen n kapı bir daire şeklinde düzenlenmiştir, oyuncu 1 numaralı kapının önünde başlar.\nHer turda, oyuncu bir sayı i seçebilir ve i adım sağa hareket etmek için bir maliyet C_i ödeyebilir\nve ardından o konumdaki kapıyı açabilir. C_i >= C_{i+1} olduğu garanti edilmiştir, 1 <= i < n için.\nGörev, tüm kapıları açmak için gereken minimum toplam maliyeti belirlemektir.\n\nÖrnek:\n    >>> f_36(3, (1, 1, 1))\n    3", "vi": "Cho n cửa được sắp xếp thành một vòng tròn, người chơi bắt đầu trước cửa số 1.  \nMỗi lượt, người chơi có thể chọn một số i và trả một chi phí C_i để di chuyển i bước sang phải  \nvà sau đó mở cửa tại vị trí đó. Đảm bảo rằng C_i >= C_{i+1} cho 1 <= i < n.  \nNhiệm vụ là xác định tổng chi phí tối thiểu cần thiết để mở tất cả các cửa.\n\nVí dụ:\n    >>> f_36(3, (1, 1, 1))\n    3", "id": "Diberikan n pintu yang disusun dalam lingkaran, pemain mulai di depan pintu 1.  \nSetiap giliran, pemain dapat memilih angka i dan membayar biaya C_i untuk bergerak i langkah ke kanan  \ndan kemudian membuka pintu di posisi tersebut. Dijamin bahwa C_i >= C_{i+1} untuk 1 <= i < n.  \nTugasnya adalah menentukan total biaya minimum yang diperlukan untuk membuka semua pintu.\n\nContoh:\n    >>> f_36(3, (1, 1, 1))\n    3", "ja": "与えられた n 個のドアが円形に配置されており、プレイヤーはドア 1 の前に立っています。  \n各ターンで、プレイヤーは数 i を選び、コスト C_i を支払って右に i ステップ移動し、その位置のドアを開けることができます。  \nC_i >= C_{i+1} が 1 <= i < n の範囲で保証されています。  \nすべてのドアを開けるために必要な最小の総コストを求めることが課題です。\n\n例:\n    >>> f_36(3, (1, 1, 1))\n    3", "ko": "n개의 문이 원형으로 배열되어 있을 때, 플레이어는 문 1 앞에서 시작합니다.\n각 턴마다 플레이어는 숫자 i를 선택하고 비용 C_i를 지불하여 오른쪽으로 i단계 이동한 후 해당 위치의 문을 엽니다. C_i >= C_{i+1}이 1 <= i < n에 대해 보장됩니다.\n모든 문을 여는 데 필요한 최소 총 비용을 결정하는 것이 과제입니다.\n\n예제:\n    >>> f_36(3, (1, 1, 1))\n    3", "ml": "n വാതിലുകൾ ഒരു വൃത്തത്തിൽ ക്രമീകരിച്ചിരിക്കുന്നപ്പോൾ, കളിക്കാരൻ വാതിൽ 1-ന്റെ മുന്നിൽ നിന്ന് ആരംഭിക്കുന്നു. ഓരോ തവണയും, കളിക്കാരൻ ഒരു സംഖ്യ i തിരഞ്ഞെടുക്കുകയും i ഘട്ടങ്ങൾ വലത്തേക്ക് നീങ്ങി ആ സ്ഥിതിയിലെ വാതിൽ തുറക്കാൻ C_i ചെലവ് നൽകുകയും ചെയ്യാം. 1 <= i < n എന്നതിനുള്ള C_i >= C_{i+1} എന്ന് ഉറപ്പാണ്. എല്ലാ വാതിലുകളും തുറക്കുന്നതിനുള്ള കുറഞ്ഞ മൊത്തം ചെലവ് നിർണയിക്കാനുള്ളതാണ് ഈ പ്രവൃത്തി.\n\nഉദാഹരണം:\n    >>> f_36(3, (1, 1, 1))\n    3", "fa": "با توجه به n در که به صورت دایره‌ای چیده شده‌اند، بازیکن در مقابل در شماره 1 شروع می‌کند.  \nدر هر نوبت، بازیکن می‌تواند یک عدد i را انتخاب کند و هزینه C_i را بپردازد تا i قدم به سمت راست حرکت کند  \nو سپس در آن موقعیت در را باز کند. تضمین می‌شود که C_i >= C_{i+1} برای 1 <= i < n.  \nوظیفه این است که حداقل هزینه کل مورد نیاز برای باز کردن همه درها را تعیین کنید.\n\nمثال:\n    >>> f_36(3, (1, 1, 1))\n    3"}}
{"task_id": "CPP/37", "prompt": {"en": "#include <cassert>\n#include <vector>\n/**\n * Computes the total number of handshakes in a classroom scenario given\n * the sequence of student IDs as they enter the classroom. It assumes\n * that students have IDs ranging from 0 to N-1 and that each student\n * will shake hands only with students already in the classroom with a\n * smaller ID.\n *\n * Examples:\n * >>> f_37(3, {2, 1, 0})\n * 0\n */\nlong long f_37(int n, const std::vector<int>& order)", "sq": "#include <cassert>\n#include <vector>\n/**\n * Llogarit numrin total të shtrëngimeve të duarve në një skenar klase duke pasur\n * parasysh sekuencën e ID-ve të studentëve ndërsa hyjnë në klasë. Supozohet\n * që studentët kanë ID që variojnë nga 0 deri në N-1 dhe që secili student\n * do të shtrëngojë duart vetëm me studentët që janë tashmë në klasë me një\n * ID më të vogël.\n *\n * Shembuj:\n * >>> f_37(3, {2, 1, 0})\n * 0\n */\nlong long f_37(int n, const std::vector<int>& order)", "hy": "#include <cassert>\n#include <vector>\n/**\n * Հաշվում է ձեռքսեղմումների ընդհանուր քանակը դասարանում, \n * տրված է ուսանողների ID-ների հաջորդականությունը, ինչպես նրանք մտնում են դասարան: \n * Ենթադրվում է, որ ուսանողները ունեն ID-ներ 0-ից մինչև N-1, \n * և որ յուրաքանչյուր ուսանող ձեռք կսեղմի միայն այն ուսանողների հետ, \n * ովքեր արդեն դասարանում են ավելի փոքր ID-ով:\n *\n * Օրինակներ:\n * >>> f_37(3, {2, 1, 0})\n * 0\n */\nlong long f_37(int n, const std::vector<int>& order)", "bn": "#include <cassert>\n#include <vector>\n/**\n * একটি শ্রেণীকক্ষের পরিস্থিতিতে মোট কতগুলি করমর্দন হয় তা গণনা করে\n * যখন ছাত্রদের আইডির ক্রমটি দেওয়া হয় যেভাবে তারা শ্রেণীকক্ষে প্রবেশ করে। এটি ধরে নেয়\n * যে ছাত্রদের আইডি 0 থেকে N-1 পর্যন্ত এবং প্রতিটি ছাত্র\n * শুধুমাত্র তাদের চেয়ে ছোট আইডি সহ ইতিমধ্যে শ্রেণীকক্ষে থাকা ছাত্রদের সাথে করমর্দন করবে।\n *\n * উদাহরণ:\n * >>> f_37(3, {2, 1, 0})\n * 0\n */\nlong long f_37(int n, const std::vector<int>& order)", "bg": "#include <cassert>\n#include <vector>\n/**\n * Изчислява общия брой ръкостискания в класна стая, като се дава\n * последователността от идентификатори на учениците, когато влизат в класната стая. Предполага се,\n * че учениците имат идентификатори в диапазона от 0 до N-1 и че всеки ученик\n * ще се ръкува само с ученици, които вече са в класната стая с\n * по-малък идентификатор.\n *\n * Примери:\n * >>> f_37(3, {2, 1, 0})\n * 0\n */\nlong long f_37(int n, const std::vector<int>& order)", "zh": "#include <cassert>\n#include <vector>\n/**\n * 计算在一个教室场景中握手的总次数，给定学生进入教室的顺序。\n * 假设学生的ID范围是从0到N-1，并且每个学生只会与已经在教室中且ID更小的学生握手。\n *\n * 示例:\n * >>> f_37(3, {2, 1, 0})\n * 0\n */\nlong long f_37(int n, const std::vector<int>& order)", "fr": "#include <cassert>\n#include <vector>\n/**\n * Calcule le nombre total de poignées de main dans un scénario de classe donné\n * la séquence des identifiants des étudiants à mesure qu'ils entrent dans la classe. Il suppose\n * que les étudiants ont des identifiants allant de 0 à N-1 et que chaque étudiant\n * serrera la main uniquement avec les étudiants déjà dans la classe avec un\n * identifiant plus petit.\n *\n * Exemples :\n * >>> f_37(3, {2, 1, 0})\n * 0\n */\nlong long f_37(int n, const std::vector<int>& order)", "de": "#include <cassert>\n#include <vector>\n/**\n * Berechnet die Gesamtanzahl der Händedrucke in einem Klassenzimmerszenario, gegeben\n * die Sequenz der Schüler-IDs, während sie das Klassenzimmer betreten. Es wird angenommen,\n * dass die Schüler IDs im Bereich von 0 bis N-1 haben und dass jeder Schüler\n * nur mit Schülern Händedrucke austauscht, die bereits im Klassenzimmer sind und eine\n * kleinere ID haben.\n *\n * Beispiele:\n * >>> f_37(3, {2, 1, 0})\n * 0\n */\nlong long f_37(int n, const std::vector<int>& order)", "ha": "#include <cassert>\n#include <vector>\n/**\n * Yana lissafin jimillar yawan gaisuwar hannu a cikin yanayin aji da aka bayar\n * jerin lambobin ID na ɗalibai yayin da suke shiga ajin. Yana ɗauka\n * cewa ɗalibai suna da ID daga 0 zuwa N-1 kuma cewa kowane ɗalibi\n * zai gaisa da hannu ne kawai da ɗalibai da suke cikin ajin tuni da\n * ke da ID mafi ƙanƙanta.\n *\n * Misalai:\n * >>> f_37(3, {2, 1, 0})\n * 0\n */\nlong long f_37(int n, const std::vector<int>& order)", "hi": "#include <cassert>\n#include <vector>\n/**\n * एक कक्षा परिदृश्य में कुल हैंडशेक की संख्या की गणना करता है, \n * जब छात्र आईडी के अनुक्रम के रूप में कक्षा में प्रवेश करते हैं। यह मानता है \n * कि छात्रों की आईडी 0 से N-1 तक होती है और प्रत्येक छात्र केवल उन छात्रों \n * के साथ हाथ मिलाएगा जो पहले से ही कक्षा में हैं और जिनकी आईडी छोटी है।\n *\n * उदाहरण:\n * >>> f_37(3, {2, 1, 0})\n * 0\n */\nlong long f_37(int n, const std::vector<int>& order)", "hu": "#include <cassert>\n#include <vector>\n/**\n * Kiszámítja a kézfogások teljes számát egy osztálytermi szituációban,\n * figyelembe véve a diákok azonosítóinak sorrendjét, ahogy belépnek az osztályterembe.\n * Feltételezi, hogy a diákok azonosítói 0-tól N-1-ig terjednek, és hogy minden diák\n * csak azokkal a diákokkal fog kezet, akik már az osztályteremben vannak, és kisebb azonosítóval rendelkeznek.\n *\n * Példák:\n * >>> f_37(3, {2, 1, 0})\n * 0\n */\nlong long f_37(int n, const std::vector<int>& order)", "es": "#include <cassert>\n#include <vector>\n/**\n * Calcula el número total de apretones de manos en un escenario de aula dado\n * la secuencia de IDs de estudiantes a medida que ingresan al aula. Se asume\n * que los estudiantes tienen IDs que van de 0 a N-1 y que cada estudiante\n * solo estrechará la mano con estudiantes que ya estén en el aula con un\n * ID menor.\n *\n * Ejemplos:\n * >>> f_37(3, {2, 1, 0})\n * 0\n */\nlong long f_37(int n, const std::vector<int>& order)", "arb": "#include <cassert>\n#include <vector>\n/**\n * يحسب العدد الإجمالي للمصافحات في سيناريو الفصل الدراسي المعطى\n * تسلسل معرفات الطلاب عند دخولهم الفصل. يفترض\n * أن الطلاب لديهم معرفات تتراوح من 0 إلى N-1 وأن كل طالب\n * سوف يصافح فقط الطلاب الموجودين بالفعل في الفصل مع\n * معرف أصغر.\n *\n * أمثلة:\n * >>> f_37(3, {2, 1, 0})\n * 0\n */\nlong long f_37(int n, const std::vector<int>& order)", "sw": "#include <cassert>\n#include <vector>\n/**\n * Inahesabu jumla ya mikono iliyoshikana katika hali ya darasani ikizingatiwa\n * mlolongo wa vitambulisho vya wanafunzi wanapoingia darasani. Inadhaniwa\n * kwamba wanafunzi wana vitambulisho vinavyoanzia 0 hadi N-1 na kwamba kila mwanafunzi\n * atashikana mikono tu na wanafunzi ambao tayari wapo darasani wenye kitambulisho\n * kidogo zaidi.\n *\n * Mifano:\n * >>> f_37(3, {2, 1, 0})\n * 0\n */\nlong long f_37(int n, const std::vector<int>& order)", "tr": "#include <cassert>\n#include <vector>\n/**\n * Bir sınıf senaryosunda, öğrencilerin sınıfa giriş sırasına göre toplam\n * tokalaşma sayısını hesaplar. Öğrencilerin kimliklerinin 0'dan N-1'e\n * kadar olduğu ve her öğrencinin sadece sınıfta zaten bulunan ve daha\n * küçük kimliğe sahip öğrencilerle tokalaşacağı varsayılır.\n *\n * Örnekler:\n * >>> f_37(3, {2, 1, 0})\n * 0\n */\nlong long f_37(int n, const std::vector<int>& order)", "vi": "#include <cassert>\n#include <vector>\n/**\n * Tính tổng số lần bắt tay trong một kịch bản lớp học cho trước\n * dãy số ID của học sinh khi họ vào lớp. Giả sử rằng\n * học sinh có ID từ 0 đến N-1 và mỗi học sinh\n * sẽ chỉ bắt tay với những học sinh đã có mặt trong lớp với\n * ID nhỏ hơn.\n *\n * Ví dụ:\n * >>> f_37(3, {2, 1, 0})\n * 0\n */\nlong long f_37(int n, const std::vector<int>& order)", "id": "#include <cassert>\n#include <vector>\n/**\n * Menghitung total jumlah jabat tangan dalam skenario kelas yang diberikan\n * urutan ID siswa saat mereka memasuki kelas. Diasumsikan\n * bahwa siswa memiliki ID berkisar dari 0 hingga N-1 dan bahwa setiap siswa\n * hanya akan berjabat tangan dengan siswa yang sudah ada di kelas dengan\n * ID yang lebih kecil.\n *\n * Contoh:\n * >>> f_37(3, {2, 1, 0})\n * 0\n */\nlong long f_37(int n, const std::vector<int>& order)", "ja": "#include <cassert>\n#include <vector>\n/**\n * 教室のシナリオで、学生のIDの順序が与えられたときの握手の総数を計算します。\n * 学生のIDは0からN-1までの範囲であると仮定し、各学生はすでに教室にいる\n * 自分より小さいIDの学生とだけ握手をします。\n *\n * 例:\n * >>> f_37(3, {2, 1, 0})\n * 0\n */\nlong long f_37(int n, const std::vector<int>& order)", "ko": "#include <cassert>\n#include <vector>\n/**\n * 학생들이 교실에 들어오는 순서가 주어졌을 때 교실 시나리오에서 총 악수 횟수를 계산합니다.\n * 학생들은 ID가 0부터 N-1까지 범위에 있으며, 각 학생은 자신보다 작은 ID를 가진\n * 이미 교실에 있는 학생들과만 악수를 한다고 가정합니다.\n *\n * 예시:\n * >>> f_37(3, {2, 1, 0})\n * 0\n */\nlong long f_37(int n, const std::vector<int>& order)", "ml": "#include <cassert>\n#include <vector>\n/**\n * വിദ്യാർത്ഥികളുടെ ഐ.ഡി.കൾ ക്ലാസ് മുറിയിൽ പ്രവേശിക്കുന്ന ക്രമത്തിൽ നൽകിയാൽ\n * ക്ലാസ് മുറിയിലെ ഒരു സാഹചര്യത്തിൽ ആകെ കൈകുലുക്കങ്ങളുടെ എണ്ണം കണക്കാക്കുന്നു. \n * വിദ്യാർത്ഥികൾക്ക് 0 മുതൽ N-1 വരെ ഐ.ഡി.കൾ ഉണ്ടെന്ന് ഇത് അനുമാനിക്കുന്നു \n * കൂടാതെ ഓരോ വിദ്യാർത്ഥിയും തങ്ങളുടെ ഐ.ഡി.യേക്കാൾ ചെറിയ ഐ.ഡി.യുള്ള \n * വിദ്യാർത്ഥികളുമായി മാത്രം കൈകുലുക്കം നടത്തും.\n *\n * ഉദാഹരണങ്ങൾ:\n * >>> f_37(3, {2, 1, 0})\n * 0\n */\nlong long f_37(int n, const std::vector<int>& order)", "fa": "#include <cassert>\n#include <vector>\n/**\n * تعداد کل دست دادن‌ها را در یک سناریوی کلاس درس محاسبه می‌کند با توجه به\n * ترتیب شناسه‌های دانش‌آموزان به محض ورود به کلاس. فرض بر این است که\n * شناسه‌های دانش‌آموزان در بازه 0 تا N-1 قرار دارند و هر دانش‌آموز\n * فقط با دانش‌آموزانی که قبلاً وارد کلاس شده‌اند و شناسه کوچکتری دارند\n * دست می‌دهد.\n *\n * مثال‌ها:\n * >>> f_37(3, {2, 1, 0})\n * 0\n */\nlong long f_37(int n, const std::vector<int>& order)"}, "canonical_solution": "{\n    long long ans = 0;\n    std::vector<int> tr(n + 1, 0);\n    \n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n\n    return ans;\n}", "instruction": {"en": "Write a CPP function `long long f_37(int n, const std::vector<int>& order)` to solve the following problem:\nComputes the total number of handshakes in a classroom scenario given the sequence of student IDs as they enter the classroom. It assumes that students have IDs ranging from 0 to N-1 and that each student will shake hands only with students already in the classroom with a smaller ID.\n\nExamples:\n>>> f_37(3, {2, 1, 0})\n0\n", "sq": "Shkruani një funksion CPP `long long f_37(int n, const std::vector<int>& order)` për të zgjidhur problemin në vijim:  \nLlogarit numrin total të shtrëngimeve të duarve në një skenar klase duke pasur parasysh sekuencën e ID-ve të studentëve ndërsa hyjnë në klasë. Supozohet që studentët kanë ID që variojnë nga 0 deri në N-1 dhe që secili student do të shtrëngojë duart vetëm me studentët që janë tashmë në klasë me një ID më të vogël.\n\nShembuj:\n>>> f_37(3, {2, 1, 0})\n0", "hy": "Գրեք CPP ֆունկցիա `long long f_37(int n, const std::vector<int>& order)` հետևյալ խնդիրը լուծելու համար:\nՀաշվում է ընդհանուր ձեռքսեղմումների քանակը դասարանում սցենարի մեջ՝ հաշվի առնելով ուսանողների ID-ների հաջորդականությունը, երբ նրանք մտնում են դասարան։ Ենթադրվում է, որ ուսանողները ունեն ID-ներ 0-ից N-1 միջակայքում և որ յուրաքանչյուր ուսանող ձեռք կսեղմի միայն այն ուսանողների հետ, որոնք արդեն դասարանում են ավելի փոքր ID-ով։\n\nՕրինակներ:\n>>> f_37(3, {2, 1, 0})\n0", "bn": "`long long f_37(int n, const std::vector<int>& order)` ফাংশনটি লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nশ্রেণীকক্ষের দৃশ্যে শিক্ষার্থীদের প্রবেশের ক্রম অনুযায়ী মোট হ্যান্ডশেকের সংখ্যা গণনা করে। এটি ধরে নেয় যে শিক্ষার্থীদের আইডি 0 থেকে N-1 পর্যন্ত এবং প্রতিটি শিক্ষার্থী শুধুমাত্র শ্রেণীকক্ষে ইতিমধ্যে উপস্থিত ছোট আইডি বিশিষ্ট শিক্ষার্থীদের সাথে হ্যান্ডশেক করবে।\n\nউদাহরণসমূহ:\n>>> f_37(3, {2, 1, 0})\n0", "bg": "Напишете CPP функция `long long f_37(int n, const std::vector<int>& order)`, за да решите следния проблем:  \nИзчислява общия брой ръкостискания в класна стая, като се има предвид последователността на идентификаторите на учениците, когато влизат в класната стая. Предполага се, че учениците имат идентификатори в диапазона от 0 до N-1 и че всеки ученик ще се ръкува само с ученици, които вече са в класната стая с по-малък идентификатор.\n\nПримери:\n>>> f_37(3, {2, 1, 0})\n0", "zh": "编写一个 CPP 函数 `long long f_37(int n, const std::vector<int>& order)` 来解决以下问题：\n计算在一个教室场景中，根据学生进入教室的顺序，总握手次数。假设学生的 ID 范围是从 0 到 N-1，并且每个学生只会与已经在教室中且 ID 较小的学生握手。", "fr": "Écrire une fonction CPP `long long f_37(int n, const std::vector<int>& order)` pour résoudre le problème suivant :\nCalcule le nombre total de poignées de main dans un scénario de classe donné la séquence des identifiants des étudiants lorsqu'ils entrent dans la classe. Il est supposé que les étudiants ont des identifiants allant de 0 à N-1 et que chaque étudiant serrera la main uniquement avec les étudiants déjà présents dans la classe avec un identifiant plus petit.\n\nExemples:\n>>> f_37(3, {2, 1, 0})\n0", "de": "Schreiben Sie eine CPP-Funktion `long long f_37(int n, const std::vector<int>& order)`, um das folgende Problem zu lösen:\nBerechnet die Gesamtanzahl der Händedrucke in einem Klassenzimmer-Szenario, gegeben die Reihenfolge der Schüler-IDs, wie sie das Klassenzimmer betreten. Es wird angenommen, dass die Schüler IDs im Bereich von 0 bis N-1 haben und dass jeder Schüler nur mit Schülern Händeschütteln wird, die bereits im Klassenzimmer sind und eine kleinere ID haben.\n\nBeispiele:\n>>> f_37(3, {2, 1, 0})\n0", "ha": "Rubuta aikin CPP `long long f_37(int n, const std::vector<int>& order)` don warware matsalar mai zuwa:\nYana ƙididdige jimlar yawan gaisuwar hannu a cikin yanayin aji la'akari da jerin lambobin ID na ɗalibai yayin da suke shiga aji. Ana ɗauka cewa ɗalibai suna da lambobin ID daga 0 zuwa N-1 kuma kowanne ɗalibi zai gaisa da hannu kawai da ɗaliban da suka riga sun shiga aji da ƙananan ID.", "hi": "एक CPP फ़ंक्शन `long long f_37(int n, const std::vector<int>& order)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nकक्षा परिदृश्य में कुल हैंडशेक्स की गणना करता है, जिसमें छात्रों के आईडी के अनुक्रम को दिया गया है जैसे वे कक्षा में प्रवेश करते हैं। यह मानता है कि छात्रों के आईडी 0 से N-1 तक होते हैं और प्रत्येक छात्र केवल उन छात्रों के साथ हैंडशेक करेगा जो पहले से ही कक्षा में छोटे आईडी के साथ मौजूद हैं।\n\nउदाहरण:\n>>> f_37(3, {2, 1, 0})\n0", "hu": "Írj egy CPP függvényt `long long f_37(int n, const std::vector<int>& order)` a következő probléma megoldására:\nKiszámítja a kézfogások teljes számát egy osztálytermi szituációban, figyelembe véve a diákok azonosítóinak sorrendjét, ahogy belépnek az osztályterembe. Feltételezi, hogy a diákok azonosítói 0-tól N-1-ig terjednek, és hogy minden diák csak azokkal a diákokkal fog kezet, akik már az osztályteremben vannak kisebb azonosítóval.\n\nPéldák:\n>>> f_37(3, {2, 1, 0})\n0", "es": "Escribe una función CPP `long long f_37(int n, const std::vector<int>& order)` para resolver el siguiente problema:\nCalcula el número total de apretones de manos en un escenario de aula dado la secuencia de identificaciones de estudiantes a medida que entran al aula. Se asume que los estudiantes tienen identificaciones que van de 0 a N-1 y que cada estudiante solo estrechará la mano con estudiantes que ya están en el aula con una identificación menor.\n\nEjemplos:\n>>> f_37(3, {2, 1, 0})\n0", "arb": "اكتب دالة CPP `long long f_37(int n, const std::vector<int>& order)` لحل المشكلة التالية:\nتحسب العدد الإجمالي للمصافحات في سيناريو الفصل الدراسي بالنظر إلى تسلسل معرفات الطلاب أثناء دخولهم إلى الفصل. يفترض أن الطلاب لديهم معرفات تتراوح من 0 إلى N-1 وأن كل طالب سيصافح فقط الطلاب الموجودين بالفعل في الفصل بمعرف أصغر.\n\nأمثلة:\n>>> f_37(3, {2, 1, 0})\n0", "sw": "Andika kazi ya CPP `long long f_37(int n, const std::vector<int>& order)` kutatua tatizo lifuatalo:\nInahesabu jumla ya mikono iliyoshikwa katika hali ya darasani ikizingatia mlolongo wa nambari za wanafunzi wanapoingia darasani. Inadhani kwamba wanafunzi wana nambari za utambulisho kuanzia 0 hadi N-1 na kwamba kila mwanafunzi atashikana mikono tu na wanafunzi ambao tayari wako darasani wenye nambari ndogo.\n\nMifano:\n>>> f_37(3, {2, 1, 0})\n0", "tr": "Bir CPP fonksiyonu `long long f_37(int n, const std::vector<int>& order)` yazın:\nBir sınıf senaryosunda, öğrencilerin sınıfa giriş sırasına göre toplam tokalaşma sayısını hesaplar. Öğrencilerin kimliklerinin 0'dan N-1'e kadar olduğunu ve her öğrencinin yalnızca sınıfta kendisinden daha küçük kimliğe sahip olan öğrencilerle tokalaşacağını varsayar.\n\nÖrnekler:\n>>> f_37(3, {2, 1, 0})\n0", "vi": "Viết một hàm CPP `long long f_37(int n, const std::vector<int>& order)` để giải quyết vấn đề sau:\nTính tổng số cái bắt tay trong một tình huống lớp học cho trước dãy số ID của học sinh khi họ vào lớp. Giả sử rằng học sinh có ID từ 0 đến N-1 và mỗi học sinh chỉ bắt tay với những học sinh đã có mặt trong lớp với ID nhỏ hơn.\n\nVí dụ:\n>>> f_37(3, {2, 1, 0})\n0", "id": "Tulis fungsi CPP `long long f_37(int n, const std::vector<int>& order)` untuk menyelesaikan masalah berikut:\nMenghitung total jumlah jabat tangan dalam skenario kelas yang diberikan urutan ID siswa saat mereka memasuki kelas. Diasumsikan bahwa siswa memiliki ID berkisar dari 0 hingga N-1 dan bahwa setiap siswa hanya akan berjabat tangan dengan siswa yang sudah ada di kelas dengan ID lebih kecil.\n\nContoh:\n>>> f_37(3, {2, 1, 0})\n0", "ja": "CPP関数 `long long f_37(int n, const std::vector<int>& order)` を作成して、次の問題を解決してください:\n教室のシナリオで、学生のIDの順序が与えられたときの握手の総数を計算します。学生はIDが0からN-1までの範囲であると仮定し、各学生はすでに教室にいる自分より小さいIDの学生とだけ握手をします。\n\n例:\n>>> f_37(3, {2, 1, 0})\n0", "ko": "`long long f_37(int n, const std::vector<int>& order)` 함수를 작성하여 다음 문제를 해결하십시오:\n학생들이 교실에 들어오는 순서에 따라 교실 시나리오에서 총 악수 횟수를 계산합니다. 학생들은 ID가 0부터 N-1까지 범위에 있으며, 각 학생은 이미 교실에 있는 자신보다 작은 ID를 가진 학생들과만 악수를 한다고 가정합니다.\n\n예시:\n>>> f_37(3, {2, 1, 0})\n0", "ml": "`long long f_37(int n, const std::vector<int>& order)` എന്ന CPP ഫംഗ്ഷൻ എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ: ക്ലാസ് റൂം രംഗത്തിൽ വിദ്യാർത്ഥികളുടെ ഐഡി ക്രമത്തിൽ ക്ലാസ് റൂമിൽ പ്രവേശിക്കുന്നതനുസരിച്ച് ആകെ കൈകുലുക്കലുകളുടെ എണ്ണം കണക്കാക്കുന്നു. വിദ്യാർത്ഥികൾക്ക് 0 മുതൽ N-1 വരെ ഐഡികൾ ഉണ്ടെന്ന് ധരിക്കുന്നു, കൂടാതെ ഓരോ വിദ്യാർത്ഥിയും ക്ലാസ് റൂമിൽ ഇതിനകം ചെറുതായ ഐഡി ഉള്ള വിദ്യാർത്ഥികളുമായി മാത്രമേ കൈകുലുക്കുകയുള്ളൂ. \n\nഉദാഹരണങ്ങൾ: \n>>> f_37(3, {2, 1, 0}) \n0", "fa": "یک تابع CPP `long long f_37(int n, const std::vector<int>& order)` بنویسید تا مسئله زیر را حل کند:\nتعداد کل دست دادن‌ها را در یک سناریوی کلاس درس محاسبه می‌کند با توجه به توالی شناسه‌های دانش‌آموزان به محض ورود به کلاس. فرض بر این است که دانش‌آموزان دارای شناسه‌هایی از 0 تا N-1 هستند و هر دانش‌آموز فقط با دانش‌آموزانی که قبلاً وارد کلاس شده‌اند و شناسه کوچکتری دارند دست می‌دهد.\n\nمثال‌ها:\n>>> f_37(3, {2, 1, 0})\n0"}, "level": "middle", "test": "int main() {\n    assert(f_37(4, {2, 1, 3, 0}) == 2);\n    assert(f_37(6, {0, 1, 2, 3, 4, 5}) == 15);\n    assert(f_37(3, {1, 2, 0}) == 1);\n    assert(f_37(4, {3, 2, 1, 0}) == 0);\n    assert(f_37(4, {0, 1, 2, 3}) == 6);\n    assert(f_37(6, {5, 4, 3, 2, 1, 0}) == 0);\n    assert(f_37(4, {0, 2, 1, 3}) == 5);\n    assert(f_37(5, {3, 1, 4, 2, 0}) == 3);\n    assert(f_37(4, {1, 0, 3, 2}) == 4);\n    assert(f_37(3, {2, 0, 1}) == 1);\n    assert(f_37(5, {1, 3, 0, 2, 4}) == 7);\n    assert(f_37(5, {4, 3, 2, 1, 0}) == 0);\n\n    return 0;\n}", "entry_point": "f_37", "signature": "long long f_37(int n, const std::vector<int>& order)", "docstring": {"en": "Computes the total number of handshakes in a classroom scenario given the sequence of student IDs as they enter the classroom. It assumes that students have IDs ranging from 0 to N-1 and that each student will shake hands only with students already in the classroom with a smaller ID.\n\nExamples:\n>>> f_37(3, {2, 1, 0})\n0\n", "sq": "Llogarit numrin total të shtrëngimeve të duarve në një skenar klase duke dhënë sekuencën e ID-ve të studentëve ndërsa hyjnë në klasë. Supozohet se studentët kanë ID që variojnë nga 0 deri në N-1 dhe se çdo student do të shtrëngojë duart vetëm me studentët që tashmë janë në klasë me një ID më të vogël.\n\nShembuj:\n>>> f_37(3, {2, 1, 0})\n0", "hy": "Հաշվում է դասարանում ողջույնի ձեռքսեղմումների ընդհանուր քանակը՝ հաշվի առնելով ուսանողների ID-ների հաջորդականությունը, երբ նրանք մտնում են դասարան: Ենթադրվում է, որ ուսանողների ID-ները տատանվում են 0-ից մինչև N-1, և որ յուրաքանչյուր ուսանող ձեռքսեղմում է միայն այն ուսանողների հետ, ովքեր արդեն դասարանում են ավելի փոքր ID-ով:\n\nՕրինակներ:\n>>> f_37(3, {2, 1, 0})\n0", "bn": "শ্রেণীকক্ষের পরিস্থিতিতে শিক্ষার্থীদের আইডির ক্রম অনুযায়ী শ্রেণীকক্ষে প্রবেশের সময় মোট কতগুলি হ্যান্ডশেক হয় তা গণনা করে। এটি ধরে নেয় যে শিক্ষার্থীদের আইডি 0 থেকে N-1 পর্যন্ত এবং প্রতিটি শিক্ষার্থী শুধুমাত্র তার চেয়ে ছোট আইডি সহ ইতিমধ্যে শ্রেণীকক্ষে থাকা শিক্ষার্থীদের সাথে হ্যান্ডশেক করবে।\n\nউদাহরণ:\n>>> f_37(3, {2, 1, 0})\n0", "bg": "Изчислява общия брой ръкостискания в класна стая, като се даде последователността от идентификатори на ученици, когато влизат в класната стая. Предполага се, че учениците имат идентификатори в диапазона от 0 до N-1 и че всеки ученик ще се ръкува само с ученици, които вече са в класната стая с по-малък идентификатор.\n\nПримери:\n>>> f_37(3, {2, 1, 0})\n0", "zh": "计算在教室场景中，给定学生进入教室的顺序后，总共的握手次数。假设学生的ID范围是从0到N-1，并且每个学生只会与已经在教室中且ID较小的学生握手。\n\n示例：\n>>> f_37(3, {2, 1, 0})\n0", "fr": "Calcule le nombre total de poignées de main dans un scénario de classe donné la séquence des identifiants des étudiants à mesure qu'ils entrent dans la classe. Il suppose que les étudiants ont des identifiants allant de 0 à N-1 et que chaque étudiant serrera la main uniquement avec les étudiants déjà présents dans la classe avec un identifiant plus petit.\n\nExemples :\n>>> f_37(3, {2, 1, 0})\n0", "de": "Berechnet die Gesamtanzahl der Händedrucke in einem Klassenzimmer-Szenario, gegeben die Sequenz der Schüler-IDs, während sie das Klassenzimmer betreten. Es wird angenommen, dass die Schüler IDs von 0 bis N-1 haben und dass jeder Schüler nur mit Schülern Händeschütteln wird, die bereits im Klassenzimmer sind und eine kleinere ID haben.\n\nBeispiele:\n>>> f_37(3, {2, 1, 0})\n0", "ha": "Yana ƙididdige adadin gaisuwar hannu a cikin yanayin aji idan aka ba da jerin lambobin ID na ɗalibai yayin da suke shiga aji. Yana ɗauka cewa ɗalibai suna da lambobin ID daga 0 zuwa N-1 kuma cewa kowanne ɗalibi zai yi gaisuwar hannu ne kawai da ɗaliban da suka riga sun shiga aji da ƙaramin ID.\n\nMisalai:\n>>> f_37(3, {2, 1, 0})\n0", "hi": "कक्षा परिदृश्य में कुल हैंडशेक की संख्या की गणना करता है, जब छात्रों के आईडी के अनुक्रम के अनुसार वे कक्षा में प्रवेश करते हैं। यह मानता है कि छात्रों के आईडी 0 से N-1 तक होते हैं और प्रत्येक छात्र केवल उन छात्रों से हाथ मिलाएगा जो पहले से ही कक्षा में छोटे आईडी के साथ हैं।\n\nउदाहरण:\n>>> f_37(3, {2, 1, 0})\n0", "hu": "Számítja az összes kézfogás számát egy osztálytermi szituációban, adott a diákok azonosítóinak sorrendje, ahogy belépnek az osztályterembe. Feltételezi, hogy a diákok azonosítói 0-tól N-1-ig terjednek, és hogy minden diák csak azokkal a diákokkal fog kezet, akik már az osztályteremben vannak és kisebb azonosítóval rendelkeznek.\n\nPéldák:\n>>> f_37(3, {2, 1, 0})\n0", "es": "Calcula el número total de apretones de manos en un escenario de aula dado la secuencia de identificaciones de estudiantes a medida que ingresan al aula. Se asume que los estudiantes tienen identificaciones que van de 0 a N-1 y que cada estudiante solo estrechará la mano con estudiantes que ya están en el aula con una identificación menor.\n\nEjemplos:\n>>> f_37(3, {2, 1, 0})\n0", "arb": "يحسب العدد الإجمالي للمصافحات في سيناريو الفصل الدراسي بالنظر إلى تسلسل معرفات الطلاب عند دخولهم إلى الفصل. يفترض أن الطلاب لديهم معرفات تتراوح من 0 إلى N-1 وأن كل طالب سيصافح فقط الطلاب الموجودين بالفعل في الفصل والذين لديهم معرف أصغر.\n\nأمثلة:\n>>> f_37(3, {2, 1, 0})\n0", "sw": "Hesabu jumla ya mikono iliyoshikwa katika hali ya darasani kutokana na mlolongo wa vitambulisho vya wanafunzi wanapoingia darasani. Inadhani kwamba wanafunzi wana vitambulisho kuanzia 0 hadi N-1 na kwamba kila mwanafunzi atashikana mikono tu na wanafunzi ambao tayari wapo darasani wenye kitambulisho kidogo zaidi.\n\nMifano:\n>>> f_37(3, {2, 1, 0})\n0", "tr": "Sınıfa giren öğrenci kimlik numaralarının sırasına göre bir sınıf senaryosunda toplam el sıkışma sayısını hesaplar. Öğrencilerin kimlik numaralarının 0'dan N-1'e kadar olduğu ve her öğrencinin yalnızca sınıfta kendisinden daha küçük kimlik numarasına sahip öğrencilerle el sıkışacağı varsayılır.\n\nÖrnekler:\n>>> f_37(3, {2, 1, 0})\n0", "vi": "Tính tổng số lần bắt tay trong một tình huống lớp học với dãy số ID của học sinh khi họ vào lớp. Giả sử rằng học sinh có ID từ 0 đến N-1 và mỗi học sinh chỉ bắt tay với những học sinh đã có mặt trong lớp với ID nhỏ hơn.\n\nVí dụ:\n>>> f_37(3, {2, 1, 0})\n0", "id": "Menghitung jumlah total jabat tangan dalam skenario kelas yang diberikan urutan ID siswa saat mereka memasuki kelas. Diasumsikan bahwa siswa memiliki ID berkisar dari 0 hingga N-1 dan bahwa setiap siswa hanya akan berjabat tangan dengan siswa yang sudah berada di kelas dengan ID lebih kecil.\n\nContoh:\n>>> f_37(3, {2, 1, 0})\n0", "ja": "教室のシナリオで、学生が教室に入る順番に基づいて、合計の握手の数を計算します。学生はIDが0からN-1までの範囲であり、各学生は教室に既にいる自分より小さいIDを持つ学生とだけ握手をすると仮定します。\n\n例:\n>>> f_37(3, {2, 1, 0})\n0", "ko": "교실 시나리오에서 학생들이 교실에 들어오는 순서에 따라 총 악수 횟수를 계산합니다. 학생들은 ID가 0에서 N-1까지 범위에 있으며, 각 학생은 이미 교실에 있는 자신보다 작은 ID를 가진 학생들과만 악수를 한다고 가정합니다.\n\n예시:\n>>> f_37(3, {2, 1, 0})\n0", "ml": "വിദ്യാർത്ഥികളുടെ ഐ.ഡി.കൾ ക്ലാസ് മുറിയിൽ പ്രവേശിക്കുന്ന ക്രമത്തിൽ നൽകിയാൽ\n * ക്ലാസ് മുറിയിലെ ഒരു സാഹചര്യത്തിൽ ആകെ കൈകുലുക്കങ്ങളുടെ എണ്ണം കണക്കാക്കുന്നു. \n * വിദ്യാർത്ഥികൾക്ക് 0 മുതൽ N-1 വരെ ഐ.ഡി.കൾ ഉണ്ടെന്ന് ഇത് അനുമാനിക്കുന്നു \n * കൂടാതെ ഓരോ വിദ്യാർത്ഥിയും തങ്ങളുടെ ഐ.ഡി.യേക്കാൾ ചെറിയ ഐ.ഡി.യുള്ള \n * വിദ്യാർത്ഥികളുമായി മാത്രം കൈകുലുക്കം നടത്തും.\n\nഉദാഹരണങ്ങൾ:\n>>> f_37(3, {2, 1, 0})\n0", "fa": "محاسبه تعداد کل دست دادن‌ها در یک سناریوی کلاس درس با توجه به توالی شناسه‌های دانش‌آموزان هنگام ورود به کلاس. فرض بر این است که دانش‌آموزان دارای شناسه‌هایی از 0 تا N-1 هستند و هر دانش‌آموز فقط با دانش‌آموزانی که قبلاً با شناسه کوچکتر در کلاس حضور دارند دست می‌دهد.\n\nمثال‌ها:\n>>> f_37(3, {2, 1, 0})\n0"}}
{"task_id": "CPP/38", "prompt": {"en": "#include <cassert>\n#include <cstdio>\n/**\n * Given n positive integers representing the count of each number from 1 to n,\n * find the maximum sum of the mode (most frequent element) for all prefixes of\n * a sequence constructed from these numbers. The mode is the largest number among\n * the most frequent elements in a sequence.\n * \n * Example:\n * >>> f_38(3, {1, 2, 3})\n * 17\n * A sequence that reaches its maximum value is (3,2,3,1,2,2).\n */\nlong long f_38(int n, const int* counts)", "sq": "#include <cassert>\n#include <cstdio>\n/**\n * Duke pasur n numra pozitivë që përfaqësojnë numrin e secilit numër nga 1 deri në n,\n * gjeni shumën maksimale të modës (elementi më i shpeshtë) për të gjitha prefikset e\n * një sekuence të ndërtuar nga këta numra. Moda është numri më i madh ndër elementët\n * më të shpeshtë në një sekuencë.\n * \n * Shembull:\n * >>> f_38(3, {1, 2, 3})\n * 17\n * Një sekuencë që arrin vlerën e saj maksimale është (3,2,3,1,2,2).\n */\nlong long f_38(int n, const int* counts)", "hy": "#include <cassert>\n#include <cstdio>\n/**\n * Տրված է n դրական ամբողջ թվեր, որոնք ներկայացնում են 1-ից n թվերի քանակը,\n * գտնել մոդի (ամենահաճախ հանդիպող տարրը) առավելագույն գումարը բոլոր նախածանցների համար\n * հաջորդականության, որը կառուցված է այս թվերից։ Մոդը հաջորդականության ամենահաճախ հանդիպող\n * տարրերի մեջ ամենամեծ թիվն է։\n * \n * Օրինակ:\n * >>> f_38(3, {1, 2, 3})\n * 17\n * Հաջորդականություն, որը հասնում է իր առավելագույն արժեքին, (3,2,3,1,2,2) է։\n */\nlong long f_38(int n, const int* counts)", "bn": "#include <cassert>\n#include <cstdio>\n/**\n * n টি ধনাত্মক পূর্ণসংখ্যা দেওয়া আছে যা 1 থেকে n পর্যন্ত প্রতিটি সংখ্যার গণনা উপস্থাপন করে,\n * একটি ক্রমের সমস্ত উপসর্গের জন্য মোডের (সবচেয়ে ঘন ঘন উপাদান) সর্বাধিক যোগফল খুঁজে বের করুন\n * যা এই সংখ্যাগুলি থেকে নির্মিত। মোড হল একটি ক্রমের সবচেয়ে ঘন ঘন উপাদানগুলির মধ্যে বৃহত্তম সংখ্যা।\n * \n * উদাহরণ:\n * >>> f_38(3, {1, 2, 3})\n * 17\n * একটি ক্রম যা তার সর্বাধিক মানে পৌঁছায় তা হল (3,2,3,1,2,2)।\n */\nlong long f_38(int n, const int* counts)", "bg": "#include <cassert>\n#include <cstdio>\n/**\n * Дадени са n положителни цели числа, представляващи броя на всяко число от 1 до n,\n * намерете максималната сума на модата (най-често срещания елемент) за всички префикси на\n * последователност, конструирана от тези числа. Модата е най-голямото число сред\n * най-често срещаните елементи в последователност.\n * \n * Пример:\n * >>> f_38(3, {1, 2, 3})\n * 17\n * Последователност, която достига максималната си стойност, е (3,2,3,1,2,2).\n */\nlong long f_38(int n, const int* counts)", "zh": "#include <cassert>\n#include <cstdio>\n/**\n * 给定 n 个正整数，表示从 1 到 n 的每个数字的计数，\n * 找出从这些数字构造的序列的所有前缀的众数（最频繁元素）的最大和。\n * 众数是序列中最频繁元素中的最大数字。\n * \n * 示例:\n * >>> f_38(3, {1, 2, 3})\n * 17\n * 达到其最大值的序列是 (3,2,3,1,2,2)。\n */\nlong long f_38(int n, const int* counts)", "fr": "#include <cassert>\n#include <cstdio>\n/**\n * Étant donné n entiers positifs représentant le compte de chaque nombre de 1 à n,\n * trouver la somme maximale de la mode (élément le plus fréquent) pour tous les préfixes\n * d'une séquence construite à partir de ces nombres. La mode est le plus grand nombre parmi\n * les éléments les plus fréquents dans une séquence.\n * \n * Exemple :\n * >>> f_38(3, {1, 2, 3})\n * 17\n * Une séquence qui atteint sa valeur maximale est (3,2,3,1,2,2).\n */\nlong long f_38(int n, const int* counts)", "de": "#include <cassert>\n#include <cstdio>\n/**\n * Gegeben n positive ganze Zahlen, die die Anzahl jedes Zahl von 1 bis n darstellen,\n * finde die maximale Summe des Modus (häufigstes Element) für alle Präfixe einer\n * Sequenz, die aus diesen Zahlen konstruiert wurde. Der Modus ist die größte Zahl\n * unter den häufigsten Elementen in einer Sequenz.\n * \n * Beispiel:\n * >>> f_38(3, {1, 2, 3})\n * 17\n * Eine Sequenz, die ihren maximalen Wert erreicht, ist (3,2,3,1,2,2).\n */\nlong long f_38(int n, const int* counts)", "ha": "#include <cassert>\n#include <cstdio>\n/**\n * An ba da n lambobi masu kyau waɗanda ke wakiltar adadin kowace lamba daga 1 zuwa n,\n * nemo mafi girman jimlar yanayin (abu mafi yawa) don dukkanin farkon\n * jerin da aka gina daga waɗannan lambobin. Yanayin shine mafi girman lamba a cikin\n * abubuwan da suka fi yawa a cikin jerin.\n * \n * Misali:\n * >>> f_38(3, {1, 2, 3})\n * 17\n * Jerin da ya kai darajarsa mafi girma shine (3,2,3,1,2,2).\n */\nlong long f_38(int n, const int* counts)", "hi": "#include <cassert>\n#include <cstdio>\n/**\n * दिए गए n धनात्मक पूर्णांक जो 1 से n तक प्रत्येक संख्या की गिनती का प्रतिनिधित्व करते हैं,\n * उन सभी अनुक्रमों के उपसर्गों के लिए मोड (सबसे अधिक बार आने वाला तत्व) का अधिकतम योग खोजें\n * जो इन संख्याओं से निर्मित होते हैं। मोड अनुक्रम में सबसे अधिक बार आने वाले तत्वों में सबसे बड़ा संख्या है।\n * \n * उदाहरण:\n * >>> f_38(3, {1, 2, 3})\n * 17\n * एक अनुक्रम जो अपनी अधिकतम मान तक पहुँचता है वह है (3,2,3,1,2,2)।\n */\nlong long f_38(int n, const int* counts)", "hu": "#include <cassert>\n#include <cstdio>\n/**\n * Adott n pozitív egész szám, amelyek az 1-től n-ig terjedő számok előfordulási számát jelölik,\n * keresse meg a módusz (leggyakrabban előforduló elem) maximális összegét az összes prefixumra\n * egy ezekből a számokból felépített sorozat esetén. A módusz a legnagyobb szám a sorozat\n * leggyakrabban előforduló elemei között.\n * \n * Példa:\n * >>> f_38(3, {1, 2, 3})\n * 17\n * Egy sorozat, amely eléri a maximális értékét: (3,2,3,1,2,2).\n */\nlong long f_38(int n, const int* counts)", "es": "#include <cassert>\n#include <cstdio>\n/**\n * Dados n enteros positivos que representan el conteo de cada número de 1 a n,\n * encuentra la suma máxima del modo (elemento más frecuente) para todos los prefijos de\n * una secuencia construida a partir de estos números. El modo es el número más grande entre\n * los elementos más frecuentes en una secuencia.\n * \n * Ejemplo:\n * >>> f_38(3, {1, 2, 3})\n * 17\n * Una secuencia que alcanza su valor máximo es (3,2,3,1,2,2).\n */\nlong long f_38(int n, const int* counts)", "arb": "#include <cassert>\n#include <cstdio>\n/**\n * بالنظر إلى n من الأعداد الصحيحة الموجبة التي تمثل عدد كل رقم من 1 إلى n،\n * ابحث عن الحد الأقصى لمجموع النمط (العنصر الأكثر تكرارًا) لجميع البادئات\n * لتسلسل مُنشأ من هذه الأرقام. النمط هو أكبر رقم بين\n * العناصر الأكثر تكرارًا في تسلسل.\n * \n * مثال:\n * >>> f_38(3, {1, 2, 3})\n * 17\n * تسلسل يصل إلى قيمته القصوى هو (3,2,3,1,2,2).\n */\nlong long f_38(int n, const int* counts)", "sw": "#include <cassert>\n#include <cstdio>\n/**\n * Ukipewa n nambari chanya zinazowakilisha idadi ya kila nambari kutoka 1 hadi n,\n * pata jumla ya juu zaidi ya hali (kipengele kinachojitokeza mara nyingi zaidi) kwa viambishi vyote vya\n * mlolongo ulioundwa kutoka kwa nambari hizi. Hali ni nambari kubwa zaidi kati ya\n * vipengele vinavyojitokeza mara nyingi zaidi katika mlolongo.\n * \n * Mfano:\n * >>> f_38(3, {1, 2, 3})\n * 17\n * Mlolongo unaofikia thamani yake ya juu zaidi ni (3,2,3,1,2,2).\n */\nlong long f_38(int n, const int* counts)", "tr": "#include <cassert>\n#include <cstdio>\n/**\n * 1'den n'e kadar her sayının sayısını temsil eden n pozitif tamsayı verildiğinde,\n * bu sayılardan oluşturulan bir dizinin tüm önekleri için modun (en sık görülen eleman) maksimum toplamını bulun.\n * Mod, bir dizideki en sık görülen elemanlar arasında en büyük sayıdır.\n * \n * Örnek:\n * >>> f_38(3, {1, 2, 3})\n * 17\n * Maksimum değerine ulaşan bir dizi (3,2,3,1,2,2) şeklindedir.\n */\nlong long f_38(int n, const int* counts)", "vi": "#include <cassert>\n#include <cstdio>\n/**\n * Cho n số nguyên dương đại diện cho số lượng của mỗi số từ 1 đến n,\n * tìm tổng lớn nhất của mode (phần tử xuất hiện nhiều nhất) cho tất cả các tiền tố của\n * một dãy được tạo ra từ các số này. Mode là số lớn nhất trong số\n * các phần tử xuất hiện nhiều nhất trong một dãy.\n * \n * Ví dụ:\n * >>> f_38(3, {1, 2, 3})\n * 17\n * Một dãy đạt giá trị tối đa là (3,2,3,1,2,2).\n */\nlong long f_38(int n, const int* counts)", "id": "#include <cassert>\n#include <cstdio>\n/**\n * Diberikan n bilangan bulat positif yang mewakili jumlah masing-masing angka dari 1 hingga n,\n * temukan jumlah maksimum dari modus (elemen yang paling sering muncul) untuk semua awalan dari\n * sebuah urutan yang dibangun dari angka-angka ini. Modus adalah angka terbesar di antara\n * elemen yang paling sering muncul dalam sebuah urutan.\n * \n * Contoh:\n * >>> f_38(3, {1, 2, 3})\n * 17\n * Sebuah urutan yang mencapai nilai maksimumnya adalah (3,2,3,1,2,2).\n */\nlong long f_38(int n, const int* counts)", "ja": "#include <cassert>\n#include <cstdio>\n/**\n * 1からnまでの各数字のカウントを表すn個の正の整数が与えられたとき、\n * これらの数字から構成されたシーケンスのすべてのプレフィックスに対して\n * モード（最も頻繁に出現する要素）の最大合計を求めます。モードは、\n * シーケンス内で最も頻繁に出現する要素の中で最大の数字です。\n * \n * 例:\n * >>> f_38(3, {1, 2, 3})\n * 17\n * 最大値に達するシーケンスは (3,2,3,1,2,2) です。\n */\nlong long f_38(int n, const int* counts)", "ko": "#include <cassert>\n#include <cstdio>\n/**\n * 1부터 n까지의 각 숫자의 개수를 나타내는 n개의 양의 정수가 주어졌을 때,\n * 이러한 숫자로 구성된 시퀀스의 모든 접두사에 대해 최빈값(가장 빈번한 요소)의 최대 합을 찾습니다.\n * 최빈값은 시퀀스에서 가장 빈번한 요소 중 가장 큰 숫자입니다.\n * \n * 예시:\n * >>> f_38(3, {1, 2, 3})\n * 17\n * 최대값에 도달하는 시퀀스는 (3,2,3,1,2,2)입니다.\n */\nlong long f_38(int n, const int* counts)", "ml": "#include <cassert>\n#include <cstdio>\n/**\n * 1 മുതൽ n വരെ ഓരോ സംഖ്യയുടെ എണ്ണവും പ്രതിനിധീകരിക്കുന്ന n പോസിറ്റീവ് പൂർണ്ണസംഖ്യകൾ നൽകിയാൽ,\n * ഈ സംഖ്യകളിൽ നിന്ന് നിർമ്മിച്ച ഒരു അനുക്രമണത്തിന്റെ എല്ലാ പ്രിഫിക്സുകളുടെയും മോഡ് (ഏറ്റവും കൂടുതലായി പ്രത്യക്ഷപ്പെടുന്ന ഘടകം) \n * പരമാവധി തുക കണ്ടെത്തുക. ഒരു അനുക്രമണത്തിലെ ഏറ്റവും കൂടുതലായി പ്രത്യക്ഷപ്പെടുന്ന ഘടകങ്ങളിൽ ഏറ്റവും വലിയ സംഖ്യയാണ് മോഡ്.\n * \n * ഉദാഹരണം:\n * >>> f_38(3, {1, 2, 3})\n * 17\n * പരമാവധി മൂല്യത്തിലെത്തുന്ന ഒരു അനുക്രമണം (3,2,3,1,2,2) ആണ്.\n */\nlong long f_38(int n, const int* counts)", "fa": "#include <cassert>\n#include <cstdio>\n/**\n * با داشتن n عدد صحیح مثبت که نشان‌دهنده تعداد هر عدد از 1 تا n هستند،\n * حداکثر مجموع مد (عنصر با بیشترین تکرار) را برای تمام پیشوندهای\n * یک دنباله ساخته شده از این اعداد پیدا کنید. مد بزرگترین عدد در میان\n * عناصر با بیشترین تکرار در یک دنباله است.\n * \n * مثال:\n * >>> f_38(3, {1, 2, 3})\n * 17\n * دنباله‌ای که به حداکثر مقدار خود می‌رسد (3,2,3,1,2,2) است.\n */\nlong long f_38(int n, const int* counts)"}, "canonical_solution": "{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}", "instruction": {"en": "Write a CPP function `long long f_38(int n, const int* counts)` to solve the following problem:\nGiven n positive integers representing the count of each number from 1 to n,\nfind the maximum sum of the mode (most frequent element) for all prefixes of\na sequence constructed from these numbers. The mode is the largest number among\nthe most frequent elements in a sequence.\n\nExample:\n>>> f_38(3, {1, 2, 3})\n17\nA sequence that reaches its maximum value is (3,2,3,1,2,2).\n", "sq": "Shkruani një funksion CPP `long long f_38(int n, const int* counts)` për të zgjidhur problemin në vijim:\nDuke pasur n numra pozitivë që përfaqësojnë numrin e secilit numër nga 1 deri në n,\ngjeni shumën maksimale të modës (elementi më i shpeshtë) për të gjitha prefikset e\nnjë sekuence të ndërtuar nga këta numra. Moda është numri më i madh ndër elementët më të shpeshtë në një sekuencë.\n\nShembull:\n>>> f_38(3, {1, 2, 3})\n17\nNjë sekuencë që arrin vlerën e saj maksimale është (3,2,3,1,2,2).", "hy": "Գրեք CPP ֆունկցիա `long long f_38(int n, const int* counts)` հետևյալ խնդիրը լուծելու համար: \nՏրված են n դրական ամբողջ թվեր, որոնք ներկայացնում են 1-ից n թվերի քանակը, \nգտեք մոդի (ամենահաճախ հանդիպող տարրը) առավելագույն գումարը բոլոր նախածանցների համար \nայս թվերից կազմված հաջորդականության: Մոդը հաջորդականության ամենահաճախ հանդիպող տարրերի մեջ \nամենամեծ թիվն է:\n\nՕրինակ:\n>>> f_38(3, {1, 2, 3})\n17\nՀաջորդականություն, որը հասնում է իր առավելագույն արժեքին, (3,2,3,1,2,2) է:", "bn": "একটি CPP ফাংশন `long long f_38(int n, const int* counts)` লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\nপ্রতিটি সংখ্যা 1 থেকে n পর্যন্ত গণনা উপস্থাপনকারী n টি ধনাত্মক পূর্ণসংখ্যা দেওয়া হয়েছে, \nএই সংখ্যাগুলি থেকে গঠিত একটি ক্রমের সমস্ত উপসর্গের জন্য মোডের (সবচেয়ে ঘন ঘন উপাদান) সর্বাধিক যোগফল খুঁজে বের করুন। \nমোড হল একটি ক্রমের সবচেয়ে ঘন ঘন উপাদানগুলির মধ্যে বৃহত্তম সংখ্যা।\n\nউদাহরণ:\n>>> f_38(3, {1, 2, 3})\n17\nযে ক্রমটি তার সর্বাধিক মানে পৌঁছায় তা হল (3,2,3,1,2,2)।", "bg": "Напишете CPP функция `long long f_38(int n, const int* counts)`, за да решите следния проблем:\nДадени са n положителни цели числа, представляващи броя на всяко число от 1 до n,\nнамерете максималната сума на модата (най-често срещания елемент) за всички префикси на\nпоследователност, конструирана от тези числа. Модата е най-голямото число сред\nнай-често срещаните елементи в последователност.\n\nПример:\n>>> f_38(3, {1, 2, 3})\n17\nПоследователност, която достига максималната си стойност, е (3,2,3,1,2,2).", "zh": "编写一个 CPP 函数 `long long f_38(int n, const int* counts)` 来解决以下问题：\n给定 n 个正整数，表示从 1 到 n 的每个数字的计数，\n找出从这些数字构造的序列的所有前缀的众数（最频繁元素）的最大和。\n众数是在序列中最频繁元素中最大的数字。\n\n示例：\n>>> f_38(3, {1, 2, 3})\n17\n一个达到其最大值的序列是 (3,2,3,1,2,2)。", "fr": "Écrire une fonction CPP `long long f_38(int n, const int* counts)` pour résoudre le problème suivant :\nÉtant donné n entiers positifs représentant le compte de chaque nombre de 1 à n,\ntrouver la somme maximale du mode (élément le plus fréquent) pour tous les préfixes d'une séquence construite à partir de ces nombres. Le mode est le plus grand nombre parmi les éléments les plus fréquents dans une séquence.\n\nExemple:\n>>> f_38(3, {1, 2, 3})\n17\nUne séquence qui atteint sa valeur maximale est (3,2,3,1,2,2).", "de": "Schreiben Sie eine CPP-Funktion `long long f_38(int n, const int* counts)`, um das folgende Problem zu lösen:\nGegeben sind n positive ganze Zahlen, die die Anzahl jedes Zahl von 1 bis n darstellen,\nfinden Sie die maximale Summe des Modus (häufigstes Element) für alle Präfixe einer\nSequenz, die aus diesen Zahlen konstruiert wird. Der Modus ist die größte Zahl unter\nden häufigsten Elementen in einer Sequenz.\n\nBeispiel:\n>>> f_38(3, {1, 2, 3})\n17\nEine Sequenz, die ihren Maximalwert erreicht, ist (3,2,3,1,2,2).", "ha": "Rubuta aikin CPP `long long f_38(int n, const int* counts)` don warware matsalar mai zuwa:\nAn ba da lambobi masu kyau n da ke wakiltar adadin kowace lamba daga 1 zuwa n,\nnemo mafi girman jimlar yanayin (mafi yawan abu) don dukkan farkon\njerin da aka gina daga waɗannan lambobin. Yanayin shine mafi girman lamba a cikin\nmafi yawan abubuwa a cikin jerin.\n\nMisali:\n>>> f_38(3, {1, 2, 3})\n17\nJerin da ke kaiwa ga darajarsa mafi girma shine (3,2,3,1,2,2).", "hi": "एक CPP फ़ंक्शन `long long f_38(int n, const int* counts)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए n धनात्मक पूर्णांक जो 1 से n तक प्रत्येक संख्या की गिनती का प्रतिनिधित्व करते हैं,\nउन सभी अनुक्रमों के उपसर्गों के लिए मोड (सबसे अधिक बार आने वाला तत्व) का अधिकतम योग खोजें जो इन संख्याओं से निर्मित होते हैं। मोड अनुक्रम में सबसे अधिक बार आने वाले तत्वों में सबसे बड़ी संख्या होती है।\n\nउदाहरण:\n>>> f_38(3, {1, 2, 3})\n17\nएक अनुक्रम जो अपने अधिकतम मान तक पहुँचता है वह है (3,2,3,1,2,2)।", "hu": "Írj egy CPP függvényt `long long f_38(int n, const int* counts)` a következő probléma megoldására:\nAdott n pozitív egész szám, amelyek az 1-től n-ig terjedő számok előfordulási számát jelölik,\ntaláld meg a módusz (leggyakrabban előforduló elem) maximális összegét az\nezekből a számokból felépített sorozat minden prefixére. A módusz a legnagyobb szám a sorozat leggyakrabban előforduló elemei között.\n\nPélda:\n>>> f_38(3, {1, 2, 3})\n17\nEgy sorozat, amely eléri a maximális értékét: (3,2,3,1,2,2).", "es": "Escribe una función CPP `long long f_38(int n, const int* counts)` para resolver el siguiente problema:\nDado n enteros positivos que representan la cantidad de cada número de 1 a n,\nencuentra la suma máxima del modo (elemento más frecuente) para todos los prefijos de\nuna secuencia construida a partir de estos números. El modo es el número más grande entre\nlos elementos más frecuentes en una secuencia.\n\nEjemplo:\n>>> f_38(3, {1, 2, 3})\n17\nUna secuencia que alcanza su valor máximo es (3,2,3,1,2,2).", "arb": "اكتب دالة CPP `long long f_38(int n, const int* counts)` لحل المشكلة التالية:\nمعطى n من الأعداد الصحيحة الموجبة التي تمثل عدد كل رقم من 1 إلى n،\nابحث عن الحد الأقصى لمجموع النمط (العنصر الأكثر تكرارًا) لجميع البوادئ\nلسلسلة مكونة من هذه الأرقام. النمط هو أكبر رقم بين العناصر الأكثر تكرارًا في سلسلة.\n\nمثال:\n>>> f_38(3, {1, 2, 3})\n17\nسلسلة تصل إلى قيمتها القصوى هي (3,2,3,1,2,2).", "sw": "Andika kazi ya CPP `long long f_38(int n, const int* counts)` kutatua tatizo lifuatalo:\nUkipewa n nambari chanya zinazowakilisha idadi ya kila nambari kutoka 1 hadi n,\ntafuta jumla ya juu zaidi ya hali (kipengele kinachojitokeza mara nyingi zaidi) kwa viambishi vyote vya\nmfuatano ulioundwa kutoka kwa nambari hizi. Hali ni nambari kubwa zaidi kati ya\nvipengele vinavyojitokeza mara nyingi zaidi katika mfuatano.\n\nMfano:\n>>> f_38(3, {1, 2, 3})\n17\nMfuatano unaofikia thamani yake ya juu zaidi ni (3,2,3,1,2,2).", "tr": "Bir CPP fonksiyonu `long long f_38(int n, const int* counts)` yazın ve aşağıdaki problemi çözün:\n1'den n'ye kadar olan her sayının sayısını temsil eden n pozitif tamsayı verildiğinde,\nbu sayılardan oluşturulan bir dizinin tüm önekleri için modun (en sık görülen eleman) maksimum toplamını bulun. Mod, bir dizideki en sık görülen elemanlar arasında en büyük sayıdır.\n\nÖrnek:\n>>> f_38(3, {1, 2, 3})\n17\nMaksimum değerine ulaşan bir dizi (3,2,3,1,2,2) şeklindedir.", "vi": "Viết một hàm CPP `long long f_38(int n, const int* counts)` để giải quyết vấn đề sau:\nCho n số nguyên dương đại diện cho số lượng của mỗi số từ 1 đến n,\ntìm tổng lớn nhất của mode (phần tử xuất hiện nhiều nhất) cho tất cả các tiền tố của\nmột dãy được tạo từ các số này. Mode là số lớn nhất trong số các phần tử xuất hiện nhiều nhất trong một dãy.\n\nVí dụ:\n>>> f_38(3, {1, 2, 3})\n17\nMột dãy đạt giá trị tối đa là (3,2,3,1,2,2).", "id": "Tulis fungsi CPP `long long f_38(int n, const int* counts)` untuk menyelesaikan masalah berikut:\nDiberikan n bilangan bulat positif yang mewakili jumlah masing-masing angka dari 1 hingga n,\ntemukan jumlah maksimum dari modus (elemen yang paling sering muncul) untuk semua awalan dari\nsebuah urutan yang dibangun dari angka-angka ini. Modus adalah angka terbesar di antara\nelemen yang paling sering muncul dalam sebuah urutan.\n\nContoh:\n>>> f_38(3, {1, 2, 3})\n17\nUrutan yang mencapai nilai maksimumnya adalah (3,2,3,1,2,2).", "ja": "以下の問題を解くために、CPP関数 `long long f_38(int n, const int* counts)` を作成してください:\n1からnまでの各数の出現回数を表すn個の正の整数が与えられたとき、\nこれらの数から構成されるシーケンスのすべての接頭辞に対するモード（最頻要素）の最大合計を求めます。モードは、シーケンス内の最頻要素の中で最大の数です。\n\n例:\n>>> f_38(3, {1, 2, 3})\n17\n最大値に達するシーケンスは (3,2,3,1,2,2) です。", "ko": "`long long f_38(int n, const int* counts)` 함수를 작성하여 다음 문제를 해결하십시오:\n1부터 n까지의 각 숫자의 개수를 나타내는 n개의 양의 정수가 주어졌을 때, 이러한 숫자로 구성된 시퀀스의 모든 접두사의 최빈값(가장 빈번한 요소)의 최대 합을 찾으십시오. 최빈값은 시퀀스에서 가장 빈번한 요소 중 가장 큰 숫자입니다.\n\n예시:\n>>> f_38(3, {1, 2, 3})\n17\n최대값에 도달하는 시퀀스는 (3,2,3,1,2,2)입니다.", "ml": "ഒരു സിപിപി ഫംഗ്ഷൻ എഴുതുക `long long f_38(int n, const int* counts)` താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\n1 മുതൽ n വരെ ഉള്ള ഓരോ സംഖ്യയുടെ എണ്ണത്തെ പ്രതിനിധീകരിക്കുന്ന n അനുകൂല സംഖ്യകൾ നൽകിയാൽ, ഈ സംഖ്യകളിൽ നിന്ന് നിർമ്മിച്ച ഒരു അനുക്രമണത്തിന്റെ എല്ലാ മുൻഗാമികളുടെയും മോഡ് (ഏറ്റവും സാധാരണമായ ഘടകം) പരമാവധി തുക കണ്ടെത്തുക. ഒരു അനുക്രമണത്തിലെ ഏറ്റവും സാധാരണമായ ഘടകങ്ങളിൽ ഏറ്റവും വലിയ സംഖ്യയാണ് മോഡ്.\n\nഉദാഹരണം:\n>>> f_38(3, {1, 2, 3})\n17\nപരമാവധി മൂല്യത്തിലെത്തുന്ന ഒരു അനുക്രമണം (3,2,3,1,2,2) ആണ്.", "fa": "یک تابع CPP به نام `long long f_38(int n, const int* counts)` بنویسید تا مسئله زیر را حل کند:\nبا توجه به n عدد صحیح مثبت که نشان‌دهنده تعداد هر عدد از 1 تا n هستند،\nحداکثر مجموع مد (عنصر پرتکرار) را برای تمام پیشوندهای\nیک دنباله ساخته شده از این اعداد پیدا کنید. مد بزرگترین عدد در میان عناصر پرتکرار در یک دنباله است.\n\nمثال:\n>>> f_38(3, {1, 2, 3})\n17\nیک دنباله که به حداکثر مقدار خود می‌رسد (3,2,3,1,2,2) است."}, "level": "middle", "test": "int main() {\n    int a1[] = {1, 3, 2};\n    int a2[] = {4, 1, 2, 3};\n    int a3[] = {1, 1};\n    int a4[] = {1, 2, 3, 4, 5};\n    int a5[] = {100000};\n    int a6[] = {5, 3, 2, 4, 1};\n    int a7[] = {100000, 100000, 100000};\n    int a8[] = {2, 2, 5};\n    int a9[] = {4, 4, 4, 4};\n    int a10[] = {1, 2, 3, 4, 5, 6};\n    int a11[] = {3, 1, 2};\n\n    assert(f_38(3, a1) == 17);\n    assert(f_38(4, a2) == 37);\n    assert(f_38(2, a3) == 4);\n    assert(f_38(5, a4) == 75);\n    assert(f_38(1, a5) == 100000);\n    assert(f_38(5, a6) == 62);\n    assert(f_38(3, a7) == 900000);\n    assert(f_38(3, a8) == 27);\n    assert(f_38(4, a9) == 64);\n    assert(f_38(6, a10) == 126);\n    assert(f_38(3, a11) == 16);\n    return 0;\n}", "entry_point": "f_38", "signature": "long long f_38(int n, const int* counts)", "docstring": {"en": "Given n positive integers representing the count of each number from 1 to n,\nfind the maximum sum of the mode (most frequent element) for all prefixes of\na sequence constructed from these numbers. The mode is the largest number among\nthe most frequent elements in a sequence.\n\nExample:\n>>> f_38(3, {1, 2, 3})\n17\nA sequence that reaches its maximum value is (3,2,3,1,2,2).\n", "sq": "Duke pasur n numra pozitivë që përfaqësojnë numrin e secilit numër nga 1 deri në n,\ngjeni shumën maksimale të modës (elementi më i shpeshtë) për të gjitha prefikset e\nnjë sekuence të ndërtuar nga këta numra. Moda është numri më i madh ndër elementet më të shpeshta në një sekuencë.\n\nShembull:\n>>> f_38(3, {1, 2, 3})\n17\nNjë sekuencë që arrin vlerën e saj maksimale është (3,2,3,1,2,2).", "hy": "Տրված են n դրական ամբողջ թվեր, որոնք ներկայացնում են 1-ից n թվերի քանակը,\nգտնել մաքսիմալ գումարը մոդի (ամենահաճախ հանդիպող տարրը) բոլոր նախածանցների\nհամար, որոնք կազմված են այս թվերից։ Մոդը ամենամեծ թիվն է ամենահաճախ հանդիպող տարրերի մեջ հաջորդականության։\n\nՕրինակ:\n>>> f_38(3, {1, 2, 3})\n17\nՀաջորդականությունը, որը հասնում է իր մաքսիմալ արժեքին, (3,2,3,1,2,2) է։", "bn": "n টি ধনাত্মক পূর্ণসংখ্যা দেওয়া আছে যা 1 থেকে n পর্যন্ত প্রতিটি সংখ্যার গণনা উপস্থাপন করে, একটি ক্রম থেকে সমস্ত উপসর্গের জন্য মোডের (সবচেয়ে ঘন ঘন উপাদান) সর্বাধিক যোগফল খুঁজে বের করুন। মোড হল একটি ক্রমের সবচেয়ে ঘন ঘন উপাদানগুলির মধ্যে বৃহত্তম সংখ্যা।\n\nউদাহরণ:\n>>> f_38(3, {1, 2, 3})\n17\nযে ক্রমটি তার সর্বাধিক মানে পৌঁছায় তা হল (3,2,3,1,2,2)।", "bg": "Дадени са n положителни цели числа, представляващи броя на всяко число от 1 до n, намерете максималната сума на модата (най-често срещания елемент) за всички префикси на последователност, конструирана от тези числа. Модата е най-голямото число сред най-често срещаните елементи в последователност.\n\nПример:\n>>> f_38(3, {1, 2, 3})\n17\nПоследователност, която достига своята максимална стойност, е (3,2,3,1,2,2).", "zh": "给定 n 个正整数，表示从 1 到 n 的每个数字的计数，找出从这些数字构造的序列的所有前缀的众数（最频繁元素）的最大和。众数是序列中最频繁元素中最大的数字。\n\n示例：\n>>> f_38(3, {1, 2, 3})\n17\n达到其最大值的序列是 (3,2,3,1,2,2)。", "fr": "Étant donné n entiers positifs représentant le compte de chaque nombre de 1 à n, trouvez la somme maximale du mode (élément le plus fréquent) pour tous les préfixes d'une séquence construite à partir de ces nombres. Le mode est le plus grand nombre parmi les éléments les plus fréquents dans une séquence.\n\nExemple :\n>>> f_38(3, {1, 2, 3})\n17\nUne séquence qui atteint sa valeur maximale est (3,2,3,1,2,2).", "de": "Gegeben n positive ganze Zahlen, die die Anzahl jedes Zahl von 1 bis n darstellen, finde die maximale Summe des Modus (häufigstes Element) für alle Präfixe einer Sequenz, die aus diesen Zahlen konstruiert wurde. Der Modus ist die größte Zahl unter den häufigsten Elementen in einer Sequenz.\n\nBeispiel:\n>>> f_38(3, {1, 2, 3})\n17\nEine Sequenz, die ihren maximalen Wert erreicht, ist (3,2,3,1,2,2).", "ha": "An ba n lambobi masu kyau waɗanda ke wakiltar adadin kowace lamba daga 1 zuwa n, nemo mafi girman jimlar yanayin (abin da ya fi yawa) don dukkan gabanin jerin da aka gina daga waɗannan lambobin. Yanayin shine mafi girman lamba a cikin abubuwan da suka fi yawa a cikin jerin.\n\nMisali:\n>>> f_38(3, {1, 2, 3})\n17\nJerin da ya kai darajarsa mafi girma shine (3,2,3,1,2,2).", "hi": "दिए गए n धनात्मक पूर्णांक जो 1 से n तक प्रत्येक संख्या की गिनती का प्रतिनिधित्व करते हैं, उन सभी अनुक्रमों के उपसर्गों के लिए मोड (सबसे अधिक बार आने वाला तत्व) का अधिकतम योग खोजें जो इन संख्याओं से निर्मित होते हैं। मोड एक अनुक्रम में सबसे अधिक बार आने वाले तत्वों में सबसे बड़ा संख्या होता है।\n\nउदाहरण:\n>>> f_38(3, {1, 2, 3})\n17\nएक अनुक्रम जो अपनी अधिकतम मान तक पहुँचता है वह है (3,2,3,1,2,2)।", "hu": "Adott n pozitív egész szám, amelyek az 1-től n-ig terjedő számok számosságát jelzik, \nkeresse meg a módusz (leggyakrabban előforduló elem) maximális összegét egy \nezekből a számokból felépített sorozat minden prefixére. A módusz a sorozat \nleggyakrabban előforduló elemei közül a legnagyobb szám.\n\nPélda:\n>>> f_38(3, {1, 2, 3})\n17\nEgy sorozat, amely eléri a maximális értékét: (3,2,3,1,2,2).", "es": "Dado n enteros positivos que representan el conteo de cada número del 1 al n, encuentra la suma máxima del modo (elemento más frecuente) para todos los prefijos de una secuencia construida a partir de estos números. El modo es el número más grande entre los elementos más frecuentes en una secuencia.\n\nEjemplo:\n>>> f_38(3, {1, 2, 3})\n17\nUna secuencia que alcanza su valor máximo es (3,2,3,1,2,2).", "arb": "إعطاء n أعداد صحيحة موجبة تمثل عدد كل رقم من 1 إلى n، \nابحث عن أكبر مجموع للوضع (العنصر الأكثر تكرارًا) لجميع البادئات في تسلسل مُنشأ من هذه الأرقام. الوضع هو أكبر رقم بين العناصر الأكثر تكرارًا في تسلسل.\n\nمثال:\n>>> f_38(3, {1, 2, 3})\n17\nالتسلسل الذي يصل إلى قيمته القصوى هو (3,2,3,1,2,2).", "sw": "Kutolewa n nambari chanya zinazowakilisha idadi ya kila nambari kutoka 1 hadi n, pata jumla ya juu zaidi ya modi (kipengele kinachojitokeza mara nyingi zaidi) kwa viambishi vyote vya mlolongo ulioundwa kutoka kwa nambari hizi. Modi ni nambari kubwa zaidi kati ya vipengele vinavyojitokeza mara nyingi zaidi katika mlolongo.\n\nMfano:\n>>> f_38(3, {1, 2, 3})\n17\nMlolongo unaofikia thamani yake ya juu zaidi ni (3,2,3,1,2,2).", "tr": "Verilen n pozitif tam sayı, 1'den n'e kadar olan her sayının sayısını temsil eder,\nbu sayılardan oluşturulan bir dizinin tüm önekleri için modun (en sık görülen eleman) maksimum toplamını bulun. Mod, bir dizideki en sık görülen elemanlar arasında en büyük sayıdır.\n\nÖrnek:\n>>> f_38(3, {1, 2, 3})\n17\nMaksimum değerine ulaşan bir dizi (3,2,3,1,2,2) şeklindedir.", "vi": "Cho n số nguyên dương đại diện cho số lượng của mỗi số từ 1 đến n, tìm tổng lớn nhất của mode (phần tử xuất hiện nhiều nhất) cho tất cả các tiền tố của một dãy được tạo thành từ các số này. Mode là số lớn nhất trong số các phần tử xuất hiện nhiều nhất trong một dãy.\n\nVí dụ:\n>>> f_38(3, {1, 2, 3})\n17\nMột dãy đạt giá trị lớn nhất là (3,2,3,1,2,2).", "id": "Diberikan n bilangan bulat positif yang mewakili jumlah dari setiap angka dari 1 hingga n, temukan jumlah maksimum dari modus (elemen yang paling sering muncul) untuk semua awalan dari sebuah urutan yang dibangun dari angka-angka ini. Modus adalah angka terbesar di antara elemen yang paling sering muncul dalam sebuah urutan.\n\nContoh:\n>>> f_38(3, {1, 2, 3})\n17\nSebuah urutan yang mencapai nilai maksimumnya adalah (3,2,3,1,2,2).", "ja": "n個の正の整数が1からnまでの各数のカウントを表しているとき、これらの数から構成されるシーケンスのすべての接頭辞に対するモード（最も頻繁に出現する要素）の最大合計を見つけます。モードとは、シーケンス内で最も頻繁に出現する要素の中で最大の数です。\n\n例:\n>>> f_38(3, {1, 2, 3})\n17\n最大値に達するシーケンスは (3,2,3,1,2,2) です。", "ko": "n개의 양의 정수가 1부터 n까지 각 숫자의 개수를 나타낼 때, 이러한 숫자로 구성된 시퀀스의 모든 접두사에 대한 최빈값(가장 빈번한 요소)의 최대 합을 찾습니다. 최빈값은 시퀀스에서 가장 빈번한 요소 중 가장 큰 숫자입니다.\n\n예시:\n>>> f_38(3, {1, 2, 3})\n17\n최대값에 도달하는 시퀀스는 (3,2,3,1,2,2)입니다.", "ml": "നൽകിയ n പോസിറ്റീവ് പൂർണ്ണസംഖ്യകൾ ഓരോ സംഖ്യയുടെ എണ്ണവും 1 മുതൽ n വരെ പ്രതിനിധീകരിക്കുന്നു, \nഈ സംഖ്യകളിൽ നിന്ന് നിർമ്മിച്ച ഒരു ശ്രേണിയുടെ എല്ലാ മുൻഗാമികളുടെ മോഡ് (ഏറ്റവും അധികം ആവർത്തിക്കുന്ന ഘടകം) \nപരമാവധി തുക കണ്ടെത്തുക. ഒരു ശ്രേണിയിലെ ഏറ്റവും അധികം ആവർത്തിക്കുന്ന ഘടകങ്ങളിൽ ഏറ്റവും വലിയ സംഖ്യയാണ് മോഡ്.\n\nഉദാഹരണം:\n>>> f_38(3, {1, 2, 3})\n17\nഅതിന്റേതായ പരമാവധി മൂല്യത്തിലെത്തുന്ന ഒരു ശ്രേണി (3,2,3,1,2,2) ആണ്.", "fa": "با توجه به n عدد صحیح مثبت که نشان‌دهنده تعداد هر عدد از 1 تا n هستند، حداکثر مجموع مد (عنصر با بیشترین تکرار) را برای همه پیشوندهای یک دنباله ساخته شده از این اعداد بیابید. مد بزرگترین عدد در میان عناصر با بیشترین تکرار در یک دنباله است.\n\nمثال:\n>>> f_38(3, {1, 2, 3})\n17\nیک دنباله که به حداکثر مقدار خود می‌رسد (3,2,3,1,2,2) است."}}
{"task_id": "CPP/39", "prompt": {"en": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Given an array A of integers, the task is to calculate the sum of the XOR of all subarrays.\n * A subarray is defined by a pair of indices (L, R) such that 1 <= L <= R <= n, where n is the size of the array.\n * The XOR sum of a subarray is the result of XORing all elements from L to R.\n * The final result is the sum of the XOR sums for all possible subarrays.\n *\n * Example cases:\n *     >>> f_39({1, 2, 3, 4, 5}, 5)\n *     39\n */\nlong long f_39(const std::vector<int>& A)", "sq": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Duke pasur një varg A të numrave të plotë, detyra është të llogaritet shuma e XOR-it të të gjitha nënvargjeve.\n * Një nënvarg përcaktohet nga një çift indeksesh (L, R) të tilla që 1 <= L <= R <= n, ku n është madhësia e vargut.\n * Shuma XOR e një nënvargu është rezultati i XOR-it të të gjitha elementeve nga L në R.\n * Rezultati përfundimtar është shuma e shumave XOR për të gjitha nënvargjet e mundshme.\n *\n * Shembuj të rasteve:\n *     >>> f_39({1, 2, 3, 4, 5}, 5)\n *     39\n */\nlong long f_39(const std::vector<int>& A)", "hy": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Տրված է ամբողջ թվերի զանգված A, խնդիրն է հաշվարկել բոլոր ենթազանգվածների XOR-ի գումարը:\n * Ենթազանգվածը սահմանվում է (L, R) ինդեքսների զույգով, այնպես, որ 1 <= L <= R <= n, որտեղ n-ը զանգվածի չափն է:\n * Ենթազանգվածի XOR գումարը L-ից R բոլոր տարրերի XOR-ի արդյունքն է:\n * Վերջնական արդյունքը բոլոր հնարավոր ենթազանգվածների XOR գումարների գումարն է:\n *\n * Օրինակներ:\n *     >>> f_39({1, 2, 3, 4, 5}, 5)\n *     39\n */\nlong long f_39(const std::vector<int>& A)", "bn": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * একটি পূর্ণসংখ্যার অ্যারে A দেওয়া আছে, কাজটি হল সমস্ত উপঅ্যারের XOR এর যোগফল গণনা করা।\n * একটি উপঅ্যারে একটি জোড়া সূচক (L, R) দ্বারা সংজ্ঞায়িত করা হয় যেখানে 1 <= L <= R <= n, যেখানে n হল অ্যারের আকার।\n * একটি উপঅ্যারের XOR যোগফল হল L থেকে R পর্যন্ত সমস্ত উপাদান XOR করার ফলাফল।\n * চূড়ান্ত ফলাফল হল সমস্ত সম্ভাব্য উপঅ্যারের জন্য XOR যোগফলের যোগফল।\n *\n * উদাহরণ কেস:\n *     >>> f_39({1, 2, 3, 4, 5}, 5)\n *     39\n */\nlong long f_39(const std::vector<int>& A)", "bg": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Даден е масив A от цели числа, задачата е да се изчисли сумата на XOR на всички подмасиви.\n * Подмасив се дефинира чрез двойка индекси (L, R) така че 1 <= L <= R <= n, където n е размерът на масива.\n * XOR сумата на подмасив е резултатът от XOR на всички елементи от L до R.\n * Крайният резултат е сумата от XOR сумите за всички възможни подмасиви.\n *\n * Примерни случаи:\n *     >>> f_39({1, 2, 3, 4, 5}, 5)\n *     39\n */\nlong long f_39(const std::vector<int>& A)", "zh": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * 给定一个整数数组A，任务是计算所有子数组的异或和的总和。\n * 子数组由一对索引(L, R)定义，其中1 <= L <= R <= n，n是数组的大小。\n * 子数组的异或和是从L到R的所有元素的异或结果。\n * 最终结果是所有可能子数组的异或和的总和。\n *\n * 示例案例:\n *     >>> f_39({1, 2, 3, 4, 5}, 5)\n *     39\n */\nlong long f_39(const std::vector<int>& A)", "fr": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Étant donné un tableau A d'entiers, la tâche consiste à calculer la somme du XOR de tous les sous-tableaux.\n * Un sous-tableau est défini par une paire d'indices (L, R) telle que 1 <= L <= R <= n, où n est la taille du tableau.\n * La somme XOR d'un sous-tableau est le résultat du XOR de tous les éléments de L à R.\n * Le résultat final est la somme des sommes XOR pour tous les sous-tableaux possibles.\n *\n * Exemples de cas :\n *     >>> f_39({1, 2, 3, 4, 5}, 5)\n *     39\n */\nlong long f_39(const std::vector<int>& A)", "de": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Gegeben ein Array A von ganzen Zahlen, besteht die Aufgabe darin, die Summe des XOR aller Teilarrays zu berechnen.\n * Ein Teilarray wird durch ein Paar von Indizes (L, R) definiert, so dass 1 <= L <= R <= n, wobei n die Größe des Arrays ist.\n * Die XOR-Summe eines Teilarrays ist das Ergebnis des XORs aller Elemente von L bis R.\n * Das Endergebnis ist die Summe der XOR-Summen für alle möglichen Teilarrays.\n *\n * Beispiel-Fälle:\n *     >>> f_39({1, 2, 3, 4, 5}, 5)\n *     39\n */\nlong long f_39(const std::vector<int>& A)", "ha": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * An ba da wani tsari A na lambobin cikakke, aikin shi ne a lissafa jimillar XOR na dukkan ƙananan tsaruka.\n * Ana ayyana ƙananan tsari ta hanyar ma'aurata na alamomin (L, R) ta yadda 1 <= L <= R <= n, inda n shine girman tsari.\n * Jimillar XOR na ƙananan tsari ita ce sakamakon XORing dukkan abubuwa daga L zuwa R.\n * Sakamakon ƙarshe shine jimillar XOR na dukkan yiwuwar ƙananan tsaruka.\n *\n * Misalan lokuta:\n *     >>> f_39({1, 2, 3, 4, 5}, 5)\n *     39\n */\nlong long f_39(const std::vector<int>& A)", "hi": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * दिए गए पूर्णांकों की एक array A के लिए, कार्य यह है कि सभी उप-श्रृंखलाओं के XOR का योग गणना करें।\n * एक उप-श्रृंखला को (L, R) सूचकांक की एक जोड़ी द्वारा परिभाषित किया जाता है, जहाँ 1 <= L <= R <= n, जहाँ n array का आकार है।\n * एक उप-श्रृंखला का XOR योग L से R तक के सभी तत्वों के XOR का परिणाम है।\n * अंतिम परिणाम सभी संभावित उप-श्रृंखलाओं के लिए XOR योगों का योग है।\n *\n * उदाहरण मामले:\n *     >>> f_39({1, 2, 3, 4, 5}, 5)\n *     39\n */\nlong long f_39(const std::vector<int>& A)", "hu": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Adott egy A egész számokat tartalmazó tömb, a feladat az, hogy kiszámoljuk az összes részhalmaz XOR összegét.\n * Egy részhalmazt egy (L, R) indexpár határoz meg, ahol 1 <= L <= R <= n, ahol n a tömb mérete.\n * Egy részhalmaz XOR összege az L-től R-ig terjedő összes elem XOR-olásának eredménye.\n * A végső eredmény az összes lehetséges részhalmaz XOR összegeinek összege.\n *\n * Példa esetek:\n *     >>> f_39({1, 2, 3, 4, 5}, 5)\n *     39\n */\nlong long f_39(const std::vector<int>& A)", "es": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Dado un array A de enteros, la tarea es calcular la suma del XOR de todos los subarrays.\n * Un subarray se define por un par de índices (L, R) tal que 1 <= L <= R <= n, donde n es el tamaño del array.\n * La suma XOR de un subarray es el resultado de aplicar XOR a todos los elementos desde L hasta R.\n * El resultado final es la suma de las sumas XOR para todos los subarrays posibles.\n *\n * Casos de ejemplo:\n *     >>> f_39({1, 2, 3, 4, 5}, 5)\n *     39\n */\nlong long f_39(const std::vector<int>& A)", "arb": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * بالنظر إلى مصفوفة A من الأعداد الصحيحة، المهمة هي حساب مجموع XOR لجميع المصفوفات الجزئية.\n * يتم تعريف المصفوفة الجزئية بواسطة زوج من الفهارس (L, R) بحيث 1 <= L <= R <= n، حيث n هو حجم المصفوفة.\n * مجموع XOR لمصفوفة جزئية هو نتيجة XOR لجميع العناصر من L إلى R.\n * النتيجة النهائية هي مجموع مجموعات XOR لجميع المصفوفات الجزئية الممكنة.\n *\n * أمثلة الحالات:\n *     >>> f_39({1, 2, 3, 4, 5}, 5)\n *     39\n */\nlong long f_39(const std::vector<int>& A)", "sw": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Ukipewa safu A ya nambari za mzima, kazi ni kuhesabu jumla ya XOR ya vipengele vidogo vyote.\n * Kipengele kidogo kinatajwa na jozi ya faharasa (L, R) ambapo 1 <= L <= R <= n, ambapo n ni ukubwa wa safu.\n * Jumla ya XOR ya kipengele kidogo ni matokeo ya XOR ya vipengele vyote kutoka L hadi R.\n * Matokeo ya mwisho ni jumla ya XOR za vipengele vidogo vyote vinavyowezekana.\n *\n * Mifano ya kesi:\n *     >>> f_39({1, 2, 3, 4, 5}, 5)\n *     39\n */\nlong long f_39(const std::vector<int>& A)", "tr": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Bir tamsayı dizisi A verildiğinde, görev tüm alt dizilerin XOR toplamını hesaplamaktır.\n * Bir alt dizi, 1 <= L <= R <= n olacak şekilde (L, R) indeks çifti ile tanımlanır, burada n dizinin boyutudur.\n * Bir alt dizinin XOR toplamı, L'den R'ye kadar olan tüm elemanların XOR işlemine tabi tutulmasının sonucudur.\n * Nihai sonuç, tüm olası alt diziler için XOR toplamlarının toplamıdır.\n *\n * Örnek durumlar:\n *     >>> f_39({1, 2, 3, 4, 5}, 5)\n *     39\n */\nlong long f_39(const std::vector<int>& A)", "vi": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Cho một mảng A gồm các số nguyên, nhiệm vụ là tính tổng của XOR của tất cả các mảng con.\n * Một mảng con được định nghĩa bởi một cặp chỉ số (L, R) sao cho 1 <= L <= R <= n, trong đó n là kích thước của mảng.\n * Tổng XOR của một mảng con là kết quả của việc thực hiện XOR tất cả các phần tử từ L đến R.\n * Kết quả cuối cùng là tổng của các tổng XOR cho tất cả các mảng con có thể.\n *\n * Các trường hợp ví dụ:\n *     >>> f_39({1, 2, 3, 4, 5}, 5)\n *     39\n */\nlong long f_39(const std::vector<int>& A)", "id": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Diberikan sebuah array A dari bilangan bulat, tugasnya adalah menghitung jumlah dari XOR semua subarray.\n * Sebuah subarray didefinisikan oleh sepasang indeks (L, R) sehingga 1 <= L <= R <= n, di mana n adalah ukuran array.\n * Jumlah XOR dari sebuah subarray adalah hasil dari XOR semua elemen dari L hingga R.\n * Hasil akhirnya adalah jumlah dari semua hasil XOR untuk semua subarray yang mungkin.\n *\n * Contoh kasus:\n *     >>> f_39({1, 2, 3, 4, 5}, 5)\n *     39\n */\nlong long f_39(const std::vector<int>& A)", "ja": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * 整数の配列 A が与えられたとき、すべての部分配列の XOR の合計を計算するタスクです。\n * 部分配列は、1 <= L <= R <= n のインデックスのペア (L, R) によって定義されます。ここで、n は配列のサイズです。\n * 部分配列の XOR 合計は、L から R までのすべての要素を XOR した結果です。\n * 最終的な結果は、考えられるすべての部分配列の XOR 合計の合計です。\n *\n * 例:\n *     >>> f_39({1, 2, 3, 4, 5}, 5)\n *     39\n */\nlong long f_39(const std::vector<int>& A)", "ko": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * 정수 배열 A가 주어졌을 때, 모든 부분 배열의 XOR 합을 계산하는 작업입니다.\n * 부분 배열은 인덱스 쌍 (L, R)에 의해 정의되며, 여기서 1 <= L <= R <= n이고, n은 배열의 크기입니다.\n * 부분 배열의 XOR 합은 L에서 R까지의 모든 요소를 XOR한 결과입니다.\n * 최종 결과는 가능한 모든 부분 배열의 XOR 합의 합입니다.\n *\n * 예제 사례:\n *     >>> f_39({1, 2, 3, 4, 5}, 5)\n *     39\n */\nlong long f_39(const std::vector<int>& A)", "ml": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * ഒരു പൂർണ്ണസംഖ്യകളുടെ നിര A നൽകിയാൽ, എല്ലാ ഉപനിരകളുടെയും XOR യുടെ മൊത്തം കണക്കാക്കുക എന്നതാണ് ഈ പ്രവർത്തനത്തിന്റെ ലക്ഷ്യം.\n * ഒരു ഉപനിര (L, R) എന്ന സൂചികകളുടെ ഒരു ജോഡിയാൽ നിർവ്വചിക്കപ്പെടുന്നു, 1 <= L <= R <= n, ഇവിടെ n ആണ് നിരയുടെ വലുപ്പം.\n * ഒരു ഉപനിരയുടെ XOR മൊത്തം L മുതൽ R വരെയുള്ള എല്ലാ മൂല്യങ്ങളുടെയും XOR ഫലമാണ്.\n * എല്ലാ സാധ്യതയുള്ള ഉപനിരകളുടെയും XOR മൊത്തങ്ങളുടെ തുകയാണ് അന്തിമ ഫലം.\n *\n * ഉദാഹരണ കേസുകൾ:\n *     >>> f_39({1, 2, 3, 4, 5}, 5)\n *     39\n */\nlong long f_39(const std::vector<int>& A)", "fa": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * با توجه به یک آرایه A از اعداد صحیح، وظیفه محاسبه مجموع XOR تمام زیرآرایه‌ها است.\n * یک زیرآرایه با یک جفت شاخص (L, R) تعریف می‌شود به طوری که 1 <= L <= R <= n، که n اندازه آرایه است.\n * مجموع XOR یک زیرآرایه نتیجه XOR کردن تمام عناصر از L تا R است.\n * نتیجه نهایی مجموع مقادیر XOR برای تمام زیرآرایه‌های ممکن است.\n *\n * مثال‌ها:\n *     >>> f_39({1, 2, 3, 4, 5}, 5)\n *     39\n */\nlong long f_39(const std::vector<int>& A)"}, "canonical_solution": "{\n    int n = A.size();\n    std::vector<long long> q(n + 1, 0);\n    std::vector<std::vector<long long>> w(21, std::vector<long long>(2, 0));\n    long long ans = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        q[i] = q[i - 1] ^ A[i - 1];\n    }\n\n    for (int i = 0; i <= n; ++i) {\n        for (int j = 20; j >= 0; --j) {\n            w[j][(q[i] >> j) & 1]++;\n        }\n    }\n\n    for (int i = 0; i <= 20; ++i) {\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    }\n\n    return ans;\n}", "instruction": {"en": "Write a CPP function `long long f_39(const std::vector<int>& A)` to solve the following problem:\nGiven an array A of integers, the task is to calculate the sum of the XOR of all subarrays.\nA subarray is defined by a pair of indices (L, R) such that 1 <= L <= R <= n, where n is the size of the array.\nThe XOR sum of a subarray is the result of XORing all elements from L to R.\nThe final result is the sum of the XOR sums for all possible subarrays.\n\nExample cases:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39\n", "sq": "Shkruani një funksion CPP `long long f_39(const std::vector<int>& A)` për të zgjidhur problemin e mëposhtëm:\nDuke pasur një varg A të numrave të plotë, detyra është të llogaritet shuma e XOR të të gjitha nënvargjeve.\nNjë nënvarg përcaktohet nga një çift indeksesh (L, R) të tilla që 1 <= L <= R <= n, ku n është madhësia e vargut.\nShuma XOR e një nënvargu është rezultati i XOR-it të të gjithë elementeve nga L në R.\nRezultati përfundimtar është shuma e shumave XOR për të gjitha nënvargjet e mundshme.\n\nShembuj rastesh:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "hy": "Գրեք CPP ֆունկցիա `long long f_39(const std::vector<int>& A)` հետևյալ խնդիրը լուծելու համար:\nՏրված է ամբողջ թվերի A զանգվածը, խնդիրը հաշվարկել է բոլոր ենթազանգվածների XOR-ի գումարը:\nԵնթազանգվածը սահմանվում է (L, R) ինդեքսների զույգով, այնպես որ 1 <= L <= R <= n, որտեղ n-ը զանգվածի չափն է:\nԵնթազանգվածի XOR գումարը L-ից R բոլոր տարրերի XOR-ի արդյունքն է:\nՎերջնական արդյունքը բոլոր հնարավոր ենթազանգվածների համար XOR գումարների գումարն է:\n\nՕրինակ դեպքեր:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "bn": "একটি CPP ফাংশন `long long f_39(const std::vector<int>& A)` লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\nএকটি পূর্ণসংখ্যার অ্যারে A দেওয়া আছে, কাজটি হল সমস্ত উপঅ্যারের XOR এর যোগফল গণনা করা।\nএকটি উপঅ্যারে একটি জোড়া সূচক (L, R) দ্বারা সংজ্ঞায়িত করা হয় যেখানে 1 <= L <= R <= n, যেখানে n হল অ্যারের আকার।\nএকটি উপঅ্যারের XOR যোগফল হল L থেকে R পর্যন্ত সমস্ত উপাদান XOR করার ফলাফল।\nচূড়ান্ত ফলাফল হল সমস্ত সম্ভাব্য উপঅ্যারের জন্য XOR যোগফলের যোগফল।\n\nউদাহরণ কেস:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "bg": "Напишете CPP функция `long long f_39(const std::vector<int>& A)`, за да решите следния проблем:\nДаден е масив A от цели числа, задачата е да се изчисли сумата от XOR на всички подмасиви.\nПодмасив се дефинира от двойка индекси (L, R) така че 1 <= L <= R <= n, където n е размерът на масива.\nXOR сумата на подмасив е резултатът от XOR на всички елементи от L до R.\nКрайният резултат е сумата от XOR сумите за всички възможни подмасиви.\n\nПримерни случаи:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "zh": "编写一个 CPP 函数 `long long f_39(const std::vector<int>& A)` 来解决以下问题：\n给定一个整数数组 A，任务是计算所有子数组的异或和的总和。\n子数组由一对索引 (L, R) 定义，其中 1 <= L <= R <= n，n 是数组的大小。\n子数组的异或和是从 L 到 R 的所有元素进行异或运算的结果。\n最终结果是所有可能子数组的异或和的总和。\n\n示例案例:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "fr": "Écrire une fonction CPP `long long f_39(const std::vector<int>& A)` pour résoudre le problème suivant :\nÉtant donné un tableau A d'entiers, la tâche consiste à calculer la somme du XOR de tous les sous-tableaux.\nUn sous-tableau est défini par une paire d'indices (L, R) telle que 1 <= L <= R <= n, où n est la taille du tableau.\nLa somme XOR d'un sous-tableau est le résultat du XOR de tous les éléments de L à R.\nLe résultat final est la somme des sommes XOR pour tous les sous-tableaux possibles.\n\nCas d'exemple :\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "de": "Schreiben Sie eine CPP-Funktion `long long f_39(const std::vector<int>& A)`, um das folgende Problem zu lösen:\nGegeben ist ein Array A von ganzen Zahlen. Die Aufgabe besteht darin, die Summe des XOR aller Teilarrays zu berechnen.\nEin Teilarray wird durch ein Paar von Indizes (L, R) definiert, sodass 1 <= L <= R <= n, wobei n die Größe des Arrays ist.\nDie XOR-Summe eines Teilarrays ist das Ergebnis des XORs aller Elemente von L bis R.\nDas Endergebnis ist die Summe der XOR-Summen für alle möglichen Teilarrays.\n\nBeispielfälle:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "ha": "Rubuta aikin CPP `long long f_39(const std::vector<int>& A)` don warware matsalar mai zuwa:  \nAn ba da wani tsari A na lambobi, aikin shine a ƙididdige jimlar XOR na dukkan ƙananan tsaruka.  \nAna ayyana ƙaramar tsari ta hanyar ma'aurata na alamomi (L, R) inda 1 <= L <= R <= n, inda n shine girman tsari.  \nJimlar XOR na ƙaramar tsari shine sakamakon XORing dukkan abubuwa daga L zuwa R.  \nSakamakon ƙarshe shine jimlar XOR na dukkan yiwuwar ƙananan tsaruka.  \n\nMisalan lamura:  \n    >>> f_39({1, 2, 3, 4, 5}, 5)  \n    39  ", "hi": "एक CPP फ़ंक्शन `long long f_39(const std::vector<int>& A)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए पूर्णांकों की एक array A के लिए, कार्य यह है कि सभी subarrays के XOR का योग गणना करें।\nएक subarray को (L, R) सूचकांक की एक जोड़ी द्वारा परिभाषित किया जाता है, जहाँ 1 <= L <= R <= n, जहाँ n array का आकार है।\nएक subarray का XOR योग L से R तक के सभी तत्वों का XOR करने का परिणाम है।\nअंतिम परिणाम सभी संभावित subarrays के लिए XOR योगों का योग है।\n\nउदाहरण मामले:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "hu": "Írj egy CPP függvényt `long long f_39(const std::vector<int>& A)` a következő probléma megoldására:\nAdott egy A egész számokat tartalmazó tömb, a feladat az, hogy kiszámoljuk az összes részhalmaz XOR összegének összegét.\nEgy részhalmazt egy (L, R) indexpár határoz meg, ahol 1 <= L <= R <= n, ahol n a tömb mérete.\nEgy részhalmaz XOR összege az L-től R-ig terjedő összes elem XOR-olásának eredménye.\nA végső eredmény az összes lehetséges részhalmaz XOR összegeinek összege.\n\nPélda esetek:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "es": "Escribe una función CPP `long long f_39(const std::vector<int>& A)` para resolver el siguiente problema:\nDado un array A de enteros, la tarea es calcular la suma del XOR de todos los subarrays.\nUn subarray se define por un par de índices (L, R) tal que 1 <= L <= R <= n, donde n es el tamaño del array.\nLa suma XOR de un subarray es el resultado de aplicar XOR a todos los elementos desde L hasta R.\nEl resultado final es la suma de las sumas XOR para todos los subarrays posibles.\n\nCasos de ejemplo:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "arb": "اكتب دالة CPP `long long f_39(const std::vector<int>& A)` لحل المشكلة التالية:\nمعطى مصفوفة A من الأعداد الصحيحة، المهمة هي حساب مجموع XOR لجميع القطع الفرعية.\nيتم تعريف القطعة الفرعية بواسطة زوج من الفهارس (L, R) بحيث 1 <= L <= R <= n، حيث n هو حجم المصفوفة.\nمجموع XOR للقطعة الفرعية هو نتيجة XOR لجميع العناصر من L إلى R.\nالنتيجة النهائية هي مجموع نتائج XOR لجميع القطع الفرعية الممكنة.\n\nحالات المثال:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "sw": "Andika kazi ya CPP `long long f_39(const std::vector<int>& A)` kutatua tatizo lifuatalo:\nUkipiwa safu A ya nambari za mzima, kazi ni kuhesabu jumla ya XOR ya vipengele vidogo vyote.\nKipengele kidogo kinafafanuliwa na jozi ya faharasa (L, R) kama 1 <= L <= R <= n, ambapo n ni ukubwa wa safu.\nJumla ya XOR ya kipengele kidogo ni matokeo ya XOR ya vipengele vyote kutoka L hadi R.\nMatokeo ya mwisho ni jumla ya XOR kwa vipengele vidogo vyote vinavyowezekana.\n\nMifano ya kesi:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "tr": "Bir CPP fonksiyonu `long long f_39(const std::vector<int>& A)` yazın ve aşağıdaki problemi çözün:\nVerilen bir tamsayı dizisi A için, tüm alt dizilerin XOR toplamını hesaplama görevi.\nBir alt dizi, 1 <= L <= R <= n olacak şekilde (L, R) indeks çiftleriyle tanımlanır, burada n dizinin boyutudur.\nBir alt dizinin XOR toplamı, L'den R'ye kadar olan tüm elemanların XOR'lanması sonucudur.\nSonuç, tüm olası alt diziler için XOR toplamlarının toplamıdır.\n\nÖrnek durumlar:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "vi": "Viết một hàm CPP `long long f_39(const std::vector<int>& A)` để giải quyết vấn đề sau:\nCho một mảng A gồm các số nguyên, nhiệm vụ là tính tổng của XOR của tất cả các mảng con.\nMột mảng con được định nghĩa bởi một cặp chỉ số (L, R) sao cho 1 <= L <= R <= n, trong đó n là kích thước của mảng.\nTổng XOR của một mảng con là kết quả của việc XOR tất cả các phần tử từ L đến R.\nKết quả cuối cùng là tổng của các tổng XOR cho tất cả các mảng con có thể.\n\nCác trường hợp ví dụ:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "id": "Tulis fungsi CPP `long long f_39(const std::vector<int>& A)` untuk menyelesaikan masalah berikut:\nDiberikan sebuah array A dari bilangan bulat, tugasnya adalah menghitung jumlah dari XOR semua subarray.\nSebuah subarray didefinisikan oleh sepasang indeks (L, R) sehingga 1 <= L <= R <= n, di mana n adalah ukuran array.\nJumlah XOR dari sebuah subarray adalah hasil dari XOR semua elemen dari L hingga R.\nHasil akhirnya adalah jumlah dari semua jumlah XOR untuk semua subarray yang mungkin.\n\nContoh kasus:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "ja": "`long long f_39(const std::vector<int>& A)` を使用して次の問題を解決します:\n整数の配列 A が与えられたとき、すべての部分配列の XOR の合計を計算することが課題です。\n部分配列は、1 <= L <= R <= n であるインデックスのペア (L, R) によって定義されます。ここで、n は配列のサイズです。\n部分配列の XOR 合計は、L から R までのすべての要素を XOR した結果です。\n最終的な結果は、可能なすべての部分配列の XOR 合計の合計です。\n\n例:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "ko": "CPP 함수를 작성하세요 `long long f_39(const std::vector<int>& A)` 다음 문제를 해결하기 위해:\n정수 배열 A가 주어졌을 때, 모든 부분 배열의 XOR 합의 합계를 계산하는 것이 과제입니다.  \n부분 배열은 인덱스 쌍 (L, R)에 의해 정의되며, 여기서 1 <= L <= R <= n, n은 배열의 크기입니다.  \n부분 배열의 XOR 합은 L에서 R까지의 모든 요소를 XOR한 결과입니다.  \n최종 결과는 가능한 모든 부분 배열에 대한 XOR 합의 합입니다.  \n\n예제 경우:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "ml": "`long long f_39(const std::vector<int>& A)` എന്ന CPP ഫങ്ഷൻ എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nഒരു പൂർണ്ണസംഖ്യകളുടെ നിരയായ A നൽകിയാൽ, എല്ലാ ഉപനിരകളുടെയും XOR യുടെ മൊത്തം കണക്കാക്കുക എന്നതാണ് പ്രവർത്തി.\nഒരു ഉപനിര (L, R) എന്ന സൂചികകളുടെ ഒരു ജോഡിയാൽ നിർവചിക്കപ്പെടുന്നു, 1 <= L <= R <= n, n ആണ് നിരയുടെ വലുപ്പം.\nഒരു ഉപനിരയുടെ XOR മൊത്തം L മുതൽ R വരെ എല്ലാ ഘടകങ്ങളും XOR ചെയ്യുന്നതിന്റെ ഫലമാണ്.\nഎല്ലാ സാധ്യതയുള്ള ഉപനിരകളുടെയും XOR മൊത്തങ്ങളുടെ മൊത്തം ഫലമാണ് അന്തിമ ഫലം.\n\nഉദാഹരണ കേസുകൾ:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "fa": "یک تابع CPP `long long f_39(const std::vector<int>& A)` بنویسید تا مسئله زیر را حل کند:\nبا توجه به آرایه A از اعداد صحیح، وظیفه محاسبه مجموع XOR تمام زیرآرایه‌ها است.\nیک زیرآرایه با یک جفت اندیس (L, R) تعریف می‌شود به طوری که 1 <= L <= R <= n، که n اندازه آرایه است.\nمجموع XOR یک زیرآرایه نتیجه XOR کردن تمام عناصر از L تا R است.\nنتیجه نهایی مجموع مقادیر XOR برای تمام زیرآرایه‌های ممکن است.\n\nمثال‌ها:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39"}, "level": "middle", "test": "int main() {\n    assert(f_39({1, 2, 3, 4, 5}) == 39);\n    assert(f_39({1, 1, 1}) == 4);\n    assert(f_39({2, 3, 1}) == 9);\n    assert(f_39({4, 5, 7, 9}) == 74);\n    assert(f_39({0, 0, 0, 0}) == 0);\n    assert(f_39({8, 8, 8, 8, 8}) == 72);\n    assert(f_39({3, 6, 9, 12, 15}) == 125);\n    assert(f_39({10, 20, 30, 40, 50}) == 390);\n    assert(f_39({16, 16, 16, 16, 16, 16}) == 192);\n    assert(f_39({1, 3, 5, 7, 9, 11, 13}) == 192);\n    assert(f_39({0, 1, 2, 3, 4, 5, 6, 7, 8, 9}) == 218);\n\n\n    return 0;\n}", "entry_point": "f_39", "signature": "long long f_39(const std::vector<int>& A)", "docstring": {"en": "Given an array A of integers, the task is to calculate the sum of the XOR of all subarrays.\nA subarray is defined by a pair of indices (L, R) such that 1 <= L <= R <= n, where n is the size of the array.\nThe XOR sum of a subarray is the result of XORing all elements from L to R.\nThe final result is the sum of the XOR sums for all possible subarrays.\n\nExample cases:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39\n", "sq": "Duke pasur një varg A të numrave të plotë, detyra është të llogaritet shuma e XOR-it të të gjitha nënvargjeve. Një nënvarg përcaktohet nga një çift indeksesh (L, R) të tilla që 1 <= L <= R <= n, ku n është madhësia e vargut. Shuma e XOR-it të një nënvargu është rezultati i XOR-it të të gjithë elementeve nga L në R. Rezultati përfundimtar është shuma e shumave të XOR-it për të gjitha nënvargjet e mundshme.\n\nShembuj rastesh:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "hy": "Տրված է A ամբողջ թվերի զանգված, խնդիրն է հաշվել բոլոր ենթազանգվածների XOR-ի գումարը։  \nԵնթազանգվածը սահմանվում է (L, R) ինդեքսների զույգով, այնպես, որ 1 <= L <= R <= n, որտեղ n-ը զանգվածի չափն է։  \nԵնթազանգվածի XOR-ի գումարը L-ից R բոլոր տարրերի XOR-ի արդյունքն է։  \nՎերջնական արդյունքը բոլոր հնարավոր ենթազանգվածների համար XOR գումարների գումարն է։  \n\nՕրինակներ:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "bn": "ইন্টিজার সম্বলিত একটি অ্যারে A দেওয়া আছে, কাজটি হল সমস্ত সাবঅ্যারের XOR এর যোগফল গণনা করা। \nএকটি সাবঅ্যারে একটি ইন্ডেক্সের জোড়া (L, R) দ্বারা সংজ্ঞায়িত করা হয় যেখানে 1 <= L <= R <= n, যেখানে n হল অ্যারের আকার।\nএকটি সাবঅ্যারের XOR যোগফল হল L থেকে R পর্যন্ত সমস্ত উপাদানের XOR করার ফলাফল।\nচূড়ান্ত ফলাফল হল সমস্ত সম্ভাব্য সাবঅ্যারের জন্য XOR যোগফলের যোগফল।\n\nউদাহরণ কেস:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "bg": "Даден е масив A от цели числа, задачата е да се изчисли сумата от XOR на всички подмасиви. Подмасив се дефинира чрез двойка индекси (L, R) така че 1 <= L <= R <= n, където n е размерът на масива. XOR сумата на подмасив е резултатът от XOR на всички елементи от L до R. Крайният резултат е сумата от XOR сумите за всички възможни подмасиви.\n\nПримерни случаи:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "zh": "给定一个整数数组A，任务是计算所有子数组的异或和的总和。  \n子数组由一对索引(L, R)定义，其中1 <= L <= R <= n，n是数组的大小。  \n子数组的异或和是从L到R的所有元素进行异或运算的结果。  \n最终结果是所有可能子数组的异或和的总和。  \n\n示例案例:  \n    >>> f_39({1, 2, 3, 4, 5}, 5)  \n    39  ", "fr": "Étant donné un tableau A d'entiers, la tâche consiste à calculer la somme du XOR de tous les sous-tableaux.  \nUn sous-tableau est défini par une paire d'indices (L, R) telle que 1 <= L <= R <= n, où n est la taille du tableau.  \nLa somme XOR d'un sous-tableau est le résultat du XOR de tous les éléments de L à R.  \nLe résultat final est la somme des sommes XOR pour tous les sous-tableaux possibles.  \n\nCas d'exemple:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "de": "Gegeben ein Array A von ganzen Zahlen, besteht die Aufgabe darin, die Summe des XOR aller Teilarrays zu berechnen.\nEin Teilarray wird durch ein Paar von Indizes (L, R) definiert, so dass 1 <= L <= R <= n, wobei n die Größe des Arrays ist.\nDie XOR-Summe eines Teilarrays ist das Ergebnis des XOR aller Elemente von L bis R.\nDas Endergebnis ist die Summe der XOR-Summen für alle möglichen Teilarrays.\n\nBeispielhafte Fälle:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "ha": "An ba da jerin A na lambobin cikakke, aikin shi ne a lissafa jimillar XOR na dukkan ƙananan jerin.\nƘaramar jeri ana ayyana ta ta hanyar ma'aurata na alamomi (L, R) inda 1 <= L <= R <= n, inda n shine girman jerin.\nJimillar XOR na ƙaramar jeri shine sakamakon XORing dukkan abubuwa daga L zuwa R.\nSakamakon ƙarshe shine jimillar XOR na dukkan yiwuwar ƙananan jerin.\n\nMisalan lokuta:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "hi": "दिए गए पूर्णांकों की एक सरणी A के लिए, कार्य सभी उप-सरणियों के XOR का योग गणना करना है। एक उप-सरणी को (L, R) सूचकांक की एक जोड़ी द्वारा परिभाषित किया जाता है, जहाँ 1 <= L <= R <= n, जहाँ n सरणी का आकार है। एक उप-सरणी का XOR योग L से R तक के सभी तत्वों का XOR करने का परिणाम है। अंतिम परिणाम सभी संभावित उप-सरणियों के लिए XOR योगों का योग है।\n\nउदाहरण मामले:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "hu": "Adott egy A egész számokat tartalmazó tömb, a feladat az összes részhalmaz XOR összegének kiszámítása.\nEgy részhalmazt egy (L, R) indexpár határoz meg, ahol 1 <= L <= R <= n, ahol n a tömb mérete.\nEgy részhalmaz XOR összege az L-től R-ig terjedő elemek XOR-olásának eredménye.\nA végső eredmény az összes lehetséges részhalmaz XOR összegeinek összege.\n\nPélda esetek:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "es": "Dado un array A de enteros, la tarea es calcular la suma del XOR de todos los subarrays.  \nUn subarray se define por un par de índices (L, R) tal que 1 <= L <= R <= n, donde n es el tamaño del array.  \nLa suma XOR de un subarray es el resultado de aplicar XOR a todos los elementos desde L hasta R.  \nEl resultado final es la suma de las sumas XOR para todos los subarrays posibles.\n\nCasos de ejemplo:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "arb": "معطى مصفوفة A من الأعداد الصحيحة، المهمة هي حساب مجموع الـ XOR لجميع القطع الفرعية.\nيتم تعريف القطعة الفرعية بواسطة زوج من الفهارس (L, R) بحيث 1 <= L <= R <= n، حيث n هو حجم المصفوفة.\nمجموع الـ XOR لقطعة فرعية هو نتيجة تطبيق عملية XOR على جميع العناصر من L إلى R.\nالنتيجة النهائية هي مجموع قيم الـ XOR لجميع القطع الفرعية الممكنة.\n\nحالات المثال:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "sw": "Kwa kupewa safu A ya nambari za mzima, kazi ni kuhesabu jumla ya XOR ya vipengele vidogo vyote.\nKipengele kidogo kinafafanuliwa na jozi ya faharasa (L, R) ambapo 1 <= L <= R <= n, ambapo n ni ukubwa wa safu.\nJumla ya XOR ya kipengele kidogo ni matokeo ya kufanya XOR kwa vipengele vyote kutoka L hadi R.\nMatokeo ya mwisho ni jumla ya jumla za XOR kwa vipengele vidogo vyote vinavyowezekana.\n\nMifano ya kesi:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "tr": "Verilen bir tamsayı dizisi A için, tüm alt dizilerin XOR toplamını hesaplama görevi.\nBir alt dizi, 1 <= L <= R <= n olacak şekilde bir (L, R) indeks çifti ile tanımlanır, burada n dizinin boyutudur.\nBir alt dizinin XOR toplamı, L'den R'ye kadar olan tüm elemanların XOR'lanması sonucudur.\nNihai sonuç, tüm olası alt diziler için XOR toplamlarının toplamıdır.\n\nÖrnek durumlar:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "vi": "Cho một mảng A gồm các số nguyên, nhiệm vụ là tính tổng của XOR của tất cả các mảng con.  \nMột mảng con được định nghĩa bởi một cặp chỉ số (L, R) sao cho 1 <= L <= R <= n, trong đó n là kích thước của mảng.  \nTổng XOR của một mảng con là kết quả của việc XOR tất cả các phần tử từ L đến R.  \nKết quả cuối cùng là tổng của các tổng XOR cho tất cả các mảng con có thể có.  \n\nCác trường hợp ví dụ:  \n    >>> f_39({1, 2, 3, 4, 5}, 5)  \n    39  ", "id": "Diberikan array A dari bilangan bulat, tugasnya adalah menghitung jumlah dari XOR semua subarray.  \nSubarray didefinisikan oleh sepasang indeks (L, R) sehingga 1 <= L <= R <= n, di mana n adalah ukuran array.  \nJumlah XOR dari sebuah subarray adalah hasil dari XOR semua elemen dari L ke R.  \nHasil akhirnya adalah jumlah dari semua jumlah XOR untuk semua subarray yang mungkin.  \n\nContoh kasus:  \n    >>> f_39({1, 2, 3, 4, 5}, 5)  \n    39  ", "ja": "整数の配列 A が与えられたとき、すべての部分配列の XOR の合計を計算することが課題です。  \n部分配列は、1 <= L <= R <= n という条件を満たすインデックスのペア (L, R) によって定義されます。ここで n は配列のサイズです。  \n部分配列の XOR 合計は、L から R までのすべての要素を XOR した結果です。  \n最終的な結果は、可能なすべての部分配列の XOR 合計の合計です。\n\n例:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "ko": "주어진 정수 배열 A에 대해, 모든 부분 배열의 XOR 합을 계산하는 작업입니다.\n부분 배열은 1 <= L <= R <= n인 인덱스 쌍 (L, R)에 의해 정의되며, 여기서 n은 배열의 크기입니다.\n부분 배열의 XOR 합은 L에서 R까지의 모든 요소를 XOR한 결과입니다.\n최종 결과는 가능한 모든 부분 배열의 XOR 합의 합입니다.\n\n예제 사례:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "ml": "ഒരു പൂർണ്ണസംഖ്യകളുടെ നിരയായ A നൽകിയാൽ, എല്ലാ ഉപനിരകളുടെയും XOR യുടെ മൊത്തം കണക്കാക്കുക എന്നതാണ് ഈ പ്രവർത്തനം.\nഒരു ഉപനിരയെ (L, R) എന്ന സൂചികകളുടെ ജോഡിയാൽ നിർവചിക്കുന്നു, 1 <= L <= R <= n, n നിരയുടെ വലുപ്പമാണ്.\nഒരു ഉപനിരയുടെ XOR മൊത്തം L മുതൽ R വരെ എല്ലാ ഘടകങ്ങളും XOR ചെയ്യുന്നതിന്റെ ഫലമാണ്.\nഎല്ലാ സാധ്യതാപരമായ ഉപനിരകളുടെയും XOR മൊത്തങ്ങളുടെ മൊത്തം ഫലമാണ് അന്തിമ ഫലം.\n\nഉദാഹരണ കേസുകൾ:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39", "fa": "با توجه به آرایه A از اعداد صحیح، وظیفه محاسبه مجموع XOR تمام زیرآرایه‌ها است.  \nیک زیرآرایه با یک جفت شاخص (L, R) تعریف می‌شود به طوری که 1 <= L <= R <= n، که n اندازه آرایه است.  \nمجموع XOR یک زیرآرایه نتیجه XOR کردن تمام عناصر از L تا R است.  \nنتیجه نهایی مجموع مقادیر XOR برای تمام زیرآرایه‌های ممکن است.\n\nموارد مثال:\n    >>> f_39({1, 2, 3, 4, 5}, 5)\n    39"}}
{"task_id": "CPP/40", "prompt": {"en": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n/**\n * Given two positive integers n and k, find the number of positive integers x,\n * where 1 <= x <= n, that can be expressed as x = a^b with a and b being\n * positive integers and b >= k. Different legal representations of x are counted\n * only once. For example:\n *     >>> f_40(99, 1)\n *     99\n */\nint f_40(int n, int k)", "sq": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n/**\n * Duke pasur dy numra të plotë pozitivë n dhe k, gjeni numrin e numrave të plotë pozitivë x,\n * ku 1 <= x <= n, që mund të shprehen si x = a^b me a dhe b që janë\n * numra të plotë pozitivë dhe b >= k. Përfaqësimet e ndryshme të ligjshme të x numërohen\n * vetëm një herë. Për shembull:\n *     >>> f_40(99, 1)\n *     99\n */\nint f_40(int n, int k)", "hy": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n/**\n * Տրված են երկու դրական ամբողջ թվեր n և k, գտնել դրական ամբողջ թվերի քանակը x,\n * որտեղ 1 <= x <= n, որոնք կարող են արտահայտվել որպես x = a^b, որտեղ a և b\n * դրական ամբողջ թվեր են և b >= k: x-ի տարբեր թույլատրելի ներկայացումները հաշվում են\n * միայն մեկ անգամ: Օրինակ:\n *     >>> f_40(99, 1)\n *     99\n */\nint f_40(int n, int k)", "bn": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n/**\n * দুটি ধনাত্মক পূর্ণসংখ্যা n এবং k দেওয়া আছে, ধনাত্মক পূর্ণসংখ্যা x এর সংখ্যা খুঁজে বের করুন,\n * যেখানে 1 <= x <= n, যা x = a^b হিসাবে প্রকাশ করা যায় যেখানে a এবং b\n * ধনাত্মক পূর্ণসংখ্যা এবং b >= k। x এর বিভিন্ন বৈধ উপস্থাপনাগুলি শুধুমাত্র একবার গণনা করা হয়। উদাহরণস্বরূপ:\n *     >>> f_40(99, 1)\n *     99\n */\nint f_40(int n, int k)", "bg": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n/**\n * Дадени са две положителни цели числа n и k, намерете броя на положителните цели числа x,\n * където 1 <= x <= n, които могат да бъдат изразени като x = a^b с a и b, които са\n * положителни цели числа и b >= k. Различните легални представяния на x се броят\n * само веднъж. Например:\n *     >>> f_40(99, 1)\n *     99\n */\nint f_40(int n, int k)", "zh": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n/**\n * 给定两个正整数 n 和 k，找到满足 1 <= x <= n 的正整数 x 的数量，\n * 其中 x 可以表示为 x = a^b，a 和 b 是正整数且 b >= k。\n * x 的不同合法表示仅计数一次。例如：\n *     >>> f_40(99, 1)\n *     99\n */\nint f_40(int n, int k)", "fr": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n/**\n * Étant donné deux entiers positifs n et k, trouver le nombre d'entiers positifs x,\n * où 1 <= x <= n, qui peuvent être exprimés comme x = a^b avec a et b étant\n * des entiers positifs et b >= k. Les différentes représentations légales de x sont comptées\n * une seule fois. Par exemple :\n *     >>> f_40(99, 1)\n *     99\n */\nint f_40(int n, int k)", "de": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n/**\n * Gegeben zwei positive ganze Zahlen n und k, finde die Anzahl der positiven ganzen Zahlen x,\n * wobei 1 <= x <= n, die als x = a^b ausgedrückt werden können, wobei a und b\n * positive ganze Zahlen sind und b >= k. Verschiedene zulässige Darstellungen von x werden\n * nur einmal gezählt. Zum Beispiel:\n *     >>> f_40(99, 1)\n *     99\n */\nint f_40(int n, int k)", "ha": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n/**\n * An ba da lambobi biyu masu kyau n da k, nemo adadin lambobi masu kyau x,\n * inda 1 <= x <= n, wanda za a iya bayyana shi azaman x = a^b tare da a da b suna\n * zama lambobi masu kyau kuma b >= k. Ana kirga wakilci daban-daban na doka na x\n * sau daya kawai. Misali:\n *     >>> f_40(99, 1)\n *     99\n */\nint f_40(int n, int k)", "hi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n/**\n * दिए गए दो धनात्मक पूर्णांक n और k, उन धनात्मक पूर्णांकों x की संख्या खोजें,\n * जहाँ 1 <= x <= n, जिसे x = a^b के रूप में व्यक्त किया जा सकता है जहाँ a और b\n * धनात्मक पूर्णांक हैं और b >= k है। x के विभिन्न वैध प्रतिनिधित्व केवल एक बार गिने जाते हैं। उदाहरण के लिए:\n *     >>> f_40(99, 1)\n *     99\n */\nint f_40(int n, int k)", "hu": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n/**\n * Két pozitív egész szám, n és k megadása esetén találjuk meg azon pozitív egész számok x számát,\n * ahol 1 <= x <= n, amelyek kifejezhetők x = a^b formában, ahol a és b pozitív egész számok és b >= k. \n * Az x különböző legális ábrázolásai csak egyszer számítanak. Például:\n *     >>> f_40(99, 1)\n *     99\n */\nint f_40(int n, int k)", "es": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n/**\n * Dados dos enteros positivos n y k, encuentra el número de enteros positivos x,\n * donde 1 <= x <= n, que pueden expresarse como x = a^b con a y b siendo\n * enteros positivos y b >= k. Diferentes representaciones legales de x se cuentan\n * solo una vez. Por ejemplo:\n *     >>> f_40(99, 1)\n *     99\n */\nint f_40(int n, int k)", "arb": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n/**\n * بالنظر إلى عددين صحيحين موجبين n و k، ابحث عن عدد الأعداد الصحيحة الموجبة x،\n * حيث 1 <= x <= n، التي يمكن التعبير عنها كـ x = a^b مع كون a و b\n * أعداد صحيحة موجبة و b >= k. يتم احتساب التمثيلات القانونية المختلفة لـ x مرة واحدة فقط. على سبيل المثال:\n *     >>> f_40(99, 1)\n *     99\n */\nint f_40(int n, int k)", "sw": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n/**\n * Ukipewa nambari mbili kamili chanya n na k, tafuta idadi ya nambari kamili chanya x,\n * ambapo 1 <= x <= n, ambazo zinaweza kuonyeshwa kama x = a^b huku a na b wakiwa\n * nambari kamili chanya na b >= k. Uwakilishi tofauti halali wa x unahesabiwa\n * mara moja tu. Kwa mfano:\n *     >>> f_40(99, 1)\n *     99\n */\nint f_40(int n, int k)", "tr": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n/**\n * İki pozitif tamsayı n ve k verildiğinde, 1 <= x <= n aralığında x = a^b\n * şeklinde ifade edilebilen pozitif tamsayı x sayısını bulun, burada a ve b\n * pozitif tamsayılardır ve b >= k. x'in farklı yasal temsilleri yalnızca bir kez sayılır. Örneğin:\n *     >>> f_40(99, 1)\n *     99\n */\nint f_40(int n, int k)", "vi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n/**\n * Cho hai số nguyên dương n và k, tìm số lượng số nguyên dương x,\n * với 1 <= x <= n, có thể được biểu diễn dưới dạng x = a^b với a và b là\n * các số nguyên dương và b >= k. Các cách biểu diễn hợp lệ khác nhau của x chỉ được đếm\n * một lần. Ví dụ:\n *     >>> f_40(99, 1)\n *     99\n */\nint f_40(int n, int k)", "id": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n/**\n * Diberikan dua bilangan bulat positif n dan k, temukan jumlah bilangan bulat positif x,\n * di mana 1 <= x <= n, yang dapat dinyatakan sebagai x = a^b dengan a dan b adalah\n * bilangan bulat positif dan b >= k. Representasi legal yang berbeda dari x dihitung\n * hanya sekali. Sebagai contoh:\n *     >>> f_40(99, 1)\n *     99\n */\nint f_40(int n, int k)", "ja": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n/**\n * 2つの正の整数nとkが与えられたとき、1 <= x <= nの範囲で、x = a^bと表現できる\n * 正の整数xの数を求めます。ここでaとbは正の整数であり、b >= kです。\n * xの異なる合法的な表現は一度だけカウントされます。例えば:\n *     >>> f_40(99, 1)\n *     99\n */\nint f_40(int n, int k)", "ko": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n/**\n * 두 개의 양의 정수 n과 k가 주어졌을 때, 다음 조건을 만족하는 양의 정수 x의 개수를 찾습니다:\n * 1 <= x <= n이며, x = a^b로 표현될 수 있고, 여기서 a와 b는 양의 정수이며 b >= k입니다.\n * x의 다른 합법적인 표현은 한 번만 계산됩니다. 예를 들어:\n *     >>> f_40(99, 1)\n *     99\n */\nint f_40(int n, int k)", "ml": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n/**\n * രണ്ട് പോസിറ്റീവ് പൂർണ്ണസംഖ്യകൾ n, k എന്നിവ നൽകിയാൽ, 1 <= x <= n എന്ന അവസ്ഥയിൽ,\n * x = a^b എന്ന രൂപത്തിൽ രേഖപ്പെടുത്താവുന്ന പോസിറ്റീവ് പൂർണ്ണസംഖ്യകളുടെ എണ്ണം കണ്ടെത്തുക,\n * ഇവിടെ a, b പോസിറ്റീവ് പൂർണ്ണസംഖ്യകളാണ്, b >= k. x ന്റെ വ്യത്യസ്തമായ നിയമാനുസൃതമായ\n * പ്രതിനിധാനങ്ങൾ ഒരിക്കൽ മാത്രം എണ്ണപ്പെടുന്നു. ഉദാഹരണത്തിന്:\n *     >>> f_40(99, 1)\n *     99\n */\nint f_40(int n, int k)", "fa": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n/**\n * با داشتن دو عدد صحیح مثبت n و k، تعداد اعداد صحیح مثبت x را پیدا کنید،\n * که در آن 1 <= x <= n، که می‌توان به صورت x = a^b با a و b که\n * اعداد صحیح مثبت هستند و b >= k بیان کرد. نمایش‌های قانونی مختلف x فقط\n * یک بار شمارش می‌شوند. برای مثال:\n *     >>> f_40(99, 1)\n *     99\n */\nint f_40(int n, int k)"}, "canonical_solution": "{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += static_cast<int>(sqrt(n)) - x;\n    }\n    free(mp);\n    return count;\n}", "instruction": {"en": "Write a CPP function `int f_40(int n, int k)` to solve the following problem:\nGiven two positive integers n and k, find the number of positive integers x, where 1 <= x <= n, that can be expressed as x = a^b with a and b being positive integers and b >= k. Different legal representations of x are counted only once. For example:\n    >>> f_40(99, 1)\n    99\n", "sq": "Shkruani një funksion CPP `int f_40(int n, int k)` për të zgjidhur problemin e mëposhtëm:  \nDuke pasur dy numra të plotë pozitivë n dhe k, gjeni numrin e numrave të plotë pozitivë x, ku 1 <= x <= n, që mund të shprehen si x = a^b me a dhe b që janë numra të plotë pozitivë dhe b >= k. Përfaqësimet e ndryshme të ligjshme të x numërohen vetëm një herë. Për shembull:  \n    >>> f_40(99, 1)  \n    99  ", "hy": "Գրեք CPP ֆունկցիա `int f_40(int n, int k)` հետևյալ խնդիրը լուծելու համար:\nՏրված են n և k դրական ամբողջ թվերը, գտնել դրական ամբողջ թվերի քանակը x, որտեղ 1 <= x <= n, որոնք կարող են արտահայտվել որպես x = a^b, որտեղ a և b դրական ամբողջ թվեր են և b >= k: x-ի տարբեր թույլատրելի ներկայացումները հաշվում են միայն մեկ անգամ: Օրինակ՝\n    >>> f_40(99, 1)\n    99", "bn": "একটি CPP ফাংশন `int f_40(int n, int k)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য: দুটি ধনাত্মক পূর্ণসংখ্যা n এবং k দেওয়া আছে, 1 <= x <= n এর মধ্যে কতগুলি ধনাত্মক পূর্ণসংখ্যা x আছে তা খুঁজে বের করুন, যা x = a^b হিসাবে প্রকাশ করা যেতে পারে যেখানে a এবং b ধনাত্মক পূর্ণসংখ্যা এবং b >= k। x এর বিভিন্ন বৈধ উপস্থাপনাগুলি শুধুমাত্র একবার গণনা করা হয়। উদাহরণস্বরূপ:\n    >>> f_40(99, 1)\n    99", "bg": "Напишете CPP функция `int f_40(int n, int k)` за решаване на следния проблем:\nДадени са две положителни цели числа n и k, намерете броя на положителните цели числа x, където 1 <= x <= n, които могат да бъдат изразени като x = a^b с a и b, които са положителни цели числа и b >= k. Различните легални представяния на x се броят само веднъж. Например:\n    >>> f_40(99, 1)\n    99", "zh": "编写一个 CPP 函数 `int f_40(int n, int k)` 来解决以下问题：  \n给定两个正整数 n 和 k，找出有多少个正整数 x，满足 1 <= x <= n，并且可以表示为 x = a^b，其中 a 和 b 是正整数且 b >= k。x 的不同合法表示仅计数一次。例如：  \n    >>> f_40(99, 1)  \n    99  ", "fr": "Écrire une fonction CPP `int f_40(int n, int k)` pour résoudre le problème suivant :  \nÉtant donné deux entiers positifs n et k, trouver le nombre d'entiers positifs x, où 1 <= x <= n, qui peuvent être exprimés comme x = a^b avec a et b étant des entiers positifs et b >= k. Différentes représentations légales de x sont comptées une seule fois. Par exemple :  \n    >>> f_40(99, 1)  \n    99  ", "de": "Schreiben Sie eine CPP-Funktion `int f_40(int n, int k)`, um das folgende Problem zu lösen:\nGegeben sind zwei positive ganze Zahlen n und k. Finden Sie die Anzahl der positiven ganzen Zahlen x, wobei 1 <= x <= n, die als x = a^b ausgedrückt werden können, wobei a und b positive ganze Zahlen sind und b >= k. Verschiedene zulässige Darstellungen von x werden nur einmal gezählt. Zum Beispiel:\n    >>> f_40(99, 1)\n    99", "ha": "Rubuta aikin CPP `int f_40(int n, int k)` don warware matsalar mai zuwa:\nAn ba da lambobi guda biyu masu kyau n da k, nemo yawan lambobi masu kyau x, inda 1 <= x <= n, waɗanda za a iya bayyana su a matsayin x = a^b tare da a da b suna kasancewa lambobi masu kyau kuma b >= k. Ana kirga daban-daban halattattun wakilcin x sau ɗaya kawai. Alal misali:\n    >>> f_40(99, 1)\n    99", "hi": "एक CPP फ़ंक्शन `int f_40(int n, int k)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदो धनात्मक पूर्णांक n और k दिए गए हैं, उन धनात्मक पूर्णांकों x की संख्या ज्ञात करें, जहाँ 1 <= x <= n, जिन्हें x = a^b के रूप में व्यक्त किया जा सकता है, जहाँ a और b धनात्मक पूर्णांक हैं और b >= k है। x के विभिन्न वैध प्रतिनिधित्व केवल एक बार गिने जाते हैं। उदाहरण के लिए:\n    >>> f_40(99, 1)\n    99", "hu": "Írj egy CPP függvényt `int f_40(int n, int k)` a következő probléma megoldására:\nAdott két pozitív egész szám, n és k, találd meg azon pozitív egész számok x számát, ahol 1 <= x <= n, amelyek kifejezhetők x = a^b alakban, ahol a és b pozitív egész számok és b >= k. Az x különböző érvényes ábrázolásait csak egyszer számoljuk. Például:\n    >>> f_40(99, 1)\n    99", "es": "Escribe una función en CPP `int f_40(int n, int k)` para resolver el siguiente problema:\nDado dos enteros positivos n y k, encuentra el número de enteros positivos x, donde 1 <= x <= n, que pueden expresarse como x = a^b con a y b siendo enteros positivos y b >= k. Diferentes representaciones legales de x se cuentan solo una vez. Por ejemplo:\n    >>> f_40(99, 1)\n    99", "arb": "اكتب دالة CPP `int f_40(int n, int k)` لحل المشكلة التالية:  \nمعطى عددين صحيحين موجبين n و k، ابحث عن عدد الأعداد الصحيحة الموجبة x، حيث 1 <= x <= n، التي يمكن التعبير عنها كـ x = a^b مع كون a و b أعداد صحيحة موجبة و b >= k. يتم احتساب التمثيلات القانونية المختلفة لـ x مرة واحدة فقط. على سبيل المثال:  \n    >>> f_40(99, 1)  \n    99  ", "sw": "Andika kazi ya CPP `int f_40(int n, int k)` kutatua tatizo lifuatalo:\nUkipiwa nambari mbili nzima chanya n na k, tafuta idadi ya nambari chanya x, ambapo 1 <= x <= n, ambazo zinaweza kuonyeshwa kama x = a^b huku a na b zikiwa nambari nzima chanya na b >= k. Uwiano tofauti halali wa x unahesabiwa mara moja tu. Kwa mfano:\n    >>> f_40(99, 1)\n    99", "tr": "Bir CPP fonksiyonu `int f_40(int n, int k)` yazın ve aşağıdaki problemi çözün:\nVerilen iki pozitif tamsayı n ve k için, 1 <= x <= n aralığında olan ve x = a^b şeklinde ifade edilebilen pozitif tamsayı x'lerin sayısını bulun, burada a ve b pozitif tamsayılar ve b >= k. x'in farklı yasal temsilleri yalnızca bir kez sayılır. Örneğin:\n    >>> f_40(99, 1)\n    99", "vi": "Viết một hàm CPP `int f_40(int n, int k)` để giải quyết vấn đề sau:  \nCho hai số nguyên dương n và k, tìm số lượng số nguyên dương x, trong đó 1 <= x <= n, có thể được biểu diễn dưới dạng x = a^b với a và b là các số nguyên dương và b >= k. Các biểu diễn hợp lệ khác nhau của x chỉ được đếm một lần. Ví dụ:  \n    >>> f_40(99, 1)  \n    99  ", "id": "Tulis fungsi CPP `int f_40(int n, int k)` untuk menyelesaikan masalah berikut:\nDiberikan dua bilangan bulat positif n dan k, temukan jumlah bilangan bulat positif x, di mana 1 <= x <= n, yang dapat dinyatakan sebagai x = a^b dengan a dan b adalah bilangan bulat positif dan b >= k. Representasi legal berbeda dari x dihitung hanya sekali. Sebagai contoh:\n    >>> f_40(99, 1)\n    99", "ja": "次の問題を解くために、CPP関数 `int f_40(int n, int k)` を作成してください:\n2つの正の整数 n と k が与えられたとき、1 <= x <= n の範囲で、x = a^b と表現できる正の整数 x の数を求めます。ただし、a と b は正の整数であり、b >= k です。x の異なる合法的な表現は一度だけカウントされます。例えば:\n    >>> f_40(99, 1)\n    99", "ko": "다음 문제를 해결하기 위해 CPP 함수를 작성하세요 `int f_40(int n, int k)`:\n두 개의 양의 정수 n과 k가 주어졌을 때, 1 <= x <= n 범위 내에서 x = a^b 형태로 표현될 수 있는 양의 정수 x의 개수를 찾으세요. 여기서 a와 b는 양의 정수이고 b >= k입니다. x의 서로 다른 합법적인 표현은 한 번만 계산됩니다. 예를 들어:\n    >>> f_40(99, 1)\n    99", "ml": "CPP ഫംഗ്ഷൻ `int f_40(int n, int k)` എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nരണ്ട് പോസിറ്റീവ് പൂർണ്ണസംഖ്യകൾ n, k നൽകിയാൽ, 1 <= x <= n എന്ന അവസ്ഥയിൽ, x = a^b എന്ന രൂപത്തിൽ രേഖപ്പെടുത്താവുന്ന പോസിറ്റീവ് പൂർണ്ണസംഖ്യകളുടെ എണ്ണം കണ്ടെത്തുക. ഇവിടെ a, b പോസിറ്റീവ് പൂർണ്ണസംഖ്യകളായിരിക്കണം, കൂടാതെ b >= k ആയിരിക്കണം. x ന്റെ വ്യത്യസ്തമായ നിയമപരമായ പ്രതിനിധാനങ്ങൾ ഒരിക്കൽ മാത്രം എണ്ണപ്പെടുന്നു. ഉദാഹരണത്തിന്:\n    >>> f_40(99, 1)\n    99", "fa": "یک تابع CPP به نام `int f_40(int n, int k)` بنویسید تا مسئله زیر را حل کند:\nبا داشتن دو عدد صحیح مثبت n و k، تعداد اعداد صحیح مثبت x را پیدا کنید، به طوری که 1 <= x <= n، که می‌توان آن را به صورت x = a^b با a و b به عنوان اعداد صحیح مثبت و b >= k بیان کرد. نمایش‌های قانونی مختلف x فقط یک بار شمارش می‌شوند. برای مثال:\n    >>> f_40(99, 1)\n    99"}, "level": "hard", "test": "int main() {\n    assert(f_40(99, 1) == 99);\n    assert(f_40(99, 3) == 7);\n    assert(f_40(99, 2) == 12);\n    assert(f_40(10, 1) == 10);\n    assert(f_40(10, 2) == 4);\n    assert(f_40(500, 1) == 500);\n    assert(f_40(500, 2) == 30);\n    assert(f_40(500, 3) == 13);\n    assert(f_40(1000, 1) == 1000);\n    assert(f_40(1000, 2) == 41);\n    assert(f_40(1000, 3) == 17);\n    assert(f_40(1000, 93) == 1);\n    assert(f_40(50, 2) == 10);\n    assert(f_40(50, 3) == 5);\n    assert(f_40(2, 3) == 1);\n    return 0;\n}", "entry_point": "f_40", "signature": "int f_40(int n, int k)", "docstring": {"en": "Given two positive integers n and k, find the number of positive integers x, where 1 <= x <= n, that can be expressed as x = a^b with a and b being positive integers and b >= k. Different legal representations of x are counted only once. For example:\n    >>> f_40(99, 1)\n    99\n", "sq": "Duke pasur dy numra të plotë pozitivë n dhe k, gjeni numrin e numrave të plotë pozitivë x, ku 1 <= x <= n, që mund të shprehen si x = a^b me a dhe b që janë numra të plotë pozitivë dhe b >= k. Përfaqësimet e ndryshme legale të x numërohen vetëm një herë. Për shembull:\n    >>> f_40(99, 1)\n    99", "hy": "Երկու դրական ամբողջ թիվ n և k ունենալով, գտնել դրական ամբողջ թվերի x քանակը, որտեղ 1 <= x <= n, որոնք կարող են արտահայտվել որպես x = a^b, որտեղ a և b դրական ամբողջ թվեր են, և b >= k: x-ի տարբեր օրինական ներկայացումները հաշվում են միայն մեկ անգամ: Օրինակ՝\n    >>> f_40(99, 1)\n    99", "bn": "দুটি ধনাত্মক পূর্ণসংখ্যা n এবং k দেওয়া আছে, এমন ধনাত্মক পূর্ণসংখ্যা x-এর সংখ্যা খুঁজে বের করুন, যেখানে 1 <= x <= n, যা x = a^b আকারে প্রকাশ করা যায় যেখানে a এবং b ধনাত্মক পূর্ণসংখ্যা এবং b >= k। x-এর বিভিন্ন বৈধ উপস্থাপনাগুলি কেবল একবার গণনা করা হয়। উদাহরণস্বরূপ:\n    >>> f_40(99, 1)\n    99", "bg": "Дадени са две положителни цели числа n и k, намерете броя на положителните цели числа x, където 1 <= x <= n, които могат да бъдат изразени като x = a^b с a и b като положителни цели числа и b >= k. Различните легални представяния на x се броят само веднъж. Например:\n    >>> f_40(99, 1)\n    99", "zh": "给定两个正整数 n 和 k，找出有多少个正整数 x，其中 1 <= x <= n，可以表示为 x = a^b，其中 a 和 b 是正整数且 b >= k。x 的不同合法表示仅计算一次。例如：\n    >>> f_40(99, 1)\n    99", "fr": "Étant donnés deux entiers positifs n et k, trouver le nombre d'entiers positifs x, où 1 <= x <= n, qui peuvent être exprimés comme x = a^b avec a et b étant des entiers positifs et b >= k. Les différentes représentations légales de x sont comptées une seule fois. Par exemple :\n    >>> f_40(99, 1)\n    99", "de": "Gegeben zwei positive ganze Zahlen n und k, finde die Anzahl der positiven ganzen Zahlen x, wobei 1 <= x <= n, die als x = a^b ausgedrückt werden können, wobei a und b positive ganze Zahlen sind und b >= k. Verschiedene gültige Darstellungen von x werden nur einmal gezählt. Zum Beispiel:\n    >>> f_40(99, 1)\n    99", "ha": "An ba da lambobi biyu masu kyau n da k, nemo adadin lambobi masu kyau x, inda 1 <= x <= n, waɗanda za a iya bayyana su azaman x = a^b tare da a da b suna kasancewa lambobi masu kyau kuma b >= k. Ana ƙidaya wakilcin doka daban-daban na x sau ɗaya kawai. Alal misali:\n\n    >>> f_40(99, 1)\n    99", "hi": "दो सकारात्मक पूर्णांक n और k दिए गए हैं, उन सकारात्मक पूर्णांकों x की संख्या ज्ञात करें, जहाँ 1 <= x <= n, जिन्हें x = a^b के रूप में व्यक्त किया जा सकता है जहाँ a और b सकारात्मक पूर्णांक हैं और b >= k है। x के विभिन्न वैध अभ्यावेदन केवल एक बार गिने जाते हैं। उदाहरण के लिए:\n    >>> f_40(99, 1)\n    99", "hu": "Két pozitív egész szám, n és k esetén találja meg azon pozitív egész számok x számát, ahol 1 <= x <= n, és amelyek kifejezhetők x = a^b alakban, ahol a és b pozitív egész számok és b >= k. Az x különböző érvényes ábrázolásait csak egyszer számoljuk. Például:\n    >>> f_40(99, 1)\n    99", "es": "Dado dos enteros positivos n y k, encuentra el número de enteros positivos x, donde 1 <= x <= n, que pueden expresarse como x = a^b con a y b siendo enteros positivos y b >= k. Diferentes representaciones legales de x se cuentan solo una vez. Por ejemplo:\n    >>> f_40(99, 1)\n    99", "arb": "بالنظر إلى عددين صحيحين موجبين n و k، ابحث عن عدد الأعداد الصحيحة الموجبة x، حيث 1 <= x <= n، التي يمكن التعبير عنها كـ x = a^b حيث a و b هما عددان صحيحان موجبان و b >= k. يتم احتساب التمثيلات القانونية المختلفة لـ x مرة واحدة فقط. على سبيل المثال:\n    >>> f_40(99, 1)\n    99", "sw": "Ukipiwa nambari mbili chanya n na k, pata idadi ya nambari chanya x, ambapo 1 <= x <= n, ambazo zinaweza kuonyeshwa kama x = a^b huku a na b wakiwa nambari chanya na b >= k. Uwakilishi tofauti halali wa x unahesabiwa mara moja tu. Kwa mfano:\n    >>> f_40(99, 1)\n    99", "tr": "Verilen iki pozitif tamsayı n ve k için, 1 <= x <= n aralığında olan ve x = a^b şeklinde ifade edilebilen pozitif tamsayı x'in sayısını bulun, burada a ve b pozitif tamsayılardır ve b >= k'dir. x'in farklı yasal gösterimleri yalnızca bir kez sayılır. Örneğin:\n    >>> f_40(99, 1)\n    99", "vi": "Cho hai số nguyên dương n và k, tìm số lượng số nguyên dương x, với 1 <= x <= n, có thể được biểu diễn dưới dạng x = a^b với a và b là các số nguyên dương và b >= k. Các biểu diễn hợp lệ khác nhau của x chỉ được đếm một lần. Ví dụ:\n    >>> f_40(99, 1)\n    99", "id": "Diberikan dua bilangan bulat positif n dan k, temukan jumlah bilangan bulat positif x, di mana 1 <= x <= n, yang dapat dinyatakan sebagai x = a^b dengan a dan b adalah bilangan bulat positif dan b >= k. Representasi legal yang berbeda dari x dihitung hanya sekali. Sebagai contoh:\n    >>> f_40(99, 1)\n    99", "ja": "2つの正の整数 n と k が与えられたとき、1 <= x <= n の範囲で、x = a^b と表現できる正の整数 x の数を求めます。ただし、a と b は正の整数であり、b >= k です。x の異なる合法的な表現は一度だけカウントされます。例えば:\n\n    >>> f_40(99, 1)\n    99", "ko": "두 개의 양의 정수 n과 k가 주어졌을 때, 1 <= x <= n인 양의 정수 x의 개수를 찾으시오. 여기서 x는 a와 b가 양의 정수이고 b >= k인 경우 x = a^b로 표현될 수 있습니다. x의 서로 다른 합법적인 표현은 한 번만 계산됩니다. 예를 들어:\n    >>> f_40(99, 1)\n    99", "ml": "രണ്ട് പോസിറ്റീവ് പൂർണ്ണസംഖ്യകൾ n, k എന്നിവ നൽകിയാൽ, 1 <= x <= n എന്ന നിലയിൽ, x = a^b എന്ന രൂപത്തിൽ പ്രകടിപ്പിക്കാവുന്ന പോസിറ്റീവ് പൂർണ്ണസംഖ്യകളുടെ എണ്ണം കണ്ടെത്തുക, ഇവിടെ a, b എന്നിവ പോസിറ്റീവ് പൂർണ്ണസംഖ്യകളാണ്, b >= k. x ന്റെ വ്യത്യസ്തമായ നിയമാനുസൃത പ്രതിനിധാനങ്ങൾ ഒരിക്കൽ മാത്രം എണ്ണപ്പെടും. ഉദാഹരണത്തിന്:\n    >>> f_40(99, 1)\n    99", "fa": "با توجه به دو عدد صحیح مثبت n و k، تعداد اعداد صحیح مثبت x را پیدا کنید، که در آن 1 <= x <= n و می‌توان آن را به صورت x = a^b بیان کرد، به طوری که a و b اعداد صحیح مثبت هستند و b >= k. نمایش‌های قانونی مختلف x فقط یک بار شمارش می‌شوند. برای مثال:\n    >>> f_40(99, 1)\n    99"}}
{"task_id": "CPP/41", "prompt": {"en": "#include <cassert>\n/* Given three integers n, m, and k, find the number of sequences consisting of n '(' and m ')',\nsuch that the longest balanced subsequence is of length 2 * k. The result should be calculated modulo 1,000,000,007 (10^9 + 7).\n\nFor example:\n    >>> f_41(2, 2, 2)\n    2\n*/\nlong long f_41(long long n, long long m, long long k)", "sq": "#include <cassert>\n/* Duke pasur tre numra të plotë n, m, dhe k, gjeni numrin e sekuencave që përbëhen nga n '(' dhe m ')',\ntë tilla që nënsekuenca më e gjatë e balancuar është me gjatësi 2 * k. Rezultati duhet të llogaritet modulo 1,000,000,007 (10^9 + 7).\n\nPër shembull:\n    >>> f_41(2, 2, 2)\n    2\n*/\nlong long f_41(long long n, long long m, long long k)", "hy": "#include <cassert>\n/* Երեք ամբողջ թիվ n, m և k տրված են, գտնել հաջորդականությունների քանակը, որոնք բաղկացած են n '(' և m ')',\nայնպիսին, որ ամենաերկար հավասարակշռված ենթահաջորդականությունը լինի 2 * k երկարությամբ։ Արդյունքը պետք է հաշվարկվի 1,000,000,007 (10^9 + 7) մոդուլով։\n\nՕրինակ:\n    >>> f_41(2, 2, 2)\n    2\n*/\nlong long f_41(long long n, long long m, long long k)", "bn": "#include <cassert>\n/* তিনটি পূর্ণসংখ্যা n, m, এবং k দেওয়া হয়েছে, n '(' এবং m ')' নিয়ে গঠিত কতগুলি ক্রম রয়েছে তা খুঁজে বের করুন,\nযেমন দীর্ঘতম সুষম উপধারা 2 * k দৈর্ঘ্যের হয়। ফলাফলটি 1,000,000,007 (10^9 + 7) দ্বারা মডুলো হিসাবে গণনা করা উচিত।\n\nউদাহরণস্বরূপ:\n    >>> f_41(2, 2, 2)\n    2\n*/\nlong long f_41(long long n, long long m, long long k)", "bg": "#include <cassert>\n/* Дадени са три цели числа n, m и k, намерете броя на последователностите, състоящи се от n '(' и m ')',\nтакива че най-дългата балансирана подредена последователност е с дължина 2 * k. Резултатът трябва да бъде изчислен по модул 1,000,000,007 (10^9 + 7).\n\nНапример:\n    >>> f_41(2, 2, 2)\n    2\n*/\nlong long f_41(long long n, long long m, long long k)", "zh": "#include <cassert>\n/* 给定三个整数 n, m 和 k，找出由 n 个 '(' 和 m 个 ')' 组成的序列的数量，\n使得最长平衡子序列的长度为 2 * k。结果应以 1,000,000,007 (10^9 + 7) 为模进行计算。\n\n例如:\n    >>> f_41(2, 2, 2)\n    2\n*/\nlong long f_41(long long n, long long m, long long k)", "fr": "#include <cassert>\n/* Étant donné trois entiers n, m, et k, trouvez le nombre de séquences consistant en n '(' et m ')',\ntelles que la plus longue sous-séquence équilibrée soit de longueur 2 * k. Le résultat doit être calculé modulo 1,000,000,007 (10^9 + 7).\n\nPar exemple :\n    >>> f_41(2, 2, 2)\n    2\n*/\nlong long f_41(long long n, long long m, long long k)", "de": "#include <cassert>\n/* Gegeben sind drei ganze Zahlen n, m und k. Finde die Anzahl der Sequenzen, die aus n '(' und m ')' bestehen,\nso dass die längste ausgeglichene Teilsequenz die Länge 2 * k hat. Das Ergebnis sollte modulo 1.000.000.007 (10^9 + 7) berechnet werden.\n\nZum Beispiel:\n    >>> f_41(2, 2, 2)\n    2\n*/\nlong long f_41(long long n, long long m, long long k)", "ha": "#include <cassert>\n/* An ba integers guda uku n, m, da k, nemo yawan jerin abubuwa da suka ƙunshi n '(' da m ')',\nta yadda mafi tsawon jere mai daidaituwa yana da tsawon 2 * k. Ya kamata a ƙididdige sakamakon modulo 1,000,000,007 (10^9 + 7).\n\nAlal misali:\n    >>> f_41(2, 2, 2)\n    2\n*/\nlong long f_41(long long n, long long m, long long k)", "hi": "#include <cassert>\n/* तीन पूर्णांक n, m, और k दिए गए हैं, उन अनुक्रमों की संख्या खोजें जो n '(' और m ')' से बने होते हैं,\nऐसे कि सबसे लंबा संतुलित उप-अनुक्रम 2 * k लंबाई का हो। परिणाम को 1,000,000,007 (10^9 + 7) से मापांकित किया जाना चाहिए।\n\nउदाहरण के लिए:\n    >>> f_41(2, 2, 2)\n    2\n*/\nlong long f_41(long long n, long long m, long long k)", "hu": "#include <cassert>\n/* Adott három egész szám: n, m és k. Találja meg azon sorozatok számát, amelyek n '(' és m ')' karakterből állnak,\núgy, hogy a leghosszabb kiegyensúlyozott részszekvencia hossza 2 * k. Az eredményt 1,000,000,007 (10^9 + 7) modulo szerint kell kiszámítani.\n\nPéldául:\n    >>> f_41(2, 2, 2)\n    2\n*/\nlong long f_41(long long n, long long m, long long k)", "es": "#include <cassert>\n/* Dados tres enteros n, m, y k, encuentra el número de secuencias que consisten en n '(' y m ')',\ntal que la subsecuencia balanceada más larga tenga una longitud de 2 * k. El resultado debe ser calculado módulo 1,000,000,007 (10^9 + 7).\n\nPor ejemplo:\n    >>> f_41(2, 2, 2)\n    2\n*/\nlong long f_41(long long n, long long m, long long k)", "arb": "#include <cassert>\n/* بالنظر إلى ثلاثة أعداد صحيحة n و m و k، جد عدد التتابعات المكونة من n '(' و m ')',\nبحيث يكون أطول تتابع متوازن بطول 2 * k. يجب حساب النتيجة بتقسيمها على 1,000,000,007 (10^9 + 7).\n\nعلى سبيل المثال:\n    >>> f_41(2, 2, 2)\n    2\n*/\nlong long f_41(long long n, long long m, long long k)", "sw": "#include <cassert>\n/* Ukipewa nambari tatu n, m, na k, pata idadi ya mfuatano unaojumuisha n '(' na m ')',\nambapo mfuatano mrefu zaidi ulio na usawa ni wa urefu 2 * k. Matokeo yanapaswa kuhesabiwa kwa modulo 1,000,000,007 (10^9 + 7).\n\nKwa mfano:\n    >>> f_41(2, 2, 2)\n    2\n*/\nlong long f_41(long long n, long long m, long long k)", "tr": "#include <cassert>\n/* Üç tamsayı n, m ve k verildiğinde, n '(' ve m ')' karakterlerinden oluşan dizilerin sayısını bulun,\nöyle ki en uzun dengeli alt dizi uzunluğu 2 * k olsun. Sonuç 1,000,000,007 (10^9 + 7) modunda hesaplanmalıdır.\n\nÖrneğin:\n    >>> f_41(2, 2, 2)\n    2\n*/\nlong long f_41(long long n, long long m, long long k)", "vi": "#include <cassert>\n/* Cho ba số nguyên n, m và k, tìm số lượng dãy bao gồm n '(' và m ')',\nsao cho dãy con cân bằng dài nhất có độ dài 2 * k. Kết quả cần được tính theo modulo 1,000,000,007 (10^9 + 7).\n\nVí dụ:\n    >>> f_41(2, 2, 2)\n    2\n*/\nlong long f_41(long long n, long long m, long long k)", "id": "#include <cassert>\n/* Diberikan tiga bilangan bulat n, m, dan k, temukan jumlah urutan yang terdiri dari n '(' dan m ')',\nsehingga subsekuens seimbang terpanjang memiliki panjang 2 * k. Hasilnya harus dihitung dengan modulo 1,000,000,007 (10^9 + 7).\n\nSebagai contoh:\n    >>> f_41(2, 2, 2)\n    2\n*/\nlong long f_41(long long n, long long m, long long k)", "ja": "#include <cassert>\n/* 3つの整数 n, m, k が与えられたとき、n 個の '(' と m 個の ')' からなるシーケンスのうち、\n最も長いバランスの取れた部分シーケンスが長さ 2 * k であるものの数を求めます。結果は 1,000,000,007 (10^9 + 7) で計算されるべきです。\n\n例えば:\n    >>> f_41(2, 2, 2)\n    2\n*/\nlong long f_41(long long n, long long m, long long k)", "ko": "#include <cassert>\n/* 세 개의 정수 n, m, k가 주어졌을 때, n개의 '('와 m개의 ')'로 구성된 시퀀스 중 가장 긴 균형 잡힌 부분 시퀀스의 길이가 2 * k인 경우의 수를 찾습니다. 결과는 1,000,000,007 (10^9 + 7)로 나눈 나머지로 계산되어야 합니다.\n\n예를 들어:\n    >>> f_41(2, 2, 2)\n    2\n*/\nlong long f_41(long long n, long long m, long long k)", "ml": "#include <cassert>\n/* മൂന്ന് പൂർണ്ണസംഖ്യകൾ n, m, k എന്നിവ നൽകിയാൽ, n '('  മും m ')'  മും അടങ്ങിയ സീക്വൻസുകളുടെ എണ്ണം കണ്ടെത്തുക,\nഅങ്ങനെ ഏറ്റവും നീളമേറിയ ബാലൻസ്ഡ് ഉപസീക്വൻസ് 2 * k നീളമുള്ളതാണ്. ഫലം 1,000,000,007 (10^9 + 7) മൂല്യത്തിൽ മോദുലോ കണക്കാക്കണം.\n\nഉദാഹരണത്തിന്:\n    >>> f_41(2, 2, 2)\n    2\n*/\nlong long f_41(long long n, long long m, long long k)", "fa": "#include <cassert>\n/* با داشتن سه عدد صحیح n، m و k، تعداد دنباله‌هایی را پیدا کنید که از n '(' و m ')' تشکیل شده‌اند،\nبه طوری که طولانی‌ترین زیر دنباله متوازن دارای طول 2 * k باشد. نتیجه باید به پیمانه 1,000,000,007 (10^9 + 7) محاسبه شود.\n\nبرای مثال:\n    >>> f_41(2, 2, 2)\n    2\n*/\nlong long f_41(long long n, long long m, long long k)"}, "canonical_solution": "{\n    const long long P = static_cast<long long>(1e9) + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}", "instruction": {"en": "Write a CPP function `long long f_41(long long n, long long m, long long k)` to solve the following problem:\nGiven three integers n, m, and k, find the number of sequences consisting of n '(' and m ')',\nsuch that the longest balanced subsequence is of length 2 * k. The result should be calculated modulo 1,000,000,007 (10^9 + 7).\n\nFor example:\n    >>> f_41(2, 2, 2)\n    2\n", "sq": "Shkruani një funksion CPP `long long f_41(long long n, long long m, long long k)` për të zgjidhur problemin në vijim:\nDuke pasur parasysh tre numra të plotë n, m, dhe k, gjeni numrin e sekuencave që përbëhen nga n '(' dhe m ')',\ntë tilla që subsekuenca më e gjatë e balancuar është me gjatësi 2 * k. Rezultati duhet të llogaritet modulo 1,000,000,007 (10^9 + 7).\n\nPër shembull:\n    >>> f_41(2, 2, 2)\n    2", "hy": "Գրեք CPP ֆունկցիա `long long f_41(long long n, long long m, long long k)` հետևյալ խնդիրը լուծելու համար:\nՏրված են երեք ամբողջ թիվ n, m և k, գտնել n '(' և m ')' բաղկացած հաջորդականությունների քանակը,\nայնպես, որ ամենաերկար հավասարակշռված ենթահաջորդականությունը լինի 2 * k երկարությամբ։ Արդյունքը պետք է հաշվարկվի 1,000,000,007 (10^9 + 7) մոդուլով։", "bn": "একটি CPP ফাংশন `long long f_41(long long n, long long m, long long k)` লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\nতিনটি পূর্ণসংখ্যা n, m, এবং k দেওয়া আছে, n '(' এবং m ')' নিয়ে গঠিত এমন সিকোয়েন্সের সংখ্যা খুঁজে বের করুন, যাতে দীর্ঘতম ব্যালান্সড সাবসিকোয়েন্সের দৈর্ঘ্য 2 * k হয়। ফলাফলটি 1,000,000,007 (10^9 + 7) মডুলোতে গণনা করা উচিত।\n\nউদাহরণস্বরূপ:\n    >>> f_41(2, 2, 2)\n    2", "bg": "Напишете CPP функция `long long f_41(long long n, long long m, long long k)`, за да решите следния проблем:\nДадени са три цели числа n, m и k, намерете броя на последователностите, състоящи се от n '(' и m ')',\nтакива че най-дългата балансирана подредица е с дължина 2 * k. Резултатът трябва да бъде изчислен по модул 1,000,000,007 (10^9 + 7).\n\nНапример:\n    >>> f_41(2, 2, 2)\n    2", "zh": "编写一个 CPP 函数 `long long f_41(long long n, long long m, long long k)` 来解决以下问题：\n给定三个整数 n, m 和 k，找出由 n 个 '(' 和 m 个 ')' 组成的序列的数量，\n使得最长的平衡子序列的长度为 2 * k。结果应以 1,000,000,007 (10^9 + 7) 为模进行计算。\n\n例如：\n    >>> f_41(2, 2, 2)\n    2", "fr": "Écrire une fonction CPP `long long f_41(long long n, long long m, long long k)` pour résoudre le problème suivant :\nÉtant donné trois entiers n, m, et k, trouver le nombre de séquences composées de n '(' et m ')',\ntelles que la plus longue sous-séquence équilibrée soit de longueur 2 * k. Le résultat doit être calculé modulo 1,000,000,007 (10^9 + 7).\n\nPar exemple :\n    >>> f_41(2, 2, 2)\n    2", "de": "Schreiben Sie eine CPP-Funktion `long long f_41(long long n, long long m, long long k)`, um das folgende Problem zu lösen:\nGegeben sind drei ganze Zahlen n, m und k. Finden Sie die Anzahl der Sequenzen, die aus n '(' und m ')' bestehen,\nso dass die längste balancierte Teilsequenz die Länge 2 * k hat. Das Ergebnis sollte modulo 1.000.000.007 (10^9 + 7) berechnet werden.\n\nZum Beispiel:\n    >>> f_41(2, 2, 2)\n    2", "ha": "Rubuta aikin CPP `long long f_41(long long n, long long m, long long k)` don warware matsalar mai zuwa:  \nAn ba da lambobi guda uku n, m, da k, nemo adadin jerin da suka ƙunshi n '(' da m ')',  \nta yadda mafi tsawon jerin da aka daidaita yana da tsawon 2 * k. Ya kamata a ƙididdige sakamakon modulo 1,000,000,007 (10^9 + 7).  \n\nAlal misali:  \n    >>> f_41(2, 2, 2)  \n    2  ", "hi": "एक CPP फ़ंक्शन `long long f_41(long long n, long long m, long long k)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए तीन पूर्णांक n, m, और k, n '(' और m ')' से बनी अनुक्रमों की संख्या खोजें,\nऐसे कि सबसे लंबा संतुलित उप-अनुक्रम 2 * k लंबाई का हो। परिणाम को 1,000,000,007 (10^9 + 7) से मापांकित किया जाना चाहिए।\n\nउदाहरण के लिए:\n    >>> f_41(2, 2, 2)\n    2", "hu": "Írj egy CPP függvényt `long long f_41(long long n, long long m, long long k)` a következő probléma megoldására:\nAdott három egész szám: n, m és k, találd meg azon sorozatok számát, amelyek n '(' és m ')' jelekből állnak,\núgy, hogy a leghosszabb kiegyensúlyozott részszekvencia hossza 2 * k. Az eredményt 1,000,000,007 (10^9 + 7) modulo szerint kell kiszámítani.\n\nPéldául:\n    >>> f_41(2, 2, 2)\n    2", "es": "Escribe una función CPP `long long f_41(long long n, long long m, long long k)` para resolver el siguiente problema:\nDado tres enteros n, m, y k, encuentra el número de secuencias que consisten en n '(' y m ')',\ntal que la subsecuencia balanceada más larga tenga una longitud de 2 * k. El resultado debe ser calculado módulo 1,000,000,007 (10^9 + 7).\n\nPor ejemplo:\n    >>> f_41(2, 2, 2)\n    2", "arb": "اكتب دالة CPP `long long f_41(long long n, long long m, long long k)` لحل المشكلة التالية:\nمعطى ثلاثة أعداد صحيحة n، m، و k، ابحث عن عدد التتابعات المكونة من n '(' و m ')',\nبحيث يكون أطول تتابع متوازن بطول 2 * k. يجب حساب النتيجة بتقسيمها على 1,000,000,007 (10^9 + 7).\n\nعلى سبيل المثال:\n    >>> f_41(2, 2, 2)\n    2", "sw": "Andika kazi ya CPP `long long f_41(long long n, long long m, long long k)` kutatua tatizo lifuatalo:\nUkipiwa nambari tatu n, m, na k, tafuta idadi ya misururu inayojumuisha n '(' na m ')',\nhivyo kwamba msururu mrefu zaidi ulio sawa ni wa urefu wa 2 * k. Matokeo yanapaswa kuhesabiwa kwa modulo 1,000,000,007 (10^9 + 7).\n\nKwa mfano:\n    >>> f_41(2, 2, 2)\n    2", "tr": "Bir CPP fonksiyonu `long long f_41(long long n, long long m, long long k)` yazın ve aşağıdaki problemi çözün:\nÜç tamsayı n, m ve k verildiğinde, n '(' ve m ')' karakterlerinden oluşan dizilerin sayısını bulun,\nöyle ki en uzun dengeli alt dizi uzunluğu 2 * k olsun. Sonuç 1,000,000,007 (10^9 + 7) modunda hesaplanmalıdır.\n\nÖrneğin:\n    >>> f_41(2, 2, 2)\n    2", "vi": "Viết một hàm CPP `long long f_41(long long n, long long m, long long k)` để giải quyết vấn đề sau:\nCho ba số nguyên n, m và k, tìm số lượng dãy gồm n '(' và m ')',\nsao cho dãy con cân bằng dài nhất có độ dài 2 * k. Kết quả cần được tính theo modulo 1,000,000,007 (10^9 + 7).\n\nVí dụ:\n    >>> f_41(2, 2, 2)\n    2", "id": "Tulis fungsi CPP `long long f_41(long long n, long long m, long long k)` untuk menyelesaikan masalah berikut:\nDiberikan tiga bilangan bulat n, m, dan k, temukan jumlah urutan yang terdiri dari n '(' dan m ')',\nsehingga subsekuens seimbang terpanjang memiliki panjang 2 * k. Hasilnya harus dihitung modulo 1,000,000,007 (10^9 + 7).\n\nSebagai contoh:\n    >>> f_41(2, 2, 2)\n    2", "ja": "以下の問題を解くために、CPP関数 `long long f_41(long long n, long long m, long long k)` を作成してください:\n3つの整数 n, m, k が与えられたとき、n 個の '(' と m 個の ')' からなるシーケンスのうち、最長のバランスの取れた部分列が長さ 2 * k であるものの数を求めてください。結果は1,000,000,007 (10^9 + 7) で計算されたものとします。\n\n例えば:\n    >>> f_41(2, 2, 2)\n    2", "ko": "CPP 함수를 작성하십시오 `long long f_41(long long n, long long m, long long k)` 다음 문제를 해결하기 위해:\n세 개의 정수 n, m, k가 주어졌을 때, n개의 '('와 m개의 ')'로 구성된 시퀀스의 수를 찾으십시오,\n여기서 가장 긴 균형 잡힌 부분 시퀀스의 길이는 2 * k입니다. 결과는 1,000,000,007 (10^9 + 7)로 나눈 나머지로 계산해야 합니다.\n\n예를 들어:\n    >>> f_41(2, 2, 2)\n    2", "ml": "CPP ഫംഗ്ഷൻ `long long f_41(long long n, long long m, long long k)` എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ: മൂന്ന് പൂർണ്ണസംഖ്യകൾ n, m, k നൽകിയാൽ, n '(' മുകളിലും m ')' മുകളിലും ഉള്ള ക്രമങ്ങൾ എത്രയുണ്ടെന്ന് കണ്ടെത്തുക, അങ്ങനെ ഏറ്റവും നീളമുള്ള ബാലൻസ്ഡ് സബ്‌സീക്വൻസ് 2 * k നീളമുള്ളതായിരിക്കും. ഫലം 1,000,000,007 (10^9 + 7) കൊണ്ട് മോഡുലോ കണക്കാക്കണം.\n\nഉദാഹരണത്തിന്:\n    >>> f_41(2, 2, 2)\n    2", "fa": "یک تابع CPP به نام `long long f_41(long long n, long long m, long long k)` بنویسید تا مسئله زیر را حل کند:\nبا توجه به سه عدد صحیح n، m، و k، تعداد دنباله‌هایی را بیابید که از n '(' و m ')' تشکیل شده‌اند،\nبه طوری که طولانی‌ترین زیر دنباله متوازن دارای طول 2 * k باشد. نتیجه باید به پیمانه 1,000,000,007 (10^9 + 7) محاسبه شود.\n\nبرای مثال:\n    >>> f_41(2, 2, 2)\n    2"}, "level": "hard", "test": "int main() {\n    assert(f_41(2, 2, 2) == 2);\n    assert(f_41(3, 2, 3) == 0);\n    assert(f_41(3, 2, 1) == 4);\n    assert(f_41(4, 3, 2) == 14);\n    assert(f_41(5, 5, 2) == 35);\n    assert(f_41(6, 1, 1) == 6);\n    assert(f_41(1, 6, 1) == 6);\n    assert(f_41(7, 2, 2) == 27);\n    assert(f_41(8, 3, 3) == 110);\n    assert(f_41(10, 10, 5) == 10659);\n    assert(f_41(20, 20, 10) == 574221648);\n    assert(f_41(2000, 2000, 1000) == 854104531);\n    assert(f_41(2000, 1999, 1000) == 334874485);\n    assert(f_41(2000, 2000, 1999) == 259428024);\n    return 0;\n}", "entry_point": "f_41", "signature": "long long f_41(long long n, long long m, long long k)", "docstring": {"en": "Given three integers n, m, and k, find the number of sequences consisting of n '(' and m ')',\nsuch that the longest balanced subsequence is of length 2 * k. The result should be calculated modulo 1,000,000,007 (10^9 + 7).\n\nFor example:\n    >>> f_41(2, 2, 2)\n    2\n", "sq": "Duke pasur tre numra të plotë n, m, dhe k, gjeni numrin e sekuencave që përbëhen nga n '(' dhe m ')',\ntë tilla që nënsekuenca më e gjatë e balancuar është me gjatësi 2 * k. Rezultati duhet të llogaritet modulo 1,000,000,007 (10^9 + 7).\n\nPër shembull:\n    >>> f_41(2, 2, 2)\n    2\n", "hy": "Երեք ամբողջ թիվ n, m և k ունենալով, գտնել հաջորդականությունների քանակը, որոնք բաղկացած են n '(' և m ')' նշաններից, այնպես, որ ամենաերկար հավասարակշռված ենթահաջորդականությունը լինի 2 * k երկարությամբ: Արդյունքը պետք է հաշվարկվի 1,000,000,007 (10^9 + 7) մոդուլով:\n\nՕրինակ:\n    >>> f_41(2, 2, 2)\n    2", "bn": "তিনটি পূর্ণসংখ্যা n, m, এবং k দেওয়া আছে, n '(' এবং m ')' নিয়ে গঠিত সিকোয়েন্সের সংখ্যা খুঁজে বের করুন, যাতে দীর্ঘতম ব্যালেন্সড সাবসিকোয়েন্সের দৈর্ঘ্য 2 * k হয়। ফলাফলটি 1,000,000,007 (10^9 + 7) দ্বারা মডুলোতে গণনা করা উচিত।\n\nউদাহরণস্বরূপ:\n    >>> f_41(2, 2, 2)\n    2", "bg": "Дадени са три цели числа n, m и k, намерете броя на редиците, състоящи се от n '(' и m ')',\nтакива, че най-дългата балансирана подредица е с дължина 2 * k. Резултатът трябва да бъде изчислен по модул 1,000,000,007 (10^9 + 7).\n\nНапример:\n    >>> f_41(2, 2, 2)\n    2", "zh": "给定三个整数 n, m 和 k，找出由 n 个 '(' 和 m 个 ')' 组成的序列的数量，使得最长的平衡子序列的长度为 2 * k。结果应取模 1,000,000,007 (10^9 + 7)。\n\n例如：\n    >>> f_41(2, 2, 2)\n    2", "fr": "Étant donné trois entiers n, m et k, trouvez le nombre de séquences consistant en n '(' et m ')', \ntelles que la plus longue sous-séquence équilibrée soit de longueur 2 * k. Le résultat doit être calculé modulo 1,000,000,007 (10^9 + 7).\n\nPar exemple :\n    >>> f_41(2, 2, 2)\n    2", "de": "Gegeben drei ganze Zahlen n, m und k, finde die Anzahl der Sequenzen bestehend aus n '(' und m ')', \nso dass die längste ausgeglichene Teilsequenz die Länge 2 * k hat. Das Ergebnis sollte modulo 1.000.000.007 (10^9 + 7) berechnet werden.\n\nZum Beispiel:\n    >>> f_41(2, 2, 2)\n    2", "ha": "An ba da lambobi guda uku n, m, da k, nemo adadin jerin lambobi da suka ƙunshi n '(' da m ')', \nta yadda mafi tsawon jeri mai daidaituwa yana da tsawon 2 * k. Ya kamata a ƙididdige sakamakon tare da modulo 1,000,000,007 (10^9 + 7).\n\nMisali:\n    >>> f_41(2, 2, 2)\n    2", "hi": "तीन पूर्णांक n, m, और k दिए गए हैं, उन अनुक्रमों की संख्या खोजें जो n '(' और m ')' से बने होते हैं, ताकि सबसे लंबा संतुलित उप-अनुक्रम 2 * k लंबाई का हो। परिणाम को 1,000,000,007 (10^9 + 7) से मापांकित करके गणना की जानी चाहिए।\n\nउदाहरण के लिए:\n    >>> f_41(2, 2, 2)\n    2", "hu": "Három egész szám, n, m és k megadása esetén találja meg azon sorozatok számát, amelyek n '(' és m ')' karakterből állnak, úgy, hogy a leghosszabb kiegyensúlyozott részszekvencia hossza 2 * k legyen. Az eredményt 1,000,000,007 (10^9 + 7) maradékával kell kiszámítani.\n\nPéldául:\n    >>> f_41(2, 2, 2)\n    2", "es": "Dado tres enteros n, m, y k, encuentra el número de secuencias que consisten en n '(' y m ')',\ntal que la subsecuencia balanceada más larga sea de longitud 2 * k. El resultado debe calcularse módulo 1,000,000,007 (10^9 + 7).\n\nPor ejemplo:\n    >>> f_41(2, 2, 2)\n    2", "arb": "معطى ثلاثة أعداد صحيحة n و m و k، ابحث عن عدد التتابعات التي تتكون من n '(' و m ')',\nبحيث يكون أطول تتابع متوازن بطول 2 * k. يجب حساب النتيجة بتطبيق المودولو 1,000,000,007 (10^9 + 7).\n\nعلى سبيل المثال:\n    >>> f_41(2, 2, 2)\n    2", "sw": "Kwa kupewa nambari tatu za mzima n, m, na k, tafuta idadi ya mfuatano unaojumuisha n '(' na m ')',\nambapo mfuatano mrefu zaidi wenye usawa una urefu wa 2 * k. Matokeo yanapaswa kuhesabiwa kwa modulo 1,000,000,007 (10^9 + 7).\n\nKwa mfano:\n    >>> f_41(2, 2, 2)\n    2", "tr": "Üç tamsayı n, m ve k verildiğinde, n '(' ve m ')' karakterlerinden oluşan dizilerin sayısını bulun, öyle ki en uzun dengeli alt dizi uzunluğu 2 * k olsun. Sonuç 1,000,000,007 (10^9 + 7) modunda hesaplanmalıdır.\n\nÖrneğin:\n    >>> f_41(2, 2, 2)\n    2", "vi": "Cho ba số nguyên n, m và k, tìm số lượng dãy bao gồm n dấu '(' và m dấu ')', sao cho dãy con cân bằng dài nhất có độ dài 2 * k. Kết quả nên được tính theo modulo 1,000,000,007 (10^9 + 7).\n\nVí dụ:\n    >>> f_41(2, 2, 2)\n    2", "id": "Diberikan tiga bilangan bulat n, m, dan k, temukan jumlah urutan yang terdiri dari n '(' dan m ')',\nsedemikian rupa sehingga subsekuens seimbang terpanjang memiliki panjang 2 * k. Hasilnya harus dihitung dengan modulo 1,000,000,007 (10^9 + 7).\n\nSebagai contoh:\n    >>> f_41(2, 2, 2)\n    2", "ja": "3つの整数 n、m、k が与えられたとき、n 個の '(' と m 個の ')' からなるシーケンスのうち、最も長いバランスの取れた部分シーケンスの長さが 2 * k であるものの数を求めます。結果は 1,000,000,007 (10^9 + 7) で計算する必要があります。\n\n例:\n    >>> f_41(2, 2, 2)\n    2", "ko": "세 개의 정수 n, m, k가 주어졌을 때, n개의 '('와 m개의 ')'로 구성된 시퀀스 중에서 가장 긴 균형 잡힌 부분 시퀀스의 길이가 2 * k인 경우의 수를 찾으십시오. 결과는 1,000,000,007 (10^9 + 7)로 나눈 나머지로 계산해야 합니다.\n\n예를 들어:\n    >>> f_41(2, 2, 2)\n    2", "ml": "മൂന്ന് പൂർണ്ണസംഖ്യകൾ n, m, k എന്നിവ നൽകിയാൽ, n '('  മുകൾ m ')'  അടങ്ങിയ ശ്രേണികളുടെ എണ്ണം കണ്ടെത്തുക, അങ്ങനെ ഏറ്റവും നീളം കൂടിയ ബാലൻസ്ഡ് ഉപശ്രേണി 2 * k നീളമുള്ളതായിരിക്കും. ഫലം 1,000,000,007 (10^9 + 7) മോഡുലോയിൽ കണക്കാക്കണം.\n\nഉദാഹരണം:\n    >>> f_41(2, 2, 2)\n    2", "fa": "با توجه به سه عدد صحیح n، m و k، تعداد دنباله‌هایی را پیدا کنید که شامل n '(' و m ')' باشند، به طوری که طولانی‌ترین زیر دنباله متوازن دارای طول 2 * k باشد. نتیجه باید به پیمانه 1,000,000,007 (10^9 + 7) محاسبه شود.\n\nبرای مثال:\n    >>> f_41(2, 2, 2)\n    2"}}
{"task_id": "CPP/42", "prompt": {"en": "#include <cassert>\n#include <cstdio>\n/**\n * Given a rectangle paper of size n x m placed on a plane Cartesian coordinate \n * system with its bottom-left corner at (0,0) and top-right corner at (n,m), \n * you need to calculate the expected number of operations to cut the paper such that \n * the remaining area is less than k. In each operation, a line is randomly chosen \n * that is parallel to the axes, passes through points with integer coordinates, \n * and cuts through (not just touching the edge) the paper. The bottom or right part \n * of the paper along this line is then discarded. The answer should be modulo 10^9+7.\n *\n * For example:\n *     >>> f_42(3, 3, 4)\n *     3\n *     >>> f_42(5, 5, 12)\n *     2\n */\nlong long f_42(int n, int m, long long k)", "sq": "#include <cassert>\n#include <cstdio>\n/**\n * Duke pasur një letër drejtkëndëshe me madhësi n x m të vendosur në një sistem \n * koordinativ Kartezian në plan me këndin e poshtëm të majtë në (0,0) dhe këndin \n * e sipërm të djathtë në (n,m), ju duhet të llogaritni numrin e pritur të operacioneve \n * për të prerë letrën në mënyrë që sipërfaqja e mbetur të jetë më pak se k. Në çdo \n * operacion, zgjidhet rastësisht një vijë që është paralele me boshtet, kalon nëpër \n * pika me koordinata të plota, dhe pret (jo vetëm prek skajin) letrën. Pjesa e poshtme \n * ose e djathtë e letrës përgjatë kësaj vije më pas hidhet. Përgjigja duhet të jetë modulo 10^9+7.\n *\n * Për shembull:\n *     >>> f_42(3, 3, 4)\n *     3\n *     >>> f_42(5, 5, 12)\n *     2\n */\nlong long f_42(int n, int m, long long k)", "hy": "#include <cassert>\n#include <cstdio>\n/**\n * Տրված է n x m չափսերով ուղղանկյուն թուղթ, որը տեղադրված է դեկարտյան հարթության վրա՝ \n * իր ներքևի ձախ անկյունը (0,0) կետում և վերևի աջ անկյունը (n,m) կետում, \n * անհրաժեշտ է հաշվել գործողությունների սպասվող քանակը՝ թուղթը կտրելու համար այնպես, \n * որ մնացած մակերեսը լինի k-ից փոքր: Յուրաքանչյուր գործողության ժամանակ պատահականորեն ընտրվում է \n * մի գիծ, որը զուգահեռ է առանցքներին, անցնում է ամբողջ թվային կոորդինատներով կետերով, \n * և կտրում է թուղթը (ոչ միայն եզրին դիպչելով): Թղթի այդ գծի երկայնքով ներքևի կամ աջ մասը \n * ապա հեռացվում է: Պատասխանը պետք է լինի 10^9+7 մոդուլով:\n *\n * Օրինակ:\n *     >>> f_42(3, 3, 4)\n *     3\n *     >>> f_42(5, 5, 12)\n *     2\n */\nlong long f_42(int n, int m, long long k)", "bn": "#include <cassert>\n#include <cstdio>\n/**\n * একটি আয়তাকার কাগজ n x m আকারের একটি সমতল কার্টেসিয়ান স্থানাঙ্ক \n * ব্যবস্থায় রাখা হয়েছে যার নিচের-বাম কোণ (0,0) এবং উপরের-ডান কোণ (n,m) এ, \n * আপনাকে কাগজ কাটার প্রত্যাশিত অপারেশনের সংখ্যা গণনা করতে হবে যাতে \n * অবশিষ্ট এলাকা k এর চেয়ে কম হয়। প্রতিটি অপারেশনে, একটি লাইন এলোমেলোভাবে \n * নির্বাচিত হয় যা অক্ষগুলোর সমান্তরাল, পূর্ণসংখ্যা স্থানাঙ্ক সহ পয়েন্টগুলোর \n * মধ্য দিয়ে যায়, এবং কাগজের মধ্য দিয়ে কাটে (শুধুমাত্র প্রান্ত স্পর্শ নয়)। \n * এই লাইনের সাথে কাগজের নিচের বা ডান অংশটি তখন বাতিল করা হয়। \n * উত্তরটি 10^9+7 মডুলোতে হওয়া উচিত।\n *\n * উদাহরণস্বরূপ:\n *     >>> f_42(3, 3, 4)\n *     3\n *     >>> f_42(5, 5, 12)\n *     2\n */\nlong long f_42(int n, int m, long long k)", "bg": "#include <cassert>\n#include <cstdio>\n/**\n * Даден е правоъгълен лист хартия с размер n x m, поставен в равнинна \n * декартова координатна система с долен ляв ъгъл в (0,0) и горен десен ъгъл в (n,m). \n * Трябва да изчислите очаквания брой операции за рязане на хартията така, че \n * оставащата площ да е по-малка от k. При всяка операция се избира случайна линия, \n * която е успоредна на осите, преминава през точки с цели координати и \n * пресича (не само докосва ръба) хартията. Долната или дясната част на хартията \n * по тази линия след това се изхвърля. Отговорът трябва да бъде модул 10^9+7.\n *\n * Например:\n *     >>> f_42(3, 3, 4)\n *     3\n *     >>> f_42(5, 5, 12)\n *     2\n */\nlong long f_42(int n, int m, long long k)", "zh": "#include <cassert>\n#include <cstdio>\n/**\n * 给定一个大小为 n x m 的矩形纸张，放置在平面直角坐标系中，\n * 其左下角在 (0,0)，右上角在 (n,m)，\n * 需要计算切割纸张的期望操作次数，使得剩余面积小于 k。\n * 在每次操作中，随机选择一条平行于坐标轴的线，\n * 该线通过整数坐标的点，并且切割（不仅仅是接触边缘）纸张。\n * 然后丢弃沿着这条线的底部或右侧部分。\n * 答案应对 10^9+7 取模。\n *\n * 例如：\n *     >>> f_42(3, 3, 4)\n *     3\n *     >>> f_42(5, 5, 12)\n *     2\n */\nlong long f_42(int n, int m, long long k)", "fr": "#include <cassert>\n#include <cstdio>\n/**\n * Étant donné un papier rectangulaire de taille n x m placé sur un système de coordonnées \n * cartésiennes avec son coin inférieur gauche à (0,0) et son coin supérieur droit à (n,m), \n * vous devez calculer le nombre attendu d'opérations pour couper le papier de sorte que \n * la surface restante soit inférieure à k. À chaque opération, une ligne est choisie au hasard \n * qui est parallèle aux axes, passe par des points avec des coordonnées entières, \n * et coupe (ne se contente pas de toucher le bord) le papier. La partie inférieure ou droite \n * du papier le long de cette ligne est alors jetée. La réponse doit être modulo 10^9+7.\n *\n * Par exemple :\n *     >>> f_42(3, 3, 4)\n *     3\n *     >>> f_42(5, 5, 12)\n *     2\n */\nlong long f_42(int n, int m, long long k)", "de": "#include <cassert>\n#include <cstdio>\n/**\n * Gegeben ein rechteckiges Papier der Größe n x m, das in einem kartesischen \n * Koordinatensystem auf einer Ebene platziert ist, mit seiner unteren linken Ecke bei (0,0) \n * und der oberen rechten Ecke bei (n,m), müssen Sie die erwartete Anzahl von Operationen \n * berechnen, um das Papier so zu schneiden, dass die verbleibende Fläche kleiner als k ist. \n * Bei jeder Operation wird eine Linie zufällig gewählt, die parallel zu den Achsen verläuft, \n * durch Punkte mit ganzzahligen Koordinaten geht und das Papier durchschneidet \n * (nicht nur den Rand berührt). Der untere oder rechte Teil des Papiers entlang dieser Linie \n * wird dann verworfen. Die Antwort sollte modulo 10^9+7 sein.\n *\n * Zum Beispiel:\n *     >>> f_42(3, 3, 4)\n *     3\n *     >>> f_42(5, 5, 12)\n *     2\n */\nlong long f_42(int n, int m, long long k)", "ha": "#include <cassert>\n#include <cstdio>\n/**\n * An ba takardar murabba'i mai girman n x m da aka sanya a kan tsarin da'ira \n * na Cartesian tare da kusurwar ƙasa-hagu a (0,0) da kusurwar sama-dama a (n,m), \n * kana buƙatar ƙididdige adadin ayyukan da ake tsammani don yanke takardar ta yadda \n * yankin da ya rage ya kasance ƙasa da k. A kowane aiki, ana zaɓar layi da bazuwar \n * wanda yake daidai da ginshiƙai, ya wuce ta wurare tare da daidaitattun lambobi, \n * kuma yana yanke (ba kawai taɓa gefen ba) takardar. Ana watsar da ɓangaren ƙasa ko dama \n * na takardar tare da wannan layin. Amsar ya kamata ta kasance modulo 10^9+7.\n *\n * Alal misali:\n *     >>> f_42(3, 3, 4)\n *     3\n *     >>> f_42(5, 5, 12)\n *     2\n */\nlong long f_42(int n, int m, long long k)", "hi": "#include <cassert>\n#include <cstdio>\n/**\n * एक आयताकार कागज जिसका आकार n x m है, को एक समतल कार्टेशियन निर्देशांक \n * प्रणाली पर रखा गया है, जिसका निचला-बायां कोना (0,0) पर और ऊपरी-दायां कोना (n,m) पर है, \n * आपको कागज को इस तरह काटने के लिए अपेक्षित ऑपरेशनों की संख्या की गणना करनी है कि \n * शेष क्षेत्रफल k से कम हो। प्रत्येक ऑपरेशन में, एक रेखा यादृच्छिक रूप से चुनी जाती है \n * जो अक्षों के समानांतर होती है, पूर्णांक निर्देशांक वाले बिंदुओं से गुजरती है, \n * और कागज को काटती है (सिर्फ किनारे को छूने वाली नहीं)। इस रेखा के साथ कागज का निचला \n * या दायां हिस्सा फिर हटा दिया जाता है। उत्तर को 10^9+7 के मापांक में दिया जाना चाहिए।\n *\n * उदाहरण के लिए:\n *     >>> f_42(3, 3, 4)\n *     3\n *     >>> f_42(5, 5, 12)\n *     2\n */\nlong long f_42(int n, int m, long long k)", "hu": "#include <cassert>\n#include <cstdio>\n/**\n * Adott egy n x m méretű téglalap alakú papír, amely a síkbeli derékszögű koordináta-\n * rendszerben helyezkedik el úgy, hogy az alsó-bal sarka a (0,0) pontban, a felső-jobb \n * sarka pedig az (n,m) pontban van. Ki kell számítani a várható műveletek számát, hogy \n * a papírt úgy vágjuk, hogy a megmaradt terület kisebb legyen, mint k. Minden műveletben \n * véletlenszerűen választunk egy vonalat, amely párhuzamos a tengelyekkel, egész koordinátájú \n * pontokon halad át, és átvágja (nem csak érinti a szélét) a papírt. A papír ezen vonal mentén \n * lévő alsó vagy jobb részét eldobja. Az eredménynek modulo 10^9+7 kell lennie.\n *\n * Például:\n *     >>> f_42(3, 3, 4)\n *     3\n *     >>> f_42(5, 5, 12)\n *     2\n */\nlong long f_42(int n, int m, long long k)", "es": "#include <cassert>\n#include <cstdio>\n/**\n * Dado un papel rectangular de tamaño n x m colocado en un sistema de coordenadas \n * cartesianas en un plano, con su esquina inferior izquierda en (0,0) y la esquina \n * superior derecha en (n,m), necesitas calcular el número esperado de operaciones \n * para cortar el papel de tal manera que el área restante sea menor que k. En cada \n * operación, se elige aleatoriamente una línea que es paralela a los ejes, pasa por \n * puntos con coordenadas enteras y corta (no solo toca el borde) el papel. La parte \n * inferior o derecha del papel a lo largo de esta línea se descarta. La respuesta \n * debe ser módulo 10^9+7.\n *\n * Por ejemplo:\n *     >>> f_42(3, 3, 4)\n *     3\n *     >>> f_42(5, 5, 12)\n *     2\n */\nlong long f_42(int n, int m, long long k)", "arb": "#include <cassert>\n#include <cstdio>\n/**\n * بالنظر إلى ورقة مستطيلة بحجم n x m موضوعة على نظام إحداثيات ديكارتي مستوي \n * مع وجود الزاوية السفلية اليسرى عند (0,0) والزاوية العلوية اليمنى عند (n,m)، \n * تحتاج إلى حساب العدد المتوقع من العمليات لقطع الورقة بحيث تكون المساحة المتبقية أقل من k. \n * في كل عملية، يتم اختيار خط عشوائي موازٍ للمحاور، يمر عبر نقاط ذات إحداثيات صحيحة، \n * ويقطع (وليس فقط يلمس الحافة) الورقة. ثم يتم التخلص من الجزء السفلي أو الأيمن من الورقة \n * على طول هذا الخط. يجب أن تكون الإجابة موديولو 10^9+7.\n *\n * على سبيل المثال:\n *     >>> f_42(3, 3, 4)\n *     3\n *     >>> f_42(5, 5, 12)\n *     2\n */\nlong long f_42(int n, int m, long long k)", "sw": "#include <cassert>\n#include <cstdio>\n/**\n * Ukiwa na karatasi ya mstatili ya ukubwa n x m iliyowekwa kwenye mfumo wa kuratibu wa Cartesian \n * kwenye ndege na kona yake ya chini-kushoto iko kwenye (0,0) na kona ya juu-kulia iko kwenye (n,m), \n * unahitaji kuhesabu idadi inayotarajiwa ya operesheni za kukata karatasi ili eneo lililobaki liwe chini ya k. \n * Katika kila operesheni, mstari unachaguliwa kwa nasibu ambao ni sambamba na mhimili, unapita kupitia \n * pointi zenye kuratibu za nambari kamili, na unakata (sio tu kugusa ukingo) karatasi. Sehemu ya chini au ya kulia \n * ya karatasi kando ya mstari huu kisha inatupwa. Jibu linapaswa kuwa modulo 10^9+7.\n *\n * Kwa mfano:\n *     >>> f_42(3, 3, 4)\n *     3\n *     >>> f_42(5, 5, 12)\n *     2\n */\nlong long f_42(int n, int m, long long k)", "tr": "#include <cassert>\n#include <cstdio>\n/**\n * n x m boyutunda bir dikdörtgen kağıt, düzlem Kartezyen koordinat \n * sisteminde alt-sol köşesi (0,0) ve üst-sağ köşesi (n,m) olacak şekilde yerleştirilmiştir. \n * Kağıdın kalan alanının k'dan küçük olacak şekilde kesilmesi için gereken \n * beklenen işlem sayısını hesaplamanız gerekmektedir. Her işlemde, eksenlere paralel, \n * tam sayı koordinatlarına sahip noktalardan geçen ve kağıdı kesen (sadece kenara dokunmayan) \n * bir çizgi rastgele seçilir. Bu çizgi boyunca kağıdın alt veya sağ kısmı atılır. \n * Cevap 10^9+7 ile mod alınmalıdır.\n *\n * Örneğin:\n *     >>> f_42(3, 3, 4)\n *     3\n *     >>> f_42(5, 5, 12)\n *     2\n */\nlong long f_42(int n, int m, long long k)", "vi": "#include <cassert>\n#include <cstdio>\n/**\n * Cho một tờ giấy hình chữ nhật kích thước n x m đặt trên hệ tọa độ \n * phẳng Cartesian với góc dưới bên trái tại (0,0) và góc trên bên phải tại (n,m), \n * bạn cần tính số lượng thao tác kỳ vọng để cắt giấy sao cho \n * diện tích còn lại nhỏ hơn k. Trong mỗi thao tác, một đường thẳng được chọn ngẫu nhiên \n * song song với các trục, đi qua các điểm có tọa độ nguyên, \n * và cắt qua (không chỉ chạm vào cạnh) tờ giấy. Phần dưới hoặc bên phải \n * của tờ giấy dọc theo đường này sau đó bị loại bỏ. Kết quả nên được lấy theo modulo 10^9+7.\n *\n * Ví dụ:\n *     >>> f_42(3, 3, 4)\n *     3\n *     >>> f_42(5, 5, 12)\n *     2\n */\nlong long f_42(int n, int m, long long k)", "id": "#include <cassert>\n#include <cstdio>\n/**\n * Diberikan sebuah kertas berbentuk persegi panjang dengan ukuran n x m yang diletakkan pada sistem koordinat Kartesius \n * dengan sudut kiri bawah di (0,0) dan sudut kanan atas di (n,m), Anda perlu menghitung jumlah operasi yang diharapkan \n * untuk memotong kertas sehingga area yang tersisa kurang dari k. Dalam setiap operasi, sebuah garis dipilih secara acak \n * yang sejajar dengan sumbu, melewati titik-titik dengan koordinat bilangan bulat, dan memotong (bukan hanya menyentuh tepi) kertas. \n * Bagian bawah atau kanan dari kertas sepanjang garis ini kemudian dibuang. Jawabannya harus dalam modulo 10^9+7.\n *\n * Sebagai contoh:\n *     >>> f_42(3, 3, 4)\n *     3\n *     >>> f_42(5, 5, 12)\n *     2\n */\nlong long f_42(int n, int m, long long k)", "ja": "#include <cassert>\n#include <cstdio>\n/**\n * n x mのサイズの長方形の紙が、平面直交座標系上において、左下の角が(0,0)に、右上の角が(n,m)に配置されています。\n * 残りの面積がk未満になるように紙を切るための操作の期待回数を計算する必要があります。\n * 各操作では、軸に平行で、整数座標を持つ点を通り、紙を切断する（ただし、端に触れるだけではない）線がランダムに選ばれます。\n * この線に沿った紙の下部または右側の部分は破棄されます。答えは10^9+7での剰余として求める必要があります。\n *\n * 例えば:\n *     >>> f_42(3, 3, 4)\n *     3\n *     >>> f_42(5, 5, 12)\n *     2\n */\nlong long f_42(int n, int m, long long k)", "ko": "#include <cassert>\n#include <cstdio>\n/**\n * 크기 n x m의 직사각형 종이가 평면 데카르트 좌표계에 놓여 있고, \n * 왼쪽 아래 모서리가 (0,0)에, 오른쪽 위 모서리가 (n,m)에 있을 때, \n * 남은 면적이 k보다 작아지도록 종이를 자르는 데 필요한 예상 작업 수를 계산해야 합니다. \n * 각 작업에서, 축에 평행하고 정수 좌표를 가지는 점을 통과하며, \n * 종이를 자르는(가장자리를 단순히 터치하는 것이 아님) 선이 무작위로 선택됩니다. \n * 그런 다음 이 선을 따라 종이의 아래쪽 또는 오른쪽 부분이 버려집니다. \n * 답은 10^9+7로 나눈 나머지여야 합니다.\n *\n * 예를 들어:\n *     >>> f_42(3, 3, 4)\n *     3\n *     >>> f_42(5, 5, 12)\n *     2\n */\nlong long f_42(int n, int m, long long k)", "ml": "#include <cassert>\n#include <cstdio>\n/**\n * n x m വലിപ്പമുള്ള ഒരു ചതുരശ്രാകൃതിയിലുള്ള പേപ്പർ ഒരു പ്ലെയിൻ കാർട്ടിസിയൻ കോർഡിനേറ്റ് \n * സിസ്റ്റത്തിൽ (0,0) ൽ അതിന്റെ അടിഭാഗം-ഇടത് കോർണറും (n,m) ൽ മുകളിലെ-വലത് കോർണറും \n * ഉള്ളതായി വയ്ക്കുമ്പോൾ, ശേഷിക്കുന്ന വിസ്തീർണം k-ൽ കുറവായിരിക്കണമെങ്കിൽ പേപ്പർ \n * മുറിക്കാൻ പ്രതീക്ഷിക്കുന്ന പ്രവർത്തനങ്ങളുടെ എണ്ണം കണക്കാക്കേണ്ടതുണ്ട്. ഓരോ പ്രവർത്തനത്തിലും, \n * അച്ചുതണ്ടുകളോട് സമാന്തരമായ, പൂർണ്ണസംഖ്യാ കോർഡിനേറ്റുകളുള്ള ബിന്ദുക്കളിലൂടെ കടന്നുപോകുന്ന, \n * പേപ്പറിലൂടെ (വരമ്പ് മാത്രം സ്പർശിക്കുന്നതല്ല) മുറിക്കുന്ന ഒരു വരി യാദൃച്ഛികമായി തിരഞ്ഞെടുക്കപ്പെടുന്നു. \n * ഈ വരിയോടൊപ്പം പേപ്പറിന്റെ അടിഭാഗം അല്ലെങ്കിൽ വലത് ഭാഗം പിന്നീട് ഉപേക്ഷിക്കപ്പെടുന്നു. \n * ഉത്തരം 10^9+7-ന്റെ മോഡുലോ ആയിരിക്കണം.\n *\n * ഉദാഹരണത്തിന്:\n *     >>> f_42(3, 3, 4)\n *     3\n *     >>> f_42(5, 5, 12)\n *     2\n */\nlong long f_42(int n, int m, long long k)", "fa": "#include <cassert>\n#include <cstdio>\n/**\n * با توجه به یک کاغذ مستطیلی به اندازه n x m که در یک سیستم مختصات دکارتی صفحه قرار دارد \n * و گوشه پایین-چپ آن در (0,0) و گوشه بالا-راست آن در (n,m) قرار دارد، \n * شما باید تعداد عملیات مورد انتظار برای بریدن کاغذ را محاسبه کنید به طوری که \n * مساحت باقی‌مانده کمتر از k باشد. در هر عملیات، یک خط به صورت تصادفی انتخاب می‌شود \n * که موازی با محور‌ها است، از نقاط با مختصات صحیح عبور می‌کند، \n * و از کاغذ عبور می‌کند (نه فقط لبه را لمس کند). قسمت پایین یا راست کاغذ \n * در امتداد این خط سپس دور انداخته می‌شود. پاسخ باید به صورت مدولوی 10^9+7 باشد.\n *\n * برای مثال:\n *     >>> f_42(3, 3, 4)\n *     3\n *     >>> f_42(5, 5, 12)\n *     2\n */\nlong long f_42(int n, int m, long long k)"}, "canonical_solution": "{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n\n    if (k > (long long)n * m) {\n        return 0;\n    }\n\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}", "instruction": {"en": "Write a CPP function `long long f_42(int n, int m, long long k)` to solve the following problem:\nGiven a rectangle paper of size n x m placed on a plane Cartesian coordinate \n system with its bottom-left corner at (0,0) and top-right corner at (n,m), \n you need to calculate the expected number of operations to cut the paper such that \n the remaining area is less than k. In each operation, a line is randomly chosen \n that is parallel to the axes, passes through points with integer coordinates, \n and cuts through (not just touching the edge) the paper. The bottom or right part \n of the paper along this line is then discarded. The answer should be modulo 10^9+7.\n\nFor example:\n    >>> f_42(3, 3, 4)\n    3\n    >>> f_42(5, 5, 12)\n    2\n", "sq": "Shkruani një funksion CPP `long long f_42(int n, int m, long long k)` për të zgjidhur problemin në vijim:\nDuke pasur një letër drejtkëndore me madhësi n x m të vendosur në një sistem koordinativ Kartesian në plan me këndin e poshtëm të majtë në (0,0) dhe këndin e sipërm të djathtë në (n,m), ju duhet të llogaritni numrin e pritur të operacioneve për të prerë letrën në mënyrë që sipërfaqja e mbetur të jetë më pak se k. Në secilën operacion, zgjidhet rastësisht një vijë që është paralele me boshtet, kalon nëpër pika me koordinata të plota, dhe pret (jo vetëm prek skajin) letrën. Pjesa e poshtme ose e djathtë e letrës përgjatë kësaj vije më pas hidhet. Përgjigja duhet të jetë modulo 10^9+7.\n\nPër shembull:\n    >>> f_42(3, 3, 4)\n    3\n    >>> f_42(5, 5, 12)\n    2", "hy": "Գրեք CPP ֆունկցիա `long long f_42(int n, int m, long long k)` հետևյալ խնդիրը լուծելու համար:\nՏրված է n x m չափսի ուղղանկյուն թուղթ, որը տեղադրված է հարթության Կարտեզյան կոորդինատային \nհամակարգում՝ իր ներքևի ձախ անկյունով (0,0) կետում և վերևի աջ անկյունով (n,m) կետում, \nպետք է հաշվարկել գործողությունների սպասվող քանակը, որպեսզի թղթի մնացած մակերեսը լինի k-ից փոքր: Յուրաքանչյուր գործողության ժամանակ պատահականորեն ընտրվում է գիծ, \nորը զուգահեռ է առանցքներին, անցնում է ամբողջ թվային կոորդինատներով կետերով, \nև կտրում է թուղթը (ոչ միայն եզրին դիպչելով): Թղթի այս գծի երկայնքով ներքևի կամ աջ մասը \nապա հեռացվում է: Պատասխանը պետք է լինի 10^9+7 մոդուլով:\n\nՕրինակ:\n    >>> f_42(3, 3, 4)\n    3\n    >>> f_42(5, 5, 12)\n    2", "bn": "একটি CPP ফাংশন `long long f_42(int n, int m, long long k)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি আয়তাকার কাগজ যার আকার n x m, একটি সমতল কার্টেসিয়ান কোঅর্ডিনেট সিস্টেমে স্থাপন করা হয়েছে যার নিচের-বাম কোণ (0,0) এবং উপরের-ডান কোণ (n,m) এ অবস্থিত, \nআপনাকে এমনভাবে কাগজ কাটার প্রত্যাশিত সংখ্যক অপারেশন গণনা করতে হবে যাতে অবশিষ্ট এলাকা k এর চেয়ে কম হয়। প্রতিটি অপারেশনে, একটি লাইন এলোমেলোভাবে নির্বাচিত হয় \nযা অক্ষের সমান্তরাল, পূর্ণসংখ্যা কোঅর্ডিনেট সহ বিন্দুগুলির মধ্য দিয়ে যায়, এবং কাগজের মধ্য দিয়ে কেটে যায় (শুধুমাত্র প্রান্তকে স্পর্শ না করে)। এই লাইনের বরাবর কাগজের নিচের বা ডান দিকের অংশটি তারপর বাতিল করা হয়। উত্তরটি 10^9+7 মডুলোর সাথে হওয়া উচিত।\n\nউদাহরণস্বরূপ:\n    >>> f_42(3, 3, 4)\n    3\n    >>> f_42(5, 5, 12)\n    2", "bg": "Напишете CPP функция `long long f_42(int n, int m, long long k)`, за да решите следния проблем:\nДаден е правоъгълен лист хартия с размер n x m, разположен в равнинна декартова координатна система с долен ляв ъгъл в (0,0) и горен десен ъгъл в (n,m). Трябва да изчислите очаквания брой операции за рязане на хартията така, че оставащата площ да е по-малка от k. При всяка операция се избира случайна линия, която е успоредна на осите, минава през точки с цели координати и пресича (не само докосва ръба) хартията. Долната или дясната част на хартията по тази линия след това се изхвърля. Отговорът трябва да бъде модул 10^9+7.\n\nНапример:\n    >>> f_42(3, 3, 4)\n    3\n    >>> f_42(5, 5, 12)\n    2", "zh": "编写一个 CPP 函数 `long long f_42(int n, int m, long long k)` 来解决以下问题：  \n给定一个大小为 n x m 的矩形纸张，放置在平面直角坐标系中，其左下角在 (0,0) 处，右上角在 (n,m) 处，  \n你需要计算切割纸张的期望操作次数，使得剩余面积小于 k。每次操作中，随机选择一条与坐标轴平行的线，  \n该线通过整数坐标的点，并切割（不仅仅是接触边缘）纸张。然后沿着这条线丢弃纸张的底部或右侧部分。  \n答案应对 10^9+7 取模。\n\n例如：\n    >>> f_42(3, 3, 4)\n    3\n    >>> f_42(5, 5, 12)\n    2", "fr": "Écrire une fonction CPP `long long f_42(int n, int m, long long k)` pour résoudre le problème suivant :  \nÉtant donné un papier rectangulaire de taille n x m placé sur un système de coordonnées cartésiennes \navec son coin inférieur gauche à (0,0) et son coin supérieur droit à (n,m), \nvous devez calculer le nombre attendu d'opérations pour couper le papier de sorte que \nla surface restante soit inférieure à k. À chaque opération, une ligne est choisie au hasard \nqui est parallèle aux axes, passe par des points avec des coordonnées entières, \net coupe (ne se contentant pas de toucher le bord) le papier. La partie inférieure ou droite \ndu papier le long de cette ligne est alors jetée. La réponse doit être modulo 10^9+7.\n\nPar exemple :\n    >>> f_42(3, 3, 4)\n    3\n    >>> f_42(5, 5, 12)\n    2", "de": "Schreiben Sie eine CPP-Funktion `long long f_42(int n, int m, long long k)`, um das folgende Problem zu lösen:\nGegeben ist ein rechteckiges Papier der Größe n x m, das in einem kartesischen Koordinatensystem auf einer Ebene platziert ist, mit seiner unteren linken Ecke bei (0,0) und der oberen rechten Ecke bei (n,m). Sie müssen die erwartete Anzahl von Operationen berechnen, um das Papier so zu schneiden, dass die verbleibende Fläche kleiner als k ist. Bei jeder Operation wird eine Linie zufällig gewählt, die parallel zu den Achsen verläuft, durch Punkte mit ganzzahligen Koordinaten geht und das Papier durchschneidet (nicht nur den Rand berührt). Der untere oder rechte Teil des Papiers entlang dieser Linie wird dann verworfen. Die Antwort sollte modulo 10^9+7 sein.\n\nZum Beispiel:\n    >>> f_42(3, 3, 4)\n    3\n    >>> f_42(5, 5, 12)\n    2", "ha": "Rubuta aikin CPP `long long f_42(int n, int m, long long k)` don warware matsalar mai zuwa:\nAn ba da takarda murabba'i mai girman n x m da aka sanya a kan tsarin daidaitawar Cartesian \ntare da kusurwar ƙasa-hagu a (0,0) da kusurwar sama-dama a (n,m), \ndole ne ka ƙididdige yawan ayyukan da ake tsammanin za a yanke takardar ta yadda \nyankin da ya rage ya zama ƙasa da k. A kowane aiki, ana zaɓar layi da bazuwar \nwanda yake daidai da ginshiƙai, yana wucewa ta wuraren da ke da daidaitattun lambobi, \nkuma yana yanke (ba kawai taɓa gefen ba) takardar. Ana watsar da ɓangaren ƙasa ko dama \nna takardar tare da wannan layin. Amsar ya kamata ta zama modulo 10^9+7.\n\nMisali:\n    >>> f_42(3, 3, 4)\n    3\n    >>> f_42(5, 5, 12)\n    2", "hi": "`long long f_42(int n, int m, long long k)` नामक एक CPP फ़ंक्शन लिखें ताकि निम्नलिखित समस्या का समाधान हो सके:\nदिए गए आयताकार कागज का आकार n x m है जो एक समतल कार्टेशियन निर्देशांक प्रणाली पर रखा गया है, \nजिसका निचला-बायां कोना (0,0) पर है और ऊपरी-दायां कोना (n,m) पर है। \nआपको कागज को इस प्रकार काटने के लिए आवश्यक ऑपरेशनों की अपेक्षित संख्या की गणना करनी है कि \nशेष क्षेत्रफल k से कम हो। प्रत्येक ऑपरेशन में, एक रेखा यादृच्छिक रूप से चुनी जाती है \nजो अक्षों के समानांतर होती है, पूर्णांक निर्देशांक वाले बिंदुओं से गुजरती है, \nऔर कागज को काटती है (सिर्फ किनारे को छूने के बजाय)। इस रेखा के साथ कागज का निचला या दायां हिस्सा \nफिर त्याग दिया जाता है। उत्तर 10^9+7 के मापांक में होना चाहिए।\n\nउदाहरण के लिए:\n    >>> f_42(3, 3, 4)\n    3\n    >>> f_42(5, 5, 12)\n    2", "hu": "Írjon egy CPP függvényt `long long f_42(int n, int m, long long k)` a következő probléma megoldására:\nAdott egy n x m méretű téglalap alakú papír, amely a sík Descartes-koordináta \nrendszerben van elhelyezve, alsó-bal sarkával a (0,0) pontban és a jobb-felső sarkával az (n,m) pontban. \nKi kell számítani a várható műveletek számát, hogy a papírt úgy vágjuk, hogy a \nmegmaradó terület kisebb legyen, mint k. Minden művelet során egy véletlenszerűen választott vonal \npárhuzamos a tengelyekkel, egész koordinátájú pontokon halad át, és átvágja (nem csak érinti a szélét) a papírt. \nA papírnak a vonal mentén lévő alsó vagy jobb oldali része ezután eldobásra kerül. A válasznak modulo 10^9+7 formában kell lennie.\n\nPéldául:\n    >>> f_42(3, 3, 4)\n    3\n    >>> f_42(5, 5, 12)\n    2", "es": "Escribe una función CPP `long long f_42(int n, int m, long long k)` para resolver el siguiente problema:\nDado un papel rectangular de tamaño n x m colocado en un sistema de coordenadas Cartesianas en un plano con su esquina inferior izquierda en (0,0) y la esquina superior derecha en (n,m), necesitas calcular el número esperado de operaciones para cortar el papel de tal manera que el área restante sea menor que k. En cada operación, se elige aleatoriamente una línea que es paralela a los ejes, pasa por puntos con coordenadas enteras, y corta (no solo toca el borde) el papel. La parte inferior o derecha del papel a lo largo de esta línea es entonces descartada. La respuesta debe ser módulo 10^9+7.\n\nPor ejemplo:\n    >>> f_42(3, 3, 4)\n    3\n    >>> f_42(5, 5, 12)\n    2", "arb": "اكتب دالة CPP `long long f_42(int n, int m, long long k)` لحل المشكلة التالية:\nمعطى ورقة مستطيلة بحجم n x m موضوعة على نظام إحداثيات ديكارتي مستوي مع الزاوية السفلية اليسرى عند (0,0) والزاوية العلوية اليمنى عند (n,m)، تحتاج إلى حساب العدد المتوقع من العمليات لقطع الورقة بحيث تكون المساحة المتبقية أقل من k. في كل عملية، يتم اختيار خط عشوائي موازٍ للمحاور، يمر عبر نقاط ذات إحداثيات صحيحة، ويقطع (وليس فقط يلامس الحافة) الورقة. الجزء السفلي أو الأيمن من الورقة على طول هذا الخط يتم التخلص منه. يجب أن تكون الإجابة مودولو 10^9+7.\n\nعلى سبيل المثال:\n    >>> f_42(3, 3, 4)\n    3\n    >>> f_42(5, 5, 12)\n    2", "sw": "Andika kazi ya CPP `long long f_42(int n, int m, long long k)` kutatua tatizo lifuatalo:\nUkipatiwa karatasi ya mstatili yenye ukubwa wa n x m iliyowekwa kwenye mfumo wa kuratibu wa Cartesian \nna kona yake ya chini-kushoto iko kwenye (0,0) na kona ya juu-kulia iko kwenye (n,m), \nunahitaji kuhesabu idadi inayotarajiwa ya operesheni za kukata karatasi hiyo ili \neneo lililobaki liwe chini ya k. Katika kila operesheni, mstari unachaguliwa kwa nasibu \nambao ni sambamba na mhimili, unapita kupitia pointi zenye kuratibu za namba kamili, \nna unakata (si kugusa tu kingo) karatasi hiyo. Sehemu ya chini au ya kulia ya karatasi kando ya mstari huu \nkisha inatupwa. Jibu linapaswa kuwa modulo 10^9+7.\n\nKwa mfano:\n    >>> f_42(3, 3, 4)\n    3\n    >>> f_42(5, 5, 12)\n    2", "tr": "`long long f_42(int n, int m, long long k)` fonksiyonunu aşağıdaki problemi çözmek için yazın:\nn x m boyutlarında bir dikdörtgen kağıt, alt-sol köşesi (0,0) ve üst-sağ köşesi (n,m) olan bir Kartezyen koordinat sistemine yerleştirilmiştir. \nKağıdı kesmek için gereken beklenen işlem sayısını hesaplamanız gerekiyor, böylece kalan alan k'dan küçük olur. Her işlemde, eksenlere paralel, \ntam sayı koordinatlarına sahip noktalardan geçen ve kağıdı kesen (sadece kenara dokunmayan) bir çizgi rastgele seçilir. \nBu çizgi boyunca kağıdın alt veya sağ kısmı daha sonra atılır. Cevap 10^9+7 modunda olmalıdır.\n\nÖrneğin:\n    >>> f_42(3, 3, 4)\n    3\n    >>> f_42(5, 5, 12)\n    2", "vi": "Viết một hàm CPP `long long f_42(int n, int m, long long k)` để giải quyết vấn đề sau:\nCho một tờ giấy hình chữ nhật kích thước n x m đặt trên hệ tọa độ phẳng Cartesian với góc dưới bên trái tại (0,0) và góc trên bên phải tại (n,m), bạn cần tính số lượng thao tác mong đợi để cắt giấy sao cho diện tích còn lại nhỏ hơn k. Trong mỗi thao tác, một đường thẳng được chọn ngẫu nhiên song song với các trục, đi qua các điểm có tọa độ nguyên, và cắt qua (không chỉ chạm vào cạnh) tờ giấy. Phần dưới hoặc bên phải của tờ giấy dọc theo đường này sau đó bị loại bỏ. Câu trả lời nên được tính theo modulo 10^9+7.\n\nVí dụ:\n    >>> f_42(3, 3, 4)\n    3\n    >>> f_42(5, 5, 12)\n    2", "id": "Tulis fungsi CPP `long long f_42(int n, int m, long long k)` untuk menyelesaikan masalah berikut:\nDiberikan sebuah kertas persegi panjang berukuran n x m yang ditempatkan pada sistem koordinat Kartesius \ndengan sudut kiri bawah di (0,0) dan sudut kanan atas di (n,m), \nAnda perlu menghitung jumlah operasi yang diharapkan untuk memotong kertas sehingga \nluas yang tersisa kurang dari k. Dalam setiap operasi, sebuah garis dipilih secara acak \nyang sejajar dengan sumbu, melewati titik-titik dengan koordinat integer, \ndan memotong (bukan hanya menyentuh tepi) kertas. Bagian bawah atau kanan \ndari kertas di sepanjang garis ini kemudian dibuang. Jawabannya harus dalam modulo 10^9+7.\n\nSebagai contoh:\n    >>> f_42(3, 3, 4)\n    3\n    >>> f_42(5, 5, 12)\n    2", "ja": "以下の問題を解くために、CPP関数 `long long f_42(int n, int m, long long k)` を作成してください:\nn x m のサイズの長方形の紙が、平面のデカルト座標系上に配置されており、その左下の角が (0,0)、右上の角が (n,m) にあります。紙を切る操作の期待値を計算する必要があります。残りの面積が k 未満になるようにします。各操作では、軸に平行で、整数座標を通り、紙を切断する（エッジに触れるだけではない）線がランダムに選ばれます。この線に沿った紙の下部または右側が破棄されます。答えは 10^9+7 での剰余として表されるべきです。\n\n例えば:\n    >>> f_42(3, 3, 4)\n    3\n    >>> f_42(5, 5, 12)\n    2", "ko": "CPP 함수 `long long f_42(int n, int m, long long k)`를 작성하여 다음 문제를 해결하십시오:\n크기 n x m의 직사각형 종이가 평면 직교 좌표계에 놓여 있으며, \n그의 왼쪽 아래 모서리가 (0,0)에 있고 오른쪽 위 모서리가 (n,m)에 있습니다. \n남은 면적이 k보다 작아지도록 종이를 자르는 작업의 기대 횟수를 계산해야 합니다. \n각 작업에서는 축에 평행하고 정수 좌표를 지나는 선이 무작위로 선택되어 \n종이를 자릅니다(가장자리를 단순히 만지는 것이 아님). \n이 선을 따라 종이의 아래쪽 또는 오른쪽 부분이 버려집니다. \n답은 10^9+7로 나눈 나머지여야 합니다.\n\n예를 들어:\n    >>> f_42(3, 3, 4)\n    3\n    >>> f_42(5, 5, 12)\n    2", "ml": "`long long f_42(int n, int m, long long k)` എന്ന CPP ഫംഗ്ഷൻ എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nn x m വലിപ്പമുള്ള ഒരു ചതുരാകൃതിയിലുള്ള പേപ്പർ ഒരു പ്ലെയിൻ കാർട്ടീഷ്യൻ കോർഡിനേറ്റ് സിസ്റ്റത്തിൽ അതിന്റെ താഴത്തെ ഇടത് കോർണർ (0,0) ലും മുകളിൽ വലത് കോർണർ (n,m) ലും സ്ഥിതിചെയ്യുന്ന, \nശേഷിക്കുന്ന വിസ്തീർണം k-ൽ കുറവായിരിക്കാനായി പേപ്പർ മുറിക്കാൻ പ്രതീക്ഷിക്കുന്ന പ്രവർത്തനങ്ങളുടെ എണ്ണം കണക്കാക്കേണ്ടതുണ്ട്. ഓരോ പ്രവർത്തനത്തിലും, ആക്സസുകൾക്ക് സമാന്തരമായ, \nപൂർണ്ണസംഖ്യാ കോർഡിനേറ്റുകളുള്ള പോയിന്റുകൾ വഴി കടന്നുപോകുന്ന ഒരു വരി യാദൃശ്ചികമായി തിരഞ്ഞെടുക്കപ്പെടുന്നു, \nപേപ്പറിലൂടെ മുറിക്കുന്നു (വരമ്പിൽ മാത്രം സ്പർശിക്കുന്നതല്ല). ഈ വരിയോടൊപ്പം പേപ്പറിന്റെ താഴത്തെ അല്ലെങ്കിൽ വലത് ഭാഗം പിന്നീട് തള്ളിക്കളയുന്നു. \nഉത്തരം 10^9+7 മോഡുലോ ആയിരിക്കണം.\n\nഉദാഹരണത്തിന്:\n    >>> f_42(3, 3, 4)\n    3\n    >>> f_42(5, 5, 12)\n    2", "fa": "یک تابع CPP `long long f_42(int n, int m, long long k)` بنویسید تا مسئله زیر را حل کند:\nبا توجه به یک کاغذ مستطیلی به ابعاد n x m که در یک سیستم مختصات دکارتی صفحه قرار دارد \nو گوشه پایین-چپ آن در (0,0) و گوشه بالا-راست آن در (n,m) است، \nشما باید تعداد عملیات مورد انتظار برای بریدن کاغذ را محاسبه کنید به طوری که \nمساحت باقی‌مانده کمتر از k باشد. در هر عملیات، یک خط به صورت تصادفی انتخاب می‌شود \nکه موازی با محورها است، از نقاط با مختصات صحیح عبور می‌کند، \nو از کاغذ عبور می‌کند (نه فقط لبه را لمس کند). سپس قسمت پایین یا راست کاغذ در امتداد این خط دور انداخته می‌شود. پاسخ باید به پیمانه 10^9+7 باشد.\n\nبرای مثال:\n    >>> f_42(3, 3, 4)\n    3\n    >>> f_42(5, 5, 12)\n    2"}, "level": "hard", "test": "int main() {\n    assert(f_42(2, 4, 10) == 0);\n    assert(f_42(2, 4, 8) == 1);\n    assert(f_42(2, 4, 2) == 833333342);\n    assert(f_42(2, 4, 6) == 250000003);\n    assert(f_42(3, 3, 4) == 666666673);\n    assert(f_42(5, 5, 12) == 666666673);\n    assert(f_42(6, 7, 20) == 722222229);\n    assert(f_42(8, 8, 30) == 72727275);\n    assert(f_42(10, 10, 50) == 714285721);\n    assert(f_42(1, 10, 5) == 945634929);\n    assert(f_42(10, 1, 5) == 945634929);\n    return 0;\n}", "entry_point": "f_42", "signature": "long long f_42(int n, int m, long long k)", "docstring": {"en": "Given a rectangle paper of size n x m placed on a plane Cartesian coordinate \n system with its bottom-left corner at (0,0) and top-right corner at (n,m), \n you need to calculate the expected number of operations to cut the paper such that \n the remaining area is less than k. In each operation, a line is randomly chosen \n that is parallel to the axes, passes through points with integer coordinates, \n and cuts through (not just touching the edge) the paper. The bottom or right part \n of the paper along this line is then discarded. The answer should be modulo 10^9+7.\n\nFor example:\n    >>> f_42(3, 3, 4)\n    3\n    >>> f_42(5, 5, 12)\n    2\n", "sq": "Duke pasur një letër drejtkëndëshe me madhësi n x m të vendosur në një sistem koordinativ Kartesian në plan me këndin e poshtëm të majtë në (0,0) dhe këndin e sipërm të djathtë në (n,m), ju duhet të llogaritni numrin e pritur të operacioneve për të prerë letrën në mënyrë që sipërfaqja e mbetur të jetë më pak se k. Në çdo operacion, zgjidhet rastësisht një vijë që është paralele me boshtet, kalon përmes pikave me koordinata të plota, dhe e pret (jo vetëm prek skajin) letrën. Pjesa e poshtme ose e djathtë e letrës përgjatë kësaj vije pastaj hidhet poshtë. Përgjigjja duhet të jetë modulo 10^9+7.\n\nPër shembull:\n    >>> f_42(3, 3, 4)\n    3\n    >>> f_42(5, 5, 12)\n    2", "hy": "Ունենալով n x m չափսի ուղղանկյուն թուղթ, որը տեղադրված է հարթության Կարտեզյան կոորդինատային համակարգում՝ իր ներքևի ձախ անկյունը (0,0) կետում և վերին աջ անկյունը (n,m) կետում, անհրաժեշտ է հաշվարկել սպասվող գործողությունների քանակը թուղթը կտրելու համար այնպես, որ մնացած մակերեսը լինի k-ից փոքր: Յուրաքանչյուր գործողության ժամանակ պատահականորեն ընտրվում է գիծ, որը զուգահեռ է առանցքներին, անցնում է ամբողջ թվային կոորդինատներով կետերով և կտրում է թուղթը (ոչ միայն հպվում է եզրին): Թղթի այս գծի երկայնքով ստորին կամ աջ մասը ապա հեռացվում է: Պատասխանը պետք է լինի 10^9+7 մոդուլով:\n\nՕրինակ:\n    >>> f_42(3, 3, 4)\n    3\n    >>> f_42(5, 5, 12)\n    2", "bn": "একটি আয়তাকার কাগজের টুকরো যার আকার n x m, একটি সমতল কার্টেসিয়ান কোঅর্ডিনেট সিস্টেমে রাখা আছে, যার নিচের-বাম কোণ (0,0) এবং উপরের-ডান কোণ (n,m) এ অবস্থিত, তোমাকে সেই কাগজটি কাটার প্রত্যাশিত সংখ্যক অপারেশন গণনা করতে হবে যাতে অবশিষ্ট এলাকা k এর চেয়ে কম হয়। প্রতিটি অপারেশনে, একটি লাইন এলোমেলোভাবে বেছে নেওয়া হয় যা অক্ষের সমান্তরাল, পূর্ণসংখ্যার কোঅর্ডিনেট সহ বিন্দুগুলির মধ্য দিয়ে যায় এবং কাগজের মধ্য দিয়ে কাটে (শুধুমাত্র প্রান্ত স্পর্শ করে না)। এই লাইনের সাথে বরাবর কাগজের নিচের বা ডান অংশটি তারপর বাতিল করা হয়। উত্তরটি 10^9+7 এর মডুলোতে হওয়া উচিত।\n\nউদাহরণস্বরূপ:\n    >>> f_42(3, 3, 4)\n    3\n    >>> f_42(5, 5, 12)\n    2", "bg": "Даден е правоъгълен лист хартия с размер n x m, поставен в равнинна декартова координатна система с долен ляв ъгъл в (0,0) и горен десен ъгъл в (n,m). Трябва да изчислите очаквания брой операции за рязане на хартията така, че оставащата площ да е по-малка от k. При всяка операция се избира произволна линия, която е успоредна на осите, минава през точки с цели координати и пресича (не само докосва ръба) хартията. Долната или дясната част на хартията по тази линия след това се изхвърля. Отговорът трябва да бъде модул 10^9+7.\n\nНапример:\n    >>> f_42(3, 3, 4)\n    3\n    >>> f_42(5, 5, 12)\n    2", "zh": "给定一个大小为 n x m 的矩形纸张，放置在平面直角坐标系中，其左下角在 (0,0)，右上角在 (n,m)，你需要计算切割纸张的期望操作次数，使得剩余面积小于 k。在每次操作中，随机选择一条与坐标轴平行的线，该线通过整数坐标的点，并切割（不仅仅是触碰边缘）纸张。沿着这条线的纸张的底部或右侧部分将被丢弃。答案应对 10^9+7 取模。\n\n例如：\n    >>> f_42(3, 3, 4)\n    3\n    >>> f_42(5, 5, 12)\n    2", "fr": "Étant donné un papier rectangulaire de taille n x m placé sur un système de coordonnées cartésiennes avec son coin inférieur gauche à (0,0) et son coin supérieur droit à (n,m), vous devez calculer le nombre attendu d'opérations pour couper le papier de sorte que la surface restante soit inférieure à k. À chaque opération, une ligne est choisie au hasard qui est parallèle aux axes, passe par des points avec des coordonnées entières, et coupe (ne fait pas que toucher le bord) le papier. La partie inférieure ou droite du papier le long de cette ligne est alors jetée. La réponse doit être modulo 10^9+7.\n\nPar exemple :\n    >>> f_42(3, 3, 4)\n    3\n    >>> f_42(5, 5, 12)\n    2", "de": "Angenommen, ein rechteckiges Papier der Größe n x m liegt auf einem kartesischen Koordinatensystem, wobei sich die untere linke Ecke bei (0,0) und die obere rechte Ecke bei (n,m) befindet. Sie müssen die erwartete Anzahl von Operationen berechnen, um das Papier so zu schneiden, dass die verbleibende Fläche kleiner als k ist. Bei jeder Operation wird zufällig eine Linie gewählt, die parallel zu den Achsen verläuft, durch Punkte mit ganzzahligen Koordinaten geht und das Papier durchschneidet (nicht nur den Rand berührt). Der untere oder rechte Teil des Papiers entlang dieser Linie wird dann verworfen. Die Antwort sollte modulo 10^9+7 sein.\n\nZum Beispiel:\n    >>> f_42(3, 3, 4)\n    3\n    >>> f_42(5, 5, 12)\n    2", "ha": "An ba da takarda mai kusurwa huɗu mai girman n x m da aka sanya a kan tsarin daidaitawa na Cartesian tare da kusurwar ƙasa-hagu a (0,0) da kusurwar sama-dama a (n,m), kana buƙatar ƙididdige yawan ayyukan da ake tsammani don yanke takardar ta yadda yankin da ya rage ya zama ƙasa da k. A kowane aiki, ana zaɓar layi a bazuwar wanda yake daidai da ginshiƙai, ya wuce ta wuraren da ke da daidaitawa na lamba, kuma ya yanke ta cikin (ba kawai taɓa gefen ba) takardar. Sashin ƙasa ko dama na takardar tare da wannan layin sai a yar da shi. Amsar ya kamata ta kasance modulo 10^9+7.\n\nMisali:\n    >>> f_42(3, 3, 4)\n    3\n    >>> f_42(5, 5, 12)\n    2", "hi": "दिए गए n x m आकार के आयताकार कागज को एक समतल कार्टेशियन निर्देशांक प्रणाली पर रखा गया है, जिसमें इसका निचला-बायाँ कोना (0,0) पर और ऊपरी-दायाँ कोना (n,m) पर है। आपको कागज को इस प्रकार काटने के लिए अपेक्षित ऑपरेशनों की संख्या की गणना करने की आवश्यकता है कि शेष क्षेत्रफल k से कम हो। प्रत्येक ऑपरेशन में, एक रेखा यादृच्छिक रूप से चुनी जाती है जो अक्षों के समानांतर होती है, पूर्णांक निर्देशांक वाले बिंदुओं से होकर गुजरती है, और कागज को काटती है (सिर्फ किनारे को छूती नहीं है)। इस रेखा के साथ कागज का निचला या दायाँ भाग फिर त्याग दिया जाता है। उत्तर 10^9+7 के मापांक में होना चाहिए।\n\nउदाहरण के लिए:\n    >>> f_42(3, 3, 4)\n    3\n    >>> f_42(5, 5, 12)\n    2", "hu": "Egy n x m méretű téglalap alakú papírt helyezünk el egy derékszögű koordináta-rendszerben úgy, hogy az alsó-bal sarok a (0,0) pontban van, a felső-jobb sarok pedig az (n,m) pontban. Számítsd ki a várható műveletek számát, hogy a papírt úgy vágjuk el, hogy a megmaradt terület kisebb legyen, mint k. Minden művelet során egy véletlenszerűen kiválasztott vonal párhuzamos a tengelyekkel, egész koordinátájú pontokon halad át, és átvágja (nem csak érinti a szélét) a papírt. A papír ezen vonal mentén lévő alsó vagy jobb része ezután eldobásra kerül. Az eredményt a 10^9+7 modullal kell megadni.\n\nPéldául:\n    >>> f_42(3, 3, 4)\n    3\n    >>> f_42(5, 5, 12)\n    2", "es": "Dado un papel rectangular de tamaño n x m colocado en un sistema de coordenadas \ncartesianas en un plano con su esquina inferior izquierda en (0,0) y la esquina superior derecha en (n,m), \nnecesitas calcular el número esperado de operaciones para cortar el papel de tal manera que \nel área restante sea menor que k. En cada operación, se elige aleatoriamente una línea \nque es paralela a los ejes, pasa por puntos con coordenadas enteras, \ny corta (no solo toca el borde) el papel. La parte inferior o derecha \ndel papel a lo largo de esta línea se descarta. La respuesta debe ser módulo 10^9+7.\n\nPor ejemplo:\n    >>> f_42(3, 3, 4)\n    3\n    >>> f_42(5, 5, 12)\n    2", "arb": "معطى ورقة مستطيلة بحجم n x m موضوعة على نظام إحداثيات ديكارتي مستوٍ مع وجود الزاوية السفلية اليسرى عند (0,0) والزاوية العلوية اليمنى عند (n,m)، تحتاج إلى حساب العدد المتوقع من العمليات لقطع الورقة بحيث تكون المساحة المتبقية أقل من k. في كل عملية، يتم اختيار خط عشوائي موازٍ للمحاور، يمر عبر نقاط ذات إحداثيات صحيحة، ويقطع (وليس فقط يلامس الحافة) الورقة. يتم بعد ذلك التخلص من الجزء السفلي أو الأيمن من الورقة على طول هذا الخط. يجب أن تكون الإجابة بتقسيم 10^9+7.\n\nعلى سبيل المثال:\n    >>> f_42(3, 3, 4)\n    3\n    >>> f_42(5, 5, 12)\n    2", "sw": "Kwa kuzingatia karatasi ya mstatili yenye ukubwa wa n x m iliyowekwa kwenye mfumo wa kuratibu wa Cartesian kwenye ndege na kona yake ya chini-kushoto iko kwenye (0,0) na kona ya juu-kulia iko kwenye (n,m), unahitaji kuhesabu idadi inayotarajiwa ya operesheni za kukata karatasi ili eneo lililobaki liwe chini ya k. Katika kila operesheni, mstari unachaguliwa kwa nasibu ambao ni sambamba na mhimili, unapita kwenye pointi zenye kuratibu za namba kamili, na unakata (si kugusa tu ukingo) karatasi. Sehemu ya chini au ya kulia ya karatasi kando ya mstari huu kisha hutupwa. Jibu linapaswa kuwa moduli 10^9+7.\n\nKwa mfano:\n    >>> f_42(3, 3, 4)\n    3\n    >>> f_42(5, 5, 12)\n    2", "tr": "Verilen bir dikdörtgen kağıt, (0,0) noktasında sol alt köşesi ve (n,m) noktasında sağ üst köşesi olan bir düzlem Kartezyen koordinat sistemine yerleştirilmiştir. Kağıdın kalan alanı k'dan küçük olacak şekilde kesilmesi için beklenen işlem sayısını hesaplamanız gerekmektedir. Her işlemde, eksenlere paralel, tam sayı koordinatlarına sahip noktalardan geçen ve kağıdı kesen (sadece kenara dokunmayan) rastgele bir çizgi seçilir. Bu çizgi boyunca kağıdın alt veya sağ kısmı atılır. Cevap 10^9+7 ile mod alınmış olarak verilmelidir.\n\nÖrneğin:\n    >>> f_42(3, 3, 4)\n    3\n    >>> f_42(5, 5, 12)\n    2", "vi": "Cho một tờ giấy hình chữ nhật kích thước n x m đặt trên hệ tọa độ phẳng Descartes với góc dưới bên trái tại (0,0) và góc trên bên phải tại (n,m), bạn cần tính số lần cắt dự kiến để cắt tờ giấy sao cho diện tích còn lại nhỏ hơn k. Trong mỗi lần cắt, một đường thẳng được chọn ngẫu nhiên, song song với các trục tọa độ, đi qua các điểm có tọa độ nguyên, và cắt qua (không chỉ chạm vào cạnh) tờ giấy. Phần dưới hoặc bên phải của tờ giấy dọc theo đường này sau đó bị loại bỏ. Kết quả cần được lấy modulo 10^9+7.\n\nVí dụ:\n    >>> f_42(3, 3, 4)\n    3\n    >>> f_42(5, 5, 12)\n    2", "id": "Diberikan selembar kertas persegi panjang berukuran n x m yang ditempatkan pada sistem koordinat Kartesius dengan sudut kiri bawah di (0,0) dan sudut kanan atas di (n,m), Anda perlu menghitung jumlah operasi yang diharapkan untuk memotong kertas sehingga area yang tersisa kurang dari k. Dalam setiap operasi, sebuah garis dipilih secara acak yang sejajar dengan sumbu, melewati titik-titik dengan koordinat integer, dan memotong (bukan hanya menyentuh tepi) kertas. Bagian bawah atau kanan dari kertas sepanjang garis ini kemudian dibuang. Jawabannya harus dalam modulo 10^9+7.\n\nSebagai contoh:\n    >>> f_42(3, 3, 4)\n    3\n    >>> f_42(5, 5, 12)\n    2", "ja": "長方形の紙が n x m のサイズで、デカルト座標系上に配置されており、その左下の角が (0,0)、右上の角が (n,m) にあります。この紙を切る操作を行い、残りの面積が k 未満になるために必要な操作の期待値を計算する必要があります。各操作では、軸に平行で、整数座標を持つ点を通り、紙を切断する（単に端に触れるだけではない）線がランダムに選ばれます。この線に沿った紙の下部または右側の部分が破棄されます。答えは 10^9+7 で割った余りとして求める必要があります。\n\n例:\n    >>> f_42(3, 3, 4)\n    3\n    >>> f_42(5, 5, 12)\n    2", "ko": "주어진 n x m 크기의 직사각형 종이가 평면 데카르트 좌표계에 놓여 있으며, \n그의 왼쪽 아래 모서리는 (0,0)에, 오른쪽 위 모서리는 (n,m)에 위치합니다. \n남은 면적이 k보다 작아지도록 종이를 자르는 데 필요한 예상 작업 횟수를 계산해야 합니다. \n각 작업에서 축에 평행하고 정수 좌표를 지나는 선이 무작위로 선택되어 \n종이를 자릅니다(단순히 가장자리를 건드리는 것이 아님). \n이 선을 따라 종이의 아래쪽 또는 오른쪽 부분이 버려집니다. \n답은 10^9+7로 나눈 나머지여야 합니다.\n\n예를 들어:\n    >>> f_42(3, 3, 4)\n    3\n    >>> f_42(5, 5, 12)\n    2", "ml": "നിർദ്ദേശിച്ചിരിക്കുന്ന n x m വലുപ്പമുള്ള ഒരു ചതുരാകൃതിയിലുള്ള പേപ്പർ, (0,0) എന്നിടത്താണ് അതിന്റെ താഴത്തെ ഇടത് കോണും (n,m) എന്നിടത്താണ് മുകളിൽ വലത് കോണും സ്ഥിതിചെയ്യുന്നത്, കാർട്ടീസിയൻ കോഓർഡിനേറ്റ് സമാന്തരത്തിൽ വെച്ചിരിക്കുന്നു. ശേഷിക്കുന്ന വിസ്തീർണം k-ലും കുറവായിരിക്കാനായി പേപ്പർ മുറിക്കാൻ പ്രതീക്ഷിക്കപ്പെടുന്ന പ്രവർത്തനങ്ങളുടെ എണ്ണം കണക്കാക്കേണ്ടതുണ്ട്. ഓരോ പ്രവർത്തനത്തിലും, അച്ചുതണ്ടുകളോട് സമാന്തരമായ, പൂർണ്ണസംഖ്യാ കോഓർഡിനേറ്റുകളുള്ള ബിന്ദുക്കളിലൂടെ കടന്നുപോകുന്ന ഒരു വരി യാദൃശ്ചികമായി തിരഞ്ഞെടുക്കപ്പെടുന്നു, ഇത് പേപ്പറിലൂടെ മുറിക്കുന്നു (വരമ്പിൽ മാത്രം സ്പർശിക്കുന്നതല്ല). ഈ വരിയോടൊപ്പം പേപ്പറിന്റെ താഴത്തെ അല്ലെങ്കിൽ വലത് ഭാഗം പിന്നീട് ഉപേക്ഷിക്കുന്നു. ഉത്തരം 10^9+7 ന്റെ മോഡുലോ ആയിരിക്കണം.\n\nഉദാഹരണത്തിന്:\n    >>> f_42(3, 3, 4)\n    3\n    >>> f_42(5, 5, 12)\n    2", "fa": "با توجه به یک کاغذ مستطیلی به ابعاد n x m که در یک سیستم مختصات دکارتی قرار دارد و گوشه پایین-چپ آن در نقطه (0,0) و گوشه بالا-راست آن در نقطه (n,m) است، شما باید تعداد عملیات‌های مورد انتظار برای بریدن کاغذ را محاسبه کنید به طوری که مساحت باقی‌مانده کمتر از k باشد. در هر عملیات، یک خط به صورت تصادفی انتخاب می‌شود که موازی با محورهای مختصات است، از نقاطی با مختصات صحیح عبور می‌کند و از کاغذ می‌گذرد (نه فقط لبه را لمس کند). سپس بخش پایین یا راست کاغذ در امتداد این خط حذف می‌شود. پاسخ باید به پیمانه 10^9+7 باشد.\n\nبرای مثال:\n    >>> f_42(3, 3, 4)\n    3\n    >>> f_42(5, 5, 12)\n    2"}}
{"task_id": "CPP/43", "prompt": {"en": "#include <bits/stdc++.h>\n/*\nGiven a permutation q of n elements and an integer k, find the number of permutations p of n elements such that f(p) = q, where f(p) is the lexicographically smallest permutation that can be obtained by dividing p into exactly k non-empty contiguous segments and sorting each segment (i.e., choose k-1 breakpoints 1 <= x_1 < x_2 < ... < x_{k-1} < n, and divide it into [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). The result should be modulo 998244353.\n\n    >>> f_43(2, 1, [1, 2])\n    2\n\n*/\nint f_43(int n, int k, int qq[])", "sq": "#include <bits/stdc++.h>\n/*\nDuke pasur një permutacion q të n elementeve dhe një numër të plotë k, gjeni numrin e permutacioneve p të n elementeve të tilla që f(p) = q, ku f(p) është permutacioni më i vogël leksikografik që mund të merret duke ndarë p në saktësisht k segmente të pandryshueshme dhe duke renditur secilin segment (d.m.th., zgjidhni k-1 pika ndarjeje 1 <= x_1 < x_2 < ... < x_{k-1} < n, dhe ndajeni atë në [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). Rezultati duhet të jetë modulo 998244353.\n\n    >>> f_43(2, 1, [1, 2])\n    2\n\n*/\nint f_43(int n, int k, int qq[])", "hy": "#include <bits/stdc++.h>\n/*\nՈւնենալով n տարրերի q փոխատեղում և k ամբողջ թիվ, գտնել n տարրերի p փոխատեղումների քանակը, այնպես որ f(p) = q, որտեղ f(p)-ն ամենափոքր լեքսիկոգրաֆիկ փոխատեղումն է, որը կարելի է ստանալ p-ն բաժանելով ճիշտ k չդատարկ հարակից հատվածների և յուրաքանչյուր հատվածը դասավորելով (այսինքն՝ ընտրել k-1 կոտրման կետեր 1 <= x_1 < x_2 < ... < x_{k-1} < n, և բաժանել այն [1, x_1], (x_1, x_2], ..., (x_{k-1}, n] հատվածների): Արդյունքը պետք է լինի 998244353 մոդուլով:\n\n    >>> f_43(2, 1, [1, 2])\n    2\n\n*/\nint f_43(int n, int k, int qq[])", "bn": "#include <bits/stdc++.h>\n/*\nn উপাদানের একটি permutation q এবং একটি পূর্ণসংখ্যা k দেওয়া আছে, এমন n উপাদানের কতগুলি permutation p আছে তা খুঁজে বের করুন যাতে f(p) = q হয়, যেখানে f(p) হল lexicographically সবচেয়ে ছোট permutation যা ঠিক k টি খালি নয় এমন সংলগ্ন segment এ p কে ভাগ করে এবং প্রতিটি segment কে sort করে পাওয়া যেতে পারে (অর্থাৎ, k-1 টি breakpoint 1 <= x_1 < x_2 < ... < x_{k-1} < n বেছে নিন, এবং এটিকে [1, x_1], (x_1, x_2], ..., (x_{k-1}, n] এ ভাগ করুন)। ফলাফলটি 998244353 দ্বারা modulo করা উচিত।\n\n    >>> f_43(2, 1, [1, 2])\n    2\n\n*/\nint f_43(int n, int k, int qq[])", "bg": "#include <bits/stdc++.h>\n/*\nДадена е пермутация q от n елемента и цяло число k, намерете броя на пермутациите p от n елемента, такива че f(p) = q, където f(p) е лексикографски най-малката пермутация, която може да бъде получена чрез разделяне на p на точно k непразни съседни сегменти и сортиране на всеки сегмент (т.е. изберете k-1 точки на прекъсване 1 <= x_1 < x_2 < ... < x_{k-1} < n, и го разделете на [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). Резултатът трябва да бъде модуло 998244353.\n\n    >>> f_43(2, 1, [1, 2])\n    2\n\n*/\nint f_43(int n, int k, int qq[])", "zh": "#include <bits/stdc++.h>\n/*\n给定一个 n 个元素的排列 q 和一个整数 k，找出有多少个 n 个元素的排列 p 满足 f(p) = q，其中 f(p) 是通过将 p 分成恰好 k 个非空连续段并对每个段进行排序可以得到的字典序最小的排列（即，选择 k-1 个断点 1 <= x_1 < x_2 < ... < x_{k-1} < n，并将其分为 [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]）。结果应对 998244353 取模。\n\n    >>> f_43(2, 1, [1, 2])\n    2\n\n*/\nint f_43(int n, int k, int qq[])", "fr": "#include <bits/stdc++.h>\n/*\nÉtant donné une permutation q de n éléments et un entier k, trouvez le nombre de permutations p de n éléments telles que f(p) = q, où f(p) est la permutation lexicographiquement la plus petite qui peut être obtenue en divisant p en exactement k segments contigus non vides et en triant chaque segment (c'est-à-dire, choisissez k-1 points de rupture 1 <= x_1 < x_2 < ... < x_{k-1} < n, et divisez-le en [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). Le résultat doit être modulo 998244353.\n\n    >>> f_43(2, 1, [1, 2])\n    2\n\n*/\nint f_43(int n, int k, int qq[])", "de": "#include <bits/stdc++.h>\n/*\nGegeben eine Permutation q von n Elementen und eine ganze Zahl k, finde die Anzahl der Permutationen p von n Elementen, so dass f(p) = q, wobei f(p) die lexikographisch kleinste Permutation ist, die erhalten werden kann, indem p in genau k nicht-leere zusammenhängende Segmente unterteilt und jedes Segment sortiert wird (d.h., wähle k-1 Trennpunkte 1 <= x_1 < x_2 < ... < x_{k-1} < n, und teile es in [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). Das Ergebnis sollte modulo 998244353 sein.\n\n    >>> f_43(2, 1, [1, 2])\n    2\n\n*/\nint f_43(int n, int k, int qq[])", "ha": "#include <bits/stdc++.h>\n/*\nAn ba da permutation q na abubuwa n da kuma lamba k, nemo yawan permutations p na abubuwa n da suke sa f(p) = q, inda f(p) shine mafi ƙarancin permutation a cikin tsarin lexicographically wanda za'a iya samu ta hanyar raba p zuwa daidai k sassa masu cike kuma masu ci gaba da juna sannan a tsara kowanne sashe (wato, zaɓi k-1 wuraren tsayawa 1 <= x_1 < x_2 < ... < x_{k-1} < n, kuma a raba shi zuwa [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). Sakamakon ya kasance modulo 998244353.\n\n    >>> f_43(2, 1, [1, 2])\n    2\n\n*/\nint f_43(int n, int k, int qq[])", "hi": "#include <bits/stdc++.h>\n/*\nदी गई n तत्वों की एक क्रमचय q और एक पूर्णांक k के लिए, n तत्वों की उन क्रमचयों की संख्या खोजें p ताकि f(p) = q हो, जहाँ f(p) वह शब्दकोशीय रूप से सबसे छोटी क्रमचय है जो p को ठीक k गैर-खाली संलग्न खंडों में विभाजित करके और प्रत्येक खंड को क्रमबद्ध करके प्राप्त की जा सकती है (अर्थात, k-1 ब्रेकपॉइंट चुनें 1 <= x_1 < x_2 < ... < x_{k-1} < n, और इसे [1, x_1], (x_1, x_2], ..., (x_{k-1}, n] में विभाजित करें)। परिणाम 998244353 के मापांक में होना चाहिए।\n\n    >>> f_43(2, 1, [1, 2])\n    2\n\n*/\nint f_43(int n, int k, int qq[])", "hu": "#include <bits/stdc++.h>\n/*\nAdott egy q permutáció n elemről és egy egész szám k, meg kell találni azon p permutációk számát n elemről, amelyekre f(p) = q, ahol f(p) a lexikografikusan legkisebb permutáció, amelyet úgy lehet megkapni, hogy p-t pontosan k nem üres, összefüggő szegmensre osztjuk, és minden szegmenst sorba rendezünk (azaz válasszunk k-1 töréspontot 1 <= x_1 < x_2 < ... < x_{k-1} < n, és osszuk fel [1, x_1], (x_1, x_2], ..., (x_{k-1}, n] részekre). Az eredménynek 998244353-mal vett maradéka kell legyen.\n\n    >>> f_43(2, 1, [1, 2])\n    2\n\n*/\nint f_43(int n, int k, int qq[])", "es": "#include <bits/stdc++.h>\n/*\nDada una permutación q de n elementos y un entero k, encuentra el número de permutaciones p de n elementos tal que f(p) = q, donde f(p) es la permutación lexicográficamente más pequeña que se puede obtener dividiendo p en exactamente k segmentos contiguos no vacíos y ordenando cada segmento (es decir, elige k-1 puntos de ruptura 1 <= x_1 < x_2 < ... < x_{k-1} < n, y divídelo en [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). El resultado debe ser módulo 998244353.\n\n    >>> f_43(2, 1, [1, 2])\n    2\n\n*/\nint f_43(int n, int k, int qq[])", "arb": "#include <bits/stdc++.h>\n/*\nبالنظر إلى ترتيب q مكون من n عنصرًا وعدد صحيح k، جد عدد التباديل p المكونة من n عنصرًا بحيث f(p) = q، حيث أن f(p) هو الترتيب الأصغر لغوياً الذي يمكن الحصول عليه عن طريق تقسيم p إلى k مقاطع متجاورة غير فارغة بالضبط وترتيب كل مقطع (أي اختر k-1 نقاط تقاطع 1 <= x_1 < x_2 < ... < x_{k-1} < n، وقسمها إلى [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). يجب أن يكون الناتج موديولو 998244353.\n\n    >>> f_43(2, 1, [1, 2])\n    2\n\n*/\nint f_43(int n, int k, int qq[])", "sw": "#include <bits/stdc++.h>\n/*\nUkipewa mpangilio q wa vipengele n na nambari k, pata idadi ya mipangilio p ya vipengele n kama f(p) = q, ambapo f(p) ni mpangilio mdogo zaidi kwa mpangilio wa lexicographically ambao unaweza kupatikana kwa kugawanya p katika sehemu k zisizo tupu za mfululizo na kupanga kila sehemu (yaani, chagua sehemu za kugawanya k-1 1 <= x_1 < x_2 < ... < x_{k-1} < n, na igawanye katika [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). Matokeo yanapaswa kuwa modulo 998244353.\n\n    >>> f_43(2, 1, [1, 2])\n    2\n\n*/\nint f_43(int n, int k, int qq[])", "tr": "#include <bits/stdc++.h>\n/*\nn elemanlı bir q permütasyonu ve bir k tam sayısı verildiğinde, f(p) = q olacak şekilde n elemanlı kaç tane p permütasyonu olduğunu bulun, burada f(p), p'yi tam olarak k boş olmayan ardışık parçaya bölerek ve her parçayı sıralayarak elde edilebilecek sözlük sırasına göre en küçük permütasyondur (yani, 1 <= x_1 < x_2 < ... < x_{k-1} < n olacak şekilde k-1 kırılma noktası seçin ve [1, x_1], (x_1, x_2], ..., (x_{k-1}, n] olarak bölün). Sonuç 998244353 ile mod alınmalıdır.\n\n    >>> f_43(2, 1, [1, 2])\n    2\n\n*/\nint f_43(int n, int k, int qq[])", "vi": "#include <bits/stdc++.h>\n/*\nCho một hoán vị q của n phần tử và một số nguyên k, tìm số lượng hoán vị p của n phần tử sao cho f(p) = q, trong đó f(p) là hoán vị nhỏ nhất theo từ điển có thể thu được bằng cách chia p thành chính xác k đoạn liên tiếp không rỗng và sắp xếp từng đoạn (tức là, chọn k-1 điểm ngắt 1 <= x_1 < x_2 < ... < x_{k-1} < n, và chia nó thành [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). Kết quả nên được lấy modulo 998244353.\n\n    >>> f_43(2, 1, [1, 2])\n    2\n\n*/\nint f_43(int n, int k, int qq[])", "id": "#include <bits/stdc++.h>\n/*\nDiberikan sebuah permutasi q dari n elemen dan sebuah bilangan bulat k, temukan jumlah permutasi p dari n elemen sedemikian rupa sehingga f(p) = q, di mana f(p) adalah permutasi terkecil secara leksikografis yang dapat diperoleh dengan membagi p menjadi tepat k segmen kontigu yang tidak kosong dan mengurutkan setiap segmen (yaitu, pilih k-1 titik putus 1 <= x_1 < x_2 < ... < x_{k-1} < n, dan bagi menjadi [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). Hasilnya harus dalam modulo 998244353.\n\n    >>> f_43(2, 1, [1, 2])\n    2\n\n*/\nint f_43(int n, int k, int qq[])", "ja": "#include <bits/stdc++.h>\n/*\nn個の要素の順列qと整数kが与えられたとき、f(p) = qとなるn個の要素の順列pの数を求めます。ここで、f(p)はpを正確にk個の空でない連続したセグメントに分割し、各セグメントをソートすることで得られる辞書順で最小の順列です（つまり、k-1個のブレークポイント1 <= x_1 < x_2 < ... < x_{k-1} < nを選び、それを[1, x_1], (x_1, x_2], ..., (x_{k-1}, n]に分割します）。結果は998244353でのモジュロとします。\n\n    >>> f_43(2, 1, [1, 2])\n    2\n\n*/\nint f_43(int n, int k, int qq[])", "ko": "#include <bits/stdc++.h>\n/*\nn개의 요소로 이루어진 순열 q와 정수 k가 주어졌을 때, f(p) = q인 n개의 요소로 이루어진 순열 p의 개수를 찾으시오. 여기서 f(p)는 p를 정확히 k개의 비어 있지 않은 연속 구간으로 나누고 각 구간을 정렬하여 얻을 수 있는 사전식으로 가장 작은 순열입니다 (즉, k-1개의 분할점을 선택하여 1 <= x_1 < x_2 < ... < x_{k-1} < n, [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]으로 나눕니다). 결과는 998244353로 나눈 나머지여야 합니다.\n\n    >>> f_43(2, 1, [1, 2])\n    2\n\n*/\nint f_43(int n, int k, int qq[])", "ml": "#include <bits/stdc++.h>\n/*\nഒരു n ഘടകങ്ങളുടെ permutation q ഉം ഒരു പൂർണ്ണസംഖ്യ k ഉം നൽകിയാൽ, f(p) = q ആയ n ഘടകങ്ങളുടെ permutation p കളുടെ എണ്ണം കണ്ടെത്തുക, ഇവിടെ f(p) എന്നത് p നെ കൃത്യമായി k ശൂന്യമല്ലാത്ത തുടർച്ചയായ വിഭാഗങ്ങളായി വിഭജിച്ച് ഓരോ വിഭാഗവും ക്രമീകരിച്ച് ലഭിക്കാവുന്ന ലെക്സികോഗ്രാഫിക്കായി ഏറ്റവും ചെറിയ permutation ആണ് (അത് അഥവാ, k-1 ബ്രേക്ക്‌പോയിന്റുകൾ 1 <= x_1 < x_2 < ... < x_{k-1} < n തിരഞ്ഞെടുക്കുക, പിന്നെ അതിനെ [1, x_1], (x_1, x_2], ..., (x_{k-1}, n] എന്നിങ്ങനെ വിഭജിക്കുക). ഫലം 998244353 ലെ മോഡുലോ ആയിരിക്കണം.\n\n    >>> f_43(2, 1, [1, 2])\n    2\n\n*/\nint f_43(int n, int k, int qq[])", "fa": "#include <bits/stdc++.h>\n/*\nبا توجه به یک جایگشت q از n عنصر و یک عدد صحیح k، تعداد جایگشت‌های p از n عنصر را بیابید به طوری که f(p) = q، که در آن f(p) کوچکترین جایگشت لغت‌نامه‌ای است که می‌توان با تقسیم p به دقیقاً k قطعه متوالی غیر خالی و مرتب‌سازی هر قطعه به دست آورد (یعنی k-1 نقطه شکست 1 <= x_1 < x_2 < ... < x_{k-1} < n را انتخاب کنید و آن را به [1, x_1]، (x_1, x_2]، ...، (x_{k-1}, n] تقسیم کنید). نتیجه باید به‌صورت مدولوی 998244353 باشد.\n\n    >>> f_43(2, 1, [1, 2])\n    2\n\n*/\nint f_43(int n, int k, int qq[])"}, "canonical_solution": "{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i != m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}", "instruction": {"en": "Write a CPP function `int f_43(int n, int k, int qq[])` to solve the following problem:\nGiven a permutation q of n elements and an integer k, find the number of permutations p of n elements such that f(p) = q, where f(p) is the lexicographically smallest permutation that can be obtained by dividing p into exactly k non-empty contiguous segments and sorting each segment (i.e., choose k-1 breakpoints 1 <= x_1 < x_2 < ... < x_{k-1} < n, and divide it into [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). The result should be modulo 998244353.\n\n    >>> f_43(2, 1, [1, 2])\n    2\n\n", "sq": "Shkruani një funksion CPP `int f_43(int n, int k, int qq[])` për të zgjidhur problemin në vijim:  \nDuke pasur parasysh një permutacion q të n elementeve dhe një numër të plotë k, gjeni numrin e permutacioneve p të n elementeve të tilla që f(p) = q, ku f(p) është permutacioni më i vogël leksikografik që mund të merret duke ndarë p në saktësisht k segmente të pandara dhe duke renditur secilin segment (d.m.th., zgjidhni k-1 pika ndarjeje 1 <= x_1 < x_2 < ... < x_{k-1} < n, dhe ndajeni atë në [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). Rezultati duhet të jetë modulo 998244353.\n\n    >>> f_43(2, 1, [1, 2])\n    2", "hy": "Գրեք CPP ֆունկցիա `int f_43(int n, int k, int qq[])` հետևյալ խնդիրը լուծելու համար:\nՏրված է n տարրերի q փոխատեղում և k ամբողջ թիվը, գտնել n տարրերի p փոխատեղումների քանակը, այնպես որ f(p) = q, որտեղ f(p)-ն լեքսիկոգրաֆիկորեն ամենափոքր փոխատեղումն է, որը կարող է ստացվել p-ն ճիշտ k չդատարկ հարակից հատվածների բաժանելով և յուրաքանչյուր հատվածը դասավորելով (այսինքն՝ ընտրել k-1 կոտրման կետեր 1 <= x_1 < x_2 < ... < x_{k-1} < n, և բաժանել այն [1, x_1], (x_1, x_2], ..., (x_{k-1}, n] հատվածների): Արդյունքը պետք է լինի 998244353 մոդուլով:\n\n    >>> f_43(2, 1, [1, 2])\n    2", "bn": "একটি CPP ফাংশন `int f_43(int n, int k, int qq[])` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি n উপাদানের permutation q এবং একটি পূর্ণসংখ্যা k দেওয়া আছে, n উপাদানের কতগুলি permutation p আছে তা খুঁজে বের করুন যাতে f(p) = q হয়, যেখানে f(p) হল lexicographically ক্ষুদ্রতম permutation যা ঠিক k টি খালি নয় এমন সংলগ্ন সেগমেন্টে p কে ভাগ করে এবং প্রতিটি সেগমেন্টকে সাজিয়ে প্রাপ্ত হয় (অর্থাৎ, k-1 টি ব্রেকপয়েন্ট 1 <= x_1 < x_2 < ... < x_{k-1} < n নির্বাচন করুন, এবং এটিকে [1, x_1], (x_1, x_2], ..., (x_{k-1}, n] এ ভাগ করুন)। ফলাফলটি 998244353 দ্বারা মডুলো করা উচিত।\n\n    >>> f_43(2, 1, [1, 2])\n    2", "bg": "Напишете CPP функция `int f_43(int n, int k, int qq[])`, за да решите следния проблем:  \nДадена е пермутация q от n елемента и цяло число k, намерете броя на пермутациите p от n елемента, такива че f(p) = q, където f(p) е лексикографски най-малката пермутация, която може да се получи чрез разделяне на p на точно k непразни съседни сегмента и сортиране на всеки сегмент (т.е. изберете k-1 точки на прекъсване 1 <= x_1 < x_2 < ... < x_{k-1} < n, и го разделете на [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). Резултатът трябва да бъде модуло 998244353.\n\n    >>> f_43(2, 1, [1, 2])\n    2", "zh": "编写一个CPP函数 `int f_43(int n, int k, int qq[])` 来解决以下问题：  \n给定一个由n个元素组成的排列q和一个整数k，找到n个元素的排列p的数量，使得f(p) = q，其中f(p)是可以通过将p精确地划分为k个非空连续段并对每个段进行排序而获得的字典序最小的排列（即，选择k-1个断点 1 <= x_1 < x_2 < ... < x_{k-1} < n，并将其划分为 [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]）。结果应对998244353取模。\n\n    >>> f_43(2, 1, [1, 2])\n    2", "fr": "Écrire une fonction CPP `int f_43(int n, int k, int qq[])` pour résoudre le problème suivant :\nÉtant donné une permutation q de n éléments et un entier k, trouver le nombre de permutations p de n éléments telles que f(p) = q, où f(p) est la permutation lexicographiquement la plus petite qui peut être obtenue en divisant p en exactement k segments contigus non vides et en triant chaque segment (c'est-à-dire, choisir k-1 points de rupture 1 <= x_1 < x_2 < ... < x_{k-1} < n, et le diviser en [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). Le résultat doit être modulo 998244353.\n\n    >>> f_43(2, 1, [1, 2])\n    2", "de": "Schreiben Sie eine CPP-Funktion `int f_43(int n, int k, int qq[])`, um das folgende Problem zu lösen:\nGegeben ist eine Permutation q von n Elementen und eine ganze Zahl k. Finden Sie die Anzahl der Permutationen p von n Elementen, so dass f(p) = q, wobei f(p) die lexikographisch kleinste Permutation ist, die erhalten werden kann, indem p in genau k nicht-leere zusammenhängende Segmente unterteilt und jedes Segment sortiert wird (d.h. wählen Sie k-1 Trennpunkte 1 <= x_1 < x_2 < ... < x_{k-1} < n, und teilen Sie es in [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). Das Ergebnis sollte modulo 998244353 sein.\n\n    >>> f_43(2, 1, [1, 2])\n    2", "ha": "Rubuta aikin CPP `int f_43(int n, int k, int qq[])` don warware matsalar mai zuwa:\nAn ba da permutation q na abubuwa n da kuma cikakken lamba k, nemo yawan permutations p na abubuwa n irin waɗanda f(p) = q, inda f(p) shine mafi ƙarancin permutation a cikin tsarin haruffa wanda za a iya samu ta hanyar raba p zuwa daidai k sassa masu ci gaba marasa komai kuma a tsara kowane sashe (wato, zaɓi k-1 wuraren tsagewa 1 <= x_1 < x_2 < ... < x_{k-1} < n, kuma raba shi zuwa [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). Sakamakon ya zama modulo 998244353.\n\n    >>> f_43(2, 1, [1, 2])\n    2", "hi": "एक CPP फ़ंक्शन `int f_43(int n, int k, int qq[])` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए n तत्वों के एक क्रमचय q और एक पूर्णांक k के लिए, n तत्वों के क्रमचयों p की संख्या खोजें ताकि f(p) = q, जहाँ f(p) वह शब्दकोशानुसार सबसे छोटा क्रमचय है जिसे p को ठीक k गैर-खाली सतत खंडों में विभाजित करके और प्रत्येक खंड को क्रमबद्ध करके प्राप्त किया जा सकता है (अर्थात्, k-1 ब्रेकपॉइंट्स चुनें 1 <= x_1 < x_2 < ... < x_{k-1} < n, और इसे [1, x_1], (x_1, x_2], ..., (x_{k-1}, n] में विभाजित करें)। परिणाम 998244353 के मापांक में होना चाहिए।\n\n    >>> f_43(2, 1, [1, 2])\n    2", "hu": "Írj egy CPP függvényt `int f_43(int n, int k, int qq[])` a következő probléma megoldására:\nAdott egy q permutáció n elemre és egy egész szám k, találd meg azon p permutációk számát n elemre, amelyekre f(p) = q, ahol f(p) a lexikografikusan legkisebb permutáció, amelyet úgy kaphatunk meg, hogy p-t pontosan k nem üres, összefüggő szegmensre osztjuk és minden szegmenst sorba rendezünk (azaz válassz k-1 töréspontot 1 <= x_1 < x_2 < ... < x_{k-1} < n, és oszd fel [1, x_1], (x_1, x_2], ..., (x_{k-1}, n] szegmensekre). Az eredményt 998244353-mal vett maradékként kell megadni.\n\n    >>> f_43(2, 1, [1, 2])\n    2", "es": "Escribe una función CPP `int f_43(int n, int k, int qq[])` para resolver el siguiente problema:\nDada una permutación q de n elementos y un entero k, encuentra el número de permutaciones p de n elementos tal que f(p) = q, donde f(p) es la permutación lexicográficamente más pequeña que se puede obtener dividiendo p en exactamente k segmentos contiguos no vacíos y ordenando cada segmento (es decir, elige k-1 puntos de ruptura 1 <= x_1 < x_2 < ... < x_{k-1} < n, y divídelo en [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). El resultado debe ser módulo 998244353.\n\n    >>> f_43(2, 1, [1, 2])\n    2", "arb": "اكتب دالة CPP `int f_43(int n, int k, int qq[])` لحل المشكلة التالية:\nمعطى ترتيب q من n عنصرًا وعدد صحيح k، جد عدد التباديل p من n عنصرًا بحيث f(p) = q، حيث أن f(p) هو الترتيب الأصغر لغويًا الذي يمكن الحصول عليه عن طريق تقسيم p إلى k مقاطع متجاورة غير فارغة بالضبط وترتيب كل مقطع (أي اختيار k-1 نقاط فاصلة 1 <= x_1 < x_2 < ... < x_{k-1} < n، وتقسيمها إلى [1, x_1]، (x_1, x_2]، ...، (x_{k-1}, n]). يجب أن تكون النتيجة موديولو 998244353.\n\n    >>> f_43(2, 1, [1, 2])\n    2", "sw": "Andika kazi ya CPP `int f_43(int n, int k, int qq[])` kutatua tatizo lifuatalo:\nUkipewa permutation q ya vipengele n na nambari k, pata idadi ya permutations p ya vipengele n kama f(p) = q, ambapo f(p) ni permutation ndogo zaidi ki-lexicographically inayoweza kupatikana kwa kugawanya p katika sehemu k zisizo tupu na kupanga kila sehemu (yaani, chagua sehemu k-1 za kuvunja 1 <= x_1 < x_2 < ... < x_{k-1} < n, na igawanye katika [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). Matokeo yanapaswa kuwa modulo 998244353.\n\n    >>> f_43(2, 1, [1, 2])\n    2", "tr": "Bir CPP fonksiyonu `int f_43(int n, int k, int qq[])` yazın ve aşağıdaki problemi çözün:\nn elemanlı bir q permütasyonu ve bir k tam sayısı verildiğinde, f(p) = q olacak şekilde n elemanlı kaç tane p permütasyonu olduğunu bulun. Burada f(p), p'yi tam olarak k tane boş olmayan ardışık segmente bölerek ve her segmenti sıralayarak elde edilebilecek sözlük sırasına göre en küçük permütasyondur (yani, k-1 tane kırılma noktası seçin 1 <= x_1 < x_2 < ... < x_{k-1} < n ve [1, x_1], (x_1, x_2], ..., (x_{k-1}, n] olarak bölün). Sonuç 998244353 ile mod alınmalıdır.\n\n    >>> f_43(2, 1, [1, 2])\n    2", "vi": "Viết một hàm CPP `int f_43(int n, int k, int qq[])` để giải quyết vấn đề sau:\nCho một hoán vị q của n phần tử và một số nguyên k, tìm số lượng hoán vị p của n phần tử sao cho f(p) = q, trong đó f(p) là hoán vị nhỏ nhất theo từ điển có thể thu được bằng cách chia p thành chính xác k đoạn liên tiếp không rỗng và sắp xếp từng đoạn (tức là, chọn k-1 điểm ngắt 1 <= x_1 < x_2 < ... < x_{k-1} < n, và chia nó thành [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). Kết quả nên được lấy modulo 998244353.\n\n    >>> f_43(2, 1, [1, 2])\n    2", "id": "Tulis fungsi CPP `int f_43(int n, int k, int qq[])` untuk menyelesaikan masalah berikut:\nDiberikan sebuah permutasi q dari n elemen dan sebuah bilangan bulat k, temukan jumlah permutasi p dari n elemen sedemikian rupa sehingga f(p) = q, di mana f(p) adalah permutasi terkecil secara leksikografis yang dapat diperoleh dengan membagi p menjadi tepat k segmen kontigu yang tidak kosong dan mengurutkan setiap segmen (yaitu, pilih k-1 titik pemisah 1 <= x_1 < x_2 < ... < x_{k-1} < n, dan bagi menjadi [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). Hasilnya harus dalam modulo 998244353.\n\n    >>> f_43(2, 1, [1, 2])\n    2", "ja": "CPP関数 `int f_43(int n, int k, int qq[])` を作成して、次の問題を解決してください:\nn個の要素の順列qと整数kが与えられたとき、f(p) = qとなるn個の要素の順列pの数を求めます。ここで、f(p)はpをちょうどk個の空でない連続したセグメントに分割し、各セグメントをソートすることによって得られる辞書順で最小の順列です（つまり、1 <= x_1 < x_2 < ... < x_{k-1} < nのk-1個のブレークポイントを選び、[1, x_1], (x_1, x_2], ..., (x_{k-1}, n]に分割します）。結果は998244353でのモジュロを取ります。\n\n    >>> f_43(2, 1, [1, 2])\n    2", "ko": "CPP 함수를 작성하세요 `int f_43(int n, int k, int qq[])` 다음 문제를 해결하기 위해:\nn 요소의 순열 q와 정수 k가 주어졌을 때, n 요소의 순열 p의 개수를 찾아라. 여기서 f(p) = q, f(p)는 p를 정확히 k개의 비어 있지 않은 연속된 세그먼트로 나누고 각 세그먼트를 정렬하여 얻을 수 있는 사전순으로 가장 작은 순열이다 (즉, k-1개의 분할점을 선택하여 1 <= x_1 < x_2 < ... < x_{k-1} < n, [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]으로 나눈다). 결과는 998244353로 모듈러 연산해야 한다.\n\n    >>> f_43(2, 1, [1, 2])\n    2", "ml": "CPP ഫംഗ്ഷൻ `int f_43(int n, int k, int qq[])` എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nn ഘടകങ്ങളുടെ ഒരു permutation qയും ഒരു പൂർണ്ണസംഖ്യ kയും നൽകിയാൽ, n ഘടകങ്ങളുടെ permutation pകളുടെ എണ്ണം കണ്ടെത്തുക, അങ്ങനെ f(p) = q, ഇവിടെ f(p) എന്നത് pയെ കൃത്യമായി k ശൂന്യമല്ലാത്ത തുടർച്ചയായ വിഭാഗങ്ങളായി വിഭജിച്ച് ഓരോ വിഭാഗവും ക്രമീകരിച്ച് ലഭിക്കാവുന്ന ലെക്സികോഗ്രാഫിക്‌ ആയി ഏറ്റവും ചെറിയ permutation ആണ് (അഥവാ, k-1 ബ്രേക്ക്പോയിന്റുകൾ 1 <= x_1 < x_2 < ... < x_{k-1} < n തിരഞ്ഞെടുക്കുക, അതിനെ [1, x_1], (x_1, x_2], ..., (x_{k-1}, n] ആയി വിഭജിക്കുക). ഫലം 998244353 ന്റെ മോഡുലോ ആയിരിക്കണം.\n\n    >>> f_43(2, 1, [1, 2])\n    2", "fa": "یک تابع CPP به نام `int f_43(int n, int k, int qq[])` بنویسید تا مسئله زیر را حل کند:\nبا توجه به یک جایگشت q از n عنصر و یک عدد صحیح k، تعداد جایگشت‌های p از n عنصر را بیابید به طوری که f(p) = q، که در آن f(p) کوچکترین جایگشت لغت‌نامه‌ای است که می‌تواند با تقسیم p به دقیقاً k بخش متوالی غیر خالی و مرتب‌سازی هر بخش به دست آید (یعنی k-1 نقطه شکست 1 <= x_1 < x_2 < ... < x_{k-1} < n را انتخاب کنید و آن را به [1, x_1]، (x_1, x_2]، ...، (x_{k-1}, n] تقسیم کنید). نتیجه باید به پیمانه 998244353 باشد.\n\n    >>> f_43(2, 1, [1, 2])\n    2"}, "level": "hard", "test": "int main() {\n    int q1[] = {1, 2};\n    assert(f_43(2, 1, q1) == 2);\n\n    int q2[] = {3, 1, 2};\n    assert(f_43(3, 3, q2) == 1);\n\n    int q3[] = {1, 2, 3, 6, 5, 4};\n    assert(f_43(6, 3, q3) == 13);\n\n    int q4[] = {1, 2, 3, 4, 5, 6};\n    assert(f_43(6, 1, q4) == 720);\n\n    int q5[] = {1, 2, 5, 3, 4, 5};\n    assert(f_43(6, 3, q5) == 0);\n\n    int q6[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n    assert(f_43(9, 9, q6) == 1);\n\n    int q7[] = {1, 2, 3, 4, 5, 6, 7, 9, 8};\n    assert(f_43(9, 2, q7) == 29093);\n    return 0;}", "entry_point": "f_43", "signature": "int f_43(int n, int k, int qq[])", "docstring": {"en": "Given a permutation q of n elements and an integer k, find the number of permutations p of n elements such that f(p) = q, where f(p) is the lexicographically smallest permutation that can be obtained by dividing p into exactly k non-empty contiguous segments and sorting each segment (i.e., choose k-1 breakpoints 1 <= x_1 < x_2 < ... < x_{k-1} < n, and divide it into [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). The result should be modulo 998244353.\n\n    >>> f_43(2, 1, [1, 2])\n    2\n\n", "sq": "Duke pasur një permutacion q të n elementeve dhe një numër të plotë k, gjeni numrin e permutacioneve p të n elementeve të tilla që f(p) = q, ku f(p) është permutacioni më i vogël leksikografik që mund të merret duke ndarë p në saktësisht k segmente të pandara dhe duke renditur secilin segment (d.m.th., zgjidhni k-1 pika ndarëse 1 <= x_1 < x_2 < ... < x_{k-1} < n, dhe ndajeni në [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). Rezultati duhet të jetë modulo 998244353.\n\n    >>> f_43(2, 1, [1, 2])\n    2", "hy": "Տրված է n տարրերի q փոխատեղումը և k ամբողջ թիվը, գտնել n տարրերի p փոխատեղումների քանակը, այնպես որ f(p) = q, որտեղ f(p)-ն ամենափոքր լեքսիկոգրաֆիկ փոխատեղումն է, որը կարելի է ստանալ p-ն ճիշտ k ոչ դատարկ հարակից հատվածների բաժանելով և յուրաքանչյուր հատվածը դասավորելով (այսինքն՝ ընտրել k-1 կոտրում կետեր 1 <= x_1 < x_2 < ... < x_{k-1} < n, և բաժանել այն [1, x_1], (x_1, x_2], ..., (x_{k-1}, n] հատվածների): Արդյունքը պետք է լինի 998244353 մոդուլով:\n\n    >>> f_43(2, 1, [1, 2])\n    2", "bn": "একটি n উপাদানের পারমুটেশন q এবং একটি পূর্ণসংখ্যা k দেওয়া আছে, এমন n উপাদানের পারমুটেশন p-এর সংখ্যা খুঁজে বের করুন যাতে f(p) = q হয়, যেখানে f(p) হল লেক্সিকোগ্রাফিকভাবে সবচেয়ে ছোট পারমুটেশন যা p-কে ঠিক kটি খালি নয় এমন ক্রমাগত সেগমেন্টে ভাগ করে এবং প্রতিটি সেগমেন্টকে সাজিয়ে প্রাপ্ত করা যায় (অর্থাৎ, k-1টি ব্রেকপয়েন্ট নির্বাচন করুন 1 <= x_1 < x_2 < ... < x_{k-1} < n, এবং এটিকে [1, x_1], (x_1, x_2], ..., (x_{k-1}, n] এ ভাগ করুন)। ফলাফলটি 998244353 দ্বারা মডুলো হবে।\n\n    >>> f_43(2, 1, [1, 2])\n    2", "bg": "Дадена е пермутация q от n елемента и цяло число k, намерете броя на пермутациите p от n елемента, такива че f(p) = q, където f(p) е лексикографски най-малката пермутация, която може да бъде получена чрез разделяне на p на точно k непразни съседни сегмента и сортиране на всеки сегмент (т.е. изберете k-1 точки на прекъсване 1 <= x_1 < x_2 < ... < x_{k-1} < n, и го разделете на [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). Резултатът трябва да бъде модуло 998244353.\n\n    >>> f_43(2, 1, [1, 2])\n    2", "zh": "给定一个由 n 个元素组成的排列 q 和一个整数 k，找出 n 个元素的排列 p 的数量，使得 f(p) = q，其中 f(p) 是通过将 p 分成恰好 k 个非空连续段并对每个段进行排序后可以得到的字典序最小的排列（即，选择 k-1 个断点 1 <= x_1 < x_2 < ... < x_{k-1} < n，并将其分为 [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]）。结果应对 998244353 取模。\n\n    >>> f_43(2, 1, [1, 2])\n    2", "fr": "Étant donné une permutation q de n éléments et un entier k, trouver le nombre de permutations p de n éléments tel que f(p) = q, où f(p) est la permutation lexicographiquement la plus petite qui peut être obtenue en divisant p en exactement k segments contigus non vides et en triant chaque segment (c'est-à-dire, choisir k-1 points de rupture 1 <= x_1 < x_2 < ... < x_{k-1} < n, et le diviser en [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). Le résultat doit être modulo 998244353.\n\n    >>> f_43(2, 1, [1, 2])\n    2", "de": "Gegeben eine Permutation q von n Elementen und eine ganze Zahl k, finde die Anzahl der Permutationen p von n Elementen, so dass f(p) = q, wobei f(p) die lexikographisch kleinste Permutation ist, die erhalten werden kann, indem p in genau k nicht-leere zusammenhängende Segmente unterteilt und jedes Segment sortiert wird (d.h. wähle k-1 Trennpunkte 1 <= x_1 < x_2 < ... < x_{k-1} < n, und teile es in [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). Das Ergebnis sollte modulo 998244353 sein.\n\n    >>> f_43(2, 1, [1, 2])\n    2", "ha": "An ba da permutation q na abubuwa n da kuma lamba k, nemo yawan permutations p na abubuwa n da suke cika f(p) = q, inda f(p) shine mafi ƙarancin permutation a cikin tsarin haruffa wanda za a iya samu ta hanyar raba p zuwa daidai k sassa masu ci gaba ba tare da komai ba kuma a tsara kowanne sashe (wato, zaɓi k-1 wuraren tsayawa 1 <= x_1 < x_2 < ... < x_{k-1} < n, kuma raba shi zuwa [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). Sakamakon ya kasance modulo 998244353.\n\n    >>> f_43(2, 1, [1, 2])\n    2", "hi": "दिए गए n तत्वों के एक क्रमचय q और एक पूर्णांक k के लिए, n तत्वों के उन क्रमचयों की संख्या खोजें p, ताकि f(p) = q, जहाँ f(p) वह शब्दकोशीय रूप से सबसे छोटा क्रमचय है जो p को ठीक k गैर-खाली संलग्न खंडों में विभाजित करके और प्रत्येक खंड को क्रमबद्ध करके प्राप्त किया जा सकता है (अर्थात, k-1 ब्रेकपॉइंट चुनें 1 <= x_1 < x_2 < ... < x_{k-1} < n, और इसे [1, x_1], (x_1, x_2], ..., (x_{k-1}, n] में विभाजित करें)। परिणाम को 998244353 से मापांकित किया जाना चाहिए।\n\n    >>> f_43(2, 1, [1, 2])\n    2", "hu": "Adott egy q permutáció n elemre és egy egész szám k, találd meg azon p permutációk számát n elemre, amelyekre f(p) = q, ahol f(p) a lexikografikusan legkisebb permutáció, amelyet úgy lehet megkapni, hogy p-t pontosan k nem üres, összefüggő szegmensre osztjuk és minden szegmenst sorba rendezünk (azaz válasszunk k-1 töréspontot 1 <= x_1 < x_2 < ... < x_{k-1} < n, és osszuk fel [1, x_1], (x_1, x_2], ..., (x_{k-1}, n] részekre). Az eredménynek 998244353-mal vett maradéka kell legyen.\n\n    >>> f_43(2, 1, [1, 2])\n    2", "es": "Dada una permutación q de n elementos y un entero k, encuentra el número de permutaciones p de n elementos tal que f(p) = q, donde f(p) es la permutación lexicográficamente más pequeña que se puede obtener dividiendo p en exactamente k segmentos contiguos no vacíos y ordenando cada segmento (es decir, elige k-1 puntos de ruptura 1 <= x_1 < x_2 < ... < x_{k-1} < n, y divídelo en [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). El resultado debe ser módulo 998244353.\n\n    >>> f_43(2, 1, [1, 2])\n    2", "arb": "معطى ترتيب q لعناصر n وعدد صحيح k، ابحث عن عدد التباديل p لعناصر n بحيث f(p) = q، حيث أن f(p) هو الترتيب الأصغر لغوياً الذي يمكن الحصول عليه عن طريق تقسيم p إلى k مقاطع متجاورة غير فارغة بالضبط وترتيب كل مقطع (أي اختيار k-1 نقاط فاصلة 1 <= x_1 < x_2 < ... < x_{k-1} < n، وتقسيمها إلى [1, x_1]، (x_1, x_2]، ...، (x_{k-1}, n]). يجب أن تكون النتيجة موديولو 998244353.\n\n    >>> f_43(2, 1, [1, 2])\n    2", "sw": "Mojawapo ya mpangilio q wa vipengele n na nambari k, pata idadi ya mpangilio p wa vipengele n kama f(p) = q, ambapo f(p) ni mpangilio mdogo zaidi wa lexicographically ambao unaweza kupatikana kwa kugawanya p katika sehemu k zisizo tupu zinazofuatana na kupanga kila sehemu (yaani, chagua sehemu za kuvunja k-1 1 <= x_1 < x_2 < ... < x_{k-1} < n, na igawanye katika [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). Matokeo yanapaswa kuwa modulo 998244353.\n\n    >>> f_43(2, 1, [1, 2])\n    2", "tr": "Verilen n elemanlı bir q permütasyonu ve bir k tam sayısı için, f(p) = q olacak şekilde n elemanlı kaç tane p permütasyonu olduğunu bulun. Burada f(p), p'yi tam olarak k tane boş olmayan ardışık segmente bölerek ve her segmenti sıralayarak elde edilebilecek sözlük sırasına göre en küçük permütasyondur (yani, k-1 tane kırılma noktası seçin 1 <= x_1 < x_2 < ... < x_{k-1} < n ve [1, x_1], (x_1, x_2], ..., (x_{k-1}, n] olarak bölün). Sonuç 998244353 ile mod alınmalıdır.\n\n    >>> f_43(2, 1, [1, 2])\n    2", "vi": "Được cho một hoán vị q của n phần tử và một số nguyên k, tìm số lượng hoán vị p của n phần tử sao cho f(p) = q, trong đó f(p) là hoán vị nhỏ nhất theo từ điển có thể thu được bằng cách chia p thành chính xác k đoạn liên tiếp không rỗng và sắp xếp từng đoạn (tức là, chọn k-1 điểm ngắt 1 <= x_1 < x_2 < ... < x_{k-1} < n, và chia nó thành [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). Kết quả nên được lấy theo modulo 998244353.\n\n    >>> f_43(2, 1, [1, 2])\n    2", "id": "Diberikan sebuah permutasi q dari n elemen dan sebuah bilangan bulat k, temukan jumlah permutasi p dari n elemen sedemikian rupa sehingga f(p) = q, di mana f(p) adalah permutasi terkecil secara leksikografis yang dapat diperoleh dengan membagi p menjadi tepat k segmen kontigu yang tidak kosong dan mengurutkan setiap segmen (yaitu, pilih k-1 titik putus 1 <= x_1 < x_2 < ... < x_{k-1} < n, dan bagi menjadi [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). Hasilnya harus dalam modulo 998244353.\n\n    >>> f_43(2, 1, [1, 2])\n    2", "ja": "与えられた n 要素の置換 q と整数 k に対して、n 要素の置換 p の数を求めます。ただし、f(p) = q となるような p を求めます。ここで、f(p) は p を正確に k 個の空でない連続したセグメントに分割し、各セグメントをソートすることによって得られる辞書順で最小の置換です（つまり、k-1 個のブレークポイント 1 <= x_1 < x_2 < ... < x_{k-1} < n を選択し、それを [1, x_1], (x_1, x_2], ..., (x_{k-1}, n] に分割します）。結果は 998244353 でのモジュロとします。\n\n    >>> f_43(2, 1, [1, 2])\n    2", "ko": "주어진 n 요소의 순열 q와 정수 k가 있을 때, n 요소의 순열 p 중에서 f(p) = q가 되는 순열의 수를 찾습니다. 여기서 f(p)는 p를 정확히 k개의 비어 있지 않은 연속된 구간으로 나누고 각 구간을 정렬하여 얻을 수 있는 사전식으로 가장 작은 순열입니다 (즉, k-1개의 분할점을 선택하여 1 <= x_1 < x_2 < ... < x_{k-1} < n으로 나누고, [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]으로 나눕니다). 결과는 998244353로 나눈 나머지가 되어야 합니다.\n\n    >>> f_43(2, 1, [1, 2])\n    2", "ml": "ഒരു n ഘടകങ്ങളുടെ ക്രമീകരണവും ഒരു പൂർണ്ണസംഖ്യ kയും നൽകിയാൽ, f(p) = q ആയ n ഘടകങ്ങളുടെ ക്രമീകരണങ്ങളുടെ എണ്ണം കണ്ടെത്തുക, ഇവിടെ f(p) എന്നത് p നെ കൃത്യമായി k ശൂന്യമല്ലാത്ത തുടർച്ചയായ വിഭാഗങ്ങളായി വിഭജിച്ച് ഓരോ വിഭാഗവും ക്രമീകരിച്ച് ലഭിക്കാവുന്ന ലെക്സികോഗ്രാഫിക് ആയി ഏറ്റവും ചെറിയ ക്രമീകരണമാണ് (അഥവാ, k-1 ബ്രേക്ക്പോയിന്റുകൾ 1 <= x_1 < x_2 < ... < x_{k-1} < n തിരഞ്ഞെടുക്കുക, അതിനെ [1, x_1], (x_1, x_2], ..., (x_{k-1}, n] ആയി വിഭജിക്കുക). ഫലം 998244353 ൽ മോഡുലോ ആയിരിക്കണം.\n\n    >>> f_43(2, 1, [1, 2])\n    2", "fa": "با توجه به یک جایگشت q از n عنصر و یک عدد صحیح k، تعداد جایگشت‌های p از n عنصر را پیدا کنید به طوری که f(p) = q، جایی که f(p) کوچکترین جایگشت لغت‌نامه‌ای است که می‌تواند با تقسیم p به طور دقیق به k بخش متوالی غیر خالی و مرتب‌سازی هر بخش به دست آید (یعنی k-1 نقطه شکست 1 <= x_1 < x_2 < ... < x_{k-1} < n را انتخاب کنید و آن را به [1, x_1]، (x_1, x_2]، ...، (x_{k-1}, n] تقسیم کنید). نتیجه باید به صورت مدولوی 998244353 باشد.\n\n    >>> f_43(2, 1, [1, 2])\n    2"}}
{"task_id": "CPP/44", "prompt": {"en": "#include <cassert>\n#include <algorithm>\n#include <vector>\n/**\n * Given an array of n distinct integers representing the heights of Kira's friends, \n * find the number of ways to choose a triplet (a, b, c) such that the greatest common divisor (GCD) \n * of the maximum and minimum values of the triplet is 1.\n * \n * Example usage:\n * >>> f_44({1, 5, 7})\n * 1\n */\nint f_44(const std::vector<int>& heights)", "sq": "#include <cassert>\n#include <algorithm>\n#include <vector>\n/**\n * Duke pasur një varg me n numra të plotë të ndryshëm që përfaqësojnë lartësitë e miqve të Kirës,\n * gjeni numrin e mënyrave për të zgjedhur një treshe (a, b, c) të tillë që maksimumi dhe minimumi\n * i tresheve të kenë përbashkët vetëm numrin 1 si pjesëtues të përbashkët më të madh (GCD).\n * \n * Shembull përdorimi:\n * >>> f_44({1, 5, 7})\n * 1\n */\nint f_44(const std::vector<int>& heights)", "hy": "#include <cassert>\n#include <algorithm>\n#include <vector>\n/**\n * Տրված է n տարբեր ամբողջ թվերից բաղկացած զանգված, որը ներկայացնում է Կիրայի ընկերների բարձրությունները,\n * գտնել եղանակների քանակը, որոնցով կարելի է ընտրել եռյակ (a, b, c) այնպես, որ եռյակի առավելագույն և նվազագույն արժեքների \n * ամենամեծ ընդհանուր բաժանարարը (GCD) լինի 1:\n * \n * Օրինակ օգտագործում:\n * >>> f_44({1, 5, 7})\n * 1\n */\nint f_44(const std::vector<int>& heights)", "bn": "#include <cassert>\n#include <algorithm>\n#include <vector>\n/**\n * কিরার বন্ধুদের উচ্চতা উপস্থাপনকারী n টি স্বতন্ত্র পূর্ণসংখ্যার একটি অ্যারে দেওয়া হয়েছে,\n * কত উপায়ে একটি ত্রয়ী (a, b, c) নির্বাচন করা যায় তা খুঁজে বের করুন যাতে ত্রয়ীর সর্বাধিক এবং ন্যূনতম মানের \n * সর্বাধিক সাধারণ গুণনীয়ক (GCD) 1 হয়।\n * \n * উদাহরণ ব্যবহার:\n * >>> f_44({1, 5, 7})\n * 1\n */\nint f_44(const std::vector<int>& heights)", "bg": "#include <cassert>\n#include <algorithm>\n#include <vector>\n/**\n * Даден е масив от n различни цели числа, представляващи височините на приятелите на Кира,\n * намерете броя на начините за избор на тройка (a, b, c) така, че най-големият общ делител (НОД)\n * на максималната и минималната стойност на тройката да е 1.\n * \n * Пример за използване:\n * >>> f_44({1, 5, 7})\n * 1\n */\nint f_44(const std::vector<int>& heights)", "zh": "#include <cassert>\n#include <algorithm>\n#include <vector>\n/**\n * 给定一个由 n 个不同整数组成的数组，表示 Kira 朋友的身高，\n * 找出选择一个三元组 (a, b, c) 的方法数，使得该三元组的最大值和最小值的最大公约数 (GCD) 为 1。\n * \n * 示例用法：\n * >>> f_44({1, 5, 7})\n * 1\n */\nint f_44(const std::vector<int>& heights)", "fr": "#include <cassert>\n#include <algorithm>\n#include <vector>\n/**\n * Étant donné un tableau de n entiers distincts représentant les hauteurs des amis de Kira,\n * trouvez le nombre de façons de choisir un triplet (a, b, c) tel que le plus grand commun diviseur (PGCD)\n * des valeurs maximale et minimale du triplet soit 1.\n * \n * Exemple d'utilisation :\n * >>> f_44({1, 5, 7})\n * 1\n */\nint f_44(const std::vector<int>& heights)", "de": "#include <cassert>\n#include <algorithm>\n#include <vector>\n/**\n * Gegeben ein Array von n verschiedenen ganzen Zahlen, die die Höhen von Kiras Freunden darstellen,\n * finde die Anzahl der Möglichkeiten, ein Tripel (a, b, c) auszuwählen, so dass der größte gemeinsame Teiler (GCD)\n * der maximalen und minimalen Werte des Tripels 1 ist.\n * \n * Beispielverwendung:\n * >>> f_44({1, 5, 7})\n * 1\n */\nint f_44(const std::vector<int>& heights)", "ha": "#include <cassert>\n#include <algorithm>\n#include <vector>\n/**\n * An ba da wani tsararren jerin lambobi na n waɗanda ke wakiltar tsayin abokan Kira,\n * nemo yawan hanyoyin zaɓar triplet (a, b, c) ta yadda mafi girman abin da ke raba su (GCD)\n * na mafi girma da mafi ƙanƙanta na triplet ɗin ya zama 1.\n * \n * Misalin amfani:\n * >>> f_44({1, 5, 7})\n * 1\n */\nint f_44(const std::vector<int>& heights)", "hi": "#include <cassert>\n#include <algorithm>\n#include <vector>\n/**\n * दिए गए n भिन्न पूर्णांकों की एक array, जो कि किरा के दोस्तों की ऊँचाईयों का प्रतिनिधित्व करती है, \n * में ऐसे triplet (a, b, c) चुनने के तरीकों की संख्या ज्ञात करें कि triplet के अधिकतम और न्यूनतम \n * मानों का महत्तम समापवर्तक (GCD) 1 हो।\n * \n * उदाहरण उपयोग:\n * >>> f_44({1, 5, 7})\n * 1\n */\nint f_44(const std::vector<int>& heights)", "hu": "#include <cassert>\n#include <algorithm>\n#include <vector>\n/**\n * Adott egy tömb n különböző egész számmal, amelyek Kira barátainak magasságát képviselik, \n * meg kell találni, hányféleképpen lehet kiválasztani egy hármast (a, b, c) úgy, hogy a hármas \n * maximumának és minimumának legnagyobb közös osztója (GCD) 1 legyen.\n * \n * Példa használat:\n * >>> f_44({1, 5, 7})\n * 1\n */\nint f_44(const std::vector<int>& heights)", "es": "#include <cassert>\n#include <algorithm>\n#include <vector>\n/**\n * Dado un array de n enteros distintos que representan las alturas de los amigos de Kira,\n * encuentra el número de formas de elegir un triplete (a, b, c) tal que el máximo común divisor (GCD)\n * de los valores máximo y mínimo del triplete sea 1.\n * \n * Ejemplo de uso:\n * >>> f_44({1, 5, 7})\n * 1\n */\nint f_44(const std::vector<int>& heights)", "arb": "#include <cassert>\n#include <algorithm>\n#include <vector>\n/**\n * بالنظر إلى مصفوفة تحتوي على n من الأعداد الصحيحة المميزة التي تمثل ارتفاعات أصدقاء كيرا،\n * ابحث عن عدد الطرق لاختيار ثلاثية (a, b, c) بحيث يكون القاسم المشترك الأكبر (GCD)\n * للقيمتين العظمى والصغرى في الثلاثية هو 1.\n * \n * مثال على الاستخدام:\n * >>> f_44({1, 5, 7})\n * 1\n */\nint f_44(const std::vector<int>& heights)", "sw": "#include <cassert>\n#include <algorithm>\n#include <vector>\n/**\n * Ukipewa safu ya n ya nambari tofauti zinazowakilisha urefu wa marafiki wa Kira, \n * pata idadi ya njia za kuchagua tatu (a, b, c) ili kwamba mgawanyiko mkubwa zaidi wa kawaida (GCD) \n * wa thamani za juu na za chini za tatu hiyo ni 1.\n * \n * Mfano wa matumizi:\n * >>> f_44({1, 5, 7})\n * 1\n */\nint f_44(const std::vector<int>& heights)", "tr": "#include <cassert>\n#include <algorithm>\n#include <vector>\n/**\n * Kira'nın arkadaşlarının yüksekliklerini temsil eden n farklı tamsayıdan oluşan bir dizi verildiğinde,\n * maksimum ve minimum değerlerinin en büyük ortak böleni (GCD) 1 olan bir üçlü (a, b, c) seçmenin\n * kaç farklı yolu olduğunu bulun.\n * \n * Örnek kullanım:\n * >>> f_44({1, 5, 7})\n * 1\n */\nint f_44(const std::vector<int>& heights)", "vi": "#include <cassert>\n#include <algorithm>\n#include <vector>\n/**\n * Cho một mảng gồm n số nguyên khác nhau đại diện cho chiều cao của bạn bè Kira,\n * tìm số cách chọn một bộ ba (a, b, c) sao cho ước số chung lớn nhất (GCD)\n * của giá trị lớn nhất và nhỏ nhất của bộ ba là 1.\n * \n * Ví dụ sử dụng:\n * >>> f_44({1, 5, 7})\n * 1\n */\nint f_44(const std::vector<int>& heights)", "id": "#include <cassert>\n#include <algorithm>\n#include <vector>\n/**\n * Diberikan sebuah array dari n bilangan bulat berbeda yang mewakili tinggi teman-teman Kira,\n * temukan jumlah cara untuk memilih triplet (a, b, c) sedemikian rupa sehingga pembagi terbesar\n * (GCD) dari nilai maksimum dan minimum triplet adalah 1.\n * \n * Contoh penggunaan:\n * >>> f_44({1, 5, 7})\n * 1\n */\nint f_44(const std::vector<int>& heights)", "ja": "#include <cassert>\n#include <algorithm>\n#include <vector>\n/**\n * Kiraの友達の身長を表すn個の異なる整数の配列が与えられたとき、\n * 三つ組 (a, b, c) を選ぶ方法の数を見つけます。その際、三つ組の最大値と最小値の最大公約数 (GCD) が1である必要があります。\n * \n * 使用例:\n * >>> f_44({1, 5, 7})\n * 1\n */\nint f_44(const std::vector<int>& heights)", "ko": "#include <cassert>\n#include <algorithm>\n#include <vector>\n/**\n * Kira의 친구들의 높이를 나타내는 n개의 서로 다른 정수 배열이 주어졌을 때, \n * 최대값과 최소값의 최대공약수(GCD)가 1인 세 개의 요소 (a, b, c)를 선택하는 방법의 수를 찾으시오.\n * \n * 사용 예:\n * >>> f_44({1, 5, 7})\n * 1\n */\nint f_44(const std::vector<int>& heights)", "ml": "#include <cassert>\n#include <algorithm>\n#include <vector>\n/**\n * കിരയുടെ സുഹൃത്തുക്കളുടെ ഉയരങ്ങളെ പ്രതിനിധീകരിക്കുന്ന n വ്യത്യസ്തമായ പൂർണ്ണസംഖ്യകളുടെ ഒരു നിര നൽകിയാൽ, \n * ത്രയീക (a, b, c) തിരഞ്ഞെടുക്കാനുള്ള മാർഗങ്ങളുടെ എണ്ണം കണ്ടെത്തുക, \n * അതിലെ പരമാവധി, കുറഞ്ഞ മൂല്യങ്ങളുടെ മഹത്തായ പൊതുവായ ഹരസാധകം (GCD) 1 ആകുന്നു.\n * \n * ഉദാഹരണ ഉപയോഗം:\n * >>> f_44({1, 5, 7})\n * 1\n */\nint f_44(const std::vector<int>& heights)", "fa": "#include <cassert>\n#include <algorithm>\n#include <vector>\n/**\n * با توجه به یک آرایه از n عدد صحیح متمایز که نشان‌دهنده ارتفاع دوستان کیرا هستند،\n * تعداد روش‌های انتخاب سه‌تایی (a, b, c) را بیابید به‌طوری‌که بزرگ‌ترین مقسوم‌علیه مشترک (GCD)\n * مقادیر حداکثر و حداقل سه‌تایی برابر با 1 باشد.\n * \n * مثال استفاده:\n * >>> f_44({1, 5, 7})\n * 1\n */\nint f_44(const std::vector<int>& heights)"}, "canonical_solution": "{\n    int count = 0;\n    int n = heights.size();\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = std::min({heights[i], heights[j], heights[k]});\n                int maxVal = std::max({heights[i], heights[j], heights[k]});\n                \n                // GCD algorithm\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                \n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}", "instruction": {"en": "Write a CPP function `int f_44(const std::vector<int>& heights)` to solve the following problem:\nGiven an array of n distinct integers representing the heights of Kira's friends, find the number of ways to choose a triplet (a, b, c) such that the greatest common divisor (GCD) of the maximum and minimum values of the triplet is 1.\n\nExample usage:\n>>> f_44({1, 5, 7})\n1", "sq": "Shkruani një funksion CPP `int f_44(const std::vector<int>& heights)` për të zgjidhur problemin e mëposhtëm:  \nDuke pasur një varg prej n numrash të plotë të ndryshëm që përfaqësojnë lartësitë e miqve të Kirës, gjeni numrin e mënyrave për të zgjedhur një treshe (a, b, c) të tillë që maksimumi dhe minimumi i vlerave të treshes të kenë përbashkëtësin më të madh (GCD) 1.\n\nShembull përdorimi:\n>>> f_44({1, 5, 7})\n1", "hy": "Գրեք CPP ֆունկցիա `int f_44(const std::vector<int>& heights)` հետևյալ խնդիրը լուծելու համար:\nՏրված է n տարբեր ամբողջ թվերի զանգված, որը ներկայացնում է Կիրայի ընկերների բարձրությունները, գտնել եռյակ (a, b, c) ընտրելու եղանակների քանակը այնպես, որ եռյակի առավելագույն և նվազագույն արժեքների ամենամեծ ընդհանուր բաժանարարը (GCD) լինի 1:\n\nՕրինակ օգտագործում:\n>>> f_44({1, 5, 7})\n1", "bn": "একটি CPP ফাংশন `int f_44(const std::vector<int>& heights)` লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\nকিরার বন্ধুদের উচ্চতা প্রতিনিধিত্বকারী n টি স্বতন্ত্র পূর্ণসংখ্যার একটি অ্যারে দেওয়া আছে, ট্রিপলেট (a, b, c) বেছে নেওয়ার উপায়ের সংখ্যা খুঁজে বের করুন যাতে ট্রিপলেটের সর্বাধিক এবং সর্বনিম্ন মানের গ্রেটেস্ট কমন ডিভাইজর (GCD) 1 হয়।\n\nউদাহরণ ব্যবহার:\n>>> f_44({1, 5, 7})\n1", "bg": "Напишете CPP функция `int f_44(const std::vector<int>& heights)`, за да решите следния проблем:  \nДаден е масив от n различни цели числа, представляващи височините на приятелите на Кира, намерете броя на начините за избор на тройка (a, b, c) така, че най-големият общ делител (НОД) на максималната и минималната стойност на тройката да е 1.", "zh": "编写一个 CPP 函数 `int f_44(const std::vector<int>& heights)` 来解决以下问题：  \n给定一个由 n 个不同整数组成的数组，表示 Kira 朋友的身高，找出选择一个三元组 (a, b, c) 的方法数，使得该三元组的最大值和最小值的最大公约数 (GCD) 为 1。\n\n示例用法：\n>>> f_44({1, 5, 7})\n1", "fr": "Écrire une fonction CPP `int f_44(const std::vector<int>& heights)` pour résoudre le problème suivant :  \nÉtant donné un tableau de n entiers distincts représentant les hauteurs des amis de Kira, trouvez le nombre de façons de choisir un triplet (a, b, c) tel que le plus grand commun diviseur (PGCD) des valeurs maximale et minimale du triplet soit 1.\n\nExemple d'utilisation :  \n>>> f_44({1, 5, 7})  \n1", "de": "Schreiben Sie eine CPP-Funktion `int f_44(const std::vector<int>& heights)`, um das folgende Problem zu lösen:\nGegeben ist ein Array von n verschiedenen ganzen Zahlen, die die Höhen von Kiras Freunden darstellen. Finden Sie die Anzahl der Möglichkeiten, ein Tripel (a, b, c) so zu wählen, dass der größte gemeinsame Teiler (GCD) der maximalen und minimalen Werte des Tripels 1 ist.\n\nBeispielverwendung:\n>>> f_44({1, 5, 7})\n1", "ha": "Rubuta aikin CPP `int f_44(const std::vector<int>& heights)` don warware matsalar mai zuwa:\nAn ba da wani tsari na lambobi daban-daban n da ke wakiltar tsayin abokan Kira, nemo adadin hanyoyin zaɓar triplet (a, b, c) ta yadda mafi girman abin da ya raba su (GCD) na mafi girma da mafi ƙanƙanta ƙimomin triplet ɗin ya zama 1.\n\nMisalin amfani:\n>>> f_44({1, 5, 7})\n1", "hi": "`int f_44(const std::vector<int>& heights)` नामक एक CPP फ़ंक्शन लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nकिरा के दोस्तों की ऊँचाइयों का प्रतिनिधित्व करने वाले n भिन्न पूर्णांकों की एक array दी गई है, ऐसे triplet (a, b, c) चुनने के तरीकों की संख्या ज्ञात करें ताकि triplet के अधिकतम और न्यूनतम मानों का महत्तम समापवर्तक (GCD) 1 हो।\n\nउदाहरण उपयोग:\n>>> f_44({1, 5, 7})\n1", "hu": "Írj egy CPP függvényt `int f_44(const std::vector<int>& heights)` a következő probléma megoldására:  \nAdott egy n különböző egész számot tartalmazó tömb, amely Kira barátainak magasságát jelképezi. Találd meg, hányféleképpen lehet kiválasztani egy hármast (a, b, c) úgy, hogy a hármas legnagyobb és legkisebb értékének legnagyobb közös osztója (GCD) 1 legyen.\n\nPélda használat:\n>>> f_44({1, 5, 7})\n1", "es": "Escribe una función CPP `int f_44(const std::vector<int>& heights)` para resolver el siguiente problema:\nDado un array de n enteros distintos que representan las alturas de los amigos de Kira, encuentra el número de formas de elegir un triplete (a, b, c) tal que el máximo común divisor (GCD) de los valores máximo y mínimo del triplete sea 1.\n\nEjemplo de uso:\n>>> f_44({1, 5, 7})\n1", "arb": "اكتب دالة CPP `int f_44(const std::vector<int>& heights)` لحل المشكلة التالية:\nبالنظر إلى مصفوفة تحتوي على n عدد صحيح مميز تمثل ارتفاعات أصدقاء كيرا، أوجد عدد الطرق لاختيار ثلاثية (a، b، c) بحيث يكون القاسم المشترك الأكبر (GCD) للقيمتين العظمى والصغرى في الثلاثية هو 1.\n\nمثال على الاستخدام:\n>>> f_44({1, 5, 7})\n1", "sw": "Andika kazi ya CPP `int f_44(const std::vector<int>& heights)` kutatua tatizo lifuatalo:  \nUkipiwa safu ya n ya nambari tofauti zinazoashiria urefu wa marafiki wa Kira, pata idadi ya njia za kuchagua tatu (a, b, c) kama vile mgawanyiko mkubwa zaidi (GCD) wa thamani ya juu na ya chini ya tatu ni 1.\n\nMfano wa matumizi:  \n>>> f_44({1, 5, 7})  \n1", "tr": "Bir CPP fonksiyonu `int f_44(const std::vector<int>& heights)` yazın ve aşağıdaki problemi çözün:\nKira'nın arkadaşlarının yüksekliklerini temsil eden n farklı tam sayıdan oluşan bir dizi verildiğinde, maksimum ve minimum değerlerinin en büyük ortak böleni (GCD) 1 olan bir üçlü (a, b, c) seçmenin kaç yolu olduğunu bulun.\n\nÖrnek kullanım:\n>>> f_44({1, 5, 7})\n1", "vi": "Viết một hàm CPP `int f_44(const std::vector<int>& heights)` để giải quyết vấn đề sau:  \nCho một mảng gồm n số nguyên khác nhau đại diện cho chiều cao của bạn bè Kira, tìm số cách chọn một bộ ba (a, b, c) sao cho ước số chung lớn nhất (GCD) của giá trị lớn nhất và nhỏ nhất của bộ ba là 1.\n\nVí dụ sử dụng:  \n>>> f_44({1, 5, 7})  \n1", "id": "Tulis fungsi CPP `int f_44(const std::vector<int>& heights)` untuk menyelesaikan masalah berikut:\nDiberikan sebuah array dari n bilangan bulat berbeda yang mewakili tinggi teman-teman Kira, temukan jumlah cara untuk memilih triplet (a, b, c) sedemikian rupa sehingga pembagi terbesar (GCD) dari nilai maksimum dan minimum triplet tersebut adalah 1.\n\nContoh penggunaan:\n>>> f_44({1, 5, 7})\n1", "ja": "`int f_44(const std::vector<int>& heights)`というCPP関数を書いて、次の問題を解決してください。  \nKiraの友人の身長を表すn個の異なる整数の配列が与えられたとき、トリプレット(a, b, c)を選ぶ方法の数を見つけてください。そのトリプレットの最大値と最小値の最大公約数(GCD)が1であるようにします。\n\n使用例:\n>>> f_44({1, 5, 7})\n1", "ko": "다음 문제를 해결하기 위해 CPP 함수를 작성하세요 `int f_44(const std::vector<int>& heights)`:\nKira의 친구들의 키를 나타내는 n개의 서로 다른 정수 배열이 주어졌을 때, 최대값과 최소값의 최대 공약수(GCD)가 1인 세 쌍 (a, b, c)을 선택하는 방법의 수를 찾으세요.\n\n사용 예시:\n>>> f_44({1, 5, 7})\n1", "ml": "`int f_44(const std::vector<int>& heights)` എന്ന CPP ഫംഗ്ഷൻ എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nകിരയുടെ സുഹൃത്തുക്കളുടെ ഉയരങ്ങളെ പ്രതിനിധീകരിക്കുന്ന n വ്യത്യസ്ത പൂർണ്ണസംഖ്യകളുടെ ഒരു നിര നൽകിയിരിക്കുന്നു, ട്രിപ്പ്ലെറ്റ് (a, b, c) തിരഞ്ഞെടുക്കാനുള്ള മാർഗങ്ങളുടെ എണ്ണം കണ്ടെത്തുക, അങ്ങനെ ട്രിപ്പ്ലെറ്റിന്റെ പരമാവധി, കുറഞ്ഞ മൂല്യങ്ങളുടെ മഹത്തായ പൊതുഹരവും (GCD) 1 ആകുന്നു.\n\nഉദാഹരണ ഉപയോഗം:\n>>> f_44({1, 5, 7})\n1", "fa": "تابعی به زبان CPP بنویسید `int f_44(const std::vector<int>& heights)` برای حل مسئله زیر:\nبا توجه به آرایه‌ای از n عدد صحیح متمایز که نمایانگر قد دوستان کیرا هستند، تعداد راه‌هایی را بیابید که بتوان یک سه‌تایی (a, b, c) انتخاب کرد به‌طوری‌که بزرگ‌ترین مقسوم‌علیه مشترک (GCD) بزرگ‌ترین و کوچک‌ترین مقادیر سه‌تایی برابر با 1 باشد.\n\nمثال استفاده:\n>>> f_44({1, 5, 7})\n1"}, "level": "hard", "test": "int main() {\n    assert(f_44({1, 5, 7}) == 1);\n    assert(f_44({1, 6, 2, 3}) == 3);\n    assert(f_44({16, 4, 8, 2}) == 0);\n    assert(f_44({10, 1, 6, 7, 9, 8, 4, 3, 5, 2}) == 77);\n    assert(f_44({4, 5, 9, 11, 14}) == 7);\n    assert(f_44({15, 10, 6, 9, 7, 3, 12, 8, 11, 1, 2}) == 104);\n    assert(f_44({3, 7, 11, 13}) == 4);\n    assert(f_44({5, 12, 13, 17, 19}) == 10);\n    assert(f_44({2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}) == 87);\n    assert(f_44({1, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17}) == 122);\n\n    return 0;\n}", "entry_point": "f_44", "signature": "int f_44(const std::vector<int>& heights)", "docstring": {"en": "Given an array of n distinct integers representing the heights of Kira's friends, find the number of ways to choose a triplet (a, b, c) such that the greatest common divisor (GCD) of the maximum and minimum values of the triplet is 1.\n\nExample usage:\n>>> f_44({1, 5, 7})\n1", "sq": "Jepet një varg me n numra të plotë të dallueshëm që përfaqësojnë lartësitë e miqve të Kirës, gjeni numrin e mënyrave për të zgjedhur një treshe (a, b, c) të tillë që faktori më i madh i përbashkët (GCD) i vlerave maksimale dhe minimale të treshes të jetë 1.\n\nShembull përdorimi:\n>>> f_44({1, 5, 7})\n1", "hy": "Տրված է n տարբեր ամբողջ թվերի զանգված, որոնք ներկայացնում են Կիրայի ընկերների բարձրությունները, գտնել եղանակների քանակը, որպեսզի ընտրել եռյակ (a, b, c), այնպես, որ եռյակի առավելագույն և նվազագույն արժեքների ամենամեծ ընդհանուր բաժանարարը (GCD) լինի 1:\n\nՕրինակ օգտագործում:\n>>> f_44({1, 5, 7})\n1", "bn": "একটি n ভিন্ন পূর্ণসংখ্যার অ্যারে দেওয়া হয়েছে যা কিরার বন্ধুদের উচ্চতা উপস্থাপন করে, ট্রিপলেট (a, b, c) বেছে নেওয়ার উপায়ের সংখ্যা খুঁজুন যাতে ট্রিপলেটের সর্বাধিক এবং সর্বনিম্ন মানের গ্রেটেস্ট কমন ডিভাইসার (GCD) 1 হয়।\n\nব্যবহারের উদাহরণ:\n>>> f_44({1, 5, 7})\n1", "bg": "Даден е масив от n различни цели числа, представляващи височините на приятелите на Кира, намерете броя на начините да изберете тройка (a, b, c) така, че най-големият общ делител (НОД) на максималната и минималната стойност на тройката да е 1.\n\nПример за използване:\n>>> f_44({1, 5, 7})\n1", "zh": "给定一个由 n 个不同整数组成的数组，表示 Kira 的朋友的身高，找出选择一个三元组 (a, b, c) 的方法数，使得该三元组的最大值和最小值的最大公约数 (GCD) 为 1。\n\n示例用法：\n>>> f_44({1, 5, 7})\n1", "fr": "Étant donné un tableau de n entiers distincts représentant les hauteurs des amis de Kira, trouver le nombre de façons de choisir un triplet (a, b, c) tel que le plus grand commun diviseur (PGCD) des valeurs maximale et minimale du triplet soit 1.\n\nExemple d'utilisation :\n>>> f_44({1, 5, 7})\n1", "de": "Gegeben ein Array von n verschiedenen ganzen Zahlen, die die Höhen von Kiras Freunden darstellen, finde die Anzahl der Möglichkeiten, ein Tripel (a, b, c) so zu wählen, dass der größte gemeinsame Teiler (GCD) der maximalen und minimalen Werte des Tripels 1 ist.\n\nBeispielverwendung:\n>>> f_44({1, 5, 7})\n1", "ha": "An ba da wani tsari na lambobi daban-daban n da ke wakiltar tsayin abokai na Kira, nemo adadin hanyoyin da za a zaɓi triplet (a, b, c) ta yadda mafi girman raba mai yawa (GCD) na mafi girma da ƙananan ƙimomi na triplet ɗin ya zama 1.\n\nMisalin amfani:\n>>> f_44({1, 5, 7})\n1", "hi": "n अद्वितीय पूर्णांकों की एक array दी गई है जो कि किरा के दोस्तों की ऊँचाई का प्रतिनिधित्व करती है, उन तरीकों की संख्या खोजें जिनसे एक त्रिक (a, b, c) चुना जा सके ताकि त्रिक के अधिकतम और न्यूनतम मानों का महत्तम समापवर्तक (GCD) 1 हो।\n\nउदाहरण उपयोग:\n>>> f_44({1, 5, 7})\n1", "hu": "Egy n különböző egész számot tartalmazó tömböt kapunk, amely Kira barátainak magasságát jelképezi. Meg kell találni, hányféleképpen lehet kiválasztani egy hármast (a, b, c) úgy, hogy a hármas maximumának és minimumának legnagyobb közös osztója (GCD) 1 legyen.\n\nPélda használat:\n>>> f_44({1, 5, 7})\n1", "es": "Dado un array de n enteros distintos que representan las alturas de los amigos de Kira, encuentra el número de formas de elegir un triplete (a, b, c) tal que el máximo común divisor (MCD) de los valores máximo y mínimo del triplete sea 1.\n\nEjemplo de uso:\n>>> f_44({1, 5, 7})\n1", "arb": "نظرًا لمصفوفة تحتوي على n من الأعداد الصحيحة المميزة التي تمثل أطوال أصدقاء كيرا، ابحث عن عدد الطرق لاختيار ثلاثية (a, b, c) بحيث يكون القاسم المشترك الأكبر (GCD) للقيمتين العظمى والصغرى في الثلاثية هو 1.\n\nاستخدام المثال:\n>>> f_44({1, 5, 7})\n1", "sw": "Ukipewa safu ya n ya nambari tofauti zinazowakilisha urefu wa marafiki wa Kira, tafuta idadi ya njia za kuchagua triplet (a, b, c) ili kwamba mgawanyiko wa kawaida mkubwa (GCD) wa thamani za juu na chini za triplet ni 1.\n\nMfano wa matumizi:\n>>> f_44({1, 5, 7})\n1", "tr": "Verilen n farklı tam sayıdan oluşan bir dizi, Kira'nın arkadaşlarının boylarını temsil etmektedir. Maksimum ve minimum değerlerinin en büyük ortak böleni (EBOB) 1 olan bir üçlü (a, b, c) seçmenin kaç yolu olduğunu bulun.\n\nÖrnek kullanım:\n>>> f_44({1, 5, 7})\n1", "vi": "Cho một mảng gồm n số nguyên khác nhau đại diện cho chiều cao của bạn bè Kira, tìm số cách để chọn một bộ ba (a, b, c) sao cho ước số chung lớn nhất (GCD) của giá trị lớn nhất và nhỏ nhất của bộ ba là 1.\n\nVí dụ sử dụng:\n>>> f_44({1, 5, 7})\n1", "id": "Diberikan sebuah array dari n bilangan bulat berbeda yang mewakili tinggi teman-teman Kira, temukan jumlah cara untuk memilih triplet (a, b, c) sedemikian rupa sehingga pembagi terbesar (GCD) dari nilai maksimum dan minimum dari triplet tersebut adalah 1.\n\nPenggunaan contoh:\n>>> f_44({1, 5, 7})\n1", "ja": "配列に含まれる n 個の異なる整数は、キラの友人たちの身長を表しています。この配列から 3 つの要素 (a, b, c) を選び、その最大値と最小値の最大公約数 (GCD) が 1 であるような選び方の数を求めます。\n\n使用例:\n>>> f_44({1, 5, 7})\n1", "ko": "주어진 n개의 서로 다른 정수 배열이 Kira의 친구들의 키를 나타낼 때, 최대값과 최소값의 최대공약수(GCD)가 1이 되는 삼중항 (a, b, c)을 선택하는 방법의 수를 찾습니다.\n\n사용 예:\n>>> f_44({1, 5, 7})\n1", "ml": "കിരയുടെ സുഹൃത്തുക്കളുടെ ഉയരങ്ങളെ പ്രതിനിധീകരിക്കുന്ന n വ്യത്യസ്തമായ പൂർണ്ണസംഖ്യകളുടെ ഒരു നിര നൽകിയാൽ, \n * ത്രയീക (a, b, c) തിരഞ്ഞെടുക്കാനുള്ള മാർഗങ്ങളുടെ എണ്ണം കണ്ടെത്തുക, \n * അതിലെ പരമാവധി, കുറഞ്ഞ മൂല്യങ്ങളുടെ മഹത്തായ പൊതുവായ ഹരസാധകം (GCD) 1 ആകുന്നു.\n\nഉദാഹരണ ഉപയോഗം:\n>>> f_44({1, 5, 7})\n1", "fa": "با توجه به آرایه‌ای از n عدد صحیح متمایز که نشان‌دهنده قد دوستان کیرا هستند، تعداد راه‌های انتخاب یک سه‌تایی (a, b, c) را بیابید به‌طوری‌که بزرگ‌ترین مقسوم‌علیه مشترک (GCD) مقادیر حداکثر و حداقل سه‌تایی برابر با 1 باشد.\n\nمثال استفاده:\n>>> f_44({1, 5, 7})\n1"}}
{"task_id": "CPP/45", "prompt": {"en": "#include <cassert>\n#include <cstdio>\n/**\n * You are given a 1 by n pixel image, where each pixel has a color \n * represented by an integer. You can perform an operation where you \n * pick a color and change all connected pixels of the same color to \n * the chosen color. Two pixels are connected if they are adjacent \n * and have the same color. Find the minimum number of operations \n * required to make all pixels the same color.\n *\n * Note: For each color, there are at most 20 pixels of that color.\n *\n * Examples:\n *   f_45(5, {1, 2, 3, 2, 1}) -> 2\n */\nint f_45(int n, int* pixels)", "sq": "#include <cassert>\n#include <cstdio>\n/**\n * Ju jepet një imazh 1 me n pikselë, ku secili piksel ka një ngjyrë\n * të përfaqësuar nga një numër i plotë. Ju mund të kryeni një operacion ku\n * zgjidhni një ngjyrë dhe ndryshoni të gjithë pikselët e lidhur të së njëjtës ngjyrë\n * në ngjyrën e zgjedhur. Dy pikselë janë të lidhur nëse janë ngjitur\n * dhe kanë të njëjtën ngjyrë. Gjeni numrin minimal të operacioneve\n * të kërkuara për t'i bërë të gjithë pikselët të së njëjtës ngjyrë.\n *\n * Shënim: Për çdo ngjyrë, ka maksimumi 20 pikselë të asaj ngjyre.\n *\n * Shembuj:\n *   f_45(5, {1, 2, 3, 2, 1}) -> 2\n */\nint f_45(int n, int* pixels)", "hy": "#include <cassert>\n#include <cstdio>\n/**\n * Ձեզ տրված է 1x n պիքսել պատկեր, որտեղ յուրաքանչյուր պիքսել ունի գույն, \n * որը ներկայացված է ամբողջ թվով: Դուք կարող եք կատարել գործողություն, \n * որտեղ ընտրում եք գույն և փոխում նույն գույնի բոլոր միացված պիքսելները \n * ընտրված գույնով: Երկու պիքսելները միացված են, եթե նրանք հարակից են \n * և ունեն նույն գույնը: Գտեք նվազագույն գործողությունների քանակը, \n * որը պահանջվում է բոլոր պիքսելները նույն գույնի դարձնելու համար:\n *\n * Նշում: Յուրաքանչյուր գույնի համար առավելագույնը կա 20 պիքսել:\n *\n * Օրինակներ:\n *   f_45(5, {1, 2, 3, 2, 1}) -> 2\n */\nint f_45(int n, int* pixels)", "bn": "#include <cassert>\n#include <cstdio>\n/**\n * আপনাকে একটি 1 বাই n পিক্সেল ইমেজ দেওয়া হয়েছে, যেখানে প্রতিটি পিক্সেলের একটি রঙ \n * একটি পূর্ণসংখ্যা দ্বারা উপস্থাপিত হয়। আপনি একটি অপারেশন সম্পাদন করতে পারেন যেখানে আপনি \n * একটি রঙ বেছে নেন এবং একই রঙের সমস্ত সংযুক্ত পিক্সেলগুলি \n * নির্বাচিত রঙে পরিবর্তন করেন। দুটি পিক্সেল সংযুক্ত যদি তারা সংলগ্ন হয় \n * এবং একই রঙের হয়। সমস্ত পিক্সেলকে একই রঙে করতে \n * প্রয়োজনীয় সর্বনিম্ন অপারেশন সংখ্যা খুঁজুন।\n *\n * নোট: প্রতিটি রঙের জন্য, সেই রঙের সর্বাধিক 20টি পিক্সেল রয়েছে।\n *\n * উদাহরণ:\n *   f_45(5, {1, 2, 3, 2, 1}) -> 2\n */\nint f_45(int n, int* pixels)", "bg": "#include <cassert>\n#include <cstdio>\n/**\n * Дадено е изображение с размер 1 на n пиксела, където всеки пиксел има цвят,\n * представен чрез цяло число. Можете да извършите операция, при която \n * избирате цвят и променяте всички свързани пиксели със същия цвят на \n * избрания цвят. Два пиксела са свързани, ако са съседни и имат същия цвят.\n * Намерете минималния брой операции, необходими, за да направите всички \n * пиксели с един и същ цвят.\n *\n * Забележка: За всеки цвят има най-много 20 пиксела с този цвят.\n *\n * Примери:\n *   f_45(5, {1, 2, 3, 2, 1}) -> 2\n */\nint f_45(int n, int* pixels)", "zh": "#include <cassert>\n#include <cstdio>\n/**\n * 给定一个 1 x n 像素的图像，其中每个像素的颜色由一个整数表示。你可以执行一个操作，选择一种颜色并将所有相同颜色的相连像素更改为所选颜色。如果两个像素相邻并且具有相同的颜色，则它们是相连的。找出使所有像素颜色相同所需的最小操作次数。\n *\n * 注意：对于每种颜色，最多有 20 个该颜色的像素。\n *\n * 示例:\n *   f_45(5, {1, 2, 3, 2, 1}) -> 2\n */\nint f_45(int n, int* pixels)", "fr": "#include <cassert>\n#include <cstdio>\n/**\n * Vous avez une image de 1 par n pixels, où chaque pixel a une couleur \n * représentée par un entier. Vous pouvez effectuer une opération où vous \n * choisissez une couleur et changez tous les pixels connectés de la même \n * couleur à la couleur choisie. Deux pixels sont connectés s'ils sont adjacents \n * et ont la même couleur. Trouvez le nombre minimum d'opérations \n * nécessaires pour que tous les pixels aient la même couleur.\n *\n * Remarque : Pour chaque couleur, il y a au plus 20 pixels de cette couleur.\n *\n * Exemples :\n *   f_45(5, {1, 2, 3, 2, 1}) -> 2\n */\nint f_45(int n, int* pixels)", "de": "#include <cassert>\n#include <cstdio>\n/**\n * Sie haben ein 1x n Pixel-Bild, wobei jedes Pixel eine Farbe hat, \n * die durch eine ganze Zahl dargestellt wird. Sie können eine \n * Operation durchführen, bei der Sie eine Farbe auswählen und alle \n * verbundenen Pixel derselben Farbe in die gewählte Farbe ändern. \n * Zwei Pixel sind verbunden, wenn sie benachbart sind und dieselbe \n * Farbe haben. Finden Sie die minimale Anzahl von Operationen, die \n * erforderlich sind, um alle Pixel in dieselbe Farbe zu ändern.\n *\n * Hinweis: Für jede Farbe gibt es höchstens 20 Pixel dieser Farbe.\n *\n * Beispiele:\n *   f_45(5, {1, 2, 3, 2, 1}) -> 2\n */\nint f_45(int n, int* pixels)", "ha": "#include <cassert>\n#include <cstdio>\n/**\n * An ba ku hoto na pixel 1 ta n, inda kowanne pixel yana da launi \n * wanda aka wakilta da lamba. Kuna iya aiwatar da aiki inda za ku \n * zaɓi launi kuma ku canza duk pixels masu haɗin kai na wannan launi \n * zuwa launin da aka zaɓa. Ana haɗa pixels biyu idan suna makwabtaka \n * kuma suna da launi ɗaya. Nemo mafi ƙarancin adadin ayyuka da ake \n * buƙata don sanya duk pixels su zama launi ɗaya.\n *\n * Lura: Ga kowane launi, akwai a kalla pixels 20 na wannan launi.\n *\n * Misalai:\n *   f_45(5, {1, 2, 3, 2, 1}) -> 2\n */\nint f_45(int n, int* pixels)", "hi": "#include <cassert>\n#include <cstdio>\n/**\n * आपको एक 1 बाय n पिक्सल छवि दी गई है, जहां प्रत्येक पिक्सल का रंग \n * एक पूर्णांक द्वारा दर्शाया गया है। आप एक ऑपरेशन कर सकते हैं जहां आप \n * एक रंग चुनते हैं और उसी रंग के सभी जुड़े पिक्सल्स को चुने गए रंग में \n * बदल देते हैं। दो पिक्सल जुड़े हुए होते हैं यदि वे आसन्न होते हैं और \n * उनका रंग समान होता है। सभी पिक्सल्स को एक ही रंग में बदलने के लिए \n * आवश्यक न्यूनतम ऑपरेशनों की संख्या ज्ञात करें।\n *\n * ध्यान दें: प्रत्येक रंग के लिए, उस रंग के अधिकतम 20 पिक्सल होते हैं।\n *\n * उदाहरण:\n *   f_45(5, {1, 2, 3, 2, 1}) -> 2\n */\nint f_45(int n, int* pixels)", "hu": "#include <cassert>\n#include <cstdio>\n/**\n * Adott egy 1 x n pixeles kép, ahol minden pixel színe egy egész \n * számmal van ábrázolva. Végrehajthatsz egy műveletet, amely során \n * kiválasztasz egy színt, és az összes összekapcsolt, azonos színű \n * pixelt megváltoztatod a választott színre. Két pixel akkor \n * kapcsolódik egymáshoz, ha szomszédosak és azonos színűek. Találd \n * meg a minimális műveletek számát, amely szükséges ahhoz, hogy \n * minden pixel azonos színű legyen.\n *\n * Megjegyzés: Minden színhez legfeljebb 20 pixel tartozik.\n *\n * Példák:\n *   f_45(5, {1, 2, 3, 2, 1}) -> 2\n */\nint f_45(int n, int* pixels)", "es": "#include <cassert>\n#include <cstdio>\n/**\n * Se te da una imagen de 1 por n píxeles, donde cada píxel tiene un color \n * representado por un entero. Puedes realizar una operación donde \n * eliges un color y cambias todos los píxeles conectados del mismo color \n * al color elegido. Dos píxeles están conectados si son adyacentes \n * y tienen el mismo color. Encuentra el número mínimo de operaciones \n * requeridas para hacer que todos los píxeles sean del mismo color.\n *\n * Nota: Para cada color, hay como máximo 20 píxeles de ese color.\n *\n * Ejemplos:\n *   f_45(5, {1, 2, 3, 2, 1}) -> 2\n */\nint f_45(int n, int* pixels)", "arb": "#include <cassert>\n#include <cstdio>\n/**\n * لديك صورة مكونة من 1 بكسل في n، حيث يتم تمثيل كل بكسل بلون \n * ممثل برقم صحيح. يمكنك إجراء عملية حيث تختار لونًا وتغير جميع \n * البكسلات المتصلة من نفس اللون إلى اللون المختار. يعتبر بكسلان \n * متصلان إذا كانا متجاورين ولهما نفس اللون. جد الحد الأدنى لعدد \n * العمليات المطلوبة لجعل جميع البكسلات بنفس اللون.\n *\n * ملاحظة: لكل لون، هناك بحد أقصى 20 بكسل من ذلك اللون.\n *\n * أمثلة:\n *   f_45(5, {1, 2, 3, 2, 1}) -> 2\n */\nint f_45(int n, int* pixels)", "sw": "#include <cassert>\n#include <cstdio>\n/**\n * Umepewa picha ya pikseli 1 kwa n, ambapo kila pikseli ina rangi \n * inayowakilishwa na nambari nzima. Unaweza kufanya operesheni ambapo \n * unachagua rangi na kubadilisha pikseli zote zilizounganishwa za rangi \n * sawa kuwa rangi iliyochaguliwa. Pikseli mbili zimeunganishwa ikiwa \n * ziko karibu na zina rangi sawa. Pata idadi ndogo ya operesheni \n * zinazohitajika kufanya pikseli zote ziwe na rangi sawa.\n *\n * Kumbuka: Kwa kila rangi, kuna pikseli zisizozidi 20 za rangi hiyo.\n *\n * Mifano:\n *   f_45(5, {1, 2, 3, 2, 1}) -> 2\n */\nint f_45(int n, int* pixels)", "tr": "#include <cassert>\n#include <cstdio>\n/**\n * 1'e n piksel boyutunda bir görüntü verilir, burada her piksel bir \n * tamsayı ile temsil edilen bir renge sahiptir. Bir renk seçip aynı \n * renkteki tüm bağlı pikselleri seçilen renge değiştirebileceğiniz \n * bir işlem gerçekleştirebilirsiniz. İki piksel, bitişik ve aynı renkte \n * ise bağlıdır. Tüm pikselleri aynı renkte yapmak için gereken minimum \n * işlem sayısını bulun.\n *\n * Not: Her renk için en fazla 20 piksel vardır.\n *\n * Örnekler:\n *   f_45(5, {1, 2, 3, 2, 1}) -> 2\n */\nint f_45(int n, int* pixels)", "vi": "#include <cassert>\n#include <cstdio>\n/**\n * Bạn được cung cấp một hình ảnh 1 x n pixel, trong đó mỗi pixel có một màu \n * được biểu diễn bằng một số nguyên. Bạn có thể thực hiện một thao tác trong đó bạn \n * chọn một màu và thay đổi tất cả các pixel kết nối có cùng màu thành \n * màu đã chọn. Hai pixel được kết nối nếu chúng liền kề \n * và có cùng màu. Tìm số lượng thao tác tối thiểu \n * cần thiết để làm cho tất cả các pixel có cùng màu.\n *\n * Lưu ý: Đối với mỗi màu, có tối đa 20 pixel của màu đó.\n *\n * Ví dụ:\n *   f_45(5, {1, 2, 3, 2, 1}) -> 2\n */\nint f_45(int n, int* pixels)", "id": "#include <cassert>\n#include <cstdio>\n/**\n * Anda diberikan gambar 1 x n piksel, di mana setiap piksel memiliki warna \n * yang diwakili oleh sebuah bilangan bulat. Anda dapat melakukan operasi \n * di mana Anda memilih sebuah warna dan mengubah semua piksel yang terhubung \n * dengan warna yang sama menjadi warna yang dipilih. Dua piksel terhubung \n * jika mereka bersebelahan dan memiliki warna yang sama. Temukan jumlah \n * operasi minimum yang diperlukan untuk membuat semua piksel memiliki warna yang sama.\n *\n * Catatan: Untuk setiap warna, ada paling banyak 20 piksel dengan warna tersebut.\n *\n * Contoh:\n *   f_45(5, {1, 2, 3, 2, 1}) -> 2\n */\nint f_45(int n, int* pixels)", "ja": "#include <cassert>\n#include <cstdio>\n/**\n * あなたは1行n列のピクセル画像を与えられます。各ピクセルは整数で表される色を持っています。\n * あなたは色を選び、同じ色の連結したピクセルを選んだ色に変える操作を行うことができます。\n * 2つのピクセルは隣接していて同じ色である場合に連結しています。\n * すべてのピクセルを同じ色にするために必要な最小の操作回数を求めてください。\n *\n * 注意: 各色について、その色のピクセルは最大で20個です。\n *\n * 例:\n *   f_45(5, {1, 2, 3, 2, 1}) -> 2\n */\nint f_45(int n, int* pixels)", "ko": "#include <cassert>\n#include <cstdio>\n/**\n * 1 by n 픽셀 이미지가 주어지며, 각 픽셀은 정수로 표현된 색상을 가지고 있습니다. \n * 색상을 선택하여 동일한 색상의 연결된 모든 픽셀을 선택한 색상으로 변경하는 \n * 작업을 수행할 수 있습니다. 두 픽셀이 연결되었다는 것은 인접해 있고 \n * 동일한 색상을 가진 경우입니다. 모든 픽셀이 동일한 색상이 되도록 하는 데 \n * 필요한 최소 작업 수를 찾으십시오.\n *\n * 참고: 각 색상에 대해 해당 색상의 픽셀이 최대 20개 있습니다.\n *\n * 예시:\n *   f_45(5, {1, 2, 3, 2, 1}) -> 2\n */\nint f_45(int n, int* pixels)", "ml": "#include <cassert>\n#include <cstdio>\n/**\n * നിങ്ങൾക്ക് 1 ബൈ n പിക്സൽ ഇമേജ് നൽകിയിരിക്കുന്നു, ഇവിടെ ഓരോ പിക്സലിനും \n * ഒരു പൂർണ്ണസംഖ്യയാൽ പ്രതിനിധാനം ചെയ്യുന്ന ഒരു നിറം ഉണ്ട്. നിങ്ങൾക്ക് ഒരു \n * നിറം തിരഞ്ഞെടുക്കുകയും ആ നിറത്തിലുള്ള എല്ലാ ബന്ധിപ്പിച്ചിരിക്കുന്ന \n * പിക്സലുകളെയും തിരഞ്ഞെടുത്ത നിറത്തിലേക്ക് മാറ്റുകയും ചെയ്യാം. \n * രണ്ട് പിക്സലുകൾ ബന്ധിപ്പിക്കപ്പെട്ടിരിക്കുന്നു എന്നത് അദ്ജസന്റ് ആയിട്ടും \n * ഒരേ നിറമുള്ളതുമാണ്. എല്ലാ പിക്സലുകളും ഒരേ നിറത്തിലാക്കാൻ ആവശ്യമായ \n * കുറഞ്ഞ പ്രവർത്തനങ്ങളുടെ എണ്ണം കണ്ടെത്തുക.\n *\n * കുറിപ്പ്: ഓരോ നിറത്തിനും ആ നിറത്തിലുള്ള പരമാവധി 20 പിക്സലുകൾ മാത്രമേ \n * ഉണ്ടാകൂ.\n *\n * ഉദാഹരണങ്ങൾ:\n *   f_45(5, {1, 2, 3, 2, 1}) -> 2\n */\nint f_45(int n, int* pixels)", "fa": "#include <cassert>\n#include <cstdio>\n/**\n * شما یک تصویر 1 در n پیکسلی دارید که هر پیکسل دارای رنگی است که \n * با یک عدد صحیح نمایش داده می‌شود. شما می‌توانید عملیاتی انجام دهید \n * که در آن یک رنگ را انتخاب کرده و تمام پیکسل‌های متصل با همان رنگ \n * را به رنگ انتخاب شده تغییر دهید. دو پیکسل متصل هستند اگر مجاور \n * باشند و رنگ یکسانی داشته باشند. حداقل تعداد عملیات مورد نیاز \n * برای یکسان کردن رنگ تمام پیکسل‌ها را پیدا کنید.\n *\n * توجه: برای هر رنگ، حداکثر 20 پیکسل از آن رنگ وجود دارد.\n *\n * مثال‌ها:\n *   f_45(5, {1, 2, 3, 2, 1}) -> 2\n */\nint f_45(int n, int* pixels)"}, "canonical_solution": "{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}", "instruction": {"en": "Write a CPP function `int f_45(int n, int* pixels)` to solve the following problem:\nYou are given a 1 by n pixel image, where each pixel has a color represented by an integer. You can perform an operation where you pick a color and change all connected pixels of the same color to the chosen color. Two pixels are connected if they are adjacent and have the same color. Find the minimum number of operations required to make all pixels the same color.\n\nNote: For each color, there are at most 20 pixels of that color.\n\nExamples:\n  f_45(5, {1, 2, 3, 2, 1}) -> 2\n", "sq": "Shkruani një funksion CPP `int f_45(int n, int* pixels)` për të zgjidhur problemin e mëposhtëm:\nJu jepet një imazh 1 me n pikselë, ku secili piksel ka një ngjyrë të përfaqësuar nga një numër i plotë. Ju mund të kryeni një operacion ku zgjidhni një ngjyrë dhe ndryshoni të gjithë pikselët e lidhur të së njëjtës ngjyrë në ngjyrën e zgjedhur. Dy pikselë janë të lidhur nëse janë ngjitur dhe kanë të njëjtën ngjyrë. Gjeni numrin minimal të operacioneve të kërkuara për të bërë që të gjithë pikselët të kenë të njëjtën ngjyrë.\n\nShënim: Për çdo ngjyrë, ka maksimumi 20 pikselë të asaj ngjyre.\n\nShembuj:\n  f_45(5, {1, 2, 3, 2, 1}) -> 2", "hy": "Գրեք CPP ֆունկցիա `int f_45(int n, int* pixels)`՝ լուծելու հետևյալ խնդիրը:\nՁեզ տրված է 1x n պիքսել պատկեր, որտեղ յուրաքանչյուր պիքսել ունի գույն, որը ներկայացված է ամբողջ թվով: Դուք կարող եք կատարել գործողություն, որտեղ ընտրում եք գույն և փոխում նույն գույնի բոլոր միացված պիքսելները ընտրված գույնով: Երկու պիքսել միացված են, եթե նրանք հարակից են և ունեն նույն գույնը: Գտեք նվազագույն գործողությունների քանակը, որը պահանջվում է բոլոր պիքսելները նույն գույնի դարձնելու համար:\n\nՆշում: Յուրաքանչյուր գույնի համար առավելագույնը կա 20 պիքսել:\n\nՕրինակներ:\n  f_45(5, {1, 2, 3, 2, 1}) -> 2", "bn": "একটি CPP ফাংশন `int f_45(int n, int* pixels)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nআপনাকে একটি 1 বাই n পিক্সেল ইমেজ দেওয়া হয়েছে, যেখানে প্রতিটি পিক্সেলের একটি রঙ একটি পূর্ণসংখ্যা দ্বারা প্রতিনিধিত্ব করা হয়। আপনি একটি অপারেশন সম্পাদন করতে পারেন যেখানে আপনি একটি রঙ বেছে নেন এবং একই রঙের সংযুক্ত সমস্ত পিক্সেলগুলি নির্বাচিত রঙে পরিবর্তন করেন। দুটি পিক্সেল সংযুক্ত থাকে যদি তারা সংলগ্ন হয় এবং একই রঙের হয়। সমস্ত পিক্সেল একই রঙের করতে প্রয়োজনীয় সর্বনিম্ন সংখ্যক অপারেশন খুঁজে বের করুন।\n\nদ্রষ্টব্য: প্রতিটি রঙের জন্য, সর্বাধিক 20টি পিক্সেল সেই রঙের হতে পারে।\n\nউদাহরণ:\n  f_45(5, {1, 2, 3, 2, 1}) -> 2", "bg": "Напишете CPP функция `int f_45(int n, int* pixels)`, за да решите следния проблем:\nДадено е изображение с размер 1 на n пиксела, където всеки пиксел има цвят, представен с цяло число. Можете да извършите операция, при която избирате цвят и променяте всички свързани пиксели от същия цвят на избрания цвят. Два пиксела са свързани, ако са съседни и имат същия цвят. Намерете минималния брой операции, необходими, за да направите всички пиксели с един и същ цвят.\n\nЗабележка: За всеки цвят има най-много 20 пиксела от този цвят.\n\nПримери:\n  f_45(5, {1, 2, 3, 2, 1}) -> 2", "zh": "编写一个 CPP 函数 `int f_45(int n, int* pixels)` 来解决以下问题：  \n给定一个 1 x n 的像素图像，其中每个像素的颜色由一个整数表示。你可以执行一个操作，选择一种颜色并将所有相同颜色的连接像素更改为所选颜色。如果两个像素是相邻的并且具有相同的颜色，则它们是连接的。找出使所有像素变为相同颜色所需的最小操作次数。\n\n注意：对于每种颜色，最多有 20 个该颜色的像素。\n\n示例：\n  f_45(5, {1, 2, 3, 2, 1}) -> 2", "fr": "Écrire une fonction CPP `int f_45(int n, int* pixels)` pour résoudre le problème suivant :  \nOn vous donne une image de 1 par n pixels, où chaque pixel a une couleur représentée par un entier. Vous pouvez effectuer une opération où vous choisissez une couleur et changez tous les pixels connectés de la même couleur en la couleur choisie. Deux pixels sont connectés s'ils sont adjacents et ont la même couleur. Trouvez le nombre minimum d'opérations nécessaires pour rendre tous les pixels de la même couleur.\n\nRemarque : Pour chaque couleur, il y a au plus 20 pixels de cette couleur.\n\nExemples :\n  f_45(5, {1, 2, 3, 2, 1}) -> 2", "de": "Schreiben Sie eine CPP-Funktion `int f_45(int n, int* pixels)`, um das folgende Problem zu lösen:\nSie haben ein 1 mal n Pixel-Bild, wobei jedes Pixel eine Farbe hat, die durch eine ganze Zahl dargestellt wird. Sie können eine Operation durchführen, bei der Sie eine Farbe auswählen und alle verbundenen Pixel derselben Farbe in die gewählte Farbe ändern. Zwei Pixel sind verbunden, wenn sie benachbart sind und dieselbe Farbe haben. Finden Sie die minimale Anzahl von Operationen, die erforderlich sind, um alle Pixel in dieselbe Farbe zu ändern.\n\nHinweis: Für jede Farbe gibt es höchstens 20 Pixel dieser Farbe.\n\nBeispiele:\n  f_45(5, {1, 2, 3, 2, 1}) -> 2", "ha": "Rubuta aikin CPP `int f_45(int n, int* pixels)` don warware matsalar mai zuwa:  \nAn ba ku hoton pixel 1 ta n, inda kowanne pixel yana da launi da aka wakilta da lamba. Kuna iya aiwatar da aiki inda kuka zaɓi launi kuma ku canza duk pixels masu alaƙa na launi ɗaya zuwa launin da aka zaɓa. Ana haɗa pixels biyu idan suna kusa kuma suna da launi ɗaya. Nemo mafi ƙarancin adadin ayyukan da ake buƙata don sanya duk pixels su zama launi ɗaya.\n\nLura: Don kowane launi, akwai aƙalla pixels 20 na wannan launi.\n\nMisalai:  \n  f_45(5, {1, 2, 3, 2, 1}) -> 2", "hi": "एक CPP फ़ंक्शन `int f_45(int n, int* pixels)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nआपको 1 बाई n पिक्सल छवि दी गई है, जहाँ प्रत्येक पिक्सल का रंग एक पूर्णांक द्वारा दर्शाया गया है। आप एक ऑपरेशन कर सकते हैं जहाँ आप एक रंग चुनते हैं और उसी रंग के सभी जुड़े हुए पिक्सलों को चुने गए रंग में बदल देते हैं। दो पिक्सल जुड़े होते हैं यदि वे आसन्न होते हैं और उनका रंग समान होता है। सभी पिक्सलों को एक ही रंग का बनाने के लिए आवश्यक न्यूनतम ऑपरेशनों की संख्या ज्ञात करें।\n\nनोट: प्रत्येक रंग के लिए, उस रंग के अधिकतम 20 पिक्सल होते हैं।\n\nउदाहरण:\n  f_45(5, {1, 2, 3, 2, 1}) -> 2", "hu": "Írj egy CPP függvényt `int f_45(int n, int* pixels)` a következő probléma megoldására:\nAdott egy 1 x n pixeles kép, ahol minden pixel színe egy egész számmal van reprezentálva. Végrehajthatsz egy műveletet, amely során kiválasztasz egy színt, és az összes összekapcsolt, azonos színű pixelt megváltoztatod a kiválasztott színre. Két pixel akkor van összekapcsolva, ha szomszédosak és azonos színűek. Találd meg a minimális műveletek számát, amelyek szükségesek ahhoz, hogy az összes pixel azonos színű legyen.\n\nMegjegyzés: Minden szín esetében legfeljebb 20 pixel van abból a színből.\n\nPéldák:\n  f_45(5, {1, 2, 3, 2, 1}) -> 2", "es": "Escribe una función CPP `int f_45(int n, int* pixels)` para resolver el siguiente problema:\nSe te da una imagen de 1 por n píxeles, donde cada píxel tiene un color representado por un entero. Puedes realizar una operación en la que eliges un color y cambias todos los píxeles conectados del mismo color al color elegido. Dos píxeles están conectados si son adyacentes y tienen el mismo color. Encuentra el número mínimo de operaciones requeridas para hacer que todos los píxeles sean del mismo color.\n\nNota: Para cada color, hay como máximo 20 píxeles de ese color.\n\nEjemplos:\n  f_45(5, {1, 2, 3, 2, 1}) -> 2", "arb": "اكتب دالة CPP `int f_45(int n, int* pixels)` لحل المشكلة التالية:\nلديك صورة بكسل بحجم 1 في n، حيث أن كل بكسل له لون ممثل بعدد صحيح. يمكنك تنفيذ عملية حيث تختار لونًا وتغير جميع البكسلات المتصلة من نفس اللون إلى اللون المختار. يعتبر البكسلان متصلين إذا كانا متجاورين ولهما نفس اللون. جد الحد الأدنى لعدد العمليات المطلوبة لجعل جميع البكسلات بنفس اللون.\n\nملاحظة: لكل لون، يوجد على الأكثر 20 بكسل من ذلك اللون.\n\nأمثلة:\n  f_45(5, {1, 2, 3, 2, 1}) -> 2", "sw": "Andika kazi ya CPP `int f_45(int n, int* pixels)` kutatua tatizo lifuatalo:\nUmepewa picha ya pikseli 1 kwa n, ambapo kila pikseli ina rangi inayowakilishwa na nambari nzima. Unaweza kufanya operesheni ambapo unachagua rangi na kubadilisha pikseli zote zilizounganishwa za rangi sawa kuwa rangi iliyochaguliwa. Pikseli mbili zimeunganishwa ikiwa ziko karibu na zina rangi sawa. Tafuta idadi ndogo ya operesheni zinazohitajika kufanya pikseli zote ziwe na rangi sawa.\n\nKumbuka: Kwa kila rangi, kuna pikseli zisizozidi 20 za rangi hiyo.\n\nMifano:\n  f_45(5, {1, 2, 3, 2, 1}) -> 2", "tr": "`int f_45(int n, int* pixels)` fonksiyonunu aşağıdaki problemi çözmek için yazın:\n1'e n pikselden oluşan bir görüntü verilir, burada her piksel bir tamsayı ile temsil edilen bir renge sahiptir. Bir renk seçip aynı renkteki tüm bağlantılı pikselleri seçilen renge değiştirebileceğiniz bir işlem gerçekleştirebilirsiniz. İki piksel, bitişik ve aynı renkte olduklarında bağlantılıdır. Tüm pikselleri aynı renge getirmek için gereken minimum işlem sayısını bulun.\n\nNot: Her renk için en fazla 20 piksel vardır.\n\nÖrnekler:\n  f_45(5, {1, 2, 3, 2, 1}) -> 2", "vi": "Viết một hàm CPP `int f_45(int n, int* pixels)` để giải quyết vấn đề sau:\nBạn được cung cấp một hình ảnh 1 x n pixel, trong đó mỗi pixel có một màu được biểu diễn bằng một số nguyên. Bạn có thể thực hiện một thao tác trong đó bạn chọn một màu và thay đổi tất cả các pixel kết nối có cùng màu thành màu đã chọn. Hai pixel được kết nối nếu chúng liền kề và có cùng màu. Tìm số lượng thao tác tối thiểu cần thiết để làm cho tất cả các pixel có cùng màu.\n\nLưu ý: Đối với mỗi màu, có tối đa 20 pixel của màu đó.\n\nVí dụ:\n  f_45(5, {1, 2, 3, 2, 1}) -> 2", "id": "Tulis fungsi CPP `int f_45(int n, int* pixels)` untuk menyelesaikan masalah berikut:\nAnda diberikan gambar 1 kali n piksel, di mana setiap piksel memiliki warna yang diwakili oleh sebuah bilangan bulat. Anda dapat melakukan operasi di mana Anda memilih satu warna dan mengubah semua piksel yang terhubung dengan warna yang sama menjadi warna yang dipilih. Dua piksel terhubung jika mereka bersebelahan dan memiliki warna yang sama. Temukan jumlah minimum operasi yang diperlukan untuk membuat semua piksel memiliki warna yang sama.\n\nCatatan: Untuk setiap warna, terdapat paling banyak 20 piksel dengan warna tersebut.\n\nContoh:\n  f_45(5, {1, 2, 3, 2, 1}) -> 2", "ja": "C++の関数を書け。 `int f_45(int n, int* pixels)` を使用して次の問題を解決します:\n1 by n のピクセル画像が与えられ、各ピクセルは整数で表される色を持っています。操作を行うことができ、色を選んで、同じ色の隣接したすべてのピクセルを選んだ色に変更します。2つのピクセルは、隣接していて同じ色の場合に接続されています。すべてのピクセルを同じ色にするために必要な最小の操作回数を求めます。\n\n注意: 各色について、その色のピクセルは最大で20個です。\n\n例:\n  f_45(5, {1, 2, 3, 2, 1}) -> 2", "ko": "`int f_45(int n, int* pixels)` 함수를 작성하여 다음 문제를 해결하십시오:\n1 by n 픽셀 이미지가 주어지며, 각 픽셀은 정수로 표현된 색상을 가지고 있습니다. 색상을 선택하고 같은 색상의 연결된 모든 픽셀을 선택한 색상으로 변경하는 작업을 수행할 수 있습니다. 두 픽셀이 연결되려면 인접해 있어야 하며 같은 색상을 가져야 합니다. 모든 픽셀이 동일한 색상이 되도록 하는 데 필요한 최소 작업 수를 찾으십시오.\n\n참고: 각 색상에 대해 해당 색상의 픽셀이 최대 20개 있습니다.\n\n예시:\n  f_45(5, {1, 2, 3, 2, 1}) -> 2", "ml": "`int f_45(int n, int* pixels)` എന്ന CPP ഫംഗ്ഷൻ എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nനിങ്ങൾക്ക് 1 by n പിക്‌സൽ ഇമേജ് നൽകിയിരിക്കുന്നു, ഓരോ പിക്‌സലിനും ഒരു പൂർണ്ണസംഖ്യയാൽ പ്രതിനിധീകരിക്കുന്ന ഒരു നിറമുണ്ട്. നിങ്ങൾക്ക് ഒരു ഓപ്പറേഷൻ നടത്താം, അതിൽ നിങ്ങൾ ഒരു നിറം തിരഞ്ഞെടുക്കുകയും അതേ നിറത്തിലുള്ള എല്ലാ ബന്ധിപ്പിച്ച പിക്‌സലുകളും തിരഞ്ഞെടുക്കപ്പെട്ട നിറത്തിലേക്ക് മാറ്റുകയും ചെയ്യാം. രണ്ട് പിക്‌സലുകൾ ബന്ധിപ്പിച്ചിരിക്കുന്നു എന്നത് അവർ പരസ്പരം ചേർന്നിരിക്കുന്നതും ഒരേ നിറമുള്ളതുമാണ്. എല്ലാ പിക്‌സലുകളും ഒരേ നിറത്തിലാക്കാൻ ആവശ്യമായ ഓപ്പറേഷനുകളുടെ കുറഞ്ഞ എണ്ണം കണ്ടെത്തുക.\n\nകുറിപ്പ്: ഓരോ നിറത്തിനും ആ നിറത്തിലുള്ള പരമാവധി 20 പിക്‌സലുകൾ മാത്രമേയുള്ളൂ.\n\nഉദാഹരണങ്ങൾ:\n  f_45(5, {1, 2, 3, 2, 1}) -> 2", "fa": "تابعی به زبان CPP بنویسید `int f_45(int n, int* pixels)` تا مسئله زیر را حل کند:\nبه شما یک تصویر ۱ در n پیکسل داده شده است، که هر پیکسل دارای رنگی است که با یک عدد صحیح نمایش داده می‌شود. شما می‌توانید عملیاتی انجام دهید که در آن یک رنگ را انتخاب کرده و تمام پیکسل‌های متصل با همان رنگ را به رنگ انتخاب شده تغییر دهید. دو پیکسل زمانی متصل هستند که مجاور باشند و رنگ یکسانی داشته باشند. حداقل تعداد عملیات مورد نیاز برای یکسان کردن رنگ تمام پیکسل‌ها را پیدا کنید.\n\nتوجه: برای هر رنگ، حداکثر ۲۰ پیکسل با آن رنگ وجود دارد.\n\nمثال‌ها:\n  f_45(5, {1, 2, 3, 2, 1}) -> 2"}, "level": "hard", "test": "int main() {\n    int a1[] = {1, 2, 3, 2, 1};\n    int a2[] = {1, 1, 2, 2};\n    int a3[] = {1, 2, 1, 4, 2};\n    int a4[] = {5, 5, 5, 5, 5};\n    int a5[] = {1, 1, 1, 2, 2, 2};\n    int a6[] = {1, 3, 3, 3, 2, 2, 2};\n    int a7[] = {4, 4, 4, 4, 3, 3, 3, 3};\n    int a8[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n    int a9[] = {1, 2, 1, 2, 1, 2, 1, 2, 1, 2};\n    int a10[] = {3, 3, 3};\n    int a11[] = {2, 1, 1, 2};\n    assert(f_45(5, a1) == 2);\n    assert(f_45(4, a2) == 1);\n    assert(f_45(5, a3) == 3);\n    assert(f_45(5, a4) == 0);\n    assert(f_45(6, a5) == 1);\n    assert(f_45(7, a6) == 2);\n    assert(f_45(8, a7) == 1);\n    assert(f_45(9, a8) == 8);\n    assert(f_45(10, a9) == 5);\n    assert(f_45(3, a10) == 0);\n    assert(f_45(4, a11) == 1);\n    return 0;\n}", "entry_point": "f_45", "signature": "int f_45(int n, int* pixels)", "docstring": {"en": "You are given a 1 by n pixel image, where each pixel has a color represented by an integer. You can perform an operation where you pick a color and change all connected pixels of the same color to the chosen color. Two pixels are connected if they are adjacent and have the same color. Find the minimum number of operations required to make all pixels the same color.\n\nNote: For each color, there are at most 20 pixels of that color.\n\nExamples:\n  f_45(5, {1, 2, 3, 2, 1}) -> 2\n", "sq": "Ju jepet një imazh 1 me n piksel, ku secili piksel ka një ngjyrë të përfaqësuar nga një numër i plotë. Ju mund të kryeni një operacion ku zgjidhni një ngjyrë dhe ndryshoni të gjithë piksela të lidhur të së njëjtës ngjyrë në ngjyrën e zgjedhur. Dy piksela janë të lidhur nëse janë ngjitur dhe kanë të njëjtën ngjyrë. Gjeni numrin minimal të operacioneve të kërkuara për të bërë që të gjithë piksela të kenë të njëjtën ngjyrë.\n\nShënim: Për çdo ngjyrë, ka maksimumi 20 piksela të asaj ngjyre.\n\nShembuj:\n  f_45(5, {1, 2, 3, 2, 1}) -> 2", "hy": "Դուք տրված եք 1 x n պիքսել պատկերի հետ, որտեղ յուրաքանչյուր պիքսել ունի գույն, որը ներկայացված է ամբողջ թվով։ Դուք կարող եք կատարել գործողություն, որտեղ ընտրում եք գույն և փոխում բոլոր միացված պիքսելները նույն գույնով դեպի ընտրված գույնը։ Երկու պիքսելները միացված են, եթե նրանք հարակից են և ունեն նույն գույնը։ Գտեք նվազագույն գործողությունների քանակը, որը պահանջվում է, որպեսզի բոլոր պիքսելները ունենան նույն գույնը։\n\nՆշում: Յուրաքանչյուր գույնի համար առավելագույնը կա 20 պիքսել այդ գույնով։\n\nՕրինակներ:\n  f_45(5, {1, 2, 3, 2, 1}) -> 2", "bn": "আপনাকে একটি 1 বাই n পিক্সেল চিত্র দেওয়া হয়েছে, যেখানে প্রতিটি পিক্সেলের একটি রঙ রয়েছে যা একটি পূর্ণসংখ্যা দ্বারা উপস্থাপিত হয়। আপনি একটি অপারেশন করতে পারেন যেখানে আপনি একটি রঙ বেছে নেন এবং একই রঙের সমস্ত সংযুক্ত পিক্সেলগুলি নির্বাচিত রঙে পরিবর্তন করেন। দুটি পিক্সেল সংযুক্ত থাকে যদি তারা সংলগ্ন হয় এবং তাদের একই রঙ থাকে। সমস্ত পিক্সেলকে একই রঙে করতে প্রয়োজনীয় সর্বনিম্ন সংখ্যক অপারেশন খুঁজে বের করুন।\n\nনোট: প্রতিটি রঙের জন্য, সেই রঙের সর্বাধিক ২০টি পিক্সেল রয়েছে।\n\nউদাহরণ:\n  f_45(5, {1, 2, 3, 2, 1}) -> 2", "bg": "Дадено е изображение с размери 1 на n пиксела, където всеки пиксел има цвят, представен чрез цяло число. Можете да извършите операция, при която избирате цвят и променяте всички свързани пиксели със същия цвят на избрания цвят. Два пиксела са свързани, ако са съседни и имат същия цвят. Намерете минималния брой операции, необходими, за да направите всички пиксели с един и същ цвят.\n\nЗабележка: За всеки цвят има най-много 20 пиксела от този цвят.\n\nПримери:\n  f_45(5, {1, 2, 3, 2, 1}) -> 2", "zh": "你有一个 1 x n 像素的图像，其中每个像素的颜色由一个整数表示。你可以执行一个操作，即选择一种颜色并将所有连接的相同颜色的像素更改为所选颜色。如果两个像素是相邻的并且具有相同的颜色，则它们是连接的。找出使所有像素变为相同颜色所需的最小操作次数。\n\n注意：对于每种颜色，最多有 20 个该颜色的像素。\n\n示例：\n  f_45(5, {1, 2, 3, 2, 1}) -> 2", "fr": "Vous avez une image de 1 par n pixels, où chaque pixel a une couleur représentée par un entier. Vous pouvez effectuer une opération où vous choisissez une couleur et changez tous les pixels connectés de la même couleur à la couleur choisie. Deux pixels sont connectés s'ils sont adjacents et ont la même couleur. Trouvez le nombre minimum d'opérations nécessaires pour que tous les pixels soient de la même couleur.\n\nRemarque : Pour chaque couleur, il y a au plus 20 pixels de cette couleur.\n\nExemples :\n  f_45(5, {1, 2, 3, 2, 1}) -> 2", "de": "Du hast ein 1x n Pixel-Bild, wobei jeder Pixel eine Farbe hat, die durch eine ganze Zahl dargestellt wird. Du kannst eine Operation durchführen, bei der du eine Farbe auswählst und alle verbundenen Pixel derselben Farbe in die gewählte Farbe änderst. Zwei Pixel sind verbunden, wenn sie benachbart sind und dieselbe Farbe haben. Finde die minimale Anzahl von Operationen, die erforderlich sind, um alle Pixel in dieselbe Farbe zu ändern.\n\nHinweis: Für jede Farbe gibt es höchstens 20 Pixel dieser Farbe.\n\nBeispiele:\n  f_45(5, {1, 2, 3, 2, 1}) -> 2", "ha": "An ba ku hoto mai pixel 1 ta n, inda kowane pixel yana da launi da aka wakilta da lamba. Kuna iya aiwatar da aiki inda kuke ɗaukar launi kuma ku canza duk pixels masu alaƙa na launi ɗaya zuwa launi da aka zaɓa. Pixels biyu suna da alaƙa idan suna kusa da juna kuma suna da launi ɗaya. Nemo mafi ƙarancin adadin ayyuka da ake buƙata don sanya duk pixels su zama launi ɗaya.\n\nLura: Ga kowane launi, akwai mafi yawan pixels 20 na wannan launi.\n\nMisalai:\n  f_45(5, {1, 2, 3, 2, 1}) -> 2", "hi": "आपको 1 बाई n पिक्सल छवि दी गई है, जहाँ प्रत्येक पिक्सल का रंग एक पूर्णांक द्वारा दर्शाया गया है। आप एक ऑपरेशन कर सकते हैं जहां आप एक रंग चुनते हैं और उसी रंग के सभी जुड़े पिक्सेल को चुने गए रंग में बदल देते हैं। दो पिक्सेल जुड़े होते हैं यदि वे आसन्न होते हैं और उनका रंग समान होता है। सभी पिक्सेल को एक ही रंग में बनाने के लिए आवश्यक न्यूनतम ऑपरेशनों की संख्या खोजें।\n\nध्यान दें: प्रत्येक रंग के लिए, उस रंग के अधिकतम 20 पिक्सेल होते हैं।\n\nउदाहरण:\n  f_45(5, {1, 2, 3, 2, 1}) -> 2", "hu": "Egy 1 x n pixel méretű képet kapunk, ahol minden pixel színét egy egész szám képviseli. Végrehajthatunk egy olyan műveletet, amely során kiválasztunk egy színt, és az összes összekapcsolt, azonos színű pixelt megváltoztatjuk a választott színre. Két pixel akkor van összekapcsolva, ha szomszédosak és azonos színűek. Határozzuk meg a minimális műveletek számát, amelyek szükségesek ahhoz, hogy az összes pixel azonos színű legyen.\n\nMegjegyzés: Minden színből legfeljebb 20 pixel található.\n\nPéldák:\n  f_45(5, {1, 2, 3, 2, 1}) -> 2", "es": "Se te da una imagen de 1 por n píxeles, donde cada píxel tiene un color representado por un número entero. Puedes realizar una operación en la que eliges un color y cambias todos los píxeles conectados del mismo color al color elegido. Dos píxeles están conectados si son adyacentes y tienen el mismo color. Encuentra el número mínimo de operaciones necesarias para hacer que todos los píxeles sean del mismo color.\n\nNota: Para cada color, hay como máximo 20 píxeles de ese color.\n\nEjemplos:\n  f_45(5, {1, 2, 3, 2, 1}) -> 2", "arb": "أنت لديك صورة بكسل بحجم 1 في n، حيث كل بكسل له لون ممثل برقم صحيح. يمكنك تنفيذ عملية حيث تختار لونًا وتغير جميع البكسلات المتصلة من نفس اللون إلى اللون المختار. يعتبر بكسلان متصلان إذا كانا متجاورين ولهما نفس اللون. جد الحد الأدنى لعدد العمليات المطلوبة لجعل جميع البكسلات بنفس اللون.\n\nملاحظة: لكل لون، هناك بحد أقصى 20 بكسل من ذلك اللون.\n\nأمثلة:\n  f_45(5, {1, 2, 3, 2, 1}) -> 2", "sw": "Unapewa picha ya pikseli 1 kwa n, ambapo kila pikseli ina rangi inayowakilishwa na nambari nzima. Unaweza kufanya operesheni ambapo unachagua rangi na kubadilisha pikseli zote zilizounganishwa za rangi sawa na rangi iliyochaguliwa. Pikseli mbili zimeunganishwa ikiwa ziko karibu na zina rangi sawa. Pata idadi ndogo ya operesheni zinazohitajika kufanya pikseli zote ziwe na rangi sawa.\n\nKumbuka: Kwa kila rangi, kuna pikseli zisizozidi 20 za rangi hiyo.\n\nMifano:\n  f_45(5, {1, 2, 3, 2, 1}) -> 2", "tr": "1'e n piksel boyutunda bir görüntü verilir ve her piksel bir tam sayı ile temsil edilen bir renge sahiptir. Bir renk seçip aynı renkteki tüm bağlı pikselleri seçilen renge değiştirebileceğiniz bir işlem gerçekleştirebilirsiniz. İki piksel, bitişik ve aynı renkte olduklarında bağlı kabul edilir. Tüm pikselleri aynı renge getirmek için gereken minimum işlem sayısını bulun.\n\nNot: Her renk için en fazla 20 piksel vardır.\n\nÖrnekler:\n  f_45(5, {1, 2, 3, 2, 1}) -> 2", "vi": "Bạn được cung cấp một hình ảnh 1 x n pixel, trong đó mỗi pixel có một màu được biểu diễn bằng một số nguyên. Bạn có thể thực hiện một thao tác trong đó bạn chọn một màu và thay đổi tất cả các pixel kết nối có cùng màu thành màu đã chọn. Hai pixel được coi là kết nối nếu chúng liền kề và có cùng màu. Tìm số lượng thao tác tối thiểu cần thiết để làm cho tất cả các pixel có cùng màu.\n\nLưu ý: Đối với mỗi màu, có tối đa 20 pixel của màu đó.\n\nVí dụ:\n  f_45(5, {1, 2, 3, 2, 1}) -> 2", "id": "Anda diberikan gambar 1 x n piksel, di mana setiap piksel memiliki warna yang diwakili oleh sebuah bilangan bulat. Anda dapat melakukan operasi di mana Anda memilih sebuah warna dan mengubah semua piksel yang terhubung dengan warna yang sama menjadi warna yang dipilih. Dua piksel terhubung jika mereka berdekatan dan memiliki warna yang sama. Temukan jumlah operasi minimum yang diperlukan untuk membuat semua piksel memiliki warna yang sama.\n\nCatatan: Untuk setiap warna, terdapat paling banyak 20 piksel dengan warna tersebut.\n\nContoh:\n  f_45(5, {1, 2, 3, 2, 1}) -> 2", "ja": "1行nピクセルの画像が与えられ、各ピクセルは整数で表される色を持っています。色を選び、同じ色の接続されたすべてのピクセルを選んだ色に変更する操作を実行できます。2つのピクセルは、隣接していて同じ色を持つ場合に接続されています。すべてのピクセルを同じ色にするために必要な最小の操作回数を求めてください。\n\n注意: 各色について、その色のピクセルは最大で20個です。\n\n例:\n  f_45(5, {1, 2, 3, 2, 1}) -> 2", "ko": "1 by n 픽셀 이미지가 주어집니다. 각 픽셀은 정수로 표현된 색상을 가지고 있습니다. 색상을 선택하고 동일한 색상의 연결된 모든 픽셀을 선택한 색상으로 변경하는 작업을 수행할 수 있습니다. 두 픽셀이 연결되려면 인접해 있고 같은 색상이어야 합니다. 모든 픽셀을 동일한 색상으로 만들기 위해 필요한 최소 작업 수를 찾으십시오.\n\n참고: 각 색상에 대해 해당 색상의 픽셀은 최대 20개입니다.\n\n예시:\n  f_45(5, {1, 2, 3, 2, 1}) -> 2", "ml": "നിങ്ങൾക്ക് 1 by n പിക്സൽ ചിത്രം നൽകിയിരിക്കുന്നു, ഇവിടെ ഓരോ പിക്സലിനും ഒരു പൂർണ്ണസംഖ്യയാൽ പ്രതിനിധീകരിച്ച നിറമുണ്ട്. നിങ്ങൾക്ക് ഒരു പ്രവർത്തനം നടത്താം, അതായത് നിങ്ങൾ ഒരു നിറം തിരഞ്ഞെടുക്കുകയും അതേ നിറമുള്ള എല്ലാ ബന്ധിപ്പിച്ചിരിക്കുന്ന പിക്സലുകളെയും തിരഞ്ഞെടുക്കപ്പെട്ട നിറത്തിലേക്ക് മാറ്റുകയും ചെയ്യാം. രണ്ട് പിക്സലുകൾ ബന്ധിപ്പിക്കപ്പെട്ടിരിക്കുന്നു എന്നത് അവർ അടുത്തടുത്ത് ഉണ്ട്, അതേ നിറമുള്ളവയാണ്. എല്ലാ പിക്സലുകളും ഒരേ നിറത്തിലുള്ളതാക്കാൻ ആവശ്യമായ കുറഞ്ഞ പ്രവർത്തനങ്ങളുടെ എണ്ണം കണ്ടെത്തുക.\n\nകുറിപ്പ്: ഓരോ നിറത്തിനും ആ നിറത്തിലുള്ള പരമാവധി 20 പിക്സലുകൾ മാത്രമേയുള്ളൂ.\n\nഉദാഹരണങ്ങൾ:\n  f_45(5, {1, 2, 3, 2, 1}) -> 2", "fa": "شما یک تصویر 1 در n پیکسلی دارید که هر پیکسل دارای رنگی است که با یک عدد صحیح نشان داده می‌شود. شما می‌توانید عملیاتی انجام دهید که در آن یک رنگ را انتخاب کرده و تمام پیکسل‌های متصل با همان رنگ را به رنگ انتخاب شده تغییر دهید. دو پیکسل متصل هستند اگر مجاور باشند و رنگ یکسانی داشته باشند. حداقل تعداد عملیات مورد نیاز برای یکسان کردن رنگ تمام پیکسل‌ها را پیدا کنید.\n\nتوجه: برای هر رنگ، حداکثر 20 پیکسل از آن رنگ وجود دارد.\n\nمثال‌ها:\n  f_45(5, {1, 2, 3, 2, 1}) -> 2"}}
{"task_id": "CPP/46", "prompt": {"en": "#include <cassert>\n#include <iostream>\n/**\n * @brief Computes the sum of all numbers from 1 to n that are multiples of either 3 or 5.\n *\n * Counts each number only once even if it is a multiple of both 3 and 5.\n * For example:\n *     @code\n *     std::cout << f_46(10); // Outputs: 33 (3 + 5 + 6 + 9 + 10)\n *     @endcode\n *\n * @param n The upper bound of the range to check for multiples.\n * @return The sum of the multiples of either 3 or 5 within the range.\n */\nint f_46(int n)", "sq": "#include <cassert>\n#include <iostream>\n/**\n * @brief Llogarit shumën e të gjithë numrave nga 1 deri në n që janë shumëfish i 3 ose 5.\n *\n * Numëron secilin numër vetëm një herë edhe nëse është shumëfish i të dyve, 3 dhe 5.\n * Për shembull:\n *     @code\n *     std::cout << f_46(10); // Outputs: 33 (3 + 5 + 6 + 9 + 10)\n *     @endcode\n *\n * @param n Kufiri i sipërm i intervalit për të kontrolluar për shumëfish.\n * @return Shuma e shumëfishave të 3 ose 5 brenda intervalit.\n */\nint f_46(int n)", "hy": "#include <cassert>\n#include <iostream>\n/**\n * @brief Հաշվում է 1-ից n բոլոր թվերի գումարը, որոնք բազմապատիկ են 3-ի կամ 5-ի։\n *\n * Յուրաքանչյուր թիվ հաշվում է միայն մեկ անգամ, նույնիսկ եթե այն բազմապատիկ է և՛ 3-ի, և՛ 5-ի։\n * Օրինակ:\n *     @code\n *     std::cout << f_46(10); // Outputs: 33 (3 + 5 + 6 + 9 + 10)\n *     @endcode\n *\n * @param n Բազմապատիկների ստուգման միջակայքի վերին սահմանը։\n * @return 3-ի կամ 5-ի բազմապատիկների գումարը տվյալ միջակայքում։\n */\nint f_46(int n)", "bn": "#include <cassert>\n#include <iostream>\n/**\n * @brief 1 থেকে n পর্যন্ত সমস্ত সংখ্যার যোগফল গণনা করে যা 3 বা 5 এর গুণিতক।\n *\n * প্রতিটি সংখ্যাকে কেবল একবার গণনা করা হয়, এমনকি যদি এটি 3 এবং 5 উভয়ের গুণিতক হয়।\n * উদাহরণস্বরূপ:\n *     @code\n *     std::cout << f_46(10); // Outputs: 33 (3 + 5 + 6 + 9 + 10)\n *     @endcode\n *\n * @param n গুণিতক পরীক্ষা করার জন্য সীমার উপরের সীমানা।\n * @return সীমার মধ্যে 3 বা 5 এর গুণিতকের যোগফল।\n */\nint f_46(int n)", "bg": "#include <cassert>\n#include <iostream>\n/**\n * @brief Изчислява сумата на всички числа от 1 до n, които са кратни на 3 или 5.\n *\n * Всяко число се брои само веднъж, дори ако е кратно и на 3, и на 5.\n * Например:\n *     @code\n *     std::cout << f_46(10); // Outputs: 33 (3 + 5 + 6 + 9 + 10)\n *     @endcode\n *\n * @param n Горната граница на диапазона за проверка на кратни.\n * @return Сумата на кратните на 3 или 5 в диапазона.\n */\nint f_46(int n)", "zh": "#include <cassert>\n#include <iostream>\n/**\n * @brief 计算从 1 到 n 的所有 3 或 5 的倍数的和。\n *\n * 每个数字只计算一次，即使它是 3 和 5 的倍数。\n * 例如:\n *     @code\n *     std::cout << f_46(10); // 输出: 33 (3 + 5 + 6 + 9 + 10)\n *     @endcode\n *\n * @param n 要检查倍数的范围上限。\n * @return 范围内 3 或 5 的倍数的和。\n */\nint f_46(int n)", "fr": "#include <cassert>\n#include <iostream>\n/**\n * @brief Calcule la somme de tous les nombres de 1 à n qui sont des multiples de 3 ou 5.\n *\n * Compte chaque nombre une seule fois même s'il est un multiple à la fois de 3 et de 5.\n * Par exemple :\n *     @code\n *     std::cout << f_46(10); // Outputs: 33 (3 + 5 + 6 + 9 + 10)\n *     @endcode\n *\n * @param n La limite supérieure de la plage à vérifier pour les multiples.\n * @return La somme des multiples de 3 ou 5 dans la plage.\n */\nint f_46(int n)", "de": "#include <cassert>\n#include <iostream>\n/**\n * @brief Berechnet die Summe aller Zahlen von 1 bis n, die Vielfache von entweder 3 oder 5 sind.\n *\n * Zählt jede Zahl nur einmal, auch wenn sie ein Vielfaches von sowohl 3 als auch 5 ist.\n * Zum Beispiel:\n *     @code\n *     std::cout << f_46(10); // Gibt aus: 33 (3 + 5 + 6 + 9 + 10)\n *     @endcode\n *\n * @param n Die obere Grenze des Bereichs, in dem nach Vielfachen gesucht wird.\n * @return Die Summe der Vielfachen von entweder 3 oder 5 innerhalb des Bereichs.\n */\nint f_46(int n)", "ha": "#include <cassert>\n#include <iostream>\n/**\n * @brief Lissafi jimillar dukkan lambobi daga 1 zuwa n waɗanda suke lambobi masu yawa na 3 ko 5.\n *\n * Yana ƙidaya kowace lamba sau ɗaya kawai ko da kuwa tana lambobi masu yawa na 3 da 5 duka.\n * Alal misali:\n *     @code\n *     std::cout << f_46(10); // Fitarwa: 33 (3 + 5 + 6 + 9 + 10)\n *     @endcode\n *\n * @param n Ƙarshen iyaka na zangon da za a duba lambobi masu yawa.\n * @return Jimillar lambobi masu yawa na 3 ko 5 a cikin zangon.\n */\nint f_46(int n)", "hi": "#include <cassert>\n#include <iostream>\n/**\n * @brief 1 से n तक के सभी संख्याओं का योग गणना करता है जो या तो 3 या 5 के गुणज हैं।\n *\n * प्रत्येक संख्या को केवल एक बार गिना जाता है, भले ही वह 3 और 5 दोनों का गुणज हो।\n * उदाहरण के लिए:\n *     @code\n *     std::cout << f_46(10); // Outputs: 33 (3 + 5 + 6 + 9 + 10)\n *     @endcode\n *\n * @param n गुणजों की जांच के लिए सीमा का ऊपरी बिंदु।\n * @return 3 या 5 के गुणजों का सीमा के भीतर योग।\n */\nint f_46(int n)", "hu": "#include <cassert>\n#include <iostream>\n/**\n * @brief Kiszámítja az összes olyan szám összegét 1-től n-ig, amelyek 3 vagy 5 többszörösei.\n *\n * Minden számot csak egyszer számol, még akkor is, ha az 3-nak és 5-nek is többszöröse.\n * Például:\n *     @code\n *     std::cout << f_46(10); // Kimenet: 33 (3 + 5 + 6 + 9 + 10)\n *     @endcode\n *\n * @param n A tartomány felső határa, amelyet ellenőrizni kell a többszörösök szempontjából.\n * @return A 3 vagy 5 többszöröseinek összege a tartományon belül.\n */\nint f_46(int n)", "es": "#include <cassert>\n#include <iostream>\n/**\n * @brief Calcula la suma de todos los números desde 1 hasta n que son múltiplos de 3 o 5.\n *\n * Cuenta cada número solo una vez, incluso si es múltiplo de ambos 3 y 5.\n * Por ejemplo:\n *     @code\n *     std::cout << f_46(10); // Outputs: 33 (3 + 5 + 6 + 9 + 10)\n *     @endcode\n *\n * @param n El límite superior del rango para verificar múltiplos.\n * @return La suma de los múltiplos de 3 o 5 dentro del rango.\n */\nint f_46(int n)", "arb": "#include <cassert>\n#include <iostream>\n/**\n * @brief يحسب مجموع جميع الأرقام من 1 إلى n التي هي مضاعفات لـ 3 أو 5.\n *\n * يحسب كل رقم مرة واحدة فقط حتى لو كان مضاعفًا لكل من 3 و 5.\n * على سبيل المثال:\n *     @code\n *     std::cout << f_46(10); // Outputs: 33 (3 + 5 + 6 + 9 + 10)\n *     @endcode\n *\n * @param n الحد الأعلى للنطاق للتحقق من المضاعفات.\n * @return مجموع المضاعفات لـ 3 أو 5 ضمن النطاق.\n */\nint f_46(int n)", "sw": "#include <cassert>\n#include <iostream>\n/**\n * @brief Inahesabu jumla ya namba zote kutoka 1 hadi n ambazo ni marudufu ya 3 au 5.\n *\n * Inahesabu kila namba mara moja tu hata kama ni marudufu ya 3 na 5.\n * Kwa mfano:\n *     @code\n *     std::cout << f_46(10); // Inatoa: 33 (3 + 5 + 6 + 9 + 10)\n *     @endcode\n *\n * @param n Kikomo cha juu cha safu ya kuangalia marudufu.\n * @return Jumla ya marudufu ya 3 au 5 ndani ya safu.\n */\nint f_46(int n)", "tr": "#include <cassert>\n#include <iostream>\n/**\n * @brief 1'den n'e kadar olan sayılardan 3 veya 5'in katı olanların toplamını hesaplar.\n *\n * Her sayıyı yalnızca bir kez sayar, eğer hem 3 hem de 5'in katıysa bile.\n * Örneğin:\n *     @code\n *     std::cout << f_46(10); // Çıktı: 33 (3 + 5 + 6 + 9 + 10)\n *     @endcode\n *\n * @param n Katları kontrol edilecek aralığın üst sınırı.\n * @return Aralık içindeki 3 veya 5'in katlarının toplamı.\n */\nint f_46(int n)", "vi": "#include <cassert>\n#include <iostream>\n/**\n * @brief Tính tổng của tất cả các số từ 1 đến n là bội số của 3 hoặc 5.\n *\n * Đếm mỗi số chỉ một lần ngay cả khi nó là bội số của cả 3 và 5.\n * Ví dụ:\n *     @code\n *     std::cout << f_46(10); // Xuất ra: 33 (3 + 5 + 6 + 9 + 10)\n *     @endcode\n *\n * @param n Giới hạn trên của phạm vi để kiểm tra bội số.\n * @return Tổng của các bội số của 3 hoặc 5 trong phạm vi.\n */\nint f_46(int n)", "id": "#include <cassert>\n#include <iostream>\n/**\n * @brief Menghitung jumlah semua angka dari 1 hingga n yang merupakan kelipatan dari 3 atau 5.\n *\n * Menghitung setiap angka hanya sekali meskipun merupakan kelipatan dari 3 dan 5.\n * Sebagai contoh:\n *     @code\n *     std::cout << f_46(10); // Menghasilkan: 33 (3 + 5 + 6 + 9 + 10)\n *     @endcode\n *\n * @param n Batas atas dari rentang untuk memeriksa kelipatan.\n * @return Jumlah dari kelipatan 3 atau 5 dalam rentang tersebut.\n */\nint f_46(int n)", "ja": "#include <cassert>\n#include <iostream>\n/**\n * @brief 1からnまでの数のうち、3または5の倍数の合計を計算します。\n *\n * 3と5の両方の倍数である場合でも、各数を一度だけカウントします。\n * 例えば:\n *     @code\n *     std::cout << f_46(10); // 出力: 33 (3 + 5 + 6 + 9 + 10)\n *     @endcode\n *\n * @param n 倍数をチェックする範囲の上限。\n * @return 範囲内の3または5の倍数の合計。\n */\nint f_46(int n)", "ko": "#include <cassert>\n#include <iostream>\n/**\n * @brief 1부터 n까지의 숫자 중 3 또는 5의 배수인 숫자의 합을 계산합니다.\n *\n * 3과 5의 배수인 경우에도 각 숫자는 한 번만 계산됩니다.\n * 예를 들어:\n *     @code\n *     std::cout << f_46(10); // 출력: 33 (3 + 5 + 6 + 9 + 10)\n *     @endcode\n *\n * @param n 배수를 확인할 범위의 상한값입니다.\n * @return 범위 내에서 3 또는 5의 배수의 합을 반환합니다.\n */\nint f_46(int n)", "ml": "#include <cassert>\n#include <iostream>\n/**\n * @brief 1 മുതൽ n വരെ ഉള്ള എല്ലാ സംഖ്യകളുടെയും തുക കണക്കാക്കുന്നു, അവ 3 അല്ലെങ്കിൽ 5 ന്റെ ഗുണിതങ്ങളാണെങ്കിൽ.\n *\n * 3 ന്റെയും 5 ന്റെയും ഗുണിതമാണെങ്കിലും ഓരോ സംഖ്യയും ഒരിക്കൽ മാത്രം എണ്ണുന്നു.\n * ഉദാഹരണത്തിന്:\n *     @code\n *     std::cout << f_46(10); // Outputs: 33 (3 + 5 + 6 + 9 + 10)\n *     @endcode\n *\n * @param n ഗുണിതങ്ങൾ പരിശോധിക്കാനുള്ള പരിധിയുടെ മുകളിലെ അതിർത്തി.\n * @return പരിധിക്കുള്ളിൽ 3 അല്ലെങ്കിൽ 5 ന്റെ ഗുണിതങ്ങളുടെ തുക.\n */\nint f_46(int n)", "fa": "#include <cassert>\n#include <iostream>\n/**\n * @brief محاسبه مجموع تمام اعداد از 1 تا n که مضرب 3 یا 5 هستند.\n *\n * هر عدد تنها یک بار شمارش می‌شود حتی اگر مضرب هر دو 3 و 5 باشد.\n * برای مثال:\n *     @code\n *     std::cout << f_46(10); // خروجی: 33 (3 + 5 + 6 + 9 + 10)\n *     @endcode\n *\n * @param n حد بالای بازه‌ای که برای مضرب‌ها بررسی می‌شود.\n * @return مجموع مضرب‌های 3 یا 5 درون بازه.\n */\nint f_46(int n)"}, "canonical_solution": "{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}", "instruction": {"en": "Write a CPP function `int f_46(int n)` to solve the following problem:\nComputes the sum of all numbers from 1 to n that are multiples of either 3 or 5.\n\nCounts each number only once even if it is a multiple of both 3 and 5.\nFor example:\n    std::cout << f_46(10); // Outputs: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n The upper bound of the range to check for multiples.\n@return The sum of the multiples of either 3 or 5 within the range.", "sq": "Shkruani një funksion CPP `int f_46(int n)` për të zgjidhur problemin e mëposhtëm:\nLlogarit shumën e të gjitha numrave nga 1 deri në n që janë shumëfish i 3 ose 5.\n\nNumëroni çdo numër vetëm një herë edhe nëse është shumëfish i të dyjave 3 dhe 5.\nPër shembull:\n    std::cout << f_46(10); // Outputs: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n Kufiri i sipërm i intervalit për të kontrolluar për shumëfish.\n@return Shuma e shumëfishave të 3 ose 5 brenda intervalit.", "hy": "Գրեք CPP ֆունկցիա `int f_46(int n)` հետևյալ խնդիրը լուծելու համար:\nՀաշվում է 1-ից n բոլոր թվերի գումարը, որոնք բազմապատիկ են 3-ի կամ 5-ի:\n\nՅուրաքանչյուր թիվ հաշվում է միայն մեկ անգամ, նույնիսկ եթե այն բազմապատիկ է և՛ 3-ի, և՛ 5-ի:\nՕրինակ:\n    std::cout << f_46(10); // Արդյունք: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n Շրջանակի վերին սահմանը, որտեղ պետք է ստուգել բազմապատիկները:\n@return 3-ի կամ 5-ի բազմապատիկների գումարը տրված շրջանակում:", "bn": "একটি CPP ফাংশন `int f_46(int n)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\n১ থেকে n পর্যন্ত সমস্ত সংখ্যার যোগফল গণনা করে যা ৩ বা ৫ এর গুণিতক।\n\nপ্রতিটি সংখ্যাকে কেবল একবার গণনা করে, এমনকি যদি এটি ৩ এবং ৫ উভয়ের গুণিতক হয়।\nউদাহরণস্বরূপ:\n    std::cout << f_46(10); // Outputs: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n গুণিতক চেক করার জন্য পরিসরের উপরের সীমা।\n@return পরিসরের মধ্যে ৩ বা ৫ এর গুণিতকগুলোর যোগফল।", "bg": "Напишете CPP функция `int f_46(int n)`, за да решите следния проблем:\nИзчислява сумата на всички числа от 1 до n, които са кратни на 3 или 5.\n\nБрои всяко число само веднъж, дори ако е кратно и на 3, и на 5.\nНапример:\n    std::cout << f_46(10); // Извежда: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n Горната граница на диапазона за проверка на кратни.\n@return Сумата на кратните на 3 или 5 в рамките на диапазона.", "zh": "编写一个 CPP 函数 `int f_46(int n)` 来解决以下问题：\n\n计算从 1 到 n 的所有数字中是 3 或 5 的倍数的总和。\n\n即使一个数字同时是 3 和 5 的倍数，也只计算一次。\n例如：\n    std::cout << f_46(10); // 输出: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n 要检查倍数的范围上限。\n@return 范围内 3 或 5 的倍数的总和。", "fr": "Écrire une fonction CPP `int f_46(int n)` pour résoudre le problème suivant :\nCalcule la somme de tous les nombres de 1 à n qui sont des multiples de 3 ou de 5.\n\nCompte chaque nombre une seule fois même s'il est un multiple à la fois de 3 et de 5.\nPar exemple :\n    std::cout << f_46(10); // Outputs: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n La limite supérieure de la plage à vérifier pour les multiples.\n@return La somme des multiples de 3 ou 5 dans la plage.", "de": "Schreiben Sie eine CPP-Funktion `int f_46(int n)`, um das folgende Problem zu lösen:\nBerechnet die Summe aller Zahlen von 1 bis n, die Vielfache von entweder 3 oder 5 sind.\n\nZählt jede Zahl nur einmal, auch wenn sie ein Vielfaches von sowohl 3 als auch 5 ist.\nZum Beispiel:\n    std::cout << f_46(10); // Gibt aus: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n Die obere Grenze des Bereichs, in dem nach Vielfachen gesucht wird.\n@return Die Summe der Vielfachen von entweder 3 oder 5 innerhalb des Bereichs.", "ha": "Rubuta aikin CPP `int f_46(int n)` don warware matsalar mai zuwa:  \nLissafa jimillar duk lambobin daga 1 zuwa n waɗanda suke masu yawa na ko dai 3 ko 5.\n\nKirga kowace lamba sau ɗaya kawai ko da kuwa tana mai yawa ne na 3 da 5 duka.  \nAlal misali:  \n    std::cout << f_46(10); // Yana fitarwa: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n Ƙarshen iyaka na zangon da za a duba don masu yawa.  \n@return Jimillar masu yawa na ko dai 3 ko 5 a cikin zangon.", "hi": "`int f_46(int n)` नामक एक CPP फ़ंक्शन लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nउन सभी संख्याओं का योग गणना करता है जो 1 से n तक हैं और 3 या 5 के गुणज हैं।\n\nप्रत्येक संख्या को केवल एक बार गिना जाता है, भले ही वह 3 और 5 दोनों का गुणज हो।\nउदाहरण के लिए:\n    std::cout << f_46(10); // Outputs: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n वह ऊपरी सीमा है जिसकी सीमा में गुणजों की जांच की जानी है।\n@return 3 या 5 के गुणजों का सीमा के भीतर योग।", "hu": "Írj egy CPP függvényt `int f_46(int n)` a következő probléma megoldására:\nKiszámítja az összes szám összegét 1-től n-ig, amelyek 3 vagy 5 többszörösei.\n\nMinden számot csak egyszer számol, még akkor is, ha mind 3, mind 5 többszöröse.\nPéldául:\n    std::cout << f_46(10); // Kimenet: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n A tartomány felső határa, amelyben a többszörösöket ellenőrizzük.\n@return A 3 vagy 5 többszöröseinek összege a tartományon belül.", "es": "Escribe una función CPP `int f_46(int n)` para resolver el siguiente problema:\nCalcula la suma de todos los números del 1 al n que son múltiplos de 3 o 5.\n\nCuenta cada número solo una vez, incluso si es múltiplo de ambos 3 y 5.\nPor ejemplo:\n    std::cout << f_46(10); // Salidas: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n El límite superior del rango para verificar múltiplos.\n@return La suma de los múltiplos de 3 o 5 dentro del rango.", "arb": "اكتب دالة CPP `int f_46(int n)` لحل المشكلة التالية:\nتحسب مجموع جميع الأرقام من 1 إلى n التي هي مضاعفات لـ 3 أو 5.\n\nتحسب كل رقم مرة واحدة فقط حتى لو كان مضاعفًا لكل من 3 و 5.\nعلى سبيل المثال:\n    std::cout << f_46(10); // Outputs: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n الحد الأعلى للنطاق للتحقق من المضاعفات.\n@return مجموع المضاعفات لـ 3 أو 5 ضمن النطاق.", "sw": "Andika kazi ya CPP `int f_46(int n)` kutatua tatizo lifuatalo:\nHesabu jumla ya namba zote kutoka 1 hadi n ambazo ni marudio ya ama 3 au 5.\n\nHesabu kila namba mara moja tu hata kama ni marudio ya 3 na 5.\nKwa mfano:\n    std::cout << f_46(10); // Inatoa: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n Kikomo cha juu cha safu ya kuangalia marudio.\n@return Jumla ya marudio ya ama 3 au 5 ndani ya safu.", "tr": "Bir CPP fonksiyonu `int f_46(int n)` yazın ve aşağıdaki problemi çözün:\n1'den n'ye kadar olan sayılardan 3 veya 5'in katı olanların toplamını hesaplar.\n\nBir sayı hem 3 hem de 5'in katı olsa bile her sayıyı yalnızca bir kez sayar.\nÖrneğin:\n    std::cout << f_46(10); // Çıktı: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n Katları kontrol etmek için aralığın üst sınırı.\n@return Aralık içindeki 3 veya 5'in katlarının toplamı.", "vi": "Viết một hàm CPP `int f_46(int n)` để giải quyết vấn đề sau:\nTính tổng của tất cả các số từ 1 đến n mà là bội số của 3 hoặc 5.\n\nĐếm mỗi số chỉ một lần ngay cả khi nó là bội số của cả 3 và 5.\nVí dụ:\n    std::cout << f_46(10); // Outputs: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n Giới hạn trên của phạm vi để kiểm tra các bội số.\n@return Tổng của các bội số của 3 hoặc 5 trong phạm vi.", "id": "Tulis fungsi CPP `int f_46(int n)` untuk menyelesaikan masalah berikut:\nMenghitung jumlah semua angka dari 1 hingga n yang merupakan kelipatan dari 3 atau 5.\n\nMenghitung setiap angka hanya sekali meskipun itu adalah kelipatan dari 3 dan 5.\nSebagai contoh:\n    std::cout << f_46(10); // Menghasilkan: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n Batas atas dari rentang untuk memeriksa kelipatan.\n@return Jumlah dari kelipatan 3 atau 5 dalam rentang tersebut.", "ja": "`int f_46(int n)` というCPP関数を作成して、次の問題を解決してください:\n1からnまでのすべての数のうち、3または5の倍数である数の合計を計算します。\n\n3と5の両方の倍数である場合でも、各数は一度だけカウントします。\n例えば:\n    std::cout << f_46(10); // 出力: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n 倍数をチェックする範囲の上限。\n@return 範囲内の3または5の倍数の合計。", "ko": "`int f_46(int n)` 함수를 작성하여 다음 문제를 해결하십시오:\n1부터 n까지의 숫자 중 3 또는 5의 배수인 모든 숫자의 합을 계산합니다.\n\n각 숫자는 3과 5의 배수인 경우에도 한 번만 계산합니다.\n예를 들어:\n    std::cout << f_46(10); // 출력: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n 배수를 확인할 범위의 상한값입니다.\n@return 범위 내에서 3 또는 5의 배수의 합입니다.", "ml": "`int f_46(int n)` എന്ന CPP ഫംഗ്ഷൻ എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\n1 മുതൽ n വരെ 3 അല്ലെങ്കിൽ 5 ന്റെ ഗുണിതകങ്ങൾ ആയ എല്ലാ സംഖ്യകളുടെയും മൊത്തം കണക്കാക്കുക.\n\nഒരു സംഖ്യ 3 നും 5 നും ഗുണിതകമാണെങ്കിൽ പോലും ഓരോ സംഖ്യയും ഒരിക്കൽ മാത്രമേ എണ്ണൂ.\nഉദാഹരണത്തിന്:\n    std::cout << f_46(10); // ഔട്ട്പുട്ട്: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n ഗുണിതകങ്ങൾ പരിശോധിക്കാനുള്ള പരിധിയുടെ മുകളിലെ പരിധി.\n@return പരിധിയിലുള്ള 3 അല്ലെങ്കിൽ 5 ന്റെ ഗുണിതകങ്ങളുടെ മൊത്തം.", "fa": "یک تابع CPP به نام `int f_46(int n)` بنویسید تا مسئله زیر را حل کند:\nمجموع تمام اعداد از 1 تا n را که مضرب 3 یا 5 هستند محاسبه می‌کند.\n\nهر عدد را فقط یک بار بشمارید حتی اگر مضرب هر دو 3 و 5 باشد.\nبرای مثال:\n    std::cout << f_46(10); // خروجی: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n حد بالای بازه‌ای که باید برای مضرب‌ها بررسی شود.\n@return مجموع مضرب‌های 3 یا 5 درون بازه."}, "level": "easy", "test": "int main()\n{\n    assert(f_46(10) == 33);\n    assert(f_46(15) == 60);\n    assert(f_46(20) == 98);\n    assert(f_46(5) == 8);\n    assert(f_46(3) == 3);\n    assert(f_46(6) == 14);\n    assert(f_46(9) == 23);\n    assert(f_46(12) == 45);\n    assert(f_46(17) == 60);\n    assert(f_46(21) == 119);\n    assert(f_46(25) == 168);\n\n    return 0;\n}", "entry_point": "f_46", "signature": "int f_46(int n)", "docstring": {"en": "Computes the sum of all numbers from 1 to n that are multiples of either 3 or 5.\n\nCounts each number only once even if it is a multiple of both 3 and 5.\nFor example:\n    std::cout << f_46(10); // Outputs: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n The upper bound of the range to check for multiples.\n@return The sum of the multiples of either 3 or 5 within the range.", "sq": "Llogarit shumën e të gjitha numrave nga 1 deri në n që janë shumëfish i 3 ose 5.\n\nNumëron secilin numër vetëm një herë edhe nëse është shumëfish i të dyjave, 3 dhe 5.\nPër shembull:\n    std::cout << f_46(10); // Shfaq: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n Kufiri i sipërm i intervalit për të kontrolluar për shumëfish.\n@return Shuma e shumëfishëve të 3 ose 5 brenda intervalit.", "hy": "Հաշվում է 1-ից n բոլոր թվերի գումարը, որոնք բազմապատիկ են կամ 3-ի, կամ 5-ի։\n\nՅուրաքանչյուր թիվ հաշվում է միայն մեկ անգամ, նույնիսկ եթե այն բազմապատիկ է և՛ 3-ի, և՛ 5-ի։\nՕրինակ՝\n    std::cout << f_46(10); // Արդյունք՝ 33 (3 + 5 + 6 + 9 + 10)\n\n@param n Շրջանակի վերին սահմանը բազմապատիկների ստուգման համար։\n@return 3-ի կամ 5-ի բազմապատիկների գումարը տրված շրջանակում։", "bn": "1 থেকে n পর্যন্ত সমস্ত সংখ্যার যোগফল গণনা করে যা 3 বা 5 এর গুণিতক।\n\nপ্রতিটি সংখ্যাকে কেবল একবার গণনা করা হয়, এমনকি যদি এটি 3 এবং 5 উভয়ের গুণিতক হয়।\nউদাহরণস্বরূপ:\n    std::cout << f_46(10); // আউটপুট: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n গুণিতক চেক করার জন্য পরিসরের উপরের সীমা।\n@return পরিসরের মধ্যে 3 বা 5 এর গুণিতকের যোগফল।", "bg": "Изчислява сумата на всички числа от 1 до n, които са кратни на 3 или 5.\n\nБрои всяко число само веднъж, дори ако е кратно и на 3, и на 5.\nНапример:\n    std::cout << f_46(10); // Извежда: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n Горната граница на диапазона за проверка на кратни.\n@return Сумата на кратните на 3 или 5 в рамките на диапазона.", "zh": "计算从 1 到 n 的所有 3 或 5 的倍数的和。\n\n即使一个数字同时是 3 和 5 的倍数，也只计算一次。\n例如：\n    std::cout << f_46(10); // 输出: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n 要检查倍数的范围上限。\n@return 范围内 3 或 5 的倍数之和。", "fr": "Calcule la somme de tous les nombres de 1 à n qui sont des multiples de 3 ou 5.\n\nCompte chaque nombre une seule fois même s'il est un multiple à la fois de 3 et de 5.\nPar exemple :\n    std::cout << f_46(10); // Affiche : 33 (3 + 5 + 6 + 9 + 10)\n\n@param n La limite supérieure de la plage à vérifier pour les multiples.\n@return La somme des multiples de 3 ou 5 dans la plage.", "de": "Berechnet die Summe aller Zahlen von 1 bis n, die Vielfache von entweder 3 oder 5 sind.\n\nZählt jede Zahl nur einmal, auch wenn sie ein Vielfaches von sowohl 3 als auch 5 ist.\nZum Beispiel:\n    std::cout << f_46(10); // Gibt aus: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n Die obere Grenze des Bereichs, in dem nach Vielfachen gesucht wird.\n@return Die Summe der Vielfachen von entweder 3 oder 5 innerhalb des Bereichs.", "ha": "Lissafi jimillar dukkan lambobi daga 1 zuwa n waɗanda suke lambobi masu yawa na 3 ko 5.\n\nYana ƙididdige kowanne lamba sau ɗaya kawai ko da kuwa yana ninkawa ne na 3 da 5.\nMisali:\n    std::cout << f_46(10); // Outputs: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n Babban iyaka na zangon da za a duba don ninkawa.\n@return Jimillar lambobin da suke ninkawa na ko dai 3 ko 5 a cikin zangon.", "hi": "1 से n तक के सभी संख्याओं का योग गणना करता है जो या तो 3 या 5 के गुणज हैं।\n\nप्रत्येक संख्या को केवल एक बार गिना जाता है, भले ही वह 3 और 5 दोनों का गुणज हो।\nउदाहरण के लिए:\n    std::cout << f_46(10); // आउटपुट: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n वह ऊपरी सीमा है जिस रेंज में गुणजों की जांच की जानी है।\n@return उस रेंज के भीतर 3 या 5 के गुणजों का योग।", "hu": "Számítja az 1-től n-ig terjedő összes szám összegét, amelyek 3 vagy 5 többszörösei.\n\nMinden számot csak egyszer számol, még akkor is, ha az 3-nak és 5-nek is többszöröse.\nPéldául:\n    std::cout << f_46(10); // Kimenet: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n A tartomány felső határa, amelyet a többszörösök ellenőrzésére használunk.\n@return A 3 vagy 5 többszöröseinek összege a tartományon belül.", "es": "Calcula la suma de todos los números desde 1 hasta n que son múltiplos de 3 o 5.\n\nCuenta cada número solo una vez, incluso si es múltiplo de ambos 3 y 5.\nPor ejemplo:\n    std::cout << f_46(10); // Salidas: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n El límite superior del rango para verificar múltiplos.\n@return La suma de los múltiplos de 3 o 5 dentro del rango.", "arb": "يحسب مجموع كل الأرقام من 1 إلى n التي هي مضاعفات لـ 3 أو 5.\n\nيحسب كل رقم مرة واحدة فقط حتى لو كان مضاعفًا لكل من 3 و 5.\nعلى سبيل المثال:\n    std::cout << f_46(10); // المخرجات: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n الحد الأعلى للنطاق للتحقق من المضاعفات.\n@return مجموع المضاعفات لـ 3 أو 5 ضمن النطاق.", "sw": "Hesabu jumla ya namba zote kutoka 1 hadi n ambazo ni marudio ya aidha 3 au 5.\n\nHesabu kila namba mara moja tu hata kama ni marudio ya 3 na 5.\nKwa mfano:\n    std::cout << f_46(10); // Inatoa: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n Kikomo cha juu cha safu ya kuangalia marudio.\n@return Jumla ya marudio ya aidha 3 au 5 ndani ya safu.", "tr": "1'den n'ye kadar olan sayılardan 3 veya 5'in katı olanların toplamını hesaplar.\n\nHer sayıyı yalnızca bir kez sayar, 3 ve 5'in her ikisinin de katı olsa bile.\nÖrneğin:\n    std::cout << f_46(10); // Çıktı: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n Katları kontrol edilecek aralığın üst sınırı.\n@return Aralık içindeki 3 veya 5'in katlarının toplamı.", "vi": "Tính tổng của tất cả các số từ 1 đến n là bội số của 3 hoặc 5.\n\nĐếm mỗi số chỉ một lần ngay cả khi nó là bội số của cả 3 và 5.\nVí dụ:\n    std::cout << f_46(10); // Xuất ra: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n Giới hạn trên của phạm vi để kiểm tra bội số.\n@return Tổng của các bội số của 3 hoặc 5 trong phạm vi.", "id": "Menghitung jumlah semua angka dari 1 hingga n yang merupakan kelipatan dari 3 atau 5.\n\nMenghitung setiap angka hanya sekali meskipun merupakan kelipatan dari 3 dan 5.\nSebagai contoh:\n    std::cout << f_46(10); // Menghasilkan: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n Batas atas dari rentang untuk memeriksa kelipatan.\n@return Jumlah dari kelipatan 3 atau 5 dalam rentang tersebut.", "ja": "1からnまでのすべての数のうち、3または5の倍数であるものの合計を計算します。\n\n3と5の両方の倍数である場合でも、各数は一度だけカウントされます。\n例えば:\n    std::cout << f_46(10); // 出力: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n 倍数をチェックする範囲の上限。\n@return 範囲内の3または5の倍数の合計。", "ko": "1부터 n까지의 숫자 중 3 또는 5의 배수인 모든 숫자의 합을 계산합니다.\n\n3과 5의 공배수인 경우에도 각 숫자는 한 번만 계산합니다.\n예를 들어:\n    std::cout << f_46(10); // 출력: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n 배수를 확인할 범위의 상한값입니다.\n@return 범위 내에서 3 또는 5의 배수의 합을 반환합니다.", "ml": "1 മുതൽ n വരെ ഉള്ള എല്ലാ സംഖ്യകളുടെയും തുക കണക്കാക്കുന്നു, അവ 3 അല്ലെങ്കിൽ 5 ന്റെ ഗുണിതങ്ങളാണെങ്കിൽ.\n\n3 നും 5 നും രണ്ടിന്റെയും ഗുണകമെങ്കിൽ പോലും ഓരോ സംഖ്യയും ഒരിക്കൽ മാത്രമേ എണ്ണൂ.\nഉദാഹരണത്തിന്:\n    std::cout << f_46(10); // Outputs: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n ഗുണകങ്ങൾ പരിശോധിക്കാനുള്ള പരിധിയുടെ മുകളിലെ അതിർത്തി.\n@return പരിധിക്കുള്ളിൽ 3 നും 5 നും ഏതെങ്കിലും ഒന്നിന്റെ ഗുണകങ്ങളുടെ മൊത്തം.", "fa": "مجموع تمام اعداد از 1 تا n که مضربی از 3 یا 5 هستند را محاسبه می‌کند.\n\nهر عدد را فقط یک بار می‌شمارد حتی اگر مضربی از هر دو عدد 3 و 5 باشد.\nبرای مثال:\n    std::cout << f_46(10); // خروجی: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n حد بالای بازه‌ای که برای مضرب‌ها بررسی می‌شود.\n@return مجموع مضرب‌های 3 یا 5 درون بازه."}}
{"task_id": "CPP/47", "prompt": {"en": "#include <cassert>\n#include <cctype> // For isalnum and tolower\n#include <cstring> // For strlen\n/**\n * Determine if a given string is a palindrome. A palindrome is a word, phrase,\n * number, or other sequence of characters that reads the same forward and\n * backward (ignoring spaces, punctuation, and capitalization).\n * Examples:\n *   >>> f_47(\"racecar\")\n *   true\n *   >>> f_47(\"hello\")\n *   false\n */\nbool f_47(const char* str)", "sq": "#include <cassert>\n#include <cctype> // Për isalnum dhe tolower\n#include <cstring> // Për strlen\n/**\n * Përcaktoni nëse një varg i dhënë është një palindrom. Një palindrom është një fjalë, frazë,\n * numër, ose sekuencë tjetër karakteresh që lexohet njësoj përpara dhe\n * prapa (duke injoruar hapësirat, shenjat e pikësimit dhe kapitalizimin).\n * Shembuj:\n *   >>> f_47(\"racecar\")\n *   true\n *   >>> f_47(\"hello\")\n *   false\n */\nbool f_47(const char* str)", "hy": "#include <cassert>\n#include <cctype> // isalnum և tolower-ի համար\n#include <cstring> // strlen-ի համար\n/**\n * Սահմանել, արդյոք տրված տողը պալինդրոմ է։ Պալինդրոմը բառ, արտահայտություն,\n * թիվ կամ այլ նիշերի հաջորդականություն է, որը կարդացվում է նույն կերպ առաջ\n * և հետ (անտեսելով բացատները, կետադրությունը և մեծատառերը)։\n * Օրինակներ:\n *   >>> f_47(\"racecar\")\n *   true\n *   >>> f_47(\"hello\")\n *   false\n */\nbool f_47(const char* str)", "bn": "#include <cassert>\n#include <cctype> // isalnum এবং tolower এর জন্য\n#include <cstring> // strlen এর জন্য\n/**\n * নির্ধারণ করুন একটি প্রদত্ত স্ট্রিং প্যালিনড্রোম কিনা। একটি প্যালিনড্রোম হল একটি শব্দ, বাক্যাংশ,\n * সংখ্যা, বা অন্যান্য অক্ষরের ক্রম যা সামনের দিকে এবং\n * পিছনের দিকে একইভাবে পড়ে (স্পেস, বিরামচিহ্ন, এবং বড় হাতের অক্ষর উপেক্ষা করে)।\n * উদাহরণ:\n *   >>> f_47(\"racecar\")\n *   true\n *   >>> f_47(\"hello\")\n *   false\n */\nbool f_47(const char* str)", "bg": "#include <cassert>\n#include <cctype> // За isalnum и tolower\n#include <cstring> // За strlen\n/**\n * Определя дали даден низ е палиндром. Палиндром е дума, фраза,\n * число или друга последователност от символи, която се чете еднакво напред и\n * назад (като се игнорират интервали, пунктуация и главни букви).\n * Примери:\n *   >>> f_47(\"racecar\")\n *   true\n *   >>> f_47(\"hello\")\n *   false\n */\nbool f_47(const char* str)", "zh": "#include <cassert>\n#include <cctype> // For isalnum and tolower\n#include <cstring> // For strlen\n/**\n * 确定给定字符串是否为回文。回文是指正反读都相同的单词、短语、数字或其他字符序列（忽略空格、标点和大小写）。\n * 示例:\n *   >>> f_47(\"racecar\")\n *   true\n *   >>> f_47(\"hello\")\n *   false\n */\nbool f_47(const char* str)", "fr": "#include <cassert>\n#include <cctype> // Pour isalnum et tolower\n#include <cstring> // Pour strlen\n/**\n * Détermine si une chaîne donnée est un palindrome. Un palindrome est un mot, une phrase,\n * un nombre ou une autre séquence de caractères qui se lit de la même manière à l'endroit et\n * à l'envers (en ignorant les espaces, la ponctuation et les majuscules).\n * Exemples :\n *   >>> f_47(\"racecar\")\n *   true\n *   >>> f_47(\"hello\")\n *   false\n */\nbool f_47(const char* str)", "de": "#include <cassert>\n#include <cctype> // Für isalnum und tolower\n#include <cstring> // Für strlen\n/**\n * Bestimmen, ob ein gegebener String ein Palindrom ist. Ein Palindrom ist ein Wort, ein Satz,\n * eine Zahl oder eine andere Zeichenfolge, die vorwärts und rückwärts gleich gelesen wird\n * (unter Ignorierung von Leerzeichen, Interpunktion und Groß-/Kleinschreibung).\n * Beispiele:\n *   >>> f_47(\"racecar\")\n *   true\n *   >>> f_47(\"hello\")\n *   false\n */\nbool f_47(const char* str)", "ha": "#include <cassert>\n#include <cctype> // Don amfani da isalnum da tolower\n#include <cstring> // Don amfani da strlen\n/**\n * Tantance idan wani kirtani da aka bayar palindrome ne. Palindrome kalma ce, jimla,\n * lamba, ko wata jerin haruffa da ake karantawa iri ɗaya a gaba da baya\n * (ba tare da la'akari da sarari, rubutun alama, da manyan ba).\n * Misalai:\n *   >>> f_47(\"racecar\")\n *   true\n *   >>> f_47(\"hello\")\n *   false\n */\nbool f_47(const char* str)", "hi": "#include <cassert>\n#include <cctype> // isalnum और tolower के लिए\n#include <cstring> // strlen के लिए\n/**\n * यह निर्धारित करें कि दिया गया स्ट्रिंग एक पालिंड्रोम है या नहीं। एक पालिंड्रोम एक शब्द, वाक्यांश,\n * संख्या, या अन्य वर्णों का अनुक्रम है जो आगे और पीछे से समान पढ़ता है \n * (स्पेस, विराम चिह्न, और बड़े अक्षरों की अनदेखी करते हुए)।\n * उदाहरण:\n *   >>> f_47(\"racecar\")\n *   true\n *   >>> f_47(\"hello\")\n *   false\n */\nbool f_47(const char* str)", "hu": "#include <cassert>\n#include <cctype> // For isalnum and tolower\n#include <cstring> // For strlen\n/**\n * Határozza meg, hogy egy adott string palindróm-e. Egy palindróm egy szó, kifejezés,\n * szám vagy más karakterek sorozata, amely előre és hátrafelé olvasva is ugyanaz\n * (figyelmen kívül hagyva a szóközöket, írásjeleket és a nagybetűket).\n * Példák:\n *   >>> f_47(\"racecar\")\n *   true\n *   >>> f_47(\"hello\")\n *   false\n */\nbool f_47(const char* str)", "es": "#include <cassert>\n#include <cctype> // For isalnum and tolower\n#include <cstring> // For strlen\n/**\n * Determinar si una cadena dada es un palíndromo. Un palíndromo es una palabra, frase,\n * número u otra secuencia de caracteres que se lee igual de adelante hacia atrás\n * y de atrás hacia adelante (ignorando espacios, puntuación y capitalización).\n * Ejemplos:\n *   >>> f_47(\"racecar\")\n *   true\n *   >>> f_47(\"hello\")\n *   false\n */\nbool f_47(const char* str)", "arb": "#include <cassert>\n#include <cctype> // For isalnum and tolower\n#include <cstring> // For strlen\n/**\n * تحديد ما إذا كانت سلسلة معينة هي كلمة متطابقة. الكلمة المتطابقة هي كلمة أو عبارة أو\n * رقم أو تسلسل آخر من الأحرف الذي يقرأ نفسه بنفس الطريقة من الأمام والخلف \n * (مع تجاهل المسافات وعلامات الترقيم والحروف الكبيرة).\n * أمثلة:\n *   >>> f_47(\"racecar\")\n *   true\n *   >>> f_47(\"hello\")\n *   false\n */\nbool f_47(const char* str)", "sw": "#include <cassert>\n#include <cctype> // For isalnum and tolower\n#include <cstring> // For strlen\n/**\n * Kuamua kama mfuatano uliotolewa ni palindrome. Palindrome ni neno, kifungu,\n * nambari, au mfuatano mwingine wa herufi ambao unasomwa sawa mbele na\n * nyuma (ukipuuza nafasi, alama za uakifishaji, na herufi kubwa).\n * Mifano:\n *   >>> f_47(\"racecar\")\n *   true\n *   >>> f_47(\"hello\")\n *   false\n */\nbool f_47(const char* str)", "tr": "#include <cassert>\n#include <cctype> // isalnum ve tolower için\n#include <cstring> // strlen için\n/**\n * Belirtilen bir dizgenin palindrom olup olmadığını belirleyin. Palindrom, ileri ve geri\n * okunduğunda aynı olan (boşluklar, noktalama işaretleri ve büyük/küçük harf farkı göz ardı edilerek)\n * bir kelime, ifade, sayı veya başka bir karakter dizisidir.\n * Örnekler:\n *   >>> f_47(\"racecar\")\n *   true\n *   >>> f_47(\"hello\")\n *   false\n */\nbool f_47(const char* str)", "vi": "#include <cassert>\n#include <cctype> // For isalnum and tolower\n#include <cstring> // For strlen\n/**\n * Xác định xem một chuỗi cho trước có phải là một chuỗi palindrome hay không. Một chuỗi palindrome là một từ, cụm từ,\n * số, hoặc một dãy ký tự khác mà đọc xuôi hay ngược đều như nhau (bỏ qua khoảng trắng, dấu câu và chữ hoa).\n * Ví dụ:\n *   >>> f_47(\"racecar\")\n *   true\n *   >>> f_47(\"hello\")\n *   false\n */\nbool f_47(const char* str)", "id": "#include <cassert>\n#include <cctype> // Untuk isalnum dan tolower\n#include <cstring> // Untuk strlen\n/**\n * Menentukan apakah string yang diberikan adalah palindrome. Palindrome adalah sebuah kata, frasa,\n * angka, atau urutan karakter lain yang dibaca sama dari depan ke belakang\n * (mengabaikan spasi, tanda baca, dan kapitalisasi).\n * Contoh:\n *   >>> f_47(\"racecar\")\n *   true\n *   >>> f_47(\"hello\")\n *   false\n */\nbool f_47(const char* str)", "ja": "#include <cassert>\n#include <cctype> // For isalnum and tolower\n#include <cstring> // For strlen\n/**\n * 与えられた文字列が回文かどうかを判断します。回文とは、前から読んでも後ろから読んでも同じになる単語、フレーズ、\n * 数字、または他の文字列のことです（スペース、句読点、大文字小文字を無視します）。\n * 例:\n *   >>> f_47(\"racecar\")\n *   true\n *   >>> f_47(\"hello\")\n *   false\n */\nbool f_47(const char* str)", "ko": "#include <cassert>\n#include <cctype> // For isalnum and tolower\n#include <cstring> // For strlen\n/**\n * 주어진 문자열이 회문인지 여부를 결정합니다. 회문은 앞뒤로 읽어도 동일한 단어, 구문,\n * 숫자 또는 기타 문자 시퀀스를 말합니다 (공백, 구두점 및 대소문자는 무시).\n * 예시:\n *   >>> f_47(\"racecar\")\n *   true\n *   >>> f_47(\"hello\")\n *   false\n */\nbool f_47(const char* str)", "ml": "#include <cassert>\n#include <cctype> // isalnum, tolower എന്നിവയ്ക്കായി\n#include <cstring> // strlen നായി\n/**\n * നൽകിയ ഒരു സ്ട്രിംഗ് പാലിൻഡ്രോമാണോ എന്ന് നിർണയിക്കുക. പാലിൻഡ്രോം എന്നത് ഒരു വാക്ക്, വാചകം,\n * സംഖ്യ, അല്ലെങ്കിൽ മറ്റ് പ്രതീകങ്ങളുടെ നിരയാണ്, ഇത് മുന്നോട്ടും\n * പിന്നോട്ടും ഒരേപോലെ വായിക്കപ്പെടുന്നു (സ്പേസുകൾ, ചിഹ്നങ്ങൾ, ക്യാപിറ്റലൈസേഷൻ എന്നിവ അവഗണിക്കുന്നു).\n * ഉദാഹരണങ്ങൾ:\n *   >>> f_47(\"racecar\")\n *   true\n *   >>> f_47(\"hello\")\n *   false\n */\nbool f_47(const char* str)", "fa": "#include <cassert>\n#include <cctype> // برای isalnum و tolower\n#include <cstring> // برای strlen\n/**\n * تعیین کنید که آیا یک رشته داده شده یک پالیندروم است یا خیر. یک پالیندروم یک کلمه، عبارت،\n * عدد یا دنباله دیگری از کاراکترها است که به همان صورت به جلو و عقب خوانده می‌شود\n * (با نادیده گرفتن فاصله‌ها، نقطه‌گذاری و حروف بزرگ و کوچک).\n * مثال‌ها:\n *   >>> f_47(\"racecar\")\n *   true\n *   >>> f_47(\"hello\")\n *   false\n */\nbool f_47(const char* str)"}, "canonical_solution": "{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}", "instruction": {"en": "Write a CPP function `bool f_47(const char* str)` to solve the following problem:\nDetermine if a given string is a palindrome. A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward (ignoring spaces, punctuation, and capitalization).\nExamples:\n  >>> f_47(\"racecar\")\n  true\n  >>> f_47(\"hello\")\n  false", "sq": "Shkruani një funksion CPP `bool f_47(const char* str)` për të zgjidhur problemin e mëposhtëm:  \nPërcaktoni nëse një varg i dhënë është një palindrom. Një palindrom është një fjalë, frazë, numër, ose një sekuencë tjetër karakteresh që lexohet njësoj përpara dhe prapa (duke injoruar hapësirat, shenjat e pikësimit dhe kapitalizimin).  \nShembuj:  \n  >>> f_47(\"racecar\")  \n  true  \n  >>> f_47(\"hello\")  \n  false", "hy": "Գրեք CPP ֆունկցիա `bool f_47(const char* str)` հետևյալ խնդիրը լուծելու համար:\nՈրոշեք, արդյոք տրված տողը պալինդրոմ է։ Պալինդրոմը բառ, արտահայտություն, թիվ կամ այլ նիշերի հաջորդականություն է, որը նույն կերպ է կարդացվում առաջ և հետ (անտեսելով բացատները, կետադրությունը և մեծատառերը):\nՕրինակներ:\n  >>> f_47(\"racecar\")\n  true\n  >>> f_47(\"hello\")\n  false", "bn": "একটি CPP ফাংশন `bool f_47(const char* str)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nনির্ধারণ করুন একটি প্রদত্ত স্ট্রিং প্যালিনড্রোম কিনা। একটি প্যালিনড্রোম হল এমন একটি শব্দ, বাক্যাংশ, সংখ্যা, বা অন্যান্য অক্ষরগুলির ক্রম যা সামনের দিক থেকে এবং পিছনের দিক থেকে একইভাবে পড়া যায় (স্পেস, বিরামচিহ্ন, এবং বড় হাতের অক্ষর উপেক্ষা করে)।\nউদাহরণ:\n  >>> f_47(\"racecar\")\n  true\n  >>> f_47(\"hello\")\n  false", "bg": "Напишете CPP функция `bool f_47(const char* str)` за решаване на следния проблем:  \nОпределете дали даден низ е палиндром. Палиндром е дума, фраза, число или друга последователност от символи, която се чете еднакво напред и назад (като се игнорират интервали, пунктуация и главни букви).  \nПримери:  \n  >>> f_47(\"racecar\")  \n  true  \n  >>> f_47(\"hello\")  \n  false", "zh": "编写一个 CPP 函数 `bool f_47(const char* str)` 来解决以下问题：  \n确定给定的字符串是否是回文。回文是一个单词、短语、数字或其他字符序列，正向和反向读取时相同（忽略空格、标点和大小写）。  \n示例：  \n  >>> f_47(\"racecar\")  \n  true  \n  >>> f_47(\"hello\")  \n  false", "fr": "Écrire une fonction CPP `bool f_47(const char* str)` pour résoudre le problème suivant :  \nDéterminer si une chaîne de caractères donnée est un palindrome. Un palindrome est un mot, une phrase, un nombre ou une autre séquence de caractères qui se lit de la même manière à l'endroit et à l'envers (en ignorant les espaces, la ponctuation et la capitalisation).  \nExemples :  \n  >>> f_47(\"racecar\")  \n  true  \n  >>> f_47(\"hello\")  \n  false  ", "de": "Schreiben Sie eine CPP-Funktion `bool f_47(const char* str)`, um das folgende Problem zu lösen:\nBestimmen Sie, ob ein gegebener String ein Palindrom ist. Ein Palindrom ist ein Wort, ein Satz, eine Zahl oder eine andere Zeichenfolge, die vorwärts und rückwärts gleich gelesen wird (unter Ignorierung von Leerzeichen, Satzzeichen und Groß-/Kleinschreibung).\nBeispiele:\n  >>> f_47(\"racecar\")\n  true\n  >>> f_47(\"hello\")\n  false", "ha": "Rubuta aikin CPP `bool f_47(const char* str)` don warware matsalar mai zuwa: Tantance idan wani kirtani da aka bayar palindrome ne. Palindrome kalma ce, jimla, lamba, ko wata jerin haruffa da ke karanta iri ɗaya gaba da baya (ba tare da la'akari da sarari, rubutu, da manyan ba).\n\nMisalai:\n  >>> f_47(\"racecar\")\n  true\n  >>> f_47(\"hello\")\n  false", "hi": "एक CPP फ़ंक्शन `bool f_47(const char* str)` लिखें ताकि निम्नलिखित समस्या का समाधान हो सके:\nनिर्धारित करें कि दिया गया स्ट्रिंग एक पालिंड्रोम है या नहीं। एक पालिंड्रोम एक शब्द, वाक्यांश, संख्या, या अन्य वर्णों का अनुक्रम है जो आगे और पीछे से समान पढ़ा जाता है (स्पेस, विराम चिह्न और बड़े अक्षरों को नजरअंदाज करते हुए)।\nउदाहरण:\n  >>> f_47(\"racecar\")\n  true\n  >>> f_47(\"hello\")\n  false", "hu": "Írj egy CPP függvényt `bool f_47(const char* str)` a következő probléma megoldására:  \nHatározd meg, hogy egy adott string palindróm-e. Egy palindróm olyan szó, kifejezés, szám vagy más karakterlánc, amely előre és hátra olvasva is ugyanaz (figyelmen kívül hagyva a szóközöket, írásjeleket és a nagybetűket).  \nPéldák:  \n  >>> f_47(\"racecar\")  \n  true  \n  >>> f_47(\"hello\")  \n  false", "es": "Escribe una función en CPP `bool f_47(const char* str)` para resolver el siguiente problema:\nDeterminar si una cadena dada es un palíndromo. Un palíndromo es una palabra, frase, número u otra secuencia de caracteres que se lee igual de adelante hacia atrás (ignorando espacios, puntuación y mayúsculas).\nEjemplos:\n  >>> f_47(\"racecar\")\n  true\n  >>> f_47(\"hello\")\n  false", "arb": "اكتب دالة CPP `bool f_47(const char* str)` لحل المشكلة التالية:\nتحديد ما إذا كانت السلسلة المعطاة هي كلمة متطابقة. الكلمة المتطابقة هي كلمة، عبارة، رقم، أو تسلسل آخر من الأحرف الذي يقرأ نفسه بنفس الطريقة من الأمام إلى الخلف (مع تجاهل المسافات، علامات الترقيم، والحروف الكبيرة والصغيرة).\nأمثلة:\n  >>> f_47(\"racecar\")\n  true\n  >>> f_47(\"hello\")\n  false", "sw": "Andika kazi ya CPP `bool f_47(const char* str)` kutatua tatizo lifuatalo:  \nTambua kama kamba iliyotolewa ni palindrome. Palindrome ni neno, kifungu, nambari, au mlolongo mwingine wa herufi ambao unasomwa sawa mbele na nyuma (kupuuza nafasi, alama za uakifishaji, na herufi kubwa na ndogo).  \nMifano:  \n  >>> f_47(\"racecar\")  \n  true  \n  >>> f_47(\"hello\")  \n  false", "tr": "Bir CPP fonksiyonu `bool f_47(const char* str)` yazın ve aşağıdaki problemi çözün:\nVerilen bir dizgenin palindrom olup olmadığını belirleyin. Palindrom, ileri ve geri okunduğunda aynı olan kelime, ifade, sayı veya diğer karakter dizileridir (boşluklar, noktalama işaretleri ve büyük/küçük harf dikkate alınmaz).\nÖrnekler:\n  >>> f_47(\"racecar\")\n  true\n  >>> f_47(\"hello\")\n  false", "vi": "Viết một hàm CPP `bool f_47(const char* str)` để giải quyết vấn đề sau:  \nXác định xem một chuỗi cho trước có phải là palindrome hay không. Một palindrome là một từ, cụm từ, số, hoặc chuỗi ký tự khác mà đọc xuôi hay ngược đều giống nhau (bỏ qua khoảng trắng, dấu câu và chữ hoa/thường).  \nVí dụ:  \n  >>> f_47(\"racecar\")  \n  true  \n  >>> f_47(\"hello\")  \n  false  ", "id": "Tulis fungsi CPP `bool f_47(const char* str)` untuk menyelesaikan masalah berikut:  \nTentukan apakah string yang diberikan adalah palindrom. Palindrom adalah kata, frasa, angka, atau urutan karakter lain yang dibaca sama maju dan mundur (mengabaikan spasi, tanda baca, dan kapitalisasi).  \nContoh:  \n  >>> f_47(\"racecar\")  \n  true  \n  >>> f_47(\"hello\")  \n  false  ", "ja": "CPP関数`bool f_47(const char* str)`を作成して、次の問題を解決してください:\n与えられた文字列が回文かどうかを判定します。回文とは、スペース、句読点、大文字小文字を無視して、前から読んでも後ろから読んでも同じになる単語、フレーズ、数字、またはその他の文字列のことです。\n例:\n  >>> f_47(\"racecar\")\n  true\n  >>> f_47(\"hello\")\n  false", "ko": "CPP 함수 `bool f_47(const char* str)`를 작성하여 다음 문제를 해결하십시오:\n주어진 문자열이 회문인지 확인합니다. 회문은 앞뒤로 같은 방식으로 읽히는 단어, 구, 숫자 또는 기타 문자 시퀀스입니다 (공백, 구두점 및 대소문자는 무시합니다).\n예시:\n  >>> f_47(\"racecar\")\n  true\n  >>> f_47(\"hello\")\n  false", "ml": "`bool f_47(const char* str)` എന്ന CPP ഫംഗ്ഷൻ എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:  \nഒരു നൽകിയിരിക്കുന്ന സ്ട്രിംഗ് പാലിൻഡ്രോം ആണോ എന്ന് നിർണയിക്കുക. ഒരു പാലിൻഡ്രോം എന്നത് ഒരു വാക്ക്, വാചകം, സംഖ്യ, അല്ലെങ്കിൽ മറ്റ് അക്ഷരങ്ങളുടെ ശ്രേണിയാണ്, ഇത് മുന്നോട്ടും പിന്നോട്ടും ഒരേപോലെ വായിക്കപ്പെടുന്നു (ഇടവേളകൾ, ചിഹ്നങ്ങൾ, മൂല്യനിർണയം എന്നിവ അവഗണിക്കുന്നു).  \nഉദാഹരണങ്ങൾ:  \n  >>> f_47(\"racecar\")  \n  true  \n  >>> f_47(\"hello\")  \n  false  ", "fa": "یک تابع CPP `bool f_47(const char* str)` بنویسید تا مسئله زیر را حل کند:\nتعیین کنید که آیا یک رشته داده شده یک پالیندروم است یا خیر. پالیندروم کلمه، عبارت، عدد یا دنباله دیگری از کاراکترهاست که از جلو به عقب و از عقب به جلو یکسان خوانده می‌شود (با نادیده گرفتن فاصله‌ها، علائم نگارشی و حروف بزرگ و کوچک).\nمثال‌ها:\n  >>> f_47(\"racecar\")\n  true\n  >>> f_47(\"hello\")\n  false"}, "level": "middle", "test": "int main()\n{\n    assert(f_47(\"A man a plan a canal Panama\") == true);\n    assert(f_47(\"No lemon, no melon\") == true);\n    assert(f_47(\"Was it a car or a cat I saw\") == true);\n    assert(f_47(\"Madam, in Eden, I'm Adam\") == true);\n    assert(f_47(\"Never odd or even\") == true);\n    assert(f_47(\"Eva, can I see bees in a cave\") == true);\n    assert(f_47(\"hello\") == false);\n    assert(f_47(\"GitHub\") == false);\n    assert(f_47(\"programming\") == false);\n    \n    return 0;\n}", "entry_point": "f_47", "signature": "bool f_47(const char* str)", "docstring": {"en": "Determine if a given string is a palindrome. A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward (ignoring spaces, punctuation, and capitalization).\nExamples:\n  >>> f_47(\"racecar\")\n  true\n  >>> f_47(\"hello\")\n  false", "sq": "Përcaktoni nëse një varg i dhënë është një palindrom. Një palindrom është një fjalë, frazë, numër, ose sekuencë tjetër karakteresh që lexohet njësoj përpara dhe prapa (duke injoruar hapësirat, shenjat e pikësimit dhe kapitalizimin).\nShembuj:\n  >>> f_47(\"racecar\")\n  true\n  >>> f_47(\"hello\")\n  false", "hy": "Սահմանել, արդյոք տրված տողը պալինդրոմ է: Պալինդրոմը բառ է, արտահայտություն, թիվ կամ այլ նիշերի հաջորդականություն, որը կարդացվում է նույնը առաջ և հետ (անտեսելով բացատները, կետադրությունը և մեծատառերը):\nՕրինակներ:\n  >>> f_47(\"racecar\")\n  true\n  >>> f_47(\"hello\")\n  false", "bn": "একটি প্রদত্ত স্ট্রিং প্যালিনড্রোম কিনা তা নির্ধারণ করুন। একটি প্যালিনড্রোম হল একটি শব্দ, বাক্যাংশ, সংখ্যা, বা অন্যান্য অক্ষরের ক্রম যা সামনের দিকে এবং পিছনের দিকে একইভাবে পড়ে (স্পেস, বিরামচিহ্ন এবং বড় হাতের অক্ষর উপেক্ষা করে)।\n\nউদাহরণ:\n  >>> f_47(\"racecar\")\n  true\n  >>> f_47(\"hello\")\n  false", "bg": "Определете дали даден низ е палиндром. Палиндром е дума, фраза, число или друга последователност от символи, която се чете еднакво напред и назад (като се игнорират интервали, пунктуация и главни букви).\nПримери:\n  >>> f_47(\"racecar\")\n  true\n  >>> f_47(\"hello\")\n  false", "zh": "确定给定的字符串是否是回文。回文是指无论正向还是反向读取都相同的单词、短语、数字或其他字符序列（忽略空格、标点和大小写）。\n\n示例：\n  >>> f_47(\"racecar\")\n  true\n  >>> f_47(\"hello\")\n  false", "fr": "Déterminer si une chaîne donnée est un palindrome. Un palindrome est un mot, une phrase, un nombre ou une autre séquence de caractères qui se lit de la même façon à l'endroit et à l'envers (en ignorant les espaces, la ponctuation et la capitalisation).\nExemples :\n  >>> f_47(\"racecar\")\n  true\n  >>> f_47(\"hello\")\n  false", "de": "Bestimmen Sie, ob ein gegebener String ein Palindrom ist. Ein Palindrom ist ein Wort, ein Satz, eine Zahl oder eine andere Zeichenfolge, die vorwärts und rückwärts gleich gelesen wird (unter Ignorieren von Leerzeichen, Satzzeichen und Groß-/Kleinschreibung).\nBeispiele:\n  >>> f_47(\"racecar\")\n  true\n  >>> f_47(\"hello\")\n  false", "ha": "Gano idan wata kirtani da aka bayar palindrome ne. Palindrome kalma ce, jimla, lamba, ko wata jerin haruffa da ke karantawa iri ɗaya gaba da baya (ba tare da la'akari da sarari, rubutu, da manyan ba).\n\nMisalai:\n  >>> f_47(\"racecar\")\n  true\n  >>> f_47(\"hello\")\n  false", "hi": "दिया गया स्ट्रिंग एक पालिंड्रोम है या नहीं, यह निर्धारित करें। एक पालिंड्रोम एक शब्द, वाक्यांश, संख्या, या अन्य वर्णों का अनुक्रम है जो आगे और पीछे से समान रूप से पढ़ा जाता है (स्थान, विराम चिह्न, और बड़े अक्षरों की अनदेखी करते हुए)।\n\nउदाहरण:\n  >>> f_47(\"racecar\")\n  true\n  >>> f_47(\"hello\")\n  false", "hu": "Határozza meg, hogy egy adott karakterlánc palindróm-e. A palindróm egy olyan szó, kifejezés, szám vagy más karakterlánc, amely előre és visszafelé olvasva is ugyanaz (figyelmen kívül hagyva a szóközöket, írásjeleket és nagybetűket).\n\nPéldák:\n  >>> f_47(\"racecar\")\n  true\n  >>> f_47(\"hello\")\n  false", "es": "Determinar si una cadena dada es un palíndromo. Un palíndromo es una palabra, frase, número u otra secuencia de caracteres que se lee igual hacia adelante y hacia atrás (ignorando espacios, puntuación y mayúsculas).\nEjemplos:\n  >>> f_47(\"racecar\")\n  true\n  >>> f_47(\"hello\")\n  false", "arb": "تحديد ما إذا كانت سلسلة معينة هي جملة مقلوبة. الجملة المقلوبة هي كلمة أو عبارة أو رقم أو تسلسل آخر من الأحرف يقرأ بنفس الطريقة من الأمام والخلف (مع تجاهل المسافات وعلامات الترقيم والحروف الكبيرة).\n\nأمثلة:\n  >>> f_47(\"racecar\")\n  true\n  >>> f_47(\"hello\")\n  false", "sw": "Amua ikiwa string iliyopewa ni palindrome. Palindrome ni neno, kifungu, nambari, au mlolongo mwingine wa herufi ambao unasomwa sawa mbele na nyuma (ukipuuza nafasi, alama za uakifishaji, na matumizi ya herufi kubwa na ndogo).\n\nMifano:\n  >>> f_47(\"racecar\")\n  true\n  >>> f_47(\"hello\")\n  false", "tr": "Verilen bir stringin palindrom olup olmadığını belirleyin. Palindrom, ileri ve geri okunduğunda aynı olan (boşluklar, noktalama işaretleri ve büyük/küçük harf farkı göz ardı edilerek) bir kelime, ifade, sayı veya diğer karakter dizisidir.\nÖrnekler:\n  >>> f_47(\"racecar\")\n  true\n  >>> f_47(\"hello\")\n  false", "vi": "Xác định xem một chuỗi cho trước có phải là palindrome hay không. Một palindrome là một từ, cụm từ, số, hoặc chuỗi ký tự khác mà đọc xuôi hay ngược đều giống nhau (bỏ qua khoảng trắng, dấu câu và chữ hoa chữ thường).\n\nVí dụ:\n  >>> f_47(\"racecar\")\n  true\n  >>> f_47(\"hello\")\n  false", "id": "Menentukan apakah string yang diberikan adalah palindrom. Palindrom adalah kata, frasa, angka, atau urutan karakter lain yang dibaca sama maju dan mundur (mengabaikan spasi, tanda baca, dan kapitalisasi).\nContoh:\n  >>> f_47(\"racecar\")\n  true\n  >>> f_47(\"hello\")\n  false", "ja": "与えられた文字列が回文かどうかを判断します。回文とは、前から読んでも後ろから読んでも同じになる単語、フレーズ、数字、またはその他の文字列のことです（スペース、句読点、大文字小文字は無視します）。\n\n例:\n  >>> f_47(\"racecar\")\n  true\n  >>> f_47(\"hello\")\n  false", "ko": "주어진 문자열이 회문인지 확인합니다. 회문은 단어, 구, 숫자 또는 다른 문자 시퀀스로, 앞뒤로 읽어도 동일한 것을 말합니다 (공백, 구두점 및 대소문자는 무시합니다).\n예시:\n  >>> f_47(\"racecar\")\n  true\n  >>> f_47(\"hello\")\n  false", "ml": "ഒരു നൽകിയിരിക്കുന്ന സ്ട്രിംഗ് പാലിൻഡ്രോമാണോ എന്ന് നിർണയിക്കുക. പാലിൻഡ്രോം എന്നത് മുന്നോട്ടും പിന്നോട്ടും ഒരേപോലെ വായിക്കാവുന്ന ഒരു വാക്ക്, വാചകം, സംഖ്യ, അല്ലെങ്കിൽ മറ്റ് അക്ഷരങ്ങളുടെ ശ്രേണിയാണ് (വിരാമചിഹ്നങ്ങളും, ഇടവേളകളും, വലിയക്ഷരവും ചെറിയക്ഷരവും അവഗണിക്കുന്നു).\n\nഉദാഹരണങ്ങൾ:\n  >>> f_47(\"racecar\")\n  true\n  >>> f_47(\"hello\")\n  false", "fa": "تعیین کنید که آیا یک رشته داده شده یک پالیندروم است یا خیر. پالیندروم کلمه، عبارت، عدد یا دنباله دیگری از کاراکترها است که از جلو و عقب به همان صورت خوانده می‌شود (با نادیده گرفتن فاصله‌ها، علائم نگارشی و حروف بزرگ و کوچک).\n\nExamples:  \nمثال‌ها:\n  >>> f_47(\"racecar\")\n  true\n  >>> f_47(\"hello\")\n  false"}}
{"task_id": "CPP/48", "prompt": {"en": "#include <cassert>\n#include <cstdio>\n/*\nGiven a non-negative integer num, this function reduces it to a single digit by repeatedly adding all its digits.\nFor example:\n    >>> f_48(38)\n    2\nThe calculation is because 3 + 8 = 11, and further 1 + 1 = 2. 2 is returned since it is a single-digit number.\n*/\nint f_48(int num)", "sq": "#include <cassert>\n#include <cstdio>\n/*\nDuke pasur një numër jo-negativ, kjo funksion e redukton atë në një shifër të vetme duke shtuar vazhdimisht të gjitha shifrat e tij.\nPër shembull:\n    >>> f_48(38)\n    2\nLlogaritja është sepse 3 + 8 = 11, dhe më tej 1 + 1 = 2. 2 kthehet pasi është një numër me një shifër.\n*/\nint f_48(int num)", "hy": "#include <cassert>\n#include <cstdio>\n/*\nՏրված է ոչ բացասական ամբողջ թիվ num, այս ֆունկցիան այն կրճատում է մինչև մեկանիշ թվի՝ բազմիցս գումարելով նրա բոլոր թվանշանները:\nՕրինակ:\n    >>> f_48(38)\n    2\nՀաշվարկը հետևյալն է, քանի որ 3 + 8 = 11, և հետագա 1 + 1 = 2։ 2-ը վերադարձվում է, քանի որ այն մեկանիշ թիվ է:\n*/\nint f_48(int num)", "bn": "#include <cassert>\n#include <cstdio>\n/*\nএকটি অ-ঋণাত্মক পূর্ণসংখ্যা num দেওয়া হলে, এই ফাংশনটি তার সমস্ত অঙ্ক যোগ করে একক অঙ্কে কমিয়ে দেয়।\nউদাহরণস্বরূপ:\n    >>> f_48(38)\n    2\nগণনা করা হয় কারণ 3 + 8 = 11, এবং আরও 1 + 1 = 2। 2 ফেরত দেওয়া হয় কারণ এটি একটি একক অঙ্কের সংখ্যা।\n*/\nint f_48(int num)", "bg": "#include <cassert>\n#include <cstdio>\n/*\nДадено е неотрицателно цяло число num, тази функция го свежда до едноцифрено число, като многократно събира всичките му цифри.\nНапример:\n    >>> f_48(38)\n    2\nИзчислението е, защото 3 + 8 = 11, и по-нататък 1 + 1 = 2. 2 се връща, тъй като е едноцифрено число.\n*/\nint f_48(int num)", "zh": "#include <cassert>\n#include <cstdio>\n/*\n给定一个非负整数 num，此函数通过反复相加其所有数字将其减少到一位数字。\n例如：\n    >>> f_48(38)\n    2\n计算过程是因为 3 + 8 = 11，进一步 1 + 1 = 2。返回 2，因为它是一个一位数。\n*/\nint f_48(int num)", "fr": "#include <cassert>\n#include <cstdio>\n/*\nÉtant donné un entier non négatif num, cette fonction le réduit à un seul chiffre en ajoutant de manière répétée tous ses chiffres.\nPar exemple :\n    >>> f_48(38)\n    2\nLe calcul est parce que 3 + 8 = 11, et ensuite 1 + 1 = 2. 2 est retourné car c'est un nombre à un seul chiffre.\n*/\nint f_48(int num)", "de": "#include <cassert>\n#include <cstdio>\n/*\nGegeben eine nicht-negative ganze Zahl num, reduziert diese Funktion sie auf eine einstellige Zahl, indem sie wiederholt alle ihre Ziffern addiert.\nZum Beispiel:\n    >>> f_48(38)\n    2\nDie Berechnung erfolgt, weil 3 + 8 = 11, und weiter 1 + 1 = 2. 2 wird zurückgegeben, da es eine einstellige Zahl ist.\n*/\nint f_48(int num)", "ha": "#include <cassert>\n#include <cstdio>\n/*\nAn ba da wani lamba mara kyau num, wannan aikin yana rage shi zuwa lamba guda ta hanyar ci gaba da ƙara duk lambobinsa.\nMisali:\n    >>> f_48(38)\n    2\nLissafin yana nufin 3 + 8 = 11, kuma gaba 1 + 1 = 2. 2 an dawo da shi tunda lamba guda ce.\n*/\nint f_48(int num)", "hi": "#include <cassert>\n#include <cstdio>\n/*\nदिए गए गैर-ऋणात्मक पूर्णांक num को इस फ़ंक्शन के माध्यम से एकल अंक में घटाया जाता है, इसके सभी अंकों को बार-बार जोड़कर।\nउदाहरण के लिए:\n    >>> f_48(38)\n    2\nगणना इस प्रकार है क्योंकि 3 + 8 = 11, और आगे 1 + 1 = 2. 2 लौटाया जाता है क्योंकि यह एकल अंक संख्या है।\n*/\nint f_48(int num)", "hu": "#include <cassert>\n#include <cstdio>\n/*\nEgy nem negatív egész számot megadva, ez a függvény egyetlen számjegyre redukálja azáltal, hogy ismételten összeadja az összes számjegyét.\nPéldául:\n    >>> f_48(38)\n    2\nA számítás azért van, mert 3 + 8 = 11, és tovább 1 + 1 = 2. 2 kerül visszaadásra, mivel ez egy egyjegyű szám.\n*/\nint f_48(int num)", "es": "#include <cassert>\n#include <cstdio>\n/*\nDado un número entero no negativo num, esta función lo reduce a un solo dígito sumando repetidamente todos sus dígitos.\nPor ejemplo:\n    >>> f_48(38)\n    2\nEl cálculo es porque 3 + 8 = 11, y luego 1 + 1 = 2. Se devuelve 2 ya que es un número de un solo dígito.\n*/\nint f_48(int num)", "arb": "#include <cassert>\n#include <cstdio>\n/*\nبالنظر إلى عدد صحيح غير سالب، تقوم هذه الدالة بتقليله إلى رقم واحد عن طريق جمع جميع أرقامه بشكل متكرر.\nعلى سبيل المثال:\n    >>> f_48(38)\n    2\nالحساب هو لأن 3 + 8 = 11، و 1 + 1 = 2. يتم إرجاع 2 لأنه رقم واحد.\n*/\nint f_48(int num)", "sw": "#include <cassert>\n#include <cstdio>\n/*\nIkizingatiwa nambari isiyo hasi num, kazi hii inapunguza hadi tarakimu moja kwa kuongeza mara kwa mara tarakimu zake zote.\nKwa mfano:\n    >>> f_48(38)\n    2\nHesabu ni kwa sababu 3 + 8 = 11, na zaidi 1 + 1 = 2. 2 inarudishwa kwa kuwa ni nambari ya tarakimu moja.\n*/\nint f_48(int num)", "tr": "#include <cassert>\n#include <cstdio>\n/*\nVerilen negatif olmayan bir tam sayı num, bu fonksiyon onu tüm basamaklarını tekrar tekrar toplayarak tek bir rakama indirger.\nÖrneğin:\n    >>> f_48(38)\n    2\nHesaplama 3 + 8 = 11 ve daha sonra 1 + 1 = 2 olduğu içindir. 2, tek basamaklı bir sayı olduğu için döndürülür.\n*/\nint f_48(int num)", "vi": "#include <cassert>\n#include <cstdio>\n/*\nCho một số nguyên không âm num, hàm này giảm nó xuống còn một chữ số bằng cách liên tục cộng tất cả các chữ số của nó.\nVí dụ:\n    >>> f_48(38)\n    2\nPhép tính là vì 3 + 8 = 11, và tiếp tục 1 + 1 = 2. 2 được trả về vì nó là một số có một chữ số.\n*/\nint f_48(int num)", "id": "#include <cassert>\n#include <cstdio>\n/*\nDiberikan bilangan bulat non-negatif num, fungsi ini menguranginya menjadi satu digit dengan menambahkan semua digitnya secara berulang.\nSebagai contoh:\n    >>> f_48(38)\n    2\nPerhitungannya adalah karena 3 + 8 = 11, dan selanjutnya 1 + 1 = 2. 2 dikembalikan karena merupakan angka satu digit.\n*/\nint f_48(int num)", "ja": "#include <cassert>\n#include <cstdio>\n/*\n非負の整数 num が与えられたとき、この関数はその桁をすべて足し合わせることを繰り返して、一桁の数字に減らします。\n例えば:\n    >>> f_48(38)\n    2\n計算は 3 + 8 = 11 であり、さらに 1 + 1 = 2 です。2 は一桁の数字なので返されます。\n*/\nint f_48(int num)", "ko": "#include <cassert>\n#include <cstdio>\n/*\n비음수가 아닌 정수 num이 주어졌을 때, 이 함수는 모든 자릿수를 반복적으로 더하여 한 자리 숫자로 줄입니다.\n예를 들어:\n    >>> f_48(38)\n    2\n계산은 3 + 8 = 11이고, 더 나아가 1 + 1 = 2입니다. 2는 한 자리 숫자이므로 반환됩니다.\n*/\nint f_48(int num)", "ml": "#include <cassert>\n#include <cstdio>\n/*\nഒരു നെഗറ്റീവ് അല്ലാത്ത പൂർണ്ണസംഖ്യ num നൽകിയാൽ, ഈ ഫങ്ഷൻ അതിന്റെ എല്ലാ അക്കങ്ങളും ആവർത്തിച്ച് കൂട്ടി അത് ഒരു അക്കത്തിലേക്ക് കുറയ്ക്കുന്നു.\nഉദാഹരണത്തിന്:\n    >>> f_48(38)\n    2\nകണക്കുകൂട്ടൽ 3 + 8 = 11 എന്നതിനാൽ, പിന്നെ 1 + 1 = 2. 2 ഒരു അക്ക സംഖ്യയായതിനാൽ തിരികെ നൽകുന്നു.\n*/\nint f_48(int num)", "fa": "#include <cassert>\n#include <cstdio>\n/*\nبا توجه به یک عدد صحیح غیر منفی num، این تابع آن را با جمع مکرر تمام ارقامش به یک رقم کاهش می‌دهد.\nبرای مثال:\n    >>> f_48(38)\n    2\nمحاسبه به این صورت است که 3 + 8 = 11، و بیشتر 1 + 1 = 2. 2 بازگردانده می‌شود زیرا یک عدد یک‌رقمی است.\n*/\nint f_48(int num)"}, "canonical_solution": "{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}", "instruction": {"en": "Write a CPP function `int f_48(int num)` to solve the following problem:\nGiven a non-negative integer num, this function reduces it to a single digit by repeatedly adding all its digits.\nFor example:\n    >>> f_48(38)\n    2\nThe calculation is because 3 + 8 = 11, and further 1 + 1 = 2. 2 is returned since it is a single-digit number.\n", "sq": "Shkruani një funksion CPP `int f_48(int num)` për të zgjidhur problemin e mëposhtëm:  \nDuke pasur një numër jo-negativ num, ky funksion e redukton atë në një shifër të vetme duke mbledhur përsëri të gjitha shifrat e tij.  \nPër shembull:  \n    >>> f_48(38)  \n    2  \nLlogaritja është sepse 3 + 8 = 11, dhe më tej 1 + 1 = 2. 2 kthehet pasi është një numër me një shifër.  ", "hy": "Գրեք CPP ֆունկցիա `int f_48(int num)`՝ հետևյալ խնդիրը լուծելու համար:\nՏրված է ոչ բացասական ամբողջ թիվ num, այս ֆունկցիան այն նվազեցնում է մինչև մեկանիշ թիվ՝ անընդհատ գումարելով դրա բոլոր թվանշանները:\nՕրինակ:\n    >>> f_48(38)\n    2\nՀաշվարկը հետևյալն է՝ 3 + 8 = 11, և հետագայում 1 + 1 = 2։ 2-ը վերադարձվում է, քանի որ այն մեկանիշ թիվ է։", "bn": "একটি CPP ফাংশন `int f_48(int num)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি অ-ঋণাত্মক পূর্ণসংখ্যা num দেওয়া হলে, এই ফাংশনটি এর সমস্ত অঙ্ক যোগ করে বারবার একটি একক অঙ্কে হ্রাস করে।\nউদাহরণস্বরূপ:\n    >>> f_48(38)\n    2\nগণনাটি কারণ 3 + 8 = 11, এবং আরও 1 + 1 = 2। 2 ফেরত দেওয়া হয় যেহেতু এটি একটি একক-অঙ্কের সংখ্যা।", "bg": "Напишете CPP функция `int f_48(int num)`, за да решите следния проблем:  \nДадено е неотрицателно цяло число num, тази функция го намалява до едноцифрено число, като многократно събира всичките му цифри.  \nНапример:  \n    >>> f_48(38)  \n    2  \nИзчислението е, защото 3 + 8 = 11, и по-нататък 1 + 1 = 2. Връща се 2, тъй като е едноцифрено число.", "zh": "编写一个 CPP 函数 `int f_48(int num)` 来解决以下问题：  \n给定一个非负整数 num，此函数通过重复相加其所有数字将其减少到一位数字。  \n例如：  \n    >>> f_48(38)  \n    2  \n计算过程是因为 3 + 8 = 11，然后 1 + 1 = 2。返回 2 因为它是一个一位数。  ", "fr": "Écrire une fonction CPP `int f_48(int num)` pour résoudre le problème suivant :\nÉtant donné un entier non négatif num, cette fonction le réduit à un seul chiffre en ajoutant de manière répétée tous ses chiffres.\nPar exemple :\n    >>> f_48(38)\n    2\nLe calcul est parce que 3 + 8 = 11, et ensuite 1 + 1 = 2. 2 est retourné car c'est un nombre à un seul chiffre.", "de": "Schreiben Sie eine CPP-Funktion `int f_48(int num)`, um das folgende Problem zu lösen:\nGegeben ist eine nicht-negative ganze Zahl num, diese Funktion reduziert sie auf eine einzelne Ziffer, indem sie wiederholt alle ihre Ziffern addiert.\nZum Beispiel:\n    >>> f_48(38)\n    2\nDie Berechnung ist, weil 3 + 8 = 11, und weiter 1 + 1 = 2. 2 wird zurückgegeben, da es eine einstellige Zahl ist.", "ha": "Rubuta aikin CPP `int f_48(int num)` don magance matsalar mai zuwa:  \nAn ba da lamba marar kyau num, wannan aikin yana rage ta zuwa lamba guda ta hanyar ci gaba da ƙara duk lambobinta.  \nMisali:  \n    >>> f_48(38)  \n    2  \nLissafin yana nufin 3 + 8 = 11, kuma gaba 1 + 1 = 2. 2 an dawo da shi saboda lamba guda ce.  ", "hi": "एक CPP फ़ंक्शन `int f_48(int num)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए एक गैर-ऋणात्मक पूर्णांक num को, यह फ़ंक्शन इसे एकल अंक में घटा देता है, इसके सभी अंकों को बार-बार जोड़कर।\nउदाहरण के लिए:\n    >>> f_48(38)\n    2\nगणना इसलिए है क्योंकि 3 + 8 = 11, और आगे 1 + 1 = 2। 2 लौटाया जाता है क्योंकि यह एक एकल-अंक संख्या है।", "hu": "Írj egy CPP függvényt `int f_48(int num)` a következő probléma megoldására:  \nAdott egy nem negatív egész szám, num, ez a függvény egyetlen számjegyre redukálja azáltal, hogy ismételten összeadja az összes számjegyét.  \nPéldául:  \n    >>> f_48(38)  \n    2  \nA számítás azért van, mert 3 + 8 = 11, és tovább 1 + 1 = 2. 2 kerül visszaadásra, mivel ez egy egyjegyű szám.", "es": "Escribe una función CPP `int f_48(int num)` para resolver el siguiente problema:\nDado un entero no negativo num, esta función lo reduce a un solo dígito sumando repetidamente todos sus dígitos.\nPor ejemplo:\n    >>> f_48(38)\n    2\nEl cálculo es porque 3 + 8 = 11, y además 1 + 1 = 2. Se devuelve 2 ya que es un número de un solo dígito.", "arb": "اكتب دالة CPP `int f_48(int num)` لحل المشكلة التالية:\nبالنظر إلى عدد صحيح غير سالب num، تقوم هذه الدالة بتقليله إلى رقم واحد عن طريق جمع جميع أرقامه بشكل متكرر.\nعلى سبيل المثال:\n    >>> f_48(38)\n    2\nالحساب هو لأن 3 + 8 = 11، ومزيد من 1 + 1 = 2. يتم إرجاع 2 لأنه رقم مكون من خانة واحدة.", "sw": "Andika kazi ya CPP `int f_48(int num)` kutatua tatizo lifuatalo:\nUkipiwa nambari isiyo hasi num, kazi hii inapunguza hadi tarakimu moja kwa kuongeza tarakimu zake zote mara kwa mara.\nKwa mfano:\n    >>> f_48(38)\n    2\nHesabu ni kwa sababu 3 + 8 = 11, na zaidi 1 + 1 = 2. 2 inarudishwa kwa kuwa ni nambari ya tarakimu moja.", "tr": "Bir CPP fonksiyonu `int f_48(int num)` yazın:\nVerilen bir negatif olmayan tamsayı num, bu fonksiyon tüm basamaklarını tekrar tekrar toplayarak onu tek bir basamağa indirger.\nÖrneğin:\n    >>> f_48(38)\n    2\nHesaplama, çünkü 3 + 8 = 11 ve daha sonra 1 + 1 = 2. 2 döndürülür çünkü bu tek basamaklı bir sayıdır.", "vi": "Viết một hàm CPP `int f_48(int num)` để giải quyết vấn đề sau:  \nCho một số nguyên không âm num, hàm này giảm nó xuống một chữ số bằng cách liên tục cộng tất cả các chữ số của nó.  \nVí dụ:  \n    >>> f_48(38)  \n    2  \nPhép tính là vì 3 + 8 = 11, và tiếp tục 1 + 1 = 2. 2 được trả về vì nó là một số có một chữ số.  ", "id": "Tulis fungsi CPP `int f_48(int num)` untuk menyelesaikan masalah berikut:\nDiberikan bilangan bulat non-negatif num, fungsi ini menguranginya menjadi satu digit dengan terus-menerus menjumlahkan semua digitnya.\nSebagai contoh:\n    >>> f_48(38)\n    2\nPerhitungannya adalah karena 3 + 8 = 11, dan selanjutnya 1 + 1 = 2. 2 dikembalikan karena itu adalah angka satu digit.", "ja": "CPP関数 `int f_48(int num)` を作成して、次の問題を解決してください:\n非負整数numが与えられたとき、この関数はその桁をすべて足し続けて1桁に減らします。\n例えば:\n    >>> f_48(38)\n    2\n計算は3 + 8 = 11であり、さらに1 + 1 = 2です。2は1桁の数なので返されます。", "ko": "다음 문제를 해결하기 위해 CPP 함수 `int f_48(int num)`을 작성하십시오:\n비음수 정수 num이 주어졌을 때, 이 함수는 모든 자릿수를 반복적으로 더하여 한 자리 숫자로 줄입니다.\n예를 들어:\n    >>> f_48(38)\n    2\n계산은 3 + 8 = 11이고, 더 나아가 1 + 1 = 2입니다. 2는 한 자리 숫자이기 때문에 반환됩니다.", "ml": "CPP ഫംഗ്ഷൻ `int f_48(int num)` എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nഒരു നെഗറ്റീവ് അല്ലാത്ത പൂർണ്ണസംഖ്യ num നൽകിയാൽ, ഈ ഫംഗ്ഷൻ അതിന്റെ എല്ലാ അക്കങ്ങളും ആവർത്തിച്ച് ചേർത്ത് അത് ഒരു അക്കമായി കുറയ്ക്കുന്നു.\nഉദാഹരണത്തിന്:\n    >>> f_48(38)\n    2\nകണക്കുകൂട്ടൽ 3 + 8 = 11 ആകുന്നതുകൊണ്ടാണ്, പിന്നെ 1 + 1 = 2. 2 തിരികെ നൽകുന്നു കാരണം അത് ഒരു അക്ക സംഖ്യയാണ്.", "fa": "یک تابع CPP `int f_48(int num)` بنویسید تا مسئله زیر را حل کند:\nبا توجه به یک عدد صحیح غیر منفی num، این تابع آن را با افزودن مکرر تمام ارقامش به یک رقم کاهش می‌دهد.\nبرای مثال:\n    >>> f_48(38)\n    2\nمحاسبه به این دلیل است که 3 + 8 = 11، و در ادامه 1 + 1 = 2. 2 برگردانده می‌شود زیرا یک عدد یک‌رقمی است."}, "level": "easy", "test": "int main() {\n    assert(f_48(38) == 2);\n    assert(f_48(0) == 0);\n    assert(f_48(9) == 9);\n    assert(f_48(123) == 6);\n    assert(f_48(456) == 6);\n    assert(f_48(9999) == 9);\n    assert(f_48(100) == 1);\n    assert(f_48(1010) == 2);\n    assert(f_48(1234) == 1);\n    assert(f_48(9876) == 3);\n    assert(f_48(199) == 1);\n    return 0;\n}", "entry_point": "f_48", "signature": "int f_48(int num)", "docstring": {"en": "Given a non-negative integer num, this function reduces it to a single digit by repeatedly adding all its digits.\nFor example:\n    >>> f_48(38)\n    2\nThe calculation is because 3 + 8 = 11, and further 1 + 1 = 2. 2 is returned since it is a single-digit number.\n", "sq": "Duke pasur një numër të plotë jo-negativ num, kjo funksion e redukton atë në një shifër të vetme duke shtuar përsëri të gjitha shifrat e tij.\nPër shembull:\n    >>> f_48(38)\n    2\nLlogaritja është sepse 3 + 8 = 11, dhe më tej 1 + 1 = 2. 2 kthehet pasi është një numër me një shifër.", "hy": "Տրված է ոչ բացասական ամբողջ թիվ num, այս ֆունկցիան այն նվազեցնում է մինչև մեկանիշ թիվ՝ բազմիցս գումարելով նրա բոլոր թվանշանները:\nՕրինակ:\n    >>> f_48(38)\n    2\nՀաշվարկը հետևյալն է, քանի որ 3 + 8 = 11, և հետագայում 1 + 1 = 2: Վերադարձվում է 2, քանի որ այն մեկանիշ թիվ է:", "bn": "একটি অ-ঋণাত্মক পূর্ণসংখ্যা num দেওয়া হলে, এই ফাংশনটি তার সমস্ত অঙ্ক যোগ করে বারবার একক অঙ্কে কমিয়ে আনে। উদাহরণস্বরূপ:\n    >>> f_48(38)\n    2\nগণনা করা হয় কারণ 3 + 8 = 11, এবং আরও 1 + 1 = 2। 2 ফেরত দেওয়া হয় কারণ এটি একটি একক অঙ্কের সংখ্যা।", "bg": "Дадено е неотрицателно цяло число num, тази функция го свежда до едноцифрено число чрез многократно събиране на всичките му цифри.\nНапример:\n    >>> f_48(38)\n    2\nИзчислението е, защото 3 + 8 = 11, и по-нататък 1 + 1 = 2. 2 се връща, тъй като е едноцифрено число.", "zh": "给定一个非负整数 num，此函数通过反复相加其所有位数将其减少到一位数字。\n例如：\n    >>> f_48(38)\n    2\n计算过程是因为 3 + 8 = 11，然后 1 + 1 = 2。返回 2 因为它是一位数字。", "fr": "Étant donné un entier non négatif num, cette fonction le réduit à un seul chiffre en additionnant de manière répétée tous ses chiffres.\nPar exemple :\n    >>> f_48(38)\n    2\nLe calcul est le suivant : 3 + 8 = 11, et ensuite 1 + 1 = 2. 2 est retourné car c'est un nombre à un seul chiffre.", "de": "Gegeben ist eine nicht-negative ganze Zahl num, reduziert diese Funktion sie auf eine einzelne Ziffer, indem sie wiederholt alle ihre Ziffern addiert.  \nZum Beispiel:  \n    >>> f_48(38)  \n    2  \nDie Berechnung ist, weil 3 + 8 = 11, und weiter 1 + 1 = 2. 2 wird zurückgegeben, da es eine einstellige Zahl ist.", "ha": "An ba da wani lamba mara kyau num, wannan aikin yana rage shi zuwa lamba guda ta hanyar ƙara duk lambobinsa akai-akai.\nMisali:\n    >>> f_48(38)\n    2\nLissafin yana saboda 3 + 8 = 11, sannan kuma 1 + 1 = 2. 2 yana dawowa saboda yana lamba guda.", "hi": "एक गैर-ऋणात्मक पूर्णांक num दिया गया है, यह फ़ंक्शन इसे एकल अंक तक घटाता है, इसके सभी अंकों को बार-बार जोड़कर।\n\nउदाहरण के लिए:\n    >>> f_48(38)\n    2\n\nगणना इसलिए है क्योंकि 3 + 8 = 11, और आगे 1 + 1 = 2। 2 वापस किया जाता है क्योंकि यह एक एकल-अंक संख्या है।", "hu": "Adott egy nem negatív egész szám, ez a függvény egy számjegyre csökkenti azáltal, hogy ismételten összeadja az összes számjegyét.\nPéldául:\n    >>> f_48(38)\n    2\nA számítás azért van, mert 3 + 8 = 11, és tovább 1 + 1 = 2. 2-t ad vissza, mivel ez egy egyjegyű szám.", "es": "Dado un número entero no negativo num, esta función lo reduce a un solo dígito sumando repetidamente todos sus dígitos.\nPor ejemplo:\n    >>> f_48(38)\n    2\nEl cálculo es porque 3 + 8 = 11, y además 1 + 1 = 2. Se devuelve 2 ya que es un número de un solo dígito.", "arb": "بالنظر إلى عدد صحيح غير سالب num، تقوم هذه الدالة بتقليله إلى رقم واحد عن طريق جمع جميع أرقامه بشكل متكرر.\nعلى سبيل المثال:\n    >>> f_48(38)\n    2\nالحساب هو لأن 3 + 8 = 11، وبالإضافة إلى ذلك 1 + 1 = 2. يتم إرجاع 2 لأنه رقم مكون من خانة واحدة.", "sw": "Kwa kupewa nambari isiyo na alama hasi num, kazi hii inapunguza hadi tarakimu moja kwa kuongeza mara kwa mara tarakimu zake zote. \n\nKwa mfano:\n    >>> f_48(38)\n    2\n\nHesabu ni kwa sababu 3 + 8 = 11, na zaidi 1 + 1 = 2. 2 inarejeshwa kwa kuwa ni nambari ya tarakimu moja.", "tr": "Verilen bir negatif olmayan tam sayı num için, bu fonksiyon tüm basamaklarını tekrar tekrar toplayarak onu tek bir rakama indirger.\nÖrneğin:\n    >>> f_48(38)\n    2\nHesaplama, çünkü 3 + 8 = 11 ve daha sonra 1 + 1 = 2. 2 döndürülür çünkü bu tek basamaklı bir sayıdır.", "vi": "Cho một số nguyên không âm num, hàm này giảm nó xuống một chữ số bằng cách liên tục cộng tất cả các chữ số của nó.\nVí dụ:\n    >>> f_48(38)\n    2\nPhép tính là vì 3 + 8 = 11, và tiếp tục 1 + 1 = 2. 2 được trả về vì nó là một số có một chữ số.", "id": "Diberikan bilangan bulat non-negatif num, fungsi ini menguranginya menjadi satu digit dengan terus-menerus menambahkan semua digitnya.\nSebagai contoh:\n    >>> f_48(38)\n    2\nPerhitungannya adalah karena 3 + 8 = 11, dan selanjutnya 1 + 1 = 2. 2 dikembalikan karena itu adalah angka satu digit.", "ja": "非負整数 num が与えられたとき、この関数はその桁をすべて加算することを繰り返して1桁に減らします。\n例えば:\n    >>> f_48(38)\n    2\n計算は 3 + 8 = 11 であり、さらに 1 + 1 = 2 です。2 は1桁の数なので返されます。", "ko": "주어진 비음수 정수 num에 대해, 이 함수는 모든 자릿수를 반복적으로 더하여 한 자리 숫자로 줄입니다.  \n예를 들어:\n    >>> f_48(38)\n    2\n계산은 3 + 8 = 11이고, 더 나아가 1 + 1 = 2입니다. 2는 한 자리 숫자이기 때문에 반환됩니다.", "ml": "ഒരു നെഗറ്റീവ് അല്ലാത്ത പൂർണ്ണസംഖ്യയായ num നൽകിയാൽ, ഈ ഫംഗ്ഷൻ അതിന്റെ എല്ലാ അക്കങ്ങളും ആവർത്തിച്ച് കൂട്ടിച്ചേർത്ത് അത് ഒരു അക്കത്തിൽ കുറയ്ക്കുന്നു.\n\nFor example:  \nഉദാഹരണത്തിന്:\n\n    >>> f_48(38)\n    2\n\nThe calculation is because 3 + 8 = 11, and further 1 + 1 = 2. 2 is returned since it is a single-digit number.  \nകണക്കുകൂട്ടൽ 3 + 8 = 11 എന്നതിനാൽ, പിന്നെ 1 + 1 = 2. 2 ഒരു അക്ക സംഖ്യയായതിനാൽ തിരികെ നൽകുന്നു.", "fa": "با توجه به یک عدد صحیح غیرمنفی num، این تابع آن را با تکرار جمع کردن تمام ارقامش به یک رقم کاهش می‌دهد.\nبرای مثال:\n    >>> f_48(38)\n    2\nمحاسبه به این صورت است که 3 + 8 = 11، و در ادامه 1 + 1 = 2. 2 برگردانده می‌شود زیرا یک عدد یک‌رقمی است."}}
{"task_id": "CPP/49", "prompt": {"en": "#include <cassert>\n#include <cstdio>\n/**\n * You are playing a game called Nim. In this game, you start with a pile of n stones, and you and\n * your opponent take turns to remove 1 to 3 stones from the pile. The one who removes the last\n * stone wins the game. Given the number of stones n, determine if you can win the game if both you\n * and your opponent play optimally.\n * Note: You always take the first turn.\n *\n * Here are some cases:\n *     >>> f_49(1)\n *     true\n */\nbool f_49(int n)", "sq": "#include <cassert>\n#include <cstdio>\n/**\n * Ju po luani një lojë të quajtur Nim. Në këtë lojë, ju filloni me një grumbull prej n gurësh, dhe ju dhe\n * kundërshtari juaj merrni me radhë për të hequr 1 deri në 3 gurë nga grumbulli. Ai që heq gurin e fundit\n * fiton lojën. Duke pasur parasysh numrin e gurëve n, përcaktoni nëse mund ta fitoni lojën nëse si ju\n * ashtu edhe kundërshtari juaj luani në mënyrë optimale.\n * Shënim: Ju gjithmonë e merrni lëvizjen e parë.\n *\n * Ja disa raste:\n *     >>> f_49(1)\n *     true\n */\nbool f_49(int n)", "hy": "#include <cassert>\n#include <cstdio>\n/**\n * Դուք խաղում եք Nim կոչվող խաղը։ Այս խաղում դուք սկսում եք n քարերից բաղկացած կույտով, և դուք ու ձեր\n * մրցակիցը հերթով հեռացնում եք 1-ից 3 քար կույտից։ Նա, ով հեռացնում է վերջին\n * քարը, հաղթում է խաղը։ Տրված է քարերի քանակը n, որոշեք՝ արդյոք դուք կարող եք հաղթել խաղը, եթե դուք և ձեր\n * մրցակիցը խաղում եք օպտիմալ կերպով։\n * Նշում: Դուք միշտ առաջինն եք խաղում։\n *\n * Ահա մի քանի դեպքեր:\n *     >>> f_49(1)\n *     true\n */\nbool f_49(int n)", "bn": "#include <cassert>\n#include <cstdio>\n/**\n * তুমি একটি Nim নামক খেলা খেলছো। এই খেলায়, তুমি n পাথর দিয়ে শুরু করো, এবং তুমি ও\n * তোমার প্রতিপক্ষ পালাক্রমে ১ থেকে ৩ পাথর পাইল থেকে সরিয়ে নাও। যে শেষ পাথরটি সরায়\n * সে খেলাটি জিতে যায়। প্রদত্ত পাথরের সংখ্যা n, নির্ধারণ করো তুমি খেলাটি জিততে পারবে কিনা যদি\n * তুমি এবং তোমার প্রতিপক্ষ উভয়েই সর্বোত্তমভাবে খেলে।\n * নোট: তুমি সবসময় প্রথম পালা নাও।\n *\n * এখানে কিছু উদাহরণ:\n *     >>> f_49(1)\n *     true\n */\nbool f_49(int n)", "bg": "#include <cassert>\n#include <cstdio>\n/**\n * Играете игра, наречена Nim. В тази игра започвате с купчина от n камъка и вие и вашият\n * противник се редувате да премахвате от 1 до 3 камъка от купчината. Този, който премахне\n * последния камък, печели играта. Като се има предвид броят на камъните n, определете дали\n * можете да спечелите играта, ако и вие, и вашият противник играете оптимално.\n * Забележка: Винаги вие правите първия ход.\n *\n * Ето някои случаи:\n *     >>> f_49(1)\n *     true\n */\nbool f_49(int n)", "zh": "#include <cassert>\n#include <cstdio>\n/**\n * 你正在玩一个叫做 Nim 的游戏。在这个游戏中，你从一堆 n 个石头开始，你和你的对手轮流从堆中移走 1 到 3 个石头。移走最后一个石头的人赢得游戏。给定石头的数量 n，判断如果你和你的对手都以最佳方式进行游戏，你是否能赢得比赛。\n * 注意：你总是先走。\n *\n * 这里有一些情况：\n *     >>> f_49(1)\n *     true\n */\nbool f_49(int n)", "fr": "#include <cassert>\n#include <cstdio>\n/**\n * Vous jouez à un jeu appelé Nim. Dans ce jeu, vous commencez avec un tas de n pierres, et vous et\n * votre adversaire prenez à tour de rôle 1 à 3 pierres du tas. Celui qui enlève la dernière\n * pierre gagne la partie. Étant donné le nombre de pierres n, déterminez si vous pouvez gagner la partie si vous et\n * votre adversaire jouez de manière optimale.\n * Remarque : Vous prenez toujours le premier tour.\n *\n * Voici quelques cas :\n *     >>> f_49(1)\n *     true\n */\nbool f_49(int n)", "de": "#include <cassert>\n#include <cstdio>\n/**\n * Du spielst ein Spiel namens Nim. In diesem Spiel beginnst du mit einem Haufen von n Steinen, und du und\n * dein Gegner wechseln euch ab, um 1 bis 3 Steine aus dem Haufen zu entfernen. Derjenige, der den letzten\n * Stein entfernt, gewinnt das Spiel. Gegeben ist die Anzahl der Steine n, bestimme, ob du das Spiel gewinnen kannst, wenn sowohl du\n * als auch dein Gegner optimal spielen.\n * Hinweis: Du machst immer den ersten Zug.\n *\n * Hier sind einige Fälle:\n *     >>> f_49(1)\n *     true\n */\nbool f_49(int n)", "ha": "#include <cassert>\n#include <cstdio>\n/**\n * Kuna wasa da wani wasa mai suna Nim. A cikin wannan wasa, kuna farawa da tarin duwatsu n, ku da\n * abokin hamayyarku kuna juyawa don cire 1 zuwa 3 duwatsu daga tarin. Wanda ya cire dutse na karshe\n * shi ne ya ci wasan. An ba da adadin duwatsu n, tantance idan za ku iya cin wasan idan ku duka\n * ku da abokin hamayyarku kuna wasa da kyau.\n * Lura: Kullum kuna fara juyawa.\n *\n * Ga wasu lokuta:\n *     >>> f_49(1)\n *     true\n */\nbool f_49(int n)", "hi": "#include <cassert>\n#include <cstdio>\n/**\n * आप एक खेल खेल रहे हैं जिसे निम कहा जाता है। इस खेल में, आप n पत्थरों के ढेर के साथ शुरू करते हैं, और आप और\n * आपका प्रतिद्वंद्वी बारी-बारी से ढेर से 1 से 3 पत्थर हटाते हैं। जो अंतिम पत्थर हटाता है वह खेल जीतता है। दिए गए पत्थरों की संख्या n के आधार पर, यह निर्धारित करें कि क्या आप खेल जीत सकते हैं यदि आप और आपका प्रतिद्वंद्वी दोनों अनुकूल रूप से खेलते हैं।\n * ध्यान दें: आप हमेशा पहली बारी लेते हैं।\n *\n * यहाँ कुछ मामले हैं:\n *     >>> f_49(1)\n *     true\n */\nbool f_49(int n)", "hu": "#include <cassert>\n#include <cstdio>\n/**\n * Egy Nim nevű játékot játszol. Ebben a játékban egy halom n kővel kezdesz, és te valamint\n * az ellenfeled felváltva távolítotok el 1-3 követ a halomból. Az nyer, aki az utolsó\n * követ eltávolítja. Adott a kövek száma n, határozd meg, hogy nyerhetsz-e, ha mind te,\n * mind az ellenfeled optimálisan játszik.\n * Megjegyzés: Mindig te kezded az első lépést.\n *\n * Íme néhány eset:\n *     >>> f_49(1)\n *     true\n */\nbool f_49(int n)", "es": "#include <cassert>\n#include <cstdio>\n/**\n * Estás jugando un juego llamado Nim. En este juego, comienzas con una pila de n piedras, y tú y\n * tu oponente se turnan para quitar de 1 a 3 piedras de la pila. Quien quite la última piedra gana\n * el juego. Dado el número de piedras n, determina si puedes ganar el juego si tanto tú como tu\n * oponente juegan óptimamente.\n * Nota: Siempre tomas el primer turno.\n *\n * Aquí hay algunos casos:\n *     >>> f_49(1)\n *     true\n */\nbool f_49(int n)", "arb": "#include <cassert>\n#include <cstdio>\n/**\n * أنت تلعب لعبة تسمى نيم. في هذه اللعبة، تبدأ بكومة من n من الحجارة، وأنت وخصمك تتناوبان على إزالة 1 إلى 3 حجارة من الكومة. الشخص الذي يزيل آخر حجر يفوز باللعبة. بالنظر إلى عدد الحجارة n، حدد ما إذا كان بإمكانك الفوز باللعبة إذا كنت أنت وخصمك تلعبان بشكل مثالي.\n * ملاحظة: أنت دائمًا تأخذ الدور الأول.\n *\n * إليك بعض الحالات:\n *     >>> f_49(1)\n *     true\n */\nbool f_49(int n)", "sw": "#include <cassert>\n#include <cstdio>\n/**\n * Unacheza mchezo unaoitwa Nim. Katika mchezo huu, unaanza na rundo la mawe n, na wewe na\n * mpinzani wako mnachukua zamu kuondoa mawe 1 hadi 3 kutoka kwenye rundo. Yule anayeondoa jiwe la mwisho\n * anashinda mchezo. Ukipewa idadi ya mawe n, amua kama unaweza kushinda mchezo ikiwa wote wewe\n * na mpinzani wako mna cheza kwa ustadi.\n * Kumbuka: Daima unachukua zamu ya kwanza.\n *\n * Hapa kuna baadhi ya kesi:\n *     >>> f_49(1)\n *     true\n */\nbool f_49(int n)", "tr": "#include <cassert>\n#include <cstdio>\n/**\n * Nim adında bir oyun oynuyorsunuz. Bu oyunda, n taşından oluşan bir yığınla başlarsınız ve siz ve\n * rakibiniz sırayla yığından 1 ila 3 taş çıkarırsınız. Son taşı çıkaran oyunu kazanır. Taş sayısı n\n * verildiğinde, hem siz hem de rakibiniz en iyi şekilde oynarsa oyunu kazanıp kazanamayacağınızı\n * belirleyin.\n * Not: Her zaman ilk hamleyi siz yaparsınız.\n *\n * İşte bazı durumlar:\n *     >>> f_49(1)\n *     true\n */\nbool f_49(int n)", "vi": "#include <cassert>\n#include <cstdio>\n/**\n * Bạn đang chơi một trò chơi gọi là Nim. Trong trò chơi này, bạn bắt đầu với một đống n viên đá, và bạn cùng\n * đối thủ của bạn lần lượt lấy đi từ 1 đến 3 viên đá từ đống. Người lấy viên đá cuối cùng sẽ thắng trò chơi. Cho số lượng viên đá n, xác định xem bạn có thể thắng trò chơi nếu cả bạn\n * và đối thủ của bạn chơi tối ưu.\n * Lưu ý: Bạn luôn là người đi trước.\n *\n * Dưới đây là một số trường hợp:\n *     >>> f_49(1)\n *     true\n */\nbool f_49(int n)", "id": "#include <cassert>\n#include <cstdio>\n/**\n * Anda sedang bermain permainan yang disebut Nim. Dalam permainan ini, Anda mulai dengan tumpukan n batu, dan Anda serta\n * lawan Anda bergantian untuk mengambil 1 hingga 3 batu dari tumpukan. Orang yang mengambil batu terakhir\n * memenangkan permainan. Diberikan jumlah batu n, tentukan apakah Anda bisa memenangkan permainan jika Anda dan\n * lawan Anda bermain secara optimal.\n * Catatan: Anda selalu mengambil giliran pertama.\n *\n * Berikut adalah beberapa kasus:\n *     >>> f_49(1)\n *     true\n */\nbool f_49(int n)", "ja": "#include <cassert>\n#include <cstdio>\n/**\n * あなたはNimというゲームをプレイしています。このゲームでは、n個の石の山から始め、あなたと\n * あなたの対戦相手は交互に1から3個の石を山から取り除きます。最後の石を取り除いた人がゲームに勝ちます。\n * 石の数nが与えられたとき、あなたと対戦相手が最適にプレイした場合にあなたがゲームに勝てるかどうかを判断します。\n * 注意: あなたは常に最初のターンを取ります。\n *\n * 以下はいくつかのケースです:\n *     >>> f_49(1)\n *     true\n */\nbool f_49(int n)", "ko": "#include <cassert>\n#include <cstdio>\n/**\n * 당신은 Nim이라는 게임을 하고 있습니다. 이 게임에서, 당신은 n개의 돌무더기로 시작하며, 당신과\n * 상대방은 차례로 돌무더기에서 1개에서 3개의 돌을 제거합니다. 마지막 돌을 제거하는 사람이 게임에서 승리합니다.\n * 돌의 수 n이 주어졌을 때, 당신과 상대방이 최적으로 플레이할 경우 당신이 게임에서 이길 수 있는지 결정하십시오.\n * 참고: 당신이 항상 첫 번째 턴을 가집니다.\n *\n * 다음은 몇 가지 경우입니다:\n *     >>> f_49(1)\n *     true\n */\nbool f_49(int n)", "ml": "#include <cassert>\n#include <cstdio>\n/**\n * നിങ്ങൾ നിം എന്നൊരു ഗെയിം കളിക്കുകയാണ്. ഈ ഗെയിമിൽ, നിങ്ങൾ n കല്ലുകൾ ഉള്ള ഒരു കൂമ്പാരം കൊണ്ട് ആരംഭിക്കുന്നു, \n * നിങ്ങൾക്കും നിങ്ങളുടെ എതിരാളിക്കും കൂമ്പാരത്തിൽ നിന്ന് 1 മുതൽ 3 വരെ കല്ലുകൾ നീക്കം ചെയ്യാൻ കഴിയുന്നു. \n * അവസാന കല്ല് നീക്കം ചെയ്യുന്നവൻ ഗെയിം ജയിക്കും. കല്ലുകളുടെ എണ്ണം n നൽകിയാൽ, നിങ്ങൾക്കും നിങ്ങളുടെ എതിരാളിക്കും \n * മികച്ച രീതിയിൽ കളിക്കുമ്പോൾ നിങ്ങൾക്ക് ഗെയിം ജയിക്കാനാകുമോ എന്ന് നിശ്ചയിക്കുക.\n * കുറിപ്പ്: നിങ്ങൾ എപ്പോഴും ആദ്യ തവണ കളിക്കുന്നു.\n *\n * ചില കേസുകൾ ഇവയാണ്:\n *     >>> f_49(1)\n *     true\n */\nbool f_49(int n)", "fa": "#include <cassert>\n#include <cstdio>\n/**\n * شما یک بازی به نام نیم بازی می‌کنید. در این بازی، شما با یک توده از n سنگ شروع می‌کنید و شما و\n * حریف‌تان به نوبت 1 تا 3 سنگ از توده برمی‌دارید. کسی که آخرین سنگ را برمی‌دارد بازی را می‌برد. با توجه به تعداد سنگ‌ها n، تعیین کنید که آیا می‌توانید بازی را ببرید اگر هم شما و\n * هم حریف‌تان به صورت بهینه بازی کنید.\n * توجه: شما همیشه اولین نوبت را دارید.\n *\n * در اینجا چند مورد وجود دارد:\n *     >>> f_49(1)\n *     true\n */\nbool f_49(int n)"}, "canonical_solution": "{\n    return n % 4 != 0;\n}", "instruction": {"en": "Write a CPP function `bool f_49(int n)` to solve the following problem:\nYou are playing a game called Nim. In this game, you start with a pile of n stones, and you and\nyour opponent take turns to remove 1 to 3 stones from the pile. The one who removes the last\nstone wins the game. Given the number of stones n, determine if you can win the game if both you\nand your opponent play optimally.\nNote: You always take the first turn.\n\nHere are some cases:\n    >>> f_49(1)\n    true\n", "sq": "Shkruani një funksion CPP `bool f_49(int n)` për të zgjidhur problemin e mëposhtëm:\nJu po luani një lojë të quajtur Nim. Në këtë lojë, ju filloni me një grumbull prej n gurësh, dhe ju dhe kundërshtari juaj merrni me radhë për të hequr 1 deri në 3 gurë nga grumbulli. Ai që heq gurin e fundit fiton lojën. Duke pasur parasysh numrin e gurëve n, përcaktoni nëse mund ta fitoni lojën nëse si ju ashtu edhe kundërshtari juaj luani në mënyrë optimale.\nShënim: Ju gjithmonë e merrni lëvizjen e parë.\n\nKëtu janë disa raste:\n    >>> f_49(1)\n    true", "hy": "Գրեք CPP ֆունկցիա `bool f_49(int n)` հետևյալ խնդիրը լուծելու համար:\nԴուք խաղում եք Nim կոչվող խաղը: Այս խաղում դուք սկսում եք n քարերից բաղկացած կույտով, և դուք և ձեր մրցակիցը հերթով հեռացնում եք 1-ից 3 քարեր կույտից: Նա, ով հեռացնում է վերջին քարը, հաղթում է խաղը: Տրված է քարերի քանակը n, որոշեք՝ արդյոք դուք կարող եք հաղթել խաղը, եթե դուք և ձեր մրցակիցը խաղում եք օպտիմալ կերպով:\nՆշում: Դուք միշտ առաջինն եք խաղում:\n\nԱհա որոշ դեպքեր:\n    >>> f_49(1)\n    true", "bn": "একটি CPP ফাংশন `bool f_49(int n)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nআপনি একটি গেম খেলছেন যার নাম নিম। এই গেমে, আপনি n পাথর দিয়ে শুরু করেন, এবং আপনি এবং আপনার প্রতিপক্ষ পালাক্রমে 1 থেকে 3 পাথর পাইল থেকে সরিয়ে নেন। যে শেষ পাথরটি সরায় সে গেমটি জিতে। পাথরের সংখ্যা n দেওয়া হলে, নির্ধারণ করুন আপনি গেমটি জিততে পারবেন কিনা যদি আপনি এবং আপনার প্রতিপক্ষ উভয়েই সর্বোত্তমভাবে খেলেন।\nদ্রষ্টব্য: আপনি সর্বদা প্রথম পালা নেন।\n\nএখানে কিছু উদাহরণ দেওয়া হলো:\n    >>> f_49(1)\n    true", "bg": "Напишете CPP функция `bool f_49(int n)`, за да решите следния проблем:\nВие играете игра, наречена Nim. В тази игра започвате с купчина от n камъка, и вие и вашият противник се редувате да премахвате от 1 до 3 камъка от купчината. Този, който премахне последния камък, печели играта. Като се има предвид броят на камъните n, определете дали можете да спечелите играта, ако и вие, и вашият противник играете оптимално.\nЗабележка: Винаги вие започвате първи.\n\nЕто някои случаи:\n    >>> f_49(1)\n    true", "zh": "编写一个 CPP 函数 `bool f_49(int n)` 来解决以下问题：  \n你正在玩一个叫做 Nim 的游戏。在这个游戏中，你从一堆 n 个石头开始，你和你的对手轮流从堆中移除 1 到 3 个石头。移除最后一个石头的人赢得游戏。给定石头的数量 n，如果你和你的对手都采取最优策略，确定你是否能赢得游戏。  \n注意：你总是先手。  \n\n以下是一些情况：  \n    >>> f_49(1)  \n    true  ", "fr": "Écrivez une fonction CPP `bool f_49(int n)` pour résoudre le problème suivant :  \nVous jouez à un jeu appelé Nim. Dans ce jeu, vous commencez avec un tas de n pierres, et vous et votre adversaire prenez à tour de rôle de 1 à 3 pierres du tas. Celui qui enlève la dernière pierre gagne la partie. Étant donné le nombre de pierres n, déterminez si vous pouvez gagner la partie si vous et votre adversaire jouez de manière optimale.  \nRemarque : Vous prenez toujours le premier tour.\n\nVoici quelques cas :  \n    >>> f_49(1)  \n    true  ", "de": "Schreiben Sie eine CPP-Funktion `bool f_49(int n)`, um das folgende Problem zu lösen:\nSie spielen ein Spiel namens Nim. In diesem Spiel beginnen Sie mit einem Haufen von n Steinen, und Sie und Ihr Gegner wechseln sich ab, um 1 bis 3 Steine aus dem Haufen zu entfernen. Derjenige, der den letzten Stein entfernt, gewinnt das Spiel. Angesichts der Anzahl der Steine n bestimmen Sie, ob Sie das Spiel gewinnen können, wenn sowohl Sie als auch Ihr Gegner optimal spielen.\nHinweis: Sie sind immer der Erste, der an der Reihe ist.\n\nHier sind einige Fälle:\n    >>> f_49(1)\n    true", "ha": "Rubuta aikin CPP `bool f_49(int n)` don warware matsalar mai zuwa:\nKana wasa da ake kira Nim. A cikin wannan wasan, ka fara da tarin duwatsu n, kai da abokin hamayyarka kuna juyawa don cire duwatsu 1 zuwa 3 daga tarin. Wanda ya cire dutse na ƙarshe shi ne ya ci wasan. Idan aka ba da adadin duwatsu n, tantance ko zaka iya cin nasara idan kai da abokin hamayyarka kuna wasa cikin hikima.\nLura: Kai ne kullum ke fara wasa.\n\nGa wasu lokuta:", "hi": "एक CPP फ़ंक्शन `bool f_49(int n)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nआप एक खेल खेल रहे हैं जिसे निम कहा जाता है। इस खेल में, आप n पत्थरों के ढेर के साथ शुरू करते हैं, और आप और आपका प्रतिद्वंद्वी बारी-बारी से ढेर से 1 से 3 पत्थर हटाते हैं। जो आखिरी पत्थर हटाता है वह खेल जीतता है। दिए गए पत्थरों की संख्या n के आधार पर, यह निर्धारित करें कि क्या आप खेल जीत सकते हैं यदि आप और आपका प्रतिद्वंद्वी दोनों सर्वोत्तम तरीके से खेलते हैं।\nध्यान दें: आप हमेशा पहली बारी लेते हैं।\n\nयहां कुछ उदाहरण हैं:\n    >>> f_49(1)\n    true", "hu": "Írj egy CPP függvényt `bool f_49(int n)` a következő probléma megoldására:\nEgy Nim nevű játékot játszol. Ebben a játékban egy halom n kővel kezdesz, és te, valamint az ellenfeled felváltva távolítotok el 1-től 3-ig terjedő követ a halomból. Az nyer, aki az utolsó követ eltávolítja. Adott a kövek száma n, határozd meg, hogy nyerhetsz-e, ha te és az ellenfeled is optimálisan játszotok.\nMegjegyzés: Mindig te kezded az első lépést.\n\nÍme néhány eset:\n    >>> f_49(1)\n    true", "es": "Escribe una función CPP `bool f_49(int n)` para resolver el siguiente problema:\nEstás jugando un juego llamado Nim. En este juego, comienzas con una pila de n piedras, y tú y tu oponente se turnan para quitar de 1 a 3 piedras de la pila. Quien quite la última piedra gana el juego. Dado el número de piedras n, determina si puedes ganar el juego si tanto tú como tu oponente juegan de manera óptima.\nNota: Siempre tomas el primer turno.\n\nAquí hay algunos casos:\n    >>> f_49(1)\n    true", "arb": "اكتب دالة CPP `bool f_49(int n)` لحل المشكلة التالية:\nأنت تلعب لعبة تسمى نيم. في هذه اللعبة، تبدأ بكومة من الحجارة عددها n، وأنت وخصمك تتناوبان على إزالة 1 إلى 3 حجارة من الكومة. الشخص الذي يزيل آخر حجر يفوز باللعبة. بالنظر إلى عدد الحجارة n، حدد ما إذا كان بإمكانك الفوز باللعبة إذا كنت أنت وخصمك تلعبان بشكل مثالي.\nملاحظة: أنت دائمًا تأخذ الدور الأول.\n\nإليك بعض الحالات:\n    >>> f_49(1)\n    true", "sw": "Andika kazi ya CPP `bool f_49(int n)` kutatua tatizo lifuatalo:\nUnacheza mchezo uitwao Nim. Katika mchezo huu, unaanza na rundo la mawe n, na wewe na mpinzani wako mnapokezana kuondoa mawe 1 hadi 3 kutoka kwenye rundo. Yule anayeondoa jiwe la mwisho anashinda mchezo. Ukipewa idadi ya mawe n, amua kama unaweza kushinda mchezo ikiwa wewe na mpinzani wako mna cheza kwa ustadi.\nKumbuka: Daima unachukua zamu ya kwanza.\n\nHapa kuna baadhi ya kesi:\n    >>> f_49(1)\n    true", "tr": "Bir CPP fonksiyonu `bool f_49(int n)` yazın ve aşağıdaki problemi çözün:\nNim adlı bir oyun oynuyorsunuz. Bu oyunda, n taşlık bir yığınla başlarsınız ve siz ve rakibiniz sırayla yığından 1 ila 3 taş çıkarırsınız. Son taşı çıkaran oyunu kazanır. Taş sayısı n verildiğinde, hem siz hem de rakibiniz en iyi şekilde oynarsanız oyunu kazanıp kazanamayacağınızı belirleyin.\nNot: Her zaman ilk hamleyi siz yaparsınız.\n\nİşte bazı durumlar:\n    >>> f_49(1)\n    true", "vi": "Viết một hàm CPP `bool f_49(int n)` để giải quyết vấn đề sau:\nBạn đang chơi một trò chơi gọi là Nim. Trong trò chơi này, bạn bắt đầu với một đống n viên đá, và bạn cùng đối thủ của mình lần lượt lấy từ 1 đến 3 viên đá ra khỏi đống. Người lấy viên đá cuối cùng sẽ thắng trò chơi. Cho số lượng viên đá n, xác định xem bạn có thể thắng trò chơi hay không nếu cả bạn và đối thủ đều chơi tối ưu.\nLưu ý: Bạn luôn là người đi trước.\n\nDưới đây là một số trường hợp:\n    >>> f_49(1)\n    true", "id": "Tulis fungsi CPP `bool f_49(int n)` untuk menyelesaikan masalah berikut:\nAnda sedang bermain permainan yang disebut Nim. Dalam permainan ini, Anda mulai dengan setumpuk n batu, dan Anda serta lawan Anda bergiliran mengambil 1 hingga 3 batu dari tumpukan. Orang yang mengambil batu terakhir memenangkan permainan. Diberikan jumlah batu n, tentukan apakah Anda bisa memenangkan permainan jika Anda dan lawan Anda bermain secara optimal.\nCatatan: Anda selalu mengambil giliran pertama.\n\nBerikut adalah beberapa kasus:\n    >>> f_49(1)\n    true", "ja": "以下の問題を解くために、CPP関数 `bool f_49(int n)` を作成してください:\nあなたはNimというゲームをプレイしています。このゲームでは、n個の石の山から始め、あなたと相手が交互に1から3個の石を山から取り除きます。最後の石を取り除いた人がゲームに勝ちます。石の数nが与えられたとき、あなたと相手が最適にプレイした場合に、あなたがゲームに勝つことができるかどうかを判断してください。\n注意: あなたは常に最初のターンを取ります。\n\nいくつかのケースを示します:\n    >>> f_49(1)\n    true", "ko": "CPP 함수를 작성하십시오 `bool f_49(int n)` 다음 문제를 해결하기 위해:\n당신은 Nim이라는 게임을 하고 있습니다. 이 게임에서, 당신은 n개의 돌무더기로 시작하고, 당신과 당신의 상대는 번갈아 가며 1에서 3개의 돌을 무더기에서 제거합니다. 마지막 돌을 제거하는 사람이 게임에서 승리합니다. 주어진 돌의 수 n에 대해, 당신과 상대가 최적으로 플레이할 경우 당신이 게임에서 이길 수 있는지 결정하십시오.\n참고: 당신은 항상 첫 번째 턴을 가집니다.\n\n다음은 몇 가지 경우입니다:\n    >>> f_49(1)\n    true", "ml": "CPP ഫംഗ്ഷൻ `bool f_49(int n)` എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nനിം എന്നൊരു ഗെയിം നിങ്ങൾ കളിക്കുകയാണ്. ഈ ഗെയിമിൽ, നിങ്ങൾക്ക് n കല്ലുകൾ ഉള്ള ഒരു കൂമ്പാരം ഉണ്ടാകും, നിങ്ങൾക്കും നിങ്ങളുടെ എതിരാളിക്കും കൂമ്പാരത്തിൽ നിന്ന് 1 മുതൽ 3 വരെ കല്ലുകൾ നീക്കാൻ തവണകൾ വരും. അവസാന കല്ല് നീക്കുന്നയാൾ ഗെയിം ജയിക്കും. കല്ലുകളുടെ എണ്ണം n നൽകിയാൽ, നിങ്ങൾക്കും നിങ്ങളുടെ എതിരാളിക്കും മികച്ച രീതിയിൽ കളിക്കുമ്പോൾ നിങ്ങൾക്ക് ഗെയിം ജയിക്കാനാകുമോ എന്ന് നിർണയിക്കുക.\nകുറിപ്പ്: നിങ്ങൾ എപ്പോഴും ആദ്യ തവണ എടുക്കും.\n\nഇവിടെ ചില കേസുകൾ:\n    >>> f_49(1)\n    true", "fa": "یک تابع CPP به نام `bool f_49(int n)` بنویسید تا مسئله زیر را حل کند:\nشما در حال بازی به نام Nim هستید. در این بازی، شما با یک توده از n سنگ شروع می‌کنید و شما و حریف‌تان به نوبت 1 تا 3 سنگ از توده برمی‌دارید. کسی که آخرین سنگ را بردارد، برنده بازی است. با توجه به تعداد سنگ‌ها n، تعیین کنید که آیا می‌توانید بازی را ببرید اگر هم شما و هم حریف‌تان به‌طور بهینه بازی کنید.\nتوجه: شما همیشه اولین نوبت را برمی‌دارید.\n\nدر اینجا چند مورد وجود دارد:\n    >>> f_49(1)\n    true"}, "level": "easy", "test": "int main() {\n    assert(f_49(1) == true);\n    assert(f_49(2) == true);\n    assert(f_49(3) == true);\n    assert(f_49(4) == false);\n    assert(f_49(5) == true);\n    assert(f_49(6) == true);\n    assert(f_49(7) == true);\n    assert(f_49(8) == false);\n    assert(f_49(9) == true);\n    assert(f_49(10) == true);\n    assert(f_49(11) == true);\n    assert(f_49(12) == false);\n    assert(f_49(13) == true);\n    assert(f_49(14) == true);\n    assert(f_49(15) == true);\n    assert(f_49(16) == false);\n    assert(f_49(17) == true);\n    assert(f_49(18) == true);\n    assert(f_49(19) == true);\n    assert(f_49(20) == false);\n    return 0;\n}", "entry_point": "f_49", "signature": "bool f_49(int n)", "docstring": {"en": "You are playing a game called Nim. In this game, you start with a pile of n stones, and you and\nyour opponent take turns to remove 1 to 3 stones from the pile. The one who removes the last\nstone wins the game. Given the number of stones n, determine if you can win the game if both you\nand your opponent play optimally.\nNote: You always take the first turn.\n\nHere are some cases:\n    >>> f_49(1)\n    true\n", "sq": "Ju po luani një lojë të quajtur Nim. Në këtë lojë, ju filloni me një grumbull prej n gurësh, dhe ju dhe kundërshtari juaj merrni radhë për të hequr 1 deri në 3 gurë nga grumbulli. Ai që heq gurin e fundit fiton lojën. Duke pasur parasysh numrin e gurëve n, përcaktoni nëse mund të fitoni lojën nëse si ju ashtu edhe kundërshtari juaj luani në mënyrë optimale. \nShënim: Ju gjithmonë merrni radhën e parë.\n\nKëtu janë disa raste:\n    >>> f_49(1)\n    true", "hy": "Դուք խաղում եք Նիմ կոչվող խաղը։ Այս խաղում դուք սկսում եք n քարերով կույտով, և դուք և ձեր հակառակորդը հերթով հեռացնում եք 1-ից 3 քար կույտից։ Նա, ով հեռացնում է վերջին քարը, հաղթում է խաղը։ Տրված է քարերի քանակը n, որոշեք՝ արդյոք դուք կարող եք հաղթել խաղը, եթե դուք և ձեր հակառակորդը խաղում եք օպտիմալ կերպով։\nՆշում: Դուք միշտ առաջին հերթն եք կատարում։\n\nԱհա որոշ դեպքեր.\n    >>> f_49(1)\n    true", "bn": "তুমি একটি গেম খেলছো যার নাম নিম। এই গেমে, তুমি n সংখ্যক পাথর দিয়ে শুরু করো, এবং তুমি ও তোমার প্রতিপক্ষ পালাক্রমে পাথরের স্তূপ থেকে ১ থেকে ৩টি পাথর সরিয়ে নাও। যে শেষ পাথরটি সরায় সে গেমটি জেতে। প্রদত্ত পাথরের সংখ্যা n, নির্ধারণ করো তুমি গেমটি জিততে পারবে কিনা যদি তুমি এবং তোমার প্রতিপক্ষ উভয়ই সর্বোত্তমভাবে খেলে।\nনোট: তুমি সবসময় প্রথম পালা নাও।\n\nকিছু উদাহরণ এখানে:\n    >>> f_49(1)\n    true", "bg": "Играете игра, наречена Nim. В тази игра започвате с купчина от n камъка и вие и вашият противник се редувате да премахвате от 1 до 3 камъка от купчината. Този, който премахне последния камък, печели играта. Даден е броят на камъните n, определете дали можете да спечелите играта, ако и вие, и вашият противник играете оптимално.  \nЗабележка: Винаги вие правите първия ход.\n\nЕто някои случаи:\n    >>> f_49(1)\n    true", "zh": "你正在玩一个叫做 Nim 的游戏。在这个游戏中，你从一堆 n 个石头开始，你和你的对手轮流从堆中移除 1 到 3 个石头。移除最后一个石头的人赢得游戏。给定石头的数量 n，判断如果你和你的对手都采取最佳策略，你是否能赢得游戏。\n注意：你总是先走。\n\n以下是一些情况：\n    >>> f_49(1)\n    true", "fr": "Vous jouez à un jeu appelé Nim. Dans ce jeu, vous commencez avec un tas de n pierres, et vous et votre adversaire prenez à tour de rôle entre 1 et 3 pierres du tas. Celui qui enlève la dernière pierre gagne la partie. Étant donné le nombre de pierres n, déterminez si vous pouvez gagner la partie si vous et votre adversaire jouez de manière optimale.  \nRemarque : Vous jouez toujours en premier.\n\nVoici quelques cas :\n    >>> f_49(1)\n    true", "de": "Du spielst ein Spiel namens Nim. In diesem Spiel beginnst du mit einem Haufen von n Steinen, und du und dein Gegner wechseln euch ab, um 1 bis 3 Steine vom Haufen zu entfernen. Derjenige, der den letzten Stein entfernt, gewinnt das Spiel. Gegeben ist die Anzahl der Steine n, bestimme, ob du das Spiel gewinnen kannst, wenn sowohl du als auch dein Gegner optimal spielen.\nHinweis: Du bist immer am Zug.\n\nHier sind einige Fälle:\n    >>> f_49(1)\n    true", "ha": "Kana wasa mai suna Nim. A cikin wannan wasa, ka fara da tarin duwatsu n, kai da abokin hamayyarka kuna yin juyi don cire duwatsu 1 zuwa 3 daga tarin. Wanda ya cire dutse na ƙarshe shi ne ya ci wasan. An ba da adadin duwatsu n, tantance ko zaka iya cin nasara idan kai da abokin hamayyarka kuna wasa da hikima.\nLura: Kai ne koyaushe kake fara juyi.\n\nGa wasu lokuta:\n    >>> f_49(1)\n    true", "hi": "आप एक खेल खेल रहे हैं जिसे निम कहा जाता है। इस खेल में, आप n पत्थरों के ढेर के साथ शुरू करते हैं, और आप और आपका प्रतिद्वंद्वी बारी-बारी से ढेर से 1 से 3 पत्थर हटाते हैं। जो अंतिम पत्थर हटाता है वह खेल जीतता है। दिए गए पत्थरों की संख्या n के आधार पर, यह निर्धारित करें कि यदि आप और आपका प्रतिद्वंद्वी दोनों सर्वोत्तम रूप से खेलते हैं तो क्या आप खेल जीत सकते हैं।\nध्यान दें: आप हमेशा पहली बारी लेते हैं।\n\nयहाँ कुछ मामले हैं:\n    >>> f_49(1)\n    true", "hu": "Egy Nim nevű játékot játszol. Ebben a játékban egy halom n kővel kezdesz, és te, valamint az ellenfeled felváltva távolítotok el 1-3 követ a halomból. Az nyer, aki az utolsó követ eltávolítja. Adott a kövek száma n, határozd meg, hogy nyerhetsz-e, ha mind te, mind az ellenfeled optimálisan játszik.\nMegjegyzés: Mindig te kezded az első kört.\n\nÍme néhány eset:\n    >>> f_49(1)\n    true", "es": "Estás jugando a un juego llamado Nim. En este juego, comienzas con un montón de n piedras, y tú y tu oponente se turnan para quitar de 1 a 3 piedras del montón. El que quite la última piedra gana el juego. Dado el número de piedras n, determina si puedes ganar el juego si tanto tú como tu oponente juegan de manera óptima.\nNota: Siempre tomas el primer turno.\n\nAquí hay algunos casos:\n    >>> f_49(1)\n    true", "arb": "أنت تلعب لعبة تسمى نيم. في هذه اللعبة، تبدأ بكومة تحتوي على n من الحجارة، وتقوم أنت وخصمك بالتناوب لإزالة من 1 إلى 3 حجارة من الكومة. الشخص الذي يزيل الحجر الأخير يفوز باللعبة. بالنظر إلى عدد الحجارة n، حدد ما إذا كان بإمكانك الفوز باللعبة إذا كنت أنت وخصمك تلعبان بشكل مثالي.\nملاحظة: أنت دائمًا تأخذ الدور الأول.\n\nإليك بعض الحالات:\n    >>> f_49(1)\n    true", "sw": "Unacheza mchezo unaoitwa Nim. Katika mchezo huu, unaanza na rundo la mawe n, na wewe na mpinzani wako mnapokezana kuondoa mawe 1 hadi 3 kutoka kwenye rundo. Yule anayeondoa jiwe la mwisho ndiye anayeshinda mchezo. Ukipewa idadi ya mawe n, amua kama unaweza kushinda mchezo ikiwa wote wewe na mpinzani wako mna cheza kwa ustadi.\n\nKumbuka: Daima unachukua zamu ya kwanza.\n\nHapa kuna baadhi ya kesi:\n    >>> f_49(1)\n    true", "tr": "Bir oyun oynuyorsunuz, adı Nim. Bu oyunda, n taşlık bir yığınla başlarsınız ve siz ve rakibiniz sırayla yığından 1 ila 3 taş çıkarırsınız. Son taşı çıkaran oyunu kazanır. Taş sayısı n verildiğinde, hem siz hem de rakibiniz en iyi şekilde oynarsa oyunu kazanıp kazanamayacağınızı belirleyin. \nNot: Her zaman ilk hamleyi siz yaparsınız.\n\nBazı durumlar:\n    >>> f_49(1)\n    true", "vi": "Bạn đang chơi một trò chơi gọi là Nim. Trong trò chơi này, bạn bắt đầu với một đống n viên đá, và bạn cùng đối thủ của bạn lần lượt lấy đi từ 1 đến 3 viên đá từ đống. Người nào lấy viên đá cuối cùng sẽ thắng trò chơi. Cho số viên đá n, xác định xem bạn có thể thắng trò chơi nếu cả bạn và đối thủ đều chơi tối ưu hay không. \nLưu ý: Bạn luôn là người đi trước.\n\nDưới đây là một số trường hợp:\n    >>> f_49(1)\n    true", "id": "Anda sedang bermain permainan bernama Nim. Dalam permainan ini, Anda memulai dengan tumpukan n batu, dan Anda serta lawan Anda bergantian mengambil 1 hingga 3 batu dari tumpukan. Orang yang mengambil batu terakhir memenangkan permainan. Diberikan jumlah batu n, tentukan apakah Anda bisa memenangkan permainan jika Anda dan lawan Anda bermain secara optimal.  \nCatatan: Anda selalu mengambil giliran pertama.\n\nBerikut beberapa kasus:\n    >>> f_49(1)\n    true", "ja": "あなたはニムというゲームをプレイしています。このゲームでは、n個の石の山から始め、あなたと対戦相手が交互に1から3個の石を山から取り除きます。最後の石を取り除いた人がゲームに勝ちます。石の数nが与えられたとき、あなたと対戦相手が最適にプレイした場合に、あなたがゲームに勝てるかどうかを判断してください。\n注意: あなたは常に最初のターンを取ります。\n\nいくつかのケースを示します:\n    >>> f_49(1)\n    true", "ko": "당신은 Nim이라는 게임을 하고 있습니다. 이 게임에서, 당신은 n개의 돌무더기로 시작하며, 당신과 상대방은 번갈아 가며 돌무더기에서 1개에서 3개의 돌을 제거합니다. 마지막 돌을 제거하는 사람이 게임에서 승리합니다. 돌의 수 n이 주어졌을 때, 당신과 상대방이 최적으로 플레이할 경우 당신이 게임에서 이길 수 있는지 결정하세요. 참고: 당신이 항상 첫 번째 턴을 가집니다.\n\n다음은 몇 가지 경우입니다:\n    >>> f_49(1)\n    true", "ml": "നീം എന്നൊരു ഗെയിം നിങ്ങൾ കളിക്കുകയാണ്. ഈ ഗെയിമിൽ, നിങ്ങൾ n കല്ലുകൾ അടങ്ങിയ ഒരു കൂമ്പാരം കൊണ്ട് ആരംഭിക്കുന്നു, നിങ്ങൾക്കും നിങ്ങളുടെ എതിരാളിക്കും കൂമ്പാരത്തിൽ നിന്ന് 1 മുതൽ 3 വരെ കല്ലുകൾ നീക്കം ചെയ്യാൻ ടേൺ ലഭിക്കും. അവസാന കല്ല് നീക്കം ചെയ്യുന്നയാൾ ഗെയിം ജയിക്കും. കല്ലുകളുടെ എണ്ണം n നൽകിയാൽ, നിങ്ങൾക്കും നിങ്ങളുടെ എതിരാളിക്കും മികച്ച രീതിയിൽ കളിക്കുമ്പോൾ നിങ്ങൾക്ക് ഗെയിം ജയിക്കാനാകുമോ എന്ന് നിർണയിക്കുക. കുറിപ്പ്: നിങ്ങൾ എപ്പോഴും ആദ്യ ടേൺ എടുക്കുന്നു.\n\nഇവിടെ ചില കേസുകൾ ഉണ്ട്:\n    >>> f_49(1)\n    true", "fa": "شما در حال بازی به نام Nim هستید. در این بازی، شما با یک توده از n سنگ شروع می‌کنید و شما و حریف‌تان به نوبت 1 تا 3 سنگ از توده برمی‌دارید. کسی که آخرین سنگ را برمی‌دارد برنده بازی است. با توجه به تعداد سنگ‌ها n، تعیین کنید که آیا می‌توانید بازی را ببرید اگر هر دو شما و حریف‌تان بهینه بازی کنید.\nتوجه: شما همیشه اولین نوبت را دارید.\n\nدر اینجا چند مورد وجود دارد:\n    >>> f_49(1)\n    true"}}
{"task_id": "CPP/50", "prompt": {"en": "#include <cassert>\n#include <cstdio>\n/**\n * Given two integers a and b, return the sum if the sum is even, or the product of a and b if the sum is odd.\n * Examples:\n *    f_50(2, 3) returns 6\n *    f_50(5, 5) returns 10\n */\nint f_50(int a, int b)", "sq": "#include <cassert>\n#include <cstdio>\n/**\n * Duke pasur dy numra të plotë a dhe b, kthejeni shumën nëse shuma është çift, ose produktin e a dhe b nëse shuma është tek.\n * Shembuj:\n *    f_50(2, 3) kthen 6\n *    f_50(5, 5) kthen 10\n */\nint f_50(int a, int b)", "hy": "#include <cassert>\n#include <cstdio>\n/**\n * Տրված է երկու ամբողջ թիվ a և b, վերադարձնել գումարը, եթե գումարը զույգ է, կամ a և b արտադրյալը, եթե գումարը կենտ է։\n * Օրինակներ:\n *    f_50(2, 3) վերադարձնում է 6\n *    f_50(5, 5) վերադարձնում է 10\n */\nint f_50(int a, int b)", "bn": "#include <cassert>\n#include <cstdio>\n/**\n * দুটি পূর্ণসংখ্যা a এবং b দেওয়া হলে, যোগফলটি যদি জোড় হয় তবে যোগফল ফেরত দিন, অথবা যদি যোগফলটি বিজোড় হয় তবে a এবং b এর গুণফল ফেরত দিন।\n * উদাহরণ:\n *    f_50(2, 3) 6 ফেরত দেয়\n *    f_50(5, 5) 10 ফেরত দেয়\n */\nint f_50(int a, int b)", "bg": "#include <cassert>\n#include <cstdio>\n/**\n * Дадени са две цели числа a и b, върнете сумата, ако сумата е четна, или произведението на a и b, ако сумата е нечетна.\n * Примери:\n *    f_50(2, 3) връща 6\n *    f_50(5, 5) връща 10\n */\nint f_50(int a, int b)", "zh": "#include <cassert>\n#include <cstdio>\n/**\n * 给定两个整数 a 和 b，如果它们的和是偶数则返回和，如果和是奇数则返回 a 和 b 的乘积。\n * 例子:\n *    f_50(2, 3) 返回 6\n *    f_50(5, 5) 返回 10\n */\nint f_50(int a, int b)", "fr": "#include <cassert>\n#include <cstdio>\n/**\n * Étant donné deux entiers a et b, retourner la somme si la somme est paire, ou le produit de a et b si la somme est impaire.\n * Exemples :\n *    f_50(2, 3) retourne 6\n *    f_50(5, 5) retourne 10\n */\nint f_50(int a, int b)", "de": "#include <cassert>\n#include <cstdio>\n/**\n * Gegeben zwei ganze Zahlen a und b, gib die Summe zurück, wenn die Summe gerade ist, oder das Produkt von a und b, wenn die Summe ungerade ist.\n * Beispiele:\n *    f_50(2, 3) gibt 6 zurück\n *    f_50(5, 5) gibt 10 zurück\n */\nint f_50(int a, int b)", "ha": "#include <cassert>\n#include <cstdio>\n/**\n * An ba da lambobi biyu a da b, dawo da jumlar idan jumlar tana da lamba mai lamba, ko samfurin a da b idan jumlar tana da lamba mai lamba.\n * Misalai:\n *    f_50(2, 3) returns 6\n *    f_50(5, 5) returns 10\n */\nint f_50(int a, int b)", "hi": "#include <cassert>\n#include <cstdio>\n/**\n * दिए गए दो पूर्णांक a और b के लिए, योग को लौटाएं यदि योग सम है, या a और b का गुणनफल यदि योग विषम है।\n * उदाहरण:\n *    f_50(2, 3) 6 लौटाता है\n *    f_50(5, 5) 10 लौटाता है\n */\nint f_50(int a, int b)", "hu": "#include <cassert>\n#include <cstdio>\n/**\n * Két egész szám, a és b esetén térjen vissza az összeggel, ha az összeg páros, vagy a és b szorzatával, ha az összeg páratlan.\n * Példák:\n *    f_50(2, 3) visszatér 6\n *    f_50(5, 5) visszatér 10\n */\nint f_50(int a, int b)", "es": "#include <cassert>\n#include <cstdio>\n/**\n * Dados dos enteros a y b, devuelve la suma si la suma es par, o el producto de a y b si la suma es impar.\n * Ejemplos:\n *    f_50(2, 3) returns 6\n *    f_50(5, 5) returns 10\n */\nint f_50(int a, int b)", "arb": "#include <cassert>\n#include <cstdio>\n/**\n * بالنظر إلى عددين صحيحين a و b، أعد المجموع إذا كان المجموع زوجيًا، أو حاصل ضرب a و b إذا كان المجموع فرديًا.\n * أمثلة:\n *    f_50(2, 3) returns 6\n *    f_50(5, 5) returns 10\n */\nint f_50(int a, int b)", "sw": "#include <cassert>\n#include <cstdio>\n/**\n * Ukipewa nambari mbili a na b, rudisha jumla ikiwa jumla ni shufwa, au bidhaa ya a na b ikiwa jumla ni witiri.\n * Mifano:\n *    f_50(2, 3) inarudisha 6\n *    f_50(5, 5) inarudisha 10\n */\nint f_50(int a, int b)", "tr": "#include <cassert>\n#include <cstdio>\n/**\n * İki tamsayı a ve b verildiğinde, toplam çift ise toplamı, toplam tek ise a ve b'nin çarpımını döndürün.\n * Örnekler:\n *    f_50(2, 3) 6 döndürür\n *    f_50(5, 5) 10 döndürür\n */\nint f_50(int a, int b)", "vi": "#include <cassert>\n#include <cstdio>\n/**\n * Cho hai số nguyên a và b, trả về tổng nếu tổng là số chẵn, hoặc tích của a và b nếu tổng là số lẻ.\n * Ví dụ:\n *    f_50(2, 3) trả về 6\n *    f_50(5, 5) trả về 10\n */\nint f_50(int a, int b)", "id": "#include <cassert>\n#include <cstdio>\n/**\n * Diberikan dua bilangan bulat a dan b, kembalikan jumlahnya jika jumlahnya genap, atau hasil kali dari a dan b jika jumlahnya ganjil.\n * Contoh:\n *    f_50(2, 3) mengembalikan 6\n *    f_50(5, 5) mengembalikan 10\n */\nint f_50(int a, int b)", "ja": "#include <cassert>\n#include <cstdio>\n/**\n * 2つの整数aとbが与えられたとき、合計が偶数であれば合計を返し、合計が奇数であればaとbの積を返します。\n * 例:\n *    f_50(2, 3) は6を返します\n *    f_50(5, 5) は10を返します\n */\nint f_50(int a, int b)", "ko": "#include <cassert>\n#include <cstdio>\n/**\n * 두 정수 a와 b가 주어졌을 때, 합이 짝수이면 합을 반환하고, 합이 홀수이면 a와 b의 곱을 반환합니다.\n * 예시:\n *    f_50(2, 3) returns 6\n *    f_50(5, 5) returns 10\n */\nint f_50(int a, int b)", "ml": "#include <cassert>\n#include <cstdio>\n/**\n * രണ്ട് പൂർണ്ണസംഖ്യകൾ a, b എന്നിവ നൽകിയാൽ, തുക സമവായിരിക്കുകയാണെങ്കിൽ തുക തിരിച്ചുകൊടുക്കുക, അല്ലെങ്കിൽ തുക വിചിത്രമാണെങ്കിൽ a, b എന്നിവയുടെ ഗുണഫലം തിരിച്ചുകൊടുക്കുക.\n * ഉദാഹരണങ്ങൾ:\n *    f_50(2, 3) 6 തിരിച്ചുകൊടുക്കുന്നു\n *    f_50(5, 5) 10 തിരിച്ചുകൊടുക്കുന്നു\n */\nint f_50(int a, int b)", "fa": "#include <cassert>\n#include <cstdio>\n/**\n * با توجه به دو عدد صحیح a و b، اگر مجموع آنها زوج باشد، مجموع را برگردانید، یا اگر مجموع فرد باشد، حاصل‌ضرب a و b را برگردانید.\n * مثال‌ها:\n *    f_50(2, 3) برمی‌گرداند 6\n *    f_50(5, 5) برمی‌گرداند 10\n */\nint f_50(int a, int b)"}, "canonical_solution": "{\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}", "instruction": {"en": "Write a CPP function `int f_50(int a, int b)` to solve the following problem:\nGiven two integers a and b, return the sum if the sum is even, or the product of a and b if the sum is odd.\nExamples:\nf_50(2, 3) returns 6\nf_50(5, 5) returns 10", "sq": "Shkruani një funksion CPP `int f_50(int a, int b)` për të zgjidhur problemin e mëposhtëm:  \nDuke pasur dy numra të plotë a dhe b, kthejeni shumën nëse shuma është çift, ose produktin e a dhe b nëse shuma është tek.  \nShembuj:  \nf_50(2, 3) kthen 6  \nf_50(5, 5) kthen 10", "hy": "Գրեք CPP ֆունկցիա `int f_50(int a, int b)` հետևյալ խնդիրը լուծելու համար:\nՏրված են երկու ամբողջ թիվ a և b, վերադարձնել գումարը, եթե գումարը զույգ է, կամ a և b արտադրյալը, եթե գումարը կենտ է:\nՕրինակներ:\nf_50(2, 3) վերադարձնում է 6\nf_50(5, 5) վերադարձնում է 10", "bn": "একটি CPP ফাংশন `int f_50(int a, int b)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nদুটি পূর্ণসংখ্যা a এবং b দেওয়া হলে, যোগফল যদি জোড় হয় তবে যোগফল ফেরত দিন, অথবা যদি যোগফল বিজোড় হয় তবে a এবং b এর গুণফল ফেরত দিন।\nউদাহরণসমূহ:\nf_50(2, 3) 6 ফেরত দেয়\nf_50(5, 5) 10 ফেরত দেয়", "bg": "Напишете CPP функция `int f_50(int a, int b)` за решаване на следния проблем:  \nДадени са две цели числа a и b, върнете сумата, ако сумата е четна, или произведението на a и b, ако сумата е нечетна.  \nПримери:  \nf_50(2, 3) връща 6  \nf_50(5, 5) връща 10", "zh": "编写一个 CPP 函数 `int f_50(int a, int b)` 来解决以下问题：\n给定两个整数 a 和 b，如果它们的和是偶数，则返回和；如果和是奇数，则返回 a 和 b 的乘积。\n示例：\nf_50(2, 3) 返回 6\nf_50(5, 5) 返回 10", "fr": "Écrire une fonction CPP `int f_50(int a, int b)` pour résoudre le problème suivant :  \nÉtant donné deux entiers a et b, retourner la somme si la somme est paire, ou le produit de a et b si la somme est impaire.  \nExemples :  \nf_50(2, 3) retourne 6  \nf_50(5, 5) retourne 10", "de": "Schreiben Sie eine CPP-Funktion `int f_50(int a, int b)`, um das folgende Problem zu lösen:  \nGegeben sind zwei ganze Zahlen a und b, geben Sie die Summe zurück, wenn die Summe gerade ist, oder das Produkt von a und b, wenn die Summe ungerade ist.  \nBeispiele:  \nf_50(2, 3) gibt 6 zurück  \nf_50(5, 5) gibt 10 zurück", "ha": "Rubuta aikin CPP `int f_50(int a, int b)` don warware matsalar mai zuwa:  \nAn ba da lambobi guda biyu a da b, dawo da jumlar idan jumlar tana da lamba mai ma'ana, ko kuma samfurin a da b idan jumlar tana da lamba mai waje.  \nMisalai:  \nf_50(2, 3) yana dawowa 6  \nf_50(5, 5) yana dawowa 10", "hi": "एक CPP फ़ंक्शन `int f_50(int a, int b)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए दो पूर्णांक a और b, यदि योग सम है तो योग लौटाएं, या यदि योग विषम है तो a और b का गुणनफल लौटाएं।\nउदाहरण:\nf_50(2, 3) 6 लौटाता है\nf_50(5, 5) 10 लौटाता है", "hu": "Írj egy CPP függvényt `int f_50(int a, int b)` a következő probléma megoldására:\nAdott két egész szám, a és b, add vissza az összeget, ha az összeg páros, vagy a és b szorzatát, ha az összeg páratlan.\nPéldák:\nf_50(2, 3) visszaadja 6\nf_50(5, 5) visszaadja 10", "es": "Escribe una función en CPP `int f_50(int a, int b)` para resolver el siguiente problema:\nDado dos enteros a y b, devuelve la suma si la suma es par, o el producto de a y b si la suma es impar.\nEjemplos:\nf_50(2, 3) returns 6\nf_50(5, 5) returns 10", "arb": "اكتب دالة CPP `int f_50(int a, int b)` لحل المشكلة التالية:\nمعطى عددين صحيحين a و b، أعد المجموع إذا كان المجموع زوجيًا، أو حاصل ضرب a و b إذا كان المجموع فرديًا.\nأمثلة:\nf_50(2, 3) returns 6\nf_50(5, 5) returns 10", "sw": "Andika kazi ya CPP `int f_50(int a, int b)` kutatua tatizo lifuatalo:  \nUkipata nambari mbili nzima a na b, rudisha jumla ikiwa jumla ni shufwa, au bidhaa ya a na b ikiwa jumla ni witiri.  \nMifano:  \nf_50(2, 3) inarudisha 6  \nf_50(5, 5) inarudisha 10  ", "tr": "Bir CPP fonksiyonu `int f_50(int a, int b)` yazın ve aşağıdaki problemi çözün:\nVerilen iki tam sayı a ve b için, toplam çift ise toplamı, toplam tek ise a ve b'nin çarpımını döndürün.\nÖrnekler:\nf_50(2, 3) 6 döndürür\nf_50(5, 5) 10 döndürür", "vi": "Viết một hàm CPP `int f_50(int a, int b)` để giải quyết vấn đề sau:  \nCho hai số nguyên a và b, trả về tổng nếu tổng là số chẵn, hoặc tích của a và b nếu tổng là số lẻ.  \nVí dụ:  \nf_50(2, 3) trả về 6  \nf_50(5, 5) trả về 10  ", "id": "Tulis sebuah fungsi CPP `int f_50(int a, int b)` untuk menyelesaikan masalah berikut:\nDiberikan dua bilangan bulat a dan b, kembalikan jumlahnya jika jumlah tersebut genap, atau hasil kali dari a dan b jika jumlahnya ganjil.\nContoh:\nf_50(2, 3) mengembalikan 6\nf_50(5, 5) mengembalikan 10", "ja": "以下の問題を解決するためにCPP関数 `int f_50(int a, int b)` を作成してください:\n2つの整数aとbが与えられたとき、合計が偶数の場合は合計を返し、合計が奇数の場合はaとbの積を返します。\n例:\nf_50(2, 3) は6を返します\nf_50(5, 5) は10を返します", "ko": "다음 문제를 해결하기 위해 CPP 함수를 작성하십시오 `int f_50(int a, int b)`:\n두 정수 a와 b가 주어지면, 합이 짝수인 경우 합을 반환하고, 합이 홀수인 경우 a와 b의 곱을 반환합니다.\n예시:\nf_50(2, 3) returns 6\nf_50(5, 5) returns 10", "ml": "CPP ഫംഗ്ഷൻ `int f_50(int a, int b)` എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ: രണ്ട് പൂർണ്ണസംഖ്യകൾ a, b എന്നിവ നൽകിയാൽ, തുക സമമാണെങ്കിൽ തുക മടക്കുക, അല്ലെങ്കിൽ തുക വിചിത്രമാണെങ്കിൽ a, b എന്നിവയുടെ ഗുണഫലം മടക്കുക. ഉദാഹരണങ്ങൾ: f_50(2, 3) 6 മടക്കുന്നു f_50(5, 5) 10 മടക്കുന്നു", "fa": "یک تابع CPP به نام `int f_50(int a, int b)` بنویسید تا مسئله زیر را حل کند:\nبا داشتن دو عدد صحیح a و b، اگر مجموع زوج باشد، مجموع را برگردانید، یا اگر مجموع فرد باشد، حاصل‌ضرب a و b را برگردانید.\nمثال‌ها:\nf_50(2, 3) مقدار 6 را برمی‌گرداند\nf_50(5, 5) مقدار 10 را برمی‌گرداند"}, "level": "easy", "test": "int main() {\n    assert(f_50(2, 3) == 6);\n    assert(f_50(5, 5) == 10);\n    assert(f_50(1, 1) == 2);\n    assert(f_50(0, 0) == 0);\n    assert(f_50(-1, -1) == -2);\n    assert(f_50(100, 200) == 300);\n    assert(f_50(3, 4) == 12);\n    assert(f_50(-5, 5) == 0);\n    assert(f_50(7, 8) == 56);\n    assert(f_50(9, 10) == 90);\n    assert(f_50(11, 14) == 154);\n    return 0;\n}", "entry_point": "f_50", "signature": "int f_50(int a, int b)", "docstring": {"en": "Given two integers a and b, return the sum if the sum is even, or the product of a and b if the sum is odd.\nExamples:\nf_50(2, 3) returns 6\nf_50(5, 5) returns 10", "sq": "Duke pasur dy numra të plotë a dhe b, kthejeni shumën nëse shuma është çift, ose prodhimin e a dhe b nëse shuma është tek.\nShembuj:\nf_50(2, 3) kthen 6\nf_50(5, 5) kthen 10", "hy": "Տրված երկու ամբողջ թիվ a և b, վերադարձնել գումարը, եթե գումարը զույգ է, կամ a և b արտադրյալը, եթե գումարը կենտ է:\nՕրինակներ:\nf_50(2, 3) վերադարձնում է 6\nf_50(5, 5) վերադարձնում է 10", "bn": "দুটি পূর্ণসংখ্যা a এবং b দেওয়া হলে, যদি যোগফলটি জোড় হয় তবে যোগফলটি ফেরত দিন, অথবা যদি যোগফলটি বিজোড় হয় তবে a এবং b এর গুণফল ফেরত দিন।\nউদাহরণ:\nf_50(2, 3) 6 ফেরত দেয়\nf_50(5, 5) 10 ফেরত দেয়", "bg": "Дадени са две цели числа a и b, върнете сумата, ако сумата е четна, или произведението на a и b, ако сумата е нечетна.\nПримери:\nf_50(2, 3) връща 6\nf_50(5, 5) връща 10", "zh": "给定两个整数 a 和 b，如果它们的和是偶数，则返回和；如果和是奇数，则返回 a 和 b 的乘积。\n\n示例：\nf_50(2, 3) 返回 6\nf_50(5, 5) 返回 10", "fr": "Étant donnés deux entiers a et b, renvoyez la somme si la somme est paire, ou le produit de a et b si la somme est impaire.\nExemples :\nf_50(2, 3) renvoie 6\nf_50(5, 5) renvoie 10", "de": "Gegeben zwei ganze Zahlen a und b, gib die Summe zurück, wenn die Summe gerade ist, oder das Produkt von a und b, wenn die Summe ungerade ist.\nBeispiele:\nf_50(2, 3) gibt 6 zurück\nf_50(5, 5) gibt 10 zurück", "ha": "An ba da lambobi guda biyu a da b, dawo da jumlar idan jumlar tana da lamba mai ma'ana, ko kuma samfurin a da b idan jumlar tana da lamba mai wauta.\nMisalai:\nf_50(2, 3) yana dawowa 6\nf_50(5, 5) yana dawowa 10", "hi": "दो पूर्णांक a और b दिए गए हैं, यदि योग सम है तो योग लौटाएं, या यदि योग विषम है तो a और b का गुणनफल लौटाएं।\n\nउदाहरण:\nf_50(2, 3) 6 लौटाता है\nf_50(5, 5) 10 लौटाता है", "hu": "Két egész szám, a és b megadása esetén térjen vissza az összeggel, ha az összeg páros, vagy a és b szorzatával, ha az összeg páratlan.\nPéldák:\nf_50(2, 3) visszatér 6\nf_50(5, 5) visszatér 10", "es": "Dado dos enteros a y b, devuelve la suma si la suma es par, o el producto de a y b si la suma es impar.\nEjemplos:\nf_50(2, 3) devuelve 6\nf_50(5, 5) devuelve 10", "arb": "إعطاء عددين صحيحين a و b، قم بإرجاع المجموع إذا كان المجموع زوجيًا، أو حاصل ضرب a و b إذا كان المجموع فرديًا.\nأمثلة:\nf_50(2, 3) يعيد 6\nf_50(5, 5) يعيد 10", "sw": "Ukipewa nambari mbili a na b, rudisha jumla ikiwa jumla ni shufwa, au bidhaa ya a na b ikiwa jumla ni witiri.\n\nMifano:\nf_50(2, 3) inarudisha 6\nf_50(5, 5) inarudisha 10", "tr": "İki tamsayı a ve b verildiğinde, toplam çift ise toplamı, toplam tek ise a ve b'nin çarpımını döndürün.\nÖrnekler:\nf_50(2, 3) 6 döndürür\nf_50(5, 5) 10 döndürür", "vi": "Cho hai số nguyên a và b, trả về tổng nếu tổng là số chẵn, hoặc tích của a và b nếu tổng là số lẻ.\nVí dụ:\nf_50(2, 3) trả về 6\nf_50(5, 5) trả về 10", "id": "Diberikan dua bilangan bulat a dan b, kembalikan jumlahnya jika jumlah tersebut genap, atau hasil kali dari a dan b jika jumlahnya ganjil.\nContoh:\nf_50(2, 3) mengembalikan 6\nf_50(5, 5) mengembalikan 10", "ja": "2つの整数aとbが与えられたとき、合計が偶数であればその合計を返し、合計が奇数であればaとbの積を返します。\n例:\nf_50(2, 3) は 6 を返します\nf_50(5, 5) は 10 を返します", "ko": "두 정수 a와 b가 주어졌을 때, 합이 짝수이면 합을 반환하고, 합이 홀수이면 a와 b의 곱을 반환합니다.\n예시:\nf_50(2, 3) returns 6\nf_50(5, 5) returns 10", "ml": "രണ്ട് പൂർണ്ണസംഖ്യകളായ a, b എന്നിവ നൽകിയാൽ, ആകെ തുക സമം ആണെങ്കിൽ തുക മടക്കുക, അല്ലെങ്കിൽ തുക ഒറ്റ സംഖ്യയായാൽ a, b എന്നിവയുടെ ഗുണഫലം മടക്കുക.\n\nഉദാഹരണങ്ങൾ:\nf_50(2, 3) 6 മടക്കുന്നു\nf_50(5, 5) 10 മടക്കുന്നു", "fa": "دو عدد صحیح a و b داده شده است، اگر مجموع آنها زوج باشد، مجموع را برگردانید، یا اگر مجموع فرد باشد، حاصل‌ضرب a و b را برگردانید.\nمثال‌ها:\nf_50(2, 3) مقدار 6 را برمی‌گرداند\nf_50(5, 5) مقدار 10 را برمی‌گرداند"}}
