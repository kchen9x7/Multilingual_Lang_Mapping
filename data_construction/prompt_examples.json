{
    "C#": {
        "generation": {
            "prompt": {
                "source": "",
                "translation": ""
            },
            "instruction": {
                "source": "",
                "translation": ""
            },
            "docstring": {
                "source": "",
                "translation": ""
            }
        },
        "explanation": {
            "prompt": {
                "source": "",
                "translation": ""
            },
            "instruction": {
                "source": "",
                "translation": ""
            },
            "docstring": {
                "source": "",
                "translation": ""
            }
        }
    },
    "C": {
        "generation": {
            "prompt": {
                "source": "",
                "translation": ""
            },
            "instruction": {
                "source": "",
                "translation": ""
            },
            "docstring": {
                "source": "",
                "translation": ""
            }
        },
        "explanation": {
            "prompt": {
                "source": "",
                "translation": ""
            },
            "instruction": {
                "source": "",
                "translation": ""
            },
            "docstring": {
                "source": "",
                "translation": ""
            }
        }
    },
    "CPP": {
        "generation": {
            "prompt": {
                "source": "",
                "translation": ""
            },
            "instruction": {
                "source": "",
                "translation": ""
            },
            "docstring": {
                "source": "",
                "translation": ""
            }
        },
        "explanation": {
            "prompt": {
                "source": "",
                "translation": ""
            },
            "instruction": {
                "source": "",
                "translation": ""
            },
            "docstring": {
                "source": "",
                "translation": ""
            }
        }
    },
    "Common Lisp": {
        "generation": {
            "prompt": {
                "source": "",
                "translation": ""
            },
            "instruction": {
                "source": "",
                "translation": ""
            },
            "docstring": {
                "source": "",
                "translation": ""
            }
        },
        "explanation": {
            "prompt": {
                "source": "",
                "translation": ""
            },
            "instruction": {
                "source": "",
                "translation": ""
            },
            "docstring": {
                "source": "",
                "translation": ""
            }
        }
    },
    "Go": {
        "generation": {
            "prompt": {
                "source": "",
                "translation": ""
            },
            "instruction": {
                "source": "",
                "translation": ""
            },
            "docstring": {
                "source": "",
                "translation": ""
            }
        },
        "explanation": {
            "prompt": {
                "source": "",
                "translation": ""
            },
            "instruction": {
                "source": "",
                "translation": ""
            },
            "docstring": {
                "source": "",
                "translation": ""
            }
        }
    },
    "Java": {
        "generation": {
            "prompt": {
                "source": "",
                "translation": ""
            },
            "instruction": {
                "source": "",
                "translation": ""
            },
            "docstring": {
                "source": "",
                "translation": ""
            }
        },
        "explanation": {
            "prompt": {
                "source": "",
                "translation": ""
            },
            "instruction": {
                "source": "",
                "translation": ""
            },
            "docstring": {
                "source": "",
                "translation": ""
            }
        }
    },
    "JavaScript": {
        "generation": {
            "prompt": {
                "source": "",
                "translation": ""
            },
            "instruction": {
                "source": "",
                "translation": ""
            },
            "docstring": {
                "source": "",
                "translation": ""
            }
        },
        "explanation": {
            "prompt": {
                "source": "",
                "translation": ""
            },
            "instruction": {
                "source": "",
                "translation": ""
            },
            "docstring": {
                "source": "",
                "translation": ""
            }
        }
    },
    "Kotlin": {
        "generation": {
            "prompt": {
                "source": "",
                "translation": ""
            },
            "instruction": {
                "source": "",
                "translation": ""
            },
            "docstring": {
                "source": "",
                "translation": ""
            }
        },
        "explanation": {
            "prompt": {
                "source": "",
                "translation": ""
            },
            "instruction": {
                "source": "",
                "translation": ""
            },
            "docstring": {
                "source": "",
                "translation": ""
            }
        }
    },
    "PHP": {
        "generation": {
            "prompt": {
                "source": "",
                "translation": ""
            },
            "instruction": {
                "source": "",
                "translation": ""
            },
            "docstring": {
                "source": "",
                "translation": ""
            }
        },
        "explanation": {
            "prompt": {
                "source": "",
                "translation": ""
            },
            "instruction": {
                "source": "",
                "translation": ""
            },
            "docstring": {
                "source": "",
                "translation": ""
            }
        }
    },
    "Python": {
        "generation": {
            "prompt": {
                "source": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Find the largest prime factor of a given positive integer.\n    \n    The integer is assumed to be the product of exactly two distinct prime numbers. \n    The function iterates through potential factors starting from the smallest prime (2) \n    and checks if they are a factor of 'n'. If a factor is found, the function returns \n    the division of 'n' by this factor, which is the larger prime factor. If no factors \n    are found up to the square root of 'n', then 'n' itself is a prime number and is \n    returned as the largest prime factor.\n    \n    Args:\n    n (int): The positive integer to factorize, which is the product of two distinct primes.\n    \n    Returns:\n    int: The larger of the two prime factors of 'n'.\n    \n    Examples:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    \"\"\"\n   ",
                "translation": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    找到给定正整数的最大素因数。\n    \n    假设该整数是两个不同素数的乘积。\n    该函数从最小的素数(2)开始迭代潜在因数，并检查它们是否是 'n' 的因数。\n    如果找到一个因数，函数返回 'n' 除以该因数的结果，即较大的素因数。\n    如果在 'n' 的平方根范围内没有找到因数，则 'n' 本身是一个素数，并作为最大的素因数返回。\n    \n    参数:\n    n (int): 要分解的正整数，它是两个不同素数的乘积。\n    \n    返回:\n    int: 'n' 的两个素因数中较大的一个。\n    \n    示例:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    \"\"\"\n   "
            },
            "instruction": {
                "source": "Write a python function 'def largest_prime_factor(n: int) -> int:' to solve the following problem:\n\n    Find the largest prime factor of a given positive integer.\n    \n    The integer is assumed to be the product of exactly two distinct prime numbers. \n    The function iterates through potential factors starting from the smallest prime (2) \n    and checks if they are a factor of 'n'. If a factor is found, the function returns \n    the division of 'n' by this factor, which is the larger prime factor. If no factors \n    are found up to the square root of 'n', then 'n' itself is a prime number and is \n    returned as the largest prime factor.\n    \n    Args:\n    n (int): The positive integer to factorize, which is the product of two distinct primes.\n    \n    Returns:\n    int: The larger of the two prime factors of 'n'.\n    \n    Examples:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    ",
                "translation": "एक पायथन फ़ंक्शन 'def largest_prime_factor(n: int) -> int:' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    दिए गए धनात्मक पूर्णांक का सबसे बड़ा अभाज्य गुणनखंड खोजें।\n    \n    यह पूर्णांक ठीक दो भिन्न अभाज्य संख्याओं का गुणनफल माना जाता है।\n    फ़ंक्शन संभावित गुणनखंडों के माध्यम से सबसे छोटे अभाज्य (2) से शुरू करते हुए पुनरावृत्ति करता है \n    और जांचता है कि क्या वे 'n' के गुणनखंड हैं। यदि कोई गुणनखंड मिलता है, तो फ़ंक्शन \n    'n' को इस गुणनखंड से विभाजित करके लौटाता है, जो बड़ा अभाज्य गुणनखंड होता है। यदि 'n' \n    के वर्गमूल तक कोई गुणनखंड नहीं मिलता है, तो 'n' स्वयं एक अभाज्य संख्या है और इसे \n    सबसे बड़े अभाज्य गुणनखंड के रूप में लौटाया जाता है।\n    \n    तर्क:\n    n (int): वह धनात्मक पूर्णांक जिसे गुणनखंडित करना है, जो दो भिन्न अभाज्य संख्याओं का गुणनफल है।\n    \n    लौटाता है:\n    int: 'n' के दो अभाज्य गुणनखंडों में से बड़ा एक।\n    \n    उदाहरण:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    ",
                "translation_2": "એક પાયથન ફંક્શન 'def largest_prime_factor(n: int) -> int:' લખો નીચેની સમસ્યાનું ઉકેલવા માટે:\n\n    આપેલ સકારાત્મક પૂર્ણાંકનો સૌથી મોટો પ્રાઈમ ફેક્ટર શોધો.\n    \n    પૂર્ણાંકને ચોક્કસ બે અલગ અલગ પ્રાઈમ સંખ્યાઓના ગુણાકાર તરીકે માનવામાં આવે છે.\n    ફંક્શન સંભવિત ફેક્ટર્સ દ્વારા સૌથી નાના પ્રાઈમ (2) થી શરૂ કરીને ઇટરેસ્ટ કરે છે \n    અને તપાસે છે કે શું તેઓ 'n' ના ફેક્ટર છે. જો કોઈ ફેક્ટર મળે છે, તો ફંક્શન \n    આ ફેક્ટર દ્વારા 'n' ના વિભાજનને પરત કરે છે, જે સૌથી મોટો પ્રાઈમ ફેક્ટર છે. \n    જો 'n' ના વર્ગમૂળ સુધી કોઈ ફેક્ટર્સ ન મળે, તો 'n' પોતે જ એક પ્રાઈમ નંબર છે \n    અને તેને સૌથી મોટા પ્રાઈમ ફેક્ટર તરીકે પરત કરવામાં આવે છે.\n    \n    Args:\n    n (int): ફેક્ટરાઇઝ કરવા માટેનો સકારાત્મક પૂર્ણાંક, જે બે અલગ અલગ પ્રાઈમ્સનો ગુણાકાર છે.\n    \n    Returns:\n    int: 'n' ના બે પ્રાઈમ ફેક્ટર્સમાંનો મોટો એક.\n    \n    Examples:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    "
            },
            "docstring": {
                "source": "\n    Find the largest prime factor of a given positive integer.\n    \n    The integer is assumed to be the product of exactly two distinct prime numbers. \n    The function iterates through potential factors starting from the smallest prime (2) \n    and checks if they are a factor of 'n'. If a factor is found, the function returns \n    the division of 'n' by this factor, which is the larger prime factor. If no factors \n    are found up to the square root of 'n', then 'n' itself is a prime number and is \n    returned as the largest prime factor.\n    \n    Args:\n    n (int): The positive integer to factorize, which is the product of two distinct primes.\n    \n    Returns:\n    int: The larger of the two prime factors of 'n'.\n    \n    Examples:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    ",
                "translation": "\n    找出给定正整数的最大质因数。\n    \n    假设该整数是两个不同质数的乘积。\n    该函数从最小的质数(2)开始迭代可能的因数，并检查它们是否是 'n' 的因数。\n    如果找到一个因数，函数返回 'n' 除以该因数的结果，即较大的质因数。\n    如果在 'n' 的平方根范围内没有找到因数，那么 'n' 本身就是一个质数，并作为最大质因数返回。\n    \n    参数:\n    n (int): 要分解的正整数，它是两个不同质数的乘积。\n    \n    返回:\n    int: 'n' 的两个质因数中较大的一个。\n    \n    示例:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    "
            }
        },
        "explanation": {
            "prompt": {
                "source": "from typing import List, Tuple\ndef remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Calculate the number of remaining trees along a road after specific areas have been cleared.\n\n    The road is represented as a straight line of length 'l' and is initially filled with trees.\n    Each area scheduled for clearing is specified as a pair of integers (start, end), representing\n    the inclusive range along the road where the trees will be removed.\n\n    Args:\n    - l (int): The length of the road.\n    - areas (List[Tuple[int, int]]): A list of tuples where each tuple represents a cleared area on the road.\n    \n    Returns:\n    - int: The total number of trees remaining along the road after the specified areas have been cleared.\n    \n    Examples:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) will return 5, as trees from positions 2 to 5\n      and 7 to 9 are cleared, leaving trees at positions 0, 1, 6, and 10.\n    \n    - remaining_trees_after_clearing(6, [(1, 3), (4, 4)]) will return 3, as trees from positions 1 to 3\n      and at position 4 are cleared, leaving trees at positions 0, 5, and 6.\n    \n    - remaining_trees_after_clearing(100, [(10, 90)]) will return 20, as trees from positions 10 to 90\n      are cleared, leaving trees at positions 0 to 9 and 91 to 100.\n    \"\"\"",
                "translation": "from typing import List, Tuple\ndef remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    计算在特定区域被清除后沿道路剩余的树木数量。\n\n    道路表示为长度为 'l' 的直线，最初被树木填满。\n    每个计划清除的区域由一对整数 (start, end) 指定，表示将要移除树木的道路范围（包括起始和结束位置）。\n\n    参数:\n    - l (int): 道路的长度。\n    - areas (List[Tuple[int, int]]): 一个元组列表，每个元组表示道路上的一个清除区域。\n    \n    返回:\n    - int: 指定区域清除后沿道路剩余的树木总数。\n    \n    示例:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) 将返回 5，因为位置 2 到 5 和 7 到 9 的树木被清除，\n      剩下位置 0, 1, 6 和 10 的树木。\n    \n    - remaining_trees_after_clearing(6, [(1, 3), (4, 4)]) 将返回 3，因为位置 1 到 3 和位置 4 的树木被清除，\n      剩下位置 0, 5 和 6 的树木。\n    \n    - remaining_trees_after_clearing(100, [(10, 90)]) 将返回 20，因为位置 10 到 90 的树木被清除，\n      剩下位置 0 到 9 和 91 到 100 的树木。\n    \"\"\""
            },
            "instruction": {
                "source": "def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    # Initialize the road with trees (True means a tree is present)\n    road_with_trees = [True] * (l + 1)  # +1 because we include both ends\n\n    # Iterate over each area and remove trees\n    for u, v in areas:\n        for i in range(u, v + 1):  # +1 because we include the tree at point v\n            road_with_trees[i] = False\n\n    # Count the remaining trees\n    remaining_trees = sum(road_with_trees)\n    return remaining_trees\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
                "translation": "def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    # Initialize the road with trees (True means a tree is present)\n    road_with_trees = [True] * (l + 1)  # +1 because we include both ends\n\n    # Iterate over each area and remove trees\n    for u, v in areas:\n        for i in range(u, v + 1):  # +1 because we include the tree at point v\n            road_with_trees[i] = False\n\n    # Count the remaining trees\n    remaining_trees = sum(road_with_trees)\n    return remaining_trees\n\n请用最多500个字符的中文对该Python代码提供简明的自然语言描述（文档字符串）。"
            },
            "docstring": {
                "source": "Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\nseparate those group into separate strings and return the list of those.\nSeparate groups are balanced (each open brace is properly closed) and not nested within each other\nIgnore any spaces in the input string.\n>>> separate_paren_groups('( ) (( )) (( )( ))')\n['()', '(())', '(()())']",
                "translation": "આ ફંક્શનનો ઇનપુટ એ સ્ટ્રિંગ છે જેમાં અનેક જૂથો છે જે કૌંસમાં ગૂંથાયેલા છે. તમારું લક્ષ્ય એ છે કે\nઆ જૂથોને અલગ સ્ટ્રિંગમાં વિભાજિત કરો અને તેમની યાદી પરત કરો.\nઅલગ જૂથો સંતુલિત છે (દરેક ખૂલતી કૌંસ યોગ્ય રીતે બંધ થાય છે) અને એકબીજા સાથે ગૂંથાયેલા નથી\nઇનપુટ સ્ટ્રિંગમાં કોઈપણ ખાલી જગ્યા અવગણો.\n>>> separate_paren_groups('( ) (( )) (( )( ))')\n['()', '(())', '(()())']",
                "source_2": "Calculate the number of remaining trees along a road after specific areas have been cleared.\n\nThe road is represented as a straight line of length 'l' and is initially filled with trees.\nEach area scheduled for clearing is specified as a pair of integers (start, end), representing\nthe inclusive range along the road where the trees will be removed.\n\nArgs:\n- l (int): The length of the road.\n- areas (List[Tuple[int, int]]): A list of tuples where each tuple represents a cleared area on the road.\n\nReturns:\n- int: The total number of trees remaining along the road after the specified areas have been cleared.\n\nExamples:\n- remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) will return 5, as trees from positions 2 to 5\nand 7 to 9 are cleared, leaving trees at positions 0, 1, 6, and 10.\n\n- remaining_trees_after_clearing(6, [(1, 3), (4, 4)]) will return 3, as trees from positions 1 to 3\nand at position 4 are cleared, leaving trees at positions 0, 5, and 6.\n\n- remaining_trees_after_clearing(100, [(10, 90)]) will return 20, as trees from positions 10 to 90\nare cleared, leaving trees at positions 0 to 9 and 91 to 100.",
                "translation_2": "રસ્તા પર ચોક્કસ વિસ્તારો સાફ કર્યા પછી બાકી રહેલા ઝાડોની સંખ્યા ગણવો.\n\nરસ્તો 'l' લંબાઈની સીધી રેખા તરીકે દર્શાવવામાં આવ્યો છે અને શરૂઆતમાં ઝાડોથી ભરેલો છે.\nદરેક વિસ્તાર જે સાફ કરવા માટે નિર્ધારિત છે તે પૂર્ણાંક (શરૂઆત, અંત) તરીકે દર્શાવવામાં આવે છે,\nજે રસ્તા સાથેનો સમાવેશ કરેલ શ્રેણી દર્શાવે છે જ્યાં ઝાડો દૂર કરવામાં આવશે.\n\nઆર્ગ્યુમેન્ટ્સ:\n- l (int): રસ્તાની લંબાઈ.\n- areas (List[Tuple[int, int]]): ટ્યુપલની યાદી જ્યાં દરેક ટ્યુપલ રસ્તા પર સાફ કરેલ વિસ્તાર દર્શાવે છે.\n\nપરત કરે છે:\n- int: ચોક્કસ વિસ્તારો સાફ કર્યા પછી રસ્તા પર બાકી રહેલા કુલ ઝાડોની સંખ્યા.\n\nઉદાહરણો:\n- remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) 5 પરત કરશે, કારણ કે સ્થાન 2 થી 5\nઅને 7 થી 9 સુધીના ઝાડો સાફ કરવામાં આવ્યા છે, સ્થાન 0, 1, 6, અને 10 પર ઝાડો બાકી છે.\n\n- remaining_trees_after_clearing(6, [(1, 3), (4, 4)]) 3 પરત કરશે, કારણ કે સ્થાન 1 થી 3\nઅને સ્થાન 4 પરના ઝાડો સાફ કરવામાં આવ્યા છે, સ્થાન 0, 5, અને 6 પર ઝાડો બાકી છે.\n\n- remaining_trees_after_clearing(100, [(10, 90)]) 20 પરત કરશે, કારણ કે સ્થાન 10 થી 90\nસુધીના ઝાડો સાફ કરવામાં આવ્યા છે, સ્થાન 0 થી 9 અને 91 થી 100 પર ઝાડો બાકી છે.",
                "translation2": "计算清除特定区域后沿道路剩余的树木数量。\n\n道路表示为长度为 'l' 的直线，最初被树木填满。\n每个计划清除的区域由一对整数 (start, end) 指定，表示沿道路将被移除树木的包含范围。\n\n参数：\n- l (int): 道路的长度。\n- areas (List[Tuple[int, int]]): 一个元组列表，其中每个元组表示道路上的一个清除区域。\n\n返回：\n- int: 指定区域清除后沿道路剩余的树木总数。\n\n示例：\n- remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) 将返回 5，因为位置 2 到 5 \n和 7 到 9 的树木被清除，剩下位置 0, 1, 6 和 10 的树木。\n\n- remaining_trees_after_clearing(6, [(1, 3), (4, 4)]) 将返回 3，因为位置 1 到 3 \n和位置 4 的树木被清除，剩下位置 0, 5 和 6 的树木。\n\n- remaining_trees_after_clearing(100, [(10, 90)]) 将返回 20，因为位置 10 到 90 \n的树木被清除，剩下位置 0 到 9 和 91 到 100 的树木。"
            }

        }
    },
    "Ruby": {
        "generation": {
            "prompt": {
                "source": "",
                "translation": ""
            },
            "instruction": {
                "source": "",
                "translation": ""
            },
            "docstring": {
                "source": "",
                "translation": ""
            }
        },
        "explanation": {
            "prompt": {
                "source": "",
                "translation": ""
            },
            "instruction": {
                "source": "",
                "translation": ""
            },
            "docstring": {
                "source": "",
                "translation": ""
            }
        }
    },
    "Rust": {
        "generation": {
            "prompt": {
                "source": "",
                "translation": ""
            },
            "instruction": {
                "source": "",
                "translation": ""
            },
            "docstring": {
                "source": "",
                "translation": ""
            }
        },
        "explanation": {
            "prompt": {
                "source": "",
                "translation": ""
            },
            "instruction": {
                "source": "",
                "translation": ""
            },
            "docstring": {
                "source": "",
                "translation": ""
            }
        }
    },
    "Shell": {
        "generation": {
            "prompt": {
                "source": "",
                "translation": ""
            },
            "instruction": {
                "source": "",
                "translation": ""
            },
            "docstring": {
                "source": "",
                "translation": ""
            }
        },
        "explanation": {
            "prompt": {
                "source": "",
                "translation": ""
            },
            "instruction": {
                "source": "",
                "translation": ""
            },
            "docstring": {
                "source": "",
                "translation": ""
            }
        }
    },
    "Swift": {
        "generation": {
            "prompt": {
                "source": "",
                "translation": ""
            },
            "instruction": {
                "source": "",
                "translation": ""
            },
            "docstring": {
                "source": "",
                "translation": ""
            }
        },
        "explanation": {
            "prompt": {
                "source": "",
                "translation": ""
            },
            "instruction": {
                "source": "",
                "translation": ""
            },
            "docstring": {
                "source": "",
                "translation": ""
            }
        }
    },
    "TypeScript": {
        "generation": {
            "prompt": {
                "source": "",
                "translation": ""
            },
            "instruction": {
                "source": "",
                "translation": ""
            },
            "docstring": {
                "source": "",
                "translation": ""
            }
        },
        "explanation": {
            "prompt": {
                "source": "",
                "translation": ""
            },
            "instruction": {
                "source": "",
                "translation": ""
            },
            "docstring": {
                "source": "",
                "translation": ""
            }
        }
    }
}
